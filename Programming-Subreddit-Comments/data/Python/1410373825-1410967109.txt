Rules of thumb are great, WHEN YOU'RE WORKING ON THUMBS. Otherwise, stop trying to make your development so rule-based! Use classes when you want/need cohesive chunks of data and functionality, or use separate functions when that makes more sense. Be open. Remember to breathe, and (As long as you're still breathing) THINK!
Using it to manage virtual environments seems like it would be useful.
perhaps, but the one thing that i tried so far - creating a new env - didn't even work. so, i think i'll check back on this project in about 6 months to see if it gets out of alpha. 
Thats really interesting, pardon me for asking but do you work for Kivy? Not that it matters of course, ive just noticed that Kivy people tends to be active on Reddit. In any case this is really interesting information, I did not know Kivy packaged a python interpreter, but how dies that pipeline work exactly? Im working on a Linux OS, and I write a kivy game. Then I get an xcode file that I need to move to a mac to upload it to the appstore. Is that it? This file needs little to no testing and is ready to be published to millions of phones all over the world? Also, thanks for posting about the engine, Ill be checking it out as soon as I get home. (On mobile atm)
I hope they don't start to play this song on their webpage..
I prefer: QualityAssuredDeliverable value
This is not accurate. etree is a standard library package (that *does* have a C accelerator, by the way, as the comment below explains). lxml is an external package based on etree.
etree can parse huge XMLs incrementally using iterparse. See http://eli.thegreenplace.net/2012/03/15/processing-xml-in-python-with-elementtree/ for an example how. FWIW, etree's C accelerator (which is turned on by default in 3.3+) is also a fairly slim wrapper around expat, so it's also blazing fast.
Learn on 3.x. Once you know 3.x, dropping back down to 2.x is mostly a matter of keeping up with a few things you can't use anymore - and, as a bonus, you'll naturally be writing code that is 3.x compatible as well. Most of the frustration in porting existing code isn't due to problems with Python 3, but with the fact that 3.x changed several long-standing conventions. The old conventions were removed in 3.0, and therefore old code broke.
Just use `xml.etree.ElementTree`. If you're using a Python older than 3.3, use `xml.etree.cElementTree`, its C accelerator. The `iterparse` function can be used to iteratively stream-process the XML file if it's too large to fit into memory.
&gt;etree can parse huge XMLs incrementally using iterparse. Except it will build the complete tree either way. The last `end` event you'll receive delivers the root element, and that element will, in turn, contain every single other element in the source document. I'm using etree in my asyncio-based XMPP library, and I have to call `root.clear()` (where `root` is the element that corresponds to the first `start` event) after completing every stanza to prevent memory leaks.
Yes, clearing the built element is exactly what the post I linked to suggests. One has to remember to do it, but it works just fine. It's still way more pleasant than using SAX or one of the other stream APIs directly.
It doesn't seem likely that anyone with the skill set to auto generate a CV would apply to anything that requires a .docx CV. That said, I've never used it before but [pandoc](http://johnmacfarlane.net/pandoc/) seems to solve this problem. It can convert latex to .docx. Just "os.system" or "os.popen" pandoc with the relevant files.
That's a virtual method which is banned by coding convention.
Panda3D has an asteroids sample: https://www.panda3d.org/manual/index.php/Sample_Programs:_Asteroids 
CentOS or RH ... there's a new "Software Collections" feature to fill your needs of having the latest ruby or python or what-ever. ... I use fedora for my personal servers, since I generally don't need one running for too long and like to learn the new stuff before it hits at work. ... it's not perfect, but it's what AWS, and any sensible enterprise customers use. Take a look at who contributes to the tools you use. Xen, linux kernel, gets bigger contributions from RH than anyone else ... by a huge margin. So, if you rely upon certain tools ... it's a good idea to support the company that actually makes them, and can realistically support them if you manage to encounter an issue.
I use lxml every day at work. I would start there before trying to roll my own.
http://kivy.org/docs/guide/packaging-ios.html
In this case, *thinkOutside_of* (mixed underscore and camel case, obviously) would be either a callback function or a decorator. @thinkOutside_of box(): pass or def thinkOutside_of(data): pass def box(param, callback): callback(param) box(foo,thinkOutside_of)
This is an access violation. You are either trying to access a memory block that has already been freed, or your pointer value has been overwritten with garbage (likely a stack overflow) and you are deferencing it into a random area of memory.
Actually the most useful programming concept I've ever encountered that I wish normal people grokked is the concept of a memory stack. I try to explain to my wife why she can't just interrupt me while I'm coding and then I hop back in. By far the easiest way to explain to her would be to say my mental stack is destroyed when I'm interrupted and has to be recreated, but she's like "wtf is a stack?"
&gt;I'm thinking of writing a python class structure for stocks, options, and hedges. For what purpose?
You see, we could improve our core competencies by 40% this quarter by making use of a out of the box one-click technology provided by a tertiary cloud service, this could impact our leadership politics leading to a long-term inefficiency to our personnel expenses however we must consider the management technique trend to boost revenues in foreseeable future.
I don't mean to Monday morning quarterback your decision, but why use mongo? In my experience (although relatively small) if you can create model classes that describe your db tables then you should just stick with a relational database.
So coincidental... I was just wondering this morning how I could find a good project to which I could contribute. Looks like a neat project! I'll definitely keep this in mind when I've got some time to contribute.
It's been hard to find someone who can do the Postgres work. Seems like mongo may be a little better since we all mostly know how to work with json. 
Times out for me, wayback to the rescue https://web.archive.org/web/20140910223234/http://unconnected1.blogspot.com.au/2014/09/wtfm-write-freaking-manual.html Not really just about python!
Thanks. As I feared the process is not streamlined and convoluted, but of course this is mainly due to the demands of Apple. I'm going to assume that Android is relatively easier and more straight forward.
&gt; Kivy also uses PyGame, so creating games becomes much easier (though you do have to rewrite existing PyGame code for Kivy). PyGame comes with modules for drawing shapes, rendering, dealing with colors, and playing music (as well as blowing things up, naturally). Just a note for clarity here, since sometimes people are confused about it - Kivy is not based on pygame, it runs fine without it, but it *does* currently use pygame as the default backend on desktop and (at least for some components, I think) on Android. In these cases, pygame-specific code will probably work, but Kivy doesn't guarantee it and you shouldn't really think of Kivy as a pygame wrapper. Kivy's own graphics api (which is more opengl oriented rather than pixel-pushing) is fully capable of all the same things - though the exact mechanisms may be conceptually different. We're actually in the process of switching to an SDL2 backend by default on most/all systems, which should make some things behind the scenes a lot neater, but will mean that pygame based hacks won't work unless pygame is specifically compiled in as the window provider.
Also see [part one](https://www.binpress.com/tutorial/building-a-text-editor-with-pyqt-part-one/143)
Until Python 3 has first class support, Kivy will remain yet another one of those projects that keep conveniently forgetting the 2.x branch is legacy tech. I know Kivy has some Python 3 support, but it doesn't support packaging on 3.x, which is on of the main features, it also doesn't provide packages for the main linux distros, we have to look for those on two PPAs, one for Pygame which isn't supported by the project, and the other, ominously, tagged as 'experimental'.
&gt; This is just untrue if you are a Ubuntu user. It's perfectly true. But to be extra clear, I'm talking about how kivy internally implements providers for components like the window, image loading, clipboard etc. - it is these components that may be swapped out and which do not depend on pygame or guarantee its presence, which is why it's a bad idea to generically assume pygame code will work in a kivy application. This doesn't mean that you can grab a given kivy package and expect it to work without pygame. I'm not aware of any desktop distributions made with this in mind, you would need to compile it appropriately yourself (using x11 window provider or new sdl2 components, probably). Maybe this was unclear - I apologise if that is the case. By 'it runs fine without [pygame]' I mean in the general sense that kivy doesn't internally depend on pygame, not in the sense that the versions we distribute will already work with anything else.
Thanks!
A more constructive resource: http://docs.writethedocs.org/
&gt; Until Python 3 has first class support, Kivy will remain yet another one of those projects that keep conveniently forgetting the 2.x branch is legacy tech. For the benefit of anyone not aware of the details, kivy itself (as in, the graphical framework) does support python3 fully. The problems idlecore highlights are largely that our mobile build tools currently don't support bundling with python3 - that is, compiling the interpreter for android and running it from an apk. Of course it's something we're working on - the slow development is partly because of other technical changes going on (I think we intend to change the android bootstrap to sdl2 before switching to python3), and I think because of potential performance problems with python3 on mobile. I'm not up to date on either of these though, some of the other devs would know more. &gt; we have to look for those on two PPAs, one for Pygame which isn't supported by the project, and the other, ominously, tagged as 'experimental'. I haven't used the ubuntu ppas, but it's good to have feedback if the user experience is poor. I'll see about improving this. From your other comments, I guess you'd also like to be able to directly download packages (.deb etc.) from kivy's download page? As I remember, part of the problem here is that pygame only supports python3 in a post-stable release that isn't in the normal ubuntu repositories, hence the ppa. This is one reason that (as I mentioned in another post) kivy is moving towards its own sdl2 backend, which would remove the pygame dependency as well as making other things nicer. I'm not sure why our package is tagged as experimental, it may just be that we're playing it safe with the labelling. I'll bring that up as well.
The formatting of your code is a little off close to the bottom sections. Other than that this a great tutorial, thanks!
So as a total newbie to both Python and pygame, this means I need to learn kivy right? I am interested in kivy, I am just trying to finish a small project with pygame because which is what I started it with. TLDR: Memorizing new things is hard.
Check out code academy. The best way to learn code is by writing it, so if you watch a youtube video, just write down exactly what you see, then try to decompose what is happening. What will happen if I delete this line? What happens if I add this print statement? etc. 
I really am attracted to Kivy, but have very little experience with UI creation. MVC, MVVM, what? It'd be really cool to have a little tutorial that goes over some sort of philosophy of UI/UX design as implemented with Kivy -- building a small list app with a menu or something. 
zipline is the quantopian open source lib pyalgotrader is a solid lib for backtesting as well... 
Yes he could have prevented a disaster on a test site, but my sadness would come on a live site if my daily budget was hit early in the day and the site shut down for the rest of the day. I would rather have a slow site on a normal server than no site at all. 
Because I already had a background in a few languages, I found this book to be *extremely* helpful: http://learnpythonthehardway.org/book/
Actually, that book is awesome even for the total newb (like myself)!
I always forget about `any` and `all`. So helpful to have around, to the point that I think to myself, "Why doesn't everything have this in their standard library?"
There's also [MIT OpenCourseware](http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2011/) in addition to the other things recommended here.
Over the years I've written dozens of programs, mostly in perl, for all aspects of option trading, from scanning for candidates, to analyzing different hedges, backtesting algorithms, to portfolio management, and daily tracking of positions. Each of these has been one off, without much communication between them. I want to make it a more unified system, using python, and I need to start with a rational data structure that they all can use. I've never been a big fan of OOP, but this certainly seems like a place for a system of hierarchical classes from stocks and options up through complex hedges and allocation portfolios. I was hoping I could use an existing system, but it looks like I'll have to write it myself, and then rewrite my programs to use it. Who knows if that'll leave me any time to actually Trade! :-)
Generally speaking, filter/map/itertools are all awesome. But try not to take the "this is awesome I'm going to use this everywhere now" approach. They're quite powerful but if used where it's really not necessary or where you won't get much of a speed improvement your fellow developers, who won't all speak in itertongue, will not be amused.
I agree with rhgrant10 and think you should pursue a relational DB, especially if you can use models. If you're doing any kinds of relationships at all mongo will not be a good option. I've used mongo quite a bit myself in production and while it's a nice solution to some issues it comes with its own problems as well. Also, if you go down the SQL route you really should look at sqlalchemy and not a specific database. sqlalchemy abstracts away SQL (mostly) using an ORM and removes the need for 'someone who can do the Postgres/MySQL/MSSQL/etc' because sqlalchemy will do that for you so long as you understand a little SQL.
&gt; Pygame.. pygame. pygame. ...pygame... Unfortunately, if you search for python gamedev, that's what you'll find. ..but Pygame isn't the right solution. Pygame is a simple prototyping framework. It's quite good at that. ...but that's it. It's not for production purposes. It crashes all the time. It's not portable. It's difficult to install. It's difficult to get consistent cross platform behaviour. It doesn't have a reliable UI layer. It doesn't bind openglES and there's absolutely no mobile device story for it. Don't use it. In fact, don't encourage other people to use it either. Kivy is a vastly superior library in every way... except that it uses pygame as a backend in some cases (but fortunately they're actively refactoring that to use SDL instead). You're certainly right; python lacks a good distribution or embedding story; but the core developers don't consider this a particularly compelling problem, and it's unlikely to change any time soon. Sadly that means that python continues to remain a niche gamedev platform, and that doesn't look like it'll be changing any time soon. Go, rust, lua, js, c++, c# &lt;-- these are much more compelling targets for gamedev. Python is a great language; but this is something its just not very good at. ...and no, I'm not a kivy developer. :P
Consider MicroPython. It is newer and even with the few bugs it has is evolving much faster. 
I looked at the link. You posted to some guy named Duncan (not James)'s tumblr landing page who describes himself as a photographer and web geek. I'm not going to dig through some random tumblr looking for whatever it is you're trying to cite to support your bald assertion. And, I did give you constructive criticism: you show only input, not output, nor a round tripped result. Why aren't you showing the result of xickle.dumps(toxml)? Or, what dictionary looks like after xickle.load(filename)? Or, what xmlstring and dictionary look like in the last? 
It will depend on a lot of factors. But generally speaking list comprehensions are faster for the reasons he says they are, fewer function calls. On a lower level it helps Python keep its evaluation tighter because there's fewer references, function calls and other steps involved. To really see the difference though you have to be working with non-trivial data usually or look at the using the timeit, cProfile and dis module. How you write the code makes a pretty big difference in the internals (the last two are especially interesting): -&gt; python # Python2.7, sorry at work &gt;&gt;&gt; import dis &gt;&gt;&gt; dis.dis("range(10)") 0 POP_JUMP_IF_FALSE 28257 3 BUILD_LIST 10341 6 &lt;49&gt; 7 &lt;48&gt; 8 STORE_SLICE+1 &gt;&gt;&gt; dis.dis("list(i for i in range(10))") 0 IMPORT_NAME 29545 (29545) 3 LOAD_GLOBAL 26920 (26920) 6 SLICE+2 7 BUILD_TUPLE 29295 10 SLICE+2 11 BUILD_MAP 26912 14 JUMP_FORWARD 29216 (to 29233) 17 STORE_GLOBAL 26478 (26478) 20 LOAD_NAME 12584 (12584) 23 &lt;48&gt; 24 STORE_SLICE+1 25 STORE_SLICE+1 &gt;&gt;&gt; dis.dis(""" ... output = [] ... for i in range(10): ... output.append(i) ... """) 0 UNARY_POSITIVE 1 JUMP_IF_FALSE_OR_POP 29813 4 JUMP_IF_TRUE_OR_POP 29813 7 SLICE+2 8 DELETE_SUBSCR 9 SLICE+2 10 DELETE_NAME 2653 (2653) 13 BUILD_TUPLE 29295 16 SLICE+2 17 BUILD_MAP 26912 20 JUMP_FORWARD 29216 (to 29239) 23 STORE_GLOBAL 26478 (26478) 26 LOAD_NAME 12584 (12584) 29 &lt;48&gt; 30 STORE_SLICE+1 31 INPLACE_DIVIDE 32 UNARY_POSITIVE 33 SLICE+2 34 SLICE+2 35 SLICE+2 36 SLICE+2 37 JUMP_IF_FALSE_OR_POP 29813 40 JUMP_IF_TRUE_OR_POP 29813 43 &lt;46&gt; 44 STORE_GLOBAL 28784 (28784) 47 LOAD_NAME 25710 (25710) 50 STORE_SLICE+0 51 BUILD_MAP 2601 &gt;&gt;&gt; dis.dis("list(i for i in range(10) if i % 2 == 0)") 0 IMPORT_NAME 29545 (29545) 3 LOAD_GLOBAL 26920 (26920) 6 SLICE+2 7 BUILD_TUPLE 29295 10 SLICE+2 11 BUILD_MAP 26912 14 JUMP_FORWARD 29216 (to 29233) 17 STORE_GLOBAL 26478 (26478) 20 LOAD_NAME 12584 (12584) 23 &lt;48&gt; 24 STORE_SLICE+1 25 SLICE+2 26 BUILD_MAP 8294 29 BUILD_MAP 9504 32 SLICE+2 33 DELETE_SLICE+0 34 SLICE+2 35 DELETE_SUBSCR 36 DELETE_SUBSCR 37 SLICE+2 38 &lt;48&gt; 39 STORE_SLICE+1 &gt;&gt;&gt; dis.dis(""" ... output = [] ... for i in range(10): ... if i % 2 == 0: ... output.append(i) ... """) 0 UNARY_POSITIVE 1 JUMP_IF_FALSE_OR_POP 29813 4 JUMP_IF_TRUE_OR_POP 29813 7 SLICE+2 8 DELETE_SUBSCR 9 SLICE+2 10 DELETE_NAME 2653 (2653) 13 BUILD_TUPLE 29295 16 SLICE+2 17 BUILD_MAP 26912 20 JUMP_FORWARD 29216 (to 29239) 23 STORE_GLOBAL 26478 (26478) 26 LOAD_NAME 12584 (12584) 29 &lt;48&gt; 30 STORE_SLICE+1 31 INPLACE_DIVIDE 32 UNARY_POSITIVE 33 SLICE+2 34 SLICE+2 35 SLICE+2 36 SLICE+2 37 BUILD_MAP 8294 40 BUILD_MAP 9504 43 SLICE+2 44 DELETE_SLICE+0 45 SLICE+2 46 DELETE_SUBSCR 47 DELETE_SUBSCR 48 SLICE+2 49 &lt;48&gt; 50 INPLACE_DIVIDE 51 UNARY_POSITIVE 52 SLICE+2 53 SLICE+2 54 SLICE+2 55 SLICE+2 56 SLICE+2 57 SLICE+2 58 SLICE+2 59 SLICE+2 60 JUMP_IF_FALSE_OR_POP 29813 63 JUMP_IF_TRUE_OR_POP 29813 66 &lt;46&gt; 67 STORE_GLOBAL 28784 (28784) 70 LOAD_NAME 25710 (25710) 73 STORE_SLICE+0 74 BUILD_MAP 2601
nope. It brings some syntax changes. ...yeah, that's about it. Oh, it's harder to embed because it uses unicode internally, so it's actually worse for gamedev things. :| Embedding pypy would get the sorts of benefits you're looking for.
The reason I asked isn't to make you feel like an idiot because I genuinely don't think you are one, it's just that it's good to know for sure what your goal is before giving advice. I used to work for a company that made a trading platform for the futures side mostly. I also was a programmer in algorithmic trading in Forex for a time as a contractor. We had some decent returns but now that I know more it's hard to say whether it was luck or not. I've read studies that seem to indicate that a good technical analyst get's results, it just wasn't my cup of tea so I've since switched careers. I'd say OOP is better for designing software, not necessarily for doing analysis. For example, if you wanted to make a trading platform or your own backtesting engine then use OOP. If you want to do analysis of a trading strategy there's probably a better tool you could spend your time learning the ins and outs of mostly because it will save you a lot of work. Your end choice may not even be in Python, as the language doesn't necessarily produce results you can't get from others. Anyway, it sounds like what you want is a data analysis and backtesting platform that takes into account finance models. I think the idea you are looking for when you are trying to make relationships between a hedge, an option, a stock, etc. is a "data model" or schema. I think you could do it with existing tools. Others have some good suggestions in this thread, including quantopian, pyalgotrader, etc. I'd also suggest learning about the core Python scientific stack, which is NumPy, SciPy, etc. The best distribution I've found for data analysis is [here](https://store.continuum.io/cshop/anaconda/). They have some tutorials about [finance](https://store.continuum.io/cshop/python-for-finance/). You can use *pip* to install most libraries you might need that aren't included (in general, there are exceptions).
This discussion has been had several times before, I won't go over it again. &gt; Short version: Python 2.x is legacy, Python 3.x is the present and future of the language https://wiki.python.org/moin/Python2orPython3
Honestly, how often do you need to check the *all* or *at least one* truthiness of a collection of objects? I haven't seen a reason for that sort of thing in a language like Java, C++ or C#, and honestly rarely even in Python. I wouldn't normally have a set of references in a collection where you aren't sure if one or all of them are going to *not* be null, and you don't check for empty strings by truthiness if I remember correctly. Doesn't seem to be much of a use case. I think it might be slightly more useful in Python because zero, None, empty list, empty string, and empty dictionary are all very common and have a truthiness of false. Much more of a use case to check for `all` or `any` in a collection of those types of objects.
Webscale has nothing to do with it. It's primary a combination of syntactic and semantic improvements (Unicode especially) and the removal of old cruft (old vs new style classes, print statement, lists vs iterables). For me, personally, the removal of old cruft is a much bigger deal than any of the new features. No more new vs old style classes, no more range vs xrange (or items vs iteritems vs viewitems), no more weird local imports.
&gt; for loop is more appropriate Of course not! Comprehensions for everything! ['fizzbuzz' if x % 15 == 0 else 'fizz' if x % 3 == 0 else 'buzz' if x % 5 == 0 else x for x in range(1,100)] 
`any` and `all` are awesome, but not higher-order functions. [Those](https://en.wikipedia.org/wiki/Higher-order_function) take another function as their argument and/or return a function. `any` and `all` take an iterable as argument and return a `bool`, and neither iterables nor `bool`s are functions ([as least not in Python](https://en.wikipedia.org/wiki/Church_encoding#Church_Booleans) ;)
For learning or prototyping, pyglet is the best choice. cocos2d (the old python version of the Cocos X framework) is higher-level and works well. Pygame is really too old. For desktop and a big app, Panda3d is a solid choice (made a 100k SLOC python app with it). There is also a Python enabled version of Ogre, it was quite young when I evaluated it but it should be better now. For Mobile, I don't think you could go any other route than kivy. 
&gt; Trying to build from source [using Windows] is a waste of time and a recipe for frustration. Yes, so many wasted hours.... &gt; Forget trying to build from source I've told myself this countless times, but some part of me does not want to give up the fight. I think what I dream of is a community wiki to set up a build farm like Christoph Gohlke is running... EDIT: In the mean time, if you have/want to use Windows, I agree with /u/Rhomboid: Christoph Gohlke's site is indispensable :-)
I've tried writing a web-based RPG with a relational database (using Django models) and it was beyond painful. You underestimate the myriad little state objects needed for a game. It also makes it painful to add new features or content. My far more successful web RPG (sadly also unfinished) used ZODB for persistence, which I liked a lot - it worked really well for games programming. It didn't use any other Zope components, it was Django plus ZODB. It wasn't without problems: you need to avoid breaking unpickleability of objects in the database, and objects need to deal with incomplete instance dictionaries if you change code (or you need to walk the database and migrate objects). But those are a small price to pay for the ease of persisting arbitrary object relationships like those that come up in games programming. There might be some concerns about scalability with ZODB. If you want huge numbers of active players, I'd maybe try a Redis/ZODB combo. 
I'd say writing accessors...
This gets pointed out every time there's a complaint about lack of Python 3 support and of course technically you're correct, Kivy does run on Python 3. But it's a fair bet most users of Kivy are using it to develop stuff to target Android (if not iOS also). I seriously doubt anyone is writing desktop apps with it. And so lack of Python 3 build support really is a Kivy issue.
I completely agree and have made this point myself. Virtually all the tutorials I've seen are geared towards games - and the perception I have is that all that Kivy's used for. I want to write LoB apps but there's nothing out there and aside from Minecraft I've not seen anything else that's been created with it. It's a shame as I'd really like to use Python for app development and I'll keep monitoring Kivy but the lack of UI support (you can't use iOS and Android native UIs), lack of tutorials and general lack of movement (the blog hasn't been updated in six months) has got me looking at other options. I've now looked at Rubymotion, Xamarin and RemObjects - these are all commercial projects but mature with good support and Rubymotion is pretty affordable. I'm sure a lot if not most people would be willing to pay a small fee for better Kivy support.
Conda can be used in conjunction with pip/easy_install. Use conda to install the packages that are in the Continuum repository, or search http://binstar.org to see if anyone else has uploaded their binary builds of a package you might want. If that doesn't exist, then just do pip like you normally would have. As another commenter mentioned, pip is just a way to download some python code and build it from source. If you have all of the build-time dependencies for a package, then you can build it.
If you're differentiating (and your bias is more than clear in your explanation), I would like to add the following. Pyramid is more a skeleton framework, you pick which limbs to attach and then you start working; this means that you'll be working with many different libraries, each with their own documentation and sub-community. This means that you can tune your Pyramid project to how -you- want it to be, but might give you some hard time as you're trying to keep everything properly tied together. Django comes with (replaceable) batteries included. This means you do not have to worry about picking 'the right tool', as most of those tools are already there.. later on during the project you can always decide to replace it with something different. If you're somewhat new to the python web framework thing, I would personally recommend starting out with Django first. It'll be easier to get started with, and with the added batteries you won't have to spend countless hours trying to figure out what you want/need.. that all will come as you grow more accustomed to building apps, at which point you have the knowledge and skills to replace the lacking systems with better ones. If you're a bit more experienced, and like a good challenge, Pyramid is your way to go, as it adds a bit more flexibility, making you more in control of what happens.
What about the sizes of the apk:s for Android? Could somebody enlighten me, because for me this doesn't sound attractive at all. Why would you want to use this instead of writing native apps in Java (androidspecific question)?
Any Kivy pros in here? Just grabbed it to try out and I use Eclipse with PyDev, made a project, linked to where I unzipped Kivy (python 2.7 exe) and yet it rejects finding the 'import kivy' however right-click and send-to on my app runs and launches fine linked to the .bat I'd like to integrate with Eclipse (use for Pygame and GAE dev) however wanting to check for help before I reinvent the wheel to get it rolling here..
I'm not sure about PyDev, and I don't see it come up much - optimistically, it might be because there's an easy way to make it work! We seem to link [this old SO question](http://stackoverflow.com/questions/9768489/kivy-eclipse-and-pydev-also-pypy) from the kivy wiki, but I'm not sure if the instructions there are still current. An alternative that may be convenient if you're comfortable with it is to install kivy into an existing python installation using the popular [unofficial packages page](http://www.lfd.uci.edu/~gohlke/pythonlibs/) (you also need pygame and maybe some other dependencies from there). I've recently seen people reporting success with this, and it would sidestep setting up PyDev with kivy's portable package. Our package actually only contains a python distribution to be used, we distribute it this way because installing the dependencies can be annoying on windows, but it's not the only way to run kivy. If you can't make it work, you might have the most luck posting on the [mailing list](https://groups.google.com/forum/#!forum/kivy-users), where a lot more people are likely to see it.
If not Eclipse with PyDev, what do you use for programming?
&gt; Python is a great language; but this is something its just not very good at. It could be though, if we had a clear pipeline everyone would be making games with Python. 
Personally, emacs on linux. But kivy should work with anything, though any IDE trying to load it for autocomplete etc needs a bit of fiddling (as you have found) to make it properly recognise and locate kivy in the portable package.
It depends, what are your resources? Would the app get built otherwise? I'm looking at doing something for a production system but unless it's something I can pick up myself if I need to then I'm not going to outsource it. I know little Java and no Objective-C and no interest in learning either so if there's a cross platform solution that does a decent enough job then I'm interested.
You can install Kivy into a virtualenv. The trickiest part is PyGame, but you can usually get that into your virtualenv with the small taint one sudo command. I've stopped doing this because it takes so freaking long to create a new virtualenv with cython, pygame, numpy (needed for pygame) and kivy. I now use virtualenvs with those dependencies installed system-wide and --system-site-packages.
Have you looked at either of the books that have been written about Kivy? I recommend [Creating Apps in Kivy](http://shop.oreilly.com/product/0636920032595.do) from O'Reilly.
Thanks! If this is the case I need to work list comprehensions into more of my code. That code is mostly simple scripts so I'm not expecting a lot. 
I always forget about RH, fucking always. I hadn't considered CentOS though. Still great suggestions. Thanks.
&gt; I seriously doubt anyone is writing desktop apps with it. There are, in fact, people doing this - actually, kivy and its predecessor existed for some time before even attempting mobile support. It's also used in other non-mobile but not-quite-desktop scenarios, like raspberry pi driven displays. I'm sure mobile development is one of the most popular reasons for people to try kivy, but it really is not the only thing anyone uses the toolkit for.
I meant using the xml editor part and live preview, making good UI just by using the android studio drag and drop layouts, buttons etc is harder. I admit I did not put a lot of time into kivy overall, when I tested it I made simple weather app using java and then python/kivy, and I found the former one to be much easier to use - especially for UI.
I would start with code academy and continue with learn Python the hard way.
A completely fair point about preferring a slow site. Google App Engine configuration also allows you to set maximum instance counts, and specifically say how long request queue times to an overloaded instance is OK for you until another instance is fired up. So yes, an overloaded slow response site with a small budget is also possible on GAE.
It seems like a valid point to me, given that Java is the default language to build native Android apps with.
Some tips: GitHub it instead of YouTube. Remove most of the comments. Try to not use input After you've put it on github I'll give it a good look.
Wrong, the error was asking for help with a C program in a Python forum.
 sum = lambda xs: reduce(operator.add, xs)
 &gt;&gt;&gt; unichr(0x0e3f1) u'\ue3f1' For Python 3, replace `unichr` with `chr`. This should give you something to work with. Extract the codepoints, turn them into integers and convert them to characters like above.
I'm excited to see a Kivy dev here, so a slightly offtopic question: Is it possible for me to integrate the Numpy/Scipy stack into a Kivy application easily? I have searched around for this and haven't found what I'm looking for.
Python 3: chr(int('0e3f1', 16)) Python 2: unichr(int('0e3f1', 16)) 
Kivy itself will work fine with numpy, as far as kivy is concerned it's just a python module. We don't have any code specifically aimed at working with numpy arrays (where conceivably we could, e.g. automatically dispatching events when they are modified), but that kind of thing isn't important for simply using numpy. The same is true for scipy. I guess the question is asked in the context of mobile dev though - the answer here is that we have a recipe for numpy on android, and I've personally used it (specifically for a simple FFT app) with good results. Unfortunately, scipy is not likely to work any time soon, I think it has much more complex compilation requirements due to all the wrapped scientific libraries. Also, we don't support numpy on iOS (not sure how plausible this is in principle), and I'm not sure if there are any limitations in numpy due to the nature of the arm compilation. There are also related areas where kivy could improve for this kind of work. For instance, it's probably possible to compile matplotlib for android (I'm sure I've seen it done), but it doesn't interface well with kivy since we don't have a matplotlib provider. Kivy has its own graph widget that works fine, but isn't nearly as flexible or widely powerful as matplotlib, for obvious reasons - this kind of thing could also be important depending on what kind of work you want to do. (Come to think of it, there may be a potential performance benefit for a few things - there was some recent work to do with accepting memoryviews in cython for some operations, so probably numpy could give a small advantage here. I'm not sure though, and it's not very important.)
Looks nice! But the scroll wheel zooms the plot and scrolls in the page at the same time, that's kind of weird...
_\*glares\*_
Great! I'll look into this! 
I've wanted this for years ! The SAGE software could already do that a few years back, but it was missing for the ipython notebook. Thanks for this glimpse into the future, now I will try to find good reason to put interactive 3D plots in my presentations.
Right, but how often are you doing this sort of thing in other languages? For the first assert, Python practices are that these should be able to be stripped out in production. They should never affect flow or logic, but simple catch bugs in development. For the check if any has `it.tag == 'a'`, in other languages in most cases you would iterate through a collection, check for that and perform an action given that instance if it matches the condition. It'd be a mess to have side-effects within the `any`. I'm hardly saying they're useless, and I think they have plenty of value in the Python language, but outside of Python (except maybe Ruby or Lua), I haven't seen much of a use case where they could benefit from this in their stdlib.
That's only valid for py2 but you got me on the right track with 'unicode-escape' - in python3 it looks silly but works as: "&lt;plaintext&gt;\:0e3f1 (bitcoin)&lt;/plaintext&gt;".replace("\\:", "\\u").encode().decode('unicode-escape') Thank you :D
Oops! If you go to the URL and press full-screen, it should be easier? Does that work? https://plot.ly/~etpinard/464
[wheel](http://wheel.readthedocs.org/en/latest/) wants to be your friend: $ pip wheel --wheel-dir=wheels numpy $ mkvirtualenv venv (venv)$ pip install --use-wheel --no-index --find-links=wheels numpy Wheels install almost instantly into virtualenvs. I keep those options in my pip.conf.
I love listening to loud music while watching someone code on youtube. Thanks.
But this is a Python forum. You could got to a Ruby site and ask "what's the point of Rubymotion", or ask C# devs "what's the point of Xamrin / RemObjects". It's because it's the language the developers love to use. Still trolling :-)
I ended up doing the same.
Thanks for posting that!
I'd also recommend "Let's Learn Python" video series by Trevor Payne on YouTube. Check him out!
The best place to start is google, of course. This isn't a smartass answer. People have had the same issues you have. Get good at asking the right questions and you'll find your answers. Most often, the best results will be from Stack Overflow.
You can try /r/learnpython but be very clear that it's for homework. In general is frowned upon to get help for homework *as long* as you just expect answers. If you're open from the beginning that it's for homework and you just need some help on where to go or how to improve your code, there should be some people to help you. Just make sure that you don't expect the answer to be given to you.
codecademy.com is fantastic.
I think list comprehensions are cleaner than for loops for fizzbuzz, but I would probably make a `fizzbuzz` function and do it like this: [fizzbuzz(x) for x in range(1,101)]
Really good answer. Thank you for your input.
Thanks! http://docs.writethedocs.org/writing/beginners-guide-to-docs/#why-write-docs
You're not going to like this answer but I've always had a lot of success using pip &amp; python inside a cygwin environment. You install cygwin and make/autoconf/gcc/etc and most packages build just fine on windows as if they were compiled on linux. This solution bypasses a lot of the patching you would normally need to do to make file paths work correctly, etc.
The solution is to not mutate values passed to your function. The sorted() function will accept an iterable and return a *new* sorted iterable containing the members of its argument.
&gt; all parameters (arguments) in the Python language are passed by reference &gt;&gt; **all parameters** (arguments) in the Python language are **passed by reference**
This is what I'm learning currently. I seem to have 9,000+ files in my main git repository so I worry about actually being safely added to an msi for deployment. How do you guys deploy python stuff on windows?
If you want explicit values instead of references you need to do it explicitly. In other words by [cloning](https://docs.python.org/2/library/copy.html) objects. But as other commenters said the more pythonic way is to just not modify the given object but instead use functions and tools that automatically make new objects (like sorted and list/generator comprehensions).
That still scrolls for me. Fantastic work, btw. I'm already 'plotting' how I'll use this. 
I dislike Kivy as it introduces a second language to learn, on top of python. If I have to learn another language anyway I might as well learn something more performant than this.
I'll second this, I didn't watc whole series, but Trevor Payne's videos cleared up some pain points for me when I was starting to learn classes and conditionals. They're great videos.
There is a module called "Cytoolz" that implements most/all itertools functions in cython-
&gt; I know all parameters (arguments) in the Python language are passed by reference. This isn't actually true. Python uses pass-by-assignment (or call-by-object, or whatever you want to name it). This is a pretty good explanation of how this works in practice: http://stackoverflow.com/a/986145
That solves the problem.
 xterm-256color The problem goes away if I make sure to install readline into the venv.
I'm not sure about this, and google gives me nothing now, but I think I did see a graphical drag-and-droppy sort of IDE for kivy at some point (written in kivy, no less, if memory serves). Something to keep an eye out for. 
Well WiX has no problem with an extreme number of files. I have a Python script for another desktop product that creates the necessary WiX XML for deploying about 11,000 files. That's not an issue. The issue is whether you actually add them to the WiX XML. A Python "os.walk" loop over the files to be distributed leaves me far more confident than my creating WiX XML by hand. I work on a pure-Python 3.x desktop app, the [SF Package Manager](http://packages.simplyfortran.com), that is a Tkinter-based desktop application. I first use cx_Freeze to create an executable and deploy the necessary Python runtime components, then go through a process similar to what I linked to in order to generate the WiX XML to create an MSI. Then I just need to (basically) run two WiX commands to create the package (you might have to sign some files depending on your target audience first). No end user is going to first install Python and then install my product. So you really need to package *everything* you'll need into one MSI. It's not particularly hard. I think some of the reddit discussions surrounding packaging for Windows make it seem much harder than it really is. Of course, if you're creating a Python library for developers, please forget everything I've said above. You shouldn't use an MSI.
Just remember that GAE requires coding against a specific set of APIs for things like data storage, caching or background processing. Once you have an app that uses non-GAE technologies for this, it's not really possible to migrate without recoding.
I have no doubt that an experienced cloud admin would be rarely surprised and can prevent most problems. The key is that someone new to cloud admin running their startup's account is rightfully nervous that things can go very wrong very quickly and that the budget may not be there to recover. But for a new startup a LAMP based VM setup might be more in keeping with doing what is expected for the cost that was expected. I have been running many Linux based physical machines for many years and have a fairly good grasp of what they can and can't do. But my toying with GAE and AWS made me very nervous; nothing went wrong but I was expecting my credit card to burst into flames every day. Nothing critical ended up going onto either service even though I really could appreciate the many cool services (especially the datastores) but I like my KISS server setups as they are. 
After failing at an on site Google interview (for a Software Developer position) I committed to learning Python (both as a way to expand my skill set as well as learn new approaches to general computer science problems) by studying code and lurking on the Python tag of Stack Overflow and trying to answer as many questions as I could. I would see a question and purposely not refresh the page so that when smart people would add clear and brilliant answers I would still have time to work it out on my own. Over the following year I got better and better at anticipating where to look and even managed to get a few answers in that were correct and first. Now I've been able to earn a [Python badge](http://stackoverflow.com/search?q=user:16959+[python]) (it's a StackOverflow thing for answering questions about a specific topic while receiving more than 100 up votes), and now I'm working on [Scheme](http://stackoverflow.com/search?q=user:16959+[scheme]) which is a lot harder to do as there aren't as many beginner questions. I think that this approach is a good way to keep the problem set diverse and grounded in real world problems.
The part that looks silly is that ".encode()". In the example, you're starting with a text-string (unicode in Python 2) that has content that's partially escaped. You're forced to encode the text into bytes (using the default encoding, UTF-8) before decoding it again. But when you receive data from a website, you'll start with bytes (encoded text), not text itself. So the .encode() operation above won't be necessary. Instead, do the replacement on the bytes, then decode it to Unicode text: bytestring = b"&lt;plaintext&gt;\\:0e3f1 (bitcoin)&lt;/plaintext&gt;" replaced = bytestring.replace(b"\\:", b"\\u") text = replaced.decode('unicode-escape') print(text) The above is split up for clarity. You can combine these operations into one expression: print(b"&lt;plaintext&gt;\\:0e3f1 (bitcoin)&lt;/plaintext&gt;".replace(b"\\:", b"\\u").decode('unicode-escape')) 
**Tl;Dr;** Wikipedia for algorithms and stackoverflow for solutions, teamwork for knowledge. If you where to implement say a sorting algorithm, read about it on wikipedia and in your books, then if you have specific problems. Could be that you need to do integer division, look up only that. But most of all, work in a study team. You will learn teamwork, team problem solving and best of all see that you are not the only one struggling.
ahhh, so the modulus is the remainder. Thanks! Let me try some things edit: or rather the division without the remainder
&gt; Right, but how often are you doing this sort of thing in other languages? Not often, because other languages suck in this respect. &gt; For the first assert, Python practices are that these should be able to be stripped out in production. Nope, nobody in their sane mind strips asserts in production in Python. Anyway, that's not about assert, you can write an `if` statement if you want to do something more interesting in that situation. &gt; For the check if any has it.tag == 'a', in other languages in most cases you would iterate through a collection, check for that and perform an action given that instance if it matches the condition. I expected that argument, of course if you want to do that you don't first check with `any` then find the item in question. But `any` is merely a dual of `all`. `if all(it.tag != 'a' ...)` is the same as `if any(it.tag == 'a' ...)`. Sometimes it makes more sense to use one or the other. &gt; I'm hardly saying they're useless, and I think they have plenty of value in the Python language, but outside of Python (except maybe Ruby or Lua), I haven't seen much of a use case where they could benefit from this in their stdlib. Well, yeah, they are not so useful in languages where you don't have nice generator expressions and/or lambdas. In C# they are useful, and it does have them, for example. What I wanted to correct in your comment was your idea that any/all are only useful with collections of boolean values (or those that can be coerced to boolean, such as strings/lists/whatever in Python). That's just wrong, by grepping some of my Python code I've found quite a lot of uses of any/all, but almost none of them were just checks for false values in some collection, the use case that you thought is the only possible one and relevant to Python because it has a lot of boolean-coercible types just doesn't exist for me. On the contrary, what I am using them for is stuff like: return any(1 for g in map.ghosts if g.x == x and g.y == y) assert any(' ' in line for line in map), "can't find space" assert all(len(line) == w for line in lines) customers.append((prefs, any(prefs.values()))) if all(q in found for q in queries): if op_set and any(x in op_set for x in stack): etc, etc.
HINT: What that announcement needs is a sentence or two explaining what Pyston actually is right at the beginning. Ain't no body's going to bother to click the "about" page. (for those who were wondering: it's a LLVM-implementation of Python).
Also consider innosetup, after freezing etc of course.
It's here but it's alpha and not been touched in months ... https://github.com/kivy/kivy-designer
You had it right the first time. It's the remainder. 10 % 2 = 0, 10 % 5 = 0, 10 % 3 = 1, etc.
The main problem we have with the designer is that none of the current core devs have much personal interest in it - at least, not enough to prioritise it over all the other things going on. If anyone is interested in helping to continue development, contribution is very welcome, and we can certainly provide help and support. (I don't mean that you should necessarily try this or that the onus should be on the user to develop it, just that lack of developer interest is the main reason it's stalled. We've debated long term solutions, but with no big plan right now.)
&gt; I'm surprised - I would have thought there are better solutions for using Python with the desktop I think the use of kivy is often driven by other priorities than creating a normal desktop app...in this sense it's kind of like pygame - for that kind of application it doesn't need to present a normal desktop interface but to provide simple and powerful apis for graphics (and if making games, other games stuff). I do agree it's a bit of a cop-out though, we know that many kivy users are in it for the mobile development, and we really are working on making python3 available. 
Is anybody using this for anything, yet?
http://ipython.org/ipython-doc/dev/install/install.html#readline says: # for OSX pip install gnureadline
But the little differences can often be massively frustrating.
&gt; Well, yeah, they are not so useful in languages where you don't have nice generator expressions and/or lambdas. That's basically my original point. You convinced me they are more useful in Python than I originally thought, but I still don't think `any`and `all` are necessary in all standard libraries (other languages), as originally commented. I still don't run into many situations personally where I would use these. For the most part, if I'm checking if a condition exists given an element in a collection, I'm going to use or change the object, like I mentioned. Other times, I'm working with an ORM that will handle the selection logic. Regarding what you brought up about assert, there certainly are people who strip asserts out of production code, and they will not run with the -O option. Personally, I use asserts in unit tests and non-production code, and just use condition checks and raise specific exceptions if code breaks a contract in production, though I don't have a problem personally with asserts being used in production with contract-coding, but *you should never be catching AssertionError*. It shouldn't change the logical flow in the program. It is a bug to fix, and if using the -O option changes output or breaks/fixes something, the code is bad. https://wiki.python.org/moin/UsingAssertionsEffectively &gt; Assertions are a systematic way to check that the internal state of a program is as the programmer expected, with the goal of catching bugs. &gt; Assertions should *not* be used to test for failure cases that can occur because of bad user input or operating system/environment failures, such as a file not being found. &gt; One important reason why assertions should only be used for self-tests of the program is that assertions can be disabled at compile time. With the -O option, *the code should still work*, but assertions won't run. It should never change the logical flow of your code. Whether you use a lot of them or not, the important thing is that the code should run the same. It is a bug if an assertion error is raised. Best discussion I've seen on the topic: https://mail.python.org/pipermail/python-list/2013-November/660401.html &gt; Don't use assert for checking anything that you expect might fail in the ordinary use of your program. Assertions are for extraordinary failure conditions. Your users should never see an AssertionError; if they do, it's a bug to be fixed. &gt; Don't use assert for any error which you expect to recover from. In other words, you've got no reason to catch an AssertionError exception in production code. Where I wrote "personally" is my own style, but for asserts, I do follow those two links I posted as best practices and I believe they have it right. Simply for the fact that there's a command line option which will ignore asserts tells quite a bit about what CPython devs think about how asserts should *not* be used.
I doubt it. It's simply too early.
Best of luck. The project is a great idea in my eyes.
The standard lib answer is the [curses](https://docs.python.org/2/library/curses.html) module, but being essentially a wrapper for the C curses library, you might want to try something more pythonic. Both [blessings](https://pypi.python.org/pypi/blessings/) and [urwid](http://urwid.org/) can be used for this purpose. Check the docs to see which syntax you prefer.
Is this pronounced "pie ston" or "pissed on"? 
I'm sorry, I honestly did not intend that to come out offensive :(
I'm not a bad hand with SQL (and I'm decent with psycopg2, more with sqlalchemy). Coincidentally, my emphasis IS with postgresql (my latest projects, [mangarecs](http://mangarecs.herokuapp.com), uses it so I had to learn sqlalchemy for it. if you have anything specific that you need help with, I can take a look (although no promises). I've been planning to take a cursory look at this project eventually anyway so I'll see if I can help out there. I also agree that 90% of the time, relational databases are a good choice especially for smaller projects and even more especially for games.
About us says piston
Might be good if pyston.org had project info now, it's just a listserv. I assumed I should just go there because I was too tired to see the "About" link/navigation, and found nothing.
"piss ton"
gotcha. Thanks guys! 
That's fine, I wasn't criticising. I prefer a terminal and code editor to a GUI myself anyway :-)
From Python manual's entry on input(): Consider using the raw_input() function for general input from users. Also note, that in Python 2, all division using '/' operator behaves this way, rounding down to the nearest lower integer, i.e. 99 / 100 yields 0, which is what you need now, but can be quite bothersome most of the time. If you want normal division with Python 2's '/' in the future, put from __future__ import division at the top line of your script or make sure one of the numbers is float.
I wonder what role Guido is playing in this project, considering he works for Dropbox now.
So does this mean native compiled code?
 while True: key = randrange(26) if key!=0: break https://docs.python.org/2/library/random.html#random.randrange &gt; random.randrange(start, stop[, step]) also &gt;random.randint(a, b) Return a random integer N such that a &lt;= N &lt;= b.
I see a lot. Let me study now and share later. In case you know any, please share.
Yes! &gt; At a high level, Pyston takes parsed Python code and transforms it to the LLVM intermediate representation (IR). The IR is then run through the LLVM optimizer and passed off to the LLVM JIT engine, resulting in executable machine code. LLVM contains a large number of optimization passes and mechanisms for easily adding more, which can lead to very fast code.
PISS-TON.
It's being used as blog post content.
What operating system? curses and all proposed here curses-wrapping modules wont work on Windows. If that's the case (you're using Windows) try [colorconsole](https://pypi.python.org/pypi/colorconsole/0.7.1) for instance.
Just write a "custom screen buffer" that's essentially an array of characters that gets "printed" to the screen.
Make it a daemon and communicate with it through a socket?
You're likely to have more third party modules imported than standard library modules and timing how long it takes all modules to import is not really a reasonable benchmark. Also with applications, especially if it's a web application, you're only going to go through the import process once. Plus, individual modules are only imported once so you're not going to incur extra overhead if a module is imported a lot of times in different places. So basically, importing modules will not take as much time as you think out of the total application runtime. I can guarantee there's applications out there larger than yours that if this was a real problem they would not be written in Python and you'd see a lot more of these kinds of issues on Google and Stack Overflow. Sources: Reddit (written in Python) and myself (I have a 'big app'. It's ~1M SLOC and takes up heaps of memory and CPU time...never had an issue with imports being a major issue)
Does anyone know how this compares with PyPy. What are the trade-offs compared to it
Pythonista ios
I figured as much. Also I'm not 100% sure on the inner workings of wsgi, but I assume there's probably lots of optimizations I don't know about even if I ignore all the optimizations built into Python itself. Still, it was on my mind. Your personal experience is actually super useful in answering this question.
I was talking about implementing a p2p (Distributed hash table) network. Using RPC. Was looking out for what all options are available. Thanks for the reply.
&lt;https://twitter.com/kevmod/status/451800416125067265&gt;
Check out [pyro4](http://pythonhosted.org/Pyro4/). Should be able to handle what you need.
Thanks for suggestion looks like what I needed .
Sorry if i was not clear with what i asked. I am learning RMI, RPC and Sockets so that i can implement different algorithms that i am learning. And i was interested to know what all libraries are available in Python to do RMI and RPC. 
If you really want, you can cheat by staggering the imports. I know that's done in some programs. Still, anything graphical will take 100x longer than any import. The slowest part of a script is the user interface, so optimizing 2 seconds out of a program when the user is still only going to do 1 click every 5 seconds is kinda silly.
You're converting from BGR, which is not RGB. 
Supposedly RGB images are actually BGR in cv2. If you change the convert command to "RGB2YCR_CB" you get a very similar washed out result (though the color is slightly different than BGR). 
&gt; If you are about to ask a question, please consider r/learnpython On the sidebar.
Disclaimer: I know nothing. Nada. So, PyPy is probably one of the best JITs around; it's practically in the league of those overfunded JavaScript JITs, for example. But to do this, PyPy sort-of rethought a lot of the design without considering compatibility on the C level. This means that things like `numpy` just don't work with PyPy until they're rewritten. Pyston is basically a tradeoff. It makes a few design decisions about how to JIT differently from PyPy partially out of a difference in opinion, but most of the fundamental changes seem to be because they want compatibility with CPython's C modules. It seems to be working. In this way, PyPy wants to be a better Python interpreter but Pyston wants to be a better *CPython*. PyPy's probably always going to be faster; it has both a head-start and really clever people running it. But PyPy's not going to be replacing CPython any time soon. With hope, Pyston can. Note that currently a lot of CPython benchmarks heavily dependent on Numpy and co. are actually a lot faster than the PyPy replacement because Numpy is written in C or Fortran and is often just really fast. In theory, Pyston can get you half of the JIT goodness of PyPy without making the parts where you dole out to Numpy any slower.
&gt; use Christoph Gohlke's site. I suspect this is the generous guy you mentioned. Yup, he is :)
&gt; calls to modules that also contain import statements when you call into modules that follow general best practice you should be safe anyway. except for corner cases like plugin handling and malpractice, all import statements in a module are written in the unindented header of the file, so they are executed at import time. whichever modules you need, you import them at startup as well, and by the time actual code runs (ie. everything below your imports), everything is up and loaded. the only thing to worry about is application startup time -- that's where imports culminate, and also loading the python executable adds in here. unless everything is cached by the os, this is typically limited by disk access. if that is an issue, do as pecka_th wrote and have the application run permanently. if your application is a program that gets loaded by the user and is expected to respond quickly to input that happens after the program finished starting, then import times are not your concern anyway.
can you give an example of what does that? the only reason i could think of to do that is to update some kind of splash screen, and i can think of more elegant solutions than having a "splashscreen.update('importing x'); import x" series of imports.
Pass list[:]. 
You could try some dynamic importing of modules into the global namespace. def main(): mod = 'sys' globals()['my_module'] = __import__(mod) I find splash screens annoying, but they exist so programs can import all the required modules and look responsive. I'd rather wait 1 less second.
/r/learnpython and google can be your best sources for such an event. cheers! enjoy python!
Guido doesn't seem enthusiastic about it. Therefore the pronounciation is not "pissed on" but rather "pissed off" ;-)
Teaching a new dog old tricks*
Is piss-ton greater or lesser than a fuck-ton?
So, suppose NumPyPy is fully implemented. What then? I barely know anyone who uses NumPy directly, without SciPy/Pandas/StatsModels. These things won't work with NumPyPy. So while the current work is awesome and surely will bring a lot of insights, it's practical relevance will be very limited.
&gt; cringe whenever I see people using tutorials that teach % Which would you suggest over that?
`str.format`, the topic of the article. 
I know it's like an auto piston, but being a derivative of Python, you have to wonder who did the naming on this. 
I think it's perfectly fine for simple, standalone cases. Where you're using `%s` only, or *maybe* `%d` / `%r`. It still looks clear and is shorter. It is also familiar to people coming from other languages. Got anything longer, more complex, or repeated? Use `.format`.
&gt;There should be one-- and preferable only one --obvious way to do it.
Also note `str.format_map(d)` as a fast replacement for `str.format(**d)`. It rarely matters, but it's good to know. For example, you should use `mystr.format_map(colours)` instead of `.format(**colours)` if there are a lot of colours and you only use a couple of them.
Nice if you've never seen Caesar encryption before I guess, but the code is horribly bloated: &gt;&gt;&gt; import string &gt;&gt;&gt; def caesar(plaintext, shift): ... alphabet = string.lowercase ... shifted_alphabet = alphabet[shift:] + alphabet[:shift] ... table = string.maketrans(alphabet, shifted_alphabet) ... return plaintext.lower().translate(table) ... &gt;&gt;&gt; caesar("julius caesar is a dictator and python is a creator", 1) 'kvmjvt dbftbs jt b ejdubups boe qzuipo jt b dsfbups' &gt;&gt;&gt; caesar(_, -1) 'julius caesar is a dictator and python is a creator' &gt;&gt;&gt; 
I would like to have an interface into pypy that would allow me to code the inner loop of a program in NumPyPy and call that from regular cpython. This is a logical step I think. 
i really love `str.format`, but how should `str.__mod__` go away? the problem is [LogRecord.getMessage](http://hg.python.org/cpython/file/3.4/Lib/logging/__init__.py#l319). while it is easy to just do this: import logging class FormatLogRecord(logging.LogRecord): def getMessage(self): msg = str(self.msg) if self.args: msg = msg.format(*self.args) return msg logging.setLogRecordFactory(FormatLogRecord) doing this will break logging of third party code relying on %s-formatting. --- a solution is (instead of calling `setLogRecordFactory`) to define your modules base logger that overrides makeRecord to not rely on the `_logRecordFactory`: class FormatLogger(logging.Logger): def makeRecord(self, name, level, fn, lno, msg, args, exc_info, func=None, extra=None, sinfo=None): """ A factory method which can be overridden in subclasses to create specialized LogRecords. """ rv = FormatLogRecord(name, level, fn, lno, msg, args, exc_info, func, sinfo) if extra is not None: for key in extra: if (key in ["message", "asctime"]) or (key in rv.__dict__): raise KeyError("Attempt to overwrite {!r} in LogRecord".format(key)) rv.__dict__[key] = extra[key] return rv to use it properly, instead of doing this in your module: LOGGER = logging.getLogger(__name__) you have to do it by hand again: old_class, logging.manager.loggerClass = logging.manager.loggerClass, FormatLogger LOGGER = logging.manager.getLogger(name) logging.manager.loggerClass = old_class --- and all this is still far away from cool stuff like LOGGER.info('{}: {foo}', a, foo=b)
The intent of the project is now clear from the first sentence alone. Much better! :)
NumPyPy still can interface with ATLAS and BLAS though.
For now the approach we have is passing the ndarray to cpython so it can do the C API work (without copy).
Is there any place I can read up on it? I'm not sure how it works, do you pass a pointer to ndarray create in PyPy to a CPython interpreter running in the same process? Couldn't you then just create an array into CPython and pure NumPy?
Do you know of any premade libraries that can help with transforms? (which pysdl2 is missing)
Yes, you could, but then you don't benefit from the jit
Mind, blown. Thanks! That'll be nice since I'm one of few python devs at work, people get a little confused when they see me using `**` in different contexts. Using format_map may make it a little clearer for the newer individuals.
That's not specific to str.format. In [1]: first = 'John' In [2]: second = 'Smith' In [3]: 'Hello %(first)s %(second)s' % locals() Out[3]: 'Hello John Smith' What I really like about str.format that I can't do (I believe) with the mod operator, is nesting! In [4]: 'You are call #{number:05}'.format(number=123) Out[4]: 'You are call #00123' In [5]: 'You are call #{number:0{size}}'.format(size=19, number=123) Out[5]: 'You are call #0000000000000000123'
Just because you may not have lots to add to an open source project doesn't mean you can't learn a ton from one. I would suggest finding a domain you're interested in (say, networking) and pull down a major OS project on it (say, requests in this case) and start reading through the design and seeing how the abstractions provided give benefits to a user. That's at least one good way to learn, all the while you can be working on whatever other project interests you and apply some of what you learn. Just my .02
Very cool article, thanks for sharing. I didn't know quite a bit about some of the more advanced usage of format(). 
Unfortunately, `str.format_map` was added in 3.2 and was never backported to 2.x, unlike `str.format` which appeared simultaneously in 3.0 and 2.6.
That is a matter of personal taste. I find the % syntax much less verbose and more intuitive. 
Am I missing something here? &gt;&gt;&gt; timeit.timeit("'{a} {b}'.format(**x)", setup="x = {'a': 1, 'b': 2}") 0.8770158637480474 &gt;&gt;&gt; timeit.timeit("'{a} {b}'.format_map(x)", setup="x = {'a': 1, 'b': 2}") 0.8754572159310747 That hardly seems like compelling justification for a new method to do something that standard argument splatting already takes care of.
Hi, I'm the developer of the KivEnt game engine for Kivy, wanted to drop in and mention my perspective on things and why I ended up choosing Kivy and my approach to building KivEnt. First a bit of community show and tell: chozabu has created some really cool stuff![youtube](https://www.youtube.com/watch?v=oi564c2GDJ0) to a video of an interactive editor built using KivEnt and [github](https://github.com/chozabu/KivEntEd) for the project. A friend introduced me to Kivy in 2012, and it really seemed to be very nice in some ways. Here is some guys who have a very nice OpenGL and OpenGL ES interface, with a nice UI library, and a build chain that supports Android, iOS, Windows, Linux, and OSX! At the time even less was available than there is now and the team had little time to document the less traveled areas of the API, like handling more advanced rendering. It was not at all clear the best way to go about using the framework for building a game. My team ran into many troubles in the first year as a result, and our game did not run as well as we would like on low and mid-range hardware. However, the thing I have come to like most about Kivy is that everything is written in Cython. This gives us a pretty good compromise between the ease of use of Python code and the performance of C code, and definitely enough room to build even fairly complex 2d games. We just have to make good use of what we have available, and interface in C as much as possible. So I set out to build a Cython native library that worked with Kivy and provided things like 2d physics and collision detection, automatic batching for rendering, and an overall framework for building and managing game data. This would allow a high degree of operation from python while preserving the option to instead interface with everything in Cython if the need for performance arose. Working with Kivy gives us a wonderful interface to OpenGL (really its beautiful!), backend providers for Windows, Sound, Images, Font, and so on for all major OS, a fairly documented build chain for all major platforms, and best of all everything is in Python or Cython so it is readily understandable to someone familiar with Pythons syntax. Since then we have added other libraries like [Cymunk](https://github.com/tito/cymunk) (cython wrapper of the Chipmunk2d C library for Physics and Collision detection). In addition, Cython and Kivy's Pyjnius and Pyobjus projects put pretty much any C, Java, or Objective-C library you could want at your disposal to take advantage of system features or make use of more performant libraries for something you want to do in your game. With cython we can achieve near C speeds while making it almost trivially easy to interface with the code in Python, and also have much finer control over memory for tasks where this may be desirable. Kivy's ecosystem provides very nice pathway for deploying to all major OS, and many tools for interfacing with various system code and libs. More and more libraries are being wrapped using Cython instead of other methods I think lately. The path forward for Python/Cython applications and games I think is very bright on all platforms except browser. 
Thanks for answering. I have to admit I found myself salivating reading your blogpost the other day. Using Cython in this manner is an elegant solution to this issue. Why not browser though? Is it impossible with all the C extensions? Could not a web player of some sort be written?
I'm just now starting to use python for work, and stuff like this is really helpful. Good to know what best practices are. Thanks for writing!
Ah, dang - that is a bummer since I am on 2.7 (limited by our jenkins deployment). I've been wanting to move to 3.x soon here, however.
&gt; 'You are call #{number:0{size}}'.format(size=19, number=123) Here's the % version, which is also nested. Not sure if this strictly meets your 'can do with mod operator' criteria, even though only the mod operator is used: ('You are call #%%0%dd' % 19) % 123 str.format is far clearer in meaning in this case.
The trouble is that `format` cannot be that way. Mainly because it's way more verbose -- in terms of typing, it fails the classic test 'make simple things easy, and complex things possible'. Instead, it makes moderate things easy, and complex things possible. We don't really *need* % in it's current capacity IMO, but format as it currently stands will not be completely used to replace it, for purely pragmatic reasons. 
The future is Dynd and Blaze, not numpy IMHO. Will pypy work with that? https://github.com/ContinuumIO/dynd-python http://technicaldiscovery.blogspot.com/2012/12/passing-torch-of-numpy-and-moving-on-to.html
Why not just use Numba then? I think pypy team should move to work on pyston. No sense in diluting effort, for an implementation that won't add much to scientific python (pypy). 
If you are coming from a C background, %d is probably easier to understand. Or maybe name them like this "%(name)s" % {'name': "Jon"}
format_map() was added so you could use format() on other mapping-like objects than dicts. see http://bugs.python.org/issue6081
What about a very large dictionary? (I have no idea, though.)
Can you explain what you mean by "transforms" ?
Why is everybody so reluctant to type `format`? Python is supposed to be a language that favors English words wherever possible, not punctuation. And what really is the difference in characters? '%s (%d)' % (name, age) '{} ({})'.format(name, age) OH NO, four extra characters to type, how will I ever survive. 
Just a quick note; I don't know how picky your markers are, but in my Computer Science classes, we would have marks lost if we accepted malformed input as correct. There are some strange inputs that you'll handle as if they were correct if you simply "eval" the return value from "input"; for example, when asked for minutes and seconds, try entering "__import__('webbrowser').open('breadfish.co.uk')". You may be surprised by what happens! The simplest way to only accept numbers is to instead call "int" on the returned string, and for the minutes and seconds separated by a comma, call ",".split to get a list of strings, then call "int" on each of those, after checking that it's got a length of two. Of course, if you were told to just call "eval" on the return value of "input", then I don't imagine they'll take points off for doing what's been asked of you! It's just definitely somewhere that they would have tried to catch you for points lost in an assignment in any of my classes. Hope the assignment goes well!
Blaze is written in pure python AFAIK so yes, and dynd is a C++ library with a Python wrapper, so I think we will just have to rewrite the wrapper.
I think this is an example of bike shedding. Is there really that much of a difference between he two methods? Yeah .format has some features that % doesn't have, but 99% of the time I'm doing string interpolation I'm only using one or two variables. I think I've maybe ran into one or two occasions when using .format actually made a difference in terms of readability.
For experienced Python developers, and for simple cases, % is more natural. That's why it took me so long to really think about changing. But for the many, many students I train in Python each year, the % syntax is confusing. Sometimes they need parentheses, and sometimes they don't. The use of % surprises and confuses them. And when it comes to things like %(name)s, they get completely lost. So while str.format might not be perfect for experienced developers in simple cases, the majority of developers are not experienced -- and they're often not doing simple things. Thus, having a method (rather than an operator) which takes parameters is, I believe, easier for people to understand, and thus the way I've started to teach my classes. So far, the results have been encouraging.
Comments like this make it all worthwhile. Thanks so much.
what do you mean that python 3 is more pleasant to play with ?
&gt; practicality beats purity.
Note that pypy is already useful in non-scientific python. Numba is even less compliant than pypy. It does not support generators, for example. 
Seriously ? First of all scientific python isn't the only use case, then there's no proof that the Pyston approach is viable and there's no proof Pyston will end up being more compatible with the C API than PyPy.
Cool library
Sweet. Please don't forget the other aspect of the blaze ecosystem, bcolz: https://github.com/Blosc/bcolz.
&gt;First of all scientific python isn't the only use case Yes it is ... just kidding :) &gt;there's no proof Pyston will end up being more compatible with the C API than PyPy. Hmm, is pyston not already more compatible? And at least they have it planned. On the one hand, I think this array of free market efforts is the key to optimal evolution, on the other hand, I'm concerned of the trade off vs focused efforts like that displayed by the Julia lang team. Perhaps consolidation and collective coordination should follow some additional maturation of all these JIT efforts. That way, we get the benefits of vibrant competition while focusing on the best ideas. 
you can pry % from my cold dead hands
if the processor sat idling, the lower bound of market value was the spot price which is usually half the on-demand instance price. it's more than fair of them.
&gt; Hmm, is pyston not already more compatible? And at least they have it planned. Well, wait until it gets 100% Python compatibility and then we'll see :) &gt; On the one hand, I think this array of free market efforts is the key to optimal evolution, on the other hand, I'm concerned of the trade off vs focused efforts like that displayed by the Julia lang team. Perhaps consolidation and collective coordination should follow some additional maturation of all these JIT efforts. That way, we get the benefits of vibrant competition while focusing on the best ideas. Let's wait until Pyston is closer to 100% Python compatibility (especially with stuff like sys._getframe(), sys.exc_info()...) I think moving away from the C API is inevitable for the long term anyway.
I would say lesser. :)
&gt; The thing is, % is supposedly going away, or is at least deprecated And then links to a message saying: &gt; no deprecation is planned
...tutorials. Since everyone always recommends LPTHW.
How to serve django on nginx? Searching led me to uwsgi which required (i think) cygwin to build :/
Now if only logging used the `.format()` method instead of `%=`
&gt;I think you should do some research before you voice your opinion. Thanks for your input, but a critical pyston feature is not planned for pypy. 
I never bothered learning the % notation since the docs said it was deprecated. Then they changed their minds. Either way, I'm a forever-format()ter.
&gt;Let's wait until Pyston is closer to 100% Python compatibility (especially with stuff like sys._getframe(), sys.exc_info()...) Makes sense. Relevant: http://youtu.be/kbW5sxyu9bU?t=11s
Until you do care, then you have to remember if it's !d or !s it :d or is it...
It's going to be supported for a long time as the article states, so there's no reason one can't enforce their own coding style. Sticking with a style is more important than one guy being the only one to use format in a team who doesn't like the syntax.
The [documentation](https://docs.python.org/3/library/string.html#format-string-syntax) is all I've ever needed. 
Oh the scariness of that. You're not doing the equivalent of `'{0:0{1}}'.format(123, 19)`. You're doing something equivalent to `'{{0:0{0}}}'.format(19).format(123)`, which is nasty because you have to be very careful about the level of escaping to make sure interpolations occur at the right time. The nesting that /u/TheBB demonstrated requires no care, as there's as no escaping takes place. Prefer `'{0:0{1}}'.format(123, 19)` which has no `%` analog.
.format() is great, and I'm glad it exists. But I think every programming language ever should have printf().
So it turns out `.format` on CPython cheats and actually doesn't unpack when you tell it to: &gt;&gt;&gt; def z(**kwargs): pass ... &gt;&gt;&gt; z(**{1: 0}) Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; TypeError: z() keywords must be strings &gt;&gt;&gt; "".format(**{1: 0}) '' This means that there's no real speed advantage to not unpacking even when there should be, even for large `dict`s. :/ It's a different story on non-cheating implementations: &gt;&gt;&gt; pypy3 -m timeit -s "import builtins; bv=vars(builtins)" "''.format(**bv)" :( 10000 loops, best of 3: 53.6 usec per loop &gt;&gt;&gt; pypy3 -m timeit -s "import builtins; bv=vars(builtins)" "''.format_map(bv)" 1000000000 loops, best of 3: 0.000733 usec per loop 
I learned something today - thanks!
I hadn't realized it was deprecated until now. Then again, I came from a C++ background so I never considered that there would be a different option.
I would imagine you'd have to be careful with that. Not that anyone should be doing this, but this would leak information horribly if the string on the left was or contained user-defined data.
&gt; of those overfunded JavaScript JITs But do note that the best JIT right now, with a huge difference, is actually LuaJIT2, which is a one man show, mostly self-funded.
You forgot to switch to your alt, Mr. Puppeteer.
Nearly every GUI toolkit has it's own DSL, though often it is hidden behind a WYSIWYG designer. Web programming HTML and CSS. Android has XML. OSX and iOS have Cocoa.
?
printf is a terrible, no-good system, and format's format strings are far superior. I'm glad Rust decided to use these instead of C-style printf formatting. The order-independence alone means it beats the pants off of printf-style because translations can actually work with it even without using keyword-style (which is terser with format, too)
That's very true. Some more examples: Tk has Tcl, Qt has QML. I think GTK and Swing use their native languages, though, and there are plenty of ways to code a GUI toolkit that don't involve writing a custom layout language.
Sure I will try that one.
Pick an open source project which has lots of tests, and still needs features. If you can add at least one test, and make it pass, you can contribute. 
%.*s and %*.*s are in the standard C printf. I use it surprisingly often on when debugging C code with strings that are in fixed size buffers or lengths that are passed down.
&gt; In this way, PyPy wants to be a better Python interpreter but Pyston wants to be a better CPython. PyPy's probably always going to be faster; it has both a head-start and really clever people running it. Then what's the point? Supposedly, this is a project to allow them to run their python code with high performance. If they can't outperform Pypy, this is pointless, and likely will not live long.
There are some exceptions, of course. However I was pointing out that it's more normal to learn a DSL (or "second language") with a GUI toolkit than to not learn one. Also, everything to the right of the : in a KV language declaration is Python, so it's really very easy to learn.
Isn't that partly because Lua was always designed to be easy to run efficiently? It's always struck me as kind of what java should have been, rather than an attractive high level language (Disclaimer: I have never written any lua, for that reason).
printf is *not* terrible. It's super-powerful and has been around forever. I'm not saying it should be the *default* in anything but C, but it should *exist*.
I bet % is much faster.
`**locals()` can seriously confuse your teammates; I don't think using it is worth the terseness. I would rather see an object passed to `**` so everyone knows what's going on. `person = {'first': 'John', 'second': 'Smith'}` `'Hello {first} {second}'.format(**person)`
$40 for 150+ pages? Maybe I'm spoiled but Two Scoops is $44.95 for over 400. The old edition e-book is $19.95 for over 300. Is there any way to get a sample chapter without giving up your email address? I don't like that they force you to join their mailing list. :(
It actually doesn't. values = 1, 2, 3 formatted = "The values are %i, %i, and %i" % values
My brain still defaults to % formatting, but I'm trying to train myself out of it. One (very much not) entertaining quirk of `'%s' % x` (which I often throw into a logging call to debug something somewhere) is that it works as long as it gets a single value, but if `x` happens to be a tuple, Boom, `TypeError: not all arguments converted during string formatting`. So I end up with the ugly-as-sin `log('blah: %s' % (x,))` littering my code. Practical alternatives are to use `logging`'s `.debug('%s', maybe_tuple)` instead of interpolating yourself or just use [`logbook`](https://pythonhosted.org/Logbook/) which supports new-`.format` style operations directly.
That's a *terrible* example ... like mind-numbingly so.
Curly braces are behind Alt Gr on my keyboard layout. I know it might sound kind of funny, but great functionality might become a pain in the ass to use, just because nobody bothered to check that it's actually convenient to type on something other than the US keyboard layout. I still use it, it just makes me wish I could use a US keyboard. 
I recently discovered the wonders (and/or horrors) of something like: class ReprBase(object): _repr_format = '{_r}' @property def _name(self): return self.__class__.__name__ def __repr__(self): r_orig = super(ReprBase, self).__repr__() return self._repr_format.format(s=self, _r=r_orig) class ReprA(ReprBase): _repr_format = '{s._name}: f1={s.f1} fields={s.__dict__!r}' def __init__(self, *args, **kwargs): self.f1 = 'cats' self.__dict__.update(kwargs) # just for demo class ReprB(ReprBase): _repr_format = 'Just a classname: {s._name}' where you have a base class you can wedge the formatter into, and lots of things which need to print their fields in various formats, but don't actually need any logic. It's a little bit magical, but saves a lot of duplicate `__repr__` methods and pushes it all into the classvar format string. Thoughts, criticisms?
Great write-up; thanks! https://docs.python.org/2/library/stdtypes.html#string-formatting http://legacy.python.org/dev/peps/pep-3101/ (EDIT) https://docs.python.org/3/library/string.html#formatstrings (EDIT) string concatenation -&gt; string interpolation -&gt; XSS, ___ injection, http://cwe.mitre.org/top25/ : * OS command line: http://sarge.readthedocs.org/en/latest/internals.html#how-shell-quoting-works * HTML: https://pypi.python.org/pypi/MarkupSafe (*autoescape*) * Javascript: http://jsonpickle.github.io/ * Linked Data: http://json-ld.org/playground/index.html (EDIT) * SQL: http://docs.sqlalchemy.org/en/latest/core/tutorial.html ... Markdown, ReStructuredText
...Pointer?
Why?
I am not going to write all that code. If you want me to use proper string formatting with logging, make it easy. Let me write something like this: LOGGER = logging.getLogger(__name__, use_new_string_format=True)
\\\_()_/ If I had to guess, I'd say some people are seeing the asterisks and assuming Python is like C... but I really don't know what they're thinking.
meh. it's just matrix management all over again. And dev burnout is an orthogonal issue.
I'd rather inject the `__repr__` methods with a metaclass, and pass the `_repr_format` as a class-level keyword argument. Then your code looks like this: class ReprMeta(type): # not shown, see below for why class ReprBase(metaclass=ReprMeta, repr_format='{_r}'): pass class ReprA(ReprBase, repr_format='{s._name}: f1={s.f1} fields={s.__dict__!r}'): def __init__(self, *args, **kwargs): self.f1 = 'cats' self.__dict__.update(kwargs) # just for demo class ReprB(ReprBase, repr_format='Just a classname: {s._name}'): pass However, I'm not sure if it's possible to inject dunder-methods with a metaclass in this fashion... I think CPython may special-case them. At the very least, you'd need to do it in `ReprMeta.__new__()` and *not* `ReprMeta.__init__()`.
I don't use 3.x but I read today that you can't use absolute imports like that anymore. You must instead do (if I understand where start.py is): from .module.user import * You don't do things like "./user import User?" because the . represents the same thing as the slash (sort of). The first dot is the current directory and the next is the director above it, and so on.
Yes, exactly that's the problem. It needs to be easy and visible if we want people to switch. A big this is the recommended way to do logging, as well as an API like you want would be a possible way.
I didn't realize it didn't... I've never ever used % for formatting (started 2 years ago with python and like format) and I use .format in hundreds of logging calls in my code... I must be missing something...
&gt;...and has been around forever. So have curly braces and static typing, but we're doing fine without those. ;-)
When you develop COBOL hands we shall pry % from you then.
&gt; If you were right about this not living long, nor will CPython How do you figure? &gt; a hot loop rewritten in C with a slower JIT for the rest is often faster than a better JIT and no C. Right, but the goal is to stop rewriting in C. If they were happy with that approach, this whole project would be unnecessary.
Python is a great place to start. Ultimately, "robotics" is such a broad field it's hard to say - if you move into embedded controls or anything time critical, you'll want to pick up C, but a lot of high level behavioural stuff is number crunching and statistics, and python is a great way to learn that. The Aldebaran NAO, for example ( http://www.aldebaran.com/en ) has a python SDK so you can program behavioural modules in python. It's also handy for a whole lot of visualisation tools. So I would say absolutely learn python. Later you may need C or something else, but python won't be wasted.
Very cool, I'm glad to hear that. I've been hearing about python for some time (I work in I.T.). Robotics is something I've always wanted to work in because I think it is the future, better prostatics I would love to help design in terms of making peoples life's more accessible. 
If start.py is what you run to launch your program, then you don't need the initial dot on imports in there - you can do: from module.user import User If start.py is itself a module in a larger package, i.e. if it has another `__init__.py` in the same folder, then you'll need to do relative imports (`from .module...`) in it.
&gt; Since C printf style formatting is over 40 years old and adopted across tons of &gt;languages, I see no reason to learn some nearly functionally identical but &gt;otherwise completely different system which is only available in one. But by that reasoning you'd throw out list comprehensions, decorators, yield, and a lot of other strengths of Python just because they're novel. Think of it this way - Python sets trends and breaks new ground. 
&gt;&gt; If you were right about this not living long, nor will CPython &gt; How do you figure? Because something faster than CPython with 100% compatibility has effectively no downsides, perhaps? &gt;&gt; a hot loop rewritten in C with a slower JIT for the rest is often faster than a better JIT and no C. &gt; Right, but the goal is to stop rewriting in C. If they were happy with that approach, this whole project would be unnecessary. The goal is to stop *rewriting* in C, but abandoning massive codebases just isn't practical. Going back to slower code isn't practical (PyPy *is* far slower than C). Removing support for a ton of third-party libraries isn't practical. They have a lot of C code they depend upon and don't want to remake it all from scratch in a slower language. I don't get what's confusing about that.
Thanks, that led me into an interesting read/fiddle with metaclasses which I've been meaning to get around to for ages. It looks like the `class Foo(metaclass=x, **kwargs):` is python 3 only stuff, so I'd be stuck with: class ReprFoo(...): __metaclass__ = ReprMeta _reprmeta_args = ... and not really gain much from it all, except moving the definition of the actual `__repr__` method. You're right about the `__foo__` magic being special though: [3.4.12. Special method lookup for new-style classes](https://docs.python.org/2/reference/datamodel.html#special-method-lookup-for-new-style-classes). One of these years I'm going to have to maek a serious effort at going py3k...
`any` and `all` are fantastic for stripping down an if that checks a bunch of variables against the same thing. if a == 1 or b == 1 or c == 1: Becomes if any(x == 1 for x in [a,b,c]): That's a really basic example, but illustrates an extremely practical use. Any time I find myself checking a collection of variables against the same thing, I use these.
Don't count out Flask. It's a framework in the barest sense. It's actually closer to scaffolding. It gives you routing, a way to interact with requests and sessions, the ability to build responses...and not much else. It just gets out of you're way and puts you in the driver seat. It's very beginner friendly but the lack of handholding makes it awesome for serious work too. 
Good explanation. Thank you! :)
I hate to be "that guy", but typing these 2 phrases into google will get you what you need... Rmi python Rpc python 
yeah, it seems like it would be nice to have the alt-gr key on the left side of the keyboard as well. i'm primarily in java/javascript, it's really easy for me (US keyboard) to hold the left shift for `(){}` in quick succession (backspace once and enter to begin the method / function body). Having to hold alt-gr with my thumb for all of those where they seem to typically be is a bit more strenuous, and decreases my accuracy significantly; if say the parens required shift but the curlies required alt-gr, that would turn into a mess of mis timings for me. but what i hate is my personal laptop lacks a fancy alt-gr. if i want a special character, for example to compliment you with a touch, i have to open another fucking program (kcharselect), find the character, copy it to the bottom, copy it to the clipboard, and paste it into this reply. on a somewhat related note, i knew a coworker who's `w` key had been broken for a few years; she was real good at ALT+TAB (to switch to notepad), CTRL+A, CTRL+C (to copy the only character in the buffer, a `w`), ALT+TAB, CTRL+V. The third time she did this while typing one line of code my brain finally caught up with what she was doing. it had almost become automatic for her.
str.format blows up occasionally with strange encodings, not sure what the deal is, but I stick with %s when I'm not 100% sure what encoding I'm dealing with. 
print "cats" vs print("PYgamas")
You all are blowing my mind right now. Thanks for the article!
No, you just download a setup.exe file and select the packages you want. There might be some rough edges like copying cygwin.dll files around if you don't want to run all your python in cygwin's command line. I recommend trying it and seeing for yourself.
My intention behind posting this question here was to pick up some advice from people who already have used these libraries. Looks like that was not evident from the way I asked the question. I had done my part of googling part of it. Anyways thanks for replying. 
[Stackoverflow](https://stackoverflow.com/) might be more willing to help you with this question. This is more of a news site then a support site imo. Also see sidebar: &gt; If you are about to ask a question, please consider /r/learnpython Lastly look really carefully at this line: --- if catx == 280: direction == 'down' --- Think about when you would use `=` vs `==` 
Also keep in mind that when you are dealing with float-type numbers, remember that nothing is perfectly exact.
I think it's that the documentation is inconsistent on this point. Indeed, the Python developers no longer plan to deprecate %. Apparently Guido gave a talk at PyCon where he said "fine, lots of people like % formatting, it's here to stay", and they're even making it work for bytes objects in 3.5. But the fact that they un-deprecated it is not consistently clear in the documentation. (Myself, I use .format() sometimes, but % is good for really straightforward cases. And occasionally I need code that *generates a format string*, in which case I generate one format with the other.)
That's a tuple. Parentheses don't make tuples, commas do. You're not running into the order-of-operations problem Ben347 described because you split it into two statements, one of which clearly makes a tuple and one of which clearly accepts a tuple.
I've had a similar problem, for python 2.7 at least. I can't remember if I've had the same issue for python 3.4. (I've used pygame for both distributions, but I have to use the python 2.7 pygame distibution when on the mac unfortunately.) I'm interested know the solution as well
You can't seriously mean that a complex library should never change. This is what version numbers and virtualenvs are for. If your code requires numpy 1.6, then give it a dependency on `numpy==1.6`, which is quite reproducible.
My apologies. That was aimed at the last question and I was at work so I probably jumped the gun a bit. I assumed some things. Sorry for the misunderstanding.
This is awesome thanks!!! 
&gt; So we get: &gt; &gt;  - np.pi  2.3846e-16 I don't get that: import numpy import sympy (sympy.pi - numpy.pi).evalf(30) #&gt;&gt;&gt; 1.22464679914735317722606593227e-16 numpy.sin(numpy.pi) #&gt;&gt;&gt; 1.2246467991473532e-16 As far as I can tell, it's exact for very small errors.
Scaling, rotating etc. Pysdl2 doesn't do this.
Check this out: https://github.com/JetBrains/python-skeletons While it does not contain pygame automcomplete support, it does contain instructions on how to contribute a patch.
Sure it does, it just doesn't do it in the ext library. The function you're looking for is SDL_RenderCopyEx (located in sdl2.render.SDL_RenderCopyEx). The process is a little involved, but there's actually a good explanation of how to do it in c at http://lazyfoo.net/tutorials/SDL/15_rotation_and_flipping/index.php pysdl2 is really just a thin cytpes wrapper around SDL2.
You don't need to delay it in the script itself, just call your script via [crontab](http://www.howtoforge.com/a-short-introduction-to-cron-jobs).
Thanks, that makes more sense to me.
Well the docs include a [tutorial](https://docs.python.org/3/tutorial/). `.format` is covered in it.
You need a [sleep()](https://docs.python.org/2/library/time.html#time.sleep)
 def f(somevar): someother="something" return "a message with {somevar} and {someother}...".format(**locals()) 
Why? Probably because [Python already has a library for it](http://www.wisdomandwonder.com/link/2110/why-mit-switched-from-scheme-to-python). I remembered someone mentioning robotics as the reason MIT switched a noted programming course from the Scheme language to Python and found a link.
I stumbled upon it when I was doing something with ruby and learning drb. I wondering what the python equivalent was. I like both languages a lot but prefer writing code in python more. I kind of wish it was built into the core like java has rmi, ruby has drb, etc. python is LSB after all (like perl) without relying on xmlrpc.
Just make a fake e-mail ya dingus.
Oh, ok! :)
Some have a tendency to over-check the type of arguments when venturing from statically typed languages for the first time.
&gt; import time &gt; time.sleep(30) # seconds
That's a nice way to help a student. A Gentle nudge in the right direction rather than the answer straight off the bat.
The authors of NumPy do an amazing job, and they shouldn't all quit and let it stagnate forever just because someone with a blog doesn't know how to manage his dependencies. Nothing is breaking. If you need NumPy 1.6, and you ask setuptools or pip for NumPy 1.6, you *get* NumPy 1.6. The first step in reproducible code is a reproducible environment. This is true in any programming language, but Python in particular gives you lots of tools to make an environment reproducible. It seems that the author is just *leaving out* the version numbers from his dependencies -- or worse, not listing them anywhere, so his dependencies are "whatever's in his `site-packages` at the time" -- and blaming NumPy developers for the problem. That's like writing a paper without a bibliography and blaming the editors.
That's a standard even stricter than the Python standard library, and any package that meets the compatibility standards of the Python stdlib has "one foot in the grave", as Guido van Rossum himself puts it. And even the stdlib breaks compatibility once in a couple of decades, plus smaller breaks for security reasons. 
Precisely, for reproducibility we create a tag in our Git repo at the time of publication, specifying the exact versions that were used to run our models and generate all the plots. A requirements file isn't rocketscience. His second point is more valid, in that he shouldn't have to continually update his old code base but then why is he following the bleeding edge? 
&gt; someone with a blog doesn't know how to manage his dependencies Are you a scientist? Are you maintaining software in a lab? It seems to me you are viewing the world from the narrow point of view of a software developer, and have difficulty in understanding the core points made in the article.
Try gunicorn 
Seems to me that the scientific community should grow up and learn how to properly use the tools they're given, including dependency management (which really isn't that hard... Especially for people with a PhD and up) 
Probably the server Jenkins is on doesn't have Python 3 installed
Use Semantic versioning (http://semver.org/). Python does, for example. First version number means things break. Use minimally, as described. Minor number means additions; 2.6+, etc. patch number for fixes.
Quantity  quality. Too many books about programming are way too long.
Every version of Python I've ever upgraded to has broken my code. Python 2.4, 2.5, 2.6, 2.7, and 3.2 have all broken my code. It's not that big of a deal and I hold PSF to a higher standard than Numpy. Things change and it's often so subtle that you shouldn't notice. Numpy should have killed that stuff 10 years ago. Everyone knows they shouldn't use it. 
This is why you need tox, setuptools, py.test and Jenkins
exactly
I agree with this approach. Learning is good, but use the best tool for the job. 
Floats are exact, but not every decimal number can be represented exactly in a float. It's a small, but important, difference -- for instance, 1 can be exactly represented in a float, which means that addition is also exact (until you lose precision because your number gets too large, but that's a different issue): 1.0+1.0+1.0+1.0 == 4.0
n_partialable = n_partialable(n_partialable) is a pretty fucking charming line of code if I've ever seen one.
Thanks. I did know about that but was trying to not get involved down to that level. My squirrel attention had since drifted elsewhere since I'm using game development to learn more python, not SDL or OpenGL. Looking at libtcod atm, nice and simple and allows me to focus on more general python stuff without getting embroilied in a specific domain (i.e graphics)
If nothing else, ending the program and starting it again at the appropriate time lets the various garbage collection systems have a chance to work. If it doesn't have to run continuously don't make it run continuously.
Could you possibly come across as anymore condescending?
This is especially important in a scientific context. You should be able to tell the reader exactly what versions of your libraries you used. 
Very much so. There's no other place in science where you'd just suddenly update things in your research without noting it. The rules don't stop just because it's a computer.
And, of course, nothing says that everything on your robot has to be in C. There's absolutely nothing wrong with using C modules for time critical or embedded work with python supplying the bulk of the logic.
I think you are searching for ``time.sleep``! Just make an infinite Loop with ``while True`` and in that make your actions and at the end of the ``while``-body put some time to sleep. I wonder why you do not use the Boolean literals ``True`` and ``False`` within your code. Python has a Boolean type and lietrals - so use them in favour of ``0`` and ``1`` ;-) Why don't you use JSON to dump your data? It is so easy to dump and load things with it and preserve a human readable (and changeable) file. If the latter ist not of interest, you can also use just pickle. You should have a look at the ``set``-data type. It is trivial (and much mor preformant) to look for an exististing object within a set. In your solution you have in worst case to touch **all** elements of your list, which gives you a complexity of O(n). With a set you can reduce it to O(1)! Example: ids = {'1mb4y4', '1mb867', '1mb4hl', '1mbh3t', '1mbni0'} '1mbni0' in ids &gt; True (Keep in mind that if you want to serialize a set in JSON you must convert it into a list and vice versa at deserializing!) You follow the (quite good!) naming schema of verb + other stuff for your functions. But why you chose ``duplicate_check`` and broke that scheme? Just change the order ;-) For your blog I would suggest to use some kind of syntax highlighter; for example [GeSHi](http://qbnz.com/highlighter/).
I've been thinking about just using US+Scandinavian layout, with a Scandinavian keyboard, and just switch layout in software in order to ease the pain, but I'm experiencing the boiling frog problem, so eh.
Since I'm a functional noob, can anyone give an example of how this might be used?
I don't know why you got downvoted, so I gave you an upvote. Particularly `'%s' % value_that_happens_to_be_a_tuple` breaks in confusing ways.
Am I missing something? If your code breaks with a new version of Numpy and it is code you aren't maintaining (so by definition it works and you aren't going to use any new features), why do you need to upgrade to a new version of Numpy? As for an author not providing which version of Numpy to use to verify his results: I used to be an editor for an academic journal. You establish this requirement in your submission guidelines, and if you get a submission that doesn't provide this information, you write back to the author saying "we can't publish it unless you give us the version of Numpy you're using." That's a trivial fix. We used to do this kind of thing for other reasons for every single article we published. It's literally five minutes of time eaten up in the process. I don't even use Numpy, but this guy is whinging. The issues he identifies are non-issues. This guy reminds me of a certain type of academic who thinks any problem with his life means that's a problem for society he needs to write an article analyzing, when the issue is that he is fucking it up himself.
&gt; An update shouldn't break code Well goddammit why can't my Windows 7 run Windows 3.1 programs then?!
As others have noted, format strings DO provide something beneficial that printf-style strings don't : attribute and key access. Considering how commonly attribute and key accesses are done in Python for basically everything, this is a significant benefit. (not to mention named parameters, which are meh if you only have a few but priceless if you have many; and reuse of positional arguments, which I find myself doing quite a lot.) 
Basically you create a new function out of another function by "prefilling" one or more parameters without actually calling the function. @n_partialable def add(x, y): print "x =", x, ", y =", y return x + y add_5 = add(5) print add_5(2) # x = 5 , y = 2 # 7 print add_5(3) # x = 5 , y = 3 # 8 add_3 = add(y=3) print add_3(2) # x = 2 , y = 3 # 5 print add_3(3) # x = 3 , y = 3 # 6 So this spares you from doing something like this: def add_5(x): return add(5, x)
This: http://amoffat.github.io/sh/
I can imagine at least a dozen ways...
Wait, why is 1/10 approximate? It *is* 0.1. I understand why 1/3 is an approximation, but is there something I'm missing? 
no PayPal available, some weird payment provider --- no, thank you
If you want to work accurately with irrational numbers then try sympy: &gt;&gt; import sympy &gt;&gt;&gt; sympy.pi pi &gt;&gt;&gt; sympy.sin(sympy.pi) 0 When using floating point to represent irrational numbers the values *must* be approximations, so sin(3.141592653589793) *must* return a non-zero value.
Can you still do `add(2,3)` and get the result, or do you get a function that returns the result?
Because computers store numbers in binary. Just like you can represent 0.1 exactly in decimal but not 1/3, binary can't handle 0.1 but represents 0.5, 0.25, 0.75 and such exactly. 
It can, if you use the x86 version of Windows 7 :) &lt;/irrelevant&gt;
In short: floating point math and decimal math are *not* the same thing.
Seriously. If python is going to be used as a scientific tool let's approach using it with some scientific rigor. If you don't pin your lib versions who's to say your results won't change over time? You would never introduce a potential variable like this in your experiments. 
0.1 (in base 10) is 0.00011 (in base 2), i.e., 1/16 + 1/32 + 1/256 + 1/512 + ...
I've worked on scientific software before, as a student, and I'm now a professional software developer. This comment pretty much sums up my objections to the article: the assumption that the two environments are so fundamentally different that they can't understand or learn from each other. Scientists aren't the only people who struggle with backwards incompatibility and dependency management, and labs aren't the only organisations that don't put resources towards maintenance of old software. It's interesting that the article briefly mentioned python 3, but then went on to describe how the incremental backwards incompatible changes of NumPy is bad for code that isn't actively maintained. Are we supposed to believe that lumping these breaking NumPy changes into one major upgrade would change that? This is definitely not what we've seen with python 3, where large parts of the community see it as too big of an investment to make the required changes to upgrade at all. For the average scientist writing one off software for a paper, if they're not able to maintain it then *any* backwards change to their libraries makes their code outdated - it doesn't matter how the library authors go about it. But as long as it's not presented an actively maintained library, who cares? The most important thing is that the code is available and states its dependencies in some form that allows the user to reproduce the environment. If somebody else wants to use later versions, fine, but the onus is on them to upgrade the code. As others have pointed out, this is ridiculously easy if you use pip and requirements files. Yes, this is not going to be obvious to people new to python, but it's certainly not difficult to do, and I think that the scientific python community should encourage the practice, whether that's using pip/virtualenv or some other set of tools. On the other hand, the author provides general purpose libraries for others to use, so I would naturally expect the latest versions of those to work with the latest NumPy. I don't see how this is any different from a typical open source library with dependencies though. The library author gives a set of minimum versions and the developer ensures they're met. If I as a developer use a library that doesn't work with the latest versions of its dependencies, then I request a fix, and if it's open source I can always fix it myself if the author is too busy. 
Yes, Even i feel it. But libraries like Pyro4 give good levels of abstractions so you don't have to worry about serializing and stuff. I am going to go ahead and use it today and see how it goes. 
Seems to me that this is just an artifact of pythons shoddy dependency system and not anything related to numpy...
May I abuse of your kindness my friend? For studies purpose, please can you rewrite the code with the alterantions you think are good and give to me? I'm kinda interested in this improvement and I want to compare using someone elses view... :D:D sorry for my english
[What Every Computer Scientist Should Know About Floating-Point Arithmetic](http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html)
It's not for Windows 
I believe this is called *currying* in functional parlance. See the [toolz library](http://toolz.readthedocs.org/en/latest/curry.html#id1) for example.
Why don't you try of your own? I would suggest to put your script on gist.github.com (or directly into a github-repository!) and then post the link of the refactored script here. Then anyone can review your code :-) It is not that difficult; just bring on a python shell and try the things out.
As someone whose entire career has been built on research computing, I read that article and kept getting angrier. Attitudes like this are why HPC schedulers and so much of its code are stuck in the computational Bronze Age. The number of times I've heard people say that they can't fix code because "somewhere, in the bowels of some lab, someone is depending on this behavior" is maddening. 
David Goldberg's [*What Every Computer Scientist Should Know About Floating-Point Arithmetic*](http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html) is, well, something you should probably know about.
You can get a python driver/interface for the lego mindstorms robotics kit. Good introduction to robotics and some good books that explain stuff.
A) Why do you think python's dependency system is shoddy? B) Why do you think python *has* a dependency system? (It doesn't, to be clear) C) How could *any* dependency system be able to know that when you said "install numpy" that you meant "install a numpy version that allows me to modify the return value of diag()"? 
this is a topic I'm very interested in. has anyone read the book yet? I'd like to read a review before I buy. 
It's like getting a new mass spectrometer and using the exact same instructions that you received with a 10 year old spectrometer. It *might* work the same, but odds are very high something won't. 
They don't give out free copies so there is no way to review before you buy. Which sucks for those of us who can't afford to buy books.
pi should be a class that normally acts like a float but it's treated by the trigonometric functions like it should be. 
For God's sake, this isn't hard. Just do `pip freeze &gt;requirements.txt` once your code works.
Just thought I'd share a library I just discovered the other day: [watermark](https://github.com/rasbt/watermark) will spit out all of your environment's information (Python version, library versions, datetime, etc). Can save this information in an IPython notebook cell to easily track runtime information. Haven't started using it yet, but I was intrigued.
As others have stated, in binary you can express anything that is the sum of 1/2^x . You *can* use actual decimal numbers but it's not as efficient. https://docs.python.org/2/library/decimal.html 
You are a paid employee of them, you get it for free. For the rest of us, we want to look at the whole book before we buy. They should release it for free review. Or to allow those who cant afford it to be able to read it for free. It will be on pirate bay soon enough.
I do think he has a great point with regards to breaking backwards compatibility with a major version # bump instead of a minor, but most of his other issues *should* be non issues. You need to specify what version of libraries you're using in almost anything software related. 
And you certainly wouldn't be surprised if your brand new mass spec worked slightly differently to your old one.
Just have a look into the [documentation](https://docs.python.org/3/library/time.html#time.sleep) ;-) And do not just put it into your code, but instead start a **python shell** and experimentate with new functions or objects! A REPL is so helpfull for trying things out! :-)
Thanks for the info. Also, yes, I meant for the boolean to be there. Edit: Oh holy crap! I'm so sorry for not following what you said. You are absolutely right I see why this is off. Thank you so much!
I'm not sure what catImg.y and catImg.x are, in the code it is just supplying a coordinate for pygame I believe. So, when the image gets to that location and satisfies the boolean, then we get a change in behavior of the image. That was how I was understanding it, but clearly something is off. Like I wrote though, when I changed the initial direction to down I had no problems with caty coordinates working in the logic, but again it runs off the screen once it gets to he right which to me suggests something about the logic dealing with the right side isn't correct.
That won't work. Since you really want 1 to be 1, you're immediately forced into pi being representable only with a non-terminating decimal expansion. The follows from the fact that pi cannot be represented as a fraction (the definition of an irrational number) and decimal expansions are merely convenient ways of writing fractions with a standard set of denominators.
Nope. The point is - if you want to write software as part of your work, you need to know how to do it. This includes dependency management. If a scientist cannot grasp it the issue is precisely the fact that he is not enough of software developer.
Condescending? The man speaks obvious things. You want to drive a car? Learn how to drive a car. You want to develop software tools for your science projects? Learn how to do it. Software has been used in science for decades. The fact that so many scientists still cannot implement basics like dependency management is quite amazing.
A) and B) well.. there are dependency systems. Just not a good one that is the standard. C) Why would "install numpy" be a thing at all? That's just asking for trouble! In Clojure the leiningen system requires that you specify a version at all times to use any library. There is never any doubt which version is used. It's WAY superior to anything I've used in python. (Plus it's cryptographically safe and stuff).
Maybe. Probably not though.
I use twisted web for flask app
&gt; or search http://binstar.org to see if anyone else has uploaded their binary builds Been wondering about this, for production use - So just any Joe can put his/her build there ? Is there any sort of review structure ? So far I've been doing just pip install outside of miniconda
&gt; The NumPy attitude can be summarized as introduce incompatible changes slowly but continuously. Every change goes through several stages. First, the intention of an upcoming changes is announced. Next, deprecation warnings are added in the code, which are printed when code relying on the soon-to-disappear feature is executed. Finally, the change becomes effective. AKA good software development practices? 
Yes. As soon as all parameters are bound to a value the function is called and the result is returned. So calling add(2,3) returns 5.
What is the difference between the OP's code and using `functools.partial`?
*"Why would "install numpy" be a thing at all? That's just asking for trouble!"* Ask the writer of the blog post. He's the one blindly updating numpy and complaining when things change. If I say "install numpy" then I mean "install the most recent version of numpy, whatever it is.". This is completely reasonable behavior in my opinion. I shouldn't have to know what the most recent version number is to be able to install a module. If I say "import numpy", then that means "execute the module `numpy.__init__.py` and return the resulting module, binding it to the name numpy." At no point in time does versioning come into play during the import process. (Nor should it) Code doesn't even have to *have* versions, so requiring the user to specify it is impossible. Requiring to specify the version of every module I ever write is an obnoxious overreaction. Even if we *did* require all programmers ever to do something like import numpy, "v1.4" what happens when they don't have version 1.4 of numpy installed, but they do instead have 1.3 or 1.5? Does the code just break? Does it just try to use either 1.3 or 1.5? (If so, the writer of the blog post would still have the same problem, since he couldn't be bothered to specify the version that he wanted) In my opinion, closure's system sounds really obnoxious and cumbersome. The proper solution to versioning issues isn't at runtime, it's at installtime.
Conceptionally they are the same but do it slightly differently. One could argue OPs solution is more in line with the functional concept (currying) since the function is called if all parameters are bound while the functools version always returns a function (and imo has slightly uglier syntax) from functools import partial p = partial(add, y=5, x=3) print p # &lt;functools.partial object at 0x02269330&gt; print p() # x = 3 , y = 5 # 8 EDIT: On the other hand the implementation of functools.partial is much simpler and straightforward and might be more usefull in the context of an imperative language like python. While in a functional language there is no difference between calling a function now or later since it only operates on its parameters with no sideeffects (so add(5,3) is basically the same thing as the value 8), in an imperative language it can make a difference because add might make use of a global variable that might be different when called at different times.
I mean, obviously, yes. Also I'm demonstrating that `__mod__` style string interpolation of multiple values doesn't require parentheses.
As a last resort for those "scientists" who can't figure out requirements.txt and versioning, build into your code a check that throws a warning or worse, an Exception, if the libraries you rely on don't match your expected version. Bad practice, but could save some idiot a week of time: https://github.com/numpy/numpy/blob/master/numpy/version.py.in 
Work with python 3 unless you need to use 2 for some specific reason. I started off with 2.7 because I needed to, and found the transition to 3 very simple.
Username irrelevant. 
or use real address, and then mark as "spam" 
PayPal is a weird payment provider
Yes, most of the code works the same way. The main thing to be aware of is the difference in the way they handle text and bytes - there are plenty of descriptions of that online.
Even then this is bad practice for scientific work. You write down exactly what you had installed on your computer in the same way you wrote down exactly what you put in your beaker.
Backwards compatibility is a feature - if you want it, ask it, pay for it, etc.
Same here, I am also very interested in this topic. I am ordering one from my office.
For most cases, invoking symbolic expressions is just too costly. Even in the trivial case of `sin(2)`, &gt;&gt;&gt; python -m timeit -s "from numpy import pi, sin" "sin(2 * pi)" 1000000 loops, best of 3: 1.37 usec per loop &gt;&gt;&gt; python -m timeit -s "from sympy import pi, sin" "float(sin(2 * pi))" 100000 loops, best of 3: 11.3 usec per loop It gets worse for more complicated expressions. Plus, `0.0000000000000001` is pretty small. The error is often not very important.
Basically, you should learn one or the other and then review [this document](https://docs.python.org/3.0/whatsnew/3.0.html). By far the most complex part is the Unicode section. Note that some of the details have changed since 3.0 (for instance, the `u"..."` syntax was re-introduced in 3.1 (I think) and will be supported for the foreseeable future; in 3.x, it is functionally equivalent to `"..."`).
Yes, at the moment I'm using Windows 7 but I also sometimes use Ubuntu! Thank you
Thank you very much, I will do. Man, I felt in love with python.
People use base 10. The price factorization of 10 is two times five. So we can represent any fraction exactly of the prime factorization of the denominator contains only two and five. So we can perfectly represent a number like 34/40 because 40 breaks down into 2^3 \* 5. But we can't represent 40/34 because it factors to 17 \* 2, and the 17 makes it an infinitely repeating fraction. Computers are base 2. 0.1 is 1/10 which is 1/5 \* 1/2. Computers cannot represent 1/5 in base 2, so both 1/5 and 1/10 are infinitely repeating fractions. Note that if we used base 60 we could represent numbers like 1/3 precisely using a radix point. (radix is the correct way to say decimal when you're not talking about base 10. 'deci' means tenth so decimal implies base 10.)
I just don't get it. If code can't be maintained, then why bump a major dependency for said codebase up. The rest of it is unmaintained anyway. Reality is that keeping software current requires a lot of curating, either in its own codebase or in its dependencies. 
If you know python 3, python 2.7 should be about the same with some slight syntax changes that are easy to pick up
Usually contracts exist in such a way that you say, I'm going to deliver A, B, and C at a rate of $Y/hour, and I estimate it'll take me X hours, so lets do the contract for Y*X to be delivered at date Q. Just make sure to be very detailed about what you're responsible for delivering and when. Keep in contact with your customer about how you're progressing, show them updates as you complete them to get feedback to ensure you're on the same page about what was wanted. Depending on how amiable your relationship is with your client, you can sometimes be like I'll start working on things and keep track of my hours and keep you up to date on both. 
I totally disagree. Unicode vs. bytes is non-trivial. Going from 3 to 2 is much easier than 2 to 3. Everything else, yeah. If you never need to deal with bytes, they're pretty close.
https://wiki.python.org/moin/Python2orPython3 Learn Python 3, please. Run Python 3 whenever possible as well. In the few cases Python 3 isn't possible, hack in whatever Python 2 specific code you need to get the script to work, and get right back to Python 3 again.
The /r/programming sub occasionally has articles written on this. Basically estimate how long it will take you, and pay yourself a hourly wage double of what you'd get paid as an employee. Or just bump your services to $50/hr. Include some optional additional support for 1 month or whatever that they'll inevitably want when you finish. They'll want extra features or whatever. I'd recommend looking for those articles though
Thanks!!! Looking for those articles now...
Learn 3. What you learn will help you port missing libraries from 2 to 3. But 3 has several improvements and advantages over 2, and all new feature development is taking place in 3. This includes async I/O, improvements to multi-threading and multi-processing by improving interactions with the GIL, and so on.
&gt; Omitting a printf() library function because "there should only be one way to do it" is just asinine. &gt; [...] &gt; Sometimes I just want to pull out a faithful tool and get something done without Google. That seems pretty shortsighted to me. If you can't remember that it's called `print` in Python, you're going to have much bigger problems using the language. Also, "why not" is a pretty poor way to grow a language. In Python, it's about "why". Any making a function called `printf` that does nothing but badly duplicate what `print` does is not a good use of resources. I can't really argue that duplicating the whole of C inside Python would make it easier for a C programmer to write Python, because it's true, but that's never been a goal of Python. Until your answer is something other that "I can't remember how to do *Hello World*, give me a break" I can't really take this seriously. If you *really* want this, here you go: def printf(string, *args): print(string % args) Standard library functions need to pass a *way* higher bar than that, though.
The only thing that really bugs me about python printing is fixed width printing. I don't understand why it's so hard to print a float that takes up 8 characters and uses the most precision possible. So "-.123456" or ".1234567" or "-1.23e+4" without 100 if statements. It also bugs me that '%g' % 4.0 &gt; 4 which is not a float. 4. or 4.0 would be fine to me.
First off, named parameters are trivial with traditional formatting because python extends it to provide them: `"%(name)s"`. This is *only* an extension; your actual format specifiers are all the same, meaning you can do `"%(age)0.2f"`. As for attribute/index access in the format string, that's the wrong place to do it. It's a massive anti-feature, and if you're interested I explain why in a long-winded manner below. In Python, attribute, key, and index access are sophisticated and customizable. This allows us not only to write but to alter complex systems in very powerful ways with very little code. A lot of Python programmers consider this a significant positive. In a lot of cases, it is. But implicit in this decision is a *massive* tradeoff that is ignored until it bites (and when it does, it bites *hard*): if you choose to be mindful of this fact, it increases the cognitive load of nearly all Python code (and for dumb interpreters like CPython, it incurs a runtime cost as well). A side effect of this is that it means turning your formatting strings into some kind of mini template language opens you up to compounded cognitive loads and creates new potential pitfalls. The first is that you are starting to do potentially expensive operations during string formatting in an opaque way: welcome_msg.format(user=user) What does this do? Maybe it just looks like this: `"Welcome, {user}"`. With `%` style formatting, you'd know that it would be limited to something like that, eg `"Welcome, %(user)r"`, but with `str.format` it could do just about anything with the user object. This looks like flexibility, but actually it's: * tightly coupling the welcome_msg to your user object * a total landmine if you have expensive attr/idx/key accesses Say it looks instead like `"{user.custom_welcome}, {user.name}"`, and `custom_welcome` is actually a property that will lazily look up something in a cache, or a database, or a web service; now your formatting operation is expensive despite it looking normal. It's much more difficult to hide this with `%` formatting, which is a significant reduction in cognitive load. With `%` formatting, it can't hide: welcome_msg % dict( custom_welcome=user.custom_welcome, name=user.name, ) This makes it clear that we've made a different tradeoff here, we've embedded no logic in our welcome_message, pushing that load off onto the calling code. But we've increased the readability of this code, the format string is now not at all coupled to the user object's layout, and we've made explicit what kind of attribute accesses are going on. Now, of course you can override `__str__` and `__repr__` as well, these are conventionally cheap operations, and if you make them expensive then the battle is already lost.
&gt; My favorite was the use of a module to hold a constant that they'd change and then reload(...) the module. I'm still flummoxed as to how that solution appeared. I wonder if anyone's since introduced them to this concept I found out about, that was invented back in the 50s, called "a file".
One particularly compelling use case for partialable is the creation of decorators that are optionally parameterized by arguments other than the function. Normally you have to write a nested closure in order to accomplish this: def add_x(x=4): def decorator(function): def wrapped(*args, **kwargs): return function(*args, **kwargs) + x return wrapped return decorator @add_x(x=12) def add(x, y): return x * y You can accomplish the same thing with n_partialable with only 1 level of closure in the decorator: @n_partialable def add_x(function, x=4): def wrapped(*args, **kwargs): return function(*args, **kwargs) + x return wrapped @add_x(x=12) def add(x, y): return x * y The n_partialable version also does not require you to invoke the outer function so using the default looks nicer. so for example, @add_x def add(x, y): return x * y works with the n_partialable version, but not with the original version. Somewhat ironically, n_partialable itself is an example of a function that can benefit from this technique. Because of the line `n_partialable = n_partialable(n_partialable)`, you can invoke n_partialable by providing an evaluation checker: @n_partialable(evaluation_checker=lambda *args: len(args) &gt; 1) def func(*args): return sum(arg * 2 for arg in args) or without providing one: @n_partialable def func(x, y): return x &gt; y greater_than_40 = func(40)
I just made the jump from 2 to 3 and I'm loving it. If you can, start with 3. Code written in 2 will be totally readable.
This is very cool. I did my GCSEs 7 years ago, and wish I had been given this option then - It certainly would have steered my career path towards the direction I'm now heading a lot sooner! Just one question, is each choice the whole project that has to be done? Or just one of many? It seems quite a small amount to do for 30% of a GCSE!
functools.partial will always provide a partial evaluation of the function, even if you provide enough arguments to complete the function call. so as pointed out in u/no_displayname's post below def add(x, y): return x + y result = partial(add, x, y) result will still be a partial function call. Partialable will return the actual result if enough parameters are given so in: @n_partialable def add(x, y): return x + y result = add(1, 2) result will simple be the value 3. Another notable difference is the fact that n_partialablized functions are again partialable For example @n_partialable def add(x, y, z): return x + y + z add(1, 2, 3) add(1)(2)(3) add(z=3)(1, 2) all of the above add invocations will work. Whereas with functools.partial partial(add, 1)(2)(3) Would blow up. In order to accomplish this effect you'd need to be explicit about the fact that you wanted a partial the second time: partial(partial(add, 1), 2)(3) 
I know the feeling. I want to learn the newest version too but there is way more documentation and self-teaching guides available for Python 2.7 so it's hard to pick. I would suggest learning 2.7 since there's more out there as far as resources go, and then move on to 3 since it shouldn't be that much different.
Or you could hedge your bets on a future Python 2.8 community fork...
Honestly, I feel like I'm going to have to re-read these a few times to be able to guess what you're looking for, and I'm not even sure I'd be doing what's desired. Choice 3a seems to be the easiest to understand and has a decent enough difficulty to see that they understand basic concepts. It provides example input and output and the non-programming aspect is not obscure or wordy. This is the direction I'd recommend. Still, it doesn't mention whether input comes from stdin or a file, and the format. If I was to create sample questions, I'd provide a question that can be described very easily but possibly complex to program and example input and output. They also seem to be more math questions than coding questions. The first literally takes two inputs and calculates the distance over time-delta. It's basically a math word problem. Will the input come in the form of a CSV? Will it be read from stdin? Should it be delimited by a space or comma? Will it need to quit if "quit"/"q" is typed in? If you don't want to provide simple input and output because that might describe the nature of the math, then it's a math problem, not a coding problem. In Python, it's literally two `raw_input`'s, float/int conversion and a division. I like 1b. It could be performed multiple ways (I'd certainly smile if I ran into a regex), and valid input is very clear. HOWEVER, how am I supposed to save this? Do I save to a local file? Should it be delimited by newlines? If it doesn't matter, then mention that, or show or ask for a specific format. If I saved it as AZZZ123-!-$-;BCDF456-!-$-;ZXF2568 it would be ridiculous, but it in no way specifies that you shouldn't, so it shouldn't be marked down. &gt;1c: "You will need to create a suitable file with test data, including standard registrations and vehicle owner information." Wtf does that even mean? Show a decent spec. I have no idea where I'm pulling addresses from or how this should work. &gt;"The authorities have a file of known vehicle registrations and the vehicles owner" Then you really should provide the file, or specify the EXACT input provided, whether it's typed in or should be read, and the exact path of the file. This should be able to be run from a specific location or with specific input from stdin and either say PASS or FAIL. If it's too ambiguous to write that program to pass/fail, then it's too ambiguous of a question. 2c: This is literally a question about whether they remember how to use `sorted`. Unless it's explicitly described that the test may include question involving sorting, I think it's extremely unfair that those student who happen to remember the easy way to sort in Python will just pass this in 2 minutes, and those who need to manually do some sort of bubble sort will suffer for an hour. If any of your questions say "will read" or "create and store in a file", then provide the exact spec and format of the input and output. The point shouldn't be to guess what format might be provided and in what way. If I were to come up with questions, I'd form them in a way where I can write the pass/fail program and that the question is clear enough that you can drop the script in a directory, run it, and my program will say whether it worked. If it does, check their method and score it, and if it doesn't check how close they are and if they misunderstood basic concepts. I personally would be extremely frustrated if I had to do this test (even now, as a career Python dev) because I don't have a sample input file and example output for most, and some are just wordy enough to confuse me. These sort of test questions put unfair emphasis on comprehension and guesswork of implied meaning rather than testing their ability to code.
When I did contract work (not programming, hardware server builds, maintenance documents, etc) I did the same formula as listed and it worked well. How I came about my rate was 1.5 times my current hourly rate where I was working at the time. I did undersell myself but I believed in the new company and I had a blast. I think you need to find out exactly what they need first (short project vs long project).
Bother with switching to 3 or forking?
Not so much that for me, but it's just much more convenient for me to consider all strings as bytearrays, but of course not in the context of human readable output like logging. I'd like to take a string and split it up into bytes, know that `len(plaintext)` is actually the number of bytes, be able to XOR each byte if needed, `struct.unpack` it, etc. I might be reading it from a file or stdin. It might be from a raw socket read, or the payload of a TCP/IP packet. I like knowing each character is 8 bits. In crypto and sec, the behavior in python 2 is extremely convenient. I'm not sure how similar it is the python 3, but from what I read I feel like I'll hit gotchas, and I already know how to do this stuff in python 2, so for convenience reasons I've stuck with 2.
I think that these examples are all at a suitable skill level for GCSE's, I'm a little concerned at the topics selected however... Speed camera's, testing and encryption all seem to have an 'Orwellian' theme. I don't want to start a political discussion in a programming subreddit but thought it might be worth pointing out. I understand the the examiners will have wanted to provide real world examples but I find these choices a little disheartening, not to mention somewhat dull topics. Couldn't we have something a little more creative or engaging for the kids? Anyone agree or am I just a bit cynical? 
He obviously meant forking.
Also iterators (range, filter, map, etc), print being a function and integer division being //. These are usually the main stuff i have to be careful about. But yeah, once you know the differences, which are just a handful, you should be able to code both. 
Forking.
It's rare to find someone writing for python 3 and making a living off of that. Python 2 is the standard for most industries for a variety of reasons. As far as Open Stack is concerned, I would consider python 2.7 first; this will be usable on most legacy platforms and it is extremely well supported. Python 3 is newer, and can be transitioned to if you find you're really missing something from python 2. 
Granted I started learning to program at age of 9, I think I'd be able to solve these tasks at age of 14. Hell, I think I'll take a shot at the second one in Go. I like cryptography and need something fun to do in the lang, since I'm learning it. Bonus question: what choice of programming languages and other tools will the students be given? Could a kid go with Mongo + Python + AngularJS for the second one? EDIT: Clarity. Don't drink and Reddit.
It's possible. I'm not sure if it can do what you want, but LinkedIn seems to have an API. Worth reading into: https://developer.linkedin.com/documents/profile-api You'll need python-requests (or similar) to send HTTP requests to get the data from linkedin (either via the API or via the normal webpages) If you use the API, you'll need an XML parser like this one: https://docs.python.org/2/library/xml.etree.elementtree.html If you grab normal pages, you'll need a HTML parser, I've always been a fan of BeautifulSoup. Let me know if you have any other questions / need further information :)
&gt;I'm under the impression that most scientist barf/write out the program as few times as possible Well, scientific computing is about getting the result, lots of things are hacked together to make sure it's gonna be correct and then ran *exactly once* or used to parse the output from lab equipment, once it runs, it's forgotten until the equipments end of life, practices from software engineering are either unknown creatures from different world or limited to error checking and speed optimization (that's the thing that pays off, cutting down the expensive supercomputer time from a week to five days). Stagehand company I occasionally work for has a portal coded by one of the stagehands, a nuclear physics grad student in real life, and when I asked what framework he uses, he made a sour face: "Naw man, they're too much hassle, just clean PHP from scratch". EDIT: Oh, those lab machines from hell reminded me of a [nice movie](http://phdmovie.com/), vaguely based on a [comics](http://phdcomics.com/comics.php) that says so much about how and why is that infernal code pasta cooked.
Most microcontrollers only support C and assembly. But there's micropython. https://www.kickstarter.com/projects/214379695/micro-python-python-for-microcontrollers
This should be pretty easy and fun. You'll want to look at the [python requests library](http://docs.python-requests.org/en/latest/) and [Beautifulsoup](http://www.crummy.com/software/BeautifulSoup/). I'm not sure what the Linkedin TOS say, but this might not be ok with them. Even though Threading would be cooler and faster, you might want to stay single threaded and use the sleep command and simulate human speed clicks. 
&gt;I personally would be extremely frustrated if I had to do this test (even now, as a career Python dev) because I don't have a sample input file and example output for most, and some are just wordy enough to confuse me. These sort of test questions put unfair emphasis on comprehension and guesswork of implied meaning rather than testing their ability to code. I don't disagree, but this type of question is very typical in the UK education system already and any student will have been taught specifically in this style. Part of the reason you're given three choices is so that if one of them is incomprehensible you've still got a shot at getting the marks. I don't really think it's the best way to test programming knowledge but that's a whole new issue.
For my A level project, I wrote a program in BBC Basic (32K Model B) that would take in a pseudo code text file and would output a basic program, it even had a form designer for designing user input. It was hard to fit it all into memory, so I had to remove virtually all of the spaces. it used the concept of junk words (like COBOL), so you could write calculate the value of n by adding 3 to user input, or wait 10 seconds or for a key to be pressed. It was also semi type independent, so you could say let name = "neil", print name, so it would use a string variable, but it would use val or str to convert from strings to numbers or vice versa if required.
Yeah I agree with that, and am surprised that wasn't the case with an extremely popular package.
Choice one is very poorly specified - hard to believe anyone has actually read that task since it should have raised red flags. Two and three are comprehensible but simplistic and could use some clarification (e.g. for two I'd be tempted to use a database - permissible?) &gt; Are they suitable tasks for 14 to 16 years olds? I was a geek in school and would not have had problems with 2 or 3; as said, the first one is just unbelievable. Better than the garbage they had previously though. That said ... &gt; It is more secure to use two keywords to encrypt data. From the question it looks like they are attempting to teach some cryptography content ... not my field but I'm pretty certain this is false. &gt; Anyone fancy having a go at any of them? The third one (using ruby) took me about 20 minutes (I was playing with syntax trying to be clever). Obviously not posting answers but its about 10 lines of code for the entire thing (sans user input, error checking, etc). The bright kids are going to knock this out in 10 minutes (and from my memory of every computing class at ANY level, the ones who don't grock code are going to struggle whatever) So a third of a GCSE in 10-15 minutes, is this what they were aiming for? EDIT: I take back what I said about choice 3 - there are a couple of possible ways to implement 3b/3c, of which any could be considered incorrect depending on the marking criteria even though they might be TECHNICALLY correct. It needs further clarification i.e. does it need to also use a shift cipher. 
I would avoid an API and instead use something like Casper or phantomjs which are headless WebKit browsers running in nodejs. You could use math.random to randomize click times and views. Additionally you can spoof the user agent. Casper actually has a chrome plugin that will record the code of your user actions which can then be adjusted for use.
One other neat thing is that you can hook into format to customise the handling of more detailed format specifiers, or provide custom codes for your objects by providing a `__format__` method. This is used by things like datetime to allow for embedding strftime format codes in your string without a seperate formatting call needed. Eg. "The time is {:%H:%M}".format(datetime.now()) is equivalent to: "The time is %s" % (datetime.now().strftime("%H:%M"),) 
 from __future__ import print_function from __future__ import division I automatically include those lines in every new Python 2 file I write...
Damn, you're right, of course. Makes sense, before they're done with school, Python 3 will probably overcome remaining library deficiencies.
check the length of user_tweets. It may be 0 which is why you wouldn't be able to get the length, subtract one, and get that item. That'd be my first check.
Made the leap too. Other than some character/byte issues (still haven't really wrapped my brain around this yet...), it's been wonderful. 
Being from a country that isn't served by ISO-8859-1 (aka CP1252 - I know they're not 100% the same), dealing with almost good strings and really good strings was very frustrating (in Python 2). Having strings always be strings and what you read from memory (or disk) always be bytes and *not* assume everything is US-based, was very relieving (in Python 3). And I won't even go to the difficult 256-characters-are-way-too-few cases (such as Japanese and Chinese)!
Yeeees, it's 0. I would like to ask for sorry, my english is not so good, so I'm not understanding what do you mean with *subtract one, and get that item*. The length is 0 in two parts of the code: def grab_tweets(api, max_id=None): source_tweets=[] user_tweets = api.GetUserTimeline(screen_name=user, count=200, max_id=max_id, include_rts=True, trim_user=True, exclude_replies=True) max_id = user_tweets[len(user_tweets)-1].id-1 for tweet in user_tweets: tweet.text = filter_tweet(tweet) **if len(tweet.text) != 0:** source_tweets.append(tweet.text) return source_tweets, max_id and: print "{0} tweets found in {1}".format(**len**(source_tweets), handle) if **len(source_tweets) == 0:** Can you help me? Again, sorry for my bad english. 
Thanks for your feedback and warm words.
http://youtu.be/9bum8TDd8Ag
It feels like you're trolling. I hope not. Do you even know printf()? Or maybe you didn't read my comment? I'm not commenting on Python's print vs printf. I'm saying it'll be a shame if they deprecate %-style format strings such that the new format() strings are the only way to do it. Quick, I've got a float that represents money. How do I format that zero-prefixed, two digits after the decimal, fixed width of 6 characters? printf("%06.2f", money); // C std::printf("%06.2f", money); // C++ System.out.printf("%06.2f", money); // Java print "%06.2f" % money # Python 2 Okay, now how do I do that with Python's new format strings? print("hell_if_i_know".format(money)) That's what I'm saying. 
~~I believe~~ u'' was reintroduced in 3.3.
Being able to to do bitwise operations easily (i.e with the normal mathematical operators) on bytestrings would be nice, but otherwise just using `b''` to create bytestrings in 3 is fairly straight forward.
There was an IRC channel created, and that was about it. Lots of users would like it, but none of those people are people who would know how to actually work on and continue to improve the 2.X codebase as a featureful thing. The python 3 codebase is now a LOT cleaner, and that's in fact a major reason that 3 is the one that gets development.
Yeah if your side projects are going to vary that much you probably want to go with an hourly rate for each. You can also change your rate later if you go job by job.
PayPal isn't weird, it's evil. There's a difference. 
That's a hilarious and awesome idea. You should check out [Selenium](https://pypi.python.org/pypi/selenium) - it would be pretty easy to write a script to open firefox, navigate to linkedin, log in under your profile, and either visit a list of profiles or do searches to find people to look at. Good luck!
If len(source_tweets) is 0, then the line max_id = user_tweets[len(user_tweets)-1].id-1 will not work, as len(user_tweets)-1 = 0-1 = -1 So you're trying to access user_tweets[-1] Which is causing the error.
Oh I'm pretty new to python, so I will try this. I'm used to MATLAB which does everything nice for you. Thanks a lot! 
Thanks!
Will look at it, thanks :) 
Python 3 us the future, how is using 2 which will have no more major updates safe for the future? The python 3 compat list is almost all green bow, and dealing with non Unicode strings in python 2 is aggravating. 
Well, so many comments seem to complain about the book size, price, payment method etc. Frankly, I started to deal with quite a high traffic sites few months back and I face performance issues time to time. I can't find any comprehensive materials on internet. Well, there is a blog about caching, and then a somewhere a post about making Database queries faster etc, but not a good guide which can provide concrete details. This is exact book I was looking for, and I am just glad that it's out in time :) 
If you want to use PyPy, go with 2 for now. I know that there is PyPy3, but it is not as mature as the mainline PyPy and not in the current Ubuntu repositories. You can still get PyPy3 in portable form at https://github.com/squeaky-pl/portable-pypy if you want to play around.
What's the problem with writing your project to work with both?
Pyston has the benefit of Guido giving the project his blessing. How involved is he really in the project? Either way, PyPy is here right now and is an excellent runtime. Pyston could take years to be stable or up to the speed of PyPy.
Most of what you say is true, but as for `"%(age)0.2f"`: I know this, I've used it recently, and in this area format strings (`'{age:0.2f}'`) just plain do it better.
 if user_tweets max_id = user_tweets[-1].id - 1
Do not blame the scientific community for not upgrading. The Python scientific community actually uses Python 3 more than other groups because of their lack of reliance on web interfaces. If you insist on using code that existed during Python 2.1 days, you're going to pay the price. I've upgraded Python 2.3 -&gt; 2.7 code that required me to do a mass replace on libraries and update a lot of code. It was easier than most Python 2.7 -&gt; 3.2 work I've done. When none of your packages exist anymore or you can't figure out how to build PyQt3, you start googling. 6 months after Python 2.6 bug support was dropped, we were informed at a staff meeting that our software practices would be looked at and improved, but that no plans were finalized. I bluntly asked "Why are we still using Python 2.6 instead of Python 2.7? It's not maintained by PSF. It's not maintained well by 3rd party developers. It makes it harder to write Python 3 compatible code. We should upgrade.". We did a few weeks later. It wasn't totally painless, but it maybe took a day of work for each project, especially when we figured out what were the gotchas.
The problem is that scientists everywhere are writing code, but few of them are learning any software engineering. The result is massive amounts of shitty scientific code.
To be honest, these seem too easy. I fall right into the age category. granted, I've been programming for about 5 years but they all seem really simple.
If speed is really that important, use `str.join`. For example, outside of the hot loop, do joiner = " ".join and inside of it do # a tuple is faster than a list joiner(('Hello there,', first, last)) This takes me just over half the time of `%`. TBH, though, I can't tell why this would ever be the slow part of a hot loop. For one, IO is way slower than formatting.
Should I replace for? max_id = user_tweets[len(user_tweets)-1].id-1
This is a terribly good idea!! If you get this bot working pm me :)
As someone who pays attention to the notifications, if you do this more than twice, you're just going to piss that person off. I had some dude look at my profile every day for a month straight. It was rather annoying. 
I've interviewed and worked for a few software companies that use python. I've never seen a company that uses 3.0
Right. It's not "very good practice" to index arrays like that...I mean, it's a case-by-case thing, but here you're indexing into the same array you're getting the length from. It appears you want the last element...which is what `user_tweets[-1]` will return. If `user_tweets == []` the length will be 0, and `if user_tweets:` will return false; skipping the indexing step that's causing you grief. The next for..loop will also skip because there are zero elements in the array.
Sometimes the % formatting is easier, but str.format() is certainly more explicit and easier to understand. 
*He* is not updating numpy. The users of his library are updating it, and who knows why. Maybe they need to use the newly written 'blargpy', which requires the most recent version. Maybe their linux install uses the most recent version. Who knows? The bottom line is that if you write a library that uses numpy, you had better expect to be revising it forever, because I guarantee that your users will be upgrading versions even if you don't.
Use `bytearray` and `bytes` (which is just an alias of `str` in Python 2). I used to use strings, but these are much better when dealing with binary data.
I mean, this blog is just pointing out the obvious. Yes, operators are faster than function calls. They always are. Just like {} is faster than dict(). This isnt specific to string formatting this is a basic property of the python language. Also, he doesnt break down the python bytecode so his analysis is generally baseless. For those looking to investigate stuff like this, by all means do it. This blog is step 1, do some timeits. But PLEASE dont stop there. Try to understand WHY. The next step is to decompile the code into python byte code and see what the codes actually DOING. In this case, with format, Python sees the word and then looks it up in the context of the string namespace and then calls the function. Where as % is a builtin operator and doesnt incur the lookup penalty. tldr: Drawing conclusions from timeit isnt wrong, but its important to understand that it's naieve. 
At this point if a project hasn't transitioned to 3.x it isn't in your best interest to be involved with them. Seriously why involve yourself with a bunch of Luddites. 
I work for a large tech company and we are slowly but surely moving to python3. Our linter checks for python2 only code and complains. We are slowly replacing all the deps that don't support python3.
Don't forget about absolute imports too
Isn't your code snippet missing absolute imports?
Maybe if... you're trying to build network packets using `bytes.format()` (does that method even exist?) and... no, the network is still going to be the limiting factor. \\\_()_/
So if I do the lookup in advance...: &gt;&gt;&gt; formatter1 = 'hello {}'.format &gt;&gt;&gt; formatter2 = lambda x: 'hello %s' % x &gt;&gt;&gt; import timeit &gt;&gt;&gt; timeit.timeit(lambda: formatter1('world')) 0.5309175674346502 &gt;&gt;&gt; timeit.timeit(lambda: formatter2('world')) 0.5109054626577283 ...it looks like the savings are negligible or possibly just noise.
What you will do when you want to support both versions, or if you're a little bit serious about unicode safety, is use "from \_\_future__ import unicode_literals"; then all literals are unicode and you never need u"". b"" works in both versions.
I tend to agree with /u/alenajoykrieger here. If the 2/3 transition causes pain to you, you are not using unicode correctly in PY2 to begin with. If you were using bytestrings everywhere without questions in PY2, you now have bigger problems than your PY3 proficiency.
Well, for starters, the `b"..."` syntax is necessary in Python 3 if you want to have binary string literals (because there is no other way to create them). I *think* it's also necessary under the `unicode_literals` import. But a bigger issue is this: Python 3's classes are a little stricter than Python 2's classes, and in particular it's quite difficult to support binary strings across both. In Python 2, you may need to use `ord()` and `chr()`, while in Python 3 you *must not* use them because they operate on text strings. (I'm sure `six` has something to make this easier, but my point is the semantics are actually quite different; Python 2's `str` and Python 3's `bytes` are really not the same thing at all)
As a lead developer and owner of startups, I hire both employees and contractors. My very honest personal opinion is that "intermediate" developers aren't worth $50/hr. Code quality is usually abysmal, poorly written, even more poorly documented, and shows blatant failure of understanding of systems design. I'd pay $50/hr for someone who knows what they're doing, but I never pay more than $25/hr for an "intermediate" who needs to be babysat. Don't be afraid to set a good price, but only if you know that you can deliver a solid product. For your situation, I highly agree with tRfalcore's post. Edit: by the way, use Postgres. For the love of god, don't use sqlite or redis for things they're not meant for. True story: a novice contractor I hired back when I had no experience used redis to implement a patient database for a healthcare clinic. redis. Another one used sqlite for an app backend requiring many concurrent writes. Then argued his case and failed miserably. He didn't know what table locks were...
I disagree, unicode compatibility is as perfect in Python 2 as it is in Python 3. You just have to remember to use the u"" prefix or unicode_literals when unicode is needed, but the behavior is very close.
Ack, I knew that the attribute lookup was part of the time, and should have realized that I could shave it off (and thus do a better comparison) by aliasing the function call to a local variable. I mentioned this in the post, but could have done something about it, as you did. I'll update the post; this should have been obvious, and I'm sorry that it wasn't there to begin with.
This is certainly a valid point and is completely viable. However you still have to study one before the other (and I'd go with 3).
Isn't that included in 2.7 anyway? EDIT: Ah, they're not. I have a template that auto includes all of the relevant `__future__` imports.
I'd say this is a pretty superficial difference. I'll concede the stylistic aspect of `str.format` versus `%` formatting, because even if it looks better I still don't think it *is* better; there's too much you lose and not enough that you gain. Every engineer is going to measure these tradeoffs differently, as is their wont. But that's the problem with TMTOWTDI, and since the zen of Python is very much "There should be one obvious way to do it" that's why the addition of `str.format` has been such a disappointment to me. To be fair, I've seen the new formatting strings to be taken up a lot by newer programmers the past few years, but I can't help but think that's because they've been encouraged to do so by FUD about `%` and the threat that it would be deprecated and eventually removed. Let me also say that I separate the new format string syntax from the new `str.format()` syntax. Much of the downside to the `%` syntax is actually from the weird `__mod__` overload on str and the way that it uses tuples. The greatest pain with `str.format` is that they decided to change the format strings; if they'd kept the printf format strings, it would have been golden.
Well, nobody would use 3.0, but my company is using 3.4.
Scrapy is surprisingly straight-forward and has decent crawling capabilities. It's useful for crawling through sites at multiple depths.
On a side note, doing: user_tweets[len(user_tweets)-1] Is the same as doing: user_tweets[-1] ...negative indexing starts from the end of the list, so the `len(user_tweets) - 1` call is redundant. edit: I missed /u/Cabbagenom's comment about the -1 thing. Sorry about that.
If speed is really that important, probably best to look at C, C++ or Java. I think the last sentence was the most important: &gt;However, if speed is more important than the maintainability or readability of your code, then Id argue that Python is probably a poor choice of programming language. I still prefer % for readability though, but it is being deprecated in about 10 years.
It should be noted that while desktop kivy is ready for python 3.4, our packaging toolchain still needs some work to be Python3 compatible, so for the time being if you are targeting Android, you will need Python2 code. This will change in the nearish future (No guarantees on when)
While it is maybe technically possible to run Python + Kivy through a browser, the current consensus is that it would be a ton of work and most likely the performance would not be desirable at all. None of the current Kivy core developers are interested in pursuing a browser solution. But perhaps this should be viewed as a challenge for a future core developer out there :P
&gt; If the 2/3 transition causes pain to you, you are not using unicode correctly in PY2 to begin with. Or at all...I never considered it because I work in a field where ASCII is enough. Python 3 invented the unicode problem because 1) they did it wrong in the first place very early on in Python's development history and 2) they forced people to change how they had to write code that never considered encodings before. Again, if all you're dealing with is file IO, unicode is not a problem (even in Python 2). As soon as you start messing around with byte strings, it becomes hard. Python was changed to be much less hard for some people and much more hard for others.
You may want to write out a Plot3D file and play with it in ParaView. Or to do it all in Pyyhon check out VTK.
Absolutely not! You've had half a decade to prepare yourself for a Python 3 transition. If you're not ready at this stage, that's on you. Creating a community fork, which will almost certainly not adhere to the same BDFL process that the official Python project will means garbage will make its way into the language and they'll start to diverge. Stop trying to fit a square peg into a round hole, bite the bullet, and learn Python 3. Seriously. It'll take you all of 30 minutes to learn the differences.
I dont grok "grock".
When working with Requests, make sure you check out the Session class so that cookies will persist across calls. The rest should be a piece of cake. If you need to figure out the necessary calls, you can use [Fiddler](http://www.telerik.com/fiddler) or any other debugging proxy.
I'm not sure what qualifies as a "high level language" but if that includes python a string has a translate() method that takes nearly all the work out of problem 3.
You're procrastinating. Learn the one with the best support for the libraries you'll need. Then just go make something useful.
&gt; That said, as a professional Python dev, I couldn't possibly recommend you spend much time on Python 3... &gt; Just accept that Python ended with 2.7. If you actually believe this, then why would you still be a professional Python dev? Secondly, to what will you be moving and when do you plan to transition?
You need to create consistent test data to go with Choice 1. I would suggest a small and large set of files where each of the two sets are internally consistent as well as being consistent between the two sets. You could add a third set of data that includes some errors such as unrealistic average speeds / malformed numberplate numbers / missing fields in a record.
I am. And so are all my developers. Stop spreading bullshit. It's this kind of crap that is keeping 2.7 alive, and it needs to die. 
the bytecode is practically useless in explaining the change in times in this situation, and in most. if you want actual answers, then pdb is probably the best option I'm too lazy to run it up, but, ""%something should (technically) call `__mod__` method of the object, with python built-ins, I believe there is some shortcuts around the place to make it go faster for operators additionally, %'s formatting is all done within one "area" of code, {} instead uses the `__format__` method of each object passed to it. which is where I'd imagine the most slow-down to be. profiling would have to answer that though
% for readability? ... wat
&gt; That said, in many programs, the difference in execution speed is often 100 ns, which is not enough to cause trouble in many systems. This isn't the interesting comparison. Formatting takes a tiny amount of time anyway, so if it is actually a bottleneck you have to be running it a lot, meaning this 100ns adds up. The interesting comparison is the relatively performance, i.e. raw `.format` is about 1.5&amp;times; slower than `%`. (If it were 100ns out of 1s then there would be no reason to care, but since it's 100ns out of ~200ns it's very significant.)
I'd try to get used to it if you plan on distributing your code or having other python devs collaborate on it. At Python interviews, I've been asked what style I stick to when coding in Python and I just say PEP 8, they smile and nod, it's what they're looking for, and the conversation changes to something else. If you're using PEP8 any other python dev can hop in and feel at home, and if you're pulling code from other projects it will 99% adhere as well. It's nice to have a sane standard that the community follows. You'll likely be importing a module that will use_snakecase, so it's going to look very odd for you to be using both. And if someone has to import your module and useCamelCase, it's going to be frustrating. Also, when I run into code online that uses camelCase, I automatically distrust the code as someone who came from Java or whatever and decided to try Python. I look for things to clean up or rewrite before integrating it with my own. It's a personal bias, but more often than not, I find that the code is not pythonic in many other ways. It's just a sign that you're reading code from someone inexperienced with Python, whether it's true or not, whether the code is brilliant or not. As nemec mentioned, of course consistency is best, especially when working with others, but if it's a new project and you plan on distributing it or having people help out, I highly suggest going with PEP8.
What do you mean?
But again, unless you're doing millions of them, it's not interesting. It's like claiming that chemical X triples your chance of lung cancer... from say 0.01% to 0.03%. The 300% increase is *not* significant. This is one of the fun ways to lie with statistics. I actually know someone who heard one of these reports along the lines of "chemical X in Y type of hair color increases your chance of leukemia by Z percent", didn't understand her risk was minimal in the first place, and went so far as to call the author of the study, convinced she was going to die. She was actually sobbing on the phone when she got through to the researcher. The researcher had to explain to her how the news sensationalized the research and that the actual risk to any one person wasn't signficant despite the high percentage. 
The problem is that increasingly NumPy becomes a sub-library for other libraries. That is, you may use several libraries in your code that each use NumPy, and pass around NumPy objects, but require different versions of NumPy. So just asking for a specific version doesn't work. (e.g. netcdf libraries. proj projection libs, for climate/GIS work) Fixing this requires: (1) Work to ensure packages (not necessarily client codes) move to recent versions. (2) Ensuring important libs are backward-compatible. For example libc / glibc does amazing work to stay compatible. We have tools at a C level for versioned symbols, to ensure code compiled against an old version remain functional ; similar techniques need to be developed in python and numpy as it matures.
gah, bytecode isn't a representation of how the code runs (completely), its a representation of how the code gets interpreted you need to go though pdb to see what actually happens, not running `dis` its not like a function call is *1 instruction*, is it? because code runs inside the function! which `dis` will never show! 
If you're referring to the link, you stopped reading too soon. The bytecode was to prove that the original benchmarks from that thread were wrong because one was getting optimized out. I realise that looking at disassembly isn't a benchmark. It's just a way of checking that you're running the right thing. The author of this post at least avoided that trap, so there's one plus.
% is usually around 700% faster because of less typing.
The problem is that scientists aren't generally trained in coding, even though these day's it's as vital a skill as writing. So people cobble together these monstrosities and then complain when someone's updates break their rube-goldberg contraption.
Totally agree - I've been trying to push good practice on my collegues (I left academia to work in a company for a while and picked up some good habits), we have this initiative called Software Carpentry which tries to train people not to create such byzantine codes (http://www.software.ac.uk/software-carpentry) Worst I ever saw was this layer-cake-contraption where someone had written a fortran03 program that no one understood, so another guy wrote a perl program to pre-format (mangle) input for the fortran program, but no one understood that either so people wrote matlab scripts to call the perl program to call the fortran program!
There is still the option of doing it the wrong way which people will do because they are lazy or just used to the way programming was done in the past where internationalization was an after thought and "gee I really hope no one has an accent in their name". If you are already worrying about Unicode strings you might as well just switch to py3 anyway as that's the major blocking point. There is honestly no reason , if you are starting a brand new code base to use python2. 
Because you say what any competent python programmer knows about the python2 &gt; python 3 argument. Python 3 is now, python 2 is in bug fix only mode. Dealing with non Unicode strings is shitty and aggravates me every time I have to do something in python 2. 
Unicode strings have an internal encoding, it's just that that encoding is not publicly exposed  a string acts like a series of integer code points, and how those are stored in memory is not part of the interface. As of Python 3.3, they use a flexible representation. If the text is all latin-1, then latin-1 is used (1 byte per character.) If all the characters are in the BMP (basic multilingual plane), UCS-2 is used, a two byte encoding. Otherwise, a four byte encoding is used (UCS-4.) Prior to that, you had to choose when you built the Python interpreter whether you wanted narrow strings (UTF-16) or wide strings (UCS-4). Choosing wide strings meant you were unconditionally wasting 4 bytes per character regardless of content. This was not a popular option, and most distributors/vendors chose to offer narrow builds. Choosing narrow strings however meant dealing with awkward surrogate pairs for non-BMP content, which breaks the semantics of strings, i.e. `len()` is no longer correct and indexing does not work properly and is no longer O(1). This was a very unfortunate situation, one that a lot of languages share actually. Python 3.3's advancement put it ahead of the pack. Java and C# for example are still stuck with their head in the sand using UTF-16 and pretending it's not a variable width encoding when it is. 
Isn't there an object that takes a .format() pattern and compiles it so it doesn't have to compile it every time, if you are doing a lot of repetitive formatting, kind of like precompiled re objects?
If you know basic JS you can try using a framework like casperjs (that was suggested already), but also I found a pretty simple and straightforward one called dalekjs: http://dalekjs.com/ Pretty easy to use and can help you achieve exactly what you want.
&gt; I shouldn't have to know what the most recent version number is to be able to install a module. I disagree. It's a bit of a hassle to require it but it leads to a lot less mistakes. I like this about clojure. &gt; The proper solution to versioning issues isn't at runtime, it's at installtime. In clojure you define the dependencies of a project. There's no such thing as "install globally" like in python. This just avoids a ton of problems directly. The standard runner (again: leiningen) fetches dependencies for the specific project for you when you run any command. So I just git clone a project and do "lein run" or "lein test" or whatever and if I don't have any dependencies cached on my machine it goes out and gets them for me. SUPER nice.
Yes, that's the way to go. You could also use mayavi, but it's python 2-only and a lot slower than paraview. Mayavi is built on top of VTK also. Just do as jaredj suggest, you won't regret it. For density, I find it better to use volume rendering instead of isosurfaces.
I also need some inspiration for programs ideas as well!
the only thing I can think of that might be a problem is that pypy doesn't support 3.3 yet. I consider 3.3 to be the first "worth it" release of Python3, as it brings yield from (and therefore can support asyncio) I use 3.4 in production though and it's great. People complain about the long tail of libraries a lot, but I don't feel comfortable depending on unmaintained stuff personally EDIT: the exception hierarchy fixes are really nice too
Yeah, in general GCSE and A-level questions are best played as a kind of loose word-association game. You identify the rough area the question is aiming at and produce an answer which contains the right phrases and concepts, which might vaguely answer the actual question posed (if in doubt throw it down! marks aren't deducted for incorrect or irrelevant statements!). It's fairly common for tests to be marked by people who have almost no knowledge of the subject being tested besides the mark scheme. This will likely be the case here as well (though coursework is usually marked by the teachers and then a few examples are checked by the exam board as a control). There will be a mark scheme with items like 'used a loop', 'performed some I/O', 'used an if-statement', and remarkably few marks allocated for 'does it actually work' (e.g. I submitted an assembly program for electronics which I never even assembled, let alone ran, because I lacked the hardware, and got a pretty good mark in it).
Ah I was particularly interested in using Kivy for Android development with Python3! Looks like I shall just read the docs and learn the library until then! Thank you :D
As someone who is trying to figure out the same question, here is what I found as of today: * QT, easy native good looking apps with *quite* easy porting to other OSes. * WxWidget also good on these points. For now I'm going probably with QT, but my initial need is to find a GUI framework customizable enough (like using CSS or equivalent technology to pimp the UI), so if anybody knowing QT enough can confirm this
Is this the new curriculum? The GCSE Computing I did was bullshit, (I finished high school just over a year ago, now on my second year of college doing BTEC Hardware &amp; Networking) all we did was make a website do some random MS Office tasks. Edit: I just remembered that I did the BTEC IT at high school. But the few people I know that did the GCSE course didn't do any programming.
Since you want to work on a openstack project, don't listen to anyone on this thread and go to look for yourself on this page: https://wiki.openstack.org/wiki/Python3#Python_3_Status_of_OpenStack_projects
In python 3, the source encoding of python files is utf-8, but this is not the same thing as the in-memory encoding of strings. The in-memory encoding used by python to encode its strings varies from version to version and even within versions, but utf-16 one of the encodings that is sometimes used.
I would probably go with a qt wrapper for solely-desktop apps, or kivy if you're interested in making apps for mobile devices. But really, I'm inclined to think it doesn't really matter - what's most important is to pick a project, dive in and have fun. Much of what you learn will be applicable to most/all frameworks, even if they solve problems differently. Of course there are advantages to more deeply learning about one in particular, but that can come later.
Check out /r/progether. There's a lot of proposed projects posted over there. Not many in python recently but ideas are still there. Some common ideas are irc bots, websites (in flask or django), or data manipution. While working on my latest project ([mangarecs](http://mangarecs.herokuapp.com)) I've realized how easy python makes working with databases. sqlalchemy is really easy to pick up (especially if you already know the basics of SQL)
I'd go with cython(Maybe pypy but cython compiles into c) if you want speed.
Kivy is really simple and will run on any platform.
 &gt; If you actually believe this, then why would you still be a professional Python dev? Because I feel that Python still has the best ecosystem of useful, practical packages and a vibrant community, despite the enormous damage inflicted by the 3000 transition. However, that advantage is eroding as enthusiasts champion, "Just use Python 3!" while the vast majority of software and training resources available continue to target Python 2. The day that a major, important package goes Python 3 only is the day that Python dies. I don't mean to imply that all transitions in general are impossible, but I think that Python's primary advantage in the market  its huge diversity of contributors and contributed work  is exactly negated by a backwards incompatible language transition. That is to say, were Python and most of its "standard" supporting packages maintained by a single huge corporation that could simultaneously upgrade the language, all core packages, and all of its training documentation, backwards incompatibility wouldn't necessarily be fatal. As it is, Python's value (to me) comes from the million blog posts and tutorials, the long tail of one-off abandon ware packages written by domain but not programming experts, the huge number of mid-sized community run projects, and all the SDKs and internally developed tools that every company under the sun has released to the public. All of this "infrastructure" adds up to way more than just the big names  e.g. PSF/Django/SQLa  and the odds that even a significant fraction of it will ever upgrade to 3 are nil. So even when that top 100 package list goes all green, we'll only have scratched the surface of the transition problem. And by "Python dies," I don't mean some sudden cutoff  just that less and less new programmer energy will be directed towards the single Python community, being now split between 2 and 3, and, thanks to the confusion, likely just directed to the Next Big Thing instead. Frankly, every new Python developer I've talked to in the last three years has been basically stopped dead at some point in picking up the language with the objection, "Why are all of the books, libraries, and production code I'll be working with for Python 2, and why should I bother continuing at all if everyone says it's 'outdated.'" I've seen this happen to people ranging from "I want to learn to code" newbies to senior software devs coming from other languages and needing to hack on a production Python app. And it just happened to the OP. &gt; Secondly, to what will you be moving and when do you plan to transition? I'm not planning a move  I work with whatever's the best fit for a project, whether that's because of the abstract benefits of a tech platform for a brand new app or just because the project's already written in whatever. And in any case, as I said, I still feel Python's the best choice abstractly, for the moment. It just kills me to see the community being slowly poisoned by an artificially forced separation from its legacy code and knowledge base. However, if I had to bet, I'd guess that we're already bleeding the next gen of devs to other platforms  probably Node  and starting to go the way of PHP: lots of deployed code that no one new wants to work with. 
Seeing classes with two methods, one of which is __init__, is frustrating. For the record, I'm not talking about subclasses overriding a method and needing modified initialization logic. I'm talking classes that setup and then only do one thing. That's a closure. Write a closure.
Python doesn't really have the concept of public/private. And ergo, getters and setters aren't really a thing. This bit me switching from PHP. However, Python provides limited visibility with underscores at the beginning of a name. One underscore signifies, "Hey, this is an internal method. Please don't use me outside the class." Two underscores (or dunder) will cause Python to mangle the name and make it difficult to get at from outside that class all together. Python also has the very handy property decorator. That'll allow you to change simple variable access to a more sophisticated method access without breaking existing code (well, interfaces with existing code).
OpenStack is planning to move to Python 3 in the future. 
My first suggestion is that you actually give a link to the source.
Not from python 2!
Lately my go to for UI is moving to the Web. I like having the ability to access my programs from anywhere and it is fairly cross compatible. Granted I don't do a lot of local file system based development and most of my stuff is to manipulate and display data but still prefer an html5/css3/js stack for UI. 
Again though, if you're going to enforce pep8, you'd clean the project first, and use the standard from that point. Using it for a bit of your code just to avoid difficulties is just *asking* for trouble down the line.
He means your question is too vague to answer effectively. Be more specific. 
With QT you can use [QML](http://qt-project.org/doc/qt-5/qtqml-index.html), which, I guess, is about what you wish from the customizability point of view. It does take more initial effort, but the end result will probably look a lot more the way you want it to.
I should of phrased it differently . I was not necessarily referring to the legal entity of Github. Just saying docker as a tool works similarly to git as a tool; you commit, you pull, you push. There is another registry service called quay https://quay.io/ . I also watched another video talking about how to set up your own registry server https://github.com/docker/docker-registry Yeah, since I am working on a mac I need to spin up a VM with vagrant. It is just so that I can run docker in linux. This is nice because I know that if I take it to a VPS like digital ocean for example it will behave exactly the same as it does on my laptop. 
Yeah, our host is a paid solution and they currently only have python &lt;=2.7.2 available at the moment. Fortunately, most of what I want in 3 has been backported (futures, print, absolute import being the main ones). Right now I'm writing testing frameworks, so it's not a huge deal though - it would just be nice to use 3.x (but I am writing it where it won't break when I can move). I'll probably put in a ticket this week to get 3.4 installed with devops to encourage an update.
I used it for a while, it's horrible and I don't really remember why. Switched to PyQt and been happy since then. Wxwidget have some problem with Windows and exe building, so I don't use it. It's a nice option though 
&gt; % is being deprecated... In almost a decade Where is this coming from? All the docs I can find say that it's not being deprecated.
There is a philosophical thing here. Python3 assumes that there is a single, better representation: one code point per index. So that means that it is worth the cost to convert all other representations to the one true representation as a simplification. In Python3 you should only have to think about strings containing text in one way. So the actual internal representation is not important and is hidden from the application level. This is not the only way to approach this particular problem. If you don't particularly care about one code point per index and assume that in most cases the actual representation will be a black box to the application then you can simply ignore the problem in various ways. Julia is an interesting example, where some index values are simply not allowed and will cause an error: http://docs.julialang.org/en/release-0.3/manual/strings/ 
Css*
Not so. One of two things will happen: 1. You'll eventually work on all of the code, and so it'll eventually fall under spec. 2. Part of the code will never be modified, and it not being up to spec won't matter.
We saw someone from openshift (@codemiller) show us exactly how to do this just yesterday at kiwipycon 2014. That talk was recorded, and will be put up online in the next few days by the conf organisers. Keep an eye on http://nz.pycon.org for the vid The repo for the talk is here: https://github.com/codemiller/cloud-craft-python
I asked it here first but didn't get any replies.
You should really try out Enaml: http://nucleic.github.io/enaml/docs/index.html It's the best UI framework for desktop apps that I've used. It's based on Qt so you can integrate with existing Qt code fairly easily. Once you've got use to the declarative approach Enaml uses, you won't want to use anything else. The only downside is the lack of python-3 support.
I've heard very good comments about [Enaml](https://github.com/nucleic/enaml). It adds a very pythonic declarative layer on top of PyQt.
Hm, not sure I agree with leaving old code out of spec/guidelines, but each to their own. I'd always want the entire codebase in line with the spec.
I can only point you at [node-webkit](https://github.com/rogerwang/node-webkit) which lets you write native apps using web technologies. It pretty much runs chromium and points it at your app.
&gt;Please note that Twitter does not permit any automated or bulk following or un-following behavior. Please review our Automation Rules and Best Practices for more information on automating your account.
I have come to the same conclusion as mordaunt0, but I have not implemented anything yet. One site I found while researching is [here](http://toolsforagile.com/blog/archives/51/deploying-a-django-app-on-the-desktop). I was already wanting to use Django, so I have not looked at other Python possibilities. Not to mention the non-Python alternatives.
You can do that in Qt.
I started with django but in the end I almost default to flask now for the simplicity 
*"Hello, Mr. Boss guy. I'm just committing trivial changes to literally every file in the repository because they don't follow what this particular tool interprets to be the standard library's style guide. This is important Mr. Boss Guy. On an unrelated note, could you please review these changes and make sure that I haven't broken anything. I know we don't have tests yet, but I'm sure my changes are safe."* 
I gotta ask, why is it such a big deal just to use wide strings? Even massive amounts of strings only result in a few megabytes of data.
Yeah, I'm sure the Python community is fractured a bit and bleeding some folks into Node et al. That said, it's not like it's really even replaced PHP, so it's not like we really have a huge upheaval coming up. There's not much there numbers-wise to disrupt. Personally, I think Python hasn't hit its apex yet, so when library authors finally do come around to Python 3, there will be very little indeed holding it back. It's certainly a lot more sane and widely applicable platform than Node and really Node seems to be taking away far more folks from the Ruby on Rails community as those are much more apples to apples. The Python community certainly does have a web niche, but it extends far beyond Node's reach. All that said, Python's influence has certainly been far reaching already; even if it isn't used by virtually everyone yet. I don't think it will be done and forgotten anytime soon.
Create an action when something is liked then use exceptions and such to extract information
Don't get me started on the problems with Tkinter. It is NOT threadsafe. Sometimes you can trigger events from a thread, but other times it crashes the python interpreter. Most of the time you'll get an error message about an apartment model not being started from the current thread. The workaround is to have the Tkinter main thread read a queue of events to process. See http://effbot.org/zone/tkinter-threads.htm Why does Tkinter need a Python programmer to maintain a separate event queue rather than having threads place events onto Tk's internal event queue? This situation is frustrating.
&gt; MIT / BSD is a far safer option. What about LGPL?
I made one, and then I contributed some stuff to kivy, and then I became a core developer. So, I guess it went pretty well. One thing I've done is a [series of video tutorials](http://inclem.net/pages/kivy-crash-course/) that you might find useful. &gt; I know it will be hard I'd actually say that the process of making a working app and running it on an android device is remarkably easy in general. That's what I covered in the first 20 minutes of (real time) video tutorial just to try and demonstrate how cool it is. Of course, building any non-trivial app needs a lot of learning in any toolkit, just to get an idea of good ways to work and fit things together. I think kivy is mostly very reasonable about this, it has a simple but pythonic api and optional-but-recommended language for declaring widget trees without all the python boilerplate. Kivy also has an excellent, active community, so don't be afraid to ask questions on the irc channel or mailing list.
*"Why would use a tool whose sole purpose is to compare your work to pep8, if you weren't going to use pep8 as your standard?"* But I *do* want to conform to PEP8. (And let's just pretend that there exists a tool that accurately checks PEP8 conformance. (There isn't, but we'll pretend)) *"If you are using a standard, make all of your code conform to it, not just the recent sections."* This is the point that you're missing. If I've got 500 files and no tests, it's difficult to confirm that I haven't broken something when I changed literally every file in the repository. Code breakage aside, doing it the global way means that I have to spend several days doing this, meaning it's several days where I don't fix any bugs or develop new features. Alternatively, assume that there isn't a company-wide style guide and there is no desire to have one. You personally decide that you're going to stickto PEP8. That's fine and you can make the files you work on match PEP8, but you can't just go and modify all the files that you're not working on match your personal style. *"Furthermore, why would you impose a standard without any form of testing? You just wouldn't change standards without FIRST writing the tests for it."* Haha. Why does any codebase anywhere exist without testing? Do you mean to imply that no changes to a codebase should take place until it has tests? For some unfortunately reasonable real-life reasons, this isn't always practical. Sometimes you've got to keep working without unit tests. (You might instead rely on human-driven QA, for example) It's an unfortunate reality in the commercial world.
+1. "Here's my webapp, I want some feedback please" is not going to be all that informative. Plus based on some of his latest tweets he *seems* to be security oriented so he should especially care about having his code reviewed. That said the one question I do have for the author is "Why?". Passing data hash to an external website seems like overkill and something I can do myself in my own application. If the application is just a toy then why not let people select what hashes they want back or how about a RESTful api?
if i may ask, what was you development environment? Cant make kivy work properly in Ubuntu. Did you use the VM that kivy provides?
Amazing reply yacob, thanks i will and i'll check the links, also have a good time there :)
There are programs that deal with a lot string data, more than just a few megabytes.
:-D
Small world, I was looking at your video series yesterday and today I run into you again. Thanks for answering my question about the right side bug.
It really depends on your target. Distribution of GUI libraries can be a royal PITA if you need to be cross platform. I'd probably go with a web based UI if I wanted to hit the big three, otherwise I'd look at PySide.
I work with qt and I can tell you that can be customized a lot. All the drawings is done by a QStyle class with many stiles ready for every platform. And on top of that more or less all the widgets can be styled with a stylesheet with a css syntax. In my application you can add a theme crating a folder with a stylesheet.qss file and some svg for the images and the software can load this at runtime and apply in real time. 
I recommend /u/inclemnet's tutorials. I was able to get an app running within a few hours. I ran into some obstacles that I had to work through, but they had nothing to do with the tutorials. Once I had everything set up correctly, compiling and packaging took a minute or less. I have no more than an intermediate understanding of Python and found Kivy pretty easy to do. Go for it.
Thanks! It just looked.... Intimidating at first so I wanted to know first hand how it was. Can I see the app you made? 
FWIW, the main maintainer of git is employed by github.
You can use [marching cubes](https://en.wikipedia.org/wiki/Marching_cubes) to turn a 3D scalar field into a surface at the given threshold. [Here](https://code.google.com/p/pythonisosurfaces/source/browse/modules/p3d.py) is an implementation of marching cubes, but it is a little tied into its web-app roots. If you would like to quickly have an [OBJ](https://en.wikipedia.org/wiki/Wavefront_.obj_file) of the field, PM me your data and I'll run it through [Houdini](http://www.sidefx.com/). 
But it seems like that is the exception, not the norm?
I've written my first android app with kivy a while ago. It's really easy and tons of fun!
Use kivy, it's awesome :)
Yeah I'm currently taking an edx course and when I finish that I wanted to make an app with kivy. But it looked so advanced and intimidating, but now that I know there's people who can break it down for me I'm definitely going to try it!
I can't wait to start then! What's your app called? 
Yeah, pygame can be a real pain, it's one reason we're moving away from it with a new default backend, which should hopefully go into master fairly soon. In the meantime, are you trying to install kivy for python3 or python2, and how is pygame installed? If python3, you need an up to date (master branch) pygame that may not be in ubuntu'r repos, and there's another ppa for that. I'm not sure if the same applies for python2.
The first app I made was [noGo](https://play.google.com/store/apps/details?id=net.inclem.nogo) - don't judge kivy by how well it performs, there are a lot of things I'd change (and could get great performance for) if I did it again or have time to revamp it. That said, the the main poor performance is on the scrolling lists, anything else should be fine. I'd also like to make it fit in a lot better as an android app, theming is something I didn't spend much time on and could do a much better job of. I also have [PlaneWaves](https://play.google.com/store/apps/details?id=net.inclem.planewaves) on google play, but it's mostly a kivy shader demo - fun to make though! I don't have anything else on google play, more recently I've mostly done a lot of smaller tests and demos.
You're actually the very first person ever to mention that bug - I always wondered if people kept quiet about it or if nobody notices!
Qt is great, but be very careful with memory management. My experience is plenty of segfaults or memory leaks if you are not careful managing the lifetime of your objects. 
This did come out of a real issue in the pandas codebase, we'd occasionally have people committing huge/unrelated changes to the code base (to be fair, I [started that trend](https://github.com/pydata/pandas/pull/2632)). Doing this every release just got too much - it really does cause rebase hell. I agree pep8ing each commit can be a good idea and many projects do this, but I think it's too much of a barrier for us in pandas, IMO keeping the barrier low is important. This is also an easy way for new contributors and those unfamiliar with pep8/best practices/crazy merge conflicts (!), just to keep the code consistent with ours. We have definitely seen ugly pep8 related rebases, and unhelpful git blame.
Not really. Consider something like a web application  that's pretty much all string manipulation. Handling any given request may not require giant amounts of strings, but you're not just handling one request at a time. A busy web app could be serving thousands of requests per second by running many instances of Python at the same time, and if it's using 4x the amount of memory that's really going to add up fast. That would be a serious hit in performance, because you'd be able to run fewer instances compared to 2.x before running out of memory. 
autopep8 has [been run on pandas](https://github.com/pydata/pandas/pull/2632) every so often (mostly after a release), but this unfortunately this touches everyone's open branches and they have to rebase. Many of our contributors are scientists first (rather than programmers), and any barrier to entry is a bad thing... I think *requiring* pep8 on every commit would be too much. Unfortunately that means it's continuously in brownfield development!
You might want to try an optimized version of list_unique: def optimized_unique(seq): seen = set() seen_add = seen.add return [x for x in seq if x not in seen and not seen_add(x)] It outperforms all the others on my laptop.
No my point to you is python 3 isn't guaranteed the future. As I recall they've already stated they will continue to support 2.7 for a long time if not indefinitely. Secondly, companies on 2.7 will not be updating to 3.
Wow that seems really cool! Can't wait to see it hit the top 10(!
Tkinter's *only* saving grace is it's in the standard lib. It lacks a native look in anything outside GTK, and even then some of the widgets look way outside of what everything else does, so it lacks consistency. 
The QT framework comes with QT Designer. Glade also has something similar. 
You can also put something in the .openshift/cron directory if you want to run regularly: https://www.openshift.com/blogs/getting-started-with-cron-jobs-on-openshift 
&gt; . Most of the time you'll get an error message about an apartment model not being &gt;started from the current thread. "I don't understand this error message. I live in a condo!" 
I did and it made me learn Java because of the performance hit you get with it. Which, really is no different than when you use py2exe or something, which is why I don't use those either. Its a great platform, but it takes a while for the app to start up and I don't feel the benefits it provides warrant it for me, personally. YMMV
1) self-propagation is considered by many a strength, not a weakness (but then I'm writing this from desktop Linux). 2) Qt has an LGPL license. The only license problem you would have is if you change code within Qt but don't want to distribute those changes for some reason. Code linked to LGPL does not need to be GPL code.
Qt is LGPL.
Not deprecated but definitely discouraged as indicated by this remark at the head of the [3.3 doc section on %](https://docs.python.org/3.3/library/stdtypes.html#printf-style-string-formatting), &gt;Note The formatting operations described here exhibit a variety of quirks that lead to a number of common errors (such as failing to display tuples and dictionaries correctly). Using the newer str.format() interface helps avoid these errors, and also provides a generally more powerful, flexible and extensible approach to formatting text. 
huh? is that about [pep 328](http://legacy.python.org/dev/peps/pep-0328/), only needed in 2.5?
Be careful. You were on the payroll when you developed this IP. Your employer would have a very strong claim for ownership for the middleware product you developed for Salesforce. They would have a weaker, though still compelling, claim that they own all related IP for future work based on the work that you created as an employee.
For the record, in my experience Debian systems ship with Python wide-builds by default. edit: fixed typo
Even so, you're only using twice as much memory as a UTF-16 implementation. That's not really such a big deal, if it gains you the convenience and ease of fixed-width code units. 
Im using Anaconda as a python installation. Just followed [this](http://kivy.org/docs/installation/installation-linux.html) tutorial on installation. However, when I run [this](http://bytedebugger.wordpress.com/2014/05/21/tutorial-android-development-with-python-and-kivy-introduction/) page I example, i get the error: [WARNING] [WinPygame ] SDL wrapper failed to import! [DEBUG ] [Window ] Ignored &lt;sdl&gt; (import error) [DEBUG ] [Window ] Ignored &lt;x11&gt; (import error) [CRITICAL] [Window ] Unable to find any valuable Window provider at all! [CRITICAL] [App ] Unable to get a Window, abort. Exception SystemExit: 1 in 'kivy.properties.dpi2px' ignored [CRITICAL] [App ] Unable to get a Window, abort. Error which, according to [Kivy's installation page](http://kivy.org/docs/installation/troubleshooting-macosx.html#unable-to-find-any-valuable-window-provider-error) , is solved by installing pygame. So lets move to Pygame! When i do on the command line: import pygame I get the following error: from pygame.base import * ImportError: /home/manueslapera/anaconda/bin/../lib/libm.so.6: version `GLIBC_2.15' not found (required by /usr/lib/x86_64-linux-gnu/libpulse.so.0) Which is an error i ABSOLUTELY cant fint a fix for. So im afraid im forced to develop on Kivy using the slow VM :(
Julia, Go, and some other modern languages conflate the high-level string interface with the low-level underlying implementation. It's a stupid idea for a high-level language, and it just goes to show that even people who are quite smart and should know better are still trapped in the 1963 paradigm of "text is ASCII" and haven't quite gotten out of it. It is as if you wanted to work with an array of C longs, but the array was indexed as *bytes*. If you specified an index of 0, 4, 8, ... you're okay, but if you gave an index of 1, 2, 3, 5, 6, 7, ... you either get an error, or worse, the wrong results. And when you ask for the length of the array, it gives you an answer 4 times as long as you want. Only worse, because instead of a fixed 4-bytes per long, you have a *variable-width* type, where values can take anything from 1 to 4 bytes. That's effectively what Julia is doing: human-readable strings are not a first class data type, only raw bytes are. When it comes to numeric values, we all recognize this as a stupid idea, but when it comes to text, even in 2014 there are still otherwise smart programmers who think that's acceptable to dump responsibility for working with high-level characters (actually, code-points) on the programmer, not the library. That's **shameful** for a language in the 21st century. (The curse of C continues to blight computer programming -- in the long run, C will have done more harm than Pascal, BASIC, Fortran and COBOL combined.) Just say NO to variable-width encodings (UTF-8 or UTF-16) for in-memory implementations where random access is required. UTF-8 is the correct solution for transmission and storage, but for in-memory string objects, a fixed-width implementation is better. Speaking of idiotic design decisions... julia&gt; int('2') 50 And somebody actually thought that was a good idea. Sigh. 
Sheesh, don't take a screen shot and post it on imgur. Just copy and paste the text! 
There is no "both languages", unless you think that British English and American English are mutually incomprehensible. If you are fluent in Python 2 or 3, learning the other is easy. But if you are just learning the language, then **learn what you will be using**. For an experienced coder, it is easy to adapt from one to the other because you can tell the difference between "I've made a mistake" and "this is a difference between the dialects". But for a beginner, you don't have that knowledge yet, and you'll be constantly running into trivial differences between the two which nevertheless give you grief because you can't tell if it's *your* error, an error in the code you're reading, or a difference between the two dialects.
&gt;I'd actually say that the process of making a working app and running it on an android device is remarkably easy in general. No, it isn't. When you're making an app for a phone, you're making a program that will have to be run on significantly less powerful computers. There are so many constraints and limitations. Most people tend to forget that. 
Writing code to handle bytes is easy. Just use b'...'. Writing code to handle text is easy, just use '...' or u'...'. It's writing mixed mostly-bytes-but-a-bit-of-ASCII-text formats that can be painful, but the Python devs are working on making that use-case less painful in 3.5.
&gt; Python 3 invented the unicode problem Wot? 
I really don't think there is anything we can say about this that hasn't been said many times before. You have some combination and amount of bits in a computer somewhere. Who or what ultimately decides what those bits mean is a legitimate thing to debate. I personally don't think there is a right answer.
Yay to hear about the coming Python 3 support!
Thanks kart_king, i will take a look at this article, i appreciate it.
This might be something helpful to you: http://controlcenter.io/
&gt; Idiots still strongly suggest picking 2. That's nonsense. There are still good reasons to learn 2 if you must. Python 3 is, in general, a much better experience and a much cleaner language. But Python 2 will be supported until at least 2020 and beyond for commercial paid support, so it isn't going away soon. If you're going to be using 2, then *learn 2*. As a beginner, it's much easier to learn a language when you aren't constantly trying to guess whether your code doesn't work because you haven't followed the instructions correctly or because the instructions are for a different, incompatible version. For experienced Python coders, up- or down-shifting from 2 to 3 or visa versa is easy. But if you're a beginner, you will really regret not learning the version you're using. 
You'll never need anything but the official docs and anything else will get outdated quickly.
Sorry, can you please elaborate.
Can't you change headers? How would they know it's selenium?
I know of at least one person who is still using Python 1.5 in production. That's ONE point five. In fifteen years time, the number of people using 2.7 will be about the same as the number of people using 1.5 now. But if it works for you, and you don't care about upstream support, then stick to what works. There's no shame in it and no need to upgrade just for the sake of upgrading. But for those who want upstream support, after 2020 there will be no more free Python 2 support, and you'll need to pay for it from companies like Red Hat. And that finishes in 2023. So companies will have to make a choice: * upgrade to Python 3; * re-write the application in a completely different language; * or give up on upstream support and be like that guy running 1.5. 
It's not actually, there are plenty of odd corner cases where Python 2 tries to be "clever" by automatically converting between Unicode and byte strings. Try this in Python 2.7 and 3.x: raise ValueError(u'') and try to explain the difference.
&gt; There are so many constraints and limitations Obviously there are constraints and limitations, I didn't say otherwise. What I *did* say is that making a working [kivy] app and running it on an android device is remarkably easy, and I've no problem sticking by that statement. That said, even in the context of phones being less powerful and having limitations, I don't thing it's fundamentally hard to write code that runs fine on them in a wide range of cases without putting vastly more thought into it than you would a desktop app; phones are much less powerful than desktops, but desktops are far *more* powerful than many applications actually need. Of course, there are plenty of cases where things are harder, or where the limitations are more of a problem.
Here are some basic games I wrote in Python/Kivy, if you want to check them out. * [TicTacToe](https://github.com/grierson/ttt-kivy) * [Breakout](https://github.com/grierson/breakout-kivy) **Resources** * [Kivy Crash Course](https://www.youtube.com/playlist?list=PLdNh1e1kmiPP4YApJm8ENK2yMlwF1_edq) * [Creating Apps in Kivy](http://shop.oreilly.com/product/0636920032595.do)
Hmm, this one I don't know about, especially with conda involved. How did you install pygame? And are you trying to use python2 or python3?
I installed pygame following [this](http://www.pygame.org/wiki/CompileUbuntu) tutorial on Pygame. #install dependencies sudo apt-get install mercurial python-dev python-numpy ffmpeg \ libsdl-image1.2-dev libsdl-mixer1.2-dev libsdl-ttf2.0-dev libsmpeg-dev \ libsdl1.2-dev libportmidi-dev libswscale-dev libavformat-dev libavcodec-dev # Grab source hg clone https://bitbucket.org/pygame/pygame # Finally build and install cd pygame python setup.py build sudo python setup.py install And im using python 2.7, more specifically: 2.7.8 |Anaconda 2.0.1 (64-bit)| (default, Aug 21 2014, 18:22:21) [GCC 4.4.7 20120313 (Red Hat 4.4.7-1)] Any help you could provide me in terms of how to install pygame, or make kivy work (i dont care about pygame honestly) would make me super happy. 
I made a simple-ish, not published, weather app to try out kivy. 1. I find UI development harder with kv than with xml in android studio. 2. It doesn't look nowhere near native. 3. It doesn't feel really native either, I can't really pinpoint it but something is just... off about apps that use kivy, or maybe it's just my code. 4. File size is much larger due to the fact that it has to package python alongside the app. 5. Setting up development environment can be bit tricky. 6. Documentation is not that great, although it isn't bad either. It's relatively new framework that isn't used by big number of users so that's understandable. 7. I wrote a small amounts of game code and it was much better experience than writing a standard android app. Overall if you're comfortable working with Java then you should absolutely use that for developing android apps, if you're working on a game and/or application that should work on both desktop and android then you can go with kivy.
I'm actually going to do both. Now I'm learning Python; so I use kivy. Next semester when I take my programming class so I'll learn java and use it to make apps.
tried that, didnt make it work :(
Nobody can breakdown this code, since there is none ;) 
As I commented on your other post: user_tweets[len(user_tweets) -1] Can be shortened to: user_tweets[-1] Because negative indexing starts from the end of the list. To make sure you have tweets before setting the `max_id` you could wrap it all in an `if`. source_tweets = [] user_tweets = api.GetUserTimeline( screen_name=user, count=200, max_id=max_id, include_rts=True, trim_user=True, exclude_replies=True) if user_tweets: max_id = user_tweets[-1].id - 1 for tweet in user_tweets: tweet.text = filter_tweet(tweet) # Using plain 'if' here, instead of len(). if tweet.text: source_tweets.append(tweet.text) # If no tweets are available, the return value would be: # ([], whatever was passed for max_id) return source_tweets, max_id So: tweets, maxid = grab_tweets(api) if not tweets: print('User has no tweets available!')
Well shit. 
You should add 4 spaces at the beggining of each lines of code, so it's displayed consistently (see the sidebar of this subreddit)
Support for Python 2.7 is scheduled until 2020. Saying that there will be "support" for something until "x" is not a valid argument for reasoning to use it. Companies on 2.7 will not update to 3? How can you make this sweeping statement? And still, OP is asking for his project, which lang to use. Why should he choose to purposefully use an older version? None of your arguments yet defend this.
Lol was way to high when I posted that. 
You want an explanation for *each line*?! That is what reference manuals are for, find them and read them.
Python bindings for the Enlightenment Foundataion Libraries
No python 3 progress :( https://github.com/nucleic/enaml/issues/117
I made a small library for turning [flask apps into desktop apps](https://github.com/Widdershin/WebUI) a while ago. Might meet your needs.
Is there a way to use kivy and native widgets? I woul love to do android apps with python.
/r/learnpython
I think he's trying to say that printed texts have a habit of being rather static. The official tutorial is pretty good and was what I used to learn most everything. https://docs.djangoproject.com/en/dev/intro/tutorial01/ Good luck and have fun.
Not in any way that's remotely useful for making full native applications. You actually can instantiate and use some native widgets directly, but they don't fit well with kivy (they're always in front of or behind all kivy's drawing), and it's using the java api to directly instantiate and position them rather than getting to use any of the normal java gui building methods. This all uses pyjnius, kivy's project that lets you directly use java classes from python. The methods can probably be extended, and there's a possibility that maybe a more complete gui toolkit *might* be possible this way, but it would be a lot of work to get there if it's even possible at all.
I prefer kivy because its cross platform including android. If you don't expect to port your apps or develop for android I used tkinter a lot with bwidgets. Qt doesn't cut it for me due to the C++ dependencies even with QML. Worked long and hard with QML but gave up because a) can't read files from local storage as javascript doesn't support it. b) debugging was dreadful compared to kivy. Android file size is enormous - around 14 Megs and up compared to 6 Megs for a kivy apk.
Code for 3 and use something like [this](http://python-future.org); when you're stuck on some poorly-maintained system that's only giving you the option of 2 it'll be much easier. 
Try in /r/learnpython/. Here your post will be deleted.
I blame Ubuntu
Also, does it provide the tools to support a material design style interface on Android?
You probably need to make another object similar to text_surface for each line, and remember to adjust 'y' accordingly (subtract another .get_height() off the existing area) Then screen.blit all of them in that loop. Warning: I've never touched pygame, this probably isn't the best way of doing it
Depending on what sort of characters you are printing, resetting the cursor may help: def print_there(x, y, text): """" allows display of a game of life on a console via resetting cursor position to a set point - looks 'ok' for testing but not production quality. """ sys.stdout.write("\x1b7\x1b[%d;%df%s\x1b8" % (x, y, text)) sys.stdout.flush() 
/r/learnpython would be a good place to start. In the meantime -- what have you tried? Post some code here. The point is to guide you to a conclusion instead of just posting code that works.
One thing to always keep in mind is that professors sometimes make mistakes on their questions. From reading what you wrote above, the functions and the answers might be backwards. Your "d" function will return a boolean. Your "f" function will return a number. d(2, 1) would return False. f(5, 3) would return 2.
This is a highly subjective viewpoint. If willing to sacrifice individual freedoms for the good of society in general then GPL does more, for more people then more permissive licenses. Permissive licenses should be used for libraries and underlying tech. Top stack applications should choose GPL. Of course, this is my own highly subjective opinion.
Again: What have you tried? What has worked/partially worked? What has failed (and how)? If you are really stuck, it might be worth it to try doing it against the instructions' wishes (with string operations -- like [string slicing](https://docs.python.org/3.3/tutorial/introduction.html) to get you started. The way to *really* learn things is to try, fail, rewrite, succeed, repeat.
Keep posting examples here. Post attempts that failed. People here will help you through it.
Oh. Cool! Thanks.
Thanks!
I don't know why people are downvoting you. Python 3 is great, but the majority of places using Python is production are still using Python 2 because that's what their OS comes with as a standard install. 
I started with Django, but always had a love/hate relationship with the Admin interface &amp; other "niceties/magic" that Django forces you to use. Now I primarily use Pyramid, which has done a lot of the monkey work for me, without forcing me to use any single library or framework. I prefer it to Flask for large projects as it feels a bit more of a "serious" framework to me. I've used Flask for small hobby projects like single purpose websites. I don't think I'd ever use Django again. Not impressed with their ORM &amp; that's a dealbreaker for me. But if I was hoping to pawn off the project to another developer I would most likely use Django. At least the person taking over would know the layout &amp; structure straight away.
Original 2048 game was made with Kivy
Excellent talk. Summary: Transforming Code into Beautiful, Idiomatic Python Learn to take better advantage of Python's best features and improve existing code through a series of code transformations, "When you see this, do that instead." Published on Mar 20, 2013
&gt; Fixed-width encodings are a myth. That's nonsense. UTF-32 is fixed-width. Every code point uses exactly one 32-bit code unit. &gt; There is no fixed-width Unicode. &gt; &gt; You can have fixed width code points, but this is not the same. Of course it is the same. By definition if we're talking about Unicode we are talking about code points. I know that for simplicity I often say "characters", but I always mention that's a simplification. Unicode is an encoding scheme for code points, not graphemes. Unicode is aware that graphemes exist, but doesn't make any promises about them -- it's not a grapheme standard, it's an charset standard, like Latin-1 and ASCII but bigger. There is no programming language which offers strings of graphemes as a built-in type (as far as I know). I'm not aware of any third-party libraries which do so, since that would require knowledge of what language the text is supposed to represent. All this is out-of-scope for a simple "text string" type in a programming language. So while you are completely correct that Unicode doesn't offer fixed-width graphemes, that's irrelevant to the discussion since no programming language, and Python in particular, promises graphemes as a data type. If you want to argue that they *should* offer grapheme APIs, that would be awesome, and I look forward to seeing your code ;-) 
Did you delete all the libm.so files? If you just delete the .so.&lt;number&gt; files, it won't work because those are just links to libm.so.
FWIW I didn't have any problems with getting the basic Hello World KivyF app compiled on Ubuntu 14.04, but I wasn't using Anaconda, just out-of-the-box Python and pip-installed Python packages.
&gt; If willing to sacrifice individual freedoms for the good of society From my perspective, things that inhibit my ability to produce something for other people to use is a big deal. I think society would be much worse off if GPL really went to court. Most of the embedded devices would become illegal overnight. It'd be a bad day.
hmm, this might be an easy fix, gonna try it now, thanks!
How similar to native is the kivy ui on android?
It doesn't have any tools to make any desgin fit Android. It's more or less a NUI framework: it's for physical and direct interaction, not through GUI metaphor like menu, button
An excellent speaker and I learned alot. Thanks for sharing.
Awesome! You inspire me... if only I had more free time!! 
&gt; I've found performance regressions in 3.x Could you say a little more about those?
Python is perfect for robotics, as mentioned you might need C for embedded applications but otherwise it's great. I've used it with industrial robot arms, Turtlebots, custom built bots...it's good very good ROS support as well, I'd definitely have a look into that. http://wiki.ros.org/
Big thing worth noting about Qt is it's not free for commercial applications.
do you have to use uwsgi? If you can just use plain old fastcgi, then it should be fine, nginx has goo dbuilt in support for fastcgi/conn pooling etc
That syntax is like XPath but worse. 
A 30-person company, [Luminoso](http://www.luminoso.com/). We do natural language processing stuff, so we ran into everything that's wrong with Python 2's Unicode all the time, plus we all love Python and wanted to be able to use the new features. Getting to use the 3.3+ string representation instantly cut our RAM use in half, for example. In non-Unicode features, we often need the `TemporaryDirectory` class that cleans up after itself and the `yield from` statement.
Oh really? I didn't know that. --- &gt; Junio C Hamano (  Hamano Jun[1]?) is a Japanese software engineer and hacker best known for being the maintainer of Git since 26 July 2005.[2][3] Linus Torvalds has said that one of his own biggest successes was recognizing how good a developer Hamano was on git, and trusting him to maintain it.[4] He lives in California and works for Google. Wiki^ seems to disagree. Uhm... Are you referring to someone else?
pyopencv
CPython 3 on average is slightly slower than CPython 2 on the whole, mostly because of its different model for numbers. It's visible in most trivial benchmarks, although the difference is normally quite small. Somewhat thankfully, * A lot more is written in C in CPython 3, so if you use the right libraries it can actually much be faster and * PyPy3 has *different* performance but on the whole it's no worse than PyPy (Python 2).
Thanks
Sorta relevant: https://github.com/rogerwang/node-webkit. You can write desktop apps using web technologies.
Thanks, I'm going to check that!
Thanks for the tip! I'm going to check
I'm not exactly sure what you require, but I've been working with square markers from the ALVAR library using using ROS using Python. The library itself is written in C++ and runs as a ROS node, but I receive the messages about the pose of the markers in Python and do any further processing using Python 2.7. From there you can use any python libraries to do your visualisation and so forth. ROS is quite a large framework and I don't know the scope of your project and whether it will be worth it to invest the time. A believe there is a Windows version available, but I also don't know how well it is developed. Anyway, here is a set of relevant links: ROS: http://wiki.ros.org/ ALVAR: http://wiki.ros.org/ar_track_alvar http://virtual.vtt.fi/virtual/proj2/multimedia/alvar/ A quite good book about augmented reality: http://www.vtt.fi/inf/pdf/science/2012/S3.pdf 
Of course it's exactly what I'd write, I did write it! :-) Hello Joshua, long time no read. But I'm serious. I think that ultimately you're right and programming languages ought to supply either some sort of library, or perhaps even fundamental data structures, for dealing with graphemes from human languages. But that's a Hard Problem, and language specific. Here's something trivial I was dealing with 20 years ago or more on Apple Macs: if I search for "fi" (that's two characters, f followed by i) what I actually want is to *also* match the single character  ligature. Except for the times that I don't want to match them, so the API has to support both cases. The  ligature is two graphemes in a single code point. How about Dutch?  is (at least sometimes) considered a single character in Dutch, sometimes a ligature of i and j, and sometimes two completely independent characters. But in English it is always two characters. And I have no idea about the rules for ligatures in Arabic. Deciding on graphemes in full generality is extremely complex, and requires not just knowledge of the language you're writing, but of the semantics of the word you are writing. The algorithms given by Unicode are just the tip of the iceberg of what a full text library would have to deal with. I believe it is out of scope for the language primitives (strings). 
Thanks, these sort of things will certainly be very useful on a raspberry pi, or when we can make mobile apps in python
Huh. I'm not sure I get the difference. Isn't material design mostly a set of recommendations for how direct manipulation interfaces should look and behave? In that way it seems to be aligned with the idea of Natural User Interface.
But you're producing something for people to *not* be able to use fully. They buy a device and are locked into using it a certain way. You've denied them (for you're own personal benefit) the freedom to use the "something" any way they choose. In the long run, society is better off without that something than with it.
If you alreaday have it working there really is no good reason to switch. Odds are your project will be end of life anyways before Python 2 support ends.
Look up these technologies: - NGINX - UWSGI - Flask
Red Hat is quite an exceptionnal case
I didn't say you can't use it to do GUI or Material design, it just doesn't provide the tool needed, the widget, UI element will not look native.
Silly question . If you make an app with Kivy . You must have Kivy in every smartphone you want to run your app ? You can upload it for example at google play ?
Well I would like to make utilities with a GUI that looks good and is not just standard os windows and buttons. I would like to have one version that runs on all platforms so it needs to be easily portable. Also I would like it to be free and I don't want to be hung on licensing I want to create cool tools to help me and then share that with others.
&gt; "New libraries may not support Python 2 at all." We haven't seen this for anything significant or important yet, at all. That's a pretty subjective point of view. 
Looking at the post above, 2020, this may not be the case. Both projects (more so the second one I mention in my post) could very well be around past then.
This is cool - you should rig up some automated testing against [Humanize](https://github.com/HubSpot/Humanize) :)
No, I can't be sure of that. https://hg.python.org/peps/rev/76d43e52d978 
Well, I have never used another web framework besides Django, so I don't have much perspective on alternatives. I do agree that using Django for little projects would be a pain though. But, when you are familiar with a module, configuration goes fast. What ORM to you use with Flask? 
thank you very much
it was wanted to be deprecated at a time but not anymore
I would suggest to switch from custom made ``assert`` testing to "real" unit testing using a framework. Besides the fact, that you can organize your tests better, you will get nicer output and the suite will keep running through **all** tests, even if one failed. (That is also a rational reason, why you should only have one assert per test) Besides that it looks nice :-)
I know Disqus uses Django for their site, but their product commenting system is in JS right? The book advertises Disqus as one of the Django user for high performance
This should really be in r/learnpython... In your code, you have 'int( ... )'. That is where it's failing since you can't run int(4.5)--try it in the interpreter. Just change that to 'float( ... )' instead.
What /u/ApproximateIdentity said. Also, why are you screenshotting text? You can format your code by starting with 4 spaces like this. print "Hello, World" Or you could pastebin it as well if the code is particularly large. What you're doing now is just plain silly as we can't copy this.
Check out dateutil. I don't think it has all the parsing features of your library though. Suggestions: use py.test for testing. Keep tests in a sub package called "tests" under the package they're testing. Take a look at py.test fixtures and monkeypatch.
Is there a reason why the timezone offset is inverted compared to how it normally is, i.e. negative west/positive east?
I tried it with a string that includes days in addition to hours. Didn't work. from chronyk import Chronyk Chronyk('05:20:25') &gt; &lt;chronyk.chronyk.Chronyk instance&gt; Chronyk('2-05:20:25') &gt; ValueError: Failed to parse time string. 
this is cool. i see you've implemented it by having a whole pile of different format strings. i used a similar approach in [simple-date](https://github.com/andrewcooke/simple-date), but with a different aim - it parses timezones. i think it would be quite easy to add what you have done here to simple-date. would that be annoying? i am not promising i will - depends on free time. but if i do, i would add you to the author list. alternatively, feel free to steal simple-date and add it to your code! :o)
i can't remember the exact details, but i *think* there's two different conventions, depending on context. i'm not saying you're wrong, just that it may be more complex than you think (or you may know/remember more than me...)
Don't use IDLE. IDLE is a buggy mess. There are better free IDEs out there (PyDev, Spyder) and there are way better paid ones.
That's the way Python's time module does it. No idea why...
AFAIK, dateutil doesn't support parsing relative strings, like "2 hours ago", which was one of my main incentives to write this in the first place.
What would you want this to evaluate to? The xth day of the current month? The closest day that matches this? I don't really see the use case there. If there's a good reason, I'd obviously try to support it.
py 3 only ?????
Didn't know that sub existed!! And Thanks!
You want [`itertools.product`](https://docs.python.org/3/library/itertools.html#itertools.product): &gt;&gt;&gt; from itertools import product &gt;&gt;&gt; list(product(*(range(x + 1) for x in (2, 0, 1)))) [(0, 0, 0), (0, 0, 1), (1, 0, 0), (1, 0, 1), (2, 0, 0), (2, 0, 1)] I've wrapped the result in `list()` here so that there is something for the REPL to print, but you shouldn't do that in your code. Leave it as an iterable, and pass it on to the next stage, whatever that is. 
It's just a ctypes call through windll. Here's an example: https://github.com/psychomario/pyinject/blob/master/dllinject.py#L256 Also perhaps you should be injecting a DLL into the process versus simply changing memory haphazardly? 
&gt; From my perspective, things that inhibit my ability to produce something for other people to use is a big deal From another perspective, the ability for you or others to use the law to reduce the freedom of users is a big deal. It is this perspective that the GPL addresses.
If you're looking for solutions to engineering units in Python, I've had good success with [Pint](http://pint.readthedocs.org/en/0.5.1/).
Kivy is fairly similar to Android ~3 (was this honeycomb I don't remember the code words) native UI. However in the intervening time, UI design has changed significantly. The default UI in kivy looks a little old at this point, however Kivy is designed to be agnostic with respect to the look of your apps. It is entirely possible to design a UI in Kivy that looks like ANY native UI, no matter which platform: as an example, here is a quick [screen-cap vid](http://www.youtube.com/watch?v=QXazKXy_OZo) of an in progress Kivy app being built with an eye towards Google's Material Design, which of course is not yet possible to use 'natively' on Android. Kivy does not intend to recreate any platforms UI, but to give the developer the tools to ensure that on every platform their app looks however they would like, allowing for a greater degree of similarity across platforms, and giving the developer an immense amount of control over the entire visual pipeline. 
&gt; py 3 only ????? The "python 3 sucks" argument is pretty tired 
&gt; That code should be: &gt; try: fh = os.fdopen(os.open(path, os.O_WRONLY | os.O_CREAT | os.O_EXCL), 'wb') except OSError as e: if e.errno = errno.EEXIST: raise InvalidConfiguration("File %s already exists!" % path) Note that Python 3.3+ lets you do: try: fh = open(path, "xb") except FileExistsError: raise InvalidConfiguration("File %s already exists!" % path) 
How does this relate to [parsedatetime](http://pypi.python.org/pypi/parsedatetime)?
One thing does not have to suck to make the other thing preferable. 
So... you're looking to create a spam bot. Good luck with that.
Not a spambot. But posting for a company for job positions, things for sale, etc etc Just so it can auto post/bump to the top basically 
&gt; In about six years, Python 2 will stop receiving security updates. In about six years we'll see a fork of 2.x (or maybe a stable Pyston release) that will stop any sentences about it's death.
I just launched main class in python 2.7 and it works well.
Well as I was testing the library, I was seeing it more as a time delta, not a date. Maybe I got the purpose wrong : ) Here is a example case: a user wants to run a job for X time and asks for N number of processors. We want to check that the combined number of CPU hours is below 1000. 
It depends on how efficient your algorithm will be.
[Also posted on /r/learnpython.](http://www.reddit.com/r/learnpython/comments/2ghcal/type_i_vs_type_ii_errors_in_pybrain/)
Python can be used for many things, however it would not be a good choice for graphic games (though I'm sure there are some fanboys that would disagree). Python is good for scientific applications, and in general things you want to hack out as quickly as possible. I use python a lot for manipulating data that is not in a regular enough format for some of the other tools I use. For example in the past I have takin large documents contain student information and used a python program with some regex to pull out the email address of all students from a specifc contry who hadn't met certain requirments for continued residence in the US. We were then able to email all these students. Before I wrote a program, the data had to be manuel parsed for email address which is extremely time consuming and error prone. There are also a lot of thing that use python as a scripting language to modify or extend them like XChat (IRC client). And of course on of my favorites B3 (Big Brother Bot) is written in python and has a full addon system in python. It allows you to perform various administrative function in certain games that typically use a simple console for admin. I have created a lot of custom addons for that including one that allow webchat between Urban Terror (open source game you should play it) and a website. I'm sure you will think of something by the time you finish. But possible most importantly python is a great introductory point for programming much the same as QBasic was when I started program (except you can do stuff with it other than learn). An introductory point to programming is good because it allows you to get your feet wet before complicating things by getting you involved in a more complex language low level languages like C++. Good luck.
The two `scale` sentences confuse me: scale[A, B] = 1/scale[B, A] scale[A,B] = scale[A,C] * scale[C, B]
This was solid. A lot of these points are applicable well beyond Python.
Damn, sending the comment to Growl or libnotify would be a 10/10 prank!
Who is proclaiming virtualenv falling out of favor and why? It works very well.
Assuming this is a personal project to help you learn the language, there is nothing wrong with writing a file compression algorithm in python. It's an excellent language for prototyping or for high-level tasks. When you're talking about 3D games with decent graphics and a complex environment you will almost certainly need to rely on C/C++ components. It's possible to do low-level computations in C and then call these functions from python. In fact, many of python's built-in functions do just this. The reason 3D games and OSes aren't written in pure python is because a high-level interpreted language has to do a lot of extra runtime checks that eat up CPU cycles. For instance, python will always check boundaries on list indexes. Example: a = [1,2,3,4] print a[10] // this will cause an exception Checking that access takes a little bit of time, and if you're running millions of computations that time starts adding up. Now, in some circumstances you will be able to design a program wherein these inefficiencies won't affect the user experience much. But you will never be as fast as you could be with C or assembly. For this reason you should stay away from python whenever the need for efficiency is significantly greater than the benefit of a faster development cycle.
Well at the moment the constructor is meant to parse things describing a certain point in time, although parsing deltas could be worth a thought...
Realizing how easy python makes prototyping. Sure c/c++ or java might be the better language for a certain use case, but if I want to make sure that an idea is actually practical, it's extremely easy to start a base foundation python, find any issues, and then convert it over later. This and the realization of how good python is at certain tasks namely irc bots and scraping web sites. When it comes to those two tasks, I'll pretty much never use anything other than python. oh and small demo websites (usually with flask). Here are my top three projects that I like the best: 1. [/r/progether irc bot](https://github.com/projectdelphai/progether_reddit_bot) - an irc bot that lurks in /r/progether's irc chat. it's extendable with different modules. Can't take all the credit for this project though since many other people worked on it 1. [mangarecs](https://github.com/projectdelphai/mangarecs) - an /r/manga recommendation site. 1. [karzetek](https://github.com/projectdelphai/karzetek) - an rss recommendation service, maybe not my best, but I like it.
Python is nice (for me) because it's so fast to program. Applications that need to be run once or rarely benefit because you don't spend a lot of time programming. If you want ideas to practice look into /r/dailyprogrammer or [Project Euler](https://projecteuler.net/). If you have questions you can ask for help in /r/learnpython
From a quick Google, it seems that some people do it that way because of posix. No idea why exactly. But it doesn't make it any less wrong. Something like that would just make me refuse to use it.
You just described craigslist spamming. 
Came here to ask that too.
I really wish Arrow was more functional and less based around the Arrow() object. I still have to switch back and forth between datetime and Arrow most of the time and it's very annoying. arrow.Arrow.get(datetime)
I have been thrown into teaching Python will very little knowledge. Over the weekend I have been trying to complete Choice 2. Successfully completed task A using a combination of random, loops and selection statements. Need help with task B?! thought about exporting scores to .txt file but not sure how I will manipulate this to cover task 3... Help?! and inspiration needed. Help.
I thought this was one of the articles few big missteps. Wouldn't it make more sense to do something like enumerating the list_[:-1]?
I've seen it once or twice in devops discussions about servers. The thought is with docker + other tools + cheap VMs, you don't need virtualenv anymore. At least on servers anyway. I've never seen anyone mentioning that virtualenv is not needed for local development. Which means I agree with you. 
who's making the argument here ?
do to the GIL and significant whitespace, a file compression programmed in Python can only achieve a weissman-score of up to 87. Within that boundaries you are good to go.
Yeah, I fail to see how that's more Pythonic. I work with reams of Python code every day and I'd probably ask someone to change the "more Pythonic" way to something a bit more or explain why they want to use enumerate(itertools.islice()) for something that is a pretty loop structure.
I'm not quite sure what you are trying to say. Maybe you should add one more question mark? I'm sure that would make things clearer.
 # Haskell terminology - all but last item init = lambda xs: itertools.islice(xs, len(xs)-1) for i, archive in enumerate(init(archive_list)): .. If I had to guess at the author's intent, it's because he wants to use iterators over `[:-1]` which creates intermediary, temporary lists ([deforestation](https://en.wikipedia.org/wiki/Deforestation_\(computer_science\))).
There's also Eve Online which AFAIK is using CPython to run a (truly) massive online multiplayer game. I don't know about the client (that seems to be more the OP's concern), but the server is using stackless python to (I assume) great effect.
I still use it for local dev. Who needs a bunch of stale libraries cluttering up their system python install? And even with VMs, you still have to solve the issue of the version of python and packages your OS or orher applications rely upon being different than those used by your project.
You're making the argument that one liners are hard to read: evens = [x for x in range(10) if x % 2 == 0] vs evens = [] for x in range(10): if x % 2 == 0: evens.append(x) vs is_even = lambda x: x % 2 == 0 evens = filter(is_even, range(10))
&gt; Is create_terms() modifying the __main__ module's dict? Yup. You can also load a string full of clauses into pyDatalog, which doesn't require you to declare your terms up front, but it will also shove them into your namespace. It's a convenience, if a somewhat blunt one.
You are the dude that links to the same thread with recursions questions aren't you.
Basically it's trivial patch to pass test suite on py2: https://github.com/KoffeinFlummi/Chronyk/pull/2
Python runs much much slower than C/C++, ~70x slower. If you want to do something that does not require much computation, python is good, but if you want to develop a game that has constant collision detection, a physics engine, etc, then you will need to use C++. 
+1. Thanks for the heads up on [pipsi](https://github.com/mitsuhiko/pipsi), really helps clean up the growth in python based commands like flake8. (I do find it ironic that pipsi installs `click` and other libraries globally though).
List slicing isn't lazy, unfortunately. I have no idea what the original context of the code is, so eager evaluation of the slice may not even have a performance hit, but I do wish some of the great features in itertools were more succinct.
Not a big deal. I've heard Guido has a quite low [mean jerk time](https://www.youtube.com/watch?v=Tx3wDTzqDTs).
Won't help if third party libraries stop supporting Py2.x
Built an application in Python 2 that connected in four layers of metal to their respective locations on a pin grid array of over 1000 locations for a modern microprocessor and expanded it to do quality control on the power and ground connections as well. This was back in 2000. My first app using other than perl, c, or fortran. Probably not exactly what you were looking for.
That's a very useful library, but it's not the point of the post. The point is to show that that library provides Prolog-like logic programming in Python.
Could be wrong, but I'm not certain these 2 are equivalent: def fetch(path,fromTime,untilTime=None,now=None): fh = None try: fh = open(path,'rb') return file_fetch(fh, fromTime, untilTime, now) finally: if fh: fh.close() vs. the suggested alt: def fetch(path,fromTime,untilTime=None,now=None): with open(path, 'rb') as fh: return file_fetch(fh, fromTime, untilTime, now) The first will catch pretty much any exception....including failure to open the file, failure to exit properly and close the file, etc. The second version, with the context manager doesn't catch any of the exceptions the first would.... Or am I missing something?
I'm familiar with webstorm, but hadn't heard of pycharm. Thanks! 
Hah! I'm not so sure that's true, although it's been generalized to that. There are some pretty agreed-upon Pythonisms I'd say, like reasonable (fits in 80 chars, just one if, etc.) list comps instead of for loops, use of 'with' instead of try/catch blocks when working with IO, that sort of thing. I would not say it's Pythonic to swap in Python-specific modules for common computing paradigms unless they offer something in terms of readability or performance (and the latter only when necessary). Why should I have to look up what itertools.islice does just to walk a simple list with indexes? How is that better?
How old are you? I think your answer to this is pretty crucial to next steps for you.
I think he's making the argument that some people think "Pythonic" means jamming as much function into 1 line of code as possible, and that becomes unreadable sometimes. I don't think he suggested that 1-liners are always hard to read. At least that isn't what I took from it.
Can you tell me what the benefit of an `assertEquals` function over an `assert` statement? I see this as a key-word versus a third party function that doesn't comply with PEP8. There's a clear winner here, and it ain't the function. I agree with testing frameworks (I'm partial to Py.test), but that's wholly a separate problem from `assert some_expression` vs `assertWhatever(an_expression)`.
I've used quantities on the past, works fine.
This isn't a homework forum.
Well... I'm going to have to call that obnoxious. Calls into external modules should not clobber my namespace, at least not unless I ask for it. It's easy enough to return a dictionary for the client code to pass to `globals().update()`. If you think that's ugly, you can also replace your module object with a "real" class instance and override `__getattr__()`; this in turn allows client code to explicitly import things from you. Of course, if you really want to ensure a variable is created with the same name as the term, you can abuse metaclasses to that end. A term declaration would then look like this, assuming a sufficiently clever `Term` class with a metaclass: class scale(Term): pass (IMHO this is also pretty gross, but at least it's obvious a new object is created in the local scope)
This isn't going to work, all you're doing is dividing by two (the p series, apparently) over and over, then checking if the result is even or odd (the r series, I think). What you need to be doing is checking if the number is greater than each power of 2 (2, 4, 8, 16, 32, etc.). If it is, the relevant digit in the binary output takes a 1, then you subtract off that value and repeat (from largest power of 2 to smallest, of course). And definitely go over the previous lessons a few more times. 
I wish `islice()` used this syntax: islice(some_list)[start:stop:step] # returns iterator It's actually pretty simple to write such a thing: import itertools class islice(object): def __init__(self, iterable): self.iterable = iterable def __getitem__(self, index): start, stop, step = index.start, index.stop, index.step return itertools.islice(self.iterable, start, stop, step) Technically, this could also be done without breaking back-compat, but that's a lot harder to write.
Awesome...thanks for that clarification!
Pfffft. I stopped calling builtin `open()` [ages ago](https://docs.python.org/3/library/pathlib.html#pathlib.Path.open).
You need 2.x if you are using libraries/modules that require python 2, otherwise go for python 3. I stick with 2.7 because I haven't had a reason to go to 3 yet, but it's a good idea since it's the new version. 
`assertEqual` will give you some more context, like what the value was vs. what was expected. With `assert` all you get is the message and a stack trace. res = do_some_stuff() self.assertEqual(1, res) # AssertionError: 1 != {whatever res is} Sometimes using `assert` is fine: body = make_a_request() assert 'message' in body, 'body should contain message key' Has all the context you'd want/need. Obviously you can put the context you need into assert messages: res = do_some_stuf() assert 1 == res, "failed asserting that {} == 1".format(res) It's just a trade off. I use a lot of both, but tend to favor the `assert*` functions when they exist for the use case. `assert` covers everything else. There's really not a lot of `assert*` in the unittest library, but what's there is helpful. As far as third-party, [unittest is part of the standard library](https://docs.python.org/3/library/unittest.html).
*"What happens if you install a newer requests, html5lib, or colorama over it? Ill tell you what: stuff starts breaking."* Like everyone here I agree with the post, however the conclusion should read "we need a proper package manager, that can properly solve dependencies". There is no reason we should have to reinstall packages in each environment either, and why can't different versions of packages coexist?
Thank you very much for your detailed reply. I'm a big fan of Kivy, though I haven't used it cross platform at all. 
How does it deal with ambiguous dates? Is 3/2/2014 equal to 3rd Feb or 2nd March?
Okay, so that's the stuff that py.test does for me [mostly] automatically. I suppose that's why it's never made sense to use another type of assertion. Thanks for explaining.
My only kernel trick with Python would be using the multiprocessing module to stress all the system's cores to the max then attempt to pop popcorn on the CPU. Think this would be worth at least a lightning talk at the next PyCon?
Don't worry, it's maybe fancier than it sounds. Not knowing this stuff just means that you didn't need it yet, which isn't necessarily a bad thing :). And it is really just about reading the 3 papers I linked in the references and you are all set for basic applications of this stuff (there is a lot more advanced stuff out there and I also haven't had the time to dig into it - being just a "computational biologist", not a computer scientist, for me, this stuff is just a rainy evening hobby, but I find it fascinating and it can be useful here and there). Btw. I have written a [short overview article](http://sebastianraschka.com/Articles/2014_intro_supervised_learning.html) to put this into context of predictive modeling. Basically, this article is just about "preprocessing" data that is non linear as input for linear classifiers for example.
Haha, that's a neat idea. Reminds me of the days when the PS3 came out and people made this funny BBQ pictures... Btw., it's quite interesting that you just "coincidentally" (or intentionally? :P) mentioned 2 different definitions of "kernel" in one swoop other than the use of "kernel" in statistics. Namely the kernel in context of corn (or popcorn) and this magic computer program that sits between the software applications and the hardware ;)
Yeah you got my meaning right on the money
&gt; The reason 3D games and OSes aren't written in pure python is because a high-level interpreted language has to do a lot of extra runtime checks that eat up CPU cycles. For instance, python will always check boundaries on list indexes. Which is why you don't use lists. Lists are dog slow. Numpy is so much faster and someday numba may take over. It's a wrapper around numpy that supports multicore and GPU acceleration. Every 3D program (e.g. VTK) has the real work being done in C. You never have to think about it. Combine vectorization and acceleration with direct evaluation and you can really speed up your code. So instead of c = 2*a + 3*b, which requires 3 temporary arrays, you can use 1, but it requires special code (numexpr is pretty awesome).
Exactly. Explicit is better than implicit, and create_terms cannot be more explicit. Its also more concise than any of the solutions proposed. I don't see a problem here.
This seriously has a lot of application in my day-to-day work. The number of times I spend just doing pointless PCA or even try to do any form of dimensionality reduction on systems that are typically dimension invariant has driven me crazy in the past. You will see this a lot when using a Random Forest. Tons of feature classes, often iffy separability, but highly dimensionalized and good at being invariant to it. You'll get these odd groupings and it's often the case separability is honestly non-linear. Good article, fun read!
Googling for docker virtualenv gives me the following pearls on the first results page alone: - http://agiliq.com/blog/2013/06/deploying-django-using-docker/ (quote: Coming from the python world where virtualenv is ubiqitous, it's a huge relief to me that there's such a better and cleaner solution.) - http://pythonrants.wordpress.com/2013/12/06/why-i-hate-virtualenv-and-pip/ - http://www.markbetz.net/2014/01/17/python-if-you-have-docker-do-you-need-virtualenv/ - http://continuousdelivery.nl/uncategorized/using-docker-as-a-python-development-environment/ (subtitle: (or lets get past virtualenv)) - http://jpetazzo.github.io/2013/12/01/docker-python-pip-requirements/ I remember seeing some of them on Planet Python. It has been the running gag on Twitter and everywhere for months and it got especially bad since docker arrived (cf https://twitter.com/koalallama/status/510882559040184321 ). As for desktop: - I get asked *regularly* by people how to unfuck their system installs. - People widely recommend installing tools using `pip install --user` (which has the same version space and tends to break). And closingly, I already got attacked by one debian fan for that article attacking from the other side, arguing against virtualenvs. So if you wonder where the motivation came to write it, it was was months-long attrition. Im happy for you if it went past you.
superfluous comment
Apparently goole does not trust this site, anyone else not getting in?
Nice write up. Thanks for keeping it very simple and straightforward to follow. 
Report the issue here after checking http://bugs.python.org/
See this [list of common libs](https://classic.scraperwiki.com/docs/python/python_libraries/index.html) to get your started For something simple: Beautiful Soup is very popular. Also using the requests module and parsing with regex or xpath. May want to check out: [scrapy](http://scrapy.org/) 
Look at landscape2.js script in the page. It changes the data in table using that age selector. Everything is there, nothing is loaded dynamically, but it may take some work to scrap it automatically. Either scrapt the data from table and use the formulas in that script yourself in python, or use selenium to interact with the age droplist and scrape the table.
17
Im afraid they might have removed it due to lack of demand? :-/ Complete guess though, I thought its in there because I can vividly remember csh scripts (but maybe Im just confused). Considered trying [fish](http://fishshell.com/)? :) I completely agree that ksh-descendants arent in any way acceptable technology.
Checkio.org for python challenges and exercises, just doing these will teach you a lot. Also the book Learn Python The Hard Way (free online book) will probably take you further than code academy. Games, I dunno, that isn't really what python is designed for, you can do it though.
It seems like a library that handles time should necessary have the concept of a time difference ? What happens if I do: Chronyk('05:20:25') - Chronyk('02:14:09')
Use [htop](http://hisham.hm/htop/), press \ and type a part of the process name you want to watch. I use [this here](https://gist.github.com/vindolin/3b128838fb5431fa505d) to profile long running parts (don't use it for precise timing). 
I think you're overreacting a bit, for some people the presented benefits have little value (like very few tools, or don't care if stuff breaks). The bombastic title and mild rant-like writing style is what likely prompted the "superfluous" remark. Not worth [whining on Twitters](https://twitter.com/hynek/status/511830057187561472) over this.
It tells you exactly what it returns in both the code sample and the text documentation?
&gt;Technically, this could also be done without breaking back-compat, but that's a lot harder to write. Would it be that difficult? It looks like all you'd need to do is make the inner iterable another islice object to support the previous args. Eg. class islice(object): def __init__(self, iterable, *args): if args: s=slice(*args) self.iterable = itertools.islice(s.start, s.stop, s.step) else: self.iterable = iterable #Rest as in your example. There's a slight incompatibility (needed for your usage) in that passing no args is no longer an exception (just defines the full slice), but that seems fairly minor since you're opening up something invalid rather than making a previously valid usage invalid. As such, I think you could drop that in as a replacement for islice without breaking anything. 
"Open the file pointed to by the path, like the built-in open() function does" That's not a return type. That's a reference to some other piece of documentation, without guaranteeing that it returns the same sort of object. I assume it does, but it's not great to leave out explicit detail like that.
Oh man, I'm not really an expert on this stuff. You should definitly learn python as a first language it will help you understand your limitation and potential. And as for games, I guess it depends what kind of games. You know I would probably use java if I was going to make a new tetris game or something, but I would use C++ or possible even C if I wanted to make a good first person shooter where performance is really important. I would just worry about learning to program, and as you understand it more you will get a better idea of what you personal can do with it. 
Is there a text version? 
Different versions of packages can't co-exist because the Python runtime doesn't enable the ability to (sanely) load multiple versions of the same package at once. As it stands you can only (sanely) have one version of a thing importable by ``import html5lib`` in one Python process at any one time. As long as that remains the truth it means there will always be a requirement that only one particular version is available at any one time. Beyond that there are two main methods of handling selection which versions are available. One is the the "virtualenv" style which uses isolated environments on disk which each have their own site-packages and function as sort of mini installs of Python. The other is setuptools-style which doesn't install *anything* directly to site-packages but instead makes versioned directories for each thing (like html5lib-0.999/) and at runtime it will munge your sys.path in order to "activate" the correct one. The setuptools style way would allow "installing" into a system without an explicit virtualenv, however it does so by essentially creating a virtual environment in memory at runtime which comes at fairly hefty performance cost and has a lot of nasty edge cases which is why virtualenv was created in the first place.
Why don't you just use TLS?
&gt; without guaranteeing that it returns the same sort of object That's never guaranteed. It obviously returns a "file like" object, just like open, but it doesn't have to be the same. It could be any number of io.* classes or a [duck](https://en.wikipedia.org/wiki/Duck_typing).
string.Template may compile templates once: https://docs.python.org/2/library/string.html 
Well I think you just proved you can't even take content-related criticism, unless it's sugar-coated with flattery. How about you just ignore criticism you don't like instead of throwing little tantrums of butthurt-ness and calling names on people you can't accept criticism from.
Sure. So that should be in the docs there. Function docs that rely on other function docs are lazy and make it harder to learn the language.
The main problem is that you can't use negative indices in the customary fashion, no matter what's the syntax (and I'd say that your syntax is worse than a single islice call). And you fundamentally can't solve that problem in an acceptable way because input iterators (in C++ terminology) simply don't and can't possibly allow you to ask for the "n-th from the end" item. Even if you try to do it inefficiently, by using an n-item queue for lookahead, that would produce unexpected results if you, for instance, ask for `islice(file_iter, 0, -5)` only to discover that that actually consumed and discarded those last five lines. That's actually a good thing for iterators, IMHO: see where the attempt to accommodate for types of iterators beyond input in a single abstraction got C++. But it would be nice if we had a parallel "view" abstraction which provides random access through a lightweight wrapper (and is implicitly convertible to input iterator, of course) -- we already have dict's keys/values/items views in Python3, some bits and pieces of the buffer protocol, but no unified interface + a bunch of built-in combinators a la itertools.
You probably mean numba not bokeh, which is a plotting library.
awesome :) ty!
Cool! This and [srcml](http://www.srcml.org/) (C, C++, C#, Java, or AspectJ to xml convertor) mentioned on that page seem like amazing building blocks for plugins and other custom tools. I've seen refactoring tools before (they're often baked in to eg. eclipse) but never something that allows you to make your *own* easily.
Start with python. C++ and C# will likely only confuse you to a point where you get frustrated and give up. Learn to program now with python, learn to program games in the future with other languages.
Will look into selenium. Thanks! 
Is this really still something people struggle with? Download the source, unpack, run $ python virtualenv.py {target dir} ... and you have a virtual environment. I really don't get the hoopla.
Did not know about the * operator in strings. Blew my mind a little.
Your question is too vague I'm afraid; for example &gt; 2.Secondly, how can I store the activity in redis i.e what data structure in redis is used to store class such as Activity. What data structure in redis should you store a class? Do you know how redis stores data? What have you tried already? Where did it get stuck? Your question is basically asking someone to design and build a generic newsfeed app. Which, I suppose, if someone wants to do that, great. If you're truly trying to learn, however, try and ask specific questions.
Why?
I love it when "big shots" talk in code. He is referring to ftplib where you can set up secure control connection by using TLS or SSL. He forgot to say why Transport Layer Security applies to your problem. Here is a place to start, it has some trivial code examples: https://docs.python.org/2/library/ftplib.html Here is an explanation of how TLS is just an upgrade of SSL: http://en.wikipedia.org/wiki/Transport_Layer_Security If you google "python examples TLS connections", you get more code; here is a result on turning a TCP connection into TLS: https://docs.fedoraproject.org/en-US/Fedora_Security_Team//html/Defensive_Coding/sect-Defensive_Coding-TLS-Client-Python.html Happy coding 
What happens if you have libraries A and B depending on different versions of a library C and you pass an object from A's version of C to B's version of C? This inevitably has to produce some issues.
There is not a single instance of constructive content-related criticism in this thread. I don't see how /u/hynek could possibly show himself incapable of handling it.
ironpython + visual studio is pretty straight forward, but its .NET/MONO only which is another dependency to depend on.
The answer is runtime errors... maybe. Depends on how compatible the two versions of C are.
I myself was looking for one, but couldn't fine one.
Wow, thanks. I guess that settles it.
&gt; comes at fairly hefty performance cost and has a lot of nasty edge cases which is why virtualenv was created in the first place Which is precisely my point. The fact that the good solution is currently broken doesn't make the clunky virtualenv less of a bad one.
wait really? Do you have any sources that I could read? Cause this sounds fascinating and really interesting. I didn't think this was possible.
&gt;  Eww...
Agreed. This was an attack piece, written so that the writer could show how smart he is by being nasty about this piece of code. Don't like it? Don't use it. No need to be such a jerk.
&gt; If you want to keep order, just use a list of pairs like (1, 2). Lists always stay in the same order. Or a `collections.OrderedDict`?
&gt; AST does not preserve comments and source code formatting. That's only a half truth OP! Ast nodes have lineno and col_offset attributes. Also it's fairly easy to use the lib2to3 library to manipulate code from python to ast and back to python and preserve the comments and formatting of the original source code file in the process. Regardless this is an interesting take on the problem using xml. 
This is programming 101.
I feel like you should have mentioned the join operator on strings. '+' is easy to do but it get's very messy very quickly :(
Just waiting for the text version.
You forgot the "Hello, world" snippet in your Python 101 tutorial. Also, this is spam.
That's only half truth that lib2to3 can preserve comments :) Try this: d = {} d.has_key( # comment 1 'a') # comment 2 
Thanks! I'll check those out. Part of my googling problem was that I didn't know what to google.
Very nice and timely thanks.
It's also slow.
I would take a look into using requests and BeautifulSoup. And once you feel comfortable in that I would take a look into Mechanical Soup.
Same boat as you, but at least we can use Excel :D 
You sort of contradict yourself when you say "strings are immutable" and then proceed to assign a new value to a variable that holds a string. I think all you're missing is a statement that you're essentially throwing away the old value of necklace and creating a new necklace with your addition (possible as demonstrated with some handy id statements.) Or maybe I'm being a pedantic ass. Up to you. 
If you end up not wanting to write a scraper you can give https://scrape.it a try. It's closed beta so you need an invite but I stopped writing web scrapers all together, nothing wrong with that but sometimes I just want to get the data and don't want to maintain a separate python script around it.
For me, this is actually the reason to use py.test over unittest. 
What platform are you on?
Python is a good first language to learn programming, and there are tons of free Python tutorials and how-to guides online. Here's one place to start: [Python-guide.org](http://docs.python-guide.org/en/latest/intro/learning/)
windows 8.1. here's the code: http://pastebin.com/jr1XvNjX followed by red error text
Only in some implementations. String concat is internally converted to ''.join in CPython 2.5+, as far as I know.
I'm on the same OS and Python version and it works perfectly for me. Try reinstalling Python. You can also hit alt-M and type "turtle" in the box to see if it can find the library by doing that.
The red error text is the most interesting part. :-) This code isn't very fortunate (there's no `position` method in turtle, and those tuples have no effect), but this code works - turtle draws two lines. OK, most important question: file, that contains that code, is named `turtle.py`? That would cause problem. edit: My bad, there is `position()` method - it returns position as tuple. So i'm guessing, that you pasted code from interactive session (from book/website) to file named `turtle.py` and tried to run it.
I'll change the name. also, [here](http://pastebin.com/MpcFuSu6) is the red text. and here's the [example](http://pastebin.com/5eE3hDFC) i was given.
I played with this a bit and I have the same question...of course I could have set it up wrong. I think this would be advantageous if you could call your script as a direct executable... $ my_python_script versus $ python my_python_script ...but I was not successful in getting it to work this way. Not to mention it seems like a fairly minor detail. Another possible advantage would be controlling multiple entry points...but at that point you probably should be developing a front-end to manage the user experience...so idk.
Another thing is that you can speed up the video 2x if it is too monotonous. And, also, VLC media player lets you speed up videos as well with Youtube links. Can make online lectures bearable.
noted. trying. 
It worked, sweet moses. Now to make it draw a cube. Thank you, i had to not name it turtle.py
You mean cube like cube in 3D space? I hope you know, that turtle walks (draws) only on 2D canvas. :-)
Yeah it sounds like you may just not have something setup correctly. I use entrypoints all the time and it works just fine by calling the entrypoint name, even on Windows. Now to try and answer the question of 'why'. Basically setting things up this way ensures that: * The script ends up on `PATH` * The shebang (nix*) or executable (Windows) are pointing at the right Python interpreter. * The entrypoint gets installed with your modules so you don't have to worry about someone running your script from a location where your modules can't be found 
It won't, necessarily. It will be easier on *you* in the long run.
Good-ole FUN stack :P
Specifically, why is this better than using `scripts`?
I am confused but can't you just define a function with a for loop that prints "Hello World' 1024 times?
He doesnt want a loop that the thing. I would just used the loops and called it a day. 
something like this will print out 10 times defprintTwo(): print("Hello World") print("Hello World") defprintThree(): print("Hello World") print("Hello World") print("Hello World") print("Hello World") printTwo() printThree() printThree() printThree()
Hehehe: import sys sys.setrecursionlimit(1025) def f(): print "Hello, World!" f() f()
Looks like you need a combination of functions. For example, if you had funcA(): print("Hello World"); print("Hello World"); print("Hello World"); print("Hello World"); funcB(): funcA(); funcA(); funcA(); funcA() This works because 4^5 = 1024. 
* 1024 = 2**10 * 20 = 2*10 * Think about this: def f1(): print("Hello World") print("Hello World") def f2(): f1() f1()
/r/learnpython
I got it. I can rub it in this professor face !! HAHA THANK YOU GUYS ALL 
Code Academy has a good free tutorial on python basics. 
First, this is really a question for /r/learningpython. Second, it's because your if statement is doing this: `Q or q. If ratingSystem equals Q` When you really want this: `if ratingSystem equals q or ratingSystem equals Q` Which amounts to one of these statements: `if ratingSystem == "Q" or ratingSystem == "q"` `if ratingSystem in ("Q", "q")` You should read up on how Python handles order of operations. Finally, **don't expose personal details in a public posting**.
When you write: if ratingSystem == "Q" or "q": it is the same as if you had written if (ratingSystem == "Q") or ("q"): and since Python interprets a non-empty string as being True, this is the same as if (ratingSystem == "Q") or True: You likely know that anything or True is True, hence this explains why your first if statement is always executed. 
I made a few toy apps with it, but moved on to learning native development in Java. I'm not nearly as fast with it as I am in python, but I like the final look and feel much more. 
that's 4 * 5, or am I missing something?
[I made it work](https://imgur.com/yx4vlZa). Thank you again. You may have saved my college career.
You don't have to play with Windows. And the shebang is always correct.
I know...I was just being silly.
You can call it like that, provided your $PATH is correct. It should contain the directory with the python executable on Linux, and the PythonXY/Scripts directory on Windows.
When is the shebang incorrect? I've never tried to target Windows for my apps, so I'm unaware of what difficulties that brings.
I believe the shebang is changed at install, but this may not necessarily be the case. I've seen hacks to do this somewhere. Windows difficulties: either this, a hacky .bat file, or naming the launcher with .py(w) in the end. Otherwise, it won't work, because file extensions.
Ask in /r/SublimeText as well, they might be helpful.
I dunno about your environment, but if your remote server is running an SSH server, you could try the paramiko library to do a SFTP transfer. It's pretty simple to implement and will encrypt your file during transport. [http://stackoverflow.com/questions/3635131/paramikos-sshclient-with-sftp] (http://stackoverflow.com/questions/3635131/paramikos-sshclient-with-sftp) Personally, unlike the example I would use key files to authenticate in order to avoid needing to hard-code a password into your script. here is some excerpts of a script I use to transfer files over the network: import paramiko local_file = '/home/manbart/somefile.txt' remote_file = '/home/backup/somefile.txt' user_name = 'manbart' key_file = '/home/manbart/.ssh/id_rsa.pub' remote_host = 'remote.mydomain.com' ssh = paramiko.SSHClient() ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy()) ssh.connect(remote_host, username=user_name, key_filename=key_file) sftp = ssh.open_sftp() sftp.put(local_file, remote_file) sftp.close() ssh.close() This assumes some familiarity with SSH though. [http://www.linuxproblem.org/art_9.html](http://www.linuxproblem.org/art_9.html) for some more info on using key files for SSH login **edit** Also, for what it's worth, I think learning to set up an OpenSSH infrastructure will be easier than using OpenSSL. Generating keys in OpenSSH is optional, simple username+password can be used if you like. Using OpenSSL will require you to generate and sign certificates, which is a little more complicated in my opinion.
You don't need to name your file `__main__.py`. I've never seen it done like this, and there's no reason to do it. If you invoke the script via python &lt;file&gt;, or python -m &lt;fully qualified name&gt;, the `if __name__ == __main__` construct will suffice. The context in which the file is being invoked is what's important. Edit: I'm not saying it's a *bad* idea to name it that, just saying that it's not necessary as far as I know. Edit: I stand corrected. The only time it's useful is when you want to invoke a *package*. Learned something. Upvotes for all.
Code academy is an excellent place to start.
In Python3.4, on my laptop, spam1 is 0.152 seconds, and spam2 is 0.326 seconds.
A list of appids is a great idea, but I beg to differ on the while loop design. Just run the script as a cronjob ..if you're on Linux and OSX. I don't know if Windows does cronjobs. This way you don't have to waste CPU cycles on while-loops. If you are going to use event loops, I would strongly advice you to use Twisted. It's a great networking library with a really robust event loop. 
Ha. I did not even know of the existence of this "cron" thingy. Seems to make a lot more sense than halting execution for a couple of hours.
Asking if you can ask rarely works out. Try it. 
Sorry I was not clear. You need to apply a fix! It would be too easy if you dont re-write/transform anything. $ 2to3 test_source.py --- test_source.py (original) +++ test_source.py (refactored) @@ -1,4 +1,3 @@ d = {} -d.has_key( # comment 1 - 'a') # comment 2 +'a' in d # comment 2 Note how "comment 1" is gone.
I'm the author, and wasn't planning to make a text version; *I* don't even remember everything I said! However, I am planning to do more free Webinars and paid courses, so you're welcome to join me in future sessions. You can check out my upcoming schedule at [my site](http://lerner.co.il/courses).
I'm glad so many people who couldn't attend are enjoying the Webinar! I had so much fun doing this, I'll likely do more of them, probably every month or so (in addition to my for-pay classes). 
&gt; Different versions of packages can't co-exist because the Python runtime doesn't enable the ability to (sanely) load multiple versions of the same package at once. good. imho the node.js-approach is insanity. i run everything globally installed and fixed the two problems i had by updating (took 4 days for a new minor version to come out) and by fixing it myself, sending a pull request, and then updating (took a week, two hours of which was working on the fix), respectively.
which is only one reason why i prefer pythons approach of: things not working with the newest version of everything else is a bug
id rather create some list view: class SlicedList: def __init__(self, l, start=0, end=None, step=1): self.wrapped = l self.start = start self.end = end if end is not None else len(self.wrapped) - 1 self.step = step def __getitem__(self, i): if isinstance(i, slice): return SlicedList(...) #we actually have to calculate a new start end and step here from our own and the wanted one, but im too lazy else: mapped_i = self.start + self.step * i if (self.step &gt; 0 and mapped_i &gt;= self.end) or (self.step &lt; 0 and mapped_i &lt;= self.end): raise KeyError('Index {} out of range {}'.format(mapped_i, len(self))) return self.wrapped[mapped_i] def __len__(self): return (self.start + self.end) // self.step def __iter__(self): return ... # you get the idea then we could do `SlicedList(l, end=len(l) - 2)` as well as `SlicedList(l)[:-1]` /edit: the math in this code is full of off-by-one errors :)
There are way fewer jobs, but they're usually more interesting and better paying. PHP seems to attract the [client from hell](http://clientsfromhell.net/) types.
&gt; It would be nice if you could supply like a list of appids for games that you want to watch If you wishlist a game on Steam you will get an e-mail from Steam whenever that game goes on sale. I've gotten e-mails for discounts ranging from 25% to 90%. The only time I didn't receive e-mails was during Steam summer/winter sales.
&gt; This way you don't have to waste CPU cycles on while-loops. If you are going to use event loops, I would strongly advice you to use Twisted. It's a great networking library with a really robust event loop. I think you might be over-engineering a bit. `while true, do stuff then sleep`, would work fine and not waste cycles regardless, cron would be easier but then you can have a bit of a persistence "problem" if you wanna track changes in price
How much per month do you earn, freelancing for Python?
The while-loop solution is actually going to waste fewer CPU cycles than the cronjob.
Might I recommend a microphone? A different one, that is.
openSesame also has a [forum](http://forum.cogsci.nl/index.php?p=/categories/opensesame). Doesn't look too active, but could be worth a shot
 [kwpolska@kw-cassandra /tmp]% mkdir pyp [kwpolska@kw-cassandra /tmp]% touch pyp/__init__.py [kwpolska@kw-cassandra /tmp]% python -m pyp /usr/bin/python: No module named pyp.__main__; 'pyp' is a package and cannot be directly executed
Once you have put the list comprehension inside a `dict` call, you might as well (and should) drop the list brackets and make it into a generator comprehension!
Very good point! Thanks for the suggestion. 
This also addresses price drops which steam won't email about. 
This is a strange place to ask this question. Why not join the [Kivy Users Google Group](https://groups.google.com/forum/#!forum/kivy-users) or the IRC channel (#kivy on Freenode)?
In fact Kivy started before iOS or Android existed as a desktop (Windows, OSX, Linux) GUI framework for Python. The mobile pieces were added later, and as you've discovered are not actually a part of the Kivy core. This is why I say that Kivy itself does not have the holes, it is the mobile parts that are not as refined. [A talk I gave at PyOhio](http://pyvideo.org/video/2825/getting-python-all-up-in-your-mobile-with-kivy) a few months ago may make it more clear.
Dictionary comprehensions are so cool. { item.split('=')[0] : item.split('=')[1] for item in query_string.split('&amp;') } Good god! Those are nice.
I dont want to use ftp. The project is a resume builder and I just want to make a light weight dropbox app in python that runs in the background. Currently I am able to send files via command line but now my goal is encrypting all communication using certificates. Any ideas ? Should I use ssl or openssl?