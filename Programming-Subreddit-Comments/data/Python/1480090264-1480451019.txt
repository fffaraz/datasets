Pizza Hut?
fsencode/fsdecode() are for situations where you have a function that doesn't return bytes, and you might have files with invalid byte combinations. Hopefully there are not many cases where you need to use it.
True, but it does mean that they are not flat out ignoring 3 which had been my concern some months ago.
I work at a startup and before i got there all their analysis routines were people-intensive. Move this file out of this folder, run this program, move the file back into the folder, run this other program, upload the data to the network then import it into excel, etc. all for one data set. fuck. that. i wrote a script that takes care of all the piddly shit so you can just run it and walk away and in 5 minutes *ding!* results.
You should use virtualenv even with system python, the only time when you might avoid it is when you pass --user to pip. Otherwise you are risking overriding files installed by system packages, which might lead to issues.
I think you mean not all byte combinations are expressible in Unicode, which is true, because there are invalid combinations, but Unicode is fairly complete and should have all languages that are written today.
Because real companies have many projects that use shared libraries which makes it hard to move them. If you move the piecemeal, because you end up with this mix of code that is a mess. Trying to move them all at one time is difficult because of the shear size of it all. Basically, the Python core devs have proven they understand little about real enterprise usage. Python is a nice toy language, but until the core devs start being responsible, it is nothing more.
Maybe type checking will finally help people recognize that Python is not just good for coding small scripts!
First of all, **excellent** tutorial, definitely the best on the subject and the only one that gave me a proper insight of asyncio. For people that are a bit confused,I'm thinking of the following analogy when considering sequential execution concurrency and parallelism: Imagine you have 3 glasses and want to fill them with Coke. 1) **Sequential**: You have to fill one glass completely before you move on to the second glass. When you pour coke, you have to wait for the foam to settle down (i.e. the task of pouring is **blocked**) to continue pouring coke to the glass. 2) **Concurrent**: You fill one glass but when foam starts to form, you start pouring on the other glass. This way you don't have to wait for a certain task to finish but instead of waiting, you continue with another task. However, note that you always are pouring coke to one glass at a time. 3) **Parallel**: You call some friends and hand them a bottle. All three of you are simultaneously pouring coke, each one in his own glass at the same time.
So two years ago? 
Yeah, probably. I thought OP meant it to vocalize his own skills in comparison with other "real" developers. Which says more about me than about OP. Oh well
I'm sticking to Win7 till EOL.
So like airdrop kind of but unencrypted?
&gt; the thought of updating it fills me with dread Update it to work with the latest Python 2 and do a separate version for Python 3.
I gotcha. I ran into this recently when I was using some libraries which were written years ago for Py2 (I was using 3.4). It was explained to me that I had to add a "b" to the front of the string parameter because the function was looking for a byte array, not a string.
...eh, a good chunk of the point of homework is to grind those equations and thinking into your head. Even if it really is easy and easy to script it helps to have that muscle-memory level understanding of the basics when you get up to more complex stuff. That said you have other classes and time allocation is always a struggle so I can see both sides here.
I've been on that at work. We do have legal reasons for asking a user for piecemeal names (e.g. First middle last) but I've been trying to sell a canonical name field for several months. 
½ is a great nit in fact. Encoded as latin-1, it's "\xBD". Decoded as unicode code points, it's also "\xBD". But encoded as utf-8, it's "'\xC2\xBD'". Meaning if your app mixes it up, and treating latin-1 bytes as a "string", then outputs it thinking it's utf-8, you're now missing the "\xC2" bit, and will get a decode error on the next trip. Or if it mixes it up the other way, you get a spurious "\xC2" byte injected.
As I said, the systems are completely offline. We're allowed to burn code onto a CD and bring it in, and I've pushed it with what I bring in, but I'm not willing to push it that far. 
[Proofread Wikipedia](https://github.com/priyankamandikal/arowf) (my GSoC student Priyanka Mandikal finished it.)
At least one aspect of it: I usually check for movie ratings before watching/acquiring, so I created a Flask web-app that scans Rotten Tomatoes and IMDB for newly listed movies and gives an average rating of the two (actually three) scores. My first ever app. I'm just now getting into Bitcoin and I kinda want to write a trading bot.
Questions like these are better suited for /r/learnpython. In this case, the **print** function is being passed two arguments. The second one is obvious - it's a keyword argument "sep" with an empty string. The first one is `*range(1, int(input())+1)`. Normally the `range` function gives you an iterator of integers between two values. The `*` "unpacks" a list for use as positional arguments. So the command `print(*range(1,5))` would take an iterator that produces the list `[1,2,3,4]` and essentially call the command `print(1, 2, 3, 4)`. But this code does something really stupid which is to put `input` in the middle of everything. That's not safe, and it's hard to read and debug. When you run this line of code, your interpreter will hang until you type something in.
Years ago I wrote a little script that would translate SRT subtitles using Google Translate API. I really wanted to watch an anime which I could only find with Spanish subs. It worked out pretty well and it was a great feeling to finally solve an actual problem of mine using Python.
You should be more specific — what parts do you need help with? I'm assuming that you're referring to the asterisk. If you use an asterisk in front of an argument when calling a function, that activates a feature where the specified argument is treated as an iterable and the items it yields become positional arguments to the function. For example: def foo(a, b, c): ... args = ['blah', 42, 3.1415] foo(*args) The call to foo is equivalent to `foo('blah', 42, 3.1415)`. Lists and tuples are the most common types of iterables used for this purpose, but a range object is also an iterable. 
you are in luck sorted(seq, key=lambda x: str(type(x)))
Exactly! 
"SpaceYes"
python programs
I built a dashboard for our lab environment at work, every hour it polls the whole IP address range and then using fping, nmap and queries to the API on our appliances determines which are currently licensed and what version of our software is running on it. Makes finding a system to test against much faster than our current hip chat bot method
Wrote a script to hash all accessible files on a network share, and work out what / how much was duplicated. Took a while to run - but revealed over 50% was copied. Was interesting, but not enough to worry about optimising things!
must have [topical logic](http://www.nameamigo.com/#/custom-words?words=trump) built in too, some of these are priceless! 
I realize more often that my job is to take away the general case, so i can spend more time on the corner cases.
Do MKVs contain the full font? IIRC PDFs contain only the subset of characters that is used in the document, so you end up missing uppercase z and the number 6 and so on.
I was sick of manually copying files from a network drive over to a local drive. Just this last week, I wrote a script to copy files from the network drive that have been modified since the last copy to the local drive, using `shutil`.
https://github.com/Python-scripter/PySpace A Python script that looks for duplicate files on my computer and remove them.
I love to read pen and paper RPG rulesets. Whenever I find a web page for a free p&amp;p it takes about an hour of my time to search for all its sub pages and download all PDFs on there. So I wrote a script that handles this for me. Traverse an URL, follow links, download every PDF you find.
This is really cool! Simple and expressive - great job on this!
That's really cool! Do you mind sharing briefly, on a high level, how the script works? Or what key libraries were used?
Everyone uses PyCharm.
Yeah, as someone who uses OpenCV as a teaching example, I can say that the Python 3 tutorials are still in short supply. Though to be fair, it was hard getting OpenCV to work with Python 3.x. But that was back in 2014...now, Anaconda makes installing the opencv wrapper for 3.x fairly straightforward. I think updating for 3.x (and for OpenCV3) would be a useful resource.
Usually full fonts but with few characters. They typically need fonts with some stylizations, like 'creepy' looking, or 'digital' looking, but such artistic fonts are underdeveloped anyway and have small file size.
Python3 is a ghetto.
You should go with that.
Thanks. Yes, doing it in steps seems like the best way forward.
A python script that pretty prints json. It aligns colons and does line breaks only when appropriate. Used as a command you can pipe json into it and it will write pretty printed json to stdout. [pretty_json.py](https://gist.github.com/mbarkhau/c9eb067454ba16cdc03818e8f2ec26b4) Sample Output [ {"menu": { "id" : "file", "popup": {"menuitem": [ {"onclick": "CreateNewDoc()", "value": "New"}, {"onclick": "OpenDoc()", "value": "Open"}, {"onclick": "CloseDoc()", "value": "Close"} ]}, "value": "File" }}, {"widget": { "debug" : "on", "image" : { "alignment": "center", "hOffset" : 250, "name" : "sun1", "src" : "Images/Sun.png", "vOffset" : 250 }, "text" : { "alignment": "center", "data" : "Click Here", "hOffset" : 250, "name" : "text1", "onMouseUp": "sun1.opacity = (sun1.opacity / 100) * 90;", "size" : 36, "style" : "bold", "vOffset" : 100 }, "window": { "height": 500, "name" : "main_window", "title" : "Sample Konfabulator Widget", "width" : 500 } }} ] 
Seconded. 
"Enter your words/setences"
Lots of coders have cs degrees, and at many programs they would have had to study language design. That makes what they have to say useful and informative. If you think talking about something you have no control over is egotistical, what are you doing here debating about since other guy's blog comments? Are you a mod who can actually do something?
Good questions, I'll like to know too.
The is true. The angular team is a model for how to actually change a "language" dramatically the right way. Also ecma guys and typescript with the transpilers
How often does someone brag about doing sometiing the hard way
Since you won't need advanced features (like inheritance), this could be done in pure Python without much hassle, no need for adding another dep to the project.
Exactly this. I earn my living by playing with excel and writing reports, not by playing with an IDE. 
 As a Debian unstable user I sometimes need to downgrade packages, if they are not in the other branches I have to manually search for the package at the Debian snapshot repo.I wrote a python program that gets the info I need from its api from the my termunal and appends the right entry in my .list file 
Naive argument. Type hinting is a very long time away from giving benefits right now. Witness how long Python 3 is taking to make inroads and add how is static-typing-disliking ingrained in the community. I think it's fairly possible that it will never be commonplace enough for it to be on par with say, Java's primitive type system. While I am in the static typing camp (but I like Python and code it everyday), I can accept that the question of static and dynamic is not an objective matter, though. 
https://www.logilab.org/project/logilab-constraint
This is super basic, but one day I thought to myself, "It would be really handy to have a very simple key-value store that works from the command line," so I created a little script that just reads and writes to a file containing a dictionary. I then combined it with a small shell function to let me set a working directory for different project and cd into them easily.
Wrote something to delete all posts from a subreddit I moderate.
Wxpython does system trays and I think context menu is possible too. 
I find paragraphs like the following pretty reasonable "Once a year I go through my Python book and I try to convert all the code to Python 3 as a test. I do this with the eye of a total beginner, looking for things that will trip them up and cause problems. Bad error messages, confusing syntax, broken libraries, and inconsistencies. Every year I run into nearly the same problems: strings are difficult to use, error messages don’t have variable names, libraries don’t really help with strings, and there’s too many inconsistent string formatting systems. So I decided to see again what it would take to make my book Python 3 and ran into the same issues all over again." and his characterisation of the blind leading the blind here on reddit is pretty true in my experience.
[POS](https://github.com/aiforai/GSI)
have you looked at the [PRAW](https://praw.readthedocs.io/en/stable/) the python api for reddit? this can really simplify your needs
Yeah, but Brainfuck is also a terrible target for a compiler. And compiling a more friendly language down to Brainfuck would miss the whole joke aspect of esolangs, whereas something like INTERCAL, Q-BAL, *W, LOLCODE, &amp;c., preserve the joke aspect. Usability rather misses the point of esolangs. INTERCAL isn't really a difficult language to write an interpreter for, though. The only real difficulty is in the lexer, but once you have an AST, the rest is easy.
Working on some research to write an ebook on the basics of how to use python to scrape ecommerce sites. Does anyone have any pointers or tips on this? 
to my understanding its this: Every file has a unique checksum, sometimes referred to as Sha1. Basically, its a unique signature for a file by cryptography on its binary files. Its referred to alot when you download say windows 7 install files but wanted to check the integrity of the source to know its not corrupted and or has viruses in it So that every file has a unique Sha1 value zeroconf is how the two computers are communicating the files. Its similar to TCP (packets of data sent) / IP (figure out where its going) works. http://i.imgur.com/Hb32jcK.png ^ should be how it works I think
Disclosure: I'm one of the authors of The Python Apprentice. I was disappointed to see the furore around LPTHW and Zed Shaw's attack on Python 3. I've been developing with Python since Python 1.5.2 (around 2000) and programming exclusively in Python 3 for five years now, since Python 3.2. Python 2 seems like a distant memory. My only recent contact with Python 2.7 is occasionally tweaking my own open source code so it so it is backwards compatible with Python 2.7. Python 3 is the only viable future.
I’ll add two more: * 25% of the book are boring print exercises * the book uses outdated practices: distribute, easy_install, nosetests
Wrote a program that would press the windows key twice every 5 minutes so that my computer wouldn't log me out when idle. Our company policy logs you off when idle, but sometimes I need to be able to see the screen but not be at the computer for more than 10 minutes... drives me nuts. So I fixed it. Don't tell IT...
I wrote a one time script for my work to fill out a PDF form for machines that we were requesting approval to be destroyed. The form has to be filled out based upon the funding project and could only have a max of 4 machines listed. I took the excel tables we had it the machines for disposal and the other one for the funding into and imported it into SQLite. With 2 queries and a couple for loops it would generate FDF files which would be the data to fill out the forms with. Using PDFTK to combine it with the actual PDF. Reduced the workload from filling out about 100 machines to barely anything. My boss asked me to put it in the internal wiki but it needs a lot of work because importing is a pretty manual process to a random person looking to use the script.
Converting text based lyrics and chords to chopro and then to html for my songbook. Wrote a double entry accounting system 30 years ago mostly in AWK. Been converting (slowly) to Python. Various file conversion programs. Like digging XIF info from media files, table formats (html, tsv, etc.), building web pages from tabular data. Bioinformatics files. So no big whoop.
Minor correction: in this case the SHA1 hash refers to the filename, not to the file contents, because obviously Bob cannot calculate the SHA1 before he has the file, but both Bob and James know the filename.
There is hardly a consensus on Python only being a toy language. My paychecks say otherwise for sure.
Python 3 has much, much better support for characters beyond the ASCII set appearing in strings. Unicode strings are a wholly separate type in Python 2, but there are only Unicode strings in Python 3. It does mean that someone using a non-American keyboard isn't going to randomly crash your program by inputting something sensible for their locale. 
Man is told his work is obsolete, pitches old man fit. Film at 11. 
2017 will be the year of Python 3, imo. By 2019 if you're still using Python 2 you will likely be in the minority and due to legacy or political reasons.
Just a (new) fan. I came across it while collecting examples of Python in academic teaching.
&gt; microsoft access database files sigh why ?
There's a program called caffeine that does the same thing. Stand alone executable you should be able to run if your IT ever finds out. 
yes, gspread uses sheets api v3. I needed some functionalities which was not offered by v3 so wrote pygsheets. The basic interface is similar to gspread , with additional functionalities like batch updates, sharing from terminal, pandas support, exporting etc. Also v4 supports more features like graphs , formatting which i haven't implemented.
a script to parse the latest weekly ad for the grocery store across the street to see if there are any current deals on hot cheetos
https://docs.python.org/2/library/2to3.html
hey i guys i dont have a problem im looking to make a simple program that helps me carting shoes that are limited before others do.. so who can help
Really it is time to move on.
Outlook can't even use it's built-in search on the webapp effectively, so let me know if you get anywhere.
His book is not one I've ever read, but have seen it recommended numerous times. After reading that list of complaints about his book, I'm rather embarrassed for our community. I'll make sure to not ever recommend it. Zed's dead baby.
You can try ``bottle`` it's not just a HTML template, but it's a single file package.
&gt; I'm kind of confused of why the 2 vs 3 debate is still continuing. Do some people think that eventually Python 3 will be cancelled and we'll all go back to 2? I have no idea why the debate goes on. It reminds me or the sore loser mentality that has hit America. &gt; &gt; And his response seems kind of...juvenile? I mean, the basic tone of this is "You are all a bunch of 'lonely coders' and you don't matter because my sales haven't budged." Yep the general feeling you get from the Python 2 community is that they lack maturity and can't take on adult responsibilities. &gt; &gt; I get that he feels that Python 3 doesn't make for as good of a tutorial, but regardless, why not teach to the future? Or heck, he can do what he wants, but then again, a subreddit can also decide that it would rather recommend a different book. Why put this down as some sort of fascist "censoring" made by a "tribal" community of &lt;strongly implied&gt; amateurs? There are schools that start new comp-sci students out on C++. I'm not sure why the Python community has to embrace the imbeciles out there that want to be coders. Programing isn't for everyone and we shouldn't try to make it so. Beyond that with all new or updated programming languages it is better to embrace the positives rather than to dwell on the negatives. The C++ community does this with each new revision to their programming language and programmers using Apples new Swift have massively adopted that language. Both Swift and C++ have their dark spots too, but it simply doesn't pay to dwell on them. Ideally you program to minimize the impact the horrors of the language.
I wrote a hacky script to randomize my wallpaper! #!/usr/bin/env python3 import os import random from subprocess import call EXTENSIONS = ("jpg", "jpeg", "png") BASEDIR = os.environ["HOME"] + "/Pictures" WALLPAPER = BASEDIR + "/wallpaper" WALLPAPERS = BASEDIR + "/wallpapers" def main(): file_list = [f for f in os.listdir(WALLPAPERS) if f.endswith(EXTENSIONS)] new_wp = random.randint(0, len(file_list) - 1) try: os.unlink(WALLPAPER) except FileNotFoundError: pass os.symlink("%s/%s" % (WALLPAPERS, file_list[new_wp]), WALLPAPER) call(["feh", "--bg-scale", WALLPAPER]) if __name__ == "__main__": main()
Is there any background on this? Just an overall somewhere of how they connect to each other?
Motion detection script (with OpenCV) that records videos and puts them in Dropbox. Also initiates soul destroying cursing from the speakers. 
Thank you, man.
Are you getting any errors when you run that code? What does the error message say?
Why a metaclass?
&gt; Not a developer. I work as a financial analyst. Merge the two, quants get paaaaid.
&gt; Some would say node's selling point is that it's a very fast, expressive, dynamic language V8 is fast. Javascript is those other things. &gt; Personally I would choose something saner, but node does get work done. Can't disagree with that. But weak typing does give me the heebie jeebies. Not something I'd want in a large-ish codebase.
Python 2.6 is part of the operating system, so if you just upgrade it, things break. It's not so terrible to install a new Python version, but you have to do a bunch of non-standard stuff to make it go.
Had a stray thought, is `__eq__` used for detecting hash collisions? I haven't examined the source for dict/set but that would make sense. 
Wrote a script that reads my spotify saves and creates a spotify playlist of bands I might like that are coming to my town (using songkick). Now I can just fire up the playlist and hear bands-I-like-or-might-like with real concert potential based on songkick. I like it. Well I used to. It doesn't work anymore. I should fix it. I half finished a next step that reads my google calendar and does the playlist based not on my home town but rather wherever I'll be (I travel a lot). I think all together this could be awesome. But even the simpler version is really nice.
Wow this is automation at it's best
I have a string method for the Runner class I was missing the __repr__ method in the Runner class. 
That's actually great, but why "Popeye"? 
&gt; Almost all of the other dynamic languages are in the same boat here. Absolutely. The reason I say the GIL is an issue is that the core devs have stated that their motivation for the changes introduced in Py3 were to make it a better language for *applications* (as opposed to scripting, presumably). That being the case, they're eying Java territory, and the GIL is a glaring issue with Python vs Java and other "traditional" languages in that space. &gt; Even Node, which is still growing despite of it. V8 is a lot faster than the CPython interpreter, and its major selling point, imo, is being able to run the same code on the server and client. &gt; For me personally the main stumbling block is the deployment of end user applications Oh fuck, yeah. That's a nightmare. If I ever wanted to distribute a desktop application (except perhaps on Linux), I don't think I'd ever consider using Python.
1. Created a program that reads a word document of multiple choice questions exam. The program creates a new document with multiple exams. Each exam has all the questions shuffled, and the answer in each question shuffled as well. 2. Created a program that generates random encounter for my DnD cmapaign based on a data base of creatures and treasure. The idea was to have a pool of creatures that slowly reduces and let the players try roam around. 
Clever name indeed, I believe this may be one of the reasons it was somewhat popular.
Sounds very useful to me
I have a script that runs every 5 minutes during the baseball season and manages my fantasy lineup to ensure my entire roster is active every day.
Well. It's been a hobby of mine for a while. Saved me lots of money! https://www.stealengine.com All python and C
&gt; This is incorrect No it isn't. You're talking about HTTP **1.1**. From the HTTP **1.0** standard: &gt; Recipients of header field TEXT containing octets outside the US-ASCII character set may assume that they represent ISO-8859-1 characters. So, yeah. &gt; you can't reliably interpret the non-ASCII bytes and shouldn't try Exactly. So why the fuck does Python 3 insist on decoding them when it supposedly supports HTTP 1.1? The sad reality (which apparently doesn't matter much to Py3 devotees) is that headers are usually ASCII, sometimes UTF-8 and sometimes ISO-8859-1. 
First of all, Zed Shaw's criticisms of the whole Python3 migration process are better viewed as two separate things. One thing is him being retarded with that "Turing Completeness" bullshit, which is actually 100% wrong. Python3 is Turing Complete, you can write a Python2 interpreter in it, but that wouldn't make you any happier because it would be exactly the same as trivially patching `subprocess` to allow you to call some Python2 module function from Python3. And you can instantly see that it'd be very problematic and limited, because calling simple functions would work well of course, but what if the library wants you to give it an object derived from its own class? What if their class was derived from the 2x `dict` and your class was derived from the 3x `dict`, and you overrode `items()` and omg this is a disaster. -------- The other thing is him channeling the Pragmatic Programmer. The Pragmatic Programmer wants shit to Just Work™, so that he or she can get back to writing Useful Code. Like, you know, I remember seeing a post in /r/linux where the dude complained that after he finally managed to wrestle down all problems with his distribution, he's bored and doesn't know what to do. And one of the replies was, yeah, just rotate between Arch, Ubuntu, and Fedora, and by the time you've fixed one you can switch to the next one and everything will be broken again. This is the opposite of Pragmatic Programmer. This is intellectual masturbation of the worst kind, it gives you a superficial feeling of figuring stuff out as if you were a real programmer, but you're not actually creating anything new and useful. And from the Pragmatic Programmer point of view, who just wants the shit to work and get out of the way and let her write Useful Programs, the transition from Py2 to Py3 does indeed feel like enemy action. You can't deny that, it does. Now, I personally think that it was purely incompetence with no malice on part of Python core devs, but it still feels like pointed malice in places. ------- And Zed Shaw is 100% right that if right now a newbie programmer learns Python2, she's going to get her time investment's worth and could switch to Python3 at any time, while if she learns Python3, then she would have to face all this busywork shit-management bullshit that the red-eyed Lunix Untermensch enjoy and Pragmatic Programmers hate with every fiber of their souls. And yeah, strong words and slurs are excusable, because the sad state of modern open source software development begs to be explained by those red-eyed waste of life nerds dominating it. In case of Python3, I personally am willing to write it down to incompetence as I said, but I get where Zed is coming from. By God, I get it. I **hate** programmers, not all programmers obviously since I'm one, but I hate that sort of programmers that oftentimes seem to dominate software development and cause unspeakable trouble to me when I'm just trying to write some Useful Software.
Doubtful. As popular as numpy is, it's hardly the foundation on which Python's biggest hits are built.
I made a script that transfers an iTunes Playlist to a Creative MP3 player that I owned. Buying an iPod would have been cheaper if my time is worth anything but programming is more fun.
Just today I found myself refreshing a website trying to snag a black friday deal, and it occurred to me that this was something that should be automated. So I spent 5 minutes to write a quick script that checks the page for the name of the product I'm looking for every 60 seconds, and if it finds a match it shoots me an email. Small, but very pleasing because it's the first script I've written that wasn't work related and actually made my life easier.
Thanks that's what I was looking for. 
It's just on the file name - the receiving party wouldn't be able to compute the SHA1 on the binary without the binary itself, but would be able to compute the SHA1 on the file name, which they would know.
It's easy-ish to paste segments of video together. I'm really wondering about the introductory blur and band-name overlay. That's easy to do in a second pass, but not easy to do in code.
Though drilling the 'easy stuff' is a good way to train the kinds of pattern recognition and mental associations that develop into the intuition required to work on the complex stuff. 
How does this differ from ``json.dumps(x, indent=4)``?
Have you won anything? lol 
Removing a link is not "recommendation". Disallowing a good book based on the author opinion isn't suppressing his freedom of speech/opinion? Nothing in my post that I need to feel bad about! I feel very good instead, because I expressed my opinion. And you are telling me to feel bad about it is suppressing my freedom of speech. **But don't feel bad about it! (see what I did there?)** Because you expressed/voiced your opinion and I took my time to read it and respond.... **Without** telling you how you should feel about your own opinion or how ignorant you are not understanding the argument. 
Created a script that searches a folder for .c assignments from students, automatically compiles them, saves the compilation output and displays a menu that allows me to explore which assignments compiled with and w/o warnings/errors, read the compilation output and execute any of the generated executables from the same terminal. In the end it deletes all of the generated files so I can have a nice Git repo without clutter.
Oh wow, does this depend on Python 2? 
I still think those are pretty easy to do programmatically, but it's still not my project, so I can't tell you definitively. However the name overlay and the blur don't make me think that it required human editing. In fact, I'm kind of inclined to think that you could achieve the entire thing with Bash and FFmpeg's command-line options. FFmpeg supports very sophisticated custom filter graphs.
Is it possible to not delete the files? Can we run this and just create a table of paths to duplicate files? 
I wrote 'Game Programming - The L Line' a few years back, in Python 2.7 with PyGame. I haven't updated the book and don't really plan to, but I've actually been teaching Python3 to beginners with very few problems. Honestly the dysfunction within the publishing world is the main reason I may never write another book, but honestly the current 'controversy' over Python3 is completely silly to me. I actually prefer teaching 3 to beginners over 2, because honestly beginners should not care about their language. A programming language for beginners should try hard to get out of the way. Most beginners don't really need to know or care about the differences, and they only ones they'll see are simple, but occur in nearly every program. First, getting rid of the insanely dangerous input() function from 2.7 and renaming raw_input() to input. I love that, because I don't want them using that old input at all. I like that integer division is now explicit with the // and that dividing two integers with a single / will produce a float, like they expect. I'll teach about data coercion and its dangers another day, but the first week of programming, division signs should pretty much do what the user expects. Changing print from a statement to a function was a necessary move, and it never bothers them, but I still have motor memory from years of Python 2.7. Oh, and the capitalization of Tkinter has changed. From a beginner's point of view, NONE of this matters, because it's all new. Silly set of arguments, as I've said. My newest video series (no longer doing books) does cover Python in the Blender Game Engine, and does use 3.4, as that's the version currently included in Blender. I've had no real problems. 
It's not a "war" as such. What it essentially boils down to is a conflict between what's best practice (Py3) and what works best *in* practice (Py2). The core of the ~~schism~~ dispute is that Py3 has a very different text model to Py2. In the general case, when everything is configured correctly, Py3 behaves *much* better. Non-ASCII text Just Works, whereas Py2 leaves it up to the programmer to make sure non-ASCII text works. (Which many coders simply don't do.) The problem is that—almost entirely due to deficiencies in its implementation—[Py3 makes some things that Py2 can handle just fine](http://lucumr.pocoo.org/2014/1/5/unicode-in-2-and-3/) very difficult to impossible. Developers who know how to Unicode in Py2 are understandably rather upset about this. And on the other side, there are a lot of Py3 ~~fanboys~~ devotees who cannot accept that these are valid grievances. They're theoretical purists. "Bytes are bytes and strings are strings" fundamentalists. The real world is chock full of strings-of-indeterminate-encoding (UNIX filenames, wire protocols, email, etc. etc.), which just don't fit well with Py3's "all text is Unicode" principle (as it's currently implemented), and which Py3 makes a total PITA to work with compared to Py2. It's a perfectly valid position to say that it's the fault of UNIX/the protocol/email, but *that doesn't help me write a program that works with that data*. This really wouldn't be an issue if the Python core devs hadn't been so militant about their Unicode-first position. But they utterly gutted Python's ability to treat bytes as strings, instead of just reversing Py2's default behaviour whereby all strings are bytes unless explicitly decoded. Indeed, many of the features Py3 has gained since 3.0 have been geared towards restoring features that Py1 and Py2 always had, but it still isn't there yet, and thus still makes doing certain things *way* harder than they are in Py2 (or sometimes impossible). 
Do you need a specific Python environment? I've used [Choco](http://www.choco-solver.org/) with Jython, and it worked out pretty well.
I've not had to go through the process, but YPlan recently blogged about their experience migrating their backend codebase. https://tech.yplanapp.com/2016/08/24/upgrading-to-python-3-with-zero-downtime/
So what are the alternatives to openSSL? I vaguely recall seeing something about "gnuTLS" but never looked at it further.
This might sound like a silly question, but I don't have any practical experience using relational databases. What is the purpose of using SQLite? Is there a benefit of using a .db instead of something like .csv?
I was just thinking of posting something like this yesterday because I just had the biggest Ah Ha moment in my life. I made a script that would automate massive amount of repetitive work in photoshop. Might not seem impressive when you are just editing 10 or 20 layers but when you replace that workload with 100 layers 200 layers or even 500 layers, it such a life saver! What's more amazing is that the script was written in javascript and not in python. I used what I learned in python to apply the general knowledge to what I was doing in PS, I was also able to read the majority of the boring ass doc and understood what they were talking about. I had no perspective before how absolutely AMAZING this is, I had 5 lines of code, hours time saved in the future, reusable script, and its fucking awesome.
&gt; Were you not aware of the existence of different filesystems? People want to treat filenames as text and do text-manipulation things with them. They want to look at whether a filename starts with some sequence of text, or replace a bit of text with another, or tack on some text, or look for filenames which match a pattern, or... You know. Text things. So encouraging people to use APIs that get them the filename as text is the right approach. If you think there are improvements that can be made to the API, by all means suggest them. But if an API shortcoming causes a bug, you don't throw the baby out with the bathwater -- you fix the bug rather than re-architect the whole thing around "filenames are opaque bytes in an unknowable encoding, deal with it".
Python 3 says bytes should be converted to a text type instead of left as bytes and interacted with on the assumption that performing text operations on bytes is safe. Since I don't see any way to get what you want other than the known-unsafe approach of opening up text operations on bytes (especially since you do seem to want to rollback the entire change), what is it, exactly, that you want?
I made this so i didn't have to clear my browser history... [Image_Gen](https://github.com/Comm4nd0/Image_gen ) it basically searching a subreddits for all image types, mp4 and webm's and displays them either in the gui or in a web browser.
&gt; what is it, exactly, that you want? I want to be able to treat bytes as strings, just like I can in Py2, *when that's appropriate*. I want to be able to easily undo Py3's automatic decoding when it's fucked up by decoding something it shouldn't have (i.e. round-trippable surrogate escapes). I know perfectly well how to Unicode in Py2, and I want to be able to write the same programs in Py3 without their dying in flames because Py3 would rather point the finger at the OS/protocol than *work in the crappy world of text-of-no-specific-encoding we currently live in*. I DGAF if it's mojibake *if that's what the program I'm passing it to expects*. 
Of course feedback is all important. What I was against was the specific notions of having "debates" on reddit as if those are relevant in any way except wasting a lot of people's time on pointless arguing. Which is one of the core facets of reddit, so if redditors want to do that, let them, sure. I'm just, like, if you're aware that you are a reddit user but not necessarily a redditor, that's a thing that'd help you to distance yourself from that pointless waste of time.
This isn't the place to ask home work questions.
I just wanted to say that I looked up the company and did a little reading I think it is super cool what you are trying to do over there and I'm glad to see a business model addressing these issues. Of course it's for profit and such, but nothing wrong with that!
&gt; I want to be able to treat bytes as strings, just like I can in Py2, when that's appropriate. The answer to this is "Python 3 is not the language for you". Python 2 catered to you at the expense of me for many years. Now it caters to me at the expense of you, and [doing so is the correct choice](http://www.b-list.org/weblog/2016/jun/10/python-3-again/). If you disagree fundamentally with this and can never be convinced otherwise, well, I'd suggest you start migrating to a language that isn't Python, because you've got less than four years before Python 2 stops being a supported platform.
So you are on reddit arguing that arguing on reddit is pointless. I don't agree, but you definitely have shown a great example that some arguments axiomatically have to be pointless. Good laugh. 
[Infetterence!](http://infetterence.com/)
I got it :) have an upvote
Yeah actually Choco is the main tool I have used for CP. The thing is the project I am working on is entirely in Python, and some new components that need to be implemented might be related to CP, this is the reason I am asking and researching. Could I do that with Jython? Never heard of it, never used it. But anyway, I'm focusing on my original question.
* .split??? * Ideally I'd like to use json parsing. Unfortunately the packets picked up by pyshark/tshark don't contain the complete json string, only fragments. Searching for text data and grepping for text known to be nearby to the roomId is the next best thing * But why not just use regex, it would be so much cleaner * I agree, but hey, this works. You wouldn't get any more reliability out of using regex, it would return the same data, and the bottleneck is on the network anyway. * memory pointers instead of unreliable packet sniffing? * Jackbox doesn't store the current room id at a static pointer. That was the first thing I tried, definitely would have been easier than this solution
I would do a size check before any hashing.
Well that's part of the petition, getting the thunderbird plugin. We work in a strict environment and every piece of external software that we use has to pass legal and IA review, which takes about 3 months, unfortunately. 
So you're being very quiet about your scraper I imagine! 
So wait I can just write Java code for the CP components using Choco and import it in my Python project?
I wrote a script to download the subtitles for any movie that lands in my video folder automatically. Not the biggest achievement, but it's a time saver.
I wrote a script that makes managing the SQLite entries used by another, bigger Python project a lot easier. I can chose to go into user management or global management from a bash script which opens up the relevant Python script. From there, input is turned into SQLite queries that make the changes I want. Much easier than going into the database and writing them manually.
Very cool! I had similar struggles when looking up international companies like Volkswagen and all the tickers they have. That being said, I feel like more accessible data/insight that just a general score would be helpful. Like maybe explain the methodology and the weight given to each estimate (unless you did somewhere and I totally missed it). Just to make this useful and practical. However, this is already super cool and very different from existing tools that are available out there (as far as I can tell). Keep up the great work and hopefully you attract like-minded investors.
Now level-up and instead of doing that for yourself, do it in a portable way so that your work is visible, sharable, and your automation is available to others to build upon.
haha i need to fix that
The HTTP/1.0 standard is irrelevant except as a historical document. RFC 7230 is the HTTP/1.1 spec, but it's also normative for interpreting headers from HTTP/1.0 peers. Basically it's saying "yeah, we know the HTTP/1.0 spec said that, but you SHOULDN'T [in the technical standards-ese sense] trust your peer to follow that spec even if it claims to". As for the rest, I'm not really sure what you're arguing -- I'm not even sure what it means to say that "Python 3 supports HTTP 1.1". Certainly the HTTP libraries I use on Python 3 represent headers as byte strings. It seems like you really want to find something to argue about? I'll pass on that -- I just wanted to point out that one inaccuracy, since there's enough confusion/misinformation about HTTP header encoding floating around already. 
It started off really basic with looking at successful business names such as FaceBook, SalesForce, DropBox, etc. and taking permutations of those... so we would have for Face: FaceForce FaceSales FaceDrop FaceBox From there I started adding and deleting terms, and customizing it more and more. I've been interested in applying machine learning to discover what makes a great business name. This is exceedingly difficult though as natural language processing does not work so well with implied meanings like this. For the front end there is some JQuery and Bootstrap just for the forms. Flask is used for routing, and the rest of the system is built in Python. It performs very well I was surprised. Actually, I can generate names faster than Chrome or IE can render HTML. You will notice that you rarely see duplicates on the list and you just chose a random name there are up to 6+ million possibilities.
I haven't followed in detail, but OpenSSL has been turning things around at least somewhat. The 1.1.0 release in August included a lot of major API cleanups, including simplifying the code layout, getting rid of a lot of obsolete (insecure) algorithms, making most API structs opaque to allow better API evolution, etc. They're starting from a huge amount of technical debt, but I wouldn't necessarily count them out yet.
I'm sort of a n00b still so I haven't done anything super cool, but the first time I felt compelled to make something that had nothing to do with my work was a little alarm. It would play a bit of music to wake me up, read headlines, and then give me the weather and tell me what to wear. That last part was the crux because I am one of those people who hates making decisions. I figured I'd outsource it to a program that would take the humidity, temp and precipitation probabilities at different times during the day and map that on to what I know I like to wear. Unfortunately, I never got the timed task to run properly.
Honestly all of his complaints are just excuses for his laziness. His 'real problem' are the unicode strings and error messages in python 3? are you kiding me? We got finally rid of the ugly global error and have now the name error, something, even beginners can better understand. And the whole unicode thing, is he so ignorant to understand we need a codec for the world, because many people just can't us ascii alone? I am from europe and I have to deal with alot of different languages all day. And to be honest the standard unicode in python3 saves me alot of time! He didn't even update his tutorial series to 2.7. And he is arguing about some bullshit. I can't believe that there are real death threats and some bullshit on his person... And the talking about his paintings are just there to give him some kind of personality, I don't care about, it is useless crap so he can try to convince us to be an actually carring person, boring writting trick. Especially his 'international' critique shows me that Zed is just an arrgogant and lazy wanker, nothing more. Fuck him, really. 
That's right! And apparently being ordered wasn't a goal in itself, it's just a (super awesome) side effect of the new dict implementation. 
&gt; smoothly upgrade No such luck.
&gt;quantum espresso Let me get some of that future coffee 
The bilingual PDF generator sounds awesome.
It could work either way -- my current setup favors 2.7 though, I might need to create a few modifications to make it play well with 3+ but it wouldn't be impossible.... The worst thing about some of the 3 version libraries is how it patches the module (usually dynamically) which is really bad for compiling a script into PyInstaller -- I can't tell you how many times that has been a PITA for me to figure out.
Isn't the goal to write a program which makes your life much much harder? :) I made a python script which generates a random number between 1 and 999. You have to write the number in spanish. If you fail you get asked again. I put this in my bashrc. OK I can quit it by pressing ctrl+c if I am in a hurry but it helps a lot getting better with the numbers.
Combine this with automatic web domain availability lookup and you've got something really useful!
Nice one haha... yea sometimes the names can be pretty amusing. I was wondering if it's possible to define what makes a good business name. I looked into the subject quite a bit, and it seems to based mostly of speculation from marketers. Trying to find a scientific definition of a good business name has seemed very difficult so far.
thanks :) 
popeye deals in population receptive field models. i considered poppy, as in the flower but i like popeye better. plus it has "eye" in it, and i'm a vision scientist. the Cython lives in [spinach.pyx](https://github.com/kdesimone/popeye/blob/master/popeye/spinach.pyx)
In this case it makes the code brittle; it could crash for non-obvious reasons (anything that `range` doesn't like). Run it with the input 10000000000000 and let me know what happens on your machine.
I work QA for a development platform, and part of the testing process is setting up around 30 test applications. ... on about 5 different operating systems, and including N+1 clustering.... I wrote a python script that not only sets them up, but can be used to setup pretty much any test app. I went further and then automated the entire process, starting from spinning up a virgin VM, downloading and installing the latest build. Configuring it and setting up external resources as needed for a given test set, setting up the tests, running the tests, validating the tests and then reporting the results. It's all parameterized with script hooks, to be as open-ended as possible. It's about about 13k likes of code. (well, about 300k if you count everything, but 13k that I wrote) It was my first program, ever. Prior to that I had only ever made smallish scripts in bash, php, javascript and our proprietary languages. But no python. I have no programming background or education, either - and it took me about 3 months to complete. Mostly in my spare time, as I still had to keep up on manual testing and professional service type issues. Somehow this didn't earn me any clout in the company. Seemingly the opposite, even. No one really gave a shit, even seemed to be even a little shitty about how long it took me. But at least we're getting a bit more regression coverage. ...
Glad you liked it! In this specific case, my main concern was just to get it done with as little of my own time as possible, so it was actually easier/faster to do the blur and logo as a second pass manually through a free video editor GUI. Although after reading this, of course now I want to see if I can write something to do the whole job!
The script is very simple. Just replace a remove method with a print statement 
Your down votes will be epic. Contribute something instead of being a lame ass next time. 
Thank you for the post. I'll look it over when I get home!
Shall we get a high score table going? I lasted 47 seconds
It was sometime ago, I created a simple facebook in the terminal cli tool. to show me only data [ posts ] that I wanted to see [ posts from specific pages or profiles ]. it helped me to only checkout facebook once or twice a day max, and not scroll down to infinity wasting my time. it doesn't work now due to changes in facebook's graph api. 
Just checked out the script 😅. Whoops, should have done that before commenting! Thanks!
So, you're using PBKDF2HMAC for key generation and AES+CFB mode which looks good, but you should keep in mind there's still a known plaintext attack on this. It still lacks an integrity check. Let's say there's a malicious payload that can fit in a 128 bit block in a specific file that the attacker has (or has up to a certain point). For example, let's say it's financial transactions like (SEND $100 to JOE, SEND $500 to JACK, ...) and each fits in 128 bit blocks. https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_Feedback_.28CFB.29 If the attacker knows what the plaintext is at a certain block, they can take that block XOR malicious payload block XOR cyphertext and swap out that specific block without knowing the key, and it'll decrypt to the malicious 128 bits they wanted. In the example, they could put ("SEND $99999 MALLORY" ) if it fits in 128 bits. In CFB mode that'll cause the rest of the file to decrypt to garbage, but in some cases that might not matter. If some program read that and ran the transactions then crashed, Mallory still gets her $99,999. In a binary executable, this could be a malicious 128 bits that executes and that might be enough. They wouldn't even have to know the key, just the plaintext. If you're saying you're sending some specific filetype, that filetype might always have some specific header so generally you already know a lot about the data in the file just by knowing the filetype. You need some sort of integrity check to make sure that the file hasn't been messed with in transit, like hmac (not regarding key generation, should be pre-decrypt integrity check). You should use something like hmac with a password derived from the key to create a hash which is checked on the data before the receiver attempts to decrypt it. Also, you should also still use a salt in PBKDF2. I'd figure out a way to make that work. I know it's not a very easy problem, but that's not using it how it's meant to be used. It's a fun project to roll out all this crypto yourself but for practical usage you should probably use something like TLS or GPG and not bother working out the crypto on your own. It's very hard to get this stuff right. Python has a good GPG library I believe and you could just exchange the key and not have to worry about integrity checks or any of that before hand. You could also allow them to use asymmetric crypto as an option, so the file could be signed by the sender and encrypted for only a specific user ahead of time.
If i type "pri" into your search engine, I get "Primerica" as choice #1....so you may want to change your 'yahoo finance' example and/or your implementation :) 
I've posted this before, but here it is again: [This script](https://github.com/joshnewlan/say_what) listens to meetings I'm supposed to be paying attention to and pings me on hipchat when my name is mentioned. It sends me a transcript of what was said in the minute before my name was mentioned and some time after. It also plays an audio file out loud 15 seconds after my name was mentioned which is a recording of me saying, "Sorry, I didn't realize my mic was on mute there."
I've got one that makes my wallpaper the most up voted image on /r/EarthPorn
Very cool. Can you share this?
No, seriously though.
Nope.
20+ projects and I'm running out of harddrive space. Datasets are large enough without this unnecessary bullshit.
&gt; DHH Heaven forbid you should google something. [This](https://en.wikipedia.org/wiki/David_Heinemeier_Hansson) guy.
I got as far as 3.
`from pprint import pprint` ?
Take note folks, this is what a person taking full advantage of Python and life looks like. Well done.
TL;DR: "Both Python and R have great packages to maintain some kind of parity with the other, regardless of the problem you're trying to solve (...) But if you're looking for a flexible, extensible, multi-purpose programming language that also excels in both machine learning and data analysis, Python is the clear choice.
[Shuffles your Spotify library as I find Spotify's shuffle algorithm repeats too many songs](https://github.com/DiljotSG/spotify-shuffler). 1. Given a playlist, it will empty that playlist. * Gather all the tracks in your library. * Shuffle them * Add them back to the playlist.
Two things A list of python articles i often refer to https://github.com/Leo-G/DevopsWiki#python-guides-and-scripts A script to scaffold database driven web apps and api's https://github.com/Leo-G/Flask-Scaffold
awesome :)
The Tkinter changes always mess me up because I rarely use it, so when I do I look up tutorials which sometimes don't specify which version they are based on and I forget which capitalization is for 2 and which is for 3.
Now it makes sense. Pop(ulation)eye. By the way, what does a vision scientist do?
Not to mention major differences in the culture of documentation. In Python, you're likely to find a website with images or an interactive notebook. In R, you'll get a 90+ page PDF without graphic examples. I do data visualization and use both R and Python regularly, with a strong preference for the latter. The number of R packages for graphics that are one hundred pages without a single example of said graphics is ridiculous. It's like documentation is maintained by an academic who hasn't been told those PDFs don't count during tenure review.
For this purpose? Personal choice. I'd personally do `json.dump()` in this case.
Does it work with extensions?
Yeah, but that's on mac.
[Image](http://imgs.xkcd.com/comics/command_line_fu.png) [Mobile](https://m.xkcd.com/196/) **Title:** Command Line Fu **Title-text:** When designing an interface, imagine that your program is all that stands between the user and hot, sweaty, tangled\-bedsheets\-fingertips\-digging\-into\-the\-back sex\. [Comic Explanation](https://www.explainxkcd.com/wiki/index.php/196#Explanation) **Stats:** This comic has been referenced 55 times, representing 0.0401% of referenced xkcds. --- ^[xkcd.com](https://www.xkcd.com) ^| ^[xkcd sub](https://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](https://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_dafv8ke)
When I google 'DHH' I get two pages of results about a local timber company. Sorry that my Google results don't look the same as yours. Thanks for the link, though. I appreciate it.
[?](http://www.youtube.com/feed/subscriptions)
Oh shit! Gotta give this a try. Is there any functionality that gspread has that yours doesn't?
That's true, I'm always annoyed to see people consider Python only a scripting language or just a language for small or toy projects. Python is powering many things, a large code base could be OpenStack.
You are doing arithmetic on string values not numerical values. $ ~/tmp.py 33, &lt;type 'str'&gt; 21, &lt;type 'str'&gt; 10, &lt;type 'str'&gt; 33, &lt;type 'str'&gt; $ cat ~/tmp.py #!/usr/bin/python from functools import cmp_to_key l = ['21', '33', '10'] def num_cmp(x, y): print "{0}, {1}".format(x, type(x)) print "{0}, {1}".format(y, type(y)) return x+y &gt; y+x sorted(l, key=cmp_to_key(num_cmp)) Edit: Is there a reason why you are doing? x+y &gt; y+x
We're trying pretty hard. Honestly, I think we're probably in a better position to accomplish the goals of better, cheaper healthcare than a non-profit, the government, or anyone else. It's all a matter of incentive alignment; Medicare Advantage is paid on a risk adjusted basis so the more we can do to keep very sick people out of hospitals, the more money we make, and the more money the federal government saves.
I teach Python to middle schoolers on the side. I have insisted on Python 3, because there's no point in muddying their minds with 2.7. By the time they graduate from high school, Python 2 will have been EOL'd. The reality is that yes, we can have debates about whether Python 3 made the right call, and whether PyPy is the future of Python instead of Python 3. But CPython does seem to be the Python version with the best name recognition and widest adoption. If Zed Shaw wants to be another Abe Simpson, let him. I've taken that manuscript I've been working on halfheartedly for 8 years now and updated it to Python 3 already *because it's the right thing to do*. 
Yeah, that's true. Python is being used in projects with large large code base for sure, I'm all for it and I've no intention to question that. My post is mostly like a response to those people who bring that excuse, Thing is, these type checking makes our work as developers much easier. You mentioned a very good point: &gt; Good news is it hasn't been the case for a very long while: python is used in very large code bases. Typically in python people rely on unitest and coverage to prevent bugs. There should be a better and more productive pay to do that, type checking is time consuming when it comes down to unit test, wouldn't be great to let Mypy check that for us ? which it does. There're many data types in an application source code, its instance to check our code base for all the possible types and it's insane to check only against 1 or 2 types. 
why is this specific to python. (not going to down vote yet because I only lasted 3 seconds, and maybe I'm missing something)
Wrote my own CLI around the Salesforce API so I can easily view cases, customer numbers, support contracts, order item lists, etc. The webapp is pretty fully featured, but it's too slow when you need something fast.
Lol, there's actually a website just for that.
No kidding, Salesforce drives me nuts with how slow it is. The data is good, but it's hell navigating the app to get some simple info. You've planted a seed I'm thinking about watering.
Thanks for the tip. I did have 2.7x installed. Problem resolved, total noob to programming. Thanks SO much!!
I think it's because he uses python in his examples. 
Built a scraper to farm rewards points for using a particular search engine in a particular browser.
Serious question, What do you use Python 3 for? I've never seen it used in production anywhere so I haven't really had any reason to touch it. I've tried it on some personal projects but ended reverting back to 27 because I didn't have time to figure out the new stuff. 
 import this
The thing that bothers me the most is R's coding style. I guess it's more of a personal preference but I just cannot get over it.
IMO, Python is way better tha R if you plan to do data minig for a long time.
 $ python3 -c 'print("21" + "33" &lt; "33" + "21")' $ True 
I suppose that makes sense. Every network is different, and some don't use Python, and it's "not everywhere". Either way though, if he converted his Python to exe he'd have his own clone, which would be pretty awesome. Wouldn't even need to worry about Python being "everywhere" and still have an awesome utility.
Sadly no :(.
&gt; x+y &gt; y+x Hence my edit asking if this was intended, either way I believe OP wanted to do descending order which can be done like so: $ cat ~/tmp.py #!/usr/bin/python from functools import cmp_to_key l = ['21', '33', '10'] print sorted(l, reverse=True)
&gt; Python 2 had one obvious way to do string formatting. Python 3.6 has three. Wait...what's the one obvious way in Python 2? Python 2.6 and 2.7 have 2 methods. Python 3.6 will have 3. Nobody ever uses Python 2.4 (besides me), so that version isn't really part of the discussion. `str.format` is excessively verbose, has odd syntax, doesn't really add anything, and is "new" (it's super old, but people don't really use it, so it's always funny looking). Python 2 has 2 methods. Python 3.6 has a nicer 3rd method. I don't know why you don't like f-strings, but like format. F-strings fix the problems of format.
To be fair, the fact is that R is hugely popular in academia and publishing a package can count as a publication for some faculty has a significant part in creating this culture.
Yeah, it's a silly thing, but cmon', having periods inside of identifiers? The stupid &lt;- thing? Using $ to denote structure? WHAT ARE WE, ANIMALS!!?
I really wanted to switch to simple bank, but the lack of paper checks is crazy. People still need them for random one off things. For me, they are required a lot for holding spots in my kids school system. Anyway, you actually have an account. What's your opinion on the bank?
Shiny is still the quickest way to get really nice dashboards up and running. Also, R has quite a bit more flexibility in dealing with missing data than sci kit learn. One place where I am now finding a lot of good use for Python though is with redshift. You cannscale Python udfs to a lot of data.
Huh, seems I forgot about python's "fuzzy math" :P
You can use "&lt;-" or "=" but I use the former because it's hilarious. 
Python has the best syntax of any programming language ever created by man hands fucking down.
Yep. The 2/3 differences that are relevant to a beginner are: * Use input() instead of raw_input(). * print() is a function now. * / works as you think it would now. That's pretty much it.
You do realise that there are 36^4 = 1.7 million combinations, right? It's highly non-trivial to try all of them. Also, look at the [intertools.product](https://docs.python.org/3.6/library/itertools.html#itertools.product) function
I'm building a unittest module to auto test my code that parses through Heroes of the Storm replay files (heroprotocol) and outputs map specific and hero specific data to two different csv files. Though those files are no where big enough to justify the use of apache spark, I plan on using the Python API of apache spark to become familiar with spark, and to apply machine learning algorithms to determine which "pre-game" stats can best predict the outcome of the game.
Doesnt it seem inspired by fortran?
Yeah, I kinda wish more languages used wee arrows
yes it is intended. So in the above situation when comparing 33 and 21, '3321' &gt; '2133' so '33' &gt; '21' '2110' &gt; '1021' so '21' &gt; '10' '3310' &gt; '1033' so '33' &gt; '10' so shouldn't it output I am trying to do this problem: https://www.interviewbit.com/problems/largest-number/ that's why I am doing this :) ['10', '21', '33'] and when I pass in reversed=True give ['33', '21', '10'] ? 
What was confusing with Python 3? I use Python 3 for everything including work, a lot of it is just more intuitive to me. I got into it for the Unicode strings, and I stayed with it for the continuing support.
This can be done in Excel. Why not just stay in the same domain: Excel? You are using 2 domains which is a waste of time.
Are you a quant because this is kinda false.
I must concede that I haven't tried your program yet, but I like the idea quite a lot! Where do you plan to go from here? I might suggest that it could be designed to be more sophisticated than an alias manager for text files. As it stands, you are basically creating a program that sets aliases from a list whenever it is run, and provides an interface for updating that list. Your project looks very nice, but to be brutally honest, I don't see the advantage this really has to simply making a bash script that is run on startup with a list of alias assignments. It even saves a step when calling the file up to be edited, as I could just say, for example, "vim tmux-config" as opposed to "cfm edit tmux-config". Since package management systems tend to provide records for conf file locations, you can probably use the host's package management system to actually automate the import of conf files. From there, users could add custom locations or flag favorites to create a curated list if that is your main goal. However, I think automating the import of conf files during setup would be the expected and appreciated behavior. Additionally, while you are interacting with the package management and file systems, you have the opportunity to get additional data that you may want to use to add new features. For example, you could: 1. Collect the name of the package maintainer to display as metadata along with the package title. 2. Try to locate conf files that have been orphaned by packages that were installed/uninstalled using the package manager. 3. Use checksum from installation to determine whether the conf file has been modified since installation. 4. Restore the original config file from the package by utilizing the package manager itself. 5. Manage and make recommendations regarding the permissions on the file relative to the current user and the program it belongs to. Lastly, concerning your overall design of using the aliases: 1) Does this not prevent using the name of the application itself as the argument designating the conf file being edited? For example, the command "cfm edit foo" where "alias foo=~/.foorc" -- in many cases, foo would be the name of the executable itself, and setting the alias would pollute your shell as to prevent calling to the executable I think? Maybe I'm wrong and you prevent that from occurring somehow. Regardless, my humble opinion is that it is highly desirable to edit the conf file just by calling the name of the program itself as the argument. 2) This may not be the best design for the sorts of features you may want to add in the future. For example, it would be really cool if the program could manage multiple versions of a conf file and provide an interface for swapping. You could even create *groups* of conf files across multiple programs that could be swapped at once, useful for deploying customizations across multiple programs (tmux, vim, emacs, etc.) While each program will have a different method for loading conf files, you could control which file is loaded by default for any program by relocating the conf files found on setup to a central directory, and then creating symbolic links in the default directories. I think that the program needs to store all of the data for a particular conf file in some kind of database or simple list of records, and then handle the argument containing the application name by looking it up internally, rather than calling to an alias that has been set externally. Anywho--interesting project, got me thinkin bout some stuff and some things. Edit: Just wanted to add that the above would be difficult to implement across multiple platforms since it relies on specific package managers. You'd likely need to treat every package manager as special, and in general any file system operation is going to be different on Windows. However, I suggest not trying to be cross platform for a project like this. It is platform specific. Most tools operating in this space are *not* cross platform. 
Are you running Django on a pi and passing serial commands, or somewhere else and using an arduino ethernet module to accept http commands? Edit: Nm, kept reading comments, found answer 
I read your link; its interesting, and raises some points I hadn't considered. ...but, I still maintain that on either side of the fence, by *anyone*, when you start making personal attacks, you've lost the plot. Angry? sure. Swearing? sure, I don't care. ...but personal attacks? What did telling Zed to fuck off and shutup actually achieve? How did the end of that article, which is openly hostile to Zed, improve it? Not to what *he said*, to *him*. How *tangibly* did that make things better? Looking at this thread, it looks like it made a few hundred people send hate mail to Zed. Is that something to be proud of? *I'm* ashamed to see the community I'm a member of doing that, *to anyone*, even Zed. If other people don't care, or think it's perfectly reasonable to do that, well... all I can say is I don't want to have anything to do with those people.
I was actually going to PM you and ask about this since you mentioned you would be up for talking about the company. How exactly does it make money? Feel free to PM me if you don't feel like you can discuss this publicly. I just know that the financial incentive usually exists when people opt to buy in to a service or use the government to buy that service for them. In your case how does that happen when you get paid for people to NOT opt in to buy a service or product? Edit: spelling
 Not a chance. :)
You got a point as well :)
Headtracking via webcam in pure python without OpenCV, which I consider overkill.
I use [BitBar](http://bitbar.com) for this on Mac. It allows you to write a script in bash or python or whatever. I use it to query Github for any pull requests assigned to me. The text in the menu bar highlights blue whenever there is at least one. Now I want to make more of these :)
Especially if Learn Python the Hard Way is on it. But really, Fluent Python is the best programming book I read in the last 5 years. 
C++
I was expecting Raymond Hettinger talking about Pythonic vs non Pythonic. I was deeply disappointed...
I have been a professional software engineer for 15 years, the last 3 of which I've spent using Python. The 12 before that were using a variety of other languages. Python is unique in this toxic fanboi shit. Bury your heads, folks: you'll be irrelevant soon.
Still possible - you just need to have a C shim in between.
I made an application for sharing clipboard contents on gdrive/(own|next)cloud/gist/imgur. Snapshot of portion of screen can be taken and shared as well. You get URL or two (like view and delete) for sharing with your friends. You can log in with your account or upload files anonymously on services supporting this. https://github.com/rokups/paste2box/
dplyr is insanely useful
It wasn't that obvious from your original post that you wanted a world map - wanting to show data per region doesn't imply anything about the background :-)
12 :/
One can probably write sorting function that needs 100 parameters as well. 
Nice try troll (local imports are definitely not spaghetti imports -- and I bet you never coded in that style to have a formed opinion)... I must say what you're saying is completely backwards: if you have something local or small, it really doesn't matter, but if you have a codebase which you expect to become big, or start fast, it's a must. To give some examples on code I've done myself: In the debugger for PyDev/PyCharm: https://github.com/fabioz/PyDev.Debugger, top-level imports are fine. It's a reasonably small codebase which is not meant to be used as a library. For mu-repo (https://github.com/fabioz/mu-repo), imports should be local. It's a command-line application, so, any delay on startup is treated as a bug. For Rocky (http://rocky-dem.com) and Kraken (http://www.esss.com.br/Kraken/), which are built on top of a 10-year codebase, with &gt; 10k modules on its own code (sorry, can't show the code as it's commercial, but it's pretty well coded IMHO) and &gt; 150 external deps, importing everything on top would just lead to unusable code. So, yes, it depends on what you're doing... I agree, it'd be nicer if Python itself had a better solution for import hell, but unfortunately it doesn't!
if it is getting deleted on a simple reboot/restart than you have something very very odd going on. I would be tempted to diagnose that issue first. One way to maybe to work round your issue would be to use a virtualenv (maybe use virtualenvwrapper to make things easy), and always install the modules you need into a specific virtualenv for your project. Since Virtual envs exist under your /home directory system they are less likely to be uninstalled by whatever is messing with your system on reboot
Or use [SWIG](http://www.swig.org/)
Hey, for some reason I didn't get an orangered and since the original author replied to me, I'm guessing you didn't either. But [he said he added those things manually, like you suspected.](https://www.reddit.com/r/Python/comments/5esa4g/what_python_program_have_you_created_to_make_your/dafrm60) :)
For shell bookmarks you may be interested in [autojump](https://github.com/wting/autojump), a zero-configuration tool for quick navigation.
lol the strength of twitter is it's brev
Actually most of the potential combinations of business names come from existing business names. I looked up the names of successful companies I knew or had heard of and used this as the basis of the generator. Later I added synonyms of some of these words, and just other words which I thought sounded good. Lately, I am actually looking to remove words which produce not great sounding names.
I'm running python on a freeBSD server envo to do some diagnostics on a schedule. The extra module (openpyxl) is an extra feature that I wanted to add for data output to excel (because people tend to use excel). noticed this odd behavior when i restarted and I believe it is to do with the odd get-pip operations I have to do to make the module install. Not totally sure though :/
This is really cool!
Yeah, I want to crawl the website to get the directory folders and files. How would I do this in python?
Old Man Shouts at Cloud
Both
Use = then do a find and replace all with &lt;-. I also think -&gt; is another way to do =
R wasn't created to replace or replicate what Python already does. Stats and graphs. Created by biology students I think? That's why counting starts from one and not zero. I learned about pandas maybe a year after learning R (2012) and preferred it until pandas became insanely overused and over relied on to do data analysis. Plus pandas is super slow.
Let me try.. | | Python | R | |---|----------|----| | basic ML | scikit-learn | 1,000,000 packages¹ | | deep ML | 1,000,000 packages¹² and mxnet³ | mxnet³ | | Bayesian inference | pymc | 1,000,000 packages¹ | | basic plotting | matplotlib | built-in | | nicer plotting | matplotlib + seaborn | ggplot2 | ¹ and 1,000,000 different APIs ² good luck getting everything installed and running on GPU if you're on Windows ³ also available for Python, R, Scala, Julia, and of course C++; probably the easiest DeepML library to install and get running
It contains python code for the travelling salesman problem
But so is pandas 
Mixed effects logistic regression is the biggest missing piece in Python for me, so I do almost everything in Python,but most of my regressions and related plotting in R. Not the worst status quo.
I have the Python pocket reference, it's okay but not that much. 
Studying Matplotlib more thoroughly. Love some of the things you can do with it, but I'm not too familiar with it yet at this point. 
&gt; I've never felt that, for a beginner, that there was actually any difference between Python 2 and Python 3, other than some syntax changes. The real differences don't show up until a bit down the road, and they're certainly not challenging at all. Exactly. No true beginner (as Zed caters to) cares about Turing completeness, or doing Python VM. The points he brings up are ridiculous.
Probably, but it's not as fun
&gt; A program which adds 'fingerprints' to image file names, so similar images would stay together when sorted alphabetically. You might be better off adding that fingerprint to the exif/metadata, that way you can still sort by it in file explorers and scripts, but it doesn't make your filenames weird.
Nothing special to show in a repository but I created a script to process PDF. Each week a goverment institution sent 50-70 sheets of names in PDF that required one-two people working ALL the week transcribing names and SS numbers in our database. Furthermore if somebody made a mistake let's say, three weeks ago, all work done should be redone starting from that week on. My script converted PDFs to text using pdftotext Linux utility and all that work could be done in a few seconds just by using a few regular expressions. Luckily management decided not to fire anybody and use these two colleagues for useful tasks
And your boss is okay with you wasting company hours? Wouldn't want to be at that company.
also ``cat file.json | python -m json.tool``
Not worth much with 1000 channels.
This is probably the link you are looking for: http://lucumr.pocoo.org/2016/11/5/be-careful-about-what-you-dislike/
Its deceptive to not write that in your initial reply.
It took me a while to get it :) Probably should have included [a link](https://web.archive.org/web/20080103072111/http://www.zedshaw.com/rants/rails_is_a_ghetto.html) though. Maybe he will eventually wipe this rant too, like he did with his "Rails is a Ghetto" rant.
R's strength includes ggplot2 and stats modeling. Python's port of ggplot2 is promising. IMO, people ought to use ggplot2 rather than seaborn, etc. Python's statmodels need to have better documentation and many more things to approach R's statistical modeling.
All posts? So a nuke them from orbit option? 
“Ex 40: Classes are like minimodules, objects are like mini-imports.”
SyntaxError: multiple statements found while compiling a single statement Thats the error. But what im saying is i don't think ill ever be able to run that code without inputting extra information into the code. I will literally pay someone to figure this out for me
I knew I should have looked it up before opening my mouth. Thanks for the clarification! 
No worries, R can be silly at times https://i.imgur.com/Q0KymG7.png
Or `| jq .` for syntax highlighting.
That's reasonable, thanks!
map/filter because list comprehensions can go *straight* to hell. 
&gt; hugely popular in academia This is certainly field dependent. In astronomy, very few, if any, people are using R regularly for their research. I think even fewer people are writing packages and contributing back to the community in that way. My wife says it is more popular among the social sciences but I am less familiar with them. 
If this generates animosity, then there is something wrong with people... What I'm taking from this, as PHP dev who doesn't know much about machine learning yet is: * If your focus is machine learning, you might as well learn both R and Python. * If you're already a dev in another field and want to get started in machine learning, maybe Python is a good place to start with. 
I've just installed a basic Ubuntu 16.04 server, taking care to install a minimal set of packages. All the Ubuntu tools are Python 3, so I had a small list of Python 3 dependencies installed and all was fine. When I decided to add Mercurial to manage /etc, it pulled Python 2, and that looked *wrong* and stuck in the past.
The first programming languages I learned were Java, JavaScript and then a bit of C. And now I do PHP mainly. Curly braces are ingrained in my brain.
for _____ in _____
&gt;social "sciences" What a great place for people to make vague denigrating remarks about fields that use statistical methods, in a thread about statistics related programming.
I like `&lt;-` or `:=` better than `=` for assignment, it seems like a better fit with logic or math conventions. I would prefer seeing those for assignment and `=` for equality or identity rather than `==` or even `===`.
If you have your own home space a virtual environment will help 
Comprehensions.
Nothing to do with fuzzy maths - this is to do with + being string concatenation - so it evaluates to : '2133' &lt; '3321' And then you get operating overloading - as the '&lt;' operator compares the two strings for which one is 'alphabetically' earlier - this case '2133' comes before '3221' in a string compare
Start by converting your book to Python 3 and OpenCV 3. Sell it as a digital download and include as a free bonus the old version for people that need to support Python 2. You are obviously targeting a different demographics than Zed Shaw, so you can probably ignore his rant about Python 2 vs Python 3.
Don't have time to read through this (and I only know a little C, and no C++). Do you have any recommendations for handling the namespace issues that arise with compiling C++ to a python module? I was reading on this maybe a year ago, and all the function names were mangled so that I couldnt simply call module.func(), but instead module.func123456(). The calls worked, just the naming convention was wrong. If that's covered in your links please let me know and I'll read through later.
It's simply because at this point in the book we haven't introduced properties. We can't really introduce properties until we have introduced classes, attributes, instance methods and, ideally, decorators. Learning is a journey, and there's little to be gained by overwhelming readers with too much in large indigestible lumps. In any case, getters and setters for retrieving and modifying internal object state (even when wrapped up in properties) aren't particularly good object-oriented programming style compared to telling objects what to do and giving them the information they need to do it. Hardly 'best practice'. Hopefully you'd guide and assist somebody who wrote code like this for you rather than just rejecting it outright. Code review is as much about education and knowledge sharing, as it is about correctness.
I'm not very familiar with R but AFAIK the '=' cannot be used in functions. '&lt;-' can be used everywhere.
Awesome, I'll DM you shortly. Although I've trained/competed in powerlifting for several years, I have a pretty well-rounded understanding of weight training as a whole (general fitness, strength training, olympic weightlifting, strongman, etc.), and would love to bounce some ideas off of you. 
I'm pretty sure at this point you can use = anywhere you can use &lt;-. I know I've written functions with = sprinkled liberally throughout.
Yes.
Alignment of values.
You are quite correct in general, however the CPython interpreter is willing to overlook that: &gt;&gt;&gt; type( False | ( 1 &lt; 2 ) ) &lt;class 'bool'&gt; However now I am thinking: yes, that is the result of dynamic execution: the interpreter, at run-time, says, oh, I am doing bitwise-or but I have a bool and a bool, I will help the user by doing what she means not what she said... bool! But mypy is not doing dynamic execution, it is running down the ASTree, seeing "&lt;arg&gt;|&lt;arg&gt;" and says, "probably int, at least for many &lt;arg&gt;s". 
Haha, its DFT code. But I am naming my code Biscotti to pair nicely with it. :)
Oh, right. Thanks :)
That looks excellent!
Your are correct. I was ignoring the PBKDF salt currently as the AES IV serves the same purpose (different result when reusing the same password). I am not sure if this a safe assumption though. :-) Also I was thinking about replacing key derivation on both sides with a key exchange, like PAKE. Didn't come around to it yet though. I dont think TLS or GPG would work or be helpful in this case: TLS has the possibility of using a PSK instead of a cert, but that feature isn't available in Python. And GPG only works with keypairs and has no option for PSK, as far as I know. I certainly don't want users to set up and exchange keys or certs before being able to use this. :-)
I realized that I had some errors in my model and was attempting to implement your solution. While I was able to get it running, I'm not sure the calculations are correct. Are you able to match your results with one of the [online tools](http://www.decisionaide.com/mpcalculators/extrapaymentscalculator/ExtraPayments1.asp)
I do analysis at work all the time. We set up API servers for streaming data analysis. The thought of doing that in R makes me shudder. R might have the better ecosystem when it comes to actual stats, but the rest of Pythons ecosystem is far better (networking, etc.) and makes common programming tasks (set up an API, give users quota, etc.) so much easier. 
You can still get checks from them; you just have to request them online and get them mailed. I need checks every once in a while too for those one-off things. I'm really enjoying Simple personally. The app is fun to use and I really, really like the concept of goals and having a better idea of what is 'safe to spend' after accounting for upcoming payments like rent and stuff. Their customer service is great, too. I've had to dispute a couple charges and they were always really helpful. The main downsides for me are lack of Android Pay and lack of recurring goals.
cffi is great
In addition to the convenience functions and Matlab/Matplotlib like interfaces, the integration of VTK with Enthought's "Traits" library to form TVTK which Mayavi uses has the benefit of being able to easily create user interface components that control VTK properties. Mayavi takes advantage of this for all of it's GUI controls. Any object with Traits can be represented as a GUI and GUI components can be more easily composed (with pure python or with "enaml" I think?) than traditional UI libraries, which is one of the fundamental selling points of Enthought's entire platform (of which Mayavi is a part alongside Chaco for 2D plotting and other tools). I was drinking their cool-aid for a while until Python 3 was picking up momentum and they were much more interested in developing their Canopy ecosystem/editor/repos than keeping up with Python 3. Which is odd since Enthought hosts many of the conferences where the "pydata stack" is shared. Regarding Python 3 specifically, they at one point (3-4 years ago?) said point-blank that they wouldn't take it seriously until it was the default on OSX. On the other hand, in addition to porting Traits and support for several GUI backends, they also had to wait until VTK had ported to Python 3, which took a long time. I've read from folks in the scientific visualization community that VTK's development culture is fairly insular and unwelcoming. Add to that the fact that Python is much lower priority than their mainline C++ work and the fact that most of the folks using VTK were fine sticking with Python 2 (perhaps a combination of VTK being old and the tendency of scientific communities to have huge old python 2 code-bases?). Anyways, there was a lot of inertia and culture on the long road towards Enthought's Mayavi 2 becoming Python 3 compatible.... sorry for the diatribe... I'm procrastinating.
Eevee has [a pretty extensive FAQ](https://eev.ee/blog/2016/07/31/python-faq-how-do-i-port-to-python-3/) on that exact subject.
Just to close the loop on this, the mypy issue I submitted was quickly closed by GvR himself, saying it was a known bug not in mypy but [typeshed](https://github.com/python/typeshed/issues/649).
really nice pattern matching, namely a, b = b, a
You, sir, are a man living on the edge.
You're prob right, a little too inside :) Zed's a good guy, has contributed a lot, but boy is he that stereotypical developer on the personality disorder spectrum. 
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
It does from my perspective, although to be fair I mostly deal with the science side of the world.
&gt; `role[randint(0,len(role)-1)]` You might want to give `random.choice` a spin.
This better be focusing on python 3 and not the outdated python 2. The longer we keep python 2 alive the slower the python community evolve because of the divide. Its time to move on folks! Nope. It's just supports python 2. Whatever Just for giggles i hope they'll break python 4 and have the gil removed.
&gt;&gt;Not Bob and Alice Suspicious, this guy may not know what he's talking about. /s In all seriousness though, excellent write-up. Certainly if OP intended this for widespread adoption, it should be changed as you suggest. Practically, of course, OP probably does not need to worry that his neighborhood happens to contain malicious actors capable of both recognizing his traffic and then successfully exploiting known plaintext attacks against it. (And even if he did, there is little reason to suppose he is a target worth the effort.)
Avoid swig like the plague
I've used R quite a bit. It's easy and and fast, and I'd have no problem working for a company whose stack was based on it. But the syntax is incredibly ugly in comparison to pretty much any mainstream programming language.
Being pythonic isn't the solution to everything. It's a complicated world and not everything fits the Python scaffold. In fact, matplotlib is very unPythonic, but in a bad way. Ggplot's grammars of graphics might not be Pythonic, but it is *good*. It's intuitive and sensible. It's not hard to understand and once you understand it you'll tell yourself, oh yes, this makes sense. Unlike things like matplotlib, you constantly go, "wtf is this?".
It seems like you're saying we shouldn't import things because they might depend on things (and so on) and your compromise is to do local imports - which will load the dependencies into `sys.modules` anyways - but this just ends up obscuring your module's dependencies. 
&gt; &lt;- and = are equal While they behave similarly in a global scope, they are different. For example, using the two inside a function: median(x = 1:10) x ## Error: object 'x' not found versus: median(x &lt;- 1:10) x ## [1] 1 2 3 4 5 6 7 8 9 10 ([source](http://stackoverflow.com/questions/1741820/assignment-operators-in-r-and))
This would be a great project for you to try out a templating engine like Jinja. That lets you easily edit the text without having to mix it up with code. 
Represent and analyze data with [pandas](http://pandas.pydata.org/)-dataframe-based networks: [DeepGraph](https://github.com/deepgraph/deepgraph) I use it as a research physicist working on complex systems. So far I have used the package for neurophysiological and climate data. It's very handy if you want to compute and analyze relations between objects of some system.
Yes, I agree it's helpful to have the assignment operator unambiguously different from the logical equality operator (which is often `==` but in mathematics is `=`).
Unless you make a keybinding for it. 
OMG! That is what I am planning on doing this weekend. 
Nope: &gt; within(list(), x &lt;- 1) $x [1] 1 &gt; within(list(), x = 1) Error in eval(expr, envir, enclos) : argument is missing, with no default
We are an insurance company. We make money by paying out less in claims than we take in for premiums. We operate exclusively as a provider of [Medicare Advantage](https://en.wikipedia.org/wiki/Medicare_Advantage) plans, which is essentially private administration of public Medicare. The (greatly simplified) explanation is that the federal government says they think it will cost $X to take care of the average Medicare enrollee (over 65 or disabled); we say we can do it for less; and they say great, we'll split the difference. One of the important details is that Medicare Advantage premiums are paid on a risk adjusted basis, so we may get $Y for the average, healthy member but we might get 1.5*$Y for a member with diabetes (purely for illustration, not the real multiplier). If we do nothing special, that member is likely to cost more than the extra premiums cover (extra hospitalizations, etc.). The cool thing, and where our business model comes from is that, relative to hospitalization, proactive primary care is relatively inexpensive. If (and this is a huge "if") you can get a person's diabetes under control, you can **VASTLY** improve their quality of life and substantially decrease their medical costs. For us, health insurance is a problem of logistics and data; more than 95% of the software that we build is internal tools for the nurse practitioners and call center operators at Clover Health. We use software to identify our most at risk members and then we see what we can do to help. Sometimes it's as easy as identifying people that haven't filled prescriptions (harder than it sounds), calling them to ask why, and finding a pharmacy that is closer to their home and doesn't charge a co-pay, or even signing them up for mail-order prescriptions. At the end of the day, hospitalizations are **SO** expensive that preventing a single hospitalization can be profitable, even if we send our staff to visit them, and encourage them to visit their primary care physician *more*. So, for us, an unhealthy member is someone that we can do a lot for and doing so directly aligns with our financial incentives. The thing that differentiates Clover Health is that we are a health insurance technology company, whereas our competitors (United Healthcare, Aetna, etc.) are health insurance bureaucracies. Bureaucracies just cannot handle the individual focus and rapid adjustment that a technology company can. It's not easy for us either, but every time that I hear a story from one of our members or see a graph showing improved medication adherence, I know that what I'm doing really matters. If we can also make a profit: great, we can hire more nurses, engineers, and data scientists to do an even better job.
I liked how pandas started out, but after adding on features to keep up with dplyr the syntactic beauty fell apart.
I guess I was wrong, then.
If I had to pick just one thing, it's the iterator protocol. I find Python's for loop extremely intuitive and being able to hook into it with no fuss is fantastic. And then there's the whole suite of things that use it as well. 
 def main(): while True: filepath = input('File name: ') try: with open(filepath, 'r') as f: lines = f.readlines() break except FileNotFoundError: print('File not found..') for i, l in enumerate(lines): if 'Variables/Columns' in l: for line_to_print in lines[i:i+6]: print(line_to_print.rstrip()) print('\nAll done!') break if __name__ == '__main__': main()
Thanks, this is a fantastic reply. I got to step 2 :P Listed all the modules using: import sys file = open("pylog.txt","w") file.write(str(sys.modules)) And oddly the modules for pip and openpyxl are not listed, though I CAN use both of them until restart. They are installed at /usr/local/lib/python2.7/site-packages accorcding to shell if I try to overwrite/update them... Any suggestions? Is it site-packages that ends up being temp somehow?
Also Pomegranate on Python for lots of Bayesian and probabilistic programming.
I must say I'm usually more interested on library dependencies (i.e.: pip requirements.txt) to make sure the env is correct or on function dependencies (i.e.: what does a function need to work) than on module dependencies (and if you really want to do that analysis, I'm sure the tools which work for making dependency analysis of modules will take local imports into consideration). On the other hand, the problems I described are very real and I don't see a better solution (although I'm open to it). For instance, on the conda case, we have a build process which takes 15 minutes, and from those 15 minutes 5 minutes are just calling conda and waiting for it to process the imports which it'll not need in the first place on the particular command lines it's called with (yet, it always spends all that time doing the imports) or a test which will test a simple function of a module will spend the time importing things it doesn't care about (for instance, if you're going to test conda, even to run a simple, tiny test on something from its command line, you'd have to wait for almost half a second warm-up, which IMHO is not acceptable). My impression from the comments is that people think those are non issues -- which is fine if they are willing to spend their own time waiting for something which isn't needed, although personally I think that's unacceptable -- and so far I saw no constructive comment on a better solution. 
++ for a library I've never heard of that solves the main problem with C++ extensions (verbosity) with a tidy, self contained package
&gt; It's like they bought the license for a handful of "reaction" tracks (surprise, climax, sadness, major plot point, etc) and never use anything else. Because that's *exactly* what they did.
It is the de-facto language for statistics in academia.
Here is a reference: Programmers need to learn ~~statistics~~ python 2 or I will kill them all /s
Hm... 502 is not "Connection Refused", but "Bad Gateway" -- well, at least in HTTP land, and that usually happens when the load balancer/proxy to the real server loses connection to said server. The whole 5xx errors represent [server errors](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#5xx_Server_Error), which you have no control over (it's *their* side breaking, not yours).
I think you are referring to the auto-generated manpages, which cannot contain graphics and are not intended to be used as a comprehensive manual. The package vignettes, especially for graphics packages, are usually very good.
Variables in side functions are only local to that function. you need to pass them through of make them global. a mixture of the two would be : X = 0 Y = 0 Z = 0 def function_1(): global X global Y global Z X = 1 Y = 5 Z = 8 def function_2(): a = X * 10 b = Y * 10 c = Z * 10 return a, b, c def function_3(a, b, c): print(a) print(b) print(c) def main(): function_1() a, b, c = function_2() function_3(a, b, c) main()
No, I meant I have around 40 libraries (which compose 10k modules) and depend on 150 other libraries (all with their own set of modules), now, on one point or another I use all those 150 libraries, so, if everything was put in the top level for each module, I'd be importing everything to start up my application (which is just nonsense but the way the "standard" Python coding style would go to). Also, I don't see the "module" as the main point of dependency (in Python the standard seems to be putting a lot inside a module for a non-nested API, so, the module is usually dependent on many uninteresting things for the actual functions which will be used from it), rather I see libraries (with requirements.txt) as the main point of dependencies (and anything inside the library may depend on anything from the requirements), and I'm usually interested in what a function depends on, not a module. 
Yeah, I know about the 502 message weirdness... I'm just typing verbatim what the error reads on my terminal. Not sure what the deal is.
I'm pretty sure this is not a behavior that you should rely on as it is an implementation detail, *not* a feature. If you need the ordered property, you should still use an `OrderedDict`. I certainly wouldn't consider an unreliable implementation detail "super awesome", since you shouldn't actually be *using* this property for anything. Frankly, I'm a bit worried that this is going to lead to some subtle bugs out there (but not worried enough that I'd actually advocate deliberately scrambling dictionary keys).
Compared to web, how hard/frustrating was it? And how would you compare the results in terms of potentialities? PS for making style a little less tk-ish for every widget you can use a **prefs that is a dict with your prefered stuff like bg colors and al. Cf this gist for an example https://gist.github.com/jul/e9132abe8b5aeea573917191591fb90b (search for **pref) PPS I am the troll who wrote http://beauty-of-imagination.blogspot.fr/2016/01/tcltk-vs-web-we-should-abandon-web.html so I am curious to see if I was the only one pleased with going back to tk 
well the programmer can make profit himself also i am the proccess of making it myself
Json dumps and loads. Use them all the freaking time for data parsing requests that come in. 
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Wow. Thanks for the help. Both options looks many times better than my original code. I'll definitely update my source code and use this method in the future. 
No license?
So, let's say that your folder looks like this. . ├── package │ ├── __init__.py │ ├── fileone.py │ └── folderone │ ├── __init__.py │ └── filetwo.py └── script.py 2 directories, 5 files And in this folder in every file, I add the following lines. import os current_directory = os.path.dirname(os.path.realpath(__file__)) And let's say `script.py` has the following. import os import package from package import fileone from package import folderone from package.folderone import filetwo if __name__ == '__main__': print('The folder that `package` is located in is \t {}'.format(package.current_directory)) print('The folder that `fileone` is located in is \t {}'.format(fileone.current_directory)) print('The folder that `folderone` is located in is \t {}'.format(folderone.current_directory)) print('The folder that `filetwo` is located in is \t {}'.format(filetwo.current_directory)) print('I can find use my knowledge of the location of filetwo\n\tto find the package root from anywhere by using this - {}'.format(os.path.join('..', filetwo.current_directory))) The output of running `script.py`, regardless of where I run it from will always be the following The folder that `package` is located in is /Users/$USER/myfolder/package The folder that `fileone` is located in is /Users/$USER/myfolder/package The folder that `folderone` is located in is /Users/$USER/myfolder/package/folderone The folder that `filetwo` is located in is /Users/$USER/myfolder/package/folderone I can find use my knowledge of the location of filetwo to find the package root from anywhere by using this - /Users/$USER/myfolder/package/folderone You can also use `package.__file__` sometimes to find the location of the file, or use the `inspect` module. 
See [this](https://www.reddit.com/r/Python/comments/5ejyr3/how_can_i_make_a_python_script_read_a_file_whose/dah2645/) answer and let me know if that still doesn't help. But as mentioned by other people, this question is more well suited for /r/learnpython or stackoverflow 
Why are you running the game on a VPS? 
I'd start by reading [Porting Python 2 Code to Python 3](https://docs.python.org/3/howto/pyporting.html).
&gt; Of course the devs' real reason is that it's hard, not mathematically impossible. I think the more likely situation than "it's possible but hard" is "it's possible but you wouldn't want to do it". Suppose there were a 2to3 transpiler that resulted in Python 3 code that was both horribly inefficient (both in terms of memory usage and speed) and horribly unreadable. As long as it eventually resulted in the same output on a system with unlimited resources, it would prove that Python 3 is Turing complete to his satisfaction. But who would want to use it? There's already a system that requires some manual intervention but results in much better, more efficient code. It doesn't prove that Python 3 is Turing complete, but it's actually useful.
I guess the question is whether dictionaries are guaranteed to be ordered with the new implementation or if there's a chance they'll end up out of order. Even if it's not a feature per se, if the implementation is such that dicts *can't* lose their order, then I see no problem with relying on it. I really just don't know enough about it. 
Oh man, are you in for some fun! First off, it is generally better for your edification to post to r/learnpython. Other people usually point it out before me, but I consider it to be good etiquette. Repetition is key. Moving on. Without knowing precisely why you are trying to put your code together that way, I'm not going to comment on it, save that it seems like something that would have to have a very good reason to exist if it did. You wanna have fun with scopes? Check this nonsense out. def main(): x = 1 y = 5 z = 8 def function_2(): a = x * 10 b = y * 10 c = z * 10 def function_3(): print(a) print(b) print(c) function_3() function_2() main() That should give you the output you're looking for. Figuring out why would probably be a good exercise!
I'v successfully used [gecode-python](https://pypi.python.org/pypi/gecode-python) in the past. IIRC I had to install gecode itself separately.
Why not both? I use Jedi for autocomplete and then turn off pretty much every feature in python-mode except rope refactoring tools
I got through about half of this article before deciding "yeah, this guy just went full retard". He's very clearly the same sort of person who might, for example, hang out in a C++ forum aimed at beginners and constantly go "VIM AND THE COMMAND LINE IS ALL YOU NEED, IDES ARE FOR MORONS." He's the sort of person who legitimately believes that programming **should** be unnecessarily hard and inaccessible simply for the *sake of being hard and unnecessarily inaccessible*, because for some unknown reason he thinks that the ability of one to handle that is a legitimate measure of their character. 
Maybe it's not a feature, but when I realized I could add functions to a list and then call them by reference and have an instant "menu" I was pretty excited. 
Don't try and patronise me when you've literally had to _write a tool_ to better use an incredibly popular website that everyone else manages to use just fine.
https://www.jetbrains.com/help/pycharm/2016.2/configuring-keyboard-shortcuts.html Better suited for /r/learnpython 
I don't quite understand what you're saying, could you link me to an example?
Didn't know about *argparse*.Will surely check it out. By the way, do you know how could I use BASH commands with python? I tried that using *subprocess* library, but there were some problems.
I think there's a `args.parse_args().as_dict()` member function you might rather call than just reference `__dict__`
I got it. I did: something =('.state', '.extension') if saves.endswith(something): Now I'm trying to learn how to do a progress bar. 
I'm converting some old rails project into django. still not used to django's testing style (i'm using lettuce). overall doesn't seem too difficult
By bash commands I assume you mean the standard coreutils programs like ls? And the best way depends on what exactly you want to accomplish. The os module has functions to handle manipulating directories and files. If all you need to do is invoke one of the utilities from your script, the fork-exec-wait pattern works fine. The subprocess module will also work, and makes it easier to interact with the utility by directly connecting to input or output pipes. 
jedi-vim and VimCompletesMe for autocompletion. [ropevim](https://github.com/python-rope/ropevim) for refactoring. A [flake8 compiler plugin](https://github.com/drgarcia1986/python-compilers.vim) for building. Gutentags and Universal Ctags for building tags
The [IPython](http://ipython.org/) interpreter - which is an alternative to the standard interpreter - can do that. For example, you can type `ls` in the IPython prompt and list the current directory's contents. But that's just for use within the interpreter.
Next up: [Instacart](https://www.instacart.com/) integration.
http://stackoverflow.com/questions/5751689/using-logical-bitshift-for-rgb-values
Sorry, im not well versed with terminals. Can you please provide an example of what you mean?
I used to used python-mode for a long time. It was pretty nice, but I kept running into performance issues, especially when working on large projects - had to keep tweaking the settings - I think I had to disable rope and some other stuff to prevent freezes. Think I also had to disable some folding feature for perf issues, and use vim-fast-fold instead. For completion, I used to use YouCompleteMe, which worked nicely - though you had to keep recompiling libs when an update was rolled out. I think there are also issues where you can't have python-mode and jedi-vim side-by-side - not sure if issues are resolved. (ie. if you wanted most of python mode features, but wanted to use jedi-vim for completion, etc). For linting and all, syntastic works well. I think I disabled python-mode's linting and enabled linting in syntastic. At some point I think I just disabled python-mode altogether. All I missed were the convenient motions to select/change/delete methods and classes - cim, dam, viC, daC etc etc. I'm currently redoing my vim setup. I'm using neovim now, using neomake for supa-fast async linting. For completion, I'm using deoplete along with deoplete-jedi. I had to install jedi-vim as well to be able to have the 'go-to-definition' feature (disabled completion in jedi-vim - since that is handled by deoplete-jedi).
&gt; And that works more reliably in Py2 (if you know what you're doing) Ah, and here's the part where you hide a bunch of stuff under the rug. It's like people who resisted CSS for so long, saying table layout was so much simpler and just worked: they were secretly glossing over all the hacks and tricks and workarounds they'd internalized to make table layout work, and then comparing that "just works" situation to CSS, where they didn't yet know all the hacks and tricks and workarounds. You probably know and do a lot of things to work around Python 2's string model without realizing you're doing that (and granted, the language helps you with it a bit by letting you do dangerous things and not complaining about them). But I suspect most of what you complain about is not "Python 3 makes this impossible", but "Python 3 requires a different set of tricks to do this, and I haven't learned them yet, so compared to the ones I already know for Python 2 it seems much more complex and difficult". Meanwhile Python 3 still picked the right way to handle strings.
I *literally* spend 1 hour to avoid sorting through a hundred videos every morning. I would dare to say it made MY life easier.
You might want to head over to /r/learnpython. To help you start off, you can get that data into python like this: survey_file = open('filename.txt', 'rt') survey_lines = survey_file.readlines() survey_file.close() The first parameter for `open` is the filename, and the second is how you want to treat the file. `'rt'` specifies that you want to read text. However, a better practice would be something like this: with open('filename.txt', 'rt') as survey_file: survey_lines = survey_file.readlines() Using `with open...` is better because it will close the file automatically (as well as other reasons). This means that you don't have to worry about remembering to close the file. 
In 3.6 there's an `f` print function. I'm not even sure what it's called. name = 'Bob' f"My name is {name}" Edit: They're called formatted string literals [Source](https://docs.python.org/3.6/whatsnew/3.6.html#whatsnew36-pep498)
Hey, currently it mostly hand tuned, but I've been looking for ways to apply machine learning to the system. Actually I think it would not be that hard to do poetry with hand tuning and then we could add learning techniques later. Right now, it is a private GitHub. I can add you though if you have a GitHub user name or email? My GitHub user name is wpr101
There's also [plumbum](https://plumbum.readthedocs.io/en/latest). You can write shell commands like so: &gt;&gt;&gt; from plumbum import local &gt;&gt;&gt; ls = local["ls"] &gt;&gt;&gt; ls() u'build.py\ndist\ndocs\nLICENSE\nplumbum\nREADME.rst\nsetup.py\ntests\ntodo.txt\n' (Taken from plumbum's examples.)
If obs doesn't want to record the game, try changing the backend renderer for pygame. (I believe it's done through a enviroment variable) Try setting it to opengl or something
It doesn't print. It just returns the string with interpolated variables. Otherwise it'd be pretty useless
Doing this with dicts is how you implement cases in python.
It's evaluated immediately. IIRC. there was a similar PEP for i-strings that did support some kind of lazy evaluation
That's what I thought when I read the pep, and I don't understand the need for this. If it can only be evaluated the one time, how is it any different that the example code I pasted?
shiny
Also, [check this one out](https://mkaz.tech/python-string-format.html) for more awesome usage for formatting text. Named arguments and padding are two personal favorites.
&gt; Unlike, subprocess, you can pass the string as you would straight to the shell. but why would I want that? List = unambiguous, rock solid list of arguments. Going to town with a shitton of space ridden filenames? Just works. Horseshit with word splitting, quoting and escaping is a decades old problem in shell scripting and people are forced to jump through the hoops to write remotely correct scripts. I actually used bash a lot and "let's import bash problems to python because hey, they feel familiar!" is the very last thought on my mind. It doesn't look nice? Calling cli tools from python doesn't look nice in the first place.
It's basically a different syntax, although there are there *are* some differences in what you can do with it iirc.
Hey, you're right, I really like your script and have downloaded it for my own use. I especially like how it aligns the decimal point of floats. Well done, and thanks for sharing it!
Do you mean compared to python Web stuff? It's completely different, you can't even compare. I'll look into prefs thanks! Let's be honest, it's just a porn generator really. Type in some key words on the box and view images in the GUI or both images and video in a Web browser.
So essentially you are giving up security for a convenience not to type 5 extra characters? As a conceptual hack it is interesting though.
Not python but I've been using [the Node http-server](https://www.npmjs.com/package/http-server) and it is a freaking dream. All I need to do is the following cd ~/path/to/site http-server Done. Its remarkable.
Pretty well used feature, but when first I discovered python's list and dictionary comprehensions years ago, I was absolutely blown away. I still am blown away. I feel like a neanderthal in most other languages when I have to write loops that can otherwise be expressed as comprehensions.
Or in Python 3: python3 -m http.server
Just don't use functions?
As dicts are key (no pun intended) to the way that cpython works I don't understand your "heavy objects", could you explain please.
I think you remember incorrectly: if I'm not mistaken, any use of f-string can be rewritten using `.format`. The [docs](https://docs.python.org/3.6/whatsnew/3.6.html#whatsnew36-pep498) seem to say as much.
Now that you've already got an answer for the terminal, as yet another alternative: just use a modern full featured IDE like Pycharm. That automatically installs setuptools in any VM you create via the wizard in the GUI.
I only recently discovered that you can unpack lists as arguments in a function. e.g my_list = [3, 2] def f(a, b): return a * b f(*my_list) 
Though as soon you as want to get around the non-standard evaluation in the tidyverse it quickly turns into a huge ugly mess.
This is not a print function. What you’re seeing is the REPL here; the real thing that happens is string formatting. You can: name = "Bob" greet = "Hello, {name}!" And you can do anything with `greet`, which will contain `Hello, Bob!`
Yeah... From the comments section of the blog, there is no plan to support Python 3 in Pyston, and Dropbox doesn't use Pyston in production. Since it already has been in development for a couple of years, by the time it is deemed stable enough for Dropbox's own usage, Python 2 will be even more outdated. I know that a lot of people moved to Python 3 when Python 3.5 was released (I'm using both 2.7 &amp; 3.5 but will move completely to 3.6 after testing). Maybe that wasn't expected when the project started.
&gt; This doesn't work, says that the line variable is not defined Works fine here. 
did you get to the part where you can do the same with dicts? my_dict = {'a': 3, 'b': 2} def f(a, b): return a*b f(**my_dict) # equivalent to f(a=3, b=2) 
Yeah, fuck everything about not being able to do this in Java. They overload + for String, but won't *let you* do it for your classes.
c++ can do operator overloading too. I am not sure why java left it out and chose the ridiculous verbosity for domain specific logic. I am not a java pro, but another thing that is arguably retarded in java is ==. Imo python has it right and java is ass backwards. `obj.equals(obj)`? get the fuck out of here. Convenient syntax should go to the mainstream case. 99% of the time people care about logical values represented by variables/objects. If you really really want to test actual identity you can, with a bit less convenient tool.
I always use this little class to use subprocess easier and it works like a charm: https://gist.github.com/awesomebytes/fd1dba778c3569d09702
`python3 -m http.server` Great trick when you need to move files to another between computers on the same LAN, works instantly.
My life changed when I discovered list comprehensions.
Might add that a unique value is generated for each XY coord which is the number that I want to represent as a color pixel. 
Late to the party, but I discovered some sweet implementation details of Python by accident. Notes [here](https://norvoshipriest.wordpress.com/2016/06/06/pythons-number-caching-and-code-parsing/) (TL;DR below). I might be wrong on some things because like I said, I discovered them by accident.
Did you save the file before running it? Also, /r/learnpython for questions pls :) 
Generators! If you have a heavy function that return a list of stuff, you can make it faster by just"yield" each element of the list instead of returning all elements at once, making the code more dynamic
Try `import openpyxl; print openpyxl.__file__`. Or write to file, whichever. If it's in /usr/lib, then reboot. If /usr/lib/....pyxl is still there, then you might have an issue with PATH/PYTHONPATH when running your script, maybe bsd has some strange behavior.
O(1) doesn't necessarily mean fast (or even consistently fast/slow), but in this particular case, the results would be pretty consistent (as you're probably not inserting any new functions into the dict at runtime, meaning there will be no re-shuffling or hidden amortized costs -- whatever you paid the first time, you'll pay every time.) But if you're calling the function many times, it'll still be a huge slowdown compared to looking up the function reference from a list, inlining it or whatever alternative may work for the use-case. Like, I wouldn't do this when e.g. performing some task for every pixel in an image, or processing a large list of things, and it has to be fast.
Scala is a bless if you're coming from python, it takes away a lot of the "wow this is retarded" things you see in java.
 Yes,i saved the file as said, but it still only inputs Hello World,no What is your name? to be found. Im sorry for the wrong subreddit!
Look up "PHP register globals" and the resulting security disaster that ensued when the PHP developers decided that it's a good idea to make it work like that by default. For a script the user calls from the command-line, the attack surface is admittedly much smaller, but there might still be ways to exploit this in certain scenarios. Maybe if the script is called from another service with user-input for the arguments, or if the script has setuid.
Agreed, I'm not a mathematician or anything, but i would prefer if languages used math/logic notation "correctly" where its reasonable.
I found Keras to be super simple and fun. But your problem rather sounds like linear regression. For that, scikit-learn would be a good package.
I will assume here that they don't get deleted after a reboot. Try running this command before you run your script : `export PYTHONPATH=/usr/local/lib/python2.7/site-packages`. I am assuming that is correct path, I am on mobile and can't see gp. Do this after a reboot, when you would normally expect your script to fail, and would install again using pip. Don't reinstall, just set this variable. If this works, then you will have to decide which way you want to inject /usr/lib.... into python module search path, there are many ways it it will help you to learn a few of them.
Gotcha! I didn't get that you operated as an insurance provider from the beginning. That's cool! Wish I could work with you but I'm not willing to live that $$$$an franci$$$$co life! I have no doubt you'll get some top notch employees soon anyway if you don't have them already. Thanks for the explanation and good luck!
The 'transpose trick': transpose = list(zip(*matrix))
list comprehensions &lt;3 Didn't know about them in my early days of python, and when I did it changed my life!
 In [1]: 10/2 Out[1]: 5.0 In [2]: 10//2 Out[2]: 5
I use this when creating new model instances in Django all the time. Really keeps the code concise.
As in, python has no switch statement so you have to improvise. Edit: hey downvoters. I was just clarifying what the poster above meant, not agreeing with them.
It just has ls and cd I think. But you can prefix anything with a ! to call the external shell.
/r/learnpython
/r/learnpython
/r/learnpython
/r/learnpython
Thanks, I've already got great advice there^^
I have never benchmarked this in python, but in e.g. C++, you will typically find that just linearly searching e.g. through a `vector&lt;tuple&lt;int, int&gt;&gt;` or even an `int*` will easily outperform something like a `std::unordered_map` until the number of elements you put into it goes into the tens of thousands. (But lots of difficult details here, like e.g. gcc6 has SSO and whatnot, which likely changes the picture e.g. for strings.) Size of the object matters too, because of your limited cache size) A sorted vector/btree can easily outperform a hash map for a long long time (millions or even billions of elements?) even though it is not O(1). (Databases tend to use btrees for indexing) Remember that e.g. "O(1) lookup in the number of elements inside the container" just tells you something about the scalability of the worst-case of looking up something in the hash map, not how long it takes. O(1) could mean it takes a second to look up the element you want -- the only guarantee you get out of it is that the amount of time it takes does not grow with the number of elements inside the container. O(1) could even mean that it takes a second on the first lookup, a day on the second lookup, a week on the third lookup, ... In practice, it takes some time to compute the hashing function, and there are a lot of various implementation details (closed/open hashmap, where is the data stored, what is the loadfactor threshold for your hashmap, etc) and looking things up is typically also not the only thing you do -- inserting into a hashmap can take a long time, if the loadfactor threshold is exceeded, all elements may need to be shuffled around etc. Depending on how "hardened" the hashmap implementation is against attacks, certain insertion patterns can also trigger worst-case behaviours and make insertion into hashmaps quadratic etc (as recently seen in rust.)
I think /u/swingking8 was spot on when s/he said to find a project that captures your interest. You'll be *using* the language and not just following a tutorial. But, once you have a feel for the syntax, I can't recommend strongly enough that you look up presentations and writing by [Raymond Hettinger](https://twitter.com/raymondh) and [David Beazley](http://www.dabeaz.com/). If you learn best by reading before doing, Mark Lutz's [Learning Python](https://www.amazon.com/Learning-Python-5th-Mark-Lutz/dp/1449355730) seems intimidating because of its size. But it's so big because it is both comprehensive and accessible for beginners. So depending on what you already know, you can skip large parts. But if you really *understand* everything in that book, you are well on your way to being an intermediate level Python dev.
It's one of the best parts of the language, Id definitely take some time to learn more
Since none of us have any benchmarks there's really no way to know for sure, but one big difference between Python and C++ is how fundamental dicts are to the language. They're the backing for pretty much the whole language (e.g. classes are implemented using dicts), and that code is written in C and has been pretty heavily optimized. Lists are not optimized to the same level so the behavior might not directly map to C++. 
You'd like Haskell comprehensions, then. Even more powerful than Python.
Just write stuff yo. You can read all the books in the world, but if you never write anything you're never gonna progress.
I was already super familiar with functional programming before going into python. Just to have a strong sense of functionality in a non functional language is suuuuper nice.
great thanks!
Or wrap it with a vars() call
Well, it's statically typed regarding the linter, of course. The runtime ignores it but if you consider the linter as part of your development process, there is no difference with a classical typed language which actually most are not type checked at runtime either.
Wait until you learn about coroutines
You need Javascript for that. 
What you're asking for has nothing to do with Flask. You probably want either [Selenium](http://www.seleniumhq.org/) for automating a web browser on the PC your Python code is executing on or client-side JS for opening tabs on clients that visit your Flask site. Client-side JS has restrictions on how it can interact with other tabs for annoyance/security reasons.
1) There are a few (to_datetime, melt) but they are very specific use cases that can generally be completed through methods as well. Especially in recent years Pandas now has pipe and assign, so you can method chain for pretty much anything. Look at this link - I think it represents a fairly logical, clean syntax for using Pandas: https://tomaugspurger.github.io/method-chaining.html 2) This is a known flaw, but if you follow the rule of ignoring .ix and using .iloc and .loc, I'd argue it's fairly consistent. Pandas indexing has also been shown to be faster/better-optimized than R in many cases. 3) True. In Python, you either, as you said, use a string with identifiers, or pass a lambda which requires a reference a la lambda x: x["col"]. 4) This is something that has been actively improved and is highly discouraged. There are many functions that take an inplace parameter, but it's bad practice to use it. Most of the time you can modify things as a return value instead. I work in quantitative finance and I've used both stacks. I actually went from R to Python, the opposite of your move. My opinion, in essence, is that (1) it's not nearly as bad or inconsistent as it may have been in the past, and (2) while R certainly has the more concise syntax, I think the "cognitive load" of typing "loc" or "lambda df:" is a small cost for the benefits being on the Python stack can give you for things other than data-wrangling. 
Thanks for your feedback.
Thanks for your feedback.
Yes, i do this at one moment, but python-mode dont get updates so...
&gt; O(1) indicates a constant time Well, not quite -- it merely indicates constant-time in the number of items in the collection. It doesn't have to be constant in any other kind of variable. &gt; O(1) should theoretically be faster Only faster asymptotically. This means that there is some number N (possibly very large) such that for all n &gt;= N, the O(1) function is smaller than the O(n) function. There are no constraints on what happens for n &lt; N; the O(n) function can be smaller, for instance. So it is entirely possible to have a data-structure (like a hashmap) that first has to perform a very very complex "pre-"computation (the hash) which may take a minute to compute, but once the hash is computed, the lookup of the element in the bucket is very simple (only takes a microsecond.) This structure has order O(1) lookup times, but since each lookup takes a minute, it is obviously slower than just linearly searching through a list, even if the list is of quite significant size. Of course in reality, computing the hash of the key you use to look up the object you want isn't *that* expensive, but it's not free either (and if it accepts an input of variable length, such as a string, then it is itself not constant-time but linear in the length of the input) -- imagine for instance computing the hash of a string that is too big to fit into cache. Of course it really depends on the hash function here, and how conflicts are resolved (pythons dict implementation uses probing, so in python this can't happen (see `dictobject.c`), but bucketed hashmaps, if there are too many collisions, in the worst case, lookup into a hashmap can degrade to actually be O(n) as well. It would be interesting to do some actual benchmarks on what performance looks like in cpython (also in different python interpreters and different versions of cpython and maybe using numpy ndarrays etc) -- if it is indeed true that dict lookups are always faster, then I feel that that is maybe an indication that traversing lists is not as fast/cache-friendly as it should be!
Everything in the [`collections`](https://docs.python.org/2/library/collections.html) library.
Also check out ptpython and bpython for extra REPL goodness 
I'd use `brew install python3`
Oh goody, I like reading :) I honestly don't know where to start with Python, hence picking up the books for ideas. I'll check out some of the stuff on the sidebar! One question on this, if I may: I'm looking at web development as my secondary skillset, and I know Python is very suited to this. I know of Django, and I've heard of Flask. What I want to do is to develop (full stack) on node.js and a js framework such as ember or meteor. Does Python fit nicely into these?
Yes, there is an "included battery" that does exactly that. You can see it in action if you write `import antigravity` (awesome easter egg!). You can't close it. The **only** thing you can do with it is to make it go to another link. https://docs.python.org/3.6/library/webbrowser.html
This could be interesting...
For me, it was list comprehensions. It got me thinking more in the terms of loops/list processing, refactoring so I can create the loops more easily, etc. That lead into generators, and so on....
SimulateMe! NicolasGuacamole
'It can be relatively low due to two factors: Courseras new model wherein they are beneficial in deeper nets anh and Logistic non-linearities tend to die, saturation of tanhs, magnitudes of activations greatly affects learning. ~/u/NicolasGuacamole ----------------------------------------------------------------------------------------- [*^^[Feedback]*](https://www.reddit.com/message/compose/?to=Simulate_Me_Bot) [*^^[Get ^^a ^^bot]*](https://www.reddit.com/message/compose/?to=iNeverQuiteWas) [*^^[Info]*](https://www.reddit.com/r/FreeKarma4You/comments/5b0r6r/i_am_a_bot_that_will_simulate_you/)
Could you elaborate from the 'and so on'. I have only quite recently begun to use generators.
&gt; 'It can be relatively low due to two factors:nn- Courseras new model wherein they are beneficial in deeper nets anh and Logistic non-linearities tend to die, saturation of tanhs, magnitudes of activations greatly affects learning. That certainly sounds like me... Not sure if that's good or bad.
Will look into it. Thank you! 
It's not exactly an improvisation though, compilers will usually turn switches into jump tables, so they act in basically the same way 
what do you mean by notebooks?
What's that?
sometimes I feel they're too visually complicated for one line of code though.
Are you maybe accidentally running the pyc file and not the py file? 
Dict lookups are definitely going to be faster. IIRC cpython implements lists as arrays of pointers to python objects. 
Oh yeah, that's right it does 
I'm working my way through project euler https://projecteuler.net/archives Forces me to think carefully about how I approach a problem. Makes me much more facile with array manipulation and stuff like list comprehension.
&gt;ptpython `ptipython` is even more useful. It is an alternative REPL that comes with ptpython and provides all benefits of both IPython and ptpython.
Try setting shell=True, that will run the command through whatever you have set as sh. Without it it tries to exec the the first argument as an executable. 
Mastering generators
Do you have any advice with respect to this?
amazing. the circle is complete
My bad -- I missed that part completely.
Link should be http://coconut-lang.org/ (no ssl) I have no experience with Coconut :)
A lot of context at https://github.com/crazyguitar/pysheeet/blob/master/docs/notes/python-generator.rst and https://www.jeffknupp.com/blog/2013/04/07/improve-your-python-yield-and-generators-explained/ For me generators have led to more performant code when it comes to any kind of series calculations. The trade-off is that code tends to be less readable, and definitely not easily understandable by novice developers. 
I don't get this. Could you please give a little code example? That'd be nice. 
Great, thanks. I will look them up.
Minor nitpick, you don't need to take the square root, or even better you could use `math.hypot`, it's faster, and more precise.
That's fair, but yeah, things are designed to prevent cross site scripting. If it's Youtube, couldn't you just embed the video on the page? Then maybe have a like/dislike buttons which connect to the youtube api, performs the action, then calls back to your server with the action so you can track that? EDIT: P.S. basically this is something you'd do mostly on the front-end, not in Flask. Flask would handle the call to record the likes/dislikes on the backend, but calling the video and getting the user input is frontend stuff. 
Not only that, but you create a dynamically allocated mutable data structure which will never be mutated. This, on top of the forced `__getitem__` (extra method call + hash lookup), might be too much for something done many times, such as case lookups. Of course, if `O(1)` is that important, it might be needed, but generally it's not the case. This is why I generally prefer raw `if` statements. On a sidenote, a nice thing with this pattern is that it can be used with `defaultdict` to provide the fallthrough.
Pandas Dataframes. 
Yes because when it's my home computer that is not even online all the time, in the heat of the moment extra five chars adds up.
`dir ()` can often be useful. Pickle is also great. I use those a lot.
The canonical way is to add a `setup.py` to each module and [`pip install -e .` each module](https://pip.pypa.io/en/stable/reference/pip_install/#editable-installs). This is the same as creating a `.pth` file, with the benefit that `pip uninstall` works too and the whole thing is easier to reproduce on other machines.
I just did some quick-and-dirty benchmarks, and it looks like you're right -- even with just 1-100 elements, and under conditions that should be fairly ideal for linear searching (small objects - I chose small random integers in the range [-5, 256]), dict-lookups appear to be faster. I also gave it a quick shot with numpy.array(), which actually slowed things down almost by a factor of 10x, which I do not understand (and when I switched to using a numpy iterator, it got another 2x slower!). Might be worth it to create a more comprehensive benchmark suite that tests this with many more different variations and parameters (different types of keys &amp; values, different python interpreters &amp; versions, different approaches (loop vs filter())) etc. (and also to understand why numpy.array is slower)
`pdb` is magical. `dir` too.
Understanding how iteration really works in Python opens up many possibilities for elegant, high performance code. Use iPython. Learn that **for** does tuple unpacking; play with **zip**, **enumerate**, **all**, **any**; take a look at the **itertools** module. Study generator functions. Focus on plain generators, not coroutines (that's also interesting, but another subject). So, focus on **next(g)**, forget about **g.send()** (that's for abusing generators as coroutines). List, set &amp; dict comprehensions are nice syntax sugar; generator expressions are more important!
Oh, wow, I learned some nifty new python today! It's funny because I was thinking something like this as I was writing the code: "There ought to be a function for this, it's such a common operation. And there is math.atan2, which is a very similar case. I know numpy has a function for this, but I don't want to use that for this small example, so I guess I'll have to do it manually." I should have guessed that python had me covered. Thanks for the tip! :-) 
Who uses coconut? I've never heard of it
 class Foo: # in some third-party lib … class Bar(Foo): # our code def our_new_method(self, …): … obj = some_thid_party_lib.get_foo() # can't change the way we get this object, but… obj.__class__ = Bar # we can still make it into our better version type(obj) # → Bar obj.our_new_method() # works!
Just like you can use * unpacking with any iterable you can use ** unpacking with any object that implements `.keys()` and `.__getitem__()`. This includes pandas dataframes for example. Edit: Formatting
The other super-nice thing that you can do with this is construct dictionary arguments programmatically. I at some point wrote code that initialized some big object with 20+ kwargs that were all mandatory from a website, and you can just get a dictionary and then send it off. Really neat stuff. The one thing I wish you could do is make default arguments a dictionary, because a lot of functions have a ton of defaults and it pains me how you store all this stuff that's really data in the middle of your code.
I have beent waiting for a year but I still know next to nothing about it. Any good tutorial you can recommend?
Yes. You are correct. I didn't mean to imply that shlex was perfect. I'm aware that it has some flaws but I'm also thinking that if I had known of shlex 5 or some odd years ago the first time I wanted or needed to use subprocess then it would have made for some better times in the beginning. IDK or I'd like to at least think that it's there for a reason for it being in the standard library. Thinking in terms of being a beginner, you gotta learn word-splitting eventually but when it gets thrown that in at the same time as someone is possibly just having an introduction to what stderr is and why you need to decode bytes and why you need to remove newlines and why you can't use that alias you just made and why you should know when to use strong quotes and why you should refer to executables by their path ... well it gets frustrating. As for the shell arg, I did say it was counter-indicated so ... If it's two blind men arguing about what an elephant is, then I'm just gonna stand here with my head down and wait for a third so I know which way is up again. peace
You can define how operators will behave for your own types. Here's an example: from math import pi class Real: val = 0 def __init__(self, val=0): self.val = val def __call__(self): return self.val def __add__(self, num): if isinstance(num, Real): return self.val + num() elif isinstance(num, (int, float)): return self.val + num else: raise TypeError a = Real(5) b = Real(6) print(a + b) print(a + 7) print(a + pi) print(a + []) That prints 11 12 8.141592653589793 And then show you a TypeError. This is called operator overloading. EDIT: As proposed by /u/PeridexisErrant, I changed the type comparisons with isinstance() because that was what I had in mind.
Hi, I'm the author of "Automate". The best next steps for any language are getting familiar with the standard library and doing projects. I recommend Doug Hellmann's Python Moduel of the Week blog https://pymotw.com/3/ and the "Python Cookbook" book. For projects, you can work on your own or try tackling the problems on http://exercism.io/ (I like it better than Project Euler)
i'm glad it is contrived. when passing on code, be kind to others (and your future self) :)
Learning a programming language with a different paradigm. Specifically I learned Haskell. It introduced a lot of new approaches to solving problems, many of which I could apply in Python. Now it also made me dislike Python and I now try to do all my projects in Haskell, so take this advice at your own risk. 
That is beautiful! Thank you very much for posting this. I love creating lightweight domain objects, but implementing `__lt__` and co. always felt a bit over the top. I was puzzled for a bit that `key_funct` took a dict of places, until I realized you chose it because the `max` function iterates over dict keys (places), while the comparison function needs the place coordinates: an function that takes a lookup table plus an origin, and returns a key function, lets you avoid hardcoding the lookup table or the origin into the key function. On that note: how do you like this code, which uses a lambda expression to decouple the distance function from the place-&gt;coord mapping? I've added type hints for fun. :-) from typing import Tuple Coord = Tuple[int, int] def distance(pt: Coord, pt2: Coord) -&gt; float: return math.hypot(pt[0] - pt2[0], pt[1] - pt2[1]) places = dict(zip("abcd", [(0, 0), (5, 5), (2, 7), (6, 1)])) coord = (5, 0) print("Place closest to {} is {}".format( coord, min(places, key=lambda k: distance(coord, places[k])) ))
PyCharm editor
The python project is moving to github https://mail.python.org/pipermail/core-workflow/2016-January/000345.html
Creating setup files seems like difficult overkill at first, but it really is the best way to do it. Once you've made a setup.py or two, they are easy. There are so many advantages. 
Agreed. Especially if you don't have any crazy extensions etc it is really just 10-15 lines of metadata, most of which will be the same for all modules.
My (slightly) educated guess is that it has something to do with how the bytecode is generated. Try running your benchmark function with [the bytecode disassembler](https://docs.python.org/3.4/library/dis.html). If you could post the code you're benchmarking here so I could try it myself, that would be awesome. p.s. Thanks for the above explanation of the difference between speed and time complexity.
[Image](http://imgs.xkcd.com/comics/python.png) [Mobile](https://m.xkcd.com/353/) **Title:** Python **Title-text:** I wrote 20 short programs in Python yesterday\. It was wonderful\. Perl, I'm leaving you\. [Comic Explanation](https://www.explainxkcd.com/wiki/index.php/353#Explanation) **Stats:** This comic has been referenced 310 times, representing 0.2258% of referenced xkcds. --- ^[xkcd.com](https://www.xkcd.com) ^| ^[xkcd sub](https://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](https://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_dai0b4x)
http://launchd.info/ http://launched.zerowidth.com/
Reading high quality code from big libraries, seeing best practices and coding that way.
Most programs have user input, so they would have to guess my input.
Getting an in-built understanding of: zip lamba filter yield And: * generators * list / dictionary comprehensions Finally: * ipython * managing virtual environments Oh. And realising *everything* is an object.
Take a look at [this](http://aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html#how-python-generators-work). The whole book is great, chapter I linked was written by Guido van Rossum and A. Jesse Jiryu Davis.
I had a surprise with generators with some cassandra code. While fixing some performance issues i found out that in my particular query list(some_query_result) was twice as fast as: for sqr in some_query_result: yield sqr But as the old saying goes, when it comes to performance there is no way to be sure but to measure. 
Hey, your idea sounds really cool so I got a head start on it, using some lines from Robert Frost. I took only lines from Robert Frost for about 8 of his best known poems, and the lines appear in random order with some spaces in between. I am actually surprised how legit it sounds. http://www.nameamigo.com/robert-frost-poetry Do you have a favorite poet yourself? I could try and make a generator for that poet as well.
As an alternative you might try [click](http://click.pocoo.org/5/) by Armin.
Yes, plus read_sql for any actual queries. I'll also mention that being able to use certain methods like Cx_Oracle's InsertMany will give you a speed up versus a standard insert, for DataFrames with many records.
i think the idea in my head is: will the code be slower if I don't initialize everything at once. I err on the side of clarity, but some people might not.
Yeah, but I think the performance benefits of list comprehensions have been vastly overstated in most cases.
Yeah, statically typed languages are checked at compile time. Not run time, which is the best python can do.
They act the same, but I imagine a switch is more efficient than a general purpose hash table.
thanks
You can use pip install with -e or --editable parameter to create just a link. So, the installed package will be updated every time you modify your project. More info [here](https://pip.pypa.io/en/stable/reference/pip_install/#editable-installs) and a discussion [here](https://stackoverflow.com/questions/30306099/pip-install-editable-vs-python-setup-py-develop).
Learning functional programming. It's amazing how much you can transfer from ML-based languages (F# in this case) to Python.
Mission analysis and trajectory optimization software development at NASA. Usually the theory stuff that i do with pencil and paper comes with calculus, then you routinely rearrange the resulting equation depending on what you know and what you want to know. Therefore I use algebra more than anything else by far. Next is probably linear algebra then calculus. After that is things that are not frequently used, like graph theory and geometry. 
Learning Haskell.
Serves your local directory over http, on whatever port you specify. So you can (eg) test some web-related code, browse html without the usual hassle around `file://` URIs, and so on.
They already included a ton of features in the stdlib random module that a lot of standard libraries don't bother with. It's already pretty full featured. I've had to do weighted choice myself but it's actually really easy to do so I don't see a problem. Look into any markov chain library and it'll have to implement some version of it. If you want an inefficient but super simple way of doing a weighted choice using positive integers, try this: import random weighted = 20*['alpha'] + 5*['beta'] + 1*['gamma'] + 12*['delta'] print(random.choice(weighted)) Bam, weighted choice. If you need the real thing with floating points, it's pretty easy to do (again, markov chain implementations).
Keyword arguments may be given in any order, so it doesn't matter. Dicts are unordered maps. In Python 3.6, they'll be ordered *as an implementation detail only*, so you should still use `collections.OrderedDict`\* if ordering is important for you. \* which as an implementation detail might be a thin wrapper around a `dict`, on CPython. Don't rely on that!
Pretty neat stuff man.
&gt; o pre- and post-increment for python This might be a silly question, but why?
Sorry, the misspelling, capitalization and formatting bother me more than I expected. import pdb pdb.set_trace()
Have you tried IPDB? I've found it to be even better.
I've been trying to get someone else to review my code for a while. It's unfortunately difficult.
&gt; python -c "import this" The Zen of Python.... haha thanks!
Building a DeepQA bot using this comment as a reply to another comment would turn out very strange.
I don't know the reasons, but really, use conda (http://conda.pydata.org/docs/) for this -- if you're interested in using the scientific stack of Python, it'll make your life much easier.
Not Python specific, but I've found function closures to be extremely useful. I often find myself wanting to save some sort of state between function calls, but feel like defining a class is too much.
I have not. Will take a look next session! This one? http://www.ipdb.org/ /s
PhD student in image processing. The standard is MATLAB but I much prefer python so I use that. The math is mostly linear algebra, images are essentially matrices, with some calculus for optimisation, machine learning and Fourier transforms. 
And some things is functools library (especially partial).
Protocols. A protocol is basically a set of special methods (`__getitem__`, etc). If your class implements all the methods of the given protocol, then it's said to implement the protocol. For example, there's a bunch of special methods that your class can implement to be a *mapping*. This way, not only objects of your class are compatible with operators such as `[key]`, but you know that if you ever encounter a function whose argument must be a "mapping", objects of your class can be safely passed to this function. A marriage between C++ operator overloading, and Java interfaces, basically.
Jealous. I only got my bachelors and I worked in financial services for a bit but I really want to go back to school. I don't have the money. In the meantime, I am constantly working on my data analysis skills and math skills. I only have an educational background in Linear Algebra, Econometrics, Calc 1-4, Stats 101, and other mathy undergrad econ courses. Have you stayed in school since your undergrad years or do you have experience in an industry? I want to see if I can ask you about a project idea that would impress a hiring manager so I can start my path going back to school.
Came here to say classes. I did a pretty hefty project just using nested lists for everything, it was disgusting. A more experienced programmer looked over it and said "we're learning classes today." I'm afraid to look over my old code again because I'm pretty sure it'd give me cancer.
That's really cool! Thx!
I was about to write an answer about pandas myself. I love it.
Ah, right, not really a problem with tidyverse itself. Rather than that, it's the bad part of the trade-off of having pass-by-expression semantics in R in general. Yeah, I agree it sometimes gets ugly. Still, to be honest, I prefer having the choice of using pass-by-expression when convenient than not being able to do it at all.
pretty disappointing but whatever. let's keep on beating a dead horse. and see how far the community will go. I used to think that the python3 vs python2 divide was a tad exaggerated. boy was I wrong
If you're an experienced Python (or really any standard system or scripting language) developer, you're almost always going to prefer Python over R - it's much closer to what you are used to. However, if you are from a STEM field that doesn't teach programming and instead uses R, or SPSS, or some other stats based language - you are probably not going to bother putting in the time to learn Python unless someone pays you to learn it - and even then, you'll probably still prefer R. R is a specialist language, and as such, it tends to get the cutting edge stuff from academia faster than Python (often an R package for a new algorithm will be released alongside the paper to encourage use), but the Python data community has become extremely good at porting the most important contributions from the R community to Python - that's why we have libraries like pandas. The article is a good overview of the strengths and weaknesses of both, but I think this is the key quote from the conclusion: "There are so many distributions, modules, IDEs, and algorithms for each that you really can't go wrong with either." In other words, follow your bliss. Personally, I know and use both with the decision resting on what I'm actually trying to achieve. A web based dashboard? Python. Quick data cleaning and exploratory analysis? R. 
my mom said that Python was neat and that made me want to python.
`sys.setdefaultencoding('utf8')` - please don't do this. The function gets removed for a reason. 
&gt; I've never tried Conda, so I'm not sure what they get right. I'm glad they do, though. conda isn't a "python" package manager like pip is... it's like a system package manager, just extracts files and drops them where they need to go (within the environment) this is how a bunch of scientific completely non python related tools can be packaged with conda source: package stuff with conda all the time. conda github says it's a "OS-agnostic, system-level binary package manager and ecosystem"
Good job. Just played around with it and added a requirements.txt, moved the database to Postgres and changed Safari to Chrome using webbrowser. Still not working as expected but I'll try again tomorrow :)
Clear and concise, me likey 
Physicist: lots of geometry for system design, numerical integration of complex functions and Fourier transforms for optics, linear algebra for solving everything that comes up. Rudimentary calculus and differential equations to model things and for error propagation. Spreadsheet math for budgets and schedules. 
Well, there's a big difference between using classes and writing a program in nested lists. It sounds like learning to break things into smaller bite sized chunks was what was important for you. 
The idea of comprehensions has been present in FP languages since forever. Python made it more mainstream though.
Yep, before click I tried docopt, it is nice for simple things, but once you want something more complex it stands in the way.
PhD &amp; about 20 years in. What you need depends entirely on your discipline in science. I highy recommend becoming as good at programming as you possibly can. It's what separates some from others these days--if you can solve complex questions and work out hard solutions through programming, your capabilities expand greatly. 
I mostly use linear algebra, bit of calculas and group theory. Also a decent amount of Bayesian work. Im a grad student studying experimental quantum computing/information. 
BS Physics, MS Electrical/Computer Engineering. Senior Software Engineer as a job. I use PEMDAS if I'm lucky. Mostly just plumbing and translating data between webpages, microservices and databases. Weekly in my spare time, I'll brush up on my mathematical analysis education. Scared if I don't use it, I'll lose it. 
How long have you been out of school? See, the thing is, I am confident in those skills: &gt; plumbing and translating data between webpages, microservices and databases. But I am trying to get back into the job market and I don't want hiring managers to think I am not good at maths. I've never been asked a math question in an interview before, but you never know. It means like I should just keep doing what I am doing and build stuff in Python, SQL, Excel in my free time and talk about it at an interview.. no?
pdb++ with sticky mode was a gamechanger for me
Have you programmed in any statically typed languages? 
How were you able to get `tf` (not tensorflow) etc to work from the virtualenv? Every time I tried that, I see ImportError: No module named '_tf' It's trying to import that from `/opt/ros/kinetic/lib/python2.7/dist-packages.
Not OP but I can usually find an example of something I need to do in the Django codebase. Flask (really anything from pocoo.org) is another good one.
PhD in optics, working in a field that's heavy in nonlinear optimization. Essentially build an optical model to create an image, parameterize it, and perform optimization to find the correct values of parameters. As a result, we use optimization (obviously), but also linear algebra, fourier transforms, and a boatload of calculus. The calculus is the biggest and most important part - for finding search directions for the optimization algorithm to traverse, it needs the gradients of your error metric with respect to the parameters. You can do this with finite differences calculations, but that can take a long time when building images. If you write your forward model's steps in reverse using algorithmic differentiation, you gain a ton of speed in the optimization. We use a LOT of Scipy and Numpy to do our work, in other words.
Shameless self-promotion. https://hackernoon.com/asynchronous-python-45df84b82434
So, does this mean that installing scipy from Christoph Gohlke's site is good if you are just using scipy, but can cause problems when used with other modules that also use want to use the same internalised native library dependencies ? How did people manage with scientific python before anaconda then ? Thank you for your answer :)
working on building a recommendation engine for movies for a school project. Yay for impossible deadlines and sleepless nights!
I've used python-docx for generating Word docs. It works as advertised but don't expect a ton of features and functionalities. It only does the basics. As far as extracting, I think the more you know about XML the better off you are. I don't believe Microsoft Office XML specs are freely available so it's going to be a challenge figuring things out.
What makes them more powerful? 
Best functional programming language out there. It has lazy evaluation built in so everything that pure functions and generators do in Python is just the normal way of thinking in Haskell.
Have you used Ice? Our infrastructure team use it. Id be curious what people's opinions are on how it compares. 
[Fluent Python](http://shop.oreilly.com/product/0636920032519.do) is a great book to learn python3, a lot advansed topics explained very nice. It is very different from other Python books.
Metaprogramming. In general if you're solving a problem with metaprogramming you're probably doing it wrong. It's a lot of cleverness that can be detrimental to readability and there are many better ways to handle whatever you're trying to do. But there are a few cases... Understanding that there is nothing special about the class creation pattern (for example): class Foo(bar): def __init__(self, y): self.y = y def my_method(x): return self.y + x Could be written like: type('foo', (bar,), {y=y, my_method=lambda x: x+y}) Like. Ok. That's terrible and your probably shouldn't do that. But... there are some cases. Let's say you're trying to write a unittest around something that inherits Python's Unittest.TestCase. But you can't have a unittest.TestCase inherited by your unittests because the unittest runner will (correctly) identify it as a unittest and try to run it. If you understand metaclasses you could make a new object that is exactly like the original only it stubs out that problematic unittest.TestCase inheritance. I find myself pulling out metaclasses any time I need to stub out something complicated for testcases. I also find myself much faster at working with blackbox / undocumented python code - I have all the tools I need to inspect it now. But even beyond that understanding how things work under the surface gave me some new tools for solving complicated problems. Once you understand this you can start making dynamic code that changes based on how, why, and where it's called. Sometimes, with complicated problems or legacy code, you need a little bit of magic to make things work.
crontab -e
As you probably know, you shouldn't assign a dictionary to a function argument as a default, because it ends up sharing the dict between all invocations (usually not what you want). So typically there's a check against None and then, yes, an assignment within your function. However, you can define your default dict in module scope, and then *copy* it to your argument variable when you want to use it as a default. You can use a shallow copy if it's just POD, otherwise a deep copy will work. At least that way you keep your data out of your function: MY_DEFAULTS={"foo": 42, "bar": 3.1416} # ... def x(data=None): if data is None: data = dict(MY_DEFAULTS) # shallow # ... 
Honestly if Python had support for it I would use an ADT / struct instead of a class. IMO classes (or at least methods) unnecessarily tie data to behavior.
Be careful though. You may not want to touch Python again afterwards. 
How about http://rodeo.yhat.com/?
Incidentally, this shows how easy it is to get people to run code (possibly as root) without them being likely to inspect it first. 
I use quadratures, gaussian processes, neural networks, PDEs, ODEs. My PhD (which is relevant to my job) was on polynomial chaos expansions which are a generalized Fourier series. I am a computer scientist/engineer/applied mathematician at a national lab working in the verification &amp; validation and uncertain quantification department.
Definitely agree with several of the items mentioned already (PyCharm, generators, closures...), so here's something else that changed how I write Python: Decorators. Being able to slap @retry(3) or @timeout(secs=60) on top of a function definition really simplifies the codebase.
Install [Anaconda](https://anaconda.org) to get all the data analytics packages you need to start, then run [Spyder](https://github.com/spyder-ide/spyder) from there. That should get you started. I started with RStudio and this was my preferred Python equivalent. I had too many problems using Rodeo where changes I made were not saved back to the file. Spyder v2 was slow, but v3 seems vastly improved.
So... of those of us who have packages on pypi, many have now updated those packages. What is your update schedule for packages, or is that not yet one of your concerns?
I grabbed one of the wheels (on OS X) and ran strings over it, grepping out any DLL names. The Windows build doesn't appear to link to anything interesting aside from something that looks to be part of Intel's Fortran runtime. That likely means the extension modules are statically linked to BLAS &amp; co. I'm not sure how Windows handles dynamic module symbols, but for example on Linux, in a situation where some shared library is already loaded that defines a set of symbols (e.g. exported functions from a library like BLAS), as in the case when that shared library was statically linked with its dependency, attempts to load and link a new shared library either directly defining those symbols, or depending on (e.g. a shared copy of BLAS) another shared library will cause the additional libraries to be linked to the statically embedded implementation from the first library, which may be a completely different version, or expecting structure arguments to be passed in, where the struct layout depends on the compile-time configuration. Sorry long-winded answer, I should be asleep already. Basically the advice is the same as my last comment
You're correct on the limitations, but if you want to validate things with mypy you need to think ahead of the code that you want to write; a preexisting code base big enough won't probably validate without changes. But for new code designed with it in mind, it's pretty good. "None" as an optional type is covered by the Optional type, and you can use "Union" for heterogeneous containers if you know all the types beforehand (but this will logically produce a warning if you use a specific method of a type). It also provide specializable generics (that are correctly checked for the instanced type) and with the abc module you can define types or typedefs to "unduck" the duck typing of functions (a little like interfaces in Java). It has some other interesting things, like allowing you to write "stub modules" for binary or third party modules (like header files), but logically if you want your code to be 100% statically validated you need to renounce some things. So I'll rephrase saying that mypy allows you to statically type Python code written with it in mind. 
Looking at a few specific parts of the cpython source code to get a feel for what's really going on: * **The grammar** https://hg.python.org/cpython/file/tip/Grammar/Grammar * **The builtin types of objects** https://hg.python.org/cpython/file/tip/Objects * **The virtual machine loop that "runs" python opcodes** https://hg.python.org/cpython/file/876bee0bd0ba/Python/ceval.c#l1220
Cool, I feel like mypy didn't have those features when I first heard about it. Our codebase at work is too large to convert, but maybe we can look into it for new modules going forward. Thanks
My calculator blew up when I typed in +-/* and pressed ENTER. How do I get my calculator to work again?
I can't reply to such a question without starting to write a whole book (it's a huge, fascinating world), so I'll just give you a few of the amazing, often game-changing topics/fields to which Haskell has introduced me, none(?) unique to Haskell, but all of which Haskell excels at: * purity * separating pure functions from effectful ones * immutability * proving functions inductively (way better than tests!) * property-based testing (way better than hand-written tests!) * equational reasoning * like-for-like replacement * "making illegal states unrepresentable" * higher order functions * algebraic data types¹ and type-level algebra * recursion * tacit programming ("point-free" style) * currying and partial application² * composition * the lambda calculus³ * category theory/laws Each of these could be a book, or several (many are), and each of them on its own has blown the doors off what I thought I knew about programming. Many of these things combine in even more powerful ways. I encourage you to look into it, and not to run away if it seems completely alien at first. ^¹ ^I ^want ^these ^everywhere ^in ^my ^life ^² ^beautifully ^represented ^in ^Haskell ^³ ^Haskell's ^underbelly ^- ^profound ^optimization ^and ^maintenance ^effects 
This sounds like it could be fun--I should have some time on a weekend soon if you like.
Generators ftw!
SimulateMe! PenguinRocketScience
subprocess is the right answer, at least to start with. However once you start using it beyond simple commands, you soon find yourself wrapping it in code to deal with working directories, return values, stdout, errors, etc. It's perhaps better to use the [sh](https://amoffat.github.io/sh/) module instead, which will make your life a lot easier.
namedtuple is a decent substitute.
It's not special - it's a standard single-character variable name with some established conventions: * It is a function in i18n (gettext) that does translation lookup. E.g. `print(_("translate me"))`. * In a Python *interpreter* (e.g. python, ipython) it can be used to hold the value of the last expression/statement, as a convenience. * You can use it as a "don't care" variable to hold the result of something you don't care about. E.g. `x, _ = split(string)`. Unless you're using it for i18n, in which case it is now no longer the translation lookup function! :) 
Fixed, thanks a lot.
What would the code to retreive data like only the words "microsoft" and get the average of all the numbers with that specific keyword be?
Oh, I'm well past that point, sadly. Alas, I must use it at work.
Coupon Save 75% . This Python Programming Professional Bundle is designed to get you up to speed with all the major Python skills you need right now. Learn on your own time and at your own pace, just be sure to learn this stuff
Thanks! The stuff I care about is in the py_src folder of [this repo](http://git.p2p.today). Please ignore chord.py, as that is very much a work in progress.
dask is my jam. 
Coupon Save 75% . This comprehensive course will be your guide to learning how to use the power of Python to analyze data, create beautiful visualizations, and use powerful machine learning algorithms!
Ipython notebooks. God I love those. Easy to chunk up and execute your code. Try lots of different things out. Figure out basic algorithms. I've even started making some online books with them.
it's good to see some people enjoying python. :)
Eclipse does with JUnit
You should look into Visual Code Studio. It's halfway betwwen an editor and a full-featured IDE, IMO it's perfect.
If you coded in Clojure would you see his point /s
Actually if you know where to look, MS has a lot of documentation available on their Office XML formats. Start with: https://msdn.microsoft.com/en-us/library/aa338205(v=office.12).aspx https://msdn.microsoft.com/en-us/library/dd773189(v=office.12).aspx
Discrete maths to prove algorithms correct and to figure out optimal solutions to problems, keeping in mind the lower bounds of the problem in hand.
VBA for all it annoyances is sometimes the superior choice, especially cases like this. Dealing with ms office files can be a real pain, easier to convert the files first if possible, xlsx &gt; csv and docx &gt; txt You can still call the macro from python if it's being integrated into something bigger. To run a VBA macro on startup: Private Sub Workbook_Open()
Is there a way to make it import faster if that is all you want it to do?
Great question Turk! For me it wasn't tools, tutorials, modules. It was when I started making stuff that I use every day. That's a big thing. You get a surge of satisfaction when you log in, reminders and feedback as you use it, a slowly growing desire to make it better. And new ideas for further projects. I've got four things on my desktop that I wrote myself: a menu button, a shutdown application, a sort of info bar/panel, and the newest item, a todo list application. The latter just today replaced the same job as four conky scripts. And it looks a lot better. I have a couple more things to make and then the presentation of my entire desktop will be stuff I made. Behind the scenes I have about 100 minor scripts ready to go, mostly just little things like unit conversion, such as Celsius to Fahrenheit and back, but also some more important things like scripts to manipulate the todo lists, one that sets a random wallpaper on log in, curators when I get sick of one, one that that backs up my current open browser tabs and favourites list. And so on. When you start owning the functionality of your computer, you start setting achievable, meaningful goals. Techniques and tricks which were interesting and cool become *useful* and satisfying.
Isn't Automate the boring stuff with Python free anyway directly from the author's website? No offense to your post, but why spend money on Udemy when you can learn for free.
&gt; In terms of when you do have enough memory, I'm not sure how list(some_query_result) would ever be slower than the generator approach. The generator will be faster if you're iterating over a list and stopping when you find what you want; for a list you'll always have to create the whole thing and throw away the part you don't use, whereas with the generator you only create the items you look at.
An if/elif chain won't have any *extra* function calls in it because you've inlined them. That is, if x == "a": # do stuff 1 elif x == "b": # do stuff 2 vs {"a": function_that_does_stuff_1, "b": function_that_does_stuff_2}[x]() #&lt;-- call Using the dictionary requires you to abstract out the "do stuff" into functions, which introduces overhead when you call them. That overhead, for Python, is sometimes nontrivial.
I've never had a reason to use a map, but I'd never heard of reduce before. Looked it up and it's gold, I will definitely find a use for it.
Good video, keep em coming 
&gt;I've never had a reason to use a map Really? I find that hard to believe. But I guess people tend to use list comprehensions and for-loops instead. Anyway, I find map very useful and you've probably just not *found* a good use of map but I assure you they are plenty. 
Holy shit didn't know about those. Seems nice when all you need is some kind of reusable data container without inherent behavior. My Python game is weak...
I was yesterday teaching my son some Python beginner stuff and I caught myself thinking, I really should show him classes right now, everything would make so much more sense... 
Yup, if I'm working on a project with more than one file, or has any imported libraries, I want syntax highlighting, code completion, and keyboard shortcuts to jump to variable and method declarations. There's no way I'm remembering all the features of all libraries, and I'll discover new ones much faster if the IDE is constantly suggesting things. 
Cool. I was suspicious that "Learning Haskell" was related to learning the core concepts of functional programming per se instead of "Go write code in Haskell, forget Python". But, is it easy to write code in Python following these same concepts as in Haskell? 
What a feeling. That is precisely how I feel too. Tutorials are like stumbling around in the dark. Coding for real life is the process of mapping your knowledge to your reality then filling in the blanks. 
One area that they can help for sure with is when io bound. By using them within async code, then you can perform some processing while waiting on io. If you wrote blocking code to read everyone into a list, then the async/generator approach would win.
PyCharm has some integrations, but I do it from the terminal. 
In this case there is some inline sorting going on too, so a list is needed. But yes.
The speed difference was large enough in this case that i suspect that the cassandra driver is doing a network operation with every objet for the yield approach and concatenates the list method into a single query. Or at least handles it more efficiently.
Taking a functional programming course that was not directly related to Python. Mastering more general concepts allows one to easily understand how things work (in contrast to learning how to use them without knowing the details). For example to understand how Python decorators work, one has to understand the concept of functions beeing first class objects and function closures. These are all well known terms in the functional world. Learning the differences between different type systems, scopes, etc. also changed the way I write code.
Have you tried joblib?
That's really nice advice. I never really write utilities for myself, just for work. I think I'll try to do it more, thanks.
What do you use for logging?
Which company?
actually using ipdb before, but using pdb++ for minimal but required additional features.
not op, but i always logging unknown error and condition.
Without it, I occasionally got errors with strange ASCII codes in user names. Is there another way around?
It's interesting that JKM decided to present parameterised functions rather than fixtures. In my experience, pytest fixtures are both more interesting and more useful/convenient, parameterised tests are neat but otherwise easy to replicate. Fixtures are pytest's answer to setup/teardown concerns filling in for multiple issues, some caused by pytest but most being intrinsic issues of xUnit-style setup and teardown: * method-based setup and teardown are difficult to compose, IME small setup/teardown "mixins" lead to complex inheritance graphs and don't work that well, so I've tended to resort to bigger less reusable or reused ones, commonly no reuse at all of the methods and some setup functions on the side (which would hopefully work) * providing set up resources to the tests is annoying as you have to set them on the test instance, that also makes what resources or set up steps each test needs very unclear * xUnit-style means setup and teardown *of a given resource* are far apart *and* mixed with other stuff (other setups and teardowns, non-resource setup code, …) *and* you have to be very careful to teardown in reverse order from the setup lest you teardown a dependency before its dependent and the teardown blows up (or worse) * partial setup/teardown (a subset of the setup blowing up after some of it has been executed) really doesn't work in xUnit style, unittest [had to grow an addCleanup method](https://docs.python.org/3/library/unittest.html#unittest.TestCase.addCleanup), mixing addCleanup and xUnit-style tearDown doesn't necessarily work correctly (by default cleanups are all called *after* teardown) * using methods, scopes (a group of tests bracketed by a single setup/teardown pair) are pretty inconvenient, older unittest only had test-scope, newer unittest has class and module requiring different hook names * because the canonical test "bundle" in pytest is a function you can't have setup/teardown methods Instead pytest uses "fixture functions", which are simply decorated with `@pytest.fixture`, and are *pretty good*: * Fixtures are dependency-injected, if a test (or an other fixture) wants to use a fixture they just request it by name e.g. def test_sendmail(smtp): … requests the `smtp` fixture, and that's it. Fixtures work the same way, they can just request an other fixture by name to explicitly depend on it or use it. Because it's convenient and explicit, pytest plugins (and external libraries via a bundled pytest plugin) can easily provide fixtures e.g. Django could provide a set of pytest fixtures as testing support without having to have its entire testing framework, [that's essentially what pytest-dj. * fixtures can either return an object directly (with a normal `return`) or perform setup/teardown similar to `contextmanager`-decorated functions: set up, `yield` (with an optional value) and teardown e.g. @pytest.fixture def smtp(): s = setup_server() yield s s.close() this makes for simple and obvious code, with very little distance between the setup and teardown of the resource, and it's compatible with contextmanagers: @pytest.fixture def smtp(): with contextlib.closing(setup_server()) as s: yield s these steps are automatically and correctly ordered between dependencies (such that all dependents of a fixture A are torn down before A is). * if a fixture setup fails, all previously set up fixtures will be properly torn down in reverse order, fixtures encourage small self-contained single-concern setup/teardown functions: one fixture manages one resource, or sets up one configuration point, or creates one type of objects Now these are the simple and obviously convenient use cases, but fixtures also (optionally) provide way more power than that: * pytest fixtures have a concept of *scope* as a fixture attribute (`pytest.fixture(scope=…)`, this defines how long the fixture remains alive before being torn down. There are 3 unittest-like scopes ("function" ~ setUp, "class" ~ setupClass, "module" ~ setupModule) and then there's "session" which scopes the feature to the entire test session, very cool for stuff like starting a test server or semi-static configuration * pytest fixtures are lazy, pytest allows filtering tests (using tags or regex or whatever) and fixtures which are never requested are not instantiated * fixtures can also be marked as `autouse` in which case the fixture will automatically be used for all functions matching the fixture's *definition scope* (e.g. an autouse fixture in a module will be applied to all tests of that module but only them, whereas a project-wide or plugin autouse fixture will be applied to all tests of the project) * fixtures can be parameterised, and will in turn automatically parameterise their dependents e.g. given @fixture(params=['a', 'b']) def demo(request): … def test_foo(demo): … `test_foo` will be called twice, once with `demo('a')` and once with `demo('b')`.
But it's very annoying to do this if diffferent kinds of strings appear all over the code.
Rodeo is pretty awesome, since it's basically RStudio for Python.
`property` and `contextlib.contextmanager` are good ones.
Hard reset it with a hammer. You might need to do a few resets for it to stick
If it's just a for/yield in one line like that, you might want to use generator comprehension syntax or `yield from`. Not sure if that's just a simple example or if you don't know about those. But check out the disassembly of those two (visit link and click "run"): https://repl.it/E9Fz/1 list version: 0 LOAD_GLOBAL 0 (list) 3 LOAD_FAST 0 (x) 6 CALL_FUNCTION 1 (1 positional, 0 keyword pair) 9 RETURN_VALUE None for loop yielding: 0 SETUP_LOOP 19 (to 22) 3 LOAD_FAST 0 (x) 6 GET_ITER &gt;&gt; 7 FOR_ITER 11 (to 21) 10 STORE_FAST 1 (i) 13 LOAD_FAST 1 (i) 16 YIELD_VALUE 17 POP_TOP 18 JUMP_ABSOLUTE 7 &gt;&gt; 21 POP_BLOCK &gt;&gt; 22 LOAD_CONST 0 (None) 25 RETURN_VALUE The top one is fast if list(x) is efficient, but it might use a lot of memory depending on the size. The bottom one is way less efficient in some cases but for a very large `some_query_result` with a lot of computation on `sqr` you'd have to. But you see there's a lot more going on in the generator. It has to setup the loop and go in the for loop, load `sqr`, store it into a local, load the local, yield it, pop top, jump back to the start of the for loop and pop the block... Lots of python instructions run for this to work. But then look at the disassembly of "list". It's None. Pretty sure that means that it's calling compiled C code in cpython's case. This probably means you're comparing C code to a python construct that takes up a lot of python instructions. What you're sacrificing though is you generate a list in memory when you don't have to. It'll depend on your use case, but if some_query_result generates a very large list when you call `list` on it (is a generator itself another words), then you will dramatically reduce your resource usage for not much processing overhead by writing your own generator. If instead of just "yield sqr" you had a lot of python logic then yielded the result, your overhead of using a generator would be less and less of an issue. If it does a lot in the loop, then those 10 instructions don't matter. If it just loops and yields, there's generator overhead. However, using list there's memory overhead that doesn't need to happen.
IME you don't write tests, then you learn about unit testing and you write tests, then you get a job and professionally you don't write unit tests. They're very useful for that 6 month period after you learn them, and for that theoretical workplace that does TDD.
Thanks. Very informative. In my case i always need the entire list and they will not become terrible large by design, so my list approach is the most sane.
I just tried it a bit, I can't say much interesting unfortunately (I wrote some lines of a webscraper, just to have a feel of coconut, which I'm pretty excited about, as with [dg](https://github.com/tomoconnor/dogelang)).
Metaprogramming is the logical choice for some things. Definitely not commonly needed, but when it's needed you will know it. For example, django and classes you write that inherit from django.db.models.Model. So much magic needs to happen for that class to work as a sql table. You get so much for free. Depending on the class variables you set in your class definition inheriting from it, it creates different sorts of rows with different types. It looks super clean as an end result for the programmer using django, but tons of database and backend magic happens which you don't need to worry about whatsoever. Metaprogramming is huge if you're writing a framework. If you want your users to be able to define classes and magic stuff happens depending on their definition, you need it. You almost never need metaprogramming because your end user isn't going to use your code to program stuff. It's a very special case, but incredibly necessary when it makes sense.
Head will do
It may be worth trying PyDev along with its interactive console: http://www.pydev.org/manual_adv_interactive_console.html You can use an editor to type the code and use F2 to send things line by line to a console afterwards or Ctrl+Alt+Enter to run the file in the console and make all symbols available for your current file (and then work interactively). Also, you can have a debugger view connected to the console (http://www.pydev.org/manual_adv_interactive_console.html#full-debug-support-in-interactive-console). This way, you can have all the IDE features you expect -- such as go to definition: F3, browse through all symbols available: Ctrl+Shift+T, find references: Ctrl+Shift+G, etc, while still having an interactive console integration... If you go that route, make sure you take a look at http://www.pydev.org/manual_101_root.html to configure things properly. Can't hurt trying ;)
oh damn, you're right. fixing I screwed it up in two ways... checking x &lt; stop_int when it should be checking 2*x, and yeah forgot the increment.
From past experience Tesseract works better on bigger images (so upscale the image by e.g. 5*). You can also try variant images where you do different thresholding after blurring. This is a very manual discovery process but if you know the answers for a sample, you could auto-tune the process. Since you have segmented individual letters you _could_ also look at machine learning. There's a large literature on recognising single digits using machine learning (from naive bayes through to deep belief networks), but I suspect you'll get quite a long way just with tesseract. Hope that helps, Ian.
I hate MATLAB so much I don't understand how is it even considered an standard. There are much better tools.
Thanks Ian! Could you clarify on what you meant by "do different thresholding after blurring"? I did not do any blurring in my python script, only removing colors and fuzz. Here is a sample processed image by my script. http://i.imgur.com/5F7GROm.gif
The right click menu has some cool stuff too that I really like. * Compare with Clipboard * Local History * Column selection mode * Execute line in Console or highlight some code, then: * Execute selection in Console Some other features I like: * Record Macros under the Edit menu. (Although keyboard macros my usual go-to) * Click the hyperlinks in the Traceback to bring up the source code. It takes you right to the line last called. &gt;File &gt; Settings &gt; Editor &gt; General &gt; Smart Keys &gt; Surround Selection on typing quote or brace * Now you can double click/highlight and surround selection with quotes, braces, parenthesis, etc. by typing one button. You're welcome. * Right click file tabs and split vertically/horizontally to have multiple files displayed concurrently. * Create a template by writing some code, clicking Tools &gt; Save file as template. Use a template by creating a new file, but instead of selecting Python File, select one of your presaved templates. * Click External Libraries which is at the bottom of the Project Menu on the left. You can quickly access all your installed libraries. 
I often used the following approach: use "record macro" feature in word, then open the macro, copy-paste its code to Python editor and fix syntax for use with PyWin32. Easier than looking all these methods and constants in documentation.
I did it using wxpython, and use it on a Windows machine, so yes :)
That was very informative, thank you!
Pygame, Tkinter, Matplotlib, BeautifulSoup and Flask are great tools to create nice Python applications.
 import urllib.request as request from bs4 import BeautifulSoup import string, re, pprint, unicodedata import csv, os, datetime class SecFilings(): def __init__(self,stock_symbol,start_row=1, end_row=10,sort=('date_filed','ascending'), url_root="http://secfilings.nasdaq.com/"): self.url_root = url_root self._get = self.parser(stock_symbol,start_row,end_row,sort) self.export = self.export() def __getitem__(self,filing_id): return self._get[filing_id] def __str__(self): return str(self.pretty_print(self._get)) def __repr__(self): return str(self._get) def pretty_print(self, x): pp = pprint.PrettyPrinter(indent=4) return pp.pprint(x) def build_query(self, stock_symbol, start_row, end_row, sort=('date_filed', 'descending')): #Process the inputted arguments used for our query url asc_desc = {'ascending':'A', 'descending':'D'} sort_ids = {'form_type':'104', 'date_filed':'101', 'period':'105'} sort_by = sort_ids[str(sort[0])] sort_direction = asc_desc[str(sort[1])] #build minimal query to get get total number of records url_template = str("{ur}filingsCompany.asp?SortBy={sb}&amp;{sd}=D&amp;StartRow={sr}&amp;EndRow={er}&amp;selected={ss}&amp;SchValue=0000320193") url = url_template.format(ss=stock_symbol, ur=self.url_root, sr=1, er=1, sb=sort_by, sd=sort_direction) pre_results = request.urlopen(url) #Display the url for our query just so we can make sure everything is on track. print('Accessing url: ' + url + '...') print('Stock symbol: ' + stock_symbol) #Download the results for the first stage of the query print('Searching...') #Make soup, and parse outter table soup = BeautifulSoup(pre_results.read(), from_encoding="iso-8859-1") meta_table = soup.find_all("table",attrs={"class":"body1"})[2] #This outter level of the table contains the "Records X - Y of Z" statement, which is useful data to our parser function. meta_row = meta_table.find_all("tr") #print(meta_row) for record in meta_row: meta_statement = record.find("td", attrs={"align":"center"}).text count = re.search(r"(\bRecords )(\d+)( - )(\d+)( of )(\d+)", str(meta_statement)).group(6) #Parse "Records X - Y of Z" self.count = int(count) print(str(count) + " records found.") query = url_template.format(ss=stock_symbol, ur=self.url_root, sr=start_row, er=self.count, sb=sort_by, sd=sort_direction) self.query = query return query def parser(self,stock_symbol,start_row,end_row,sort): url = self.build_query(stock_symbol,start_row,end_row,sort) print('Downloading...') results = request.urlopen(url) soup = BeautifulSoup(results.read(), from_encoding="iso-8859-1") print('Parsing...') #Find the table table = soup.find_all("table",attrs={"class":"body1"})[3] #Tables appear to be nested for formatting purposes on this page. [3] selects the 3rd level of nested table, which contains our data. #Returns a list of rows in our main table rows = table.find_all("tr") #rows[0] contains some directions that aren't useful to us. row[1] contains headings. All other rows[2:] contain the actual data you want to parse. data_rows = BeautifulSoup(str(rows[2:])).find_all('tr') heading_row = BeautifulSoup(str(rows[1])).find_all('td') #Add two list comprehensions together to create list of headers. Two are needed due to different formatting on headers. headings = [heading.find('b').text for heading in heading_row if heading.find('b') and not heading.find('a')] + [heading.find('a').text for heading in heading_row if heading.find('a')] headings.append('Owner/Filer') #additional heading headings.append('Filing Id') #another additional heading! self.headings = headings row_list = list() self.list = row_list row_dict = dict() self.dict = row_dict #Open a for loop that will take us down to the individual-record level. for record in data_rows: row = dict() #Start parsing the html tags and adding them to row{} dict. company_name = record.find('b') if company_name: company_name = unicodedata.normalize("NFKD", company_name.text).strip() row[headings[0]] = str(company_name) #Should be 'Company Name' form_type = record.find('a') if form_type: form_type = unicodedata.normalize("NFKD", form_type.text).strip() row[headings[2]] = str(form_type) #Should be 'Form Type' period = record.find('td', attrs={"class":"secperiod"}) if period: period = unicodedata.normalize("NFKD", period.text).strip() row[headings[4]] = str(period) filed = record.find('td', attrs={"class":"secreceived"}) if filed: filed = unicodedata.normalize("NFKD", filed.text).strip() row[headings[3]] = str(filed) #Parse the filer name. Tricker filer = record.find('font', attrs={"class":"smallText"}) if filer: filer = unicodedata.normalize("NFKD", filer.text) if 'Reporting' in filer: filer = filer.replace('Reporting Owner: ','') elif 'Filed' in filer: filer = filer.replace('Filed As: ','') elif 'Filer' in filer: filer = filer.replace('Filer: ','') row['Owner/Filer'] = re.sub(r'[\t\n\r]', '', filer) #Parse the list of urls from the href tags. url_list = [link.get('href') for link in record.find_all('a', href=True)] url_dict = dict() #remove duplciates by using set() as an intermediary type url_list = list(set(url_list)) #append root directory for any urls that were parsed as a relative path for n,url in enumerate(url_list): if self.url_root not in url: url_list[n] = str(self.url_root) + str(url) #build dictionary of urls based on file type if url_list: for url in url_list: if 'html' in url: url_dict['html'] = url if 'pdf' in url: url_dict['pdf'] = url if 'xls' in url: url_dict['xls'] = url if 'orig' in url: url_dict['original'] = url if 'rtf' in url: url_dict['rtf'] = url row[headings[1]] = url_dict #Parse the filing_id from the first url available using regex. Not available in any other location. filing_id = re.search(r"(FilingID=)(\d+)", url_list[0]).group(2) row['Filing Id'] = filing_id #Add our newly created row to our list-of-dicts, aka row_list[] row_list.append(row) for row in row_list: row_dict[row['Filing Id']] = row print('Parsing completed.') if self.export == True: export(self.list) return row_dict def export(self,directory="~"): now = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S") filename=str('\SEC_Filings({now}).csv').format(now=now) location = str(directory + filename) print(location) with open(str(filename), 'w') as csvfile: writer = csv.DictWriter(csvfile, fieldnames=self.headings) writer.writeheader() for record in self.list: writer.writerow(record) 
I guess mathematical optimization has the closest relation to my job. Kinda some graph theory and linear algebra I guess. I am a research fellow in computational intelligence.
This function is like 200 lines long, why not just use Python 3? It would take basically no time to convert and you won't have to worry about `UnicodeDecodeError` unless you are doing things really wrong.
Thank you!
Yes, I just decorate my functions with Hypothesis and use pytest to run them.
I had the same experience moving from Haskell to Rust. 
What's the recommended variable name style? Lower case with underscores?
Lmao spoken Iike a true professional. Tbf, I worked at Microsoft and they really do TDD. 
Those could maybe made better by dilate/erode it a few times.
Yes, unless you're working with some old codebase that uses mixedCase (not your case) https://stackoverflow.com/questions/159720/what-is-the-naming-convention-in-python-for-variable-and-function-names module_name, package_name, ClassName, method_name, ExceptionName, function_name, GLOBAL_CONSTANT_NAME, global_var_name, instance_var_name, function_parameter_name, local_var_name
People like matrices for all the things. 
You can check out my [cheat sheet](http://nbviewer.jupyter.org/github/pybokeh/jupyter_notebooks/blob/master/pandas/PandasCheatSheet.ipynb). But just in case nbviewer is still experiencing 503 errors, here is direct [link](https://github.com/pybokeh/jupyter_notebooks/blob/master/pandas/PandasCheatSheet.ipynb) to my github repo for it. Also check out Chris Albon's [site](http://chrisalbon.com/). Once you master Pandas, I would check out blogs by one of [Pandas contributor](http://tomaugspurger.github.io/). 
The problem is that the interest you pay depends on the amount you have borrowed, so you have to take additional payments into account *before* you calculate it. You can still use numpy to calculate the monthly payment, but after that you have to do the rest of the work yourself: def amortize(present_value, interest_rate, years, additional_payment=0): annual_payments = 12 period = 1 monthly_payment = round(np.pmt(pv=present_value, rate=interest_rate/annual_payments, nper=years*annual_payments), 2) additional_payment = -additional_payment if additional_payment &gt; 0 else additional_payment while present_value &gt; 0: interest = -round(present_value*interest_rate/annual_payments, 2) principal = monthly_payment - interest present_value = round(max(0, present_value + principal + additional_payment), 2) yield OrderedDict([('Period', period), ('Payment', monthly_payment), ('Principal', principal), ('Interest', interest), ('Additional_Payment', additional_payment), ('Balance', present_value)]) period += 1
something like that def read_data(): headers = ("score", "selected_answer", "free_text_answer") survey_data = [] with open('filename.txt', 'rt') as survey_file: for line in survey_file: if line.strip(): score, selected_answer, free_text_answer = line.split("|") survey_data.append(dict(zip(headers,(int(score), selected_answer, free_text_answer.strip())))) return survey_data def filter_data(data, search_key, search_phrase): filtered_data = [] for row in data: if search_phrase in row[search_key]: filtered_data.append(row) return filtered_data def get_average(data): n = len(data) return sum([row['score'] for row in data])/n def main(): data = read_data() ms_data = filter_data(data, "free_text_answer", "microsoft") print(get_average(ms_data))
and call `main()`
Lack of validation/sanitation made me cry at my last job (web hosting). Had a customer that wrote a 1 line php script, directly used values from the request in his call to a MySQL related function. 
A bit magic in my opinion, `[thing for thing in _list if thing]`, while verbose, is explicit on what it's doing. This is subjective though.
if you open the file as `f` you can use the `Counter` in the collections module as follows: c = Counter(tuple(row.rstrip('\n').split(' ')) for row in f) Edit: You can then generate your results with something like this for (source, dest), count in c.most_common(): print('{} ---&gt; {} ------- {}'.format(source, dest, count)) The `most_common` method takes an optional argument `n` for the number of entries you want to return.
Are you using Python standalone or the console provided in ArcMap (or Desktop, Pro, etc--I left off at 10.1/10.2)? As suggested by u/elbiot, make sure all dependencies are loaded. Be sure that your installation is pointing to the correct directories.
In the future, consider posting such questions to /r/learnpython. Please read the sidebar. Thanks!
I knew about flake8, pep8 and the like. Never heard of radon which seems awesome. How exactly do you use it? I find it hard to integrate tools that don't provide a strict passes/doesn't pass answer (like pep8 does) into our build pipeline.
I've actually stayed in school since my undergrad, but I get a stipend for the PhD which is enough for me moneywise fortunately. 
I recently discovered the 'py_modules' option as an alternative to 'packages' for single-module packages, which are many of my use cases. Edit: the method with packages=['darling'] and a darling.py in the setup.py's directory doesn't work for me. The module doesn't get attached to the distribution.
You're right, Python is excellent to build MVPs and prototypes. Now, I'm just curious... What leads you to believe that you should eventually switch to another language?
This is pretty general but creating my own custom IDE color scheme helped me a lot I think.
The problem with an IDE is that your DE is so f'ing I that you don't get to do something that some guy didn't anticipate.
Nice! Are all the software ITAR regulated? My lab makes some trajectory optimization software in Python. Mostly focused on hypersonic flight. 
Without actually knowing the Twitter API and whats possible with it but is there a unique identifier for each Twitter post? When I wrote my reddit Reply bot I had the same Problem until I saved each respective Post ID into a database so it wouldn't Reply to the post each time the bot started.
I wrote a debugger using [sys.settrace](https://docs.python.org/2/library/sys.html#sys.settrace), and a Object mapper, which required understanding metaclasses. You learn a lot about the internals of the language and a lot of the nuance.
I do computer system performance analysis and capacity planning. Mostly 4th grade math with a smattering of stats, just to keep it from being totally mind numbing.
That has nothing to do with list comprehensions or generator expressions. It's basically a hackish reimplementation of `reduce`.
Removing the loop doesn't change anything. I'll try changing the indentation for on_error and on_timeout, thanks for the suggestion. [EDIT: I screwed up copying the code into Reddit -- both on_error and on_timeout are attributes of the StreamListener in the code.] Where would be the appropriate place for a count variable?
I'm not saying that python is the wrong tool here, but sometimes [if all you have is a hammer, the whole world looks like a nail](https://en.wikipedia.org/wiki/Law_of_the_instrument). If I was trying to accomplish this on any unix-like system, I'd do the following: `sort datafile.txt | uniq -c &gt; frequency.txt` If you do need to do more manipulatation of that data within python, then sure, go with one of the other answers given here. But if it's just a one-off thing, it's worthwhile learning to use standard unix tools.
Hi, I'm the dev advocate for PyCharm...super video and good comments here as well.
What about Clojure? I thought it will easier to pick up from python since its dynamically typed. I am interested in functional programming but can't decide between ocaml/haskell/clojure
This was amazing, you can tell that person had a really bad time with users screwing up.
Aw! I totally had this one on my list and I must have forgot to include it. Definitely one I use the most, but I didn't know about the second part you mentioned.
In fact, both the question and the answer were written by the powerusers of Stack Overflow and the Python question board to be as fully-answered as possible to keep future users from asking the same question over and over.
The way to preprocess raw text is to first split on whitespace, strip punctuation and invalid characters, lowercase the tokens, then remove stop words. Any reason tf-idf was not used for term weights? Nltk is strictly a teaching tool. It is easy and simple because it is for learning purposes. It should not be used in production.
I'm just curious about your code now.. :)
Very true, yes. No need to complicate the situation until it's actually necessary.
&gt;I saved each respective Post ID into a database so it wouldn't Reply to the post each time the bot started. Genius!! I was having the same problem with my reddit bot and that's a great way to solve it!
If you want some help writing your text-based game, I'd be glad to help. I've got [some experience](https://www.bitmonga.me/web-client).
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
You will still get that one shit lord who replies BUTTERFLY.
You should also pray that your list doesn't have 0 or False in it (tho a simple is not None would fix it)
A recent example I came up with was fixing the annoying way that wx does events. Specifically, when you create a new event you have to do from wx.lib.newevent import NewCommandEvent MyEvent, EVT_MINE = NewCommandEvent() Where def NewCommandEvent(): evttype = wx.NewEventType() class _Event(wx.PyCommandEvent): def __init__(self, id, **kw): wx.PyCommandEvent.__init__(self, evttype, id) self.__dict__.update(kw) return _Event, wx.PyEventBinder(evttype, 1) This is rather annoying, because you have to bind against `EVT_MINE` and post with `MyEvent` instances. Instead, a simple metaclass and base class lets me do class MyEvent(BaseEvent): """A docstring so my sphinx docs look way better""" frame.Bind(MyEvent, handler) wx.PostEvent(frame, MyEvent(a=1, b=2)) This is accomplished by first customizing the construction of the class and introducing the base class to inherit from class EventMeta(type): def __init__(cls, name, bases, members): cls.EVT_TYPE = wx.NewEventType() @six.add_metaclass class BaseEvent(wx.PyCommandEvent): def __init__(self, id=None, **kw): wx.PyCommandEvent.__init__(self, self.EVT_TYPE, id or wx.NewId()) self.__dict__.update(kw) But this doesn't give us the `wx.PyEventBinder` that we need to bind against. The trick here is to make the metaclass inherit from it, so that the `BaseEvent` itself is the instance of `wx.PyEventBinder`, while instances of `BaseEvent` are not: class EventMeta(type, wx.PyEventBinder): cls.EVT_TYPE = wx.NewEventType() type.__init__(cls, name, bases, members) wx.PyEventBinder.__init__(cls, cls.EVT_TYPE) @six.add_metaclass class BaseEvent(wx.PyCommandEvent): def __init__(self, id=None, **kw): wx.PyCommandEvent.__init__(self, self.EVT_TYPE, id or wx.NewId()) self.__dict__.update(kw) This lets me inherit to create a new type, each time I inherit from `BaseEvent` the class will get a new `EVT_TYPE`, I can now create a hierarchy of event types, rather than each being isolated. They can be pickled since the class isn't created in a closure and actually exists in a module namespace. I don't have to carry around a class and an object. I don't have to come up with a crazy naming scheme. All I did was make the class itself an instance of `wx.PyEventBinder` and tacked on an attribute at class interpretation time, then mimicked the closure class created by `NewCommandEvent`.
I like pudb personally. Gives you a console to browse the code, set breakpoints, etc. Great when debugging on a machine over ssh or something
My pleasure :)
I agree, don't give the user the implication that they can choose literally anything, when they can really only choose 2(or 3, or x).
Well, not really: $ python Python 2.7.12 |Anaconda custom (x86_64)| (default, Jul 2 2016, 17:43:17) [GCC 4.2.1 (Based on Apple Inc. build 5658) (LLVM build 2336.11.00)] on darwin Type "help", "copyright", "credits" or "license" for more information. Anaconda is brought to you by Continuum Analytics. Please check out: http://continuum.io/thanks and https://anaconda.org &gt;&gt;&gt; l = [0, 1,2,None] &gt;&gt;&gt; [a for a in l if a] [1, 2] &gt;&gt;&gt; filter(None, l) [1, 2]
Looks like a fascinating article, but I had to come back to reddit to comment before continuing past the first code block: The code blocks aren't monospaced!
&gt;Is it possible to have this script be scalable to all similar documents? Certainly, there's a special file you save your macro in to make it available to all workbooks, for word check out Normal.dotm, for excel its Personal.xlsb (I have no idea why MS can't standardise these things.) Easiest way to get started is to record a macro, copy/paste/save your section and then look at what the code does. It will probably record a bunch of unnecessary stuff but the meat and bones will be in there. If your section is always going to have the same name, it's quite trivial. Unsure how varied your documents will be. This SO question is asking more than you need, but you can probably work out the basics of copy pasting to new files from the code here: https://stackoverflow.com/questions/34026436/copy-contents-of-a-section-to-another-section-without-disturbing-section-breaks VBA is quite verbose, usually easy to work things out without knowing much about the language, and plus MS office isnt going away anytime soon. Though if you are ever asked to do a big project with it run away as fast as you can :)
A `while True break` loop could help you here. # You may want to sanitize the input from the user to make it one case. # Or use something like str.lower while doing comparisons. while True: choice = raw_input('What is your gender? ') if choice == 'm' or choice == 'M': # do something! gender = 'm' break elif choice == 'f' or choice == 'F': # do something else! gender = 'f' break else: pass 
I was just listening to a discussion about this question on the Talk Python To Me podcast. Good stuff.
Older software is ITAR, but going to do whatever it takes to release my current project as open source. It's being designed with modularity in mind so, for instance, different equations of motion can be swapped in and out. That way if some EOM or models are deemed ITAR, the rest of the framework can still be made available. 
Sorry to ask a kind of off-topic question but what IDE are you using? This looks like InteliJ or Android Studio but for Python?
Shoot, it shouldn't be! It looks as if the post got cut off. I started using Hugo and I guess I'm not perfect with it yet
for my build pipeline, i just have a series of command line commands and if they return non-zero exit codes, then i spit out the output and abort. i do that with all three of those as well as unit tests, eslint, etc.
The last option will also allow the string `mf`, and the empty string, which you probably don't want?
i only use classes when using third-party apis that rely on them. even then you can sometimes wrap them with functions. NamedTuples are probably my favorite "datatype" in python, and i have yet to find a purpose where they don't make my code simpler than implementing the same data to a class's internal state.
That would depend on how it is being used. I didn't see a place where it was used. If you are trying to count the number of times you respond, then I'd say you need to initialize it on startup to zero somewhere. And then either directly increment it, or call a count_increment method, on each successful response. But I think you'd want to count errors and timeouts as much as successes. You almost want to implement a full monitoring solution... :-p
REAL programmers user butterflies.
welcome. your password is welcome. now change it.
It is pycharm, made by the same people as intelij and android studio
Same, heh.
Not sure why this is downvoted :(
M/F/Apache Helicopter?
Thanks! Signed up.
Even better was his control panel was prompting the change. Buddy you're not getting out of it, the system will not let you proceed. So stubborn 
Thanks for this. Quite new to PyCharm and fairly new to really putting some effort into learning to program. I got the feeling that PyCharm was good but clearly there are even more amazing features. Thanks for this. Subscribed to the YouTube channel. Looking forward to more.
Thanks! :)
Awesome, I'll have to check it out!
Signed up thanks 
Here's the UK Government's advice on asking users for gender: https://www.gov.uk/service-manual/user-centred-design/resources/patterns/gender-and-sex.html
You should tweet about this so I can retweet you.
From the looks of it, once you register for the course you can finish it at any time.
The divmod library function. Divmod returns a tuple representing the dividend and remainder of an integer division operation. For example: &gt;&gt;&gt; divmod( 7,2) (3, 1) What divmod does is similar to what the hardware divide instruction does. And it uses a distinctively Python feature where a function returns multiple values in a tuple. (Ruby has a similar function that produces an array). So those make it kind of cool. For large numbers, DivMod is actually faster. For small numbers, because Python is high level and because divmod() is a library call it generally doesn't optimize divmod enough to make it as fast as doing both the integer divide (//) and modulo divide(%) operation This StackOverflow shows how to time operations using timeit and how to optimize a library function call by using a local variable. It compares divmod calls with the operation calls. http://stackoverflow.com/questions/30079879/is-divmod-faster-than-using-the-and-operators And learning about that was cool. 
Currently I'm working with the book (I'm totally into it). I wouldn't even dream of possibility to take an additional video course. Big thanks!
Thanks a lot!
That'll definitely save me a few lines thanks xD 
I appreciate the offer. This is just me finding my way around the python language. I'm not that experienced with it yet. 
I actually really like the way Halo handles gender. In the main story, you're playing as either Chief or Locke, so you're a guy, because that's how the story is. In multiplayer, you pick a body type (with or without boobs, wide or narrow hips/shoulders) and that's the extent of it.
Does anyone know how long it takes to get a refund? I just purchased this course a few days ago.
Static types is one of the best parts of Haskell and programming in general IMO. So I would personally go with Haskell. 
Well poop. I just paid for it last week.
You are astute -- I have edited my comment accordingly. After testing that `modules` works, too, I've used that instead of the `py_modules` form. I assume one comes from `setuptool`, and the other from `distutils`, but really, I am not an expert. (Though I don't think I am at risk of being mistaken for one.)
http://www.clips.ua.ac.be/pages/pattern-en#wordlist I want the profanity word list and also if u happen to know where I could get some word list in python to flag pedophiles something along those lines.
I got refund the next day when I used the wrong account to buy some courses. Money took a few more days to come through. HTH 
Just got to NC for almost a month of work. This is going to fill hotel time.
thanks a looot ! xoxo 
Oh, right. Too much Haskelling confused my Python :) Can use a list of chars instead of a string then.
Lucky. I was only data mungling around in excel vba and basic sql querying after college because no one ever trained me at my jobs. I found out the hard way that consultants don't get trained out of college, so I spent so much of my time outside work to learn stuff. I digress.
Impressive tool, and a big need for younger investors.
Wowee Zowee Nifty Keen, Thanks! 
Thanks a lot. I was actually looking at automating some tasks. While I'm already a decent programmer it's always helpful to pick up some extra knowledge.
Should be `__name__` rather than `'__name__'`, as `__name__` is a magic variable rather than a string :)
Look into `subprocess.check_output`. Also, /r/learnpython is a better place for questions.
I disagree. This is something he can use threads for because the slowdown is in the io Even in a language with no interpreter lock, his code would have the same performance. It's serial and blocking. 
Use either python threads or multiprocessing or async. Each time you query Google, you're taking a speed hit. Threads would let your code run while Google is waiting to respond, or multiprocessing would let you run multiple sessions of python at once. Async runs similar to threads but is easier to use. I would try async first if you're on python 3.5
it's tough to comprehend how knowledgeable you are about python with this post, just me... it looks like pauses for 2 seconds, did you see that? 
You didn't ask specifically how I use math **and** Python :P. I don't use Python in my math classes, but I am teaching a group of students who are interested (but can't yet earn credit because we have no official course offering) how to make a text-based MMO with Python.
Thanks /u/AlSweigart. Love your books! Can't wait to go through the video course.
What level do you teach at?
Wow, thank you for putting so much effort into this! This does way more than what I had in mind! I used to write shell-scripts but I am still new to python, so now I definitely have something to work with! I am running this on a linux machine and the csv-file is written in the current directory. Makes it convenient for further processing. :) Thanks again!
High school. I'm not technically a credentialed teacher yet, but I'm just about done with my master's/credential program. Then I'll be moving on teach at the junior college level while I work on my doctorate to teach at a real university.
Signed up, thanks a lot OP! 
Step 1) Get a throwaway mail Step 2) Register Step 3) Find a script on github that will download the course for you Step 4) Enter your email and password Step 5) Wait about 30mins (times may vary) Step 6) Never actually watch the cource cuz aint nobody got time for dat shit
Negative. I am a meat popsicle.
 parser.add_option("--pause", metavar="SECONDS", type="float", default=2.0, help="pause between HTTP requests [default: 2.0]")
Ach thanks. Is there any way to pay money so that you can get a certain number of requests per unit of time?
Free? I am on the Udemy site right now and the course costs $280 (normally $750).
0.5 is fine for development purposes but is completely inadequate for production. We will need some kind of paid service.
&gt; Not sure why this is downvoted :( I must have hit a hot button with the anti-SJW crowd. 
A better idea is: Do you want to be called a he or a she?
Whoa, that must be a totally different course. My course is "Automate the Boring Stuff with Python Programming" by Al Sweigart. If you've found a knock-off copycat, please tell me. The course is normally $50. If you use this post's link, it should automatically apply the free code.
As someone who has worked through the book and videos, I just want to say thank you. I hope you know that this course and book really set me on a new direction in life!
I love pandas more than almost anything. Seriously
On mobile. Raymond hettinger pandas from the ground up on YouTube is nice
Building a Red-Black tree for my algorithms and data structures class
"What's your password?" "The letter 'a'."
Yes! The OpenCV/NumPy/SciPy stack is very mature. 
He probably went with parameterized tests as they're much simpler to explain to someone either unfamiliar with testing or py.test Compare the length of your post to JKM's explanation of parameterization. Don't get me wrong, I love fixtures and make extensive use of them (though I do wish you could fixturize `__init__`, but that's a different matter). 
I disagree that it makes it easier as it opens up the question of which pronoun to use for the user-entered string. A middle ground could be to allow a choice of "male", "female", and (for want of a better label) "other" then set the usual defaults for the first two whilst allowing a custom pronoun for the third.
Yes, the link should automatically apply the R_PYTHON code which makes it free.
Why 3? 4? Just put M/F/Other
I bought this book not long ago. I struggle with studying at home but I'm determined to read the book cover to cover. I can recommend this book if you were always interested in Python but never got around to learning it. 
Its already free....
``` Please enter your preferred pronoun: they Please enter your preferred possessive pronoun: their ```
I'm curious... what exactly is your project trying to do?
Sometimes I can add and multiply without screwing it up. I'm a full stack web developer at a big 4. I always wonder why people stress math so heavily for all developers. I understand there are plenty of jobs where advanced math (calculus, linear algebra) is a requirement. But, there are definitely jobs, high paying ones even, where basic algebra and statistics (just the college prereq's or intro courses) are all you need.
If you'd like to do that, then it works well. I've seen a lot of games - like Halo's multiplayer, as I was discussing with another user - that never use a pronoun for the player character. It really depends on what kind of game you're making. For many, ignoring the issue of gender works fine. For some, it does not. On the other hand, if your game doesn't have stat changes based on gender (and it had better not), why not replace a "gender" choice with a "pronouns" choice? This is an example of some infrastructure that any game that has to make extensive pronoun replacements needs anyway. The only thing different in this example is that I haven't made any assumptions about the player's preferred pronouns: from collections import namedtuple Pronouns = namedtuple("Pronouns", ["subjective", "objective", "dep_posessive", "indep_posessive", "reflexive"]) def get_pronouns(): pronoun_string = input("Enter pronouns, space separated.\nExamples: they them their or ei eim eir. &gt;") pronouns = pronoun_string.split() if len(pronouns) &gt;= 3: return Pronouns(pronouns[0], pronouns[1], pronouns[2], "{}s".format(pronouns[2]), "{}self".format(pronouns[1])) else: return Pronouns("xe", "xir", "xir", "xir", "xirself") def fill_pronouns(text: str, pro: Pronouns): return text.format(sub=pro.subjective, obj=pro.objective, dep_pos=pro.dep_posessive, ind_pos=pro.indep_posessive,ref=pro.reflexive) pronouns = get_pronouns() print(fill_pronouns( "The player picks {ref} up off the ground. After adjusting {dep_pos} " + "cap, {sub} looks about and grabs {dep_pos} dropped book, " + "resolving to take it with {obj}.", pronouns)) And some example sessions: Enter pronouns, space separated. Examples: they them their or ei eim eir. &gt; The player picks xirself up off the ground. After adjusting xir cap, xe looks about and grabs xir dropped book, resolving to take it with xir. Enter pronouns, space separated. Examples: they them their or ei eim eir. &gt;he him his The player picks himself up off the ground. After adjusting his cap, he looks about and grabs his dropped book, resolving to take it with him. Obviously this is a really simplistic example. It guesses at the independent possessive and reflexive forms. However, you could just ask the player for them, or guess at them unless the player supplies them. The point is, it's really not hard to just ask for the player's preferred pronouns. If you are asking for gender when you need pronouns, you're fuckin' up. If you're asking for gender because you have stat changes based on it, you're fuckin' up. I really can't think of a single use case where you need to know the player's gender. Just don't ask for it.
"Reducing" should never be a goal in itself. You should strive for two things - clarity (in terms of reading) and efficiency (in terms of performance). Sometimes those happen to coincide with reducing code, but that should never be the goal. 
Yeah, I just got a bit caught up in Code Golf. I should probably use more comments than I do, as well. That said, say I did want to crush this code into as little as possible, do you see any way to do that? List comprehension somehow?
What is `dicts`?
You didn't search that hard then, https://github.com/python-hyper/hyper-h2. Been using that in production close to a year now (client side).
User studies indicated alienation when other was used. 4 is probably a joke.
I haven't. That looks cool though! Thanks!
Anyone mid-level Pythonista's here looking for a job in Singapore. I work for a HFT and we're looking for trading ops guys, relocation included if you don't live in Singapore currently (lots of Aussies in the office). It's like a tech firm so things are pretty chill.
Thank you for all your hard work! I learned VBA religiously for over a year and thought the next best language to go into was Python. Took the basic stuff, and always have a strong interest in optimization, speeding up tasks and making life simple.....your course exactly caters to my mindset of automating boring stuff! I automated boring stuff in Excel for a year, and now Python will be even more fun :)
I have a simple ADT lib in python, haven't released it yet but this is basically it: https://github.com/ericgj/fungi/blob/master/fungi/util/adt.py
Why is face a list of a tuple? What is dicts? Why is this in a function of no arguments? You could also probably factor this into a list comp in a single statement if all your goal was is code golf Also if you want feedback, post the full code and to /r/learnpython 
I looked at it before posting, and seems not to support Flask and many other web frameworks
Sounds interesting. Checkout clairvoyance or something like that. Im on mobile so I can't check rn but it's usually trending on github. It does sentiment analysis to make stock trades. It's not something you will be able to use directly but it may give you some inspiration. 
Thank you!
I really appreciate it! Just started reading the book and this will make a great companion. You sir, are the man!
Why would flask help with writing an interpreter?
i mean for jobs that require a stats degree (usually they require an M.S) they will use SAS or R but there are a ton of other data jobs out there in industry that require excel skills as well as SQL, Python, R, Access,etc ... Outside of the sciences, alot of companies use SAS for data storage purposes. My company uses it for clinical trials but R can do pretty much all the stats stuff SAS can AFAIK. For industry jobs...skills matter more than degrees most of the time. 
How long it takes to finish this?
/u/AlSweigart A while ago when this book came out (and later the course, which you also provided for free) I worked through the whole thing, and it really gave me a solid foundation in Python. I was comfortable with basic syntax and I had toyed with some simple scripts before, but not enough. Since then I've gotten a software engineer job where I code in Python, and I'm in the Georgia Tech online MS CS program (finishing my first semester), where I also mostly code in Python. And it's your book that gave me the all-important push toward self confidence in the language. I just want to say: Thanks!
[removed]
It's just my Thinkpad's keyboard. :)
fuck yeah! Thank you!
Do we need to refer to the book or is this a standalone course?
You don't need the book to take the course, though you could always flip through it if you want to reinforce the lessons. The book is free online: https://automatetheboringstuff.com
There are various midi libraries, but I am not deeply familiar with them. You should be able to figure out some way to output midi data at a given frequency. What are you trying to do specifically, if you don't mind my asking? The question would imply that you are wanting to produce pitches which are outside the 12-tone scale, which is quite interesting to me. 
Those are references to YAML files in loading. Contents is just the dict that the file contains.
That way I can append the actual face to the list, and then exclude the tuple with the selector. So I don't have to use multiple lists.
Just started learning Python as a beginner. Thanks a lot!!!
You're probably going to get a biased sample here because people who are proud of their math usage will be more likely to respond. I'm an astronomy PhD student, and the most advanced math I've used in the last year is algebra. I use calculus about once a year on finals. Literally none of the math classes I took in undergrad are relevant to my work. I use words like `gradient` when explaining algorithms to people, but only because that's a more concise way to explain what's going on at a high level. I could make do just fine without any calculus.
"Experienced software engineers who are already familiar with Python and the modules the course covers can skip this course."
Fuck me. I might be smarter than I give myself credit. Or, I'm just over working myself into a frenzy. Can I pm you about something related to work and more questions?
[removed]
Thank you so much! It's been on my back burner for a while. Maybe I'll open it now!
Whoops! I think I clicked reply on the wrong comment. :)
You shouldn't be using a Python HTTP server to serve up your pages. Look into deploying with WSGI and a real web server like nginx.
Is the database view in the Community Edition? I can't seem to find it anywhere...
FYI, this coupon has now expired.
Coupon expired :(
It's refreshing to see some civility, finally. And the author actually addressed the points in Zed's Shaw's article while avoiding jumping on the whole Turing-completeness thing. One thing, though, I would have liked to have seen addressed is whether Python 2 or Python 3 is better for beginners, which is actually where Zed Shaw was coming from. Also, sure it's difficult to recommend an EOL language, but to a beginner who just got their first programming job where Python 2 is the language used in the company, telling the beginner "You shouldn't use Python 2 because X, Y, and Z" isn't helpful -- and doesn't serve the beginner (who probably doesn't have a choice). And there is heaps of legacy Python 2 code, believe it or not, as well as companies that use them. I'm in one. 
IMHO if the question is: if a complete beginner (NOT in the meaning "who just got their first programming job where Python 2 is the language used in the company" but a general beginner) should learn python 3 or 2, than thanks to predicted overtake of general "market share" by python 3 I think it is better to start with python 3.
I'm by no means an expert, and I'm not sure, but it seems like there will be at most 2000*1999 = 3998000 unique combinations of primes, thus only that many unique cyphers? That's not really a lot...
&gt; Compare the length of your post to JKM's explanation of parameterization. Most of my comment is a comparison to and advocacy over xunit-style, which wouldn't have happened in TFA since it ignores unittest/xunit entirely. And fixture functions would be needed in almost every pytest-based suite, so it'd be much more useful an introduction than parameterized tests which are convenient but not *necessary*.
&gt; 90% of programmers don’t need to think about Unicode Until they run their script/app/project in the real world and hit UnicodeDecodeError. Probably should be "90% of programmers don't think about Unicode, but probably should". 
Thanks - I'm on Firefox Ubuntu - probably didn't have the correct fonts installed. Looks great now :) Definitely looks like something I'm interested in, thanks for posting!
He forgot to mention that not all new programmers are taught in English so his 10% is meaningless, especially for people who are taught in languages that use unicode. And it is a pain in the ads to work with unicode. It is that and the amount of libraries available that make python 2 the best choice for beginners. (BTW, my first programming language was python )
Used it to wrap around a c++ library, absolutely no issues. It's more powerful than the other options in my mind because of the easiness of the glue layer. 
Ok, so how do you turn something like say the maintainability index of Radon into a 0/1 exit code? Does Radon do it? Or do you do something like grep the output for being 'A'?
Not making v2 and v3 compatible was not an amazing decision. We python programmers lost due to this. We could all be using new version of the language we so loved instead of dreading to make that switch. The main problem is that python3 does not have enough features to make us want to switch. I use a lot of unicode, I was hoping python3 would have as much support as Java. Whenever I need to handle unicode I just use Java, not worth the hassle.
did you have to deal with c++ exceptions?
OP here: The overwhelming majority of Python classes I teach are to programmers whose native language isn't English. Many of those classes are taught in non-English languages (by me). And yet, most of those developers don't use Unicode day-to-day, simply because of the work that they are doing. My classes might be taught in non-English languages and/or locales, but the examples all use ASCII characters. When I talk about Unicode, a minority of people talk about their experience with it; most of these people don't deal with it day or day. 
Love your books!
Just want to say thanks for the awesome content you produce! Automate the boring stuff is a perfect approach to learning a new language, while highlighting the areas where python excels at the same time.
You could maybe get an entry level job in a place that uses SAS, but in terms of adding another string to your bow, R would make more sense for you at this stage. There will be places that make use of SAS and R, but I don't recall ever seeing a job advert calling for Python and SAS (that didn't also require R). That's largely because SAS and R tend to be used by people who are statisticians, who minor in code, versus Python which is often used by coders who know a little stats. You are going to have more luck getting a job with the stats heavy folks, if that is your background. But by all means, learn Python - it's way fun.
We get hit by Unicode errors at work all the time. We do a lot of batch processing and it happens hours in then have to restart.
After wasting weeks on SWIG and later Cython I decided C++ represented too great of an impedance mismatch with Python and I threw out my C++ code and rewrote it in pure Cython. It wasn't that much code anyway, it was an experiment. YMMV. That was 6 years ago. I'm sure there are better tools today. Boost.Python and ShedSkin look interesting.
I tried having a look at Boost.Python but it seemed such a large thing that we 'ever really managed to get anything from it. Used cython and solved it in half a day. 
here is a picture of the error I get when I try pip install requests[security]. http://imgur.com/XtGOVS7
Check out pyo. Simple to use yet very efficient.
For me the most interesting thing in Pyston is compatibility. They really aim for a drop down replacement of Cpython, especially when it comes to extensions like numpy. The basically go from compatibility first then performance rather than the opposite, which I think is a good approach. You don't care how fast you can go if you have to heavily modify your code to make sure it works, just spend the same time making a better code instead. 
And you don't reset the variable?
Love this one
Cuz it's a throwaway email ;)
I've been lurking recently becausw I'm just starting to learn. I want to use Python for data analysis and visualization, maybe modelling and simulation. Does this affect me? Should I worry about learning 2.7?
I'm searching for a junior C/C++/Python Embedded Software Developer position in Germany. I got a master in Embedded Systems in France (Paris) and had the opportunity to work in Japan and Germany for more than 3 years on low/high level projects (besides C/C++ and Python, I have an extensive experience with Golang). I have a preference for systems based on Linux. Thank you.
This so much. I'm always disappointed when I see packages only have stable versions in 2. I always prefer to use the latest if work or the task allows it. It seems the split could last for quite a while due to thew incompatibility.
I'm in a similar position, from what I can tell as a near-beginner the only reason to learn Python 2 is if you expect to work somewhere that has a huge existing Python 2 codebase. Otherwise, the more you learn Python 3 (and programming in general, if this is your first language) the better prepared you'll be to learn the differences on the fly when/if they ever become relevant. It seems to me that any problems in 3 *could* ultimately be addressed in future versions as development is ongoing. Any problems in 2.7 are going to stay that way from this point.
Ha! There are a bunch of ways for you to accomplish this, you should learn them! Any way for you to build a new server image, one that works and has your app installed? :) Good luck dude. Friggin ramdisk will get ya every time .... 
Bookmarks tip could be better with "[Task &amp; Contexts](https://www.jetbrains.com/help/pycharm/2016.2/managing-tasks-and-context.html)"
this is the worst thing I have ever seen
Learning a shitload of other languages. Can gladly recommend, it helped not only my Python ;-)
Noted and thank you so much.
Sorry I'm new to programming. But what's legacy code?
Old code that is still running in production, and still requires upkeep and maintenance. 
It annoyed me so much when I was first learning. I deployed a Python 2 app that worked great on my computer but when people in France of China picked it up, decode errors were everywhere. I then had to spend an incredible amount of time to learn about different encoding schemes and how to handle them. I have not had a more confusing programming experience since. Bytes vs Strings was an easy concept for me. Different encoding schemes and how to use them and when to convert was not. I code in Python 3 full time now and have not once wanted to go back in the past 3 years.
I used Python 2.7 for a long time doing the exact kind of work you're describing. Switching to Python 3.5 was easy, and there are a ton of nice new things in 3. Better control of inputs to functions/methods, an `@` operator in numpy for nicer looking matrix math, and improvements to generators have all been very helpful.
I would like to see Shaws idea of exactly how it would work to run py2 in py3. If I concat a bytes and str in python2 code in a python3 vm, what should happen? Do they work if the file "is" python2 but fail if the file "is" python3? And if so, how the hell do you tell?
you're supposed to convert from non-unicode early in the input process.
Yes it does. Text within Python 3 is always in Unicode, translation to other encoding happens clearly separated at the IO boundaries. Python 2 does not enforce such a clean separation, so the danger of having to deal with 8-bit string that you don't know anymore which encoding they're in is much greater.
Python3 is starting to have enough features to make us want to switch. If 3.7 focuses on speed, then it will move the needle enough for a lot of organizations to switch (I hope).
The key to the Python3 model is actually the abstraction from encoded bytes to a real, honest-to-goodness string type, and that works just fine for dealing with data that comes in as latin1-encoded bytes. You *could* continue to just use encoded bytes everywhere, but since it is textual data, why not turn it into a string type? The standard pattern is to decode the bytes coming in (latin1-encoded in your case) into an actual string (`str` in the case of Python3), do your work against that, and then encode back to bytes (most likely latin1 again, in your case) on the way out.
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
I was looking at that and it was all about custom search. I want the same results as I'm getting from the script in the post right now. Can this give it to me or just "a very shitty approximation"
If you aren't talking about Twisted (and even that is mostly there), what library do you want to use that's Python2-only?
I couldn't get the code but already purchased it with the discount, you're amazing.
Right, so I'm doing an experimental music project. I'm not really a programmer, but I took a python course last year. So it's not a fully formed idea, but the "composition" would be that the program takes an input of text and takes each letter, gives it a random pitch of random Hz, so the likelihood that it would fall exactly on the 12-tone scale is pretty slim. Then the program will give it a random timing and length, and the resulting sound file is the piece. So it's a deconstruction of the language into what could be considered meaninglessness, but what could be considered more meaningful than the original text in that it is a fresh sound that you've likely never heard before. If you're interested in stuff outside the 12-tone scale, you should check out this piece: https://en.wikipedia.org/wiki/The_Well-Tuned_Piano https://www.youtube.com/watch?v=c3eN4xwADTI I'm sure you can dive down an interesting rabbit hole from there. The normal 12-tone scale is not as perfect as it seems.
&gt; Text within Python 3 is always in Unicode, translation to other encoding happens clearly separated at the IO boundaries. &gt; Text within Python 3 is always in Unicode, translation to other encoding happens clearly separated at the IO boundaries. Yeah, that great if you want to deal with Unicode. If I have a string that under no circumstances may contain any other character than the ones in latin1 using Unicode internally is no better than using bytes.
You'll need to show where you are calling `ApplicationForm` as well.
Working on a propagation model of Gaussian beams. With added least square fit algorithm of experimental data. That's a first for me since I used to do all that in MatLab, but for this one I decided it was time to dig in numpy/scipy. Spent like 2h trying to install scipy via pip, but finally gave up and installed Anaconda.
I'm using it in a web service API that gets thousands of requests per minute, and it's not the slowest part of the functions in which it runs. I can't say more than that, as I didn't write it.
Shebang lines are your friend here. Won't get you exact version specificity and it isn't really foolproof when distributing, but it is a start.
who is supposed to care? reporting as spam.
My _only_ case against Python 3 is that RHEL/CentOS isn't using it by default yet.
Actually it may not be. The pro version is needed to do web development.
The problem is, that there is practically no internal language concept in any programming language implementation (I know), that deals comprehensively **and** efficiently with Unicode - the mismatch between memory size and accessability makes that de facto impossible. Is it really so important to count *code points*? And if it is, why there is no support for counting / splitting *coded characters* or *grapheme clsuters*, which might be even more usefull? For limitiations of user input for example, the **encoding** of the persistance layer is much more important! So you must count the size of bytes of the encoded byte sequence rather than the amount of code points... For example I reproduced the one given by the excellent [utf8everywhere](http://utf8everywhere.org/)-page (section 5, coded cahracters, 3rd bullet point): In [19]: s = "\u044E\u0301" In [20]: s Out[20]: 'ю́' In [21]: print(list(s)) ['ю', '́'] Hm... two code points, but the String shows one glyph! Would result in strange user experience if you would shorten the String for the UI layer and break it up right there, wouldn't it? &gt; Teaching beginners that bytes and strings are the same is an invalid cognitive shortcut and just outright bad education. So imho is is a shortcut to assume that an average developer knows good enough the important aspects of unicode and encodings. Therefor the strategy to *hide* this complexity will fail for almost every developer one day - and probably within a bad situation, say after the deployment to production. Python 3 would be much better, if it would define a **default encoding** for all builtin IO, like ``utf-8`` in favour. Then it is *explicitly* clear, how a file or input must be encoded and that you have to *explicitly* have to deal with different encodings, if you need to support those (for example let the client provide the encoding). Then you will have no more trouble in deploying a Python 3 script to Windows if you have developed on Linux and vice versa. On top of that, the ``print``-function is broken right now in a similar way. At minimum it must provide an optional argument for chosing the encoding. Right now it jut fails for example on my Windows 10 machine if I want to print an ``interrobang`` (‽): &gt;&gt;&gt; print("\u203D") Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "C:\Users\chausknecht\AppData\Local\Programs\Python\Python35-32\lib\encodings\cp850.py", line 19, in encode return codecs.charmap_encode(input,self.errors,encoding_map)[0] UnicodeEncodeError: 'charmap' codec can't encode character '\u203d' in position 0: character maps to &lt;undefined&gt; On a (modern) Linux machine it should work, as UTF-8 is the de facto default there - but who knows? Why not enable to print also bytes or provide the encoding? Yes that would probably result in strange looking output, but the behaviour would be *platform independant* and imho better because it would not make a program fail. Those mistakes have been made by the Java and the .NET-world years ago - why Python had to choose to make the same mistake? Rust for example has chosen to use ``UTF-8`` as unicode data type for unicode strings - interesting approach! Imho you can't totally hide the complexity of unicode - so better be explicit about the en- / decoding process; imho that will result in less pain!
"... If wait is False then this method will return immediately and the resources associated with the executor will be freed when all pending futures are done executing. Regardless of the value of wait, the entire Python program will not exit until all pending futures are done executing." Also, you can try cancel() method of a Future object, or just raise an exception with exception() method of the same object.
under what circumstances do you see this happening, and how would the python2 incarnation react in the same circumstances?
I work for one of those enterprise shops, and because it was my call to make, I put in a plan for 2.7 -&gt; 3.5 migration. I'm still debugging shit months later, and everything left is all tied to the string/unicode -&gt; bytes/string conversion. In Python's defense, a substantial part of it is Django's fault. This whole "all uploads are bytes, fuck you" thing is a source of endless pain when dealing with libraries like configparser that expect files as input. Still, there comes a point when you realize that the pain is also a result of Python 3 abandoning Python 2's typing principles. Methods like .startswith() really should be agnostic to byte/string parameters. They both quack, they're both ducks.
&gt; whether Python 2 or Python 3 is better for beginners I began trying out both. I then ditched 2 and stayed with 3.
&gt; no internal language concept in any programming language implementation (I know), that deals comprehensively and efficiently with Unicode assuming you don't expect a language to deal in graphemes instead of unicode code points, what's wrong with the python one in terms of efficiency? pep393 strings are pretty efficient. &gt; &gt;&gt;&gt; print("\u203D") which python version was this error from? i haven't had my hands on python on windows for a long time, but at least as of python 3.6, this has been addressed.
I'm porting dropbox's zxcvbn library to python. There is a port already but it's not being maintained and is 4 years behind.
Sorry! Have edited the post now.
So dont?
The "so don't" argument can be used to defend any shortcoming of any programming language. That doesn't mean it's a good argument.
Not really. The problem is that latin1 can't handle Unicode. And if it's critically important that you only ever support latin1 characters, I'd recommend writing your own string type, e.g., `latin1_str`, that will enforce that constraint for you. Realistically, a type that enforces data integrity for you is the only robust solution in this situation, and a string that only supports latin1 (or any other outdated, 8-bit encoding) is edge-casey enough that I don't think you were ever going to get that in the core language, so Python 3 fixing Unicode for the majority of use cases doesn't really impact this at all.
How often have you had to switch from Python to Java or C++ because Python was just not good enough?
Okay. Well you just heard me say that about Python 3. The meaning being that I have no problems with it, but I also don't need anything that it provide vs 2.7. So should I make my deployment even slightly more difficult just for the sake of saying I use Python 3 too?
I feel 99% of the pain is legacy from the old days of lower-case ASCII and random encodings that is pervasive everywhere, and lack of best practices, like you mention with the combined characters. But figuring this out when you just learned everything based on ASCII and bytes being the same is even worse then knowing that there is a difference you need to be careful about while still learning to program and then moving up from that. The average programmer doesn't have to know everything about unicode, but absolutely HAS to know bytes and string are separated through an encoding scheme. (eg: you don't have to be *wise* as long you're not *naive*).
&gt; exception nothing works 
A very welcome feature! I've worked a few times with repli.it to write Python code and it's great. A full-fledged debugger will make it even better. Right now, you can't watch locals or evaluate expressions with the debugger, so I find that there's no real use to it. I guess that this is more like a proof-of-concept. However, this is a very good start!
&gt; and a string that only supports latin1 (or any other outdated, 8-bit encoding) is edge-casey enough that I don't think you were ever going to get that in the core language This is where I see a difference between perceived and actual reality. 8-bit encodings are not edge-cases in many industries, it's rather the newer Unicode encodings that are edge cases. As I wrote some other place many systems that handles addresses, payment, shipping information and so on are very often designed pre-unicode. They don't accept Unicode, they accept whatever encoding the developers decided on in 1992 and no one seems in a rush to upgrade them. Keep in mind that a change to Unicode might also involve replacing hardware like printers and scanners(as an example v40 QR-codes may be bytes, alphanumerical, latin1 or Shift JIS X 0208, unicode encodings are not supported). I guess eventually most systems will support at least one unicode encoding but that is not today.
http://stackoverflow.com/questions/29177490/how-do-you-kill-futures-once-they-have-started
There's an art to writing regular expressions that are fast. For example, that `.*?` at the beginning isn't doing anything useful and is just eating up time. And you can combine them into one regex if you can make a few concessions: tmp_links = [m.group(2) for m in re.finditer(r'(?:URL|window\.location)\s*=\s*([\'"])([^\'"]+)\1', rstring)] This will match either quoting style, and will reject mixed quotes (e.g. `URL='foo"` won't match) but it won't catch embedded quotes, such as `URL='foo"bar'`. If these are URLs, chances are that embedded quotes would be urlencoded anyway, so that's probably not an issue. But even if it is, you can at least reduce this to two passes from four, which will halve the time it takes from what you have currently. 
Yeah, and I don't disagree with you overall. I was about to use a *real* real-world example and then realized that by doing so I'd be sharing proprietary code. Once I have some more time to think about it, I should update my in-depth example to be more "non-trivial". You'll always be able to rewrite in Python, of course, because Python's a complete language. But in complex rule-based engines where requirements change quickly, I've found kanren to be really helpful in making validation and filtering rules "less brittle" and less prone to growing hair.
After some documentation reading, I understand what you did. I really appreciate it!
This really belongs on /r/learnpython. The usual way for doing this is to write an infinite loop that you break out of when an acceptable value is found, such as: while True: temp = float(raw_input('Enter a value: ')) if 0 &lt;= temp &lt;= 100: break print('Try again') 
Crossposting my comment in the site: The Python 2 -&gt; Python 3 transition was made in a terrible way, it almost killed the language… The only change that made it backward incompatible was to make strings unicode by default. They should have added a transitional string (something like strbytes) and then 2to3 would just add parenthesis for print, // for /, and make every string “strbytes”. Anyhow, I think Python 3 is a better language (it is where all Python progress happened in the last decade after all), and it’s finally flourishing. By 2020 debian and red hat will ship Python 3 by default, facebook already uses Python 3 by default, Google is transitioning to Python 3 (web2py is finally being ported to Python 3) – in the end everyone will be on Python 3+ (and by everyone I mean 85% of active Python devs). About formatting strings, I do not think there is “too many ways” of doing it. The new way should be the default, and it’s just a shortcut for “.format”. Sometimes you cannot use f’strings, maybe you want to use a prepared string that codifies the format, and then you should use the unsugared “.format”. The percent way should be used when you want to treat bytes and strings more or less equally (it would be perfect for the “strbyte compatibility string”, but alas – that does not exist). 
you should support non-binary pronouns before you offend someone! edit: guess I need to use a /s here
The app is very simple and has limited features: - User signup (with invite code) - Messaging and secret/sneaky messaging (with email notifications) - Gallery - Admin features - Drawing names, Sending mass emails Check screenshots [here](http://avi.im/della/#screenshots).
Oh, I *think* about Unicode. What happens when my code hits the real world is some dorkus's email client sent me unicode and told me it was windows-1251!
I hope I am getting this right... but this is because Flask (and wsgi) are synchronous, while http2 (including hyper-h2 library) are async based and require an event loop of some sort. I personally just switched to Go for async and websocket sort of stuff, but you should be able to continue using Python just new frameworks will need to be built on top of async http2 libraries from what I understand, it's a design issue with wsgi being synchronous. Edit: I know ASGI is being developed to solve this problem, but as far as I understand it isn't ready yet I think. It should bring Python back in line with what Go and Node can do today already. To me ASGI and Django channels seems Python is trying to "catch up" a bit to Node and Go.
So harsh, but so true.
I understand you're trying to be funny, but this attitude is pretty distasteful.
Two things: First, it sounds like your case against Python 3 is that — for you — it has nothing to offer (not whether or not it's default in some distro.) Second, seems like you rely on the distro to provide you with the executable, and this is known to backfire. You should start your deployment to anywhere with installing the version you are testing against. Even if today by some chance $version is already included with $distro.
Yes. He used a word you don't like. That reason more than any other ruins his credibility.
I think compiling the regex before using it is a little faster. i.e. rx = re.compile('myregex') re.findall(rx, rstring) Are you parsing a whole html file or just javascript? Parsing html with regex is generally a bad idea. If you're parsing a whole html file, it's almost definitely better to parse it with something like lxml and only run your regex on the actual javascript code. 
&gt; First, it sounds like your case against Python 3 is that You're already wrong. My whole point is that I don't have a real case against Python 3, that I'll be switching as soon as it's as easy to deploy to as Python 2.7 &gt; You should start your deployment to anywhere with installing the version you are testing against. I'm testing with the same version of CentOS that I'm deploying to.
Because if I just use the default, my OS of choice, it's simpler.
What brings you to wanting to learn?
Digging through old projects, looking at stuff I wrote years ago, and trying to figure out WTF was I thinking.
I think maybe it's not the language that's brittle, but the code. Maybe you're trying to write your Python in the same idioms as Java or C++?
This is why I hate Java developers. I never met one that could understand that there are other languages with other concepts :(
Making a troll bot for IRC. 
You can detect the version at run time with `sys.version_info`. This lets people write version agnostic code by making conditional changes based on this information - better than having to make separate files for each different version of python you want your code to work with (including minor versions in some cases!).
You are recursing to fix invalid input. Please don't, python doesn't support recursion well (there is a max stack size, each function call adds to that) https://gist.github.com/SilverWingedSeraph/e17468d747c7053c18e9964e3f91cece#file-pronouns-py-L47-L51 this suffers from copy-pasting, best solution would be to reduce the branching there You are centering your code all around the existence of a class, so you might as well have pronoun creation as part of the class Pronouns('he') Pronouns('she') Pronouns('they') Pronouns(a, b, c) Pronouns(a, b, c, e, f) https://gist.github.com/SilverWingedSeraph/e17468d747c7053c18e9964e3f91cece#file-pronouns-py-L76 else and elif after returning branches, unneeded. - - - Since this is bordering on the realm of localization, having something that would work well with gettext would probably be a more practical angle
Out of loop here, what they did?
This is exactly what most libs do. So in this regard Python 3 DOES run Python 2 code. So that would make Shaws argument just flat out wrong. Either way you look at it Shaws argument about running py2 in the py3 VM makes no sense. 
At first, I didn't like the '(s)' here: matchResult = match.search(s) But then I thought it was cool cause it kinda codes it more. Overall, good job. Not bad for a first project, but, then again, I am not a Python Dev yet.
Anyone here available to be a code mentor?
Can you tell us the specific packages you're trying to install and their versions?
It's an old text-based adventure. At the start of the game, the character has a full bladder, and a choice of the ladies or gentlemens toilet in a bar. 
I'm considering using python for this kind of work, but I don't know where to start. What were your first implementations?
That's what shkle said!
bytes != ASCII There's ambiguity in things like recasting concatenations, but there is literally no ambiguity in asking if a byte string and a Unicode string contain the same substring, regardless of whether a byte string represents ASCII, Unicode, or binary output. It's also far more reasonable than strangeness like str * int operations that Python supports without complaint.
That's cool, are you the only one at your company using it? I'm at a CPA firm, and nobody else here has heard of it but I'm trying to start using it for more things.
Nice. In general, you can use it for automating anything repetitive you do in excel, or you can use it to analyze large files or groups of files. Do you work at an accounting firm? If so, what kind of work do you do? I do audit and tax, and use it to pull in the trial balances and general ledgers for audit, and sometimes will extract information from 1099s for tax returns when there are lots of stock sales. 
Yeah I could have definitely used a better name for that string to make my script more readable. Thank you for the input
I am not a CPA. I do bookkeeping, payables, transparency reporting for some certain provision of the Affordable Care Act, due to my industry. I am the only one in my company who uses python, because the other accountants are still using the old school calculators that print a paper receipt. I think it would be pretty hard to get most accountants to use python, due to technological illiteracy. I know accountants who cannot properly wield Excel and if they aren't learning Excel, then Python is a lost cause. I have used excel+python to eliminate about half of my workload. 
Sure. I've tried and failed to install most of these through the normal means: https://github.com/SpatialPython/spatial_python/blob/master/packages.md including gdal, shapely, mplleaflet, cartopy, descartes, fiona, geopandas, and more Like I said, for most of them I've found a workaround with gohlke, but I assume some, if not most, of those should be simple to install with the basic pip command without having to go through gohlke, right?
&gt; Is it really so important to count code points? And if it is, why there is no support for counting / splitting coded characters or grapheme clsuters, which might be even more usefull? Well, the reason a string really ought to count code points is because a string is an iterable and you iterate over the individual code points. But yeah, there really ought to be a "how many printable characters" function; in fact I would've presumed there was one.
Brainfuck interpreter !
Are you not using virtual environment though? I haven't used the OS version of python in so long now, because everything has its own separate env. Easier to keep track of dependencies, more portable/reproducible, etc etc.
Keep me posted on this. Sounds like a tool i could use too. 
Hi .. I am starting to learn python and just came across your post . Can you provide pointers to the resources you used to study python ? TIA
"This language doesn't let me divide 4 by a potato. Literally unusable."
&gt; A translation is added to the comment, the translation contains non latin1 characters. So validate at this point. Any other language would "happily" let you add whatever random garbage to a byte-string; not having unicode doesn't help you here at all.
It's almost done, I'm just trying to implement the Amazon API.
*Clearly* we just need everyone to learn to express their ideas as raw binary, this eliminating all of these problems. /s