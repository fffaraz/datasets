Reminds me of [this](http://decomplecting.org/blog/2013/03/01/code-typos-got-you-down-stop-worrying-with-close-enough/) ~~cute little thing~~ grotesque abomination.
I did go through. It is good no doubt
The `set([a, b, c])` notation is *so old*; use `{a, b, c}` instead. On the topic of prettier syntax for collections, one can do just `students = a, b, c` instead of `students = (a, b, c)` to create a tuple - no parentheses required. Note further that the methods `.intersection` and `.difference` are primarily for calling on non-sets to prevent the need to convert them. When you already have two sets, use valid_values = input_values &amp; colors invalid_values = input_values - colors if input_values &gt;= colors: ... Note that this will be faster: invalid_values = input_values - valid_values Set operations are one of the most underappreciated abstractions, in my opinion. It's not like `for...else` where it's occasionally a little nicer; sometimes there are pretty measurable improvements. Note that `int(num) * int(num)` is probably better as `int(num) ** 2` or even squares = (num * num for num in map(int, f)) I feel it's worth pointing out `.iteritems` is from back in the 2.x days; Python 3 dumped it and `.items` now refers to `.viewitems`. 
Well, it is a blog post, with a date at the top. What do you consider the best documentation on PyGI? I'm happy to look at it and add an update. Looking at py2exe's svn repository, I think my statement "Development stopped for a long time, but at the time of writing there is some recent activity on it." is still substantially true.
In the 'batteries included' model each battery is a (relatively) small package, easy to maintain. (See the [full list here](https://docs.python.org/2/library/).) That's a good pattern for you to follow as well when you are making your own packages.
Likewise I think "Generator" ought to be named "[Generator Expressions](https://docs.python.org/3/reference/expressions.html#generator-expressions)" and the section just called "yield" be named "[Generators](https://docs.python.org/3/glossary.html#term-generator)". The `yield` keyword is only ever used in the context of generators, but generator expressions are inline shorthand for defining them.
I think licensing differences are why PyQt is not the standard, rather than any lack of technical merit.
Sorry for the non Python comment, but it seems that there is absolutely no link to the original works. Feels a bit like a theft to me…
What are you comparing to? C++ is an outlier, hugely difficult for a variety of reasons. Scala has hard issues. But Java, C, and especially Lisp have simple syntax and their semantics, the relationship between the code on the page and what actually happens, are much easier than python. The difference between average and expert programmers isn't about knowing syntax, except maybe in APL and Perl6.
No. The shell is not involved at all in the case of `shell=False`. The target program is executed directly. There is nothing special about the shell — you can tell the operating system to execute any program, you don't have to go through the shell. The only reason you would need to execute the shell and then ask it to execute the actual target executable is if you want some behavior that the shell provides, such as performing word splitting or glob expansion. But those are the very things that make it unsafe; you can perform those exact same things in Python without the risk, thus avoiding the shell completely. For example, if you have a filename and you want to execute some program with that filename as a parameter (e.g. `program -x filename`), then something has to break that command into a series of strings: `argv[0]` is the program itself, `argv[1]` is the option (`-x`), and `argv[2]` is the filename. You can either do that word splitting yourself, or let the shell do it. The problem with letting the shell do it is that the filename might contain shell metacharacters. But you already know where the splits should go, so there is absolutely no reason to involve the shell. You just pass the desired `argv` as a list: subprocess.call(['program', '-x', filename]) There is *NO* shell involved here whatsoever, which means it doesn't matter one bit what kind of funny characters `filename` might contain. You've already done the word splitting, and whatever is in `filename` is going to be the `argv[2]` of the program. There's no worrying about quoting or any nonsense like that. If you think you need `shell=True`, you're probably doing something wrong. 
Nitpicking, I know, but I've never seen ` students = a, b, c` and I'd assume that that was a typo that should have been `a, b, c = students` i.e. unpacking a tuple. Using brackets makes it clear that you're creating a set. 
for inline code, use backticks: \`code\` becomes `code`
`students = a, b, c` will create a tuple, not a set.
I understand it's a blogpost. My comment wasn't really a complaint and the lack of info in it is my mistake. So let's try again. Py2exe has made some improvements in the last year, including Python3 support. Downloads are now managed through PyPi instead of Sourceforge (latest release there is from 2008): https://pypi.python.org/pypi/py2exe/0.9.2.2 PyGI docs are found here: http://lazka.github.io/pgi-docs/index.html This includes a lot of Gobject Introspection packages, not only GTK/Gobject. A tutorial can be found here: http://python-gtk-3-tutorial.readthedocs.org/en/latest/index.html Hope this helps.
Sorry, the phrasing was misleading. `a, b, c` creates a tuple.
I suggest ignoring `reduce`. You could always target 3.x and suggest using [`Python-Future`](http://python-future.org/index.html) to backport stuff ;P.
Oh geez, I misread and before my coffee, at that. Thanks. Duh.
I had not seen Python-Future before, I will check it out. I will make a change so that the set example uses both ways of declaring the set, so people understand they are the same. For the other set stuff you suggest, I would rather leave it for another post where it can be developed more fully. Thanks for all your feed back, this is my real step out of just programming, into the world of bloging about it. So this kind of reaction is really a great boost. EDIT: is there a reason you don't like `reduce()` ?
http://sarge.readthedocs.org/en/latest/overview.html#why-not-just-use-subprocess
Speaking about `itertools` I think that [`izip`](https://docs.python.org/2/library/itertools.html#itertools.izip) is worth to mention. 
Excellent, thank you for the response. Clears up a lot for me. :)
Actually a built in function - not a keyword - which is the one I was suggesting talking about. I think the one in `functools` is exactly the same as the builtin. But I don't use that a lot myself, so I am very interested in why /u/Veedrac might think it wise not to use it.
Very cool, thanks.
Have *you* read [this?](http://tvtropes.org/pmwiki/pmwiki.php/Main/WalkThisWay)
 # call function if object is not None name = user.name() if user is not None else 'Guest' RPN Python? Screw that. If I'm skimming code, I'd much rather see, and quickly parse, if user: name = user.name() else: name = 'Guest"
You can do `a ? b : c` in python with `a and b or c` if you can be absolutely sure b is not false. Otherwise you could also use its safer equivalent `(a and [b] or [c])[0]` Not that its worth doing it that way now, but its kinda cool. `b if a else c` would be preferable.
TIL: for ... else
You're posting XML as a multipart file, which is probably not what the endpoint you're connecting to expects. Instead of files=, use data= and just pass a string containing your XML.
This was exactly it! A new problem popped up, but that I know how to fix! Expect gold in just a minute.
No mention of an often overlooked feature of the humble `iter()` function. Not only can it take an iterable sequence of some kind, but it can also take a function that gets called repeatedly until some sentinel, `None` by default, is reached. This is useful with DB-API drivers as it makes streaming results much neater: with contextlib.closing(conn.cursor()) as c: c.execute(""" SELECT spam, eggs, sausage FROM breakfast WHERE price &lt; %s """, (max_price,)) for row in iter(c.fetchone): print row
&gt; (I didn't mean to imply that *you* were autistic, sorry!) Wow. Just... wow.
I take it you're confirming the lack of a "table widget"... these complex widgets like tables and trees are the reason I'm using PySide. I always get nervous when it seems like there's a lot of momentum around something I'm not using, but I haven't yet gotten the impression that Kivy beats Qt for complex science/engineering applications with lots of tables/trees/graphs/3D visualization, etc, and have great Windows compatibility, and be fairly deployable for other Windows users without Python. Sorry if I'm too off-topic ... I'm really excited for what Kivy represents, but it doesn't look like it meets my needs yet...
This bot is annoying..
To throw in another perspective: you probably only need to learn a tiny bit of SQL to use it for something simple. Take a look at the first couple of examples in the Python [sqlite3 module docs](https://docs.python.org/3/library/sqlite3.html). Those few statements can take you a long way: * CREATE TABLE * INSERT * SELECT There's a lot more you can do in SQL, but you don't need to know all of that to make use of it. SQLite's docs have handy [syntax diagrams](http://www.sqlite.org/lang_createtable.html), though they can be a bit daunting because they show every possible option.
A lot of people make deployment way harder than they need to. Similar to how a lot of people think they need "big data" tech when they'd be better off with something much simpler. Basically if you had a need for Docker, you'd already know it.
I think it's worth learning, yes. It doesn't actually take long. I think it's the sweet spot between a VM and just installing everything on the same machine. It's about as fast as running a process natively, and yet you get almost all the value of the VM. Random example: I want the latest version of imagemagick. I'm running centos on my datacenter boxes. Even EPEL is way behind, but ubuntu 14.10 has what I need. Ok, I can base my docker container off ubuntu and run the app in that environment, no need to 'destabilize' the whole machine. Even better example: getting python 2.7 running on Centos 6 is very annoying. Ok, just tuck the version of python you need in your docker container, and everything is happy. In pythonic terms, it's basically like virtualenv, but extended to the whole machine. It's a global, generic virtualenv. The good news is it's free and easy to play with; [boot2docker](http://boot2docker.io/) runs on OSX/Windows. You can learn the basics in a few hours and see if it's compelling you. Edit: forgot to actually include the use cases. I think I'd use docker for almost all the apps I've deployed in the last few years, and they'd be better off for it. Let's say you have a flask app backed by redis. Normally I would be setting up a new cloud server; installing pip system-wide so I can install my custom code; setting up nginx on port 80; run uwsgi to drive my code; build redis from source and package it (repo out of date, yuck); install duply to back up the host to s3, including triggering a redis dump; scripting (ansible for me) all of that so I can run it locally and then deploy to my box In the docker world, I would deploy my app as a container, deploy redis as a container, deploy nginx as a container, and keep the host system as simple as possible. To roll a new version of my app, I just need to update the app container. In fact, with nginx set up for multiple backends, I could run my new app side-by-side and make sure there are no errors before I shut the old one down. This is possible (but way more complicated) to do with virtualenvs on a single host. Also, it's much lower risk to try and run multiple apps on a single box, and just have nginx (or haproxy, or whatever -- you can swap it out with low risk!) send the right dns names to the right container. And that's high density, but you are now super well equipped for scale-out as well.
Perhaps [Scipy](https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.linregress.html) would be a better choice then since it calculates r &amp; p-value and stderr.
He was disoriented by Flask, which is one of the simplest and best documented micro web frameworks of all time, and you are suggesting Django. Cool. Maybe the people recommending he work his way up from something simpler he can write himself are trying to make the task more manageable.
I've used Flask, and Pyramid, and Twisted, and Django. Django is by far the easiest to get started for simple straightforward projects. He can have a website up and running without actually writing any real code. Create a [model](https://docs.djangoproject.com/en/1.7/topics/db/models/#quick-example), run [one command](https://docs.djangoproject.com/en/1.7/ref/django-admin/#runserver-port-or-address-port), and open the webpage and it's running. 5 or 10 lines of variable declarations, depending on how many columns are in his data.
Some people simply aren't cut out to be programmers. Beyond that what sort of computer studies did you have if you can't grasp Python? It really makes me think that you simply don't have the mind for programming. Programming should be like bicycle riding, even if you haven't been on a bicycle for awhile you should be able to regain the feel of riding fairly quickly. The same is to be said for programming if you understood it at one time you should be able to pick up where you left off with a bit of effort. If you can't there is something seriously wrong. 
I use it quite frequently if I quickly want to sort, calculate, or count something. In scripts I typically never use it though since I find the explicit version visually more appealing. &gt;&gt;&gt; sorted("I use it quite frequently if I quickly want to sort, calculate, or count something".split()) ['I', 'I', 'calculate,', 'count', 'frequently', 'if', 'it', 'or', 'quickly', 'quite', 'something', 'sort,', 'to', 'use', 'want'] &gt;&gt;&gt; len("I use it quite frequently if I quickly want to sort, calculate, or count something".split()) 15
Awesome. Saved for later, I might be able to use the query one and the proxy one right away. Could you build in some form of django caching into the proxy one, or would you try something else?
"As of 2015, The PySide project looks mostly dead and does not support Qt 5. If you are looking for a long term solution, or one compatible with Qt 5, consider PyQt instead." http://qt-project.org/wiki/PySide
&gt; As for s[:] is s, that's probably the way it is efficient by keeping a table of used immutable strings (pretty sure). Lookup would be hella' expensive. It's actually just a special case overload. [The source is here.](https://github.com/python/cpython/blob/master/Objects/unicodeobject.c#L13748-L13750) &gt; I'd be curious what that bytecode looks like. No different to other slices: import dis dis.dis("x[:]") #&gt;&gt;&gt; 1 0 LOAD_NAME 0 (x) #&gt;&gt;&gt; 3 LOAD_CONST 0 (None) #&gt;&gt;&gt; 6 LOAD_CONST 0 (None) #&gt;&gt;&gt; 9 BUILD_SLICE 2 #&gt;&gt;&gt; 12 BINARY_SUBSCR #&gt;&gt;&gt; 13 RETURN_VALUE 
Thank's for your suggestions. 
What replaced .iteritems?
Do not post a screen shot of your code!! Paste it here with everything indented another four lines or post &gt;225 line code in paste bin And post the traceback of your error the same way.
Sorry about that!
Flask + Flask-SQLAlchemy + Flask-Admin Define your database as a simple object and flask-admin makes a pretty interface to them. Here's an example https://github.com/mrjoes/flask-admin/tree/master/examples/sqla
Many questions. How complex is this web project? Must it be polished and slick or can you get by with a rough demo? Are there any constraints as to server, OS, or db engine? Do you ever just sit at the python console and mess around? That can be a great way to learn. Trial and error is my recommended route, as long as you have enough personal drive to work through each error and continue onto the next trial. Is this a personal project or is it for someone else? You mention a deadline which makes me assume it is not your personal project. I wish you luck and I'm certain there will be people here who can help, along the way. ^And ^don't ^forget ^to ^get ^plenty ^of ^sleep.
http://wiki.scipy.org/NumPy_for_Matlab_Users Numpy is basically matlab for Python, Scipy is the toolboxes. Matplotlib will give you the plotting functions. ipython is a better interpreter with tab completion. 
Automated-wise, I haven't, yet. Yes, I appreciate the irony. :) Automated tests are on the [future plans](https://github.com/skoczen/polytester/#into-the-future). Practically, it was tested by giving it heavy use, in both dev and build environments. But - I do want to bring a proper test suite in. Testing CLIs is just such a PITA. If anyone knows a great CLI test helper/framework, I'm all ears!
The thing that is missing is a straightforward way to grab stdout and stderr as the process is running. At the moment there are workarounds involving threads that feel cumbersome, there should be a simple built in way to do this.
[Image](http://imgs.xkcd.com/comics/standards.png) **Title:** Standards **Title-text:** Fortunately, the charging one has been solved now that we've all standardized on mini-USB. Or is it micro-USB? Shit. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php/927#Explanation) **Stats:** This comic has been referenced 1199 times, representing 2.4113% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_co4gs31)
in most cases, it is this reason. when one needs a list of words that will in later versions of the code be expanded, this is very easy to maintain (just add the word instead adding `", "` in between). just a word of warning: as a string operation, it is time consuming (writing `("x", "y", "z")` is executed faster). that doesn't really matter when you do this at the beginning of the module where it is only executed once, but don't do this inside loops.
All good thoughts, thanks for posting them. The challenges in this case is that the majority of the sticky code / tricky cases involve weird combinations of CLI arguments and yaml config. Being a pretty strong e2e proponent in web-based projects, I tend toward integration tests as a first and last line of defense. Unit tests I love mostly because they force you to properly abstract your code. That said, I definitely see your point that I'd be better served by skipping all the argparse bits and focusing mostly on passing those strange scenarios directly into the runner. Will keep that in mind when building out the suite - unless someone else gets to it sooner!
A common reason to use the shell is that it will find your program by looking in the `PATH` environment variable, so that you don't need to specific absolute paths to the program. This is a weak justification to use the shell from a Python program though - it is not hard to use `/bin/which` to locate the program. But it's an extra `subprocess.call` and people are lazy...
Hum, would be better to use the new API to replace content of the current cell don't you think ? https://github.com/ipython/ipython/pull/6994 ?
https://scipy-lectures.github.io/ This is very good introductory material.
You're welcome, glad it was helpful. BTW Looks like someone just posted a concrete example of [doing almost exactly what I described.](http://www.defuze.org/archives/331-a-more-concrete-example-of-a-complete-web-application-with-cherrypy-postgresql-and-haproxy.html).
Although I don't really see why this is in /r/python (I expected it to be /r/sysadmin or alike), this post was really informative. I didn't know boot2docker and will definitely look into that.
This would be a better question to ask on /r/osx. I imagine that if you can do it, it would be a small, os x native command line utility, applescript or a third party utility. You can open a program in OS X via python using from subprocess import call call(["open", "/Applications/AppName.app"])
does this pass arguments like the command line does? 
I'd rather have the expression throw the AttributeError since I was expecting an object with that method. Especially if this is in a "lower level" part of my project, and then let something higher up deal with it. 
can you post an example of what are you working on ?
Yes and no. Wxpython as found on the site i linked above only works on 2.x. My understanding is that the future of wxpython is in the phoenix project which does support 3.x. I'm not sure how far along pheonix is, but i know you can download the latest builds.
But if you add `run`, you will have one more function to choose from, or am I missing something? But in general, I am +1 for `run`. Wish it existed from the beginning instead of those 3 almost identical ones
Never mind. Somebody already commented that on his site. It looks like the example was a simplification.
Did you run the scripts with sudo like it says and not get any errors? The scripts don't run a gui or anything, they just make the package available to other code. You should be able to run a python shell and type `import vmtk` to see if it worked. 
I have not tested this but in principle some combination of these commands should work In Os X you can switch desktops with keystrokes ie. hold Control and press left/right arrow keys. So That should be able to be executed via applescript which in turn can be executed from a command line: osascript -e 'tell application "System Events" ..... you'd fill in the ..... with some applescript command like 'keystroke "right" using {control down}' I don't know if applescript uses left/right or some other method of referencing the arrow keys. The 'using' part tells it to execute the given keystroke while pressing the buttons in {} so in that example it would press the right arrow key while holding down control. So you could execute all of that from a python code using subprocess This would switch you to the next desktop. Then You could run another subprocess call like /u/jedrekk mentioned call(["open", "/Applications/AppName.app"]) 
Kivy has pretty good Windows support with your app compiled by pyinstaller. We only provide a few basic widgets and expect you to construct your own more complicated ones. We do have [a repository of complex widgets](http://kivy.org/docs/api-kivy.garden.html) that users create and submit so others can re-use them, but due to app size considerations these are not included into Kivy by default.
I actually find [this shit](http://mathesaurus.sourceforge.net/matlab-numpy.html) is more readable for me. I use both when I need to transfer between the two languages. 
The solutions don't get stderr and stdout at the same time. All the workarounds I've seen (and used) seem really hacky. This is what I've used so far: http://stefaanlippens.net/python-asynchronous-subprocess-pipe-reading Pythons lack of support for nonblocking readline hurts a bit here, but even with it programmes that want to monitor both stdout and stderr need quite a lot of boilerplate right now.
You might get some better answers on /r/vfx
Ah yes, I've tried NoseJS, it's terrible :-) My main grievance with all the solutions is lack of consistent reporting (like xunit xml).
"Add 4 extra spaces before each line of code" as the sidebar says. 
More elegant Google Form quick recap: https://docs.google.com/forms/d/1DqxkNi4GvyTCu54usSdE1DjW29zw1tc52iMeH3z4heg/viewanalytics Overall people started writing more python 3: +15 points in "I ever wrote python 3 code", +10 points in "I write more python 3 than 2". Transition is still ongoing and I hope a tipping point will be soon be attained. Users definitely seem to want to switch to python 3, but dependencies keep them with 2.7 (I weep for the few ones still on 2.5).
Sorry, it's my first time posting something like this. Thanks for the pointers. The fix is really hard to describe as I'd have to get into personal information a little bit so I would like to avoid that if I could.
Glad you liked the gif(s)! All the credit for them should go to [licecap](http://www.cockos.com/licecap/). And I'll make a note to work on the wording and pacing up top - communicating the most important features is always tricky.
I figure I should note that we'll only post major releases here. I think major releases are about the right level where interest level justifies a post (about one a year). If you're interested also in getting notice of minor releases, see the RSS or email announcements links at top of http://wingware.com/news
Those are probably the best suggestions you can get. Learn the NumPy basics, but really aim for using pandas (roughly speaking a library on top of NumPy with many useful additional functionality). Also, don't forget about scikit-learn (probably the best and most complete machine learning library I have ever seen). I am not sure if there is a (good) book on scikit-learn and I don't want to recommend something I haven't read myself, but scikit-learn is pretty accessible itself and the [scikit-learn website](http://scikit-learn.org/stable/) has pretty good tutorials.
This is how you should use `arcpy.AddField_management` in line 94: http://help.arcgis.com/en/arcgisdesktop/10.0/help/index.html#//001700000047000000 Some of the parameters that should be numbers in this context: arcpy.AddField_management(folder + fileName,commFieldName,"TEXT","","",40,"NWT Community") are strings instead. Read the documentation on that function and we can help you further.
+1 alembic is fantastic tool. Currently I am using it with sqlalchemy but *without* ORM and it works great.
Yes, that surprised me as well!
From what I'm looking at in the documentation these are the parameter matchups: in_table = folder + fileName field_name = commFieldName field _type = "TEXT" field_precision = "" field_scale = "" field_length = 40 field_alias = "NWT Community" but I don't see any matchups where numbers should be there instead of strings. Unless you mean that the empty "" should be 0 instead, is that what you mean?
The old functions certainly won't be removed, but I hope to highlight the new one in the docs as the 'one obvious way to do it', and demote the old functions to further down the documentation. The idea is that you should be able to use `run()` without having to think about the other trio of functions, although admittedly getting the equivalent of `check_output` is a bit longer: stdout = check_output(...) stdout = run(..., check=True, stdout=PIPE).stdout
Fixed! Thanks
Yeah, I messed this example up. Have to be more careful next time. :-)
It's easy enough to get live output on a single channel (e.g. if you've passed `stderr=STDOUT` to combine the streams). Beyond that, I'm not exactly sure what would be generally useful: should it handle only output, or input as well? Should it be synchronous, thread based, or based on asyncio? (See [subprocesses in asyncio](https://docs.python.org/3/library/asyncio-subprocess.html)) But if you can describe what you want in more detail, feel free to propose it. The standard library is not set in stone: the core devs do listen to suggestions for improving it. I'd start on [python-ideas](https://mail.python.org/mailman/listinfo/python-ideas) - that's where I went to propose run(). If people are interested in it, I'm happy to help hash out the details and the implementation.
I had similar problems with matplotlib on Mac - which I think I fixed it by copying `.pyd` files directly to the frozen application. I then hit an insurmountable problem packaging IPython. My current attempt at cross-platform compatibility is to build on Mac using `py2app` (which helpfully allows 'custom recipes' for weird packages) and `pynsist` on Windows, which doesn't freeze at all (just bundles) and works a treat.
As someone fairly uneducated on python 3, can you give me a quick rundown on why you like it?
Doesn't surprise me at all. Lots of companies, especially those with continuous deploy, want one code base that always works and they don't want any downtime when switching to 3.x. The best option for that is to straddle both versions and flip a switch when the 3.x code is fully functional. 
I have a theory. I added some debugging in the calculateCommunityField function. Could you try running it? def calculateCommunityField(folder,fileName,commFieldName,community): # calculate shapefile Community field fieldList = arcpy.ListFields(folder + fileName) for field in fieldList: logFile.write("{0} is a type of {1} with a length of {2}\n".format(field.name, field.type, field.length)) if not arcpy.Exists(folder + fileName + '\'' + commFieldName): "Adding '" + commFieldName + "' Field..." logFile.write('Field COMMUNITY does not exist - adding field') arcpy.AddField_management(folder + fileName,commFieldName,"TEXT","","",40,"NWT Community") arcpy.CalculateField_management(folder + fileName,commFieldName, "community", "PYTHON") writeMessage("Community Field Calculated") return True It should list all the fields in the file that is currently processed. Then if the field doesn't exist it logs the attempt to add it. I suspect that the field exist but the program is adding it anyway.
&gt; If you find the graphs ugly, please [help me make it better](https://gist.github.com/brunal/88418f72fc981a4bf9c3). pls giev `survey_answers.csv`
If our test suite using 3.x will take much less than the 35 minutes it takes now for the full suite to run, then I'll make a major push to port/convert
This is a deceptively simple looking problem. You're going to need to build a parser. It's a *simple* parser, but even a simple parser has all sorts of complexities to it. For example, your single line has a grammar roughly like this: INGREDIENT ::= QTY UoM? ITEM A quantity, followed by an optional unit of measure, followed by the name of the time. But quantity isn't just a number, right? For example, I might have a recipe like this: &gt; 1 1/2 cups milk So the grammar for QTY might look something like this: QTY ::= integer FRAC? FRAC ::= integer / integer UoMs are simple, right, more like just a word? UoM ::= \w+ #one or more word characters And then, finally, the ingredient itself is every to the end of the line: ITEM ::= [\^\n]* Let's think up a general flow for this code. We start expecting a QTY, and a QTY starts with an integer. So let's start grabbing characters from the start of the string until we find something that's NOT an integer. That's the integer portion of our QTY symbol. The next character should be whitespace, and then we have a branch in our code, right? We either have a FRAC after that space, OR we start the UoM. If the next character is *not* a number, then we're definitely looking at a UoM, otherwise, we need to read until we find a "/", then read again to find the next whitespace character. At this point, everything we've read is part of QTY. Now, the UoM is easy- read until we hit the end of the word. Read to the next whitespace. ITEM is also easy- read everything else. This is a simple case, and it's worth building this parser yourself, because it's a great exercise. For larger, more complex versions of this problem, I recommend using a parsing library, like PyParsing. 
False
It's not *that* different to Python 2.
Ah geez, I'm actually fairly new to programming, you really lost me. I'm actually using this for an assignment and I don't think I am experienced enough to make my own parser yet. Thank you for your advice though, I am definitely going to revisit this and learn how to do this because it seems your way is better!
Thanks for the advice, I might take a look at Django when the time comes. It's true that I've been kind of confused by Flask but may be it comes from the fact that at the same time I was reading about Python, SQL and Flask. Too much at the same time for starting I guess (at least for me). :) The thing I like about Flask is - correct me if I'm wrong - is perfect for micro projects and also seems more python-like than Django which as some "bad manners" of syntax.
Less and less each year. Less people each year to hold us back
Yes, I think I should learn the very basics of SQL and those might be enough for me to get started. So with sqlite3 we can write some basics sql requests without installing anything, am I right ? I'm definitely going to look more into it. Thanks for all the comments and feedback. Definitely a great community. I love Python so far and this make me like it even more. :)
It's not exactly "nobody", but really, what are the incentives to move to 3 if you're intimately familiar with 2? Simply on account of the Unicode/encoded string issue, Py3 is a no-brainer for people new to Python, imo, but for experienced Py2 coders it means trading in a well understood set of problems for a different set you don't understand. 
My favorite thing about python 3 is that it isn't 5 years old.
&gt; Users definitely seem to want to switch to python 3 How do you come to that conclusion? I mean the majority of respondents still start *personal* projects in Py2, and it's not like lack of Py3 support in libraries is the problem it was.
What's that got to do with anything?
&gt; It's not exactly "nobody" True, only people haveing some *actual* work to do don't want to deal with 3.x oddities. &gt; Simply on account of the Unicode/encoded string issue, Py3 is a no-brainer A no-brainer not to use it. I work a lot with raw data. And having a string represent a list of bytes makes a lot more sense in my use case. Also even though the strings are now officially unicode the re package py 3 doesn't treat them as such which leads to much confusion and strange bugs. 
"Slow and steady wins the race." I seriously hope it turns out to be true :)
Flask is a micro framework, but no, that does not make it better for micro projects. Flask being small itself leaves much more for you to have to do yourself. Django is much bigger than Flask. This means Django does much more for you so you don't have to do it. This is where Django gets criticism, and indeed Django can make large complicated projects with extensive customization fairly difficult. If the actual backend logic of your project is complicated, like having multiple databases or using xmlrpc or something, Django isn't a good choice. But if you have a single database project, like yours, getting something up and running can be mind-bogglingly simple. I'd estimate, once you get through the tutorial and are familiar with the very basics of the framework, you can have something online that will do whatever you want for this particular case in less than an hour. Maybe less than 10 minutes.
Library support for one. Also, wider use of 2.7 means wider community support. I could give these up, but what do I get for it? This is why I wanted to know why /u/willy1234x1 said 'haven't looked back.'
2.7 is a dead end. Python3 is the way forward. 
I'm about done for the day but I will definitely try it tomorrow, thanks muchly friend.
Py3 behaviour is way better if you need to handle any language besides English (or need to handle non English names). 
Yep, most SQL databases run as a separate program, and your application communicates with it over a socket or something. sqlite3 is an SQL database that works as a library inside your application, and a standard Python install includes sqlite3, so you don't need to install anything else. You're welcome :-)
I suspected it was a class assignment, which is part of the reason I went the super-technical route. But man, we did BNF grammars in CS100 when I was in college. Kids these days. Let's just assume numeric units (no fractions). Our grammar and our parser get much simpler. I'm not even going to diagram out the grammar, it's so simple. Read everything up to the first space. That's the number. Read everything up to the second space. That *might* be the unit of measure, or it might be an actual ingredient. How do we tell them apart? Well, there's a finite list of possible UoMs- cup(s), teaspoon(s), etc. If it's a UoM, record that, then read the rest of the string- that's the ingredient. If it's *not* a UoM, you still read the rest of the string, and append that. By "read", I recommend using the "split" function, to break the string on spaces.
Because for the work I do (web development primarily with Django and Flask) there is no need to Python 2. All the major libraries support Python 3 and if they don't I'll fork them and update them myself using six. Aside from library support Python 3 is just a big step forward for the language in terms of clarity and cleaning out a lot of baggage that had built up over the years while also adding lots of nice features. Plus for me I prefer to be on the newer versions of technologies.
This is all I was looking for, and I got people jumping down my throat for it :( Anyhow, thanks. I've been meaning to look into it, I just haven't had the time.
Been using them for a while, they seem helpful and its pretty easy to get things going. They also have quite a bit of packages preinstalled so I don't usually have to worry about trying to install something. You can sign up for a free account to sort of get an idea on how it all works, I would suggest doing that first.
&gt; Overall, it would be a good amount of pain to switch over, for not much benefit. It certainly sounds like it. For my purposes of scientific computing, machine learning, numerical optimization, web crawling, and other academia/hobbyist level projects, the choice between python 2 and 3 has become a non-issue. For others, that clearly is not the case yet.
It's better when it works and fucked up when it doesn't. It lets you pretend that text just works for longer before you run into difficulties and have to learn about Unicode, encoding, normalisation and all that jazz.
If a package does not currently support python3, shouldn't that package be considered abandonware? Not supporting 3.x in 2015 is inexcusable, considering how broken the unicode support was in 2.x. Unless, of course, the software you write is not supposed to be used by people outside of the US.
So stay with 2 then ...? -- Stable, getting security updates, been around for a while, fast, used and tested by others. Ok that's easy.
You are exposing yourself to risk. Many 3.x ports you see haven't been tested and used as much. So you are volunteering to do that for those libraries. Which might be cool and fun. 
The reason 2.7 is still widely used is precisely because it is *not* a dead end. As long as maintenance releases and back ports keep coming, there will be little reason to change. As soon as you need something that 3 has and 2 does not have, and never will, then you'll seriously consider the move to 3. Until then, preserving sanity prevails.
&gt; considering how broken the unicode support was in 2.x. How broken was it? Been using, and shipping and making money off of 2.x for 10+ years. Never noticed any unicode issues.
Ok? All I said is that I like anaconda and if supports Python 3. Maybe you meant to reply to someone else.
I've been writing a lot of node.js lately did I miss python 4? 
Never used 2.x. They said it's no longer going to be actively developed so I never considered learning it. I don't think there's any reason for you to feel pressured to change. If it's working for you, go with it. It's not going to die out overnight.
Thanks for doing this! Your are doing this survey for a couple of years now, right!? Would be nice to have a time series plot "year vs python2/python3" ratio or so for the different questions!
For me personally, it's primarily the unicode. It's convenient if you are scraping data from web sources or dealing with data for sentiment analysis or other text classification tasks. If you are interested, a while ago, I summarized the [key differences between Python 2 and 3 here](http://sebastianraschka.com/Articles/2014_python_2_3_key_diff.html) back when I made the switch.
i haven't read your code. that said; an 'explored' array a 'frontier' array an 'unexplored' array when you examine a state, your possible moves are the frontier, the moves you've explored are... well you get the idea. something to think about anyway. Put your coordinates in arrays.
/r/titlegore
&gt; ut now, what libraries have you needed to pull that either aren't fully supported on 3 or don't have a spiritual successor for 3? wxPython &amp; VTK for me I still code using six and manage a Python library that supports Python 3. Still, it's the redheaded stepchild since I can't figure out how to figure out the encoding of a text file. You just have to know. If you want to help :) this py file that runs through all the possible encodings and it crashes on the test problem pulled off wikipedia. https://code.google.com/p/pynastran/issues/attachmentText?id=168&amp;aid=1680001002&amp;name=unicode_test.py from the ticket https://code.google.com/p/pynastran/issues/detail?id=168
Well they came a little too close for comfort to ending support.. I can't write software that handles sensitive data, for instance, on a platform that I can't trust will receive security updates. But if you want to talk strictly improvements / features, you'll find (as is typically the case) that they're quite minimal. I will say that I've spent a lot less time debugging unicode issues (the only time I have problems are when I'm using 2.7 code that hasn't been ported yet), and the other is in exception handling. [The tracebacks are better](http://blog.ionelmc.ro/2014/08/03/the-most-underrated-feature-in-python-3/). Honestly, though, the real reason to switch to python3 is because it's the only way forward for python. I don't agree with the way they did the py2/3 split - I think it was poor planning.. however, there's too much invested in py3 and it seems like we're really finally starting to reach a tipping point (at least in terms of library support) that makes py3 a legitimate choice. In any case, py2.7 is quickly leaving the arena of "legitimate choice" unless you have legacy code that depends on it.
&gt; getting security updates They almost let the security updates expire this spring as of last year.. So the problem is that "tried and tested" can quickly be transformed into "in the dust"
Awesome! I'll try it out and let you know. How does it know where to resume from?
Come on dudes fix this already 
Same here, I sat down to work on a fairly large Twisted based project, figured surely by now most of what I need in Twisted is ported. I was wrong. 
&gt;...and does not really offer any major improvements over 2.7. Didn't that canard get addressed several months ago? I remember a webpage in which the "Jeopardy" theme song played as the user scrolled down page after page after page of changelogs for all the improvements since 2.7. I remember it weighed over a pound when printed out! So please stop making this particular claim. Unlike other reasons which are preferences or opinions, this is a factual claim and has been shown to be factually false. To make it suggests that Guido Van Rossum, Raymond Hettinger, Jessica McKellar and all the other illustrious Python core developers haven't been working hard but sitting on their behinds twiddling their thumbs for 8 years now. Here you go: http://sealedabstract.com/rants/python-3-is-fine/ It was 192 pages and two pounds of changes, actually. Another helpful resource: http://asmeurer.github.io/python3-presentation/slides.html#1 (you have to hit page down to view) 
It looks like there is a bias. Why are there so less people who have use python 2x prior? Did they just quit python?
No, it's the IDE v5.1. Python is still in v3
&gt; The tracebacks are better. Okay, that right there is pretty good.
&gt;print("some text,", end="") This is minor, but pretty good. I'm tired of having to use sys.stdout.write() to get this done!
We forgive you for your honesty.
The release notes for the 3.x series total 192 pages. Hour-long presentations have been given at PyCons that only cover a fraction of the features. If you have to ask, you honestly haven't looked.
It's very different if you use Unicode at all. The Unicode support in Python 3 is far better -- more transparent and more convenient. For some people living in the USA, maybe it's okay to pretend that other languages don't exist, but for much of the rest of the world, Unicode really does matter. Python 3 is designed with Unicode in mind, and its support for that is far nicer as a result. I switched over to Python 3 some five years ago. I really don't bother with Python 2, as its Unicode support is clumsy. Besides, I'm writing programs to be supported in the future. I don't want to write something for a language that is already "legacy" stuff. edit: typo.
On the other hand, with the asyncio in Python 3.4 now, if Twisted doesn't port it may become irrelevant in the future the way PILlow replaced PIL.
&gt;As long as maintenance releases and back ports keep coming, there will be little &gt;reason to change. That's like saying I'll live forever so long as my heart keeps beating. Guess what's going to inevitably happen in both cases?
In section 2 the Scala equivalent Python code is wrong. The following code checks for NaN. Python None is not the same. NaN = float('NaN') x = NaN if x is NaN: print("x is NaN") else: print("x is not NaN") # prints x is NaN 
How about print "some text",
The [Python 3.3: Trust Me, It's Better than 2.7 video from PyCon 2013](https://www.youtube.com/watch?v=f_6vDi7ywuA) will give you an overview of the advantages of Python 3. While I can see why some people don't see much reason to switch to Py 3.x, there are definitely reasons others will like the changes. Users in doubt can watch that video or the refs alcalde gave and decide what works for them.
Nothing missed from Ruby. (But it's nice to know they have an equivalent).
You tell them! Comments, HTML and XML ones, are fun things for breaking software that uses regexps to extract data.
indeed. but then again, i've most frequently seen that idiom in situations where spaces are implicitly disallowed anyway (nameduple construction). i did not make it clear in my original response, but feel obliged to emphasise that constant string splitting is not something i'd recommend.
subprocess does path lookups for you: &gt;&gt; subprocess.check_call(['ls']) [works] &gt;&gt; os.environ['PATH'] = '' &gt;&gt; subprocess.check_call(['ls']) [fails]
Other languages are just the start. we had a lot of fun with unicode emoji's that turn up anywhere people edit content on mobile. We moved everything from python2 and mysql to python3 and postgres. Worth it for unicode heaven.
You should also look at using Anaconda and its package manager "conda", which makes it easier to manage and deal with binary packages for various libraries in the Scipy/Pydata ecosystem.
I've been using Python 3.4 solidly for a while now, I've never found a problem with support (yay stack overflow) and most libraries I've needed have been perfectly stable.
pyNastran has kinda become my dumping ground for code. It just doesn't get released in the official versions. I made a GUI to figure out coordinate system transformations that you can download. Then I needed to view Cart3d and Panair models for work, so rather than trying to unbreak the old, slow, in-house viewer that read those formats, I added some new formats. It's even got a scripting capability, which is very cool. Really it's all in the greater plan to develop an integrated open-source aircraft MDO system with a halfway decent GUI.
Also, unicode is only an issue for folks that use it. For people using Python for numerical work and processing simple ASCII text files, unicode never enters the picture. I know web-related stuff is a huge chunk of Python development, but it's not everyone. edit: all this to say, thank you for saying that Python 2.7 wasn't broken "because unicode...".
Not to mention, when you write code that deals with bytes, it's now more clear that you're actually doing so. Indexing a `bytes` object will give you the integral value of the individual byte (you can still slice to get "substring" `bytes` objects). When you read from a file in text mode you get a `str`, and when you read in binary mode you get a `bytes`.
Your doctor's going to announce that your life will be extended by five years as the last deadline comes up to expiring? (In this scenario, your doctor is Guido).
Now if only 3.x `bytes` didn't have all this misleading cruft on it, like `.strip()` and `.swapcase()` and `.zfill()`...
Thanks. Sad though.
[There you go](https://docs.google.com/spreadsheets/d/1jueUgoqzxoAxMgy7B_X_wNIDnZMYlFkO0394gMvun24/edit?usp=sharing)
It's been done last year as well, but not by me. That's what I tried to do: 2013 vs 2014. The plot you're describing would be nice, but it's a bit too early yet :-) next year maybe
Thankyou ! the pd.df looks spot on...i've been losing sleep over this :-) From my (limited) exploration of Python so far this is one of the very few things that I'd say would be easier in C than Python
For me, dynamic size data structures in C are somewhat complicated, and much more easily implemented in Python! *Gnaddel* gave a very good suggestion. If you don't want to import the whole pandas, you can try only with the suggested np.array, that allows you to use the slice notation to get the data that you want (some rows with just the first and second columns, for example). During construction time, maybe it would be better to only has a simple list where each element is another list with the measurements. With the whole data in the list, you can then create a np.array to use the indexing.
It's even easier to get right.
Very nice, after I downloaded it I was pretty sure it wasn't Java. It was blazing fast even on my little HTPC box which PyCharm usually kills.
I want to learn a bit of SQL, is the unicode-support of postgres a lot better than other sql-servers? 
Many interesting questions.. :) The main use, is for embedding other processes in GUIs, I guess input can be useful here, but not always... I think most people don't bother with input as it's difficult enough getting stderr and stdout*. Here I grab them using an iterator: https://github.com/shoebot/shoebot/blob/master/extensions/gedit3-plugin/shoebotit/__init__.py#L143 Other people have similar solutions - I probably need to experiment with asyncio at some point. If it could be purely asyncronous and not use threads it would be ideal, not sure how possible this is. Next time I have a look at this, I'll see if I can come up with something for python-ideas. My instinct is that you should be able to iterate over the lines from stderr + stdout and maybe .send() data to stdinput. Maybe this would involve some kind of stdcomm_state object or similar to encapsulate stdout, stderr and stdin. It's tricky since it's easy for them to get out of sync, in fact maybe it's not possible to guarantee they stay in sync at all. *In fact, I found some bugs in the implementation above while writing this.
`from __future__ import print_function` I've been using it for years on the assumption that I will have to use Py3 at some point.
Can you be more specific about what you mean with "still doesn't run". If you have imported your django directories in your project and it does not find your manage.py or settings file because your layout is non standard, then the worst case that can happen is it will tell you that you must manually set DJANGO_SETTINGS_MODULE. Also it helps if you add paths to your django apps [assuming again that we are talking about non standard django project layout], in the Project-&gt;Project Properties-&gt;Python_Path. All my django apps are pip installable hence I often do not need to explicitly have to do this. 
It might not be exactly what you were looking for, but it will at least confirm if you are going into the right direction or not. Check this wikipedia link and the project page http://en.wikipedia.org/wiki/RRDtool. Basically, for time series you are mostly interested in a certain amount of data that is always constant (for example 5000 sensor readings - 3 days). You can store this type of data in a round robin fashion to keep the memory constant. If you require another set of data, for example values for each 30 minutes for 1 month, you can calculate the data points using the original series by various methods (median, mean, max, min, etc) and add the new data series in the same structure. There is also a python binding for this: https://pypi.python.org/pypi/python-rrdtool
Even Guido has said that Python 2's Unicode support wasn't done well and needed to be replaced. One of the major reasons for Python 3 was to do this work that he saw as long overdue.
http://imgur.com/iibjEMc Here is a PyQt example. Tk is fine, but if you're wanting to do anything complex you will save yourself time starting with wxWidgets/PyQt. I originally started on wxWidgets, but switched due to the lack of a standard browser in wx. A great example of a beautiful native-look wxWidgets-based application is mMass (a mass spectroscopy tool) http://www.mmass.org/features/ 
The Unicode stuff was what got me over the hump, really. One day I was tired of trying to find the right combination of encode and decode and messing with strings as bytes and so on for something that downloaded text from the internet and installed Py3.
Upgrading python and switching to a proper database thanks to mobile smiley faces. What a time to be alive.
Some of my clients use a pretty old RHEL version. I guess I can build 3.4 from source there, but its upgrades are not automatic like they are when it comes from the OS's package manager. Once that is solved, I will be happy to make the switch.
Aaand, thanks to the wonder that is open-source, within 24 hours, there is now a working test suite. Many kudos to [joshfriend](https://github.com/joshfriend) for writing it.
My view is that the 2.7 line should stay alive until substantially all the kinks are worked out in 3. Right now, 3 has great unicode handling if you work with text as text only, but kind of sucks if you want to work with byte-oriented protocols. Once that, and all other issues like that (I can't think of any others, but people in other domains may be able to) are ironed out, only then will 3 really be a properly mature replacement for 2.7.
It should be fixable though, since currently `yield from x` _is_ a fancy way of saying `for _ in x: yield x`. Plus the other direction for coroutines and maybe some corner cases wrt exception handling. I mean, at the inception the biggest advertised feature was qualitative performance improvement for nested generators, but then they quietly left it unimplemented.
gfixler, actually you have foldr1 in haskell, which folds a list into itself, using the first element as the initial value.
"returns" would be better than "return". My first thought when looking at the code would be that it would return from the where block.
Yea sorry for being harsh, it's an interesting topic. I work closely with statisticians that meticulously craft surveys. It's really just that one but it stood out. The way it should probably be is: Was python 3 a mistake? Yes/no and then a follow-up for those that answered no. Adding they 'no but' in the second year makes the comparison meaningless as you kind of mention on the blog. 
You're welcome :)
Very good point! I admit I've never done publication quality results directly from Python. I guess I'm still in Microsoft's ecosystem there with Word and PowerPoint being the standard at work.
A lot better than the PEP for sure! A minor thing: why is a list of ints not written just "[int]"? Or at least "list(int)"... capital L for List is super weird.
I agree... however, when I wrote this, I thought that suggesting the addition of ONE keyword would already be pushing the boundaries ...
That's basically what I'm saying. One has to be careful with stuff like that.
I'd argue having to add 2 (or even 1) decorator is uglier than just putting it inline
I don't really see any readability issues with the proposal - no matter how you write it you're going to have to add the type signature (as complex as that may be). This proposal means you also have to write the variable name twice (which is also an extra place to make a typo), as well as introducing a new keyword while the current PEP requires no new syntax, instead requiring only a convention.
Like you, I'm used to the notation used in sphinx. However, this is one comment made by Guido about this idea &gt;IIUC there is no rst support in the stdlib, and including docutils sounds like a bad idea (it's a huge unmaintained codebase). (https://mail.python.org/pipermail/python-ideas/2015-January/031206.html): 
Actually I find it pretty readable
It seems python mandates major fuckup every now and then. First we had 2-&gt;3 problem (even though it was necessary evil. but they should have had str=utf-8 from the start) and now its typehinting. Once they fuck it up fixing it becomes very hard because people will depend on that fuckup. Its very sad because python is such awesome language.
Docstrings aren't sufficient?
Yeah, first release was in 1991 don't forget (its been around longer than Java!). Most languages that old have grown much worse warts, python has imho only been getting better.
Decorators execute actual code, they can't be stripped-and-stored during parsing, you have to wait until the actual execution of the module to see what the hell they're doing. 
Whoa. You just blew my mind. It's been that long? It certainly felt like one and a half years. Where has all that time gone??? Again: Whoa.
Thanks ivosaurus, a very interesting article (sorry for the delay of the reply). you're the second person who send me the link XD. by the way, I changed the default install_requires to install_requires=[] 
Well, that's up to whoever executes to decide. **Of course** they can be stripped, in the same way as **any syntax can be transformed** - again, this is an **implementation detail** - look at macropy from my link. You **can** transform ASTs even during imports. As of now, type hints are simply ignored by Python, well in the same vein it can simply ignore the decorator when it sees @signature. Essentialy, it can use it for infering types too. Again - that's an implementation detail.
Seems like a false dichotomy to me. The subset of rst used for type specification is pretty small...
This would have been the smart way to do it.
So if someone already has a `@signature` decorator that will get stripped too? Will this be a builtin? Will aliases to it also be capable of being stripped? Seems like something that would be hard to decide at parse time.
Thanks for checking!
I think you're thinking of Java annotations. Python decorators are good for adding metadata runtime, but the goal is for linters and preprocessors to be able to read the type information without executing the actual code.
I've read your blogs and found them interesting. This is completely new to me as I've had experience with C#'s and Java's Unicode support, which is the same as Python 3's, and the Python 2 way of doing things seemed strange to me. What if you write to sys.stderr.buffer? It takes byte strings in its .write() method and supposedly does the right thing. There's still the problem of automatic unicode conversion of argv, but wouldn't that be an improvement?
Actually it checks for that particular `NaN` instance. Python 3.4.0 (default, Apr 11 2014, 13:05:11) [GCC 4.8.2] on linux Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; x = float('NaN') &gt;&gt;&gt; if x is float('NaN'): ... print('x is NaN') ... else: ... print('x is not NaN') ... x is not NaN The correct way is to use [`math.isnan`](https://docs.python.org/3.4/library/math.html#math.isnan): &gt;&gt;&gt; import math &gt;&gt;&gt; x = float('NaN') &gt;&gt;&gt; if math.isnan(x): ... print('x is NaN') ... else: ... print('x is not NaN') ... x is NaN 
Well we already have decorators like that: think @staticmethod and @classmethod which are already kind of special - there is not much difference in practical terms.
This subreddit is for the programming language Python.
 def greeting(name: str) -&gt; str: return 'Hello ' + name That is not Python. It certainly isn't Pythonic, this is just a Pep right? No one will have to do this?
In case you are wondering why I didnt use ctypes instead of deprecated dl module: I tested this on an old Debian 3.1 Sarge installation (where I had to patch 2.3.2 libc.so.6 manually to prevent GHOST). For 2.7 and up: from ctypes import CDLL o = CDLL('libc.so.6') for i in range(0, 2500): o.gethostbyname('0'*i) Will crash after a few iterations with segfault on unpatched libc. 
https://twitter.com/FlickrHelp/status/561196847356604416
[**@FlickrHelp**](https://twitter.com/FlickrHelp/) &gt; [2015-01-30 16:18:49 UTC](https://twitter.com/FlickrHelp/status/561196847356604416) &gt; @GurzoLegend We recently moved to SSL and this could be the reason this API isn't working. ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
I'd use a numpy array with the loadtxt method. It's much simpler than pandas in my opinion. You'll need to specify types (e.g. float32, |S8, int32) &gt; What the best way of storing multidimensional time series data in python for plotting with matplotlib ? from numpy import array, zeros, savetxt, loadtxt import matplotlib.pyplot as plt t= array([1,2,3,4,5]) x = array([1,2,3,4,5]) * 3 y = array([1,2,3,4,5]) * 4 A = zeros((5, 3), dtype='float32') A[:, 0] = t A[:, 1] = x A[:, 2] = y fA = open('A.txt','wb') fA.write('#t,x,y\n') savetxt(fA, A) fB = open('A.txt', 'r') headers = fB.readline()[1:].split(',') B = loadtxt(fB) T = B[:, 0] X = B[:, 1] Y = B[:, 2] plt.plot(T, X) If you don't like the idea of hardcoding the indicies of T, X, and Y, .... iT = headers.index('t') iX = headers.index('x') iY = headers.index('y') 
One thing which you actually seem to ignore is that, if you look at the current PEP, it is not simply functions and methods for which type hinting can be provided. After I wrote my blog post, someone suggested to me that I had a look at the discussion that took place on the python-ideas list. The idea of using decorators was discussed at length on that mailing list and rejected. It is my understanding that an updated version of the PEP will include some reasoning as to why decorators (as well as the idea mentioned in my blog post) are deemed unsuitable for the purpose of type hinting.
Type hinting is meant to be optional, but is already used in some code base. This syntax has been valid since 2007...
The syntax is Python 3.3+ correct? I'd love to use it in my open source library, but it supports Python 2.6, and 2.7.
Complete Reddit newbie here, but IRL I know people at Packt, so if you have the time &amp; energy to read any of the 4 books mentioned for free I can help you (anyone who is interested really). The last book BTW covers pandas a bit too &amp; has a list of recommended Packt books in the preface. The list includes scikit-learn books as well.
I don't do Django so my answer is not django-specific, but I have implemented Sphinx Search in some projects using PHP. You can do sphinx queries to it, so it doesnt really matter from where you make them. (Django allows raw queries, AFAIK) On a side note, check out django-sphinxsearch https://github.com/adw0rd/django-sphinxsearch Ps. I have heard better words for ElasticSearch.
It is very difficult to suck more then MySQL at unicode. Seriously, it is a minefield of problems (some you won't notice until too late). If you want a taste of desperation search stackoverflow and other QA sites for unicode/utf and mysql, it is a dreadfull road. Postgres is very nice; it feels a bit heavier, more professional. For unicode you have to initialise the database with the right settings (see online manual) but then it just works for regular projects (Django and some manual stuff).
Nice eh :) As trivial as it seems to show smiley faces and pile-of-poo icons; it was a real business requirement to be able to handle social media content. This whole unicode upgrade went all the way to the stakeholders and management, and real time/money was allocated and used to make it happen. After all the pain before it was a good day when the decision came through.
Thanks for your help. I have just given up because I need to move forward. But in a not-so-far future, I plan to develop a django-sphinx (python3) app (it will be open source and hosted on github). Anyway, the repo that you suggested is based on python 2.6 and I already tested it. There are incompatibilities and unfortunately I don't have time to debug it (or adapt it to python3).
If Py3 runs into a string it can't decode using then encoding it has guessed from the environment, instead of dying (or just ignoring the offending filename, [like `os.listdir()` used to do](https://docs.python.org/3.0/library/os.html) before surrogate escapes were a thing), it will decode it to a `str` object containing surrogate escapes for the characters it couldn't decode, which is actually invalid Unicode. You can use this messed up `str` within Py3 just fine, but if you try to encode it (by `print`ing it or writing it to a file), you'll get a `UnicodeEncodeError` because Py3 is trying to use the wrong encoding. Probably the easiest way to run into Unicode problems with Py3 is to run a program via `cron` or any Mac app (they all use the default POSIX C environment, so Py3 defaults to US-ASCII for IO encoding) and pass it non-ASCII via `sys.stdin` or `sys.argv`. Then try to `print` the `str` or write it to a file. Py3 will try to encode it to ASCII, which will fail. Other potential sources of invalid Unicode are APIs or libraries that handle text that doesn't necessarily have a specified encoding, like `os.listdir` (Linux filenames are explicitly bytes and the FS will not enforce any particular encoding), `os.environ` (also bytes according to the POSIX standard), `email` and `subprocess`, which may all return `str` objects containing surrogate escapes. Presumably, `zipfile` may also do so, as the paths of files in a ZIP archive also have no specified encoding. Armin Ronacher wrote [a very good article about dealing with messed up Unicode on Py3](http://lucumr.pocoo.org/2013/7/2/the-updated-guide-to-unicode/), but AFAIK, there's no solution to the problem of Py3 defaulting to ASCII in a C environment, e.g. running it via `cron`, other than ensuring the environment isn't empty before running `python3`. 
I've told lots of people about this trick: if i in range(10): # do something here You'd think you can use `xrange` in Python2. But no, `xrange` didn't implement `__contains__` magic method, thus `x in xrange(LARGE_NUMBER)` will be super slow.
Not a fan. This seems to imitate the pre-ANSI C syntax of argument types in C. ANSI C abandoned that syntax 25 years ago and moved to inline types. I never heard anybody wanting the old syntax back. If a type declaration get to unwieldy you can just give it a name: RetryCallback = Callable[AnyArgs, Any[int, None] 
&gt;A feature to avoid if you want to use the same code base across different Python &gt;versions. So your objection to numerous Python 3 advances is that they're not in Python 2?
&gt;If it was self evidently true, the claim would not be, repeatedly, made by people. Are you kidding? In America about half the population rejects evolution and there are still lots of climate change deniers. In both cases the evidence is voluminous. The amount of evidence is irrelevant when one is ignorant of what one is talking about. &gt;Unfortunately many of the improvements in python3 are not self evident. What's a "self-evident" improvement? &gt;Once again it really just boils down to: new python users learn py3 and are &gt;irritated by py2 hanging around; many people already working with python &gt;consider the cost of porting to be insurmountably larger than the benefit gained &gt;from python3. Then I have this to say: suck it up. It's a fact of life: you HAVE to port, just as XP users have to stop using it. Technical debt is a fact of life in software development and it's baffling to encounter people who don't understand that. Python 3 is the way forward, period (since none of the complainers have shown any interest in actually forking Python 2.7 or contributing code themselves). You can either be stuck at a dead end or move forward, and every line of code you continue to write in 2.x just makes the eventual transition harder. On top of that, between 2to3, six, python-modernize and a lot of other libraries the cost of porting is not severe. In fact, again, there have been Python talks by people who ported codebases to 3 and they say that it wasn't that bad, but for some reason the reality can't change the perception. There are books available like [Porting to Python 3: An in-depth guide](http://www.amazon.com/Porting-Python-An-depth-guide/dp/1456411519). The co-author of Python Cookbook wrote [a blog post about porting dateutil](http://www.protocolostomy.com/2011/02/25/lessons-learned-porting-dateutil-to-python-3/) to Python3. It took him 4-5 hours and he'd never looked at dateutil code before! He went on to write: &gt;This is totally doable. Stop listening to the fear-inducing rantings of naysayers. Don’t let them hold you back. The pink ponies are &gt;in front of you, not behind you. &gt;...“I Can’t Port Because…” &gt;If you’re still skeptical, or you have questions, or you’re trying and having real problems, Dave and I would both love for *you* to &gt;come to our tutorial at PyCon. Or just come to PyCon so we can hack in the hallway on it. I’ve ported, or am in the process of &gt;porting, 3 modules to Python 3. Dave has single-handedly ported something like 3-5 modules to Python 3 in the past 6 weeks or &gt;so. He’s diabolical. I couldn't find the video online, but the authors were so confident in Python 3 they planned on taking challenges direct from the audience and showing them how Python 3 can solve their problems ("Attendees should plan on bringing challenges for us to address - we will demonstrate the use of Python 3 to solve all manner of practical problems as suggested by the audience"). Note: Don't google "Cooking with Python 3" or you'll get lots of recipes for eating snake. :-) &gt;Its not that python3 isnt compelling as a platform; its (and completely validly) the &gt;cost to using it is not yet enough to make the swap for some people There is no "cost" to using it other than some things not being backwards compatible. The irony is that many Python 3 features were backported to Python 2 at the insistence of Python 2 users, and now these people are complaining that Python 3 isn't worth switching to (?!?). &gt;Its not quite as simple as 'python3 is fine' It is. The Python 3 community is doing just fine and Python hasn't gone the way of COBOL like some people were writing about in 2012. Most major libraries have ported or been replaced. People are demanding that the volunteer developers do things to please them but none of the complainers want to fork Python 2.7 and make a 2.8 themselves. This shows that there is no demand for a Python 2.8 and/or that it's not as simple as they claim. Python 3 could incorporate AI that writes your code for you and people would still complain "There's no compelling reason to switch!" 
&gt; It definitely allows you to specify whatever encoding you want for I/O Not in an easy way, it doesn't. If `sys.setioencoding('utf-8')` were possible, things would be different. As things are, changing the encoding is not entirely straightforward. Similarly, `str` objects that contain surrogate escapes really should be marked in some way, so it's as simple to tell the difference between valid and invalid `str` objects as it is between `str` and `unicode` in Py2. As things stand, Py3 can hand you borked `str` objects that are essentially time bombs. Instead of getting an exception right where you try to create an invalid `str` object, which is what any sane language does, in Py3 you can have bad `str` objects floating around in your code that won't reveal themselves as such till you try to encode one. I agree 100% that using ASCII by default is not an acceptable solution in this day and age, but I believe Py3 goes too far with its Unicode/bytes dichotomy and especially with the "magic". I mean, how is silently passing your code invalid Unicode the right thing to do? 
&gt; but much more important eventually they can be used for a greater good - optimization Given Python's type system I'm not sure there are many optimizations to make. Possibly on certain built-in types like `int` or `float`, but anything more complex than that (even `list`s) and I think you're gonna be out of luck. 
&gt; It certainly isn't Pythonic It's Pascalish.
Your using find() to get the space? If so make it find(" ") so that you have the space within quotes. Just being find() your pasing the function no arguments 
&gt; Other languages are just the start. we had a lot of fun with unicode emoji :D I love the implication that emoji support is somehow even cooler than, you know, supporting every natural language on the planet. All of which Py2 can handle just fine, FWIW…
Typo on my part, edited. what I'm stuck on now is the finding the first letter of the last name. How do I join finding the space and the NAME[0] for the last name? 
The problem is that type hinting mainly helps by allowing the size of a variable to be known at compile time (fewer allocations and frees) and unless Python's type system undergoes some fairly breaking changes I don't think that's possible. I very well could be forgetting something, however, so don't take this as gospel.
Ah, thanks so much!
If you'd like to know the major differences, look through [this](http://python-notes.curiousefficiency.org/en/latest/python3/questions_and_answers.html#is-python-3-a-better-language-to-teach-beginning-programmers) I linked to a section of the whole page, but the whole thing is worth a read if you have the time. TL;DR: * Unicode support * Basic arithmetic and issues with number formatting * The print statement wasn't an actual function with arugments like it is now in python 3 * Some errors handling issues * input function improvement I'm not claiming to be an expert, just summarizing a section of the article Edit: it seems you might know more than you let on so this is just a ten thousand foot level of some basic differences, it may not be worth it to you
Take your damn upvote.
I think it's something like Name.index(" ") +1 Edit: [ like this](http://i.imgur.com/DCUoxD3.png)
Started on Python 3 and now use 2.7. Some things need to "cook" longer.
This is a very good point that is too often forgetten in these kinds of discussions: Python allows you to redefine absolutely everything except keywords. 
&gt;Without another reason, why use the most up to date stuff? Applies just as much. What you're saying amounts to "all else being equal, newer (i.e. made at a later point in time) is better".
&gt;... but if he is going to play the Benevolent Dictator for Life card anymore, he should &gt;consider ending all further development on the 2.x line and thereby 'encourage' the &gt;hold-outs to finally decide whether their projects are worth maintaining in modern &gt;environments. I've been saying this for awhile now and one blogger began calling it "the stick" vs. the carrot. Regardless, it's true: in the 2012 VP debate between Biden and Ryan, Biden explained why the U.S. needed to set a firm withdrawal date for Afghanistan. If they didn't, the Afghans would believe America would stay there forever and never step up. This applies directly to Python 2. The former head of the Pyjamas library once wrote "Why should I port to Python 2 when it's going to be supported FOREVER?" A firm date lights a fire under people's behinds and lets them know you're serious. I was very disappointed when Guido caved. I think he's too nice a guy (maybe he needs to swap places with Linus Torvalds for a day?). He also seems to think that if people get this extra time they'll spend it porting. Instead, they'll wait until the next deadline and say "But I haven't had time to port my code!" I come to Python from Delphi and the same thing was going on over there. People took grace periods for deprecation not as a window of opportunity to port but as an excuse to continue to generate tens of thousands of lines of code using the deprecated but still maintained features. Even the product manager eventually chimed in, saying that expecting the new VW Beetle to still accept parts/accessories from the old Beetle would be seen as ridiculous by automotive companies, but for some reason programmers expect languages to use the same constructs forever. (In Delphi's case they want to replace the compiler with LLVM and removing lots of old, deprecated cruft would make the job a lot easier but users are balking at getting rid of anything). 
Think you hit the nail on that one, thanks man!
Why is pyqt your favorite? Does it run smoother, easier to program, etc?
I understand that right now Python 3 has missing functionality and it's hurting you. I however feel that the benefits of having automatic unicode everywhere are immense. Could you suggest a way to get the best of both worlds?
I like it. One thing that bothers me about all three is that you had to choose between: 1. Manual handling of stdout/stderr. 2. Handling ret code exceptions. Quite a lot of the time I would prefer to just check the output, rather than needing to have a try: except: block just to get the stdout (or working with the pipes). 
But, but, def int add(int x,int y): return x + y is much much much BETTER!!1!
wxPython and PyQT (or PySide) are both reasonable options. I would avoid tkinter and PyGTK - they are both harder to write code in and less powerful, with little real advantage. As far as the wxPython/PyQT choice, it likely doesn't matter that much. If you want widgets that behave *exactly* like native widgets on whatever platform you're on, then wxPython is probably the better choice. If you want easier to customize widgets, PyQT is probably a little better, but anything you can do in one you'll be able to do in the other.
No, that's not the same. Actually I think you can't do the same in Python2 only using the print statement!
Let me start by recognizing that my opinion is not based on hard facts and extensive experience. I wrote one significant GUI program (rur-ple) some 10 years ago. At the time, after reading various discussions (including an opinion from Guido van Rossum himself who indicated that he preferred wxPython over Tkinter) I chose to use wxPython. At the time, I found that more documentation was freely available for wxPython than for Tkinter; that wxPython included more "widgets"; that it did not require what I thought were weird callbacks using lambda (which were utterly foreign to me). Since then, I have written very few GUI, kept reading about how much better PyQt was, how much more complete in terms of widgets, etc. I had made some attempts at installing an older version of PyQt on an old computer (some 5 to 7 years ago) but it didn't work - so I gave up on the idea. I found that new versions of wxPython required me to make some changes to my code for rur-ple, some not very obvious, and that new versions were not developed rapidly (due to a lack of resources - it was done mostly by one incredible programmer.) Recently, I installed the Anaconda Python distribution which includes PyQt; installation was painless. I started playing with it, found it relatively straightforward, very complete in terms of "widgets", fairly easy to implement my own widgets. I found it easier to find good documentation on it than for Tkinter. PyQt comes with a GUI based app-designer, something that does not seem to exist for Tkinter nor for recent versions of wxPython. All Python GUI frameworks are "adapted" from some existing framework written in other languages (usually C++) which themselves are based on some native widgets (to the respective underlying OS). As a result, the code is not very "pythonic". However, based on everything I have read, and weekly supported by my own limited experience, I would recommend PyQt. [Although, if you are on Linux, I read that PyGTK is nice to use ... but, to my understanding, not cross-platform like the other three.]
Take a look at [Enaml](http://nucleic.github.io/enaml/docs/). It's really easy to get started and make an MVC application. It runs on top of PyQt/PySide or wxPython, but the enaml guys have said that they greatly prefer Qt to wx. I've done some raw PySide programming; there are more features available than in enaml, but it takes more work.
For multiple constructors you can do def __init__(self, *args): ... And check the length of args in in it although it might be less clear then a classmethod factor y. For the particular case presented on your article the best thing to do is to give last_name a default arguments of empty string. def __init__(self, first_name, last_name=""): ...
I also recommend avoiding python.com.
Isn't this already in the standard library in Python 3.4?
No one's going to suggest using SQLite to store the data (in-memory or otherwise)?
How so? From what I can see, the Personal edition is much more limited than the free Python community edition (lacks version control, unit testing, etc.) and the Professional version is $245 vs. $99 for PyCharm. JetBrains has said before that the feature set of their community version is equal to the features of the the WingWare Professional version.
Basically im trying to create an arithmetic problem with two random numbers and either and addition subtraction or multiplication. I dont know how to have the answer rewdy in the program so i can wrjte sometjing like input == answer
work in steps to a solution. 1) write a program that adds two numbers and prints the result 2)write a program that uses the function `add` to add two numbers and print the result. 3) make a variable `operator` and assign `add` to it, then use it to add the numbers. 4) make variables random numbers and use `random.choice` to make `operator` one of your operations. edit: https://docs.python.org/3/tutorial/introduction.html#using-python-as-a-calculator
Since you're clearly very new and don't know where to get answers, you can always find exactly what you need to know about something from the documentation. first result for "python add" in google is exactly what you want, the official documents page: https://docs.python.org/2/library/operator.html same for "python random.choice": https://docs.python.org/2/library/random.html edit: grammuh
The benefits of automatic Unicode are *enormous*, but only when it works. Unfortunately, there are a *lot* of cases where it just isn't possible to do automatic string decoding because the world is full of strings of indeterminate encoding. Python should recognise this fact and either revert to a Py2-like model but with a saner default encoding than ASCII (e.g. UTF-8 on OS X/Linux and whatever it is Windows uses on Windows) or recognise that "all text is Unicode" and Py3's encoding guesswork is actually bullshit and back way off on the this-is-bytes-and-this-is-Unicode shtick, and also make it simple to change the encoding. In Py2, encoding is entirely your problem. Py3 tries to do a lot of that crap for you, but it's difficult to work around the "magic" if Python pulled the wrong encoding out of its arse (which it effectively does by design in the very common case of being run via `cron` or `launchd`). At the very least, Py3 should *never* silently hand your code invalid Unicode strings that will explode if you ever try to encode them. Not even PHP does something as retarded as hand your code invalid objects *by design*. 
I just wish they would modify the syntax. If you're going to do static typing, *do it* -- give it language support, don't just hack something in. The Haskell syntax is so much better than inline type annotations. Heck, add a special "comment" token, if you need to: #= add :: Int -&gt; Int -&gt; Int def add(a, b): return a + b You could do it as a "special" decorator: @sig("Int -&gt; Int -&gt; Bool") def equal(a, b): return a == b And those are only if you absolutely must maintain backward compatibility. I know Guido is gun-shy after the Python 3 debacle, but there are only two "supported" versions of Python, 3.4.2 and 2.7.9. How hard would it be to add `::` as a special token to both versions -- if detected as the second token of a line of code, that line is a comment? map :: List[a] -&gt; (a -&gt; b) -&gt; List[b] def map(lst, f): return [f(x) for x in lst]
Pick one of wx or Qt and go with it. You're unlikely to regret your choice either way. For what it's worth, I've mostly used Qt and like it, but the little I know of wx suggests it's also quite decent.
They do not intend to add static typing. The proposal is to add a syntax that tools (like linter) can use to analyze the code. It is not intended to be used as a runtime feature: Python will continue to use dynamic typing.
Poorly chosen term; "type hints," then. Still, even if you're only going into the shallow end of the pool, why would you reject the techniques that experienced swimmers use? If the syntax enumerated above is expressive enough for Haskell's (much more powerful) type system, why wouldn't it work for Python's hints?
in the future: post in /r/learnpython
Brilliant. you're right. and it' much better than using None.
It is, `functools.lru_cache`. But it's also good to see implementations of a cacheing decorator. 
Googled for voluptuous python (without quotes) and PyPi is the first link. :)
Lol love the question
Now with more ads
It's very easy to change encodings. Python 3 will default to your environment's default encoding (usually UTF-8), but you can (and you should!) specify the file encoding when you try to read a file: f = open('/tmp/myfile', 'r', encoding='utf-8') I'm not sure what you're on about with silent invalid Unicode, but if you mean ignoring encoding and decoding errors, different modes of strictness and behavior can be chosen when opening a file for I/O. For most applications this isn't a big issue, but for something serious it should probably be a consideration. f = open('/tmp/myfile', 'r', encoding='utf-8', errors='strict') It's all about what your program's policy is. If you are doing I/O with strict error handling, then I don't see how serious problems come up. The interpreter would throw a ValueError for bad strings. Edit: actually specifying "strict" is not necessary because it appears that this is the default. If you choose "ignore" instead, then errors will be silently ignored. So Python 3 is doing the "right thing" by handling errors strictly by default.
heheheh [2007](https://www.python.org/dev/peps/pep-3107/). Its pretty nice though, I like it at least.
thanks...will have a look at that. I assume this means you have one python script to collect the data and write it to txt file and what you've got above to plot it ?
i hadn't considered that...will give it some thought..thanks!
My favorite "Matlab quirks" story (from /r/matlab I think) involves this guy spending an entire summer internship tearing his hair out about why his code is taking a complex input and returning a real result... It turned out that (at least back then, maybe not now) when you do for i in &lt;range&gt;: do stuff You're overwriting the built-in default value of the imaginary unit. WTF? For a language that's supposed to be all about "how would an engineer try to write code if they didn't know how to code?", you'd think they'd at *least* throw up a warning message about what you're doing.
&gt;"aiming to unify the functionality of call, check_call and check_output" I really like this idea. I hope it makes it. I just wanted to say 'good job'.
&gt;Hello from a fellow Aerospace Engineer! I also learned Matlab in school, and still use it quite a bit with fellow engineers at work. While I'm a huge fan of Python, it's still often important to use the language/tool that is most productive in a given situation/team, so I use a combination of Excel/VBA, Matlab, and Python depending on the project. You're not wrong...but dear god, VBA. At work I got approached about dealing with this model that was written in Excel...there was VBA, but it was basically just some macros for moving an input column over a specified number of times so that a bunch of other cell references didn't have to be updated. The PI wanted to do keep doing VBA since he happened to know it. I basically said "I'll do this for you, but not in VBA." I suggested Python--other languages would have been just as good but I'm most comfortable with Python. I was apparently not the only one he approached to have this reaction. The real vindication for this came when the guy who built the Excel monstrosity agreed that, yes, it should have died a long time ago, please stop using it and redo it in a real programming language. And again, I agree with your point. And I get that this can be hard to do as a new hire. But do be cognizant of the line between "this is what everyone else uses" and "this is *not* the best tool for the job." I don't mean "oh, Java maybe does this better than Python", I mean torturing a tool beyond all reasonable limits and you need to find something else. We've hit some problems redoing things in Python, but they tend to get resolved within a week or two tops...we'd be lucky to even understand what the Excel model was doing by now.
Is it possible to create standalone app with Enaml and something like cxfreeze or pyinstaller?
How does it differ from Celery?
Is it only me or anyone else have not been aware of [SymPy][]? It’s pretty cool. [SymPy]: http://www.sympy.org/
It is much nicer than six in my experience: * the builtins module is awesome * future.library.install_aliases + the backports module * the handling of metaclasses is much better than six's I consider it much more powerful than six, because it lets you write code very much in the Python 3 style with a small amount of Python 2 syntax cruft. That's very different from six, which feels like I'm writing a crap version of Python 2.
hah...I have no idea what I'm doing with the data. This whole project has been about teaching myself. a) Eagle CAD for board design (for the sensors themselves, the radio and the Ucontroller (arduino pro mini)) b) low power operation so a lightweight version of the sensor can run on batteries for about a year (temp, light, humdity and pressure only) c) Python d) basic data science with numpy etc I am interested in things like the most efficient way to run my aircon in a 100+ year old house which is double brick and thus cools and warms very slowly. Thanks for your input, I was trying to avoid db's as they seem very heavy to me (and it's another thing to learn :-) but perhaps i need to get over that
Yep I know RRDtool...and I've always found its config to be completely alien (and I've used its predecessor MRTG) thus I'm trying to avoid it..perhaps I need to get over my bias :-) I believe (and I might be wrong) that RRDtool isn't great when your data periods are not constant which is what happens in my case.
Hi, thanks, I'll add this information directly in README. It focuses on local task execution and tries to stay simple as possible. But it is extensible, so one can write an extension to parallelize execution, or send tasks to remote workers. "Hello, world!" section in the [docs](http://button.readthedocs.org/en/latest/hello_world.html) explains the very basics of task execution.
How would you compare this to Shapely? I have been using Shapely to find polygon intersections etc. Would I be able to do a similar task with the geometry package in sympy?
Update. I already have the ping command and can ping an IP once I have it. The part I need help on is auto finding the IP address.
Swap the `while` loop around with the `for`, That will get you halfway through the door. Then fix the logic within the `while True`, By indenting the `else` to the `elif` rule. One more thing before you can relax, Don't `break` if weight is out of `min` to `max`. 
I've run into this, actually. The fundamental problem is that the environment is not set up properly with $LANG. To set it up manually within Python to override the terminal environment requires a little code. You can set stdio streams to any encoding by detaching the current stream and then building another TextIOWrapper: sys.stdin = io.TextIOWrapper(sys.stdin.detach(), encoding='utf-8') sys.stdout = io.TextIOWrapper(sys.stdout.detach(), encoding='utf-8') sys.stderr = io.TextIOWrapper(sys.stderr.detach(), encoding='utf-8') Needing to do this is not ideal, which is why it's easier to set up the terminal environment properly, but it may be useful sometimes. To set up the environment for cron, you can edit /etc/environment: LANG=en_US.UTF-8 Fixed! Actually the user could be using any Unicode encoding and any language, so the easiest fix is to make sure the environment is set up for cron jobs from the beginning. :-)
They have even their own tool similar to wolfram alpha: http://gamma.sympy.org/
That would make the code incompatible with previous versions of Python. Last time we did this, we got python 3.
Just a rehashed version from PyQt4. In "First programs in PyQt5" there are 3 mentions left for Qt4, even last sentence is "In this part of the PyQt4 tutorial, we covered some basics." Anyways, good read nonetheless. Edit: problems fixed now. Kudos to /u/janbodnar for his work!
&gt; I'm not sure what you're on about with silent invalid Unicode Then read my comment again. I listed half a dozen APIs that can (and do) silently return `str` objects that contain invalid Unicode. This isn't about reading and writing files. It's about the standard library handing you invalid Unicode. &gt; It's all about what your program's policy is. If you are doing I/O with strict error handling, then I don't see how serious problems come up Oh really? Please explain how you pass `errors='strict'` to `os.environ` or `sys.argv` to prevent them containing surrogate escapes.
How do you run programs, that you run into this all the time? It should be as easy as setting up the locale properly, or even just the $LANG variable. The Python 3 interpreter basically just tries to figure out the default I/O encoding by checking the terminal environment. That means if your terminal is not set up properly, there is no way for the interpreter to know the right encoding.
I've used cx_Freeze with a PyQt project but it was very simple. I wouldn't say I understand all the options but in terms of libraries I think you need something like this: options = { 'build_exe' : { "includes" : "C:\path\to\mylib.dll","mylib.dll" } } In terms of multiple files, if they are modules I'm pretty sure cx_Freeze pulls them in automatically. If you want to install multiple exes then you just need to include multiple executables e.g. here's a snippet from a setup.py file I use to install a gui and cli version of the same program: executables = [ # Console app Executable('SC930_LRQ.py', base=None), # windows app Executable('SC930_LRQ_gui.py', base='Win32GUI', shortcutName='SC930_LRQ',shortcutDir='DesktopFolder') ] From the looks of it the PyCharm setup.py tasks is just offering to run the setup for you. I have been running it at the command line: python setup.py bdist_msi As I said I'm not an expert. Hopefully this helps some and doesn't contain any embarrassing mistakes 
True, but I've only recently come to Python and PyQt, and when I tried to look for tutorials online there was a distinct lack of PyQt5. It seemed to be all PyQt4. So this is welcome.
Since you can ping, couldn't you just loop through the subnet and see if you get an answer? That would be like a poor man's nmap ping scan i guess. 
A test suite that can't be reasonably run every time you make a small change before you move on to another change sounds horrible to work with; I'm not surprised you want to speed it up. I can only offer anecdotal evidence, but a project I work on had its test suite run the last time on Travis in 43s on 2.7, 41s on 3.3, and 30s on 3.4. I kind of doubt a 25% reduction is actually typical, but 3.4 does seem to be at least a little faster from everything I've seen. (Your suite may vary, obviously)
Oh the irony! The subtitle of the blog post is "focus on readability", but when I go to the page the *very first paragraph* is in such microscopic font size that it is practically unreadable.
Maybe give [Nuitka](http://nuitka.net/) a try.
You shouldn't be thinking in terms of "I just want to", because presumably you are not doing this to only make this little starter application and then never make anything after that, right? So you should pick a widget toolkit for the longer haul. (You can of course still change later on, but it is harder once you're already invested into one). wxPython is a great choice from my experience, as is PyQT (from what I hear). 
It's not a question for r/Python - please post to other groups. The answer is https://ccl.northwestern.edu/netlogo/
&gt; there is already a perfectly good convention of adding a meta information to a function, and it's called a DECORATOR, dad gone it. Incorrect. Decorators are **not** "perfectly good" for this purpose. They're a second-class solution. Let's see what's wrong with them: @decorate def spam(n): pass Here we have a function that already has a decorator. Now we want to add type hints. So where does the type hint decorator need to go? Before or after the existing `decorate` one? They are *not the same* -- decorators can't be chained in arbitrary order. So you need to understand how `decorate` works and what changes it makes to the arguments of `spam` before you know where to put the type-hints. Where is `decorate` defined? Look it up. Maybe you don't have the source code to it -- perhaps it is written in C, or you only have the .pyc file. Somehow, you find out the signature of it, and decide whether or not it has the same signature as `spam`. Now you can add the type-hint decorator, either before or after the `decorate` one. Or, you can just annotate the spam function signature directly. Okay, let's throw away that decorator and just use the type-hints: @typehint(n=int, return=str) def spam(n): pass Oops. We have a syntax error. How do you declare the return type? You can't use the `return` keyword since that's reserved, you can't use an identifier (since it might clash with a parameter), you can't use a non-identifier. If a decorator was the only solution, then we might accept a second-class, ugly solution like the convention that `return_` means the return type, and any function that wants a parameter called `return_` is out of luck. Or perhaps "Return", or "FUCKTHISFORASTUPIDIDEA", or any other magic name we liked. One more. Here's a function from the "statistics" module in Python 3.4, with annotations added: `def median_grouped(data:Sequence[Real], interval:Real=1)-&gt;Real:` (you would need `from numbers import Real` first, but that's neither here nor there). That's a nice simple signature, with just two parameters. Let's ignore the return annotation, because we already know that there's no good way to include that in a decorator solution, and re-write it with this hypothetical type-hint decorator: @typehint(data=Sequence[Real], interval=Real) def median_grouped(data, interval=1): We've doubled the number of lines, for a trivial-one line function header! Imagine what this will do to a function with a dozen parameters, one to a line for readability. And we have to repeat each parameter name twice, once in the function signature, once in the decorator. Ugly, hard to use, and impractical. Decorators are definitely a second-class solution to this: * decorators need to be applied in a particular order * no good way to annotate the return result using a decorator * decorators double the amount of vertical space used by the function signature * decorators require you to state the parameter name twice Function annotations don't have *any* of these problems (except that they may sometimes increase the amount of vertical space, but not generally doubling it). If Python didn't already have annotations, and if annotations hadn't been added *specifically* to allow type hints, maybe decorators would have been a "good enough" solution. But that horse bolted five years ago, when Python 3 came out with annotations.
&gt; How do you run programs, that you run into this all the time? It should be as easy as setting up the locale properly, or even just the $LANG variable. cron, init, launchd, via OS X applications. All have essentially empty environments, so Python 3 puts its pants on its head and goes full ASCII. &gt; The Python 3 interpreter basically just tries to figure out the default I/O encoding by checking the terminal environment. That means if your terminal is not set up properly, there is no way for the interpreter to know the right encoding. None of which is relevant to or meaningful for the very common situation when there is no shell present for Py3 to interrogate for an encoding. Launching programs from cron or init is hardly an edge case, so why does Py3 make it so unnecessarily difficult to undo the dumb shit it does? The bottom line is Py3 in many situations a big step backwards from Py2 in terms of string handling because of all the dumb shit it does and how difficult it makes it for you to undo its bad choices. No amount of explanation *why* or *how* it does said dumb shit will change the fact that it does the things in the first place. It's broken. It needs fixing. 
My prediction is that the author of Nuitka will probably try using annotations for optimization, since it is his aim to do static analysis and optimized Ahead Of Time compilation. But the PyPy guys have already said that annotations won't make any difference to them, the author of Cython has said something similar, and Guido has made it clear that he sees type hinting as a way of improving *correctness* not speed.
Wrapping a window around Qwebview is kind of cheating, isn't it? import firefox firefox.run() Look! I made my own browser in python!
pyinstaller has worked very well for me.
Yes, but it would only add to the initialisation time of your application, not the "do some useful work" time. The decorator gets executed when the `def` statement is executed, which is normally once only, when the module loads the first time. After that, there doesn't need to be any runtime cost. However, Python 3 *already has* syntax to do this. Annotations are already supported. All this is doing is providing a standard meaning to those annotations. From the perspective of static analysis ONLY, it doesn't matter whether we use decorators, stub files, specially formatted comments, doc strings, or function annotations. Each of these have their own advantages and disadvantages, but for a static type checker, it just has to parse the source code, and if it can pass annotations it could parse docstrings or decorators or comments instead. That part makes no difference. There are [more important reasons](https://www.reddit.com/r/Python/comments/2u6wi2/type_hinting_in_python_focus_on_readability/co6rwi1) for rejecting a decorator solution than runtime cost.
I know that at least cron usually checks for several files to set the environment. On Linux you can modify /etc/environment, and just define $LANG there, and all cron jobs will use that environment. The manpage for cron explains this and the other possible ways to set the environment. The basic problem is more the environment, not Python. Many Unix programs expect POSIX locales to be set. As long as they are set properly, Python should pick up the right encoding.
It is very Pythonic. I'm looking forward to it. But don't worry, it is optional, and always will be. The Python compiler itself will ignore type-hints, but they will be available for the human reader as documentation, for runtime introspection, and for optional third-party type-checkers. Don't want to run the type-checker? Then don't run it. It will be like a linter (PyFlakes, Pylint, Obiwan, etc), not built into the compiler. 
&gt; they should have had str=utf-8 from the start /face-palm 
What a pointless waste of a perfectly good (potential) keyword `where`. This proposal has [many of the same flaws as using a decorator](https://www.reddit.com/r/Python/comments/2u6wi2/type_hinting_in_python_focus_on_readability/co6rwi1). It requires a new keyword. You cannot use it to annotate lambdas. It saves no vertical space. For short and simple examples, it *costs* a huge amount of vertical space: def median_grouped(data:Sequence[Real], interval:Real=1)-&gt;Real: pass # versus def median_grouped(data, interval=1): where: data: Sequence[Real] interval: Real return: Real pass 
Why Python 3 is better than Python 2: - Firstly, it's *not that different*. It's not a completely different language, just a slightly new dialect. - Better Unicode support. Welcome to the 21st Century, where we exchange text with people from all over the world. Even foreigners. - Exception chaining. Now when you get an exception inside an except clause, you can see the original failure that lead to the new exception as well. - Just one kind of class. The legacy distinction between "Classic Classes" and "New-style classes" (and the associated bugs when you messed them up) is gone. - Lots of minor improvements to the standard library. None of which are *on their own* worth changing for, but taken in combination, Python 3 is much nicer. 
:) 
my gawd, I would love for our test suite to only take 43 seconds...
I'm also interested in computational geometry in python. Performant code is always my focus. Right now, I'm working on an overhaul of Pyrr to vectorize it. I want to make a versatile library that can do POV raytracing, optical raytracing, and other CG tasks efficiently. 
Yes, I'm working on a numpy vectorized computational geometry library for this reason.
My problem with this is that if it isn't vectorized (numpy), then you're still working through a slow ass python for loop. 
Oh. My. God. I just realized why IDLE is the name of the default Python IDE. I've never felt this stupid before.
So you're looking for speed and "basic features"?
If it's just a tiny window, I'll use TkInter, but if it's a nice GUI, I'll use PyQt4 (not PySide because it's a buggy mess). I actually know wxPython the best, but have been been burned by it and PyQt GUIs look better. Last month, I was trying to build an executable using pyInstaller. On Windows 7, Python 2.7, everything was fine using wxPython. On Linux, I was running Python 2.4 because that's what the partner program needed (it had a dependency on PyQt3). I tried installing different versions of wxPython for weeks, but failed miserably. It's not like I haven't installed wxPython on Linux with Python 2.7 either. It's just a painful program to install. The last day of the contract, I decided to rewrite it in TkInter (freaked out my boss in the process). I installed TkInter, learned how and wrote the GUI in 2 hours and then built the software.
It's Eric 6 (now) BTW. I've used it from time to time and always been impressed, though it's a bit more than I need TBH. 
I'd probably go for some very simple [Eliza](http://en.wikipedia.org/wiki/ELIZA)-style chat bot. That lets you to show them basic concepts like loops and conditional execution, and they have something fun they can play with and try to extend.
Thanks for this. I have just tried it and its great. I am currently evaluating Wing Pro. My gripes with it is that it seems to have too much settings and configurations. If my boss won't cough up for a wing pro license, Eric 6 sounds like my next choice. I wonder why its not as popular as Komodo or PyCharm which I seem to hear about from everyone.
http://reeborg.ca/world.html Tutorial at http://reeborg.ca/docs/begin_py_en/ Most beginners like this a lot more than math-related stuff... edit: as long as they have access to a computer with internet access, they could follow along your demos - no need to install anything.
Because it requires to install many other libraries (e.g. PyQt...) which can be problematic on some platforms. I installed the Anaconda Python Distribution which, in principle, has all the libraries required to run Eric. However, the APD also comes with Spyder which is fairly good. All free...
How do you think it compares to pycharm?
/r/learnpython is the place for questions. Please describe your problem there. 'not working' isn't enough for us to help you on. Meanwhile whenever you present your code problem to people, and you're dealing with say map rendering, don't include the code for the input, since naturally you're debugging the map, so you've already reduced the code without the input so you can nail down the issue. No sense asking for help with 1000 lines when you can reproduce the issue with 10 right? Anyway, you'll need to include the text file if you want us to help you debug it.
Try http://pynsist.readthedocs.org/
He originally said Pycharm was slow on Linux for him.
Most of these are all false problems: &gt; Docstrings are free-form text. You just make syntax error inside the docstring. Docstrings are not huge, no problem to debug. &gt; Risk of false positives. The odds it happens are so low it's not even worth consedering it. It may bother you once it your life. No big deal. &gt; Annotations are easily introspected at runtime. Writting a parser for the stdlib for the notation is really not hard. Once it's down, you stick it into the func attributes, and that's it. &gt; What format should be used That's what the pep is for, decide these things. Last time i checked the annotation format was also debated cause you can put anything in there. Guido created an new type notation just for his proposal for god sake ! &gt; Docstring declarations duplicate the name of the parameter, This is the real bugger. But given it's optional, and most people documenting their code have being doing it, and it's hidden by docstring folding, well, it's not a terrible burden. Have you tried to read big functions with complex type annotations ? It's so ugly your eyes bleed. Python is about readability. I'd rather write the args twice that read 100 times the same ugly code.
I'm not understanding the basic command of specifing ip address range. If i'd like to scan my personal network, the normal aurgument would be 192.168.1.1/255 but when inputting that into this scanner it tries to scan some arbatrary range.
Literally every respectable IDE has that feature...
&gt; Not quite fine I said it *can* handle all that just fine, not that it magically does so by default. Which Py3 doesn't either unless your stars align… &gt; Python 3 puts an end to that "Do What I Mean" nonsense and forces you to explicitly encode/decode If that were all that it does, it would be a welcome improvement. But it isn't. Not by a long way. Sure, Py2 will try to automatically decode bytestrings to Unicode if you mix the two, but at least it has the decency to raise an exception when it can't. When Py3 is being all "helpful" and automatically decoding IO for you, if it can't determine the encoding, it silently returns invalid Unicode instead. That's some full-on, pants-on-head, PHP-level retardation right there. 
(╯°□°）╯︵ ǝɔnpǝɹ foldr1 (ツ)
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Eric Idle**](https://en.wikipedia.org/wiki/Eric%20Idle): [](#sfw) --- &gt; &gt;__Eric Idle__ (born 29 March 1943) is an English comedian, actor, author, singer, writer and comedic composer. Idle is a member of the English surreal comedy group [Monty Python](https://en.wikipedia.org/wiki/Monty_Python), a member of [the Rutles](https://en.wikipedia.org/wiki/The_Rutles) on *[Saturday Night Live](https://en.wikipedia.org/wiki/Saturday_Night_Live)*, and the author of the Broadway musical *[Spamalot](https://en.wikipedia.org/wiki/Spamalot)*. &gt;==== &gt;[**Image**](https://i.imgur.com/QeZAsqg.jpg) [^(i)](https://commons.wikimedia.org/wiki/File:Eric_Idle.jpg) --- ^Interesting: [^Medical ^Love ^Song](https://en.wikipedia.org/wiki/Medical_Love_Song) ^| [^I ^Bet ^You ^They ^Won't ^Play ^This ^Song ^on ^the ^Radio](https://en.wikipedia.org/wiki/I_Bet_You_They_Won%27t_Play_This_Song_on_the_Radio) ^| [^The ^Rutles ^2: ^Can't ^Buy ^Me ^Lunch](https://en.wikipedia.org/wiki/The_Rutles_2:_Can%27t_Buy_Me_Lunch) ^| [^Eric ^Idle ^Sings ^Monty ^Python](https://en.wikipedia.org/wiki/Eric_Idle_Sings_Monty_Python) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+co71n12) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+co71n12)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
You're not listening, are you? I don't need a tutorial on how to set my environment, I want a programming language that doesn't go full-retard if a locale isn't set. &gt; Many Unix programs expect POSIX locales to be set POSIX locale = C locale, which is the one that Python 3 chokes on. Are you at any point going to address the issues with Python 3 itself instead of pointing fingers in other directions? How about surrogate escapes? I'd love to hear why it's not a terrible idea for the stdlib to silently return invalid `str` objects that will likely explode at some indeterminate point later in your program when you try to decode them.
After finding [Christoph Gohlke's Python Libs page](http://www.lfd.uci.edu/~gohlke/pythonlibs/), my job of installing several quite difficult libraries (such as PyQt) has become quite easy on Windows. Right now I can install a new virtualenv very easily from scratch - I just need pip (which is now included in Python) and some wheel (*.whl) files. How do you do this on a Mac? I recently got one, and for the life of me, I can't install PyQt4 on the python.org downloaded python. I barely can on the linux machine either (but the situation is a bit better there).
Well, you can write your own rules for whether or not two entities not having an attribute in common is a miss or ignored. You can also give greater weight to some keys over others in your metric function. But, weighting keys might start to get pretty arbitrary. How much more important is having the same name than having the same company? If two entities have the same company, phone number, address, etc but different names, is that a worse match than two entities that have the same name but different companies? Maybe they have a nick name? Maybe the clerk misspelled it? If you give name a weight, won't that bias matches between entities that have the same name, which could easily be coincidental, over entities which have the same company and which are really related? If you choose the weights to make your sample data work, then how can you know the weights apply to the full data. Not a data scientist here, just some thoughts.
Thanks. So far, no-one has said it shouldn't go in, so I'm optimistic. I'll give it a couple more days before pinging on the issue.
I remember having PyQt trouble on OS X (to the point where I decided it wasn't worth the hassle), but I have had [this page](https://gist.github.com/guillaumevincent/10983814) open for a few days, meaning to try it out... it's for PyQt5, not 4, but maybe it will help you out. Caveat: still not tried it myself yet.
&gt; It is No, it isn't. Py3 is a cunt of a language for working with encoded strings, the things that network protocols are made of. If it were as easy to port Py2 code to Py3 as you pretend, then surely someone would have ported PyPI to 3 already, wouldn't they? It's been 6 years since 3 was released. You'd think someone would have got round to porting such a "flagship" Python app running on python.org if it were as straightforward as you seem to think. Or perhaps they haven't because Python 3 is a PITA to port such apps to. 
I'm not an expert on matplotlib, but after testing to write the greek letter, I just got a single rectangle instead of the letter, so I assumed it's because matplotlib was not using the correct font. After googling a bit I learned, you can define a FontProperties object and pass it to the xlabel method: &gt;&gt;&gt; import matplotlib.pylab as plt &gt;&gt;&gt; from matplotlib.font_manager import FontProperties &gt;&gt;&gt; fp = FontProperties('Symbola') &gt;&gt;&gt; plt.xlabel('This is a test \u03bc', fontproperties=fp) &lt;matplotlib.text.Text object at 0x7f7465407ba8&gt; &gt;&gt;&gt; plt.show() This worked for me. `Symbola` is the font name I chose to use. Note: I did this with python3, so the string literals are all Unicode strings.
It should be able to handle unicode characters: plt.xlabel(u'Wavelength μm') Failing that, it can render a limited subset of Latex: plt.xlabel(u'Length ${\mu}m$')
&gt; It feels great being righteous about python 3 doesnt it? bit lame though, when you ignore reality. In a way, I find the ability of Py3 apologists to ignore reality really rather impressive. We can't be far from the point now where one of them rolls out the old "it's the world that's broken, not Python 3" chestnut. 
Thank you for your answer :)! I didn't express myself correctly, indeed. I'd like to know how to create this matrix, the grid where the bombs and all will be. I googled it multiple times but I only found some outdated or not working code about this grid problem, or code too complex for me if concerning the whole game.
Zero issues installing it with a APD FWIW.
Sounds good! To be honest though - to do basic data science with python you need some sort of objective. You can't just go blindly into a dataset and start pulling random statistics. Think of an interest question that your dataset can answer and prove it!
That's true; however, you can achieve something similar without doing inline type hints. The lack of currying also opens up the syntax a little. #= stringSlicer :: String, {Int, Int, Bool} -&gt; String def stringSlicer(str, start=0, end=1, upper_case=False): ... That is to say, align the type declarations with the function definition, but indicate that they can be in any order.
&gt;A change is not necessarily an improvement. And to some people any change is unacceptable. Neither changes the fact that there have been a boatload of changes to Python 3 and as the original author states, it's highly unlikely that in 192 pages of changelogs one can't find anything to be excited about. &gt;There's a lot of stuff in 3.x that I'd be happy to see in 2.8, but there are some very &gt;serious fundamental problems with Py3's text model that more than outweigh all &gt;the little improvements. Text is Text; bytes are bytes. How is that a fundamental problem? How is Python 2's model not a problem? 
your stuff is miles ahead of where I'm at (and at a much larger scale) but very interesting, thanks. I was going to have a play around with Bokeh (http://bokeh.pydata.org/en/latest/docs/user_guide.html) once I get the basics out of the way 
I just tried μ = 6 print(μ) in IDLE (3.4.2) and it worked as expected. I hate Windows alt-codes so I Google for "mu" and copy-pasted in μ from the Wikipedia page. Is matplotlib butchering the rendering of μ for you?
and that's just ipython, right?
&gt; Python is used for a lot more than for working with network protocols. How about POSIX environmental variables, filenames on Linux or in zip files? Those are all bytes, too. &gt; And text is text, bytes are bytes is as obvious as it is brilliant It's not brilliant. It's straight up contrary to reality. It might work out by the time we get to 3.7 or 3.8 when [all these missing pieces](https://thoughtstreams.io/ncoghlan_dev/missing-pieces-in-python-3-unicode/) have been added, but at least as of 3.4, Py3 has some grave regressions versus Py2. &gt; Python guru David Beasley So your argument is, "porting is easy because this exceptionally talented Pythonista found it easy"? By that logic, astrophysics is easy because Stephen Hawking finds it easy. &gt; Currently, as of 2013-11-11, PyPI is undergoing a complete rewrite from scratch.... It'll be very interesting to hear about the all the problems Py3 caused them. Unless they're using a framework, of course, nicely punting all the problems Py3 causes with HTTP to the framework's developers instead. If *you* don't see the problems with Python 3, well that's your tunnel vision. But don't go around telling other people for whom it presents *very* difficult to solve problems they don't have with Py2 that they're wrong just because you don't have those problems. 
I somehow missed that. Thanks :) 
Complete beginner here. I've got mac and brew installed all required packages. How do I actually install it once I've downloaded eric6? I can't find any documentation on their site or google.
Use the CIDR notation (192.168.1.1/24)
Thanks for such the classy reply!
Try /r/learnpython for questions like this. But for one, break down your conditions into functions and look into the built in function [all()](https://docs.python.org/2/library/functions.html#all)
&gt; Now do something which has 2-3 arguments, keyword or two with a default , (at least one iterable) + callable, and make it return a tuple. Well, we can't read now, can we? Of course we can. At worst, split the signature so that there's one parameter per line: def v_mapper(coordinates:List[Point], generic_vehicle: Maybe[T], locator_function: Callable[Any, Any], default_coords: Tuple[int, int] =(0,0), ) -&gt; Tuple[int, int]: """docstring""" pass That's far more readable than shoving your type information into a *string*, splitting the reader's attention repeatedly back and forth from the parameter list to the decorator. 
&gt; When Py3 is being all "helpful" and automatically decoding IO for you, if it can't determine the encoding, it silently returns invalid Unicode instead. What? That's bullshit. Python 3 doesn't try to guess the encoding. (Although I consider `chardet` all but essential for anyone dealing with real-world text. There's an awful lot of legacy encoded text out there.) If the default encoding isn't suitable, and you can't deal with "invalid Unicode" (I still don't know what you think that means), pass errors='strict' to the file opener. Talking about "pants-on-head, PHP-level retardation", I'm pretty sure that whining that you don't like the defaults while completely ignoring the fine control you have to specify non-default arguments counts too. You can write like a PHP non-programmer in any language.
I'm pretty sure you can use latex notation, so "$\mu m$"
Let me fix that for you. Why Python 2 is better than Python 3: * Slightly better 3rd-party library support, with the gap steadily shrinking. * There are still some Linux distros and Unix systems which don't make it obvious how to install Python 3. And you missed one: * Mixed text and bytes is significantly easier in Python 2 than Python 3 so far. Your other arguments are bogus. - Python 3 doesn't assume "all" text is Unicode. It supports legacy encodings, and it allows you to use byte strings just as Python 2 did. You just have to prefix your byte-string literals with a b. - "Invalid Unicode strings" sounds like FUD. In the absence of evidence to the contrary, I'm calling bullshit on that. - Python 3 programs that work in the shell work from cron too. Python 2 programs can fail to work from cron as well, and not just those using locale. - Working with encoded strings is simple in Python 2 too. They're just called *bytes* instead of strings. 
Very cool, I started working at a Ruby shop recently and I like bundler much more than virtualenv.
The C locale is itself 1970's ASCII mode, so it makes sense that Python would use ASCII with that locale. The C locale is itself "full retard" mode. If you don't want that, then you should set up your environment properly (obvious) or override it in Python. You seem to think that Python should *ignore* your locale and override it with something else, just because you can't be bothered to set up your cron environment properly. Next we will be hearing about how Unix shells are stupid because they don't set up $PATH automatically for cron jobs... :-P I don't think the surrogate escapes issue is a big deal (it's a problem, but not a big one). If you are passing in an environment variable, for example, it could have anything in it. Python does its best to decode it using the native encoding, but still preserves any other "stuff" inside it. The obvious solution is to sanitize the data either when you first read it, or later when you write it, or just expect that an I/O error can possibly be thrown upon trying to write a string that you haven't bothered to validate in any way.
Eric Python itself is written in Python with QT library. It is faster than Pycharm, uses less memory etc. PyCharm written in Java, you can imagine the memory usage. But still I use PyCharm, because project management and code editing in PyCharm are better (I wish It works faster).
Interesting first program, I like it. My biggest suggestion would be to stop that abuse of `global`, it's honestly like 2nd time I've ever seen it used (the other from a misguided beginner) and you actually taught me how it works here haha. (It's extremely taboo to use) You should implement classes. Attributes would really help you get past using globals. From what I understand you randomed `apple_price` the first time around, then used it as a global over in the next part so you had the same random. import random class Shop: def __init__(self): self.apple_price = random.randint(1,3) def example(self): print(self.apple_price) #can refer to variables made in init via 'self' shop1 = Shop() shop1.example() print(shop1.apple_price) #can also grab attributes of the class outside it I didn't want to port the bit confusing shop over to a class but here's what a class looks like. Then incase you random more stuff in the shop it'll be really useful as basically a 'state' of the shop and when you leave it's destroyed and a new state of the shop will be created next time. Or if you build a bigger game with different zones, you could have different shops with static item sets (remember the instance of the class) that were randomed for that specific play through of the game! Theres a lot of power in classes and it saves you from spaghetti code of functions calling functions indefinitely, and drop the damn globals and now it'll be days of parameter tossing between the spaghetti functions. edit: Forgot to add, you should really check out /r/learnprogramming or /r/learnpython this post is sorta ok for here since it isn't just a beginner question but over there you'd probably get a lot more responses and advice. People here just sorta want Python news, libraries, and IDE talk here mostly. 
SQL isn't Python so writing it in a Pythonic way is misguided.
IDLE isn't really meant for any serious development. It's much more of a tool designed for beginners to reduce the friction from writing code to executing it so I give it a pass on looks. 
PyCharm just got it, but people have loved it for a long time. I've used IDLE, Textpad, Eclipse, PyCharm, and WingIDE. WingIDE is by far the best of those for me.
What I mean by that is an application that enhances the desktop, make grids etc. I dont quite understand how or what Id need to learn and control in order to make something similiar. Even just sticking a window to the desktop like the windows post-it notes would be a great start thank you
Someone needs to tell the LINQ guys they've made a terrible mistake then. /s
Integrating with the desktop itself is tricky, and how you do it will most likely be completely different for each desktop (Windows, GNOME, KDE, etc.). Normally, applications are expected to stay in their own window or terminal, so interfaces for enhancing the desktop aren't well defined. If you're interested in that, then I'd recommend you spend a while using at least one of the open source desktops (GNOME, KDE, xfce, etc.) and seeing what configuration options and extensions are available, then start looking at the source code of those that come closest to what you want to do.
Thanks for the tip. I'm portuguese actually xD My girlfriend is of romanian heritage though, and the username came from an inside joke.
They have nice [coding standards](https://github.com/USArmyResearchLab/Dshell/blob/ec828967298ee72b58419211e18cd153327af785/lib/dnsdecoder.py) :) There are already a few commits to PEP8 the code a little, but I think there is still work to do.
You have to think in Python to understand, why this is useful. Let's say you have an object A querying the database and an object B inheriting from A and doing almost the same query. Do you rewrite the whole sql query? I don't think you should because of maintenability concern, coherence, etc.
I posted it over there too, but I'm not sure they get all the references.
Soooo an ORM? Not really a python-specific concept... Although this library looks a bit lower-level, more like a DAL.
This is more of a game tip but at lines 40 and 65 append .upper() like: menuInput = raw_input("Please enter your choice: ").upper() which makes your input into caps since it looks for letter in caps
How is %-formatting coming back and why?
&gt; PyCharm just got it Care to elaborate on that? From the early release notes I'm reading PyCharm has had a line-by-line debugger with variable inspection since V1.0 in 2010.
Maybe [dedupe](https://github.com/datamade/dedupe) suits your needs
I've done this cause there was nothing really adequate for microbenchmarks. Timeit is quite bad here, it shows you only the min while the other metrics like average or variations are important to identify issues with your run (eg: you forgot your browser or services running, now your tests are unreliable cause you have external influences - you'll see that when you have high deviations). 
I have an i5 CPU. Start up and loading projects take too long (2-3 minutes), and GUI doesn't respond well, too. I increased the heap size, disabled plugins that I don't need but still slow. Android Studio (built on Intellij IDEA) is worse in my case.
what does this do exactly?
LINQ! You've made a terrible mistake!
tcpdump?
Hi there! Have you seen [kivy](http://kivy.org/#home)? It does wonders for game programming :) 
use idle :3
I've used both pycharm and wing, both really good ide's. Are you going to be doing any other development besides python? Pycharm has a better plugin system if you're going to be writing any other languages. Wing is dedicated 100% towards python, and has slightly better built in code testing.
There's a few FLOSS forensics tools floating around with military origins. PyFlag, which I've used extensively, was originally written by the Australian DoD if I remember correctly and Foremost originated with the US Air Force's office of special investigations. 
Hilarious… and true.
XC post this to /r/computerforensics. A lot of net analysis folks there 
&gt; PyFlag, which I've used extensively, was originally written by the Australian DoD if I remember correctly I used to use PyFlag for RAID reconstruction back when I did forensics. It's good shit.
&gt;Start up and loading projects take too long (2-3 minutes) Strange, mine is basically instant! (2-3 seconds). The program is on an SSD and all my projects on a magnetic hard drive. Maybe it's SSD magic I'm seeing here?
If you cut off the legs on your horse it becomes considerably lighter :P
Great article. Thanks!
Feature-wise for the individual, they seem similar. Pydev often breaks when installing plugins, and it's harder to setup the workflow. Pycharm was therefore an easy choice for me. I can't comment on price, licensing or vendor's support as Pycharm very kindly provide a free license for open source projects. As I work mostly on my own, there may be some differences with features intended for large organisations (shared code snippets or settings) that I'm unware of.
This is platform specific. What you've shown is a Windows app, and you'll need the [Windows API](https://msdn.microsoft.com/en-us/library/windows/desktop/ff818516%28v=vs.85%29.aspx ) as their desktop is part of the operating system. There are various function in there that you can call to create windows, icons etc. You can do this in Python on a Windows box. You'll probably need windows versions of various python packages, which you can find [here](http://www.lfd.uci.edu/~gohlke/pythonlibs/) Someone else has already discussed Linux.
I use pyCharm. It works for me without too much settings, and plug-ins. So it is easier to use it on different machines. But I lately tried atom, and it was quite nice, since support for other languages is just a plug-in away.
You *are* being snarky. You know that the dude you're replying to didn't read the README and you're dickishly pointing that out. Let's be clear about what's really happening here.
How should I best structure my code for creation of the database as well as updates of the database structure between versions, given the fact that the application should be easily distributed? I'm thinking about adding all database creation to the setup.py script, but I'm not sure what the standard way is. 
* https://www.reddit.com/r/Python/comments/2oer3f/suggestions_for_middle_school_presentation/cmmgoc8 * https://www.reddit.com/r/IPython/comments/1dl8wc/seeking_advice_for_introducing_ipython_in_high/
http://www.cvedetails.com/cve/CVE-2015-0235/ &gt; Heap-based buffer overflow in the __nss_hostname_digits_dots function in glibc 2.2, and other 2.x versions before 2.18, allows context-dependent attackers to execute arbitrary code via vectors related to the (1) gethostbyname or (2) gethostbyname2 function, aka "GHOST." 
Or you could just use Peewee and save yourself a bunch of time and code.
&gt; It seems like it just tells you the IPs you monitored, but that doesn't make sense. I see geoip is involved, which leads me to think that it categorizes traffic by country. It's a framework/toolkit to do that kind of thing, making it easier to analyze recorded traffic. Packet captures are really just all packets saved in a file (+ timestamps), without further structure, and this a) offers helpers to make writing scripts to parse and modify packet captures easier and b) includes some of these scripts already E.g. first example is the invocation of one of these scripts, that (in a quite primitive way) analyzes DNS traffic and reports all DNS queries made. (which e.g. could help to identify rouge or infected machines in a network)
AFAIK, it's being added to `bytes` and `bytearray` [in 3.5](http://legacy.python.org/dev/peps/pep-0461/). The main reason is wire protocols and file formats, e.g. HTTP, email, PDF, that are mixtures of binary data and ASCII text, which is something that is currently much harder to work with on Py3 compared to Py2. 
I prefer PyCharm. Are you attempting to make a decision for your entire team? Why not let individual developers use the tools that work best for them? Carpenters aren't usually told which hammers to use. Writers aren't told which pen/typewriter to use. Why should developers be limited to a single IDE?
Except you don't need to connect to a database nor define the schema.
Couldn't this be done with awk?
It depends what you're looking to do with python. If you're going to be writing your own stuff, it's probably better to start with python 3. If you know you need python 2, and you'd know if you need to, use https://www.python.org/downloads/release/python-279/ instead.
&gt; Python 3 doesn't assume "all" text is Unicode. It supports legacy encodings, and it allows you to use byte strings just as Python 2 did. You just have to prefix your byte-string literals with a b. I'm referring to IO like `sys.argv`, `os.environ`, `sys.stdin` etc. Py3 treats those as text despite the fact that POSIX explicitly states that they are bytes. &gt; "Invalid Unicode strings" sounds like FUD. In the absence of evidence to the contrary, I'm calling bullshit on that. They're most definitely a thing whether you've heard of them or not. If they weren't why did Python 3.1 add [surrogate escapes](https://www.python.org/dev/peps/pep-0383/)? &gt; Python 3 programs that work in the shell work from cron too Not necessarily. cron (and init and upstart and launchd) uses the C locale by default, which means Py3 defaults to ASCII for IO instead of the UTF-8 you'd usually get in your shell. &gt; Working with encoded strings is simple in Python 2 too. They're just called bytes instead of strings. You mean Python 3, right? No it isn't easy. Apart from the fact that you have to dick around a lot to, e.g. reopen STDIN and STOUT in binary mode, `bytes` doesn't have the full string API like Py2's `str` does. Fortunately, %-formatting is coming (back) to `bytes` in 3.5, which is a big help in that regard. 
Use 3.4.2 unless you need another (app specific) version, which you can use safely by creating a virtual environment (virtualenv, virtualenvwrapper). I don't know if it works with windows as good as with unix systems. (I think Pycharm supports it)
i love python but why would anybody want to use this? It looks like it's a fucking nightmare compared to much more mature frameworks already in existence. 
Of course, it could be done with perl, awk, java, assembler, c and COBOL. But given that Python is very productive, heavily used for data analysis, and allows one to easily add more transformations - it's fairly ideal.
I use both and I prefer eclipse when I don't need support for web languages edition (css, html, javascript). You have eclipse plugins for that, but the ones I tested were slow. A few examples of what I prefer in pydev: -"Quick fixes"/"Inspections" require only one keystroke &amp; menu. - "Quick fixes"/"Inspections" displayed very clearly as red/orange/yellow next to the line numbering. - better icon contrast for folder and packages. - Overall easier to learn and good screencasts. 
If you pull a value from, say, `sys.argv` or `os.environ` that Python couldn't correctly decode using whichever encoding it got from your locale (because on POSIX there is no guarantee that a specific encoding applies), you will get a `str` object that contains so-called surrogate escapes, which encode the decoding error within the Unicode string. That way, information doesn't get lost in decoding, so if you've got a filepath from `sys.argv`, Py3 can still find and open the file (before surrogate escapes, Py3 would just fail). You can pass such strings around internally in Python just fine, but because a string with surrogate escapes isn't valid Unicode, if you try to do anything with it that will encode the `str`, you will get a `UnicodeEncodeError`. Unfortunately, `str` objects that contain surrogate escapes (i.e. they're invalid Unicode) are not marked in any way, so you have to memorise which APIs may return bollixed strings and deal with them there. If you don't, then your program may throw an exception a *very long way* away from where the bad data originated. This is all, imo, a far bigger PITA than dealing with plain old bytestrings in Py2. At least in Py2, if `isinstance(s, unicode)` is `True`, you know you have valid Unicode. 
What I mean is "Isn't this just text manipulation?". If you have to write the module anyway, why not write one for a program that analyzes ANY text instead of just pcaps?
I dunno dude... Rtfm or gtfo
&gt; I never got used to the Eclipse interface. This basically encompasses the entirety of my argument on the topic. As astonishing as it may seem it is also my entire argument if you were to ask the same thing but in /r/java for Eclipse vs IntelliJ. JetBrains offerings just 'feel' better and are easier to use for me. I have a coworker that feels the exact opposite: he loves Eclipse and is turned off by IntelliJ. This is probably not helpful at all as it only reinforces your opinion that it is a matter of personal preference. Mostly because it is entirely a matter of personal preference...
I'd say you're right in saying it's a matter of taste. Personally I use PyDev because I use eclipse for a lot more than just Python. So I don't have to switch IDE when I switch projects.
Don't point them to 2.7.8. That's not the current release. 
thanks for the feedback, i'll make sure to make note of all these things
All Imports should be in alphabetical order, and Importing a module should have no side effects to it, also always lowercase the host value. And I would suggest stderr instead of stdout ______________ I can't spot any error-handling. __________ I had a hard time with this when I was learning but those are the only errors I can spot.
Awesome - I'll give it a shot... I do a lot of work with geospatial data in python and want to try creating some weather maps... Looks like you were using some nws rainfall shapefiles in the contour.py example... What other geospatial data types (if any) are supported? If I had some raster type data could those be shown on a map too?
Fixed, thank you.
I... I need to go change pants.
/r/learnpython
You'll have better luck in /r/learnpython - read the sidebar and follow the advice about how to ask a good question.
If you're looking for a flask-dal extension maybe you should take a look at [weppy](https://github.com/gi0baro/weppy) ;)
Such as? 
It seems so. SSD's performace is much, much better.
You may want many button widgets, created programmatically by loops and stored in a 2d array (list of lists). Or you could use a canvas if you're willing to draw the grid with lines and convert mouse coordinates to boxes. 
If ease of distribution/installation is paramount and you don't care if it looks slightly ugly, just use tkinter.
I wish I could be some help, but I'm struggling with Urwid myself.
/r/learnpython
The side bar here has some great resources.
I have to admit I cringed when I saw a Python 2.x print statement and checked the date and saw that the article was written in 2015. 
I second this, as someone who wants to start tinkering with game design, but doesn't know where to look, I'd love to know what other frameworks exist.
Oh cool. I'll just make this nice and PEP compliant. I'm helping the army! flake8 */**/*.py Oh dear lord.
It's a false choice. You can share the data access layer in different ways than trying to model SQL's version of relational algebra as an object hierarchy. This library is only a Query builder, but full on ORMs have [even more problems](http://en.wikipedia.org/wiki/Object-relational_impedance_mismatch). If the SQL tuple output was removed, how long would it take you to determine what queries were being produced? Would you even be able to? That's the problem. This library looks like an impressive feat of programming, but I don't think its goals are actually desirable.
I see that, but it is hardly simpler, is it? Maybe I just don't really appreciate the cumbersomeness of joins.
OpenCV can open a video file and treat it just like a live stream, and then save the combined video if that's what you mean. What exactly are you trying to achieve?
You can decode the video frame by frame using OpenCV's VideoCapture class, modify the decoded images at the X and Y coordinates specified by your eye trace data, and encode the results frame by frame using OpenCV's VideoWriter class. You can also display the result in a window using OpenCV's imshow function. 
FYI, PyCharm has a community edition that's free to download if you care to try it.
I'm interested to know as well. As far as Python is concerned, there's really only Kivy and Panda3D. Others: Pygame (hasn't been updated in years), and Pyglet (seems to be dying), and Cocos2d (eclipsed by its objective-C and C++ counterparts).
\**cough*\* &gt; PyDark was designed **too** make sense, thus the code is easy to read and pickup. Irony ;)
Maybe check out moviepy. It uses ffmpeg.
Are there any Python libraries to overlay the coordinates in a CSV file over a a video file when it was played without saving a new video?
I'm processing 2 weeks worth of 4K video data from 2 cameras where I extract the coordinates of the objects I'm tracking and would really like to find a way to layer this over the original video when I play it because it would take up too much space to save new videos with OpenCV. Really interested if someone can solve your issue because hopefully that will fix my problem too.
Perfect, exactly what I was looking for.
You could possibly misuse a subtitle format like ASS (Advanced SubStation Alpha) for that.
That's great to know, thanks! I was gonna sink €100 euro on that thing, won't bother (yet?).
Pretty much this. Py3 or yawn.
Nitpicking point: game design is technically the part of game development that doesn't involve programming. :)
are you trying to do feature matching?
Thanks for the help. Got it working :)
Whoa, good catch... try: ... except: and eval(command) *shudders*
&gt; Just in case: I am not the author/maintainer of the framework. Why say "for perfectionists" then?
I simply clicked on "Suggest title" button. This is the text from the title.
For the initial release it doesn't matter if you distribute the database file or have a script create it. For subsequent releases, have your application apply an upgrade script to the previous version. It doesn't matter if it's a script in a separate file or if it's a hardcoded string in your program. To make this work it helps to have a table where you store the database version. So for the initial release that table, let's call it "Version", contains a single row with the value 1. When you ship version 2 of your application you likely have database changes as well so when version two of the application connects to the database it checks the version, and if the version matches what it expects it upgrades it to version 2. The next time version 2 of your application starts the database is already at version 2 and should not be updated. I like to be paranoid and make sure that the program can't upgrade from v 1 to 3 without going through 2 first. You can run into lots of trouble if you skip a version. If this is at all unclear let me know and I can expand on it. So when you are at version 5 of the application you probably have a few upgrade functions that you can apply, in order, to the database at startup. If you start version 5 of the application against version 1 of the database all the previous updates will have to be run on the database in order to have the database in the right state. The application and database versions doesn't have to follow each other. Sometimes you bump the application version and doesn't have any database changes. Then it doesn't make sense to bump the database version as well. I also like to be able to supress the database updates, e.g. with command line switches. Sometimes it makes sense to start a new version of the application against an old version of the database without having it updated, if you know what you are doing. 
Aha, stupid chrome doesn't show full titles anymore. I couldn't see that "branding" on the index page itself :)
I'm not /u/MagicWishMonkey, but the impression I get is that IntelliJ with the Python plugin features everything that PyCharm can do, but not being aimed specifically at only Python it can handle a wider selection of languages and file formats.
Try Unity. Making Unity games do lock you in their platform and you won't have access to low level stuff, but it's painless to make levels, test, deploy and distribute games. The web player is the greatest thing in it with sites like congregate and gamejolt coming into existence. If you want something more bare bones I suggest SFML. It's a media library written in C. The reason I like it is that it offers an working layer of functionality that you can replace as you go on. For example, you can start your text needs using sf::Text and then switch for a complete text rendering library later on, or use sf::Audio then switch to an audio library, replace sf::RenderWindow and sf::Input with GLuT code, etc.
I can ensure you that it is simpler when you have to dynamically construct the query instead of manipulating string concatenation. Also it can be used a little bit like the CTE[1] but for anything by reusing the same small part of the query in many places. And so the all query will be easier to read and understand (if it is a big query). [1] Common Table Expression
No I'm tracking insects and have some reflective tags, all the tracking has been handled, I'm just trying to come up with a way to overlay this data over the original video without writing a new video.
Thanks for the idea, I'll check it out :)
 select.where = (user.name == 'foo') &amp; (user.active == True) That... doesn't really strike me as all that Pythonic, to be perfectly honest. It seems really disjointed to generate the queries through `__iter__`, and all the operator overloading is *cute*, but the borderline haphazard way it's employed here seems to be much more at home in a C++ setting than Python.
Thank-you so much! I'm checking it out now, I really didn't want to have to drop down to using Qt so you've saved me a lot of hassle!
&gt; https://twitter.com/FlickrHelp/status/561196847356604416 I know that, but the latest api uses SSL.
I had some trouble installing opencv and related libs at my mac so I made this https://github.com/gleicon/vagrant-ansible-computervision to create a linux vm at vagrant with the whole packsge and build enviroment. I would end up running code at aws so testing locally using linux made sense for me.
I was hoping I'd be able to use a simpler drawing system but I'm starting to think that this is probably the most straight forward way.
Its more intricate that you appear to realise. You need to write your own code.
&gt; Jinja2 is a modern and designer-friendly templating language for Python, modelled after Django’s templates. &gt; Django is a high-level Python Web framework that encourages rapid development and clean, pragmatic design. Basically, Django allows you to complete many of the tasks you could encounter while building the webservice in python. Jinja2 is a measure to deal with only one of those tasks, which is document rendering. Besides Django - [Flask](http://flask.pocoo.org/) or [Pyramid](http://www.pylonsproject.org/projects/pyramid/) are worth considering. I will direct you [to the article](https://www.airpair.com/python/posts/django-flask-pyramid) - some of the statements there may be out of date of course. What I'd say is: if you want to start fast, use Flask - it uses Jinja2 template system by default. If it's something bigger then Django and all features it incorporates are nice, but they may take a while to setup.
Yeah OpenCV isn't difficult, I was just hoping there might be a way (for instance) to use the VLC API with Python to layer text over the video which wouldn't require me to set up OpenCV on additional computers when I distribute the software. 
&gt; SFML. It's a media library written in C. C++, actually.
You should list all your constraints then..... I tend to choose differently if I distribute my software to collaborators, or if I am using it only for my own research. On the other hand, you sound like you work in science, so you should just prescribe the supported configuration and let your users replicate it. I do this for a living, and if you let some arbitary masters student expect they can run your research quality software on some random computer they own, you are setting yourself up for madness.
The __iter__ is there to provide easy usage with DB API of Python like: cursor.execute(*query) instead of (also working if you prefer): cursor.execute(str(query), query.params) Those operators usage is because Python doesn't allow to override and/or operators to return something else than bool value. So we need to use the bit operator instead which has a lower precedence (and so it needs parenthesis). But you can use, if you prefer: select.where = And([user.name == 'foo', user.active == True])
You can use Touchandgo as a library for your app ;)
^^^ exactly this. There are plugins for just about any language you can imagine (it even has support for stuff like Coffeescript). If you're going to spend a lot of money on an IDE anyway, you might as well get IntelliJ (especially if you can expense it). 
Is singleton actually something we want in Python? I've implemented one a few times just to get rid of it later on because it wasn't actually necessary. Instead of applying some logic from other languages it might be better to look at the actual use case and find a Python pattern that applies. For example in Java I sometimes used Singletons to carry Methods without side effects to the Singleton's state. Something like that can be done in Python via using functions instead of methods. Also there are some examples in the Python core that use Factory methods/functions instead of object construction (e.g. logging.getLogger). If you have a Factory taking care of your object creation then you don't need Singletons either, because the Factory can assure that each object is only created once. Are there other usecases for Singletons? I bet we can find an alternative approach that works more pythonic.
Aren't MP4's a version of MPEG...?
I think OpenCV has an OR operator http://stackoverflow.com/questions/17961092/how-do-i-do-boolean-operation-on-mat-such-as-mat3-mat1-mat2
I'm superficially familiar with Redis, but quite versed in Twisted, so bear that in mind when I dole out advice :) &gt;maybe involving twisted is overkill To give the standard non-answer: I guess that depends on what you call *overkill*. Are you worried about performance? Maintainability? The learning curve? Twisted has the advantage of being very lightweight and having very loosely-coupled constructs. As far as performance and maintainability are concerned, Twisted is a developer's dream-come-true. The point here is that you can make use of Twisted's `Deferred` API (which, again, are promises by another name) without involving *anything* else from the framework. Just do the following: `from twisted.defer import Deferred`. If you want to manipulate `Failure`s as well, just do `from twisted.python.failure import Failure`. Again, these two constructs are *completely* independent from each other and the rest of the Twisted framework. With regards to the learning-curve, Twisted is indeed... well... twisted... The good news is that the Deferred API is actually quite simple and you can safely ignore anything that doesn't pertain to the callback/errback chain. Given that you're already familiar with Promises, it should all feel very familiar anyway. **To answer your question more directly:** I'd be inclined just to use txRedis. It's already tested and supported, it's built upon a mature library, and you don't appear to need anything that isn't already offered. As suggested reading, here is an [excellent tutorial](http://krondo.com/?page_id=1327). I would start with sections 7 - 9. **Again**, `Deferred` works independently from everything else, including the `reactor` that you see appearing in these examples. In case you aren't convinced, consider the following demonstration: from __future__ import print_function # this will serve as a callback from twisted.internet.defer import Deferred def add(first_addend, second_addend=1): """This is our first callback function""" return first_addend + second_addend d = Deferred() d = d.addCallback(add, second_addend=5) d = d.addCallback(print) d.callback(10) See? *Completely* independent. You can consider `twisted.internet.defer.Deferred` a stand-alone library. In fact, that's exactly what we did when implementing [txCelery](https://github.com/SentimensRG/txCelery). Seriously, look at the source code. It's small as all hell and involves virtually nothing beyond `Deferred`s. 
One example contrary to module var would be if you want to delay initialization to some time _after_ import (until object is accessed for the first time for example). You can of course to simply write this delayed logic. But it if you have several of such guys it starts to look as a bunch of copypaste-like code. And its only 14 lines of magic btw.
I prefer my solution, [Spyral](https://github.com/platipy/spyral)
How compatible is it with the Anaconda distribution? I teach non-majors how to use python to create visualizations - including map plots. This would be amazing to allow them to show off their work, but I worry how difficult it would be to get installed and running.
Python 3, what a marvellous success! More than 6 years on and 70% of users are still writing more 2.7 code than 3.x even according to this (probably Python 3 skewed) survey. I'm saying skewed because the survey was advertised here on reddit where the audience is mostly Python 3 oriented (I guess because there are many beginners hanging around here and they are more likely to use Python 3). In the real world it's another story (python 2.7 still rules). 
There's a lot in the description about what it does but nothing about how it's useful. So... how is it useful? What does this get me that giving functions different names doesn't?
Thanks, I'll try that format. Last week I tried that with this format in an .srt file: http://en.wikipedia.org/wiki/SubRip#With_specific_DVD_rectangle_positioning_and_styling but every player I tried it on ignored the position, or ignores all subtitles. VLC just scrolled thousands of Xs vertically.
In that case, this seems quite useful
I thought pygame was dead, yes? As in, the last release was in August 2009? Also: - Globals everywhere! - Unconditional `eval` of network data! - Only python 2! - Beautiful javadoc style documentation! I was really excited when I read the headline, because I was hoping this library would get me away from the tyranny of pygame and its dark masters SDL and software rendering. At this point there's still no reason to switch away from the wonderful [SFML](http://www.sfml-dev.org/) and its only-slightly-less-wonderful [python](http://www.python-sfml.org/) (2 *or* 3) bindings.
+1 for SFML. I slogged through SDL for just way to long before I discovered the beauty and simplicity of SFML. To this day I hold it as one of the few extraordinary examples of good, simple, OO design.
Django is a web framework, Jinja2 is a template engine. They aren't really comparable. If you are interested in the differences between the Django template engine and Jinja2, I would recommend [this talk](https://www.youtube.com/watch?x-yt-cl=85114404&amp;x-yt-ts=1422579428&amp;v=rHmljD-oZrY) by Armin Ronacher, the author of Jinja2, on the differences between the two.
Nothing like that.I should explained you in detail.actually data is fetched from a pickle file.I created that pickle file by scraping several comic websites.I just loading them in my website.It is the thing there.Here is the link.Now you can explore. https://github.com/narenaryan/comicsense 
Damn, for a second I thought ASS was actually a file format name
It's an `OrderedDict`: https://github.com/dnaeon/py-vconnector/blob/master/src/vconnector/cache.py#L85 I only needed an in-memory cache, so `OrderedDict` for now, but it should be easy to extend this to support other backends, e.g. Redis, Memcached, etc. 
thread safety?
VLC should do fine with .ass subs. [Here](http://docs.aegisub.org/3.2/ASS_Tags/) is a bunch of tags you can use with ASS. You can use [python-ass](https://github.com/rfw/python-ass) to parse or create .ass files (unfortunately it does not parse the individual tags yet, afaik).
That's awesome! Feel free to message me here or on the PyImageSearch blog if you want to chat about OpenCV.
It's for when you want to expose a single function that does very different things based on the arguments it receives. The overloading style can allow for cleaner code. Compare: class DB: def get(self, *args): if len(args) == 1 and isinstance(args[0], Query): return self.get_by_query(args[0]) elif len(args) == 2: return self.get_by_id(id=args[0], model=args[1]) else: raise TypeError() def get_by_query(self, query): ... def get_by_id(self, id, model): ... The same thing with overloading: class DB: @overloaded def get(self, query: Query): ... @overloads(get) def get(self, id, model): ... 
I would swap steps 3 and 4... better start with a full stack framework unless you **know** what you would like to customize!
If you think about it, single dispatch (dispatch off of only the first type) is exactly what classes give you. Multiple dispatch is useful for situations like operators (`add(x, y)`). The situation in Python is suboptimal because it's so easy to get wrong with when to return `NotImplemented` and dealing with both sides. I've not needed it much, but Julia [uses it well](http://julia.readthedocs.org/en/latest/manual/methods/). &gt; Although it seems a simple concept, multiple dispatch on the types of values is perhaps the single most powerful and central feature of the Julia language. I'm unconvinced it fits the Python type-system well, though.
I've looked for a caching in-memory library before starting with this one, and honestly I didn't like how the existing ones worked or how much dependencies they had, while I really wanted something simple and possibly done by using what we have in the standard library. That's why I ended up writing one myself :) &gt; However this is pretty much the same way other caches work.. every item having it's death time set and you invalidate your cache by changing the key. The invalidation of an object from the cache is not done by changing it's key, it's done by removing that object from the cache, so it can be garbage collected. What I didn't like about the existing caching libs: 1. With some of the caching libs you can only create a fixed-size cache only, while I want to be able to make as large cache as possible 2. Most (if not all) of the other caching libs try to invalidate objects on every access to the cache - that is every time you read and write to the cache they search for expired objects, which might not be what you want, especially if you have a pretty large cache. 3. And probably there are other reasons why I didn't like the existing ones :) How I did this in my case: 1. The cache inventory can be both - a fixed-size inventory or of size your memory allows it to be. 2. An item is check for expiration only if you check the cache for item membership (e.g. `'myitem' in cache`), or when you get the item from cache (e.g. `cache.get('myitem')`). In order to avoid checking for expired items on every access to the cache a housekeeper thread runs in the background on certain periods and removes expired items. Overall, it's a caching module like other ones and it does caching. The way it's implemented though is different than the ones I've seen so far :) 
I had this exact idea a little while ago- https://github.com/Lucretiel/Dispatch It's a useful idea, but in my experience it just kills python's already unfortunately poor function calling performance. Looks like you have a much more clever matching algorithm than my "try them one by one until there's a match" system.
This is just what I needed for one of my projects. I will give it a try.
This sounds very reasonable, thanks!
[It's not hard to do.](https://github.com/gelstudios/gitfiti) Other than that, he doesn't have much in the way of public contributions at all...
you wanna start recording direct on a file?
There's a similar project here: https://github.com/mrocklin/multipledispatch (Author: I don't want to dissuade you - this is an interesting idea and I'm glad multiple people are exploring it)
Eclipse can be a bitch at times but then again if you compare it to EMACS, VIM and the like it is wonderful! I do like Eclipse for the free aspect as it fits in with the limited development I do. 
This library looks awesome!
I love the idea of a 35 hour Work week. There is far too much time squandered in a 40+ hour work week. 
Thank you; this helped a lot!
Thanks for the recommendation; I may try this in the future.
The world is far too complex to learn every detail! Would you suggest to someone who would like to build a gui application, that he should start writing his own? Go down to opengl or something else and start pixeling? Then implement an event system? And so on... Why one should do that at the Web application side? Don't get me wrong, flask is an excellent framework, but you can only appreciate the freedom of chosing supplement frameworks as an orm for example once you got a good understanding of the sense of those components. So imho it is easier to learn the basics in a "closed" and cohesive environment before you go out into the wild!
yep and now I am going to work on the next PythonFOSDEM 2016.
You say that as of business people would realize the impact they have on a developer's week! This may be a little cynical, but I'd expect more meetings from my work so I could fill in the other person filling the extra time (needed or not, it would likely be scheduled)...
I may be because I am still a student but I enjoy working, at least on group projects where I can get a lot of help (more efficient) and talk about fun stuff.
Np, if you would like me to ask the author of the post to add another book just ask.
This is awesome. Thanks.
I don't think the overlay per se is the problem - the issue here is synchronising the files. The data from the tracking file will match specific frames from the original, so you need to cross reference the two files to ensure that you have the right timing. Which is why someone else has recommended subtitle files - they have a similar requirement for synching.
&gt; You can write like a PHP non-programmer in any language. Also, FWIW, I'm not talking about *coding* like a PHP "programmer", but the *language itself* ascending to PHP-like levels of questionable behaviour.
Can you add the ebook of Two Scoops Django 1.6? Not 1.5. The 1.6 version.
This is great news for my profiling library [pyinstrument](http://github.com/joerick/pyinstrument), because it uses signals to sample the stack. Hooray! Thanks maintainers!
There are already created official docker images for all major python versions: * https://registry.hub.docker.com/_/python/ There are also very usefull 'onbuild' versions.
It's funny, when I Googled "EINTR" to figure out what this was about, the blog post that came up was about how Python deals with EINTR, and that ZeroMQ had to handle the retry instead of Python doing it. http://250bpm.com/blog:12
Could you ask the author to add Programming Python by Mark Lutz, please? 
It would be ready in 10 mins from what I understand. 
As a French guy who mainly works minimum wage jobs, the 35 hour week is a blessing. No one wants to work at macdonald's but at least you have some time to enjoy life on the side, even without much money. Now I'm starting to do MOOCs online, and I'm not sure I'd have the motivation if I worked say 45 hours a week, and the only thing you want to do after work is go home and relax.
This looks interesting! Is there a renderer for opengl ? I've been looking for something to create and render geometry in realtime..
Oh. Naive me thought he actually did this by himself.
Here's a list of mostly the same books, filterable by subject and free/paid, with a nice UI: http://inventwithpython.com/bookshelf/
Seems completely reasonable and logical to me.
&gt; A multi-threaded or multi-process based server cannot scale appropriately for WebSockets because it is designed to open a connection, handle a request as quickly as possible and then close the connection. This is not exactly correct. WebSocket uses HTTP to bootstrap its connection. Once the handshake is performed, simply don't let the HTTP server close the connection for you. Simply detach it. This is what [ws4py](https://github.com/Lawouach/WebSocket-for-Python) does and it works very well. Talking about it, not mentioning ws4py or [crossbar.io](http://crossbar.io/) is shortsighted.
I'd love to know more about using Websockets with python on the client side - there's a website that I would like to use automatically, which uses websockets. Does anyone have any resources for client side usage of websockets with python? 
I'll just add that Inno Installer is another alternative for building an installer after you've frozen your program and are prepared to deploy it.
Yep, but those images are independent. I mean we have one image per python interpreter, so we need to run tests separately in different containers. It could be a bit painful, since the commands aren't easy to type and you obviously need a helper script. But yes, it definitely could be used too. 
To me it's funny that it should be a rather default strategy and I expected to be implemented long ago. In fact, I discovered this was not true on my own.
PyOtherSide has no knowledge about widgets. All communication between QML and Python is done in JSON (essentially). Hence, embedding Matplotlib is not possible. However, there are plotting plugins for QML that work well enough. Complex custom widgets are definitely possible though, and can use Python as their models. Delegates have to be coded in QML, but can use Python data. In general, QML is a joy to work with, and building custom widget is incredibly simple. I really can't recommend it enough! 
Just use a library such as [ws4py](https://ws4py.readthedocs.org/en/latest/sources/clienttutorial/) or [tornado](http://www.tornadoweb.org/en/stable/websocket.html).
You learned a couple of important point about market. 1. supply and demand. Python recently exploded, and it's exploding even more. But it's too late now. You can't get on the bandwagon when the wagon has already left. Find new green fields. Which ones? GPU programming, parallelism, stuff like this. They are leaving... right now. 2. You don't find projects. Projects find you. You just have to put yourself in an environment where projects do need someone. This is why people go to university (unless it's a useless one). To get into an environment where skills are needed because projects are needed to be completed and nobody knows everything. Of course this opens a completely different can of worms. &gt; I'd love to be able to do a project without googling much at all on how to do what the project lead wants me to do. Googling is a fundamental part of your job. Google is an extension of your brain. Nobody gives a damn if you google, also because you still have to know what to google for and what are the drawbacks of the stuff you find. That takes the skill. I am 10 years in the trade and I use google at least 15 times a day. I don't remember the details of the interface of unittest. I just google it. I just know that unittest exists and has that member that I need for what I need to do. 
In the face of competition from cheap and easily available labor, distinguish yourself. They may know a lot and code fast, but do they code well? Practice writing code that is: - readable - follows the [style guide](https://www.python.org/dev/peps/pep-0008/) - is idiomatic - has a [logical and thought out structure](http://www.amazon.com/Code-Complete-Practical-Handbook-Construction/dp/0735619670) - doesn't [smell](http://en.wikipedia.org/wiki/Code_smell) - has plenty of helpful comments and no redundant ones - is well sprinkled with docstrings containing the information that those that read them expect to find there - committed often with descriptive commit messages and in logical units - is written [using test-driven development](http://chimera.labs.oreilly.com/books/1234000000754/index.html) - doesn't [reinvent](https://docs.python.org/3.4/py-modindex.html) the [wheel](https://pypi.python.org/pypi) - runnable in both python 2 and python 3 (or at least know how to do so) - is security-oriented Learning to follow all these procedures while coding is difficult and slow going at first, as you'll likely have to fight old habits while forming new habits and making the needed procedures second nature. Use the time you have on your hands now to do so! Clients/employers who have been burned by hiring developers who write unmaintainable code will be inclined look for those who don't the next time, and will know that there is a good reason for the difference in asking price. You should have some examples of your work that will convince them of the difference. At least, that's the theory. Reality may differ. 
[Seems really really simple](https://github.com/jrosebr1/imutils/blob/master/imutils/__init__.py), what else are you planning to add? Appreciate the hard work, cool looking project!
I think they were trying to say that a server that has one-process-per-connection would be a poor choice for websockets - which is true, but I'm surprised if any webserver uses that sort of approach in 2015. The `select()` call has existed for decades, for example.
Lol, it's good to know googling is that normal. Perhaps I expect a little much of myself :p I'm also curious about this gpu programming you mentioned. A quick google and I'm intrigued by CUDA, is this what you mean?
So essentially webscraping for sockets?
Just a guess - do you work with Srini?
See so https://github.com/vhf/free-programming-books/blob/master/free-programming-books.md#python !!!
I don't think servers run one-connection per process anymore indeed. As for multithreaded servers, they are still doing well.
Here is what the linked meme says in case it is blocked at your school/work or is unavailable for any reason: #***Fuck Me, Right?*** &gt;***Post Title:*** *I need it to use django* &gt;***Top:*** *TRYING TO INSTALL PILLOW* &gt;***Bottom:*** *ON WINDOWS* [Original Link^1](http://imgur.com/WCTJvVT) | [Meme Template^2](http://imgur.com/memegen/create/WCTJvVT)
cuda is one technique, but not the only one. There's also openCL and GLSL. GLSL are focused on graphics exclusively, and openCL is a "portable CUDA" (CUDA is Nvidia only). CUDA is good, but the big problem is not to run a cuda calculation. That is trivial. The problem is to take advantage of every nook of optimization you can get, normally by maximizing bandwidth and pipeline occupation. It's way more complex than you think. One thing is that you should focus on techniques that are - hard to achieve (so you weed out the low end of the competition) - are transferable (e.g. if you learn this or that framework, as soon as the fashion is over, you are out of the game) 
&gt; The invalidation of an object from the cache is not done by changing it's key, it's done by removing that object from the cache, so it can be garbage collected. I am not sure we talk about the same thing here. As a "user" of the cache ill once set the gc times and then only use it. If somewhere i need to ensure my data is not cached, ill simply change they key, so the existing cache record cannot be found with it. Also at that point i dont care anymore when and how it will be removed from the cache. The other points regarding performance you made are good. I might just give this cache a try in one of my next django projects. I am honestly curious how it will hold up. Thanks for sharing, Cheers!
Move along, nothing to see here, Pillow already has wheels ...
Installing pillow on Windows is the [easiest thing](https://pypi.python.org/pypi/Pillow/2.2.1#downloads). There are other modules which are really hard to install on Windows.
you probably want to use a hough transform - built into opencv. 
One thread per connection?
Totally agree on your points here. I'll do some more digging on Socket.IO. I haven't kept up to date on that library specifically due to that flask-socketio bug with the 1.X release. Thanks for the feedback! 
Multi-threading it not going to help you at all, because the API has been designed in a way that requires serial access. Unless you can convince the API designers to produce something different, there isn't any logical way around this. They might not be willing to do that, because the whole point of forcing pagination is to limit the amount of server resources you can take up.
Yes. But in the case of ws4py, the socket is detached from the thread as soon as the websocket handshake has been performed. 
I'm mostly interested in why a server would go that route for HTTP connections in general. It doesn't seem scalable beyond maybe a 2-digit number of concurrent clients.
Don't know about faster or more memory efficient but it is more Pythonic (I think): def cherche_mot_taille_N_essai(chaine_adn, n): ''' :param chaine_adn: a string ranging from 10**6 to 10**8 char and containing the letters A,T,C,G :param n: the size of the words to find in chaine_adn :return a list of tuples of found words and number of occurences ''' connu = {} for i in xrange(0, len(chaine_adn) - n + 1): motif = chaine_adn[i: i + n] try: connu[motif] += 1 except KeyError: connu[motif] = 1 return connu.items() 
Even with extra time for meetings, I'd still get the same amount of work done. I'd bet most hardworking people can finish their work in 2 hours. The rest of the day is usually fluff.
This is awesome, thanks for sharing!
you could use a collections.Counter instead of a normal dict connu = Counter() for i in xrange(0, len(chaine_adn) - n + 1): connu[chaine_adn[i: i + n]] += 1 return connu.items()
Yes exactly, it return a list of tuple like: [('ATC',1),('TCG',1),('CGA',1),('GAG',2), ('AGA',2),('GAT',1),('ATA',1),('TAC',1)] 
Yes, try /r/learnpython or /r/learnprograming, check out requests and pillow to download images and pygame to display them.
first i have a simply suggestion, you don't need to declare motif before the cycle. calculate the length of a string of million characters and iterate over a generator (xrange) or a list (range), it's a waste of time. is more convenient to navigate through it until we have a "IndexError: string index out of range" i = 0 while 1: try: motif = chaine_adn[i:i+n] if motif in connu: connu[motif] += 1 else: connu[motif] = 1 i+=1 except IndexError: break another idea would be to harness the power of multi-threaded processors or video cards with thousands of CUDA cores. dividing the long string into many smaller ones, and launch the program in parallel on all. atcgcgtatcatcgatctatctaaggGAtatcgtacgtacgtattctgactgATgtgcacgatattacggctatctagACttagcgtatcatcgatctatctaagg atcgcgtatcatcgatctatctaaggGA - GAtatcgtacgtacgtattctgactgAT - ATgtgcacgatattacggctatctagAC - ACttagcgtatcatcgatctatctaagg
Yeah I realised my mistake and posted this over on /r/learnpython when this post got downvoted! Thanks a lot.
Your Pi is playing craps.
And Eggs and Exes
Is there a local python user group in your area? You should check that out and attend the meetings/present on topics of interest. Networking is key - whether it is online or in person. Once you start to know some others in your area with python experience, they may be able to point you to places where you can get some more experience. Good luck
&gt; Not really, since pretty much everything that isn't web traffic is coping just fine with a select-based method (or poll, or whatever) I assume they perform only very short operations. If not, they will stack if you have a single process with select (or else). That's what I meant. &gt; you multiplex between them, sending a bit at a time to whichever connection is ready. Funnily enough, this scales very well in may use-cases. Simply not on very high load.
Yes there is... you'll see how rendering is performed in the [examples](https://github.com/tpaviot/pythonocc-core/tree/master/examples), for instance loading a [STEP](https://github.com/tpaviot/pythonocc-core/blob/master/examples/core_load_step_ap203.py) file would be a good start. display.DisplayShape( your_geometry_here ) renders geometry in the OpenGL viewer
I do not like black boxes, particularly for such simple problems. For example, i can not tell you how OpenCV generates and picks features. I also can not tell you which interpolation method OpenCV uses. Yeah, i could look this up, but i already have code that works like i want it to.
in the past we did not exactly follow best practices... Thomas Paviot, lead author of pythonocc has done a *ton* of work over the past half year, to weed out non-tested code, py3k support, continuous integration for pythonocc, and a strong focus on general code quality, for instance, including proper doc strings. a novel thing is that we're building pythonocc for [conda](https://binstar.org/jf/pythonocc-core/) so running "conda install -c https://conda.binstar.org/jf pythonocc-core" would get you a full install in under 5 min. This is osx for now, and we look forward to support the conda binaries on linux and windows too on the upcoming release ( 0.17 ). i've been involved in pythonocc for a while now and develop pythonocc based software for [industrial robotics](https://vimeo.com/94076571). 
Do users show in any way their interest on other users? Like for instance viewing their profile or becoming friends? If so, I think you will find collaborative filtering and recommendation algorithms are just what you need.
not a single comment? is the book any good?
Yeah, we used "Dive into Python" to learn how to convert the numerals to decimals and vice-versa, and it was most helpful, a very good learning tool :) 
As a, how should I describe myself, casual newbie user of Python, it's getting a bit annoying when you find some cool library, and then it's stuck supporting a version of Python from the stone age. Then I look for stuff, find a comment, then another comment mentions that they don't have Python 3 support yet, I check the project website anyways and they've just added support a month ago. At least people are moving over, but old code never being updated worries me. Then again, if it's not being updated, it's not being maintained, so maybe it's best I don't use it. 
Hi guys, I'm not the author of the library, just wanted to share it.
The GIL is a big problem in python, you can get around it with a little 'hard work or change interpreter. but simply you can use the GPU, easy to implement and much faster than CPU
I get that. But, you will introduce some latency the more your loop waits for the current handler being executed. If you have a websocket running only on a event-driven loop in a single process, if any of your handler/callback starts taking a long time, your entire process will be waiting for it. Your clients will therefore experiment greater latency than in a multithread server. If your callbacks/handlers are short, then, indeed an event-based app will probably be less resource intensive.
Also, check out the "numpy" library. It should contain all the functions you need for randomly generating numbers. 
No. There's no need to use an external lib for that, especially for a class project. The standard library contains anything that is needed.
 w = Work([ 1, 2, 3 ]) @w.job def addOne(w): return w + 1 I'm confused by this. Isn't `w` bound at runtime, yet the decorator decorates the callable at compile-time?
thanks for bringing this to my attention - should be fixed now.
In python, runtime IS compile time. When you type `import module`, each line in module is executed in the same namespace. So, when w is instantiated, and it is used to decorate methods later in the code, those methods are used to populate w. The code is like this so that it reads in the same order as traditional, imperative programming. 
Read that tutorial again - you're misunderstanding what it's going for when it discusses asynchronicity. It doesn't matter what web framework you use, since the web framework has nothing to do with what you're attempting to do. You'll need to look into something like [Celery](http://www.celeryproject.org/). With that, you define code to run as 'tasks,' with a group of workers that handle those tasks. Then, when certain URLs are accessed, you'll queue up tasks to run. That way the webserver can return without having to have the task completed.
"If you run this script [...] you should see START, MIDDLE, and END show up **one by one** (rather than waiting 8 seconds to see them all at once)" yes i did misread. thanks. and thanks for Celery link, checking it out.
This only matters when the number of connections is equal to or fewer than the number of processors - beyond that, clients are going to be waiting for CPU time anyway. Your main cost starts to become context-switching overhead, so if you can switch between connections without switching between threads, it's cheaper (which is why Nginx does that sort of thing). I'm not saying you'd only ever use 1 thread, just that 1 thread per connection is not optimal.
I use pandas almost everyday in my work. It takes care of a lot of things we would otherwise use a db for, with some fancy stuff on top. It provides a (easy?) way to work with tabular data, apply transformations and interact with your python ecosystem and objects nicely. It's definitely oriented toward data scientists who need to manipulate tabular data efficiently in terms of memory and cpu usage. It keeps numpy's weird overloading of operators and syntax and adds a ton more stuff which can make the learning curve very steep, even if you already know numpy arrays relatively well. 
Yaosf opens the config file and reads the value every time you call getVar() which seems like a bit overkill. I'm having a hard time imagining when I would need such a simple config that would actually warrant being abstracted out into a config file.
Is there a github for this project? I'm trying out examples and getting a ton of errors - especially exceeding recursion depth.
I just use **kwargs for the same thing... but this is cool if you're used to C++ or Java style overloading.
I haven't spent time with Pandas yet but I get the impression from what I read that Pandas is trying to replace Excel for light data exploration tasks. You know, stuff like making a quick graph, or visually inspecting some data. 
Interesting, like a Celery task singleton. Is the lock released when the task completes?
https://github.com/ContinuumIO/into/
So if you use this with a celerybeat scheduler and the worker crashes, will this cause the scheduler to also crash? Can I use this to prevent parallel execution of duplicate scheduled tasks?
[Please don't commit `*.pyc` files to Git...](https://github.com/EricSchles/contexts/blob/master/slavery_website/__init__.pyc) &gt; Reuse code as often as possible You could use an ORM or other database extension to get rid of [this repeated code sprinkled everywhere](https://github.com/EricSchles/contexts/blob/1dcd6dd3fa1e551fd0be270db5e78091abab2376/slavery_website/cms/models.py#L4-L5). Alternateively, use [this example from the official flask docs](http://flask.pocoo.org/docs/0.10/patterns/sqlite3/#using-sqlite-3-with-flask).
I'm not super competent with numpy/scipy, but does it have split-apply-combine functionality like Pandas does? http://pandas.pydata.org/pandas-docs/stable/groupby.html
You're both spot on. Steps 1 and 2 can be done on parallel - learn Python basics and HTML/CSS/web fundamentals at the same time, as two separate subjects. Then do a bit of REST, scraping, maybe some JavaScript before going for Flask and then Django (if you don't love Flask ;) ). It doesn't have to be a year long intro btw... Just get the fundamentals of each before moving on. Then maybe sit on Flask a while.
Ah I think I know who you're referring to! He used to work with my supervisors at ANU before I started there, but he's now based at the QBI in QLD :)
One of my first troubleshooting steps is to remove spaces from the file names just in case that's an issue... also try the simplest thing first - place the files directly on the path before messing with the assets folder. Sorry if this isn't very helpful.
Congratulations! I'm personally waiting on Python 3.4 with asyncio compatibility but you guys are doing some amazing stuff. Keep up the good work!
How convenient, I've been trying to make time to implement something like this for one of my projects. Will definitely give this a go tomorrow. Thanks for sharing!
I guess when they get to Python 3.3 you should be able to install asyncio as a module as well :D https://pypi.python.org/pypi/asyncio/
You can checkout my version of Mine Sweeper: https://bitbucket.org/lmondy/steve-sweeper/overview It might be a bit odd, but it seems to work well enough. Essentially makes a board object, which contains tile objects. The tiles can be bombs or not, and store the images to display as needed. It definitely has its problems, but it might give a guiding direction. Any code reviews would be appreciated! edit: woops, I forgot - mine was with PyGame.
It can be pretty simple (sorry, I'm on my phone): def foo(s): idx = sorted(s) return ''.join(str(idx.index(c) + 1) for c in s) It should go without saying that you shouldn't submit this for your assignment. It's a basic solution for the specific example given, but it probably uses things you aren't supposed to know about yet. Study and dissect it, then use it to craft your own answer. I'm still trying to think of a sane way to do this with nested loops, but it makes my head hurt this far past my bed time... Will return in the morning if I get inspired to share my thoughts (in words rather than code) :)
you use pypy like this:: pypy &lt;your program&gt; instead of:: python &lt;your program&gt; no modifications necessary. As for compression - it should be a lot cheaper, depending on how long your substrings are. If your substrings are say 3 characters, probably not too worrying, if they're like 20 or 100 or longer than compression should be faster. Again, check before judging. Also this sort of simple numeric stuff will be A LOT faster under pypy, so just check (the pure dict stuff might or might not be, I'm not sure)
Thanks, I'll check it out later today :)
I've come to believe explicit function signatures are good. Of course, structured docstrings can substitute for them to a degree. But add to this the ability to get rid of mundane argument validation and error throwing in the function body, and I was eventually led down this path... 
Do you have any code at all to show? Like codekoala said, I'm guessing these have some more advanced features than your class would accept. I'm guessing the nested loop would come from doing something like this instead of using index() import string [i for i,char in enumerate(string.uppercase) if char == 'D'] # returns [3] enumerate() is something that's useful and forgotten about by many. It accepts a list (or iterator) and returns one item at a time with an index. It's a much more elegant approach than something you'd do in another language like: import string for i in range(len(string.uppercase)): char = string.uppercase[i] if char == 'D': print i string.uppercase, string.printable, and the like are also useful and commonly overlooked.
Maybe some examples would make this question easier to answer?
Argh, I've been a bit of an idiot. Everything was fine; I just needed to copy the assets folder into the directory where main.exe was. 
My main interest is data science and statistics, so for example [Naive Bayes](http://scikit-learn.org/stable/modules/naive_bayes.html). It's all about data manipulation, and it can be implemented by numpy and scipy. But I sometimes fail to conceive what such equations would do in python.
there's libraries for basically all high level maths, you should be a lot more specific
You can already use [trollius](https://pypi.python.org/pypi/trollius), althoough without `yield from` it isn't as nice.
I can't open that url. Is it dead? 
Quora I don't know but Overflow and Reddit are quite a different context in my eyes. Overflow is for explicit coding questions. "Here is problem X. Solution Y doesn't work. Help me find something better." Reddit is more for information sharing, small talk, keeping up with what the community is doing.
Thank you. I didn't know the "init_printing()" for sympy. It's one of the two thing I wanted to have in this post, although if there is Latex to python code it would be more helpful.
Try http://williamg.me/recycle/ (slash at the end), the original URL didn't work for me either (on mobile).
Thank you.
That's pretty much what I've been doing, I shifted my day a Lilly's earlier, get a lot done first thing and then expected the rest of the day to be available for other stuff.
Yeah, it's a pretty cool tutorial!
mechanize is basically unmaintained and doesn't support Python 3. mechanize and requests do different things: one is a high-level web tool (parses HTML for you, lets you fill in forms easily), the other is a low-level HTTP tool (handles SSL, cookies, form submission -- but won't parse HTML for you). Screen-scraping images from the front page is simple enough that you can do that with requests and ElementTree/lxml/BeautifulSoup, no need for mechanize.
StackOverflow: What to do ... Quora: Why do that ... Reddit: This has been done. Oh, and some gonewild links! ... 
Nice idea! You should fix the spelling error in "glorfied" to "glorified" 
It shouldn't cause the worker or scheduler crashing to affect one another. You can use it prevent execution of duplicated scheduled tasks. 
Cool, thanks. I could definitely use this. Like doing credit card auths.
You can still use any broker or results backend you want with celery. The redis instance can be entirely separated (or you could multiple purpose it to be our broker + result backend + celery once lock store). 
The most popular computer algebra system (CAS) for Python is indeed sympy. It is possible to convert standard python expressions to sympy via [sympify](http://docs.sympy.org/dev/modules/core.html). It is also possible to get pretty math output with a LaTeX representation in IPython (both in Notebook and in QtConsole via the sympy printing system). However AFAIK there is no way to do the reverse, i.e. transform a LaTeX formula into a sympy representation. Granted, LaTeX is not trivial to parse, however I think such a parser would quite a useful thing to have. If somebody knows of such a library I would highly appreciate a link. 
I'm not sure why you would create a Python script that calls all bash commands. Wouldn't it make more sense to do everything in bash or everything in Python? Have a look at the `shutil` module to copy and remove directories. Doing it with Python modules has the benefit of catching exceptions when something goes wrong instead of doing checks. Edit: also, Python is not Javascript. Concatenating strings is best done through string formatting either with the module operator or `str.format()` method. Much easier to avoid the interrupted string and quoting hell. "Creating new template '" + name + "' from " + files # Current "Creating new template '{}' from {}".format(name, files) # String formatting 
I just realized this isn't the same thing as pypi. I'm an idiot.
Hey thanks for the advice! I did it in python mainly because I'm not too familiar with bash scripting, but I didn't know python had such functionality. I'll definitely look into making it more Pythonic! 
Sorry, I don't have the time to answer your question properly...but try having a look here: http://nbviewer.ipython.org/github/rasbt/python_reference/blob/master/tutorials/scope_resolution_legb_rule.ipynb
Thanks for your reply. Quite helpful and clears up some other lingering questions I've had as well. I have a follow-up question though: Let's say I have a for-loop and within the loop an array is created/declared for a specific length. Now let's further say that the size of the array changes every loop cycle. Is it best just to redeclare the array with the new size?
Cheers for the link. I'll give it a read, looks like it will explain more fully some of python's variable use structure. I started python at a run and haven't had time to look at the language structure/formalism.
I'm a bit new to advice so forgive me if this is confusing. Start by identifying each step that you need to do. For example 1. Ask for an items price 2. Add the items price to your subtotal (like a stored variable) 3. Repeat 1-2 for five items 4. Be able to stop repeating (maybe you prompt the user each time if they have more items) 5. Add the tax to the subtotal 6. Return this total value. Once you have it broken down like this imagine how you would accomplish each task using Python, and use some Google. Quick tips are for #2 you can use something like subtotal += itemPrice Which is shorthand for subtotal = subtotal + itemPrice Also for step 3 you might want to use a loop, maybe a for loop
Thanks for the great response! Yeah when i tried Counter i did find it is effectively slower than a Dictionnary. I knew about python -m cProfile file.py I didn't about doing the profiling inside a python script :) 
Thanks for the explanation, i'm going to try it as soon as possible. :) 
I've never written code for open source before, so please go easy on me.
Thanks, I'm interested in ways to test GUI code. Is it easy to use the GUI automation part in regular tests without the BDD pseudo natural language stuff?
As a lazy bastard, I would like to formally thank you for that synopsis.
Have you looked at pymc?
It mostly looks fairly good. A couple of thoughts about how it works: - In each loop, you get the directory contents twice (before and after). If a file is added or removed between the 'after' listing of one loop and the 'before' listing of the next, then the monitor won't call the callbacks for it - that change will be completely missed. The longer the callbacks take, the more likely this is. To get round this, only call listdir() once per loop, and reuse the after set from one loop as the before set for the next. - Nothing else can run while the monitor is running, except for its callbacks. That has its uses, but it limits what you can do with it. You might want to read about event loops and think about how this could be integrated with other code going on at the same time. - Minor point, but I'm intrigued why you've called the parameters `path_i, interval_i`? What is the `_i` suffix for? Finally, I'll point out that if you actually need a tool to do this, you don't need to reinvent the wheel - see e.g. the [watchdog](https://pypi.python.org/pypi/watchdog) package. Don't let that put you off, though - doing a project like this is valuable experience.
Do you have a ~/.bashrc where it is defined maybe? What happens why you type: alias Is your alias really defined ? 
Neat project. I was going to suggest you checkout [pyinotify](https://github.com/seb-m/pyinotify). It's a wrapper around the linux inotify utility. Won't work on Windows, but very useful if you only need linux systems. It looks like the watchdog PyPI page had other packages that do similar stuff. If for nothing else, maybe those packages could give you ideas for features. And if you're going to be programming you need to learn how to understand documentation.
This worked! Sorry I didn't get a chance to test it until now. Thanks for your help!
Thanks for the suggestion. Sadly, this library is the fruit of a project meant originally for a Windows system.
Well the discrepancy here is that cpython ordereddicts are hugely wasteful. We'd need slim and easy cpython ordereddicts for them to be used more often.
I did that and it seems to work now. Thanks!
I don't think that's going to happen for a minor release. Maybe for Python 4 (which I don't think is even in the horizon).
What you want to know about is the "scope" of variables. There is at least one thread about the at [stackoverflow](http://stackoverflow.com/questions/291978/short-description-of-python-scoping-rules). Also: have a look at /r/learnpython
Hey! /u/broketheweb messaged me but hasn't replied yet. Maybe you could send them a PM if you want? Or if you're ready to start now I could get them to PM you? I wouldn't know what to suggest as daily time commitment, as much as you feel like really!
I happen to be a big foodie and also happen to live in the food capital of the United States, New York City. I was a little overwhelmed initially looking at a list of 400 NYC Restaurant Week participants. I wanted to pare them down by average review rating. That's exactly what this script aims to do. It will pull all of the restaurant week participants from online and then try to look up their average Yelp review rating. It outputs the results to a CSV. This script highlights Python's utility as a general scripting language. One can quickly and seamlessly mesh together several libraries to accomplish complex tasks. This is what makes python special to me.
I've mainly used mayavi, but if VTK doesn't do what you want then probably mayavi doesn't either (though it does have some scientific stuff on top of VTK). If you haven't seen it, you might also be interested in Vispy. It's under active development, particularly the higher level components, but it has a very nice, powerful opengl API. I guess the vispy developers probably intend to support what you're after, but I don't know if it's available right now - though it might be a good backend if you have to implement some things yourself (or even contribute them).
Their problem to deal with? Sure. Their problem to discover? Absolutely not. Few things in my life are more infuriating than code that shits itself silently. Throw exceptions plz k thx. 
Yes as I said its a web server only. With Twisted they have in built protocols for nearly any networking service you could want. I've used it in the past to build mail severs and sftp servers. That is way beyond Tornado can do. If you, just need a web server, you would probably find that Tornado is slightly faster. I didn't mention it in the last post but gevent would be worth having a look at as well. 
The fucked up thing is "OrderedDict(key1=value1, key2=value2)" is unordered. you have to do "OrderedDict(('key1',value1),('key2',value2))" to get ordering which is ugly as sin.
It's not working because `include_files` isn't supposed to be an option to `setup`. It's much more cumbersome than that: `include_files` is supposed to be an option to `build_exe`, which is an option to `options`, which is an option to `setup`. So it should look something like: setup( ... options={'build_exe': {'include_files': ['assets/double arrow h.png', 'assets/double arrow v.png', 'assets/jamie\'s cross.png', 'assets/jamie\'s tick.png']}} )
You can do that, but build scripts should be as automated as possible; you don't want to forget a key step at the end. Doing `setup(..., options={'build_exe': {'include_files': [...]}})` should work
Bottle is the simplest solution but is syncronous. Crossbar.io is the most performant but will ask you to learn a little more since it's all async. But it works really, really well on Rasbpi.
Vispy: http://vispy.org/
And I use normal dicts *far* more than I use ordered ones
https://www.python.org/dev/peps/pep-0468/ Unfortunately it didn't get into Python 3.5 :( It's still a draft.
It would be nice if OrderedDict became the default dict in Python, with UnorderedDict available when speed is a major concern. I more often care about ordering than performance with my dicts.
It seems like mayavi might match well. I was playing with it a bit since you suggested it, and it seems more accessible for me to use and the example gallery looks great. Opacity settings on mesh surfaces [look wonky](http://i.imgur.com/HDd1y4b.png), but I'll try to figure it out. # Create the data. from numpy import pi, sin, cos, mgrid divs = 30 dphi, dtheta = pi/divs, pi/divs [phi,theta] = mgrid[0:pi/6+dphi*1.5:dphi,0:2*pi+dtheta+1.5:dtheta] m0 = 4; m1 = 3; m2 = 2; m3 = 3; m4 = 6; m5 = 2; m6 = 6; m7 = 4; r = 100 x = r*sin(phi)*cos(theta) y = r*cos(phi) z = r*sin(phi)*sin(theta) from mayavi import mlab s = mlab.mesh(x, y, z,opacity=0.3) mlab.show()
Python 4 is the planned release after 3.9, not another huge backwards breaking change. Guido has stated that he doesn't like major.minor.patch versioning where you end up with things like 3.12.10. So after 3.9 comes 4.0
People on reddit will happily answer your questions and clarify things for you but no one is going to do your work for you.
Is he actually retarded? 
I didn't know that, but I meant the next backward-compatibility breaking release, if another one is ever made.
He's overseen one of the most successful languages in the world. He must be doing something right.
Before trying to translate it, try to understand what it does and write some tests for it; you'll have a much easier time rewriting it.
uhhh... Wrong python but does remind me of the bash.org quote http://bash.org/?400459
Why ask for feedback, to debate it?
Let me guess: you wrote a python script that automatically posts news articles to the wrong sub?
Try updating. My windows testing bots were down and I failed to check in with them. Many tiny debilitating bugs crept in. These have since been squished.
Do I really come off sounding like that? That's not what I meant at all... I think /u/matuba was mistaken by what I meant, and I just tried to clear it up.
&gt; There are 5 categories of encodings that UniversalDetector handles: &gt; ... &gt; 5. windows-1252, which is used primarily on Microsoft Windows by middle managers who don’t know a character encoding from a hole in the ground. ...and 90% of everyone else =_=
No problem! I've been python-ing for years now and I still do that stuff all the time. 
One thought, when I am moving a very large file to the directory being monitored, even though copying is not complete, code triggers the on_added callback. One way to get around this is to check after a second if file size has changed. Could anyone suggest a more efficient way?
Cheroot has received very little activity over the past year, and has stayed in "beta" for the entire as well. I had to ask maintainers to upload a usable release to PyPI a while back, to make installing through pip without hassle easier. You need to work on it and release something stable if you want to seriously tell people to use it in production.
In my linux based system, it increases slowly if I am copying or moving the file. If I am creating and writing the file using a C program, it starts with 0 bytes when it is created, then suddenly becomes the size it is supposed to take (few KBs).
You could expect `**kwargs` is an OrderedDict. Clearly, if you already know `**kwargs` is a dict, then you know it's unordered, so you wouldn't expect it to be ordered.
Vpython 
Scikits-learn has a Naive-Bayes implementation. It's a very good package. Don't reinvent the wheel. http://scikit-learn.org/stable/modules/naive_bayes.html &gt; But I sometimes fail to conceive what such equations would do in python. Don't all equations do math? I don't follow...
This is the exact reason I was looking to build it! Random csv files from all over the place with various encodings / other issues.
Great! Happy to help
&gt; Python 4 is the planned release after 3.9 Source?
Others have answered, so I'll just advise: avoid variable reuse for the same reason you should avoid global-scope variables (where possible): it leads to awkward bugs. Obviously this doesn't apply to informative function argument names (like input_file) or trivial counter variables.
Very nice solution. But I have some concerns coming from my sad being-no-more-a-developer situation. Could you please help me understand better this solution providing me with a real-world scenario (or something similar)? Thanks in advance and... good luck with the book!
In writing real programs I think the serializing example is a real-world scenario. It's very similar to connecting Python classes to Database rows with an ORM. You can use the same thing to build plug-in systems. But I think what you're saying is object serialization is only for developers, and you'd like to know a more user-oriented reason to do this? Is that right? Here's what I came up with on the spot. So let's say you're building some kind of blogging software that allows you to add custom tags in your site's HTML templates. For example, one of those custom tags could be embed the YouTube video with the given ID. Here's a cool video: {% YouTube('1234') %} The goal would be to expand that to HTML: &lt;iframe src="http://youtube.com/..."&gt;&lt;/iframe&gt; If you used the approach from this post, you could have your "custom tag" classes inherit from a common base class. By inheriting, the custom tag class would gain access to the parent class's functionality: all the things you'd need to render some HTML in your blogging template. This would let you hook in the YouTube embed HTML code without much difficulty. class YouTube(CustomTag): def __init__(self, vid): self.vid = vid def render(self): return '&lt;iframe src=...' % self.vid When the blogging system sees the YouTube('1234') call, it could construct your class and then call render() on it to get back the HTML to put in its place. The problem is, how does the blogging system find out about the YouTube class? Usually people do something like this: tag_names = { 'YouTube': YouTube, ... } Which is annoying, error-prone boiler plate. Another way is to have a registration function: register_tag('YouTube', YouTube) That's the approach Django uses (see [this page](https://docs.djangoproject.com/en/1.7/howto/custom-template-tags/#registering-the-tag)). It's also error-prone. However, if the CustomTag base class also had a metaclass, it could manage registration automatically. No boiler plate. No need to explicitly call a registration function. Create CustomTag subclasses and they will be available in your templates as long as they're properly imported.
I prefer decorators for this kind of thing. You get the same benefit of writing it at the top of the class, and it requires less infrastructure - all you do is add a line to `register_class` to return the input.
Metaclasses have a few issues though: * you can only have one, things generally get iffy when you try to compose metaclasses * the "base class" on which you set the metaclass will invoke the metaclass, if you don't expect it things get weird. More annoyingly, the first metaclass call is performed because that base class is even instantiated (in order to instantiate it in the first place) Although class decorators can be forgotten, it's much less likely to forget them than a post-facto call to a registration method. Metaclasses work well in library/frameworky systems where you want an "in-system" base class to start with, but for more cross-cutting concerns decorators are probably a better idea. An other alternative, further into the "magical" land, is an import hook.
Meh. I really don't care what my wsgi server is as long as I have a reverse proxy in front to force SSL, handle static content, and provide caching/load balancing. 
your opinion is bad and you should feel bad! :) i'd rather not risk sacrificing performance for convenience. especially not for a convenience that can be achieved using readily available alternative data structures (collections.OrderedDict)
if you care more about ordering than performance, you can use lists :). the O(1) operations of dicts are what make it worth using. i'm assuming that inserting into an OrderedDict is O(logn). by making that kind of change, you could be hitting older code with massive performance issues.
http://opensource.com/life/14/9/why-python-4-wont-be-python-3 That's from one of the core devs 
http://opensource.com/life/14/9/why-python-4-wont-be-python-3 I can't find where Guido voiced his dislike for major.minor.patch version numbering, but Nick is one of the core devs. 
Do you have access to SSH or SSH via the web? You could set up your own server and access it remotely.
Are nitrous.io or codio.com blocked?
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Inotify**](https://en.wikipedia.org/wiki/Inotify): [](#sfw) --- &gt; &gt;__Inotify__ ([inode](https://en.wikipedia.org/wiki/Inode) notify) is a [Linux kernel](https://en.wikipedia.org/wiki/Linux_kernel) subsystem that acts to extend [filesystems](https://en.wikipedia.org/wiki/Filesystem) to notice changes to the filesystem, and report those changes to applications. It replaces an earlier facility, [dnotify](https://en.wikipedia.org/wiki/Dnotify), which had similar goals. &gt;Inotify was created by John McCutchan, and it was merged into the [Linux kernel mainline](https://en.wikipedia.org/wiki/Linux_kernel_mainline) in kernel version 2.6.13, released on August 29, 2005; later kernel versions included further improvements. The required library interfaces were added into the [GNU C Library](https://en.wikipedia.org/wiki/GNU_C_Library) (glibc) in its version 2.4, released in March 2006, while the support for inotify was completed in glibc version 2.5, released in September 2006. &gt;One major use is in [desktop search](https://en.wikipedia.org/wiki/Desktop_search) utilities like [Beagle](https://en.wikipedia.org/wiki/Beagle_(software\)), where its functionality permits [reindexing](https://en.wikipedia.org/wiki/Index_(search_engine\)) of changed files without scanning the filesystem for changes every few minutes, which would be very inefficient. By being *told* directly by the kernel that a file has changed, indexing utilities can achieve change-to-reindexing times of only about a second. [*[citation needed](https://en.wikipedia.org/wiki/Wikipedia:Citation_needed)*] &gt; --- ^Interesting: [^Dnotify](https://en.wikipedia.org/wiki/Dnotify) ^| [^Robert ^Love](https://en.wikipedia.org/wiki/Robert_Love) ^| [^Gamin](https://en.wikipedia.org/wiki/Gamin) ^| [^FSEvents](https://en.wikipedia.org/wiki/FSEvents) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cobyxma) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cobyxma)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
I was unsatisfied with these existing solutions: - https://github.com/sashka/atomicfile -- No Windows support - https://github.com/abarnert/fatomic -- Windows support, but no features for avoiding overwriting of existing files Couldn't really find anything else, pretty sure many popular tools contain a half-baked version for POSIX.
`pip install pillow` is so hard?
I work half of my time in a secure installation. The basis of security (for top secret projects) is that no information should get in or out of your facility. Ask your supervisor if there is a way to set up a DMZ so you can reference technical information.
&gt; The underlying problem is that UNIX doesn't allow daemonized processes to create sub-processes as it would easily lead to orphaned processes. What nonsense is this? UNIX most certainly allows processes to create processes and doesn't know anything about what's a daemon and what isn't (even the lack of a controlling TTY is a red herring; people put daemons in `/etc/ttys` at one point!) The trick is to create a file descriptor with `pipe(p)`, clear the writer-side `FD_CLOEXEC` flag, and then right before exiting: close(p[1]); while(read(p[0],buf,sizeof(buf))&gt;0);
Have you looked at [lockfile](http://pythonhosted.org/lockfile/)?
Locking files is related, but not quite the same thing. Also this seems to rely more on convention: It *seems to* be useless if there are other programs not respecting your locking mechanism. Kind of like using threadlocks: The code has to *know* about the existence of these locks, and not just access the data without acquiring the lock.
Read the post again: the OP is not allowed to take phones inside the building.
I've been reading about ArangoDB lately and it seems like an interesting, if somewhat schizophrenic, project. For instance, it features a JSON Document Store, a Graph database, query-by-JSON, query-by-proprietary-SQL-like-lang, and --this one really surprised me-- a built-in web server and JavaScript framework. How do people use this in production? Do they use it for the document store, the graph stuff? Does anyone use the javascript framework part?
You could use a Live CD/DVD. However, you might have some issues if they've blocked booting from media (plus they might not be happy with you running a different OS on a work computer) 
Link?
[Documentation](https://cell.readthedocs.org/en/latest/) [Github](https://github.com/celery/cell) It's still in "early" stages of development, though I think it seems mostly stable now.
I disagree completely. PyPy should *not* be the reference implementation of Python. The purpose of CPython is to function as the proving ground for all new developments in the Python language itself. It's a relatively simple implementation that is relatively easy to modify. It's performance is also reasonably predictable. The same can *not* be said of PyPy, which performs really well in many cases, but falls flat on its face in surprising ways (string concatenation in a loop is still astonishingly slow in PyPy).
You can download a portable python (http://portablepython.com/), burn it and copy the python dist in your workstation..
If it's for windows, why not just use the [FindFirstChangeNotification API](https://msdn.microsoft.com/en-us/library/windows/desktop/aa364417%28v=vs.85%29.aspx)? Hell, there's even [a nice article](http://timgolden.me.uk/python/win32_how_do_i/watch_directory_for_changes.html) with source code to boot.
Nice, I will try this in a couple of hours. I'll let you know how I get on!
ok let me rephrase. I am completely new to programming. so i don't know how to write this out..
Not going to happen, unfortunately. Locked down pretty tight here, the process for unrestricted internet is lengthy and wouldn't pass the review process as the systems I work on are well documented and information readily available within the unit.
This is my fall-back option. I have a few books that I can use, should the need arise.
Seems to be working for me. At least, no explicit code errors breaking it. What exactly is not working for you? What is your intention here?
From what I can tell it seems like the issues is with the fact that you are attempting to connect to a virtual comptuer on a remote server. It would be great if there were some web based forms that just did a character by character check to ensure the code was entered correct. let me know if you find something. 
Your code never re-evaluates r2 if you change your radius within the while loop. When you're "restarting" the loop, you need to ignore all code outside that loop. So, if you want to change r2, as well, it needs to be set at the top of the loop, rather than before it: import turtle import math wn = turtle.Screen() wn.bgcolor("lightblue") radius = 5 # Turtle charlie = turtle.Turtle() bri = turtle.Turtle() charlie.shape("circle") bri.shape("circle") area = math.pi * radius ** 2 while True: r2 = int(radius * 2) #output print('This is a program to do collision detection') print('The balls have the same radius of {}.'.format(radius)) # input x1_str = input("Enter the x coordinate of circle 1:") y1_str = input("Enter the y coordinate of circle 1:") x2_str = input("Enter the x coordinate of circle 2:") y2_str = input("Enter the y coordinate of circle 2:") x1 = int(x1_str) y1 = int(y1_str) x2 = int(x2_str) y2 = int(y2_str) # formula d = int(math.sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2))) d print("Distance: ", d) print(r2) charlie.goto(x1,y1) bri.goto(x2,y2) # hit if d &gt; r2: print('no Collision') elif d &lt; r2: print('collision detected') elif d == r2: print('Colision detected') # restart (rough) print("This is the end") #if user enters "q" then quit the program command = input("Enter 'q' to quit ") if command == 'q': break radius = input("Do you want to change your radius(no)? ") if radius == ('no'): radius = 5 A word of caution, though: you will need to error-check this first. If the user enters a string such as "yes" on the last input, the code will attempt to do this: r2 = int('yes' * 2) You should add an else statement that checks for this type of error at the end, before you allow the radius input to go unchecked. Further, changing the radius at the end of the loop in the code I posted will only adjust the r2 variable. It still will not update anything outside that loop, so it doesn't really have an effect unless you make it do something *inside* the loop.
I signed up for one of the training sessions and it got cancelled. Are these just going to be cancelled too?
That looks like a great service, however I notice the documentation states the following: "If you do not have Python 2.5 (or later 2.x) already installed, you will have to download and install it before running web2py."
this is something that would be best implemented at a filesystem level, for the reasons you've run into, it's really difficult to do properly. Even if it seems that you're making atomic writes, the Filesystem may not be committing to disk/SSD immediately. This causes problems with other processes that might be trying to write/read from the same area. 
Two things: 1. Try running your gist against your example - it won't work properly. In the gist, neither of the decorator functions actually return or run the decorated function. In the bind decorator function's decorate function you need to ```return func```, otherwise you can only call the bound function through functions registered to call it - you'll no longer be able to call ```second_function()``` directly. In the call decorator function's decorate function's inner function you need to call ```func()``` before running the for loop, otherwise only the bound function gets called - the caller function never gets run. 2. There needs to be better exception handling when there's no function bound to a channel that gets called. Right now you just get a very non-descriptive KeyError. Catch it and raise a better exception.
So I fixed what you said but what do you mean in the last statement? I'm pretty new I only know a few basics..I have to change the radius inside the loop instead of outside of it? I tried what you did and the result was still 1010 as the new r2 =[
Thanks I will take a look when I get to work, web2py looks great.
I love it for simple projects, beginners, and one man full stack teams. It just brings everything you need in one cohesive package. 
Well if you're looking for a general purpose scientific distribution, I'd recommend WinPython. Good Luck!
Thanks for the advice! I just learned about decorators yesterday, so I'm still not very good with them. But this was an interesting exercise to try them out on. I had the idea while working on another project and was having trouble coordinating all of the pieces in an organized manner. I updated the gist to address both of your points. I decided to raise ValueError. Would that be the correct one to use? 
Working from a template isn't really the way to go. You should learn the basic instructions, and work from there. Programming is basically taking simple instructions and combining them to do complex things. In this case you will need these: #This is a comment, to explain things #First you need to know how to get data from a user and store it in a value value = input("Text to show the user what you want: ") #This is how to print a value (using python 2) print "This is my value:",value #You can modify a value before printing it or add values together print "These values are added together:", value + value2*10 And that should give you everything you need for your assignment. 
Writing to a tmpfile and then moving is a fairly common thing to do in POSIX. I do see your point, but AFAIK it's not like the filesystem entry isn't going to show up before the data is synced to disk. Note that this isn't about ensuring that all data is written to disk immediately. The point rather is, e.g. in case of a power outage, to ensure the target file is completely written, or not. At no point there should be a half-baked file lying around (except for the temporary files). Also, I don't know if this is true for the Windows API. As explained in the README, it's untested... I'm currently struggling with setting up CI for it. Also, better tests probably would be appropriate.
+1. Portable Python is the way to go.http://portablepython.com/ got a lot of libs packages with it, and the other lib, well, you can get download them from pypi as zip most of the time and it will work out of the box. 
Somewhat related: http://kernelnewbies.org/Linux_3.11#head-8be09d59438b31c2a724547838f234cb33c40357 and http://lwn.net/Articles/559969/ You can open a file with the O_TMPFILE flag (newer linux kernels) and then linkat() the file descriptor to a normal file in the filesystem. Yet another option.
No. We aren't helping you write a DDOS tool, no matter how misguided it may be. http://www.reddit.com/r/Python/comments/2uvsys/getting_a_ping_t o_do_more_thatn_32_bytes/
Not a ddos tool. I wouldn't use pings to do a DDOS tool! I study ethical hacking and network security! we have made a tool kit and I wanted to add this to finish it off! :)
First, you are passing arguments wrong. It should be `subprocess.Popen ( ["ping", "-l", "200", . . .`, not `subprocess.Popen ( ["ping", " -l 200", . . .` &amp;nbsp; Second thing, run the command by hand. Ping might be reporting an error. Possible issues: * not all ping versions support -l and -n options OR they mean something different * you might need to run ping with sudo in order to use -l option * your command is actually not what you think it is :)
Yeah, except looking at your post history, that's exactly what you're doing. http://www.reddit.com/r/HowToHack/comments/2u77dh/need_to_make_a_tool_in_python_any_ideas/co5yepx http://www.reddit.com/r/Python/comments/2uvsys/getting_a_ping_to_do_more_thatn_32_bytes/ 
What about codepad.org ? 
Yes, but it was for the tool kit! Now changed it to a network stress test, but then changed it again just to ping a bit!
Though I have not tried this combination of methods myself, I believe you can do what you want using the pandas library. It contains functions for [reading Excel files](http://pandas.pydata.org/pandas-docs/stable/generated/pandas.io.excel.read_excel.html) into the pandas Dataframe object as well as [writing a Dataframe to SQlite](http://pandas.pydata.org/pandas-docs/dev/generated/pandas.DataFrame.to_sql.html). pandas is BSD-licensed, so that should be pretty friendly for what you want to do. If you're using tabular data in any capacity it would be a good idea to dig into pandas a bit.
Good suggestion :D
Excellent post, A++ would read again.
Doing something similar at the moment, we are using pywin32 some examples are here http://pythonexcels.com/python-excel-mini-cookbook/ 
Does it work?
Thanks!
No idea, but I've used xlwt for dealing with Excel files from python and it a) seems to work well and b) is BSD licenced.
They also omit the actual algorithms people use to solve matrices. The include the simple, slow, easy-to-explain algorithms that aren't necessarily stable or fast. They're fine for learning though. Still, it's just more complexity than you need to learn. You'd may need to validate something that's hard to validate. I'd just start with a bunch of nodes (Nx3 floats), triangles (Nx3 ints), and calculate area (1/2 a x b). It's harder than you think if you want it to be fast.
yes.. 
My script is just repeating itself. I am so lost
pandas pandas pandas pandas Hell if you were asking about doing this in another language I'd say no, use python and pandas. 
Looks like the MIT license, IIRC.
Your `x` never changes, so your loop never terminates.
There's no description of how it ensures that the write is atomic, or what precisely the guarantees are. Those both need to be part of the documentation.
x is the input parsed as an integer. Then you compare x to a char in the while loop. There's a lot wrong here and looks like homework. Check your indentation, why you are using global, and order of statements. 
Thanks, I have already an issue open for this, just not high-priority ATM. EDIT: [Link to the issue](https://github.com/untitaker/python-atomicwrites/issues/2). Next thing to do is looking up how to call `linkat` elegantly in Python.
Sirgraendal, so what is the solution? I put INT before everything..it just doesnt make sense to me. It keeps making it 1010
The most detailed explanation is at https://python-atomicwrites.readthedocs.org/en/latest/#atomicwrites.AtomicWriter Maybe it should be a bit more elaborate.
Just quickly in my terminal I was able to find a terminal command tojust get you the 'time=xx' part: ping -c 1 -n google.com | grep icmp | awk {'print $7'} If you execute that instead of your current os.system() command, it will return 'time=xx' which you could I guess then split on the = to get the number. Someone may be able to suggest a far more elegant solution. EDIT: The awk and grep parts of course assume you're using Linux or some sort of unix variant. 
Cool, it's nice to see some machine learning posts on here as well.
https://github.com/trending?l=python
Very ugly solution, but it should work: ping_str = check_ping() ping_list = ping_list.split("/") ping_list looke like this: ["--- google.com ping statistics --- 1 packets transmitted, 1 packets received, 0.0% packet loss round-trip min", "avg", "max", "stddev = 10.262", "10.262", "10.262", "0.000 ms test 0"] Now you want the -2nd element of that list cause that is your average ping: ping_float = float(ping_list[-2]) This will probably cause an error when the server doesnt respond in time (because ping_list[-2] is "-" or something else that can't be converted to float), so you could do something like: if "timeout" in ping_str: ping_status = "Network Error" Also check out /r/learnpython, this question is more fitting for that sub.
Try printing the important variables throughout your whole code. Then you can check them manually and see in which exact line the weird 1010 is created.
It took so much work to make that work. You enter it and after ~5 mins it ends, not installing pillow saying "vcvarsall.bat not found."
Thing is, it shouldn't be doing that... On a normal windows Python, it should be selecting one of the wheel files (end in .whl) you can see on the [downloads page](https://pypi.python.org/pypi/Pillow/2.7.0). And their codepath strictly doesn't have the ability to come up with that error. What version of python and pip are you using? (`pip --version` and `python --version`)
&gt; you can only have one, things generally get iffy when you try to compose metaclasses This depends on whether the metaclasses were coded with extensibility in mind, just like all classes in Python. For instance, (shameless self-plug warning) see [this example](https://github.com/brandjon/simplestruct/blob/master/examples/abstract.py) from my simplestruct library. A direct subclass of the two metaclasses is all that's needed, because the designers of `abc.ABCMeta` had the foresight to [code it with super()](https://hg.python.org/cpython/file/default/Lib/abc.py#l133) instead of hardcoding a method retrieval from the base class.
Thank you very much! I hadn't heard of Pandas, I pretty much just Googled "Python Excel" and went from there haha
Thank you :D I'm extra glad I asked now because I've gotten a better alternative
This is good to hear! I will be using Pandas for this project instead.
Oh ok thank you! I've never really bothered to make things where the license would matter before, so I wasn't sure. But it does make sense that the license would be in the source code directly.
&gt; exorcism.io ??? couldn't fine it Thank you
That's a very good example
Thanks. Glad I found a case where I could reasonably defy the "Never stoop to using metaclasses" wisdom.
Sorry, exercism.io. With an e. It takes a little to set it up, it uses a command line to fetch and upload exercises, but I think that is also a good learning experience.
&gt; Incidentally, does anyone happen to know how the magic translation from super() is implemented in CPython? It's done in `super_init()`, which looks back into the caller's frame. 
There is also [OpenPyxl](https://openpyxl.readthedocs.org/en/latest/), which I generally use for writing Excel, but you can read also, particularly the new .xlsx files. Documentation sucks pretty badly but it's a nice active project.
You might also like /r/pystats but it's a smaller sub.
It's questionable whether renames can be made atomic on Windows, as `MoveFileEx` doesn't say anything about it. There are also issues with buggy/broken implementations of file systems (like NFS) that break a lot of the usual guarantees.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Cheese Shop sketch**](https://en.wikipedia.org/wiki/Cheese%20Shop%20sketch): [](#sfw) --- &gt; &gt;The __Cheese Shop__ is a well-known sketch from *[Monty Python's Flying Circus](https://en.wikipedia.org/wiki/Monty_Python%27s_Flying_Circus)*. &gt;It originally appears in episode 33, "[Salad Days](https://en.wikipedia.org/wiki/List_of_Monty_Python%27s_Flying_Circus_episodes#7._Salad_Days)". The script for the sketch is included in the book *The Complete Monty Python's Flying Circus: All the Words, Volume 2*. &gt;It would later be reworked for the album *[The Monty Python Matching Tie and Handkerchief](https://en.wikipedia.org/wiki/The_Monty_Python_Matching_Tie_and_Handkerchief)* and appeared for one last time during [Monty Python Live (Mostly)](https://en.wikipedia.org/wiki/Monty_Python_Live_(Mostly\)), as a surprising coda to the [Dead Parrot](https://en.wikipedia.org/wiki/Dead_Parrot) sketch. &gt;==== &gt;[**Image**](https://i.imgur.com/6eFfs4f.jpg) [^(i)](https://en.wikipedia.org/wiki/File:Cheeseshop.jpg) - *Michael Palin \(left\) and John Cleese \(right\) of Monty Python performing the Cheese Shop sketch.* --- ^Interesting: [^Sam ^Peckinpah's ^"Salad ^Days"](https://en.wikipedia.org/wiki/Sam_Peckinpah%27s_%22Salad_Days%22) ^| [^Fynbo](https://en.wikipedia.org/wiki/Fynbo) ^| [^Brouère](https://en.wikipedia.org/wiki/Brou%C3%A8re) ^| [^Terpsichore](https://en.wikipedia.org/wiki/Terpsichore) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+coclf8s) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+coclf8s)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Python is named Python because of the comedy group "Monty Python". The default IDE, Idle, is named that because of Eric Idle, one of their members. Many other references to the comedy troupe and their work exist, including that which you asked, which is one of their jokes.
I'm glad to see it's possible and not *too* complicated :) 
I can code in secret, obscured by a poster of Rita Hayworth. Genius.
Django can do that, and a lot more.
And if my grandmother had wheels, she would be a wagon.
I would love to have a code buddy! Pick me !!
Oh cool ~ another site to practice! BTW, you can check these out too: [CodeEval](http://codeeval.com) [CodeWars](http://codewars.com) &lt;-- My favorite [CheckIO](http://checkio.org)
I really don't think that sending people to /r/javahelp would be very productive. 
xlrd, xlwt, and xlutils' license are bsd, bsd, and mit
Are there any siginificant advantade using Kyoto Cabinet?
/r/learnpython But let the up/down vote and commenting system do its job here. 
&gt; Just downvote the posts to make them go away. These pop-up banners are for the lazy. Python help posts have a place on reddit, maybe just not here. You're advocating annoying us with them, and not having a place to put them. Maybe we could get rid of subreddits and put everything in /r/all. Just downvote bad posts to make them go away.
Is the data columnar? If so run your own scripts to export it. 
I kinda like the newbie questions though. Keeps the sub from getting to focused on one thing. 
Subreddits == good. Giant flashing banners == bad. No need to move everything to /r/all. That would just be silly.
People don't pay attention to that shit &amp; it's useless for mobile posters.
Precisely. I came here to ask a question on Jinja2 and its use outside of web frameworks, and I see this as the top post of this subreddit. Open ended questions that spark a good discussion is what we need to keep the community going. StackOverflow also discourages open ended questions like that, and I really don't know where else I can go.
There are some beginner Python tutorials [here](https://simpletutorials.com/c/1549/Python+for+Beginners) as well
Maybe have a sticky thread that people can ask questions in? We shouldn't be looking to turn people away.
Yes!!! Exactly what I'm looking for. Thank you!
string concatenation in a loop is astonishingly slow in CPython too, if you happen to have an extra reference to that string (and *that's* really obscure performance characteristics). While I agree with the "unpredictability", you chose a really bad example.
Perhaps it's a bit too subtle? Trolling is usually inflammatory or controversial in how stupid it is ( eg Python is a terrible language or the guy who put NOS energy drinks in his motorcycle gas tank... for the extra horses ).
Doesn't seem to be working too well as a deterrent. 
This rant would have been valid maybe three years ago. Yes, Python packaging used to suck but the situation has got a whole lot better. `pip` is the defacto downloader, `twine` is the defacto uploader. PyPi does host your tarballs for you. Make wheels if you are targeting Windows users. Follow the packaging guide from [PyPA][0]. Yes, there is still legacy cruft, but which 20 year old project doesn't? [0]: https://packaging.python.org/en/latest/current.html
I have an open-source Python project that could certainly do with some help: [Pathomx](http://pathomx.org) Pathomx is a workflow-based scientific data analysis tool that enables step-wise construction of analyses. The neat thing is that steps are constructed from small editable Python scripts that can be chained together to do almost anything. Code is run via an IPython cluster instance bringing support for R and MATLAB scripting with it. The analysis code makes heavy use of numpy, scipy, pandas, matplotlib and the scikit packages. The UI is built with PyQt. So you should find something that interests you to do! Source is available on [Github](http://github.com/pathomx/pathomx) Let me know if you're interested in getting involved!
Cheers, some of it looks a bit heavy for me, but I'm interested. Sometimes it's easier to listen and get some value by osmosis even if you don't really get the content. Do you know any good starter video tutes for Python / Machine Learning?
Currently, the twisted project needs help to be ported from Python 2 to Python 3 : https://twistedmatrix.com/trac/milestone/Python-3.x This is one of the last big libs needing this and preventing the switch for a lot of companies. Actually, helping any lib from http://python3wos.appspot.com/ to be ported would help the entire Python community. The twisted community has the reputation to be friendly, and is experienced with introducing newcommers with contributing. They have an entire guide (http://twistedmatrix.com/trac/wiki/ContributingToTwistedLabs) and you can join them on chats to get guidance (https://twistedmatrix.com/trac/wiki/BasicGuideToContributingCode).
"Pick one" is spot on, there is little difference particularly for simple applications. From experience it's also relatively easy to convert from wx &lt;-&gt; Qt if you find you made a mistake, as the application models aren't too dissimilar. 
Or the official upstream sample https://github.com/Itseez/opencv/blob/master/samples/python2/facedetect.py
/r/learnpython
we already have /r/learnpython, that would be sufficient IMO
I have made a ping plotter. It plots ping responses with braille-dots. Maybe it can help you. https://github.com/gurkslask/pingVisualizer
thanks for pointing that out. i just looked up the PEP, and its not as bad as i previously thought: https://www.python.org/dev/peps/pep-0372/ &gt; * Keeping a sorted list of keys is fast for all operations except \_\_delitem\_\_() which becomes an O(n) exercise. This data structure leads to very simple code and little wasted space. &gt; * Keeping a separate dictionary to record insertion sequence numbers makes the code a little bit more complex. All of the basic operations are O(1) but the constant factor is increased for \_\_setitem\_\_() and \_\_delitem\_\_() meaning that every use case will have to pay for this speedup (since all buildup go through \_\_setitem\_\_). Also, the first traveral incurs a one-time O(n log n) sorting cost. The storage costs are double that for the sorted-list-of-keys approach. i think it would still be unwise to drop in OrderedDict as the default due to the increased costs mentioned in there. the PEP goes on to say that OrderedDict could be rewritten using linked lists to make some of those O(1), but i'm sure its O(1) would be slower than the normal dict's O(1).
There are sites on-line, better suited to getting help where a solution is needed. They even let people vote on the correct solution. And, they have good systems in place to stop duplicated attention. This sub is for "news about the dynamic, interpreted, interactive, object-oriented, extensible programming language Python". Questions can never be "news". This place, is for NEWS.
E,,,hacking is my hobby, i won't try to hide it. Knowledge is for everybody, right? Even if I am a blackhat. ( I didn't use my knowledge for evil, but maybe someday i will :) ) 
Hi, we have a project to get social media like/share count. If you have interest take a look at [sharegg server](https://github.com/sharegg/sharegg). Our API is flask based. It's very small and simple, but very useful.
Thanks for feedback sushibowl :) 
&gt; The banner appears only *while* hovering over the *submit text* button No need to navigate around it.
Regarding filesystem-specific behaviors, I agree with /u/reallyserious. For MoveFileEx, as said in the README, Microsoft isn't very explicit about this. I based my assumption off the following comment by [Doug Crook](https://social.msdn.microsoft.com/profile/doug%20e.%20cook/) at [the documentation for MoveFileEx](https://msdn.microsoft.com/en-us/library/windows/desktop/aa365240%28v=vs.85%29.aspx): FAQ: Is MoveFileEx atomic Frequently asked question: Is MoveFileEx atomic if the existing and new files are both on the same drive? The simple answer is "usually, but in some cases it will silently fall-back to a non-atomic method, so don't count on it". The implementation of MoveFileEx looks something like this: [...] The problem is if the rename fails, you might end up with a CopyFile, which is definitely not atomic. If you really need atomic-or-nothing, you can try calling NtSetInformationFile, which is unsupported but is much more likely to be atomic. He seems to be a Microsoft employee.
I'd say that beginner questions should go to r/learnpython but intermediate and advanced questions are welcome. ITT: the typical cadre of arrogant Python gurus. 
I don't think that I did. String concatenation in a loop is a fairly common idiom among naive Python developers. This is the kind of "gotcha" that I've actually seen people run into with PyPy.
You can add a comment guiding people toward r/learnpython. . . or you can continue suffering this grave injustice.
A lot of people are assholes. I've gone to a lot of tech meetups, including many Python meetups (in multiple cities) and while there are certainly bright spots in the greater Python community (e.g. Doug Hellman and Miguel Grinberg's blogs/documentation), there are a large number of arrogant and condescending folks as well. I stopped going to Python meetups partly because they felt like more of an algorithmic pissing contest. In my experience, there are two general camps of Python jerks: the Scipy/Numpy crowd and the Django/webdev crowd. What's funny about that main split is that those two groups don't like each other very much. . . I've seen a nontrivial amount of tribal hostility between them. :) Myself personally, I love Python but wish the community were more accepting/embracing towards beginners, especially considering how accessible the languages is to newbies. I do my best with my co-workers and friends, but the assholes are plentiful. Not to pretend that it's much different with other languages/communities. Functional programmers aren't generally kind toward anyone who doesn't have a PhD. :)
We can just recommend that they go to r/learnpython for beginner level questions. . . people like the OP are awfully melodramatic about this "problem".
You guys did an excellent job of styling that sub. Really slick looking. 
If by any chance, the excel files are irregular wrt their columns etc then you may want to check out: https://github.com/alixedi/semantic_parser Full disclosure: I wrote it.
Thank you, but it's not entirely our own merit. I've handpicked a bit of the css of /r/FlatBlue and touched up the rest with help from the css community.
BTW it's in the README now.
&gt; and I really don't know where else I can go Not to be a dick, but you can go to /r/learnpython, or /r/learnprogramming as suggested in the side bar. The help subs exist for helping. If no ones going to bother using it then it should be phased out and then /r/python can become the place where people ask questions easily found on Google. &gt;Open ended questions that spark a good discussion is what we need to keep the community going. Here's the front page: &gt;Is it possible to use Apache Spark with Python 3? &gt;Using python to work with excel files &gt;Looking to contrubute &gt;Throttling email from Python logger &gt;Python Beginner. Code Buddies? &gt;do we have anything like PHPGrid? &lt;-- this one. Seriously? &gt;Code Academy - Python Hardly stimulating questions. All of those are either easily Googled, or better served by /r/learnpython. To me, and I could be the odd man out here, what actually drives this "community" is tech articles, tutorials, people sharing what they've built, cool tidbits, etc. The zero effort, lazy questions are just noise. 
Oh thank you, this is good to know. I will only be taking certain cells from the sheet, not the entire sheet so I think I should look at xlrd as well. Pandas sounds like something I should learn even if I don't use it here.
I'm not claiming that Python packaging is completely pain free. I'm claiming that the "problems" pointed out in this blog post written in 2015 is based on a completely outdated understanding of the current packaging ecosystem. Yes, there are a lot of problems that still exists but I wish people will stop complaining about things that *have* already been fixed.
Thanks
I can suggest you to submit a talk to a PyData conference, for instance (shameless plug) [PyData Paris 2015](http://pydataparis.joinux.org/) which I happen to be organising.
Don't use pydev, but interested in the referenced [pyvmmonitor](http://www.pyvmmonitor.com).
I agree with you, which is why I created /r/pythoncoding. It's /r/python, but with a mod-enforced mandate to do basic research. The mods of Python on several occasions have expressed faith in the voting system. Fair enoug, but I personally disagree. Thus that sub.
Can't find the 'easy tasks' page !
thats nice. but you're alone in there
I changed my code to: import os,sys def check_ping(): hostname = "google.com" response = os.system("ping -c 1 -n " +hostname +" | grep icmp | awk {'print $7'}") return response check_ping() When i call this function I get: time=100.825 How would i make so that i can get time as a variable so i can then plot the ping time in a histogram? 
For now yea, but it's a new subreddit and growing.
Hey /u/omnius, I actually co-wrote two of those courses (1 &amp; 3). While I'm pretty proud of my effort, the course is for beginners. Hence, after ten years of coding I don't think you'll get much out of them except for a very hefty bill. **Note**: Considering how much they charge for those classes, I should have asked for several times more than what I got paid, and I should have asked for residuals. Oh well, lesson learned... In any case, I completely respect your concerns about not having the right skills. I don't have a CS background and a lot of things intimidate me. Sure, I have data structures down, but not the fancy B-Trie variants. Also, I still struggle with recursion. I could go on and on, but my ego can't take it. Still, like you, I think I've done pretty well. What I've considered doing is going right to the source of the Python language genius. That means saving up enough money for advanced classes by Raymond Hettiger or David Beazely. Those guys, I can assure you, teach **EXACTLY** what you are looking to learn.
What don't you have a good understanding of? That is, of the below list, which would you have a hard time teaching to a beginner? - Algorithms and data structures - networking protocols - object-oriented programming - software architecture / design patterns - optimizing Python &amp; making it fast - security for networks, applications, etc These are just a few ideas off the top of my head. Pick one that you're not too strong in and search for books such as Algorithms in Python or Python for Networking or whatever. Choose 3 from the shelf at a library, start reading them and stick with whichever grabs you the most (return the boring books) Or, pick up a new language, maybe starting with SICP or The Reasoned Schemer or something fundamental like that. 
It's not being melodramatic at all. Subreddits have a purpose. Just look at /r/askhistory - a subreddit that is absolutely dedicated to the quality of its content. How do they get that quality? By having a strict enforcement of what is and isn't acceptable to post there. And it's an excellent subreddit. It's not absurd to want quality content. Should /r/Python turn to an approach to modding a subreddit like /r/askhistory? I don't think so, but I agree with the OP that there should be some method of helping bring quality content to the top and removing shitty content from view that's beyond upvotes.
Yeah, you put a return character in your text block. What it doesn't support is dynamic regeneration based on screen width (e.g. it will use 80 characters if it can, but space things onto the next line if it can't)
Thanks for the post!
Wow, just the discussion alone there is enlightening. I was planning to play around with Spark, but I didn't realize that it didn't support Python 3.4. Thank you to both of you for bringing this to my attention.
If you're in Atlanta (or will be Thursday), Doug's actually giving a presentation on packaging for PyAtl. I won't be able to make it, so maybe you can fill my seat? Though, I recommend parking across from Manuel's main lot. 
I work in a very small family-owned company (i.e. 2 engineers) and have the same kinds of issues. I'm self-taught as well, and I usually learn what I don't know by finding something I want to do that I can't, and struggling through it. So, the question is - what do you want to do that you can't do? There are so many types of programming careers that learning everything seems impossible.
Whenever I feel like I should learn something I open my copy of Code Complete 2.0 and read a few chapters. All the advice in the book is independent of the language and will teach you some good stuff.
Have you tried the interactive interpreter on https://www.python.org/shell/ ? Alternatively there's also brython: http://www.brython.info/tests/console.html Terminal.com is also good. Failing all that (and the rest of the useful selections)... if you have a C compiler you could always try to print out and input the Python source code yourself ;) But actually it would probably be easier to just write down the source on paper and translate it into the computer when you get home. Honestly that's probably the best way to go.
Same here that's the problem i can force through something just fine. My stuff works. I am trying to get to a point where my solutions are less fragile more elegant. As far as domains go mostly backend web stuff, creating api's, and then administration programs for managing *nix machines.
I up voted him to. It is good advice but i am already following pep-8 but yeah its still great for anyone else reading this.
&gt;I am trying to get to a point where my solutions are less fragile more elegant. I'm not sure what the solution is apart from from learning from someone who already knows, which you're obviously suggesting. The lack of any kind of mentor in my current job is why I'm looking for another place to work.
I have this same question posted to some google+ python communities. One suggestion i got, which i thought was good, and hasn't been listed here (or i missed it). Was to join an open source project. Benefits of reading code, and working with other developers even though i don't have any at my job to work with. Anyone here have any suggestions on finding a project and contributing. I am going to read up on it on Google tonight but if anyone has already done some of this work that would be very appreciated.
Version 2 is from 2004 :)
PyCharms will push your changes to a remote host and execute code there as well. It is quite handy. It does require a professional license though. A few relevant links: https://www.jetbrains.com/pycharm/help/configuring-remote-interpreters-via-ssh.html https://www.jetbrains.com/pycharm/help/creating-a-remote-server-configuration.html https://www.jetbrains.com/pycharm/help/configuring-remote-interpreters-via-deployment-configuration.html
PyCharm can easily debug code via SSH, you just need to add a remote interpreter. If you combine this with a mount via SSH and a appropriate path mapping you can run and edit if it were local. I'm doing this every day in combination with Vagrant. While the VM is local in this case from PyCharms perspective a remote SSH server and a local SSH server is no difference. 
dammit, I wish he had numbered those.. I can't tell if you're starting at 0 or 1.
I cleaned it up.
Another self-taught coder here. Might not be the answer you're looking for, but: learn other languages to get new perspectives on how things are done. Dabbling in JavaScript, Ruby, Clojure (and derivatives), Haskell and perhaps a few others that I can't remember right now has been a huge eye-opener; I even managed to overcome my old fear of low-level coding and hack together a thing or two in C thanks to getting out of the Python box. Python is a beautiful language in its own right, and having it as your day-to-day weapon of choice means you've got taste in these matters. But there's a whole universe of programming languages out there for you to appreciate, you know, so you might as well make the most of it.
What also helps is to trawl news.ycombinator.com every day and read all the programming related articles even if you don't fully understand them. From time to time you will find articles or blog posts which will rock your world. My favorite article which I found in 2014 is called "Program to an interface, fool" (can't link to it, i am on mobile). It is a short article but it changed my thinking about object oriented programming. You should also go an read the whole book on gameprogrammingpatterns.com This one teached me a lot of interesting things about the different programming patterns. If you want to read a book, then you should select this one. 
Great advice i use in my daily work flow: python and javascripts (with a range of different frame works). I started with Perl back in the late 90s before finding python. I want to either start poking at c++ (just because) or java. I also want to play around with a functional language as well figuring it might help me not see everything as objects when a function can do the job. I also played with Ruby but it was very short lived. I didn't find anything there that i wasn't getting from python (from a learning prospective).
At the base level Pathomx is completely agnostic of data types - I'm currently working on adding support for image processing to the toolkit as a trial for this. In practice it depends largely on the input data format. Most of the default tools make use of pandas or numpy arrays for data-passing, and each tool has input-filters that control what kind of data it will accept (down to dimensions, structure, etc.) If you can't get your data to work, let me know and I"ll write a tool!
Also ask questions and share your code and projects, if you have time, get into OpenSource projects. This sounds trivial, but it is a great way to learn about and avoid bad habits: Even if your code is good and works just fine, there is always someone who will point out a weak spot (in terms of efficiency or style) and gives you good and constructive advice (at least most of the time in my experience). This is especially true if you are working in teams.
It's not omitted - all of the functions pass their arguments through to `Popen()` using `*args, **kwargs`. But because there are a lot of arguments, only the most common are listed in the documentation. It does mention this: &gt; The arguments shown above are merely the most common ones... The full function signature is largely the same as that of the Popen constructor
Thanks for the positive feedback, always nice to hear - I've been working on this a long time so not sure if my opinions still connect with reality ;) You're quite right that the samples are all very domain-specific - that's a product of my PhD being entirely metabolomics focused. The publication was also submitted before the expansion into a more generic workflow system, and so reflects a more narrow focus. In practice the software is almost entirely agnostic of data formats. If I add some more basic datasets (e.g. data tables, gels, ELISA outputs) and showed a workflow for processing that, do you think that would help? PCA is included in the sample tools, but only demonstrated for metabolomics so I'll find some alternate data to demo with too. The custom script is a fair cop, it works (and I know it works) I just don't generally use it so I haven't made the examples - I'll get on that! Thanks again for the feedback, really is appreciated.
Honestly, I would love to. I've looked at a few Python conferences before but thought it might be a bit too basic a project to be presented. But, since you ask I'll submit a talk and see how it goes! Thanks for the suggestion, much appreciated.
I think you're looking for [curses](https://docs.python.org/3.4/library/curses.html)
lol fixed.
&gt; news.ycombinator.com Hacker News ... Not sure why i didn't recognize the URL. This is a fantastic site!
I do believe you're correct. I've heard of ncurses in the Linux context, but I hadn't seen that sort of GUI done in Python before. I think this is exactly what I'm looking for. Thanks!
I find myself continually needing to select `3.4.2` from the docs dropdown list, as if `docs.python.org` is surprised that anyone is using it. I'd love to have a "login" ability so at least the site remembers that I prefer to see the v3 docs. Or even just a cookie set anonymously.
I think pdcurses is supposed to, and there might be more support now for straight curses. But I don't develop for Windows, ever.
Btw I also want to mention that i looks very cool! I made a proof of concept with same in mind (https://github.com/Tillsten/qt-dataflow) but never got far. I now just tell everyone who want to use my code to learn Python, but this approach probably works only in small groups. Supporting a GUI app is quite a lot of work and i can really see how pathomx can help there, maybe i will try it out and implement some tools. Btw can the connection-nodes have labels? For example you have somekind process which needs two inputs.
Very well stated. I think learning at least 2 or 3 languages helps you see outside the box (hate the cliche) and lets you become somewhat language agnostic. It's easy to get bogged down in the semantics of a language without realizing that it's the concepts that really make the difference. Also, glad to see it's not only me that has a fear of C.
Do you have a source for that?
https://docs.python.org/library/string.html doesn't specify a version, and so it should redirect to the most commonly used version of python. If you want the docs for v3 go to the docs for v3. https://docs.python.org/3/library/string.html works fine, and the links on that page will keep you in the v3 docs. &gt;This configuration affects everything from StackOverflow links (how I first noticed it) to Google pagerank. Most of the links to the docs on StackOverflow are almost certainly *intended* to point to v2. Changing the behavior the way you suggest would result in vastly more incorrect links than leaving it as is. This isn't to say that I don't think switching over to v3 as the default will eventually be called for, but at present at least, the majority of users are still v2 users. Switching the default would inconvenience them just the way the current default inconveniences you, and you're outnumbered.
&gt; it should redirect to the most commonly used version of python There is where I disagree. It should redirect to the **current** version of python.
I guess I was more suggesting to use the table of contents, stumble on the `os` module, and browse its contents until discovering `os.listdir()`. That's how I like to use reference documentation. It sounds like a worse way to find things compared to searching, but having done that once you now have an idea of all the things in that module so that the next time you need something you will know exactly where to look, without worrying about how to phrase the question for a search engine. It also means that on your way to finding `os.listdir()` you will stumble upon things you didn't know you ever needed but which are really useful. The Python standard library is packed with those.
&gt; It should redirect to the current version of python. Why? There's an obvious practical advantage to using the most common version of python. I'm not sure there's any reason to necessarily make it the most recent version other than some unreasoned insistence on the formal correctness of the most recent version. But with how slow python 3 adoption has been, and how limited third party support was initially, I think it should be clear that at least in principle, the most recent version shouldn't always be the one you're pushing.
I once worked in an environment which blocked SSH outbound, and I simply just configured my server's SSH to listen on 443. The firewall can't tell the difference between encrypted SSH traffic vs encrypted HTTPS, so I was able to do whatever I needed on my personal machine. 
Sublime IS my IDE. with linting, autocomplete, pep8, snippets, building all built in with various packages. Search for "sublime Python ide". 
Is what?! Don't be ridiculous, run it on Java 8, it's quite faster there, and I have no issues.
There is a package with the unfortunate name of Console that might work out well for you. ( http://effbot.org/zone/console-handbook.htm ) Think of it as a cmd window where you can write anywhere you want.
Never been able to make it work here because of my company proxy. There is no way to connect to a remote ssh interpreter with that proxy. I'd like to be wrong, 
So they fixed that bug. That's fine. I still maintain that Pypy has no place at python.org. The purpose of CPython isn't to be the fastest interpreter in the west. It's the reference implementation. It's easy to reason about its implementation (most of the time). And, most importantly, the body of people developing the Python of tomorrow are working on it. I dislike PyPy. Yes, it's faster. Yes, it uses less RAM. I'm only afraid that we're going to end up with the same situation the LuaJIT guy created for Lua. Lua 5.3 is out. Nobody will ever use it. Because there is a high performance implementation that does not dedicate itself to confirming to the latest standard set by the developer of the language, Lua development is essentially dead. I don't want that to happen with Python.
The reason that all the good Python IDEs are written in Java, is that all the good IDEs (with the possible exception of VS) are written in Java. Building an IDE is a monumental effort, and basing your work off of an existing, full-feature IDE is far more practical than creating a brand new one "because java". There was a project to create an IDE using PyQT called Ninja. It looks like the project is dead. There's Wing IDE. It's pricy. I've never used it. I hear that it's pretty okay, though. There's Eric IDE. It's... an IDE. I personally use Vim with Jedi.
&gt; Wing IDE Not yet - i'm checking it out now.
Spyder - written in Python using PyQt. Eric, which you mentioned, is also written in Python. 
I'm quite intrigued by the package and will try to give it a whirl next week. I'm a proteomics guy, but I'm curious to see how the pipeline handles it. My immediate comments after skimming the docs: * Do you have a listing of all built-in tools? Knowing that there is an implementation of peak picking, normalization, smoothing, PCA, classifier, regression, etc would be a helpful sell. * Maybe a comparison of this versus Galaxy? * More use cases with public data. I would love to see if you could show some super disparate analyses. Browsing the collection of [IPython notebooks](https://github.com/ipython/ipython/wiki/A-gallery-of-interesting-IPython-Notebooks) has a few full analyses which might be adapted * More example visualizations. People love pretty graphics and if you can show some clustering, venn diagrams, heatmaps, etc of results that would wow some of my less technical colleagues.
PyCharm works great with single files. It's a bit heavier than just opening it up in sublime, sure, but it doesn't need to work out of a project. The completion engine is great, but the part that I really love about PyCharm is the debugging capailities. I've never ceased to be amazed at how well its debugger works. The main reason I don't use it is that I rarely get to edit files locally. Most of my work is through a shell, so Vim + Plugins has to be my IDE. 
I think the biggest hurdle is the high praise of LPTHW coupled with LPTHW telling you not to use Python3. (assuming new users = new programmers) I just started learning programming with python, and went straight to LPTHW. Then I started learning more, researching more, and realizing that there's no reason to avoid Python3. I think my case refers more to "new users" as "new people learning to code" as opposed to experienced programmers who are new to Python - which is probably more of an issue with your post.
[Visual Studio with Python Tools](http://www.visualstudio.com/en-us/explore/python-vs.aspx).
Really it would be best if it was to point to the latest (in line with read the docs perhaps), after which users can choose to navigate to whatever version they want. Introduce user sessions or cookies to remember the version selected for subsequent visits. 
 &gt;&gt;&gt; sorted([1, 4, 2, 3], key=max) Traceback (most recent call last): File "&lt;pyshell#0&gt;", line 1, in &lt;module&gt; sorted([1, 4, 2, 3], key=max) TypeError: 'int' object is not iterable Python sorts take a key function, not a comparison function. You should use `key=float` if your version numbers are strings with no patch version.
&gt; or something else entirely? The *Zeus IDE* can do seamless FTP/SFTP editing. It think it's also possible to run the Python code remotely using something like plink, but I never tried that myself. Here are some more details regarding plink: http://www.zeusedit.com/phpBB3/viewtopic.php?f=3&amp;t=1549 NOTE: Zeus is shareware, runs natively on Windows and runs on Linux and Mac OSX using Wine. *Jussi Jumppanen* *Author: Zeus IDE* 
/r/learnpython in the future please.
Zeus is a *language neutral IDE* and it has support for Python: http://www.zeusedit.com/python.html It does the standard things like syntax highlighting, code completion, class browsing, code folding etc. It also has a from of Python autocompletion/code navigation that is driven by Jedi. Zeus is also fully script-able and naturally those scripts can be written in Python. But Zeus **is not REPL**, instead it uses an external Python interpreter to syntax check and run the Python code. &gt; What I hate the most is the bad, clunky feel of Java apps Zeus is written in C++ so it run's lightning fast on these modern day machines. **NOTE:** Zeus is shareware, runs natively on Windows and runs on Linux and Mac OSX using Wine. *Jussi Jumppanen* *Author: Zeus IDE* 
&gt;...and went straight to LPTHW. I looked at it, but it seemed for all the hype it was just a lot of exercises with very little instructional material. When there are entire free books like Dive Into Python (3), I'm a bit puzzled as to the appeal of LPTHW.
&gt;and so it should redirect to the most commonly used version of python. So how do we determine that, and on what intervals? It's not like Python phones home. We do know that Python 3 downloads have surpassed Python 2 downloads (per month) for years now.
Does Microsoft have their web pages default to Windows XP information?
Oh shit, you're right. :/ Well this is awkward. It should've been `reversed=True` Major.minor versions as floats if you ignore that `.10 == .1` 
I assume the people over at python.org have pretty good stats on how people are using the site. Personally I'm basing my opinion on a number of surveys I've seen over the last months. [Here's](http://blog.frite-camembert.net/python-survey-2014.html) a recent one that showed up on reddit. You can find more surveys and data if you look. You'll find that by most reasonable measures there are a lot more 2.x users than 3.x users. I would speculate that python 3 gets more downloads because it's much less likely to be pre-installed on a system, and users are much more likely to already have python 2.x generally.
Microsoft's wants to sell more copies of Windows. Of course they show their newest program. I'm actually not sure I even understand what point you were trying to make by this. Is it that there's a principled reason you should focus on the latest version, and Microsoft is a paradigm of industry best practices? Because that *sounds* like what you were trying to imply, but it's almost too ridiculous for me to believe it.
As far as data structures go, and I'd even argue optimizing python goes (since algorithmic thinking tends to focus on reducing the number of total steps) you should check out http://it-ebooks.info/book/2467/
It has exponential back off (it is poorly documented though): &gt;&gt;&gt; import time &gt;&gt;&gt; from retrypy import retry, delay &gt;&gt;&gt; def foo(): ... print time.time() ... raise Exception("Error") ... &gt;&gt;&gt; retry.call(foo, wait=delay.exponential(1)) 1423293213.61 1423293214.61 1423293216.61 1423293220.61 1423293228.61 Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "retrypy/retry.py", line 63, in call wait, File "retrypy/retry.py", line 29, in _retry raise previous_exception Exception: Error
Take a Linux rescue cd. Plug into windows comp. Reboot. play with python.
Because it encourages users to upgrade, and it's more future-proof.
Honestly? Think up a project that might be good for the open source community and get coding. Or, find a project you like, look at the open Issues, and get coding. You've got enough experience that what you need now isn't education, it's exposure. You need to cross-pollinate with the community to advance further. With 10 years of experience, even if it's self taught, there isn't a tutorial or class out there that will teach you what you're looking to learn.
&gt; helps you see outside the box Helps you see several more boxes (outside the box you were previously looking at) that are known to contain valuables.
I just tested it. Also a little janky, and pretty slow. I switched back to PyCharm, and am very happy with it.
But at this point in time it shouldn't be pointing to py2 as the default in the first place. Currently most of the major users are now pushing py3, it's used for most new projects, and the vast majority of dependencies have been ported. Py3 is no longer the latest new toy that you should try out if you're brave enough, it's the general default, with py2 remaining for legacy projects and the small handful of very specific libraries that require it. LPTHW should have switched to py3 by now - especially considering how small many of the syntactical differences actually are - a user that for some reason needs to learn py2 can still follow along with a py3 tutorial mostly, albeit with a little bit more difficulty. OTOH, py3 should be the default that most users are actually introduced to.
I won't link to it right now since I'm on mobile, but you should check out the c++ documentation's approach to this. They basically don't make a distinction between different versions of the language, but rather specify on each topic page what version that topic applies to. If it's more than one, then you can select your version from a tab, which is very convenient. 
Can't speak to pandas but agree that xlrd is what you want if you basically just want the built-in csv module but without having to first manually convert your Excel files into CSV. 
If I follow, you have two connecting issues. One is that you have a very restrictive firewall to deal with. The other is that you need to code on the classified side but are feeling hampered by needing to learn totally offline. Is this right? If so, maybe what you need is to ask for an unclassified computer station sitting next to your classified computer station at your desk. It won't solve your firewall issue but it's still better than having to learn to code purely on the classified computer. If your issue really is the firewall, yeah, a book is your best bet. Or, this is probably kind of insane, but look into downloading the Python part of Stack Exchange onto a CD/DVD.
I actually discovered [Orange](http://orange.biolab.si) after I'd started developing Pathomx. It is similar, but when I looked was focused more on machine learning rather than data processing. That architecture isn't linear passing, making tools more complicated than simple scripts. The internal data table format also didn't seem itself to the NMR data I was processing. I would have preferred to implement the analysis on an existing platform if I could, to save on all the GUI programming! One advantage of Pathomx is that it is based on standard Python libraries like numpy and pandas - it just passes variables between scripts and displays and viewable outputs. That means a lower learning curve to write tools. 
Perhaps you're right. I'm always annoyed with v2 documentation Google suggests.. 
That's exactly the use case I developed it for - sharing analysis toolkits with non-programmers. There are plans to add simplify use further with reporting functionality. Users can open a complete workflow, set the key variables, run the analysis and get the outputs + PDF report. Yep, all the input/outputs are named. If you hover them you get the name (this needs expanding). As you drag connectors around the destination ports light up green if they can accept the data. Please do have a go at creating some tools and let me know how you get on! Thanks.
&gt; If an old link has the generic URL, it will then point to the new one generic URL's point to the **old** one.
The appeal of it, I think, is exactly that it cuts the fluff. If I want to learn to code, I do not want to read a book about it, I just want to do it. LPTHW is very hands on and learning by doing. I know a few people who have degrees in comp sci, and sort of don't really have any idea how to *write* code, even if they understand algorithms. -edit- My point being: Some people look for the "how"s before they go looking for the "why"s.
/r/learnpython
If you want a job it depends what you want to do, loads of companies do Java with tomcat. I code Python daily and a friend if mine (Embedded developer) writes C++ daily.
Java usually is compiled into bytecode that is then interpreted by the Java Virtual machine (JVM), so it's not that different from Python in that aspect.
That does sound like Postgres. And Postgres tends to give search results as any damn version it pleases, it seems. Anything I look for might turn up on 9.4, 9.3, 9.2, 8.1, etc., with no rhyme or reason. I've just gotten used to choosing versions after clicking through.
Even if you didn't randomly mix incompatable versions your instructions don't even work... pip install pygtk ... * Building PyGTK using distutils is only supported on windows. * ... I am sorry but this post is just a mess of incorrect and unhelpful information. 
Or you could learn Go and practice concurrency while also having fun.
It doesn't seem very productive to stumble around blindly hoping to land on the right page instead of using search. Especially for newcomers who have no idea what they are looking for. And not everyone has time to peruse through the entire stdlib documentation just because they need to reference the return value of a function. There is a reason search engines won out over web directories.
The tool looks at first sight very interesting, but also very tied to bioinformatics. I wonder how easy it would be to adapt Pathomx to different domains. In the area of ETL I'm looking at the moment for an alternative to the heavyweights [Talend Open Studio for Data Integration](http://www.talend.com/products/data-integration) and [Pentaho Data Integration](http://community.pentaho.com/projects/data-integration/). Would Pathomx be a possibility? As I have seen the creation of plug-ins is easy, but I could also hide the existing bioinformatics tools?
Of if you don't have time to watch Transforming Code into Beautiful, Idiomatic Python [read the slides](https://speakerdeck.com/pyconslides/transforming-code-into-beautiful-idiomatic-python-by-raymond-hettinger-1)
There's also the issue that RHEL/CentOS 7 is still shipping without python 3 by default. That was an annoying surprise at work last week when I brought myself up to CentOS 7... 
This **would** (currently not) be really useful if the **else** would **only execute** for an **empty generator**, then you could have something like this: for v in collection: print v else: print 'empty generator' Does anyone know what is the best way of making it so, **without a boolean flag** that is?
I've used it as a finally clause for processing iterators. In the following code you can't simply do `while iterator` because `bool(iterator)` always returns true. The else statement here is a workaround of the usual `StopIteration` try-catch pattern which I think is cleaner and safer. In Python3: def chunk_iterable(iterable, chunksize): """Convert iterable into blocks of a given size The last block will return a block containing whatever was remaining in the buffer that did not already get put in a block. """ _iterable = iter(iterable) buffer = collections.deque(maxlen=chunksize) while True: # Adds items to buffer for i, v in enumerate(_iterable, start=1): buffer.append(v) if i &gt;= chunksize: yield tuple(buffer) buffer.clear() break # End while loop when iterator is finished else: if buffer: yield tuple(buffer) break
Look at Active State's Komodo /Py IDE. Used them all, java sux. Built on Gecko. My tool of choice since 2007. Active State are good cust svc and serious Py contributors. 
Yep, don't need windows users introducing some awful hack like this into python because they're trying to do something bizarre and their os is a pain.
Also, before posting in learn python, write some code, even if it doesn't work. Post the code and error traceback with every line indented an extra four spaces for reddit formatting. You can copy and paste from the terminal too, if you didn't know.
C++ is famous for its multiple features? and with the std, the compiled information is not so friendly to read
Thanks for the feedback, seems to be a common observation! I'll add some new workflows covering different analysis domains.
Thanks for taking a look. It *should* be able to handle proteomics data, although the support in the toolkits is minimal (I've just started a proteomics post-doc so will be implementing more over the coming months). To answer your questions - - There is currently no complete listing, I will add one! As the number of tools is increasing it is becoming kind of unmanageable to have *everything* loaded at once, so a better interface for loading/unloading toolkits is under construction. - It is similar to Galaxy in the sense of data processing, however it is focused on real-time analysis and therefore smaller datasets. That said, with the remote cluster support via IPython the limitations are reducing. I will write up a more complete comparison vs. other tools including Galaxy and add it to the documentation. - That's a great point. I will sit down and write up some example workflows using public databases (the support for the data formats is already in there) - I'm working on improving the plot management, including batch-outputs and 'report' generation for an upcoming release. Hopefully this will tick the prettiness box! Thanks again for the detailed feedback, really appreciated. Let me know how you get on with using it!
I agree with this. Too many tutorials want to go deep into detail and theory. Someone who has 3 hours of programming experience doesn't want to learn type theory they want to make a game or some fun little program. I don't really think reading a book full of theory teaches people to program, it is like reading a book about nutrition and calling yourself a cook. Ofcourse theory is very useful and something which professionals have to know but it isn't the place to start.
Link please?
Pathomx is completely data agnostic - the bias towards bioinformatics (and metabolomics) is just through me developing tools to solve my problems. You could quite easily create tools for performing ETL-like transformations to data, including querying/updating databases: anything Python can do, you can do it in Pathomx. The existing tools are all loaded as plugins so you can deselect them in the plugin manager to hide them. A more elegant interface is in the works for an upcoming release, allowing you to bundle tools together and activate/deactivate en-masse depending on the work task. Two other planned features that may be of interest are: 'automators' that allow you to trigger execution based on events (file changes, cron), and report generation that gives a document-formatted view of the calculation result. This is a few months away at present, but it will get there. Have a go with it and let me know how you get on! Thanks.
Unfortunately my teacher is stupid in that reguard. My other question is what exactly does float, eval, int. do?
Hangout just started! :)
Wow, that was a rant! Look, I think that we got off on the wrong foot. My whole point wasn't that PyPy should not exist. When I was talking about is this idea that PyPy should become the reference implementation. When you talk about things like PEP-483, you do realize that it's being done *for pypy*, don't you? I hate it as much as you seem to! I think it's ridiculous, and it's exactly what I was afraid of! Now the reference implementation is making changes to the language to facilitate better performance in an alternative implementation, and it's sacrificing it's own virtues to do so! It's hideous. I agree with the Python developers 100% on the _ssl issue. If you use undocumented libraries, you get what you deserve. It's that simple. Oracle recently had a similar issue with Guava. When you endeavor to preserve the functionality of undocumented interfaces, you might as well shut down the project and go work on something else. Your code is effectively frozen. Packaging in Python is... fun. We can all agree, there. The fact that you can't play with Python 3.4 in whatever godawful version of Ubuntu you're using isn't really the Python developers' faults, either. You should hit up canonical about that one. The python-future project offers a band-aid. It's a nice band-aid, but a band-aid implies a wound. That wound is the split between the people using Python 2, and those using Python 3. It's going to take time for that wound to heal. PyPy actually made things worse for that wound, for a while. By taking so long to adopt support for Python 3, it managed to keep that divide alive just a little bit longer. You really should check out Rust... it's actually fantastic... 
thanks takluyver.. im going to give it a try.
Heh, I'm not a windows user 98 percent of the time :) Still; I maintain a gtk app and using gtk from a virtualenv involves making symlinks on linux, and on windows you can forget it. Like it or not, most potential users are not on linux, so I'm building something to automate this kind of hack. Some of the best python tools are built on hacks - pip and virtualenv at least.
This should be fixed with this [pull request](https://github.com/toddsifleet/retrypy/pull/2). It wasn't totally straight forward because python3 handles things differently. 
Similar thing happens when doing a Google search for specific a specific doc. 2.x is always more relevant than 3.x.
Link is dead
thanks gurzo... i've just tried it a while ago.. and it does install in my android version... but the problem is that when i try to open a sample script it gives me an error in the console saying cannot create executable.. do you have any idea? how to fix it? thanks 
I go there often enough to warrant a bookmark. It's nice always opening up the /3/ page every time.
I've used this before. https://github.com/rholder/retrying
What is stopping you from downloading it? You can save so much time rather than selecting the version of python and etc. Link to github: https://github.com/pferretti/docsforkindle Yep, you won't find the newest versions right away, but the core of documentation is there.
**LPTHW = "Learn Python the Hard Way"** Let me save the google for those who, like me, were confused by the acronym. 
Wouldn't it stand to reason that most often the documentation of the most used version of python is the documentation that is being searched for? Of course, "used" in this context means actually writing or maintaining code for, you rarely need those docs for just running code. Of course, you may choose to have developers not find the thing they are searching for too easily, if it helps to push the new version!
Indent everything by 4 spaces.
I have been working as a Python developer for all my career(so is most of my team) . Recently we needed to write a web-server for our startup. We chose Go for it, and ended up shifting all our web services in Go. We observed that it was easy for all Python developers to grasp (It is Python-like in its approach to programming, almost just one way to do stuff and minimal code). Nim is another very cool language, which has no learning curve for its syntax if one comes from Python and I have been trying it out in another side project of our startup.
I don't mind braces so much, and my laundry is, as of right now, relativley intact (though I do appear to be missing some socks...) I think that you're right about the lack of a specification. It's been argued that cpython *is* the specification, but I don't really buy it. I honestly think that STM is a fool's errand. Better to remove the concept of pthread-style threading from Python entirely. Move to something like what Dart has, with isolates. Push everything else off to a C or OpenCL kernel.
I would recommend taking a look at Go. Really fun to program in and pretty easy to get going. Take a look at [The Golang Book](http://www.golang-book.com/)
What do you mean by 'everything'?
&gt; In the area of ETL I'm looking at the moment for an alternative to the heavyweights Talend Open Studio for Data Integration and Pentaho Data Integration. Do those two tools support components written in Python?
Interesting. Go seems to get as much love as it gets hate. What pulls you towards Go specifically?
Look at the source of this post def RaceSelection():#race selection RaceList=['Human,(Clever)','Orc,(Strong)','Elf,(Magical)','Goblin,(Sneaky)','CatFish,(Fishy)'] print(RaceList) race=input("What race are you?") race=(race.lower) RacialBonus="" RacialBadness="" if race == 'human':#setting all the races stats now for future use RacialBadness=("not strong ") RacialBonus=("clever ") elif race == 'orc': RacialBadness=("stupid ") RacialBonus=("strong ") elif race == 'elf': RacialBadness=("weak") RacialBonus=("magical") elif race == 'goblin': RacialBadness=("weak") RacialBonus=("sneaky") elif race == 'catfish':#Catfish is OP print("You're a Fish, have luck surviving") NewGame() else: RaceSelection() print("You're a ",race,", you are ",RacialBadness,", yet you're ",RacialBonus)
Awesome
It is fast, it is a small language, the documentation is superb, really nice package system. Once the environment is set up it is incredibly easy to get going. Really, really easy for doing web stuff too. 