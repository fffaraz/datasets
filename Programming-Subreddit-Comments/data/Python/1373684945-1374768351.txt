oh, yeah I am. Thanks for the pointer! I've tried to google for this problem in the past but only found some stackoverflow question with no useful answers iirc.
Got in about 10 minutes (just under half-way), still nothing to do with Python. But lots to do with gay lifestyle advocacy. If you want to learn that homos like Kylie Minogue &amp; Disney films, and fling their hands in a semicircle a lot while talking like Sean Hayes in Will &amp; Grace, this is the video for you. If you considered there may be some relevancy to Python in here, you can easily skip the first 10 minutes. 
Scroll down to the meteorology and climatology sections. https://conference.scipy.org/scipy2013/presentations.php
Yeah, ditto that. I was mucking about with an unsupported feature, and mentioned on IRC that I was running into problems. Despite being some random passer-by, one of the devs chatted with me, and came back half an hour later saying "fixed the bug, so you can pull &lt;git id&gt; from the dev depot and try it out, or wait until the next build." ... for an *unsupported* feature. Those guys seem pretty awesome.
Through the [NCSS Challenge](http://ncss.edu.au)! :D
Yes, you need to factor the expression and then cross-cancel it as much as possible. I was solving one problem from HSPL (High School Programming League) &gt;You may perhaps know how to find the last nonzero digit of n factorial. This time your task is harder, find the last nonzero decimal digit of the multinomial coefficient: &gt;(a1+a2+ … +an)!/(a1!*a2!* … *an!) &gt; In each line you were given one positive integer ( n≤20 ), followed by n integers: a1,a2,…,an, where 0 ≤ ai ≤ 1000000000. where you had to use (factor &amp; cancel) method in order to achieve 10/10p.
Nice article, but why not use python native iterators? import itertools class Node(models.Model): parent = models.ForeignKey(to='self', null=True, blank=True) value = models.IntegerField() def __unicode__(self): return '%s #%s' % (self.__class__.__name__, self.id) @property def ancestors(self): if self.parent is None: return () return itertools.chain((self.parent,), self.parent.ancestors) @property def larger_ancestors(self): return (a for a in self.ancestors if a.value &gt; self.value) 
theano + pandas.
This [answer](http://stackoverflow.com/a/14492358) describes loading [netCDF](http://en.wikipedia.org/wiki/NetCDF) with [netCDF4-python](http://code.google.com/p/netcdf4-python/) into [pandas](http://pandas.pydata.org/pandas-docs/stable/) `Series` and `DataFrame`s; and drawing charts with [matplotlib](http://scipy-lectures.github.io/intro/matplotlib/matplotlib.html). Scikit-learn and statsmodels may also be useful.
[disclaimer: I am the main author of pythran] Pytrhan's developpment is mainly test driven, and we have 1500+ python snippets that are 1. executed and result stored 2. translated to c++ then binary module, executed with the same input and result stored 3. assert results are similar That plus the fact that we limit the scope to scientific application makes it indded easier to reach an acceptable level of corectness.
You may be interesetd in this: http://numfocus.github.io/python-benchmarks/ Note that Pythran's input is backward compatible with Python, which is not the case of Cython (if you want performance)
You could use F() as well if you want to compare the value of a model field with another field on the same model https://docs.djangoproject.com/en/dev/topics/db/queries/#query-expressions
And again. What's not good enough in the official tutorial?
I was excited to see this in /r/Python, until I looked at the link. Step 1: Install bitcoind via apt. That makes me sad. There's a Python client out there, why not use it? How about Electrum? It seems like overkill to me to download the entire blockchain just to accept a few payments. Then again, my preference is just to pre-load a database with a few thousand public keys and keep the private keys offline - then periodically query Blockchain.info's API to see if any money was transferred to the key assigned internally to a specific transaction.
Yes, [relational algebra](https://en.wikipedia.org/wiki/Relational_algebra) is very cool.
The elders of Reddit's Python will downvote me to hell, but it is interesting to point out that web2py's queryset is just as nice, if not more expressive and powerful. db( db.article.id &gt; 0 ) db( (db.article.name == 'John') &amp; (db.article.tags.contain('news'))) Why is it more powerful? Because inner joins are done nicely and intuitively, when two tables are linked together. For example, in table "thing", there is a field "owner_id" that references (is a foreign key of) table "person": db(db.person.id==db.thing.owner_id)
I was an unbeliever too until two minutes ago. When the or operator `|` or the and operator `&amp;` is used to link QuerySets the entire expression is reduced to a single SQL query. So the second example: mymodel.objects.filter(a=1) | mymodel.objects.filter(b=2) Will result in a SQL query on the `mymodel` table with a single `WHERE` statement operating with `OR` on the filter expressions, just like the Q object based filter. Had to test it out using Django debug toolbar's debugsqlshell.
AFAIK Django can't create recursive SQL requests so one way or another it will be filtered in Python.
You're right. In this case you already have to get the ancestors one query at a time from the parent attribute of each ancestor. You could do it in fewer queries by filtering in python, and still use less memory. I overlooked this in my previous comment. That said, I think this is more of a flaw in the simplified example. The point of the example was to demonstrate how querysets can be filtered and combined, which gets lost when you use pythons iterators. I agree that your proposal would be more efficient for this case in a real system, but there are lots of places you can get advantages from querysets, and the point here was to demonstrate how to manipulate querysets. 
I don't really understand what the fuss is about. A queryset is comprised of two parts: - lazy evaluation of SQL queries - a datastructure for representing queries Django querysets do a nice job of the lazy evaluation, but I think they're pretty lacking as a data-structure...You have to use all sorts of weird APIs to represent various types of expressions (``Q``, ``F``, ``annotate`` and ``aggregate``, ``values``, etc). SQLAlchemy and Peewee are *much* more expressive. I posted this elsewhere, but here's a [post I wrote about shortcomings of the ORM](http://charlesleifer.com/blog/shortcomings-in-the-django-orm-and-a-look-at-peewee-a-lightweight-alternative/).
This seems interesting. I just recently started looking into Python and Flask and I was wondering how to stand up a site quickly. I'd like to hear from some more experienced Python devs to see what they think.
Cool talk! Hm.. just curious are there any current R users considering jumping ship to Python/Pandas? Regarding the performance issues in R, there are some alternatives like RevolutionR (although commercial). But a few weeks ago [Radford Neal announced pqR as well.](http://radfordneal.wordpress.com/2013/06/22/announcing-pqr-a-faster-version-of-r/) 
Whoa. That's awesome.
Does he want to learn the syntax or run simulations on a cluster? 
How do they compare?
i think the take-home message (at least for me) is to avoid global variables. i've always understood that to be part of good programming practices anyway.
Python feels like a programming language with statistics libraries. R feels like a statistics environment that you can program if you really have to.
Haha! I like how you described that.
I am really interested to see what happens with Julia. I think a lot of matlab users may catch on. 
Julia was something I've glanced at but never really taken a second look till now. After reading [the reason why Julia was created](http://julialang.org/blog/2012/02/why-we-created-julia/) I sure am happy you brought it up!
R is playing a pretty good game of its own too. Shiny for web apps, data frames, not to mention libraries that Python will never have. A good data scientist really needs to know both. 
I currently use a mixture of rpy2 and pandas to do the job (I even wrote some of the pandas-&gt;rpy2 code present in pandas's own rpy module). Not perfect by any chance, but better than pure R nevertheless.
That's awesome. Thank you for sharing!
He wasn't serious.
I think splinter is just an API over SE
the instructions are pretty verbose for "push button deploys" alas, ansible looks useful so thanks for the indirrect heads up. 
I prefer Pandas since most of the I stop short of needing to do sophisticated statistical analysis. The best part is the lack of context switching... i.e. I write a lot of code in Python for acquiring data so it's very productive to stay in the same language.
Damn right I am. That's really impressive; I'm not completely convinced by the microbenchmark nature of these but coming in even half the speed¹ of well-written Cython code is amazing. You say you "limit the scope to scientific application"; does this mean you only focus on numpy/scipy with numbers? Kudos to you either way. ¹ I'm rounding up here
Good old Zed.
It's a very well written micro framework. Setting up is super easy. I highly recommend it to everyone.
Or, you can just use [Google Takeout](https://www.google.com/takeout/?pli=1) to download the data in JSON format.
Use a Counter to represent each factorial. from collections import Counter class BadlyFactoredNumber: @classmethod def from_factorial(cls, n): return cls(range(2, n+1)) def __init__(self, factors): self.factors = Counter(factors) self.factors[1] = 0 for factor, n in self.factors.items(): if n: if not isinstance(factor, int) and factor &gt; 1: raise ValueError def __mul__(self, other): try: return BadlyFactoredNumber(self.factors + other.factors) except AttributeError: return NotImplemented def __truediv__(self, other): try: new = BadlyFactoredNumber(self.factors) new.factors.subtract(other.factors) return new except AttributeError: return NotImplemented def __repr__(self): return "BadlyFactoredNumber({})".format(dict(self.factors)) def __str__(self): value = 1 for factor, n in self.factors.items(): value *= factor ** n return str(value)
When I saw the title, I immediately thought "Hey, this is something Zed Shaw could write". Turns out I was right. 
Oh look, it's PHP but for Python.
I couldn't get out of my head those DB multi requests so I wrote this monstrosity, which bothers DB only once and returns QuerySet. Maybe someone will finds this interesting: class Node(models.Model): parent = models.ForeignKey(to='self', null=True, blank=True) value = models.IntegerField() def __unicode__(self): return '%s #%s' % (self.__class__.__name__, self.id) def get_ancestors(self, max_ancestors_num=10): if self.parent is None: return self.__class__.objects.none() db_table = self._meta.db_table db_id_field = self._meta.get_field('id').column db_parent_field = self._meta.get_field('parent').column sql_ids_str = ', '.join('t_%i.%s' % (i, db_id_field) for i in range(2, max_ancestors_num + 1)) sql_joins = ' '.join( 'LEFT JOIN {table} AS {alias_2} ' 'ON {alias_2}.{id_} = {alias_1}.{parent}'.format( table=db_table, id_=db_id_field, parent=db_parent_field, alias_1=('t_%i' % i), alias_2=('t_%i' % (i + 1)) ) for i in range(1, max_ancestors_num) ) sql_ancestors_ids = ( "SELECT CONCAT_WS(',', {ids_str}) " "FROM {table} AS t_1 " "{joins} " "WHERE t_1.{id_} = '{self_id}'".format( table=db_table, id_=db_id_field, ids_str=sql_ids_str, joins=sql_joins, self_id=self.id ) ) return self.__class__.objects.extra(where=('FIND_IN_SET(%s, (%s))' % (db_id_field, sql_ancestors_ids),)) def get_larger_ancestors(self, max_ancestors_num=10): return self.get_ancestors(max_ancestors_num).filter(value__gt=self.value) The amount of generated JOIN's depends on max_ancestors_num variable, which is 10 by default. Thereby this code can't handle infinite recursions. This SQL (MySQL) should explain basic principle: CREATE TABLE t( id INT PRIMARY KEY AUTO_INCREMENT, parent INT NULL ); INSERT INTO t(parent) VALUES (5), (NULL), (1), (2), (6), (4); SELECT * FROM t; SELECT * FROM t WHERE FIND_IN_SET(id, ( SELECT CONCAT_WS(',', t2.id, t3.id, t4.id, t5.id) FROM t as t1 LEFT JOIN t as t2 ON t2.id = t1.parent LEFT JOIN t as t3 ON t3.id = t2.parent LEFT JOIN t as t4 ON t4.id = t3.parent LEFT JOIN t as t5 ON t5.id = t4.parent WHERE t1.id = 3 )); PS. PostgreSQL have native recursion support: http://www.postgresql.org/docs/8.4/static/queries-with.html
For some reason that page isn't loading for me.
Quickly glancing over the code, that seems to the joke. Right down to the name.
What bad design decision are you talking about? And what trouble are you having?
Python has both mutable and immutable sets. And you most certainly can make sets of sets, as long as you do it with immutable sets.
you can stay here. nobody doubts that *some* choices have to be tradeoffs. e.g. tuple creation happens via “`,`” not “`(…)`”. except “`()`” which is an empty tuple. but if you think (like in that other comment) that python has no immutable sets, there are probably more misconceptions. just ask, and try not to alienate us.
It's not hard, nothing is hard. It's just annoying to learn because there are too many exceptions to remember. Sets being immutable makes sense for many reasons - you want to only differentiate between /values/. 
I love the mascot. 
What language do you use that features sets being immutable?
Should we learn it the hard way? 
You might also be interested in [django-mptt](https://github.com/django-mptt/django-mptt/), which adds more general tree support to django models. 
Clj
Could the same thing be accomplished like this, without needing to pass in extra arguments to `save()`: class User(models.Model): created = models.DateTimeField(editable=False) modified = models.DateTimeField() def save(self, *args, **kwargs): today = datetime.datetime.today() # On initial creation if not self.id: # Only set created/modified if it isn't already populated # This respects an existing value if set before initial save if not self.created: self.created = today if not self.modified: self.modified = today # Subsequent saves, always set modified else: self.modified = today super(User, self).save(*args, **kwargs) Then, if you import a record: &gt;&gt;&gt; record = User(**existing_data) &gt;&gt;&gt; record.save() # First save, if 'created' or 'modified' are in 'existing_data', they are preserved. If not, they are defaulted. &gt;&gt;&gt; record.save() # Second save, only 'modified' is updated Edit: removed save comment
I've been wanting to do this for a while. 
Wrong, wrong, and wrong. I'm simply saying I got just under half-way through and am yet to see any content relevant to Python. i.e. he hasn't started addressing the first point - making. This link belongs in some other subreddit for gay advocacy. 
&gt; It's a very well written micro framework. What makes you say that? Why should I believe you?
the only thing that won’t be allowed afaik is putting a kwarg before a positional one, which makes sense.
I wonder if it's useful to allow something like `*{"a": 5, "b": 7}` produce `("a", "b")`
Before reading the PEP I was rather skeptical of this idea, as it just adds new ways of doing things that you can already do, which seems to violate the "there should be preferably one obvious way to do it" mantra. For example, if `a` and `b` are both lists then `[*a, *b]` is just a redundant way of writing `a + b`, and similarly for tuples. The new syntax only really helps if you have mixed types, like a tuple and a list, or a sequence type that doesn't support addition. But after reading the PEP, I think I'm won over. The main thing that did it was the idea that what we have now is really just a special case, and that being able to freely unpack any sequence or iterable into any expression, container, or comprehension is something that has value. The fact that `a + b` is still hanging around as a reminder of the past will just have to be something that we live with. 
As well as set unions: `{*a, *b}`. The advantages of this method is that you get n-way merging/unions for free: `[*a, *b, *c, *d]`, `{**a, **b, **c, **d}`, `{*a, *b, *c, *d}`, `(*a, *b, *c, *d)`.
Glad someone brought this in. I remember wondering why `[*a, *b]` didn't work after learning the `f(*args)` syntax. Thinking about it again, I could have just used `list(*a, *b)` though. Edit: damn, `list(*a, *b)` doesn't actually work. Aside from list() requiring an iterable, I guess I wasn't super familiar with the rules of parameter expansion. Apparently it only allows one * expansion in a call. I did try: def new_list(*args): return args new_list(*range(3), *range(4)) and got SyntaxError.
FFS, why do Google keep axing so many products?
I think this leads to ambiguity since this could mean either the list of keys or the list of values. In this case, dict.keys() works well enough and very unambiguous.
This syntax is so nice I think it should be the new correct way to do it. Especially because it is a unified syntax between all the sequence types.
There's a few subtle differences: `x.update(y)` *updates* an existing dictionary object, x, with y. `{*a, *b}` first expands `a` and `b` then creates a new dictionary. It's *probably* a lot more inefficient (when I can download a copy of Python I'll have to disassemble the statements to be sure.) 
But `{**a, **b}` is not a replacement for `a.update(b)`. It's a replacement for x = {} x.update(a) x.update(b) # or x = dict(a.items() + b.items()) # 2.x x = dict(list(a.items()) + list(b.items())) # 3.x So it's okay that we still have a update-in-place if you want, but now we'd have a more concise way to create a new merged-copy of a set of dictionaries.
it would break old code in numerous hard-to-debug ways. but you’re right that there’s no advantage of them being methods: creating them doesn’t cost much and you don’t need to pass the methods handle anywhere, since the view is updated on the fly if sth. is changed, so calling it more than once has no advantages.
The specific point I was making is that it is **order-dependent**; `{*a, *b}` is not the same as `{*b, *a}` in much the same way that using update isn't either. However, dicts are orderless, so if you don't concatenate in the order in which you want to "update" -- you may end up with a different dictionary than you intended. 
I'm not sure I follow the problem with that. In what other way would you expect `{**a, **b}` to work? The fact that the keys of a dictionary are unordered isn't relevant to what happens when you merge two (orderless) sets of keys together. If you have conflicts, one key is going to have to overwrite another. The only question is whether `a` overwrites `b` or `b` overwrites `a` (and that behavior is defined). I don't see a hidden "gotcha" behavior here at all.
I've updated the example on my blog post to simplifying the pattern. I'm a perl guy who just started coding python and didn't see the obvious shared today variable because I was too worried getting python syntax correct. def save(self, *args, **kwargs): # Edit: Changed example to more efficient version # from comments # created = kwargs.pop('created', None) # if created: # self.created = created # elif not self.id: # self.created = datetime.datetime.today() # # modified = kwargs.pop('modified', None) # if modified: # self.modified = modified # else: # self.modified = datetime.datetime.today() today = datetime.datetime.today() if not self.id: self.created = kwargs.pop('created', today) elif kwargs.get('created', None): self.created = kwargs.pop('created') self.modified = kwargs.pop('modified', today) super(User, self).save(*args, **kwargs)
**--no-site-packages** seems to be the default behavior so no need to specify it. --no-site-packages Don't give access to the global site-packages dir to the virtual environment (default) As for branching, you can chose to do that or not. The point is that you can push your branches to master at anytime to save them and merge whenever you want to. (just in case your laptop catches on fire, falls into a swimming pool, etc, etc). But if you're the only one working on the project and your development is pretty linear, no need to branch. 
Ah I see and that was the original functionality that I thought was missing from auto_now (the context of a new record or not). Thanks for taking time to clarify and sorry for glossing over your comment.
It's a joke. (A dangerous joke, I suppose, if somebody takes it seriously, but a joke nonetheless.)
How on earth does this become clear?
Also note that `{*a, *b}` is a set operation, whereas `{**a, **b}` is a dict operation.
Reading the [source code](https://github.com/zedshaw/fuqit/blob/master/fuqit.py).
No point. Iterating over the dict will do it by default, and if you really want the keys you can just do `list(d)` or `d.keys()`.
This... is... WEBSCALE!!!!1111!!!!!!11!!
Some good knowledge is the size (in bytes) of empty objects: &gt;&gt;&gt; import sys &gt;&gt;&gt; sys.getsizeof("") 51 &gt;&gt;&gt; sys.getsizeof([]) 64 &gt;&gt;&gt; sys.getsizeof({}) 288 &gt;&gt;&gt; sys.getsizeof(lambda x:x) // same cost as a new function 136 &gt;&gt;&gt; class C: pass &gt;&gt;&gt; sys.getsizeof(C) 968 &gt;&gt;&gt; c = C() &gt;&gt;&gt; sys.getsizeof(c) 56 If you make a ton of these objects, say on the order of tens of thousands, you'll easily eat up much memory. Just an 
I create a virtualenv (defaults to no site packages) in the folder I'm about to check out my project to. I check out my project so that my directory structure is project-name/ bin/ include/ lib/ local/ project-name/ module/ __init__.py module.py ... setup.cfg setup.py I can then just cd into project-name/project-name, then `source ../bin/activate`. Once in the virtualenv, I install my dependencies with pip, either manually or with a requirements.txt. Usually manually because I rarely have that many dependencies.
Something to note, although the memory is never returned to the operating system, python has internally released the memory, this is done to save time later on where python can already use a chunk of memory it allocated originally without calling out to the operating system to allocate it a new chunk.
For git branching, I tend to stick pretty close to this: http://nvie.com/posts/a-successful-git-branching-model/ Although for solo projects, I'll mostly just work directly in the master branch, only doing a feature branch if it's something that I suspect will take a lot of time to stabilize and that I might end up just throwing away. I also do things a little differently depending on whether what I'm working on is a "library" that will have versioned releases or an "application" (web application usually, for me) that gets deployed to production. For libraries with versioned releases, the branching model above makes a lot of sense. For applications, I will usually just stick to a "master should always be deployable" mindset. At work, our CI and deployment setup works on that assumption, watching master on the repo and pushing that out to the test/deploy pipeline. virtualenv is a complete necessity for me as I tend to run a lot of different applications on one server and rely on the isolation and repeatability. I have an application template that I use to generate the directory structure for new projects and it drops a 'bootstrap.py' script into the top level that contains the commands to create a clean virtualenv in a known location and install the packages specified in requirements.txt into it. I currently have two different variations of the bootstrap that I use. One pulls all packages from a PyPI mirror that I maintain at work, the other expects a 'requirements' directory to exist containing all the actual packages locally. Both allow me to do a full deployment even if PyPI happens to be down and the latter lets me deploy even without a network connection (at the cost of having to keep all those dependencies checked into the repo). This is an example of the first: https://github.com/thraxil/mithras/blob/master/bootstrap.py And the second: https://github.com/ccnmtl/rolf/blob/master/bootstrap.py Both create the virtualenv in a directory called 've' in the project's checkout. I set up my .gitignore to ignore that directory. Since all my projects are set up that way, I've developed some muscle memory to always type "./ve/bin/python whatever" instead of just "python whatever" and the result is that I never have to worry about "activating" the right virtualenv. Since I do a lot of Django, I also change the shebang line in my manage.py to "#!ve/bin/python" so I can always do "./manage.py some_django_command" and it will work with the right virtualenv.
I use a Makefile that creates the virtualenv, installs dependencies with pip, runs the tests, runs the development server and deploys into the production environment. It would also make me sandwiches if I'd have a kitchen robot. Basically I can type 'make deploy' from a fresh checkout and know that everything is taken care of.
Huh. Not sure why I can't open it then. Weird! In any case, thanks for showing me this site. I didn't know about it before.
Try https://github.com/wyplay/pytracemalloc it's awesome
Yes, of course copying memory and keeping around two copies will usually be slower than having a single copy. More memory usage causes more cache misses, more memory management overhead and so forth. Whether the slowdown is noticeable will depend upon the specific situation. Is the extra allocation in a tight loop? Is it a large allocation? Etc.
What are you trying to send the command `sudo bash` to? `id` doesn't know what to do with it ..
Try changing: print child.after to: print child.before Or just change the logfile to standard output to troubleshoot 
Will try it out later today, thanks.
Quite useful, thanks.
Which is one of the few parts that I don't like about Python. When I actually need to iterate through a dictionary like that, I purposefully do it like this: &gt;&gt;&gt; [x for x in my_dict.keys()] This helps make it less ambiguous for other people that might work on the project and are not necessarily that fluent in Python.
My God, it's full of stars.
I like to keep stuff as simple as possible. I never use virtualenv for anything, ever. I always install everything with `sudo pip install`. You might think this is a nightmare, but in actually, it works out fine. If one project needs 1.3, but 1.5 is installed. 99% of the time, there is no problem in doing that. I can understand someone in the Microsoft world resisting newer versions, but in the open source world, the newer version generally means its better. I feel like virtualenv is a program that encourages not upgrading software to the newest version. On the other hand, if a new version *is* worse, then virtualenv is a great tool to offer a solution. But as a "methodology" is a bad tool to use in my opinion.
I'm confused. Are you using an implementation with the new PEP? (Does such a thing exist?) I think Sinistersnare is saying that `list(*a, *b)` will work when the new PEP is implemented.
But it won't. Sure, it'll compile and run, but the builtin `list` constructor will complain about getting *n* arguments instead of 1. Under the new syntax, `list([*a, *b])` *will* work, but then you could just do `[*a, *b]` anyway.
 mkvirtualenv foo git clone ssh://foo cd foo pip install -r requirements.txt python foo.py cd ../bar workon bar python bar.py (`mkvirtualenv` and `workon` coming from the wonderful `virtualenvwrapper` which everyone should use)
I'm similar - except for three things: * I use virtualenvwrapper - and so use workon rather than source activate. * After I create a distribution I install that in a separate virtualenv I create exclusively for testing. This allows me to test the package, and ensure all the pathing is exactly correct. * I'm using tox - which automatically runs my test harness against every python and dependent module version permutation. All three of these items are easy and highly recommended. EDIT: added third &amp; final point.
I believe the PEP is outdated. According to [a later email in this thread](http://mail.python.org/pipermail/python-ideas/2013-July/021915.html), the changes to function signatures are not accepted, only changes to assignment and literals. The argument against the function signature changes is that it breaks backwards compatibility with keyword-only argument syntax. For instance, here is the current behavior in python3: &gt;&gt;&gt; def foo(*bar, baz): print(bar, baz) ... &gt;&gt;&gt; foo(1, 2, 3) Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; TypeError: foo() needs keyword-only argument baz With the change to syntax, `baz` would instead be treated as a positional argument following `*baz`, so it would instead behave as &gt;&gt;&gt; def foo(*bar, baz): print(bar, baz) ... &gt;&gt;&gt; foo(1, 2, 3) (1, 2) 3 I think some additional pushback might be needed on the mailing list, as the use case proposed by /u/earthboundkid is pretty compelling: DEFAULTS = { ... } def foo(**kwargs): bar(**DEFAULTS, **kwargs) as opposed to def foo(**kwargs): temp_dict = dict(DEFAULTS) temp_dict.update(kwargs) bar(**temp_dict) or now def foo(**kwargs): bar(**{**DEFAULTS, **kwargs})
I agree to some extent, as I think unnecessary adoption of virtualenv does more harm than good, leaving bugged and insecure software running everywhere. But I can see how it is useful as a tool for finding dependencies in existing software, which I think is the idea here. You only have to activate it for testing.
I find a + b shorter and cleaner in this case. Also, it, too, generalizes the otherwise special cased + in an obvious way.
That wouldn't work...
 &gt;&gt;&gt; for x in range(1, 11): ... print(11-x if x != 10 else "Lift off") ... 10 9 8 7 6 5 4 3 2 Lift off Yes? Yes it does? edit: Oh, you mean because 1 is missing? Swap it out with x != 11 and range(1, 12)..problem solved
The [Anaconda](https://store.continuum.io/cshop/anaconda/) Python distribution includes conda, which trivializes a lot of these steps. Multiple conda environments can be set up, cloned, and switched between, all with one utility.
While useful, but it doesn't always show you where your memory problems are. For example, matplotllib bleeds memory if you don't close the figure at the end, but you won't be able to track that down using getsizeof. It's a good starting point to tell you how much you should be using. If the numbers are significantly different, you probably have a C leak.
I'm not sure it's nice to overload curly braces to mean either set or dict depending on the number of stars. If nothing else {} becomes a special case.
The lack of a builtin *flatten* function is part of what they're addressing here.
I've been using python for years and I still intuitively expect iterating a dict to return the items. Keys is a horrible default.
[Mother of God...](http://i0.kym-cdn.com/photos/images/original/000/199/693/disgusted-mother-of-god.png)
It actually bothers me how `dict` only has an in-place merge (`update`) built in, and nothing analogous to `set.union`.
The fact that your tests failed because of unknown dependencies is a good thing, since you want that to happen only in development, not when you deploy. I will setup an empty environment to test my deployment before hitting the production servers.
shouldn't `workon` be the second command after mkvirtualenv? as a side note I'm personally start with setup.py as soon as I ensure that the project works inside virtualenv. 
It might be redundant, but I think generalizations like `[*a, *b]` would make sense to anyone who just learned about unpacking.
Like I said, if somebody take it seriously....he'll learn it the hard way :p
FYI: http://www.python.org/dev/peps/pep-0448/
[this is about optimizing speed](http://wiki.python.org/moin/PythonSpeed)
I use tox(http://testrun.org/tox/latest//) to run my unittests in a virtual env. Its excellent, just automatically can handle all kinds of tests over multiple python versions. I also use git, never really used much branching yet however.
Curly braces are already overloaded: &gt;&gt;&gt; type({"key"}) &lt;type 'set'&gt; &gt;&gt;&gt; type({"key":"value"}) &lt;type 'dict'&gt; It makes sense to me - dicts are basically sets with an extra value associated with each item in the set.
* http://scikit-learn.org/dev/developers/performance.html#memory-usage-profiling * http://stackoverflow.com/questions/110259/which-python-memory-profiler-is-recommended
Oh right, that was backported to 2.7. I used to have to write 2.6 compatible code and wasn't using it.
Try to expect for something more specific. ".*" matches anything, even 'nothing' (no output) matches that regex.
Much better. I use chain for multiple iterators.
Oh dear. The prediction is a little rough. (It failed at "1" even!) It only got around 2 out of ten of my numbers. (They were quite clear to my eyes)
The kernel provides a single call to increase (or decrease) where the end of the data address space is (sbrk). When a memory allocation is done, the kernel is asked to increase address space by the memory allocator chunk size and then proceeds to give out small pieces of the chunk. The only time the address space can be decreased in size is if the last chunk has no used pieces which is very unlikely.(1) The Python allocator is fairly sophisticated having different chunks for different sized objects, but at the end of the day you are going to use what you use. Avoid using threads if possible including in the Apt library. They cause extra address space allocation (a common default for the stack for the thread is 2MB). The memory allocator may also allocate per thread areas. In your shoes I would add some swap to the system as that relieves the RAM pressure, although this option may not be available to you. The cache line can be "solved" by deleting the on disk cache before running your code. A non-existent cache doesn't need 50MB to load :) This assumes that code that builds the missing information doesn't need more memory than the cache took! The final solution is to split your code into multiple scripts that each do one thing and then exit, passing the results on to the next one. That lets intermediate data get freed by the process exiting. The final final solution is to rewrite in C where you are in control of every allocation, but not those of libraries you use. (1) Some allocators will use a different mechanism if a large allocation is made (mmap) which can be returned when the allocation is freed. See MMAP_THRESHOLD. You may have some luck running with that set to a tiny value like 16kb. See also mallopt for repercussions.
No, mkvirtualenv also activates it.
Welp, I suppose you're entitled to your opinion. But this is a terrible practice for so many different reasons.
Pythran accepts any implicitly typed python module without global variable (this may change) or user classes (this should not change) or any dynamic construct (e.g. eval/exec). It supports a few standard Python module (math, itertools, (part of) numpy)...) and is focuses on number crunching: profile your app, find the computation intensive kernel, offload it to a new module, turn the module into native code is the main way of using it. 
To me this is more interesting because of the toolset used than the outcome. 
&gt; should be preferably one obvious way to do it Yes, and the new way would be the one obvious way to do it instead of some uncanny structures like `func(*(a + [1, 2]))` or `func(**(dict({'a': 123, 'b': 456}.items() + kwa.items())))`; which, I suppose, is the primary use-case for this PEP.
I agree, but it's still disappointing. It's like watching a professor write code in class, try to run it, only to have it blow up with a long list of exceptions. I can't help but feel like a bad outcome (I tried it again and it got around 4 out of about 15 correct) suggests that something might be wrong with the technique or process. Maybe my handwriting is just extremely different from the sample data given to the classifier.
The tools are good (or at least I assume they are). The method of doing digit recognition - PCA + k Nearest Neighbors (kNN) is the complete wrong set of tools like using your screwdriver as a hammer. I'd write a long post on why these are the wrong tools, but I already did this [the last time they used these same tools (PCA + kNN) the wrong way](http://www.reddit.com/r/MachineLearning/comments/1g9hzz/contentbased_image_classification_in_python/caiak34) to stupidly do document classification. Again, when you have features that should withstand translations (e.g., shift each pixel up / over a place) then PCA + kNN should not be what you use. (E.g., use a multi-layer neural net).
Argh. You are right, of course. The `*a, *b` will expand as intended, but `list()` won't accept it.
Backwards compatibility - if you changed it from a list to an iterator in python2, you'd break code that assumed it was getting a list back. Instead, they just added `iterkeys()` and `itervalues()` methods. In python 3, they changed it to return an iterable view object on the dict internals. This has the same advantages of iterators (ie. no copy needed), but adds a bit more functionality too (behaves like a set), so things like `'foo' in d.keys()` can take advantage of the dict structure to get O(1) performance, rather than having to iterate, and you can do things like `d1.keys() == d2.keys()`. 
That was what Rhomboid was referring to. Check the link - it'll take you to the change, including the one to Doc/reference/expressions.rst that added this text.
So many? The chance of a package upgrade fixing a problematic bug or security flaw is far higher than the chance of it breaking something's functionality. And the damage from leaving a security flaw open is usually higher than the damage from brief downtime due to an incompatible package. 
numbers are tougher than you’d think due to the different forms. (e.g. 9 could be written as one curve, starting at the bottom (making it look siilar to q), as one curve starting in the middle (looks like 9), or as two connected curves (looking like g)) collecting the data yourself is superfluous if there’s already something like [MNIST](http://yann.lecun.com/exdb/mnist/)
I should totally go with something similar. Do you have any example published? Thanks in advance. 
me, too. some argue that `dict_a + dict_b` doesn’t make it obvious that for keys appearing in both, one value would be lost, while `first.update(other)` makes it clear that values of `other` can overwrite `first`’s values. since sets have no value associated to their items (“keys”), they don’t have that problem. but since `{'foo': None, 'foo': 'bar'}` always had overwriting behavior, that’s neither an issue with the new syntax.
yeah. `{}` is a dict for backwards-compatibility (and that’s nice, because dicts are more common than sets). use `set()` or `frozenset()` for empty ones.
no. `{'foo': None, 'foo': 'bar'}` already experiences that behavior, so there’s no new behavior in that regard. if that’s a gotcha, it has been there since the very beginning.
256MB memory..? Is this something ancient?
I would appreciate more insight on this. Personally inspite of being a classification task, I believe a generative model for each digit might be an appropriate way to start?
Using "Twisted" would be informative in the title.
Not to be a negative nancy but that random silhouette in the banner offends my (admittedly poor) designer's sense. There are a couple of other things weak with the design, particularly one of the ads being placed right in the middle of the list of packages. Can't you put it on the sidebar or something?
Wow, what a great example! Seems like such a nifty way to do it. I was curious, would you mind putting the output of this: print result.state print result.path() 
print result.state: HELLO WORLD That is the final state, the one the algorithm found as a solution. print result.path(): [(None, ''), ('H', 'H'), ('E', 'HE'), ('L', 'HEL'), ('L', 'HELL'), ('O', 'HELLO'), (' ', 'HELLO '), ('W', 'HELLO W'), ('O', 'HELLO WO'), ('R', 'HELLO WOR'), ('L', 'HELLO WORL'), ('D', 'HELLO WORLD')] That is the path from the initial state to the goal state. Each tuple has the action taken at that step, and the resulting state after the action.
Let's say I have a chat log. If I can parse it into a format SimpleAI can use, can I make a chat bot with it?
Sadly, it's not that easy to make a chat bot. You would need natural language processing tools (still not part of simpleai), machine learning tools (some utilities present on simpleai), and some hard work on putting all together, plus some knowledge on both topics. A good chat bot isn't something easy to create :)
In api.py, Instead of: if x == None: do: if x is None: In response.py, instead of: if type(x) == dict: do: if type(x) is dict: In profiles.py: Why use "if not len(self):"? Shouldn't "if not self:" suffice? An empty list should evaluate as false. 
Better would be `isinstance(x, dict)` since it also handles MRO.
Right you are :-) 
How legal is this? Scraping imdb is against their condition of use.
this is essentially what I use. Again, love it! My local work projects are hg rather than git, but either way... works great. In particular, the ability to test out upgrading a particular package is really helpful by tweaking just that one virtualenv or creating another virtualenv. Great stuff. Deployment is also much easier. Automated testing... etc... all made easier with it. 
Very cool man, I'll have to check it out when I get off work.
You are right! I want it to be really readable and easy for anybody coming from another programming language to understand the code. x == None is a little bit more readable(from my point of view) instead of x is None Thank you for the reply :D 
Thank you for the reply! Well, rauth was really easy for me. Just passing client_id, client_secret, the access_token and done! I've played with request before, so it was an obvious choice for me :D Oauth lib is really big...heavy...
condition of use ≠ law just saying. could still be illegal.
I guess we're solving different problems. For input on a touch/stylus device, some sort of trained stroke data seems great (e.g., the method without any ML would work fine using a well-separated intended alphabet like [Graffiti](http://en.wikipedia.org/wiki/Graffiti_(Palm_OS\)); and adding in some ML would help train a device to your particular deviations). This is a slightly different problem than starting from a pixel-based image (say from a camera or scanner) and trying to recognize digits on that. Though, my gut says PCA would not help much -- as the stroke data should be relatively low dimensionality to start with -- there shouldn't be tons of redundant features that can be thrown out. After classifying down the character into a combination of a bunch of stroke-types (e.g., this is a loop, straight horizontal line; straight vertical line), measuring everything relative to everything else, some sort of training like kNN seems great to improve the accuracy and capture all the ways to write the same symbol. Intuitively, this preprocessing of pixel data (even time-ordered pixel data) into stroke data seems to be the most critical step. To be honest, I wrote this long post sort of in response to both you and GizmoC. Your method of breaking down into stroke data didn't seem perfectly clear; but again its a totally different method than what they did: &gt; We shrink the images down from 500x500 to 50x50 to make them easier to work with (faster to process). &gt; Then we run a RandomizedPCA on the data to reduce the dimensionality. &gt; By reducing dimensionality, we mean that we're taking an image with 2500 cells (50x50) and aggregating it so that it becomes a vector of length 10.
Why is part of this written in C BTW?
Very nice work. I'll have to dig deeper into the pygame library after seeing something this awesome.
Qt. by means of its pyside bindings. For smaller projects i should recommend you to have fun with kivy.
Thanks MarCialR. I didn't know about kivy, but I will look at it.
Are you talking about [this Bitcoin client](https://github.com/samrushing/caesure) ? (looks dead) or armory, which latest commit is ~~3 month old~~, and need 6+ GB of RAM ? I think one would prefer running the bitcoind client than these two for such project. EDIT ; I didn't see the [ramreduceleveldb](https://github.com/etotheipi/BitcoinArmory/tree/ramreduceleveldb) branch on their repo, which is more active as the RAM consumption is the main problem in Electrum ATM.
`x == None` is not Pythonic and for other Python programmers will be *less* readable.
There's one case to use `if not len(self):`, if your library regularly uses numpy arrays (presumably not an issue here).
This is what I wrote to solve this problem: https://github.com/gavinwahl/sdb/blob/ec2b4dd09ed2b902cdab70e93d744964e8eeb0b5/sdb/passwords.py#L196. It uses a lock file instead of flock(2). It's ACID [I hope!], but just bails on conflicts. 
What do you mean by "graphics"? Do you want to make a GUI interface, or a game, or a 3d rotating teapot?
Awesome! Python's my personal favorite language for game development. We use it a great deal for PCG. I'm hesitant to make the leap to 3.x, though. I'm still running 2.6/2.7.
Thanks! As for python 3.x, you [can watch this video](http://youtu.be/f_6vDi7ywuA) if you need some convincing. It's not as scary as it seems, maybe the next time you start a new project you can start using it. If not, I also am maintaining a [2.x branch](https://github.com/RenfredH04/tmx/tree/python2.x) of the tmx library I used
Yes. I've had great experiences with Qt. Recent editions are letting you blur "front-end web developer skills" with "desktop GUI developer skills" even more than they used to, which is handy. You can also use their GUI-based UI designer (Qt Creator) and then generate code from it. ([Here's how to integrate with PySide](http://qt-project.org/wiki/QtCreator_and_PySide)) [Here's a random sample](https://github.com/shuge/Enjoy-Qt-Python-Binding/blob/master/layout/auto_adjust_size_to_fit_img.py) to see what the code looks like. This one loads images and resizes the window to fit it. There's a really nice callback mechanism, too. # Define a labeled Button self.btn = QtGui.QPushButton("switch without adjusting size", self) # When it's clicked, call the _btn_cb callback self.btn.clicked.connect(self._btn_cb)
I knew about Qt for C++ and it is great it has been ported to Python. Thanks.
Oh, great. Yeah, It's worked on Python for about as long as it's been out, I used it back in 2003. It was good even back then, I ported a C++ GUI and was able to get the GUI itself to come up in about 20 minutes by searching and replacing. (`'s/-&gt;/./'` and so on.)
Why not use `os.copy` to copy files instead of `with open... as f ... f.write` 224 &amp; 225 could be `os.copy(filename, get_backup_filename(filename)` hell, it could even be an `os.rename` (this assumes you trust your file lock though)
dang lucky guy
Thanks!
wtf is this ?
Qt would be a good option. It's a good framework. I've heard good things about the python bindings, though I've only used it with C++. Look at some documentation for the Qt canvas widget to see if that would meet your needs. Gtk, wx, or pretty much any GUI framework would probably work for what you want.
No problem, its actually part of series this guy does and I found it very informative. It got me into Python, so I figured I'd share the love.
 from itertools import chain chain.from_iterable(...) is what you are looking for.
*I* am the Joshua Landau of that PEP ...WHAT!? These are *my* upvotes! Give them to me! ;) But srsly, here I am to answer your questions, should you have any that I can answer. (Heck, any comment's fine, I need more friends)
&gt; The JIT doesn't kick in until a piece of code has been run over 1000 times, so if you run it just a small handful of times, it won't be fast. Somewhat unrelated but can this be adjusted to something like 100 times?
I'm the Joshua Landau who wrote the PEP. I'm struggling to understand what you're saying. Function *definition* is unchanged, function *calls* are changed. So: &gt;&gt;&gt; def foo(*bar, baz): print(bar, baz) ... &gt;&gt;&gt; foo(1, 2, 3) (1, 2) 3 would not happen but DEFAULTS = { ... } def foo(**kwargs): bar(**DEFAULTS, **kwargs) would now work.
(PEP writer here.) How would you like it to hande None?
Thanks for the clarification! I think I took the "`def func(*args, foo): pass`" section of the message and ran somewhere weird with it.
Should use EventSource for this purpose. Websockets are for full duplex applications.
I went to the comments for the same question :p
I mean, sure, there are things Python is great for. Talking about its library support is tangential to some extent, but possibly fair. But this one? If I can expose just as simple an API using PHP or even C, I think it fails the test of 'gotta love Python'.
Sure, you can run `pypy --jit threshold=100` and it will compile earlier, however this may not have the effect you want, it'll start compiling loops that are just run a handful of times, and really don't provide any value.
This is easily doable in like every language. I don't see what's special.
Kinda-sorta related: is it possible to save jitted application runs and reuse that for tests &amp; the like? I know there's a jit log you can feed to jitviewer but can you feed it to pypy to AOT compile when the program starts?
No, there is no AOT compilation or ability to save the state across processes.
:( Any chance that could be done to avoid slow ramp-up of jitting on process restart?
I see you have successfully installed pygame into python3 on os x. What is this sorcery I see before me? No binary package for python 3 pygame is the no 1 reason I don't use it.
Because we have to beat Ruby adepts in the condescension.
If you want *python* code to be "in the style" of "other languages" (for whatever nebulous definition of that you have), you will end up with horrible python code. I have *no* expectation that Rubyists should write pythonic code either, in fact I'd feel rather sorry for them if they did. Maybe you should try writing python in a style that a lisper understands, to make it easier for them to interpret?
Note, I don't think this is the intended use of `venv`. `venv` is supposed to be a library of functionality for things like virtualenv to use, so they no longer have to do many hacks needed before 3.3, not a direct user-facing feature itself.
I've yet to come up with a way, believe me if I had we'd be working on it. If you listen to http://radiofreepython.com/episodes/11/ we talk about why it's hard. We're working on other approaches to reduce the start-up time.
Cool project. Btw, remember, no tabs, 4 spaces.
Yeah ... worst tutorial ever. You do NOT use regular expressions for parsing HTML! Also, bad Python code.
I would strongly discourage using regular expressions to scrape the web. Try a library like beautiful soup. It uses lxml for parsing, which is the heavy lifting really. You could scrape with only lxml. But difficult for beginners. Regular expressions assume a structured predictable text. That's not always the case with HTML. Beautiful soup does a great job handling malformed tags. For flexible and approachable web scraping consider beautiful soup with lxml over regular expressions. 
&gt; TLDR: please point me in the right direction for getting started in writing web apps that will run off my home computer. Thanks. Sidebar -----&gt;
Yeap :D You're right. As I said, my first time doing this and I don't know if is right or bad. Thank you! 
The simplest way, imho, is: * easy_install django supervisord * cd &lt;project_dir&gt; * django-admin startproject &lt;project_name&gt; * add entry to supervisord.conf an entry for: python &lt;project_dir&gt;/&lt;project_name&gt;/manage.py runserver * set an entry in your router to forward port 8000 to the IP of your PC (192.168.something) * register a free dynamic domain, eg noip.com, and forward it to your external IP, ie that of your router * create your models.py file, read the Django web site for this * python manage.py syncdb * log into admin and start playing! You should be fine security wise with this setup, and should be up and going in an hour. Let me know which parts you want me to expand upon. Phillip.
Please don't make this kind of sloppy, incomplete and bad "tutorials/how-tos/walk-throughs".
Your guide is far superior. I bow to your far more advanced knowledge. Phillip.
My guess is that the maintainers of these projects no longer care about them, so the transfer to 3.0 isn't worth it. Additionally, with a lot of these projects there just aren't people with expertise of these module's sources, so no-one fixes it up. That said, what are you missing? The vast majority is (finally) now supporting Python 3. ^edited ^for ^grammar
Teach a man to fish. I pointed to official resources and entry points just like OP wanted. But actually I don't know why I did this ... because, you know, you are supposed to **read a subreddit's sidebar before posting** anything in it.
Very cool! Could you use TMX alongside Kivy?
http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#1732454
Two reasons I can see: a) some people are less convinced that Python 3 offers substantial improvements over 2.7. For example see this article: http://lucumr.pocoo.org/2011/12/7/thoughts-on-python3/ b) From a game theory perspective, I think the dominant strategy as a self-rational company / dev is still to use 2.7 and let other people figure out the transition and then jump on the wagon when the railroad is set.
Exactly! ^(I was too lazy to link it.) This is actually in the top 5 hits when you google for "html regex".
Ha, I figured you were so I threw it in as a reply! All aspiring web devs should read this. :)
On my Android app I cannot see any sidebar. The guide is basic as I know the guy can already program but I don't know how much research he has already done. I don't want to go into Django in case he's convinced himself he wants to use Flask or Bottle. I could link to supervisord docs but not so easy on phone and he has Google anyway. I think you are being a little uptight. Phillip.
b) is why i am still on 2.7. my primary focus is making stuff that works first. when 3.0 is sorted and there are zero obstacles*, i'll switch to that (probably triggered along by some essential library which is 3.0+ only) * for all i know, this is already the case
Then why did you reply in the first place? Were you afraid he won't get any answers? And I bet your app is able to show the sidebar.
&gt; Try a library like beautiful soup. It uses lxml for parsing, which is the heavy lifting really. You could scrape with only lxml. But difficult for beginners. You've got this the wrong way around. BeautifulSoup is pure Python (internally it actually uses regexes), whereas lxml is C-based with Python bindings. lxml has a [compatibility layer for BeautifulSoup](http://lxml.de/elementsoup.html#parsing-with-the-soupparser) so code written for BeautifulSoup will work with lxml also. lxml also supports css-selection expressions, which was my preferred method of navigating scraped DOMs when I worked with it. In my experience, lxml is faster and more tolerant of malformed HTML than BeautifulSoup. It also has support for more different ways of navigating DOMs for scraping. I don't really understand why everyone pushes BeautifulSoup when lxml seems to be far superior.
You should check out [Plumbum](http://plumbum.readthedocs.org/en/latest/) if you do much in the way of command-line invocation from your scripts. It also provides a nice framework for things like flags and help messages when you're making a CLI app.
Wow I just realized that my apps also don't show the sidebar. 
Python 3.0 is not backwards compatible. To use it, *all* of your dependencies need to use it. Those library developers aren't going to be super keen on making the switch, seeing as most people are still on 2.7. Vicious cycle.
How the hell has this got 73 upvotes? 
or [x for y in a for x in y] but I prefer a version that handles non-iterables too because I use it on lists that could contain numbers or numpy arrays.
Thanks :-)
I don't understand why the convention is that None isn't iterable and can't be added to a list. Without having thought about it too carefully, it seems like a lot of code could be simpler if [] + None didn't raise an exception. Similarly, it would be nice if *None worked. Then you wouldn't have to test every function argument, or use [] as the default with all the error potential that brings. Of course changing the behavior of *None is a bigger issue than this PEP and would break existing code.
I don't understand what's wrong with chain.from_iterable (or your famous-but-unsightly comprehension version) for what you want; what is your expected result and what are you getting instead?
Is Ruby still a thing?
Eeek. Yes, this PEP will not solve your problem. Additionally, you say "you wouldn't have to (...) use [] as the default with all the error potential that brings"; how is using "[]" as the default more error-prone than having iterable None? Iterable None or making "None" a type-agnostic version of "0" is really not a very Pythonic idea, as Python would rather you know when things go wrong and deal with them than silently (implicitly) passing them on. In fact, Python's remarkably fussy about things like addition, type wise: &gt;&gt;&gt; [] + () Traceback (most recent call last): File "&lt;input&gt;", line 1, in &lt;module&gt; TypeError: can only concatenate list (not "tuple") to list If None could add to lists, that would be really quite odd.
 list(chain.from_iterable([np.arange(5), [1,2,3], 17])) TypeError: 'int' object is not iterable Which is fine, but since I mainly flatten combinations of scalars and arrays, I rolled my own that just sticks non-iterables into the result as-is. A typical application is to take machine learning model parameters of varying shapes and flatten them into a single vector suitable for scipy optimization routines. flatten([np.arange(5), [1,2,3], 17]) [0, 1, 2, 3, 4, 1, 2, 3, 17]
Also, I meant to point out that your "later email" actually precedes the one posted at the top by about a week.
Yup, I guess that's all dandy then. This PEP could help the explicit cases, so you could write that last one as [*np.arange(5), *[1,2,3], 17] but you'll still need your custom flatten for other cases. Have a nice day.
we'll make it provided you'll write a comprehensive answer to the question "is this module the same as the module we had in the previous run". Note that code equality is not good enough (even bit to bit), since you have to compare globals that might come from wherever or generally be non-comparable. 
Thanks for this. And thanks for the offer to expand if needed. This'll get me started.
Thanks for these points. I do want to host it off my own machine because it's solely for my use and to learn stuff.
PIL is a bit frustrating, since I used it a bit for my board game helper apps what's up with that?
I work in a research lab so my work environment is less slanted towards "do what works, screw elegance", but I gotta say I really really like Python3 and feel crippled without it. The gains are larger than I thought they would be. It's the small things.
Yeah fijal's comments make both clear, it's basically à problem of cache invalidation without the ability to add any invalidation hook right? And of course if it's provided as an optional and opt-in feature people will start using it incorrectly (by not throwing out the jit cache when things change) then report crappy "bugs" when it segfaults all over the place. 
Yeah, it was a pain just because there's no documentation but it actually is really simple. You just need to make sure the source installs in a where python3 can access it (for me this is /usr/local/lib/python3.3/site-packages) but it could be anywhere you configure it to be. There's a great [homebrew tutorial here](http://florian-berger.de/en/articles/installing-pygame-for-python-3-on-os-x) specifically for installing pygame on python 3. Also note there are different pip commands for python2.x and 3.x. The defaul 'pip' is usually set to 2, so make sure to manually put in pip-3.3 ... I don't remember if this made a difference, but it doesn't hurt to try. Here's one more tutorial [on installing it from the source](http://jalada.co.uk/2011/06/17/installing-pygame-on-os-x-with-a-homebrew-python-2-7-install.html) that should also work if you put it in a python 3 directory like I mentioned earlier. Just fiddle around until it successfully imports. Hope it works for you.
Not sure, I haven't used kivy. This particular tmx module was designed for use with pygame, but TMX itself is an open source XML language, so if you were to make the library compatible with kivy then yes it would work.
Eh I know...PEP 8 strongly suggests using spaces but they just seem like a pain to me. Even more so after [reading this article](http://lea.verou.me/2012/01/why-tabs-are-clearly-superior/) about them [as well things like this](http://stackoverflow.com/a/1777008/2491623), so I never understood the reason. Maybe if you convince me I could switch over. My text editor can easily convert them.
You and AdShea both asked the same thing at the same time; and I elaborated more in my reply to [her/him](http://www.reddit.com/r/Python/comments/1ibnaz/recognizing_handwritten_digits_in_python/cb36wxz)
Obviously you can write this in basically any other language, and you might even get better performance, but the fact is that when I was asked if I could write a program that analyzes some data from imdb, just to prove some silly theory about TV shows ratings, two searches came to mind: 1 - imdb api 2 - imdbpy So why you gotta love Python? Because I don't think I would've ever written that little program if the second search hadn't produce such a simple and convenient solution. Edit - Damn you formatting!
I made tutorial how to do the same with rauth http://www.vurt.ru/eng/2013/06/using-flask-and-rauth-for-github-authentication/ 
Well, you still have to be a rubist if you want to be the "Rock Star" of the programming world.
To expand on that: PIL development is pretty much dead, Pillow is a fork that you should be able to use as a drop in replacement. And it supports Python 3.
My stance on this has changed lately. I was in the same camp with you but, as we have moved away from a monolithic stack to a combination of web services and mq we can spin up the interpreter of our choosing and migrate where it makes sense. 
Got it. I keep forgetting that tabs are configured differently on different machines. It just seems sensical to keep them at a length of 4 spaces by default. Anyway, thanks for the info. I think I'll be switching over on my python projects to make it easier for everyone. 
For clarification: &gt;Beautiful Soup sits on top of popular Python parsers like lxml and html5lib, allowing you to try out different parsing strategies or trade speed for flexibility. That's the official documentation. I'm not sure how I have it the wrong way around. You are perhaps thinking of version 3, which is dated, and the last time BeautifulSoup performed it's own parsing. To be clear, you **must** install a parser, like lxml, in order to use BeautifulSoup as of 4.x. Put another way, &gt;It uses lxml for parsing, which is the heavy lifting really. You could scrape with only lxml. But difficult for beginners. lxml is faster, which is why BeautifulSoup separated parsing and largely abstracts lxml. To say it is somehow different in tolerance of malformed HTML is disingenuous, seeing as lxml is most typically doing the HTML parsing. With due respect, your experience seems more with lxml than BeautifulSoup so it is easy to see how you wouldn't understand why people push it. As I wrote, lxml isn't as approachable initially, but it is what does the heavy lifting and could be used individually. 
My critique was two-fold. First, bitcoind is a binary dependency for a Python app. I don't think the options in Python are 100% mature yet, but they do exist. I didn't research it thoroughly, I admit. Second, bitcoind is a full Bitcoin client, which means that it must have a complete copy of the blockchain and constant network connectivity to function. There's no need for every single client to have that, as a thin client would let you poll a server for the current state of an address instead of calculate it manually. Finally - and most importantly - *you shouldn't be generating Bitcoin addresses on your production server*. Doing so means that your private keys are stored there, and are therefor as open to compromise as anything else on the system. If you *must* do that, then at least immediately send the funds to a "cold storage" address upon verification, to limit the attack surface. Still, it would be better to generate a large number of keypairs offline, and load only the public keys onto your server. Pop one key off the stack for each transaction, then watch for that address to receive funds by polling a public API (like Blockchain.info). Once funds are there and the transaction is confirmed to your satisfaction, then mark the order as paid and move on with life. The funds would be absolutely safe at their destinations as long as necessary. In short, maintaining an air gap between your private keys and a network-enabled machine is essential. Failing that, as soon as funds hit your payment addresses you forward them to a single collection account where the private key is not on a network-connected machine.
I'm not quite sure if you're joking or if you don't realize the irony of what you just wrote.
oh i realized ;)
Would something like TMX be appropriate for an implementation of Carcassonne? (here is a screenshot from the Java implementation: http://jcloisterzone.com/img/screenshot.jpg)
Free 
Heroku free tier is free. Up to 750 free dyno hours and 1 starter-tier database for each app up to 10 apps. Way more than enough for a static site and enough for a lot of simple dynamic sites, too.
Heroku can only service one request at a time per dyno. Github deploys your site via a CDN. For a static site, if you expect any more than a trivial amount of traffic, github would be a noticeable improvement over heroku's free tier.
Based on the picture it looks like it would be perfect for that. [The tutorial](http://gamedev.tutsplus.com/tutorials/implementation/parsing-tiled-tmx-format-maps-in-your-own-game-engine/) outlines some of the features that might be appealing for that project
Because the python people aren't as smart as the Linux kernel guys: you don't break people's code just because you want to. 
I really love the "select a bit of text and send to interactive window" feature where you can almost just execute arbitrary blocks of code on the fly - similar to the smalltalk development experience. It's not exactly the same, but it's the closest thing I've come across. Seriously, this tool is the only thing keeping me on Windows. So much love, so much hate! Mostly because the debugger experience is way better than any other tool available.
He actually does start using BeautifulSoup in later videos
Thanks!
Thanks! 
Thanks!
I'm actually working on a python implementation of 8tracks.com. http://github.com/ramblingpirate/8tracks The only issues I'm having is blocking gstreamer from playing the next track until it's finished with the first :'( but you're more than welcome to looking at my code and implementing something like what I have. It's probably not the most elegant way of doing things, but it works beautifully. Also, gstreamer, as a bonus, is capable of playing (I think) anything that ffmpeg can play/stream.
I'm not sure I get what Static Flask means, and googling isn't helping a ton. Could someone enlighten me?
r/learnpython
Python 2.7 is still supported and Python 3.3 had 2.7 compatibility things added. Matplotlib (a major requirement for me) just recently got Python 3 support. The day after Python 2.7 is not supported, I'll upgrade. I have to find a 3D visualization code since I can't use VTK as well as learn PyQt instead of wxPython since that thing seems pretty dead.
As in stays the same, not dynamic
It's a decent amount of work to update libraries to be compatible with 3+ AND &lt;=2.7 simultaneously. Also, lots of projects have been abandoned by their maintainers and are sort of stuck in a no-mans land. Sticking with 2.7 is the path of least resistance and there's not much risk associated with it.
virtualenvwrapper wraps virtualenv.
You can also use [sockjs-tornado](https://github.com/mrjoes/sockjs-tornado) which is a drop-in replacement for the tornado websocket api that provides transparent fallbacks for browsers that don't support websockets.
I think PyRu would have been a better name.
Doesn't really say what it is.
&gt; RuPy is a unique conference that brings together communities from different state-of-the-art programming languages Ruby, Python, JavaScript, Clojure and related technologies.
I'm afraid I might disagree with his sentiment here a little bit. I don't believe that it's pivotal to know the number of instructions, but I do believe people should know roughly what the underlying mechanisms are. In the case of print, it's not a big deal unless you're dealing with a failure for some strange reason, but when you start talking about things like concurrency, it can become important to have at least a somewhat functional knowledge of what's going on under the hood when you start a thread or a process. But no, I would agree that other than for pure metadata, instruction counts aren't pivotal in Python, and I find it unlikely that someone in IRC asking about getting close to the metal is going to be able to vastly improve the efficiency of print unless they have a very specific and unusual application in mind.
Anyone knows if there is a way to get your voting history? Doesn't seem to be supported in any module available, and IMDB forbids scrapping...
I think this reasoning could be useful with lower level languages ( C? Anyone? ) where you can effectively grasp something of what's going on under the hood. Languages like python already take care of "under-the-hood" possible issues, so if you're going your entire life with Python, I think you can just ignore this stuff...
Hmm, I suppose you bring up a good point about going to IRC for experts. Most of what I've seen in IRC when I used to hang out there was... not constructive. "Teach me to write [insert language of the month here]" came up a lot. Perhaps I was in the wrong IRCs. From the article, it sounded more like either someone with a C background, or someone new who just learned about instruction counts and wanted to apply it to Python. Did a quick Google, didn't turn up a lot, but it would at least be a starting point.
The author makes it clear that this number is pretty useless. &gt;But number of instructions? Meh. It's more out of pure curiosity and the trill of finding a way to measure this.
Thanks. I didn't understand what you meant about the comments, can you make it more clear. Also, do you think chaining is better or worse?
How would I know from the sidebar that https://github.com/kennethreitz/python-guide/blob/master/docs/scenarios/web.rst is relevant to this question? /r/learnpython/wiki/index /r/python/wiki/index
I know raw x86 assembly is like 10 instructions, but then again one of those is a call to print so that probably adds a lot
It's weird that some people are discouraging the investigation of such a simple question. Maybe it's the useless question ever (`print x` is not even CPU bound), but why discourage curiosity, which is a very useful tool to programmers? Hacking is all about experimentation. I bet that most hackers work on about five useless projects for any other useful one. (This is more in response to some comments on the blog and here, rather than about the article itself.)
By clicking on *The Hitchhiker's Guide to Python!*.
my main problem is that for all web-dev stuff this is super easy. Just pull flask and any other relevant packages from requirements.txt with pip and you're set. However, I do most of my work on NumPy, SciPy, matplotlib, and PyQt. These all require non-python pacakges being prebuilt and whatnot. Does this approach help with this problem?
All of this guy's posts seem like he'd be much happier with C or Delphi (which has a contingent for which no optimization is too premature) than with Python. 
Thanks for the suggestions. 1. What are the advantages of sphinxdocs over HTML. 2. Added a License. 3. What are the new style classes? Any Python documentation links?
python noob here, trying to get out of my comfort zone, I ran into some problems. I tried to install it with pip First I made sure it was in PyPI. It was https://pypi.python.org/pypi/IMDbPY/4.9 So I did this from command line : sudo pip install IMDbPY then I copy / pasted his code into a file (experiment225.py) and ran it (python 3.1) I fixed the print error right away, but am stuck at this : from imdb import IMDb ImportError: No module named imdb So I guess Im confused as to where that file imdb gets put and how to install and use something using pip. 
builder.py: 1. Shouldn't QRCodeBuilder inherit from 'object'? 2. ____init____() - Instead of: elif not isinstance(data, str): self.data = str(data) else: self.data = data Why not: else: self.data = str(data) 3. What's the point of having an import statement inside grouper() or other methods?, have you noticed you're importing itertools twice? 4. No need to check 'if x == 0'. You can replace with 'if not x'. I like the idea, and the simplicity of your API. Despite that, I personally would go for something like: url = 'bla bla return instance()' url.create_qr('filename.suffix', scale=bla) I would then continue to create the file based on the suffix supplied, or raise an exception if that suffix isn't supported. I find that simpler as a user. All in all, I really like your code. You should also be commended for choosing Python 3. Well done! 
&gt; Only import entire modules, never individual symbols from a module. what? i don’t want to do `class MyShit(PyQt4.QtGui.QWidget): …`, that’s plain stupid. and especially their example that we should do `my_auth = auth_util.Authorize()` instead of importing the class symbol is super redundant. and later they contradict themselves recommending `from app import App`… *and they don’t like relative imports* like `import .models`. wtf? --- i’ll continue to do from PyQt4.QtGui import QWidget, QLabel from .submodule import MyClass clean, clear, terse. --- apart from that quite nice. they could have just scrapped the 79 char limit instead of grudgingly working around it, though. and used tabs :P
I run a Pelican blog for one of my projects this way. Works like a champion.
Isn't it dangerous to skip a test that is too slow? If slow, then something must be wrong about it.
http://pyopengl.sourceforge.net/
You have me confused with someone else. You may not like the channel as a whole, but I try hard to be polite and respectful. If you and I have gotten tangled up in the past, I'd like to revisit the discussion to see where we ran off the rails. Angering people is the last thing I want to do.
You're polite, I never said you weren't. However you and a lot of the 'big' posters in that channel are dismissive about new ideas or alternate styles of using Python. An altercation between you and I which sticks out to me is when I came in talking about a fun implementation of a fully usable switch statement in Python. You literally just said "This isn't the Python way, let's not help him!" when I clearly, clearly stated many times that I was doing it for fun. It's just not conducive to a fun learning environment, there's this horrible dictatorship feel to #python as the One True Way, with a reluctance to accept that other languages or tools may get certain things a lot better.
I'm sorry if I put you off. I may have said something like, "I don't want to help make that work, it isn't something I would use." Next time we chat in #python, I will try to be more aware of my tone (unless you start with, "so full of shit.") IRC is hard: do I owe you support? I want to help people, but frankly, if the discussion is unpleasant for some reason, I'm unlikely to continue. Talking about a construct that I find silly or counterproductive might be something I don't want to do, even if you find it fun. I definitely don't want the feel of #python to be elitist or difficult, and I try hard to be welcoming and helpful. If you see me slipping again, feel free to point it out. 
No-one owes anyone an ounce of anything on IRC, that's for definite. However, I'm merely pointing out that the vast majority of highly knowledgeable people are very dismissive (yourself included) due to their apparent superior skill with Python. There's also a not-insignificant group of people (again, yourself included) who seem to use Python and nothing but, yet dismiss ideas and practices from other languages as if they are out to dilute the purity of Python. If you thought for a minute, you will see this to be definitely true. Regarding the switch statement, this again is something I find quite funny since nearly all modern languages still have it and it's a far superior option over if/else chains, however, Python noobies are taught that since Python chose to not include it therefore a switch is bad and must never be used ever. This is such poor form and something which is done far more often than is acceptable.
And your back again. Still breaking TOS. 
Haha, landed my current gig and got to choose; Py3 it is. It's a bit painful migrating some projects by myself, but it feels right.
But of course that includes the instructions to actually run python which then interprets "print".
Well, they say that you can do sub-modules. It would look like `from PyQt4 import QtGui`, then `class MyShit(QtGui.QWidget)`. Still a stupid rule though. With things like PyQt or Django it's horribly inefficient and lots of extra dot notation to import entire modules. It kind of takes the point out of `django.shortcuts`, IMO.
Yes this is definitely true. I am currently on a different machine so I cant make a fair comparison but when I am back on the previous machine I will subtract perf stat python -c "" from perf stat python -c "print" 
&gt;builder.py: &gt; 1. Shouldn't QRCodeBuilder inherit from 'object'? It does. Python 3 has no old style classes, so `class Foo:` is exactly equivalent to `class Foo(object):`
Upvote, purely for writing python 3 code &lt;3
I'm not sure I understand you, specially because I was already combining python and php. (My web host had python but without any mysql module installed) So I ran a python script for logic, wich relied on php scripts for writing to database. Both communicated with urllib2 and stdin Maybe i can now do another php script for front end and form data trasnsmission (I expect php allows some easy form of cgi or fastcgi with php) So I'd end using php files (for front end cgi-emulation and db import-export) and python for manipulation... lol, its weird 
There is no import antigravity. [Flask](http://flask.pocoo.org/) is pretty easy to get started. It works great with WSGI.
It can be done in two; the conversion piece is only one, even. mov eax, 5 add eax, 48 Now `eax` holds the ASCII character "5". Substitute in any other number and it'll work. ^(Yes I am only half-serious.)
According to their own mail archive, the current release of this module is broken: http://sourceforge.net/mailarchive/message.php?msg_id=30171631. It can no longer do movie searches. Looks like it might be fixed in trunk though.
Yeah, `shutil.copy` could save a couple lines, but I don't think `os.rename` would have the same atomicity properties. What if we're interrupted after renaming? There's a short period where the original file never exists.
You're making generalizations about the Python community. Some will say, "that's the way it is, it must be the best," but they are not the ones to listen to. Read the PEP that explains why there isn't a switch statement: http://www.python.org/dev/peps/pep-3103/ The Python core devs aren't stupid and they aren't besotted zealots. You can find the history of these discussions and understand what led to those decisions.
you might: * compile: [`python -m compileall`](http://docs.python.org/2/library/compileall.html) * adjust `sys.path` * look into teh `dis` module and/or python-ptrace
Yeah, that sounds terrible -- and fragile. Could you migrate the whole thing (prestashop included) to a VPS? These days they are pretty cheap, you could almost certainly get it working on a [$5 one from Digital Ocean](https://www.digitalocean.com/pricing). Then you'd be able to host both on the same system, set up as you'd like?
I know you've said that migration to a new server is pretty much a no go.. You don't have any linux installation knowledge, so that limits it even further. The whole python for logic communicating with php for database sounds like a sort of abomination, but obviously something you've had to do to work around your host. first steps:- * You don't know whether they will make the changes yet. Well, IMO they've pushed you onto nginx, so they kind of owe it to you to assist you with getting python working on nginx? * Push to get a python / mysql driver installed while you're at it (Doesn't it come with a default install?! Failing that, perhaps look at taking a dump of your mysql db, and finding a new host that supports you. Right now you have a bunch of bandaids in place, looking to add a few more, your software stack is speaking to you right now, you should listen :) edit: s/dumb/dump
I'd +1 the digital ocean option, except for this: &gt; I can do no linux, no server install/knowledge makes it harder 
as far as super simple wsgi for python, I'd put forward flask or bottle, bottle is simple because its literally download/import one file, flask is built on a couple of different libs by the same author (bias warning: I'm currently writing an app based on bottle)
Crap, missed that part. Yeah. The other option would be to move the whole thing to a shared host that supports python.
Developer at the [Center for Open Science](http://centerforopenscience.org). I support the sciences by writing software that helps researchers do their work, while encouraging open data practices. Basically, I want to see the ethos of the F/OSS community applied to academia. Prior to this, I worked for FedEx Freight. There, I designed and managed a small custom enterprise reporting system with a focus on identifying and correcting the causes of lost and damaged shipments.
I just meant printing the string, not converting, but one of those calls printf which is probably 1000s right there. 
Thanks!
&gt; Exception: for third-party code, where the module documentation explicitly says to import individual symbols. From http://pyramid.readthedocs.org/en/latest/designdefense.html#application-programmers-don-t-control-the-module-scope-codepath-import-time-side-effects-are-evil : &gt; Global-registry-mutating microframework programmers therefore will at some point need to start reading the tea leaves about what might happen if module scope code gets executed more than once like we do in the previous paragraph. When Python programmers assume they can use the module-scope codepath to run arbitrary code (especially code which populates an external registry), and this assumption is challenged by reality, the application developer is often required to undergo a painful, meticulous debugging process to find the root cause of an inevitably obscure symptom. The solution is often to rearrange application import ordering or move an import statement from module-scope into a function body. The rationale for doing so can never be expressed adequately in the checkin message which accompanies the fix and can’t be documented succinctly enough for the benefit of the rest of the development team so that the problem never happens again. It will happen again, especially if you are working on a project with other people who haven’t yet internalized the lessons you learned while you stepped through module-scope code using pdb. This is a really pretty poor situation to find yourself in as an application developer: you probably didn’t even know your or your team signed up for the job, because the documentation offered by decorator-based microframeworks don’t warn you about it. 
With the overly broad language of the Computer Fraud and Abuse Act (CFAA), using a site against the terms of use is unauthorized access, and unauthorized access is a felony.
Wakari provides access to the full Anaconda Accelerate python distribution. So all of NumPy, SciPy, Pandas, and MatPlotlib are there. PyQt is hard to take advantage of because Wakari is a web platform. I also work for continuum. 
&gt; No need to check 'if x == 0'. You can replace with 'if not x'. If using integers his version is better just for readability sake
&gt; It's a common beginner mistake to micro-optimize like that. The important thing is to know whether your filter() or listcomp will be linear or quadratic, for example. http://wiki.python.org/moin/TimeComplexity and http://bigocheatsheet.com/ are great references for complexity analysis. I think there is an optimum balance between maintainable patterns and mature optimization; and -- for the sake of [parallelization](https://en.wikipedia.org/wiki/Parallel_computing) -- it is good to get in the pattern of factoring things out into closures/kernel methods (without [side effects](https://en.wikipedia.org/wiki/Side_effect_\(computer_science\))) that can be applied to iterables. &gt; The difference between filter() and a listcomp is incredibly unlikely to make a difference in the running time of your program. In Python 2, `filter` consumes the entire iterable and returns a `list`, which may affect running time and memory usage. [`filter` in Python 3 is `itertools.ifilter` in Python 2](https://github.com/nandoflorestan/nine/blob/master/nine/__init__.py#L27).
You should really take step 3 seriously. You can get a cheap vps with digital ocean, or ramnode, i mean, we're talking a few bucks a month tops, coffee money. (I have a vps with digital ocean, two with ramnode, and one with linode).. * You make use of the [linode library](https://library.linode.com/) (it applies to any vps you use, you can literally cut and paste commands into a terminal and run them) * Security is a genuine issue, [theres this basic guide](http://plusbryan.com/my-first-5-minutes-on-a-server-or-essential-security-for-linux-servers), saw this [originally on HN](https://news.ycombinator.com/item?id=5316093) and it's worth reading the comments on the link too
I'm sorry, but I really do like my tabs. Substituting 1 character with 4 also isn't a good sell to me.
As someone learning python and starting in version 3, I find this very helpful.
These hosts support Python: * http://wiki.python.org/moin/OtherCommercialHosts * http://wiki.python.org/moin/SpecializedCommercialHosts * https://code.djangoproject.com/wiki/DjangoFriendlyWebHosts
You used "projects" instead of "project's" (or maybe "projects'") twice on that page...
Complex numbers also have properties `.real` and `.imag` and the method `conjugate()`. And all of the usual mathematical operators are overloaded, except for modulus: &gt;&gt;&gt; ((1 + 3j)**2).real -8.0 
Just wondering, why is it `j` and not `i`?
&gt;[In electrical engineering and related fields, the imaginary unit is often denoted by j to avoid confusion with electrical current as a function of time, traditionally denoted by i\(t\) or just i.](https://en.wikipedia.org/wiki/Imaginary_unit#Alternative_notations) [There was a request to change the notation from j to i back in 2010, but it was closed with a wontfix.](http://bugs.python.org/issue10562)
as of Python 2.7 there *is* `import antigravity` Flask is not going to work on a plain old school shared host that only has Apache + CGI + PHP running. He won't have permissions to install anything from the cheeseshop, and he likely won't be able to run a daemon himself and proxy through Apache either. His best bet will be to find a host that supports python well.
Read the article. You have to account for all the initialization. He is talking about the instructions for the print statement, not the instructions to run the whole program.
Did you even read the article? Even the author says the number doesn't really matter. He's just curious.
Also i is used way more often in programming than j. For indexes (even though with python you don't need it as much because of the easy way to iterate over collections)
You will never use this. :)
Thanks for the heads up! I am not a native English speaker (nor do I live in an English speaking country), so even doing my best, mistakes and awkwardness are bound to creep in my writings. But that's a poor excuse for not having a native speaker review the texts...
I don't think whitespace significance is as error-prone as you say it is. Reddit's Markdown is whitespace sensitive (at least in the live preview box -- I hope it is not lying to me): *emphasis* vs * emphasis * and super^script versus super ^ script, but `verbatim` and ` verbatim ` (...it's not even *consistent!*). *emphasis **does not nest** either*. [God help you with links with parentheses in them](http://blabla.com/foo_(bar)). It's a bit of a mess, really, but it's reliable enough, because edge cases don't happen much in normal use. I mean, I didn't even know about these quirks before I tried to find them. Quaint *is* more of a techie's tool, though. It probably requires more learning upfront than some other markup languages. It compensates by being extremely consistent: in some sense, it is either the case that all of its features share some quirk, or none of them do. Anyhow, it is probably not suited for all uses :) 
I feel like I'm the only one annoyed with this type of post. Your not "Doing &lt;functionality&gt; in &lt;low number of lines&gt;." If your just importing a library and running it. #This is a recursive factorial function in 2 lines fac = lambda x: 1 if x &lt; 1 else x*fac(x-1) print fac(4) #This is not a factorial in 2 lines import Nonstandardlibraryfactorial print Nonstandardlibraryfactorial.run(4) "But oh it's only 2 lines for the person using the library" Yes but it's not in the standard library so I can't rely on it being there. Look I'm fine with people getting the message out that we all now have a new library that does some cool thing, just say "PyQRCode - a library that makes QR codes written in python 3."
 &gt;&gt; 1j**2 (-1+0j) &gt;&gt;&gt; 
Disapointing: &gt;&gt;&gt; import math &gt;&gt;&gt; math.sqrt(-1) traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; ValueError: math domain error 
meh... &gt;&gt;&gt; math.sqrt(-1+0j) Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; TypeError: can't convert complex to float &gt;&gt;&gt; 
Try: import cmath cmath.sqrt(-1+0j) You don't want to do complex math, when it doesn't make sense.
Precedence man
I've just seen your post this morning, I believe that we covered all your points in IRC last night.
not everybody is american.
good point, but only if you misuse decorators. &gt; Astute readers may notice that Pyramid has configuration decorators too. Aha! Don’t these decorators have the same problems? No. These decorators do not populate an external Python module when they are executed. They only mutate the functions (and classes and methods) they’re attached to. good thing i never wrote a decorator that has module-populating side effects when executed.
impressive examples, just one thing: i’d use the new formatting syntax! it’s mightier and prettier. e.g. `'%(type)smeister' % {'type': 'Dude'}` returns `'Dudemeister'` without an “s”, since the “s” is part of the format syntax: strange. also what if you additionally want positional arguments? impossible! with the new syntax: `'{} is the {type}meister!'.format('Keith', type='Dude')`: no problem to mix, no strange “s”. also `'%s' % something` – if `something` happens to be a tuple, this breaks. you’ll have to do the ugly `'%s' % (something,)` to be safe.
The lack of "switch" is one of my pet peeves about python, even if I know the - and largely agree with - reasons. So, I'd love to see your implementation!
I'll have to dig it out, it's deceptively simple actually. EDIT: Just re-wrote it for kicks: https://gist.github.com/AeroNotix/6027648
Do you have ssh access to this host? If so create a virtual enviroment so you can install mysql modules, gunicorn and everything else. Once you have a python wsgi server: gunicorn or cherrypy or werkzeug you can (maybe) proxy nginx to the python server. Another edit: why not tell us what hosting is it?
You're right, and but as far as I know 0x is the only main stream convention used for hex, and it is pretty much universally understood by all programmers (and used all the time). But both i and j are common notations for imaginary numbers. I am not sure what is the most commonly used, but neither one seems to be much more common that the other, i is used by mathematicians, and j by engineers in my experience. Given that you have two equally used notations, it makes sense to go with the one that has the least cross over with other commonly used variables for readability - even if the usage would be completely unambiguous. Or at least that is the justification I would use.
Reading bug reports closed with a wontfix usually shows there is a good answer to "why not?". I think these two fragments summed up the conversation of i vs j best: &gt; It's a bit of no-win situtation. None of the core devs see enough possible benefit to warrant the disruption it would cause. Years of Python being used in the scientific community has shown that the current use of 'j' has not been a problem. and &gt; It may not have been obvious, but most of the comments here including mine were not serious even when they did not include smileys. Nothing will happen here. Time to move on. and the BDFL with some closing words: &gt; This will not be fixed. For one thing, the letter 'i' or upper case 'I' look too much like digits. The way numbers are parsed either by the language parser (in source code) or by the built-in functions (int, float, complex) should not be localizable or configurable in any way; that's asking for huge disappointments down the road. If you want to parse complex numbers using 'i' instead of 'j', you have plenty of solutions available already.
(-1+0j)**0.5 works
Most standard or default text editors default a tab as 8 chars.
coding the matrix with linear programming ftw
I'd rather go with the idea that Python has more affinity with EE and engineering in general than with Math - it is, most of all, a pragmatic language that focuses more on the practical things happening inside a computer than the theoretical underpinnings (although it seems that it *is* used a lot in scientific programming). BTW, most programming languages provide complex numbers as a library rather than built-in types; of those languages I could find that do have a built-in complex type, Scheme and Go use `1+3i`, Python uses `1+3j`, while the others use a completely non-mathy syntax, e.g. `#C(1 3)` in Common Lisp or `(1, 3)` in FORTRAN.
Too much work and possibly breakage of old code for no good benefit IMHO.
Surprisingly, you don't need the parenthesis around 10+20j. Python treats the 10+20j as one object. `10+20j.real` returns 10.
Whoa! What is this sorcery? &gt;&gt;&gt; 10+(20j.real) 10.0 &gt;&gt;&gt; 5*(10+(20j.real)) 50.0 Probably some optimization, I guess. I've never seen it before.
I use this in my imagination all the time. 
I don't understand what is surprising about your quote
1. Sphinxdocs are written in Restructured text, which similar to Markdown and then rendered into HTML. The advantage is that you spend your time writing documentation rather than fixing HTML. 2. Great on the license! 3. New style classes follow the current MRO, making inheritance predictable and sane. Just do this with your code: class MyClass(object): # do stuff See how that has an (object) before the colon?
Well if you use .real 20j is looked at as a complex number which always has the form: n + m*i n beeing the real part and m*i beeing the imaginary part. So its something like: 10 + 30i With 10 beeing the real part and 30i beeing the imaginary one. So if you have 20j and you call 20j.real, python interprets 20j as the complex number: 0 + 20j which real part is 0.
j is not actually a *very* common notation for imaginary numbers, *only* EEs use it. 99.9% use i, I'm pretty sure -- mathematicians, physicists, and all types of engineering disciplines except electronics.
True, true. However, when discussing a US site (imdb) on a US site (reddit), I tend to default to US laws unless otherwise stated.
Nothing really. Just a brain fart of mine. I think metl_lord's statement that "Python treats the 10+20j as one object" threw me off. `10+20j.real` doesn't return 10 because of that, but simply because the real part of `20j` is 0.
 I don't know, the ~15k instructions (or cycles, at 0.86 ins/cycle) per syscall is a pretty interesting number, in my opinion. It means that you're limited to about 100,000 simple syscalls per second (even if your IO throughput allows more), and you'd be eating 100% CPU doing that. It means that switching from `printf` to `write` (or even more relevant, caching results of some read-only syscalls) can speed up your C program by a factor of 10,000, or your Python program by a factor of 100, that's nothing to sneeze at. It's better to have that knowledge in the back of your head than to try to rediscover it by profiling. Another important thing is being able to make a very rough estimate of how long something would take. Less than a second, a minute, and hour. Like, I'm want to read 1Gb file into a string and run a regexp on it, should I use Python at all, how should I use it from the start (*premature pessimization* might not be a root of all evil, but still is damn annoying), and then, as I said in the above paragraph, it would be nice to have some idea of how to optimize it _before_ reaching for a profiler (kind of like it's nice to have an idea how something important works right there in your head instead of spending hours on learning it). Finally, to tie all these points together, "you use Python when you don't care about performance" is patent bullshit if your Python scripts routinely take a second or more to execute. Because _of course_ you'd care about the difference between a second and ten minutes.
i've just got a cheap shared hosting. yeah, I guess i should have gone first into php, but as i said before, i hate it. Python looks and feels simple and friendly to me, whereas any unexpected result or behavior in php would put me in a unknown zone. finally, i'll go to the local python - external php (for db comms) solution. this will give me the most portable environment with the least hassle and still with the 99 pct of code in python.
You will never use this, for *real* 
This is very useful. Thank you.
No it doesn't, your example doesn't differentiate anything as the real part of 20j is zero. In [1]: 10+20j.imag Out[1]: 30.0 This does two parts -- imag(20j) == 20, and then add that to 10. Granted yes if you write `10+20j` it will return `(10+20j)` which will be treated as one object.
Could you enumerate a few of those small things? I imagine unicode is less of a pain in py3k, but anything else?
It's not. Soft tabs have a fixed with. Hard tabs to do not.
That's nonsense. Where do you all get this kind of ideas? One TAB is one character. It's always been one character.
Correct. I just noticed this.
MATLAB understands both `i` and `j` but uses `i` when printing output. Octave will accept any of `iIjJ`, and prints as `i`.
So? How often do you actually change the width of how your tabs are displayed, and how does that make it any easier to mix your code with code from others which will almost certainly follow the standard convention?
How does the new class style help me? I only use inheritence for the Chrome User-agent part. Or is it for the users to inherit library functions?
Yeah, but not *very* common. :P I'm sure some people use it, but I'm pretty sure the majority learns it as "i" in school. I hardly ever see "j" used.
I am not breaking TOS. According to the Readme and the License files the user breaks TOS.
the use of imaginary numbers is something that 99% of programmers never need, why is such a snarky comment upvoted so much?
&gt;good point, but only if you misuse decorators. Import time side effects are an issue with module globals. The problem is specifically demonstrable with decorators that attempt to use globals.
I saw this same documentation quote too, but when I went to look at the BeautifulSoup source, I couldn't find any mention of lxml as a requirement, but I could still see Python-based xml parsing... so I'm not sure what to think about BeautifulSoup now. Perhaps I was looking in the wrong place? In any case, given lxml contains a BeautifulSoup compatibility layer, why would you even bother installing BeautifulSoup? You can achieve a superset of it's functionality with lxml alone.
Normally though they are one of the first things a person learns about python for some reason, and they tend to be remembered well because of the "why would I ever need this, why is this mentioned so early" thought. This TIL is hilariously useless because it's about a rarely used, but widely known feature.
I was about to post this in /r/crappydesign, but then I started doing it... EDIT: This. Site. Is. Awesome.
The puzzles are pretty interesting, especially if you haven't used the modules called for. It appears abandoned judging by the spam-ravaged forums.
For any new python project I start, it feels like there's always just one library not ported to 3 yet.
Right, I forgot to specify that a also needs to be in the domaine of math.somefunction(x). Yeah, I suppose you'd sometimes want the error.
You could try: import os os.system("open /Applications/Safari.app") 
No, its completely correct. It's not treating 10+20j as one object. Thats how I would evaluate it in mathematical language too. In math, you wrote 10+Re(20i). Re(20i)=0, so 10+0 = 10 5(10+Re(20i)) = 5(10+0)=5(10)=50 
You aren't the only one. This isn't some tiny library either, it's a couple thousand lines of code. While it seems to be fairly well written and documented, I agree that it's misleading to advertise as only '2 lines of python'
unicode is a given packing arguments on assignment so like x, y, *other_information = generate_data(z) calling a parent class on an inherited one as `super()` (a bit magicky but I like it) I even dabbled in function annotations a bit def momentum(m : '[kg]', v: '[m/s]'): return m*v universalizing how you call the next value of a generator with `next(generator)` instead of `generator.next()`, falling in line with `enumerate` and `reversed`. I think `with open(path) as f` is available on 2.7, but it's a new-ish feature still. idk. Nothing really game-changing, but just a more pleasant experience in general. **edit:** *crippled* may have been a strong word.
Oh man. I think I want to see how quick I can write a Mandelbrot Set renderer.
sockjs-tornado is fantastic.
Soft tabs ensure code always displays exactly the same which is required for the line length requirement. (which is important for working with code over ssh, or lots of code simultaneously locally) And again, any decent editor will make working with soft and hard tabs identical, why be contrarian? There's nothing to gain by not following convention. I could almost understand if you preferred something else like 2 or 8 space tabs but if you're going to stick with 4 anyway....
They do specifically say that they'll allow exceptions for 3rd party libraries, like something like django. Also, maybe they'd think that django.shortcuts was a bad idea in the first place. (just being a devils advocate here)
Well at the very least it should be far easier managed by using a class instance state instead.
&gt; If you were to submit code that uses tabs at my work it would simply be reformatted by our commit hooks. As it should be. Code should always adhere to the standards of the project(s) to which it is submitted. Though in that case, I would not submit my work with tabs in it, I would use whatever was asked. 
Check the docs on subprocess. [2.7](http://docs.python.org/2/library/subprocess.html) and [3.3](http://docs.python.org/3.3/library/subprocess.html)
You can pretty much use either interchangeably or however else you define it, so frankly it doesn't matter. Python has just taken the position to define "an imaginary unit" as "j" however if I wanted to I could define it however I want in a mathematical paper as long as I tell the reader about it. Mathematical notation is arbitrary, and most mathematicians understand that. If you actually look at different books on the same subject for advanced mathematical topics the notation changes a little anyway--the first chapter usually defines the notation. One place that I ran into that a lot was the way people would define operators, such as the Fourier transform, in Functional Analysis.
on windows you can also just bind hotkeys to shortcuts and open them that way. Easier than getting focus on a python program and then hitting the hotkey. But fubarx has the right idea if you're looking to open programs via python.
You don't need a dual-boot box. There's this thing called [virtualbox](http://virtualbox.org), and you can run any kind of server you want, all in a tidy little virtual machine running [on*] your main computer (windows? mac? whatever, there's a virtualbox). It's the best way to start working with Linux. Not only that, all the cool kids are using [Vagrant](http://vagrantup.com) &amp; [Chef](http://docs-v1.vagrantup.com/v1/docs/provisioners/chef_solo.html) / [Puppet](http://docs-v1.vagrantup.com/v1/docs/provisioners/puppet.html) to create virtual servers right from the command line, based on a simple configuration file. You don't need to dual-boot, you can run whatever OS you like, and just share your local files to one of these virtual servers. It's the only way to fly. Check out "Vagrant Ubuntu tutorial" on YouTube if you want to watch it happen, there's lots of screencasts out there.
Naw, I'm at work.
Higher resolution makes a big difference. 
Do you know how to do this? I can't find the AHK that I used to have, since the websites links were broken. Mouse over will activate the window, but will not focus it. ( or maybe I have the two terms swapped ) It means if I mouse over, I can interact with the window. ( MWHEEL, typing , etc). But does not bring the window to the front like clicking would. It saves a ton of alt tabbing. 
The function annotations seem really cool. I had no idea about that... none at all. Thanks!
By developing this application and providing a user with a means to use this and also testing your app during development IS A VIOLATION OF TERMS OF SERVICE
I think it's possible but difficult with AHK. I use Katmouse... it doesn't let me type in a window that doesn't have focus, but it lets me scroll, which is more important IMHO. http://ehiti.de/katmouse/
Show me what a complete example document looks like, not just a few examples of extension :/
Sure. There is a "Source for this file" link at the bottom of each page, if you hadn't noticed. Also, if you check the source repository on GitHub, there is [this directory](https://github.com/breuleux/quaint/tree/master/examples), and the source for [all the documentation](https://github.com/breuleux/quaint/tree/master/doc), with a Makefile.
Or simply "open -a Safari"
He's already said he has little linux admin knowledge, I don't think this would be a useful soltuion for him.
He's having trouble with setting up a WSGI compatible server interface, not WSGI itself.
AFAIK heroku makes it extremely easy to host WSGI apps, you should check them out.
No I didn't notice, and it hardly looks like a link. I'd suggest you make something like that much more prominent.
The instructions aren't always very clear though, it can be a bit annoying.
Thanks.
I think the discouragement isn't against curiosity, but the context of these questions are normally for micro-optimizations, not curiosity. If you want to micro-optimize, then there are far bigger bottlenecks elsewhere.
I remember finishing this a long time ago. It was pretty darn awesome. (And challenging)
Or just: &gt;&gt;&gt; import cmath &gt;&gt;&gt; cmath.sqrt(-1) 1j
Look into Beautiful Soup; it's a library designed to parse HTML in a "forgiving" way, that is, unlike most other parsers, it will accept slightly incorrect or malformed HTML and make a best effort correcting it. The general procedure for such a scraper would be something like: 1. Get the HTML using an HTTP GET request (e.g. using urllib2) 2. Parse it into a Soup object 3. Query the soup object for suitable nodes; this part needs special-purpose code for each website you want to scrape, unfortunately - there is little point trying to guess which elements contain the parts that interest you in a generalized way. 4. Write the query results out in a text file.
&gt; Regarding the switch statement * http://www.python.org/dev/peps/pep-0001/ : PEP Purpose and Guidelines * http://www.python.org/dev/peps/pep-0275/ : Switching on Multiple Values * http://www.python.org/dev/peps/pep-3103/ : A Switch/Case Statement http://stackoverflow.com/questions/374239/why-doesnt-python-have-a-switch-statement * Do a `dict` lookup (adapter pattern?) * write it in C * write documentation on properly nesting conditionals &gt; IRC is hard: do I owe you support? I want to help people, but frankly, if the discussion is unpleasant for some reason, I'm unlikely to continue. Talking about a construct that I find silly or counterproductive might be something I don't want to do, even if you find it fun. ... &gt; However, I'm merely pointing out that the vast majority of highly knowledgeable people are very dismissive http://www.reddit.com/r/Python/comments/18ssb6/the_python_documentation_is_bad_and_you_should/c8ie97r
From the page: &gt; There are currently levels. Yes. Yes, there are.
[creational](http://en.wikipedia.org/wiki/Creational_pattern) [software design pattern](https://en.wikipedia.org/wiki/Software_design_pattern#Classification_and_list).
The locals vs. globals thing is certainly something that should be mentioned. I imagine the speed difference in the other two examples is incredibly minimal, though. If someone is actually looking for answers into the inner workings of the interpreter, then they should specify they're doing so and that they're interested in a purely theoretical sense.
I think in windows you can use "start" instead of "open" I'm not sure though. EDIT: Yeah it works. I did: import os; os.system("start .") And it opened the an explorer window in the current directory.
There is actually an image that says 33 there. Your probably blocking it with something
Yeah, probably adblock...
I agree with you on that; I learned a load of modules that are great use from this site.
Part of the fun! ~~I totally agree, fuck those instructions ;_;~~
&gt;probably adblock I use adblock, works fine for me...
Looks like you mixed spaces and tabs. Python doesn't accept that.
I know you are in a Mac. For reference, in windows someone could try os.startfile('thefile') Careful though - there is no return code. 
it's a nice way to practice doing stuff efficiently.
I learned a lot from this site when I first got my hands on Python 7 years ago 
You are correct. Lxml is not specifically required. A parsing library, however, is. lxml is the most popular option because it can replace BeautifulSoup, is very fast, and works really well with BeautifulSoup. You always win choosing lxml. You might find lxml better suited to your preferences, which is why I recommend using it if you use BeautifulSoup. If you don't prefer it, BeautifulSoup is different enough that might appreciate it without requiring you to sacrifice the performance of lxml. Choose a scraping target and objective. Attempt to perform the operation coded with each. No preference? Use lxml. Hate BeautifulSoup? Use lxml. Otherwise, well you get it
As a Web developer, two things came in my mind: * tulip &amp; PEP-3156 * async wsgi 3.0 Especially WSGI, the current status-quo sucks: 1. why still need to use cgi environments as request contexts like 20 years ago? Headers are SortedDict, body should be streaming bytearray buffer 2. why does the interface has to be sync by design? WSGI does not support post-response cleanups by design. 
Dude loves his vectors that span GF(2) :P
bottle and flask are for writing wsgi applications not serving them, the op would still have the same issue with their host regardless of sleek framework that is currently being blogged about. 
Best advice I can give you when it comes to programming: don't make asking reddit your first resort. A five second Google search gives you a solution almost instantaneously and you think that you're worth all our time by asking this basic question. I know it sounds harsh, but that's what people think when questions like these are asked. It makes you look lazy and arrogant. 
Same here. I'm not sure how Noscript works, so maybe it's that? A lot of people use that too.
&gt; One tab character indents the code as much as eight spaces do That's is simply incorrect. &gt; I do agree that Python should not allow you to mix the two It doesn't.
Typically you can reply with the lmgtfy link :-) 
It's fun, but a shitty way to learn python. I'd recommend http://reddit.com/r/dailyprogrammer
I'd recommend users install using [pip](http://pip-installer.org), rather than sudo installing into their global package namespace.
www.stackoverflow.com is your best friend. 
That's merely a default setting. I'm not sure what that matters.
I use python 2.x all the time. I feel like I've gotten an error every time that's occurred. Looks like I was wrong there. Though I'm not sure why we ended up on mixing indentation when I was just talking about using TABs consistently.
Are they going to do away with the ridiculous 80 character column limit? I realize 80 chars was plenty when everyone worked on 800x600 terminal displays, but things have changed. It's fucking ridiculous that 75% of my screen can't be used without violating that stupid pep rule. 
It's been on my "list of things to learn" forever, I finally had a chance ~8 months ago when my team decided to transition from node.js. I love it. Lots of gotchas and quirks for the first few weeks but I think it might be my favorite language now. 
Can you sm me more info about your organization and what exactly it is that you need help with? 
*Ctrl+F GIL* ... *Ctrl+F global* What the...
With /r/IPython , http://ipython.org/ipython-doc/stable/interactive/tutorial.html#system-shell-commands : !&lt;cmd&gt; EDIT: ipy = get_ipython() ipy.system? ipy.system?? ipy.system(u'&lt;cmd&gt;') 
I am not on the mac right now but I do know that sh module works on my imac so you could try this: from sh import firefox firefox() If you can run it in commandline, then sh can import it and you can run it like a normal function. http://www.pythonforbeginners.com/systems-programming/how-to-use-sh-in-python/ 
Ugh.. I solved #2 by using find-&gt;replace in a text editor for each letter. Didn't work right and then I realized I had start at z. And typing this I just figured out I could have went forward if I went find "a" replace with "C"
Yup, stuck on level 3 :)
Am I missing something? The key point in the code shown is a python module **app.py** which is executed directly (ie., it is executed as __main__), and is later imported from **app2.py**. This is just crap programming. **app2.py** needs to access *config.decorator* so it should import *config* directly.
I agree. Most of the challenges are just finding out a riddle. The actual solutions aren't that difficult. I had a good time with the urllib linked list one though. There's another where you get a generic XML error and that's supposed to mean you are supposed to use xmlrpclib. I don't know how you are supposed to figure that out I have never heard of it and don't even know what it is. 
I liked that one. Mostly because I don't get to use Counters nearly enough.
I glanced at the forums.. Never seen counters like that before. I really need to start learning Python though as it seems to be a pretty slick language with lots of nice library.
[numpy.log](http://docs.scipy.org/doc/numpy/reference/generated/numpy.log.html) seems to work as you would expect for complex numbers, it just behaves a bit strangely for negative real numbers: &gt; For real-valued input data types, log always returns real output. For each value that cannot be expressed as a real number or infinity, it yields nan and sets the invalid floating point error flag. &gt; For complex-valued input, log is a complex analytical function that has a branch cut [-inf, 0] and is continuous from above on it. log handles the floating-point negative zero as an infinitesimal negative number, conforming to the C99 standard. So, for example: &gt;&gt;&gt; numpy.log(-1) __main__:1: RuntimeWarning: invalid value encountered in log nan &gt;&gt;&gt; numpy.log(-1+0j) 3.1415926535897931j EDIT: actually, I suppose this makes sense, as it might cause problems if the `dtype` of the output array can vary depending on the values in the input array.
If you are working purely with real numbers, you probably want `sqrt(-1)` to raise an exception. Making `cmath`'s behaviour the default would be especially confusing to people who aren't familiar with complex numbers.
ok, i see in the docs a recipe to install web2py on shared hosting over mod_python, without tweaking apache. This looks good, and I'll try it, but my scenario is quite different. I want to develop some user tools to work over existing databases (like prestashop's). I feel is overkill to deploy web2py when a single php file gets the work done. Thats my complain: python requires too much overload to do a quick web scripting job, when that is its main strength for offline work. Some other guy replied the obvious: if the script is simple, migrate to php. Sadly, seems to be right. 
Ajax would over complicate things. You have given no reason why you should use EventSource over WebSockets (apart from "that's what its for", which is a terrible argument). As far as I can tell WebSockets are better supported by both browsers and frameworks, so why not use it for this.
Hahah, me too, so I opened NP++ and did a search/replace for each character I could see. Ended up with the answer!
Perhaps; if you RMB &gt; Inspect Element on the page, you can see that it's not simple just an image that says "33", but it's an actual counter, so perhaps NoScript or another addon is messing it up somewhat.
I agree with you, but find the behaviour inconsistant. Why does the basic interpreter happy to deal with complex number by default, especially in a weakly typed language. What if you tend to use j as a variable, but for to define it (or define it in a path that didn't get executed): &gt;&gt;&gt; j=5 &gt;&gt;&gt; (1+j) 6 &gt;&gt;&gt; del j &gt;&gt;&gt; (1+j) Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; NameError: name 'j' is not defined &gt;&gt;&gt; 
&gt; and they don’t like relative imports like import .models. wtf? Relative imports are discouraged by PEP 8 itself - [this issue](http://bugs.python.org/issue18472) proposes expanding the justification to: &gt; Always use the absolute package path for all imports. Even now that PEP 328 is fully implemented in Python 2.5, its style of explicit relative imports is still discouraged; absolute imports are usually more readable and tend to be better behaved (or at least give better error messages) if the import system is incorrectly configured (such as a directory inside the package ending up on ``sys.path``).
That NameError makes perfect sense. Python 2.7.4 (default, Apr 19 2013, 18:28:01) [GCC 4.7.3] on linux2 Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; j Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; NameError: name 'j' is not defined &gt;&gt;&gt; 1j 1j &gt;&gt;&gt; 2j 2j 
The interpreter only recognises `j` if it is at the end of a numeric literal (like `1j`, `2.5e-4j`, etc.), which would otherwise be a syntax error, so there is no downside to this. Most people might never need complex numbers, but those who do (like me) use them very frequently, and typing things like `complex(0, 1)` all the time would be annoying - it's really helpful to have a succinct syntax for them.
Right, it's an error to reference `j` as "literal" since it's more or less a numeric suffix like `L` to make ints into longs. In the same way, to define `j` and to attempt to reference it in the way you do the numeric suffix `j` is to write inaccurate code: &gt;&gt;&gt; j = 1 &gt;&gt;&gt; 1 + 1j # 1j is not a multiplication, it's an imaginary number (1+1j) # so you can't reduce the value at all 
This is the first time I had heard of this, nor had I ever read it, or observed it. Forgive my ignorance on the topic. I do subscribe to the recommendation of never mixing indent style. But I don't consider that Python specific.
The main point of all (modern?) MVC frameworks is that they separate the data representation (Model) from the presentation (View) from the workflow (controller). In my opinion this separation is worthwhile because makes the code more readable. In fact you can program web2py (as well as many other MVC frameworks) in a very similar fashion as PHP by embedding all code in templates but I would not suggest nor recommend it. I will show instead a simple example. Say you want a database table to store things with names and you want a crud interface to manage the things (search/add/edit/delete/browse). You do: # models/db1.py db.define_table('thing',Field('name')) # controllers/default.py @auth.requires_login() def index(): return dict(grid = SQLFORM.grid(db.thing)) # views/default/index.html {{extend 'layout.html'}} &lt;h1&gt;Manage your things&lt;/h1&gt; {{=grid}} It includes authentication (login/registration/etc.). Try it. Then show me you can do it in PHP with less code.
this works for static html only, won't work for javascript heavy sites
True. For those, you'd need something like phantomjs, which means you'll be using JavaScript, not Python. Also, I assume typical search result pages *do* work without JavaScript, at least well enough to be scrapable - the big search engines at least do.
That is why I do it. Plus I have been burned before where a function returns None and 0. So I try to be explicit.
Ohh thanks! I wish it was just a flag :)
I agree. I'm planning on putting it on PyPi, but I don't know any other way until it's there. Am I wrong? Can you pip install a package even if it's not on PyPi? I'll look into this. Thanks for pointing it out. **Edit:** You can install from a local package. I'm on it.
i cannot accept the challenge, obviously, but you should consider that the tight snipped you posted includes in the background a full web2py install. You will tell me php needs its own codebase too, but its already installed and working in 99% of servers. And theres another constrain I mentioned elsewhere in this thread: i am working on a distributable tool for database management in a third party software. I cannot require my potential customers to do web2py installation on their servers. For the same reason, keeping it python (or 99% python) will require me to do a executable: i cannot require a full python install (at least, for win users). This is were I see the main python drawback against php. I will try to stick to python (and learn web2py or another framework), because i love it, but for some lightweight web work requires a bigger effort.
&gt; Only import entire modules, never individual symbols from a module. For top-level modules, that means `import foo`. For sub-modules, you can do either `import foo.bar` or `from foo import bar`.
It should work now, but I'm not sure I know what I'm doing yet, as I'm new to pip. (I've just been using Ubuntu packages until now.) It's about time I sit down and learn pip and virtualenv.
Let me go ahead and link the wikipedia article for 'strawman argument' here.
I did that with the previous one where it was encoded by each letter being off by 2. 
web2py does not require installation. It is a simple zip file with the required py files and example. One version requires Python 2.7 pre-installed. The Windows distribution comes with python in the zip file (also does not require installation). They all come with web2py's own web server. You can run the all package off a USB drive without installing anything. We have solved these problems 6 years ago. If you want to integrate with Apache with mod_wsgi or with Nginx via uWSGI than you must install dependencies. If you are happy with the built-in server or to use Apache as a proxy than no installation. You can unzip web2py, install your web2py application(s), re-zip it and distribute the zip.
From http://www.reddit.com/r/Python/comments/11bkdp/condent_i_got_tired_enough_of_manually_indenting/#c6ny07r : &gt; It is wholly up to you, but http://stackoverflow.com/questions/120926/why-does-python-pep-8-strongly-recommend-spaces-over-tabs-for-indentation . &gt; &gt; From http://www.python.org/dev/peps/pep-0008/#tabs-or-spaces : &gt; &gt;&gt; Never mix tabs and spaces. &gt;&gt; &gt;&gt; The most popular way of indenting Python is with spaces only. The second-most popular way is with tabs only. Code indented with a mixture of tabs and spaces should be converted to using spaces exclusively. When invoking the Python command line interpreter with the -t option, it issues warnings about code that illegally mixes tabs and spaces. When using -tt these warnings become errors. These options are highly recommended! &gt;&gt; &gt;&gt; For new projects, spaces-only are strongly recommended over tabs. Most editors have features that make this easy to do.
Re: space efficiency Python eggs are compressed archives.
pretty much ending up reinventing rpm ...
Python on OS X is kind of *magical*...but not always in a good way. Just look at the description paragraph of 'man python' to see what I mean. &gt;To support multiple versions, the programs named python &gt;and pythonw now just select the real version of Python to run, &gt;depending on various settings. Working with modules can be troublesome. Unless you need to work with the Objective-C / Cocoa stuff provided in Foundation and want to make stuff for deploying to many Macs I wouldn't bother with it. If you just want to use matplotlib etc. for your own use then Enthought as recmommended above would be the easiest solution. As a bonus it will give you iPython and the super awesome (especially for what you are doing) iPython notebook. [Examples](https://github.com/ipython/ipython/wiki/A-gallery-of-interesting-IPython-Notebooks) If you really want to know just what you have and learn a bit about how things work normally I would do the following. 1. get and install python from python.org *The rest of this if C&amp;P'd from my notes when I was doing something similar a while ago.* [Python Dev Environment Screencast](http://youtu.be/jI8VBP1wEZU) 1. get &amp; install easy_install `$ curl -O http://python-distribute.org/distribute_setup.py` 2. install pip **NOTE: this is easy_install at /usr/local/bin You probably have to change your $PATH** `$ sudo easy_install pip` * killer feature **`$ pip freeze`** shows all installed modules 3. `$ sudo easy_install virtualenv` 4. make virtualenv easier to work with `$ sudo easy_install virtualenvwrapper` 5. make a directory to store all projects in `$ mkdir virtual_py` 6. add the following to .bashrc `export WORKON_HOME="$HOME/virtual_py"` `source $(which virtualenvwrapper.sh)` 7. `$ source .bashrc` ## Working with virtualenv ## create a virtual environment `$ mkvirtualenv --distribute --no-site-packages test_project` **tips** * multi-python support with `-p /usr/local/bin/python3` or `--python=/usr/local/bin/python3` * `$ deactivate` to leave virtualenv * `$ workon test_project` to get back in to it * `$ cdvirtualenv` takes you into virtualenv dir * don't need sudo inside virtualenv for easy_install! EDIT: sorry for the icky formatting. C&amp;P notes were/are in multimarkdown already so it is a little wonky... P.S. Last time I installed it, iPython in EPD Canopy was old. 1. download and install [EPD Free][1] 2. upgrade to [latest][2] iPython `$ sudo enpkg enstaller` `$ sudo enpkg ipython` 3. at this point if you run ipython and get an *AttributeError* [then][3] `$ rm -rf ~/.ipython` [1]: http://www.enthought.com/products/epd_free.php [2]: http://fperez.org/py4science/workshop_geilo_2013.html [3]: http://comments.gmane.org/gmane.comp.python.epd.user/658 
Have you looked at [macports](http://www.macports.org)? The accepted answer to [this stackoverflow question](http://stackoverflow.com/questions/8072664/install-scientific-python-environment-os-x-10-7-numpy-scipy-matplotlib) gives directions on how to install python 2.7, matplotlib, ipython, etc using macports. Macports itself requires Xcode (available from the app store) and its command line developer tools. Instructions for installing macports can be found [here](https://www.macports.org/install.php).
I just got a macbook air and this website was invaluable: http://www.lowindata.com/2013/installing-scientific-python-on-mac-os-x/ I had made such a mess in my attempts to get all my stuff in order that I actually did something that apparently no-one ever does: Formatted it on the second day I had it and reinstalled the OS. Then I followed every step in there carefully and it worked great. **WARNING:** Before jumping in there, download and install Xcode. Then go into its settings and enable "Command Line Tools". After that, it's all smooth sailing. I don't ever use Xcode, but it's good to have `make` and whatnot available in the most mainstream fashion. To install PyQt properly you need to do some manual installation. I can guide you through that too.
Try using a VM? Install Virtualbox and make a VM using Ubuntu. You can install matplotlib on the VM using apt-get. http://osxdaily.com/2012/03/27/install-run-ubuntu-linux-virtualbox/
To uninstall: First check that the packages aren't installed in ML's default Python in `/Library/Python/2.7/site-packages`. If they are, delete them. If you've got pip, `pip freeze` will show you the packages that are installed currently. `pip uninstall` the stuff you installed. If that doesn't work, just remove the directories and files from Homebrew Python's site-packages at`/usr/local/lib/python2.7/site-packages` By the way, make sure that Homebrew's executables are ahead of the default ones in your PATH. Edit `/etc/paths` and make sure `/usr/local/lib` is at the top of the file. If you made an edit, restart Terminal (quit and re-open). IIRC, I had issues installing numpy/scipy/matplotlib with pip on my last Mac, so I'll guide you through installing from source (I'm actually doing this right now on my MBA). cd ~ curl https://pypi.python.org/packages/source/n/numpy/numpy-1.7.1.tar.gz#md5=0ab72b3b83528a7ae79c6df9042d61c6 &gt; numpy.tar.gz tar xzvf numpy.tar.gz cd numpy-1.7.1/ brew install gfortran At this step, I got a an error saying that Homebrew couldn't link `isl`. If you get the same error, try sudo chown [account] /usr/local/libpkgconfig sudo chmod 777 /usr/local/Cellar/isl/0.11.2/lib/pkgconfig/isl.pc brew link isl brew install gfortran python setup.py build --fcompiler=gnu95 python setup.py install cd ~ pip install nose python &gt;&gt;&gt; import numpy &gt;&gt;&gt; numpy.test() You should get all passing tests except some skips and known-fails. Next, install scipy from source: curl https://pypi.python.org/packages/source/s/scipy/scipy-0.12.0.tar.gz#md5=8fb4da324649f655e8557ea92b998786 &gt; scipy.tar.gz tar xzvf scipy.tar.gz cd scipy-0.12.0/ python setup.py install This will take a while. If nothing goes wrong, cd ~ python &gt;&gt;&gt; import scipy &gt;&gt;&gt; scipy.test() I actually got some failed tests at this point... uh-oh. I'm kind of stumped right now. I'll figure it out later, but for now... let's just power through and install matplotlib. `pip install matplotlib` failed for me at first, I had to do brew install freetype brew install libpng pip install matplotlib Install iPython while you're at it, and check that everything works: pip install ipython ipython --pylab In [1]: x = randn(1000) In [2]: hist(x, 100) You should get a histogram in a new window (it'll be hidden behind all the other stuff you have open). If you get an error... sorry? This is exactly what I jut did on a 10.8.4 MBA. If you're on 10.7 things might be different, but I don't think there would be. So apart from the scipy test failures, that's how you install the Python scientific stack on Mountain Lion. Hope it works for you!
Same. I write Finite Element Analysis code to run on supercomputers as part of my research. All of my code and solvers are C, C++ or Fortran based. CLE (Cray Linux Environment) does not make it easy to use python currently so that's another problem too. We had serious problems running even basic python scripts on [Kraken](http://www.nics.tennessee.edu/computing-resources/kraken).
except, rpm does not work cross platform, and does not support multiple environments
Anaconda provides a scientific python distro that is cross platform and comes with python 2.6, 2.7, and 3.3. It uses something called envs instead of using virtualenvs that can contain those versions of Python plus any versions of packages you want. http://continuum.io/downloads
Pycharm is the best IDE in my opinion.
but right on the first page of the manual it shows you exactly how to trim leaves and unused modules to only required. Ports will also let you create packages so you can make a distro for say py27-ffmpeg or py27-pil or py27-pil-ffmpeg. Then you can distribute whatever you need as stand alone. It's a really good way to figure out what software depends on what and how to later build things from source. It's also a whole different type of tool from virtualenv... whole other level.
I wrote code in C, VBA, Tcl, Java, MATLAB, etc, but I didn't GET programming until I had a Python prompt to play with. You can read books on Java and learn how to wrangle complex structure and syntax, or you can follow along with the official Python tutorial and be immediately productive. 
 from subprocesses import Popen Popen(["firefox","www.duckduckgo.com"]) I didn't know about the OS method, but I've used Popen before xD
[Sublime Text](http://sublimetext.com) is pretty good for Python.
Also worth noting that the SAT solver that Conda uses is an open source project: [pycosat](https://github.com/ContinuumIO/pycosat).
it kinda looks like Python is easier to understand compared to Java. There is a degree I'm interested in going for but I have to learn some kind of programming language before applying. The prof. suggested Java or Python. To me Python looks more like stats or Calculus so I think I'm leaning in that direction.
Data analysis tools in Python beat just about everything else. 
Sweet. Why do you say that?
I would start with Panfas, which are an excellent way to manage stored data and they are super fast. Next big toolset is Numpy, which rivals matlab in terms of libear algebra computations. Then scipy which has additional clustering, differential equation, optimization and statistical tools. Scikits learn is also there for machine learning. Not to mention Python has connectors for most database systems and file types.
Fucking phone. Pandas data frames.
Ok, that makes sense. thanks!
I've been thinking since I first discovered Python that it needs to throw out this whole easy_pip whatever stuff and use libzypp and get real Linux-style dependency resolution. 
Bad title. You should reference what it is so people know why they should click the link.
You're all invited to /r/midopy/.
"Plock is a Plone Installer for the Pip-Loving Crowd" Plip Plop Plup? Plock
&gt;Moreover, we are working on an application building framework for Wakari and Anaconda, which allows users to very easily create a applications, which can then be made available through the Anaconda-Launcher. These applications are also conda packages, but contain an icon and entry point. I'm curious how this will work, because I never got Py2Exe to work and having non-technical people install their dependencies (or even the right version of Python) can be tricky. If you guys need alpha/beta testers, I'm up for it!
I agree on Rejection of this, It makes things very complicated. 
There *is* just one way. indent with 4 spaces. Everything else is heresy.
I think this is a joke ;)
http://www.youtube.com/watch?v=IlLzsF61n-8
See, I've never really understood the want for it to be spaces. If tabs are used then anybody who works on the source code can display it exactly how they like.
I think the problem with tabs is that different programs display tabs differently, while a space is a space is a space. 
If I could define my own indentation rules, I would make python accept tabs, variable length spacing, brackets, end statements, rainbows, and any combination of the aforementioned. Because screw the conformist elitism embedded in the system of coding standards.
Why is this considered a bad thing?
2 spaces is better.
There should be examples on what exactly this means, the short paragraph doesn't really do it justice...
The reason why hasn't been made into a cross platform tools is political not technical. The only technical issue is with relocatable packages, but that is the same with the vast majority of the software not designed for it, nothing to do with rpm in itself. Multiple environments are a bad idea! For first it makes next to impossible to repeat that "environment" in the not unlikely event of changes to it (think of a branched development without source code control). Second (and that is a real concern) it is impossible to audit: where the sources came from? Can you guarantee there aren't backdoors? If so how you identify the backdoor source? If there's a bug what's the resolution path (actions to your code? to others code? your changes to others code? and so on). 
Let's split the difference
I reject any indentation. Blocks should end with pass ;)
Version 1.0.0 is now on PyPi: https://pypi.python.org/pypi/mido/1.0.0 
In practice, the idea works OK as long as you only ever write statements on single lines in a text editor. If you're sharing code, for example writing a blog post on-line or e-mailing comments to a colleague, tabs aren't so good because a lot of general software tools won't be as strict about preserving/presenting them as a programmer's text editor would be. Also, as soon as you have a statement that is too long and needs to be split across multiple lines in your source file, you wind up wanting to use tabs to indent the blocks logically but then spaces to align your continuation lines neatly with those above. Mixing tabs and spaces brings forth evil demons from the depths of the world, and they will make you suffer before they eat you.
About page returns 404 
Ever look at it in Word?
Perhaps, this is just anecdotal but every editor I've used has the facility to change how tabs are displayed. Not so much for spaces, which is a tad irritating when you aren't the only person working on a project.
&gt; Our built-in template engine called "SimpleTemplate" (or stpl for short) got a lot of attention in 0.12! I'm surprised. If I recall there was a bug that no one noticed for a very long time and it turned out no one was actually using the SimpleTemplate so they have decided to drop the support. I remember something like this but I might be wrong.
We dropped Simple**TAL**Template, a third party template engine adapter. The built-in engine is widely used and fully supported.
&gt; If you're sharing code, for example writing a blog post on-line or e-mailing comments to a colleague, tabs aren't so good because a lot of general software tools won't be as strict about preserving/presenting them as a programmer's text editor would be. &gt; &gt; A valid concern. Most everything I've used outside of my IDEs or text editors handle tabs very well, but I know issues can crop up. That said, does and should this have any impact on the way you code? The probability that you might have to a) export some code to some outside source and b) the delivery mechanism for that outside source does not handle indentation well? Not to mention that when this is a recurring thing and you keep using software that hampers your ability to quickly and efficiently share code (because even if you aren't using tabs many others still are, not to mention other languages), switching said software seems like a *far* better alternative. &gt; &gt; Also, as soon as you have a statement that is too long and needs to be split across multiple lines in your source file, you wind up wanting to use tabs to indent the blocks logically but then spaces to align your continuation lines neatly with those above. Mixing tabs and spaces brings forth evil demons from the depths of the world, and they will make you suffer before they eat you. You never mix the two, but tabs work inside the code as well. So instead of doing some funky tab + space combo or pushing space 20 times, you can do if&lt;---TAB---&gt;True and \ &lt;---TAB---&gt;True which is perfectly fine.
Thanks for the correction then. Names are very similar. That's why I'm confused.
Bruno, I recognise you from the web2py forums - how does Quokka compare? 
That's not indentation, that's alignment. But it does show that people can still argue over whitespace even if indentation is settled.
Yes! Every time you open a new block, you flip a coin. Heads: indent by 2 spaces. Tails: indent by 4 spaces. If the coin lands on the edge, indent with a tab.
yep, use the -e flag as well if you want to install while developing a package.
I highly recommend pip and virtualenv! Also virtualenvwrapper. After you've managed to set all of those up (takes a little bit of figuring out, some .bashrc settings, etc, I admit), it's as simple as `mkproject mynewpythonproject` and you can work on a new python project (or start helping someone else's) in an isolated environment where nothing can interfere. Makes packages (and installing requirements) such less of a hassle.
I'm a vim guy, but my coworkers really like Pycharm.
In what ways is bottle different from/better than Flask?
First thing Monday morning! :) 
I've found its mostly just, slightly smaller. Benchmarking would be interesting. Flask probably has more extensions to do integration with other things, but if you just want something to make python WSGI-serving nice, and nothing else, bottle probably fits the task best.
&gt; indent with 4 spaces me likes 3 
yes, but how about ponies?
I want haiku style for nesting: 5, 7, 5
Tabs were *made* for indentation and serve perfectly. Somehow a bunch of people ended up thinking spaces were the best thing ever invented and now there are numerous hacks to make spaces work like tabs when editing. Where did we go wrong... I hate this space filled world
I would also say make the effort to learn vim. If you do, you can get some auto-completion: https://github.com/davidhalter/jedi-vim I usually just split my terminal into two vertical tabs, edit in one, run in the other. I run using ipython --pdb so that it'll run the debugger if an exception gets thrown. If I want to get access to the terminal to inspect the workspace after running the script you can just throw a -i in there.
so, i was googling for ruby-style blocks in python, but seemed to find that they didn't have any. your comment makes me think otherwise. (?)
I just added the ez_cluster button to the blog, too :)
I personally use Bottle for all my "ad hoc" and work-specific projects, and Flask for the rest. I think they're both fantastic frameworks. Thank you for the excellent project.
this one is so aesthetically pleasing. definitely keeping it around for when i'm more apt.
im pretty sure this is the one i'm leaning towards...
I use bottle quite a bit. Thanks for the good work.
Code is read more than it is written. I for one love being able to check out a Python project, and expect that the writer has conformed to PEP-8. Python doesn't have multiple ways to do the same thing often, and that combined with a community that tends to be good at following the style guidelines mean that Python code is generally great for reading. The more inconsistent people are, style-wise, the more formatting wars you get in SCM systems. Sure, you can argue that these changes could be automated when dealing with a repo to ensure that you don't get crazy, but one of the core principles behind PEP-8 is that it's all guidelines and what is most readable is best. Humans are better at formatting code for readability, and automated tools will strip the human touch.
Thanks for the quick response! I've been using Flask for a little personal project, but I am not married to it. I'll have to look into your framework a bit more thoroughly to see if it's worth switching.
Pycharm has a 30 day free trial and is a capable editor.
Dude. Don't shroom and Reddit. I have no idea what you're talking about!
Fibonacci nesting increments all the way.
I dislike who you are, but I respect you for your consistency.
I think the first three are all true of Flask. Do you have citations for the performance? Preferably using the same server setup, I think nginx + gunicorn is pretty standard when performance matters.
Why do you make that distinction? I'm struggling to understand the difference between the projects.
Bottle has a somewhat nicer and simpler API, but Flask comes with a great ecosystem full of numerous modules and extensions, wrappers, documentation, support, etc. Flask also has some more features for structuring large applications (blueprints, middleware, custom dispatching, and more). Flask lets you do a lot of "plug-and-play". It is kind of the opposite of DHH's "Omakase" essay: http://david.heinemeierhansson.com/2012/rails-is-omakase.html You can pick and choose what you like, from wherever you like, and put them together however you want. This is in sharp contrast to Rails, or for Python, Django. Bottle is about as minimalist as you can get. It doesn't really have a big extension repository, though you can certainly extend it. It's nothing like PHP, but I would sort of compare it to PHP in how easy it is to get it up and running. It doesn't have many layers between your code and the HTTP response. It's the go-to answer when someone might ask "how do I embed some Python processing in my web page?" or "how do I make a small Python website?". Practically speaking, for small and simple apps it really makes no difference which one you use. Your code will look fairly similar in both cases, and will be approximately the same number of lines (though your Bottle one may have a few less lines, and Bottle will have less boilerplate when deploying it). For larger apps though, Flask will still generally scale, while it may be more troublesome to do so with Bottle. In theory you could build a site as big as reddit completely with Flask and various Flask extensions; with Bottle it would be less feasible. In terms of verbosity and general complexity, it pretty much goes `Bottle -&gt; Flask -&gt; Pyramid -&gt; Django*`. All Python web apps, in my opinion, can be made in one of those 4 frameworks. You just have to choose the right one for the job. \*(Though I'd say Pyramid and Django *can* be interchangeable in many cases, unless the app you want to make already conforms to Django's style, like a blog of some kind, or something that otherwise involves admins constantly publishing dynamic content, and could benefit from a massive admin interface.)
Judging by the comments, I think it is fair to conclude that the objects of irony don't get irony.
I was under the impression that Flask had a compatibility layer for 2/3 bridging, and didn't use 2to3, or six, at all.
why spaces ended up in python is clear: guido picked up the status quo at some point in time, and [although he preferred tabs](http://www.python.org/search/hypermail/python-1994q2/0205.html), that status quo seemed to disagree with him. but i don’t get it either why that status quo was spaces… it just doesn’t make sense sematically: 1 tab = one indentation level. it can’t get any clearer.
&gt; Multiple environments are a bad idea! &gt; For first it makes next to impossible to repeat that "environment" in the not unlikely event of changes to it (think of a branched development without source code control). One environment or many environments have nothing to do with repeatability. If you know what is installed in one environment or multiple environments, you know how to recreate them. &gt; Second (and that is a real concern) it is impossible to audit: where the sources came from? Define what you mean by audit. There are so things and levels to audit, it doesn't make sense to fixate on a perfect solution at one level when ignoring all of the other levels. There is no silver bullet here that is solved by package managers. 
Perhaps we could introduce braces, negating the need to enforce any indentation rules.
That's something that's not really true across domains. If, for whatever reason, you are representing a lot of tabular, or jagged, data, along with certain kinds of rulesets for a wide range of technologies and languages, you end up really wanting to format vertically across lines. It's a matter of legibility and maintenance, and being able to match comments to code in those situations is a fundamental requirement. 
from \_\_future__ import braces
Jeeze just use I-Python notebook.... (and the new vim bindings)
The indent style is my most hated aspect of python. Big long blocks of code become impossible to trace back to the "opening brace."
[PEP8](http://www.python.org/dev/peps/pep-0008/#indentation) explains, and has explained since 2001: &gt; Use 4 spaces per indentation level. There is thus one true indentation style, even where it's not defined explicitly in the interpreter.
Honestly I wish that python would enforce pep8 and just not run any violating script. I don't even care what rules are in pep8, or jslint, or stylecop - I'll happily code to someone else's standard - it's just good that everyone writes code in the same way so that everyone can read it.
Indentation levels plus space characters for alignment (for instance, for multi-line statements) means local tabwidth settings will lead to alignment issues with other tabwidth settings, which can make review more difficult. Tabs aren't smart enough, in short. Either you enforce tabwidths settings, or use set number of spaces. The latter is easier to enforce since contributors can't "cheat" and use a different tabwidth and forget to check it before submitting/committing
The deeper the nesting the worse the penalty, I like it
2 spaces for Lisp 4 spaces for Python 3 spaces for heretics
TIL a way to present Python code in a blog comment where the blog rejects indentation in comments. Thanks, silon.
Looks equally readable to me.
Note: pip in the near future (this year) is hoping to do similar to this. Also, perhaps somewhat confusing to some of you, but distribute is going away in favour of setuptools, because the former has merged into the latter. Python 3.4 should hopefully have a pip bootstrap that will install cool new versions of both pip and setuptools, because they're both rather symbiotic. OP, if you'd like to help out, work is going on at https://bitbucket.org/pypa and the [distutils-sig mailing list](http://www.python.org/community/sigs/current/distutils-sig/).
~~Without a doubt, the single stupidest thing about python is its treatment of whitespace. Whitespace should have 0 meaning. 0. None. The interpreter should not care about it at all. Disregard that I sock cucks~~ &gt;Python -Tn will refuse to run when tabs are not exactly n spaces Oh god - the lols! What do I do with them all?
Would you say I should learn Greek or Spanish when it comes to languages? Which one is better? Not interested in going to foreign countries, just learning some languages. I know Greek has been around for a very long time, but I know that Spanish is also very popular. 
No.
You like your interpreted language to run even slower than usual due to software emulation? There is no issue (or, indeed, discernable difference) between installing and running Python on Linux vs MacOS X. The same rules apply to both: 1. ignore the system python (especially on hideously outdated distributions like RHEL/CentOS). 2. install a nice Python environment like Anaconda or Canopy 3. Fix your $PATH accordingly 4. use virtualenvs for each project 
The other nice thing with Anaconda is its built-in package management tool 'conda' which handles dependency resolution and will also let you package up your own stuff, its also got built-in support for pip. So your env can be tracked/managed entirely within conda irrespective of whether you get the pre-made anaconda package, the very latest pip version, or are including a self-made package. It's also entirely installable as a user, so you can drop it anywhere irrespective of whether or not you have root on that system. 
Nice to see Flask/MongoDB CMS, but wonder why web2py community does not provide some decent web2py-powered CMS which could compare with some from the Django world like Django-CMS/Mezzanine...or they still believe everyone has to write its own from the scratch and keep it as closed-source. :-/
&gt; Also, perhaps **somewhat** confusing to some of you, but distribute is going away in favour of setuptools, because the former has merged into the latter. You don't say. 
Well it's basically just a fork that has been reincorporated into the original software package. Unfortunately you don't tend to see a 'happy story' such as that often in the software world, or it never creates quite as much drama...
Well, you basically need dedicated people who know how to package installers for windows, and who are then able to give support for that installation method. Since you'll likely be interacting with pip through a command line anyway, there's no argument that everything will be a gui and therefore easier. Overall, yes there is the practical admission that there is simply less man-power available to support Windows in general, I don't believe this is unique to python among programming languages. That said, there is a dude that creates a lot of installers for python packages, unfortunately they're currently a bit out of date with the newest pip: http://www.lfd.uci.edu/~gohlke/pythonlibs/#pip 
&gt; Built-in template engine and development server. How is that different from Flask? &gt; Mature Python3 support and 2.5-3.3 support from a single code base (no 2to3) How is that different from Flask? (Granted, the current version no longer supports 2.5) &gt; Better performance. That's very debatable. If people actually run into Flask as a performance bottleneck I can provide them with a lot of options to make it faster. That said, I don't feel like removing functionality and user friendliness just to win some benchmarks. &gt; We were there first ;) Very debatable considering Flask is basically just a tiny layer on top of Werkzeug and a few other things that have been around for many years more than bottle.
Sadly, time to get a new laptop. It is worth it. 
&gt; Do not use @models.permalink Why? 
Oh, got it from the documentation.
Having a ton of data in your code is generally a bad idea too. That should probably be extracted out into other files. I definitely agree there are some cases where legibility defies the general rules of what makes code readable, but I would argue the cases where you *need* to align comments horizontally are minimal.
Then why promote python for kids if you need to be a sysadmin to use it?
They do on mac.
Nope, it isn't repeatable: the reason if you change manually any of those files (no matter what the requirements.txt says) you have hard time to figure it out what has changed and it is a manual task anyway. pip's got certificate signing/verify very recently. so while what you describe is technically correct.. it has never been an issue until very recently (talking few days ago!). 
How is that different from changing files in /usr/lib/python/site-packages? Sure, there's a dpkg command to verify the files, but it's not something one would ordinarily run. You shouldn't do either of those things. Instead you can fork the upstream repo and make the change, then point pip at your new repo. Or monkeypatch it.
This thread compares Java and Python: http://www.reddit.com/r/Python/comments/1ew4l5/im_giving_a_demo_of_python_to_a_bunch_of_java/
This thread from /r/IPython may also be helpful for data analysis in Python: http://www.reddit.com/r/IPython/comments/1i8bgw/statistical_data_analysis_in_python_scipy2013/
The /r/IPython sidebar lists a number of Python data analysis tools. This thread may also be useful: http://www.reddit.com/r/datascience/comments/1eb7ef/linux_data_analysis_tool_suggestions/c9z2iga
pygame
&gt;What I like about MATLAB is the ability to enter breakpoints, see what variables are in the workspace, and the evaluate specific selections.
Flask depends on Werkzeug. If Werkzeug wouldn't run on 3.x, Flask wouldn't either.
There is one : [pip-win](https://sites.google.com/site/pydatalog/python/pip-for-windows)
I just came across this post while doing research for my webapp. The problem with the "shortcut now, right way later" teaching model is that most people never progress to the right way. Since we're comparing Python to PHP, look at how many beginner mistakes get pushed into professional jobs. I still see a bunch of code that uses mysql_* and no sanitation on user input (specifically $_GET and $_POST) when I browser /r/phphelp. I'm a fan of PHP's easy execution, low entry bar, and it's great for quick and dirty web scripts. I'm not a fan of many aspects of the language (Do I seriously need eight different ways to execute a shell command? How about some module control and namespaces that make sense?), but overall it's a great beginner language with some terrible tutorials still floating around. Back to the point, if we start teaching people that, "It's okay to stash your Python app in the cgi-bin." now and then when they grow some they learn, "That was just a shortcut, here's the RIGHT WAY! Forget we even taught you that shit." They'll get frustrated and might even give you the finger. That's how I felt every progressive year in math, "You can't have a negative numbers." Next year, "You *can* have negative numbers. But you can't have a root of a negative number." Next year, "You *can* have roots of negative numbers and here's an entire branch of math based on imaginary numbers. You still can't divide by zero, though." I kept expecting "You can't divide by zero." to change to, "Well, you can and here's an entire branch of math dedicated to zero division." Don't get me wrong, I love math and I'm teaching myself Calc right now, but it was very frustrating having this happen in school. Or a more relevant example would be the nascent of the MVC model in PHP. You start off, "You can mix PHP and HTML. Go a head." And then, "Well, you should off load as much of your complex code to a file and then include that into your PHP/HTML file." Then, "Do it the other way, and maybe use classes." Then, "Here's a templating engine (isn't that what PHP was initially?)." Then, "Maybe you should divide your logic and data handlers. But keep the templating engine." And then, "Here's a full stack MVC framework that'll do 90% of the work for you but you MUST keep the division of logic, data and presentation very strict." You lose a lot of people along the way because you're constantly revealing that they were taught a shortcut instead of the proper way to do. I get that going from no programming experience straight to MVC isn't feasible. But constantly teaching shortcuts is no way to educate either. What we should look towards doing is lowering the entry bar of python on the web. How many (L/W/M/X)AMP install programs can you think of? You just run a command and BLAM! You have a server running on your desktop/laptop. Most of these are incredibly barebones, but we should look towards creating something like this for Python. The only shortcut being taught is how to setup a server, and let's face it, most web developers aren't interested in setting up a server. I taught myself that because I wanted to, not because I felt it was necessary. And I think it's safe to say that python web developers might not be interested in intimately understanding WSGI and don't care to compare specs on uWSGI vs Gunicorn vs mod_wsgi vs Passenger. They want to get up and go. For example, I've been researching Nginx vs Apache and Gunicorn vs uWSGI. Eventually, I decided fuck it, I haven't played with Nginx and uWSGI seems to the popular choice to pair with it, so when I run into trouble I'll likely have an answer quickly. With a turnkey, I could have just said, "Fuck it. Virtualenv, aptitude install lamp-like-python-server-package." And then dicked around with Nginx and uWSGI later. Teach from the beginning HOW to code with WSGI in mind. Teach from the beginning that "This is how it's done. We can show WHY later if you want. But for now, play with these tools and get familiar with them." Don't teach shortcuts, those are for people who know what they're doing. 
&gt; pip in the near future (this year) is hoping to do similar to this. I can't believe they've taken so long getting around to this.
Yes I noticed that, thanks.
If only just 1% of modern Python packages knew how to write good docstrings, `__all__`, avoid reliance on `**kwargs` etc. e.g. requests and flask use `**kwargs` endlessly, and pydoc by default ignores objects whose `__module__` doesn't match the module documentation was requested for, unless listed in `__all__`. So in a case like that it's sadly still quicker to use grep on the source. (Not to suggest requests isn't "beautiful" and "Pythonic") (brb, vomiting)
&gt; Documentation is still lacking, though. Anyone? Shouldn't that be: &gt; Documentation is still lacking though, anyone?
You could also use devhelp, and download the python-doc package (under Linux/Unix anyway) and browser the doc offline :)
you're coming off like a huge asshole here, but I'm still intrigued by what you're saying got any links that discuss your improvements in detail (from the docstrings to kwargs)? I'd look at them. **edit:** particularly *good docstrings*. between the sphinx standard and the google standard and the fact that it's just a string without any rigid structure and the doctests module I really don't know which standard to stick to.
`socket.error: [Errno 49] Can't assign requested address`
Thanks!
1. Choose a port above 1024 (thanks /u/squeakyneb). 2. Choose a different, unused port.
&gt; If only just 1% of modern Python packages knew how to write good docstrings, From [here](http://www.reddit.com/r/Python/comments/1ew4l5/im_giving_a_demo_of_python_to_a_bunch_of_java/ca4htwo) and [**here**](http://www.reddit.com/r/Python/comments/18w8si/why_i_dont_feel_so_bad_brian_curtin_about_python/c8jby1t) : * http://sphinx-doc.org/markup/desc.html#info-field-lists (`param`, `type`, `raises`, `returns`, `rtype`) * http://google-styleguide.googlecode.com/svn/trunk/pyguide.html?showone=Comments#Comments (`Args`, `Returns`, `Raises`) * https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt#sections (`Parameters`, `Returns`, `Raises`) * [EDIT] [khanacademy python style guide #Docstrings](https://sites.google.com/a/khanacademy.org/forge/for-developers/styleguide/python#TOC-Docstrings) (`Args`, `Returns`, `Yields`, `Raises`)
True it is not something ordinary but on a multiuser system one needs to be root to write there so ordinary users cannot tamper files "randomly". Imagine a production system.
As it has been noted, pip, setuptools and distutils (the python standard library's system which forms the basis for setuptools) are by many measures terrible, complex and hopelessly outdated solutions to the packaging problem. Although that may be, there are hundreds of thousands of package releases and who knows how many developer workflows / build systems that depend on setup.py and pip's command-line interface. In the past it has been suggested that we throw away setuptools completely. This seems like a great and expedient idea unless you realize that throwing away setuptools gives you the responsibility to port all 100k existing releases of the 33k pypi-hosted packages to the new system. I tried it with one of my own packages; it took long enough that I wasn't about to do it 99,999 times more. The new strategy is to improve pip and setuptools, allow setuptools to become an available but optional and deprecated part of the packaging ecosystem, and to decouple the build and install phases (traditionally both handled by setuptools in the same setup.py process) so that the developer's choice of build systems doesn't affect you so much at deployment time. Eventually you should be able to choose between several installers, not just pip, and several build systems, not just setuptools, based on a simple set of file formats that the build systems emit and the installers consume. In the mean time the many users who depend on setuptools' myriad but often controversial features, or just don't care and want to get work done, can continue to do so with little interruption. As for this version of pip, it just solves a very irritating problem which is that it was necessary to somehow install setuptools (without an installer) before pip would work at all. Pip will happily do a half-upgrade or uninstall setuptools, and with a now-broken installer there is no convenient way to fix it. Instead, this version of pip doesn't require a working setuptools install and is still able to function in the event of a botched setuptools upgrade. It can install from pre-built wheels without ever installing setuptools at all. It should even be easy to package as a single Python zip archive that can install itself. If you're looking for an innovative installer that solves a different set of problems in a modern way without the ridiculous set of constraints faced by pip, Anaconda aka conda looks pretty cool. It does the much-vaunted libzypp-style SAT solving dependency resolution and can install the Python interpreter and non-Python software as well as run-of-the-mill Python packages. distlib is another emerging library that implements a lot of what pip does in a similarly Python-specific way. If you're looking for a Python-specific packaging system (setup.py replacement) Bento is worth a try. It has a nice extensible codebase.
Thanks! I notice that many of the [Sphinx](https://en.wikipedia.org/wiki/Sphinx_\(documentation_generator\)) [ReStructuredText](https://en.wikipedia.org/wiki/ReStructuredText) [markup constructs (*roles* and *directives*)](http://sphinx-doc.org/markup/index.html) are not natively supported by [docutils](https://pypi.python.org/pypi/docutils); making things like [`sphinx.ext.autosummary`](http://sphinx-doc.org/ext/autosummary.html) and [`sphinx.ext.autodoc`](http://sphinx-doc.org/ext/autodoc.html) also useful. [EDIT] [TIL the CPython documentation is written with ReStructuredText and Sphinx and also hosted through ReadTheDocs](http://www.reddit.com/r/Python/comments/1irskc/til_the_cpython_documentation_is_written_with/) 
The most important limitation of Linux-style package management is that it is designed for system-wide installation from centrally curated package repositories. On the other hand Python package management and language-specific package management in general is designed for cobbling together enough libraries to develop or run an application. The PHP package manager called "composer" does use a PHP port of libzypp. http://0install.net/ is another non-system package manager with some cool features.
The Python community could use and would surely welcome some updates to pydoc. It is literally at least a decade out of date.
&gt; You like your interpreted language to run even slower than usual due to software emulation? Not software emulation. Virtualization. The hard drive and video system are emulated, but the CPU is virtualized and runs at full speed.
* localhost:6060/pydoc.html * http://hg.python.org/cpython/file/tip/Doc/library/pydoc.rst * http://hg.python.org/cpython/file/tip/Lib/pydoc.py
[searching for cpython standard library module documentation (`pydoc`)](http://www.reddit.com/r/Python/comments/1irpst/just_read_post_about_pydoc_p_6060_wouldnt_it_be/#cb7esaf) 
Psst, pydoc -g works too.
1024*
You could also use wget -r to steal all the documents from elsewhere. The point of this is that it has no external dependencies and it generates documentation for anything you have without needing help.
[`rtd.css`](https://github.com/rtfd/readthedocs.org/blob/master/readthedocs/templates/sphinx/_static/rtd.css)
Doesn't seem to do anything on my system. Are you sure this is correct?
Or pydoc3 -b for Python3. :)
I'v always pydoc -g without specifying any port number. When gui appears I just click on open browser and that's it.
Is #2 really necessary?
Software is fine on OSX - just copy the .app bundle. The worst issues I've had with installing applications is the need to change security settings (for unsigned apps, on later OS X editions), and installing X-server (for bad ports). When you are trying to set up libraries, compilers, etc, it gets hairy. It's like any system really, but Linux distros usually let you apt-get most of the basic requirements.
The problem largely hasn't been dependency resolution, it's been package management and distribution formats. How do you install one package correctly on all the common platforms? What if it needs to build C source? Where should it go, how is it removable? These are not the simple, generic problems a SAT solver deals with.
Quokka is a CMS not a web framework... and it is different because it is running with a non-relational database. web2py does not have a stable support for NoSQL yet.
There is a new CMS based in web2py http://www.pynuke.net/ looks promissing. I am quite inactive in web2py community because I am working with another kind of projects, I developed a web2py CMS, but I am not maintaining that project.
That color scheme
If you're on a Mac, I recommend checking out Dash in the App Store. Press Control+Space for access to the documentation of many languages. 
Sounds like git bisect
LOL. That's awesome. I had no idea, since I've never used `git bisect`. Well, I guess it was a good learning experience.
Given that I did try to reinvent the wheel, are there any suggestions for how to improve it?
Perhaps a link to the project page / docs would be clearer (and I say this as someone interested in these pipelines).
Try /r/learnpython to get some help instead :) 
I moved to an imac circa 2 years ago and initially this is how I did it. But using an IDE on the mac to develop inside a VM is not a great experience. I bit the bullet and installed Xcode + Homebrew and never had a a problem. Between my linux workstation and home imac, i do the same for any project: virtualenv newproject source newproject/bin/activate and at this point I can do: pip install yadayada The only problem I had where a pip install failed was with PIL but a quick google told me to use pillow and I downloaded that .tar.gz and followed the instructions. Sometimes when installing certain modules that are written in C, you might need to brew install the dependent libraries but that would be the same thing you need to do on linux. Note: It goes without saying, when you install python with brew, you must update your path to point to it. Otherwise you will continue to use the system python. Edit: Added Note. 
Don't be sorry. Questions are great. They help you learn but they also help other people with similar questions or who don't even know what to ask but benefit from the answers too. Ask questions when you need to. Also /r/learnprogramming and /r/learnpython subscribers won't complain or downvote your questions so I would recommend them as well.
I think it's all about expectations and misunderstandings. The OSX packaging system is indeed wonderful although at times it can lead to bloat. Yesterday I packaged a python script that uses QT and now all the user needs to do is to drag my app into Applications folder but the simple script unfortunately could get no less than 80 megs since it has a copy of the QT libs and python interpreter in it. I think the misunderstanding is for folks who don't really know what they are doing and expect that setting up a development environment is also a simple drag and drop. In Linux you have apt-get and yum, in the mac we have fink [i don't like it] and homebrew [I could not work without it]. Think of homebrew as similar system to gentoo. It downloads and compiles all necessary third party software that you need. 
Obligatory Emacs post. You can use pdb within Emacs' Grand Unified Debugger just like you would use gdb. I've found it to be the best programming editor on OSX. Then again I've used Emacs for a long time now so it could just be what I'm used to. YMMV
TYL'd stack-based parsing.
It looks better. But maybe they have their own reasons to keep the old one.
Specifically: https://docs.djangoproject.com/en/1.5/ref/models/instances/#the-permalink-decorator
 t = self.stack[-2] self.stack[-2] = self.stack[-1] self.stack[-1] = t You could swap them on one line. `x, y = y, x` 
&gt; install a nice Python environment like Anaconda or Canopy Nobody does this on Linux, there's absolutely no need - pretty much all Python software is designed for Linux first, so it's all pretty easy to install as needed.
[Learn Python The Hard Way](http://learnpythonthehardway.org/book/) is a great book. I started off in Python using that. :)
I tried 1025, 1026, 8888 none of them work.
The readme should give useful examples, the current "Usage" section is a bit uninspiring
What about pydoc -g or pydoc3 -b? Maybe this is some kind of a firewall issue? 
High spaghetti factor. Would definitely benefit from a more structured approach - split things up into functions and possibly even classes, so that the reader can follow your abstraction hierarchy. Also, it's customary to add a bit of "is main entry point" guard code so that the file can also be loaded into an interactive session without executing everything right away, something like: if __name__ == "__main__": # all the top-level code goes here This way, if you import the file into another one, or into an interactive session, it won't execute the top-level statements, but any functions and classes it defines would still be available to the importing context.
Hi - I bought your cookbook from packt. Just wondering what kind of projects you are working on now, and if you still find web2py as good as back then, or if there was too much boilerplate for your taste?
I'd have to disagree with /u/dAnjou about calling this pointless. The article can have a fan base of brand new coders and this might be a simpler way to pick things up than looking at the python.org docs, and in the end, attract more developers to python. If the web didn't have authors such as yourself, we wouldn't have any documentation or tutorials anywhere outside of official docs, so I say carry on, and thank you for doing this.
Hey i really like the idea. Are you using it in a real world problem, and can you please describe the concurrency in detail.
[You'll benefit yourself a lot by just using pep8](http://www.python.org/dev/peps/pep-0008/). It'll teach you about the formatting conventions. This will alleviate some of the spaghetti-ness. $ pip install pep8 $ pep8 StockPy.py Now, on the side, you're using matplotlib, so there is an inevitable spaghetti-ness that will happen. With that in mind... Here are the major ones: * Don't be afraid to use variables! You recompute len(stock.index) a ton of times. It will help simplify the code as well as ease you behind 79-cols. * Python packages should also have short, all-lowercase names, although the use of underscores is discouraged. CamelCase filenames (modules) are not the best looking thing. * Trailing spaces at the end of lines. Looks like your editor just doesn't clean it up. * You need to add spaces between operators. * Group your module names when appropriate, i.e. "from datetime import date, datetime" * Use string.format() rather than "" %. For example, ("%s Trading Volume" % stockname) could be ("{} Trading Volume".format(stockname). The .format() convention is much more Pythonic than the manually-defined "%type" string format conventions. Good luck! 
Templates makes sense. I was aware of the overkill, but it's also good to show how to pass template_folder setting. Updated the article. I didn't aware Flask was updated for the static folder setup, that was a piece of code that I found before, which on production will not be important as well. Thanks for the ideas, I personally not agree on official documentation will be enough. That's a great reference, but as a beginner, you would like to see less, and complete the most minimum task. Flask is one of the best documentation out there, but that was also my intention to put the dictionary article in the first place and I will keep on writing on Flask with all the plugins that are necessary. Thanks for the feedback, I appreciated a lot! 
Give yourself a bit of a break and consult the [dos-and-don'ts](http://docs.python.org/2/howto/doanddont.html). You should *really* avoid star-imports if possible. Besides the reasons listed in the dos-and-don'ts if you start using any kind of static checking your respective static-checker will most likely not follow imports, so it relies on properly qualified names.
That's one of the worst tests I've ever seen. It never takes into account the overhead of startup, optimization, teardown, etc. The number of instructions that a print statement takes is deterministic. You have the Python source, you probably have the source for linux. You can work it out solidly.
I often prefer to import whole modules: from x import y y.func() rather than: from x.y import func func() The former gives more context (so you don't wonder where func came from). For example if there is a "string" module with a "reverse" function then the reverse function by itself doesn't really tell you what it does (you might not know it expects a string and use it with a list), however using string.reverse is pretty explicit and avoids this. However its up to you. Also never use: from x import * Every time you do a kitten will die. You have been warned.
Matter of taste, mostly; if you import whole libraries, it's best to do it qualified, that is, `from library import *`; this way, you still avoid possible name clashes. I think there are some sections in various python docs about this matter.
[Sphinx was actually created for the purpose of building the CPython docs.](http://sphinx-doc.org/): "It was originally created for the new Python documentation..."
Oh yes, forgot about that. That will make some of the stack swapping stuff much easier.
Alright, thanks will check it out.
Sorry I was extremely tired when posting but will do.
I'll check it out, thanks! 
Ah. And no, I've known about it for a while.
I've used Django, Flask, and CherryPy so far. Each have their strengths and weaknesses, so it really depends on what you want to do. For a smaller, stand alone type project, I tend to use CherryPy. No external dependencies, production ready server right out of the box, rock solid stability wise, has had Python 3 support for a long time. The drawback is the community is small, so building in things like user authentication is going to be mostly manual, and on the whole you're going to have to re-invent the wheel with things more often using CherryPy. Flask is my go to for most serious projects. It has a lot of similarities to CherryPy, except there's a much larger community and far more add-ons that mean not having to re-invent the wheel nearly as often. The only drawbacks in comparison to CherryPy are it has a decent sized dependency list, and on the whole it's a bit more opinionated about things like which templating engine you should use. Django is the most full featured out of the box, and once you get your head around it, you can enable features pretty quickly and have a very functional website up and running with relative ease. The big drawbacks are that learning the entire framework can be somewhat painful, and the ORM, form, and templating systems that come bundled aren't very useful outside of Django. I've personally started to steer away from Django, mainly because I far prefer using SQLAlchemy to the built in Django ORM. But if that type of thing isn't a deal breaker, and you can get over the hurdle of learning Django initially, the community really is fantastic. 
I'm more of a dog person, but I completely agree with you, the latter gives context. But why does the second method exist? Does it affect performance? Because using the y.func() is obviously more clear. Does pep8 have guildelines regarding importing modules?
Ah, ok thank you for clearing that up. But surely y.func() and z.func() do not clash, do they?
Thank you for pep8, I'm reformatting my code according to pep8 guidelines. And about your last point, thank you, will certainly look into it. I am currently just looking around the example galleries and trying to string together a nice small project to learn about python 
Ever seen the requests or flask docs? They are much better than what pydoc can give you. Sphinx &gt; Pydoc!
I like web2py for my python web projects. The auto form creation saves me a ton of time. 
I use bottle at work and it is nice. Doesn't get in the way and doesn't require that it be loaded unless I need/want it to be, which makes unit tests a lot easier.
[List of projects created with Sphinx](http://sphinx-doc.org/examples.html) ([src](https://bitbucket.org/birkenfeld/sphinx/src/tip/EXAMPLES)) * http://scipy-lectures.github.io * http://ericholscher.com/blog/2012/dec/1/interesting-projects-read-docs-teaching/ lists a few more There could be more books: * http://sphinx-doc.org/builders.html#sphinx.builders.latex.LaTeXBuilder * http://sphinx-doc.org/builders.html#sphinx.builders.epub.EpubBuilder 
Thank you for your feedback. Yes, I'm using it for real world problems and I'll happily explain: There are three good business cases for using Pythonect: 1. SOA / Integration 2. Rapid Prototyping 3. Scripting Engine Why SOA / Intergration? Pythonect visual programming interface, and the fact that it's dataflow oriented, makes it an ideal language for SOA (Service-oriented architecture) and Intergration. By leveraging already-existing Python Standard Library (as well as other 3rd party libraries) you can easily develop Pythonect scripts that access certain resources (e.g. Website, Database, REST API), read (or write) data, manipulate it, and write it to another system (or locally as a file). I have to admit that I have yet written such script myself, but I'm working on RSS Feeder example for future release that will be demonstrating this use case. Why Rapid Prototyping? Pythonect text programming interface, and again, the fact that it's dataflow oriented, makes it Unix Shell-like with Python functions instead of 3rd party binaries. In other words, you can pipe data from one function to another, manipulate it, and etc. Pythonect by design allows you to leverage already-existing Python code without modifying in Pythonect scripts, in other words, write code once (in Python) and use it twice (in Python, and in Pythonect). So just as System Administrators and Hackers (of all sorts) are using Unix Shell scripting to automate their work, or make it smarter - Pythonect will let 'em do the same with Python API's (which are naturally, more powerful and diverse). Why Scripting Engine? Pythonect manages a lot of stuff for you, multithreading / multiprocessing / remote call and etc. If your application exports a Python API, you can easily leverage it with Pythonect to let your users to script their scripts using Pythonect, making multithreading / multiprocessing / remote calls from your app and all from the comfort of their favorite diagram editor. Another open source project that I am currently working on is called Hackersh ("Hacker Shell"). Hackersh is a Unix Shell-like for IT Security Professionals and it's using Pythonect as a scripting engine to expose what I call "Hacker Script" (which essentially let IT Security Professionals quickly develop attacking tools and test their networks/apps for vulnerabilties) Regarding concurrency, currently supported are also 3 types: Multithreading (happens everytime the flow "forks"), Multiprocessing (happens everytime the programmer specifices the '&amp;' at the end of the code block) and Remote procedure call (which currently only supports XML-RPC) which lets you develop a distributed application. Hope it answers your question. Thank you again for your interest!
What are you looking to get out of a framework ? ease of use? no html code ? template friendly ? easy plugins? etc etc. need a bit more details to give advise here. also, this question has been asked dozens of times. i would search for frameworks in /r/python and /r/learnpython. 
Use this. Being a full stack framework, web2py comes with tools for the back-end and front end. This way you don't have to peice a bunch of stuff together. 
Just amended the post. Better? Thanks btw.
It's my framework of choice, not even because of its ease of use, but because it's so damn security conscious. As long as you don't go full derp, you're protected against the common cases of the common exploits. Away with you, SQL injection! A pox on your ancestors, timing attacks!
I think he has it the wrong way round, from library import * causes name clashes. y.func() and z.func() do not clash as y and z are different module names.
Point is, there will always be people maintaining the official docs as long as the project lives (be it Python or Flask or whatever). But authors of these third party things will lose interest and will stop maintaining eventually. And what's the point then in creating them in the first place? People should contribute to the project's official documentation if they think it's not good enough. Note though that I mean only tutorials/how-tos/articles that do nothing special except explaining this one single thing. I appreciate tutorials though that cover uncommon use cases and usage of several components, for example: how to use Flask and Redis to build a web chat? But OPs articles don't add any extra value. They will probably never be updated.
[flake8](https://pypi.python.org/pypi/flake8) and [pep8ify](https://pypi.python.org/pep8ify) can be helpful.
Good, thanks. One question now: how does this compare to [bcbio-nextgen](https://github.com/chapmanb/bcbio-nextgen)?
You could add a [setup.py](http://pythonhosted.org/an_example_pypi_project/setuptools.html#setting-up-setup-py) file and a [tox.ini](http://tox.readthedocs.org/en/latest/#basic-example) with some [tests](http://www.reddit.com/r/Python/comments/1drv59/getting_started_with_automated_testing/c9tfxgd). [The Hitchhiker's Guide to Python: Structuring Your Project](http://docs.python-guide.org/en/latest/writing/structure.html) explains conventional approaches to namespacing code in Python. To [this directory structure template](http://pythonhosted.org/an_example_pypi_project/setuptools.html#directory-structure) I would also add: * `README.rst` (or `README.md`, instead of just `README`) * `requirements.txt` listing package dependencies for `pip install -r` * a `docs/` directory with a `conf.py` and an `index.rst` (for [sphinx](http://www.reddit.com/r/Python/comments/1irskc/til_the_cpython_documentation_is_written_with/)) [EDIT] [Building and Distributing Packages with Setuptools](http://pythonhosted.org/setuptools/setuptools.html)
if you're a newbie I'd hate to know what I am at this point. I hope to be able to do stuff like that. I briefly had a run with VB script but the instructor wasn't very motivated and I didn't enjoy the course. I"m using udacity now and enjoying it thus far. Kudos sir
* [Khan Academy Python Syle Guide: Imports](https://sites.google.com/a/khanacademy.org/forge/for-developers/styleguide/python#TOC-Imports) * [Google Python Style Guide: Imports](https://google-styleguide.googlecode.com/svn/trunk/pyguide.html?showone=Imports#Imports) * [Python Do's and Don'ts: `from module import *`](http://docs.python.org/2/howto/doanddont.html#from-module-import) [*](http://www.reddit.com/r/Python/comments/1it01z/newbie_my_firstsmall_attempt_at_coding_in_python/cb7sjya)
* http://www.reddit.com/r/Python/comments/1eboql/python_website_tuts_that_dont_use_django/#c9yxl8w * http://www.reddit.com/r/Python/comments/1drv59/getting_started_with_automated_testing/ * https://en.wikipedia.org/wiki/Comparison_of_web_application_frameworks#Python_2 https://github.com/revolunet/PythonBooks [EDIT] In no particular order: * /r/django * /r/pyramid * /r/flask 
Personally I like it. I have just begun to learn python over the past year, and while the official documentation is nice, sometimes a more friendly and complete explanation is necessary. Yes, there are a lot of these things out there, but in my experience that's a good thing. Each tutorial has its own way of explaining the subject and when you find someone who's style and thought processes reflect your own things just "click". So keep it up! It will not only help you learn but the rest of us as well. Much thanks!
Fair enough. Should probably not have written that comment.
No, they don't. That's the whole point of qualified imports: if you import both `x` and `y` unqualified, Python would have to decide which `func` to import into the global namespace - that is what we call a name clash.
very true, although I would use them if a method has a ton of arguments , but maybe then it would be time to split functionality to different methods/functions if you have too many...
if you're working interactively at the prompt it can be very convenient to do something like from math import * when you know there'll be no namespace conflicts and it makes the typing faster. Think those who do data analysis or math work. 
I'd recommend Django. One install, and you're ready.
I would recommend Flask personally. Yes you will need to pip install some plugins for things like ORM but as someone else mentioned, with Django you are stuck with Django ORM, which in my opinion sucks. SQLAlchemy is great and Flask-SQLAlchemy makes integration easy. I can get a serious prototype working and almost fully fleshed out in 24 hours. Obiviously this would depends on the scope of the project. Anyways, if you go with Flask, I would recommend Flask-SQLAlchemy and Flask-WTForms. If you need login/authentication there are a number of options. You can even try Flask-Restless if you want to automatically present a REST api for your SQLAlchemy models.
I'm very much interested in packaging a python "package". Because I'm also trying to build a quadcopter and I hope to make the gui on the comp python based using pyserial and kivy. I have never used pip, could you please explain what exactly it is. I know it's used to manage your libraries, but where does it get the libraries from? I am on a linux machine and I just download libraries from the repo. Thank you again
I've always liked Pyramid (successor to pylons)
&gt; I'm very much interested in packaging a python "package". [The Hitchhiker's Guide to Python: Packaing Your Code](http://docs.python-guide.org/en/latest/shipping/packaging/) should link to these: [Python Packaging User Guide](https://python-packaging-user-guide.readthedocs.org/en/latest/) * [how to install pip](https://python-packaging-user-guide.readthedocs.org/en/latest/installation_tutorial.html) from source. * [descriptions of python packaging tools and projects](https://python-packaging-user-guide.readthedocs.org/en/latest/projects.html) [The Hitchhiker's Guide to Packaging](http://guide.python-distribute.org/creation.html) * http://guide.python-distribute.org/specification.html#sequence-based-scheme (http://semver.org) &gt; [] where does it get the libraries from? * [`.pypirc`](http://docs.python.org/2/distutils/packageindex.html#pypirc) * [`$PIP_CONFIG_FILE` (`pip.conf`, `pip.ini`)](http://www.pip-installer.org/en/latest/configuration.html#config-file) * [`pip install`](http://www.pip-installer.org/en/latest/usage.html#pip-install) * https://pypi.python.org * https://crate.io * https://binstar.org 
* /r/learnpython/wiki/index * /r/IPython sidebar * https://github.com/jrjohansson/scientific-python-lectures/blob/master/README.md * http://pythonbooks.revolunet.com/
I tried doing the "Using the YouTube API" but nothing happened. Any ideas?
Did you import the modules? ( import requests, json ) (Post updated)
that's great! now someone needs to implement a CLI-solitaire to play while running tests ^^ fyi: pull-request sent.
## Fortran matplotlib.pylab requires numpy which requires Fortran for some things. http://docs.scipy.org/doc/numpy/user/install.html#prerequisites : &gt; To build any extension modules for Python, you’ll need a C compiler. Various NumPy modules use FORTRAN 77 libraries, so you’ll also need a FORTRAN 77 compiler installed. * http://stackoverflow.com/questions/11151118/how-to-link-to-fortran-library-via-numpy-distutils * http://stackoverflow.com/questions/7688304/how-to-force-numpy-array-order-to-fortran-style * http://pandas.pydata.org/pandas-docs/dev/overview.html?highlight=fortran ## [Performance](http://en.wikipedia.org/wiki/Computer_performance) and [Optimization](http://en.wikipedia.org/wiki/Optimization_\(computer_science)) * http://scikit-learn.org/dev/developers/performance.html * [testing #instrumentation](http://www.reddit.com/r/Python/comments/1drv59/getting_started_with_automated_testing/c9tfxgd) * https://github.com/pydata/vbench
I believe there are also new CSS styles for http://preview.python.org/documentation/
nose-solitaire + https://github.com/ralphbean/nose-audio would be an epic combo. Thanks for the pull request! My eval approach was totally a quick-and-dirty hack. Your patch broke Python3 support though, since unichr was removed, but it was an easy fix.
Maybe an image preview would be helpful: http://imgur.com/tFUvrxw
This is super cool. I'm going to have a fun time implementing Bruce Schneier's *Solitaire* cipher!
Without any idea what your project is, I'll say any of them would be fine for learning. That said, I use Pyramid.
The website is called "Python for Beginners". Why would a beginner care to use the Reddit API directly when you have access to such nice and simple wrappers like [PRAW](https://praw.readthedocs.org/en/latest/)?
This is really cool. My only complaint is the license; GPL3 seems like such overkill for something like this. Nethertheless, really cool. [Uploaded to the AUR](https://aur.archlinux.org/packages/python-unicards/).
I love Flask! Not too light, not too heavy, just the right size for most projects!
Fortran was created in 1957 and was the first simple programming language (i.e. not assembly). C was released in 1972. Fortran was made for engineers to solve engineering problems, which is why it has complex numbers. Fortran also had the first multiprocessing libraries because the people doing the real science that actually had the funding to develop develop multicore hardware and software used Fortran.
nice, bet you can't make that!!!
Try [How to Think Like a Computer Scientist: Think Python](http://www.greenteapress.com/thinkpython/) by Allen Downey. I'm in the process of reading it, and I like it a lot. It primarily focuses on Python 2, but it does mention some notable differences between that and Python 3.
on what topics would you like to read more ? Lists ? Tuples ? What's the area you are interested in..
hey xsist, thanks a lot. I also agree that I also learn a lot. That's also why all the articles and most of the code is open source and available as well. After covering up most basic, I will get into much more detailed topics.. Thanks again! What do you want to read more ? 
thanks a lot for the example, very useful
Could you also use the Reddit API to reply? Any advice on how to go about doing this?
This is about iterables and isn't specific to generators. If you want to use the same iterator more than once: from itertools import tee sequence, memoized_sequence = tee(sequence, 2) 
It looks like a bunch of rectangles on a Mac. Is there a special font to install?
TIL Godoc was inspired by Pydoc
I think you mean "iterator", not "iterable". (Sequence types are iterables and they can be iterated over an arbitrary number of times)
Coverity usually warns about a lot of things that doesn't make code to crash, the high-risk are usually the ones that REALLY needs to be fixed, and those are very rare (if you're an average C developer).
Iterators are iterables in python (they define \_\_iter\_\_ to return self). You can call iter(some_generator) and get a new iterator, but it doesn't fork the generator. Lists aren't iterators though, so in the context of the title I think it makes more sense to talk about iterables.
Yeah, you'd want to create an HTTP POST to this command: [reddit.com/api/comment](http://www.reddit.com/dev/api#POST_api_comment) However, this is a bit more complicated than reading content with the other API calls mentioned by OP: To comment on things, you must first [login](http://www.reddit.com/dev/api#POST_api_login) and also get the [modhash](http://www.reddit.com/dev/api#GET_api_me.json), which is a type of session ID you get after logging in, so reddit knows you're the same user which logged in. Some of the reddit API commands need to be in HTTP GETs, and some need to be HTTP POSTs; this is listed next to each API command. As someone else mentioned, if you want to look at more in-depth Python client samples, check out the [PRAW](https://praw.readthedocs.org/en/latest/) code. PRAW implemented more (all?) of the API commands already, so if you get stuck, that is working code which you can compare with yours.
Okay, so I don't at all know what you're trying to say now. (By which I mean I don't understand what your original post was trying to say. I understand the technical points of your comments)
I'm still fairly new to python and I thought this tutorial was a great way to learn how it actually works. Within a few minutes I had a little command line reddit reader script working. I think it's a great entry point. 
I'm on windows and tried IE, Firefox and Chrome and it just shows up as boxes or unicode symbols. I'm guessing these aren't characters that most fonts implement in unicode.
If you are a beginner — Django or Flask.
How is it better than Flask? Why do they create more frameworks to render "Hello world"?
I just realized I never had time to look at Plone. Now I know i will never use that! Nice. This Joomla is just bad.
Some bandwidth providers do strange throttling to make HTTP downloads look faster; making a [rolling mean (or a moving average)](http://en.wikipedia.org/wiki/Moving_average) a bit of a closer fit, in some cases.
Is there examples of the problematic code? I would guess many of them are necessary for handling the wide range of compilers/platforms where Python is used Also it would be interesting to see what it says about a "mature" version of Python, like the source for the latest 2.7 patch
Agreed. Especially since once you get the hang of one JSON API, you understand how most of them work.
Looking at the title it may not look like a complement, but from the report it looks like an achievemnt, the average defect density of programming languages is 1 per thousand lines, and Python has the index of 0.1. 
There is no requirement that ``__iter__`` returns self, it's just a convenient shortcut and avoids allocating another object.
Rather than using a list comprehension, you can just use ``list(x)`` to expand a generator (or other iterable).
Why Python? Would it not be more interesting in the long run as a stand alone language? Plus something in C++ would be a lot more portable. By the way I have nothing against Python, in fact I like using it a lot. It is just that I'm not convinced a language within a language is the way to go. Further the world could really use some fresh blood in the scripting language playing field. Python maybe my go to scripting language but I'd certainly consider something a bit different that easily can be compiled as needed. 
&gt; as I move up to integration testing As a side note, I've been using [Robot Framework](https://code.google.com/p/robotframework/) for those for a long time now and it's been quite a good experience so far (for the most part). The best feature being that testers feel it's easier to grasp its DSL than learning Python. 
[Searching python's bug tracker for "coverity"](http://bugs.python.org/issue?%40columns=id%2Cactivity%2Ctitle%2Ccreator%2Cassignee%2Cstatus%2Ctype&amp;%40sort=-activity&amp;%40filter=status&amp;%40action=searchid&amp;ignore=file%3Acontent&amp;%40search_text=coverity&amp;submit=search&amp;status=-1%2C1%2C2%2C3) will show you a few of the bugs if you're interested in what they look like.
I got Python 2.3 to crash only once by crashing a C extension module (MySQLdb).
This is basically a re-wording of the todo app tutorial on the bottle web page [itself](http://bottlepy.org/docs/dev/tutorial_app.html). I'm really not sure what value this adds.
I've seen it crash in a reliable way by setting an overly high recursion limit. ... A known problem assuming it is considered a problem.
Okay so replying to myself, it does actually link to the official tutorial and say that it will "improve the UI a little bit" and in a later article use SQLAlchemy rather than sqlite. 
My vote goes for Django. People wrongly suggest that it's big, heavy or bloated. But I assure you that's just the small but vocal minority of (generally) Flask users who want to ensure that they made the right choice when choosing a web-framework. The crux of the matter is this: Django has pretty much all you will need out of the box to get going and has a *tonne* of nooks and crannies with all kinds of tools to help your project scale as it gets larger.
I wouldn't recommend pyramid or flask to a total beginner, the documentation and amount of tutorials for those frameworks is nothing compared to the material available for Django. 
yeah, SQL-Alchemy is perfect for a "total beginner" with its user-friendly API ;)
well.. its gone long time enough for it to be modern again ;) both the colors and the flat look is really hip
&gt; I've also tried web.py, liked it but it seems to be very simple, I'm afraid that I might feel lack of features or robustness in the future web.py used to power reddit. I don't know what you plan to build but I don't think you'd reach its limits quite easily. If you want a framework that has everything, I'd say go with Django.
Ha! And here I was thinking "gee... I could be a core python developer..."
So you've taken on board the advice to do if __name__ == "__main__": # all the top level code goes here And that's fine. But now what would be the point of importing it? You couldn't do much. So I usually suggest something like: def run (): # blah if __name__ == "__main__": run() In your case you have some potentially useful other methods so I would refactor to something **like**: def plot_data(stkname, fig, topplt, botplt, sidplt): # As before def run (): # Setup figure #Top, Bottom, Side with top and bottom plot sharing x axis fig = plt.figure() top = plt.subplot(221) bot = plt.subplot(223, sharex=top) sid = plt.subplot(122) fig = plot_data('GOOG', fig, top, bot, sid) multi = wd.MultiCursor(fig.canvas, (top, bot), color='r', lw=2) # As before .... plt.show() if __name__ == "__main__": run() 
Are there any reports to other programming languages/interpreters/VMs for comparison?
Most scientific python libraries have a mixture of C and Fortran components. Pylab is built on numpy, which uses fortran for some things. Numpy uses a lot of blas/lapack/atlas, which could be anything (there's several versions), but is probably either fortran or assembly. 
That tutorial was unmaintained for some time. We accept pull requests or patches if you want to improve the official documentation.
Looks like that script grabs the cookies files from the current user's AppData/Local/Google/Chrome/User Data/Default/cookies, then emails them from 'iliketoeatyourredditcookies@gmail.com'. There's another email address in the executable that I won't reproduce here to avoid violating reddit's personal information policy.
Interesting comparison but shame the author didn't give some guesses at why they differed, which one was probably better in general use cases, etc. In other words, some analysis would have been useful.
Django ORM might be a little more friendly, after all your defining tables as classes in both but not nearly as flexible when actually USING SQLAlchemy in your project. So if you start with Django and have to rewrite in Flask/SQLAlchemy, seems like wasted time to me. Again, just my opinion.
It's very possible, not even really hard. When you ran pythongame.exe, you allowed it to do anything you can do yourself as a regular user - including reading anything in you Chrome profile. Unless you have set a master password and log out of all your sessions in Chrome before running the untrusted code, such a program can easily read your passwords - it's just a matter of knowing where Chrome stores them. Getting this information back to him isn't too hard either; you can connect to the internet, so the program can do the same, which means sending the login data to pastebin or some such is relatively trivial. I haven't looked at the .zip, but I assume that's more or less how he did it. Of course, another option would be to hack your hosts file, so that reddit.com points to a server he controls; that server would just proxy the real reddit, so you wouldn't notice anything, but meanwhile, it could sniff all the traffic between you and reddit, including your session ID and login credentials. (This, BTW, would work with *any* browser, and he wouldn't have had to ask about Chrome; it will not work, however, if you log in over HTTPS, unless you get an "invalid certificate" warning and actively choose to ignore it). A few things to consider: * Your "friend" abused your trust in a way that constitutes an actual crime. Now, personally I wouldn't press charges, but he definitely needs a lecture on ethical hacking. People go to jail for this sort of thing. It's the information technology equivalent of a date rape. * You acted sloppily yourself. Your web browser is the most likely piece of attack surface on the entire machine, so you better make sure it is secured properly. This means: set a master password (or just don't have it remember your passwords), install a script blocker, and maybe install a second browser for "high risk" browsing, with even more safeguards - script blocker, ad blocker, tracker detector, etc. etc. * On Windows, you absolutely want to run a good personal firewall: if you did, your friend's program would most likely have triggered a confirmation popup asking you to allow it to connect to the internet, which should have made you suspicious. * When you want to run code that you have any reason not to trust fully, do it in a sandbox. If your machine can handle running a VM, use it - if it breaks anything, you can just roll back to the latest known-good snapshot, or just discard the VM and set up a fresh one. Breaking out of a VM is much, much harder than the kind of thing your friend did. So now what? 0. Stop using the Windows partition right now. Don't touch it until you know it's safe to do so (which might be never). 1. Change your reddit password from a known-good browser (thus, *not* anything running from anything the Windows install has access to). 2. Grab your "friend" by the collar, have him explain in minute detail what his program does and how to undo it. If you can, have someone else double-check his statements. 3. If you have absolutely no doubts that what he says is true, do whatever is required to undo the hack. If you have the slightest doubt, wipe the Windows partition and reinstall from scratch. Really. 4. Review your system's security setup, your computer usage habits, and your friendship algorithm.
No Blueprints, but you can merge and mount apps into each other. That is basically the same as far as I understand blueprints (correct me if I'm wrong). Bottle has [plugins](http://bottlepy.org/docs/dev/plugindev.html) and hooks. The plugin API is slightly more powerful than flasks extensions I think. They allow you to selectively wrap route callbacks (apply decorators), which has some benefits compared to hooks. 
Use oursql instead of MySQLdb!
Great point, but that was in 2008 and oursql was not even started back then.
I guess you'd rather have false positives than false negatives. You can dismiss false positives, but false negatives stay hidden.
Hmm, I'm not sure. According to this page, XP+ should support them out of the box? http://www.alanwood.net/unicode/playing-cards.html
Lots of people ask this question but almost nobody comes back to let us know what they tried and the results of their experiences. I am the lead developer of web2py and I would like to hear more feed back if you actually get to try it. Most people comment on software without actually trying it.
It's the username/password for iliketoeatyourredditcookies@gmail.com, not his own account. edit: I decompiled it. [Here's the source of both files together](http://hastebin.com/salasowepu.rb) (I think the first one is a generic loader for py2exe) Tools: [unpy2exe](https://github.com/matiasb/unpy2exe), [uncompyle2](https://github.com/wibiti/uncompyle2) Another edit: So I changed the email account's password. The program will now not work. (also permanently deleted the previous emails containing cookie data)
As robin said, they're preferable to false-negatives -- I would imagine the "issue" arises out of the effort to achieve full coverage. *i.e.* It is better to find *N* real problems and *n* more false ones than it is to find *N - n* real problems and to miss *n* other real problems. **EDIT:** Also, one of the graphs shows that about 100 of those FPs are "intentional". They might actually be "wrong" but achieve the desired effect. The other 150 or so (15%) are true FPs.
I changed the email account's password, the program will now not work. (also permanently deleted the previous emails containing cookie data. The recipient of those emails will still have them though.)
Thank you for the feedback, unfortunately, I tried something similar and I'm having a lot of trouble passing the axes of the plots. The multicursor is not executed and also the radio widgets does not accept inputs. Problem is keeping the axes and the figure as local variables inside the functions. Assigning them as global is a sort of dirty workaround. 
I have very mixed feelings about this. `imaplib` is one of the most un-Pythonic libraries I've used from the stdlib. It feels barely better than just writing out all your IMAP commands by hand. We could definitely stand some improvement here. This module seems a little *too* detached from the stdlib, though. Calling it `MailBox` when we already have a `mailbox` module is asking for trouble. And why doesn't it work with the `email` module, which provides much better ways of handling individual messages than simple dictionaries?
I'm just starting to learn Python (well, programming in general) and I completely agree with this. Things didn't start to click until I got out of the hand-holding "beginner" tutorials and started following things that actually showed me what was going on behind the scenes.
Nitpick but I would have expected `get_all` to be a generator.
Literally copy and paste the 'plot_data' function to the top level (unindenting it). That is all that is required.
As someone who deals with a certain widely adopted "Security scanner" on a near daily basis, I dream of 25% false positives. Manually investigating and dismissing 75% of "HIGH PRIORITY" security items while people in the field scream down your neck is not my most favorite day at the office. No, I dont have Windows-only software magically installed on this Linux server, you piece of-....
setup.py for atomic libraries (reusable), requirements.txt for stand alone, not-that-much-reusable projects. 
Well, arbitrary code execution is security hole in a web server, but it essential for a general purpose programming language.
How does it work with gigantic mailboxes?
Why on earth would you compare parsers on sentences that would be considered ungrammatical by modern standards, and that look nothing like either their training data or any corpus you would be interested in applying a statistical parser to? The only practical example is the court opinion, on which they both do well. From the [Stanford Parser FAQ](http://nlp.stanford.edu/software/parser-faq.shtml#z): *english{Factored|PCFG} is currently trained on:* * WSJ sections 1-21 * Genia (biomedical English). Originally we used the treebank beta version reformatted by Andrew Clegg, his training split, but more recently (1.6.5+?) we've used the official Treebank, and David McClosky's splits * 2 English Chinese Translation Treebank and 3 English Arabic Translation Treebank files backported to the original treebank annotation standards (by us) * 95 sentences parsed by us (mainly questions and imperatives; a few from recent newswire) * 3924 questions from QuestionBank, with some hand-correction done at Stanford.
"pip install mailbox" fails: Running setup.py egg_info for package mailbox Traceback (most recent call last): File "&lt;string&gt;", line 16, in &lt;module&gt; File "/private/tmp/pip-build-root/mailbox/setup.py", line 9, in &lt;module&gt; long_description= open('README.md').read(), IOError: [Errno 2] No such file or directory: 'README.md' 
Thank you for that. I will replace the dictionaries with generators as soon as possible 
Mailbox is just a thin wrapper around 2 python modules: *email* and *imap*. I will rename it for sure, for the moment the library is just a proof of concept that I am not the only one who needs a simpler way to deal with IMAP
I'm going to make a public apology right here: this scheme was my idea. I did not intend to use this in any malicious manner other than finding out what my friend's reddit USERNAME was. I was annoyed that he would not tell me or any of our other friends his username, so I did a little research to try to make something like this. I was not aware of the full potential consequences nor did I intend for this to do anything that would remotely harm my friend or his computer. Immediately after I found the username, I deleted all of the cookies. I now realize what this could have done if fallen into the wrong hands, which I hope it did not do. Again, I now understand how truly bad an idea this was, and I will never mess with any viruses or any attempts at hacking again, because other people's information is theirs. I sincerely apologize to the OP and all you Reddit users who did OP a favor by disabling it as soon as possible.
i specifically chose the api so i can understand what is going on in the code, although i think that once i learned it, i would always use praw after
Done. Still need to figure out how to get it rendering properly on Mac/Win/Android :\
You're right, copyleft is probably overkill for 10 lines of relatively simple code (so is having external CI &amp; coverage analysis but…why not? ☺). It was the result of a copy-paste job from another project. Anyway, I just re-licensed it to ASL2, per the FSF's recommendation for projects under ~300 lines of code. Thanks for pushing it out to Arch! It looks like the source URL on that page is broken though.
Thanks. I think I'm just gonna make a new account; I like having my privacy when redditing. I never even thought anything about it since I really only use my Windows partition to play games. Don't really do much browsing. This person WAS a really good friend and I'm not gonna press any charges. I think this scared him enough. I'll definitely install some safeguards though. He even told me that Chrome might say that it's not safe but that was because the game is still in development. Definitely will be checking out that friendship algorithm you mentioned. I'm annoyed that he figured out my username (it was actually my second account) but the betrayal of trust is more disheartening.
Thanks so much. 
Interesting, but why would you get back a dictionary instead of an object? If the fields are the same every time (as it implies) it would have been a much nicer interface.
Still testing, but once I replace the dictionaries with generators I think it will have identical performance in small and gigantic mailboxes 
Nothing is written in stone, I just wanted to start from somewhere and to see reactions and adapt :)
We are using jinja2 and I think it does a good job.
Well, he probably didn't realize what he was doing. It's easy to get caught up in the thrill of actually pulling off something like this. Happens to the best; if he's a good guy, he'll learn his lesson and pick up some hacker ethics. (BTW., ethical hacking is quite an honorable and profitable occupation...)
As someone on HN said, a big +1 to anything that would possibly someday allow us to write `&lt;script&gt;PYTHONPYTHONEVERYWHERE&lt;script&gt;` right there in our html.
Really cool use of Flask and SQLAlchemy to build a RESTful HTTP HATEOAS facade for a defined set of SQL tables. Thanks! Legacy databases are always fun. I assume you are using reflection to infer attributes and relations from the database with the extra cost of queries to introspect database schema? FWIW, many migrations libraries can also generate a set of model mappings as python code from an existing database schema (e.g. as migration script #0) * [sqlalchemy-migrate `create` command](https://sqlalchemy-migrate.readthedocs.org/en/latest/versioning.html#experimental-commands) * [alembic](http://alembic.readthedocs.org/en/latest/tutorial.html#building-an-up-to-date-database-from-scratch) One best practice from both of these libraries is an access-limited version table containing the current version of the database schema. There are arguments for and against including API version numbers with what are then not RESTful permalink URLs. With URIs, RDF, and Linked Data: * http://schema.org/DataCatalog and http://schema.org/Dataset * http://d2rq.org has SPARQL over RDF, but is read-only and requires column-attribute mappings that can be generated * [W3C LDP 1.0](http://www.w3.org/2012/ldp/wiki/Main_Page#Deliverables) abstracts things into RESTful containers
&gt; (i.e. nothing passes from templates to python's eval or has access to server resources -- we push data structures for processing TO the templates only) if you really have that requirement, then mako/jinja/most others are out the window - they all execute code willynilly, especially mako (of which I am the author). I'd use something like [pystache](https://pypi.python.org/pypi/pystache), it's quite nice.
Yes, that's a bug with the AUR; source urls are incorrect when the pkgname is reprocessed. Rest assured, it downloads just fine =) Thanks for relicensing!
This is bonkers. Why didn't he even mention that rpython used to have a Javascript backend?
&gt; [...] security on either [..] * http://cwe.mitre.org/top25/#CWE-79 * http://cwe.mitre.org/data/definitions/79.html * http://jinja.pocoo.org/docs/extensions/#autoescape-extension * https://github.com/mitsuhiko/markupsafe * https://docs.djangoproject.com/en/dev/ref/utils/#module-django.utils.safestring * http://docs.makotemplates.org/en/latest/filtering.html#expression-filtering https://en.wikipedia.org/wiki/Separation_of_presentation_and_content 
&gt; we push data structures for processing TO the templates only) So, only JSON in the template context data? https://en.wikipedia.org/wiki/Template_engine_(web)#Comparison
I've been using [IMAPClient](http://imapclient.freshfoo.com) lately. It's a thin wrapper over `imaplib`. It's missing a wrapper for `email` though.
&gt; For instance Apple sells devices with a secured bootloader that is a consumer product (all iPads and iPhones). It would be impossible for them to comply with the GPLv3 license requirements unless they completely get rid of the devices' security systems They could just add an option to disable those 'security systems'.
I am not 100% sure because I have not used it. But from looking at it, my pipeline is specifically to streamline the running of the tuxedo protocol suite. For that, mine seems to **ME** to be **MUCH** more accessible to non-programmers which is one of my goals.
I wish I'd had this when I was first learning Celery. Good job. I'll point new devs to this as a get-started tutorial before having them dive in to our complicated setup.
ymmv: def streamavg_running_segment(itr, avg=None, seqpos=0): """ calculate momentary mean (cumsum/n) optionally from {avg,seqpos} :param itr: iterable of {int, long, float} :type itr: iterable :returns: cummean float generator :rtype: generator(float) """ if not hasattr(itr, 'next'): itr = iter(itr) avg = avg or itr.next() yield seqpos, avg, avg for i,val in izip(count(seqpos+1), itr): weight = (1.0 / (i+1) ) newavg = avg - (avg*weight) + (weight*val) yield i, val, newavg avg=newavg
It may very well vary. ~~I'll look this over and process how the hell it works~~ I'll read the docstring that I initially completely overlooked because I'm that scatterbrained, then see what it can do for down_calc. Thanks a lot!
Thanks spiffyman. That means quite a bit actually. Putting together those posts is a lot more work than I'd like to admit. Knowing that someone will get use of it is very rewarding.
Don't really know anything about the subject, so I can't judge it, but a quick search turned up this: https://bitbucket.org/hizel/py-ipfw
&gt; And why doesn't it work with the email module, which provides much better ways of handling individual messages than simple dictionaries? `email` module is awkward. It leaks a lot of header format details to the application (see the whole [email.util](http://docs.python.org/2/library/email.util.html) module). Why do I have to preprocess RFC1522-encoded headers to Unicode, email address lists and dates myself? What a pain. Python 3 version got better, but still have most of these quirks. Python 2 version doesn't even decode text bodies to Unicode for you.
here's one from 2011 http://www.coverity.com/library/pdf/coverity-scan-2011-open-source-integrity-report.pdf 2012 is behind a register-wall.
I'd agree with all that, too. The `email` module is a little verbose. Still, compared to dictionaries of plain strings, I'd prefer to have objects that do at least some of the work of handling headers and MIME properly.
I normally strongly dislike and generally disagree with Stallman, but I kind of feel like when I look at the kinds of walled-garden type of software distribution models that are rising up right now (e.g. "app stores") and the general tendencies of Apple, his sort of radical (and in my opinion wrong) opinions are exactly what we need right now. I hope for two opposing types of silliness cancelling each other out. That said, I'm still a fan of the MIT license.
The Ministry of PyPy Propaganda (which emphatically doesn't exist) is presently purging all references to such unfortunate things. Your post will be quarantined shortly.
&gt; I feel like the author is trying to draw a connection between the release of GPLv3 and the rise in GitHub, and how that plays into developers' attitudes towards licensing. I drew a connection with the mashup generation and the decline of GPL. Github is just currently the unquestioned platform for Open Source collaboration. &gt; It seems to me like licensing norms would've been pushed this way whether or not GPLv3 came out and sparked the debates it did. The GPLv3's release split the copyleft camp into two and caused a lot of discussions about the future of the license. You now have prominent members of the community that declared that they will not license under the GPLv3. This whole debate dragged the viability of the GPL into question.
can you quarantine people using emscripten on pypy too
your editor can be set to display tabs in a way different from how python reads them, which is bad.
Here's some things you can do with complex numbers. http://home.pipeline.com/~hbaker1/Gaussian.html
Non-existant agencies cannot comment on individuals who may or may not be currently being quarantined.
Well, that would be YOUR problem, not everyone else’s, no? So why “fix” a potential problem for everyone else while you don’t have it in the first place?
I love it dearly. It's ideal for a beginner. And experience gained while fiddling with it will serve as solid foundation for learning more complex web frameworks.
web2py is a great web framework and it is improving day by day. I am now working with CMS development, I am one of the developers of Opps CMS http://github.com/opps it is a Django CMS for high traffic and also I am developing Quokka for the needs of another project. I still like web2py very much and I have some websites running with the CMS I developed (http://menuvegano.com.br, http://www.web2pyslices.com and others). But now I am not working full-time in a web2py project because my clients wanted Django/Flask.
a mix of SQLAlchemy and bottle looks a bit strange, given that bottle is minimalist and SQLAlchemy... isn't really minimalist :&gt; but an ORM is nice, so unless you must use SQLAlchemy, there are other lighter options for example, peewee is a cool thing and there's even a bottle-peewee plugin on github, which makes integration seamless
From the looks of it, they aren't doing the same thing at all. Inbox is an smtp server. This is an imap client.
 May I have this dance? 
&gt; Not trying to be contrarian, but what kind datacenter doesn't have ipv6 at this point? [My datacenter]. Our ISP doesn't yet support IPv6, so we pass the savings on to you! Trust me, I get plenty inquiries about IPv6 support, and we're considering an ipv6 tunnel, but most projects either a) don't care b) already run a tunnel.
Good to know. I'm going to go through it and see what it has to offer. Even if I don't use it, I'm sure I'll learn a few things. What I'm still curious about is where to put my integration tests, and if there are any "rules," like all of the standards Bob Martin and his crew have come up with for TDD. I admit I've not read a full TDD book yet - just finishing up "Clean Code" - so my answers may be in one or more of those. One rule I'd be curious about - how many things can/should I integrate at once? Another thing I'm wondering: What do I name my integration test files? Should I just have one big one with all of them in it? Is it totally up to me, i.e. there's no real standard way of handling this? Etc... My search continues.
Too many questions :) I think you should start with unit tests, at some point you will reach the high level interfaces by which your application communicates with the external world (or simply with other components). There, you'll slowly start realising your tests target the behavior of your application rather than assert that your code computes B from a given input A. It's not always clear what should be called functional or integration testing but with some experience you may get a better feeling for it. A [book](http://www.amazon.com/Agile-Testing-Practical-Guide-Testers/dp/0321534468) that might be quite helpful to start your quest. In addition you may read [this](http://www.ambysoft.com/essays/agileTesting.html). Though they focus on agile development teams, they still can be relevant.
I disagree with their overall tone but I can appreciate where they are coming from. Unit tests are indeed faster and easier to setup. This is important because tests that take too long to run are usually not executed at all, and tests that take too long to create are left out by management. With that said, unit testing does not provide the same feedback and both help each other. I would advise doing both but you should understand gradually why you do one rather the other and the risk associated with it. 
[This](http://www.packtpub.com/python-testing-cookbook/book) is also an interesting book for a broad coverage of testing in Python.
I think we need a _new_ Stallman. He's the Hacker Messiah, but the era he belongs to is long gone. I'd say that it will probably be someone in the current pirate community, someone who is as idealistic, driven, radical and outspoken as Stallman. Any takers?
Thanks
Try [Computer Science Circles](http://cscircles.cemc.uwaterloo.ca). My fiancee recently worked through the interactive tutorials on this site and successfully learned the basics.
And referring to your analogies on Math and PHP, I don't think teaching complex calculus from the very beginning is a good approach. If you do it on an incremental way, you can see who is motivated to go on. But anyway I am no expert on this and don't have a strong opinion.
Hmm, I really don't see how this is better than the official documentation. 
Regarding the headers dict: Have a look at the datastructures used in Werkzeug to store HTTP headers. They might be useful for you. You want case-insensitivity for sure when dealing with headers...
Please not. Having immutable objects for something like this is just wrong.
Thank you for that tip. I will take a look 
What does this article have to do with parsing? The focus is on pos tagging
&gt; pip will now warn when installing a file that is either hosted externally to the index or cannot be verified with a hash. In the future pip will default to not installing them and will require the flags –allow-external NAME, and –allow-insecure NAME respectively. (Pull #985) Not a change I welcome personally. Not all packages are hosted directly on the index. 
There's one bug fix that I think is very important: [pip now correctly upgrades packages](https://github.com/pypa/pip/issues/709). This was broken for very long time and it was very annoying.
Thanks a lot for the information. I'm definitely a RESTful HATEOAS journeyman, so I appreciate the advice. With regard to a versioned schema table, I purposefully put off the decision to add anything that would require modification of the database. My experience with legacy databases in the enterprise has been that the most important requirement when building an API facade is that the underlying database can't change (mostly for FUD reasons). In the near future, I'll likely add database-changing functionality as an option. For now, though, I'm focusing on fleshing out the API capabilities. Thanks again for all the info/adivice!
Here is what I did when I was at the university: * create your own "usr" folder: mkdir ~/usr * compile what you need inside: * get python3 (or 2) * ./configure --prefix=~/usr &amp;&amp; make &amp;&amp; make install * add ~/usr to your PATH in the .bashrc * have fun!
This version of pip supports the wheel binary package format. Wheel provides a standardized replacement for eggs and can be used to install things blazingly fast. ## Install wheel (only needed to create wheels, not needed to merely install them) pip install wheel ## Build a directory of wheels for pyramid and all its dependencies pip wheel --wheel-dir=/tmp/wheelhouse pyramid ## Install from cached wheels pip install --use-wheel --no-index --find-links=/tmp/wheelhouse pyramid One of the main motivations for wheel was how slow lxml had been to compile. Now you can compile it once with the "pip wheel" command (runs at the normal speed) but the secord "pip install --use-wheel --no-index ..." command will install lxml in a small fraction of a second. This can be very helpful when making heavy use of virtualenv.
My goal wasn't to make something better than the official docs. Rather, I wanted to fill a gap that I noticed. The examples they provide are very basic and don't provide a solid set of stepping stones in transitioning from them to something more deployment specific. And for a new developer, such as myself, reading the API docs isn't enough sometimes. 
Agree wholeheartedly that cryptography can't just be thrown at a problem to solve it. However, major improvements can be made. 1. Use TLS to encrypt via transport from pipy to prevent network attacks. 2. Require authors to sign their packages at start and maintain with signature to update. 3. Create a security review process and use gpg chain of trust. Create a core team that reviews code signed by pipy's public key. Require some validation of identity to be on core team. Packages unreviewed can be installed after a warning. New updates wont be trusted. Any insecure code on pipy is removed, and if it was signed thoroughly review what else was reviewed.
Go on...
Wheel... because newegg was taken.
This is a huge win from a security standpoint.
First, you still need the initial download, second I don't see how you could *not* be concerned with security, dismissing an easy win for 99% of the community because you run your own index is irresponsible. And finally it's also a HUGE reliability and performance increase.
It's a problem for anyone reading or editing Python code with tabs in it.
Just to add to what's been said... More time is spent reading code than writing it. You're making it harder for people to read your code by importing modules and assigning them to aliases. While numpy.ones(...) involves typing 3 more characters, it saves someone reading your code time because they don't have to figure out what np is. 
Thoroughly recommend Two Scoops of Django...very, very good book for Django beginners.
&gt; First, you still need the initial download Yes. so? You download packages once, you check manually for their md5 once and then stop worrying about it. Let's imaging for one second the main index gets hacked and your package is replaced, you could imagine the perpetrator has even ensured the md5 is properly updated to reflect the new package. What did you gain? You're still relying a system you don't have any control over. &gt; dismissing an easy win for 99% of the community because you run your own index is irresponsible I didn't dismiss anything. However, if security is such a high priority for you, I don't think relying on a third-party server is the appropriate response. &gt; And finally it's also a HUGE reliability and performance increase. How so? As a side note, at my company we had to run our own instance mainly because packages sometimes disappeared from the main index and we were screwed. 
Because realistically, very few people are going to do that. Making the default path more secure is the biggest bang for the buck.
I'm still not convinced it is suddenly more secure. However, I know for sure it's gonna be a pain in the ass to have to explicitely allow every single package not on the index.
* http://pythonhosted.org/sphinxcontrib-httpdomain/ * https://cornice.readthedocs.org/en/latest/sphinx.html
pirate bay?
Mailbox is the backend for my own startup, I've started building a pretty robust system with Django and Celery on top of it. Will see which part I am going to open source next 
&lt;personal_rant&gt; [Dictionaries](http://pythonarticles.com/python_dictionaries.html) [Lists](http://pythonarticles.com/python_lists.html) [List comprehension](http://pythonarticles.com/list_comprehension.html) &lt;/personal_rant&gt; I highly suggest you to read [Python For beginners](http://pythonforbeginners.com) and also [Learn Python the hardway](http://learnpythonthehardway.org/book/) 
\o/
The viral nature of the GPL is a huge issue. I want to release my source code under whatever license I choose, but if my app uses a library that has a requirement on another library that is GPL my entire app could be considered to be under the GPL...
Don't do identity comparison ('is') when you mean to do value comparison (==). "[] is not []" reads as: "the object that represents the first empty list is not identical to the object that represents the second empty list". Which is usually TRUE because Python created two (different) empty lists. 
More of a RESTful question, but I would have had expected a PUT to update an entity instead of a PATCH. But read afterwards that PATCH is supposed to partially update an entity. Any explicit reason to go for PATCH here? Definitely going to test this out at some point (already bookmarked :))
`is not` is not equality. It means "the object is exactly the same as". This is better written as: &gt;&gt;&gt; a = [] &gt;&gt;&gt; b = [] &gt;&gt;&gt; a == b True &gt;&gt;&gt; a is b False Furthermore, try these: &gt;&gt;&gt; a = b &gt;&gt;&gt; a [] &gt;&gt;&gt; b.append('a') &gt;&gt;&gt; b ['a'] &gt;&gt;&gt; a ['a'] &gt;&gt;&gt; a == b True &gt;&gt;&gt; a is b True When you say `a = SomeObject()` (or `a = []`, which is shorthand for `a = list()`), what you are doing is carving a piece of memory and assigning it a name. When you say `a = []` and `b = []`, you are carving two different pieces of memory, and assigning them the names `a` and `b`. When you say `a = b`, you are assigning the names `a` and `b` to the same part of memory. When you're asking `a == b`, you are really saying "does the part of memory that is assigned to `a` has the same _contents_ as the piece of memory that is assigned to `b`"? When you are asking `a is b`, you are asking "are `a` and `b` assigned to the same piece of memory"? I hope this doesn't confuse you more :) --- EDIT: I just noticed this *isn't* /r/learnpython. I'm sorry if I came off a bit condescending, I thought I was really helping somebody understand some elementary concepts of programming :)
Awesome, thanks for the info.
I started typing `pip install --upgrade --force-reinstall -b=/tmp/reallyupgradeyoubastard` every time I wanted to upgrade a package. I'm so glad this is out now.
Ah ok, thanks for the quick reply. Guess I have to re-read the REST principles again 
Another way to think about this is to consider some values that work how you thought this would. `True is not True -&gt; False` --- This is logically true because the compiler only has one value for `True`, and `is` checks the id (AKA the memory address) of the object. All `True` values are the same `True` referenced by different names. Now, it wouldn't make sense for all empty lists to be the same because it makes sense to have multiple instances of an empty list -- they can be used for different things at once, *e.g.* mayonnaise_brands_enjoyed = [] onion_varieties_enjoyed = [] Now, each of those lists is likely to remain empty, but on the rare event that I discover an onion I can stand (mayonnaise is right out!), I wouldn't want to go mixing onions and mayonnaise! 
* http://docs.python.org/2/library/stdtypes.html#comparisons * http://docs.python.org/2/library/functions.html#id Here's [this (visualized with pythontutor)](http://pythontutor.com/visualize.html#code=%5B%5D+is+not+%5B%5D%0Aid\(%5B%5D\),+id\(%5B%5D\)%0Aid\(%5B%5D\)+is+not+id\(%5B%5D\)%0Aid\(%5B%5D\)+is+id\(%5B%5D\)%0Aid\(%5B%5D\)+%3D%3D+id\(%5B%5D\)%0Aa+%3D+%5B%5D%0Aid\(a\)+%3D%3D+id\(a\)%0Aid\(a\)+is+id\(a\)%0Aa,b+%3D+%5B%5D,+%5B%5D%0Aa+is+not+b%0Aid\(a\),+id\(b\)%0Aid\(a\)+%3D%3D+id\(b\)%0Alist\(\)+is+not+list\(\)%0A&amp;mode=display&amp;cumulative=false&amp;heapPrimitives=false&amp;drawParentPointers=false&amp;textReferences=false&amp;showOnlyOutputs=false&amp;py=2&amp;curInstr=0): &gt;&gt;&gt; [] is not [] True &gt;&gt;&gt; id([]), id([]) (161131916, 161131916) &gt;&gt;&gt; id([]) is not id([]) True &gt;&gt;&gt; id([]) is id([]) False &gt;&gt;&gt; id([]) == id([]) True &gt;&gt;&gt; a = [] &gt;&gt;&gt; id(a) == id(a) True &gt;&gt;&gt; id(a) is id(a) False &gt;&gt;&gt; a,b = [], [] &gt;&gt;&gt; a is not b True &gt;&gt;&gt; id(a), id(b) (161170668, 161169996) &gt;&gt;&gt; id(a) == id(b) False &gt;&gt;&gt; list() is not list() True [EDIT] http://pythonconquerstheuniverse.wordpress.com/2012/02/15/mutable-default-arguments/ &gt; And that is why you should never, never, NEVER use a list or a dictionary as a default value for an argument to a class method. Unless, of course, you really, really, REALLY know what you’re doing.
 &gt;&gt;&gt; id([]), id([]) (161131916, 161131916) Thought I'd clarify this, for kicks, as this seems to go against the idea that is checks the `id()` of each operand. What happens here: 1. instantiate `[]` 2. pass it to `id()` 3. return int for address (161131916) 4. throw out `[]` since no names refer to it now (memory is freed) 5. instantiate `[]` (into the same memory as the first, *but this is not guaranteed behavior*) 6. pass it to `id()` 7. return int for address (161131916) 8. throw out `[]` 9. tuplify these ints 
Thanks! /r/IPython [`%doctest_mode`](http://ipython.org/ipython-doc/dev/api/generated/IPython.core.magics.basic.html#IPython.core.magics.basic.BasicMagics.doctest_mode)
Alternatively, as with all pip options, you can set environment variables named like the commands: PIP_USE_WHEEL, PIP_FIND_LINKS etc.
Wow, I'll be back with more questions about the links in that reddit post when I finish getting through them in 4 years :) Thanks! I think I might - at least for now, while I'm learning, and coming to better grips with how this stuff plays together - write a few dependency tests (e.g. in `test/dependencies/test_dependy_foo.py`, if that works for my test-runner) for anything I'm concerned may change out from under me later. This way I don't have to realize that a dependency changed when my own tests fail. I can just see immediately that my own tests *of* the dependency are suddenly failing, *along* with my own tests, telling me that my code may be fine, but out-of-sync with some 3rd party library. As long as they don't take long to write, I could see dependency tests giving me one more level of assurance, and simplifying tracking down errors that arise from liquid dependencies.
Thanks, I guess I took that bit for granted. Added it in.
Ditto, I've been working on setting up a celery cluster for the past two weeks and it's been a bit of a rollercoaster. Now that I've got it all up and running I can appreciate the sheer power of celery, but getting to this point has been a real battle.
For some (and not only "freeloaders") it is exactly the GPL's (and LGPL for libs) strong point. I choose this license for my software exactly because it is quite strong.
Randomly generate some bytecode. Guaranteed segfault.
Any notable packages that have uploaded wheels on pypi ?
I assumed it was "No point in reinventing the..."
The other commenters are right, the gist is that `is` compares on strict equality, and those two instances of the list class are separate, but equal. The reason you can use `is` for some special values, like `None`, is because `None` is a singleton object.
I never thought about it, but now a realized what the difference between "is" and "==" is. Thank you.
Canvas is just used to create an OpenGL context, nothing special. WebGL is only ever so slightly different from Open GL ES 2. The best way to learn WebGL is in fact to read the GLES2 specification. And GLES2 is almost identical to modern OpenGL, but with fewer features and a few tiny incompatibilities (all resolved in the next version of GLES/WebGL as I understand it). Anyway, none of this has anything to do with the fact that OpenGL/WebGL suck to use directly, and three.js doesn't.
In the interpreter itself? Never. Language gotta be small. In the standard library? Maybe, but I'd say very unlikely for now. It would put certain requirements on the library which might or might not be accepted by the developers of Pandas. For example they'd need to adjust to python release schedule, have stronger requirements on code compatibility, etc. These requirements are good for a mature projects, but not so much for a fast-evolving one. Also, pandas require quite a lot of other libraries (numpy, hdf, etc.), whose developers would need to also agree to become part of standard library. This is really lots and lots of code. In some python distributions? Already happens. For example [Anaconda](https://store.continuum.io/cshop/anaconda/) already bundles Pandas and lots of other science-related packages together in a single installer. Most popular distributions of Linux also come with these libraries available as normal system packages, so kind of part of normal distribution.
PyQtGraph has some nice OpenGL convenience wrappers. 
Oh boy was this annoying. Glad to see it fixed! Thanks for pointing this out.
Did they fix the fact that editable packages are blown away when you install them again. i.e. Step 1: install package as editable, Step 2: make changes, Step 3: commit changes locally, Step 4: run pip install -r requirements.txt, Step 5: start drinking because your locally committed changes are gone.
Probably not until well after numpy gets integrated... so don't hold your breath on it.
I have literally never gotten this argument, except in the context of those odd aligning people who like to "indent up to the brace". If you're not one of those people *why do you care* what the indentation is? It's just a marker of depth. I find 2-spaced indents *really hard* to read, par example, and using spaces just makes things worse then. Sometimes 8 spaces is nice, even. Tabs should never cause a problem in real code. If they do I can conclude that you're doing it wrong. Plus, some people legitimately like proportional fonts (I do, but my current set of monospaced fonts is better).
Back to the original point, if you're using tabular data, tab sizes and types are irrelevant. You'll be aligning with spaces either way. *In code* you should never care how large a tab is. Additionally, what Lattyware says.
Ha nice. I literally just did this today. I wrote a flask app so I could learn another framework other than Django. I used a guide at the bottom of this post http://maximebf.com/blog/2012/10/building-websites-in-python-with-flask/ as a guide. The only difference seemingly is using supervisor which I like. I did find it was good for me to start without supervisor to make sure the connection to nginx was working and then move to supervisor. Good reference though.
While, anecedotally, I agree with the author that the author knows more about [database normalization](https://en.wikipedia.org/wiki/Database_normalization) than their long-haired opponent; I disagree with what seems to be a fundamental premise of the argument: that a normalized database "in fifth normal form" is superior to a (naievely) [denormalized](https://en.wikipedia.org/wiki/Denormalization) database. I disagree that a model is better "because it needs more JOINs" or "because there is less duplication of data." Fifth normal form may be "technically correct", but woefully inadequate for most real-world applications that need to scale. Dear DBAs: please store your schema and test data in version control. [EDIT] From [here](http://www.reddit.com/r/Python/comments/1gpr4u/zodb_actively_maintained_python_3_beta_available/#can2dfg): &gt; Does [...] maintain [referential integrity](http://en.wikipedia.org/wiki/Referential_integrity) and/or [propagation constraints](http://en.wikipedia.org/wiki/Propagation_constraint) so as not to leave [dangling pointers](http://en.wikipedia.org/wiki/Dangling_pointer)?
I think we would be erring if we ruled out that it was ALL THE JOKES.
Fifth form normalization looks like something that happens when a manager says all fringe cases must be accounted for. Third form is what I've been using most, and I came upon that on my own (it makes sense when you think about it). Fifth form is like a mathematician's answer: technically correct but probably useless in a practical situation.
&gt; Are these data structures the kind of thing that would ever be included in a base python build? * [Pandas requires numpy](https://github.com/pydata/pandas#dependencies) and a number of other libraries that are not likely to be included in the [Python standard library](http://docs.python.org/2/library/). * [`pandas.core.frame.DataFrame`](https://github.com/pydata/pandas/blob/master/pandas/core/frame.py#L338) requires numpy (`import numpy as np`) * https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt 
* https://en.wikipedia.org/wiki/Reification_(computer_science)#RDF_and_OWL [*](http://www.reddit.com/r/semanticweb/comments/1dvakc/schemaorgdataset_standard_schema_for_linked_data/) * https://en.wikipedia.org/wiki/Eigenclass_model#In_RDF_Schema * http://docs.sqlalchemy.org/en/rel_0_8/orm/extensions/declarative.html#declarative-inheritance * http://pythonhosted.org/SuRF/index.html * https://en.wikipedia.org/wiki/Search_engine_indexing
Why do you think it's OK for your editor to show you code differently from how Python sees it?
I'm not sure what your point is unless it's "Sometimes it has applications." I wasn't denying that. But for most programs I've come across, third form with many-to-many relations suffices. I will also cavaet that with that I've primarily worked with small webapps. Nothing exceeding a few MB of data, tops. I get that for huge programs a more nuanced approach is required. Normalization vs Denormalization is a debate that can rage for hours and hours. I'd say that a smartly normalized database will probably out perform a naively denormalized table. However, a smartly denormalized database will probably out perform a poorly normalized database. It's more about how well it's designed rather than what design pattern is used.
Would be a good to include those screenshots in the readme
What's flask and WSGI guys?
These three links should help you: http://bit.ly/17F3nPi , http://bit.ly/11flkD4 &amp; http://bit.ly/11flryz You're very much welcome. 
[Flask](http://flask.pocoo.org/) is a library for making web apps. It's simple and straightforward, but powerful enough to do interesting things with. [WSGI](http://en.wikipedia.org/wiki/Web_Server_Gateway_Interface) is a way of connecting web apps in Python (like a Flask app) to web server software that actually takes incoming network connections. You can use any app that supports WSGI along with any server that supports WSGI. In this case, a Flask app is being served to the world by uWSGI, a server which supports WSGI.
Hm, PyPy once had a Javascript backend, which is now abandoned: http://www.mail-archive.com/pypy-dev@codespeak.net/msg03951.html "Re: [pypy-dev] pypy appears to have entirely removed all mention of javascript back-end support from web site" &gt; We found out it's impossible to provide a reasonable subset of python under JS, still being a subset and not being something which has a common intersection. I don't fully understand this, but seems like emulating everything at a lower level (pypy-&gt;c-&gt;emscripten-&gt;js) is a more practical way of making a strict subset of Python - more so because it builds on existing projects (RPython's existing C backend, LLVM, emscripten) There is a bunch of projects which aim to translate Python code into Javascript, the Pyjamas (aka pyjs?) is one, and the ["alternatives" section here](http://en.wikipedia.org/wiki/Pyjamas_\(software\)#Alternatives) lists several more
Flask is to make websites using python. WSGI is to translate the above to something a webserver can understand.
Fuck that, mod_wsgi and apache2 FTW.
Thanks. Coming from PHP, the power, common sense and fun of Python is damn cool.
I haven't tried it, but Coin seems to be what you want. It's a high-level 3D API based on Open Inventor. It has a python binding called Pivy (http://pivy.coin3d.org/). Sadly, the web site is well out of date and docs look poor. I have more experience with VTK (The Visualisation Toolkit). This is more targeted data visualisation. If you want something lightweight, VTK is probably not ideal (the library has 1925 classes) but for putting togather a quick 3D visualisation, its very effective and easier the programming OpenGL directly.
This is OK, that said I think the setup for uWSGI is overly simplistic. I'd recommend a config file and using emperor mode, threads, and a master process at the very least. Here's an example INI: https://gist.github.com/radiosilence/5714387 Which demonstrates support for running an external daemon, also. Personally, I've switched to the fastrouter/subscriber-server model: http://uwsgi-docs.readthedocs.org/en/latest/Fastrouter.html which is kinda nicer for permissions, as it allows nginx to look for all of your uWSGI stuff on a single TCP socket, and then have that routed to any number of clusters of uWSGI processes, including non-local ones (read: horizontal scale made piss easy).
Ditch supervisor, run uWSGI emperor as a proper init daemon. Supervisor is just another point of failure. In fact, with attach-daemon and smart-attach-daemon, uWSGI can act as a pretty fantastic process manager.
&gt; In fact, with attach-daemon and smart-attach-daemon, uWSGI can act as a pretty fantastic process manager. Are you using that in production ? How do you have separate logs for each daemon ? Does it work with logrotate ? 
Yea.. this is something I really like about web2py -- to use any webserver you like :-) Besides of this, w2p can also be used quite powerful as a SOA middleware (i.e. just deploy services at controller level).
ditch php and regain sanity
Kinda toying with it at the moment. I think if your command specifies a log path you can use separate logs.
I don't see anything about three.js that makes me think that it's particularly browser-specific. What design choice in three.js are you thinking of that invalidates OP's question?
yeah that's not really the discussion culture here in this subreddit
IIRC, the canvas API (which three.js uses) is specific to the HTML DOM. Of course it is possible to implement the same API in other contexts, and I'm pretty positive there are some implementations of JavaScript with an HTML DOM API that target desktop or mobile applications. But I can't see how three.js would make sense outside such a context. It doesn't wrap OpenGL directly, it wraps Canvas, so if you don't have a Canvas, I don't know what three.js is supposed to do. It doesn't invalidate the question at all, I just thought I'd note that three.js solves a slightly different problem than a Python wrapper on top of ("native") OpenGL (sans Canvas) would.
Exactly. I'm grateful to php, but I wish I had learnt Python or Ruby 7 yrs back. Sigh.
I don't think you understand the role canvas has with three.js. It looks like there are two roles: one is for the 2D mode, which isn't relevant to OP. However, for that, a "three.js-like-thing for Python" could use Pygame or Cairo without any difficulty. Canvas is not really unique at all, it's just special because we didn't have Pygame or Cairo for the web before canvas came along. The second role is the one I think deserves some more explanation. Canvas is used to create an OpenGL context. three.js doesn't "wrap canvas" -- it creates a canvas element, tells Firefox "use this canvas element for WebGL", and then never touches the canvas object ever again. From then on, like any other WebGL code, it uses the WebGL API, which is nearly identical to the OpenGL API. Canvas here is being used to reserve space on which OpenGL renders. It's a messy job, the details differ from platform to platform. So there's wrapper APIs -- on the web, the wrapper API you use to create a context is Canvas. On the desktop, you would use GLFW (or something older). At all times except context creation, three.js is only really touching the OpenGL API. So if we were to create a three.js for Python, we'd replace the context creation using canvas with context creation using GLFW, and we'd replace calls to WebGL with calls to OpenGL. At any rate, none of this, as far as I can tell, affects the API that three.js exposes, so you could write a module with the same API for Python fairly cleanly. Just instead of canvas it'd use GLFW, and instead of WebGL it'd use OpenGL. (I need to be careful here because while I've used WebGL, I haven't used three.js)
The difference I was trying to highlight is that the scenarios in which you would use either are different. three.js targets browsers and HTML contexts; but for Python, you want to target the desktop directly. So the request "something like three.js but for Python", I think, deserves a tiny bit more clarification. That is all.
7 yrs ago finding a cheap hosting for ruby or python was a nightmare, that's probably why you ended up with PHP.
Shouldn't denormalized will outperform the normalized one?
Setting up on an EC2 instance... http://h6o6.com/2012/12/configuring-multiple-flask-sites-with-uwsgi-and-nginx-on-an-amazon-ec2-instance/
I was just about to make a game or two in Python / pygame so the timing is perfect. Anyone interested in teams?
I'll team up with you, if you'd like.
Pull requests will be accepted :D I'll see if I can't throw together a page with them. I'm more working on the Git driven feed combining and stats. The interface is usable, but the archivist slant with Git diffs, progressive caching, and how it can integrate with other feed readers are the kinds of things I'm looking for feedback with.
+1
&gt; how do i put it out on the web for developers to download and use considering the fact that its opensource? --- Look at [GitHub](http://www.github.com) or [BitBucket](http://www.bitbucket.com) for hosting your code online. Since it's open source, you should be fine with a free, public profile. &gt; how do i fund the hosting of the website ...? --- With GitHub, you can host a static site for free, so you'd not have to worry about it for a little while. Some projects accept donations -- YMMV as far as response and tax-related things. &gt; do i need to inform the author of every library that i have used before putting the project out there? --- Depends on the licenses for the code you used. Most don't require any notification, but there a plenty of things they can require -- **make sure you've read and understand them**.
Very useful. Thanks
I'd also be interested :)
Given a reasonably competent design, yes. At the cost of becoming eventually consistent.
logging is one of those libs that's just good enough, so nobody replaces it. i thought it might be a better idea to make it easier to use instead of tackling the topic completely.
I'll definitely enter again. Last time I tried to make an MMO. It went okay. I may give it another shot.