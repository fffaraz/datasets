What is the worst that could happen - having to reinstall python completely? Is that really *so* bad? I mean if you're in production then yes, but this is my linux box here. 
Looks good, anyone know if there's any plans to implement errorbars?
Sorry, im a newbie and a half do you mind elaborating on this... now my file reads: P:/Hfref/Neyvqvb Qboen/Qrfxgbc/xy.gkg could this be used to then decrypt the file to its original cyphertext?
I definitely see the benefits for using virtualenv. But, just out of curiosity, I've had difficulty in the past (this was years ago) when installing/setting up some packages like scipy, numpy, matplotlib or sklearn. Would you suggest using the system's package manager? Also, if you install them in a virtualenv, do you have to redo the full install for each project? The last time I installed some of these packages it took a while (though that computer was kind of old and slow). 
OH yay me i know a python joke... i belong :) .... will let you know if its any help 
Python 2.7 only though! You can't do in-solution debugging (as far as I can tell) with that site either. I think your notebooks are much better. Only tried a couple but I look forward to working through the rest, thanks :-)
FileSave is (I suppose) the name of the file to be saved: &gt; FileSave = filedialog.asksaveasfilename(defaultextension=".txt") What you need is the file descriptor to write; which you created with the "with" keyword: &gt; with open(FileSave, "w") as File: So you actually need to use "File" instead of "FileSave".
&gt; Would you suggest using the system's package manager? Absolutely! &gt; Also, if you install them in a virtualenv, do you have to redo the &gt; full install for each project yes, I try to put stuff in a common requirements.txt or a script that I can run when I create a virtualenv. You could do as https://www.reddit.com/r/Python/comments/3cefm8/toyplot_a_python_plotting_library_from_sandia_labs/csut564 suggested (although I am not sure how supported / popular this approach is)
/r/learnpython
It's my personal experience. In schools and education, python is used a lot and very popular, in real life, business and industry, it's much more Java, C++ and others. So while everybody raves about Python, the industry says: "Not really". Is it used in the industry, absolutely, is it rising/declining, imho it's declining, and this google move is an example. They tried to push it, but it wasn't accepted as much, so providers like google follow their customers and drop the push. The talk about the new binary web (WebAssembly) that is coming, is it python? No, it's C++. This is another example. The industry just doesn't want python. The whole 2.x, 3.x incompatibility is one of the stupid mistakes we can note down in IT history. It's their own fault. 
Create a simple webapp with Flask. Simple is the keyword, don't get hung up on fancy features. Make it demo something- maybe like what Ewildawe suggested. The key is to keep it simple, so you actually finish something. Share it with us!
I think you are in over your head and should go back and review your coursework and preliminary excercises. This looks like and end of term/year project and you didn't spend any time practising earlier in the year.
with open(filename.txt, "w") as variable 
The animation feature is really cool. Thanks for sharing. 
I guess my point was that if it's actually bad, then it should be easy to provide a couple highlights as to why. I know nothing about Atom, so I was genuinely curious. His response below just showed me that he's a jackass, instead.
&gt; hink you are in over your head and should go back and review your coursework and preliminary excercises. This looks like and end of term/year project and you didn't spend any time pra True. We had teacher problems... over the cource of the year our teacher changed 5 times... and we were given this a month ago with NO practise.... 
I wouldn't doubt it, I just didn't take the time to check. 
[Look here](http://nbviewer.ipython.org/urls/gist.githubusercontent.com/darothen/ecef11a02d518796a089/raw/6429a73f8d647d2a31fb5852a5184c70af744655/pandas_groupby.ipynb). 
Computer died; instructions unclear
&gt; saying you're calling write() on FileSave, which is a string and that you need to call write on Yes the error has been resolved but when i load the file it says 'none' :S
More information is needed to help you, which python framework are you using? which webserver?
Then could you tell me how i can install via a package manager inside my virtual environment? Because the reason i switched to linux is to be able to simply install the pre-built binary's to make it simple. Like scipy, numpy, graph-tool, ect.. 
You can also do `pip install --user` to install into your per-user package tree.
[like this?](http://bokeh.pydata.org/en/latest/)
Cool. My aim was to build a simple utility rather than a library. I'll look into pandas if I need to do any serious data work in the future.
Sorry so are your notebooks in python 2.7 it 3? Can't check whilst on phone.
Double check your open flag. You might be using 'a' or 'r'. Which would return none if it doesn't exist. Need to use 'w'.
there are a lot of libs written on top of theano. I'd say [keras](https://github.com/fchollet/keras) is the simplest by far though. I mean, come on... model = Sequential() model.add(Dense(20, 64, activation='tanh')) model.add(Dropout(1/2)) model.add(Dense(64, 1, activation='relu')) model.compile(loss='mse', optimizer='rmsprop') model.fit(X, y, batch_size=32, nb_epoch=100) 
You should check out the documentation, or Google that one. If it's googlable, it's not fair to ask people to think for you. But, Write takes an argument which is the thing you write. Aka. Fileobject.write(somestringtowrite)
I wrote a function that outputs my cell phone number if run from the Python command line...but that's kinda niche; it fits my personality.
I'm so ready for that matrix multiplication operator. It's going to make my code so much more legible.
Thanks! I will look into it and let you know how it goes!
Those y-axis labels though. 
From the tutorial I see the following quote, "Toyplot figures are beautiful, scalable, embeddable, and interactive" Is there any documentation on how to embed these plots? I'd like to try putting them into a PyQt gui. If its similar to how matplotlib figures can be embedded then it would be super useful. I didn't see anything in the tutorial, user-guide, or API reference about procedure for embedding the plots. Edit: I filed an Issue on the official github page. It could be by embeddable they just mean the plots can work inside of ipython / Jupyter or something like that. It could be I misinterpreted it to be embeddable in the same way for instance a matplotlib figure is embeddable into various GUI libraries.
Commenting to save as I am on mobile
Looks great! I'm probably not alone in saying that I am willing to move away from matplotlib as soon as a viable competitor emerges. This looks really promising!
i cri thanks for this!!!
 async def read_data(db): async with db.transaction(): data = await db.fetch('SELECT ...') Dope.
&gt; The values of the matrix are of magnitude e-16, so I suspect this is why my matrix is so ill-conditioned. If **every** matrix element is of the order of 1e-16, you should be fine, but if even one of them is of the order of 1e-2 or above, you may be in trouble. As well, depending on which operations you performed on the original data used to construct this matrix, you might be in trouble (what is the order of magnitude of the original data? Did you perform a subtraction?) The reason is that the default type for floating point calculation is Float64 (called double in C). The precision it guaranties is around 14-16 significant figures. That means that, in any programming language you would get: &gt;&gt;&gt; x = 1. &gt;&gt;&gt; for i in range(1000): x+= 1e-16 print("x is equal to: ", x) x is equal to: 1.0 # &lt;-- see that, nothing was added up because 1e-16 is too small while &gt;&gt;&gt; 1 + 1e-16 * 1000 # &lt;-- added the same amount (1e-13), but at once 1.0000000000001 # &lt;-- this time this was taken into account All of this because change beyond roughly 15 orders of magnitude cannot be taken into account in memory! However, &gt;&gt;&gt; 1e-200 + 2e-200 3e-200 because it is the **difference** in order of magnitude which is important. So you need to make sure that there is no value in your matrix above 1e-3. I'm also curious about subtractions because they are the origin of the most blatant rounding errors in programming (again, this is not Python specific): &gt;&gt;&gt; (0.1+0.1+0.1+0.1+0.1+0.1+0.1+0.1+0.1+0.1) - 1 -1.1102230246251565e-16 As you can see, instead of cancelling perfectly, there is a residual of the order of... 1e-16... The residual is due to the way floating point numbers are represented in the computer memory. This is not Python specific. This residual is nothing but an artifact, an error, something that shouldn't mathematically exist. Depending on how you generated your matrix S, all the e-16 values might well be errors like this. If that's the case, you can set all these values to 0. &gt;&gt;&gt; S[np.abs(S) &lt; 1e-15] = 0. -------------------------------------- &gt; Otherwise, it should be invertible....all values are real and positive. I must insist. Real and positive is not enough to guaranty that S is invertable. &gt;&gt;&gt; S = np.array([[1,1], [2,2]]) &gt;&gt;&gt; np.linalg.det(S) 0.0 is **not** invertable. because its columns are colinear. Try to calculate the determinant of your matrix S. If it is very small or even equal to zero, that means that at least two columns are colinear (or very close to be, which induces instability). &gt; I think the best thing to do is (1) to multiply all matrix entries by e+17, That shouldn't change the condition number by much: if every matrix element is of that order of magnitude and if you are sure that these are not random noise provoked by rounding error, then you should leave them as they are. But you can try, that won't change the fact that your matrix is ill-conditionned though. &gt; and then (2) instead of inverting the matrix S, solve Ax=b where the solution x is x = solve(A,b) (e.g. in Python, numpy.linalg.solve() ), Yes, that's it! However in the specific case that your matrix is ill-conditionned **because** det(S) ~ 0, then you would still be in trouble because a non-invertable matrix **is** non-invertable. In all the other case, your problem is solved: &gt; For my equation inverse(S) * d, that is actually solve(S,d). This is exactly what you should always do! &gt; Any other ways to make my ill-conditioned matrix well-defined? Nope, ill-conditioned matrices **are** ill-conditioned and you can't do much about it. You may find some tricks to "solve" the problem of ill-conditioned matrices. But these tricks only solve half the problem: they guaranty you that the result that was given to you is exact to a certain degree in the case that the number in your input matrix S are perfectly exact. Most of these tricks are already used by `np.linalg.solve` so you really don't have to care and that was the whole point of using `solve` in the first place instead of direct inversion. But your problem is not limited to that. Your real problem is that the **slightest** error in your input will generate **HUGE** differences in your output! &gt;&gt;&gt; import numpy as np &gt;&gt;&gt; d = [10, 1] &gt;&gt;&gt; S1 = np.array([[0.999999999, 1.0000000001], &gt;&gt;&gt; [ 2, 2]]) &gt;&gt;&gt; S2 = np.array([[0.999999998, 1.0000000002], &gt;&gt;&gt; [ 2, 2]]) &gt;&gt;&gt; print("S1 condition number is:", np.linalg.cond(S1)) S1 condition number is: 4545452658.52 &gt;&gt;&gt; print(np.linalg.inv(S1)) [[ -9.09090926e+08 4.54545463e+08] [ 9.09090926e+08 -4.54545462e+08]] &gt;&gt;&gt; print(np.linalg.inv(S2)) [[ -4.54545440e+08 2.27272720e+08] [ 4.54545440e+08 -2.27272719e+08]] &gt;&gt;&gt; print("S1^-1 . d:", np.linalg.solve(S1, d), " DET(S1):", np.linalg.det(S1)) S1^-1 . d: [ -8.63636379e+09 8.63636379e+09] DET(S1): -2.19999995998e-09 &gt;&gt;&gt; print("S2^-1 . d:", np.linalg.solve(S2, d), " DET(S2):", np.linalg.det(S2)) S2^-1 . d: [ -4.31818168e+09 4.31818168e+09] DET(S2): -4.40000014201e-09 The tricks I was talking about guaranty you that `[ -8.63636379e+09 8.63636379e+09]` and `[ -4.31818168e+09 4.31818168e+09]` are correct given `d` and `S1` (or resp. `S2`). However, as you can see, the result itself, even if computationally correct is not guarantied to be mathematically correct. And to this respect, almost nothing can be done. &gt; At the moment, the condition number is e+19. Which is very high and confirms that the correct answer in this case should be "my matrix is ill-conditioned so solving this problem would be as effective as playing dice". All that said, you might be able to reformulate the problem in a broader way. Do some algebra and see if you could decompose the problem in of few of them among none of which you need an ill-conditioned matrix. For instance, if your matrix is built from other matrices, that could to the trick, but you really need to perform some serious algebra before thinking of calculating it.
I'm pretty sure they meant [venv](https://docs.python.org/3/library/venv.html) (and the corresponding pyvenv utility)
Doesn't seem to be well tested. [Bug already](https://github.com/black-perl/ptop/issues/4). The developer definitely put a lot of work into this and keep up the good work!
True, it has always been a pain in the ass to change the x and y limits when having subplots in matplotlib. I beleive I might just be to hard wired to change my plotting ways. Although with Pandas managing subplots is really easy it can be done by just saying: df.plot(Layout=(3,1), subplots=True) 
&gt; sudo pip install *can* ... emphasis on the *can*. I've used Python and "sudo pip install" for over a decade on various linux systems including Ubuntu and RedHat and at no point did it cause problems. But can it cause problems? Sure. So learn about python virtual environments and chose when to use that instead of "sudo pip install".
Can i ask what kind of work you do with Python that this comes up often? Math in academia? Engineering?
Thanks for prolonging bad habits that reflect poorly on our ecosystem. But hey go ahead, being a contrarian can be fun too!
No biggy, you'll be just fine :)
`zipapp` is nice, but you can't get most of it, if Python devs won't finally make it possible to import `.so` extensions from zip.
Hi there. You have posted a beginners question to /r/python, however it is far more suited to /r/learnpython, where users are actively interested in helping with beginner topics. Please resubmit it over there! Make sure to read their sidebar rules before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." Cheers &amp;amp; best of luck!
Thanks :)
My advice is to quatify everything. Don't just say "I know how to use celery task queue", say "I reduced long running tasks by 40% using a distributed task queue". Focus on general patterns, not tools. Ideally both if you can make it look right. Feel free to take a look at [my resume](http://registry.jsonresume.org/traverseda), I'm told it's very good. Not sure how applicable that is for an academic resume.
I think it's good your encouraging best practices, but you shouldn't call people names. Your comment would be a lot better received if you didn't call his comparison idiotic.
I started with pascal on 2004. It was fairly simple for learning to program, but then I quickly moved to C, C++, and Java. So, I don't think learning a simple programming language will difficult learning more complex languages later. It is more about the concept than the syntax. just like learning english or spanish it is all about the meaning. 
The more languages the learn, the easier it gets. There are hardly any programming languages that would "spoil" you; each of them has some unique thing about it that will shape your thinking in a certain way and expand your horizon. Also, in comparison, Python isn't very clean at all - the syntax is very accessible, and it often tries to act in a way that is intuitive to non-programmers and beginners, but this has a few consequences that eventually make it no cleaner than any other of the mainstream languages. So, by all means, go with Python first, but be sure to also dabble in a few other languages - even if you make Python your preferred language, you'll learn a lot of things that will make you a better programmer overall. And if you like any of them better than Python, then you'll still see that a lot of the things you learned in Python transfer.
Plots are pretty, but have you read the License? " the U.S. Government retains certain rights in this software." WTF? 
Once you start to learn some of the underlying data structures and how to manipulate them to do what you want, learning a new language usually just involves learning a new syntax. I say "usually" because there are some languages--such as Haskell or Prolog--built around programming paradigms that, for someone new to these paradigms, take a significant amount of effort to gain proficiency. So, the short answer is: no more than other common first languages.
I feel that it honestly is a great language to learn first and then move out into others, as it has a very low barrier to entry and gives you the mindset you need to understand the basics of coding. You may find yourself hating semicolons more than others who started on something else, but the languages themselves you just need to learn the basics of and it gets smoother from there. The two hardest parts when learning new languages for me has been the paradigm shift and deployment, not really the code itself. For paradigm shift example: Javascript is not hard to code, but require's understanding that by nature it wants to be asynchronous and silent failures, which feels very odd when coming from Python. Deployment example: Python itself can feel as if has far to many ways to be deployed (script, wheel, egg, virtualenv vs system package, etc..), and a lot of other languages suffer the same problem *cough* Java *cough*
I wonder whether goodDayM's response comes from the *way* you phrased your advice. You didn't explain *why* one shouldn't use sudo pip. For one thing, this makes people less likely to take your advice. For another thing, it's more useful to explain why you're giving the advice so users can know when to take heed and when it's safe to ignore. 
Pointers will mindfuck you, but you should be fine :)
Also, pypi is not curated at all. Anyone can upload whatever malware they want and if you `sudo pip install` a typo, you could be executing arbitrary code as root. Just don't use sudo with untrusted code, and pypi packages are not trusted.
First of all, Python 3.5 has not been released yet; it's still in beta. The current latest version is 3.4.3. &gt; I think python 2.7 is better because it is not being developed and is finished. That's just a ridiculous assertion. By that logic, you should be using Python 1.1, since it's also not being developed. And while you're at it, you might as well use Windows 95 or OS X 10.1. Those are also not being developed. Being not developed does not mean something is better, it means it's not being developed. All of these things I mentioned are ancient and have numerous bugs and security vulnerabilities. And Python 2.7 *is* still being developed. It gets bug fixes and security updates, and on rare occasions, it gets backports of new features, such as the SSL changes. This was done because it was argued that it was a security feature. But that doesn't mean you should use Python 2.7. Python 2.7 is a dead end. You will eventually have to upgrade, so why not do it now? The excuses of the past, like modules not supporting 3.x, are mostly gone. If you are using learning resources that teach 2.x, then get better learning resources. Don't blame Python for improving itself. There are dozens of design blunders and other mistakes that were fixed in 3.x, not to mention a heap of new features and improvements. Python 3.x is by far more consistent, especially for a beginner.
You'll need to mention https://cryptography.io/
As someone who has studied toolchains extensively, the thought of loading a `.so` file from inside a `.zip` gives me implementation nightmares.
I would temper this response by advising you this: if you are fortunate enough to know what general area and modules you will be working with, go and look at what they support. I started Python on 3.x only to find that significant functionality for working with Hadoop components was only available in 2.x for example, and had to port (which was actually quite easy, but that's beside the point).
no, it doesn't impede learning. the more languages you know the more quickly you can add new languages. however, it does make using languages that aren't python unbearable. 
Doesn't count. There's only one semicolon and it's used to initialize the parameter.
Sounds like a good problem. You should submit a pull request...wink wink :)
Fair enough. 
There's hardly anything mindfucking or even difficult about memorizing what that handful of operators and functions does. There's what, like 6 of them? I guarantee most C programmers can list that off in their sleep. Also, if you mean what I think you mean, the standard library function is realloc, not frealoc :P
one reason is that debugging memory corruption can be hard.
&gt; Also, if you mean what I think you mean, the standard library function is realloc, not frealoc :P Proving my point :p
Doesn't it depend on how zipapp is / going to be implemented? If it just unzips the app to temp and then executes it a la virtualenv, then wouldn't that be pretty easy to implement? Disclaimer: I have no idea how they've actually done it.
I mostly use C++ and Python. 
I actually started learning C/C++ in high school and found it quite obtuse. Then I discovered Python, learned that, and only now, more than a decade later, I'm starting to learn C again. I find it a lot easier this time around. I feel since I've already gotten a handle on a lot of programming concepts - variables, data types, arrays, control logic - I can concentrate on the more complex but necessary features, such as the aforementioned memory management. If anything, Python has prepared me for learning C.
The GUI was a very useful paradigm, and quite powerful. The only reason I needed to switch to JASS was to overcome some of the GUI limitations (such as memory leaks) and to do more advanced things like custom Spells, where using the GUI was much more cumbersome than more simple game logic.
except that you could just hard-code the parameter(s) and then it really would be one line.
Thanks for the SO link. I've seen that solution before and it might be the correct one im seeking. I've also used the path string in the past, just looking for pure dot syntax.
The screenshots doesn't reflect the title. How this tool can be a better task manager when we see not much as 5 task by default on a big screen :/ CPU/Mem graph is cool for the history, but i don't think that should be the default. Or rephrase your headline :)
I'm a Python software developer, have been for over 10 years. I also manage various servers and VMs for several users - which all have Python on them. Virtualenvs are great, I use them, I also happen to use "sudo pip install". There is a time and place for both. You can let people know about the pros and cons of different ways of doing things.
C types are complex *because* it doesn't abstract the machine. OTOH once you understand the machine the types are not so much of a problem. 
I've always found Graphviz best for this http://eli.thegreenplace.net/2009/11/23/visualizing-binary-trees-with-graphviz has some code in C - should be trivial to translate to Python
Don't new versions of pip come with wheels that allow for quicker/easier compilation?
You are correct, thanks. I get paid to write python software and in my work I use both "virtualenv" and "sudo pip install". They're both fine - just different trade-offs, time, risks, and such.
Just released a new update, can you please report on the index error ?
&gt;Also, in comparison, Python isn't very clean at all - the syntax is very accessible, and it often tries to act in a way that is intuitive to non-programmers and beginners, but this has a few consequences that eventually make it no cleaner than any other of the mainstream languages. Could you explain what you mean? I'm a beginner so I'd like to know some examples. 
Can I embed this in `wx`? Looks nicer than mpl.
A lot of the problems tend to appear when people don't use reference counting while writing non trivial programs. And unfortunately debugging memory corruptions is an awful experience which further confuses people in situations where reference counting isn't the solution.
&gt;collections.OrderedDict is now implemented in C, which improves its performance between 4x to 100x times. Wow, I've didn't notice this until now. This is a pretty big change.
That's a good point, I hadn't thought of that. In general, I think using a semicolon is cheating but I have to agree with you here, since it was only for code legibility.
No, in fact, most "learn to program" courses I see nowadays teach you the easy languages first, like Python and VisualBasic and such. The hardest part about your first language is just getting in the coding mindset. Once you understand the basics of programming, it'll be much easier to pick up other languages. And it's easier to learn the basics of programming when the syntax of the language is easy to learn.
I learned python before JavaScript and Ruby. It didn't make either language harder to learn, it just made me wish they were python. :-) Full disclosure... Prior to python I had a lot of experience with C and C++ so maybe I'm not the best test subject.
No. You can even run these native libraries directly from memory where the decompressed data is stored. All you need is "only" your own dynamic linker. The actual problem is that the given native library might also have dependencies. Google for ABI compatibility. 
Is that the end of CX_freeze et all then? Also maybe this is the point you were making and sorry if it is, but does this also zip any native code libs?
I would assume so but maybe because of the GIL it's a complete new process. Probably just a thread though.
Probably because they learned a non-pointer language first. Hence an answer to OP; probably a good idea to learn C first. One of my friends IRL wanted to learn Python and C; I gave him the same advice: C first.
[Learn C first](https://www.reddit.com/r/Python/comments/3cgocl/does_learning_python_first_impede_learning_other/csvp3yy). Then Python. Then C++, Java or any other language (or none, focus on algorithms/data-structures instead) if you feel like it. Also have linux (and try to make it your daily driver) as a dual boot if you use Windows. If you use Mac OS X, then probably you're fine (if you setup bash, gnu tools, git, homebrew all that stuff, but I never used a Mac). Also learn a good text editor: either vim or emacs (or both). Just my opinion.
I got a contract high from reading this
There is the [Reingold-Tilford algorithm](http://reingold.co/tidier-drawings.pdf)[pdf].
How is this better than htop?
I wanted to comment on this even though there are already several excellent comments, mostly because I have actually reversed my own view on this over the last few years. A few years ago, I was a staunch advocate of the "Learn C First" school of thinking. As a bit of background, I started with various flavors of BASIC (built into the Commodore 64, the ROM BASIC in Apple IIe's, and gwbasic/basica on a 286. I then moved on to C, and later C++, reveling in the additional power, but also early on rueing the manual memory management and off-by-one errors (not the mention the infamous missing semicolons and mismatched parentheses and braces). I dabbled with Visual Basic for a while, learned Java, then Eiffel, later Python, followed by Erlang and then Ruby. (I dabbled with Perl somewhere in there, but hated it, and never did too much with it. Played with Objective-C, Haskell, and others along the way, but never really picked them up.) At this point in time, my two "core" programming languages, that between them comprise 90+% of all development I do, are C and Python. I do a lot of low-level systems stuff, and I use Python for almost everything that isn't. When I was new to Python, I really believed that until you deeply understood the underlying hardware, you couldn't be a proper programmer, and that the low-level understanding of things like memory management and pointers were foundational. That until you know those things, you weren't prepared to program effectively at a high level. I have changed my view quite a bit over time however, mostly as a result of my experiences in trying to help teach several close friends to program. The biggest single factor contributing to my changed view is trying to lower the initial learning curve enough to let the new programmer get *excited* before they have to wade through the particularly dry bits. I still firmly believe that a strong understanding of the computer hardware and operating system is crucial to being a great programmer, but I now believe that a lot of that knowledge can be obtained *separately* from learning the basics of how to program and a particular programming language. One of the keys in learning seems to be for the student to be able to see demonstrable results from their efforts early on. The simpler it is to do something "cool" (let's face it, the high you get from writing "Hello, World!" wears off pretty quickly), the sooner someone really gets hooked and develops the motivation to really dive in. The languages that I started with were actually quite good from that standpoint. BASIC on the Apple IIe was very easy to do graphics (even animation) in. Later, with C, I could at least do fancy console-mode stuff, because with DOS in real mode, doing colorful ASCII art stuff was just a matter of poking some values in memory (about the only thing I really miss, now that we've moved to protected mode). In trying to teach others, I start with Python now. I find that the basics "make sense" enough for people to get it, and start building things and having fun. From there, you can always chase the esoterica. Python also has a very optimized backend implementation (things like getting the built-in sort implementation, "timsort" for free, versus writing one from scratch in C or trying to use the standard library qsort() function...) are a huge leg up. The fact that the basic data structures and methods are so optimized means that you actually can build fairly decent programs without being a machine expert. And while you've probably read it already (and will repeatedly, I'm sure) a better algorithm pretty much always wins out over micro-optimizations anyhow. Learning how to organize a C struct in order to ensure that the compiler doesn't pad the struct innefficiently in terms of space and damage your page alignment or cache efficiency is a useful skill. But I really believe it's one that can come long after you learn how to do something fun while programming. Regardless, you absolutely want to learn multiple languages. I think Python is a great first choice, but do learn something from the C family as well. Also, be sure to learn at least one "functional" language (I think Erlang is a great choice in certain ways, with the completely immutable "variables" it has). It will force you to think about solving your problems differently. tl;dr Sure, learn Python first. Keep learning from there, add other languages, and pick up the low-level stuff as you can.
I am not saying that it's better than "htop" rather "top", top does not have much visuals as ptop has. "htop" and "top" are different things :)
Are we going to see Python 4 before the user base embraces 3?
Conjunction junction, what's your malfunction?
So I found a pretty good online book for 3.3 from company called Zyante. Should I use this book, or is it now massively outdated?
It's not actually a 'real' OS thread, and definitely not a new process. Threads and processes are 'preemptive' multitasking: the computer can at any point stop one thread and switch to another. Coroutines, like in this mechanism, are 'cooperative' multitasking: a coroutine will keep running until it does an `await` on something to wait for some data (DB query, HTTP response, pipe, etc.). That returns control to the event loop, which waits for data to be ready for any of the coroutines, and resumes one when there's data for it to process. This avoids some of the problems with writing code using threads, because it's more predictable when it will switch between bits of code. You can run threads or processes from your coroutines if you want, though.
I like the addition of format for bytes, but does this mean it supports both `%` and `.format`? I didn't notice anything about the latter in the PEP. Seems like we should be pushing toward the newer formats, if any.
Thanks, I had the impression it might just be a few extra things to learn at the end.
&gt; Spend the 5 seconds to write those packages down in a requirements.txt and then you can install them all at once. just do a 'pip freeze &gt; requirements.txt' and you are done. 
I am not sure if you were looking for a real answer, I am sure you already know this but in case someone else didn't/doesn't.... My understanding is that the interpreter simplifies the `(4)` to just be a `4` the same way that `(2 + 2)` becomes `4`. So basically to keep math working properly `(4)` is not a valid way to make a tuple and thus there is no method to add an integer and a tuple.
I think that "no cleaner than any other mainstream language" is utter codswallop. Languages like [PHP](http://eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/) and [C](http://blogs.msdn.com/b/oldnewthing/archive/2014/06/27/10537746.aspx) are notorious for their ugly, inconsistent and downright perplexing designs full of special cases to memorise and surprising behaviour. There is nothing in Python like the C gotcha that [variables can be both true and false](http://markshroyer.com/2012/06/c-both-true-and-false/) *at the same time*. (The closest you can get is if you write a custom __bool__ or __nonzero__ method which deliberately flips from returning True to False at random.) All languages have their "gotchas". Sometimes they are design flaws in the language, sometimes the language is clean and consistent but people's expectations are not. Here are a few Python gotchas: - Default arguments to functions always use early binding. The practical consequence of that is that a default mutable container like a list is sometimes surprising: `def spam(x, storage=[])` doesn't give you a brand new empty list each time you call the function, it reuses the same list each time. This is consistent with the rest of Python's behaviour, but people don't expect it. (This is probably the Number One most common Python gotcha.) - In Python 2, Python will try really hard to guess what you want if you combine ASCII byte strings and Unicode text strings together. That avoids some trivial errors, but at the cost of creating even more, harder to diagnose, non-trivial errors. Python 3 corrects that. - Backslashes in filenames won't do what you expect. `filename = 'C:\Project\textstuff.py'` contains a TAB character, not a backslash followed by t. 
www.nuitka.net
I really could've used that in my quantum computing class five years ago.
&gt; I don't believe it is detrimental to learn ANY language. Learning C will screw with your mind and encourage you to consider it reasonable for a compiler to *utterly ignore* the actual code you wrote, introducing [a serious security hole](https://isc.sans.edu/diary.html?storyid=6820), or [anything else it feels like](https://randomascii.wordpress.com/2014/05/19/undefined-behavior-can-format-your-drive/), just so that the compiler writers can claim faster benchmarks. That's far worse than [BASIC and its use of GOTO](http://www.brainyquote.com/quotes/quotes/e/edsgerdijk201164.html).
have a look at [pyserial](http://pyserial.sourceforge.net/pyserial.html) and to convert from using python from the prompt to a application create a file test.py . You can run this file by using python test.py def do_things(): print("HELLO") if __name__ == '__main__': do_things()
I think he was just trying to make the point that there is complexity all over the place similar to that seen in pointers. 
No, python is a great first language. Primarily because it makes it easy to actually write code to get things done, and eliminates a lot of the things that usually trip up new programmers. Also, because it is applicable to many different problem domains. When you get a solid grasp of the fundamentals, and you run up against some problem where need another language, you can branch out then.
I appreciate where you are coming from, and it's the same advice a lot of experienced programmers give, because they think that people should learn the right way first. What I have seen first hand, from teaching a bunch of people to code, that if you try to start them on C and a terminal based text editor the start, they just get really frustrated and quit. It's not fun, they can't make anything interesting, they hit a bunch of dumb hurdles that have nothing to do with what they actually want to do, and it takes forever to make anything they actually give a damn about. The things you list are all important to learn, but they are a bad place to start.
It's not clear what you want. Is it that you want to write an app for a PC or mac, with a graphical UI ("polished product"), to be the control interface to some piece of hardware on the other side of a USB port? If that's it, the answer is yes; there are several packages that let you write a GUI app in Python, and [here is the official GUI FAQ](https://docs.python.org/3.4/faq/gui.html#index-0). That takes care of the UI side. On the driving-a-usb-port side, here are the [available packages from pypi](https://pypi.python.org/pypi?%3Aaction=search&amp;term=USB&amp;submit=search). Your mention of compiling made people think of the ways to actually compile Python, including [Cython](http://cython.org/) and [Nuitka](http://nuitka.net/) and [PyPy](http://pypy.org/). Wanting to distribute your Python app to a user who doesn't have Python (or the other dependencies) installed is a common need. Already mentioned is [py2exe](http://www.py2exe.org/), which is Windows only, and there is [PyInstaller](https://github.com/pyinstaller/pyinstaller) and [cx_Freeze](http://cx-freeze.sourceforge.net/), both of which are cross-platform. All 3 do the same job, bundling a Python app with all dependencies into a self-supporting executable. 
Hi unexpected person. Didn't think to see you here. Cython + Pyinstaller is the route I'm looking at right now. It all falls back on how Python uses/requires interpreted code. Even if you can afford the $500 for the license for PyQT, Python remains based on openness/legibility so my code is pretty much still out there. Standalone distributables aren't exactly it's strong point. Every app would carry ~10MB of cruft that isn't shared. Please let me know if you find a good standalone/static linker.
Please note that the "What's New" section for 3.5 still needs to be updated and thoroughly edited. David Mertz [recently volunteered to do this before the upcoming 3.5 release](https://mail.python.org/pipermail/python-dev/2015-July/140654.html), but that was just two days ago and will take a while.
Well, right now the bot does several things. It creates a loop for each frame, in that, it runs deepdream on each frame, then saves the image in a new folder. I tried doing it myself, but it keeps messing up because the code is all screwy. But the code that I need multithreaded stars around here: def main(input,output): make_sure_path_exists(input) make_sure_path_exists(output) frame = np.float32(PIL.Image.open(input+'/0001.jpg')) frame_i = 1 for i in xrange(frame_i,2980): frame = deepdream(net, frame, end=layersloop[frame_i % len(layersloop)],iter_n = 5) saveframe=output+"/%04d.jpg"%frame_i PIL.Image.fromarray(np.uint8(frame)).save(saveframe) newframe=input+"/%04d.jpg"%frame_i frame = morphPicture(saveframe, newframe) # give it back 50% of original picture frame = np.float32(frame) frame_i += 1 
Pyinstaller works well too
I recommend reading [this blog post](http://sealedabstract.com/rants/python-3-is-fine/) about why Python 3 does not, in fact, suck, and why people should really stop arguing about 2.x vs. 3.x.
VB.NET basically exists to serve as bridge tech to migrate legacy VB projects to the .NET Framework. It's almost the opposite of a compatibility breaking update that developers have been slow to adopt.
He's talking out of his ass.
Well, there are a few things about its design that make for very accessible code, but once a project grows larger, they require a lot of effort to avoid nasty surprises. A popular example is how default arguments are evaluated only once, when the function is defined, so this: def foo(x = []): x.append("a") return x foo() foo() ...produces `["a", "a"]` on the second run, not `["a"]`, because the empty list we passed as the default argument is modified in-place inside `foo`. Binding mutability semantics to types in a dynamic language is particularly troublesome IMO, worse when it's implicit.
No, {} is for strings only.
You have been developing for as long as me and you still use the "CLOSED NOTABUG WORKSFORME" policy?
Your code is out there one way or another. Compiling it will make it a bit harder for a casual tinkerer, but for anything serious, it's not an obstacle at all. If you want to keep people from copying and redistributing your code, write a license that says they aren't allowed to, and consider fingerprinting or something like that to make it easier to detect and prove license violations.
Just something I glimpsed from the corner of eye. I don't want to nitpick but: if count &lt; 0: print "Count must be at least 1. Exiting." In this case, the code will actually not print this if 0 is entered for count. So just a little correction: Either use if count &lt; 1: or if count &lt;= 0:
I would downvote to express my opinion (wrong analogy), but will upvote instead to highlight the comments. Python 3 was designed to "fix" (YMMV) inconsistencies in the language and improve its core concepts. Its true value shines when teaching newcomers: teaching Python3 to beginners is more straightforward, less caveats and legacy quirks.
The only thing that sucks about Python 3 is that more third-party packages haven't adopted it yet. And even that is barely defensible.
Last time I checked, I was able to fully upgrade to Python 3 for my projects. None of the critical dependencies I had were only on Python 2. It may be time to check again for your dependencies as well. I can't tell new programmers that they should use Python 2 anymore. The pros to Python 3 outweigh the cons.
Regarding the name. There is already a project with ptop name: http://ptop.projects.postgresql.org/ It's "PostgreSQL performance monitoring tool akin to top"
Sorry, maybe this is not the solution but it might help to get an idea. So I'd move the frame opening and saving into a separate (handler) function. In this function you call the deepdream() too. Then create a multiprocessing.Pool instance and apply the handler function on the list returned by os.listdir() (and forget about frame_i += 1) Something like this: from multiprocessing import Pool if __name__ == '__main__': pool = Pool() pool.map(handler, os.listdir(input)) So the pool applies the handler function on each path (so it opens the frame image, passes it to deepdream() then it saves the result to the disk). Also you could try using subprocess to read frames from ffmpeg and also to feed frames into it so no shell scripts would be needed.
Maybe you are a bit long in the tooth to pick up new work flows. New work flows that are unarguably better and safer then 'sudo pip install'. New work flows that will help to stop the prolonging of the clusterfuck of python packaging, distribution, install that our generation created. But hey, if you want to declare VMs are the answer so you can continue doing your old ways, then be my guest. Remember to tell new users of python the /u/KyleG way - &gt; Python - so easy to use you need to isolate your software in a VM** so you can sudo pip install safely because &gt; thats faster or something alternatively you can sudo pip install if you know enought about what you are doing &gt; but if you are new user you probbably won't so you should definately do the safe thing which is use virtualenvs &gt; but those are hard so just fuck it sudo pip install. What a terrible motto for our language. What a fucking joke. ** are we using Docker/KVM/Qemu/Vmware/coreos/these days? who can keep up! Its so much simpler than a virtualenv my head is spinning.
It's a shame that 3 went so badly. I sometimes wonder whether they should have just stopped developing 2 as soon as 3 was released, give people a bit of impetus to change. 
Your C example there is actually a great example of one of the more fundamental differences between dynamic and compiled languages which gets overlooked amongst the trivia of syntax: compiled languages tend to come with vastly better static analysis than dynamic languages. Your example shows a variable being used before it has been assigned, which is indeed a potential source of extremely odd behaviour. There are better ones, like returning a pointer to a variable on the stack from a function, and watching its value change seemingly randomly during execution. However, it's one that you're unlikely to hit, because the compiler will tell you about it at compile time. Dynamic languages, in general, aren't very good at this. Python's laissez faire attitude to interfaces is often presented as an advantage, but it comes at a huge cost in lost automation. One of those costs is the neverending quest for coverage in unit tests. In Python, the only way to know if a function doesn't exist is to run the code which tries to call it. This means, for example, that if you want to ensure that you don't have any typos in your debug log messages, you need to ensure that your unit tests call every... single... one of them. You just don't have to do this with a compiled language, because the tools do it for you. There's an old joke: "it compiled, so it must be good. Ship it!". This is obviously not recommended :) However, if your program compiles without warnings, you can be sure that all your function, object, and variable names are correct. All functions and methods are called with the correct arguments of the correct type. Oh, and you haven't tried to use any variables before assignment, because that's undefined behaviour.
tl;dr: Yes, python is a fully functional programming language. You can write modules and scripts that you can call with python/python3 yourmoduleorscript.py which behaves about the same as a compiled binary, except there are only syntax erros which get thrown when you load the module or script and run time errors that only get thrown when you'd actually execute that specific line. A similar question to this was asked recently: https://www.reddit.com/r/learnpython/comments/3bihhm/eli5_the_steps_to_creating_a_executable_that_i/ I don't think python ever gets compiled, but you can extract and bundle the parts you need to distribute standalone packages and executables. That is to say, I think the interpretive nature gets preserved but the stuff that gets interpreted you can nail down so it doesn't make a difference funtionality wise. And yes you can distribute to pretty much every plattform without requiring the user to know anything about python or programming.
Python 3 was a good project and necessary to get rid of some mistakes. The problem were the users which were happy with too many problem of Python 2.x and the huge amount of external libraries. Large parts of the standard library got an overhaul or a new implementation. New functionality was added and problems like 1/3 == 0 were removed. And I'm glad that handling of unicode and binary data is so much easier. I had a project of accessing a PLC over TCP/IP and the fuckup with the mixture of ascii and binary has ended. 
You can program your chips with python too: http://micropython.org/
&gt;All 3 do the same job, bundling a Python app with all dependencies into a self-supporting executable. cx_Freeze doesn't support single executable mode, which many people want. PyInstaller and py2exe does.
Go get the ipyhon notebook docker and run that. 
Make a github blog, and then go make ipython notebooks with lots of graphs of data. That way it looks cool ðŸ˜ƒ
Hey thanks for your reply, once I get the time I look forward to taking a look through your project. If you had an idea of how you wanted to collaborate let me know! I'm always open to working with other people. Quick question: When editing posts how are you validating against your databases unique constraints? (title slug for example).
&gt;Also, in comparison, Python isn't very clean at all Try typing a quote in non-unicode or getting your indentations messed up.
Hey! thanks for responding. You're absolutely right about the comments. It's something I caught myself wishing I had done recently after I hadn't had a chance to look at my code for a while and came back trying to remember why I had done certain things. I plan to implement logging once I'm closer to deploying to something other than heroku. Like DigitalOcean, where I plan to host the product for my personal site.
I love Python, but the language is getting bigger and bigger with very little to show for it. It's still slow and still unpredictable at runtime. At least when it was a bog basic dynamic language you could be pretty confident if your code was simple it was probably right. Now if your code is simple, it's probably outdated and no longer idiomatic.
Doesn't work. Shows garbage in the window when I move it. Can't read any text. Doesn't appear to be tested. 2/10 would not recommend.
try CTRL + L while its on ! It's a known issue with few terminals, will fix this in new release
It does. Thanks very much for your suggestions!
except that `directory = r'C:\Project\'` don't work so it's just an half fix
Nope. It's meant to be used inside the asyncio framework, which handles resuming the coroutine at the right times.
maybe there should have been a bit more testing before releasing this.....
I think the single executables are really zips that are decompressed anyway at startup. But still a single file. Lately I've been using [InnoSetup](http://www.jrsoftware.org/isinfo.php), as I can't get cx_Freeze to make a proper installer. InnoSetup takes everything in a build directory and makes it into a really nice installer.exe. It has tons of customization and the docs are pretty good. It makes start menu icons and registers your app in the Add /Remove Programs in windows. Of course you can use InnoSetup with anything, even a single exe. 
It's an easter egg, if it weren't obfuscated in some way I'd be disappointed.
It's pretty explicitly obfuscated, most people can't read rot13 right away. It rather violates "Beautiful is better than ugly" (though that's in the eye of the beholder) and "Readability counts", however. I suppose it's best to be understood ironic.
Typo I meant Pandas and Seaborn, you should know that both libraries use matplotlib in the background for plotting, although it can have son archaic feeling (matplotlib) it also have more customization than all of the other libraries I know. But as I said it all comes to your necessities and what do you want to plot. 
The highest rule of mastering **any** skill is that no rule is unbreakable. As you asymptotically approach 100% mastery of a subject, you become qualified to choose to make an exception to a rule when it is justified. Sure, for production code, you really wouldn't want to violate "Readability counts". But this isn't production code. This is a fun easter egg for imparting wisdom to programmers. The exception is made because it's funny and educational (you just learned what ROT13 is).
Whoa. I learned something today, thanks! Is there a way to make an argument like that read-only, or "const"? This sounds really dangerous.
With my test.py script the name in taskmanager is test.exe. No python.exe.
Machine learning is a huge one. Matrix multiplication and tangents are most of the network building.
I'm definitely looking for something like this, to help with continuous integration, managing development/test/deployment containers. One issue I see is that it requires boot2docker, which I think is going to go away to docker-machine. Docker-machine is what Kitematic uses, which was purchased by docker. If you install Kitematic, you won't have boot2docker installed necessarily. The other is I'm confused by why nginx is required on OSX. It seems like you'd want to require only docker, then encapsulate things like nginx in a container. Here is some recent work of trying to come up with a minimal build for deployment: [docker-deploy-python](https://github.com/rothnic/docker-python-deploy). A bit different focus, but maybe some use for reference. I haven't pushed it yet, but I have a python-builder container as well that uses pyenv to build python versions, that I plan to use in a testing container. The idea is to have a run container that only has what is required to run the app, not compile source files, or run tests, etc. I'll also mention that [dox](https://github.com/stackforge/dox), tox with docker, might be of some interest as well.
Those are guidelines, not rules. They can reasonably be broken in circumstances of the author's choosing for reasons that are subjective, so there's no point in picking apart places where they're not used. The existence of guidelines doesn't mean that we don't still have free will.
You are completely correct. I apparently hurried too much and didn't review/test sufficiently. I am leaving the original as posted for your comment to make sense, but I goofed on that.
Wha... What does a time need a boolean value for? 
If you're creating installers, you might be interested in my project [Pynsist](http://pynsist.readthedocs.org/en/latest/).
You missed an important bit : async with db.transaction(): which expands to : VAR = await aenter try: BLOCK except: if not await aexit(mgr, *sys.exc_info()): raise else: await aexit(mgr, None, None, None) 
&gt; One of those costs is the neverending quest for coverage in unit tests. Yes, I've worked with Scala &amp; Java programmers that don't spend nearly as much time building unit tests because they've got compilation to check many errors. And so, because of this, I generally end up testing their code because it turns out that the compilation errors are usually the obvious &amp; trivial ones, and you actually need that test coverage to handle business rules, field mappings, etc. Bottom line: the complaint about dynamic language test hell is misplaced.
Try piserial or pyUSB
No idea.
I don't use a VM, either, and I don't know where you got the idea I do.
My first one was VB6 and I turned out fine :)
Yes-ish: async libraries need to be written with some knowledge of the async framework in which they will work. But the `async` and `await` is a new syntax to support `asyncio`, a framework that is already in Python 3.4 (and can be installed in 3.3). There are already [a number of libraries for asyncio](http://asyncio.org/#libraries) - you should be able to use these with `async` and `await` immediately. Technical details: I said that there will be a series of nested awaits. In current asyncio code, there's a series of nested `yield from`s instead. The `async` and `await` mechanism has been designed to work with current asyncio syntax. 
I'm a bit baffled by some of the problems this purports to solve You can use Docker containers rather than VMs under Vagrant for example Also the routing, port forwarding and file sharing (at least for paths under `/Users/`) 'just works' on OSX already in recent versions of boot2docker... so why the need for an Nginx proxy and rsync?
Not a subreddit, but: http://codereview.stackexchange.com/
We decided to use boot2docker since it'd been around longer and Docker Machine is still billing itself as in beta. boot2docker hasn't exactly been a joy to use, so we'll definitely look into moving to Machine once it stabilizes. I think it would be good to move nginx into a container eventually. This is quite a bit harder than the current solution, though, since you are now managing nginx's container lifetime while also keeping track of the various container IPs it needs to be connecting to. Currently, the only IP we need to keep track of is the boot2docker VM's, and this is pretty static relative to constantly shifting containers. Thanks for those links, I'll definitely check them out. We could definitely use some improvement in our Python setup and build times in our setup internally. `setup.py develop` really doesn't cut it very well in a lot of cases.
on a not completely unrelated question, has anyone had luck with compiling a kivy app for Mac OS from linux?
Gotcha. The main thing that the images I was working on was extending off of someone else's work, then trying to add in using a minimal image (the official python one is ~600MB or something), and work in testing. The build.docker builds all the wheels and stores them into your local machine, then then run.docker image includes just the base requirements and installs the wheels directly. The run image ends up being about half the size of the builder. I tried utilizing conda to have direct access to compiled packages, but the conda binaries are not compatible with musl compiler, which is what all the minimal linux distros use. In the end, I think not using the distro's python is the most robust, especially for testing against many versions of python via pyenv. I went ahead and committed what I have, which is incomplete for the testing side, due to an issue compiling 3.4.3. The python-builder.docker is basically pyenv encapsulated with all the build requirements for python, with the idea it could produce the compiled versions of python to use for testing.
Yes, it is available https://docs.python.org/3.5/whatsnew/index.html
You can't really have a "false time" unless it falls outside the 1-12/0-23 hour, 0-60 minute/second pattern. And if this happens, datetime throws a ValueError. But yes, somewhere, someone will upgrade to 3.5 and have this bugfix cause havoc all across their system.
Shedskin can compile a subset of Python to native. It's fast. Nuitka supports the full spec. Also, the Nim programming language is worth looking at in this context.
To be curious, what did 3.4 bring that made it much more valuable than 3.3? 3.3: * introduced groundwork to make things like asyncio possible. * brought back the `u` prefix for strings (even though it doesn't actually do anything, it allows backwards compatibility to 2.6/2.7 where it transforms a bytestring to unicode) * reworked the import machinery, * brought mock and venv into the standard library, * rejiggered the IOError hierarchy, * allows cleanly reraising an exception in a different context, * added a C speedup for the decimal package. * has implicit namespacing for packages without `__init__.py` files * gave us function signature objects * `__qualname__` (though, I've not found a great use for it) By comparison, the killer apps in Python 3.4 were: * asyncio in the standard library * pathlib * pip in the standard library And then some nice extras like enum, functools.singledispatch, selectors and statistics libraries. I'd argue that 3.3 is when Python 3 really became worth it, and since then it's only been gaining steam.
python pex
Try installing with PIP https://pip.pypa.io/en/latest/installing.html PIP is a terminal command that will install python libraries for you
If I don't use sudo I get this error: /System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/distutils/dist.py:267: UserWarning: Unknown distribution option: 'install_requires' warnings.warn(msg) running install running build running build_py running install_lib running install_egg_info Removing /Library/Python/2.7/site-packages/gdata-2.0.18-py2.7.egg-info error: /Library/Python/2.7/site-packages/gdata-2.0.18-py2.7.egg-info: Permission denied
How exactly would I go about installing this via PIP, which I have?
I guess it's because then it's not able to clean up the files from the previous installations using sudo
Okay, I'm a python novice at best and I love browsing this sub for sweet content like this. So forgive me if the following question has an obvious answer. Are you running the scripts client or server side?
In addition to using a multiprocessing queue, you can also send frames directly to the ffmpeg stdin, rather than write them to disk. Then let the -threads 0 parameter of ffmpeg deal with multi-threading. See here for an example: https://github.com/alexjc/shadertoy-render
Minor detail. ASAIK, Nuitka relies on libpython to execute the code so is not really machine code what's being executed. The plan is that in the future they'll minimize the use of libpython and actually compile the code to C++, which is then compiled to machine code. [source](http://nuitka.net/pages/overview.html) But other than that, it's cool. And it raises the awareness that Python the language is not the same thing as an implementation of Python.
Don't you get an exact error? I'm not near an IIS server right now, but there should be an option in the site or the application pool to send errors to the browser. I think it might be in the "errorpages" item. we are running flask under IIS as well, and I can get my detailed errors that way. Also, make sure you're not using IE with "friendly HTTP errors enabled"... It could be the upload byte limit that IIS has, but without an exact error you can't be sure. 
Thanks! Is my understanding correct? The notion of "backporting" is a result of the continued development of 2 in parallel with 3? Such that when a PEP is accepted, and is "backportable", it is released at (or about) the same time in both 2 and 3?
$ pip install &lt;python_library_name&gt; you may need to use sudo.. but only if you get 'permission denied' errors
This is a really dumb question, because I've been using Python for like 10 years, but how do I know which one of these I'm using?
If you don't know you are probably using C Python.
Really... Thank you for the source on that. Interested to see how that does when implemented.
PyPy uses a JIT, which should be distinct.
I was just wondering if ~~you were~~OP was using something like [pyp.js](http://pypyjs.org/) or if it was done server side. Thanks for the info!
I have most fun with any development when it is a good problem to solve and it is an intellectual achievement of sorts. e.g. I had grunt watch tasks working with our very custom Content Management System which uses a combination of Iron Python and C#. It only took 30-45 minutes to integrate it with the build and development process but wow ... made soo much difference and I felt pretty smart afterwards.
Okay? So, what does this mean?
So does CPython (along with most/all of the others, I imagine). Pretty much any Python interpreter is going to compile just before execution, i.e., Just In Time.
Not exactly. https://en.wikipedia.org/wiki/Just-in-time_compilation
Me too! I know that right now is performing some optimizations within the python code that don't change its semantics. He usually has examples of that in the docs or the change logs.
JIT compilers are monitoring code as it's executing, which allows several types of special optimization and adjustment of strategies. That's not the same as taking a C++ program, compiling it and then running it. 
This looks interesting, but I have to say that I absolutely hate the way this is presented. The navigation is rather confusing and I've twice reached dead ends when all I've wanted to do is flip through the charts. :-/
&gt; It includes a Python compiler that targets C No. Cython is one of the only C++ interfaces to Python.
Hey guys, let's not pile on with downvotes. He's being earnest and it's topical so I think his comment should at least be &gt;0 so it isn't hidden. edit: sorry if you are female, I had to pick a pronoun.
Sometimes you can get some awesome speedups for little work using them, over CPython. Which one to choose though mostly depends on what exactly your codebase looks like at the time and its dependencies.
* If you want to do any real work with this hook, The tasks should be performed asychronously to prevent request timeouts. Environments like Heroku have a hard cap (30s) on request time limits. * If the signature check fails, the app should return a non `200` status code (like `400 Bad Request` or `401 Not Authorized`). * Some of your links are broken
Okay, I see the issue. I'll need to ponder this a bit. Thanks.
Well, as I said, I don't know much about Cython, but [cython.org](http://cython.org/) says: &gt; The Cython language is a superset of the Python language that additionally supports calling C functions and declaring C types on variables and class attributes. This allows the compiler to generate very efficient C code from Cython code. The C code is generated once and then compiles with all major C/C++ compilers .... I suppose, therefore, that Cython allows linking with C++ for the same reason that C can be linked with C++ (?).
&gt; I had to pick a pronoun. Not everybody agrees but I've always been a fan of the singular "they" to be gender-neutral. E.g., "They're being earnest and it's topical so I think their comment..."
I second this opinion. The layout, navigation, presentation are all terrible and very difficult to maneuver. While the content may be of value I stopped after 20 seconds of struggling to get to the information I was interested in. Classic example of form over function.
Python wasn't the first language I was exposed to, but it was the first language I sat down and really tried to learn. Then things clicked. And then I finally hit myself over the head for how easy CS110 (Java) would've been if I knew the same thing back then.
Neat. I love Pandas but can never keep it all in my head. I'm constantly referring back to the largely excellent docs, but this feature is news to me. Thanks!
So is the wooey the flask project being abandoned for wooey the django project?
Look into mechanize or PhantomJS.
No Python specific advantages, I've just found that drivers, accessories, etc tend to 'just work' better on Mint compared to a native Ubuntu. And the UI/UX is more similar to that of Windows. (Ask around and see what coworkers use, if the products you'll be working with are a PITA to setup on anything that isn't Ubuntu you may just want to go with Ubuntu.) &gt; What's with this stuff #!/usr/bin/env python Will this be your first time with Linux in general? Ubuntu's package manager is called Aptitude, so become familiar with the following commands: * apt-get install X * aptitude search X IE: * aptitude search pip * (Look through available things and note that python-pip is what you're looking for.) * sudo apt-get install python-pip This will be how you'll search/install/update a lot of perquisites, libraries or applications. If you're building something and it barfs on something like &gt; ncurses not found. You can begin your quest of installing it with: * aptitude search ncurses. (Often times there is either a 'lib' prefix or '-dev' suffix for these requirements.) &gt; PATH/PYTHONPATH? In your home directory you'll want to create/append to a .profile file environmental variables to load. Also, /etc/rc.local is where I put commands that I wish to have run on startup. (Spin things like mongodb, elasticsearch, nginx, etc up without me having to remember to. Someone may want to correct me on if this is the proper location/procedure.) edit: (Sorry, gonna keep editing this as I look through my env and think of things.)
Woah. You should first understand what you are doing. Here is a example of a restful api, which should give you a idea of what is actually happening. [http://www.restapitutorial.com/lessons/httpmethods.html](http://docs.python-requests.org/en/latest/user/quickstart/) And here is how you could execute this: [http://docs.python-requests.org/en/latest/user/quickstart/](http://docs.python-requests.org/en/latest/user/quickstart/) Best way to get interested and your feet wet is to follow the tutorials to do them with an api you know works. And is setup for this type setup. In python [Django Rest Framework](http://www.django-rest-framework.org/) is a perfect way to learn this, play with their demo.
I'll try and cover some parts you've missed. **Pyston** is an up-and-coming Python JIT, like PyPy. It aims to support CPython's C extensions, which is the main reason Dropbox funded its development. It is not production ready. Another future competitor might be **ZipPy**, which uses Graal and Truffle. I don't know if ZipPy will ever be production-ready, though, or if it's just a proof of concept. **MicroPython** is a minified version of Python designed for constrained-memory situations. It aims to support Python 3 and has some tools to improve runtime above CPython. I have not been particularly convinced of its applicability for general usage, and it's still developing, so I would not recommend it for everyday usage. Consider this if wanting to write Python when you have little system memory. **Numba** is a CPython *library* that compiles code at runtime with LLVM. It specializes on a well-chosen *subset* of Python useful in numeric computation, and is not itself a complete runtime environment. It is also not technically compliant, but this is fine as it is a per-method opt-in. **Cython** is an almost-superset of Python, that aims to allow seamless mixing of C and Python in one combined language. It allows writing fast C code in a convenient-to-embed manner and allows simple wrapping of C libraries. It has relatively widespread usage, but it being encroached on by specialist tools from both sides (eg. CFFI and PyPy or Numba). Cython does not itself contain a runtime, and instead reuses an existing CPython's runtime. This means that simply running normal Python code in Cython will only remove bytecode dispatch overhead, which is normally only a tiny fraction of runtime. **Nuitka** aims to replace CPython's bytecode dispatch exactly the same way Cython does, but hopes to further compile code by using appropriate static analysis and further fine-grained compilation. Many people, myself included, are very sceptical of this approach. Nuitka has yet to show any impressive speed improvements, but several people have claimed that it makes distribution of code much easier since it produces single compiled binaries. It should be nearly 100% compliant with CPython, with the exception of runtime code introspection. On the topic of PyPy, it's worth noting that PyPy isn't missing features in the same way a C++ compiler would be. Either PyPy has a release for a specific version of Python or it does not, and its stable releases are extremely compatible. If you're not using CPython-specific code (eg. CPython extensions) and you're running on a version of Python that PyPy supports, it will almost certainly work. Even CPython implementation details tend to get copied in PyPy. 
CPython generates non-native byte code that is interpreted at runtime, similar to the Java Virtual Machine. a Just In Time compiler generates native byte code at run time that is interpreted by the processor natively.
What is the difference in performance when using libraries like numpy which are mostly c code under the hood?
Perhaps the variable 'r' does not have a member function called login? Are you using a specific library or something so that we can see that the login function is actually a part of the class?
/etc/rc.local is not the proper, flexible method for startup services. (It uses one file only where many packages/applications may need to run something at startup, has no dependency management, etc.) This is not friendly for package management (or manual package installation), portability between different systems with heterogeneous configurations, or system maintenance. Ubuntu uses upstart and various Upstart scripts in I think /etc/defaults. Other Debian-based systems use a SysV-based method (dependency based boot, etc.) using scripts in /etc/init.d/ and the runlevel directories /etc/rc#.d (# = 1 to 6 inclusive) (controllable via the update-rc.d script). Recently, Debian has decided to use systemd (including for startup services), which IIRC runs on a similar principle. I haven't used it yet. Also why are you using different aptitude frontends? Fyi the apt(-get) analog to aptitude search is apt-cache search. Both work, but the heterogeneity of that workflow feels weird. EDIT: Fixed path to /etc/init.d for SysV-like boot scripts.
Thanks for your response! This is what I put together, but I am getting a 500 error when I run it. *********************************************************** import requests body = {"security":{"Email":"xxxxx@xxx.com","Password":"xxxxxxx"}} response = requests.post("https://services.etosoftware.com/API/Security.svc/SSOAuthenticate/", data = body) print response **************************************************** Any idea what I'm doing wrong?
Numba is made to complement NumPy AIUI. The speedups won't matter in a Python interpreter if you're using a non Python language.
Why can nobody ever answer this question?
I think requests will form encode that data argument if it's not a string, that API looks like it wants a JSON string: import requests import json body = {"security":{"Email":"xxxxx@xxx.com","Password":"xxxxxxx"}} response = requests.post("https://services.etosoftware.com/API/Security.svc/SSOAuthenticate/", data=json.dumps(body)) Depending how picky that API is you may also need to set the two headers it asks for, content-type and accept.
I'm glad it is working. And, because every process is on to finish its task as soon as possible the frames appear "randomly". This is a typical problem of parallel computing. Also don't forget that threading module is usually used for IO bound tasks, and multiprocessing is for CPU bound ones. 
See the recent post in /r/learnpython "why are classes bad". It has a link to a good video.
&gt; What's with this stuff #!/usr/bin/env python Its called shebang. In windows, a .py extension is associated with python, so system knows to use python to execute it, but such concept exist on linux. When a file is executed, kernel checks first line to see what to do with it. So this could be just #!/usr/bin/python, but python location varies between systems, while env is more likely to be located universally in the same place, and it can find python using PATH variable. As for graphics (as in image processing), look for Pillow and graphicsmagick. If you want to learn more, I can recommend this book: http://www.amazon.co.uk/Beginning-Linux-Programming-Neil-Matthew/dp/0470147628 (probably some python-focused book exist as well).
you import it as a reference, in that module, and only after that you replace, that is the documented behaviour of python, and has nothing to do with monkeypatch, monkeypatch is not supposed to replace all other names a object has, it replace one defined name you should import the module, and call the function using attribute access, that way it would call the replaced one as soon as you monkeypatch the attribute of the module
Looks great, forked! Do you take feedback or accept changes?
IronPython and Jython also compile to machine code, just the VM does our for them
Before you start screenscraping, check if the wiki has an API. 
There are some things it makes sense for - situations where you're hosting a bunch of servers for example - but Python is cross-platform, its tools are cross-platform, the major IDEs are cross-platform, and setting up a compiler for Python's C packages isn't difficult on Windows at all. I know what you mean, though - Sometimes it's just trendy to hate on Windows, but I feel like there might be something else going on here.
I just had some excellent feedback on /r/learnpython for a script I wrote (and asked a code review for).
You have an earlier query that failed in the same transaction. You'll need to find out who the problem child is. http://stackoverflow.com/questions/2979369/databaseerror-current-transaction-is-aborted-commands-ignored-until-end-of-tra
Don't use any of those. Use `{}`, `{keyword}` and the format function: s = "Hello {} {thing}".format("beautiful", thing="world") print(s) And you should probably ask this in /r/learnpython 
For new style print-function calls I often don't format either way, instead just: print("stock remaining:", amount)
The advantage is not very apparent when you are formatting something as a string (using the %s). However, the first method can be very useful when you want to format floats. For example: print "Tau: %1.2f" % 6.283185 will give you Tau: 6.28
&gt; I want to know is it better to write classes or functions to accomplish a specific task? Which specific task? You use the word "specific", but then ask a ridiculously vague question.
+1 for Mint. It is beautiful! Which is something one rarely says for anything Linux
The last plan was for the current wooey repo to be forked into something like flask-legacy or something of sorts. We wanted to combine efforts, and we're both more comfortable with Django. It'll still be there, and will probably get bug fixes/etc. but I don't know how much in terms of new features. You'd have to ask [martin](https://www.reddit.com/u/mfitzp)
Thanks for posting, OP!
At first there does seem to be a lack of material targeted at intermediate users. There is a course on [udemy!][https://www.udemy.com/python-the-next-level/?dtcode=06XFAb13f2RZ] for python (courses go on sale frequently). My best advice is to focus on an area that holds interest for you and look for materials targeted to that particular area. For example, there is good, easy to find material for Flask or Django. When exploring those subjects you will encounter other libraries and tools along the way that are helpful. [Checkio.org!][http://www.checkio.org/] also looks to be a good place to build skills. Finally, learn by doing. Set useful challenges for yourself. In my case, I wanted to create a little application for keeping track of books that I had read. As I went through the process, I had to learn how to talk to databases and how to build the user interface. I ended up using python with SQLite and Flask. 
virtualenv is meant to keep you from stomping on python dependencies across different projects, correct.
Seconded, considering a lot of people understand *spreadsheets* and find them at least doable if not fun.
One of my interests would be networking, any suggestions for that? (Python 3)
Arg. Before you even consider reading the source, you should [read the documentation](http://www.crummy.com/software/BeautifulSoup/bs4/doc/#parsing-xml). You are trying to parse XML using a HTML parser, which is destined for fail for numerous reasons. Tell BeautifulSoup that the input is XML and everything works fine: from bs4 import BeautifulSoup text = '''&lt;xml&gt; &lt;sport name="baseball"&gt; &lt;team name="Braves" city="Atlanta"&gt; &lt;link&gt; &lt;url&gt;http://atlanta.braves.mlb.com&lt;/url&gt; &lt;/link&gt; &lt;/team&gt; &lt;/sport&gt; &lt;/xml&gt;''' soup = BeautifulSoup(text, 'xml') print(soup.find_all('link')) Output: [&lt;link&gt; &lt;url&gt;http://atlanta.braves.mlb.com&lt;/url&gt; &lt;/link&gt;] This is still using lxml, so there's no reduction in performance and there's no need to hack up the markup to rename `&lt;link&gt;` to `&lt;resource&gt;`. Seriously, talk about missing the point completely. 
I do not use fedora but it is super easy in debian based systems For system wide: apt-get install python-matplotlib Done. There is no reason to use pip or a virtualenv for a package that is in the official repo (that is not a networking package). 
Bokeh is a very interesting library, I use it from time to time as it can generate a single html file that contains all the data, with no need for a server. Also, "mpl.to_bokeh" is a just a timer saver when you are in a hurry.
I thought that isolation was for security reasons, and to prevent potential incompatibilities. yet I usually consider packages in the official repo to be safe?
I second that, plus if you are lost you can press ESC and get a map of where you are in the presentation!
- Can you give me a example - I know, I was not able to figure out how I change the headers, can I do that with jsonify? - Which links? Thanks for your valuable feedback
Well, you're going to get jumped on for a statement like that. I understand your frustration - there are particular packages and setups that have lost me a ridiculous amount of hours - but it's not to do with python being "inconsistent". Python is very consistent when it comes to finding packages. The packages themselves and the installation utils however ... Perhaps you might explain what the problems are that you're encountering. I would think that virtualenv and pip should see you right, but it depends on what you're trying to achieve. Packages that install scripts or system-wide resources can be tricky.
Even simpler than scrapy is selenium webdriver: http://selenium-python.readthedocs.org/en/latest/getting-started.html Then you could use xpath or beautifulsoup to get the page data. Not Python but Refine (http://openrefine.org/) can download/parse mediawiki. Edit: assuming you're using media wiki, there IS an api ~ https://www.mediawiki.org/wiki/API:Querypage
Correction for SysV-like: /etc/init.d and /etc/rc#.d (# = 1 to 6 inclusive).
Or with format strings: print("Tau: {tau:.2f}".format(tau=6.283185))
The 'conda create' environment management is super easy. http://conda.pydata.org/docs/faq.html#managing-environments It will let you set up python 2/3 environments with whatever packages you want. Plus, it won't redownload what packages you already have. The anaconda distribution is awesome for scientific computing. Plus if you have a .edu email address you can get a lot of their paid packages, including the MKL optimized linear algebra package.
but why?
Yes, that is nice. But how does this fare when I just want matplotlib to plot something in a different setup. Can I require only the packages I want? Can I add packages I want?
Sometimes. Like when it's actually more readable.
With only 20 values, it doesn't matter, but the [purpose of Numpy is to avoid looping](http://alternative-schools.org/ElliotHallmark/some-points-about-numpy-performance/), because looping is slow. I can't really give an example because I don't know what func does. Here's how you'd use newaxis (which may or may not apply to op) result = x[np.newaxis,:] + y[:,np.newaxis] #adds every x to every y resulting in an array of a higher dimension. Meshgrid is probably more suitable.
I haven't made any other queries/transactions than that one. I'm starting the shell, importing the Flask-SqlAlchemy connection as db, and executing the code I posted earlier. But I'll try to find another way to do the query that doesn't involve executing only a raw sql query via db.session.execute since that's what I'm using now. (I'm trying to make the code more maintainable instead of having a big generator function that renders an sql string of more than 300 characters...)
How does it deal with ambitious shit like twisted, wx, and mysql.connector?
&gt; In particular using it for scientific "programming". So here's the thing: if you're doing scientific programming, you won't need virtualenv. For web apps that you will later need to deploy remotely or for doing extensive app development, a venv is a good thing to have. But for most scientific computing, you will not ever need numpy 1.8.1 and numpy 1.9.2 installed at the same time, as these libraries are usually stable and have good backwards compatibility. Now, one thing that sometimes messes with your python installations if you're not using venv is system-wide installations vs. pip-installations. Concretely, system-wide installations are often placed in `/usr/lib` while pip installs in `/usr/local/lib`. If you have two version of the same lib installed, you'll need to make sure that the right one is loaded. I could well imagine that is the source of your problems. Personally, I always stick with pip (or rather, use setup.py) because I want to optimize my numpy-builds, and don't bother with the system-package. **TL;DR:** IMHO using virtualenv is not needed in scientific python usage EDIT: wording
Mike Bayer did a talk about SQLAlchemy (duh) where he explored doing things like complex groupings and intermediate tables. I want to say it was something like "The Hand Built App" but the only thing that brings up is "Building the App" which ends up being a Minecraft extension at the end (nothing wrong with that, just not the video I was looking for).
The New Boston's Youtube channel has a course on Python - https://www.youtube.com/playlist?list=PL6gx4Cwl9DGAcbMi1sH6oAMk4JHw91mC_
Yes, [as /u/frodre points out](https://www.reddit.com/r/Python/comments/3coawj/frustrated_with_the_setup_of_matplotlib/csxgqum). In fact, these days, Anaconda is a bit *too* fully-featured for the average data science programming stack. So, instead, I now use [miniconda](http://conda.pydata.org/miniconda.html) to set things up. Each project I work on gets its own environment and only the packages it needs, and porting that environment configuration is *incredibly* easy. As an example, consider [Christine Doig's Bokeh/Blaze tutorial from the SciPy currently happening](https://github.com/chdoig/scipy2015-blaze-bokeh). She provides this simple yaml file with the distribution for her tutorial on git: name: scipy-tutorial dependencies: - blaze=0.8.0 - bokeh=0.9.0 - ipython=3.2.0 - ipython-notebook - netcdf4 - boto From within the folder containing the code, creating the special, minimal environment necessary to run her code just requires executing the command *conda env create*. And voila! Special environment with the specific package versions she was using. You can specify versions of your packages if you're worried about conflicts. Additionally, if there are any other dependencies, conda will inspect your configuration and compute the necessary packages and versions to download automatically for you. I really can't recommend it highly enough.
I guess it depends on the person. The same syntax works great for formatting in C# and they're even adding [string interpolation](http://www.codeproject.com/Articles/846566/What-s-new-in-Csharp-String-Interpolation) with the brace syntax. Also, I find "Hello, {name}, welcome to {place}".format(name="John", place="/r/Python") Way more readable than "Hello, %s, welcome to %s" % ("John", "/r/Python")
Look man, i have been working on a Cython project for a few months now and you are just flat out wrong. Cython takes C++ code, through Cython code (pyx/pxd/pxi), makes highly optimized C++, and compiles it.
I'll try find it, thanks. Essentially there are 30+ columns with data in them, and I'm trying to accomodate some filtering and maths on each column, while also truncating according to an interval. One col might need to have values 1&lt;x&lt;100 filtered out, maybe a baseline/multiple/offset applied, and then a floor or average etc. My generator function(s) works, but it's a mess to decode every time I need to make changes to them.
I really enjoy and recommend: https://cloud.sagemath.com It is already setup with numpy, scipy, matplotlib, pandas, and more for Python 2 and 3... You can work in bash, Jupyter notebook, Latex, MarkDown etc.
Also not good. If we have lower debug level - we are actually doing expensive string formatting/substitution, for something that wouldn't be logged. Arguments in logging module are for a reason. Valid contr-argument might be, that since 3.2 there is a new parameter for formaters 'style'. So if I am using mysqldb or/and python &lt;3.2, I am not sure if I want to use new format for a couple of new features, which I don't use, and have two different styles instead of one. 
Cython documentation is terrible. Most of it comes from the C-only days. I think it was version 0.13 that incorporated C++. I have been working with Cython for a while now and chose it because of its support for C++ (boost.python is shit). 
I understand you. But I'm wondering, in which situation someone would want to do it manually when there're plenty of tools to deal with it automatically? Probally you've got a setup for some tasks, and you need a different version of python/packages/envPaths for another task, or something like that. In that case, I would use a standard automatically installed python/package setup. And install manually another python/packages/envPaths. Or setup a virtual environment. Or use some of those special python distributions. Idk, 'cos I'm a windows 7 user. And I just use standard software. (I went on the Ubuntu world once. Windows is better, imo)
Nice! Thanks. Yeah I know looping is slow, but for any arbitrary operation I can't think of another way to do it. But it's one of those things I *know* has to exist. Maybe meshgrid is it, I didn't look for a good tutorial yet.
I didn't want to elaborate cause I feel it was the wrong subreddit to do it. Why? Because it's Python 3 compatible and because keyword arguments arguments are more readable and you can switch positions.
This is a post that's better for /r/learnpython (which is for questions about Python) rather than /r/python (which is about Python news). Put simply: technically you are not adding (or rather, concatenating) the string values. In this code: print('Stock remaining: ', amount) ...you are passing two separate values to print(), just like you pass two values to random.randint(0, 99). To answer your question, when you pass multiple values to print(), the function will insert a space in between them. You might not want that space character there.
&gt; I thought that isolation was for security reasons, and to prevent potential incompatibilities. Preventing incompatibilities is the purpose of isolating everything in a venv. It has nothing to do with security. &gt; I usually consider packages in the official repo to be safe? This is an absolutely terrifying statement. Nothing in PyPI or your package manager (apt, yum, whatever else...) of choice is really truly vetted. At all. Ever. The only safety involved is the fact that thousands of people are hitting it for packages and no one is crying foul that a particular package is doing something shady and malevolent.
I did it on both Win 8.1 with Python 3.4.3 and whatever old, busted out of date linux AMI is running on my AWS instance with Python 3.4.1. Interestingly enough the AWS test didn't require the Tcl fix I linked above, making it an even better argument for nothing being broken or wonky. It Just Worked(tm)
&gt; IMHO using pip is not a best practice in scientific python usage Did you mean virtualenv there?
Thank you. The documentation looks great. I'm going to pour a glass of wine and get started :)
+1 for miniconda I have miniconda installed on every computer I do development on. after installing miniconda: conda install numpy matplotlib scipy pandas seaborn ipython-notebook update comes along for package I want, or want to merely check if there is an update? conda update --all 
I mainly don't use it because it's slower. Also, how do you do: s = "Hello {} %s" % '{}'
So basically credit risk analysis?
Just remember that when you do that method, Python adds a space between the values. &gt;&gt;&gt; print('Hello','World') Hello World
&gt;This is an absolutely terrifying statement. Nothing in PyPI or your package manager (apt, yum, whatever else...) of choice is really truly vetted. Not PyPy, I specifically said APT. All submissions to the official APT repositories go through an official review process before being added. (Not extra PPAs that you add, I'm talking only official repos). You are saying even these official packages "are never truly vetted"? What am I missing?
* Anything that would take longer than a second or two. * http://flask.pocoo.org/docs/0.10/quickstart/#about-responses (tl;dr don't use `jsonify`, instead return a 3 item tuple of `(body, status, headers)`) * https://GitHub.com/Leo-g/Flask-GitHub-Webhooks/blob/master/GitHub-webhook.py (also, none of the "links" on this post are clickable)
https://docs.python.org/3/library/stdtypes.html#old-string-formatting &gt; Note The formatting operations described here exhibit a variety of quirks that lead to a number of common errors (such as failing to display tuples and dictionaries correctly). Using the newer str.format() interface helps avoid these errors, and also provides a generally more powerful, flexible and extensible approach to formatting text. That'd be why, but we all have our reasons for picking what we use. I grudgingly went from `%` to `format` to be consistent, and I found I sometimes used its extra features.
&gt; Not PyPy, I specifically said APT. And I specifically included apt in my reply. It is a blanket statement. PyPI, APT, RPM, any distro-du-jour with it's own repo, Ubuntu Software Center, Docker, and on and on. There is no guarantee of security and safety just because you installed from there instead of from a source tarball. &gt; What am I missing? You're missing the fact that an 'official review process' really doesn't mean much. There is no comprehensive code review done on every version of every package sitting out there, even in the official repositories. Really all it guarantees is that the source that went in to the package is signed by the same person that usually signs it and that it was delivered to you in a fairly secure manner. There can most definitely be huge security issues, be they malicious code or unintentional bug/vulnerability, still present in anything you get from the official repos. That said, some of the bigger groups do have security and audit teams. Debian is one example. But they can't review everything and generally stick to the bigger, more popular packages as well as doing reactionary reviews based on advisories and user reporting. It all comes down to trust in the author, trust in the repo maintainer, and trust in the processes they use to vet contributions.
Donâ€™t bother with YouTube tutorials. Youâ€™ll have much more fun [reading the official tutorial](https://docs.python.org/3/tutorial/index.html).
&gt; But no, something is not working. What is not working? What did you do and what results do you get? Error messages? &gt; python is just inconsistent. Package management is one of the annoying parts of programming. I don't think I've come across anything that I consider "good", though I consider Python to be one of the more pleasant ones (except on Windows), part of which is simply because Python does not compile to native code so you don't have to worry about ugly things like ABI compatibility. Now, I just made a quick virtualenv myself and it seemed to work just fine out of the box: virtualenv -p /usr/bin/python3.4 venv . venv/bin/activate pip install matplotlib # drink some coffee One of the tricky things with matplotlib is that it requires some "external" non-Python libraries (to interact with the GUI) like Qt, which lie outside Python's package management. This is why it's easier to install using your system package manager because the system's package manager can take care of these "external" dependencies. If you do it manually, you will need to read up on [what matplotlib requires](http://matplotlib.org/users/installing.html).
you didnt tell it that it was an xml doc and complain that it didnt work quite right ? awesome.
p vs np?
Meshgrid doesn't do anything useful in this regard. If you read that blog post you'd see fairly involved computations can be done with ufuncs and broadcasting. Compute first and mask out later can solve some if/else situations. If you really need "arbitrary" code, use cython or use python lists.
p = np
yes, not a best practice is a bit harsh. Probably "not needed" would've been a much better way to put it. HPC/scientific libraries tend to be fairly stable (both with regards to bugs and backwards compatibility) so one single installation (in either your user-directory or systemwide) is usually enough (in my experience).
You're not missing anything. The distro packages (APT for instance) are all intended to work together and are THE way to get stuff installed with a minimum of fuss. Sure, bugs happen and sometimes things conflict with each other, but that is NOT supposed to happen in a distro, and a distro bug should then be filed. Most of the non-distro bs exists because some people like to use OSs that haven't yet figured out how to manage packages. 
What is the benefit of using django vs flask (not asking for a general comparison, just how it applies in this case)
I'd recommend the [Python Cookbook by Dave Beazly &amp; Brian Jones](http://chimera.labs.oreilly.com/books/1230000000393/). Also, you can get a shitload of knowledge out of the various Pycon tutorials that can be found on YouTube. The tutorials are generally about 3 hours in length, and go highly in depth. - https://www.youtube.com/user/PyCon2014/videos - https://www.youtube.com/channel/UCgxzjK6GuOHVKR_08TT4hJQ/videos is the PyCon 2015 channel And finally, check out YouTube for guys like David Beazley, Raymond Hettinger, Miguel Grinberg, and Armin Ronacher, and many, many others. 
The simplest answer is I'm more comfortable with Django, which I believe is the same case with martin as well. That being the case, we chose to go with Django because we can implement features faster and know how to best implement them in that framework.
Alright you convinced me. Will try tomorrow.
Ah, I totally forgot that pct formatting could do that.
don't forget clone, the coolest feature!
A large part of it is shit python packaging, some could be bad instructions, some could be PEBKAC. TBH you haven't posted much detail about the steps you ran, your env, $PATH, $PYTHONPATH, what instructions you followed etc. Conda will probbably work better, there is less change to shoot yourself in the foot, but It would be a shame not to get to the bottom of this.
I said it before, but here it goes: I have multiple projects, some are more into business, some more into scientific stuff. The business packages has to be in different environments because each project might require different versions of packages. So I use virtualenv to manage them. Worked well so far. I would like to keep my workflow, so I adapted it to the scientific projects that I have. Some have to use python2, some python3, and again sometimes they the programs interact with something else, so a specific version is required. I use pip to install the packages, but I don't want to pollute or even corrupt my system python, as some other programs might depend on that. Ergo I try to keep away from installing it system-wide. A virtual environment is what I thought would be the right choice for this, but as I see in this thread, most people just use Anaconda. &gt; Idk, 'cos I'm a windows 7 user. And I just use standard software. I do too! But I like to control it more, maybe? I don't know. &gt; (I went on the Ubuntu world once. Windows is better, imo) Well... better than Ubuntu - maybe. But it depends on how you interact with your system, I guess. I mean, I don't even use my mouse for most stuff. And I like to have control and knowledge about my system, but this is really time consuming - but rewarding. And my system looks and behaves (mostly) exactly how I want to, or how I configured it.
You could also look at the .setdefault method, but defaultdict should do what you want.
Yes, that works fine, but this is no test. Do plot something.
&gt; Does matplotlib install successfully using pip? Yes... It confirms it. I can import it, but not really use it, as some dependencies are not fulfilled.
Ohh, I forgot you said it when I was writing. I understand you. I like to have as much control over my computer as I can. Time consuming but rewarding as you said. Back to the python problem, I had problems with the environment path Path before I know, more or less, how it works. For the different python versions, just install both and rewrite your env paths. Then you can call them differently from the terminal. python2 script.py -args python3 script2.py -args for different packages, well, just download them and unpack to the default packages folder. You can install two pips, set up them differently just like the python setup. pip_a install package_name pip_b install pyckage_name Have you tried this before?
Hmm, doesn't look terribly Pythonic to me: `forward.declare` acts as a separate flat namespace to hold classes which wrap the stuff you want to forward-declare (a novel thing) and access it through that namespace. Why not simply `import bar` from foo.py and `import foo` from bar.py?
I'm confused. What's wrong with: foo.py import bar &lt;code that uses bar stuffs&gt; bar.py import foo &lt;code that uses foo stuffs&gt; If either is heavy, and I just need an instance, I'll put the import in the __init__ and then use it, so it's delayed until instantiation.
One of my side projects on my todo list is to use various NLTK approaches and scraping a bunch of stock news sites and then use backtracking correlation (i.e. hindsight), for extra shits and giggles I'd quite like to see if it's possible to train a neural network. I seriously doubt that'll work (if it did someone would have done it already and the market would have equalized it out as a method). 
I haven't used it with those packages, but give it a try. if you find any bugs, the developer is very receptive to fixing them.
Oooo never used that... now I have *no* excuse for not porting some of my analysis packages for my different research projects to Python 3!
&gt;if it did someone would have done it already and the market would have equalized it out as a method Only if the implementer had enough market influence to control the market. Seriously: for company in market: if distress(company,one_year_ago) &gt; distress(company,currently) and press_is_good(company): me.buy(company) Is a far better algorithm than anything I'd do just reading the paper. I'd rather do this to assess 401k's or mutual funds. Really, *this* is a good investment. Why haven't the mods removed OP's post yet? hrmmm...
3 of my favourites, I love Daft Punk, Tool and Muse :).
A fair point, I guess if an approach worked, you masked your buys and kept your mouth shut you could extend the life of it working.
Yup! (And please forgive my tone in the initial comment; when I re-read my comment a moment ago I sounded awfully grouchy/mean, so I've rephrased myself)
Awesome, I just finished a site using Mezzanine a couple months ago. I'm pretty new to Django though, any need or plan to make a 3.1 to 4.0 migration guide?
I gotta say that I hate this attitude. As a scientist-programmer, I am continually frustrated with CS style papers which seem adamant to include only the absolute minimum of information. What should be the most reproducible of sciences instead publishes pseudo-code with some vague implementation details. Even if you never intend to share your code with anybody, *please* go through the pretense of making a virtualenv which could facilitate future distribution/re-analysis. I dream of a time when all computational papers could come with an IPython like computing platform to replicate results.
There ain't no such thing as "not importing at runtime" in python, each statement (including imports) are executed at runtime. What do you mean with "not smart enough to work out cyclic imports"? It's clearly working here: *a.py:* import b def a(): print b *b.py:* import a def b(): print a *c.py:* import a, b a.a() b.b() Running it: $ python c.py &lt;module 'b' from '/tmp/cyclic/b.pyc'&gt; &lt;module 'a' from '/tmp/cyclic/a.pyc'&gt; $
Yes: http://nuitka.net/pages/mailinglist.html (though I wonder how many of the subscribers can quite understand everything he writes, unless they too know the ins and outs of it).
I'm not too clear on your example... but if A depends on B and B depends on A that is a cyclic dependency, I don't care what language it's bad juju...
That works just as fine. What really doesn't work is importing names from such modules which would cyclically attempt to import themselves, but your forward declaration trick doesn't work around that either.
&gt; I don't care what language it's bad juju... Well, that's just plain superstitious. It will work fine. Here's a good discussion: http://stackoverflow.com/questions/744373/circular-or-cyclic-imports-in-python And, in your example, that's not a circular dependency. The code in the \_\_init\_\_ isn't run until instantiation. *You have no circular dependency*. It's possible to make one that doesn't work as expected, but most of the time you can fix it by sticking the import at the bottom, or not writing insane code. edit: could you show an example that doesn't work. There's an odd odor in the air. :P
And how does the system package manager handle virtual environments?
Lol nice, one day I'll have a good idea no one else has had ;).
Agreed ... That's a circular import ... maybe this gets fixed in Python3? Either way it's a bad code smell and if this is done in practice you can bet the code is poorly architected.
Everything has a learning preference, and mine is videos. That does look like a good resource though, so I will use it too :)
How do you get the coefficients of xavg?
Also this "SIGMA = annualized stock's standard deviation over the previous 3 months" makes me suspect the model. Shit behaving very unlike normal distribution and stuff. I really did not read the paper and if this problem is accounted for, I'm sorry.
&gt; Anything that would take longer than a second or two. Didn't get you, I mean how do I perform async, Should I use celery? Thanks will check links and reponses 
Mezzanine is great. Thank you, Steve and the community for all the hard work you guys do.
You can pad the input to match the key length. keys = ['x', 'y', 'z'] data = ['item_1'] paddedData = data + [None] * (len(keys) - len(data)) dict(zip(keys, paddedData)) Though personally I think /u/Vaphell's suggestion about using itertools.izip_longest() is more elegant. 
Second this... getting financial data seems to be the hardest part.
Sorry, had to sleep. But here you go: I run Fedora22, the virtual env was created with `mkvirtualenv compsim -p /usr/bin/python3 --system-site-packages`. echo $PATH /home/muma/python_envs/compsim/bin:/usr/lib64/qt-3.3/bin:/home/muma/.rvm/gems/ruby-head/bin:/home/muma/.rvm/gems/ruby-head@global/bin:/home/muma/.rvm/rubies/ruby-head/bin:/home/muma/bin/clang/bin:/home/muma/bin:/usr/local/bin:/usr/bin:/bin:/home/muma/bin/neovim/build/bin:/home/muma/.rvm/bin:/home/muma/bin:/usr/local/sbin:/usr/sbin:/home/muma/bin PYTHONPATH is not set. (Not sure, if this is a bad thing.) Anything else? 
Some confusion around this stems from the fact that you need to distinguish between top-level code (at import time) and other code (which was called "at runtime" in parts, but as someone stated, it's all at runtime, just at different times). Cyclic imports hurt you in top-level code (e.g. needing base class names defined). But cyclic imports are The Evilâ„¢ even if they work. The *real* solution is to factor out the common parts both modules need into a new module that then gets imported by both. The less favourable solution is to import inter-dependant stuff not at top-level, but within the implementation. This is still better than adding some strange mechanism, and works when the cycle is just a very small coupling (one or two names). If cohesion is stronger, stuff DOES belong into one module â€“ if that module is then too big, you should fix your big ball of mud, not throw more mud at it.
BTW, the comparable best option for non-Debian POSIX systems right now is Platter.
See the answer [here](http://stackoverflow.com/questions/18833759/python-prime-number-checker) 
Can you do the following inside the virtual env and outside the virtual env python -c 'import sys; print(sys.path)' and check that which python points to the virtualenv python3 copy
# Outside: python -c 'import sys; print(sys.path)' ['', '/usr/lib64/python27.zip', '/usr/lib64/python2.7', '/usr/lib64/python2.7/plat-linux2', '/usr/lib64/python2.7/lib-tk', '/usr/lib64/python2.7/lib-old', '/usr/lib64/python2.7/lib-dynload', '/home/muma/.local/lib/python2.7/site-packages', '/usr/lib64/python2.7/site-packages', '/usr/lib64/python2.7/site-packages/gtk-2.0', '/usr/lib/python2.7/site-packages'] which python /usr/bin/python python --version Python 2.7.10 # Inside python -c 'import sys; print(sys.path)' ['', '/home/muma/python_envs/compsim/lib64/python34.zip', '/home/muma/python_envs/compsim/lib64/python3.4', '/home/muma/python_envs/compsim/lib64/python3.4/plat-linux', '/home/muma/python_envs/compsim/lib64/python3.4/lib-dynload', '/usr/lib64/python3.4', '/usr/lib/python3.4', '/home/muma/python_envs/compsim/lib/python3.4/site-packages'] which python ~/python_envs/compsim/bin/python python --version Python 3.4.2
did you install the Python3 bindings (to gtk/tk/etc) using your package manager? Or just the Python2 ones? does the whole thing work normally if you create the virtualenv like mkvirtualenv --system-site-packages foo i.e. then then virtualenv will at least share the interpreter version with the host system, no python3 weirdness
1. In the first two tests on lines 4 and 6, which are not that useful anyway, you would have to `return` to stop the execution of your function. But donâ€™t do that and instead delete them immediately. (In fact, delete your entire function and start over.) 2. You need to check all integers between 2 and n-1 (use a `for` loop and `range`, but make sure to check what numbers `range` includes). Only when you find that all the modulo divisions return something larger than 0, you can say `prime`; if you find a case where it does equal zero, say `not prime` and stop. 3. You should not bother with maths problems if you donâ€™t know enough maths and instead do something more useful. They wonâ€™t help you become a better programmer.
I've written keyloggers in both C# and Python. C# is a better fit IMO, since this is very windows specific. I came across some annoyances with Python when trying to make a windows keylogger. I can give you the C# source for a really good keyboard listener class if you like
In Python 3, the `bytes` type supports neither `%` nor `string.format`, as it should be since `bytes` is not a string. This was changed in Python 3.5 to add `%` support to `bytes`, which is just *begging* for a redux of the unicode problems we had in Python 2.
&gt; did you install the Python3 bindings (to gtk/tk/etc) using your package manager? Or just the Python2 ones? Yes. Currently only tk is installed (I tried something else): dnf list installed | grep python3-matplotlib python3-matplotlib.x86_64 1.4.3-3.fc22 @System python3-matplotlib-tk.x86_64 1.4.3-3.fc22 @System &gt; does the whole thing work normally if you create the virtualenv like &gt; &gt; mkvirtualenv --system-site-packages foo &gt; &gt; i.e. then then virtualenv will at least share the interpreter version with the host system, no python3 weirdness Trying right now. 
Could you post this to pastebin? This code is quite unreadable
I saw that you got it working, but are you using your GPU or CPU? Getting 1 frame per 2 minutes using your CPU is quite fast, actually. 
&gt; I think it would be very hard to write a robust static type checker for Python without significant changes to the language. [You think wrong](http://mypy-lang.org/). &gt; No, the fundamental issue is that you can only know this at runtime. That's simply wrong. If you, the human reader, can look at a piece of code and recognise that a function will or will not exist without actually running the code through an interpreter, then so can a static checker. There may be some heavily obfuscated code, or ultra-dynamic code that uses exec all over the place, that is beyond even human intelligence. Or the code may simply be indeterminate: if random.random() &gt; 0.5: def func(): pass but *in real life* code that is that obnoxious is very rare and best dealt with by coding standards. 
We use a similar workflow, but deploy to S3 and use aptly.info to manage all versions and deliver updates at our rate (and not upstreams)
it's somehow (but not completely) not our problem - it's really not my fault that debian/ubuntu packages pip that does not work with pypy. Generally you should complain on debian/ubuntu (pip is a massive hack, that does not help). Additionally, distributing binaries on linux is not a thing. We really can't make it happen, the portable binary e.g. comes with statically linked openssl that a lot of sysadmins would consider a big no no. It's just linux in general and has nothing to do with pypy. Again, the picture is terrible and denializm does not help, but it's really not just pypy problem, but anything that takes a while to build.
&gt; It might be worth mentioning how you can't use {} in 2.6, you have to {0}. http://pyformat.info/#simple_3
There's no extension point for that, but you can still get notified about things through its API. It's something like: PythonRunner.onPyUnitServerCreated.registerListener(new ICallbackListener&lt;IPyUnitServer&gt;() { @Override public Object call(IPyUnitServer obj) { obj.registerOnNotifyTest(new IPyUnitServerListener() { @Override public void notifyTestsCollected(String totalTestsCount) { } @Override public void notifyTest(String status, String location, String test, String capturedOutput, String errorContents, String time) { } @Override public void notifyStartTest(String location, String test) { } @Override public void notifyFinished(String totalTimeInSecs) { } @Override public void notifyDispose() { } }); return null; } }); 
As it turns out, 'lxml' does not mean 'xml'. 
I've been looking for a project like that for *so* long ...
+1 for New Boston, I have used some of their other stuff in the past its pretty comprehensive.
(xposting my comment from the /r/programming thread) &gt; This is a situation I'd like us to solve once and for all for a couple of reasons. Firstly, it is a technical roadblock for some Python developers, though I don't see that as a huge factor. Regardless, secondly, it is especially a turnoff to folks looking into Python and ultimately a PR issue. The solution boils down to natively supporting multiple cores in Python code. Heh. So let's go full-cynic mode: finish out the already somewhat present support for subinterpreters (basically, all global variables should be moved to a huge Interpreter\_State struct), then just replicate the `multiprocessing` interface on top of that and bam! you have the so called green multiprocessing (like Perl AFAIK) but now you can market it as having got rid of the GIL. Obviously you'll still have the copies of all imported modules (including builtins) and probably the performance improvements in marshaling objects would be pretty marginal compared to using mmap, but yeah, mission accomplished! (I actually fully agree about that being 99% a PR problem. I don't think _any_ roughly Python-like language from PHP to Scheme has free threading support, but for some reason only Python folks waste countless hours being upset about it on the internet).
I guess this is technically an algorithm, but I would really call this more of a "statistical model". That said, is there a subreddit for sharing statistical and mathematical models?
I don't know if you're aware but there's http://www.reddit.com/r/kivy and also the #kivy channel on Freenode IRC is super helpful.
What tools are you using to package it? I have a Windows packaging tool called [pynsist](http://pynsist.readthedocs.org/en/latest/). I don't think anyone's tried it with kivy, but it aims to avoid the kind of errors that often seem to affect freeze tools.
I love conda, but its relevance to this example is minimal.
do you try with https://www.themoviedb.org/documentation/api ? seems much more open than IMDB. to interract with the API, look at requests: https://pypi.python.org/pypi/requests. 
:)
Conda is a package/environment provider that lives over the system in user-space. It's trivial to switch between environments in conda, something that operating system package managers are only just beginning to support. Conda packages could have been used instead of debian packages in this example, with the added flexibility of the ability to support multiple environments.
If you could code for 30k a week, you would find time for that
Just because you could build a hacked-together prototype doesn't mean it would work well or scale. Secure payments? Email notifications? Proper signup forms that integrate with an automated billing system? A management and administration console? An inventory management system that works? Reports generation system that isn't just a synchronous process blocking the front-end server's main thread? Comparison and analytics code to be able to compare offers 1:1? Logging, monitoring, backups...Hell, a "stock-like chart of prices" is crazy to do correctly: - Recording a denormalized version of each price on every transaction - Proper cache invalidation so you're not doing a table scan on your database every time the page updates - Storing relative price changes scalably so you don't fill up your database will thousands or millions of rows - Deleting old data and removing rows for deleted offers or items Sure, anyone could go in there and build the equivalent of a college hackathon project and have it not fall entirely on its face. This is what enormous multi-billion dollar companies *do*. OP is asking for how long it would take to build a fully-functioning enterprise-scale software company.
Yeah but it wouldn't be a just a week. The bulk of the site would be done sure, but I'm sure op would want continuous improvements, and there would be maintainance, so itwould probably be more like a 3-6 month ongoing thing. 
Yeah I was a sys developer for a while and every example you noted I have faced and had solutions for. So it's not like I'd be doing it from scratch but implementing previous solutions.
I know all that. The article is from a SAAS online company thing. I fail to see how deploying a conda environment containing the server application is better than deploying a deb package.... One should use the right tool for the right job, not one tool for every job... &gt; with the added flexibility of the ability to support multiple environments. don't see how that applies. One usually deploys a server to a single well controlled environment.
Small caveat: By default, that's true, but the new print function has awesome [kwargs](https://docs.python.org/3/library/functions.html#print), for `sep` and `end`: print(*objects, sep=' ', end='\n', file=sys.stdout, flush=False) Print objects to the text stream file, separated by sep and followed by end. sep, end and file, if present, must be given as keyword arguments. All non-keyword arguments are converted to strings like str() does and written to the stream, separated by sep and followed by end. Both sep and end must be strings; they can also be None, which means to use the default values. If no objects are given, print() will just write end. The file argument must be an object with a write(string) method; if it is not present or None, sys.stdout will be used. Since printed arguments are converted to text strings, print() cannot be used with binary mode file objects. For these, use file.write(...) instead. Whether output is buffered is usually determined by file, but if the flush keyword argument is true, the stream is forcibly flushed. Changed in version 3.3: Added the flush keyword argument. 
The two projects (Wooey and djangui) are fundamentally the same except one was built on Flask the other Django. As a result me and the djangui developer have decided to merge the two projects under the Wooey name. Development is being based off the djangui codebase (therefore using Django) with features and UI stuff being ported over. You can follow progress in the djangui-Wooey repo at: https://github.com/Wooey/django-djangui Once it's ready that repo will be merged into the wooey repo for release. I'm currently on holiday in Greece for a week, but happy to answer any other Q's when I'm back. Also on mobile to excuse any dud links.
Sure. I still think it's a stretch but whatever. Lets concentrate on getting scientists to stop 'sudo pip installing' before replacing distro package managers for defining the base system.....
That's good news. The implicit conversion between `bytes` and `unicode` is where most of the problems came from, and there's *still* discussion on the mailing list about allowing it so coders can get results quickly for common inputs. 
I'm using Pyinstaller. Thanks for that. I'll check it out.
Why does that suck?
It isn't *necessarily*, but it goes against Python's mentality of "there should be one, and preferably only one, obvious way to do it". 
Futures works only with python2, see https://pypi.python.org/pypi/futures/3.0.3 But, Python3 has futures module in standard library https://docs.python.org/3/library/concurrent.futures.html , you should use them for your python3 distribution.
And it's one of Python's most basic and intrinsic features, something that beginners will use straight away -- and now it's a two headed beast with all this baggage. Really bothers me.
its c code, the cost of maintaining a setup like that like that is utterly high note that a major problem is the refcounting gc and another major problem is the seemingly atomic operations that no longer would be without gil
They cache it, but: * some new dependencies requires compilation * upgrading a package invalidates the cache 
In golang they have a goprocs environment variable that determines the number of threads. Doing something like that with python makes sense to me. Maybe spawn n+1 processes, where the extra is a coordinator. The coordinator is responsible for shared state. Children register If they are using something and deregister when not. The coordinator gcs the shared state when all refs are gone. The children act normally otherwise. ]]
You need to filter on event type, you're getting keyups/keydowns/etc. [See this stackoverflow post](http://stackoverflow.com/questions/5910202/pyhook-return-keydown-fires-twice).
I did have this error a few months ago, fought hard against it and lost, but a few days after, a fix for it landed in request's master, so next time i tried, it did work, have you tried updating requests or applying this fix manually? https://github.com/kennethreitz/requests/pull/2533 (see https://github.com/kennethreitz/requests/issues/2465) Hope it helps!
~ 9 mo I was huge perl programmer. Friend asked me to help him with Python script. I scoffed at "significant whitespace" (I was young and stupid). Still, I helped him. 9 mo later I'm struggling to figure out what this perl program I wrote does.. he asks me for help again. Looking at the python we wrote 9mo prior, I instantly understand it. Think there might be something to this Python thing.
you seem to massively underestimate the problems of needing to introduce fine grained locks everywhere, its a massive maintenance and security hazard going to production quaity is vastly different from a proof of concept the problem wrt seemingly atomic operations was never solved outside of pypy pypy is on a entirely different page wrt pulling things up because it has so many metaprogramming cappabilties in pypy introducing a new gc model is not rewriting all alloc/deallo code, but creating a algorithmic graph transformation the approaches are incomparably different i consider just saying cpython can do it because pypy could do it hostile 
A classic case of a bad workman always blames his tools.
From other side all current C extensions will not work without GIL. PyPy does not care about this most of the times. 
PyPy is just magic; you don't really need to do anything special (although structuring code in certain ways can certainly help PyPy go faster). The catch is that, compared to the gains you can get with the other two options it doesn't give that much of a performance boost. Cython can take a little work. It really helps to profile and use the "cython -a" output to really find the right places to annotate your python code and squeeze out extra performance. There's also some overhead in working with Cython (actually cythonizing and compiling files etc.) unless you are working with ipython notebook and cython cell magics. Numba can give incredible performance improvements, and is practically free to use (just add @numba.jit() to the top of your function). The catch is that it doesn't work on everything. If you actually want to see real performance from it you better be working on numerical code with numpy. Numba also asks you to write your code differently -- you actually want to do the "dumb" things of actually writing loops running over numpy arrays etc. that are the naive approach -- it will work otherwise, but you won't see much performance gain. 
What do you want it to print back?
https://bitbucket.org/tpn/pyparallel
5/2 is 2.5 in Python 3 and 2 in Python 2.
So I should delete the old version of python?
If you're interested in seeing the latest and greatest talks, the SciPy 2015 convention is just finishing up its last day of talks and the videos are getting uploaded to the [Enthought youtube channel](https://www.youtube.com/user/EnthoughtMedia/videos) same day in most cases. I was sitting in a talk about Numba and the latest and greatest features just earlier today [and it's already online](https://www.youtube.com/watch?v=eYIPEDnp5C4). There's also been a [tutorial on Cython](https://www.youtube.com/watch?v=gMvkiQ-gOW8), and today there was a talk specifically on [circumventing the linker for BLAS and LAPACK in Cython](https://www.youtube.com/watch?v=R4yB-8tB0J0). There haven't been any talks on PyPy here though, but this should be good to get you started.
' '.join(['worst', 'join', 'syntax', 'ever'])
I'd look at Requests and Tabulate
 x = 5 try: raise Exception() except Exception as x: pass print(x) # fails on python 3 because x is not defined 
I just ran this and it worked fine for me. No error. 
sorry edited again. forgot catch... "as x" 
[](/rdtwismile) This is great, thank you!
(Run on the interactive shell) &gt;&gt;&gt; x = 5 &gt;&gt;&gt; y = 5 &gt;&gt;&gt; x is y True &gt;&gt;&gt; x = 305 &gt;&gt;&gt; y = 305 &gt;&gt;&gt; x is y False
He, wrote the same example while you submitted this. 
How do you handle dependencies on things that are outside of python? Manually avoid conflicts? What about different versions of python, other than the very latest 2.7, 3.4? It seems like this would work in many cases, but won't be devoid of issues, which is why there is momentum for docker. If all you deploy are web apps, it is likely you won't run into issues. I think maybe a hybrid of this approach and docker would work well, but relying on virtualenv alone will run into issues eventually.
 &gt;&gt;&gt; True = False &gt;&gt;&gt; True == False True
Ca you explain what's happening here?
Fair point. I don't know if it is _that_ surprising to me though.
Integer Cache is a weird thing. &gt; The current implementation keeps an array of integer objects for all integers between -5 and 256, when you create an int in that range you actually just get back a reference to the existing object. So it should be possible to change the value of 1. I suspect the behaviour of Python in this case is undefined. :-)
https://docs.python.org/2/c-api/int.html &gt; The current implementation keeps an array of integer objects for all integers between -5 and 256, when you create an int in that range you actually just get back a reference to the existing object. So it should be possible to change the value of 1. I suspect the behaviour of Python in this case is undefined. :-)
The fact that you can assign it is though. At least you're prevented from assignments within comparison statements. 
http://pastebin.com/Up45fY6B 
I think this is pretty WTF especially when combined with /u/Aea 's explanation. I didn't realize that `-5 to 256` were actually existing objects. I could imagine someone not familiar with this getting really frustrated to find out some comparison they were using with `is` didn't work with values beyond 256. 
The latest version of OS X (10.10, released 2014-10-16) shipped with Python 2.7.6 (released 2013-11-10). Apple is notorious for using out of date versions. The poster wants the current version.
Oh yeah? Well python is my first language so I really don't have much of a frame of reference. When I first wrote the code I assumed that variables were inherited with the rights to alter them. Good to know!
The 'is' comparison checks if the two have the same identity (share the same memory address). When you start up python the first 256 numbers will be allocated. These numbers gets used a lot, so it makes sense to just have them ready. In the first example a and b just gets assigned to the same address and you ask if they are identical which is true. In the second example, since 257 has not be pre-assigned, you will allocate both a and b separately. They have the same value but not the same identity. In the third example, the python interpreter is made such that it will recognise that you are assigning the same value to a and b and will only allocate that value once and make a and b refer to the same.
Probably tars up your porn folder and emails it you your boss. All bets are off in the topsy-turvy world of python.
Presumably a performance optimization as small numbers are used a lot? This doesn't exist in Python 3. 
fixed in python 3.
no, because protocols. would you rather be able to join any iterable of strings, or have to re-implement string joining for every iterable you define? feel free to write `str.join(' ', ['pretty', 'awesome'])` instead
On top of that I would suggest if you need to use `global` it is likely you are doing it the wrong way. If you depend a lot on global variables, you will have code that is hard to debug and maintain.
That's what I've read before. It was a small app so I couldn't really think of a better way to write it. I try to avoid using global.
defining a function inside a loop is absurd...unless you need multiple function definitions.
Please don't do that. Avoid global variables. In Python 3, use nonlocal instead of global.
 import re string1 = '{{1234}}' string2 = '{{1234a}}' reg1 = re.compile(string1) reg2 = re.compile(string2) reg1.match(string1) #No match reg2.match(string2) #match I'm not too sure but I think it has something to do with string formatting (Like ```'Test {0}'.format('this')```) You'll have to escape the string in order for it to match. ``` reg1.match(re.escape(string1)) ```
I had never heard of `__format__` before this. Now I really want to find a use for it.
I was creating Qt widgets inside a loop and also creating the signal handlers to connect them to. Later, I learned about QSignalMapper so I probably didn't need to create all those signal handlers.
Please, please, **please**, someone do this on a fork and **solve real problems** with it before introducing it into a piece of software tons of people use. The core solutions for many things (including this thing) have been botched pretty bad at times, but because it's official many people run headfirst into the pain.
Here's an interesting one that I'm certain no one has said before: Excluding programs that throw exceptions, any python program can be written in a single line without any semicolons.
You mean : ' '.join(['best', 'join', 'syntax', 'ever']) ' '.join(('best', 'join', 'syntax', 'ever')) ' '.join({'best', 'join', 'syntax', 'ever'}) '-'.join('bestjoinsyntaxever') d = {'best': 4, 'join': 16, 'syntax': 36, 'ever': 64} ' '.join(d) d = {v:k for k, v in d.items()} res = '\n'.join(d[x * x] for x in range(1, 10) if x % 2 == 0) with open('cool.txt', 'w', encoding='ascii') as f: f.write(res) ''.join(open('cool.txt', encoding='ascii')) 
It's a performance optimization. It avoids repeated object creation/destruction for the most frequently used integers. 
No it is not. It is very common for programatic and "data as code". Instead of hardcoding 10 callbacks or whatevers you create them in a loop.
I burned my hand multiple times at this when I was defining piecewise functions using np.piecewise. That function takes a list of domains and a list of functions, so it naturally requires running a for loop to obtain a list of functions. The "feature" also occurs a in list comprehension: F = [lambda x: x**i for i in range(10)] print [g(2) for g in F] which returns [512, 512, 512, 512, 512, 512, 512, 512, 512, 512] In this case you can also fix it by: F = [lambda x, i=i: x**i for i in range(10)] print [g(2) for g in F] which returns [1, 2, 4, 8, 16, 32, 64, 128, 256, 512] 
Alternatively pass in i as named variabe funcs = [] for i in range(5): def myfunc(i=i): return i funcs.append(myfunc) 
Why do you disagree?
C = True Def go(var): If var: var = False go(C) If the function go only ever takes the variable C, you could put C instead of var. I just used it here as a clarification. Also, unless you are talking speed of light, (or x, y as coordinates or similar) single letter variable names are a bad idea. Much better to have something descriptive :) 
Could you elaborate on this a bit? I'm just starting out with Python and to me they seem to be one in the same. 
Import program
There's something similar in Java. Ints can be compared to Integers smaller than some value (1000 maybe?) with ==. Anything higher must use .equals(). 
Exactly.
nah, not run, written.
Default parameters values aren't recreated each time a function is entered. def thisIsBroken(y = []): print("Before: %r" % y) y.append("hello") print("Afte: %r" % y) # call it once thisIsBroken() &gt;Before: [] &gt;After: ["hello"] # call it again thisIsBroken() &gt;Before: ["hello"] &gt;After: ["hello", "hello"] Forcing you to do a stupid hack like: def thisIsNotBroken(y = None): if y is None: y = [] # stuff There is no sane reason, just like "literal strings" not being able to end with a slash. Devs r lazy. :P
Docker is hardly devoid of issues, either. Nothing's perfect. But `dh-virtualenv` is a good tool to have in your belt.
It's strange, but I think it's sane. I don't want to accidentally modify global variables unless I specifically say it should be a global variable. Otherwise I would have to keep track of them. I like that this is strict, to the point of creating a local variable if assigned. But, I always want to read global variables, if there's no local variable with the same name. The point is that they're globally *accessible*.
/r/learnpython
That example helped a lot. I'm still a little fuzzy on why defining a and b in one line made a difference though.
&gt; ; 
That is a classic. One has to realize that unless a second argument is provided to wtf(), it will be reference some same array over and over. print id(a) will make that clearer
oh boy. I have a document for this sort of thing. Here is one: &gt;&gt;&gt; True = False &gt;&gt;&gt; if True == False: ... print "I AM A BANANA" ... I AM A BANANA
This was a fun one to learn. 
Another! &gt;&gt;&gt; int(None) Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; TypeError: int() argument must be a string or a number, not 'NoneType' &gt;&gt;&gt; str(None) 'None' 
Only wtf until one realizes that Python is simply storing refs for defaults. Crazy would be if Python tried to re-evaluate defaults on every use: myconfig = open('config.txt') def fn(cfg=parseConfig(myconfig)): ... If Python *didn't* save references, the above would break on the second call. This is not to say it wouldn't be cool for Python to support evaluator-arguments, but I'm glad (after I got into Python a bit) that the default isn't that way.
When `a` and `b` are set to 257 in the same line, the Python interpretor creates new object, then references the second variable at the same time. If you do it in separate lines, it doesn't "know" that there's already 257 as an object. &gt;&gt;&gt; a, b = 257, 257 &gt;&gt;&gt; a is b True &gt;&gt;&gt; b is a True &gt;&gt;&gt; id(a) 140640774013296 &gt;&gt;&gt; id(b) 140640774013296 &gt;&gt;&gt; a = 257 &gt;&gt;&gt; b = 257 &gt;&gt;&gt; a is b False &gt;&gt;&gt; id(a) 140640774013392 &gt;&gt;&gt; id(b) 140640774013488 
If you write this code in a file a = 257 b = 257 print a is b and execute it $ python is.py True What is happening here? Each line in the interactive mode must be compiled and executed separately to update the environment, so each creates an object to the integer 257. When compiling (and executing) a single file, a single object is created. So the ";" is still just a separator, and there is no code smell here.
 Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy. Avoid writing scripts or custom code to deploy and update your applicationsâ€” automate in a language that approaches plain English, using SSH, with no agents to install on remote systems. http://ansible.com/ 
Ehhh this is true for almost every language though. You can get by with a global install though if you're the only one who ever uses your programs.
Yeah, this str/unicode thing can be a pain. I now start all my python wiith from __future__ import unicode_literals I think this should be mandatory. Probably along with `absolute_import`, to stomp another source of unexpected bugs, when someone decides to make a file named `datetime.py`. 
besides just using the completely wrong operator (is instead of ==) or the function default arguments thing, it's nice to see that atleast it's mostly just people having to make up a bunch of ridiculous situations to get "WTF" (...) reactions instead of there being any real problems someone might actually run into edit: whoops i meant 'is' instead of 'in'
 class RandomClassName(): def __init__(self): # &lt;&lt; wtf This is coming from previous experience in Delphi ( object pascal ) . Why the hell are you passing the object to itself as an argument in its own constructor , it doesn't exist yet, what. the. fark. 
Where's my switch case?
&gt; that's some serious code smell coming from the "optimizer". [Here's even more code smell from the optimizer](http://i.imgur.com/Ic9VXr0.png).
You can reassign constant integers within a certain range around zero as they are predefined objects that can be overridden. Literally 2 can equal 3. def function(foo=[]) will use [] as a single object so if you modify foo at any time, it will be used for all future invocations of the function as the new default.
__init__ is not the constructor. __new__ is the closest thing in Python to a constructor. [docs](https://docs.python.org/3/reference/datamodel.html#object.__new__)
 &gt;&gt;&gt; is is is True **Edit:** I know, I know, it really raises a `SyntaxError`, but still, if `is` isn't `is`, I just don't know what `is` even is!
https://www.youtube.com/watch?v=j4XT-l-_3y0
Lack of positional-only arguments - specifically how you can't have a keyword argument and a positional argument with the same name. &gt;&gt;&gt; def the_fn(model_class, **kwargs): ... pass ... &gt;&gt;&gt; the_fn("something", model_class="hello") Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; TypeError: the_fn() got multiple values for keyword argument 'model_class' I'm running into a situation where I'm using a function from a contributed library that has the header `the_fn(model_class, **kwargs)`. The keyword arguments get passed to an ORM, and there's a column name of "model_class" for the table, so I can't just *not* use that keyword argument. I actually don't know what to do about that situation, lol. Why should positional arguments care about kwargs when you can't even access the values the same way? &gt;&gt;&gt; def ok(lol, **kwargs): ... print(x) ... &gt;&gt;&gt; ok("haha", x=10) Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "&lt;stdin&gt;", line 2, in ok NameError: global name 'x' is not defined 
`__init__()` isn't a constructor, it's an initializer.
This is exactly what I was looking for! Do you know of other examples provided besides the ones on the main webpage? 
yes i tried googling it and have been to all the links that you and google have given me and i can find an exe for pyhook. i know there is one out there because i used to have it but i cant remeber where i got it from
The trouble I've had with pip is nowhere near the Ruby dependency hell I've encountered. 
The decision to almost-completely ignore distro packaging makes life hell for actually distributing code. The incompleteness and weird edge cases of virtualenv make it *seem* as though you have isolation, but you don't. The problem is the halfway-ness of it; it desperately needs help.
If you really want to have fun, fire up ctypes and start changing the value of these integers in memory. Shit gets real weird real fast.
Don't worry me neighter. But do not give up. You can wacht Shia labeouf if you need motivation. https://www.youtube.com/watch?v=DvVUBZy_MHE 
It's not the constructor, it's the initialiser. The object it constructed by `__new__`, but because that just creates an object it rarely needs to be overridden. The object returned by `__new__` is passed to `__init__`. Hence it does exist when `__init__` is called. 
Be aware though that the outer reference keeps the object alive and it can lead to hard to track memory leaks.
Disagree. Pip works great (even with compiled packages like numpy), setup.py and requirements.txt is fine, packages can be hosted on github and installed through pip (without cloning the repo), and virtual envs are awesome. What's not to like?
Not off hand. I know they have a fairly active discussion group (possibly Google groups?), so it might be a good idea to find the link to that. From what I saw, the devs seem quite helpful. 
I ran into this one the other day while diagnosing why there were 10x the expected number of messages dropped onto a queue. &gt;&gt;&gt; t = ('one', 'two') &gt;&gt;&gt; for i in t: ... print i ... one two &gt;&gt;&gt; t = ('one') &gt;&gt;&gt; for i in t: ... print i ... o n e &gt;&gt;&gt; 
I found also this https://github.com/PolicyStat/terrarium or good old https://pypi.python.org/pypi/as.recipe.frozenpkg :)
Perfect! Thanks so much again!
**Big do-over edit:** Having trouble replicating this, and I'm also having trouble replicating my trouble replicating this. Lots of trouble tonight! Python 2.7.10 test &gt;&gt;&gt; funcs = [] &gt;&gt;&gt; for i in range(5): ... def myfunc(): ... return i ... funcs.append(myfunc()) ... &gt;&gt;&gt; funcs [0, 1, 2, 3, 4] Python 3.4.3 test &gt;&gt;&gt; funcs = [] &gt;&gt;&gt; for i in range(5): ... def myfunc(): ... return i ... funcs.append(myfunc()) ... &gt;&gt;&gt; funcs [0, 1, 2, 3, 4] Ok, I'm going to bed now hah Previous post is below: &gt; I'm not really following: &gt; &gt; Python 2.7.10 &gt; &gt;&gt;&gt; funcs = [] &gt; &gt;&gt;&gt; def myfunc(arg): &gt; ... def _func(): &gt; ... return arg &gt; ... return _func &gt; ... &gt; &gt;&gt;&gt; for i in range(5): &gt; ... funcs.append(myfunc(i)) &gt; ... &gt; &gt;&gt;&gt; funcs &gt; [&lt;function _func at 0x6ffffe277d0&gt;, &lt;function _func at 0x6ffffe27848&gt;, &lt;function _func at 0x6ffffe278c0&gt;, &lt;function_func at 0x6ffffe27938&gt;, &lt;function _func at 0x6ffffe279b0&gt;] &gt; &gt; On a hunch, I tried this loop: &gt; &gt; &gt;&gt;&gt; funcs = [] &gt; &gt;&gt;&gt; for i in range(5): &gt; ... funcs.append(myfunc(i)()) &gt; ... &gt; &gt;&gt;&gt; funcs &gt; [0, 1, 2, 3, 4] &gt; &gt; Tried it again in Python 3: &gt; &gt; Python 3.4.3 &gt; &gt;&gt;&gt; funcs = [] &gt; &gt;&gt;&gt; def myfunc(arg): &gt; ... def _func(): &gt; ... return arg &gt; ... return _func &gt; ... &gt; &gt;&gt;&gt; for i in range(5): &gt; ... funcs.append(myfunc(i)) &gt; ... &gt; &gt;&gt;&gt; funcs &gt; [&lt;function myfunc.&lt;locals&gt;._func at 0xb6e86f5c&gt;, &lt;function myfunc.&lt;locals&gt;._func at 0xb6f4fa94&gt;, &lt;function myfunc.&lt;locals&gt;._func at 0xb6ea302c&gt;, &lt;function myfunc.&lt;locals&gt;._func at 0xb6ea3074&gt;, &lt;function myfunc.&lt;locals&gt;._func at 0xb6ea30bc&gt;] &gt; &gt; Tried the same nested function call as before: &gt; &gt; &gt;&gt;&gt; funcs = [] &gt; &gt;&gt;&gt; for i in range(5): &gt; ... funcs.append(myfunc(i)()) &gt; ... &gt; &gt;&gt;&gt; funcs &gt; [0, 1, 2, 3, 4] &gt; &gt; I can't seem to be able to replicate your issue! &gt; &gt; **Edit:** formatting
I use it to build a command string which it does great.
2 options: One that is easy: if there are any names that are valid in python that are not valid in your ORM (maybe starting with "_"?), you could make that the name. Another that is probably less easy depending upon the details your case is to define the_fn in a closure and provide a model where instead of doing that, you do: def the_fn_factory(model_class): def the_fn_closure(**kwargs): pass # do the_fn's job here return the_fn_closure And then pass the_fn_factory(model_class) in where you would've passed the_fn in. Whatever you do, it's going to me messy, so document why it is that way!
Yeah, tidied the formatting. See my edit. Sorry about that.
It actually makes a lot of since to me in a functional sort of way. You pretty much state in the begin that list1 and list 2 are equal. Therefore they are still equal after modifying on. Think of it like a math formula if y = x then y+1 = x+1 It's not 100% equivalent to a mathematical formula though. 
I don't understand, when I run this, it doesn't do that. http://i.imgur.com/i8s18DY.png Why the downvote? I honestly don't understand.
You need to call the functions in `funcs`. `[f() for f in funcs]`
Yes, but that's the purpose of the with statement, to create a small lifetime for a single variable. I don't think this is the purpose of exceptions!
I guess I'm used to that. Python passes references to objects, and creating a new object assigns that new reference to the variable rather than updating the reference that variable had in the global name space. I'm glad we have clear scopes like this. The alternative is either everything is global (ech!) or everything is immutable in a different scope (which would pretty arbitrary and a PITA IMO).
&gt;You can reassign constant integers within a certain range around zero as they are predefined objects that can be overridden. Literally 2 can equal 3. Example?
You mangled my code again. It's important that you add all of the functions to the list during the loop, and then only call the functions once you are out of the loop. Once again: `[f() for f in funcs]`
Yes, this is most certainly it. The thing I find most surprising about jamsquad87's example is that compiling the second regex doesn't fail.
I don't follow. What should happen with def fun (x, x=5): print (x) ? I think there would be weird edge cases if things weren't consistent. 
Damn, came here to post exactly this. Great to hear they finally "fixed" this though.
&gt; without any semicolons Prove it.
Nobody, they hacked themselves in....somehow...after a lot of tries.
Every thing is an object, passed by reference. Pretty great!
That makes sense. Like zip.
Java does the same thing with small Integer objects, I believe. The _really_ cool thing is that, with reflection, you can do something like `Integer a = 5;` which will box the 5 and return the global 5 instance. Then you can use reflection to change 5 to 8. Yay!
Oic. Thanks very much
Except, not... As /u/Aea [commented](https://www.reddit.com/comments/3cu6ej/-/csz1sea), id is testing for object equality. The result of .replace is a new object, so it has its own identity.
 &gt;&gt;&gt; True is False False &gt;&gt;&gt; True is False == False False &gt;&gt;&gt; True == False False &gt;&gt;&gt; True == False is False False
Performance. Python has also done similar tricks with dictionaries; since almost everything in Python is or uses a dictionary, there have been optimization approaches that just keep a list of already-allocated structures, and hand one over when a dictionary is needed. If that list isn't full, a dictionary that's no longer being used (as determined by the garbage collector) can be returned to the list instead of freed and requiring fresh allocation for the next new dictionary needed.
I don't see the problem here.
 def fn(cfgL=lambda: parseConfig(myconfig)): cfg = cfgL() ...
`exec` is a hell of a drug.
This got me by surprise too when I started using Python. (first language). You'll find it useful when your projects get very large to have multiple variables called the same thing because though the word describes both of them, in the context of their scope, they refer to different things.
This behavior makes more sense to me than the alternative. It would be strange if this def foo(bar=[]): ... behaved differently from x = [] def foo(bar=x): ...
Sure, so lets start with a basic statement: Any while loop can be rewritten as a for loop. I'm just going to go ahead and state that. Now these can get rather complex, for example your for loop may be in the form `for x, y, z in someComplexGenerator:`, where someComplexGenerator does lots of things^(TM), but that's fine. So now, any for loop can be replaced with a list comprehension: for i in range(15): #do some complex thing # can be rewritten as def function(i): print(sum(range(i))) [function(i) for i in range(15)] So now we need to rewrite our functions in one line...lambdas! [lambda i: print(sum(range(i))) for i in range(15)] # I made a mistake in this one I'm too lazy to fix it, meh sure there's an extra side effect, but meh. Now we also need our program to run: (lambda val=15:[(lambda i: print(sum(range(i))))(i) for i in range(15)])() # this makes use of IIFEs if you're familiar with javascript oh and that keyword argument syntax at the beginning lets us declare variables in global scope, we can also use it elsewhere to declare variables in a local scope if we need to reuse things or reference them. here's another wonky one that I wrote to demonstrate some things, sadly you can't nest context managers or it would be possible to handle exceptions generally with type("ctx", (),{"__enter__": lambda s: s, "__exit__": lambda s, e, v, t: 1})() as d: (lambda x=10: [print(a) if a &lt; x else list(next(iter(()))) for a in __import__('itertools', globals(), locals(), [], 0).count(0)])() oh right that one also has me define a context manager inline, as in I create a class, that's equivalent to class ctx: def __enter__(self): return self def __exit__(self, type, value, traceback): return 1 # this swallows errors, I'm a monster import itertools x = 10 with ctx() as d: for a in itertools.count(0): if a &lt; x: print(a) else: raise StopIteration So that gets us most things, but what about recursion through tree structures, because that'd be nice. Well we get this: lambda a,N:(lambda v,s:((n,v.add(n),s.extend(N(n)))[0]for n in s if not{n}&amp;v))(set(),[a]) # this is BFS that's also been minified, here's an expanded version: lambda start,Neighbors: (lambda visited,successors: ((n,visited.add(n),successors.extend(Neighbors(n)))[0]for n in successors if not{n}&amp;visited)) (set(),[start]) # visited, successors This uses a trick that's rather sneaky. You construct a tuple `(n, visited.add(n), successors.extend(Neighbors(n)))` and then only ever take the first object. you construct the entire tuple conditionally, and visited.add and successors.extend both have side effect. useful for updating your frontier and visited set as you iterate across successors (which gets longer as you go). Or you can use the y combinator since we've defined a lambda calculus via our prior steps.
without exec.
actually in many ways it is, there's just some rules you can follow to apply that generally.
I knew we shouldn't have used Register Globals!
Isn't your example a programmer error? The programmer isn't being mindful of the side effects of executing code in a function definition. To me it's much more intuitive that this line of code would execute multiple times rather than be saved across calls, especially since there's no more special casing for mutable types. I link most of my programming knowledge back to assembly/C. I expect the statements to setup the function to be called every time I call the function, because these statements are called in order to push the value on the stack.
Is there a free open source version? How does it compare to salt? 
Not within a raw string; it should represent a single backslash no matter where you put it. It doesn't work at the very end of a raw string because of a parsing limitation.
Found it: switch = {'thing: lambda x: x+1} case = 'thing' default = lambda x: x action = switch.get(case, default) action(1) 
That's one of those WTF's you run into fairly early on. I use lists to avoid it if possible. [ "hello" ]
Very true. Maybe it is because that variable that gets created is generally never used elsewhere? Typically I see it just used to print/log the error in the next line. Still seems like very buggy behaviour though, especially if it works with Python 2 but not Python 3.
take a look on how to create a virtualenv. It will remove the need sudo for root access.
I think it still counts as a WTF, just because it's unintuitive compared to other programming languages and is a little bit backward from how you might think about it in plain english ("join these things with this joiner" probably more than "use this joiner to join these things"). But once you know the technical justification, it's a very clever and sensible WTF. WTFs can be good!
I think that's the point; the constructor is the canonical way to initialize an object in many languages, but in Python you just accept the object fully-constructed and initialize it afterward. A WTF doesn't have to be a bad design at all, just something potentially unintuitive, even if it's just because different languages make other, equally valid, yet more common decisions.
This is a fun one: &gt;&gt;&gt; any([]) False That might be expected, but then: &gt;&gt;&gt; all([]) True 
Are you using Python 3?
This bit me just this morning! After reading some StackOverflow posts, it made sense. However, it is still annoying. 
That's not really a solution as lists and tuples are different types with different use cases.
 &gt;&gt;&gt; True is False == False False What is happening here?
thirdedÂ¹ 1. Note that my comment depends on yours, as does yours upon its parent.
tuples are defined byt the commas, not the parenthesis: (a,b,c) = 1,2,3
Virtualenv is a misnomer. It's just a custom package directoryâ€”things like library dependencies still apply.
Need a multi statement function in a switch like this? No problem: https://www.reddit.com/r/Python/comments/3cu6ej/what_are_some_wtf_things_about_python/cszcpcq Excessive and unreadable use of lambda to the rescue! 
I've found ruby's gems/bundle a bit more confusing.
&gt; I'm glad (after I got into Python a bit) that the default isn't that way Why, would it affect the performance too much? Example looks more like a bad code.
This construct is always going to kind of suck without lambdas that support statements.
well... that is totally consistent and a very basic/expected behavior in python. "if &lt;cond&gt;" would evaluate to true - is_false is a method defined on the object. You're just checking that it exists.
That makes sense to me. Since there's nothing in that list everything is truthy.
Thanks. I've never used a raw string. That's cool
I just gave an example for OP, I'm not saying it's WTF.
True + 1 2 Causes all kinds of subtle problems with type checking.
That would seem like the sort of thing that could be dependent upon implementation (CPython vs. PyPy for instance) too.
I just wanted to point this out for anyone who's going to skim this and take away the wrong impression.
I would guess that this is for performance reasons. Copying a reference for each iteration is far more efficient than copying an object for each iteration.
Look at the print statement and you can tell right away it's not 3.
Python 3 is the same. I don't think anything changed regarding this optimisation.
I guess this raises more confusion. Why would it be different in interactive environment vs. regular? What else is different?
Literally the only reason I didn't use Ruby after learning it.
If you're going to support multiple distros, using debian-specific tooling would be the worst nightmare for you. I'd recommend using `sonatype nexus` instead, which allows you to serve all popular package formats including but not limited to `deb`, `rpm`, `npm`, `tar.gz`, `wheel`, `gem`, `jar` and `war`in a single place with `ldap`-configurable authentication, ACLs and pretty web interface after installing a bunch of plugins.
The important difference here is that the interactive process has to compile each line to bytecode as it goes, while the regular process doesn't.
Yeah, this doesn't really seem like a problem to me. Makes sense. The confusion comes from the lack of understanding of variable shadowing.
Those both seem exactly what I'd expect - they're following the rules of basic logic's existential and universal quantifiers. Eg. if there are no unicorns then "Are there any black unicorns" is obviously false. But equally "All unicorns are black" is true - this is essentially equivalent to "There are no non-black unicorns" - every single unicorn (all none of them) fit the "is black" specifier. The same applies here - you're asking about an empty list, just like the set of unicorns. All of them match any criteria you care to name, because there's no way an empty list can have any counterexamples.
Yeah `any` checks that there's any truthy item, `all` checks that there isn't any falsy item.
`InteractiveInterpreter` is a hell of a drug.
Just watched this. Very informative and good. 
I felt as you do once upon a time. I recommend you really give venv and pip a shot. It's quite fantastic for keeping track of your dependencies and getting a reliable, repeatable installation. I suppose if you never distribute your code to other people/machines, then there's not much point to it.
You can do stuff with naming conventions, depending on the values you're switching on. Eg. a while back I wrote a context manager that lets you do stuff like: def myswitch(val): with switch(val) as result: def case_one(): return 1 def case_two(): print("Value was 2") return 2 def default(): return "Default") print(result.value) &gt;&gt;&gt; myswitch("one") 1 &gt;&gt;&gt; myswitch("two") Value was 2 2 &gt;&gt;&gt; myswitch("three") Default Other options are to do so based on class members or similar.
Dunno if you're familiar with C++ at all. But it's like this: std::string str1("A string."); std::string str2("A string."); if(str1 == str2) // This is like == in Python cout &lt;&lt; "true" &lt;&lt; endl; else cout &lt;&lt; "false" &lt;&lt; endl; if(&amp;str1 == &amp;str2) // This is like the is operator in Python cout &lt;&lt; "true" &lt;&lt; endl; else cout &lt;&lt; "false" &lt;&lt; endl; Will print `true` then `false`. The first comparison (which is like `==` in Python, and probably does what you expect) calls `operator==()` and will evaluate whether the two strings have the same value. The second comparison (which is like `is` in Python) doesn't call any method, it simply decides whether the two things have the same memory address. The Python `is` keyword or comparing memory addresses in C or C++ have the advantage of being very, very fast, (because comparing a pointer is a single operation) but they have the disadvantage of returning non-equality for some objects which are, for all intents and purposes, equal. You wouldn't ever expect 2342125 2342125 to be not-equal, for instance. `operator==()` in C++ and `__eq__()` (which is what `==` calls) in Python have the advantage of working the way you expect them to,\* but it typically takes more time to execute. \* Unless `operator==()` or `__eq__()` are written terribly horribly rottenly badly. But hey, bugs happen.
Lambdas that support statements don't really make sense. The name alludes to [lambda calculus](https://en.wikipedia.org/wiki/Lambda_calculus). In the mathematical sense, a function cannot have side effects.
&gt; The values the object represents don't have to be numeric. The return values don't have to be boolean either so you can use them to implement symbolic conversions &gt;&gt;&gt; A() &lt; A() '&lt;__main__.A object at 0x10bed2310&gt; &lt; &lt;__main__.A object at 0x10bed2390&gt;' 
I think I agitated my math professor two days ago when I asked him to confirm that he intended to use the word "all" instead of "any." He didn't seem to understand what I meant when I said that there is a distinction between the two.
~~In formal language theory, it is permissible to repeat an empty string (a.k.a. epsilon) (when specified). Think of it like this `/n(o*)/` matches all strings with an 'n' and any number of minuscule Os (with an empty string on either side).~~ EDIT: I didn't read the grandparent comment thoroughly before commenting.
Or that 
Did you reply to the right comment?
Yeah, regular expressions are a significant aspect of formal language theory. Perhaps I was unclear about something?
`subprocess.call` is a hell of a drug.
I'm a firm believer that non-Boolean values should not be able to be implicitly cast to Boolean values. In my opinion, a Boolean question about a value must be asked in order to obtain a Boolean value. True and false don't even always have the same integer equivalents (e.g. Bash vs. Python). Why should `1` be true? Why should `-1` be true? Why should `'foo'` be true? What's true about them? To me, it just doesn't make sense. I'd much rather explicitly ask `x != 0`or `str != ''`. To me, it seems a bit more clear and doesn't really cost too much in terms of amount of code. Additionally, forcing explicit comparisons opens the possibility to simpler introduction of n-ary logic.
&gt; '{{12345}}' For whatever reason I was reading that as `'{12345}'`. My bad.
Try writing an empty tuple using that mantra ;)
Or use `{}` to make an empty set. I just don't use literals to make containers. I don't care if it means a few extra characters.
But that's no fun.
Something I ran into the other day, if one of your dependencies is dependent on an outdated version of something then you have to be careful not to upgrade it when you upgrade your packages. I don't even know what happens when the dependency no longer depends on the outdated version. This is essentially because pip forces you to update your own packages and gives you no indication of the dependency graph. 
&gt;It's similar to using i, j, k for iteration. Yes it is kind of a legacy thing, but it is so thoroughly ingrained that it probably won't go away. Using i for iteration is entirely different. It does no lead to very difficult to trace bugs. &gt;if blah: do_something_with(blah) which is great in cases This is generally terrible code. It is implicit. You can not tell what is going on without reading lots of contextual code. None and empty iterables are just as bad. It is analogous to wanting 'a' + 1 to equal b. Sure it might seem useful they sure thought it was in some languages but ultimately easy to read code is more important. If you are in a specific domain were it really is important that [] works as Fase it would be trivial to build your own class to do so making it explicit. 
ah, so x's scope is larger than function scope even though it was declared in a function call?
The [built-in chr function](https://docs.python.org/2.7/library/functions.html#chr) does most of what you need. E.g. print chr(66) # prints 'B' If you need the result to be formatted as '&lt;B&gt;', though, you'd need to do so yourself. In addition, you'll get the escape character code for some values (e.g. 0 - 31) instead of the string representation you expect. For example, chr(13) returns '\r' (carriage return). You could keep a dictionary of those that you'd like to represent differently, such as to return '&lt;ENTER&gt;' instead of '\r'. For example: def asciichar(keynum): char = chr(keynum) altchars = { '\r': 'ENTER', '\t': 'TAB' } return '&lt;{}&gt;'.format(altchars.get(char, char)) This would return: asciichar(65) # Returns '&lt;A&gt;' asciichar(13) # Returns '&lt;ENTER&gt;' For reference, the [built-in ord function](https://docs.python.org/2.7/library/functions.html#ord) does the inverse: ord('A') # Returns 65 Hope that helps.
https://i.imgur.com/gtPYl6A.gif
Wow. Python 3.4 was attractive enough to consider switching to Python3, but Python 3.5 is convincing enough. I feel outdated with my good old 2.7 when I read a such article! Great article!
&gt; I link most of my programming knowledge back to assembly/C. Exactly. In your experience, a function is *declared*. It is an instruction to the compiler on how to treat the code inside it. In Python (or other dynamic languages) a function is *created* on the spot. So using the variables from the current scope is just as logical as using them in any other line of code.
This is not a wart. I think it's totally fine for the language to intern any equal constant objects so that they point to the same object. I am also okay with `"a" is "a"`, which CPython does and similarly for equal frozensets, which CPython doesn't do.
What's wrong with that? You can do `[a, b] = (1, 2)`; so why not `[a] = 1,`; and why not `[] = ()`?
I didn't know about the `dis` module. It would make a good learning tool. Thank you. 
You can use braces with the following import: from __future__ import braces
Ansible is free and open source. I haven't used salt much but when I started using ansible salt was primarily an agent based solution (pull) and ansible was primarily agent-less (push) I think this has since changed with things like ansible-pull and salt-ssh. I really liked how ansible had so many modules, and it's super simple to add more if you know a bit of python, that its a fail fast system, and that the community was kind and growing. 
This can be convenient in some cases at least :D having a list with elements, that contain each a list of booleans and you want to sort them by "weight", i.e. the one with the most True values first: &gt;&gt;&gt; mylist = [ ... ('one', [True, True, False]), ... ('two', [False, False, False]), ... ('three', [True, True, True]), ... ] &gt;&gt;&gt; sorted(mylist, key=lambda e: -sum(e[1])) [('three', [True, True, True]), ('one', [True, True, False]), ('two', [False, False, False])] I used something like this in a MySQL query once. In PostgreSQL you'd have to cast the boolean to integers thought. I thought this might be useful, occasionally, in Python as well.
That's not unexpected. The last element `[0, '', False]` is a non-empty list, thus evaluates to True. If you had it like this, on the other hand: &gt;&gt;&gt; any([0, '', False, None, any([0, '', False])]) False 
 a, b = 1, 2
first this code is required for localization then when i take this code and put it in visual studio this code doesn't work and doesn't give a result and it doesn't output the required p as to be output i only finished learning python from nearly two weeks and i make a project so i need someone to help me at this time in understanding the errors exist in the code.
You can bind variables using function arguments: (lambda a=1, b=2: do_stuff_with(a, b))() Or there's a dummy list comprehension: [do_stuff_with(a, b) for a, b in [(1, 2)]]
YMMV, I just don't see how it's different from passing any Python object. Callbacks are iffy in languages like C where you have to mess with function pointers, but in Python they work just like any object with a __call__() method.
yeah in this case someone had deleted an unused item from a two-tuple in a default keyword argument. I surmise they were thinking in `list` mode.
Try reading [Python Performance Tips]https://wiki.python.org/moin/PythonSpeed/PerformanceTips before going down that path.
jep. itâ€™s just syntax, there are no lists, tuples, etc. involved on the left hand side. thatâ€™s also why `[] = foo` works while `() = foo` doesnâ€™t: they simply forgot to implement it. [[bug]](https://bugs.python.org/issue23275) [[SO]](http://stackoverflow.com/questions/29870019/why-is-it-valid-to-assign-to-an-empty-list-but-not-to-an-empty-tuple)
you donâ€™t, and instead finally fucking port that rotten old shit, itâ€™s been 6Â½ years since 3.0
jup. every python dependency of everything i have installed is registered as `python-&lt;pkgname&gt;` in my OS package manager. no virtualenvs on my machine. everything works flawlessly and always had.
yeah, itâ€™s basically the only wart that reliably bites every python beginner. except those who start with PyCharm. which warns you not to do that. PS: if you have a function that iterates its argument without modifying it, and youâ€™d like to pass an empty list as default, simply use an empty tuple instead: def foo(iterable = ()): for item in iterable: do_stuff(item)
Salt was a bit complicated to set up, mostly because the documentation is just crammed together from bits and pieces and is very hard to follow. My state files never really worked. I don't recall why I decided on salt first. 
yep, `()` is a special token. `( )` doesnâ€™t work as empty tuple (afaik) thatâ€™s a tradeoff they made because parens are both for tuples and grouping: either define the parens as tuple-creators (then `(1 + 2) * 3 == (3, 3, 3, 3)`) or use the comma, and youâ€™ll have ugly 1-element tuples.
I understand why it's behaving that way, but still, it was unexpected for me. I guess our expectations from the function named `any` are different.
That doesn't explain the last line.
git+ssh is used by Heroku for this purpose.
Make it personal and add the name of the one who posted the HB post in the reply. I haven't used the FB API but I suppose it's one of the fields of the json set.
Hmm, it's not always as easy as "just port it" though. I maintain ~250k lines of Python code that started on Python 1.2, now running on Python 2.7. That's before True and False were a part of the language, to give you an idea how old it is. That's when the `string` module was great and awesome. It's got crap code coverage, it's nearly twenty years old and it's 99% surrounding network communication, so bytes vs unicode is a huge problem for it, so much so that I don't know if it will *ever* be runnable under Python 3 with any confidence. That's not necessarily a bad thing, it's just a thing. Legacy and all. My personal hope is that small services with good coverage will be migrated, new services will be Python 3, and old services that are too big to migrate will stay on Python 2 unless it becomes impossible for us to use for whatever reason. The cost to migrate them all is just too much. The lack of code coverage alone has hidden some really hairy stuff. When we migrated from 2.4 to 2.7, everything seemed just fine (and surprisingly it was, for the most part), until our POP3 server started randomly crashing on certain emails months later. I took a look, and what do you know, it was playing with the internals of a `socket.socket` instance (specifically, `socket._fileobject._rbuf` from the filelike produced by `socket.socket.makefile`) if the email was large enough. It had changed from a string to a `StringIO` object. The worst part? There was a comment there saying "XXX this will break if `socket` ever changes this", but no test.
What do you expect that to do?
I wish they fixed the other "truthiness" values too. Zero shouldn't resolve to false either.
Why would this confuse you? This is pretty standard behavior. 
"Truthiness". Gets me sometimes. 
Why not? It's deliberate that `0`, `[]`, `{}` etc are falsey.
Am I missing something? This is exactly what I would expect to happen.
Tuples are for when the items are different things: (eggs, user, spammy) = (2, "nsfyn55", True) By definition it would be strange to iterate over a tuple. If you're going to iterate over it, it should be a list.
x is overwritten AND deleted. x = 5 try: raise Exception('Something') except Exception as x: print(x) prints 'Something'. `except` acts like a `with` statement.
sounds like every other shitty legacy codebase. and your strategy of writing new services in python 3 is exactly what "Python 2 or Python 3" *doesnâ€™t* mean. "Python 2 or Python 3" is the problem that people still *start* things in python 2. my frustration is that projects younger than 6 years exist that are written in python 2. if there initially were dependencies not working in python 2, it still would have been pretty easy to write a python 2 library in a forwards-compatible way using `__future__` imports and a bit of care. things written like this should be ported by now. old in-house legacy shit is the companyâ€™s technical debt, not a reason to write python 2 only libraries.
not really: /tmp â¯â¯â¯ cat &gt; test.py x = 1 with open('/tmp/test.txt', 'w') as x: pass print(x) /tmp â¯â¯â¯ python test.py &lt;_io.TextIOWrapper name='/tmp/test.txt' mode='w' encoding='UTF-8'&gt; /tmp â¯â¯â¯ whereas except yields a NameError: /tmp â¯â¯â¯ cat &gt; test.py x = 1 try: raise Exception() except Exception as x: pass print(x) /tmp â¯â¯â¯ python test.py Traceback (most recent call last): File "test.py", line 6, in &lt;module&gt; print(x) NameError: name 'x' is not defined /tmp â¯â¯â¯ 
Why would you want to sync any changes that were not commited?
Well, reading the [docs on `any`](https://docs.python.org/2/library/functions.html#any): &gt; Return True if any element of the iterable is true. [â€¦] and additionally knowing that non-empty lists are true: &gt;&gt;&gt; bool([0, '', False]) True And that non-empty list is **one** element of the list passed to `any`. Why would you expect that to be False nonetheless? 
The one that always gets me is that join() is a string operation instead of list operation. ", ".join(mylist) is absolutely the definition of counter-intuitive. It *should* be: mylist.join(", ") 
Added in Python 3.4 :(
or (lambda a=1, b=2: print(a+b))()
Then why is `x` removed from the scope?
Fine, x isn't deleted in a `with` statement but it is in an `except` statement. I'm not sure what you're arguing here. `x` is reassigned (overwritten) in the `except` and the `with` statement. This is completely expected behavior. edit: What do you expect to do with an exception after the `except` block? Of course it is deleted.
you didn't try your advice on visual studio also after trying your opinion visual studio told me that there is still an error
Yup. It's far from, say, mobile apps.
You can always use `re.match('^abc$', 'abcd')` with the same effect.
Is this wtf though? This just seems like a natural consequence of a language that supports closures...
re.match('abc$') is actually sufficient it's just easy to forget when sleep deprived, and especially when compiling the RE as a global for performance. Remembering to always use fullmatch would be easier.
Don't worry, code sometimes seems like magic to devs, too.
That was very helpful. Nice explanation. Thanks!
Yeah, but it's pretty illogical that `except` would ever delete anything from the scope then, isn't it?
Well I work in Data Science so I just deal with scripts and queries and before this I was in Academia where it was just scripts :/ It's so daunting to think of contributing to something but then you go to the github page and the codebase is just absolutely huge... I've fallen in love with MuPDF though as it is _so_ much better than Evince so maybe I will try and write a decent frontend for it (it's rather umm spartan atm with vi keyboard shortcuts etc.) but again the source code is just so big it's like where do you even start with something like that.
Relevant: try: raise Exception('first') except: try: raise Exception('second') except: pass raise # re-raises the suppressed second exception On the other hand this was fixed in Python 3.
I want to test whether the tiny changes works well or not, but I can't test it on my local system, so I should sync my code to remote system.
No, a set is not a tuple or a list. I was describing the difference between tuples and lists. If you don't want to take my word for the distinction between tuples and lists, read [this](http://stackoverflow.com/a/626871) StackOverflow answer. It links to two blog posts and the Python documentation to make the same point as I did. Also, an iterable may be infinite, but a tuple or a list certainly not.
One reason it's easier to make this mistake in JavaScript because scope isn't as obvious as it is with Python. In Python scope is (mostly) defined by indentation whereas in JavaScript scope is defined by arcane rules which were made up on-the-fly as the language was slapped together haphazardly in it's early years.
Nice I have not thought about that before. 
FYI there is a shorthand for creating sets: set(['happy', 'happiee', 'hbd', 'HBD', 'bday', 'birthday', 'returns']) vs {'happy', 'happiee', 'hbd', 'HBD', 'bday', 'birthday', 'returns'} Additionally, depending on the version of requests, the usage of importing/using json isn't necessary. There should be a json method or dict attached to the response. (http://docs.python-requests.org/en/latest/api/#requests.Response.json) # Newer requests json_response = requests.get(X).json() # Older requests json_response = requests.get(X).json It's also a little odd you're using urllib and requests, any particular reason? Also, this line doesn't do what you're trying to test(?): if set(['happy', 'happiee', 'hbd', 'HBD', 'bday', 'birthday', 'returns']).intersection(set(checkWish)) &gt; 0: I'm actually not sure why that wouldn't just fail: In [1]: {'a'}.intersection({'a','b'}) Out[1]: {'a'} In [2]: {'a'}.intersection({'a','b'}) &gt; 0 --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-2-0f7c6ed20399&gt; in &lt;module&gt;() ----&gt; 1 {'a'}.intersection({'a','b'}) &gt; 0 TypeError: can only compare to a set Would be cleaner to just test for truthy: if set(['happy', 'happiee', 'hbd', 'HBD', 'bday', 'birthday', 'returns']).intersection(set(checkWish)): (I know you didn't ask for a code-review, and most of this code isn't yours, but figured some of this info may be helpful in the future.)
The fact that there is no implicit declaration is exactly why we should be able to treat values we intend to unpack from **kwargs as isolated from non keyword arg params explicitly noted in the function header
See my comment before my previous comment in this chain.
I read it, and it doesn't apply. Nothing you have said addresses why non kwarg args, which are isolated from values that must be explicitly accessed via kwargs.get('param'), must not collide with what are essentially keys of a dictionary.
What is the proper workaround if the real behavior is not what is wanted?
Send a message to the devs! And make sure to read the CONTRIBUTING file, if they have one. Project maintainers are usually happy just to have someone who wants to help. A good way to start is to compile the project from source (preferably the development branch).
Now I need a script to wish me happy birthday on fb so I have posts to reply to. 
You can't construct a list of infinite length, because it won't fit in memory. If you can, now would be a good time to demonstrate it with a few lines of code. This is my best shot: def infinite_seq(): while True: yield 1 x = list(infinite_seq()) # x will never actually be assigned
A raw string is one prefixed with "r". A raw string doesn't parse any escapes, making it very useful for things like regular expressions and Windows paths (normally, a regex matching a single backslash in Python would be re.compile('\\\\'), but with raw strings it should be re.compile(r'\\').) There's no reason not to accept a slash at the end of the string, but unfortunately, the grammar doesn't support it.
Oh, it's inconsistent and shitty, I just don't think it's practically likely to lead to errors because there are better ways to detect whether your datetime object returned an actual time.
You need to be more specific. What operating system are you using? Where are you going to see these downloads? If you're talking about [Christoph Gohlke's site](http://www.lfd.uci.edu/~gohlke/pythonlibs/#pygame), then you want one of the two with `cp34` in the name. `pygameâ€‘1.9.2a0â€‘cp34â€‘noneâ€‘win32.whl` is for 32 bit Python, `pygameâ€‘1.9.2a0â€‘cp34â€‘noneâ€‘win_amd64.whl` is for 64 bit Python. Which bitness of Python did you install? (Note: this is not the same as the bitness of the operating system. You can run 32 bit Python on a 64 bit operating system, and in that case you need the 32 bit Pygame binary wheel.) 
This feels too much like cheating
I have done a few personal projects that use the python C api, and I can assure you that your code is correct. You should try to compile your extension with another version of python. Maybe try ~~another version of~~ visual studio (from my experience, you can compile extensions with VS2010 and above) edit. Just saw that you use GCC. Never been able to compile on windows using it. That might be your problem.
You are wrong. Read the docs, and the rest of this thread. 
Nice! Add some more random messages in those lists and this is really good.
If scraping is against their TOS, why are you asking the question ? 
You wouldn't deploy the conda environment. You'd have a build server that builds all of the requirements required to run the app (if they aren't already available on anaconda.org), your app, then you're deployment environment would be a blank slate with python+conda. You'd then just conda install the app (in a conda environment if required) and it would pull your requirements you built as well. Conda is very similar to platter, it just typically is distributed with a python interpreter. However, you can install conda from any python interpreter that has pip, with pip install conda. Note: You can conda install from anaconda.org via your own public/private channel, or, you can conda install from a local store of files, similar to wheels. The difference with conda vs wheels, is that conda is a bit more generic on what the package contains.
Us Tkinter and create a Button widget. Get this PDF to see how it works. http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/index.html
Not saying docker is without pain points, just that the discussed approach is only handling part of the problem. dh-virtualenv is like platter, but you still potentially need to deal with requirements outside python land. For example, a python app might assume that git is available, or maybe it needs a specific database for running tests, or a port is open. This can be handled manually, through specification (docker, puppet, etc.), or through app development guidelines, but debian packages with virtual environments doesn't address the same level of problem. If docker is used in the same way as dh-virtualenv, dh-virtualenv is certainly a decent option, but there is much more docker can do. Docker simply makes the developer more responsible for specifying the full scope of the dependencies the app has, which makes the deployment more flexible. You can avoid it from the application side, but it still has to be handled in some way. 
Docker compose would help with setting up the various services, but doesn't handle the actual deployment part.
I know how to make the button, i am just wondering how to make an IF statement that does something when the button is clicked... 
Thank you so much for your reply! I had seen the onPyUnitServerCreated code and thought to use it, but my implementation was all wrong. It works no problem now thanks to you!
Both `==` and `is` are comparison operators, and when you have multiple comparison operators, python evaluates them all at once. Consider how python is able to evaluate this "correctly" (the way we'd understand the expression in mathematics): &gt;&gt;&gt; 1 &gt; 0 &lt; 1 True Seeing how the integer value of `True` is `1`, that expression would be `False` if python evaluated one of the comparisons before the other. &gt;&gt;&gt; int(True) 1 &gt;&gt;&gt; (1 &gt; 0) &lt; 1 False &gt;&gt;&gt; 1 &gt; (0 &lt; 1) False So for python, `True is False == False` is an atomic comparison of all three things at once, not a comparison between the result of the first comparison and the other thing. Because of this, expressions with multiple comparison operators short-circuit.
Or just don't have a Facebook account.
So Python expands `True is False == False` to `True is False and False == False`? That's frustrating. I'd prefer to restrict expression short-circuiting to value comparisons. Then again, I don't know why I'd ever use an identity comparison and a value comparison in the same comparison expression.
I guess that for the sake of simplicity, Python functions can serve as functions or procedures.
There isn't really an "if" statement for that (well technically buried deep in the UI code, sure). But you won't interface with a Button that way. In most UI libraries, when you create the button, you'll associate a callback with it. A callback is generally a function that is called when your UI widget does something. In the case of a button, that is when it's clicked. Depending on which UI library you're using, the callback may have additional arguments supplied to it.
Yes, it looks counter-intuitive first time you see it. I found it very intuitive once I realized why it's one that way. Basically, if it's a method on a string then it can operate on any iterable (list,tuple, iterators). If it were a method on a list it'd have to be implemented separately by every type. Also, it's string specific, and it sounds wrong to put a string-specific method on a generic list. So, really it can only be either a method of a string or a standalone function.
A Facebook wall post is probably one of the most impersonal ways to wish someone a happy birthday.
Nice. Wish I had that a year ago. I write a loop to safe matplotlib plots as png and then wrote a batch script to automate Image Magick to compile animated gifs
I disagree. I think it does cover. For example, consider the following code (assuming that it is allowed): def foo(bar, **baz): pass I can call this function in many ways: 1. `foo('derp')` 2. `foo('derp', cat=Cats.Nyan)` 3. `foo('derp', bar='saloon')` 4. `foo(bar='chocolate')` Example 1 and Example 2 work fine. Now, let's look at Example 3. For the first argument, the value `'derp'` is bound to `bar`. But then what happens to the second argument? `bar` already points to an object. Do we overwrite what was just bound to `bar` or do we stuff it in `baz`? It's ambiguous. Overwriting would cause unexpected results. Putting it in `baz` has a problem that is apparent in Example 4. In Example 4, are we trying to bind `'chocolate'` to `bar` or are we trying to put it in `baz`? I suppose the interpreter could see that `bar` isn't yet pointing to an object and could deduce that the value should go to `bar`. But what if we want `'chocolate'` to be in `baz`? How do we do that? Add an arbitrary positional argument? What value would you plan to use for that and why? Or maybe we could give `bar` a default value. But wait a second. Now we still have the question asked in the first question of this paragraph. And this time, we can't use the same deduction to solve it. Sure, you could say, "Hey! An explicit parameter exists with that name. Don't put the value in `baz`." Again, what if you want the value to be in `baz`? Now, all of this *could* be solved by positional-only arguments. After all, position arguments provided as keyword arguments is what is causing this madness. But positional-only arguments would be infeasible. For one, it would require new syntax or backward-incompatible changes to Pythonâ€”neither of which are elegant. Positional arguments are allowed to be provided in a keyword manner for self-documentation purposes. Removing this would be catastrophic for the language. Which you prefer? foo('asdf', 1, True, 'derp', None, 0) or foo( file_name='asdf', data_connection_mode=1, verbose=True, hostname='derp', callback=None, command_connection_mode=0 ) I'd certainly prefer the latter. The former is more difficult to read and would make me have to look up the documentation or source code to determine which arguments to provide in which order.
Well, presumably it can check which ones it already replied to.
And to top it off I can't figure out how to properly edit txt on reddit =/
Should your code look like this? Too make it look right in Reddit, you have to indent an extra two spaces to make it look like code def is_prime(x): if x &lt; 2: return False elif x == 2: return True else: for i in range(2,x): if x % i == 0: return False return True You have to add the last return to make it return true if none of the other returns get hit.
When return is called, it breaks out of the function. That means the rest of the code is ignored. If you wrote def is_prime(x): if x &lt; 2: return False elif x == 2: return True else: for i in range(2,x): if x % i == 0: return False else: return True You would return true before you finished your for loop.
TIL color is a dimension.
In this specific example, color is energy, but really the script is just a way to represent a function of 5 independent variables, so in that sense, color-space is a dimension.
Haha! I did something similar on my last birthday. Was tired of scrolling through, and clicking on comment boxes. Got the script to print the posts, and I was able to reply from the shell (wanted to tailor the response to the person and message).
It's probably in poor taste to mock PHP for a Python problem which PHP never had.
You confuse the definition of a `tuple` with what you think you should do with a `tuple`. Just like you confuse the definition of a `list` with what is practically realizable on an physical computer. To demonstrate the latter point I need only.ask what is the maximum length of a list is. To which you say ... Depends. The definition of a tuple is a finite ordered list.
One thing I didn't like about Numba is that if I used it in an app and distributed it, I'd have to ask every user to install llvm (I think this was the package) which is not available through pip. Anyone know if there is a way around that? 
&gt;Neither does True being like 1, I have never ran into an issue because of such a thing. I have and I have seen at least one other person run into this. I mean not nearly as many bugs are causes by this than say the weird way default arguments are instantiated but it happens. &gt;Such a practice is EXTREMELY common in Python. I mean seriously I see absolutely nothing wrong with: Oh I realize it is extremely common and certainly 0,None,empty arrays were specifically designed to work this way. I just disagree with this design choice in python. Python is my favourite language but not everything about it works the way I think it should. The 1 + True problem is somewhat deeper too. You can not do 1 + []. I don't think if 1: should work but it is less trouble some to me than 1 + True working or isinstance(True,int) being True. 
At least python 3.5 will finally bring back bytes formatting ...
In a language with formal traits instead of ad-hoc duck types it wouldn't matter ...
Metaclasses and descriptors are the two most *fun* things in Python. Mixing them is quite prone to errors. Fun fact: the `metaclass=` parameter is *not* inherited by default. Rather, the metaclass of a subclass defaults to the *type* of the superclass, which may be different if a non-type callable is passed. This applies to Python2 as well as Python3, despite the fact that `__metaclass__` is an attribute and *is* inherited.
So would you prefer using something like `if len(array) &gt; 0`. I guess I can understand it but I personally quite like the Python way.
`&gt;&gt;&gt; [99, 12][True]` `12` `&gt;&gt;&gt; [99, 12][False]` `99` `&gt;&gt;&gt; {0:99, 1:12}[True]` `12` `&gt;&gt;&gt; {0:99, 1:12}[False]` `99` Yes, you can use this to fake `a = c if b else d` type statements. Though I'm not sure why you'd want to. More towards 'buggy' and less 'implementation detail-y': `&gt;&gt;&gt; False in {0}` `True` `&gt;&gt;&gt; True in {1}` `True` `&gt;&gt;&gt; sum([True, False])` `1` (this is actually seriously usable -- the sum() of a sequence of booleans equals the number of True values) 
 x = {0: None} for i in x: del x[i] x[i+1] = None print i
Deleting your comments? Tsk. Are you ashamed of the silly things you wrote? The fact that the length of a list can be any natural number still doesn't mean that the length can be infinite. 'Infinite' doesn't mean 'some potentially very large number'. Anyway, if a list is potentially infinite, disregarding practicality, then so is a tuple, so that can't be the essential difference between tuple and lists. Mutability and hashability are important differences, as are the way they should be used: &gt; "Though tuples may seem similar to lists, they are often used in different situations and for different purposes. Tuples are immutable, and usually contain an heterogeneous sequence of elements that are accessed via unpacking (see later in this section) or indexing (or even by attribute in the case of namedtuples). Lists are mutable, and their elements are usually homogeneous and are accessed by iterating over the list." Source: [docs.python.org](https://docs.python.org/2/tutorial/datastructures.html#tuples-and-sequences)
A lot of real-world switches need to do *something* like this simplified form. x = "a"; y = "b"; z = "c"; switch (var) { case 1: x = "1"; break; case 2: y = "2"; break; case 3: z = "3"; break; }
So it must also be equal to "True == False is False" and "True == False == False" and "True is False is False"? Does the documentation tell about it?
&gt; ... because its adapted from someone else's code
Neat.
It is pretty simple. This is from a guide I half-wrote a few months ago. &gt; It is possible build using Visual Studio by adding the python dependencies to the project configuration. Because python binaries do not come with a debug version, be sure to use a release build or else visual studio will search for the python debug library (aka pythonXY_d.lib) and will not find it. In your project property pages: â€¢ General â†’ Target Extension: .pyd â€¢ General â†’ Configuration Type: Dynamic Library (.dll) â€¢ C/C++ â†’ General â†’ Additional Include Directories â†’ &lt;Python Dir&gt;/Include â€¢ Linker â†’ General â†’ Additional Library Directories â†’ &lt;Python Dir&gt;/libs â€¢ Linker â†’ Input â†’ Additional Dependencies â†’ pythonXY.lib (ex: Python34.lib) 
I seriously think that Python needs a JodaTime/JSR310 type of replacement for the datetime module.
I see it as the same reason you have to use `enumerate(some_iterable)` in a `for` loop to get access to the index as you're iterating - it's just not needed often enough to justify special casing, and the builtins cover the times when you **do** need it. For the cases where it's needed, `reversed(string)` works well enough. Yes, it returns a generator, but, again, depending on why you're reversing the string, you probably want/can use that anyway - and if not, you can `''.join(reversed(string))` easily enough. &gt; Edit: Actually, upon further investigation, all mutable sequences (like list) have an inplace sequence.reverse() method, but then why don't the immutable sequences (such as str) have a sequence.reversed() method? You answered your own question - a string object is immutable, so you *can't* have an in-place reverse. It would need to return a new object - which would mean `str.reversed()` would be surprisingly different in comparison to other iterable.reverse() methods.
Ellipsis &gt; NotImplemented &gt; True
That's all good and stuff, but if I want to distribute something, I can't reasonably ask the users who aren't using Conda to switch just for my app. 
Whenever I need a lot of datetime things, I just use [Arrow](http://crsmithdev.com/arrow/). It's quite nice.
That's for letting me know about phantomjs.
Yes that is what I prefer. It requires a trivial level of extra typing. But it makes code easier to understand and read which is more important. 
But that example throws an exception. Which is what casting a function to a bool should do... right now it silently casts it to true every time...
Some of those behave differently in Python 3: &gt;&gt;&gt; 5 &gt; 'a' Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; TypeError: unorderable types: int() &gt; str() The old rule was that if the order couldn't be determined (both objects get a shot at giving one, but they can say "I don't know" by returning `NotImplemented`), then the order would be "arbitrary but consistent" based on their types (in practice, CPython did alphabetical ordering by type name). The new rule is that in that situation, the error shouldn't pass silently by default. 
It was the last library that I was waiting for.
I guess I can see where you are coming from but "the Python way" is so common now that I don't even think twice about it and instantly know what the code means. If something says `if object_list:` or `if cows:` I instantly know it is looking at whether or not the list is empty. Similar to i, j, k.
Agreed :)
It already has a check for that. It replies to each birthday post only once.
Those XML files you were looking at contained the code for the project. Moya apps can be extended with Python but you generally implement projects entirely in Moya code, which is a high level language.
One page JavaScript applications are generally backed up by 'old school' server tech. Moya has a nice JSONRPC server built-in, which is great for interfacing with JS apps.
Nah, the Viper is nothing compared to the Py... Dammit, [wrong subreddit](https://reddit.com/r/elitedangerous) [again](https://www.reddit.com/r/EliteDangerous/comments/3bq0lz/looking_for_a_cheaper_python/csof726)! In seriousness, though, this looks like a really interesting idea. I'll have to take a closer look at it when I get home from work.
&gt; Any while loop can be rewritten as a for loop. Is that true? You would need an infinite generator itertools.count(0) Ah, well. There goes that.
Yep, [VIPER is smaller than Python](http://doc.viperize.it/0.2.0.0006/VIPER_VM.html#how-different-is-viper-from-python) but its bite is more lethal :) Here the hackaday page with projects and examples: https://hackaday.io/VIPER.IoT. Enjoy!
how is it compared to http://micropython.org/ ?
The main difference is the target audience Viper has been developed for: people who want to use microcontrollers for their job without being programmers. There are engineers, designers and artists that are not interested in the intricacies of C, don't want to know why memory must be allocated and deallocated, tremble in fear in front of a volatile variable. They just want their prototype and product to work. And Viper tries to provide all of this. Indeed, VIPER is a suite composed of an cross-platform IDE, a mobile APP &amp; a Virtual Machine that runs on various platforms. VIPER has a different approach with respect to Micropython: for example the compiler does not run on the microcontroller, it is executed on the PC and the bytecode is uploaded to the VM. Regarding the features, VIPER implements a large subset of Python 3.4 syntax, with some modifications to fit on a microcontroller. Here an helpful thread on micropython forum:http://forum.micropython.org/viewtopic.php?f=2&amp;t=602&amp;p=4472&amp;hilit=viper#p4472
Or more simply, &gt; methods modify the instance can't be true since strings are immutable, yet have methods. 
technically, it's the right way to reverse that string, since u0303 is an unicode character. Moving on, nÌƒ should have its own unicode code. In [34]: t = unicodedata.normalize("NFC", "manÌƒana") In [35]: t Out[35]: 'maÃ±ana' In [36]: print(t.encode('raw_unicode_escape')) b'ma\xf1ana' In [37]: t[::-1] Out[37]: 'anaÃ±am' 
Hey delijati, the best way to spot the differences is to try it ;) http://www.viperize.it/download/
Same as adding 'on-click' in HTML or event listener in JS.
Coming from C, that always had made sense to me: slices just specify the parameters of a for-loop, with a little syntactic sugar added. The first item being the initial value, the second item being the terminating value, and the third item being the increment (which can, of course, be negative). In this view, things are consistent whether you are going backward or forward through the sequence.
Complete nonsense. Please don't comment on things you clearly know nothing about. You can't call reverse() on a string as this always works **IN PLACE**, which is impossible for strings as they're immutable. You can call the built-in reversed(str) as this always returns a copy. len() is a built-in that's provided purely for convenience, you can always call str('abc').__len__() is you like.
Blast, my ignorance of the formatting here has made dunder len() look like a normal len() but in bold, sorry about that :)
just enclose the thing in backticks, like that: ``` `__len__` ``` â†’ `__len__`
When you say different I assumed you meant identity not type. So lets put that to bed. Yes that is typically but not necessarily the case(one nickel for every time I've seen coordinates (x,y) *e.g (int, int)* expressed as a perfectly reasonable 2-tuple please). But the whole thing that kicked this off was you saying one wouldn't want to iterate over a tuple. tl;dr I said why not its a list. Now when I say that I don't mean it extends python's implementation of list. I mean it's a list by definition. Saying you can create a tuple of infinite length is nonsensical. Just look at the definition. A tuple is defined as an *n-tuple* where *n* is a natural number. As far as I know infinity is not in the set of natural numbers(i.e. you can't define an *infiinity-tuple* or an *undefined-tuple*). Therefore I'd say there are countably infinite tuples that can be defined but all of them are by definition finite in length. Hence wikipedia's (and my own) definition of a tuple as a "finite ordered list"
Could you write a script that wishes happy birthday to friends? That way, we can automate the social interaction entirely.
I don't expect an aggregation of non-things to be a thing, that's all. Why is &gt;&gt;&gt; any([[]]) False but &gt;&gt;&gt; any([[[]]]) True ? Again, I know how to explain it, just my expectations are different. I would expect `any` to evaluate lists in the list it receives.
Does string[::-1] even produce a correctly reversed string? I heavily doubt it.
 &gt;&gt;&gt; x = []; print bool(x), any(x) False False &gt;&gt;&gt; x = [[]]; print bool(x), any(x) True False &gt;&gt;&gt; x = [[[]]]; print bool(x), any(x) True True There exists a function that will return `False` here and on, even on `[[[[[[[[]]]]]]]]`. I would expect `any` to be *that* function. Currently, it opens up one level above what `bool` does.
&gt; submitted 6 hours ago * by BunslowI don't actually know Python 2 There's your issue. You need to learn more Python to see it gel rather than think of what you might want when such a beginner then ask why it is not so. For reversals of collections like strings, you need to learn about slice notation. As a later exercise you might learn by copying and trying to understand how these phrase reversals work http://rosettacode.org/wiki/Phrase_reversals#Python On TOOWTDI, you first need to be a Python programmer to a certain degree and a bye-line admitting that you don't means that obviousness is not meant to apply to you. 
[::-1] is explicit, and what it does is obvious to anyone with an intermediate grasp of Python. It is somewhat unfortunate that it may not be obvious to someone not already familiar with the slicing syntax, but you can't win em all, and anyway if we had a .reverse maybe you'd be posting about betraying "preferably only one way to do it." :)
That's pretty confusing and the page is what I got when I searched for "python 3.5 what's new". Thanks for the explanation though.
First of all, thanks for posting this here! Minor criticisms: * Currently your code is not a real module, i.e. I can't really access your code from a different module. As soon as I put `import get_pics` in my python script, your code will be executed. Suggestion: Rename your module to redditimagedownloader. Provide a function get_pics_from_subreddit(subreddit="pics") and use the `if __name__ == "__main__":` pattern. * Line 18: Why force the user to wait one second? * Line 20: Why the extra print statement? Why the extra parentheses? * Line 22 to 37: The exception handling is to broad. urllib.urlretrieve throws a few exceptions that you can properly handle, e.g. ContentTooShortError. * Line 28 and 34: Both elif and else bodies do more or less the same thing. The only difference is that you append ".jpg" to the "http://imgur.com/" link. * Line 25, 31, 36: Code duplication: `print ("&gt; " + submission.url)` * Line 17, 24: String literals are defined in two ways `'---------- Initializing download ----------'` and `"http://imgur.com/"`. Stay consistent! Hope I could help! -schleifer 
How would I create a dickbutt in there?
Not really, the whole point of Python is to be readable to everyone. If you want symbols everywhere then you should probably learn Perl. 
What happens if you have characters that consist of multiple codepoints?
If it's a unicode object, all is well. &gt;&gt;&gt; t = "maÃ±ana" 'maÃ±ana' &gt;&gt;&gt; t[::-1] 'anaÃ±am' If it's an encoded bytestring, it doesn't work as usefully (Still correct however!) &gt;&gt;&gt; y= "maÃ±ana".encode("utf-8") b'ma\xc3\xb1ana' &gt;&gt;&gt; y[::-1] b'ana\xb1\xc3am' &gt;&gt;&gt; y[::-1].decode('utf-8') Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; UnicodeDecodeError: 'utf-8' codec can't decode byte 0xb1 in position 3: invalid start byte This is because you can't just reverse bytes and expect useful unicode characters to fall out. (You do get what you asked for, so it is correct however) 
That is in the TODO list, the thing here is that it would be better to have it as a cron job rather than running the script manually each and every day.
&gt; I don't see why `str` should have a `reverse` function at all. Outside of homework, how often are there real-world applications for needing the reverse of a string? I had to do it in an interview recently. Sort of like homework I suppose.
I'm pretty sure python is not supposed to be readable if you don't know python/programming in general.
Hmm, that's a good question. If you don't mind me asking, why does it have to be a in a graph? If you just want the graphic you could use PIL and Tkinter to achieve that
To submit it to a website where you can move points. It's hard to explain but I need a data form where I can reproduce coordinates from black pixels. I already searched for PIL to convert a black-white picture into an array, but I don't know how I would do that and get X and Y values out of that.
&gt; Such a discussion in and of itself indicates to me that the lack of such a method violates TOOWTDI (more importantly the "obvious" part). Well, there's a corollary to the one obvious way to do it: &gt; Although that way may not be obvious at first unless you're Dutch. I don't find that having both extended slicing syntax *and* reverse available to violate having one obvious way to do something as they serve different purposes. Slicing syntax works on objects (typically sequences, but I won't say exclusively) that implement `__getitem__` and can parse the slice object. Strings and lists are good examples, but you can build your own as well. `reverse` on the other hand works on any object that implements `__reversed__`. I'm actually unsure if it'll do something behind the scenes if this method isn't defined -- like how `for` will look for `__iter__` first and fall back to using `__len__` and `__getitem__` together.
&gt; Why is there no str.reverse() method? Because it doesn't really add anything of use. In a way `s.reverse()` is less confusing than `s[::1]`, but in a way it's more confusing, because they would mean the same thing, but for a list `L`, `L.reverse()` and `L[::-1]` mean two very different things. I'm skeptical about any of the name possibilities not adding some confusion. &gt; and by the way, why doesn't reversed() simply yield a generator, rather than a class? [no pun intended]) `reversed` is *way* older than generators. Even if it wasn't, `reversed` would probably be a class, not a generator function, like virtually all the lazy iterables in the stdlib (consider the entirety of itertools or Python 3's `map`). &gt; Am I just over-reacting? Yes, this is *totally not a big deal*. This is a minor complaint about an obscure task. I'd encourage you to gravitate toward higher-level criticism. 
Plus, in a non-trivial context, you have to decide how to deal with Unicode normalization and combining characters. It's a huge amount of corner cases for something no one will ever use. 
Add https://www.youtube.com/watch?v=xAoljeRJ3lU to your to-watch list.
Exactly. Strings are interned when possible in Python
The construction `(_ for _ in ...)` should never be necessary in Python. `''.join(reversed(string))` does the trick just fine. Of course, the slicing approach has the advantage that it also works on tuples. `.reverse` would be wrong because that name implies a mutating operation, and strings are immutable. It would have to be `.reversed`, and then it looks kinda redundant. And really, needing a new string that is the reverse of an existing one is just not that common. If you just want to iterate over a string in reverse order, that's what `reversed` (by itself) is for. Mutable sequences have `.reverse` methods because they can implement that more efficiently than outsourcing to `reversed`. Speed notwithstanding, replacing an immutable object with its reversed equivalent would temporarily require both potentially large objects in memory - `reversed` provides a generator, allowing the user to only incur the memory hit if necessary.
The example I was repling to uses combining diacritical marks. That's why it messed up reverse. My example convert it to its actual unicode code
yay semantics!
Depends on how strict your definition of "correctly reversed string" is. It will definitely not just do the right thing given any arbitrary unicode string from any arbitrary language.
(Error 1 unexpected token 'p' ) this is the expected errors in my code you can try it in visual studio by yourself
Have you looked at [HoloViews](http://ioam.github.io/holoviews/)? It's a library to allow you to work with your data even when it's very high-dimensional without writing any plotting code. Therefore it makes it very easy to generate plots and output them to video, gif or explore them via widgets and with the widgets you're not even limited to 5 dimensions. Currently we support matplotlib as a backend but support for Bokeh is also coming.
As a convert from Matlab, i slice everything, always. 
This. I've literally never reversed a string outside an interview. Maybe we need an `interview` module in the standard library with things like `ReversibleString`, `spell_check`, etc.
This is a general problem with any python package that has non-python dependencies. It's the same thing if you want to use h5py or pytables. You need to install hdf5, which is not pip installable. Conda was designed in part to solve this very problem since it can package anything in a language agnostic way. This is huge in the scientific ecosystem, which has a lot of non-python dependencies. I certainly understand and appreciate that some users do not have the flexibility to switch up their python package manager for a single library. In those cases, I think you need to use your system package manager or something else to get the dependencies. This is just the reality of current deficiencies in pip AFAIK. 
&gt; it may not be obvious to someone not already familiar with the slicing syntax and it's a great reason to get familiar with it. It's amazing how many uses I've found for string slicing after I "got" it.
No, that's why you use "xml" instead of "lxml" 
It feels weird using an `if not` for when it has items. But it is an OK idea.
Print out the [changelog](http://sealedabstract.com/wp-content/uploads/2014/05/python_changes.pdf) for him.
Quit.
Needs more info. Is your job programming in Python? Are you in a position to pick the tools? Does your company have any guidelines that say you have to use Python 2? And if so, are there good reasons (e.g. some mission critical libraries which, for whatever reasons, haven't been ported yet)? Are you supposed to be doing anything that involves Python at all?
The documentation for any version X of Python contains "What's new" for all versions prior to and including X. For example, [here's the 3.4 documentation](https://docs.python.org/3/whatsnew/index.html), here's [the 3.5 documentation](https://docs.python.org/3.5/whatsnew/index.html), and here's [the 3.6 (aka trunk) documentation](https://docs.python.org/3.6/whatsnew/index.html). 
Holy cow! They fixed that? Amazing. I was around for the discussion when that "feature" was first raised as a possible bug, and I'm pretty sure that the decision was made to keep it because it wasn't important enough to break backward compatibility.
Ha ha, very funny, but seriously there's a kind of logic to this. Time objects are subclasses of int, and int(0) is a falsey object, so time(0) (midnight) ought to be falsey too. Either way, you're going to annoy *somebody*.
I'm not sure what you're on about, but I did not say that *all* UTF-8 strings can be normalized to use precomposed forms, just that very often this is the case. 
Well I never said the immutable `reversed` would be in place. In fact I explicitly named it like the also-not-inplace `reversed` builtin to emphasize that since it's not mutable, it does return the reversed string.
Is there an agreed-upon way to turn an encoded bytestring into a unicode object? It seems like that would be helpful, but I'm guessing it would be hard to get it "right" in a general way.
I doubt it's an actual issue with Python 3 and he wants you to justify why you would want to install something other than what the rest of the company is using.
&gt; "Python 2 or Python 3" is the problem that people still start things in python 2. Yes! Have an upvote.
Good point, that first paragraph is the stupid sort of redundancy I usually pride myself on avoiding...
The real WTF is why anyone in the right mind would want all default values to be re-evaluated every time you call the function. That truly would be a WTF. def func(a, b=some_insanely_expensive_calculation()): ... Yeah, I so want that expensive calculation to be calculated over and over again, that's why I used it as a default. Not. "Early binding" is the term for what Python does. "Late binding" is what you are asking for. Both have their legitimate uses, but if a language can only have one, then early binding is the only one which makes sense. Why? Because if you start with late binding, you cannot easily (or at all) get early binding semantics for those who want it. But if you start with early binding, it is trivially easy to get late binding for when you want it.
OK, let me see if I understand the logic correctly. A "return" exits the function, I get that. So with my code as written correctly: else: for i in range(2,x): if x % i == 0: return False return True If x = 9, (which is not a prime number) that means that it will go into the "for" loop, and start evaluating with 2, then go into 3, but with a value of 3, the "if" statement will return False and then exit the "for" loop. if x = 11 (which is a prime number) will go into the "for" loop and evaluate all the numbers up to 10, and because none validate the "if" statement, it will exit the "if" statement, with the next line having a "return True". Did I understand the logic correctly? And again my post doesn't format correctly. It's like a single run on line.
Thanks, I think I got the formatting, except for how to start new lines. Apperently, hitting 'enter' key doesn't produce a new line. Why. Is. That.
IronPython doesn't have a GIL. Neither does Jython. There's an experimental version of PyPy that doesn't have a GIL, but it doesn't work yet. Guess what? They're slower without a GIL than CPython is with it.
&gt;Function calls like foo('asdf', 1, True, 'derp', None, 0) are already possible. Nothing in the language prevents that currently. I never said that they weren't possible. I just said it's harder to read and would prefer to provide the arguments as keywords. &gt;Never did I say I wanted to remove the notion of keyword arguments. I would like to have particular arguments denoted as only positional - lack of an assignment in the header would be sufficient. I didn't mean to imply that you did say that. I was just demonstrating that that (or new syntax) would be necessary in order to allow for positional-only arguments. &gt;Keyword arguments are definitely preferred to positional-only most of the time [â€¦] The example foo(bar='chocolate') call should throw an error. I feel like those are contradictory statements.
None of those are WTFs, they all follow from the fundamental rule: False = 0 True = 1 (except that True and False belong to a subclass of int, not ints themselves.)
It doesn't work if the n-tilde is decomposed (the tilde ends up on the "a"). And before you ask, there are plenty of scripts with common characters that have no fully composed form. 
For starting new lines you must place a blank line Between two lines. Line one Line two
I don't mean to stop your excitement but beginners like yourself post scripts like this here all the time. And usually there is much room for improvement (like the comment of /u/schleifer shows). For this reason it would be better to post to /r/learnpython instead.
It makes Python [faster](http://dabeaz.blogspot.com.au/2011/08/inside-look-at-gil-removal-patch-of.html). It really makes me laugh when people complain that the GIL makes Python slow. Threads basically are the [wrong answer](https://smoothspan.wordpress.com/2007/09/14/guido-is-right-to-leave-the-gil-in-python-not-for-multicore-but-for-utility-computing/) to the question of concurrency. Even in languages which "get threads right" (note the scare quotes), it is generally recognized that thread based concurrency is hard to get right and a nightmare to debug when it isn't. And the serious players in concurrency like Erlang use a process-based model. 
It seems that error: Unexpected token 'p' comes from another part of your project. In functions defined in this program you return only q list, and p is an argument. It is possible that in some call for functions sense() and move() p list is not defined. Try debugging your project with p on watch list.
Duly noted, thank you.
Readability isn't really meant to mean "readable for someone who doesn't know the language". Readability is about you (or someone with sufficient proficiency with the language in question) being able to easily read the code and know what it does. Neither `slice(sequence, start, stop, step)`nor `sequence.slice(start, stop, step)` are more readable in my opinion than the more concise `sequence[start:stop:slice]`. More characters does not necessarily mean more readable. I would actually argue that they're *less* readable than the `[:::]` version, but of course readability is subjective.
I honestly can't remember ever encountering :: in a slice with python.
Did you make it OP? 
It's a crashy and needs a lot of RAM, but insanely useful. Interestingly, he's just calling out to a shell command and not using the selenium web driver wrapper. 
They aren't contradictory. You defined a function that should, in my ideal world, take a single non keyword argument, followed by arbitrary keyword arguments. That kind of function definition wouldn't need to be the norm, but it could be a tool provided to us to prevent the name conflict issue from happening whenever we feel that might be an issue.
Excellent, makes perfect sense to me now. Thank you.
If this guy is a beginner I have no idea what I am 
We've all been there. But keep in mind to constantly ask for feedback and best practices, preferably in /r/learnpython. When something seems hard to do then there's probably an easier way out there that you just don't know yet. Ask for it. When you've written some code that just doesn't feel right ask others to look at it. But again, preferably in /r/learnpython ;)
Do I need it in Python 3?
What parts are turning up NaN? The LocalAccel numbers? Have you tried printing out the RMartix numbers? Have you tried printing out the GlobalAccel numbers? Have you tried running sin and cos on some of the sample Rx and Ry values? Try to figure out where the NaNs/unexpected values start and I'm sure the problem will be obvious.
No problem ðŸ˜Š
Anyone review the code for this?
Nope
Its not constantly returning NaN only about 1% of the time but that is too many. The output accelerations from the calculation are outputting NaN. The global accelerations are fine.
The selenium wrapper still forks an os process, so it may be no better. 
It does the job, so it's useful for me and thought I'd share it. This script follows the KISS principle.
We had a guy import `factorial` from `math` in an interview on Friday for an engineering job. He had to redo the problem. I gave him bonus points because he had some understanding of the standard library.
Do me a favor, please. Explain in English what's going on with `[::-1]`. It's not obvious enough for me to even make sense of it.
Not my area of expertise but you may find this [link](http://docs.python-guide.org/en/latest/) comes in handy for all sorts of things, especially the section **Systems Administration** which compares several tools previously mentioned.
The most common reason for getting NaN would be dividing by zero (or taking log of a negative number or something like that). But I don't see any of those operations in your code. Write in a check for NaN in the output, and print out all the input values when that happens. Then go through the calculation step by step and see where the NaN gets produced.
For a pure REST API, I would suggest an alternative: http://falconframework.org/ It's a lot faster than Flask in benchmarks, and has less dependencies you wouldn't need in an API (Jinja2, for instance).
Would gunicorn be an example of a process based concurrency model?
&gt;Whats overriding it? Javascript. It is probably hooking onsubmit and submitting the login request asynchronously. Sounds like they are encoding the credentials somehow (possibly involving hashing with a nonce) and setting it as a cookie, so it gets sent in the cookie header, instead as part of a POST body. 
`sequence[::-1]` = "Given some sequence `sequence`, return a new sequence composed of elements starting from the end (1) step away from each other."
I appreciate your effort, seriously. But it's as clear as mud. The engineering mind *thinks* that sort of thing makes sense, but only because it *already* understands what its trying to say. Your explanation reads like a man page.
I hate double post to SO on principle.
Does not work. File "get_pics.py", line 25 print'Starting download for subreddit :', SUBREDDIT, '\n' ^ SyntaxError: invalid syntax 
I don't understand how that works, actually. I definitely agree it's not obvious. I would expect that that to create a shallow copy of `the_list` and then immediately throw the copy away. In any case, why would you ever need to clear a list? (I didn't know that `list.clear` even existed, btw) Why not just rebind the name to a new ecpty list?
That was very poorly written.
I can't say when it's critical to empty a list as opposed to just making a new one. Perhaps if you have some high-performance loop running indefinitely, in some "mission critical" application, and you need to optimize, you might determine that creating a new list with every iteration is is "too expensive"? In truth, I don't know that I've ever programmed anything where that would make a difference, but I suppose that people might want the option. In practice, I've always just made a new list.
I don't know why anyone gives a shit if it's 30 lines or 300 lines. The amount of lines is irrelevant. The code only needs to function properly, and as efficiently as possible, with comments/documentation. Get over minimizing how many lines shit is. You'll be a better programmer when you understand this. 
&gt; Python developer who earns $ 1,00,000 per annum what kind of number format is that?
I'm guessing you're using Python 3, try using paraphrases around that so it'll become print('Starting download for subreddit :', SUBREDDIT, '\n')
Hi there. You have posted a beginners question to /r/python, however it is far more suited to /r/learnpython, where users are actively interested in helping with beginner topics. Please resubmit it over there! Make sure to read their sidebar rules before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." Cheers &amp;amp; best of luck!
You may want to consider fixing that. I don't think it's the only problem with the Python version either. gallery-get has problems. Collecting gallery-get==1.5.2 (from -r requirements.txt (line 1)) Downloading gallery_get-1.5.2.tar.gz Complete output from command python setup.py egg_info: Traceback (most recent call last): File "&lt;string&gt;", line 20, in &lt;module&gt; File "/private/var/folders/7w/dtxcnlxj2y73y8gwbx2zpxr80000gn/T/pip-build-smod1ej1/gallery-get/setup.py", line 5, in &lt;module&gt; mods += map(lambda x: "gallery_plugins/%s" % x, filter(lambda x: x.endswith(".py"), os.listdir("gallery_plugins"))) TypeError: unsupported operand type(s) for +=: 'filter' and 'map' 
That's because parentheses are not the tuple operator. Tuples are created by commas. a="one", "two" for w in a: print w Or: a="one", type(a) 
Sure, but since I'm already using Flask (and I think it's amazing) this works well.
I started making an open-source version of AirDrop called pyDelivery: https://github.com/OlympusMonds/pyDelivery I haven't worked on it recently (it was largely a learning exercise), but it is able to discover other clients and send them files. It also has a semi-working Kivy interface, very reminiscent of the Apple one for AirDrop. Feel free to check it out. EDIT: this was NOT reverse engineering AirDrop - just an open source alternative.
I've always found it odd that programmers obsess over the number of lines. In C++, I tend to put each `{` in a single line, and I never write an `if` statement without declaring its scope. That increases my lines of code significantly - but it's much easier for me to come back to the code and read, so it is for others.
This is why we study fundamentals... so we know them backwards and can use them when we need them.
Are there any tests that include a db query? Wouldn't that bottleneck the entire request? Edit: My point is that it doesn't matter if your wgsi server takes microseconds if your db calls take milliseconds. This is an API webserver after all, it's going to be hitting a db. You're probably going to heavily modify your code when you start scaling anyways. Use whichever is easiest to write in.
Yes, that's my point too, I guess I'm just not explaining it well. `object.reverse()` returns none. `reverse` is always an inplace method. `object.reversed()`, and `reversed(object)` never returns none, because none of them are in place methods. I'm specifically suggesting that as a design decision, all mutable sequences have a `mutseq.reverse` inplace method. Certain immutable sequences, where deemed necessary in addition to just the builtin `reversed` (as it is with str, imo), may have a `immutseq.reversed` method (specifically named both differently from `mutseq.reverse` and named the same as builtin `reversed`), which obviously cannot be inplace, and correspondingly `immutseq.reverse` doesn't exist (trying to use it would be an `AttributeError`).
The point is, he's trying to teach you how easy it *can be*. Yes, if you do it well, it will probably have more than two functions and will probably do interesting things and probably have a comment or two. But this is an introductory tutorial, and, for that purpose, the shorter the read, the better.
I really don't understand what's happening here. The interpreter ought to throw an exception on the deletion, but that seems only to be checked for in the loop (which is the only reasonable way to implement it.) However, screwing with the keys of the dict like this seems to do something weird to the iterator for the loop. I assume I have to go and read the interpreter source to work this one out.
Well I think falcon is trying to compare differences between wsgi frameworks, makes sense to cut out as mitch as possible.
Yes. I'm digging in to the source now. How did you find this?
There is no single "actual Unicode code". Many things that we would think of as a single character actually have multiple possible representations as sequences of one, or sometimes multiple, Unicode codepoints. In this case, "Ã±" has two relevant representations: 1. `U+00F1 (LATIN SMALL LETTER N WITH TILDE)` 2. `U+006E (LATIN SMALL LETTER N) U+0303 (COMBINING TILDE)` Either of these is perfectly legal. Nothing about Unicode says one of them is "official" or is the "actual" version, or that the other one isn't. Instead, we speak of *composed* or *decomposed* forms, and when we want consistency we normalize to one or the other. In the above example, (1) is the composed form, and (2) is the decomposed form. There are four Unicode normalization forms; in form NFC or NFKC, you'd get "Ã±" in the composed form (1), while in NFD or NFKD you'd get it in decomposed form (2).
OP did solicit an alternative to IMDb with copacetic licensingâ€¦
You're not the only one. I actually thought it was suppose to be a worm. It's a pretty ugly logo though. I wouldn't mind if they improved it. 
Why don't you work there?
TBH, the only difference you mentioned is the approach of embedding python: compiling python to byte code and run it in micro-controller (Viper) vs run everything in micro-controller (MicroPython). It's interesting what kind of performance difference does it make if it does at all? Compared to MicroPython, your first paragraph does not answer the questions, as you do not need to know any C with it. Although it's great to let newcomers start easily, IMHO you'll need to know a bit more deeper about how computer works and how it executes in real time, as many embedded applications will require this knowledge. Embedded programming is usually totally different from ordinary software and/or desktop/web app. To continue my rant :), I cannot find link to github, bitbucket, etc. Is your project open-source? Comparing to MicroPython (MP), can I run Viper on compatible chips (not boards)? With MP I can use it on compatible chips, I can create my own custom board, for custom application and flash MP into ARM micro-controller. Can I do this with Viper? Also, can I not use your tools (Viper IDE)? Because usually I run everything from terminal, as I don't like when software decides for me and I do not know what's happening. Also, project seems really difficult with all Viper IDE/Cloud stuff, where with MP, I connect it with USB, and that's it, I have MP shell in my terminal. It seems, that syntax wise there is a lot of inspiration from Arduino. :) For me MP is more pythonic. Correct my were I'm wrong, but by first look Viper looks very lean python implementation (no classes (?, there are objects, but I do not see example of a class), no decorators, no **kwargs, too small Python stdlib (of course, MP does not implement full stdlib, though it has micro implementation for it and is much more full), so what's the difference from super basic ViperPython and Arduino? Many examples would be very similar in ViperPython and Arduino. Sorry, but MP seems more 'full' project. It has pythonic libraries, it has many parts of Python, so I can write pythonic OO code. I can use it on many systems, and create my own boards, for my custom embedded projects (posibility for a commercial use). Also I have a possibility to optimise MP code with assembler commands. Finally, it's open source, therefore it has clear internals on how it works and is extensible/optimizable by everyone. Though, I think best part of Viper is approach to compile it on PC and load it to VM. I only skimmed through docs very quickly, but VM builder sounds very nice. To pre-build your VM for current code and HW setup.
Or someone (well, /u/jknupp) did the exact same thing you just did, but better https://github.com/jeffknupp/sandman
Do you know why its benchmarks are so much better than the others? Also, does it generally sit behind a web server or is deployment fairly straightforward?
For making it easily distinguishable from other types of objects maybe.
Sorry, but it's very bad example, with 'screaming' title. Importing sqlalchemy, but not using it's ORM. SQL injections, class names should be in camel notation, etc. Title is completely irrelevant. Basically what this article tried to show is 'How to setup hello world program for this REST API library, BTW it could be done in 30 lines (and with SQL injections)'. 
Because Falcon is indeed micro-framework, the entire source code is very small with very little functionality, if you want tiny wrapper for processing wsgi requests falcon is a way to go. At the end of the day, when you finish the app you look back and see that you have rewritten most of Django/Flask functionality into Falcon you end up realizing that your app is not so speedy anymore. People tend to forgot that there is a reason for flask being slower than falcon: it does a lot of helpful magic in between. 
This is good for bitcoin.
They might be. But Python's GC can be flaky. Better to close them explicitly. 
You're reading way too much into my comments, and I don't believe you know the meaning of "obvious."
If you just want the current variable **the_list** re-bound to an empty list, then **the_list=[]** is the right way to go. But, if you want the actual LIST to be cleared, so that all the existing references to that actual list object now see an empty list, then you need to clear the list object, which is what del the_list[:] will accomplish. &gt;&gt;&gt; the_list = [1,2,3] &gt;&gt;&gt; x = the_list &gt;&gt;&gt; x [1, 2, 3] &gt;&gt;&gt; the_list = [] # handle rebound, but list is unchanged &gt;&gt;&gt; the_list [] &gt;&gt;&gt; x [1, 2, 3] &gt;&gt;&gt; the_list = x &gt;&gt;&gt; x [1, 2, 3] &gt;&gt;&gt; del the_list[:] &gt;&gt;&gt; x [] 
could you suggest some books about HFT?
Right, but why would you ever want to do that? Very rarely should you really have a bunch of names pointing to the same object (that all need to get updated) If you're sharing objects, usually you'll have imported it from elsewhere or it'll be a method/function local, where you shouldn't be giviing it multiple names just for the heck of it. 
Lots. First of which is the fact that you can't override the Python path on a call to Python to make sure local code is run versus installed code without a virtualenv is insane. Then there is the matter of documentation and setuptools options not even doing what's documented. It's a mess.
It's 30 lines of non production code, it's just an example. None of that matters.
Agreed! It's just example code but so much hate.
Underscored is the standard for defs and most other things. Upper camel for classes.
Why do people care so much about how many lines of code this takes (within reason). I mean, 30, 50 75, who cares? This is not a very good metric of how simple something is. Not only that, what is being hidden away that you will eventually need in order to do something more? How painful will it be then? Some frameworks get nasty after the TODO example is complete. Flask is simple, powerful and wonderful to use, but just stop with the lines of code metric already. It's not useful. 
It's just Google being bad at searching in versioned content.
That doesn't change the fact that the version number in the url is inconsistent with the intended version in the content in *both* cases.
it works for me: http://pythonchallenge.org/
When matplotlib is installing, it should display a message showing which backends are enabled and which aren't, which dependencies where found and which aren't, etc. Can you post that?
Is there a way to get that list after the installation process?
Thanks! :) This is why I love Digital Ocean! They have the best tutorials. In the end, I used "pip install --user &lt;package&gt;" like massover said and now I am reading a book on Flask to learn as much as I can. I definitely will need to use this tutorial when I start deploying it live. 
Alright. Then wait a few days. I'll get back to you. Not really time and desire to reinstall matplotlib right now. But I installed the backends before installing matplotlib.
Let's talk about `del`: C:\Users\mariox19&gt;python Python 2.7.7 (default, Jun 1 2014, 14:21:57) [MSC v.1500 64 bit (AMD64)] on win32 Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; a = 5 &gt;&gt;&gt; a 5 &gt;&gt;&gt; del a &gt;&gt;&gt; a Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; NameError: name 'a' is not defined &gt;&gt;&gt; Here, you use `del` to delete a variable from the namespace. It doesn't matter if we're talking a scalar variable or a list: &gt;&gt;&gt; m = [0, 1, 2] &gt;&gt;&gt; m [0, 1, 2] &gt;&gt;&gt; del m &gt;&gt;&gt; m Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; NameError: name 'm' is not defined &gt;&gt;&gt; Now, regarding lists, as you know, the action of the `del` keyword is completely different. It has nothing to do with the list variable, but instead applies to the list's contents. In other words, it's a complete re-purposing of the keyword. It's essentially a homonym. It's not great mental leap, but it doesn't *clarify* things; arguably, it *obscures* things. Does it work like `len`? No, because that works this way: &gt;&gt;&gt; len(m) &gt;&gt;&gt; 3 We don't say `len m` and we don't say `del(m[1:2])`. Why is that? There is no *why*; it's simply arbitrary. That's no big deal. It's easy enough to learn, and not terrible to have to remember. But it's not "obvious." By the way, why does Python have `len(the_list)` and not `the_list.len()`? Again, there is no *why.* Look, Python is a powerful and nicely-designed language that I really enjoy programming in, but it has its odd corners. The term "obvious" means: "easily perceived or understood; clear, self-evident, or apparent." But people are using it as if it meant something more like "easy to recall once you've learned it." The two are not the same thing.
Dude lol.
Try asking on their groups board? https://groups.google.com/forum/#!forum/python-challenge
You can find a reliable and suitable keylogger here: http://www.keylogger4u.com 
Yea that's the impression I got as well. It doesn't feel professional. 
There's no excuse not to sanitize input! It's literally a manner of adding a comma to the cursor.execute(...) call.
Hey thanks!
apple is not using an outdated version, it's using the version which was used when 10.10 was finalized before the beta started. if you install the current LTS version of ubuntu now, you will also get 2.7.6
O_o I don't see the problem here. 
Nice. As someone currently learning and using PyQt4, are there any benefits to migrating to the PySide release of Qt 5 once it is released?
I got completely stuck on level 6 a week or two ago and haven't looked back there since.
I'd give you gold, but I'm still bitter about Victoria...
PySide's licensing is a little bit easier to work with and more open. 
When you say different I assumed you meant identity not type. So lets put that to bed. Yes that is typically but not necessarily the case(one nickel for every time I've seen coordinates (x,y) *e.g (int, int)* expressed as a perfectly reasonable 2-tuple please). But the whole thing that kicked this off was you saying one wouldn't want to iterate over a tuple. tl;dr I said why not its a list. Now when I say that I don't mean it extends python's implementation of `list()`. I mean it's a "list" by definition. Saying you can create a tuple of infinite length is nonsense. Just look at the definition. A tuple is defined as an *n-tuple* where *n* is a natural number. As far as I know infinity is not in the set of natural numbers(i.e. you can't define an *infinity-tuple* or an *undefined-tupl*e). Therefore I'd say there are countably infinite tuples that can be defined but all of them are by definition finite in length. Hence wikipedia's (and my own) definition of a tuple as a "finite ordered list"
I thought it was gone, tried going there several times a couple of months ago and couldn't. So it's been going up and down?
I thought classes were upper camel LikeThis and defs were camel case likeThis?
It's just a convention so readers can easily tell when something is a class vs method vs variable. There's a book that gets recommended a lot called Clean Code. It goes into a lot of depth and examples to convince you to adhere to convention.
Was working for the last week
VTK nvm, not python3 friendly
I find this too hard to believe after waiting for so long. 
There is also pythran which looks pretty cool.
PySide is lgpl which lets you use it in proprietary applications. PyQt is GPL so you need a commercial license to use it in proprietary applications.
Its back up!
Not really, sorry. I'm only aware of it because TradeBot recruits at my university.
I'm nowhere near that good.
Qt5 has many awesome new features, most notably far improved GL rendering, QML scripting, and better web views. PySide is LGPL, whereas PyQt is GPL. 
Matplotlib would be great, I'll just need to figure out how to draw cubes :) I maybe need check out VTK and maybe back port to 2.7 if the application grows larger on visualization... 
Is [Eve](python-eve.org) of any use to you, it showed up in several searches I tried?
great news. python has always been great for prototyping and having this "officially recommended" Qt binding (which is also lgpl) will be awesome. edit changed wording to reflect I meant recommended by Qt, not Python Software Foundation.
Hey there! I'm starting a new blog and this is my debut post. I would love to hear from you!
I use PyQt5 but I haven't touched PySide. How does it measure up?
pyside can be installed from pip (at least on Linux). I never was able to do this with PyQt if I recall correctly.
You don't need to bootstrap pip anymore ensurepip is built in
Wow what a great discovery for me! Thanks!
What's wrong with PyQt? If you're releasing an open source application, just use the GPL version. If you're releasing a proprietary application, just buy the license, it's not very expensive
Autodesk uses Python as a scripting language. Most of their applications have some sort of Python bindings that allow for automation of simple tasks. [Reference](http://help.autodesk.com/view/MAYAUL/2015/ENU/?guid=Python_Python_in_Maya)
Very cool. Thanks for sharing! Also: &gt;The field is too far outside of my area for learning too many platforms. That is the idea behind Qt. You write once, then just have to deal with building. While this doesn't always work out, it requires less work than rewriting all your code!
Can you reexplain your question? I don't understand what you're asking.
PySide for Qt5 just was announced, and the repo that has the progress seems to have hidden it, so no one really knows. :( However, if it is as good as old PySide, it rocks. It uses the same syntax (almost entirely). Also, as mentioned already, it is licensed under the LGPL, which means that you can use it in commercial applications without paying! EDIT: Also, look at [the official comparison](https://wiki.qt.io/Differences_Between_PySide_and_PyQt) And for all those who have a *nix environment (works with Cygwin on Windows for me), I would suggest the great tool [PySider](https://github.com/prusnak/pysider). It converts from PyQt4 to PySide. It works well.
Looks like the the end is nigh for Jet. This is from a matplotlib mailing list: Hello all, Following much discussion, we are changing the default color map and styles in the upcoming 2.0 release! The new default color map will be 'viridis' (aka option D). I recommend everyone watch Nathaniel Smith and Ste?fan van der Walt's talk from SciPy2015 introducing the new color map and providing an introduction to the math of color perception: https://www.youtube.com/watch?v=xAoljeRJ3lU We are soliciting proposals to change any and all other visual defaults (including adding new rcParams as needed). If you have a proposal please create a PR or issue with the changes to `rcsetup.py` and `matplotlibrc.template` implementing the changes by August 9, 2015 (1 month from now). Do not worry about updating any failing tests. At the end, Micheal Droettboom and I will decide on the new defaults. A 'classic' style will be provided so reverting to the current default values will be a single line of python (`mpl.style.use('classic')`). Please distribute this as widely as possible. We only want to do this once and want to get feedback from as many users as possible. Thomas Caswell PS jet is harmful to you and those around you See https://github.com/matplotlib/matplotlib/pull/4622 for an example proposal PR.
From the falcon docs it is faster primarily when you use the Cython extensions and compile it
`list.append()` modifies the list it was called on and doesn't return anything (or it returns `None`, which is the same thing.) That's kind of an established thing â€” that a method either returns a new object and does not mutate the object it was invoked on, or it mutates and doesn't return anything. It's considered too confusing for a method to both mutate and return something, although that does happen in certain cases. Anyway, method chaining is all about what the method returns, because method chaining means that you're invoking a method on the value returned by the previous method call. `list.append()` doesn't return anything so you can't chain anything after it, since you'd be trying to invoke a method on `None` which results in the error that you see above. But plenty of methods do return something and can be chained, e.g. items = string.strip().split() In your example, there's a method for this very purpose that avoids the need to assign anything: gram.symbols.setdefault(current_key, []).append(line) Another alternative that I find more readable is to use a `defaultdict`: from collections import defaultdict ... gram.symbols = defaultdict(list) ... gram.symbols[current_key].append(line) Edit: after reviewing your examples, I wasn't entirely clear. The reason you get the error is because `.append()` returns `None`, and you are assigning that return value back into the dict. The next time around, you try to invoke `.append()` on that `None`, which is the error; it's not due to trying to chain something after `.append()`, but it's essentially the same problem just in different clothes. 
That's inane. Jet is the standard color map in engineering and yes I've watched the video. The fact that it is not "smooth" is OK. What matters is red is hot and blue is cold and that it goes through yellow, green, and orange because that's what people expect. The issue with jet being not smooth is fine. Fix jet; call it jet2, but leave the idea of jet alone.
I watched it 2 days ago. It was interesting and while I'll buy that jet influences our perception of data, people intuitively understand jet. For stress analysis (what I do), the fact that you have a green section or less than ideal transitions is irrelevant. Red and blue matter. Everything else doesn't really matter, but you want things to transition semi-clearly in between that. 3 color diverging color schemes (blue-white-red) are just weird. Jet may be broken, but that doesn't mean you have to get rid of the blue-green-yellow-orange-red idea. It means you should smooth it out. It seems crazy to go from the default color map that everyone uses to getting rid of it because someone doesn't like it. The whole RGB color scheme is flawed, yet almost everyone uses it. We have 4 common color schemes (RGB, Lab, HSV, and some other one). Only one should really be used (I forget which, but I think it's the other one :).
What about the data to back up that even though people think that they like jet better, in reality they're more accurate with a better designed color map? And if this is so important why not also complain about Matlab which also ditched jet recently? I get that it's what people are used to, but that doesn't mean we should keep using it. The â€if it ain't broke don't fix it" argument doesn't really apply when there's data showing it's broke. Also, I attended this talk and the birds of a feather session for Matlab, pretty much everyone is in agreement that jet should not be the default, as well as most of the people I talked to at the conference. It's definitely not just one random guy at a conference, he's certainly a core developer in the scientific python community (as in, he wrote the pep to add the matrix multiplication operator in 3.5), and the community on average prefers the change. You can definitely still use jet too, they aren't removing it, it's just not going to be the default anymore.
Flask and similar WSGI frameworks (and thus REST servers too) use the standard HTTP workflow of the browser asking the server for a resource, and then the server responding. This workflow doesn't really support long term connections, nor the ability for the server to send messages to the browser when it wants (there are workarounds though, such as [Comet](https://en.wikipedia.org/wiki/Comet_%28programming%29) / long-polling). This is where the relatively new technology of [websockets](https://aiohttp.readthedocs.org/en/latest/web.html#websockets) comes in, to provide this functionality. The [aiohttp](https://aiohttp.readthedocs.org/en/latest/web.html#websockets) package has websocket support.
could also look at scikit-image and simpleCV.
&gt; What about the data to back up that even though people think that they like jet better, in reality they're more accurate with a better designed color map? Huh? &gt; And if this is so important why not also complain about Matlab which also ditched jet recently? Because I don't use Matlab. I'm not saying we should stick with jet. I'm saying a jet-inspired colormap is what I want.
I do see you put it in quotes, but not sure what you mean by "officially recommended" option?
Thanks!
&gt; doesn't mean you have to get rid of the blue-green-yellow-orange-red ide You aren't accounting for other deficiencies, for one blue-green-yellow-orange isn't friendly for colorblind viewers at all.
&gt;&gt; What about the data to back up that even though people think that they like jet better, in reality they're more accurate with a better designed color map? &gt;Huh? In the video he talks about where they had doctors diagnose problems in medical images that had been colored using jet versus several other color maps. The doctors reported that they liked jet better because it was familiar, but the data showed that they were significantly faster and more accurate with the newer color maps. What people think they are best with is not what they are necessarily best with. Cognitive biases are hard to overcome. &gt;&gt; And if this is so important why not also complain about Matlab which also ditched jet recently? &gt;Because I don't use Matlab. Matplotlib took jet from Matlab because its what people are used to. If you use jet with matplotlib it's because more people use Matlab. I haven't heard any fuss on the engineering forums I'm on over Matlab picking a different color map. Matlab is still an entrenched industry tool, it's one of the most wildly used tools in engineering disciplines. &gt;I'm not saying we should stick with jet. I'm saying a jet-inspired colormap is what I want. They have released a tool to help you make your own color map, and this next release will have a lot more built in themes too. Make one that has better smoothing yourself, or try out the new ones that are coming out. FYI, the seaborn themes are coming with it too, and if have one that you'd like to have included then now is the time to suggest it on the mailing lists or via pull request on github. They're doing a feature freeze in 3 to 4 weeks.
Oh, OK. Based on how you started that sentence, I misunderstood you to mean (something like) PyQT/PySide was the Python Software Foundation's officially recommended widget toolkit. Another good LGPL option is wxPython. 
oh, I get it. I was thinking from a very Qt Dev point of view. Edited to clear it up.
So because someone else is colorblind, I can't use a colormap I like better? That problem exists for many colormaps, but it was a non-issue before.
What's wrong with smtp?
As a document database, I'm sure it's also a suitable option. The benefit of a graph database are edges, which could be considered as 'foreign keys' saved in both primary records, all maintained for you by the database. OrientDB in particular is a graph database built on top of a document database, so you could use it just like CouchDB/MongoDB, or take it further and use all its graph features. This explains it pretty well: http://orientdb.com/orientdb-vs-mongodb/
Use SMTP Luke!!!
Playing video games. For example, tapping in Tap Titans.
Last night I wrote a program to help with my Tax return. Basically takes the raw data from bank statements, applies a mapping for their descriptions and makes a nice single summary. Code is at https://gist.github.com/acutesoftware/3f70f952d51c161f335d but you'll need to do your own mapping file as many / most have account numbers merged in with 1,2 or up to 10 bloody spaces. I love using Python and will use any opportunity to automate a task, and tax time was always a bit of a pain - next year should be a lot easier.
Tried Django once. I hated it. Tried Flask, and I loved it. So open and free, for me to do what I need. That said, I'm new to python and so I don't have a set of go to modules for Flask.
Hehe, calm down buddy, no-one's taking away your precious jet! I guess some of us want our work to be accessible to a large audience (~8% of the male population is colour blind), and for our data to be interpreted correctly.
Colorbrewer spectral is pretty much a fixed jet, but it's divergent: its lightness gradient is dark at the ends and light in the middle. So it's not suited as a default map. A default map needs to make as few assumptions about the data as possible, which means colorbrewer sequential, one of the new matplotlib maps, cubehelix, or similar.
There are different flavours of OpenSource, not everyone buys into the GPL. As I understand it, I can link a LGPL library to a more permissive project (say, MIT licensed), but if I used a GPL library, I had to put the whole project under GPL which I might not want. So I think this is **great** news!
I've been considering trying this with Rust's keycode locks. I have a dictionary of the pixel positions of each number, and I have a list with the 20 most common 4 digit codes. I can expand after I get a proof of concept. I can't find a good clicker and keyboard input (have to hit e to open keypad again). Do you have any suggestions for how to autoclick or autopress keys? Libraries that can be installed via pip and don't require the VB compiler would be excellent. I know it's cheating, and I don't really intend to use it. I just want to see if I can actually do it. I know Python but I don't find projects that interest me very often.
Haha, I remember that one. 
Now, as a Python 3 user, I can finally start to figure out what gevent is. 
Visual studio versions are listed here https://docs.python.org/devguide/setup.html#windows
Thanks a lot for the feedback, appreciate it. About the RSS feed. That's a great idea. I'll implement it ASAP.
Hahaha. Thanks for reading and for the feedback!
He, I was thinking the same thing.
Before there were stock tools available for doing so, I wrote a small automation framework in Python that I can very quickly put together all kinds of automation tasks in. Some stuff I've used it for: * Automatically download new TV show episodes, properly name them, put them in the right folders and send me an email that a new episode was available. Also generated an RSS feed and a 'Latest' folder with links to the last 20 downloaded episodes. * Send notifications to my phone about outages in public transport on sections where I travel * Send me a notification when (a lot of) rain is expected in my home town and the town where I work (geolocation was too much trouble). * Send notifications to my phone when someone mentions my name on IRC * Continuous Integration before it was popular. * Automatically synchronise a bunch of stuff (calendar -&gt; trello, etc). Today there are apps for this (IFTTT, Sickbeard, etc), but I still use my own solution because it's much more flexible. It's basically a directed graph of nodes with queues. Some nodes poll information, some transform / filter it, others send out notifications, etc. 
You can find files at https://github.com/bids/colormap, specifically for the new default: https://github.com/BIDS/colormap/blob/master/option_d.py
It's not open source *yet*. A few months ago I decided to open source it, but it was a horrible mess (since I only used it myself) and needed refactoring. I put quite some time into it, but got sidetracked by other projects. Those are nearly done, so I think I'll get back to it soon. 
Blast(!) from the past. I remember playing this when it fist appeared (ouch). Fantastic! 
Pretty cool. though I'm really bad at this (any) kind of game.
- Flask-SQLAlchemy, with psycopg2+postgresql as database - Flask-Script for my "manage.py" (like that manage thing from Django) - Flask-Migrate for DB migrations, which incorporates a bunch of Flask-Script commands. - Flask-Assets, for all the javascript/css stuff, with node.js LESS compiler installed on my system. - Flask-Redis, possibly. I never really used it much but would probably use it for session storage. - Flask-Login, is pretty simple. - Flask-Scrypt, only adds some convenience "scrypt" functions. Doesn't really do much aside from that. - Flask-Principal, for permissions and stuff. Never actually used it on anything, but is *probably* the extension I'd go for. Have to take a deeper look (does not conflict with Flask-Login). - Flask-WTF, if I need regular webforms with easy validation. - Flask-Admin, is pretty good. I only used it once, but it really helps, if you need a simple backend for your models. There are a lot of other cool extensions, but this is what I usually go for.
I have a few questions. How/Where do you get the images/fonts/sounds for projects such as these? Are they freely available and can you modify them in any way? Do you need to reference the source? How do they impact your own license?
Maya uses Qt4 for its gui and ships with PySide
There is a full detailed answer to your question by the author of that piece of code... https://benkurtovic.com/2014/06/01/obfuscating-hello-world.html
it's a sort of asyncio but with patching python, which I don't like
jet is a piece of shit and i hate it with a passion. When I was at university, at several occasions students and researchers thought they had found something interesting in their images but when I told them to switch to a better color map their discoveries were gone.
Wrapper class is definitely the way to go. Just create a class that has the same interface as the requests module and proxy calls to requests with a try/except/else/finally block. 
Asyncio is mostly centered around the concepts of making asynchronous Input/Output operations work inside the framework of an event loop, and also using generator / yield calls to make its code nice to look at. The event loop model has already been proved to work nicely by other underlying C implementations, the whole of Node.js, etc. This is slightly more limited in scope to what gevent implements, which is cooperative green threads. Green threads are differentiated from OS threads in that they are managed by the userland environment itself, rather than the OS system call mechanisms, and are generally cooperatively scheduled to run (pass each other the baton) rather than some using an outside predictive algorithm (the OS thread scheduler). This all means, when used correctly, they are way more efficient (and effective) at implementing asynchronous threaded programming than OS threads. Green threads also allow asynchronous IO to happen but through their cooperative scheduling mechanism, rather than explicitly being designed around an event loop. As it happens, Gevent's hub (thread manager) looks rather like an event loop anyway :) Purely pragmatically, they just have different APIs, and gevent comes with more general asynchronous tooling off the bat.
implement [\_\_getattr\_\_](https://docs.python.org/3.4/reference/datamodel.html#object.__getattr__) (also see [getattr()](https://docs.python.org/3.4/library/functions.html#getattr))
Well, I knew at least that much :-)
Is the paradigm similar to Go?
Thanks. I meant in general. Say you wanted to clone an old game, how would you go about finding all of these materials? I'm sure there might be copyright issues with some of them.
postGREST also
Perhaps PyAuotoGUI or SikuliX might do the trick
Thanks for the honest breakdown!
If you can't even come up with a single example, that casts doubt on the validity of your argument. 
What are your thoughts on cubehelix?
3.8: Take over the world!
I've thought of doing something similar (but only for the download movies/tv series part) for some time now, but never really started. My idea was developing it based on plugins where I could then write plugins for various trackers/subtitles websites. Then it would have an API that I could use to add new series/movies and develop some sort of interface to be netflix like (search movie, choose tracker, download and watch with only a few buttons). I realize there's some similar solutions right now, but I would have the power with my own code.
oh, you mean *that* Nokia which dumped PySide after a year or two of funding, and then later sold off Qt to another company (thank god!) before being completely taken over by Microsoft and then driven into the ground. 
If you search for any game (say Mario bros), you can easily find the sprites etc. The problem, as /u/lrobinson2011 says, is that not all are open licensed. That doesn't mean you can't get away using them. The Flappy bird guy "borrowed" his art from Super Mario, and irritated millions, and wasn't sued (afaik). 
Do it! It's so fun to implement something like this. I often struggle to find projects I'd like to take on that are actually useful to me personally. 
What? Of course not! Use jet on anything you like, it's not being removed. This is talking about changing the default colormap.
I was looking at anaconda, is there a way to get Python 3.5's `@` operator working in anaconda with 3.4? If not I'll probably still use anaconda. Thanks!
This is a situation is where things get really fuzzy really fast, because the GPL isn't an end user license. You don't have to accept the terms of the GPL to use GPL software. You only need to accept the terms of the GPL if want to make copies of the GPL software and redistribute it to others. If you don't accept the terms of the GPL and still make copies then you are (most likely) infringing on someone's copyright. Does copying GPL software inside an organisation and passing it around inside the organisation count as distribution? I'm guessing probably, but I could be very wrong. It's unclear. 
Because python used to have no boolean type. People used 0 for false and (mostly) 1 for true. Then they added True, False, and a boolean type, but, for backwards compatibility, they couldn't make True and False constants: they just were built-in variables. Python 3 was backwards-incompatible, so theycould finally fix that.
I like cubehelix, and I was suggested it because apparently it was designed to be printed and distinguishable in B&amp;W as well as color. Which I find is true, or certainly better than jet. 
We need let them know what we are thinking , maybe they change it 
Zip comments
 what /u/pysk00l said about rollkeeper and imports. also, there's a lot going on in just that snippet, so let's take a look. def rollDice(): damage = random.randint(1,6) damage = random.randint (1,6) * first: it seems silly and nitpicky when you're new, but get used to forcing yourself to adhere to a good coding style now, before you build the bad habits. Especially when you're soliciting feedback from others, it makes it much easier to read and keep track of what's going on. * `random.randint (1,6)` should be `random.randint(1, 6)` * no space between the function name and the `(` and add a space after each `,` * second: the `def` keywork defines a function. MOST of the time you want to do that at the root level of your module. It's possible to nest functions inside of other functions, but you would rarely ever do it inside of a loop. And for it to actually *do* anything it has to return a value, and then you have to call the function from somewhere. I agree that factoring the diceroll into a function is a good idea, but you haven't quite done that here. * This is what that would actually look like in practice: import random # imports at the top of the script # ... def roll_dice(): # Another code style recommendation is to use lowercase or # lower_case for function and variable names damage = random.randint(1, 6) return damage # ... damage = roll_dice() # ... * As for the loop itself, if you want to keep looping as long as a condition is true (e.g. the user keeps entering 'roll'): while input() == 'roll': # no () needed for comparisons like this damage = roll_dice() print(damage) * This is still not very good, however, because you don't check for typos at all. 'ROLL', 'orll', and 'rolll' all immediately exit the loop. If the two accepted commands are 'roll' and 'attack' a better approach might be while True: user_input = input() if user_input == 'roll': damage = roll_dice() print(damage) elif user_input == 'attack': break * Now, the two commands function as intended, and unrecognized strings are ignored. Also, I won't go too deep into it, but it looks very unlikely that those classes function the way you intend. Inside the class you almost never want to reference variables that you create outside of the class (`damage` and `enemyDamahe`, etc.). I would take a step back and revisit some fundamentals. There's tons of links on here to sites with good tutorials and interactive python courses, etc... Go over functions and classes some more, it'll make it much easier for your to organize your program. EDIT: Formatting. Again. Again. Again. THEY ARE CODE BLOCKS, NOT A PART OF THE LIST!!!!! Again. Again. Fine, they ARE a part of the list. 
My Python final project was to clone Pong. I failed miserably on hit detection.
IMHO you will not find anything as advanced and feature rich as this.
Quokka is my stack for all my content based projects, I just create new modules and themes for Quokka. http://www.quokkaproject.org
Yeah saved me a bunch of time for super stripped sql backed apis 