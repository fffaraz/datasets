Well, testing the rc first would be a good start...
Just for fun, mind for an easy probabilistic algorithm? Generate N random points where -1 &lt; x &lt; 1 and -1 &lt; y &lt; 1. Calculate the number of these points which fall in a disc of radius 1. Then pi = 4*in_disc/N I had this for homework, I really liked it. 
I think this makes SC a very interesting game... I'd be very happy to watch a good commentary of a bot vs. bot, with the commentators being the programmers who wrote the bot saying stuff like "this is where the special routine I wrote goes into action [...]".
and, indeed, testing the release
&gt; Depends on what you mean by possible, I guess. I mean "possible," "doable." "Achievable." You know, the actual meaning of it if you look it up in a dictionary. &gt; If possible means catching 'em all, you can't do it Exactly. It's what we call "impossible." As in, "the opposite of possible." &gt; but if it means 120 GB worth, it can be done. 120 GB worth of digits is not "as many digits as possible," fuckwit. "As many digits as possible" can *never* mean "120 GB worth" of a number that *infinitely many digits*. Holy fuck, you'd dumb. All seven (so far) people who downvoted me should be ashamed of their idiocy. At least they're shrouded in anonymity; you've come out and publicly proclaimed your stupidity. "As many as possible" means "no more can be done." 120 GB is not "as many as possible." 120 PB is not "as many as possible." Every computer in the world could be generating digits of pi and you will never have generated "as many as possible." Language has meaning, dumbass, and that meaning does not permit "120 GB" to substitute for "infinity."
Out of interest, if you're not on win32 or darwin it actually assumes that the vim executable is 'mvim'. Which isn't true and will cause a traceback. Manually creating the .vimpdbrc file and specifying the vim_client_script etc. will fix it. Of further note if you're on Fedora, I see even their "vim-enhanced" package doesn't come without the needed clientserver option enabled. :-| Gvim will work though.
I don't think you actually need to fill a HDD. A [spigot algorithm](http://en.wikipedia.org/wiki/Spigot_algorithm) doesn't need previous digits to work.
Thanks for suggesting this, I was going to but you spared me the work. You can imagine this algorithm as a cannon that randomly fires cannon balls onto a square plot of land, in which a circle-shaped pond is inscribed so it touches all four sides. Then we compute the ratio of the number of 'shots' that land in the pond to the total number of shots fired. You can also use just one quarter of this setup and sample x and y between 0 and 1. You can recompute your current estimate of pi after every shot, so the number of correct decimal places will slowly increase. However, figuring out to how many digits you have already computed pi accurately is another problem ...
[Machin-like_formulas](http://en.wikipedia.org/wiki/Machin-like_formulas)
 \frac{426880 \sqrt{10005}}{\pi} = \sum_{k=0}^\infty \frac{(6k)! (13591409 + 545140134k)}{(3k)!(k!)^3 (-640320)^{3k}}\! 
Wikipedia "Pi", go to Chudnovsky Brothers
For that to work, you need an absolutely random number generator. All software generators are pseudo random number generators -- PRNGs, and will not deliver very accurate results. Even using advanced techniques like Knuth's M algorithm rapidly fail when search for high accuracy. The M algorithm which creates a stream of PRNs, then randomly selects from those candidates. Take the best two PRNGs that you can find, use one to generate candidate PRNs, use the second to select (and refill) from large array of size n where n is prime. A perfect hardware random number generator would do the job under ideal circumstances, but would take far longer than other methods. See Knuth's "The Art of Computer Programming VOL 2: Seminumerical Algorithms"
win32process.CreateProcessAsUser
How would I go about siphoning stdio?
I stopped using Elixir when the declarative layer was added to SQLAlchemy around 0.5. Good article, though. AFAIK Elixir still remains more expressive and featureful than the declarative module. Correct me if I'm wrong.
Actually, for the purposes of a hobby project (as opposed to a world record attempt) it would work well enough on any system with a somewhat usable random device. Should the quality of random numbers really become an issue, you can always sample from a (very fine) regular grid and just let the PRNG decide which area to sample next.
Do you have the code published somewhere? The way Twisted is used is that you don't have to make threads to have multiple sockets listening so most of the time you can share data without locks.
Well that's the thing, it needs to be something i'm interested in. Learning a language might not interest me per say, but it's more interactive.. so i'm assuming i'll stay awake. Personally, i fall asleep when i get bored.. and music doesn't keep me involved enough for me to not be bored :/
&gt; I want to compute π to as many digits as possible using Python 3. &gt; "As many as possible" means "no more can be done." Context, dear boy. Context.
Did you try [Cython](http://wiki.cython.org/)? 
My mistake : I forgot to update to the right default string for Linux. Fixed in latest release http://pypi.python.org/pypi/vimpdb/0.4.3.2 
Cheers!
I think this is rather redundant, but if you really wanted to keep your code off of github and back it up only to dropbox, you could simply do this for your git repository: cd Projects/project-name git clone --bare . ~/Dropbox/Projects/project-name.git git remote add dropbox ~/Dropbox/Projects/project-name.git And every time you want to push updates: git push dropbox [branch-name] 
Yeah, I had to do this same problem with Python Programming in Context by Miller &amp; Ranum.
I'm researching computational linguistics for my dissertation right now and am trying to see the limits of a particular language I've developed.
1) Get a treadmill 2) Put it next to a tall desk. 3) Move your computer to said desk. 4) Activate walking program while at treadmill 5) ? 6) Profit!
Stop eating like a fucking pig. Low glycemic index, high in lean protein. This means no mountain dew garbage. Lean tuna straight from the can, with mustard, instead of pizza every day. Lift weights. Lift heavy fucking weights. Do cardio. Fuck this bullshit of learning python at the same time. That's stupid. If you insisted, you could read the O'Reilly books on Python while riding a stationary bike. Are you stupid that you needed to ask how to do this?
I play video games while riding a stationary recumbent bike. Your upper body remains very stable - enough to read for sure. Original credit for the idea goes to this dude: http://theweightlifter.blogspot.com/2006/10/low-cal-6011-min-warbiking-3-months-41.html
Except this is only as accurate as the approximation of pi you use to determine the extent of the disc.
Where did you get this information from? According to [a post on Python-Dev](http://code.activestate.com/lists/python-dev/100872/), Python 2.7.1 will be released on December 11th. Only RC2 is planned to be released on Nov 27th (this saturday).
Don't do 2 things at one time. Generally don't do that. That's one of (maybe the biggest) reasons for people being overweight. You eat while you're in front of your computer / TV. So you don't be aware if you're already full. You don't enjoy food. You're actually not eating but putting stuff in your mouth while doing something else. Also, when working make active breaks. We all know that we can keep on hacking away for hours and hours. Onther Coke, another candy bar. That's ok as exception. The normal case should be working regular hours. Make a break every hour to calm down. Just clear your mind for 5-10 mins. Generally, higher awareness and one-pointness are the overall goals. If you get better at those, everything else will follow. For getting in shape I would recommend going to a gym and do some weight lifting. That's the best! Sugar is the devil! Avoid sweetener as well. But don't starve. There're loads of advices on the web. Check out metabolic diet, which says: "Eat carbs when you need them" E.g. before your work out or in the morning. If you don't need so much calories (in the evening) eat protein and veggies. Eat a lot, but eat right. That's the key. And if you really really want to do both: Go to the gym, jump on a cardio bike or cross trainer with your favorit Python book.
Not in python, but [eLibrary](http://sourceforge.net/projects/ebooklibrary) is also a nice windows solution. Im the lead developer, and we are always looking for help.
While I applaud OP on both goals, I think Knack makes a good point here.
&gt; Don't do 2 things at one time. &gt; jump on a cardio bike or cross trainer with your favorit Python book. ???
[Treadmill Desk](http://www.treadmill-desk.com/) A couple people have posted on reddit who have used this and have had great success with it, [like this guy](http://www.reddit.com/r/Fitness/comments/dfwor/by_turning_his_desk_into_a_treadmill_this_guy/). Of course, anyone who makes or buys a treadmill desk is also going to be food-health conscious and is likely to be avoiding the trifecta of modern disease: refined carbohydrates (sugar!), omega 3/6 imbalance (corn oil!) and gut irritating foods (wheat!). Kudos to you if you can learn Python while lifting weights though! I have trouble doing the math to add up the weights on the barbell ten minutes into a lifting session. You do need some form of exercise with high intensity to build muscle and improve your body composition (weights and sprints). The good news about that is you can get a huge amount of mileage in a brief amount of time, even doing as little as 20-30 minutes two or three times a week is enough to effect significant hormonal changes in the body. 
Every time you get an unhandled exception or a test fails, do 25 situps and 25 pushups.
well that wont help my ADD :) i need to do 2 things at once or i get bored! you point is well taken, I just thought I would see if I am the only one who has thought of this and if it has been successful in the past. Thanks for the reply 
this looks interesting .. I will look into it more
lol i would be buff mcbufferson in a week at that rate :)
You create an unnamed pipe pair and set one of the ends as a standard handle in the [STARTUPINFO](http://msdn.microsoft.com/en-us/library/ms686331%28VS.85%29.aspx) structure. 
Exercising and doing something else is not going to cut it. If you can do something else at the same time as you are training your intensity is not high enough. The only thing you can do while learning python is dieting.
For translating pypy itself (compiling), which is a hugely complex task, pypy takes about twice as much memory and is about twice as fast. For 64bit pypy compared to 64bit CPython they only take 24% extra memory though. It's only going to get better as well.
PyPy has ctypes support - so you can call into C libraries this way. You can also write RPython wrappers for C libraries.
PyPy FTW!!! And who cares for spitfire being slow on it ;) 
I cut back on drinking by imposing a rule of "beer is only allowed on days where you go to the gym or go running." If there is a particular element of your diet that you want to shift from a standard/necessity to a special treat, then you could apply the same principle and only permit it on days where you accomplish some specific task in python (e.g. finish a section of [a byte of python](http://www.swaroopch.com/notes/Python) or a problem on [project euler](http://projecteuler.net/) or a problem on [python challenge](http://www.pythonchallenge.com/) )
You've skipped an important part of my context: "And if you really really want to do both:" 
I suppose you could try eating Python books for a while and see how that goes. Definately succeeds in combining the two activies, although i have doubts about the effectiveness. :-)
Who uses spitfire besides youtube? But spitfire is faster if using cStringIO.
My experience is that you have to deal with your ADD sooner or later. You might reach a point in your life where you're so sick and tied of never being fully there. A point where you don't want to cruise over the earth somewhere in the atmosphere any more. The plasticity of brain is amazing. All kind of new habits can be learned. Even being more calm. The trouble is: Learning things needs focus. Thanks for the challenge, I say ;-) 
try (2.6): reload(your_module) instead of: import your_module This will not work if you do: from your_module import some_object I think you can get around it though by: del some_object from your_module import some_object someone might want to clarify that. Also, the reload function is not built-in in 3.0 and must be imported from somewhere i believe. This was written all from memory so feel free to correct anything wrong.
You should not be updating your productions servers with R.C. releases.
should you be doing that?
Congratulations to all PyPy developers and contributors.
Thanks a lot! Just started missing with system calls on Windows, so I was a bit clueless on how pipes were handled on non-*nix systems.
&gt;pypy.exe - Unable To Locate Component &gt; &gt;This application has failed to start because MSVCR100.dll was not found. Re-installing the application may fix this problem. where do I get this dll from? edit: place this file http://www.dll-download-system.com/home/m-dlls-not-system-/msvcr100.dll/details.html in the Pypy folder 
Not sure what the status of Numpy and matplotlib is in 1.4 !? 
Listening to something while driving? Considering that if i have something that interests me, it keeps me awake, then that's probably a good solution :P
The [official installer](http://www.microsoft.com/downloads/en/details.aspx?familyid=A7B7A05E-6DE6-4D3A-A423-37BF0912DB84) from Microsoft might be a better source for that dll.
There were also some promising results reported lately about the Reflex integration. See [this old blog post](http://morepypy.blogspot.com/2010/07/cern-sprint-report-wrapping-c-libraries.html) and [the recent thread on the pypy list](http://codespeak.net/pipermail/pypy-dev/2010q4/006383.html).
From the Beazly book: "Older versions of Python provided a reload() function for reloading a module. Hoever, use of this function was never really safe, and its use was actively discouraged except as a possible debugging aid. Python 3 removes this feature entirely. So, it's best not to rely upon it." I'm coming to the conclusion that the interactive prompt just isn't useful for developing modules. 
Since I don't use Mailman and I don't know its inner code very well, I can't make any more statements without learning more about it. Thank you for telling me about it.
Anyone got django with mysql working on it?
pypy is getting closer every time I check it out to being a valid replacement for cpython. Better C extensions support and python 2.7/3.2 features and syntax would make it the killer python vm in my humble opinion. Add in the hidden classes/mapped attributes thing to reduce memory usage and hells yeah!
Well, this was on my front page for some reason and I read puppy instead of pypy. Not what I expected, and I'm gonna say not nearly as cute.
You are a nit-picker. OP *clearly* did not mean literally all digits of pi.
I'm impressed by how much work the PyPy team gets done, and I'm beginning to be curious about trying it out. How long until the Ubuntu PPA picks up the 1.4 release?
the Python osmosis video podcast [link to torrent link](http://www.reddit.com/r/Python/comments/dtxxz/go_on_fellow_aspiring_pythonistas_fire_up/c136zp1) presents the official python tutorials in video form. With a portable video player, you could try watching while cycling etc. Dunno how much you'd learn, but it's something. (Play them on a cheep netbook, and I guess you could have python there to test it out with too...) 
"Writing python in python, that's stupid, it will never be as fast as cpython" -- me, 1 year ago. I've never been so happy to be proven wrong.
Write an application to track your exercise regime, send reminders, etc. in python.
I've done a ton of reading over the past couple days on QT and PyQT. I think I'm going to give it a shot and see how I like it. I hadn't done much development with WX, so the transition should be easy enough. For now I'll stick with PyQT and see how Pyside looks later on. I haven't looked through all that stuff yet.
Absolutely. Even 2.7-final proved to be a bit unstable, in that, it was still buggy and eventually we had to switch back to 2.6. I think 2.7.1 should be the point we would actually move the production apps to 2.7. (My dev machines however have been running 2.7 since the first beta relese)
and after it shows this post... and I could keep doing this for each time I comment. RECURSION! python RedditorStats.py RussJancewicz Following API Rules... Gotta' slow down the Calls Subreddit % Activity -------------------------------------------- pics 57.14 DoesAnybodyElse 14.29 secretsanta 14.29 Python 14.29 
What the... semicolons?
yeah... I grew up on C and other languages which require them... that is a bad habit when I write python... if I dont when i switch back to other languages I end up forgetting them 
I am no expert but a few things: * Drop those semi-colons * Why write it out to a temp file? Why not just process the JSON in-memory? * Rather than `if subreddit not in subreddits.keys()`, why not just try to retrieve the value at `subreddits[subreddit]` and handle accordingly? * Needs moar functions :-)
I didn't even know python allowed them. You have enlightened me and I'm not sure i like it.
Ah, okay. I was wondering if it was some weird dialect of Python that I had never seen before. I've seen a few C-like habits creep into some people's Python code (especially enclosing 'if' conditions in parentheses), but never so far as to use semicolons.
* like i said above, bad habit... * the temp files are just cruft from testing when I was running it more than once in minute I would hit the API timeout (which causes you to wait like a minute to rerun) * that would be fine and I suppose checking for None would be faster than iterating keys * yes.
I have added a kqueue-based observer for BSD in git head. Testing it currently. I'd be glad if you could as well since I don't have FreeBSD. I'm using the Python 2.6+ built-in kqueue interfacing select.kqueue module.
PyPy successfully bootstrapped Python like well-known C compilers.
Write a Python script that will remove them.
I've got some ugly code lying around from where I'm learning Python by doing Project Euler stuff. Some of it is rather brute force, in fact. Probably my ugliest code (but nicely sub-routined so probably ideal for pypy) ***Python***: real 0m58.656s ***PyPy***: real 0m4.509s
K. fin = open("path/to/file.py"); fout = open("path/to/clean_file.py", 'a'); for line in fin.readlines(): fout.write(line.replace(";\n", "\n")); fout.close(); fin.close(); EDIT: Just to be clear I didn't even notice that I used semicolons all over this one until I went back and read the comment... it made me laugh a bit. just run that over itself and then it can be used on anything else!
you're joking right ? (aka "are you fucking kidding me ?")
 from ControlWeight import * lose(120,'LB') 
This is quite simple and useful. Thanks.
Start by instrumenting your code to find out how long stuff actually takes. Then figure out what actually needs optimizing/caching/etc.
Well played. If you want to earn yourself another up vote, write a Python script that will add back the semicolons.
BAH! The temporary file screwed me up (I'm running windows), so I rewrote everything out of spite. I dropped percentages for just the count and a total, which is giving me much lower total than I expected. Is this for a short time period or a certain amount of comments? import sys, json, urllib, time, operator, collections username = sys.argv[1] subs=collections.defaultdict(int) urls=('/comments.json','/submitted.json') for j in urls: json_data=urllib.urlopen("http://www.reddit.com/user/"+username+j).read() for i in json.loads(json_data)['data']['children']: subs[i['data']['subreddit']] += 1 if j!=urls[-1]: time.sleep(3) total=sum(subs.itervalues()) subs = sorted(subs.iteritems(), key=operator.itemgetter(1)) print "{0:30}{1}".format("Subreddit","Activity") print "--------------------------------------------" for k, v in reversed(subs): print "{0:30}{1}".format(k, v) print "--------------------------------------------" print "{0:30}{1}".format("TOTAL",total) 
"Possible" is a relative word. "Possible, for whom?" It is not possible for anyone to calculate as many of the digits of pi as it is possible to be generated, but it is possible for someone to calculate as many digits of pi as it is possible for that person to calculate. If the OP was asking about the first, it was dumb. If he wanted to calculate as many digits as it is possible for him to calculate, then it's an achievable project by definition.
I guess he doesn't have to write the digits down as he finds them, but then the project seems even more wasteful, since it's basically just acting as a random number generator eating up cycles in the background.
Uh, no. Not if he's using a book that is written assuming that he has Python 3. In general, Python 2.7 is great. But if you're learning Python from a book written about Python 3, you should use Python 3.
The answer is no.
Pretty impressive rewrite I must say. I don't think `if j!=urls[-1]` is even required. BTW, yes, it seems that not *all* the comments are returned.
without the overhead of having to use Buildout. and it needs git now?
Pretty cool dude! I just tried it on myself: [hector@hectorhector ~]$ python RedditorStats.py hectorhector Following API Rules... Gotta' slow down the Calls Subreddit % Activity -------------------------------------------- starcraft 22.00 ucf 14.00 orlando 14.00 florida 4.00 halo 4.00 entertainment 4.00 japan 4.00 fffffffuuuuuuuuuuuu 4.00 AskReddit 2.00 atheism 2.00 science 2.00 worldpolitics 2.00 television 2.00 bestof 2.00 gaming 2.00 woahdude 2.00 meetup 2.00 sports 2.00 WeAreTheMusicMakers 2.00 skateboarding 2.00 Music 2.00 engineering 2.00 gadgets 2.00 
I'll give it a try. Thanks! Been using Geany until now.
What's slightly worrying is that you missed two.
the jit does not care for functions, it traces loops
I was dismayed as well, but You can apply for a free educational license if you are a student, or a free open source license if you need it for working on an open source project.
In St.Petersburg, Russia (where PyCharm is developed), $99 is what an average software developer earns for one working day. Seems quite affordable to me.
Note that the free PyCharm classroom license is not exactly for students - it's for use in a classroom (a teacher gets the license and uses it during his classes).
ipython seems to handle this: In [5]: import assets foobar In [6]: reload(assets) fo Out[6]: &lt;module 'assets' from 'assets.py'&gt; 
total = len(submitted) + len(comments) right?
I agree, I enjoy PyCharm a lt. I got the 50% discount but I would have paid full price for it.
Yes, but this way it's not usable as learning platform. And why would I switch if I got used to something else.
Aha. You're right, I stand corrected. function mypi = ilikepi(iterations) % this is vectorized matlab code x = rand(iterations,1); y = rand(iterations,1); h = sqrt( x.^2 + y.^2 ); mypi = 4 * sum(h &lt; 1) / iterations; 
The idea is good however this needs more features like a robust dependency installer for your app. I know setuptools is just for that but it's not very flexible when you have source dependencies. 
Django works, and I think there is patches to the mysql python driver to make it work also.
there is a typo on line four. Edit: now there isn't.
Python 2.7 support is happening on the fast-forward branch (will jump from python 2.5 to 2.7) Better memory usage for python objects (the hidden classes thingie) is something pypy already does, see: http://morepypy.blogspot.com/2010/11/efficiently-implementing-python-objects.html so hell yeah :)
and $0 is how much the average Russian developer pays for commercial software
every Python IDE haves its own benefits, is just a matter to chose the right tools for programming
This post is entirely about Python - Zine was one of the only dynamic blog platforms available for Python and Armin is the author of Jinja, Flask, and Werkzeug (edit: and Zine). Most of his blog posts are about Python.
TimeMachine -- a fairly trivial module, but... http://github.com/bkjones/TimeMachine
As an example of how Monte Carlo techniques work, yes it is quite valid. But it will not do the job of producing very many digits of pi accurately, which is what the stated purpose was. 
This is incredibly neat. Have you thought about hosting it somewhere?
Go running for an hour before breakfast and don't eat while coding.
&gt;import ControlWeight &gt;ControlWeight.lose(120,'LB') FTFY :P 
Why do you need to wait for a PPA? You can build it pretty easily.
&gt; Yes, but this way it's not usable as learning platform There are free education and open-source licenses. Though I couldn't for the life of me understand why you'd teach Python with an IDE.
Funny, as I was lying in bed this morning one of my re-occuring thoughts was that I needed to find a decent editor for Python. I'm checking this out now. Does anyone else have a suggestion for a Mac native Python editor?
Me too! (For the next 8.6 days until my trial expires.) I have 3 InelliJ licenses and really want the Rails IDE too. I can't justify $99 for personal development. I'll have to wait until a project or employer buys this one. Until then they have another 8.6 days for me to fall in love. IDEA knows how to do Django/Rails/Grails/J2EE IDE's better than anyone.
Python 3 rewrite: import sys; import json; import urllib.request, urllib.parse, urllib.error def main(): if len(sys.argv) &lt; 2: print('Please provide a username, like ./RedditorStats.py sontek') else: get_information(sys.argv[1]) def get_information(username): subreddits = {}; urls = ('comments.json', 'submitted.json') for url in urls: text = urllib.request.urlopen('http://www.reddit.com/user/%s/%s' % ( username, url )).read() for i in json.loads(str(text, encoding='utf-8'))['data']['children']: key = i['data']['subreddit'] if key in subreddits.keys(): subreddits[key] += 1 else: subreddits[key] = 1 total = sum(subreddits.values()) percents = {}; for subreddit in subreddits: hits = subreddits[subreddit]; percents[subreddit] = round((float(subreddits[subreddit])/total * 100), 2); percents = sorted(percents.items(), key=lambda t: t[1], reverse=True) f = '{0:30} {1}' print(f.format('Subreddit', 'Activity')) print("--------------------------------------------") for subreddit in percents: percent = "%.2f" % subreddit[1]; print(f.format(subreddit[0], percent)) print('--------------------------------------------') print(f.format('TOTAL', total)) if __name__ == '__main__': main() 
Especially when you can get a similar experience in Eclipse using PyDev and vrapper for free. Maybe PyCharm is oodles better, but I just develop Python as a hobby so paying $99 is kind of silly.
Textmate, if you really mean editor. If you're looking for an IDE though, seems all the ones that get great reviews are paid. Try Komodo. There's a free and paid version. 
I don't know how native Eclipse feels on OSX, but with PyDev and vrapper you can get a pretty decent IDE for Python development. vrapper's only necessary if you want vim bindings, which is something PyCharm features.
You mean RubyMine? It's pretty awesome if you do actually need a full on IDE. More often than not, I find myself just popping open Textmate though. 
I really like that formatted print, nicely done. great cleanup of my code. 
Knock yourself out : http://www.jetbrains.com/pycharm/features/index.html
Good catch
PyCharm is nice, but I can't get past the incomplete Emacs key bindings. What's the Mac standard way to go to the beginning of a buffer? Hell if I know. When M-&lt; doesn't work (and my Meta is Esc), my fingers are lost. 
or even easier, just download the linux binaries.
Interesting. If I break off a series of steps from inside a loop to a function, pypy runs it noticeably faster.
Congratulations. I thinks this is an amazing project from every point of view. We tested it with web2py and it runs on PyPy out of the box.
no offense. but I prefer non-java based IDEs. I have used eclipse/netbeans before with their python plugins, but all consume too much memory than it should be. Now I am with Wing IDE and I am happy :)
Oneliners ftw! open("path/to/clean_file.py", "w").write(open("path/to/file.py").read().replace(";\n", "\n"))
Is it just me, or does it seem like pycharm is getting spammed here a lot? 
Doesn't work. Traceback (most recent call last): File "RedditorStats.py", line 17, in &lt;module&gt; urllib.urlretrieve("http://www.reddit.com/user/"+username+"/comments.json", "/tmp/RS_Comments.json"); File "C:\Python26\lib\urllib.py", line 93, in urlretrieve return _urlopener.retrieve(url, filename, reporthook, data) File "C:\Python26\lib\urllib.py", line 241, in retrieve tfp = open(filename, 'wb') IOError: [Errno 2] No such file or directory: '/tmp/RS_Comments.json'
I created a flask application for it, someone needs to host it though: https://github.com/sontek/redditor-stats
Here is a flask application for it if someone wants to host it: https://github.com/sontek/redditor-stats
It's between US$99 and UK£77 more expensive.
It's slow as molasses for the Mac. I paid for it (wanted a native IDE) and ended up using the free version of Wing anyway and/or vim. It's the only app that managed to regularly crash in my 4GB MBP, something you cannot really overlook when it's an IDE we're talking about.
Very well. I haven't noticed any slowness, but I have a very adequate machine. Do you mean it's slow compared to other IDEs? Or maybe you're comparing IDEs to simple editors? IDEs are going to be slow, and can definitely run slower depending on your settings.
In my experience it's much slower than Eclipse with PyDev, which is quite a feat. Plus, it crashes. Wish it was different because I shelled out the money.
Hmm, havent had that happen here. 
thx. I actually kind of like what you did for formatting. I never considered using carriage return for alignment and didn't even notice that was what you were doing until I ran it in IDLE and it didn't work :( I think it'd be handy in a few places where you don't have a decent printf implementation.
I'd say PyCharm is better than PyDev and you get real support. The JetBrains guys are really good at it and keep a good eye on their message board so you'll get a real answer rather rather than being called an idiot or newb. Their platform always seems to perform better for me than Eclipse.
gedit
Does it feature all of the vim keybindings? Can you specify a .vimrc to use?
Mousepad
gedit or vim (gvim if you prefer gui) Altough I would highly recommend you to learn VIM.
the carriage return trick was something I picked up when I was writing a visual cp command (for when I was copying a ton of files from external devices and wanted to monitor progress) I think i actually got the idea from the wget source.
or Leafpad. To OP, depends what you want to do. If it is for coding Python, I'd recommend Geany.
`gedit`. `gvim` (use the `cream` package: it's a little more n00b friendly). `emacs`. Bluefish. Pick one. I recommend `gvim`, because the day will come when X fails you and you need to edit conf files from the command line.
what's "What" ?
&gt; Is this for a short time period or a certain amount of comments? I like how you are able to do an impressive rewrite of someone else's code and not notice the obvious major flaw in it. :-) The original code and all the rewrites only load up the first page of comments and the first page of submissions. For any reasonably active Redditor, this gives mostly useless results. Hint: There's an *after* URL parameter that can be retrieved from the JSON data to generate the URL for the next page.
&gt; it seems that not all the comments are returned Only one page of comments is ever retrieved, so yes, *not all* the comments are retrieved. Only 25 comments, actually. (And 25 submissions.)
Check out the "curses" library at http://docs.python.org/library/curses.html 
http://docs.python.org/library/curses.html 
Thanks!
Thanks!
Where do you guys get this information from? Is there some kind of reddit api?
semicolons still work in Python3? I would have thought that would be one of the things they would get rid of.
`gedit` seems like the obvious answer for Ubuntu (presuming you're using the Gnome desktop). It has a Python highlight mode, if that's of interest. (I actually don't know whether Notepad has that feature.)
What.cd. It's the largest private music torrent site.
Note that depending on what you're doing, you may be interested in [urwid](http://excess.org/urwid/) it makes curses programming very easy. Though the curses module isn't tough to use, I've always found myself annoyed with it.
Thanks!
Not that I know of, but I wouldn't be surprised if there was a subreddit about it. ;) I knew about the *after* parameter from a while back, but I don't remember how I came to know it (from a comment here or from looking at the JSON myself). Anyway, it's pretty visible in the URL when you hover the *next* link at the bottom of the page. There's also a 1,000 limit to comment retrieval that's been mentioned a few times, and confirmed by Reddit admins (saying they still store every comment, the limit is just to save the system from some load when sorting). There was a mention of lifting the limit for Reddit Gold, or of Reddit Gold allowing to pay more servers so that the limit is lifted for everyone, but I don't know what happened after that. Actually, a revised script that browsed all the way back through one's comments (until the after data in the JSON is null or empty) might show us the current state of affairs. :)
Yeap, it has a .vrapperrc for this.
He could always use nano that day. Not that learning vim isn't an investment that pays off, anyway.
kate if you are into kde/qt packages.
I've found that the odds of `nano` being installed are far lower than the odds of `vim` being there.
It used to be like that a few years ago. Now a noticeable percentage of PyCharm sales are personal licenses bought by developers from Russia.
Another neat one, although not really implementing what you look for is STFL - [http://www.clifford.at/stfl/}](http://www.clifford.at/stfl/) the documentation is kinda hard to follow, but once i figured it out it was a blast. urwid is basically the same thing.
Lots of hobbies I know of cost far more than $99 :)
I got a couple scripts at work written by people who know what they're doing. I was charged with maintaining those scripts and extending their functionality per request. It's been pretty much going out of control since then, but it's been a ton of fun :)
Could you please post requests about missing keybindings at http://youtrack.jetbrains.net/ ?
Well, since I already knew C/C++, learning Python was just a matter of knowing the nuances of the language. Sorry if this doesn't help if it's your first language, but I'm currently teaching myself Java and what I do aside from reading about the language is also trying some challenges from topcoder and projecteuler.com to get some practice with the language. 
Ok. I put in logic to follow the 'after' links. put in total counting and print statements in the loop, 'cause it takes a while to run. The comment limit appears to be 1000 like you said, but the number of comments per page seem to vary (probably different size comments affect it differently). I also sort of put back in the original timing logic: import sys, json, urllib, time, operator, collections username = sys.argv[1] subs=collections.defaultdict(int) urls=[('/comments.json',''),('/submitted.json','')] lasttime=time.time()-3 total = 0 while urls: filename, after = urls.pop() url="http://www.reddit.com/user/"+username+filename+after now=time.time() if now-lasttime &lt; 3: time.sleep(3-now+lasttime) lasttime=time.time() json_data=json.loads(urllib.urlopen(url).read()) if json_data['data']['after']: urls.append((filename,'?after='+json_data['data']['after'])) for i in json_data['data']['children']: subs[i['data']['subreddit']] += 1 total+=1 print url print "Total",total subs = sorted(subs.iteritems(), key=operator.itemgetter(1)) print "{0:30}{1}".format("Subreddit","Activity") print "--------------------------------------------" for k, v in reversed(subs): print "{0:30}{1}".format(k, v) print "--------------------------------------------" print "{0:30}{1}".format("TOTAL",total) 
NO, emacs
Thanks!
I already knew C and our Software Engineering teacher decided that all our assignment would be in python even if we never learned it. He wrote a couple of examples on the board then pointed us to some quick tutorial. Next day he stopped teaching us python and started delivering his Software Engineering material while throwing exercises and assignments at us. It was like been thrown in the water to learn to swim. So even if I learned it thanks to college I did not learn it IN college I had to learn it all by myself. The secret was that I was forced to learn because I had things to deliver weekly. My conclusion is that to learn any language you can read books, tutorials and articles to get familiar but it's once you start trying to make small projects that you really learn.
I read the Python tutorial, probably this version: http://docs.python.org/release/1.4/tut/ Using that, and the language/library reference, I wrote a program which parsed web server logs to produce some simple statistics (most viewed page etc) in HTML format. I think reading some form of tutorial, then using it to write something real, is the best way to go at this.
Back when I was a young lad, I went to the book shopping lot, and fancied a look. I had a devilish mind at that ticking moment, and looked for the most dawning book to draw my eye in the binary section. [Behold!](http://media.photobucket.com/image/oreilly%20learning%20python/Boston_George1/OReillyLearningPython4thEditionOct2009.png) the grande book that caught my cool and eager eye. It presented somewhat of a puzzle. Why the rodent? I thunked... And thence, I thought some more, long and hard.I opened it to find an extravagant display of more logical puzzles, silly symbols, and other blasphemous means of thought. That's when I knew, I had to learn this heathens work, for thou shalt keep thy enemy closer!
Dude, he asked for a texteditor not a textbased general purpose user interface... I really whish that somebody did take the time to write a good texteditor for it... *ducks*
My faculty provides a very bare bones server, falsk isn't provided, so I wipped up this in five minutes: [secretsantastats](http://tinyurl.com/secretsantastats). If I had a bit more active knowledge of css I could make prettier...
Thanks a lot for doing the work, I was about to give in and try it myself when you posted your new version. :) Awesome, thank you very much! I got precisely 25 comments and submissions per page, except of course on the last page of comments and submissions. I also got precisely 1,000 comments.
[This cheat sheet](http://i.imgur.com/YQafj.png) I found linked here has given me a fairly good idea as to wtf is going on in Python. I've not really done anything in Python, but probably will over Christmas break. I hope to go through [google's python class](http://code.google.com/edu/languages/google-python-class/index.html) in my spare time, at some point. edit: if anyone has any more resources similar to those I linked, please share! edit again: one of the things I find most appealing about Python is the fact there are no curly braces. 
Do you work for JetBrains?
&gt;what would you suggest I try? What? What the fuck? Crack a fucking book and read it cover to cover. Rinse and repeat. Write programs in it.
I had an app that was written in PHP, once I'd toyed around with Python I then ported it to Python. I later re-wrote it in Python3 and restructured it based on the better practices I'd since learnt.
Argh is a thin wrapper around argparse. Argparse is the standard argument parser shipped with latest versions of Python. It replaces optparse (since 2.7) which, in turn, replaced getopt (since 2.3). Plac is an alternative to argparse. Maybe it's even superior but requires some effort to dive in before you can judge.
I tried several times but I never had an achievable goal too work towards. The first few attempts I tried too rewrite a C++ application I had already written and extended a bunch. This had the consequence of making me stay in the mindset of C++ which doesn't really work for python since its a pseudo OO language (I know I'm going too get flamed for that but sorry guys its the truth). Python is a lot closer too pure functional programming in the mindset I had too achieve. Anyways I decided too learn python by learning pygame while trying too implement a worm clone. Taking it one step at a time I got too understanding the language. I still don't get the modules model. I'm used to explicitly including things and I am not fond of that aspect of python.
Thats exactly what I'm using to learn. The knights who say Ni! Ni! Ni! 
Python was the language taught in my university's first year programming course, so I learned it that way. I've since learned a lot more about it by, well, writing Python. I guess the problem is knowing what programs to write. You can find lots of interesting mathematical problems to solve at Project Euler, for a start. Other than that, just let your interests guide you. 
I learned Python as a school project using [Dive into Python](http://diveintopython.org/). There's a [new version](http://diveintopython3.org/) for Python 3 as well!
He's announcing that he is no longer using Zine on his personal log. He's **not** saying that Zine is dead.
Try writing something you want to write/finish in it. Read/research as you go along, try to use appropriate features, etc. You've really just gotta jump into writing with it. Later, you'll realize what bad code you wrote and how much time you could've saved by really knowing what you were doing, and that's the learning process.
Dive into Python. Show a simple but working application and then explain how it works is a fantastic concept. It's better than books like Learn You a Haskell which is basically the entire reference manual, rewritten. Terrible. It has funny drawings though.
I own this book and shall be learning from it. Glad to know I made the right choice.
I tried PyCharm and didn't like it. But you can't blame them for spamming when the submitter is a reddit bot...
leafpad
I learnt if because I hate matlab and had to do a image-processing assignment when I was at uni.
git or [svn](https://github.com/blog/626-announcing-svn-support). you could also simply copy `fablib/venv.py` into your project.
Interestingly, while curses is excellent, you don't need to use it if you're running your script from a terminal window that supports VT-100 (i.e., Linux or Mac). You can write the escape codes directly to the screen (the codes can be found [here](http://ascii-table.com/ansi-escape-sequences-vt-100.php)): #!/usr/bin/python import sys import math import time esc = chr(27) sys.stdout.write(esc+"[2J") # clear screen sys.stdout.write(esc+"[H") # move cursor to top of screen sys.stdout.write("Hello from the top of the world!\n") sys.stdout.write(esc+"[5B") # move cursor down 5 sys.stdout.write(esc+"[15C") # move the cursor to the right 15 # draw a circle of x's oldx = 0 # relative starting location oldy = 0 radius = 5 for step in range(359): x = int(math.cos(math.radians(step))*radius*2) y = int(math.sin(math.radians(step))*radius) dx = x-oldx dy = y-oldy if dx &gt; 0: sys.stdout.write(esc+"["+str(dx)+"C") # move the cursor to the right dx elif dx &lt; 0: sys.stdout.write(esc+"["+str(-dx)+"D") # move the cursor to the left dx if dy &gt; 0: sys.stdout.write(esc+"["+str(dy)+"A") # move the cursor to the up dy elif dy &lt; 0: sys.stdout.write(esc+"["+str(-dy)+"B") # move the cursor to the down dy sys.stdout.write("x"+esc+"[1D") oldx = x oldy = y sys.stdout.flush() time.sleep(0.01) sys.stdout.write(esc+"[5B\n") # move cursor down 5 **EDIT**: Tightened up the python a bit. 
Could you elaborate? fablib already calls `python setup.py develop`. If you don't happen to use setuptools, then `venv.install('mydependency')` ([source](https://github.com/srid/fablib/blob/master/venv.py#L134)) will install it for you.
Do you still have any of these assignments you were presented with in learning Python that you could find and share? I find that despite there always being a lot of books, online tutorials, and answers to various questions regarding a language, there is a serious and disappointing lack of exercises that are presented to work through when it comes to attempting to learn a language, and as you've mentioned, I find this aspect to be most crucial and immensely beneficial in the learning process.
Had a project due in 5 days. One of my team mats convinced us to use python and web2py and then goes and gets sick. So i do the entire project my self. (there were 4 people in my team) Everything went better than expected. Though i was coding for like 4 days strait. 
I wanted to make a guestbook albeit with some additional features for the website of an RPG I made with some friends. This was on my account on my university's server so I sent an email to the web admin (or something to that effect) asking if he had any tips on how to do it in bash, or if it was even possible. He suggested I take a look at Python. Four days later I'd written a simple but working forum. I was in love. :) This was with some static HTML experience but no CGI/forms knowledge at all.
Awesome, thanks!!!
I took AP CS (Java), and decided I wanted to learn Python. I started by rewriting some of my AP CS programs, then I went to #python on freenode, which quickly told me to look at the official python tutorial. I was looking at some of my first python code today actually (a program to play blackjack). I found it hilarious that I had getFoo() and setFoo(bar) methods. (and no idea what to do with self)
Check this out: http://pages.cs.wisc.edu/~cs368-2/2010/ I'm taking this class currently, not because I don't know python, but mostly because I'm forced to deliver a small project every Tuesday and Thursday. It forces me to code, which is great practice.
alright thanks :)
thanks ill take a look at it! I'm glad to see I can read online for free
I wanted to finally sit down and learn a powerful and simple language. My first language was QBasic in high school, and I absolutely loved that language. I wanted to use it for everything, but I really couldn't, due to its obsolescence and its Windows-only restriction. So I decided to sit down and learn Python. The book *Learning Python* by Mark Lutz helped a lot. While I didn't finish the book, I learned enough to be able to hack around everything and fill in gaps with reference documentation. I recommend Python as a first language to everyone, because I think that a first language that can be used to do powerful things will help people's interest in programming be kept.
Just think of it as playing with Legos, except you don't have to buy more Legos. Python's the next language on my list to learn, here's how I'm going to learn it: * [Google's Python Class](http://code.google.com/edu/languages/google-python-class/index.html) * [Getting Started with Python - Google App Engine](http://code.google.com/appengine/docs/python/gettingstarted/)
gosh that sounds complicated for one of your first things :P I really like that idea to start big though, so I'll try and think of something I really wanna make
haha that cheatsheet is amazing! I already knew most of the stuff on it but it did clarify a couple things and I know i'll be using it in the future :) and I really will check out those classes, Google knows what they're doing
Spent half an hour reading the official tutorial, mostly paged through it to get the gist. Got bored, scanned the spec and flicked through random module docs to get the highpoints, for the rest of the afternoon. Spent the rest of the night playing around in the interactive interpreter, wrote a few simple programs. Fell in love. Never looked back.
You might want to use the Tkinter "canvas", which can give you much more precise control of the text position, size, color, and also supports lines, arcs, polygons, bitmaps, etc. for example: import Tkinter root = Tkinter.Tk() c = Tkinter.Canvas(root, width=400, height=300) c.pack() for j in range(16): (x,y) = (20+(j*10),20+(j*j)) color_str = '#'+hex(j)[2:]+'0'+hex(j)[2:] c.create_text((x,y),text='Hello',fill=color_str) root.mainloop() 
I did this as an [exercise](http://programmingpraxis.com/2009/02/20/the-digits-of-pi/) at my [Programming Praxis](http://programmingpraxis.com) blog.
Yeah, Google uses Python in a lot of stuff they do. I know there's tons of Python stuff done on Ubuntu as well. I installed xubuntu on an oldish (new to me) laptop and look forward to coding python on it.
Knew QBasic and Visual Basic (middle schooler) and ended up finding a PHENOMENAL guide (written by some indian man with a strange name) that I was never able to find again. Learned a good amount of python in about 3 days. Kept exploring ever since.
A good teacher doesn't teach, they show you what you're supposed to learn.
Notepad is one of the oldest and most primitive editors still in existence. By todays standards, it doesn't even touch the e in edit. Not sure what you're up to but doesn't Ubuntu come with a simple text editor by default?
I think Kate is better than gedit, personally. It's more functional, has a cool terminal window that comes along with it, and seems to be more polished.
Nano I believe is the default and vim you have to get from the repos. 
I read a book (Learning Python) and then started doing projects with it. I started with simple scripting things (text file manipulation) and then more complex projects. I already knew C, C++, Java, and Perl, so it was pretty easy to pick up. It took me only a couple weeks to get comfortable and maybe a year or so to say that I really know the language. I think with any new language, you need to read some kind of book/tutorial and then just immerse yourself in it through your own projects. Working with other existing projects to see how they do things also helps. 
Nice! A few suggestions... You could simplify this: def countSubreddits(jdata): for item in jdata: subreddit = item['data']['subreddit'] if subreddit in subreddits: subreddits[subreddit] += 1 else: subreddits[subreddit] = 1 With this: from collections import defaultdict subreddits = defaultdict(int) def countSubreddits(jdata): for item in jdata: subreddit = item['data']['subreddit'] subreddits[subreddit] += 1 And this: total = 0 for subreddit in subreddits: total += subreddits[subreddit] With this: total = sum(subreddits.itervalues()) You generally want to use 'is not None' rather than '!= None'. Also, use spaces rather than tabs. Python does allow both, but everyone seems to have settled on 4 spaces. It makes cut &amp; paste re-use possible. What's with the sleeping in fetchData? Does Reddit rate-limit requests or something?
Depends on the distro, really. Not everybody's using an Ubuntu box, and the day may come when you're using someone else's box (or have moved on from Ubuntu).
The only features notepad has are no highlighting, 1 undo/redo and it conveniently adds .txt after your extension if you're lazy.
curses has been around forever. However, I believe this module is not available on Windoze, which does undermine portability somewhat ...
I was stating that on Ubuntu, Nano is the default and you have to get vim from the repos. I hardly use nano and prefer Vim and it's usually one of the first packages I go and get cause it's never there by default.
Fuck you're right. Next time I better do the math before making grandiose claims on the internet.
Well I've actually been ready this for a while: http://swaroopch.com/notes/Python_en:Table_of_Contents at about chapter 9 I just don't really comprehend much more so I'm looking for new ways and resources to approach learning :)
I was taking a C class at the time. I decided that I wanted to learn a scripting language and went with python. I did all of my assignments in C and then translated them to python. It was very nice going from a lower language like C and truly appreciating the power of python
I remember using some of these escape sequences in Pascal / DOS, some 20 odd years ago :-)
It is very nice. Some suggestions: * It's best to add #!/usr/bin/python (or equivalent) to the top of your scripts! * Also, if you didn't know, you can passed a reversed=True argument to sorted(), which means you don't have to iterate through reversed(percents).
God, I remember a time when vim was at least there by default. That was a very long time ago.
While i have yet to try it on Windows (currently running different versions of Linux) http://gnuwin32.sourceforge.net/packages/ncurses.htm
Me too. Not sure when they changed it but I agree with the change. I prefer Vim and believe that those who prefer it know how to get it. Those who don't know a thing will use Nano quicker hands-down if it comes to it.
I have scite, geany and vim on ubuntu
****I JUST ATE A LIQUID POO!****
i learned it through MITs OpenCourseWare when i was 15 (i'm 17 now). It gave me a great start. Make sure to use both the video lectures AND the text course materials/tasks. The book they link is available online, its called "how to think like a computer scientist", and its also a great resource. This is all free and available online, and should give you a great start. After youve got the basics, maybe try doing problems on projecteuler.net
Well, I've seen projects that have a list of requirements stored in a file (to be installed via pip - eg: pip install -r REQs) People do this because they have source dependencies (and pip is very tolerant to packaging issues). So what I'm saying is that it would be nice to have some tools to manage this requirements file. 
Any pointers to where those patches are?
I'm currently working my way through Zed Shaw's [Learning Python the Hard Way.](http://learnpythonthehardway.org/index). It's a great tutorial that has you to type the code in each example. This encourages familiarity with the syntax and gives you an 'eye' for the code. I'm also making my way through MIT Introduction to Computer Science and Programming, which is available via their OpenCourseware program. The full set of lectures is available on YouTube and the course materials are available [here.](http://6.00.scripts.mit.edu/home.cgi)
Google for Python Image Library. Or PIL.
Might be time to put this up on GitHub.
Hope this helps: The Console module ( http://effbot.org/zone/console-handbook.htm ) is the closest thing I've found. For example, import Console con = Console.getconsole() con.text(10,20, 'Hello world') The last line is the equivalent of the locate and print statements.
i would do the OReilly books. Learning Python and Python Cookbook. Those are the best but imo the TKinter parts in there aren't the greatest although you could probably get by with it. What are you wanting to learn Python for?
I have programmed in quite a few languages before, so to me they are all quite similar. I may not know the particulars of the language, but they are similar enough for similar language types hat I can usually just get going. Python is a imperative like OO language similar to quite a few currently being used. 
cool, thanks!
OK, edited my comment above. He is the author of Zine as well. That should make it clearer.
Not teach, but learn. By myself. Imagine I passed some basic courses and now I'd like to try some small (personal) priject. With some IDE. I'd probably end up with eclipse instead of PyCharm.. just because its license.
Which part of Chapter 9 are you stuck in? Guess It's the `*` and `**` part.
Yes, he does: http://www.jetbrains.com/company/people/Jemerov_Dmitry.html
aight thanks Ill look at them. ah, it just intrigues me and I just feel its right for me, I've grown up with computers my whole life
Recommendation: Try BlitzMax if you haven't already. For games etc it owns hard.
Wow.. slides, examples, exercises, and their solution, all in a straight-forward layout. This is really really great, thank you.
Dive into Python is great if you know another language. It's probably not the best if you don't know anything about programming.
And yet, you're only one step away from making those methods more pythonic and pre-2.4 compatible: `value = property(fget=getFoo, fset=setFoo)` Of course, later versions should use the @property decorator.
If you use version 2.7, there's a class for that in [the collections module](http://docs.python.org/library/collections.html#collections.Counter) import collections somelist = ["a", "a", "b", "b", "b"] value_count = collections.Counter(somelist) Then if you do `print value_count['a']`, it will output `2`. 
I haven't learnt it yet; see username.
unique = set(listofwords) for w in unique: print w, listofwords.count(w)
My boss gave me a simple python server app and told me to make it multi threaded and add a bunch of error checking and new features. It also needed to be done yesterday. I dealt with it and learned the language, but I'm currently looking for a new job.
Thank you for that cheatsheet and link to Google Code!
Had a similar experience in a class that taught different programming paradigms. Consisted of weekly assignments, where the language would change every couple weeks (Ocaml, Python, Prolog), accompanied by a brief tutorial on syntax. The rest we had to figure out. [edit] If anyone is interested, here are the assignments (4 and 6): http://cseweb.ucsd.edu/classes/wi08/cse130/assignments.html 
They are useful for putting lines together... i.e: import pdb;pdb.set_trace() that is the only reason they are allowed.
by accident; needed to get a job done and python was the quickest 
This is exactly what I'm going through now: http://www.reddit.com/r/Python/comments/e8fgt/proud_of_myself_but_i_still_feel_pretty_retired/
[PythonChallenge](http://www.pythonchallenge.com) After I solved the first 18 or so, I was surprisingly well versed in the basics of Python. Be sure to read the wiki after you solve each problem. Reading how other people solved the problems is just as helpful as solving the problem. Spoiler: you'll need to install the Python Image Library for several of the problems, and they don't tell you this in advance. It's pretty unfair to require an external library and not tell you.
Dictionaries in Python are collections of key-value pairs, which offer quick lookup of the value if you know the key. In a dict, the keys must at least be unique. We can use this fact to have a dict which has the word as the key, and the number of times it occurs as the value. &gt;&gt;&gt; words = ["Able", "Able", "Bravo", "Clock"] &gt;&gt;&gt; &gt;&gt;&gt; words_to_count_dict = {} &gt;&gt;&gt; for word in words: ... if word not in words_to_count_dict: ... words_to_count_dict[word] = 0 ... words_to_count_dict[word] = words_to_count_dict[word] + 1 ... &gt;&gt;&gt; print(words_to_count_dict) {'Bravo': 1, 'Able': 2, 'Clock': 1} 
Thanks for the update! Here are more tips: Consistent quoting, don't mix ' with " through out your code Use string formatting instead of string appending url = "http://www.reddit.com/user/"+user+"/"+item+".json" url = "http://www.reddit.com/user/%s/%s.json" % ( user, item) You can do better formatting with print by using string formatting instead of using the tab control character print("Subreddit\t\t\t% Activity") print("{0:30} {1}".format("Subreddit", "Activity")) You don't have to use the operator for sorting your dictionary, dictionaries have a get method, so you can use that for your key: percents = sorted(percents.iteritems(), key=operator.itemgetter(1)) percents = sorted(percents.iteritems(), key=percents.get) Don't use global variables.
I tend to use collections.defaultdict to save a few lines give or take. import collections words_to_count=collections.defaultdict(int) for i in words: words_to_count[i] += 1 
DISCLAIMER: I haven't "learned" python. I'm just getting started. I started with [Learn Python the Hard Way](http://www.learnpythonthehardway.org) and worked at that for a while until I found [Python Osmosis](http://python.sourcequench.org) by [Ryan Shea](http://www.reddit.com/user/ryanshea), which was great because it steps right through the tutorial in small segments. I made it through about 7 episodes of that before I decided to knuckle down and start a text-based adventure, and I posted my results here for feedback: http://www.reddit.com/r/learnprogramming/comments/e8fn5/proud_of_myself_but_i_still_feel_pretty_retired/ http://www.reddit.com/r/Python/comments/e8fgt/proud_of_myself_but_i_still_feel_pretty_retired/ Now I'm just working through the proposed fixes and hoping to build on the game after I use the feedback to get a better idea of what I'm doing. 
Needed to make some changes to a script in Blender. Ran with python for a few years, but mostly use Ruby now due to work. Still use it every now and again though.
The OP is perhaps unclear/unfamiliar with the built-in types that Python offers. I thought it more important to go through dicts first.
Google things like python +files. Python +http. That kind of thing. Wrote my first complete python script yesterday. Uploads my current home IP to my website. The Dyndns client just doesn't work 100% for me. Currently turning it into a daemon, and moving to email from scp.
man I wish there's python classes around here (and this is NYC metro!)
I'm 12 what is this?
I think that's about the only way that I am able to learn something new... Just *do* it and figure it out on the way. Python was my 5th programming language and ends up being the most useful to me. So, yeah. pick out a task, crank up Idle, and get to hacking ;)
was it ['A Byte of Python'](http://www.swaroopch.com/notes/Python) ?
When I do that, I always write a comment explaining why the code is so odd, or at the very least a `/* You are not expected to understand this */` I think if you write absurd code without acknowledging it with a comment, you either don't realise that your code is absurd, or you realise it's absurd and don't have the courtesy to warn others of what they're about to stumble into. In either case you would deserve to be on thedailywtf.
[The 2.7.1 changelog](http://svn.python.org/projects/python/tags/r271/Misc/NEWS) [A list of changes in 3.1.3](http://svn.python.org/projects/python/tags/r313/Misc/NEWS) 
O'Reilly just released a Python version of their well-known, newbie-friendly "Head First" book series. A lot of newbies really love the Head First books. They are an enjoyable read, and a good compliment to the more traditional, dry technical books (which I love, but even still, a different tone and perspective is great).
There is a "vi" program that is very vim like, but rather limited. It gives you a false impression of running vim. It's a rather unsettling experience.
Thanks, this site looks very useful! Have an upvote. =)
From the Django tutorial. Granted, I didn't really get what was going on for a lot of it for quite some time. Then I took a self-paced, self-study course in Python, and lastly I took a course in data structures and algorithms which, although taught in Java, cleared up a lot of stuff that I didn't really get before.
lol
It sounds like we are very similar. I programmed for years in every flavor of BASIC before giving up coding completely about 10 years ago. Since that time, I have tried over and over again to get back into it, but lost the spark completely. Just a few weeks ago, I found Learn Python the Hard Way and I was instantly surprised at how excited I was to be coding again. The book starts of very basic, but I forced myself through it and came out the other side excited again. I find myself reading everything I can now and thinking about new tricks.
Unless you require a specific python version, `#!/usr/bin/env python` is the best shebang line to use.
Oh wow I guess it was! I had heard of this since reading the guide, but never put the two together. Thanks!
Put all your root level code into a `main(argv)` function, substituting `argv` in place of `sys.argv`. At the end of the script call it like this: if __name__ == '__main__': sys.exit(main(sys.argv))
RabbitMQ/Celery is so easy to set up that this is simply garbage. Please don't do this.
Here, I created a new version with the changes I suggested for you, I also created a github for it at https://github.com/sontek/redditor-stats, it has a command line and web based version and the library is re-usable so other people can create their own interfaces based on it: import urllib import json import time from collections import defaultdict def get_all_stats(username): comments = get_stats(username, 'comments') submitted = get_stats(username, 'submitted') data = dict(comments) data.update(submitted) return data def get_stats(username, api, last_fetch=None, after=None): """ api should be comments or submitted """ subreddits = defaultdict(int) url = 'http://www.reddit.com/user/%s/%s.json?count=100' % ( username, api) if after: url += '&amp;after=%s' % ( after ) if last_fetch: delta = time.time() - last_fetch # reddit requires us to wait 3 seconds per request if (delta &lt; 3): time.sleep((3 - delta)) json_data = json.loads(urllib.urlopen(url).read()) last_fetch = time.time() for item in json_data['data']['children']: subreddit = item['data']['subreddit'] subreddits[subreddit] += 1 if (json_data['data']['after'] != None): new_subreddits = get_stats(username, api, last_fetch=last_fetch, after=json_data['data']['after']) for k, v in new_subreddits.iteritems(): subreddits[k] += v return subreddits def get_percentages(username): subreddits = get_all_stats(username) total = sum(subreddits.values()) percents = {} for subreddit in subreddits: hits = subreddits[subreddit] percents[subreddit] = round((float(subreddits[subreddit])/total * 100), 2) return (sorted(percents.items(), key=lambda t: t[1], reverse=True), total) 
Making programs with it?
For me, I've always jumped into a project. If you have an interest in web development, I'd check out the [Django Book](http://www.djangobook.com/). Granted, it will teach you django, it's a decent step to getting an app off the ground and being able to test some of those skills you're developing. After that, I'd start working on some desktop applications. One thing I've noticed about myself is that doing garners far quicker learning and stronger understanding than reading. I'd suggest that you read about the field you're interested in (audio/audio plugins) and develop smaller tools in python. Once you hit a certain point (to be determined by you -- a level of comfort with the language), make a project related to your field of interest. Make that project a little beyond your current reach to ensure that you'll continue to learn while working on it. After that's done, set the bar a little higher each time. And enjoy. Don't forget that last part. It's the most important. :)
May I ask what is good about this instead of using import ipdb;ipdb.set_trace() ?
 from itertools import groupby for item, seq in groupby(sorted(items)): print item, len(seq) 
If you don't like PIL, check out cairo
Excellent! Much appreciated. 
A simpler variation of your idea: counts = dict((w, listofwords.count(w)) for w in set(listofwords))
thanks and congratulations to all the people involved.
First off, let me start by saying that exercise is probably one of the best ways to take care of your body -- it's one of the best investments you can put into yourself. Sedentary living is one of the biggest health risks to US residents. However, excercise is not a means to loose weight. Excercise will simply make you hungrier and give you a false impression of doing something healthy for you. That one hour jog you did on the treadmill seems impressive until you realize that you just barely expanded the energy provided by two cans of soda. Another thing to keep in mind. All sorts of health factors like cholesterol and blood pressure will improve as you loose weight. So if you're overweight and start on a diet, any diet (including the twinkie diet) that causes you to loose weight, all of your "indicators" will improve. However, as you approach your ideal weight, you may have to look more closely at factors like sodium intake. The main point is that, in the pursuit of loosing weight, portion control, and more specifically, calorie count, is king. Consume less calories than you expend, and you will loose weight. Your first step is to keep some sort of food journal to track your caloric intake. Sites like fitday.com and fatsecret.com (and to a lesser extent, weightwatchers.com) help you with this by maintaining nutrition information on popular foods. Plug in something like McDonald's medium fries and it plugs in the calories for you. I'm not sure about fitday.com, but fatsecret (which is what I use) has an android app you can use to enter foodstuffs consumed. At a bare minimum, you can use a pen and paper to track your food + calorie consumption. The fatsecret site has a calculator to determine your calorie expenditure based on height + weight. The default exercise is 16 hours resting and 8 hours sleeping. Put in two hours on the treadmill and subtract 2 hours from resting. Most people expend between 2000 and 2500 calories daily, so to loose weight, you want to go below that, say 1800. Start by tracking your calories, then modify your diet to put you below it. You'll be surprised how many calories some foods contain. I've started a "soup diet" trend at work. Basically, find the healthiest soup you enjoy eating (for me, it's the Campbell's Select harvest chicken and brown rice), add some low-sodium crackers, and make that your meal. For me, I found I'm very good during my workweek. I stick with the soup and something fast food during the day and keep around 1200 calories. Then on my transition day where I go from my nightshift to being off (and awake during the day), I tend to only sleep 4 hours and find I eat well over 2000 calories. The rest of the weekend is hit or miss, but I try to keep it around 1800. However, I find that I often still exceed the 2300 mark during my days off. Also, you might want to google "the hacker's diet". It didn't stick for me, but has a lot of good information. tl;dr: excercise: good, portion/calorie control: essential to weight loss. Another note: per your original question, others have mentioned the treadmill desk. Until I moved (and no longer have room for it) I used a [mini-excercise bike](http://www.amazon.com/Magnetrainer-Extended-Range-Mini-Exercise/dp/B000V53KD8/ref=sr_1_1?ie=UTF8&amp;qid=1290927159&amp;sr=8-1) so that I could pedal while on the computer. I had modified my chair to hold my keyboard higher than my knees would rise. Simpler people sit at an angle. Another technique I use for recreational reading (not learning programming) is my droid-x and a treadmill. I read World War Z for 3 hours doing a brisk walk on a treadmill. 
I'd just like to point out that gedit has a terminal plugin. Kate's cool and all, but it and gedit are on equal ground in terms of that particular feature.
I'm learning it now. Just browsed through the python documentation on docs.python.org. I'm pretty fluent in C++, Java, VB.NET, C# so python wasn't a huge jump for me. I'm learning pygame right now which is really fun for my game programming itch. 
[Gedit Plugins](http://live.gnome.org/Gedit/Plugins) Of especial note is the Python Indentation plugin, though you might find others that you like as well.
The count=100 doesn't seem to do anything for me.
Yeah, I can't find any documentation on it... Need to look through their code. They definitely accept the count argument but don't seem to be willing to take anything over 25.
I don't know of any written stuff but these are awesome: http://www.youtube.com/user/ryanmshea
 def collect(counts, item): if not counts.has_key(item): counts[item] = 0 counts[item] += 1 return counts counts = reduce(collect, ["Able", "Able", "Bravo", "Clock"], {}) I think
upvote for using itertools
[Scribes](http://scribes.sourceforge.net/). Install on Ubuntu like so: sudo add-apt-repository ppa:mystilleef/scribes-daily sudo apt-get update sudo apt-get install scribes Although it can be used as a Notepad-alternative, it's far more powerful than Notepad. 
So, I wonder when there will be more pressure to upgrade to Python 3. Maybe when some frameworks port their code to it?
Probably when Unladen Swallow gets [merged](http://www.python.org/dev/peps/pep-3146/). It's supposed to happen for v3.3, at least according to the PEP. I'm still more in favour of PyPy than Unladen Swallow, but a JIT compiler is a pretty nice upgrade incentive, regardless of which they choose to make official.
I'm the development lead of PyCharm.
learning python by mark lutz
Took a course in algorithms, implemented most of the "standard" famous CS algorithms (Dijkstra etc) in python, never looked back. 
comes a bit unexpected for me, i suppose i will have to deepen my knowdegde on the tracing is the difference running in a module globals and function locals by chance
Same result, you shouldn't use an IDE to learn a language, let alone programming. Which is why Java is an utterly terrible learning language (and language to learn, unless you're already well-versed in languages in which case it's just a terrible language): its verbosity (and the number of files you have to deal with at all time) makes it very hard to write using a basic text editor (syntax highlighting and nothing else).
True, it's not exactly the fastest way. How about doing the four corners of the square demarcating the "plot of land" first and then constructing the above-mentioned "very fine redular grid" recursively by always taking one (sub-)square and dividing it up into four squares, giving you five new grid points? You could stop iterating at every square that has the same result (inside or outside) for all of its four corners. You could still compute the grid points contained inside for any iteration depth (while, of course, iterating breadth first) without actually counting them one by one and doing all these superfluous tests that probably involve a square root. This should speed things up significantly; you'd get a sort of quadtree describing the (quarter-)circle at the finest grid resolution your program can reach (which should be bounded only by computation time when you do it right), while skipping a huge majority of all grid points under consideration. This algorithm wouldn't need a random number generator (pseudo or not) either. It's still a bit tricky to figure out to how many digits you've already computed pi accurately, though.
Emacs can be a text based general purpose interface... with a editor you say is bad (I say it's the best) but VIM is just a bad editor! So emacs wins! 
[Your argument is invalid](http://weedoom.com/wp-content/uploads/2010/01/i-am-ironing-a-kitten-your-argument-is-invalid.jpg) &amp;#3232;_&amp;#3232; 
Actually, I think Ubuntu has vim-tiny installed by default. It's like a very stripped-down version of vim which mostly has just the vi features.
Didn't know that--thanks!
Using dict.get(key[, default]) avoids having to check if get dict has a value for the key already: def collect(counts, item): counts[item] = counts.get(item, 0) + 1 return counts counts = reduce(collect, ["Able", "Able", "Bravo", "Clock"], {})
FWIW, in the article you write: &gt; Eventually I switched to lxml, which uses ElementTree That's incorrect. lxml implements (and extends) the ElementTree API, at no point does lxml use xml.etree.ElementTree (which is the actual ElementTree, and part of the standard library since 2.5 or something). Even if you don't go with a third-party library, there is no reason (and no excuse) for using minidom.
It is proven that human brains are not capable of multitasking. When you do two things at a time you don't share your brain ressource 50/50, but its like yout capacity for both things drops to 20% or so... just don't do it. You will maybe be able to do may things. But you will suck at all of them.
It still involves (1) installing Erlang, (2) installing rabbitmq and Celery, (3) getting client libraries in python (4) then coding in python client etc etc. For really small team, learning rabbitmq/celery+client libraries, and maintaining the setups in different technlogies etc is an overhead. However, I do agree that 'really simple queue' it is not a 'long term' good solution. For short term, it gets the job done. 
Why would you build setuptools using distribute? 
Ordered dictionaries!
&gt;It still involves (1) installing Erlang, sudo apt-get install rabbitmq-server (for instance) installs erlang and rabbitmq. &gt;(2) installing rabbitmq and Celery, sudo easy_install celery django-celery &gt;(3) getting client libraries in python Celery is the client library. &gt;(4) then coding in python client etc etc. I'm working on a bookgroup site. Here's a snippet from my code. worker side: @task(name='book_discussion_started') def book_discussion_started(group_id, **kwargs): logger = book_discussion_started.get_logger(**kwargs) logger.warning("Sending discussion start emails for group_id %s" % group_id) group = BookGroup.objects.get(pk=group_id) .... web side: book_discussion_started.delay(group.pk) &gt;For really small team, learning rabbitmq/celery+client libraries, and maintaining the setups in different technlogies etc is an overhead. I'm a one-person team. Read the celery docs. They're good and easy to figure out. It's not hard. &gt;However, I do agree that 'really simple queue' it is not a 'long term' good solution. For short term, it gets the job done. Why blog about and submit your short-term hacks? Especially one that could have been avoided in less time that it probably took you to write your blog post. I'm sorry to be harsh but someday someone is going to find what you wrote and think, "Hey I should do this!"
Make a set out of your unique list. Iterate over the set *but* count the occurences in unique list. That should probably be simplest. # e.g., for uitem in set(ulist): print uitem, ulist.count(uitem) If your source is a file, you can read and split that file up into a list.
I'd love to move to Python 3 but there are some serious day-to-day tools that are not supported. For a long time setuptools was one (but thanks to distribute this is now fixed) but there are still more: * virtualenv - I need this to keep my python libs sane and work on multiple projects. There is a virtualenv3, but I can't make it install. * PyPI (cheeseshop) needs to support Python3 in a sane way. Currently it will blindly download Py2 packages and fail There is so much good work being done on Python core, but movement on these supporting tools is going very slowly.
I'm 20 and in 3rd year elec engineering. I got obsessed with python after I saw an article or /r/programming recently. Since then, I've watched the Google python class videos (the alrighty guy is amazing) and basically used python.org documentation to learn python. Already knowing C helps with python SOOO much its amazing.
I had a lot of problems with some of the more specialized libraries ( like matplotlib and wxwidgets) my soultion was to use macports and always be certain that I had built with +universal . To deal with the 32/64 issue that still happens with wxwidgets I just made an alias (pop this line in your .bashrc). alias 32bitpy='export VERSIONER_PYTHON_PREFER_32_BIT=yes' alias 64bitpy='export VERSIONER_PYTHON_PREFER_32_BIT=no' then all I have to do to switch versions is type 32bitpy and any python interpreters launched from that shell will be 32 bit and type 64bitpy to switch it back or launch a new shell
 import sys try: &lt;your code here&gt; except: sys.exit('Handled exception')
and then play the gitarr
I would have to recommend [Learning Python](http://oreilly.com/catalog/9781565924642) as the second Python book. The book might be a bit advanced (esp if Python is your first language), but its extremely well written imo, and an excellent reference. As for webapps, I would say that django is great for learning about MVC, and the django book is a good read, but I wouldn't expect to learn much about Python itself from django. Django is large enough that the book almost gives the impression that django is distinct from Python. If I were you, I would read Learning Python, and simultaneously play around with [Flask](http://flask.pocoo.org/), a very basic (and therefore adaptable and powerful) webapp framework.
Be careful with the +universal variant on mathematical based libraries. Many of them link to Atlas, which does not build universal. *edit* This includes a lot of the python numerical libraries.
this is exactly what I typed out. this is how I would definitely do it. I love python sets :D oh, and I just had to do this for a project euler problem involving number of divisors and prime factors.
&gt; The one thing that really grinds my gears is that its impossible to install things like matplotlib and scipy on a mac and keep all of the python versions in check. (Yes I have tried easy_install and macports) From where does the impossibility come from? I use macports for off the cuff scripts. If I'm developing for the Mac platform specifically (e.g. PyObjc) where using a "vanilla" interpreter is highly advisable for consistency, I include the 3rd party packages in my distribution. &gt; Dear internet, how do you cope with having to install python libraries on a mac? Primarily macports and/or virtualenv (for project level management) &gt; Do you guys have any suggestions for how I could use pyspread with Enthought 64bit or how I could change back to 32bit? Personally, I prefer a package manager that lets me keep current while maintaining multiple versions. However, there shouldn't be anything preventing you from installing both and switching when needed. 
To me, script does not mean interpreted, it means a straight-up procedural task....Do this, then this, etc, done. At some point of interactivity and complexity, I just call it a program. But that's me.
Hmm, I rarely ever make make my Python code procedural
A script is a program you start, it does its thing and ends. If it's larger with a GUI or web interface and does something for a user, it's an application. If it's to be used in another program, it's a library. They're all programs.
[Functional](http://en.wikipedia.org/wiki/Racket_\(programming_language\))?
The link for the 64 bit Windows version of 2.7.1 is broken. Here's the correct one: http://www.python.org/ftp/python/2.7.1/python-2.7.1.amd64.msi
Thank you :)
My pressure came when arch linux moved to use python 3 by default and I'm thankful for that :) There's still python 2.7 for apps that don't support it yet.
If you're doing this and want to get familiar with the Python stdlib, check out Doug Hellman's [Python Module of the Week](http://www.doughellmann.com/PyMOTW/).
thanks for the tip.
This certainly explains a lot. Upvote for you
In my opinion, "script" means interpreted, like on the TV shows. If it is not interpreted, I would say "program".
My solution is not really a solution: I keep a virtual machine with Ubuntu for development, and use my mac for everyday usage. 
It does. "Applications | Accessories | Text Editor" launches gedit, the default text editor on the gnome desktop.
tl;dr Because "despite all the hubbub around Ruby, no one is crunching numbers with it!" and he wants the power of SciPy and NumPy and PyBrain
&gt; virtualenv - I need this to keep my python libs sane and work on multiple projects. There is a virtualenv3, but I can't make it install. Try [virtualenv5](http://code.activestate.com/pypm/virtualenv5/). &gt; PyPI (cheeseshop) needs to support Python3 in a sane way. Currently it will blindly download Py2 packages and fail Try ActivePython's [PyPM](http://code.activestate.com/pypm/tag:python3/) -- which uses the `Python 3` classifier to identify packages supporting Python 3 (with custom patching as not all package authors respect this classifier convention).
I'm also surprised how hard it was to get matplotlib working. I use 32 bit enthought for general dev. I'll probably install 64 bit in a Linux vm if I need it. At the moment 32bit performance isn't hurting me for the trouble of configuring matplotlib with Tk,
Funny, my shorter Python programs are 90% procedural. Only data with a lot of structure and functions working on it is made into classes, and I use the "functional style" only for isolated tidbits. 
once you delve into things like numpy/matplotlib and non pyobjc, python on mac gets really tricky. At first I went - great everything works. Then the more complicated my app got, the less it worked on the mac - worked fine on ubuntu and windows though... sigh...
I apologize for slight detour... This article reminded me of something I have realized about Java: the language is built to enable people, who are not able of fit to program, program. It casts you into a rigid world: locks you into metaphorical shackles and does not allow you to stray from The Path. And the trick works, I think. It suits the mentality of larger companies too. In that respect, Java is antithesis to C, which lets you write practically anything and it's your problem when it does not work out as intended. With Python and Ruby we get some of the both worlds: we get less shackles and less control, yet we can be productive if we have the brains. That's why I'm a reader here.
&gt; I was physically shocked when I first learned how to read files in Ruby. Key quote. This guy thought that Java's way to read files was natural. By teaching Java as a first language to undergrads, we are making them dumber.
yeah, kinda that, I worked on it one day and I think I GPRS it, but justmoat stuff on that and upcoming chapters
If you are not a VIM user, keep using ipdb. If you are a VIM user, vimpdb's main advantage is the ability to debug with full context, iow full file. Further, when debugging code, vimpdb loads all files in its buffers. If you need to modify code after debugging, all identifiers are then available to VIM for completion.
and also preparing them for the real world where quality developers are few and far between
Christ. I've been a "All languages are just tools, we should all get along" guy long enough. I hate this "Ruby is more beautiful than Python" bullshit. These Ruby twits think they get to just state that like it's a won argument. Want to make a Ruby programmer angry ask him, "What's with all the 'end's?" Ruby has more candy, that's all. You might get lured into it with blocks and screen-casts and pretty names like "gem", and "ruby", but it's all superficial garbage. The author is on his way to realizing that Python is a tried and test language that hits a sweet spot with pragmatism and intellectualism. It's a hearty meal of protein and fiber, and won't rot your teeth. In the end, I'm glad Ruby has helped give credit to the new era of dynamic languages, and I'm glad Python has something to compete against, but most of all I'm glad the bright, audacious lights of the Ruby community distract the children away from the adult pool.
... because we teach Java as a first language. 
What are Zathras'?
which is different from teaching
&gt;Ruby showed me a new way. Instead of implementing endless loops to work through data, Ruby showed me I could outsource those loops to its runtime. That is, all Ruby needs me to tell it is a list and a function. In turn, it will run that function on every item in my list. It can slice and dice a list with that function, or it could give me a new list derived from each element in the old one. The point is that instead of demanding trite details and edge cases (think C-style for loops), Ruby only asks for broad instructions. Just to make a point, I'm pretty sure that Java has list comprehensions. So yeah, you can do this in Java.. I think edit: By Jove, he's right. It doesn't. That's horrible, the one thing I like about C# these days is LINQ. I wonder which language I was thinking of..!? edit2: jesus christ this is bothering me.. I *swear* java has list comprehensions... I'm so sure I remember using them... 
Why not bridge python and ruby
 I think you'd find it's much harder to produce something in Java than in languages such as Python or Ruby. If you're arguing that it's easier for anyone to do the same task in Java, you'd be arguing FOR the language. I've found that Python is much more approachable than Java for beginners. Java simply makes it more difficult to write GOOD programs quickly. It's a hindrance to skilled hackers and newcomers alike. Java has many, many ways to solve an issue, and most of the solutions are poor and verbose. The language would do well to have these shackles you speak of. If everyone was writing in Python, the cruddy developers would still be there. May I remind you of PEP 20: "There should be one-- and preferably only one --obvious way to do it."
It really wouldn't matter what language you first taught them on. If a CS student is unable and unwilling to learn other languages in their own time, they're never going to be a quality developer.
you're an "All languages are just tools, we should all get along" guy and yet you just went on a tirade against ruby, including another comment against ruby in the /r/programming cross-post? somehow i don't believe you...
I'm sorry if I wasn't clear: I meant that I have been a "All languages are just tools, we should all get along," kind of guy for a long while now, but am finished with it. This post has, for some reason, drawn the animosity out of me, probably because of the intense backhanded nature of it.
The whole thesis of python and similar languages is that language choice matters. Why would that stop when you teach? I submit to you that teaching a different language would encourage more exploration.
I have never had it be slower than eclipse. Wow, I just can't fathom that. However, have you tried the newest version? They updated its whole foundation and change a few things around. K6 is just a wee bit faster now.
CS students have computers. If they aren't going to spend their spare time learning about CS and other languages on their own, they will *never* be a good dev., curriculum be damned. That's not to say you can't pique the interest of those that are inherently not programmers (most CS students), but that will simply result in an adequate developer. Good programmers gain most of their knowledge and experience outside of the classroom and continue their education in their spare time indefinitely.
I forced myself to write scrips in python. It was slow going at first and a little odd because it was different than what I was used to. But once I got over the hump of writing a few scripts I soon realized what the Pythonic thing was all about. From the very first concepts I learned, Python thought me how to think in a *pythonic* way. Xoon after everything just worked the way I thought it should work. And the speed at which I learned all the features of the language to write more advanced programs increased exponentially. It helps a ton that Python has an extensive list of libraries and there is almost no task you can't do with it. Just last week I wrote a test script that simulated 40K comet/long pool connections, using Eventlet. It never stops to amaze me all the things that are possible.
http://rosettacode.org/wiki/Category:Python http://en.literateprograms.org/Category:Programming_language:Python
[Parrot VM](http://www.parrot.org/) is trying to do that. 
ahh ok. makes more sense now. carry on then :)
To be fair, all languages *are* just tools. I never really *got* Ruby. It's like Python, but more perlesque (how is that good?) and more focused on web dev or something? I can understand if you think Ruby is given more than it's due, but there are still situations where another language might be more applicable than Python.
This was the main reason I made the exact same move. Ruby's not ready for science (library wise).
Java doesn't even have delegates.
I think you misunderstood irve's point.
It has an each loop that loops over collections, that's probably what you're thinking of. Something like for(Object o : list) {
Absolutely, but teaching the bad programmers about tools that make either doing it wrong harder, or how to solve a harder problems more easily stated (ie expressiveness) so that while they may not really get whats going on, the uncreative replication of that solution can be done by a larger pool of people. Some where in my argument is the reason that the mean iq is always going up, its not really that people are smarter, its that we can express harder ideas in a way that a larger pool of people can grasp.
I would come up with a project that interests you in some way. Take your time and plan it out, maybe make some diagrams. Then try to implement it. 
Contact a lawyer ... But from my limited understanding of the GPL, you would indeed be forced to open source your program, as it would be considered the same thing as "linking" against it.
Java examples in the post are strikingly incorrect...
PySide under the LGPL might be a better option, or you could buy a commercial licence to PyQT. http://www.riverbankcomputing.co.uk/commercial/buy Edit: Also, talk to a lawyer
I'd like to know: what's the substantive difference between teaching Java as a first language vs. teaching Cobol as a first language? Yeah, nothing's really changed then, has it? The CS guys will stick to assembler, C, and maybe C++ if they're feeling all fancy. Otherwise, what we're talking about is languages for building business applications which, don't get me wrong, is an important niche; but doesn't require real CS per se.
As a ruby developer, I can tell you this is totally true. You'd end up writing C bindings to libraries. SciPy is better.
I bought a macbook thinking I'd get the benefits of OSX (Photoshop, iMovie, Office) and the benefits of Linux (good terminal, gnu tools, etc) but realized shortly that OSX wasn't a good development OS and now dual boot OSX and Linux, rarely ever go into OSX.
Scala, a language based on the JVM, does. But it is *not* java.
I think pyQt has (via Qt) an exception for specific circumstances. EDIT: here are the exceptions. It pretty much just means "you can release it under other open-source licenses" http://doc.trolltech.com/4.4/license-gpl-exceptions.html However... when you say it isn't for your personal use, what **is** the use-case, and who are you trying to avoid releasing the source to? You only have to give the source code to your users; you don't have to publish it far and wide just because one company somewhere has it running on a server, if that's what you mean
Haskell is more beautiful than both, and has much better performance too. 
It's for university researchers (and part of my honours) and will be used by them in several projects and possibly as part of a much larger program/project incorporating web interaction with the public and tourists. I think the best move might be to try one of the other popular GUI's that I know won't have any problems with, like wxPython.
so... you don't want to release the source code to the researchers? why? edit: as someone else said, also check out http://www.pyside.org/ which is LGPL python bindings for Qt
No, the researchers I'm working with get the source code, I don't want them to be forced into having to release the source code if they don't wish too for whatever reason. The code I'm making is basically theirs. 
Just because all languages are tools doesn't mean that there aren't serious flaws in them. The idea that a programmer ought to use the right tool for the job in no way implies that she should choose a substandard tool. I think the real problem is that we aren't making this important distinction: therefore, it seems that you're still that guy, just with an opinion on the quality of the tools you use.
Here are a couple sources: http://learnpythonthehardway.org/index http://inventwithpython.com/blog/
This may be a bit out of the blue, but I'm currently looking into programming as a hobby, if you will. I've got loads of time to kill, so I might as well be constructive about it. But there is a problem. There are so many programming languages, I don't know which one to begin with. **Which language should I start learning as a beginner with no programming experience?** I'm looking at Python now, but should I start with Visual Basic or even Ruby?
forced to give it to who? being python, anyone running your software already has your source code. I'm probably being really dim, but who are you trying to prevent having access to your source code, and what access do they have to your program?
You could just [buy](http://www.riverbankcomputing.co.uk/commercial/buy) a PyQt commercial license for £350 and do whatever you want. 
I kind of like the 'end's myself :/ Each to his own.
That said, my university used Pascal before they used Java. I'm not even sure reading files was possible in standard Pascal, or if you needed nonstandard extensions for that... (personally I loved it, having programmed in Turbo Pascal 4 during high school -- although that was a much better language than the Pascal version the university had on their HPUX machines)
IANAL so you should contact one... The bottom line for GPL software is that the intended USERS of the software has access to the source code. That doesn't meant ANYONE. For example, if you are releasing a product internal to your company that is based on GPL software, you need to comply with requests for the source code. However, if the software is not released outside of the company, you do not need to make the source code available outside the company. Basically, the intended users need to be able to request and then receive the source code.
&gt; This article reminded me of something I have realized about Java: the language is built to enable people, who are not able of fit to program, program. Quite the contrary. That's the niche of things like Logo. Java is a language designed for The Enterprise, where every program ever is going to turn into a 100,000 line monster and some extra lines in a small program aren't going to matter.
The solution that Java people seem to have come up with is "here, have an IDE that generates all of this damned boilerplate code for you". Not exactly satisfying.
That's a nice listing of the essence of tools you should probably use. However, I miss virtualenvwrapper :-) http://www.markus-gattol.name/ws/python.html#virtualenvwrapper
Also, let's not forget woven: http://packages.python.org/woven/
No... actually I gave up on it completely to cut losses about 9 months ago. At that point only the Windows version was bearable and I don't use Windows outside of work. I tried Wing back then (free version) and just switched to that. It's a bit like my little Android trauma, I had an absolutely horrid experience and it will take a while until I spend that kind of money in an IDE.
Hey! Auto-generated code, auto-formatted, auto-cleaned and auto-fixed code IS satisfying. Although, a language which did not require auto-anything to be pleasant to code in would be even more satisfying... I get your point :/
You have no problem then. The GPL only forces you to offer the source code to whoever receives your program, not to the public at large. 
You can use pydev in Eclipse: [Pydev](http://pydev.org/) It works well, and you don't have to give up the bling. 
I would suggest trying [Aptana Studio 3 Beta](http://aptana.com/). It is based on Eclipse but it does not feel too bloaty and it has a nice Python development environment. [NetBeans](http://netbeans.org/) is also pretty good, but it is also written in Java.
I can recommend to you Pycharm. 
Vim. Fast and always available.
Great stuff! Is it fairly bug free?
Being written in Java doesn't mean it's bad though does it ;)
yes it does lol edit: Komodo Edit +1
it's fine. it's great, in fact. I used to hate Eclipse - like, *really* hate it. I tried every other python IDE I could find before giving in to eclipse with pydev, and i've never looked back. It's great.
What you say is true. So don't worry about having to publish the code to everyone if the program is only given to the researchers. However, you have to keep in mind that by choosing a GPL library for your program, you bind the researchers to it. So even if you give them the copyright to your code, they still have to follow GPL rules, which means that if they ever want to distribute the binaries to the general public they *will* have to distribute it with the source code.
Emacs. 
You are right: I didn't want say that Java is an entry level language. I consider Java a language which is so strict that you can get an arbitrary number of code-monkeys and still produce some monster which works.
I confirm that PyDev and Eclipse is a great big Python IDE. For fast and small Python programs I recommend Komodo Edit.
Realisation of the hype that's Ruby takes such a long article? I'm sure he had fun writing it though.
It's like decorators, only the entire language is like that.
There were a lot of thread in /r/python about PyCharm, but it isn't free. On the free side, I would recommend [Komodo Edit](http://www.activestate.com/komodo-edit) (also good as general purpose text editor), or Eclipse with PyDev.
For more info, see [this issue](http://bugs.python.org/issue10518) in the bug tracker.
Netbeans is pretty good. And there is also eric: http://eric-ide.python-projects.org/
What it means is that performance is poor. When starting pycharm for example you can literally see the GUI elements loading and building up. It doesn't make me any less productive with it so I don't see it as a fatal flaw.
I use Emacs.
I am not sure that integrated development environment like Eclipse is really needed for Python programming… I’ve programming in Python with Vim. How about trying Vim or Emacs?
At that point, they can buy a commercial license for PyQt. 
+1 netbeans. I'm a massive fanboy, it makes Aptana look like dogshit. I would try vim but I lack the e-balls.
Pydev is almost perfect.
While Netbeans is good for Java development, I'm sorry to say that its Python support has fallen by the wayside some time ago. If you're coming from Eclipse, PyDev is the way to go; there'll be less for you to learn.
pydev
Well good article shouldn't give examples that won't run. First snippet has main function without String[] argument, this is not recognized by Java. Second Java snippet is completely broken. For example FileInputStream.read() returns integer, not string. If you want to read strings from file you should use FileReader, and you can pass it file name as a string. FileReader fileReader = new FileReader("my-file.txt"); BufferedReader reader = new BufferedReader(fileReader); reader.readLine(); I stopped reading after that.
Admittedly I liked pydev, though I would often get crashes. So I switched to Netbeans for python development. They likely fixed their bugs but I had already learnt the shortcuts + quirks for netbeans. It's pretty nice for dev.
This is Django specific tool. Not in context.
You can do almost everything from that list with VIM in half the time. You just have to configure VIM properly and add some plugins. I've been IDE guy myself in the past, but since I switched to VIM, i haven't installed/run any other Editor/ide, and I'm not missing any functionality.
I agree Netbeans isn't bad, but if you look at recent releases you'll see that Python gets little or no love compared to Ruby, say. And the OP is *already* familiar with Eclipse. I use Netbeans 6.9.1 for Java development (I find I prefer Netbeans for Java GUI development using Swing), and have tried both Netbeans &amp; Eclipse for Python development (as well as PyCharm, which is very good, except for wanting lots and lots of memory).
The official python docs! They are great. Sadly, they contain few examples, but the docs is easy to read, always up to date and they are easy to find. Want to find out which methods the random module has? "python random" in the adress bar and you'll find the [answer](http://docs.python.org/library/random.html) in seconds. This was how I learned Python: I had done some C++ and a tiny amount of Lua before, but most of it came from simply reading the docs over and over again.
PyCharm is the best. It's not free, but it makes perfect sense to pay for quality software. The price is reasonable too. ( Sidenote: IntelliJ IDEA is the best too :p ) 
&gt; I mean, I expected C dependencies, sure. I would hate to do math without them. But FORTRAN? Is the extra speed really worth the complication? This article was a bore, but he really lost me with this statement. He obviously doesn't understand the underpinnings of most math software. LAPACK and BLAS, the heavy lifting libraries underneath the easy-to-use NumPy, are indeed written in Fortran. If Ruby had a NumPy equivalent, it would require a Fortran compiler as well because they would most assuredly require BLAS and LAPACK.
Look, there are some programmers whose portfolio is fluorescent green on black. Others understand the importance of aesthetics. Python is older and has much better libraries right now. But as a user of both, I firmly believe Ruby has more potential.
I use [wingide](http://www.wingide.com/). It's not free but its worth a try. The support is worth the price. 
Awesome, thanks. This was one Py3k change that made no sense to me.
That would be a bit inefficient for large lists since the worst case for each unique item might be ending up traversing the entire list.
When I think of VIM I think of a crummy text-editor which old school *nix dudes refuse to abandon (I use Nano to edit files). So my prejudice is that with addons, that's just another gazillion key-commands you need to know to be able to accomplish anything. I'm guessing I'm wrong here?
My first thought as well. I use this a lot. The only thing to watch out for with defaultdict is that if you later try words_to_count_dict["Door"] but you have never seen "Door", it will return a 0 and "Door" will now be a key in your dictionary with a value of 0. When extra unintended keys like that are an issue for me, I make the defaultdict with a small object that has a bool attribute that I set to True if it is real and test it whenever querying all the keys in the dictionary.
I can't say I've ever used this function.
Honest question... Why do you have to pass self into every method of a class? Should the class not be self-aware? am I missing something?
My previous experiences with those have been less than pleasant. I found Vim annoying (with Nano doing what I wanted/expected) and Emacs to be something of a brain-overload. Could be that I've only done it wrong though. Coding without an IDE, I really miss code-completion. Don't you?
Maybe videos from http://vimcasts.org/ might help you convince yourself.
TIL
Aptana is based on Eclipse and pyDev (and some other web-related things). I've moved from Eclipse and pretty happy with it (thanks to built-in sync tools, among other goodness)
So... no one uses buildout?
[Ropevim](http://rope.sourceforge.net/ropevim.html) does basically everything that you mentioned that Eclipse does but Vim doesn't, at least for Python. [Eclim](http://eclim.org/) can be used for other languages (and Python as well, if you prefer).
Well, for Java development, it is completely unmatched in my experience. Its code-completion, auto-generation and refactoring are incredibly powerful. Other IDEs might have caught up with these functions though.
Yeah, removing it makes no sense whatsoever. 
I've used it a few times (didn't realize it was gone), but now that I think about it, I probably don't need it.
Too risky. If you'd seen more sci-fi movies you'd know that the instant a computer program becomes "self-aware" its first order of business will be to exterminate the human race.
All they can do is read it. Being able to read -- as in the basic meaning of the word "read" -- is very different from being *licensed* to read, modify, distribute, or whatever a given project's license gives you permission to do.
This will be very slow on large datasets though, since it's O(n^2) (or more accurately, O(n*m) where m is the number of unique words). That count() call is iterating through the entire list each time for every item in the set.
I really like Wing IDE. It works on many platforms and shows you the docstrings of functions you are typing most of the time, which is really helpful. The Debug features also work quite well. There is an (infinite) 30 day trial mode, you should check it out.
What's so great about fabric? Why would I want to use it over shell scripts?
The benefits are that it's obvious where ``self`` is coming from, what its scope is and why ``AClass.some_method(instance, args)`` is the same as ``instance.some_method(args)`` which BTW is key to multiple inheritance working properly. A smart editor should help you out with such boilerplate - at least this boilerplate *aids* readability rather than hurt it.
`Scanner` would contribute to even more concise code. :-)
In Gnome, you could use its default editor Gedit. There are several extensions that add IDE-like functionality (code-folding, class-browser, code-completion, ...). And you can write your own extensions in Python.
LOL sounds like name of a porn star
I dont have any problems with performance at all since almost all cpus nowadays have opcodes for VMs, however I don't do any numerics so you should just test it for yourself. Using a VM if far better a solution I think. Speed loss is minimal and the added flexibility of having snapshots and different VMs for different stuff is far better. My host OS is Windows 7 and guest OS is Ubuntu LTS atm although I think thats not important since I can change/snapshot at will.
If you're fed up with bloat, it's probably a good idea to get away from IDEs altogether. The reason they're not integral to python development like in Java is that you can develop code in the ipython REPL and copy it to the editor when you've already run it. You can also change methods on classes without even losing the objects you've already created. It's a completely different approach and Eclipse/Vim are the tools most python programmers find compatible.
I was originally the maintainer for an ETL system written in PHP, causing me serious emotional trauma due to memory leaks, resource handles disappearing, and an utter lack of real exception control. I picked up Python as recommended by a co-worker. End result, the new ETL system handled 10x as much data, took less ram, was easier to maintain, and finished a cycle around the same time as the PHP platform did.
ipython REPL, is that something along the lines of the 'irb' shell for Ruby?
Better yet: Pydev + Eclipse + Vrapper = Best of all worlds. Vrapper is my favorite because it allows you to Vim INSIDE Eclipse's IDE, instead of popping up a new Vim window inside your Eclipse.
Indeed, it's all code. It gets especially difficult to differentiate when you're writing extensions in C or C++, which may or may not be visible outside of a particular interpreter instance. The simple solution is to just refer to it as a program, and let someone else quibble about the semantics. :D
With IDEs you constantly move around the keyboard and reach for the mouse. With vim, moving away from home row is minimal next to nothing.
VIM is absolutely great. A solid vimrc file will own a lot of big time IDEs.
I only have Pydiction plugin, which looks something like [this](http://rkulla.com/images/screenshots/pydiction1.jpg), and it's kind of handy. But I don't really "code" - I just use vim for small scripts I need sometimes.
old dead functions climbing up from grave, next episode of Supernatural?
I'd recommend using a straight text editor (Emacs, vim, textmate, notepad++, gedit, etc..). I think the great thing about python is I can keep it in my head. I don't really need an IDE to do everything for me like in java. 
Yes. REPL is read-eval-print-loop, probably a Lisp term first. It's a much nicer way to develop than IDE completion. It's like test-first design but you can actually get things working before deciding on a class structure or what arguments a function needs. I think we have everything backward in Java and are basically forced by the language into a version of waterfall development where we commit to choices early on that we aren't qualified to make yet.
I've seen that report. I'd like to see the results in this specific comparison, or rather, in all benchmarks posted. It seems PyPy might be capable of winning both in time and in memory usage
 &gt;&gt;&gt; x = [(1,2), (3,4), (3,6), (4,9)] &gt;&gt;&gt; [y for y in x if y[0] == 3] [(3, 4), (3, 6)] 
But I don't mind moving my hand to the mouse. I spend most of the time thinking about the code anyway :)
Indeed. Many a time have I wanted to just try a few lines of code and see that is does what I want it to, only to be forced to write a whole main-method or step through all of the program to reach that line of code. Python is sounding better by the minute :)
why did you start words_to_count_dict = 0? I did it this way: words=['a','a','b','c'] dictcount={} for word in words: if word not in dictcount: dictcount[word]=1 else:dictcount[word]+=1 print dictcount {'a': 2, 'c': 1, 'b': 1}
The latest push onto `master` now contains the "remote_tar" plugin (only depends on [paramiko](http://www.lag.net/paramiko/)). Is this what you want? I haven't re-created the HTML docs yet. But if you open the file, it contains the docs right at the top. The configuration/control of the tar command is straightforward. I pass the parameters right onto the `tar` command. I don't see the point in recreating every single tar parameter as config value. Two reasons: * This is more portable * I don't have to re-invent the wheel Now, you might argue that *some* often used parameters (like, list of source files, list of excludes, working folder...) would be easier to edit/read as proper config values. And I am inclined to agree on that. But for now, this is not the case. Comments always welcome.
I'm sure they're going to wait till the season finale to bring out a big boy like that.
Groovy is almost the same thing for Java. Almost all Java syntax is valid Groovy so you can prototype without the scripting features and paste into your IDE.
Both Vim and Emacs offer code completion, but you're right that there is a learning curve if you're used to Eclipse.
In addition to the list comprehension filter that the others have mentioned, I'd like to point out that python _does_ have an if expression of the kind you were originally looking for: answer = x if (condition) else y
Can anyone give me a realistic example of how you would use this?
&gt;I'm a one-person team. Read the celery docs. They're good and easy to figure out. It's not hard. Thanks for the details. It help us when we go for the long term solution. I think we will probably go for celery &gt;Why blog about and submit your short-term hacks? I appreciate you taking time to write a detail reply. But I am curious to know 'Why not ?' I have already made it clear on the blog that it is a 'short term' solution. If someone still wants to experiment, be it. 
I don't endorse it, i think it's a bad function, but my guess is something like: def register_callback(self, callback): if not callable(callback): raise TypeError("register_callback takes a callable") self._callback = callback This will make it easier to find the errorenous call, instead of finding it much later when `self._callback` is called. I think this kind of thing is fine when debugging problems, but the code can be littered with such "debug aids" and it's not worth it.
there's a flip-side to that argument, teaching java to college students who already familiar with programming will make them think: "Shit, I have to deal with THIS 8 hours/day? fuck that... I'm going to pharmacy/architecture/med/math/law school." When I was cs undergrad, 1/3 of my classmates left because of this reason.
if you want autocomplete to work with new packages, you have to relocate the python interpreter in eclipse. then it will load everything new, and autocomplete works again.
Aesthetics of what? The documentation, the banners at the conventions, the shoes of the primary developers? I'm glad you bring this up (upvote), because it's a key sentiment, but it is something I reject as a mindset of vacuous hipsterism, trendiness for the sake of "I don't know better." If you subscribe to your programming language as one subscribes to fashion trend, you are doing it wrong.
Also, such IDE tends to have hefty RAM requirement.
There are also cases where you can set something to a value or a callable. When the value is accessed, if it was set as a callable, then the callable is called and its return value returned as the value. Rough example: def setter(self, value): self._value = value def getter(self): v = self._value if callable(v): v = v() return v value = property(getter, setter) I'm making no value judgements about this style of code - it's out there in some libraries which are at least moderately well used.
I haven't switched to 3.x and I already miss 2.x.
I didn't need the else in my case. Makes to control flow simpler I think -- set to 0 if it's not there, and always increment.
I'm reading Learn you a Haskell these days and I consider myself a python adventurer. Can you tell me why Haskell hasnt hit mainstream yet ? 
You do not 'pass' self, its automatically done for you. Yes, you define a method with first argument as 'self' but while calling you do not pass self. def myFunc(self, arg1, arg2): pass myObj.myFun(1,2) The reason being, myFunc is just another function and the magic happens in the 'dot' '.' Its called as descriptor protocol in Python. Instance methods in Python as Descriptors. tl;dr: myObj.myFunc(arg1, arg2) ... magic happens .. myFunc(self, ...) is called.
While you can do what others are suggesting, the more general answer is to use the functional programming constructs the way you would in lisp or haskell. That is, map, filter, all, any, reduce, functools.partial, and the iterator equivalents in itertools. List comprehensions are nice especially when you want nested loops over multiple things but they aren't always what you need. x = [(1,2), (3,4), (3,6), (4,9)] filter(lambda (a,b): a==3, x) Note the destructuring of the tuple with parentheses in the lambda, which means it technically takes one argument (a tuple) instead of two.
That's why VIM is modal editor. You go to command mode when you start thinking :)
OK- I see what you did. I was mentally indenting your +1 counter when I shouldn't have.
Consider a web framework that uses function names to expose method calls to the web. Pylons does this. class FooController(Controller): def bar(self): # do webby stuff Pylons automaps that to the URL: /foo/bar To do this it gets the bar attribute of a FooController instance and tests if it's callable before calling it. Otherwise it continues on looking for another reasonable callable, like a "default" function or something. It's debatable whether this pattern is good. (I used to think, now I think not so much), but it's the first example that came to mind. Fun fact: Pylons doesn't actually use callable. It tests: type(f) is types.FunctionType Which is dumb because if it's a decorated function it mysteriously fails. callable would be preferable.
note I believe eclipse/pydev comes with a python repl.
&gt; But I am curious to know 'Why not ?' I have already made it clear on the blog that it is a 'short term' solution. It would have taken you less time to do it right than to write it up. Now somebody else might find it and think that what you're dping is a good idea -- even for a short time. That's what's wrong with it.
no. the lisp/haskell way is the lisp/haskell way. Do you really find it better to *read* filter(lambda (a,b): a==3, x) than [(i, j) for (i, j) in myList if i == 3] ? because both do exactly the same, and one is no more generic than the other. More uniform syntactically ? maybe. Who cares ? But you can do the same with conditional generator expressions as with filter+lambdas. ah, no the conditional generator is more powerful because you can generate something different than what you tested. You'd need a map for that. So it's more a concept of being more math-like / pure ? Well, practicality beats purity. Use Scheme ! It's fun ! Let us use a language that doesn't get in the way. (Nota: the preceding sounds way more involved that it really is. it's all good)
If what you want is to filter a list then filter is the obvious choice rather than the identity+if list comprehension, but really, who cares, it's just a question of style and syntactic sugar. The guy is a beginner so he should be pointed to multiple ways to solve his problem.
I second Komodo Edit! I write all my little scripts in it because it has some nice features (a la syntax highlighting) without all the bloat.
I'd venture they're not cut out for it, then. If they're so fickle as to change their major without doing their own research regarding prospective employment opportunities, I'd say they were right for changing their major. In that case, Java was instrumental in allowing them to realize the reality of demand and how it comes into play for job availability. If you aren't willing to vie for the rare Python position, you likely *will* end up in the Java position. There are many times more Java jobs than Python jobs. If you do the math, you'll quickly realize what the majority of your peers will end up doing. Likewise, one cannot preach or fully appreciate the benefits of development in Python without understanding Java.
That's the bane of Python. The language touts its expressiveness and when you try to express something in the most natural way you can, you usually end up with the worse possible design :/
Well, the syntax is pretty. That's generally what people refer to by beautiful. It is also easier to approach (the dual object oriented/function oriented) of Python is kind of weird in this regard. Generally speaking, it's a very nice language to code with. It's a shame that you don't get many libraries, and when you do, they're dealing with things related with web development, they are undocumented and are written by people who think that metaprogramming is good practice.
I know almost nothing about Haskell, but I can take a stab at your question. Haskell hasn't hit mainstream yet for the same reason that *most* languages haven't (and never will) hit mainstream -- the community is too small and there aren't sufficient libraries. They're interrelated reasons. The success or failure of a language (as measured by hitting mainstream) really depends on those two factors, more so than the quality of the language's design. Perl, for example, has done very well due to having a large, active community and a large collection of libraries -- despite it's rather messy language design. *Edit:* Which begs the question, how did Perl manage to acquire its supporting community? As far as I can tell, it's because it offered the right features at a time when the alternatives were inferior (non-crossplatform shell scripting, etc.). Don't really know though, as the history of Perl's ascension is before my time.
Well the issue indicates that there is a "collections.Callable" that you can use with "isinstance". It seems like a reasonable solution.
Is it customary for CS programs to only teach one language? My engineer program went through C,C++,various assembly languages, VHDL, Java, and Scheme. Granted we didn't spend much time on anything other than C, you still get enough experience to develop an appreciation of each.
I think a big problem with purely functional programming languages is the difficulty involved in keeping track of state information. This could be just me, I tend to view all programs as finite state machines, where there are purely functional sections (which functional programming languages excel at) but there needs to be state information that needs to be tracked outside of those sections which are a little bit more difficult to work with in a purely functional environment.
&gt; The substitute of writing `isinstance(x, collections.Callable)` is not good, 1) because it's wordier 2) because collections is really not an intuitive place where to look for a Callable ABC. Seriously? Wait, what was the point of Python 3000 again? Getting special case shit out, fixing errors in a breaking way, getting deprecated stuff out? What was I thinking? Oh, yeah: getting ABCs as "the way to do it" when it comes to inheritance and interface tests. And what happens now? After two versions in the wild we go back to the old shit. Because the new way was "wordier" in this case. Shiiiiiiiiiit. OK, GvR gave up. We've made one step forward, so now it's time to take one step back. But this is why we can not have nice things. F-ing wordier. /rant
&gt; Because the new way was "wordier" in this case. While ranting, you seem to have missed the other reason which was presented. That's actually more of a reason than "wordier". Also, callable is IMO at a different, more basic level relative to inheritance and interface tests, just as functions are at a more basic level relative to classes. The concept of "is something callable?" was never deprecated - just the implementation detail of how to determine it was changed. For 3.0/3.1, hasattr(obj, '__call__') was suggested.
as a flask convert from django who really doesn't feel like learning the complexity of SQLAlchemy (nothing against the tool, I just don't have the time atm), thank you. I'll probably incorporate this into my next small webapp. Thanks!
From what I've seen, course material has quite a bit of variance. I wouldn't really say there is a customary way to learn or teach CS, though most would agree that being exposed to multiple languages is important in understanding the different paradigms and algorithms associated with computational theory. I see a lot posted about many CS courses focusing predominantly on Java, turning out code mill programmers rather than computer scientists. The core concept of CS is not (or was not intended to be) strongly associated with software development. 
Vim is not about the key bindings. Command chaining, speed, **opens in less than a second**, macros, focus on typing and so on...
If you use Intellij, just get the python plugin. This is exactly the same as PyCharm. If you only want the python functionality of Intellij, look into getting PyCharm as a stand alone. I've used a few different IDE's and Intellij (PyCharm) is by far my favorite. Of course, I use Intellij at work for Java so I'm a bit bias.
To each his own, but nano is the crummy text-editor not vim.
Ah yes, Scanner. I guess it has been 4 years since my intro to programming class.
Thanks for the explanation. I am more familiar with PHP and Ruby. Neither use that particular pattern. Having that perspective, it seems a bit needlessly verbose. Is there an advantage, performance or otherwise, to using this method? 
You might take a look at the [pretty print module](http://docs.python.org/library/pprint.html).
Now, every time I type self.property, I have to look over my shoulder. :D
Thank you! virtualenv5 helps me a lot!
Is this something extra that I have to download? Can you please give an example.
[Spyder at googlecode](http://code.google.com/p/spyderlib/)
thanks, it looks submit a text will ignore the submit link tab.
I recently discovered Spyder. I haven't taken the time to compare it in a bakeoff against WingIDE, which is also excellent, but as far as free Python IDEs go I think spyder is the best. I know this'll sound a bit ungrateful, please don't take it that way. Really, it's a reflection of an excellent software product. But, the only thing I would **really** like from Spyder that wasn't in the last release is proper Linux (read: Ubuntu) packaging. It's not the worst thing in the world, but decompressing the package, and linking it to ~/bin is just not the cleanest, most elegant install in the world. Small point, but a really elegant installer would make a great product that much better (and would probably make it more accessible to many more people).
Nope. In the standard library. Take a look at where the link he sent you goes: docs.python.org. Also, I have no experience with either, but I would look into tabular or tablib.
Do your own homework.
This isn't homework. I am working on the 3x+1 problem, I can send you my code if you like.
Many of the things you're naming aren't the IDE competing with Vim, it's the IDE competing with the command line. And I've never seen an IDE that successfully replaces the command line. So you can use a command line plus an IDE, or a command line plus Vim, and there's the nice feature that you can actually launch Vim from the command line. Version control, for example, is a disaster in all IDEs I've seen. They implement a horribly limiting subset of the features of Subversion, and pretend that all VCSes are just secret codes for that limited subset of features. The real world of version control has moved far beyond that, so you need the command line. Whether you can compile in the background, and how quickly you can deploy a package, are entirely functions of your compiler/packager, not the frontend you put on it. And since we're talking about Python here, I rather doubt any fancy compilation strategy is going to work with Cython or extension modules, and nothing else is compiled. I don't even know what "optimized imports" and "configuring included libraries" mean in this context -- importing and configuration are the job of your programming language, right? If you use features of your IDE to do that, then your code won't work for people who don't use your IDE. I also question how much you use Vim, because tabs and code formatting are two features that work out of the box.
Yep, I made the switch when I realized that every single math/science project I needed to do was, in reality, two projects with ruby. One writing the C bindings, the other the actual project.
Does anyone know how Python might compare to FORTRAN performance wise? I had read there was an easy-to-use Python compiler that enabled GPU computation and I was wondering if this GPU leverage may allow for Python to outperform FORTRAN in single precision.
Thanks for those links.
So much for calling my python data crawler Spyder...
Looks pretty cool, trying it out now
I wonder if pyro and do-it might be an alternative to fabric?
[The New Boston](http://www.youtube.com/watch?v=4Mf0h3HphEA&amp;list=PLEA1FEF17E1E5C0DA&amp;playnext=1). Watch the first one, see if you like it. It will automatically play through them, that is a link to the playlist.
Well, I don't have any numbers to point to right now, but let's just say it's not even close. Python is several orders of magnitude slower than Fortran, at least using the standard CPython interpreter. That being said, there's lots of ways to make it fast. You can implement computationally heavy bits in C, or Fortran, and call out to them. There's a page here: http://www.scipy.org/PerformancePython that gives several ideas of how to use Python for performance computing. There was also a project somewhere whose name I cannot recall that allowed you to inline Fortran code in to your Python program, and compile it when your program runs As for GPU computing, you don't need a special interpreter. You can use something like [PyCuda](http://mathema.tician.de/software/pycuda) or [PyOpenCL](http://mathema.tician.de/software/pyopencl). There are also numerous wrappers for both those libraries that let you work with higher-level abstractions.
I started trying to learn Python myself about a year ago (coming from 12 year of Delphi and C#) so I started a blog: http://damiankennedypython.blogspot.com/2010/04/getting-started-natural-log-doc-test.html 
If you're dealing with multidimensional arrays, install numpy and learn matlab-style vectorized operations. If your array is too big to view, shrink the ranges from 20 to 3 or something more manageable until you get the code right.
I was in grade 9 when i learned python, time very well spent so don't give up! I started here first: http://docs.python.org/tutorial/introduction.html (back when the tutorial looked like crap) then i got a book called learning python and read that. I made a website using python, though i don't really like making web pages i'd recommend making a web site with python as a first project simply because its not very complicated and interesting enough to be fun.
There is a lot of tension between Python packaging systems like pip and Ubuntu packaging. I've found using SciPy and other modules that the repos never have the most up to date stable releases and have gotten used to all of my Python libraries being installed using easy_install/pip, etc. 
http://learnpythonthehardway.org/
I don't need to do any calculations, I want a printout. Does your comment still apply?
I'm not sure why you think [this](http://www.reddit.com/r/Python/comments/ecp2u/help_generating_a_unique_list_with_counts/c173usr) or [this](http://www.reddit.com/r/Python/comments/ecp2u/help_generating_a_unique_list_with_counts/c1741r2) isn't expressive, at the same time being memory efficient. :-)
SQLObject is pretty simple, but I really use any of them anymore now that I found mongodb.
MongoDB isn't a silver bullet; RDBMS where RDBMS is required etc. etc. ;-)
I have a simple program to make ASCII tables out of python lists here: http://ioreader.com/code/python/slr/table.pys
No, it's purely syntactic, and I find it extraneous too, but I'm not a Python evangelist.
I've been following this project for a while, glad to see it made it to 2.0.
No it's the em dash before the copyright symbol. The encoding that you're trying to decode is actually cp1252. Strangely enough, the encoding of the page you linked to is actually utf-8: from urllib import urlopen x = urlopen("http://www.thrivenotes.com/the-last-answer/").read().decode("utf-8") If the content of that URI wasn't utf-8, that code would raise an error. What probably happened was when you copied and pasted the text, your text editor probably saved the text file using windows-1252. There is the [chardet](http://chardet.feedparser.org/) but generally it's pretty easy to guess what the encoding is. If it's western content, it's going to most likely be two different encodings, utf-8 or windows-1252. With utf-8, all bytes with the high bit set signal the start of a multi-byte sequence. Those bytes are reserved in both latin-1 (iso-8859-1) and the corresponding Unicode code points are reserved. Unfortunately for developers everywhere the other most common encoding, windows-1252 used those reserved bytes for really common characters in publishing such as en and em dashes. 
You may want to give this a read: http://pylonshq.com/docs/en/0.9.7/tutorials/understanding_unicode/
I think that while Haskell has officially existed for 20 years, it's only been "ready for prime time" in the last couple of years, which makes it extremely young in the competitive language field. I do believe it can hit mainstream, but cannot tell if it will actually happen. I remember Python was in a similar situation back in ~2001. The cost of switching programming languages includes the costs of learning to "think" in a different way. Moving from thinking in Python to thinking in C is a bit difficult, perhaps, but a similar move to Haskell is significantly more effort simply because Haskell is so much more different. You have to re-learn a lot. Programmers confuse "very different from what I know" with "very difficult" (and claim Haskell is very difficult), but non-programmers have an easier time learning Haskell than other programming languages. The type system is *awesome* at preventing almost all types of bugs from occurring in the first place (Haskell really makes past-compilation errors pretty rare), but it does require learning a bit more. Contrary to popular Pythoneer opinion, it does not prevent rapid programming or put large overheads on programmers - because of type inference and because types in Haskell are generally concise and are awesome documentation. Also, the compiler uses types to write code for you that in Python you'd have to write yourself. Often the types *shorten* the code. Its repository of libraries (Hackage) is still growing exponentially, though it's pretty damn huge now, I often find it easier to find a Haskell library than a Python library for a certain task. But in absolute terms, library-wise Haskell is still a bit behind mainstream languages. OTOH, Haskell's FFI bindings to call C are much better than those of Python, so it is easier to wrap missing interfaces if those are written in C. 
This looks absolutely horrible to me. What if the value just happens to be callable? Completely irrespective of the way it is used here? Am I supposed to wrap it to avoid getting it accidentally called? This also goes completely against duck-typing, of course. Imagine your surprise when you extensively test your use of a library, but then when a real-world scenario happens to instantiate a different kind of object (imagine some plugin) and the library suddenly behaves differently and everything breaks. 
Try www.google.com
If you don't have any better information (a header, some filesystem hint) you can use the [chardet module](http://chardet.feedparser.org/) to make a good guess. Also BeautifulSoup's UnicodeDammit might help you.
How about searching /r/Python...?
How do I use it?
Like "learning Photoshop" or "learning *foreignlanguage*", to "learn python" you/one/I really have (has) to [be] work[ing] towards some task other than learning the thing itself. Identify a task you'd like the compu to perform, then break that process into as small of chunks/concepts as you can conceptualize, and google those chunks + 'python' untill you can either do 'em or decompose 'em into smaller tasks you can do once you google them (The new subtasks.)
I think this is appropriate advice for someone learning a second language. For someone with no experience, I think there is too much core stuff that they'll likely miss this way -- functions, classes, scope, types, etc.
Holy shit. We're getting this post in on a Monday? What will fill up this reddit for the rest of the week? This one usually comes in on a Thursday. Someone may have to actually post some interesting content.
This one was apparently just sleeping
If you've got a reasonable PC, then Eclipse+pydev is ideal. If you've got cash to throw away you can buy WingIDE or PyCharm but neither of these provide any compelling advantages over pydev (and lack some of the niceties of Eclipse). If you're working on a resource-starved PC, Eclipse may not be viable, in which case IDLE is actually quite good although not the prettiest.
 I might be thinking of python.. I dunno... my uni days were a bit of a blur ~_~
And also [The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)](http://www.joelonsoftware.com/articles/Unicode.html) which is (no matter what you think about Spolsky) what opened my eyes about this topic and made me think, "well it's a complicated mess, but it's also in fact really pretty easy once you see what's going on.".
My PC's "the Bomb"! Even my old crummy macbook runs Eclipse smoothly. Does anyone really still use computers that can't even run eclipse?
&gt; Am I supposed to wrap it to avoid getting it accidentally called? For this usage pattern, the property getter has to support the possibility of a callable value, and the developer has to document this. The developer who puts this in presumably could do so in a responsible way depending on the specific usage of the property. Nobody's suggesting that all properties everywhere are affected. Obviously if this wasn't documented, then it would violate the principle of least surprise (at the very least). BTW I don't use this pattern myself - but I've seen it used. &gt; This also goes completely against duck-typing, of course. How so? Not disagreeing - just don't quite see why. ISTM callable() is something you might use in duck-typing scenarios - something could be a function, class, method or instance with \_\_call\_\_, and we don't care, so long as it quacks like a callable. 
Have a look at this URL http://www.markus-gattol.name/ws/python.html#comprehension as it has several examples with "if" and not just list but also "set comprehension" and "dictionary comprehension".
i'd try with pymedia, but a) it's poorly documented, b) never had it working as it should, even the copy/paste examples, c) probably it's unmaintained now. That said, I think that there are no good mp3/audio modules available for Python, or I fail at google.
PyCharm offers at least one compelling advantage over PyDev - it isn't built on Eclipse.
No time to look, but if there are programs that can do this with WAVs, then you could call the command line lame program to translate from mp3 to wav.
Check out the echo-nest people. I recall reading some sort of a audio &amp; or video mixing/editing possibilities... http://code.google.com/p/echo-nest-remix/
How about GStreamer ... although you don't want to end up doing any transcoding, it might well be possible.
I highly recommend Arch for its package selection (including the AUR) and its package-creation ease, especially for development work.
http://stackoverflow.com/questions/310765/python-library-to-modify-mp3-audio-without-transcoding The last bit, PyMp3Cut looks like the best thing for you.
I'm not saying that. What I am saying is the "there should be one obvious way to do it" mantra really isn't true. When you get straight to the point and take the obvious approach you somehow screw yourself. I would imagine there are a dozen good ways to solve this problem that are pythonic, straight to the point, expressive and easy to read. It's just when you go the most basic and obvious route you end up hurting yourself more than necessary.
small correction: pylons is going legacy, the teams of repoze.bfg and pylons have joined recently and they created a new framework, called the Pyramid. The best of both worlds. It was on pyreddit sometime ago.
One possible stack is CherryPy + repoze + SQLAlchemy + Storm + Mako. Plenty of info and links at [http://wiki.python.org/moin/WebFrameworks](http://wiki.python.org/moin/WebFrameworks).
I recommend using [Flask](http://flask.pocoo.org/): * little scaffolding - see the code on the flask homepage, 7 lines will get you started * JSON - use [flask.jsonify](http://flask.pocoo.org/docs/api/#returning-json) to return json from your views * auth - this you might have to do a little work for.. you can use [Flask-Principal](http://packages.python.org/Flask-Principal/) and/or WSGI middleware (e.g. [barrel](http://lukearno.com/projects/barrel/), [authkit](http://authkit.org/)) * deployable via mod_wsgi - all modern WSGI frameworks should be easy to deploy with mod_wsgi, [here's flask's documentation on deploying](http://flask.pocoo.org/docs/deploying/mod_wsgi/) * templating - jinja2 is the default templating language for flask, it is very easy to use In addition to those, Flask has great documentation, a nice (and growing) choice of [extensions](http://flask.pocoo.org/extensions/), a good mailing list, ... I am using it for all of my development right now.
My vote is for Django. It handles all 5 of your requirements. As for the models in Django, as long as you're sure to use [South](http://south.aeracode.org/), there's plenty of flexibility. I'd suggest running through the Django tutorial (building the Poll app) to get a feel for the framework. Shouldn't take too long. After that, start building your app. Not long after that, take a look at the excellent South tutorial to handle model migrations.
You have web2py in the title but not in the body. I am not a python guru by any stretch and definitely recognize the heavy criticism web2py gets from a design stand point. However, after years of Drupal development I was looking for a fullstack framework for rapid development and after researching and looking at the same things are looking at, I went ahead and dove into web2py. I absolutely love working with it. My heart literally bleeds joy at the conciseness of the code I write. Again, it breaks some python mantras and there is some 'magic' happening; and depending on what you are doing that may or may not be acceptable to you. But for what you are doing, building forms with moderate validation; I just can't imagine a process simpler than web2py's. There is no new templating engine to learn; it's just embedded python that uses `pass` instead of indentation for code blocks. Web2py - has available scripts for full deployment on a VPS - can build, process, validate, and display a form in ~12 lines of code - has native json/xml output of dicts - has out of the box authentication / roles / permissions done with decorators - is deployable via mod_wsgi - just uses pure python inside double curly brackets embedded in html files for templating. 
Generally seconded, other than south (like all the other migration tools for Django so far) breaks far too easily. It is a frequent case (at least for me) during development of a project under South that it becomes necessary to rip South out of the process and revert back to traditional SQL schema management. However, none of them seem to be great at it. Oddly, the one with which I've had the most overall success is [deseb](http://code.google.com/p/deseb/).
Reasonable if callable instances had something to do with collections.
On top of my upboat, I'd also recommend that you checkout several third party apps around form creation/processing: django-uni-form (presentation) django-ajax-validation (guess what this one does..) django-form-utils (code helpers)
not a python library, but you might want to check out [sox](http://sox.sourceforge.net/).
Flask vs bottle? Go!
Python, with appropriate libraries such as numpy, Sci-py, matplotlib, are used by many scientists and engineers on huge datasets *because* the environment as a whole makes them more productive. The number crunching is or can be off-loaded to routines in C or Fortran that are linked back in to the Python environment. 
exhuma - give pyramid a shot - next generation pylons project - it does everything you could expect of pylons/tg2 and has some nice functionality like seamless json etc. http://docs.pylonshq.com/ -here are docs for the project
Example use: http://codepad.org/V7LaSYNr If you use it, make sure to keep copyright intact and please place a link in it back to my blog URL.
Web2py helps you five ways that are more or less unique of this framework: 1) Any action you define, you can call it with .json and the output will be represented in json without any programming on your side. [read more](http://web2py.com/book/default/chapter/09#HTML,-XML,-and-JSON) 2) The template language is pure python between {{...}} and you can use it to generate javascript. (you can use &lt;%...%&gt; instead of {{...}} if you like it better). 3) It has a built-in role based access control. Any function can be decorated with @auth.requires_login, @auth.requires_membership, @auth.requires_permission. [read more](http://web2py.com/book/default/chapter/08) 4) If you choose a JS library for rich client interface it is more likely to use jsonrpc than json. In web2py you can register jsonrpc callbacks simply with @service.jsonrpc. For example using pyjamas. [read more](http://web2py.com/book/default/chapter/09#JSONRPC-and-Pyjamas) 5) You can do lots of ajax without any JS programming using the LOAD helper. The LOAD helper calls another action via ajax and automatically traps events inside the container DIV. This allows you to have a modular design for your pages where different boxes/DIVs talk to the server independently without reloading the entire page, transparently, and without JS programming. [read more](http://web2py.com/book/default/chapter/13#Components). web2py is build on mod_wsgi and you do not need any scaffolding app to start with (unless you want to). EDIT: example of using the LOAD helper: # controllers/default.py def index(): return dict() def a_box(): form=SQLFORM.factory(Field('name',notnull=True)) if form.accepts(request,session): return 'welcome %s' % form.vars.name return form # views/default/index.html {{extend 'layout.html'}} bla bla bla {{=LOAD('default','a_box',ajax=True)}} bla bla bla EDIT: fixed typo (suing-&gt;using)
in between pyramid and django I'd pick pyramid with sqlalchemy any day of the week. It has authentication and authorization helpers, you just need to fill in the "how". JSON vs HTML is created by changing the "view" renderer. Each view, if you go the view_config decorator route, can have any number of different renderers associated with it at different URL suffixes or routes of your choosing. There's almost *no* extra code required to write a view in pyramid. Its a python function with one or two parameters. Templating is really your choice but at least mako, jinja2, and chameleon (like genshi but lots faster) are already ready to use. Using your favorite does look like its too too hard so if your all about spitfire or whatever... Anyways I really can't recommend it enough. Did I mention its a boatload faster than the other frameworks?
Simple question, simple answer: [nagare!](http://nagare.org)
Django is the largest framework by far in terms of features and community. If you're new to Python (or Python web development) it's probably your best place to start. You might find it's a bit restrictive in places (e.g. templates, authentication) but it comes with a ton of functionality out of the box - the admin for example. You can swap out parts but this often means losing useful chunks of the framework - for example you can't use the admin with a non-RDBMS data store (yet). These issues aside Django is an excellent choice. Pyramid is the next generation framework built from repoze.bfg, incorporating Pylons. As such it has a very solid heritage. Typically you would use SQLAlchemy with Pyramid for your ORM, which again is a top quality piece of kit. At this point however Pyramid is very much in developmental flux and it might be worth waiting a while for things to standardize a bit. That shouldn't stop you from playing with it, though. Turbogears 2 was built on top of Pylons so it's not clear where it's going - will it be pulled out again into its own project, or re-integrated with Pyramid ? My own concern with TG2 was that it had far too many constantly breaking dependencies to be considered for serious development. Let's hope integration with Pyramid fixes this issue. Flask is my personal favourite. You can create a web app with a few lines of code in a single module, but build out into a larger application using extensions. The extensions are more or less thin integration wrappers around other packages - for example, Flask-SQLAlchemy or Flask-Mail. The documentation is excellent and the community, while tiny in comparison to Django's, are very helpful and supportive. As with Pyramid it's built on solid libraries - Werkzeug and Jinja2. That said, Flask isn't to everyone's taste - the use of thread local proxies annoys some people, and it is a young project and therefore has a few rough edges. With any framework though you'll find that there will be things you love and things you hate, and it really comes down to which one fits your personal style best. It's probably worth writing a small application - a blog for example - in each framework so you can compare how easy they are to work with. 
The best advice I can give is to try them all. Django's documentation includes a tutorial that'll walk you through all the basics in about 30-60 minutes, and I have to assume that Pylons and TG2 have something similar. Do the tutorials, then set aside a bit of time to try something harder. Try to get stuck, then look for help in the documentation, on mailing lists, and on IRC. Give yourself a couple-three days with each framework, and by the end of that process you should have a fairly clear idea about which "fits your brain" the best. All three tools are pretty good, and all will get you from point A to point B. But the journal will be different, and only you can tell which framework best matches your personal taste. [Disclaimer: I'm a Django core developer.]
Hmm, looks like [Seaside](http://www.seaside.st) in Python. Sounds yummy.
The benevolent dictator giveth and the benevolent dictator taketh.
Cool, thanks for that. I never have dealt much with unicode, but I have yet to see the giant confusion everyone's associated with it. Either way I feel like this article's probably something I should read.
Perfect, thanks man.
Jinja for templating. It's like Django, but without the suck.
It bugs me that people who disagree with you downvote you without adding to the discussion. Thanks for the great post, even if I am part of the minority that appreciates it.
yep, I came here knowing I would find his post, he's like in *every* thread where web2py is mentioned, and seemingly an incredibly helpful guy
I've been meaning to check out Arch for a while.
[Flask](http://flask.pocoo.org/). * Small. * Easy to use. * Well written. * Well documented. * Uses a great templating engine. * Uses a great WSGI toolkit. * Pro tip: mix with 1 part [SQLAlchemy](http://www.sqlalchemy.org/), shake, ready to serve. * &lt;3
Thank you guys. I appreciate your comments.
Second this, many more things beyond pasting them together too.
pylons is the most "lightweight" and most powerful and what I use, turbogears is built atop pylons.
Are there any SQLAlchemy tutorials you'd recommend reading if you're used to doing SQL directly? I find the idea of abstracting that much quite confusing and have no idea how it isn't really slow.
please just try them all, they are quite different and its pretty likely that just one of them would be much more appealing to you than the rest.
Bummed that nobody has recommended tornadoweb.org : super light and performant, and designed to handle lots of realtime javascript interactions. I've been using ti for a year and some change and find it much quicker to work with than django or tg/pylons. The controller syntax is very similar to web.py and the templating language is a clone of django's.
I definitely will credit as you have stated. Quick question, how do I print it out into a file that I can later make a hard copy of. I know this is a stupid question, but I am very new to this. 
http://www.sqlalchemy.org/docs/ is good enough. It will take some time getting used to though. SqlAlchemy will greatly ease your basic CRUD operation but building a complex query will be a great pain in the ass the first few time. To give you an example the first time it took me 3 hours of digging through the doc, googling and reading mailing list archives to write a line of sqlalchemy code for an SQL query I had written and tested under 5 minutes. Mind you I had very specific reason to want to do it only through SqlAlchemy interface (if only to check how far it would bend). For other case there is always session.query(X).from_statement("SQL")
Wish I knew, best guess is it is some esoteric reference to Battlestar Galatica because my teacher loves that show.
I am not sure. You could try copying &amp; pasting the output to a text editor, making the font is fixed width (e.g. Courier), and printing that.
unboated for upboat. Why do you dislike them people? They're boats, they're up! The best kind of boats.
This was a very informative and topical comment; downvotes in this thread are completely unwarranted. However, this type of advocacy permeates most of mdipierro's comments (he is the principle dev of web2py, so fair play), and they tend to occur even in threads specifically asking for opinions or help with other frameworks. It's not an excuse to downvote here, but I'd imagine it's a source of the resentment he seems to receive.
Actually, you want Jinja2.
Pylons (and soon Pyramid). Turbogears2 is just the "Turbogears" flavor on top of Pylons.
Bottle is a great alternative, it doesn't give you much extra fluff you won't need, runs without extra python modules, deployable with wsgi, and I've found the documentation to be pretty useful so far for what i've used it for. http://bottle.paws.de/docs/dev/index.html edit: grammar and such
&gt; I feel like this article's probably something I should read. ... Was it the title that gave it away? ;-)
At least mdipierro is still friendly to people. :) I also agree with the reasoning for the negative reactions (and in some ways, the reaction is understandable). Still, mdipierro should be commended for staying rather friendly. :)
Current discussion on the TG mailing list suggests that they will be merging forces with Pyramid/Pylons in the near future...official announcement expected sometime this week. http://groups.google.com/group/turbogears
Even if you just use engine.text, the result objects SQLAlchemy gives you are quite nice. If you use the Session, you get identity mapping (no two instances of the same row of data in memory at once) which becomes extremely important when your logic gets more complex. It's also a much nicer interface than string substitution for talking to a data store, though the downside is it wont support everything. It took me a few weeks of studying to really understand SQLAlchemy, but now I feel it's the best way to use a SQL database. The way Flask sets up sqlalchemy for you simplifies things a lot, anyway.
True.
hi yole, are you guys considering a trim down version like active state komodo edit? i'm really interested in the google app engine integration.
What exactly does a python program for kinect look like? I'm a web developer but very interested in this kind of stuff but have no idea what kind of stuff happens during a kinect-harnessing program. Can anyone point me to a document that explains whats going on? thanks
So how about you read my rant and take special precautions to get to that sentence with "ABCs"? Or nevermind, the community seems to be in agreement with you. Keep on truckin'. 
This is the only correct answer. Everyone has their own style and expectations of their tools. The reason so many Python MVC frameworks exist is because someone said "Yeah, X framework is cool, but if I wrote my own, I would do A, B, and C differently." And then they do create their own and release it into the wild. Django was cool, but I come from a DBA background and wanted more direct control over the database integration so I gravitated towards Pylons which has/had a more modular ORM. Odds are you don't have this same requirement. Someone else might prefer Django's Rails-like scaffolding or maybe it's larger community might be important to you. No one here is going to be able to make a decent guess for you because many times it's a combination of things that contribute a certain "feel" to each particular OSS project. As a side note: I run my own web shop and am very much trying to hire a competent PHP/Python web dev in Michigan. Someone who has any type of Python MVC framework on their resume is a big plus; I don't really care which one because if you already know Python (and are experienced), you can easily adapt to any other framework. So just start experimenting with any (or all) framework; it's a good investment in your skill set/career either way.
To me, it doesn't make sense to talk about Abstract Base Classes when something which is callable needn't be anything to do with classes (in the case of a function). In class-related scenarios, your points about ABCs are understood.
This. And whenever people ask me what IDE I use for Python: Linux
I'm really enjoying the simplicity of CherryPy, but I'm afraid how it might scale with large projects. This, of course, is only based on my personal experience.
&gt; It bugs me that people who disagree with you downvote you without adding to the discussion. That's what he earned from his previous months of spamming web2py in every single fucking thread about python web frameworks. Was it a long time ago? Yep. Has he changed a bit since? Yep. Should people let go? Yep. Do I understand that they haven't? Yep. Can't exactly blame them really, those who were here 18~24 months ago remember him as being utterly insufferable. If anything, that should teach people: don't spam the shit you're trying to peddle, it won't earn you many friends and it'll take a long time to live it down. And you *are* going to turn people away forever and turn them into active advocates of *anything but your stuff*. Speaking personally, Massimo's past behavior has turned me off of web2py forever. Probably is dumb, might be my loss (though I doubt it), but that's the way it is. Though I'm happy I don't have to actively ignore him or reply to his incorrect statements since he started turning a new leaf in the last 12 months or so.
&gt; he's like in every thread where web2py is mentioned Uh that would be because he's the author of web2py.
Fair answer, but I thought that ABCs are here so we can have better unified class hierarchy with "what does what" tests based on them. I liked that idea. My bad.
data crawler? Anything like ['scrapy'](http://scrapy.org/)?
I know ;) That level of public participation on the part of a creator of software is a fairly heartening sign imo.
Ha I feel the opposite way. Get them started, and let them figure out the specifics of functions, classes and especially scopes later as their project becomes more complicated. Of course everyone is totally different.
In my opinion that's a UI-oriented perspective. Of course, the term 'script' is pretty vague, but I wouldn't consider a 2000 line python program run from the command line with many application interfaces but no GUI a 'script'. 
It's not that uncommon, and for many older participants to this subreddit mdipierro's presence used to be an object of dread.
I don't know how it scales (I assume you mean to lots of hits), but would be interested in finding out.
Here is a response on Django vs Pylons from the Pylons developer himself: http://stackoverflow.com/questions/48681/pros-cons-of-django-vs-pylons/784390#784390
Haha, I actually *just* finished reading the article, came to reddit, and had this sole orangered waiting for me. 
Looking for Python 3 support? Bottle it is, then.
&gt; So even if you give them the copyright to your code, they still have to follow GPL rules, which means that if they ever want to distribute the binaries to the general public they will have to distribute it with the source code. I highly doubt this is the case. EDIT: I'm an idiot, and read "by choosing a GPL library" as "by choosing a GPL license".
Quit now and do something productive with your life. Become a doctor or something. Programming is a dead end.
I remember the time when other people posted about web2py and they were accused of being me trolling; when I joined in to defend them, I was accused of spamming; when known developers of other frameworks made unsubstantiated negative and offensive statements about web2py, and I'd respond, I was accused of spamming again. I am glad people are now acknowledging web2py should not be identified with me but it is actually a large community of very skilled professionals.
CherryPy is awesome. It performed pretty well in this [benchmark of Python Web Servers](http://nichol.as/benchmark-of-python-web-servers)
I learned django shortly after learning python a year and a half ago, and django was my framework of choice up until about 6 months ago until I discovered Flask. Here is my take. Django is brilliant. The ease in which you can do fairly complicated things (sign up a new user with a password and log him/her in and out, etc) is amazing. I like the django ORM more than any ORM I have ever used (it was my first ORM, so I'm biased). The community is huge and excellent. Apps like south, haystack, django-debug-toolbar, and piston/tastypie are godsends. I am definitely a fan of django. Templates were my first problem with django. I didn't like doing a lot of the variable manipulation, and worrying about extra database hits in my templates. I switched to Jinja2. I started disliking django more when I tried to use the django ORM outside of django (possible, but strange. and can't generate SQL table creation code). Eventually, I realized that my largest problem was the amount of excellent code that django locks up and duplicates. I realize django is older that many projects, but does django really need its very own ORM, form library, and templating system when so many awesome alternatives are available? This extends beyond django's core into the community, because the excellent apps (like haystack, which is great python-solr integration) are directly dependent upon django. Django is tightly integrated as advertised, but I've also found it far too tightly coupled. Also, when you want to do something slightly different than the django developers imagined, django becomes a mess. The huge resources of code become huge obstacles to overcome. An example of this is the User table, and extending it (through profiles or other manners). Django nearly requires the User data to be split among 2 tables, which can have a nasty performance hit. Jinja2 introduced me to Flask. I love its simplicity, conciseness, and DIY feeling. I've discovered that I have to write many small things myself with Flask that I didn't have to with django, but this results in me getting exactly what I want (or am capable of coding). Flask also leverages many of the larger python libraries, and deploys much easier with WSGI (yes, I know django is older than WSGI). Flask takes more time and work, but I find you never have to make ugly compromises in your code. Flask has an API I could imagine myself writing (in terms of complexity), django is beyond my comprehension. As for the OP's concern, flask has almost no scaffolding code, can handle JSON as well as any python application, auth is kinda questionable, and form validation will require learning one of python's many form validation libraries. tl;dr: Django is great for rapid web development "with deadlines"; Flask is perfect for creating a codebase that is a joy to deal with. note: I wish django wasn't so far removed from the rest of the python community.
flask seems a lot like sinatra, and that's really good :)
Flask works fine with repoze.who and repoze.what for authentication and authorization. It's a little hard to get past some example-light repoze documentation, but there are no incompatibilities, and it's easy once you get the initial setup together.
&gt; What's the vim command to format code? = &gt; How do you expand/collapse blocks of code? za, though I have it remapped to the space bar. You're right that Vim's tabs can't be dragged between windows, not even in gvim. I do appreciate the explanation of what "optimized imports" refers to. I hadn't heard that term, and "optimized" made it sound like it happens at runtime. And some of the things you're referring to in the IDE world sound pretty nice, but based on IDEs I've tried including Eclipse and Komodo, I have serious doubts about them ever working (especially with the criterion of working on three platforms). Can you point me to a Python IDE that * can do code completion and auto-generation * no really, for real code with dependencies outside of the Python standard library * understands virtualenvs, and preferably even allows creating and switching them without having to drop to the command line * compiles Cython automatically, correctly, and in the background * does memory profiling * and works with Git without imposing a faux-Subversion workflow on it? Honestly, if those actually worked, I'd give up my command line habits and switch to an IDE.
"is not" does reference comparison - that means the variabiles must point to the same object. "!=" does value comparison (via \_\_cmp\_\_/\_\_eq\_\_) "is not" worked "sometimes" for you before due to cpython optimizations (string interning, small number interning)
http://docs.python.org/reference/expressions.html#notin
Explain this please.
Turtles all the way down.
And go to [learnprogramming](http://www.reddit.com/r/learnprogramming/) if you need help!
Thanks. I knew I would feel stupid for asking, but I was really curious as to why it worked "sometimes"...
Basically the only time to use `is` is when you know you're looking at singleton object. So, you might write `if result is not None:` for example, since there's only one possible `None` object. When you write `if s is "hello"` the results are unpredictable, because sometimes Python reuses string objects, and sometimes it creates new ones with the same value. (Python strings are immutable so it shouldn't matter whether or not two strings are the same object in memory or not.) The same thing with numbers and other immutable objects. Just write `==` instead. Another thing to note coming from another language: `&amp;` and `|` have a different meaning in Python. They're for bit twiddling. So, don't write a C-esque `if ( a == 1 | b == 3):`. What that will do is bit-mask 1 and b then see if they're equivalent to a and 3. Instead do `if a == 1 or b == 3`. Remember that `and` and `or` short circuit evaluate, so they might not always test everything once the answer to the overall question is clear: &gt;&gt;&gt; #In Python 3, the print function returns None, which is False &gt;&gt;&gt; if print(1) and print(2): print(3) ... 1 &gt;&gt;&gt; if not print(1) and print(2): print(3) ... 1 2 &gt;&gt;&gt; if not print(1) or print(2): print(3) ... 1 3 One last style tip for Python new people: Don't write `if n != 0:`, `if len(l) != 0:`, or `if s != ""`. It's considered more Pythonic to write `if n:`, `if l:`, and `if s:`. 
Java is one of the main reasons I gave up my dream of professional programming.
Because it isn't always `self`. Sometimes it's `cls`. Sometimes it's nothing (as in static methods). Here's a quick example: &gt;&gt;&gt; class A(object): ... def foo(arg1, arg2): print(arg1, arg2) ... &gt;&gt;&gt; def baz(arg1, arg2): print(arg1, arg2) ... &gt;&gt;&gt; A.added_a_baz = baz &gt;&gt;&gt; a = A() #Create an A instance &gt;&gt;&gt; a #Remember what this instance looks like &lt;__main__.A object at 0x10055c310&gt; &gt;&gt;&gt; def bar(arg1, arg2): print(arg1, arg2) ... &gt;&gt;&gt; a.added_a_bar = bar &gt;&gt;&gt; a.foo("my arg") &lt;__main__.A object at 0x10055c310&gt; my arg &gt;&gt;&gt; #arg1 was self, arg2 was "my arg" &gt;&gt;&gt; a.added_a_baz("my other arg") &lt;__main__.A object at 0x10055c310&gt; my other arg &gt;&gt;&gt; #again, arg1 was self, arg2 was "my other arg" &gt;&gt;&gt; #even though we added this function to the class after its creation &gt;&gt;&gt; a.added_a_bar("will this work?") #No, needs two args Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; TypeError: bar() takes exactly 2 arguments (1 given) &gt;&gt;&gt; #It didn't work because the function attached to the instance, &gt;&gt;&gt; #not the class, so the first arg is not treated as "self" &gt;&gt;&gt; a.added_a_bar("This needs", "two args") #This will work, no self This needs two args Basically, there's no real difference between methods and functions in Python, but when you attach a function to a class and use it as a method, it gets passed the instance as its first argument. By convention, this argument is usually called `self`. 
If you're confusing Java and Python, you might have been a bit too blurred in college.
Your example just shows how incredibly assrapingly terrible Java is. Thanks.
Because society is composed of human beings and not monadic entity intelligences.
I could never remember how to open files in C++ or Java. I always had to copy-paste from an earlier file I had that did IO. Learning Python was such a relief from all that bullshit. `text = open(filename).read()` Done. (Well, you should close the file object manually if you're not using Cpython, but whatever.)
They cut it in 3.0 with the justification "just call it already!" That sounded about right to me…
Yeah, it should be in `abc.types` with the other utility ABCs, like `FileType` and `BuiltinFunctionType`. 
Something that is callable has everything to do with classes. To be a callable object, its class needs to have a `__call__` method. Functions work this same way. Every function has a `__call__` method, which has a `__call__` method, which has… ad infinitum. 
I haven't tried the other two frameworks, but my best advice when trying Django is don't be afraid to ask questions on email or in IRC. I only found very patient people who will not only help you solve your problem, but also go that extra mile to explain why certain choices were made when designing the framework. Django took me about a month before I felt very comfortable with it. I am still learning more about it every day, and the IRC channel is the most helpful resource I found. 
I didn't deny it ;)
&gt; I remember the time when other people posted about web2py and they were accused of being me trolling; when I joined in to defend them That happened after you'd pissed everybody off for about a year. The fault for this rests solely and squarely on your shoulders.
I understand about \_\_call\_\_, and function objects having it, but *conceptually* a function is at a more basic level than a class. That Python functions have a \_\_call\_\_ is surely an implementation detail, not fundamental to the concept of a function.
Thanks for this info. This pretty much confirms my first impressions of django. And this is the reason why I was skeptical about it at first. I find it important to be able to swap out specific components in your code as needed. I was already thinking about going cherrypy and plug in the other modules (FormEncode, jinja/genshi, ...) as needed. That would leave *me* in control of the architecture. I kind of like the way TurboGears is having an open mind about this as well. It comes bundled with a lot of useful modules but makes it straightforward to switch out it's "composite" parts (like ORM, Templating Engine) From what you say about Flask, this sounds like it's more something I am looking for. I've been fooling around with some frameworks in other languages, and every single time it was a tightly coupled framework, it became more of a burden in the later stage of the project than it was useful. So you win in the short-, but lose in the long-term. It all depends on what you are aiming at. But the application I am planning to create, is likely to run for another 10 years if successful. So it should be something maintainable. And this implies that it's easy to replace/extend existing capabilities of the framework.
Wow... very insightful. In this new light: +1 for pylons
Intriguing... I didn't know this one yet. One more to put on the list :) It sounds *very* nice, after reading the first paragraph.
I hope the transition from pylons to pyramid will be smooth...
Django does alot for you. Often times too much, which later steps in your way. I don't like pylons mainly because it is created out of the paste framework. I'd strongly recommend looking into werkzeug. Furthermore it's a matter of taste and style.
It's because you are using floating points, which rounds-off. Use the [decimal module](http://docs.python.org/library/decimal.html) if you want to calculate [reals](http://en.wikipedia.org/wiki/Real_number) precisely. from math import log from decimal import Decimal -log(Decimal("1")-Decimal(".95")*(Decimal("1")/(Decimal("16198"))))
Change 1/(16198) to 1.0/16198. &gt;&gt;&gt;3/2 1 &gt;&gt;&gt;3.0/2 1.5 Just to make sure you know. log(n) in python does natural log. log(n,10) does base ten.
I've started taking notes this morning :)
Symbian?? are we in the 90's ??
I agree with you on Turbogears2. Maintaining a project has bitten me on too many points where it shouldn't have. And as you pointed out correctly: the dependencies. And upgrading from 1.x to 2.0, should have been much smoother. I really *love* the TG "Widgets" though. Especially for forms. The more I read, the more I notice Flask being mentioned. Certainly an interesting fact. But as you point out correctly, it's still a bit young. As said in another post, the application is bound to run for a very long time and will have to be maintained/modified. So I would like to cut the maintenance of the web framework to a minimum. One less thing to worry about. If after a couple of years, the framework structure undergoes a fundamental change without proper migration support, that would sting a lot. Interestingly, this has happened to me with the migration path SQLObject -&gt; SQLAlchemy 0.3 -&gt; SQLAlchemy 0.4 Which were migrations I've done because of TG. More and more, Pylons looks like a solid choice. It's been around a while and has a great community. But I'll keep looking.
Giving the homepage a quick read, this sounds too good to be true. Certainly on the "experiment with it" list :)
Spyder FTW..one of the friendly IDEs i love for python dev..
Very informative post! And with actual references. Other people could learn from this! Thanks a bunch! :)
It is currently on top of my list.
Thanks for the quick rundown. The fact that it was in the title, but not in the body is a direct reflection of my mind. I know it exists. But I don't know any specifics about it. Anything I would write at this point about web2py would be blatant speculation. ;)
Wow... a big thumbs up for pyramid for stating that it is *not* a MVC framework, but rather a *MV* framework. It is my firm belief that any **web** framework stating it's MVC is just using a buzzword for advertising. In the web, there can be no such thing as *true* MVC unless it's using COMET or WebSockets. To my knowlege, no such thing is being used in any know web framework. How would it be otherwise possible to update the view directly from within the controller.
I don't think you'll go far wrong with Pyramid/Pylons. The documentation is good and the development team is top-notch. Furthermore I'm sure they will keep the Pylons-&gt;Pyramid migration path as smooth as possible. Another area mentioned in OP is complex forms. At present I'm using [wtforms with the Flask extension](http://packages.python.org/Flask-WTF/) which is similar in design to Django forms, but [Flatland](http://discorporate.us/projects/flatland/docs/tip/index.html) looks very interesting. WTForms has a simple design and pretty much just works in most situations, however Flatland looks very impressive in terms of flexibility. Both WTForms and Flatland are just as usable in Pyramid. I wasn't too keen on the old Pylons default - formencode - it was quite awkward to use and the @validate decorator which used it frankly sucked (it was a frequent source of complaint on the mailing lists). It would be good to see what form validation library Pyramid standardizes on, but you can still use the library of your choice. 
cat
Isn't there a general issue with Python 3 support and WSGI ? How does Bottle resolve this for generic WSGI deployment ?
Rounding off in such a simple expression will never give such a large difference. And a Decimal can't calculate log() precisely either.
10 years is an awfully long time. Look at the web development landscape 10 years ago - Zope was the top Python framework, Django wasn't even a gleam in jacobian's eye. There were no smartphones, dialup was the standard, and the top browsers were IE 5 and Netscape Navigator/Mozilla. No CSS3, AJAX, HTML5, jQuery. 10 years from now the landscape will be just as different, and new frameworks will come and go. I can guarantee that your project, should it prove successful, will need numerous rewrites over the next decade. You might well have abandoned Python for Scala/Clojure/Haskell/some other future language. So I wouldn't worry about 10 year support. The framework will be the least of your concerns.
Both PEP-3333 and mod_wsgi define a working WSGI spec for Python 3.
You're still going to have issues with the broken stdlib though. I would hold off using Python 3 at this point in time for web development until the basic issues are sorted out (problem is: so does everyone else, which is why it's languishing).
Nice start. Now try and make a version that always gets the right answer in 7 or fewer guesses. You could also make a simulated "player" and run the game many times to test how well your program does.
append(1) doesn't return a list, rather it just appends 1 to the list so assignment just assigns None.
Thanks. I'll have to pass that around the office. I also want to add "Decode Early, Encode Last"
The way to do it is not to re-implement everything in Python, that would be several orders of magnitude slower. The way most of us do it is implement the performance-critical parts in C/FORTRAN (in fact they are often already implemented) and glue them together in Python via tools like SWIG so that we reduce the amount of boilerplate required for I/O, data presentation and postprocessing and so on.
You can get the behavior you want with the following: d = {} d['key'] = d.get('key', []) + [1] Although i think the more idiomatic way would be: d = {} if 'key' not in d: d['key'] = [1] or even from collections import defaultdict d = defaultdict(list) d['key'].append(1) 
I recommend ["Hello World!" by Warren D. Sande](http://www.manning.com/sande/)
Or d.setdefault(key, []).append(1) setdefault works like dict.get(key, default), but if the key is not already in the dict it adds it with the default value and then returns the value.
 - Issue #10068: Global objects which have reference cycles with their module's dict are now cleared again. This causes issue #7140 to appear again. I like their method of fixing bugs.
I tend to agree. But one concern is that I work in a relatively small team of 2,5 developers (one is part-time dev and part-time sysa) and we have to maintain about 10 legacy applications (not counting some half-shelved apps). The company only has had an IT dept for the past few years, and we are in a constant process of streamlining many existing processes, cutting down the number of required applications considerably. The main reason is that many of the "half-shelved" apps are 90% identical to existing ones, but with *many* hard-coded values. Refactoring these actually makes it possible to regroup a bunch of old apps under one common roof. Some of the running applications are older than 15 years, and they are still running. Only looking at the functional requirements, it would be possible to rewrite them all as web-apps. This would be a *huge* step forward for us. However, the company does not stand still and new need arise and give need to new applications. So next to maintaining some good old-fashioned spaghetti code, we have to design and implement new apps. But most of our needs are quite similar. So creating some sort of framework onto which all legacy applications would be ported and onto which all the new ones would be developed. This is what I am aiming at. Essentially the apps are dead-simple. It's just a bunch of rule-driven data-entry with *thorough* validation. I imagine that the bulk of the work would be done in JS. It only needs a solid server-side back-end for data storage. As most of the focus would lie on the client-side (JS, HTML, CSS) it would help to keep the server-side codebase as small as possible. And given the fact that the existing apps are considered kind of a holy-grail and that they are not to be trifled with by our superiors, I could imagine, that newly developed apps will "enjoy" the same "privilege" in 15 years. Assuming someone else comes along and has to take over these apps, I would like to make their life as enjoyable as possible. So, keeping it simple, and well documented is my main concern.
... or log10(n)
wtforms looks really nice. One thing that I cannot get out of my mind is that all this still requires a round-trip to the server for validation. The way I imagine my application to work is that each field has on-change event handlers. Every time a value in a specific field changes, all applied rules would fire. These rules may issue warnings, errors, display/hide fields or change focus onto another field. I'm not yet quite sure if I should do this server-side or client-side. I am leaning towards client-side. Maybe duplicate some explicitly enforced rules on the server. Just to be safe even though the app will run in a controlled environment with informed end-users. The more client-side the application will be, the less I would require a python based form-validator. I'm still letting my brain munch an churn on these decisions...
I have always found it highly unintuitive that a method called 'setdefault' returns anything.
It's one of those methods that: * Reading its name leaves you clueless as to its purpose and usage. * Once you know all about it you understand there really isn't any better name for it. Personally I don't like it, it's not readable imo.
This is actually a nice trick question. I didn't see the problem until I ran the code.
Generally, given a choice, I prefer to avoid client-side validation - it's too fraught with various browser issues that it's best avoided, and you can apply the same rules consistently server-side without having to duplicate code in JS and Python. The round-trip to server is not really an issue these days unless you have a) a huge amount of traffic or b) your server-side code is really inefficient. I'd prefer to have properly validated input. That said, a compromise might be using AJAX. One pattern I've used in Django and Flask that works nicely is to have your actual form in an included template, and an AJAX view that just returns that template, along with any errors. You just insert the returned form into your container element. You get a faster response, as you're not updating the whole page, plus you get all the benefit of all logic in one place.
The first time I used that function I foolishly just assumed it would set the default value for the dictionary (similar to DefaultDict). Was puzzled when it didn't work and then a bit angry when I actually read the docs.
getorsetdefault Quantum python.
Not tested: with open("verbrauch.log") as fp: for line in fp: match = re.search(r'(1\.6\.1|1\.8\.2)\(([0-9\.]+)', line) if not match: continue version, value = match.groups() print version, value 
Understood. At the end of the day, regardless of the framework, success will rest on good developers and good managers. None of these frameworks will prevent people from writing poor, unmaintainable code, nor will they prevent feature creep from messing up good code.
This example highlights why functional programming can be so much more intuitive. 
You don't think that the more expressive the code, the easier it will be maintained? You don't think a poetic syntax is good for productivity? I get in the 'zone' faster in Ruby than in any other language... I believe this is because it is beautiful and I genuinely enjoy writing the code.
 d.get_if_empty_set_default_then_get('key',"where'd my pants go") Now if only there was a way to put commas in my identifiers.
 - Issue #10068: Global objects which have reference cycles with their module's dict are now cleared again. This causes issue #7140 to appear again. I like their approach to fixing bugs.
I've been using Python 3 with bottle and mod_wsgi without problem for a while now, but I'll admit I'm not pushing any limits that might expose problems. For the boring type of things I've done, though, it works just fine.
I have a different recollection of the events and there are things you do not know, yet I do not wish to bring up facts about what other people said and did. In this place, I have no interest in a discussion about me, I am only interested in technical discussions. When you are ready to try web2py and talk about it, I will be happy to contribute more to this thread. 
The None-returning behavior of .append, .sort and other side-effecting methods makes Python feel like an imperative language. On the other hand, it does let you know that the object has been modified which can otherwise make for rather nasty and hard-to-trace errors, as in Lisp's sort.
you are my personal god of the week! thank you so much defnull - it works! 
Functional programming is only "intuitive" to math majors. Are there *ANY* major programs out there at all that are functionally programmed?
&gt; Understood. At the end of the day, regardless of the framework, success will rest on good developers and good managers. None of these frameworks will prevent people from writing poor, unmaintainable code, nor will they prevent feature creep from messing up good code. qft
I think the more easily read, the easier it will be maintained. I think poetic syntax is all well and good but is useless unless it's built on principals, a philosophy if you will.
I recommend NetworkX. A list of what it supports is here: http://networkx.lanl.gov/reference/index.html
not sure about tree decomposition, but [networkx](http://networkx.lanl.gov/) and [igraph](http://igraph.sourceforge.net/) come to my mind. both are actively developed and have a big community.
Unfortunately, executing a server-side check after each value change of each field is out of the question. These rules can become quite hefty. Imagine rule A triggers a change in field X which will in turn fire rule B and C of which C changes a value in Y, ... Chains like these exist in the current applications and need to be ported to 100%. What is more, the people working in data entry have a phenomenal speed when entering data. It would be very annoying to them even if they needed to wait only half a second. As a quick example: Imagine a form with 500 fields (including table cells), and you have 5000 of these forms. This makes 2'500'000 fields in total. If you only lose half a second on each of them you lose around 350 man hours. And time is money! These numbers are not made up. It's a roughly estimated average, but the calculation is only theoretical. I disagree with my superiors that the problem is really as important. But well... they see the raw numbers, take out calculators and say: Naaa.... Let's stick with our old tools. Completely disregarding the maintenance nightmare... Needless to say. The application needs to be as fast as possible when moving from field A to B. It is however plausible to "queue" validation checks and visually highlight fields as soon as the server returns. Computations and hiding/showing fields are another concern. Imagine you have a route from field A to C. But if A &gt;= 50, then show field B, store 2*A into C and disable it (make it read-only). This should be executed as fast as possible to prevent any waiting time to skip from A to B. The bottleneck here would be "showing" the field. Given these facts, it's understandable why the people in my office think: The browser is too slow. But with all the recent advancements in the JS engines the big-picture has changed. And with a couple of smart choices in the overall application design, you can keep everything that's speed-critical on the client, while off-loading data-quality checks onto the server. While not always possible, finding a satisfactory balance should be possible.
i'm flashing back to GTK API functions.
And apparently the author though that blue text was good for non-links. /hates Seriously, I've learned that ruby looks look like a pretty cool lang. I cant comment on the beauty of it vs python
What does this have to do with Matlab? It looks more like Eclipse. Is it just an IDE or does it do something in particular with numpy and other mathematical packages?
I don't think I said anywhere to reimplement things in python... If you already have optimized working code in another language, then great! Slap a python wrapper around it and you are done. However, if you're developing a new algorithm then you can prototype it in python first and find the bottlenecks before writing the optimized code. 
Good point.
You're right, the more pythonic identifier would be: d.set_default_and_get_if_empty_else_get('key','woozlewazle')
I second that, I've had very good experience using networkx in various situations.
But the second parameter to setdefault is obviously not magically evaluated in a lazy manner, so each invocation of that line there will create a new empty list object (in this case). Something to keep in mind while optimizing, that.
setdefault is the way to go, just like [steelypip said](http://www.reddit.com/r/Python/comments/eego5/dictionary_question/c17i02c).
I don't think you'll find anything simpler than &gt;&gt;&gt; one = subprocess.Popen([...], stdout=subprocess.PIPE) &gt;&gt;&gt; two = subprocess.Popen([...], stdout=subprocess.PIPE, stdin=one.stdout) &gt;&gt;&gt; three = subprocess.Popen([...], stdout=subprocess.PIPE, stdin=two.stdout) &gt;&gt;&gt; for line in three.stdout: + print line Maybe you could automate the chaining... &gt;&gt;&gt; commands = [[...], [...], [...]] &gt;&gt;&gt; def pipeline(commands): + ... &gt;&gt;&gt; result_out = pipeline(commands) &gt;&gt;&gt; result_out.read() Use itertools for tee. Python snippets what?
Since you have no programming experience: Snake Wrangling for Kids http://www.briggs.net.nz/log/writing/snake-wrangling-for-kids/ Invent Your Own Computer Games with Python http://inventwithpython.com/ Both free e-books are aimed at kids who haven't had any previous experience. I recommend them to starting adults as well as they're a bit more friendly right off the bat than a grown up text book and also because this is pretty much the same method I learned by in the ancient days of Compute! and other such magazines. If you find you really like the language, I'd then recommend looking at 'Learning Python' by Mark Lutz. It's verbose and big enough to stun an ox with and some prefer smaller tomes but so far it's been the one Python book that's actually made a lot of sense to me. You can partially check it out on Google books to see if it's to your liking. http://books.google.com/books?id=1HxWGezDZcgC&amp;printsec=frontcover&amp;dq=learning+python&amp;hl=en&amp;ei=TIP2TI_WDs6s8Aas8dGRBw&amp;sa=X&amp;oi=book_result&amp;ct=result&amp;resnum=1&amp;ved=0CC4Q6AEwAA#v=onepage&amp;q&amp;f=false And also the very first post - Learn Python The Hard Way.
I've been using gedit for the last couple of months. All I can say is thanks for the post.
 d = dict() try: d['k'].append(1) except KeyError: d['k'] = [1]
Sounds like you might want something like Kamaelia: http://www.kamaelia.org/Home.html
[Ruffus](http://wwwfgu.anat.ox.ac.uk/~lg/oss/ruffus/) is a lightweight python module to run computational pipelines. It won't grab your stdouts for you and you have to dump to files between each step but it is a really nice way to write very flexible pipelines easily. You're welcome =)
Yahoo Stores used to be in Lisp. It has since been rewritten in C++ and Perl.
So much hate. Notice that he said "*can* be so much more intuitive" and not "is unequivocally more intuitive than." Functional idioms can make certain tasks far more elegant, intuitive, and readable. To eschew this is to ignore whole parts of Python that can and do make your life easier.
I want to say thanks to everyone. These resources are great, i also didn't know about the sub-edit /r/learnprogramming. Thank you to all the helpful people.
Looking at those requirements, maybe something closer to a desktop app (passing e.g. JSON to and forth from a web app) may be closer to what you need. Or if you want to go the browser route, maybe have a look at [Pyjamas](http://pyjs.org/).
There's no reason to reassign to d['key'] since the value is an object that's being changed. You can use d['key'] as an lvalue and write d['key'] += 1 if you use the *defaultdict* approach.
well that's just code with underspaces
&gt; [first example] That's what I've been doing. &gt; [second example] Yeah, thinking something along those lines, that deals with setting close_fds=True on posix systems, connect things together and whatnot. &gt; Python snippets what? e.g. regex based manipulation, keeping statistics, insertion/deletion (or could farm out to sed). 
Google is using base-10 logs and Python is using natural logs. To get the right result in Python, divide your answer by log (10) or supply the optional base argument to the log function.
IIRC, Reddit used to be in LISP as well. [HERE](http://blog.reddit.com/2005/12/on-lisp.html) for more info. EDIT: No point in replying to myself...
If you have specific questions, please feel free to join the web2py list. Please there are very helpful. If you come to any decision, please let us know what you tried and the reasons for you choice. It could help all of us improve. 
You should checkout stream.py: https://github.com/aht/stream.py
Not a lib, but you could use ffmpeg for this and invoke it from python.
From the preface to the [web2py book](http://web2py.com/book/default/chapter/00): &gt; *I originally started web2py as a teaching tool because I was very concerned about the growth of the digital divide and the obstacles this creates for the free flow of information. The ability to build good quality web applications, fast and efficiently, is of critical importance to enable more people to interact with the Internet in a meaningful way and prevent the biggest players from monopolizing information. This was my motivation for creating web2py, and it remains just as valid and even more important today.* &gt; *In general, the purpose of any web framework is to make web development easier, faster and prevent developers from making mistakes, especially in matters related to security...* mdipierro and the other web2py contributors have done an incredible job realizing this vision, and they rightly want others to benefit from their efforts. A few months ago, I was researching web frameworks (generally, not just Python). Without having any preconceived notions or personal investment in any particular framework or language, I found mdipierro's various postings about web2py extremely helpful. He always provides extensive details, often with code examples and links to further resources (as well as invitations for further support on the web2py mailing list). Without his efforts, I would not have discovered this amazing framework. From the perspective of someone who is truly interested in learning about different web app development options and open to any alternatives, the critiques of mdipierro's web2py promotion efforts are quite baffling. I *want* to see this kind of information, particularly from the very creator of the framework, who knows it best. I can only conclude that those who are so put off must have some other agenda. I'm particularly stuck by the almost juvenile nature of many of the retorts aimed at mdipierro, especially in light of his professionalism and graciousness. This difference in tone and maturity really undermines the credibility of his detractors.
Perhaps [joblib](http://packages.python.org/joblib/) can help?
No offense, but: 1. You've been a redditor for 4 months, for people who were in /r/python 2 years ago, your qualification of mdipierro as "professional" and "gracious" are laughable if not insulting. 2. In your 4 months on reddit, according to your comment history, you've done *nothing* but plug web2py and fellate Massimo. You're quite obviously an import from the web2py mailing list (an approach Massimo used repeatedly in the past in order to garner support when he was at his most annoying), and astroturfing doesn't impress much. I'd go as far as to find it disheartening, as it shows the web2py crowd clearly hasn't changed as much as I thought it had. &gt; the critiques of mdipierro's web2py promotion efforts are quite baffling There's a gap between mentioning your tool/framework/lib/whatever when the time is right (e.g. an open-ended question such as "what are the web development options in Python" or a question specifically about the tool) and spamming every single web development thread (including threads solely about a specific question concerning a different web framework) as well as plain and simply lying about other tools with laughably incorrect "comparisons". For the longest time, Massimo did the latter, and that earned him the well-deserved enmity of many /r/python members. He compounded that by pretty regularly posting on the web2py mailing list linking to reddit threads and asking for support. &gt; I want to see this kind of information, particularly from the very creator of the framework, who knows it best. Irrelevant, that's not the issue. Armin posting about Flask is enjoyable, Armin repeatedly posting about Flask in response to web2py question would not be viewed positively. And of course, Armin doesn't have anything to sell you, but if you were intrigued by Massimo's spamming and checked the web2py website, what you got was not even crummy and dry Rails-style API doc (with links to 5 billion blog posts) let alone a hand-written, complete and comprehensive documentation à la Django, it was suggestions to go on Lala and buy Massimo's book which would tell you about Massimo's framework. Which made Massimo a spammer trying to sell you something. &gt; I can only conclude that those who are so put off must have some other agenda. That's just your persecution complex talking.
Both igraph and networkx are excellent choices, but I found igraph to be faster and less memory hungry than networkx for large graphs. The igraph Python tutorial is a bit hard to find, so you might appreciate: * [**igraph**](http://igraph.wikidot.com/) - [Tutorial](http://www.cs.rhul.ac.uk/home/tamas/development/igraph/tutorial/tutorial.html) and [API Documentation](http://igraph.sourceforge.net/doc/python/index.html) * [**networkx**](http://networkx.lanl.gov/) - [Documentation](http://networkx.lanl.gov/contents.html) Other good choices include: * [**graph-tool**](http://projects.skewed.de/graph-tool/) - [Documentation](http://projects.skewed.de/graph-tool/doc/index.html) * [**python-graph**](http://code.google.com/p/python-graph/) - [Documentation](http://www.linux.ime.usp.br/~matiello/python-graph/docs/) for **1.7**
There is something simpler, and designed for this exact purpose! http://docs.python.org/library/pipes.html However, it seems that very few people use it. It almost seems deprecated; just not explicitly so.
Regardless of whether functional programming is more intuitive or not, how does this example show that functional programming is intuitive?
Nice try Warren D. Sande!
[This may be a better place to start](http://www.youtube.com/watch?v=tKTZoB2Vjuk)
The OP assumed that append() would return the modified (or just a new) list, which would be the case if the method was designed to be more functional. This was the OP's guessed behavior for append()'s workings. This is how append() works in many other languages. Furthermore, if append() was purely functional, the OP's code would be the way it's supposed to be done. 
I love the idea of PyPy, and I do hope and believe that it is the future of python. I mean, the idea is genious: you should not have to use another language to write the language. I also hope for other similar projects for other languages, like Rubinius.
projecteuler.net is my favourite site for random problems for each new language. (about time someone else liked it!)
&gt; Because the module uses /bin/sh command lines Aiee!
Well I highly encourage you to just give it an hour or so to play with. You should be able to get it up and running in a couple minutes; that is, if you haven't decided to go with a javascript framework, which seems likely.
Yeah, I don't know why they didn't remove the whole module in Python 3. It's very backward and neglected. The main reason I know of it is because the undocumented `pipes.quote()` function is very useful for sanitizing shell arguments when you *really* want/need to execute something through a shell.
That's a helluva catch. Ummm.... Could you just `import thefile` and run the functions you need? Otherwise, consider this: f = open(thefile) src = f.readlines() exec(src) Edit: No wait. I checked the 1.5 documentation. Do this: execfile("thefilename") Ta da! [Reference](http://docs.python.org/release/1.5/lib/node26.html#SECTION003300000000000000000) 
couldn't you just mine that data from lspci and lsusb?
I find myself doing this a *lot* for some reason. I always used to do: d = {} try: d['key'].append(1) except KeyError: d['key'] = [1] I found it quite a bit faster than your middle solution, when the default case was rare. Then I learned about defaultdicts and just went with those.
[datetime](http://docs.python.org/library/datetime.html)? Or am I missing something?...
lsusb wouldn't provide the blkdev. I have found something else called udisks. [Doesn't seem to be that accessible](http://cgit.freedesktop.org/udisks/tree/tests/run)(the only docs I can find) from python-dbus but does have a cli tool.
http://code.google.com/p/quodlibet/source/browse/quodlibet/quodlibet/devices/__init__.py It's targeting portable media players, but might be useful (works with HAL/UDisk/Devkit)
Thanks for pointing that out. Good to see a udisk implementation.
have you ever looked at [processing.org](http://processing.org)? best visualization tool i've seen, and now there's this (which i have not used): [pyprocessing](http://code.google.com/p/pyprocessing/)
You don't need libraries. You need [coroutines](http://www.dabeaz.com/coroutines/).
I'd rewrite it as a bunch of functions. Have a main() function which holds all your program loop, and at the bottom of the file, you have something which calls main() if it's run as standalone. if __name__=='__main__': main() That way your program works either as a module or as a standalone program.
I think you're thinking of a different meaning of the word "graph".
|
Great post, thanks guys. I've been looking at [Neo4j[(neo4j.org) and [OrientDB](http://www.orientechnologies.com/) as graphing solutions. Both of these are written in Java, but offer a REST or Jython solution for python programmers. How would the performance of the libs mentioned compare to these technologies and do they all offer some sort of persistence? 
It really is a matter of perspective. From my way of thinking, it's more helpful to think of everything in Python as an instance of some class/type or another. Functions are instances of the type 'function.' For my perspective, that makes it a class instance at a conceptual level.
For most time-series analysis I prefer to build star-schema models and use a real time-dimension. Your typical time dimension contains about 30-40 attributes, has a granularity of hourly or daily, and rolls up hierarchically to days, weeks, months, quarters, years, etc. This dimension has a single surrogate key that you include with all of your facts to make joins easy. Other non-key attributes might include day of week, weekend/weekday flags, holiday flags, ansi vs iso weeks, etc. You invest the time once to build a nice model, get performance benefits with large data sets, and and development benefits with whatever technology you're working with: SQL, python, ruby, etc. EDIT: this technique is common to data warehousing. Any media on this topic should provide a basic overview. A few specific things to check out include: * The best book is probably Ralph Kimball's [Data Warehouse Toolkit](http://www.amazon.com/Data-Warehouse-Toolkit-Complete-Dimensional/dp/0471200247). * [Stackoverflow](http://stackoverflow.com/questions/2507289/time-and-date-dimension-in-data-warehouse * [wikipedia](http://en.wikipedia.org/wiki/Online_analytical_processing) * Kimball also has a [forum](http://forum.kimballgroup.com/dimensional-modeling-and-data-architecture-f6/modeling-time-dimension-t135.htm) You should also be able to find some basic source code. I found one project on sourceforge [here](http://sourceforge.net/projects/dbtime/). No idea if it's any good or not. It isn't hard code to write - just code that nobody should really have to write these days - it's been implemented thousands of times. I can't share my existing solution since it belongs to my employer.
http://matplotlib.sourceforge.net/
Well, SunOS didn't get rid of that before it was retired... the pipe() call was written in such a way as it called sh IIRC.
check out [dateutil](http://labix.org/python-dateutil) 
[`datetime.strptime`](http://docs.python.org/library/datetime.html#datetime.datetime.strptime) Sort your data set and pick the zeroth entry.
I have called this setting-get in the past
[`time.strptime`](http://docs.python.org/library/time.html#time.strptime) or [`datetime.strptime`](http://docs.python.org/library/datetime.html#datetime.datetime.strptime) Sort your data set and pick the zeroth entry.
hah! i read the subject then was distracted and didn't read the post; came back and just submitted my first thought. thanks for clarifying!
Thanks for linking us over there!
Mutating methods in Python generally return `None`. `append` is a mutating method. So, it returns `None`. 
I don't mean to bash this, as I'm sure this script is perfectly appropriate and useful for this person, but I see two major issues: 1. Pure-SQL migrations are a bit limiting. Sometimes you need to process some data in a manner which is difficult or even impossible to do in SQL, especially MySQL's sometimes frustrating implementation. This is not a problem if you are just modifying schema, but sometimes you need to re-process data too. For example, if you're adding a new constraint, you might need to alter some of the existing data so that it will meet the new constraint. Say, fixing up some inconsistently-formatted phone numbers or something. 2. While the sequential nature of a simple migration system like this works great for one person doing development in a linear fashion, it really breaks down when you have a lot of people working on different branches in parallel. Sure, the last migration you ran was #78, but you just merged a branch into your main line and it brought a migration numbered #71 with it. Oh, and there are two #71's now. It is easy to fix this though. Instead of tracking the last migration run, you just track the number+name of every migration ever run. When you run the script, it looks for any migrations not run before and runs them in order (with maybe a warning or prompt). South solves both these problems quite elegantly and I wonder why, specifically, this person didn't want to use it. There have been *countless* man-hours poured into that project and it's really polished at this point. To pass up a quality tool like that in favor of a home grown script seems crazy. Then again, I'm stuck with a bunch of home grown scripts at my job, so maybe I'm just biased...
I made a convenience module for my own use: #!/usr/bin/python "Convenience module for subprocess." from subprocess import Popen, PIPE def run(commands, input="", binaryout=False, encoding="UTF-8", stdin=PIPE, stdout=PIPE, stderr=PIPE): """Returns the result of piping the commands into each other. command can be string (will be split on "|") or a list of strings or a list of lists. It doesn't use lexical parsing, so if you want sophisticated nesting, use a list of lists.""" if hasattr(commands, "split"): commands = commands.split("|") commands = [cmd.split() if hasattr(cmd, "split") else cmd for cmd in commands] #"reduce"s the stdin from one process to the next for each command #Set up itercmds = iter(commands) command1 = next(itercmds) #If there's not even one command, who's calling? process1 = Popen(command1, stdin=stdin, stdout=stdout, stderr=stderr) process = process1 #In case there's only one command stdin = process1.stdout stderrs = [process1.stderr, ] #Cycle for command in itercmds: process = Popen(command, stdin=stdin, stdout=stdout, stderr=stderr) stderrs.append(process.stderr) stdin = process.stdout #Deal with unicode #If you want some other encoding, send us bytes. if isinstance(input, unicode): input = input.encode(encoding) process1.stdin.write(input) output = process.stdout.read() err = ''.join(err.read() for err in stderrs) if not binaryout: output = output.decode(encoding) return output, err
Wrong definition of graph.
That perspective, while valid, is not that of a *user* of Python, at least most of the time. When using (and writing) functions, one generally doesn't think about the fact that each function is an instance of a function type. The conceptual level you're talking about is a little lower than common usage - when one thinks about how functions are *implemented* as opposed to how they are *used*.
Of course giving a try is important... A couple of days might be enough for you to get an idea of a framework. But thats not enough for you to understand its limitations. And its documentation most probably will not talk about its own limitations. So be aware that something that makes you get started quickly might not be that good in the long run.
beanstalkd. beantalkc for python.
We don't currently have any plans to provide a reduced functionality version of PyCharm. And if we ever did, it would definitely not include Django and Google App Engine integration.
I am planning to do that. I am going to fool around with a couple of frameworks to see which one I am most comfortable using. I will certainly need a good dash of JS for this, but I will also need to have something solid on the server side. JS alone won't be enough:)
This was my initial thought. But I want to believe it's possible in the browser :)
I don't want to belabor this too much, but vice versa, a lot of times you get code like `x = thingie(y)` and on the surface, you'd think `thingie` is a function, but secretly behind the scenes it's a class. For example, that's how a lot of decorators work. So, that's another thing that makes me feel like the class/function divide isn't so great in Python. But coming from the other side.
&gt; No offense, but: Hmm, either you don't really mean this, or we have a different understanding of "offense". &gt; 1.You've been a redditor for 4 months, for people who were in /r/python 2 years ago, your qualification of mdipierro as "professional" and "gracious" are laughable if not insulting. Well, it is possible to read reddit posts from two years ago, so when I joined reddit does not determine my qualifications. In any case, I wasn't talking about two years ago -- even in this very thread, just contrast your own language and tone with that of mdipierro. As an outsider, as I have read some of these exchanges, it has been very difficult to take mdipierro's detractors seriously. Their hostility and inability to articulate thoughtful arguments in a polite manner suggests something else is going on. &gt; 2.In your 4 months on reddit, according to your comment history, you've done nothing but plug web2py I like web2py and have made what I believe are relevant comments that I think will help others cut through some of the distortions about it and therefore benefit from what it has to offer. If you believe I have made incorrect statements, please point them out, and I'll be happy to correct them. Otherwise, I'm not sure what your point is here. &gt; fellate Here's an example of the kind of juvenile language that undermines your credibility. You claim to be concerned about posting etiquette, yet display very little of your own. This makes me suspect your real motivation is something other than policing reddit for proper manners. &gt; You're quite obviously an import from the web2py mailing list What does this mean -- I saw a reference to a web2py-related reddit post and decided to check it out for myself, and then decided to make my own contributions to the conversation? Please explain why that would be inappropriate. &gt; (an approach Massimo used repeatedly in the past in order to garner support when he was at his most annoying) I've seen this claim made before, but I haven't seen any evidence of it. Please provide. &gt; There's a gap between mentioning your tool/framework/lib/whatever when the time is right (e.g. an open-ended question such as "what are the web development options in Python" or a question specifically about the tool) and spamming every single web development thread (including threads solely about a specific question concerning a different web framework) If the thread is about a topic for which web2py would be a relevant option, then why is it inappropriate to mention how web2py would handle it? Perhaps you can provide some examples of posts where you think web2py was not relevant and therefore qualified as spam. &gt; as well as plain and simply lying about other tools with laughably incorrect "comparisons". Do you have examples? Do you make a distinction between mistakes and lies? If mistakes were pointed out, were they corrected? &gt; He compounded that by pretty regularly posting on the web2py mailing list linking to reddit threads and asking for support. Again, do you have examples? What do you mean by this? Was he asking for votes, or just informing the web2py community about reddit posts relevant to web2py (which would naturally be of interest to the community, no)? &gt;&gt; I want to see this kind of information, particularly from the very creator of the framework, who knows it best. &gt; Irrelevant, that's not the issue. Armin posting about Flask is enjoyable, Armin repeatedly posting about Flask in response to web2py question would not be viewed positively. I agree it would be inappropriate for Armin to post about Flask on the web2py mailing list or for Massimo to post about web2py on the Flask mailing list. But neither of them are doing that. Reddit is different -- it's an open forum not dedicated to a particular framework. In any case, I think it's rare for Massimo to post about web2py in a thread that is specifically about a particular framework. But again, depending on the context, I wouldn't say that's always inappropriate. For someone who's not already committed to a given framework, it can be very helpful to learn about web2py (or Flask, or whatever) even within a discussion about another framework. Also, I should note that recently, there was a reddit thread about Django and web2py, and a number of Flask folks started posting about Flask and bashing web2py -- and this was instigated by Armin himself. Seems to be a bit of a double standard here. &gt; And of course, Armin doesn't have anything to sell you, but if you were intrigued by Massimo's spamming and checked the web2py website, what you got was not even crummy and dry Rails-style API doc (with links to 5 billion blog posts) let alone a hand-written, complete and comprehensive documentation à la Django, it was suggestions to go on Lala and buy Massimo's book which would tell you about Massimo's framework. Which made Massimo a spammer trying to sell you something. I doubt Massimo has ever made more than a pittance from the book sales -- probably not even close to covering the cost of hosting the web2py.com site. In any case, the book has been available for free online for quite a long time. Furthermore, if you actually become a web2py user and join the mailing list, you'll probably receive enough free support from Massimo personally to cover the cost of many many books -- in many cases, he'll even debug your code or help you write it. &gt;&gt; I can only conclude that those who are so put off must have some other agenda. &gt; That's just your persecution complex talking. Perhaps I wasn't clear -- I made these observations about web2py while I was still researching frameworks, *before* I even decided to try web2py, so your "persecution complex" theory doesn't hold any water. The point of my comment, though, was to provide a different perspective -- that of someone new to the Python web framework world with no agenda other than learning. Granted, perhaps someone who lives on reddit and averages one or two comments every waking hour would tire of mdipierro's posts about web2py. But not everyone is scouring every /r/python thread every day for months on end. Old threads fade into the past, and new people come in and need to be informed. I was one of those people and was happy to find relevant web2py information.
No offense but you are sounding like a nasty anti-fan. What you are saying about Massimo is untrue or highly exaggerated. I have been around so I know what's going on. Armin has been bad-mouthing about web2py for years. I mean, years. He also spread false information; and was corrected. Did you say he "lied"? Massimo is clearly very passionate about web2py and aggressive in promoting it. Sometimes, he got wrong information about other frameworks and thanked people when those incorrect information was pointed out. But the level of nastiness directed to him and web2py is manifold more than he has had toward you guys or your frameworks. In fact, I have never witnessed Massimo had negative comments about other frameworks or people. You guys are doing a great disservice to the community by bullying Massimo and web2py. Web2py is a small open-source project. It is free. And many , including myself, have found it's useful. Unfortunately, it doesn't fit your taste, and you guys have been very nasty to it for *years*. This is just so stupid and immature. Please stop it. 
&gt; If the thread is about a topic for which web2py would be a relevant option, then why is it inappropriate to mention how web2py would handle it? Perhaps you can provide some examples of posts where you think web2py was not relevant and therefore qualified as spam. This is an example where it was inappropriate to post bits of code because no one was asking for a solution or an advice, it was a post about an example on how to use a framework. http://www.reddit.com/r/Python/comments/e6abx/getting_started_with_pyramid_a_notes_application/c15p52v 
It is not inappropriate to make a point using code examples instead of using natural language. The latter is ambiguous. I trust people who understand both the pyramid code and the web2py code understood the issue I was raising.
Actually, the linked blog entry itself was code for an application using Pyramid, so mdipierro's "bits of code" were indeed relevant -- he was showing how to do the same thing (more easily) in web2py. This isn't Stackoverflow -- comments do not have to be in response to a specific question or request for advice.
[django on reddit](http://www.google.com/search?q=django+site%3Areddit.com&amp;hl=en&amp;client=firefox-a&amp;hs=rXa&amp;rls=org.mozilla%3Aen-US%3Aofficial&amp;sa=X&amp;ei=g_f3TMG8EdGbOva70bcI&amp;ved=0CAkQpwU&amp;source=lnt&amp;tbs=cdr%3A1%2Ccd_min%3A1%2F1%2F2008%2Ccd_max%3A12%2F31%2F2010): 736 [pylons on reddit](http://www.google.com/search?q=pylons+site%3Areddit.com&amp;hl=en&amp;client=firefox-a&amp;hs=rXa&amp;rls=org.mozilla%3Aen-US%3Aofficial&amp;sa=X&amp;ei=g_f3TMG8EdGbOva70bcI&amp;ved=0CAkQpwU&amp;source=lnt&amp;tbs=cdr%3A1%2Ccd_min%3A1%2F1%2F2008%2Ccd_max%3A12%2F31%2F2010#sclient=psy&amp;hl=en&amp;client=firefox-a&amp;hs=0Za&amp;rls=org.mozilla:en-US%3Aofficial&amp;tbs=cdr:1%2Ccd_min%3A1%2F1%2F2008%2Ccd_max%3A12%2F31%2F2010&amp;q=pylons+site:reddit.com&amp;aq=f&amp;aqi=&amp;aql=&amp;oq=&amp;gs_rfai=&amp;pbx=1&amp;fp=fe973fefaf95f4eb): 497 [flask on reddit](http://www.google.com/search?q=flask+site%3Areddit.com&amp;hl=en&amp;client=firefox-a&amp;hs=rXa&amp;rls=org.mozilla%3Aen-US%3Aofficial&amp;sa=X&amp;ei=g_f3TMG8EdGbOva70bcI&amp;ved=0CAkQpwU&amp;source=lnt&amp;tbs=cdr%3A1%2Ccd_min%3A1%2F1%2F2008%2Ccd_max%3A12%2F31%2F2010#sclient=psy&amp;hl=en&amp;client=firefox-a&amp;hs=2Ev&amp;rls=org.mozilla:en-US%3Aofficial&amp;tbs=cdr:1%2Ccd_min%3A1%2F1%2F2008%2Ccd_max%3A12%2F31%2F2010&amp;q=flask+site:reddit.com&amp;aq=f&amp;aqi=&amp;aql=f&amp;oq=&amp;gs_rfai=&amp;pbx=1&amp;fp=fe973fefaf95f4eb): 221 [web.py on reddit](http://www.google.com/search?q=web.py+site%3Areddit.com&amp;hl=en&amp;client=firefox-a&amp;hs=rXa&amp;rls=org.mozilla%3Aen-US%3Aofficial&amp;sa=X&amp;ei=g_f3TMG8EdGbOva70bcI&amp;ved=0CAkQpwU&amp;source=lnt&amp;tbs=cdr%3A1%2Ccd_min%3A1%2F1%2F2008%2Ccd_max%3A12%2F31%2F2010#sclient=psy&amp;hl=en&amp;client=firefox-a&amp;hs=Hba&amp;rls=org.mozilla:en-US%3Aofficial&amp;tbs=cdr:1%2Ccd_min%3A1%2F1%2F2008%2Ccd_max%3A12%2F31%2F2010&amp;q=web.py+site:reddit.com&amp;aq=f&amp;aqi=&amp;aql=&amp;oq=&amp;gs_rfai=&amp;pbx=1&amp;fp=fe973fefaf95f4eb): 200 [web2py on reddit](http://www.google.com/search?q=web2py+site%3Areddit.com&amp;hl=en&amp;client=firefox-a&amp;hs=rXa&amp;rls=org.mozilla%3Aen-US%3Aofficial&amp;sa=X&amp;ei=g_f3TMG8EdGbOva70bcI&amp;ved=0CAkQpwU&amp;source=lnt&amp;tbs=cdr%3A1%2Ccd_min%3A1%2F1%2F2008%2Ccd_max%3A12%2F31%2F2010#sclient=psy&amp;hl=en&amp;client=firefox-a&amp;hs=UYa&amp;rls=org.mozilla:en-US%3Aofficial&amp;tbs=cdr:1%2Ccd_min%3A1%2F1%2F2008%2Ccd_max%3A12%2F31%2F2010&amp;source=hp&amp;q=web2py+site:reddit.com&amp;aq=f&amp;aqi=&amp;aql=&amp;oq=&amp;gs_rfai=&amp;pbx=1&amp;fp=3f2d83e828bdfbc): 71 Notice how web2py is three times as old as Flask and Flask has 3 times as many reddit posts over the last 3 years. EDIT: Fixed links
Agree with you that code could be clearer in some context, what I'm pointing out is that your comment was not related to the framework in question but was about another one. Why not blogging your own stuff?
Oh, the web2py astroturf is back, swell. &gt; No offense but you are sounding like a nasty anti-fan. If I am, you can blame Massimo for it. &gt; What you are saying about Massimo is untrue or highly exaggerated. Nope. &gt; I have been around so I know what's going on. Conspiracy theories. Great, just what I needed to brighten my morning. &gt; Armin has been bad-mouthing about web2py for years. That might be. I haven't seen that, and a quick google search returns stuff like [this]( http://markmail.org/message/wgto2rop2qz5x3tv#query:Armin%20web2py+page:1+mid:62xsqfpe7mb3yvnj+state:results) and then previous declarations that Armin is out to get web2py and has been for years by… well… [you](http://www.reddit.com/r/Python/comments/ddkal/django_vs_web2py_what_do_you_use_and_why/c0zrelt). Though I'll readily acknowledge Armin might be a bad example, I picked him up because I never saw much negative on or from him and some colleagues enjoy using (and talking about) Flask lately, so it was on my mind. &gt; Massimo is clearly very passionate about web2py and aggressive in promoting it. A bit too much, and that's the whole fucking point. You apparently missed the whole purpose of my comments here. Please go read [this comment](http://www.reddit.com/r/Python/comments/edvws/an_often_asked_question_to_which_i_still_dont/c17f4ev) &gt; Sometimes, he got wrong information about other frameworks and built utterly nonsensical tests which he then promoted on his site as demonstrations that "web2py is better than django" (also a weird obsession of his: that there's a heated competition between web2py and everything else and it's a fight to death, from your comment and those of av201001 it sure looks like the web2py community at large has the same issue) &gt; and thanked people when those incorrect information was pointed out. Not much else you can do when you're confronted with cold facts and harsh reality. &gt; You guys are doing a great disservice to the community by bullying Massimo and web2py. Web2py is a small open-source project. It is free. And many , including myself, have found it's useful. Unfortunately, it doesn't fit your taste, and you guys have been very nasty to it for years. Uh yeah, whatever, you guys are nice and persecuted and everybody is out to get you and your dear leader. I don't think there's any point to this "exchange".
Son of *@#&amp;$. I spent an hour searching on the web for that before writing my own. Oh well it was a good exercise at the least. But now... PERFORMANCE COMPARISON :D Mine will probably fail but it'll be fun ^_^
You are right but I was making a point about pyramid by making that example: Their post was supposed to be a howto but was extremely verbose.
The comment was relevant because it was related and added value to the targeted framework ;)
1. no, because you managed to fuck up 4 of these 5 links, they all search for django 2. google counts mentions, not posts, which include comments. And [flask](http://www.reddit.com/comments/67ikm/recipe_for_lsd_or_pcp) [is not](http://www.reddit.com/r/AppEngine/comments/bqlko/flasktodo_example_app_engine_todo_app_on_micro/) [just a](http://www.reddit.com/r/TwoXChromosomes/comments/e4sm3/what_would_the_tsa_do_if_they_found_a_menstrual/) [web framework](http://eo.reddit.com/r/AskReddit/comments/dc2kb/just_bought_a_new_hip_flask_what_is_the_ideal/). Your queries make no sense whatsoever 3. Using Reddit's own (and now excellent) search within /r/python returns [40 matches for web2py submissions](http://www.reddit.com/r/Python/search?q=web2py&amp;restrict_sr=on&amp;sort=relevance) versus [10 for Flask](http://www.reddit.com/r/Python/search?q=flask&amp;restrict_sr=on&amp;sort=relevance) including a common submission [by yourself](http://www.reddit.com/r/Python/comments/dwmsj/playing_with_others_web2py_dal_on_flask/) 4. And even if you were right and Flask had seen more mention than web2py… so what? What would Flask being more popular than web2py mean? That there's a global conspiracy against you because Flask spread quite fast by peer-to-peer and by reaching influential people and being found nice?
Can you recommend any tutorials/resources relating to these techniques?
Not sure what you mean here. The post was in /r/python, not /r/Pyramid. In any case, I think mdipierro was making a point about the verbosity of the Pyramid code and suggesting it could be more terse (but still clear). Judging from the net downvotes, though, I'd say the readers didn't find it pertinent, so your point is well taken in this particular case.
True. Google counts comments as well as posts. I thought you were complaining about my comments, not posts. Anyway, your links for Flask shows 16, not ten. Yes it is less than 40 but consider web2py has been around since April 2010 and web2py since Oct 2007, it is still more than a factor 2/year. I am not making a statement about Flask which is a good system and I am happy it is popular. I am merely observing that your complaints about web2py are biased.
I use and rely on South extensively but I've seen enough teams struggle with it to know that there isn't a good enough body of documented information about how to work with it successfully in a team workflow. Especially for larger projects with many running feature branches, custom fields and models, 3rd party models, fields, and migrations, etc. South can require a LOT of careful attention to keep everything running smoothly as possible. I can sympathize with why developers might get the impression that rolling their own is the way to go. IMO key factors to success are a) making sure all the developers understand how south works and what the limitations are b) frequent verification that the full migration suite can run against a fresh DB c) being able to decide that an occasional migrations "reset" is less pain than trying to workaround a South limitation. In practice I've rarely seen use for rolling back more than a couple migrations. 
&gt; True. Google counts comments as well as posts. I thought you were complaining about my comments, not posts. And it still counts the wrong thing since a number of the matches for Flask have absolutely no relation to the web framework (unless you're going to argue that [this thread](http://www.reddit.com/r/funny/comments/dgcpz/men_without_adult_supervision_pic_3/) contains any comment about the flask web framework?) &gt; Anyway, your links for Flask shows 16, not ten. Ah true, I checked the report at the top right instead of the actual number of results. &gt; Yes it is less than 40 but consider web2py has been around since April 2010 and web2py since Oct 2007, it is still more than a factor 2/year. I still don't see what relevance it has. &gt; I am merely observing that your complaints about web2py are biased. I have no complaints about web2py, I don't care for it, I have complaints about *you* and I fail to see how your comment comes even remotely close to addressing anything.
Stay away from Visual Basic. Python would be my number 1 recommendation ... followed by Ruby.
&gt; Oh, the web2py astroturf is back, swell. What does this mean? Are you suggesting vph is not a real web2py user but is somehow being compensated for posting about it? &gt;&gt; vph: I have been around so I know what's going on. &gt; Conspiracy theories. Wait, how is claiming to be aware of the history a "conspiracy theory"? You yourself claim to be knowledgeable about the history -- does that mean you're hocking conspiracy theories too? &gt;&gt; vph: No offense but you are sounding like a nasty anti-fan. &gt; If I am, you can blame Massimo for it. You should take responsibility for your own behavior. &gt;&gt; What you are saying about Massimo is untrue or highly exaggerated. &gt; Nope. Hmm, given your presentation thus far, I don't think I'm inclined to just take your word for it. &gt; (also a weird obsession of his: that there's a heated competition between web2py and everything else and it's a fight to death,... What are you talking about? I've seen Massimo praise Django and other frameworks on many occasions. He does believe web2py offers some advantages, which is obviously why he created it in the first place (otherwise, he would have been content to keep using Django). Nevertheless, he has explicitly stated multiple times that he does not believe Python frameworks should be in competition with each other -- here's one such quote: *"Let me clarify that I [think] we should not see Python (or Ruby) frameworks in competition with each other since their markets are correlated, not anti correlated. We are all better off if we do not fight and respect and acknowledge each other work."* -- mdipierro &gt; ...from your comment and those of av201001 it sure looks like the web2py community at large has the same issue) What specifically have I or vph said that implies a competitive attitude toward other frameworks? More generally, I haven't seen any evidence that the web2py community believes they're in a "heated competition" or "fight to the death." Naturally, when you're a newer framework, there will be some tendency to reference and compare with other frameworks (particularly the big players, like Django). But that's not the same thing as having an obsessive competitive posture or "fight to the death" mentality. Even the Pylons, Turbogears, and Flask communities make lots of references to Django. On the other hand, it appears you and others believe you are in competition with web2py, at least judging from all the energy you put into disparaging it and its community. I haven't seen anything like this coming from web2py folks. And then there's [this](http://dev.pocoo.org/~mitsuhiko/against-php.png). &gt; I don't think there's any point to this "exchange". You mean the exchange that you started? I agree.
&gt; 2.google counts mentions, not posts, which include comments. But you were complaining about the fact that mdipierro was posting *comments* in other reddit threads ("spamming web2py in every single fucking thread about python web frameworks"), not that he was creating his own *posts* about web2py. So, counting comments, not posts, is what's relevant here. &gt; 4.And even if you were right and Flask had seen more mention than web2py… so what? I think his point was that Flask is being mentioned at a higher rate than web2py, yet you don't complain about it appearing in "every single $!#%&amp;@ thread about python web frameworks".
I have a convenience module that looks almost exactly like that. 
As I said elsewhere, this cries out for [defaultdict](http://www.reddit.com/r/learnpython/comments/ef0s4/assignment_whats_wrong_with_the_following_code/c17nmbq). 
If you want to see how Armin has been bad mouthing about web2py, all you need to do is Google. How do I know? Because when I did a search on web2py to see what's out there. I am not defending certain aggressive promotion of Massimo. I think he overdoes it. But that's simply because he's not a good saleman. I am not a zealous fan of web2py. I have used Drupal (still using), Django, bottle and web2py. I like web2py but I am also disliking some of its conventions. I have never bad-mouth about any of these. In fact, I quite like bottle for what it does. These are tools not religions. But you guys are ways out of proportion to the point of ridiculousness, and for years. It would be nice if people like you stop making an ass out of yourselves whenever web2py is brought up. 
&gt;That's what he earned from his previous months of spamming web2py in every single fucking thread about python web frameworks. For a long time, web2py is a one-man show ( in terms of promotion). When a newbie comes in and asks, "please show me some frameworks", Massimo has every right to jump in and say, "please consider web2py; it has these good features". That is not spamming. That is entirely legit. What Massimo might not have realized is that, when this thing is done over and over again, it might be tiresome to folks like you. But on the other hand, from the perspective of a newbie who is asking questions about tools, it is completely helpful to him/her to know of web2py. Therefore, while not entirely good for PR (as it annoys people like you), there is nothing wrong with doing what Massimo has done, which you call "spamming". If you don't like his personality, that's fine. But bullies like you keep bad-mouthing about a tool largely because you don't like the personality of his creator is wrong. And when it goes on and on for years, it's too much, man. 
If anyone needs help learning python, feel free to message me about problems.
Take a look at Werkzeug from th Pocoo project: http://werkzeug.pocoo.org/documentation/dev/debug.html For web development, it lets you break into a fully interactive shell on exception at any point in the stack, viewing locals at that point in the stack, and giving you a full interactive prompt at any stack level. It's awesome.
Are you using sys.settrace?
Very nice, thank you. I'll give it a shot and see how it goes.
Having callable back: meh. Seeing Guido toppost: Priceless.
Stackless/greenlet + Actor model is what i would use to code it, But as far as sending to clients something like the following would work def sendMsg(msg): map(lambda client: client.send(msg), client_list)
Not quite what I'm looking for but thanks for trying to help. It only gives the last know state of the variable instead of all states taken through out the program. 
I like the new website, as well.
Maybe dict.confirm_then_get(key, if_missing) ?
I suspect that the average case right now isn't that far off (though the worst case obviously is). 
About a year ago I wrote something very similar based on Tornado Web. I never had a real application for it, so I couldn't figure out how scalable it was, but it was a fun thought experiment.
Nice. You don't have to keep track of entire list of guesses; just use randint to get a random integer in an interval. As a next step, try incorporating the notion of "strategies". For example, you have a random guessing strategy. How about a pessimistic (always guess low), optimistic (always guess high), and optimal (always guess in the middle) strategies? As a stretch goal, try storing the numbers the user asks you to guess somewhere and perform learning to devise optimal guessing strategy. This could take a few months :D.
If you need the admin, go with django. Else do yourself a favor and take pyramid
This tool should be included in wxPython
Ah -- yes. Sorry, in my defence I have to say it was early in the morning when I posted the other reply.
Wow. I can't tell how many of those comments are jokes and how many are people just being retarded.
Beautiful [bikeshed](http://bikeshed.com/).
Anyone else thought this was a joke about Day[9] from StarCraft?
I know, that's the beauty of it.
j &gt; i
WTF. I am a mathematician and can care less about it. 
Who's superior: Mathematicians or Engineers? [***FIGHT!***](http://images.encyclopediadramatica.com/images/c/cd/Trool.png)
Exactly. I'd prefer i over j, having both work might be the best choice in the future, but it's really not worth a fuss. 
I think most are legit. This looks very similar to the conversations I've had when drinking coffee at a mixed table of mathematicians and engineers/physicists.
In case anyone is wondering "why j?", in engineering and physics 'i' is convention for current.
Its close but engineers win according to [Google Fight](http://www.googlefight.com/index.php?lang=en_GB&amp;word1=Mathematicians&amp;word2=Engineers)
Aren't all numbers imaginary?
I am a magician and what is this?
In other words, you have a positive value for caring about it.
Why don't you stuff it all into sqlite (with the module) then query out (vanilla SQL or ORM) what you need? see: http://www.sqlite.org/lang_datefunc.html
Basically, the reporter is dead serious, and the replies of coredevs range from mildly serious to downright absurdly humorous.
all but Zero, One and Infinity :)
The correct answer is physicists.
bugs.python.org should have: &lt;title&gt;'fawlty towers'&lt;/title&gt;
Why do you care? Maybe you aren't a native english speaker and got your sentence completely backwards.
I like how care is finite and quantifiable; it really makes life feel like a useless MMO game.
I read: "In support of my book, I'm posting a new thread on /r/python now."
You assume that you can't have negative caring. I think caring is quantified on rationals (I refuse to allow you to say you care e or pi amount), so there is no value of caring which you could not care less about it.
So you can't read?
decimal does not calculate precisely, it just calculates in base 10 instead of base 2. 
Oh, you are a real punk.
Amazon really isn't the bad guy here. If I were Amazon I most likely would have done the exact same thing *if* wikileaks did in fact violate the TOS. It isn't up to Amazon to play the arbiter of truth no matter how badly you wish it. We need to stop targeting Amazon for being the bad guy. I am all for wikileaks and all that they're exposing but if you really want to do something for wikileaks, why not ask them what you can do? I'm for the truth here not revenge. What can we responsibly do to help wikileaks should probably be the question.
If I was every going to buy or recommend your book then I'm sure not going to now.
Your guess should always be halfway between min and max. That's the optimum guessing strategy, it cuts the range to search in half each time.
As an EE, I disapprove.
I'm a big fan of what WikiLeaks is doing, but this seems like a waste of time to me, unless your goal is masochism. Amazon didn't "bend to Congressional pressure" or anything else. They simply don't allow sites that breach their ToS on their network. Nothing else. So, in retaliation, you're robbing yourself of an amount of money, that will be Affect Amazon's stock price ~1/100000th of a point. Why?
The best response in my mind was this one: &gt; If this change were important, the numpy/scipy guys would have requested it long ago. It's kind of like arguing we should use ":=" instead of "=" because "=" means something different in mathematics. It's just not that important.
But this is what I don't understand, why i for current? Why not something more descriptive or something fancy? I'm pretty sure that imaginary units have been around longer than electromagnetism, why screw with the notation. Oh well I hate the 'i' notation anyway, I prefer using ordered pairs: z =(a,b).
You have to be kidding me.
&gt; Just to add my own thoughts: 'j' for *a* (not *the* &lt;/pedantry&gt;) square root of -1 has, as Michael points out, a history of use in engineering What does he mean about how i (or j) is *a* square root of -1, and not *the* square root thereof?
admittedly I only took a couple of non cs engineering courses but they used i for what its worth.
If you define the square root as the inverse of the square (that is, given x = √y then x^2 = y) , then √4 is both 2 and -2. (Square root is not a function in this sense.) Therefore -1 has two square roots: i and -i (as i is not generally defined as ±√-1)
Having both doesn't really follow the Python "only one way to do it" philosophy though, does it?
*i* is for *intensité*, the french translation of *current*. Be sure to thanks Mr Ampère for this :)
Caring is in [0, infinity), obviously. 
A lot of first years, or in general people who haven't programmed before, do find = to be very confusing. How can x = x + 1? So there is a case for using := if one is designing a new language for beginners. None whatsoever in the mainstream, though.
I don't think you can use inequalities with imaginary numbers. 
|j|&gt;|i|
http://www.youtube.com/watch?v=om7O0MFkmpw&amp;t=0m55s
Because *c* is already the speed of light.
I think by the time people were getting to environment variables it was well and truly humour. Apart from those that didn't get the jokes. I laughed a lot
I keep hearing this, and (assuming it to be true) it floors me. I don't recall any confusion whatsoever when I was learning BASIC as a kid. I fail to understand why allowing a symbol to mean multiple things is any more confusing than allowing a word to have multiple meanings (a violin bow; to tie a bow).
If the teacher says on the first day "the equals sign in C is NOT an equals sign", then maybe it shouldn't be a problem. But I bet a lot of people do not make this explicit. Also, don't forget that some people are coming to programming after a traumatising period of struggling with maths in school. This mental state can't be compared to that of a 2-year-old child which is programmed to accept language, including contradictions like the example you gave, and learn it happily.
I just realized this shortly after posting, kind of embarrassing actually! 
And in all honesty, you can only define square roots in this way. When you do this, there are three cube roots of 1, for example: e^(2πi/3) , e^(4πi/3) , 1.
Actually the french translation of current is simply "courant"... 
A mathematician, a physicist, and an engineer were each asked to comment on the assertion "All odd numbers are prime." The mathematician at once gave a counterexample, 9. The physicist said "1 is prime, 3 is prime, 5 is prime, 7 is prime. Now at nine we see second order effects!" The engineer said "1 is prime, 3 is prime, 5 is prime, 7 is prime, 9 is prime..."
Surely mathematicians were using it first? So why change the notation?
I expected a mathematician to have got the correct logical statement there long ago :\
Cause apparently physicists and engineers were using the computers more than mathematicians. Mathematicians do everything on paper anyway. As to why engineers changed 'i' to 'j'. Simply cause 'i' for current was more important and used more often.
With √-1, the two square roots are absolutely interchangeable, in a way that 2 and -2 are not.
it is a crazy invention of the electrical engineers, it caused me a lot of rage when i was a sophomore in college and taking electrical electives...
9 is close enough to being prime
But aren't people half joking in such conversations too?
But i = j, so |i| = |j|. ↯
I'm too spoiled by railscasts to listen to an MP3 :-)
That's exactly what's happening with CentOS and Python 2.4 right now, although I hear EPEL 6 will move to Python 2.6.
1 isn't prime.
It's "There should be one-- and preferably only one --obvious way to do it.". Meaning that there can be multiple nonobvious ways to do it. Nobody is stopping the "i" camp from doing: def icomplex(n): return complex(str(n).replace('i','j')) Oh man, now I'm actually responding to a bikeshed issue. :(
There are lots of jokes that make fun of engineers, especially with regard to their lack of personality, but for some reason I find a joke about engineers being bad at math offensive. How odd.
&gt; default_exceptions = (Exception) Looks like it's supposed to create a tuple, but actually doesn't. I don't think it matters because Except doesn't care whether you pass a tuple or a single exception class, but it's kind of confusing.
This is quite nice. A minor point: I strongly prefer decorators not to be implemented as classes, because then they cannot decorate methods (due to the self argument not being passed to the decorator).
http://blogs.msdn.com/b/oldnewthing/archive/2005/11/07/489807.aspx
Pretty sure you can work around that using the power of descriptors http://www.outofwhatbox.com/blog/2010/07/python-decorating-with-class/
default_exceptions = (Exception,) # this should remedy that situation.
For some reason, I cringe when I think about 'retry' anything as a solution to the problem. There is nothing technically wrong with it, but to me is speaks to an architectural problem to use a 'retry' as a way to recover from an Exception. I guess it is a quick and dirty, pragmatic way to say - hit a webservice - and then worry about a 'real' solution if it becomes a problem. I guess it really depends on what you intend to use this for. 
I forked the gist and rewrote it as a function based decorator and added some simple tests: https://gist.github.com/728327 (It also the retry argument is now how often the function should be retried, not how often it should run)
Were they electrical or circuits? That's where you deal with current a lot.
cool- stop over to http://www.reddit.com/r/learnpython there's some basic assignments that you can do and look at other's code as well. 
Sometimes it feels like everything I try to do in Python is already a function-- do a program to flip a coin- why not use random.choice(x)? Make a code program? Just use codecs. Shuffle a deck of cards? random.shuffle(x) It seems like its very important to understand everything Python can do on its own so you don't continue to reinvent the wheel. 
Indeed, the python community is great for stuff like this which is a great reason to choose python over alot of other languages.
Yeah, you'd only really want this for IO issues.
I had the same response. You'd have to be careful that the function you're retrying has no side effects or that the side effects are harmless. 
Also, Orient offers a Graph DB option where documents act as nodes and edges Node --&gt; Edge[{properties}] --&gt; Node This isn't available in the REST or BINARY interface yet, you have to be working in the environment (Java through Jython or straight up Java). I was thinking about adding another module to compass that does the graphing and was wondering if anyone had any thoughts on how to mimic (using compass' Document object) a graph of nodes and edges?
Why? If you want to know what type a variable holds then just ask it. repr(x.__class__)
Because then I would need to "ask" each variable if it has changed or not rather than detecting what variable has changed.
My true question is; why do you need to monitor when a variable changes?
Simple answer would be debugging and more explicit exceptions. Longer answer would be to allow the user to define Exception handler to alter the default behviour when an exception is thrown. The change over time of the variable(s) invloved might help the user to see what went wrong but it will be only one of many tools.
I will test it and let you know how it works, thanks
Generally my main loop will look something like this: while True: try: next_thing = get_next_thing() do_stuff(next_thing) except Exception, e: log.exception(e) Then assume that `do_stuff` (and its decentness) will make sure that relevant data remains consistent. I'll then look at the logged exceptions to and “figure out what to do” (eg, fix the code, ignore them, etc). Hope that helps.
If you're using classes, overriding `__getattr__` or `__getattribute__` might be sufficient.
Personally I would suggest modifying bytecode on the fly to store this information somewhere. The question is also - from where you need to know this?
It's for my final year project. I'm not a fan of manipulating bytecode because it requires the source code to be parsed twice. I'm more looking for appending additional code to what happens when an assignment operation occurs.
At work I develop a web application. Our policy is basically to catch exceptions as near to when they are caused. Exceptions that you expect should be caught and handled properly, and you should always catch specific exception types: try: access_some_unreliable_3rd_party_service() except WebServiceException, e: log.info("the web service broke again :(", e) redirect_to("web_service_is_broken.html") Exceptions that we don't expect and bubble up to the top are logged thoroughly. The entire traceback stack is bundled up and saved in a database, and an exception email is sent to the developers. In an internal web application devs can view the traceback, the environment dict, and all the values that were on the stack days or weeks after the exception occurred. This is the nicest debugging system for production code I've ever used. I once worked for a company that did this: try: value = some_unreliable_query() except: value = 0 # good enough! That was the WORST THING EVER.
Isn't something like this considered to be bad style? Exceptions are supposed to be just that: exceptional. If you're going to catch them and do nothing with them, you or the library you're working with is doing something wrong.
I've never used it, but I suspect a thorough investigation of the python `ast` module in the std lib will help you out. You could compile the source into AST, the walk the AST and transform assignment nodes into assign-and-inform-the-debugger nodes.
I'm somewhat of a Vim user, but to be fair, the opening time vs the opening time of another app is not really what keeps me using it.
Ok cool thanks, I was thinking of something along this line. Since I don't have a lot of time for my final year project, I'll be mostly focusing on Standard library Exceptions and letting users define how to deal with their own and allow them to plug those handlers into my environment. Do standard exceptions crop up as much as your own created Exceptions?
Thanks looks like that could help. Is this what the interpreter calls to parse the code or a tool that someone developed to convert a program into its corresponding AST? I ask because I'm interested in the method generates the corresponding code. I what to copy whatever gets evaluated on the r.h.s into my environment, index l.h.s. e.g. a = 3 this is write 3 into the memory address of a as well as my_environment["a"] (obviously scopes will complicate the structure of my_environment but thats another matter). There a few ways of doing this. the function passed to sys.settrace can parse whats going on using a tool like PLY or whatever, detect its an assignment, split the tokens, take the 0th string as the l.h.s. It will exec the line and afterwards copy the value into my environment. I could parse the source code myself and insert all of the assignments into my environment after an assignment in the original source code. I could convert each file into an AST and change assignment nodes into what I need it to do. Or I could just hijack whatever low level function or whatever is responsible for generating code for assignments into doing it's behaviour plus mine. I want to do the last choice since it's the only one that does what I need without having to do any more parsing or other complicated stuff. If people know any other way of doing it, I'm all ears.
Depends what you mean by standard library exceptions. In the web service case above I suppose we'd get an urllib2.HTTPError, which is part of the standard library. If you're talking about the exceptions in `__builtins__`, most of the time we avoid those. Almost all of the commonly used function that can generate exceptions have an exception-free variant. eg. v = a_dict.get('some_key', None) instead of: try: v = a_dict['some_key] except: v = None That's just a style choice. I bet other people prefer the except case.
According to the `ast` docs the AST can be outputted by the `compile()` function, which is what Python uses to compile code internally. Also: A modified abstract syntax tree can be compiled into a Python code object using the built-in `compile()` function. So you can open python code as text, compile it to AST with Python's own parser, transform the AST, then output valid compiled bytecode all from within Python itself. If you want to roll up your sleeves with C you can dig into the python source code and accomplish approximately the same thing. The Python C code is very well organized, but I don't know much about it. Oh, finally, you could use the PyPy interpreter (Python in Python) to do similar things. I think you'll have to experiment to determine which is the best approach.
Interesting, thanks. I asked because I was going to use the builtin exceptions as an example in my demonstrations at the end of my project(this is a small amount of research for my final year project), but if user defined exceptions are more common dealt with then I'll put a greater emphasis on those.
Exceptions are a tool. If you are using them carefully and documenting every non-exceptional usage, they might be quite a nice weapon in your arsenal. The same is with dreaded `goto` or fallback `switch` statement in C. For example, I see nothing wrong in using exceptions to force going out of a heavily recursive code--as long as you make a proper documentation! It certainly makes code easier to understand, compared to a cascade of return statements--even if it breaks some style guide. Also note that Python already uses exceptions for signalling an end of iterator. Bad style is just bad style--there is no law that would limit using exceptions only to errors. Style guides are good for most cases, but once in a blue moon you need something that your style guide didn't predict.
Thanks a mil bud. I'll keep these in mind.