Why on earth would you use MongoDB with Django? Django doesn't support MongoDB as a back-end without the addition of some third-party driver, and a standard relational database is perfectly adequate for the project you describe.
MySQL is still the best free option out there for a very broad range of use cases. 
PEP 406: Python 2.7 Phaseout Schedule --- Never
KomodoEdit also does a good job with code completion as long as no one's getting *too* wild and crazy with setattr.
It's customary to put a dependency list in the repo so I don't have to either scour your code for them, or go to run it and have "Stop, go get package, start stop, go get package..." etc etc.
Sad.
&gt; Actually, I like the stance that the Perl people are using: "Perl 5 and Perl 6 are two languages in the Perl family, but of different lineages. If you are looking for production ready code please use Perl 5." Isn't this primarily because of * large differences * a lot more importantly perl 6 is taking a long time I think if perl 6 were more complete a lot more people would encourage upgrading.
So actually pyswip has some segfaults with 64 bits systems so we're considering using pyke : http://pyke.sourceforge.net/ which may be suited to our need
That concludes that compile-time type inferencing plus type-specific bytecodes does not give at least a 5% speedup, assuming you don't want to change the language semantics. If you allow some restrictions or allow run-time JITs then you get different answers, as ShedSkin, pypy, and Cython meaningfully show. 
Unicode and WSGI. WSGI prefers strings to be simple byes, well, now all strings are not just one byte, since unicode. So its messy to port/use most WSGI frameworks. 
They're all Mercurial fans.
&gt; there are enough things from the ultimate utopian image of Pythonic things missing (cough type inference cough) Type inference is not exactly useful without static typing. &gt; Type inference, and optional type declarations, may not be useful for speeding up things, but they would on one hand act as testable assertions You *do* know one of Python3's changes was adding a syntax for type declarations (at function level anyway) right? So that editors may use it if they want?
Ah yes, I think we read about that but since we weren't using 64 we didn't run into that. best of luck!
\# The comment below says I agree I agree
There is a huge advantage going distributed. There really is something wrong with any company still on a centralised vcs.
Except he's probably calling: print most_frequent(s) Which, if it doesn't have a return statement will return None but should also print common.
 def string_count(string): count = {} for char in string: try: count[char]+= 1 except KeyError: count[char] = 1 li = [] for item in count.items(): li.append(item[::-1]) li.sort() li.reverse() return li
Gits.
What have you got against subprocess? It's a library module not a core language feature and I've found it useful several times. 
Your new code should be working. My guess is, if you're using a photo, then the greens you're trying to replace aren't nearly "green" enough for your if statement. Try running the code in the if statement unconditionally -- this should replace all of pica with picb. That should work. If it does, you know it's just a filter tweak. Try setting those values higher: if r &lt; 50 and g &gt; 128 and b &lt; 50: 
can you link me to a site that outlines the disadvantages of using centralised vcs? We use svn at work and personally I have no problems with it.
I can list a few off the top of my head: 1. Faster, everything (branching/merging) is done locally 2. More reliable. There have been times when the main server is down, I can copy the whole repo off a work mates computer. 3. No .svn folders everywhere 4. Better integrity (git/hg use hashes for commit identification) 5. More flexibility. You can have any sort of structure, not just a single server. In our office we've got a local cache server which pushes and pulls from one in the US. Basically it comes down to less pissing around. Fewer merge conflicts (svn is terrible). Easy to create repositories and branches. I can't remember how many times subversion would throw a fit if I deleted a file the wrong way or whatever. I hate using subversion, not only because it's centralized but because it just plain sucks. There is a reason a lot of companies and open source projects have moved away from subversion to git/hg. Even if you only work with a few people and don't branch often it's just plain easier to setup something like mercurial or git. A few links: http://hginit.com/ http://stackoverflow.com/questions/179161/is-a-dvcs-useful-for-one-developer http://whygitisbetterthanx.com/ http://stackoverflow.com/questions/871/why-is-git-better-than-subversion Good luck. 
Speaking from experience, the popular REST APIs ( Tastypie &amp; Piston ) become a real pain to manage if you need to start writing custom behavior for your handlers. Like serializing non-standard fields or working with custom validation on the rest verbs. Piston's serializer also has some serious performance issues when serializing many-to-many relational models. But if you work with generally vanilla Django constructs in standard ways then they'll save you ton of time.
It's so long ago that Perl 6 was conceived that Perl 5 has moved into an entirely different direction since then. I hope that Python doesn't go that way and that there will come a time where Python 2 is ancient history.
NLTK has been mentioned for NLP. openCV has Python bindings for vision. SciPy's kits (e.g. scipy-learn) are great for things like machine learning, text processing etc. There are some other AI projects and links on my (now dormant) AICookbook site: http://blog.aicookbook.com/ Separately if you're worried about slow code and you want some high-performance options check out my long tutorial (typed up from my tutorial at EuroPython 2011): http://ianozsvald.com/2011/07/25/high-performance-python-tutorial-v0-2-from-europython-2011/
Hm, that can be masked out by doing something like: p = input_img.getpixel((x, y)) d = math.sqrt(math.pow(p[0], 2) + math.pow((p[1] - 255), 2) + math.pow(p[2], 2)) g = p[1] if d &gt; 200: d = 255 if d &lt; 255: g = min(p[2], p[1]) output_img.putpixel((x, y), (p[0], g, p[2], int(d))) But then the edges get kind of blurry of course. Any ideas?
Is there some async librairies for Python than arn't network libraries? I'm looking to code in Python in async (like with node.js) but all I found yet is twisted and gevent which are network libraries.
Well, more generally it concludes that the only thing you can infer types on are atomic (read: syntactic) types.
umm ctags much? The ctags and etags programs (hereinafter collectively referred to as ctags, except where distinguished) generate an index (or "tag") file for a variety of language objects found in file(s). This tag file allows these items to be quickly and easily located by a text editor or other utility. A "tag" signifies a language object for which an index entry is available (or, alternatively, the index entry created for that object).
You and I agree on more than you think.
Looking good :) DDL transactions FTW! A question on the graph-based versioning (which I think south uses also) - is it not possible to merge migrations in a single sequential set? I.E. just like we do with code? I'm nervous about having a non-linear migration path for the production db :) Generally all dev branches are merged into a deployment branch. Ideally, in that branch I'd want all migrations to be merged (manually if necessary) into a linear versioning. Other than that - looks really good. Have the env.py completely customizable is a big win, IMO. 
Excluding those I mention above, what other reasons would you suggest MySQL for?
While it's reasonably feature-complete, its API design and implementation are woeful. A single monolithic class with a constructor that takes 10ish arguments. `.communicate()` spins up 2 threads to handle IO, and so on. Another example is, why is everything bundled into a `Popen` class (whatever a "Popen" is anyway). I've never seen code that's managed to subclass `Popen` in any meaningful way. It's a broken abstraction. It's got particular calling styles baked into it, too. For example there is no facility for calling `waitpid()` elsewhere (e.g. an async loop) without breaking your Popen instances. There's no support for the equivalent of `kill(0, pid)`, no `restart()`, and so on. On saying all that, though, I use `subprocess` all the time, and in practice it's alright. I just wish its design was fixed before it got into the standard library. Edit: `Popen.returncode` is also broken, as you need to feed it through platform-specific `WEXITSTATUS` on UNIX or whatever the equivalent may be on Windows. It should at least have been split into `exit_code`, `exit_signal`, and `exit_reason` or similar.
### main.py: print lvl.row_numbers window.window.push_handlers(interact.on_mouse_press) @window.window.event def on_draw(): ... For readability, you should put one blank line between the `push_handlers` call and the `event` decorator. This all runs together too closely. ### game/interaction.py: ## Line 36: if (obj_x[1] &gt; mouse_location[0] &gt; obj_x[0]): if (obj_y[1] &gt; mouse_location[1] &gt; obj_y[0]): ... A more readable alternative would be: if ((obj_x[1] &gt; mouse_location[0] &gt; obj_x[0]) and (obj_y[1] &gt; mouse_location[1] &gt; obj_y[0])): ... ## Interaction.on_mouse_press Your `if`/`elif` could be reduced to... self.grid_interaction((x, y), self.RIGHT if mouse.RIGHT else self.LEFT) ...although maybe not. If this is some multi-button mouse and you get a non left or right click, it'd fall through to left. It's something to think about, though. Additionally, this method always returns `True`. ___ Didn't have time to look at the rest, but I'll see if I can take a look later.
Yeah, a single file containing one id per line would be easier to edit/audit. The VCS would flag independent additions, and when one of the devs gets a migration added in the past Alembic would rollback, then reapply with the new order (or offer to apply anyway if the migrations don't rollback).
How do you play pycross?
Just updated the README with dependencies. I'll also put them here: &gt;Depends on: Pyglet (http://pyglet.org/) Numpy (http://new.scipy.org/download.html)
Muchos Gracias. I got there on my own in the end, but it's always nice to know beforehand.
Each number corresponds to a row of tiles, you know what order and how many tiles are in each row, but you don't know the spacing between them. If you have 5x5 grid and one row or column labeled '5', everyone of those tiles would be marked. If it was 2, then there would be two marked tiles, if it was 2 2, there would be 4 marked tiles with at least one space in between them.
This is exactly the stuff I needed, thanks a bunch!
Fair enough, the API could be better. Still, pretty useful. The situation before was much worse with os.system os.spawn os.popen popen2 and commands. I always had problems getting popen and spawn to do what I wanted.
You've done a much better job with your second version. A small suggestion for table.py, I would have python generated the symbols, invatomicmass, and inv_pro dicts from elements. Your dataset will not change often, so this is only useful for reducing the chance at typos. I use this technique for something similar that changes as the program runs, but I still need to look up from the value instead of the key. I would generate them like this: symbols = dict() invatomicmass = dict() inv_pro = dict() for element, data in elements.items(): symbols[data['name']] = element invatomicmass[data['mass']] = element inv_pro[data['atomic'] ] = element 
Looks like a nice start. I see a couple of files checked in that shouldn't be: game/resources.pyc and game/resources. I recommend putting '*.pyc' in your .gitignore, and being careful what you git add, rather than doing "git add \*" Get the pep8 tool (it's in PyPI so you can just "pip install pep8") and run it on all your .py files. ("find -name "*.py | xargs pep8") This will catch all the little style nits. Ditto with pyflakes, which finds things like unused variables. I personally hate * imports, but I guess they're kind of expected with pyglet's opengl code. You're using a mixture of old-style and new-style classes. I recommend always using new-style classes (inherit from object) unless you know exactly what you're doing.
None at all, old chap.
I also use webfactions, but the new UI of the admin is really making me think about switching. 
Please allow me to direct you to http://www.wsgi.org/en/latest/python3.html
I've read the PEP for adding annotations to parameters - it's not exactly useful without any recommendations for filling it; Without any recommendations on how to use it, different editors or frameworks will probably handle it differently, which defeats the purpose. I do like Cython's "pure-python" mode for declaring the types of globals or locals... http://docs.cython.org/src/tutorial/pure.html
Cannon 2005 ("Localized Type inference for atomic types") talks about using Hindley-Milner type inference and then use the inferred types to have specialized byte codes for certain primitive types; One of the takeaways is that specialized byte codes are not terribly useful. The takeaway of the Unladen Swallow project is that doing trace-based JITting is also not terribly useful if you need to keep the same object layout as CPython. ShedSkin proves that you can do type inference, and realize very impressive speed gains, on something that is very close to Python. LISP compilers show that you can combine optional type inference and guard techniques (i.e., rip out compiled code whenever someone does end up monkeypatching an already-compiled class) to realize very nice speed gains. Maybe we use different meanings of "Python" and "meaningfully" (possibly even for "type inference", as you can do both runtime specialization and optional type declarations and both considerably help the problem of having type information where you need it).
I'm sorry, but most of that is innacurate. * Unladen Swallow didn't do trace based compilation. * CPython's object layout was not the main reason Unladen Swallow failed. * ShedSkin doesn't do type inference on Python, it does it on a subset of Python. When I say Python I mean the thing CPython, IronPython, Jython, and PyPy implement. Not the subset that happens to be easy to implement quickly.
When you're asking for homework help, people are already reluctant to step in. You need to go out of your way to show you have some idea of what needs done. Or else explain why you don't know how to proceed.
You carefully ignored the part of the post that was not about Unladen Swallow [1], and deliberately misread the claim about ShedSkin - also not noticing the point that I made in the grandparent post was about Cython, which is not about supporting all the dynamic trickeries possible with CPython, so I guess you're not actually trying to make an argument of any sort beyond trying to look smart. I said that ShedSkin compiles "something that is very close to Python" - and that good Common Lisp implementations actually have useful fillers for the gab between "very close to [dynamic language with monkeypatching]" and "actual implementation of [dynamic language with monkeypatching], with optional declarations". IronPython and Jython implement a CPython-like runtime and therefore allow monkeypatching, but are also slow enough that you want to move to C# or Java at an early point if you do performance-sensitive work. Cython/ShedSkin are an answer to those who want Python-like elegance for performance-sensitive work, even if it means to be fussy about typing or having to declare variable types (unlike in CPython). [1] point taken, Unladen Swallow does JIT without specialization; Psyco does trace-based compilation keeping the object layout of CPython for 'surviving objects' (and actually achieves a decent speedup because it can optimize locally used things of semi-complex type such as lists of primitive types.
"Oh nina"?
Has anyone tried it? A few weeks ago I wanted to dive in GAE but when I saw it only supported Python 2.5, I decided to wait for 2.7. Maybe the time has come?
Add hard clipping at a lower tolerance value, then stretch the opacity range (0-255) to fit between your tolerance values. I modified your code and included 2 tolerance values [tola,tolb] for full opaque and full transparent. tola, tolb = 200, 100 for y in xrange(input_img.size[1]): for x in xrange(input_img.size[0]): p = list(input_img.getpixel((x, y))) d = int(math.sqrt(math.pow(p[0], 2) + math.pow((p[1] - 255), 2) + math.pow(p[2], 2))) if d &gt; tola:d = 255 elif (tolb &lt; d): p[1] = p[1]-(255-d) d = (d-tolb)*(255/(tola-tolb)) else: d = 0 output_img.putpixel((x, y), (p[0], p[1], p[2], d)) 
hey r/python: do my whole assignment for me &amp;#3232;\_&amp;#3232; 
I'll make a deal with someone, you help find a maintainer for f2pypy (or more accurately, f2ctypes), and once I finish my current branch on PyPy's NumPy, I'll work on exposing the ctypes API. Sound fair?
Really interested in this; related to a post I made a few days ago, responded to by someone on your team? http://www.reddit.com/r/Python/comments/m3l3x/is_anyone_working_on_the_dynamic_automatic/c2xwgxf
Ah, that was the author replying in my post; sorry. Are you on the dev. team?
Thanks for the detailed reply. This workflow sounds great. I'm going to test Alembic over the weekend and get back to you about thoughts on an automated procedure.
What have you written so far?
Node.js is also a networking library. Asynchronous programming really only applies to networking/IO. 
i'm in the process of moving a project over to it (from the ae 2.5 runtime). it works as advertised. 
yes someone felt like getting some karma out of my link ;)
It is working fine for me too. I'm especially happy that I can use lxml now.
Yep, that's probably about as good as it gets.
For me personally, the best way to determine the type of a file is the "file" command-line utility. You could run it in a Python subprocess and use its output to decide what to do. But if you only need to detect filename suffixes, or if you wanted to examine file contents, you could use code like this: accept_suff = re.compile('\.(html?|php|txt)$') accept_content = re.compile('\s(some|words)\s') for root, dirs, files in os.walk(search_path): for fn in files: if(re.search(accept_suff,fn)): path = os.path.join(root,fn) data = read_file(path) if(re.search(accept_content,data)): print path And where the above says "print path" you could put in your copy/move/whatever actions. 
&gt; Thanks :) You're welcome. Now start coding. When you have some code and some specific questions, post again. 
/me hands out some bug reports instead of karma ;-)
This looks like it's from 1993 or something.
It's actually from 2001. He mentions watching "Voyager" referring to Star Trek and is drinking Jolt Cola.
A recursive method would also really help on this one for you. Recursively search through each dir, finding all subdirectories, moving their contents and then stepping back up the recursive ladder until you reach the original dir.
And I'll cheer you all on!
40 YEARS? You are way too overconfident. 
that's what i'm using, very nice library. just now getting the hang of xpath.
Branched migrations should only be used for divergent development in back-branches, e.g. between the maintenance branch for the current version of a product and the ongoing "trunk" development for the next version. When two developers working on the same branch make a change, the change should be serialized.
no need for a python script: find /mnt/exthd -name "*.type" | xargs -I {} mv {} /destination/
[*cough*](http://fwrap.sourceforge.net/) Already being used in conjunction with Cython for a .NET port of SciPy.
It works with [pypcap](http://code.google.com/p/pypcap/) to do pcap-based capture/decoding. (not something scapy can do afaik) 
.NET ams has relevance? PyPy ams most importants as a platform because ams writes in Python. It ams about what Python cans do with a lot of powers and speed, and ams interesting in a sense far more significance than like .NET or Java implementations.
The point is that a Cython backend that generates PyPy implementations would be the best possible meeting point for efforts to wrap scientific (and other) library code, since a) it's become the *de facto* "speed shit up" solution in the scientific Python community for quite a while b) already the most painless way to write CPython extensions, particularly those that wrap C code (or Fortran code via Fwrap), c) already been refactored to the point that a .NET backend can be swapped in, meaning that a similar effort for PyPy would be pretty quick to get off the ground if it hasn't already, and would have huge potential returns (oh and d) there's widespread agreement that large parts of the raw C code in NumPy and SciPy will be rewritten in Cython for maintainability reasons and portability reasons.)
puzzled by this comment, unless there's a simple misunderstanding of the documentation. Alembic *will not run migrations* if an un-resolved branch exists. You *have* to merge the migrations into a single, linear path before proceeding.
this is an interesting idea, which would have the advantage that the full set of migration files would not have to be read each time. However, still leaning towards the current approach of migration files referencing each other as it allows them all to be self-documenting, and allows pruning of old migrations without the chance of inconsistency between an "index" file and the actual branch files. I also foresee the resolution of branches being something that would involve reading the contents of the migration files themselves; as far as ease of use, an upcoming "splice" command will interleave branch files as instructed with a single command line instruction.
 """But takluyver is correct; your data should be read from a file, probably [CSV [1]. """ I understand why people would suggest such but in this case I'm not convinced it is the best choice. One point is that with everything in one file there is nothing to loose. Another point is that baring typos the data isn't likely to change any time soon, further the size of the data is relatively fixed. For many tasks an external file is the way to go, I'm just not convinced this is one of them. 
Check out **pss**: https://bitbucket.org/eliben/pss It's a power tool for finding files recursively, written in pure Python. Suitable for use both as a stand-alone tool and as a library in some driving Python program
Okay, I see what you're saying. CSV is handy because it's easy to type. If you don't want an external data file, just type the CSV in a multi-line triple-quoted string right there in the source code. The CSV "file" to read is the StringIO object in the source. This is sort of like a `__DATA__` section at the end of a Perl script or a stack of data cards at the end of an old Fortran program. 
http://scikit-learn.org/stable/ http://pyml.sourceforge.net/ http://mdp-toolkit.sourceforge.net http://www.shogun-toolbox.org/ http://www.csie.ntu.edu.tw/~cjlin/libsvm/ There's probably more but I can't be bothered to google more than once. 
Voyager is as old as 1995 and Jolt cola is much older but I assume you know it's 2001 for other reasons.
has it? I don't know perl that well but I thought they were trying to port back part of the features to perl 5 as much as possible.
I don't understand the "already" reference. People are already looking into Cython support for PyPy. I addressed another issues, which is a migration path for existing f2py users. There's 550+ functions in SciPy alone based on f2py. Perhaps people are willing to port those functions manually, but surely you don't expect everyone to hand port their pyf files into Cython, do you? Perhaps your point is that it would be better to generate a Cython back end for f2py rather than a ctypes-based one. I wanted to emphasize is that pypy (potentially) offers some new abilities, like being able to ship pure Python code to someone and not depend on a batch-mode compiler, and still get good performance.
Also, scrolling sucks.
Managed to get a package to PyPI (http://pypi.python.org/pypi/iterplus/). The API is a bit different than in the original discussions. :)
Somewhere in the video or on the website (or maybe in class), I heard 2001. I just used those two as an example of the age.
I really like this. Clean, precise, and splits the XML structure without too much hassle. I've been doing a lot of XML data interpretation in Perl without access to CPAN and it *sucks*. I'm falling more and more in love with Python each day. It is such a beautiful language.
[this](http://www.reddit.com/r/Python/comments/kpeom/a_small_program_i_made_to_sort_my_unorganized/)?
Even a flat-file would work. A text file delimited by pipes or something, even whitespace would work here. Rhodium Ru 102.91 45 15.999 46 search = raw_input("Sup?") for line in open('file') if search in line: e = line.split() # e[0] = Name # e[1] = Symbol # etc... You can parse by line by iterating through the file and all the elements (no pun intended) will be available in a simple array. Then again, I do a lot of Perl, and this is how I store static data.
&gt;Somewhere in the video or on the website (or maybe in class) Probably in the video. Specifically at the end, where there's a copyright date given in the credits.
They must have figured we'd like some cheese with our spam, spam, eggs and spam.
Cool.
Very helpful tutorial. A question: in view, how does this add record event connect to the appropriate method in controller to actually insert an item into the database? Something seems to be missing. def onAddRecord(self, event): dlg = addModRecord.AddModRecDialog() dlg.ShowModal() dlg.Destroy() self.showAllRecords()
I re-read and understood :) If that's the case, why bother with the graph approach at all - why not just have a simple incremental version, and deal with that rather than random ids? 
if someone did different migrations in a branch, then you'd like to merge someone else's branch into your own. If your branch has 1, 2, 3, 4, and the other branch has 1, 2, 3, 4, 5, you now might get files "3, 4, 5" as conflicts - you'd need to renumber them, split the overlapping files into two, change their names, etc. So not having the name of the file be meaningful from an ordering point of view is the rationale for that - its a symbol inside the file that indicates the ordering instead, which the `alembic splice` command will make into one step. edit: plus you can prune old migrations by just deleting the files and setting the oldest remaining pointer to None.
ok, fair enough. It is simpler in that case. Although, that is what bzr does with revision no's, and it seems to work ok IME.
Scapy uses pylibpcap to provide the same functionality.
I would recommend that you check out [os.walk](http://docs.python.org/dev/py3k/library/os.html#os.walk), especially if you want to learn some more Python along the way. Good luck!
Odd terminology - create database == 'create', adding rows == 'sort of create', delete == 'destroy' Otherwise, looks good.
from fnmatch import fnmatch import os, os.path, shutil def print_fnmatches(pattern, dir, files): for filename in files: if fnmatch(filename, pattern): print os.path.join(dir, filename) def move_fnmatches(pattern, dir, files): for filename in files: fullname = os.path.join(dir, filename) if fnmatch(filename, pattern): shutil.move(fullname, enddir) print "Do you want to list files or move them?" next = raw_input("&gt; ") if "move" in next: print "what is the start directory? ex: '/home/sean'" startdir = raw_input("&gt; ") print "what type of files? ex: '*.pdf'" filetype = raw_input("&gt; ") print "please type the dir to to put them into" enddir = raw_input("&gt; ") os.path.walk(startdir, move_fnmatches, filetype) elif "list" in next: print "what is the start directory? ex: '/home/sean'" startdir = raw_input("&gt; ") print "what type of files? ex: '*.pdf'" filetype = raw_input("&gt; ") os.path.walk(startdir, print_fnmatches, filetype) works fairly well. Did my best to get the formatting to look correct in this post. You may have to correct the spacing if you c&amp;p.
Why write a whole Python script when you can just use a shell script one liner? It's so much easier than pulling out os.walk. Always use the right tool for the job.
&gt; I addressed another issues, which is a migration path for existing f2py users. And I'm saying that using Fwrap to generate Cython bindings is probably a better bet that will result in less duplication of effort. &gt; There's 550+ functions in SciPy alone based on f2py. Perhaps people are willing to port those functions manually, but surely you don't expect everyone to hand port their pyf files into Cython, do you? Why would they, when fwrap will do it for them?
Yes, but only where you want it. You can write regular Python and then add type declarations as necessary, which will result in speed gains if you use it in compiled mode.
That's sweet. I wasn't really meaning it for the speed gains, sometimes the logical *use* of type declarations helps see flaws in code and I like that.
Also, you could do a test that prints out the RGB value of the 'green' pixels that you want change. Then you can go from there accordingly and have that be the standard for your statements.
Nah, couldn't be.
GUI programming in Python, to me, always felt like a second class citizen. wxPython has great documentation and works ok across the major platforms and that's why I picked it. I'm constantly skimming the docs and checking out their demo (I love how you can edit the demo inside the demo and run it). I must admit that it isn't always easy dealing with all the boilerplate of GUI's, but I'm decided to stick with it. I really appreciate the effort and love poured onto this project.
Excellent book, highly recommend.
Yeah, Perl 6 is a huge rewrite from Perl 5 while Python 3 is just really an incremental update that fixes some things (mostly).
Yeah, what usually happens is that the Perl 6 group comes up with something and the Perl 5 group likes it and back ports it. There has been a huge upswing in cleaning up the internals of Perl 5 and making some things more sane. Regardless of what happens with Perl 6, Perl 5 has benefitted from it.
I don't use Django. I use PyCharm with a course in Python I am taking and it is wonderful.
Screenshots?
Congrats! Feels good to get that first app up - Pyramid has, so far, been a wonderful experience for me. My next step is to streamline my use of resource models and interfaces for resource models (to make generic sub-sections of a site). Have to experiment with that. I also want to experiment with a hybrid traversal + route mapping solution. I notice a lot of the more static pages require me to type out a lot of "routes" that are vapid but necessary (but in the traversal sense using nested objects) which I think is better suited for route mapping and leaving dynamic resource traversal to...traversal. We'll see.
Not an answer in itself, but you might consider looking into the Django permissions system and how it's architected. It's simple but flexible if I recall: https://docs.djangoproject.com/en/dev/topics/auth/#permissions
Came to say the same
[I made one.](http://i.imgur.com/bvfj8.jpg) 
I'm not sure of what you're trying to achieve with the Permissions class, but a simple dict would do if you're only after a data structure to hold some Roles.
Thank you for pointing out fwrap. I hadn't heard about it. The code status is self-labelled "beta" and there hasn't been a commit in over a year. Do you know its status? It looks like it uses the Fortran code as the primary reference for the interface information, and it prefers Fortran95 for that. If you have Fortran77 library (like BLAS) and hand-written f2py pyf definition files, which add checks() and defaults, then can you point Fwrap to to the pyf file instead of scanning the source code? That's not apparent from my brief scan of the project source and (limited) documentation. 
There's an app called granular-permissions. Suggest you give it a look.
&gt; I don't think it makes sense to put the permissions in their own table since any time I update them I will be modifying code that would use them. Eh? Every time you would add a new kind of permission you would have to modify some code, otherwise your new permission does _nothing!_ And I don't see how you'd have to modify any more code.
The simplest way from the perspective of the controller is to have a method like user_permission.has(modify), to simply check yes/no if user's have permissions. Outside classes need not be too concerned with how UserPermission checks if the answer is yes or no. This leaves you free to structure and refactor the internals of UserPermission however you want.
Is PyPI case-sensitive, because your app sees "django" and "Django" as two different packages.
I'm not doing django but i'll take a look at how they do it
Only reason I did the Permissions class instead of a dict was so I could access the permissions view a property, so I could do if User.has_perm(perms.users_create) rather than passing a bunch of strings around.
I love Rosetta code! I know a few languages fairly well, and it's fantastic for learning the syntax for others.
This is a good answer. Start building from the prospective of the calling code, and make that elegant. Then just do the simplest thing you can to make it work. *Edit:* From my perspective, just having a set of strings would be the easiest. For instance: self.permissions = set('users:view', 'users:create') then: user.has_permission('users:view') would just do a set lookup. You could probably also store "Role" objects instead of strings if you wanted, and then make sure they are hashable. Then it might be: user.has_permission(permissions.users_view) Anyway. Just throwing some ideas out there. I haven't built an extensive permissions system before, so I'm just coming at it from a general software design perspective.
I was going to ask the same and thanks for providing that. It looks awesome. I'm going to try that out. Are there any operating systems it won't run on?
That bug was fixed recently in vanity, now waiting for kennethreitz to fix vaincheese!
Thanks! Yup the ability to choose routes or traversal is certainly a powerful feature.
"*based on wxPython, so it can run anywhere that wxPython works, such as: Windows, Linux.*" I only tried under Linux but I guess it runs on Mac too. However, under Ubuntu 11.10 sometimes the screen blinks. It seems to be a known issue, hopefully they will fix it soon. Otherwise it seems a very nice editor.
 l = [['Key1', 'Val1'], ['Wheel', '150'], ['CPU', '200'], ['GPU', '250']] d = dict(l) # Done.
[Just use `dict()`.](http://docs.python.org/library/stdtypes.html#dict)
Well, a different way would work to do this, I think. But for the purposes of this, the problem is x - what do you pass it?
Can this be used with a for-loop? I'm retrieving the info from a .txt file and converting it to list then dictionary. def listFill(userPartsFile, partList): for line in userPartsFile: lineInfo = line.split() for part in lineInfo: partList.append(part) def fillDictionary(partList, partsDictionary): for index in partList: partInfo = index.split(':') #splits name/price Now I'm left with the information being broken up as shown.
Yes. It looks like you have a list of strings, where each string is to be split on ':' with the left side a key and the right side a value. There are two ways to approach this. An explicit for loop: d = {} for item in myList: key, val = item.split(':') d[key] = val or better, as a comprehension: d = dict(item.split(':') for item in myList) 
Right, sorry. That was just an example. But every other value in the list should be a key for the dictionary I want to fill. Edit: I'm getting the list from a .txt file therefor I don't know exactly what the data is.
I deleted my answer since the others understood you better and gave better answers.
I'm passing it a 1000 digit number formatted as such: str = """73167176531330624919225119674426574742355349194934 96983520312774506326239578318016984801869478851843 85861560789112949495459501737958331952853208805511 12540698747158523863050715693290963295227443043557 66896648950445244523161731856403098711121722383113 62229893423380308135336276614282806444486645238749 30358907296290491560440772390713810515859307960866 70172427121883998797908792274921901699720888093776 65727333001053367881220235421809751254540594752243 52584907711670556013604839586446706324415722155397 53697817977846174064955149290862569321978468622482 83972241375657056057490261407972968652414535100474 82166370484403199890008895243450658541227588666881 16427171479924442928230863465674813919123162824586 17866458359124566529476545682848912883142607690042 24219022671055626321111109370544217506941658960408 07198403850962455444362981230987879927244284909188 84580156166097919133875499200524063689912560717606 05886116467109405077541002256983155200055935729725 71636269561882670428252483600823257530420752963450"""
That's okay. Thank you for your help!
I figured it would mostly run on any system but I wasn't sure if it made hard coded assumptions or used, for example, Windows libs. Of course if I read a bit closer I would have seen that.
`rstrip` only operates on the rightmost (i.e. trailing) part of the string. You have newlines embedded throughout, but this will only remove the one at the end. `translate` can be used to delete all of a given character in a string: &gt;&gt;&gt; "abc\ndef\nhij\n".translate(None, '\n ') 'abcdefhij' Edit: note that you'll want to use `'\n '` to also delete spaces since there might be trailing space on any of the continued lines. Edit2: a perhaps quicker way of getting the two highest five-digit numbers in `str`: &gt;&gt;&gt; sorted(int(str[n:n+5]) for n in xrange(len(str) - 4))[-2:] [99879, 99890] 
Got it to work! Thank you, sir/ma'am. Another quick question if you're up for it ;) How can I list certain values of a dictionary? I was thinking of d.values() but I'm not sure how to sort the data after listing it. For example if I list the values, how can I only show the values less than '25'? 
You could use a list comprehension. [item for item in d.values() if item &lt; 25]
If you have a project on GitHub, it can be an interesting read.
Ahh yes that'll work great. I just need to change the values from strings to floats in my dictionary. . Edit: Can't figure out an efficient way to convert values to floats. I need to compare the values with each other. . hmm Edit 2: FIXED! def fillDictionary(partList, partsDictionary): for index in partList: partInfo = index.split(':') #splits name/price partsDictionary[ partInfo[0] ] = float(partInfo[1]) #Assigns Keys/Values print partsDictionary 
That's your problem. It's not a number there. It's a string that has character "7" and character "3" and ... then a newline character, and then a "9", and "6".... Take out the newlines in your source code, or split the string on newlines and join the resulting list with an empty string. n = int("".join("""1 2 3 4""".split("\n")))
Don't use a triple quote. The compiler will implicitly join adjacent strings in an expression, which can use multiple lines if in parentheses: &gt;&gt;&gt; num = ( ... "73167176531330624919225119674426574742355349194934" ... "96983520312774506326239578318016984801869478851843" ... ) &gt;&gt;&gt; int(num) 73167176531330624919225119674426574742355349194934969835203127745063262395783180 16984801869478851843L 
What about using a generator expression that filters out non-digit characters? int("".join(char for char in string if char.isdigit()) If you know that it will always be a str (not unicode), you can use: "".join(filter(str.isdigit, string))
I'm pretty sure you can, as that was the strategy planned for the SciPy migration to Fwrap/enabling the .NET port. It looks like those changes may not have made it back to Kurt Smith's repository yet. [FYI: apparently the Cython port of the old f2py files is done and available.](http://mail.scipy.org/pipermail/scipy-dev/2011-February/015951.html)
This doesn't belong in /r/Python. Try [/r/programming](/r/programming) or [/r/git](/r/git).
While this is not directly related to your question, if you're trying to learn python, have you looked at the python challenge?
Thank you. I was already waiting for that remark.
Have main() take as parameters your (options, args) and do the parsing in the `if __name__ ...` stanza. That way if you're using the code as a module, you pass your desired options, and if it's run as a standalone script, it parses the options from argv. Also a couple of notes: 1. optparse is deprecated, it's recommended to use argparse. 2. OptionParser documentation says to always pass arguments as keyword parameters, not positional. 
Neat stuff, not very Pythonic, but cool nonetheless. Being able to globally turn off the contracts with `contracts.disable_all` makes this very useful for ensuring prototyped code is behaving as expected while still being able to turn it off in production.
As long as it's always positive
I don't really understand who this is intended for. It's far too complex for most small projects, and anyone working on a major project that requires this complexity probably won't get much out of the article.
Tuple unpacking is a nice trick to avoid those indexes: def fillDictionary(partList, partsDictionary): for index in partList: a,b = index.split(':') partsDictionary[ a ] = float(b) print partsDictionary Or if you prefer list comprehensions over for loops. def fillDictionary(partList): splitList = [x.split(":") for x in partList] partsDictionary = dict([(a,float(b)) for a,b in splitList])
Hadn't heard of it to this point. I took a look at it and it seems interesting, I'll have to try it out.
This worked perfectly! Thank you so much!
&gt;`translate` can be used to delete all of a given character in a string: I suppose it could be, but the obvious and natural way is with `replace`.
&gt;It's not a number there. It's a string that has... Which is fine, given that he wants to consider consecutive sets of 5 digits from the number. The approach of taking 5 characters at a time from a string and converting to `int` (as in the illustrated code) makes perfect sense.
Populating a passed-in empty dictionary is extremely un-Pythonic, influenced by attempts to optimize things in other languages like C++. (It doesn't necessarily even work there, with modern compilers; it definitely doesn't help for Python.) Meanwhile, by using a comprehension, you get speed (since the loop is done internally by the interpreter, which is no longer forced to interpret the actual bytecodes to cause looping behaviour) **and** simplicity. Also, it's generally considered poor form to indicate a data type in an identifier name (because it generally doesn't actually have to be as specific as you think anyway), and 'index' is a strange name for an iteration variable (because the whole point with Python iteration is that we **aren't** using indices any more, but iterating directly). def dictionaryFor(parts): return dict((k, float(v)) for k, v in (item.split(':') for item in parts)) # Or you can split it across two comprehensions as freyrs3 # illustrates, if you find that clearer.
That's exactly how I use it in my projects. It is disabled by default, unless turned on by a command line option. Also I noticed that the annotations are useful when looking back at your code after some time, as they state exactly your assumptions about the parameters when you were writing the code.
thanks can you help me with the code or let me know the right search term ? I can't seem to find relevant examples.
I can't see or download any of the videos, what happened to this site? edit: nevermind, found his youtube channel with all the videos.
As an alternative, if you really want to check types and everything, you could start using cython where you have to declare types and header files with python syntax
You're right, [lxml is there](http://code.google.com/appengine/docs/python/tools/libraries27.html) among the 3rd-party libraries.
I'm hesitating between Bottle and Flask. Which one do you suggest? It seems to me that Flask offers more and Bottle is very minimalistic.
Nope, I think you mis my point. You don't want to do as you suggest with creating a CSV section in the Python file, that would be a waste. What I'm saying is use a native Python structure of your choice to represent the data. I only recommend it in this case due to the finte amount of data to be dealt with. In other situations the advice to use a CSV or similar external file is probably a good one. Here the data set is comparatively simple and a single file easier to manage and share. 
Hand coding the data for a native Python structure means surrounding string items, such as atomic element symbol and name, with quotes. CSV, or a clever use of `split`, means you don't need to surround the string data items with quotes. That's what I mean by CSV being easy for a human to type. Something like `2, He, helium, 4.002602` is easier to type than [`2, 'He', 'helium', 4.002602`]. Or maybe I'm missing your point. 
Wow, the example for C with win32 api is a total madness :| http://rosettacode.org/wiki/Walk_a_directory/Recursively#Windows
[zip](http://docs.python.org/library/functions.html#zip) and [dict](http://docs.python.org/library/stdtypes.html#dict) are your friends. 
You know, actually PyContracts is not that tailored towards types, but more towards *values*. For example: @contract def matrix_multiply(a, b): ''' Multiplies two matrices together. :param a: The first matrix. Must be a 2D array. :type a: array[MxN],M&gt;0,N&gt;0 :param b: The second matrix. Must be of compatible dimensions. :type b: array[NxP],P&gt;0 :rtype: array[MxP] ''' return numpy.dot(a, b) PyContracts will check that all matrices are compatible. And if they are not, it will explain exactly why. There are many cases like this in which a function could be written in only a few lines, but you need much more code to check preconditions. Another example: @contract(col_labels='list[C](str),C&gt;0', row_labels='list[R](str),R&gt;0', data=''list[R](list[C](numbers))') def write_table(data, col_labels, row_labels): .... 
Here's an advanced topic: http://www.cafepy.com/article/python_types_and_objects/python_types_and_objects.html 
True. A better version is to just filter out whitespace, then pass that to int(). int("".join(char for char in string if not char.isspace()))
`partition` is a little less likely to choke on bad input, since it's guaranteed to give you three things of output. key, _, value = index.partition(": ")
For a more advanced treatment, see [this tutorial](http://www.archive.org/details/scipy09_advancedTutorialDay1_1) from SciPy 2009.
Read the source code of any open source stuff you use?
You may find portions of [Text Processing in Python](http://gnosis.cx/TPiP/) interesting. I'm 50% of the way through so far. First chapter is great. Next two are a bit reference manual-like but I think the state-machine stuff should be interesting.
Let the snake be your teacher.
But if you turn off contracts, the user can now pass any argument he wants. Why don't you directly and systematically check inside the function ?
Dpends what you mean by advanced. But learning and understanding numpy arrays has proved immensely beneficial to my research. Drfinitely worth checking out.
&gt; Javascript is disabled in your browser. You have to enable it to view the site. fuck you
If you turn it off, then you don't want to check it. Contracts are by definition expendable.
This is not true. You can use any of the APIs listed on [this page](http://code.google.com/apis/calendar/) that aren't specifically labelled as deprecated. Specifically, you might want to follow [this reference](http://code.google.com/apis/calendar/data/2.0/developers_guide_python.html).
Code. Writing a lot of it. Working on a piece of software that you use is a pretty good idea. The rest you will pick up as you go.
[Expert Python Programming by Tarek Ziade](http://www.amazon.com/Expert-Python-Programming-practices-distributing/dp/184719494X). Tarek is the individual responsible for spearheading the overhaul of Python packaging over the last couple years.
It's to demonstrate code correctness, not to validate user input. The idea is to check that we use functions in the correct way, by passing the right kind of data in and getting the right kind out in return.
So if I say "list[3](str)" as return value, the package scans the function and can deduce from the code of the said function that I will always return a list of length 3 with only str type inside ? I don't think it's possible in python due to the dynamic aspect of the language, but I probably miss the point :(
For gui, I use Tkinter. Many people are against (Honestly I don't know why), but it's lightweight, included with Python, and in 2.7+ there is a native gui skinning called ttk which also comes native.
"Type" has several subtly-different meanings. In more academic contexts, restrictions on values are a natural *aspect* of a type, rather than a contrast to it.
I tried it once and was immediately turned off. This was a while ago but at the time the GUIs it'd create looked so unmodern, like something from Windows 3.1. I don't know how it's been improved over the years but lately I've been using wxPython.
Why strings for contract specifications? I expected types and/or callables. 
Hang out in #python on irc.freenode.net. There are some smart folks in there, and you can learn a lot just from listening to the odd conversation here and there. I'm amazed by how I learn a better way of doing something I thought I already knew just by listening to various people answer questions (not just in #python but in other channels too).
It's a run time check to make sure that the assumptions you state are true.
It doesn't do code analysis. Instead, at run-time it checks the input and return values. The term "contracts" and style of usage comes from the last 1980s: http://en.wikipedia.org/wiki/Design_by_contract There were some experiments in adding that programming model to Python even in the mid-1990s on comp.lang.python. Python 3 adds annotation support precisely so that packages like this can exist.
That says that the SciPy pyf files were converted by FWrap + manual changes into Cython code. It doesn't say that FWrap can handle existing pyf files. In fact, it points out that support for an embedded "for(i=0;i&lt;n;--piv[i++])" wasn't possible. Not that the f2pypy work I did can handle that case either. Well, since I have the start of a C parser then it's possible, but it's quite a bit of work.
Thanks for the heads up, I was just confused at how different the G+ example was than the ones listed on the Google Site.
Definitely [Python Cookbook](http://www.amazon.com/Python-Cookbook-Alex-Martelli/dp/0596007973) by Alex Martelli.
I've looked at the documentation and it looks like an interesting project. But I understand from the documentation that it only deals with the preconditions part of DbC (http://en.wikipedia.org/wiki/Design_by_contract), not postconditions and invariants. Do you think they are not as useful, nor harder to implement, or ?
Explain why?
This suggestion is sort of a different approach: Try going through as many [Python Challenge](http://www.pythonchallenge.com/) exercises as you can. Be sure to save the source code, for each level and when you've completed them, view the solutions that other people have posted.
There is a limited support for postconditions in the sense that you can declare constraints on the return values. For example, you can define a contract: @new_contract def sorted(sequence): # checks that the sequence is sorted # Check that the return value is a list of the same # size and sorted @contract(x='list[N]', returns='list[N],sorted') def sorted(x): ''' returns the sorted list ''' However, with the current syntax you cannot express things like "check that the lists have the same elements". To do that, PyContracts would have to be extended to allow something like the following. # parametric contracts with more than one element -- not implemented yet @new_contract def same_elements(a,b): ... @contract(x='a,list[N]', returns='list[N],sorted,b,same_elements(a,b)') def sorted(x): ... The variable "a" is bound to x, the variable "b" is bound to the return value, ``same_elements(a,b)`` invokes the check with the two elements. I didn't implement this yet --- mainly because I focused on making the current functionality robust and stable so people could trust it, try it out and give some feedback. 
I personally feel learning should be demand driven. You have to ask yourself, what is your purpose for learning python? Thus, I think a great resource (for any language) is to try [the Python Challenge](http://www.pythonchallenge.com/). Save your solutions for every level, and after you've completed a level, glance over the solutions others have posted. By doing this, you'll learn how to use python to accomplish a task, but more importantly you'll get better at figuring out how to do something new with python (or any language).
I was vaguely aware of that. On [this wikipedia page](http://en.wikipedia.org/wiki/Type_system) I found out that they would be called "dependent types". 
whatever you do, tinker around with it too. don't try to "figure it out" before you code something, try to code something and you'll figure it out. getting good at programming is just a huge cycle of failure, figuring out why you failed, and trying again (and hopefully learning something in the process).
I recommend also doing [project euler](http://www.projecteuler.net), which is a series of math problems meant to be solved in any language. And you should of course save your solutions to this too. I've also been saving many of my failures, with commented explanations as to why they did not work.
the tutorial and the library reference from the site that's all you need really but as others also said, I too prefer to focus on objectives than theory, I'm not even a college studen I'm self-taught and been working for a while now so my methods may not apply.
The difficulty in answering this question is that it may not be the right question. I've been programming for twelve years, so when I decided I wanted to learn Python, I went directly to the docs, a couple of large reference books, and a phrasebook. But what I suspect you're looking to do is teach yourself to *program* using Python as your jumping off point. For that I might start with one of those Wrox books that walks you through a few projects. That will give you a basic understanding of how small software projects are put together, while introducing or refreshing your memory of basic programming principles such as classes, methods, functions, variables, scope, flow of control and all that good stuff.
Thanks, I'll give this a go. Practical applications like this seem like a great way to get started. Also, happy cake day.
Hint: from collections import OrderedDict BTW, there are better implementations of ordered dicts available on the 'net than the builtin. 
I don't know why you're asking that really. AeroNotix wanted to try Python with static typing, regardless of how Pythonic that would be, and Cython would provide that.
I've been working on something similar, which I call "covenant": https://bitbucket.org/kisielk/covenant In Python 3 I use function annotations to implement the pre- and post-conditions on functions. In Python 2.x I use decorators, and there is also an invariant decorator. One other major difference is I don't make use of eval or any kind of code in strings, all the functions take Python callables as parameters. Eg: @invariant(lambda x: x.foo &gt; 2) class Foo(object) or @constrain def foo(a : lambda x: x&gt;2) Unfortunately I don't have any documentation or examples yet since the API is still very much in the experimental stages, but if you're interested please have a look and let me know what you think.
It's time to stop learning with visiting websites, unless it is a repository browser :)
When you need the advanced things, you'll know to start looking for them. Contribute to open source projects and study other peoples code. Don't do complicated things just for the sake of complexity. QT or wxPython for GUI framework.
Maybe with this I can finally get matplotlib to work with idle.
There's a subreddit, /r/learnpython, for just this kind of thing, too. People over there are generally quite helpful and friendly. 
The EventLoop.py extension can drive several different matplotlib backends. If you're using matplotlib, check out SubCodes.
Check the sidebar. Khan Academy Dive Into Python Learn Python the Hard Way All free and all for inexperienced users.
Not sure if the Python Challenge is for novice users? I'm having trouble and I've completed Khan Academy, Learn Python the Hard way and half way through Dive Into Python.
Some of the challenges are just hard, but it's a good way to get started and it gives you a clear goal, solve the challenge. For many people I would argue that's more rewarding than watching videos, or reading about the language.
It doesn't exactly give you a clear goal. The whole thing is very cryptic and the hints very obscure. I would recommend Pyschool's challenge section.
I've avoided this book because of Alex Martelli's review of it
If anyone has questions, ask me. I developed IdleX. EDIT: I'll still answer questions this week (11/14 to 11/18) if you have any. EDIT2: Windows users - There's a bug when running IDLE itself after IdleX. Use [fixIDLE.py](http://idlex.sourceforge.net/fixIDLE.py) to correct this problem and upgrade to [version 0.3](https://sourceforge.net/projects/idlex/files/latest/download?source=files)
Check out tkdocs.org to see the update.
You only need to use the giant monolithic class for cases complicated enough to warrant it. For most things, use `subprocess.check_call` and `subprocess.check_output` subprocess.check_call(['touch', 'myfile.out']) reddit = subprocess.check_output("ls -1 *py | sed 's/py/reddit/'", shell = True)
Interesting but lately I've been using Eclipse with PyDev. Looks good though, what we really could use is a GUI editor that would simplify the development of GUI Apps. 
Any info on using IdleX on Windows? Thanks.
Types and callables would need to be known by the interpreter before the execution of the given contract specification. That means that all custom types and callables would need to be defined before their usage, which would impose unnecessary and sometimes impossible to fullfill burdens for ordering your code.
How is your knowledge of algorithms and data structures? (Not necessarily the book, just in general). Such knowledge can make average language smarts go a long way. 
It'll work. I know of one difference. The TabExtension doesn't shift with the scroll wheel as it does on Linux. (I'm not sure how to fix this. Patches are welcome.) I didn't test Cython, Matplotlib, GTK, or Qt4 on Windows, but I don't see any reason why they wouldn't work. EDIT: You should be able to unzip the archive to a directory and then double-click on idlex.py. 
Exception handling isn't really advanced stuff...
This is a great idea, but I'd like to learn more before contributing to open source projects. 
I don't do much GUI development anymore. What toolkits need an editor?
That's exactly the reason. (no, I don't miss C's header files)
That code has nothing to do with streaming video, it is just dumping image frames to a socket as bitmaps. You could try something like pygstreamer, but be warned that such things get really gnarly really fast.
They never said anything about contributing.
None needs an editor, but one could argue that Visual C# also doesn't need a GUI editor. It just makes things (and lives of programmers) a lot easier if it has a WYSIWYG GUI editor. 
Yes, but it has gen-u-ine Python luminaries in it--like Tim Peters!
It's [PEP 405](http://www.python.org/dev/peps/pep-0405/) now
QtDesigner?
I think it's Disqus. Page renders fine without javascript but when I scroll to the bottom I get the message you said. And with javascrtipt enabled, there is disqus embedded at the bottom.
The reviews are particularly bad for this, can you give a solid reasoning why I would pick this book over anything else?
Have a look at ZeroMQ.
I'd suggest using something else unless there's a good reason I'm missing. Try using VLC or maybe [USB/IP](http://usbip.sourceforge.net/) if you need it done transparently (assuming a USB webcam). As much as I love Python I wouldn't bother writing code for this when there are so many solutions already out there. EDIT: [USB/IP doing exactly this.](http://usbip.sourceforge.net/images/ss-xawtv-full.png)
Speak for yourself, my keyboard doesn't even *have* a delete key.
Would this really be feasible? I haven't done with GUI work with Python, but it was my understanding there are quite a few different libraries to choose from. Is there one that has overwhelming support?
Give us some highlights of why this is cool and who it is aimed at. It seems like it is aimed at rapid prototyping and/or a MATLAB replacement. And that could be awesome, there is certainly a huge audience there. I used to work in a lab that was porting everything from MATLAB into Python, and a lot of people there could have really used something like this. The integration of matplotlib seems good, and would provide a familiar interface to those coming from such a background. I spend most of my time with Eclipse + Pydev and an interpreter running though, for a 500k LOC project with 5 other devs. I have worked on Lisp in Emacs, and I can see the benefit of having (what looks like?) an integrated IDE/runtime environment. For me, it would at least have to have easy navigation of large projects, autocompletion, ability to click into variables/functions/classes to jump to their source, and robust syntax checking. There are other features I rely on with Eclipse, but I am guessing remote debugging and Perforce integration are not on the menu.
It's aimed at those who need quick scripting and prototyping, like academic researchers or new programmers. It has Cython integration, which allows basic syntax highlighting and script executing. Check out "cython_demo.pyx" if you have the latest Cython installed. The "CodeBrowser" feature may be useful for code navigation. Press F8 and an overlay of all class and defs are given. It's not quite "jump to definition", but it's useful to get a high-level view of the layout in the code. (Bonus - right-click "Code Browser" to see an overlay of all keywords instead of just class and def) The SubCodes feature resembles Sagemath Cells and Matlab cell mode. This allows you to group together a set of commands for execution in an editor window instead of running the entire editor buffer. It also has a few extensions to address some long-standing criticisms of IDLE. The ClearWindow extension allows you to clear the shell window and the LineNumbers extension gives line numbers in the editor. The Terminal extension makes PyShell behave like a terminal instead of allowing the cursor to leave the input area. EDIT: Also, remote debugging is possible with IDLE. I haven't released that yet, but it isn't hard to see how it's done. The subprocess communicates to the main process via RPC over a TCP/IP loopback. With a few simple changes, the subprocess can be made to run on a remote machine.
Excellent work. This only requires Tkinter, correct?
Cool I'll look into that. I looked at VLC but I think that was similarly slow.
Yes, it only requires Tkinter. IdleX acts as a wrapper to IDLE.
I'm not familiar with this, but [StackOverflow got some possible answers.](http://stackoverflow.com/questions/3237558/python-execute-remote-program)
http://code.activestate.com/recipes/577945-execute-remote-commands-on-windows-like-psexec/?in=lang-python ?
psyco doesn't do trace jit either. it is a function jit.
Keep security in mind.
Few years back I made a jabber bot for something similar. The concept of instant message windows is similar to shell windows so it works out well and it's fairly easy to implement (I went with twisted.words). When you make your bot you can use py2exe to setup a windows service for it.
I wonder if there would be something similar done in Qt so I could take the code base and start extending to suit my own needs.
multithreaded socket bot. import socket
Interesting strategy for doing point free style in python. Decorators really do give you a lot more control than I initially expected.
This is really pretty cool, but I don't think I could ever get on board with using it in Python because it doesn't seamlessly integrate with the language. (Obviously not possible with a simple module.) It's just too clumsy to use IMO. Namely, it fosters an inconsistent style---only the functions you decorate can be composable/partially applied (unless you use 'pf' for composable functions). Also, you can get partial application of any function using [partial in the functools module](http://docs.python.org/library/functools.html#functools.partial), which is part of the standard library. It doesn't look as nice as what pointfree offers, but you can use it with any function.
Check out https://github.com/thatch45/salt It's using the mighty ZeroMQ sockets and does end-to-end encryption using a symmetric cipher (AES). Authentication is done using public key authentication (what you do if you use keys with SSH).
Why not run OpenSSH on Windows and then use Fabric or whatever?
Check out execnet.
SPOJ!
1. I'm sure that you can run Fabric nodes on Windows. 2. You can definitely run Paramiko in server mode on Windows, I can even give you some relevant code if you want. 3. Though I personally don't like Paramiko all that much, I was recently advised to look at the Twisted's SSH server, but have not, yet. 4. When I wanted a quick-n-dirty solution a couple of years ago, I did it in reverse: a script tried to connect to the server (which was actually a client, logically) every 5 seconds, and gave it a shell-like access on success. Obviously, if there's a remote possibility of DNS poisoning or something you should do it via SSH, also if you have a lot of boxes, you don't want them waste network bandwidth like that.
I know, that is a concern. Everything will be behind a firewall but still.
That looks cool. . . thanks!
I might end up doing that but I didn't want to rule out a pure Python implementation. Also, at my last company, we had problems with cygwin. I've personally run into a bunch of different issues with cygwin - it's a great toolset but not rock solid in my experience.
That looks promising. . . thanks!
What sort of link are you using (wifi)?
yep
At the very beginning, Mitch should have just coded up an Agenda-look-alike with his developers. Then add what he felt was missing in Agenda and removing that which he felt was wrong with Agenda. Then open source it. Chandler would have grown from there into something people really want, while with him at the helm, striving towards an Exchange replacement.
http://nedbatchelder.com/blog/
What do the underscores indicate here? I've seen them before on this subreddit. Are they just an abbreviation?
http://sshwindows.sourceforge.net/ &gt; OpenSSH for Windows is a free package that installs a minimal OpenSSH server and client utilities in the Cygwin package without needing the full Cygwin installation. If you use Fabric or roll your own for some reason, it *is* pure Python. Don't write a protocol for something that already exists, if avoidable.
Didn't have much luck in StackOverlfow, perhaps someone here knows what's going on?
Planet python has got quite a bit. Also r/devblogs will one day have a few, just need more people to submit 
Right, but you still need to use cygwin (not the whole toolset, which I know, is huge). I've had problems with cygwin in the past and as much I appreciate what it does, I would like to avoid using it or at least I'd like to see what my other non-cygwin options are.
I've done this before using a Google Voice number and their API. Bit different approach but it works :D Are you sure those mail servers all work for those carriers? Might they have some anti-spam feature to prevent you from doing this?
Very impressive! Is it possible to ask the Python team to accept this code to be included in official IDLE distribution?
I've been using this to access my windows box: http://www.freesshd.com/ works pretty well.
Try r/scriptkiddies
Try sending it to the gmail account itself 20 times. Gmail may be stopping you form bombing others, but maybe not yourself.
I answered on stackoverflow: http://stackoverflow.com/questions/8110951/python-package-without-init/8128033#8128033
If you are running from a Windows to another Windows box, I'd have a look at [WMI](http://timgolden.me.uk/python/wmi/index.html).
The idle-dev team is aware of it: http://mail.python.org/pipermail/idle-dev/2011-November/thread.html We'll see what happens over the next few months. Some of these extensions would not be appropriate for the official IDLE distribution, such as CythonScript.py. 
I was kind of disappointed that this doesn't exist :D
Yeah, I will be doing that sometimes but not all the time, I basically need to run from Windows or Linux to Windows or Linux. . . and I might have to throw Solaris into the mix too. I'm hoping that I don't.
I had a more experienced friend help me fix it. Thanks for your help guys!
I lold.
 &gt;&gt;&gt; import this ... *lots of points that cute python code like this totally violates, yet people keep doing it* 
If you only want function composition (no automatic partial application or messing with generators): In [15]: def composable(f): ....: class wrapped(object): ....: def __call__(self, *args, **kw): ....: return f(*args, **kw) ....: def __mul__(self, rhs): ....: def comp(*args, **kw): ....: return f(rhs(*args, **kw)) ....: return comp ....: return wrapped() ....: In [19]: @composable ....: def f(x): return x*2 In [20]: @composable ....: def g(x): return x+42 In [21]: f(10) Out[21]: 20 In [22]: g(10) Out[22]: 52 In [23]: f * g Out[23]: &lt;function __main__.comp&gt; In [24]: (f * g)(10) Out[24]: 104 In [25]: (g * f)(10) Out[25]: 62 
Thanks!
Instead of removing elements, you should build a new list with just the elements you want to keep. [x for x in S if not any(c.isdigit() for c in x)]
Thanks! Looks good, but I don't think it will work from a Linux box, which I will need to do occasionally. 
Inverse indentation? What's that about? if True: print 'it be true' else: print 'it be false'
Just so you know this is the kind of comment that drives people crazy. When you fix a problem that you post about, you should reply with your solution so this thread becomes a resource rather than another dead end. It's not a big deal here but something to keep in mind as you learn :)
 aList = [True, False, False, False, False, False] # this condition prints if any(aList): print 'at least one object in this list evaluates to True' # doesn't print if all(aList): print 'all of the objects in this list evaluate to True (which is not the case)' 
 bottle.run(server='gae') MAGIC way to defeat the wsgi middleware pipeline. So i expect another tutorial coming on how to use some more magic in order to enable stuff like appstats for bottle. 
Did you post [this thread](http://www.reddit.com/r/Python/comments/mc9ik/searching_and_removing_element_from_list/) too? I put an answer there. See if it's what you have in mind?
That's not bad, but you shouldn't modify a list while you're iterating over it. I think this may be causing the incorrect behavior you're seeing. You can correct this problem by replacing "for x in S" with "for x in list(S)", which means you're iterating over a copy of S. This, however, is a problem if a term you want to remove appears in the list twice, because it's an error to remove an element that's already been removed. There are ways around this as well, but I would do the whole thing by building a new list rather than removing elements. If you need to avoid list comprehensions, you could do it like this: newS = [] for x in S: hasDigit = False for c in x: if c.isdigit(): hasDigit = True if not hasDigit: newS.append(x)
Yep, I figured that out myself shortly after I made that edit. Thanks.
What about running a [simple XML-RPC server](http://docs.python.org/library/simplexmlrpcserver.html) on the machine you need to access remotely. Either define some functions for what you need to do, or wrap subprocess.
I wonder what the problems were? I think the libs are linked into OpenSSH in the `sshwindows` project so you'd never know it was there. Well, you could probably go find `sh` located somewhere if you wanted to...
Last chapter explains how to create a declarative framework similar to what it can be found in django models using metaclasses. This is the best example I've found about using metaclasses in a real project. You can find a less polished version of the same in his [blog](http://martyalchin.com/2007/nov/10/using-declarative-syntax-part-1/).
I really like The Mouse vs The Python. http://www.blog.pythonlibrary.org/ For more general python stuff, this site is great. http://www.siafoo.net/article/52
Not blogs but ... http://www.radiofreepython.com/ ... is a great podcast and ... http://www.pythonweekly.com ... is a good newsletter. 
A friend and I wrote something similar - we were running a web interface and used that to securely run both .net and python on remote hosts and display the output. We had the interface very simple and could run it cross platform. Never got around to all of the piping and process control bits that I wanted to add though.
Could you link to the review please? I liked the mentioned book a lot, but I also enjoy reading Alex Martelli's crystal clear answers to python questions on StackOverflow.
I'm not sure about OP, but back then I was using Cygwin, there was some Windows domain, Win authentication, and 64bit related issues. Also uninstalling Cygwin with services sometimes is a pain in the ass. 
Enough to do something real, not so much that the fundamentals get lost. Thanks.
Wow, after reading the documentation, I feel like I would use this module for everything except actually writing stuff in pointfree style. Function composition and nicely-sugared partials are cool.
... I don't particularly see how.
&gt;I guess my confusion is how to implement it in any useful way. ? You don't have to implement `any`. It's already provided for you in the standard library. I can only assume you meant how to **use** it. It's hard to imagine how this could be clearer: you call `any` with a sequence or iterable, and it returns (as a boolean) whether any of the elements are true-ish. So if you have a sequence where you want to check if any of the elements are (some other quality), you make a function `is_some_other_quality`, use that to transform the sequence, and call `any` on the result. The easiest way to do this is directly in-line, by using a generator expression and taking advantage of the special syntax rule that lets you drop the extra pair of parentheses. `any(f(x) for x in y)` means "any of the elements in y, when passed to f, results in something true-ish". This is **not** some magic specific to the `any` function; `(f(x) for x in y)` means "a generator that, when iterated over, will yield the result of applying f to each element in y".
The any() function takes in a sequence (usually a list, but also a tuple or generator), and returns True if at least one of the elements of this sequence are True. Note that the elements don't actually have to be Booleans themselves, they just need to be able to produce a Boolean. Suppose you want to find whether a list of integers contains a non-zero value. print(any([0, 0, 0, 1, 0])) &gt;&gt;&gt; True print(any([0, 0, 0, 0, 0])) &gt;&gt;&gt; False You can also get more complex behavior by using a comprehension as the sequence. Here's what you could do if you wanted to know whether there is any element greater than 5. print(any([x &gt; 5 for x in [0, 3, 2, 8, 1]])) &gt;&gt;&gt; True print(any([x &gt; 5 for x in [0, 3, 2, 8, 1]])) &gt;&gt;&gt; False If the "x &gt; 5 for x ..." syntax confuses you, then your issue is with list comprehensions, not the any() function.
 def any(iter): for i in iter: if i: return True return False
We hit a weird permissions issue with cygwin's SSH and yes, I've had a few 64 bit problems with it lately. Cygwin emacs hangs for me all the time too. I really love the whole cygwin project, I just wish it were more stable. Fortunately, for my day to day work, I'm mostly using Linux these days, but the project I'm working will need to work on Windows too.
That's something I hadn't even thought of. Thanks! I have a bunch of code-like data I'll be serializing to XML too.
For operations on longer iterators, use a generator expression instead of a list comprehension. For example, to find if there are lines with len(line) &gt; 5: with open(file_name) as f: return any(len(line.rstrip('\r\n')) &gt; 5 for line in f) It uses constant space instead of building an entire list in memory.
In addition to the examples you've already been given, you can write really readable code for testing an expression for every member of an iterable with any()/all() in combination with generator exprs, e.g. if any(item.attr == 'value' for item in collection): # do something here if any(msg.is_multipart() for msg in mailbox): # blah
didnt work for python 2.5, guess ill have to upgrade. not a big deal
You're area might have a Python community - I know Montreal Python is incredibly active and their blog is very interesting, and if you live near a major city, then your local community might be similar. I'd check that out! Planet Python, as suggested by TankorSmash, is also very active, and always has interesting articles for both beginners and experts. 
I wrote something in a very similar vein: http://www.trinhhaianh.com/stream.py/, http://blog.onideas.ws/tag/stream-py It actually has the advantage of real pipeline processing, which can be parallelized using threads/processes.
http://www.amazon.com/review/R3HETTNFMH3UO1/ref=cm_cr_dp_perm?ie=UTF8&amp;ASIN=184719494X&amp;nodeID=283155&amp;tag=&amp;linkCode=
That siafoo.net is good - never seen it before
Reading it now. Looks good! I'm giving you an upvote.
Ask yourself when it would make sense to name a module 'this'.
I can't use this module, but I &lt;3 you for writing it. If only curried functions and function composition were built in to the language so I could actually use them.
Obviously that's not what I meant. I lol'd though.
Hey, thanks. Did not get it working with Windows and Python 3.2, but never the less, great :)
Note that opening a ZeroMQ socket to the Internet is a bad idea; if /any/ invalid data is sent to the ZeroMQ socket, ZeroMQ will abort the process on the server, meaning you'll have to start it up again.
When you're asking for help, it's generally a good idea to include some more details, like what platform you're on, and the exact error message you get, including the traceback.
My personal experience is that the Battlelog is about as buggy as the game itself (i.e., not very, just enough to be annoying). Things like friends' online status not displaying properly and party options being a bit flaky. I don't think he mentioned it, but Battlelog was built using the [Planet Framework](http://www.planetframework.com/).
Btw: sys._getframe is a CPython implementation detail. Relying on this kind of hack is risky. Bottle achieves the same, but in a much more robust way (PEP 302).
How can a fellow Gothenburg pythonista help? Provide more cake? 
So far the client has been extremely buggy. I get the sense, though, that it's mostly a matter of the client plugins.
&gt; Python 2.x with gevent as well as JavaScript with jQuery and their own stuff on the client and Java for their websocket backend Use *all* the languages! Still cool if it works though.
&gt; My personal experience is that the Battlelog is about as buggy as [] It's not battlelog that's buggy, it's various windows software interfering with the websocket connections (Antivir etc.).
Eli Bendersky's blog is not exclusively about Python but has some great posts: http://eli.thegreenplace.net/articles/.
Thanks for mentioning my blog ;-) More relevant to this question would be to link to the Python posts tag, which includes articles as well as shorter posts: http://eli.thegreenplace.net/category/programming/python/
Yes! Really, there's no reason to use a list unless you are going to re-use the value later.
QtDesigner (as AeroNotix said), glade, wxGlade, what else do you need?
This is pretty nuts - if you need to run SSH then get an SSH server. That being said, you could make a quick prototype pretty quickly with a combination of Firewall rules/SSL/Ajax/Django/[Subprocess](http://docs.python.org/library/subprocess.html).
Cake is always welcomed :)
r/python should be such a place...
Ill make sure to stay informed for next time, I am not good enough to help with pypy development, but I can bring cake and cheer you guys on! 
That's just it, I don't need to specifically run an SSH server, I just need something that will allow me to run commands remotely and I was looking for ideas. If there were no Windows machines in the mix, I would probably just use SSH because it's free and easy on Linux.
He mentioned using the same templates on both the client and server. [Handlebars](http://www.handlebarsjs.com/) is a superset of [Mustache](http://mustache.github.com/) for JavaScript. Mustache is available for many languages, including Python. Though, I would definitely have no problem with using Jinja in JS, if he ports it over. =)
You are evil. def __getattr__(self, name): if name.startswith("print"): func = getattr(self, name[5:], None) if func is not None: @functools.wraps(func) def wrapper(self, *args, **kwargs): print(name[5:]) func(*args, **kwargs) return wrapper raise AttributeError Note: if you ask for printprintprintfoo, it'll actually print "printprintfoo" then "printfoo" then "foo" and then execute foo() - this is intended.
Awesome write up Armin
The PEP numbers have been switched (with 405) to give 404 some funny meaning.
When I try to open any python file: Exception in Tkinter callback Traceback (most recent call last): File "C:\Python32\lib\tkinter\__init__.py", line 1399, in __call__ return self.func(*args) File "C:\Python32\lib\idlelib\IOBinding.py", line 161, in open filename = self.askopenfile() File "C:\Python32\lib\idlelib\IOBinding.py", line 489, in askopenfile filename = self.opendialog.show(initialdir=dir, initialfile=base) File "C:\Python32\lib\tkinter\commondialog.py", line 50, in show s = self._fixresult(w, s) File "C:\Python32\lib\tkinter\filedialog.py", line 344, in _fixresult return _Dialog._fixresult(self, widget, result) AttributeError: 'function' object has no attribute '_fixresult' Windows XP. Python 3.2.2. And now I can't run simple Idle, do this extension change something in registry or system files?
https://gist.github.com/11ea875ed7499cac45b2 A bit better formatted. https://gist.github.com/1023982 some other interestin ways to NEVER use lambdas.
IdleX does change the .idlerc/config-extensions.cfg file in your home directory by including settings to the new extensions. Try moving that file and restarting IDLE. In the meanwhile I'll try to duplicate this error. EDIT: The solution. Disable CenterDialogs.py by using the extension editor or by removing it from the extensions directory. This will let you open files with IdleX. Now to restore IDLE, remove "config-extensions.cfg" from the .idlerc directory, found in your home folder. 
I was wondering what framework it was built using. Nice. used battlelog recently seems to do a lot better after the patches. 
Sprints are also a good chance to get involved in the development, you don't have to want to work on PyPy itself. For example, if you're a web developer our main performance analysis tool is a Flask application with jQuery on the frontend, and we'd always love help with it!
Pyramid has a very comprehensive granular permission system introduced here: http://docs.pylonsproject.org/projects/pyramid/dev/narr/security.html
This looks good, but also quite outdated. Is it still relevant today? I know some of the Python string methods weren't around in older versions.
How evil.
Solid effort! Writing an IRC bot is one of my favorite ways of learning a new language, since you touch on a lot of practical things while doing so (string parsing/regex, sockets, timers, callbacks etc). :D
The `any()` function can even take a string, but it's a very silly thing to do.
It doesn't even look like python :/
A lot more could have been done, but I had a bet with a friend that of I could write an IRC bot in python without any semicolons and using only lambdas. It was ~45 minutes of work. He was trying to write an obfuscated one in Perl, and I bet him I could easily make one just as unreadable.
I uploaded idlex-v0.3.zip to sourceforge to fix this problem. [fixIDLE.py](http://idlex.sourceforge.net/fixIDLE.py) will correct the problem immediately, but you should upgrade to 0.3 to avoid the problem again.
Ok that's mean. You're a nice/crazy bastard. Fuck you. : )
I've used twisted's ssh manhole &amp; conch to write a remote python console that uses ssh and key auth. It's not inherently clear how to do it, but if you are interested I can provide the snippets I used.
The strings give the game away a bit. Look at the source code for the "this" module, which uses rot13 encryption to make it a bit harder to read.
The point he brings up about the URL handler is something I was actually confused about, as this is how many unreal engine 2 and below games (UT, UT2k4, Killing Floor, Red Orchestra etc.) worked in a way, where when connecting to a server it would show the address as a url in the form of "some_abbreviation://server's ip". I'm hoping there isn't a reason that battlefield 3 doesn't do, (security or otherwise), and that they just never thought to do it.
Very sexy e, HECK THE PLANET etc. 
rot13 is not encryption.
More info: I've written the game and want you to have fun with the code and/or the game. It's about 3 days old, so there's still a lot to do. Glad to hear your ideas or feedback! BTW: Another discussion about asciitron is going on /r/programming: http://www.reddit.com/r/programming/comments/mdg8j/asciitron_a_network_multiplayer_ascii_tron_clone/
Not necessarily. The [other post](http://www.reddit.com/r/Python/comments/mc9ik/searching_and_removing_element_from_list/) referenced by Cosmologicon used `any()` on a string to test for the presence of digits.
I don't understand this: &gt;...or used the default implementation, like this: &gt; &gt;return object.__getattribute__(self, name) Surely he doesn't mean call this from \_\_getattr\_\_, wouldn't that be "going backward?" And is using "object" a mistake where you mean "self". It seems like **raise AttributeError** is the most correct solution.
Upgrade to version 0.3 before trying again.
Google for winexe - it can remotely execute commands on Windows boxes from a linux environment.
Why is this so needlessly complex? You really don't need a wrapper function for this -- not to mention that you're assuming the attribute is always callable. class MyClass(object): def __getattr__(self, name): if name.startswith('print'): print 'looking up "%s.%s"' % (self, name[5:]) return getattr(self, name[5:]) return super(MyClass, self).__getattribute__(name) 
Come on, if you're going to go lambda crazy might as well go all the way and just write the whole thing in lambda calculus. [I'll even start if for you](http://dpaste.com/657100/).
I will definitely hit you up if necessary - thank you.
I'm curious how much of the bugs were from the Framework or from the Battlelog app.
Your "some_abbreviation" is known as the scheme name or simply scheme: http://en.wikipedia.org/wiki/URI_scheme#Generic_syntax Applications that are built to handle a particular scheme register with your operating system. Then when you request a url (like when you click on a link in your browser), the OS launches the corresponding application, typically passing the url as a parameter. It's all very boring and 90s-ish. 
You're right, I'm sure the middle chapters are outdated. Whether these middle chapters are outdated or not isn't relevant IMHO as they are basically poor. I hate it when textbooks basically repeat reference documentation. Personally I did love the first chapter and I feel this hasn't dated.
Have you filed [an issue](https://github.com/mellort/reddit_api/issues?sort=created&amp;direction=desc&amp;state=open) for these requests? Edit: Looks like there [already is one](https://github.com/mellort/reddit_api/issues/24).
Actually it is encryption. How trivial it is to defeat doesn't change what it is.
I do know what they are, however, for the unreal engine based games, the actual scheme depended entirely on whatever the game wanted it to be. (For instance, utk24 used ut2k4 (heh), unreal tournament used ut, killing floor uses kf, etc.) I simply use the some_abbreviation to show that most games would just abbreviate their own name, rather than spelling it out completely. (Sorry if that's not how it came across)
Obfuscated code contest entry?
In Python 2.x: for x in range(100):print x%3/2*'Fizz'+x%5/4*'Buzz' or x+1
good article, I think I've been bitten by this one too but it was too long ago to remember. btw I wouldn't had called myself recursively after founding the real attribute name but instead use self.f() of course this has the same problem as in the article.
Nice! I have a hard time imagining it getting much smaller than this.
 TELNET TO 216.246.45.19:31337... CONNECTED! You are in the ready room of the light cycle arena. You see a blue light cycle in front of you. &gt; get light cycle There is no 'light' here. &gt; get cycle That is too big for you to take! &gt; go into cycle As you seat yourself in the light cycle, it automatically turns on and hurtles you forward into the arena. You see a yellow light cycle to your left. You see an orange wall in front of you. &gt; go right You see an orange wall on all sides. &gt; get out of cycle Your light cycle has crashed into the orange wall. You survive the impact, but are soon eaten by a grue.
Someone has been playing "Zork tron".
I wrote a trivial bot in Scheme the other night as an exercise for myself, and while I didn't try to obfuscate it in any way, I imagine with the combination of parentheses and convoluted macros you could make something pretty darn ugly looking too :P
You can't compare QtDesigner to a full WYSIWYG editor such as Visual Studio. 
An even better (though more complicated) mechanism is [SCRAM](http://tools.ietf.org/html/rfc5802), which supports mutual authentication, election of newer hash algorithms; and most importantly the password is not stored in plaintext on the server, but as a PBKDF2 derived key, meaning a breach of the server does not reveal the user passwords. not that there are many python implementations of this out there :(
I enjoyed this. Thanks. 
Weak sauce. Try a whole chat _server_ written in this style: http://tinyurl.com/chatserver
Thanks, now all is fine.
Nah, it looks like lisp :(.
Why not? Because you can't edit code with it? That has nothing to do with a WYSIWYG editor. But for your sake, what about Qt Creator and Anjuta?
main(3934). Wow. It takes a parameter.
For shortest code, use Perl; for most elegant, use Python. ;-) That said, what are some other ways to do it besides the obvious for-loop? Here's one that could be a little more efficient, but it shows off Python's slicing and tuple unpacking: &gt;&gt;&gt; l = list(range(1, 101)) &gt;&gt;&gt; l[2::3] = ["Fizz"] * 33 &gt;&gt;&gt; l[4::5] = ["Buzz"] * 20 &gt;&gt;&gt; l[14::15] = ["FizzBuzz"] * 6 &gt;&gt;&gt; print(*l) 1 2 Fizz 4 Buzz Fizz 7 8 Fizz Buzz 11 Fizz 13 14 FizzBuzz 16 17 Fizz 19 Buzz Fizz 22 23 Fizz Buzz 26 Fizz 28 29 FizzBuzz 31 32 Fizz 34 Buzz Fizz 37 38 Fizz Buzz 41 Fizz 43 44 FizzBuzz 46 47 Fizz 49 Buzz Fizz 52 53 Fizz Buzz 56 Fizz 58 59 FizzBuzz 61 62 Fizz 64 Buzz Fizz 67 68 Fizz Buzz 71 Fizz 73 74 FizzBuzz 76 77 Fizz 79 Buzz Fizz 82 83 Fizz Buzz 86 Fizz 88 89 FizzBuzz 91 92 Fizz 94 Buzz Fizz 97 98 Fizz Buzz Python 3, of course. Here's the Python equivalent of one of those YAGNI Factory Patterns you see in Java: &gt;&gt;&gt; def FizzOrBuzz(n): ... r = "" ... if not n % 3: ... r = "Fizz" ... if not n % 5: ... r += "Buzz" ... return r or str(n) ... &gt;&gt;&gt; def FizzBuzzer(upperbound): ... for i in range(1, upperbound+1): ... yield FizzOrBuzz(i) ... &gt;&gt;&gt; print(*FizzBuzzer(100)) 1 2 Fizz 4 Buzz Fizz 7 8 Fizz Buzz 11 Fizz 13 14 FizzBuzz 16 17 Fizz 19 Buzz Fizz 22 23 Fizz Buzz 26 Fizz 28 29 FizzBuzz 31 32 Fizz 34 Buzz Fizz 37 38 Fizz Buzz 41 Fizz 43 44 FizzBuzz 46 47 Fizz 49 Buzz Fizz 52 53 Fizz Buzz 56 Fizz 58 59 FizzBuzz 61 62 Fizz 64 Buzz Fizz 67 68 Fizz Buzz 71 Fizz 73 74 FizzBuzz 76 77 Fizz 79 Buzz Fizz 82 83 Fizz Buzz 86 Fizz 88 89 FizzBuzz 91 92 Fizz 94 Buzz Fizz 97 98 Fizz Buzz Could be a bit more needlessly abstract and general, but this is the sort of thing I can imagine myself writing "in case I need to make it more flexible later."
I'm not in Python 3 yet, but I've learned several things here. That was much of the reasoning behind the post. Thanks!
We can shut down the subreddit now, thanks.
The only difference between this code and 2 code is the `print` function and that I had to manually convert `range` to a list. Otherwise, it's identical.
I've only read a little about Python 3 so far, but it seems like everything is slightly more difficult.
Mmm... Baskerville. So creamy. I want to click them all.
Because the OP wanted the method to print the original name **when called**.
The space is not needed before `or`. ;)
Really? I have done stuff in jQuery before, and all my homeprojects right now are in flask-peewee. When is the next sprint?
?? Not really. * `print` as a function is better. People who hate having to type a simple pair of parentheses should go to Ruby, where all parentheses are optional. Having `print` as a function lets you do things like argument unpacking (the `*` in my examples), the same as you can with any normal function. It also makes changing the options when printing much less cryptic (comma on the end of a line??). * `range` as an iterator gets rid of a stupid part of every Python programming guide where they say, "OK, I just taught you about `range`, but please use `xrange` from now on instead" That part is a waste. * Unicode is easier in Python 3. The only thing bad about Python 3 is somewhat reduced library support. But that's getting better every day.
And they say that you can't do one-liners in python...
I don't understand why Python documentation can't explain important things like this.
Definitely "Core Python Programming" should be included in "Python Books" section.
you're right, I was posting out of desperation. As it turns out I solved the problem within 15 minutes of making this submission. I actually thought I had deleted it, but as you by now have realised, I am in fact, retarded. 
Pretty cool, but somehow disappointingly grokable despite all the effort :)
My friend works at http://busmapper.co.uk/ If it looks like something you would be interested in, then I could set you up a meeting.
Because battlelog does more than just launching the game.
Thanks, I'll added a non-free book section. I tried to keep it to free/available online books
I agree. Python is extremely elegant, but the official docs are completely useless to a person learning the language.
The development docs are an API reference, but yes, they can and should include more things helpful to beginners, such as usage examples.
I understand that. I still find it frustrating that I have to learn a programming language from random StackOverflow entries instead of from the languages own website/community.
There had been talks of integrating [PyMOTW](http://www.doughellmann.com/PyMOTW/) content in the library docs, but that didn't seem to take off. If you're looking for good examples, that is the place I recommend, or [buy his book](http://www.doughellmann.com/books/byexample/). You're also conflating "learning a programming language" and "learning the standard library". Learning Python *the language* can be completed via [the tutorial](http://docs.python.org/tutorial/index.html) and the [language reference](http://docs.python.org/reference/). After reading that or similar content, you know Python. From there, you'd want to step into the [libraries](http://docs.python.org/library/) - standard or third-party - and broaden your knowledge, and that is where we don't have great examples. (That doesn't make what you said wrong, I just wanted to clarify)
Actually, it's fairly common to use multiple languages on the server. Most web frameworks in most languages don't tend to deal with real-time/websockets very well, and there's other frameworks/languages that manage it better. For example, even when the rest of the application is created in Python with Django or similar, it's fairly common for the real-time parts to be written in node.js.
This was a very useful blog post, because in addition to the usual PyPy updates, it pointed me to [DMTCP](http://dmtcp.sourceforge.net/). Which in turn pointed me to [URDB](http://urdb.sourceforge.net/), a reverse debugger for Python. I don't know if URDB is actually useful yet, but I'll find out.
Fairly common yes, but this article is claiming it's a "modern web application" and it just looks like the same old jumble of bits and bobs as always. I'm fairly involved in [Pyjamas](http://pyjs.org) which is a Python client-side toolkit (it translates to js for actual execution by the browser) and that allows the entire app to be written front-to-back in Python. If you use it with Django or something else with a Python ORM, you can even eradicate SQL.
Oh? I've looked at Pyjamas a bit, but I've never seen a Websockets part of it... updating would still involve manual long polling. A Websockets part would also involve server-side support, as Pyjamas only really covers the client-side stuff.
*Request invite*? Really?
yeah, finally, a Python webframework!
Ah yes, actually it doesn't support websockets yet. They're fairly new; in fact last time the idea was floated (18 months ago maybe) only safari/chrome supported them. Are Django's websockets any good? Or any other ORM-packing Python server framework?
This word, I do not think it means what you think it means: [Realtime](http://en.wikipedia.org/wiki/Real-time_computing)
KILL IT WITH FIRE!
Good points, though if you'd agreed with me, it would have been the first time online that a Python user has ever agreed with any critique of any part of Python ever ;) This language is absolutely infallible to its users.
Well, in each context realtime means something different. Wikipedia says "... and in the domain of data transfer, media processing and enterprise systems, the term is intended to mean without perceivable delay." We could add web to that list.
So is there a FOSS solution similar to this? More power to them if they're successful, but that's quite a chunk of change to drop to be able to develop web applications.
I really don't care, but I wish there was a "end" statement to close while/if/with/whatever just to shut up everyone that complains about indentation. I personally prefer the "indentation is your block", but I'm dead sick of people complaining about it.
 10 PRINT"Y U NO HAVE LIEN NUMBAHS?!?!" 20 GOTO 10
Tons of stuff! The module system, lack of tools to create immutable objects, unnecessary separation of 'is' and '==', multiple inheritance, to name just a few off the top of my head. Then there's other stuff I find limiting or annoying for which no fixes seem possible, like adding multi-statement function expressions. I love Python, but I've been looking for a superior replacement for 10 years. :) 
I want python to have ruby style blocks. Not sure how. And the syntax should be no more ugly than lambda. Maybe if it were just lambdas that could handle statements. Dunno. But I would *really* like it. 
One thing that I think they should have done is say that either spaces or tabs can be allowed for indentation but never both in the same file. During the tokenizer stage the compiler should flag if there are both in the same file and immediately halt execution with an error message giving a reason, line number, and suggested fix. I have had literally DOZENS of times where python couldn't figure out the indentation levels because I was working on a project with other programmers who all had different space counts for their indentation or used tabs. Whats worse, is that often-times the same code looks identical in a text editor, and python would never error about this but would just introduce subtle logic bugs when the clauses of if statements executed unconditionally. It was frustrating. After I sat everyone down on the project and we standardized a convention and converted all of our code to that convention, all the bugs went away. It would have saved us a lot of time if python simply warned us "Im sort-of guessing at your indentation here, this code is probably wrong"
You can use the word pass. Some editors (emacs) will understand it as the closing of a block because you do nothing after a "pass" and automatically indent code accordingly.
I wish the interpreter had block execution. Speaking as a Windows user, when you're editing a script, running IDLE simultaneously, and you write a few lines of code, you might want to execute the new lines to see if your output matches expectation. I notice that when I copy and paste multiple lines of code into IDLE, IDLE reads the first and ignores the rest unless it's part of a block, because it's waiting for a newline without indentation (which it then ignores). So running this selection f = 8 g = 9 defines f, but not g. EDIT: It's fairly clear there are alternatives. It's a valid criticism of the Python that ships, without having to search for 3rd party software.
1) This should work a = 3 def f(): print a a = 4 f() and not give an UnboundLocalError. Everybody I talk to finds this odd. 2) class A: a = 2 b = A.a # not allowed b should be allowed. EDIT: people are misunderstanding my reasons. I know very well how to solve these problems. Yet these are reasons some friends have brought up against python. They are very competent people which I respect and have a lots of experience with many programming languages. Pointing an alternative way to do things is not the answer. The answer is being able to explain why things work the way they do. pjenvey below provided a good argument, unfortunately I read that as "it works like it works because that's how it was implemented". EDIT2: python is still the best language out there!
No OpenMP or OpenMP-like support.
1. The unintuitive behaviour of mutable default args. def do_stuff(items=[]): ... I think almost everyone trapped into this once. 2. It's not always self explaining (at least to me) wether a method returns a copy or works in place. Some convention would be nice. 3. The strict sequencial interpretation of modules. You need to place definitions before usages in the files. 4. Documentation: I still find it a bit untidy. I think a clearer destinction of what's in the module, what are functions, what are classes and methods would be helpful for beginners.
Django doesn't really have much support for websockets, nor do any other commonly used Python frameworks to the best of my knowledge; they're rather difficult to deal with along the normal request handling path. Coroutines are a fairly good way to support them, and they're tricky with Python natively. I don't think there's many web frameworks for Python that are really asynchronous either, which is rather a necessity; the surrounding framework in Python, in the form of async DB layers, etc, is simply not there.
Not to nitpick but... * The module system ** It's not mind blowing, but I don't have problems with it. Care to expand? * Lack of tools to create immutable objects ** like NamedTuple? * Unnecessary separation of 'is' and '==' ** I have to disagree strongly with you on this one. The former compares object identity, and the latter compares value. In a language with mutable types, this is very important. * multiple inheretance ** You don't have to use it, you know. I find it useful sometimes.
The -t and -tt params do just that. -t gives you warnings, -tt gives errors. Python 3 defaults to -tt now.
Yes to fixing the module system, and for more immutable choices Personally I'm a fan of `is` vs == though.
I have trouble with Python's handling of closures and coroutines. They got a little better in 3.x, but there's still a concept overhead involved with using them.
That you can not print integers to file handles. Dang nab it! Everything else makes the right assumptions about that! Now I put [str(x) for x in list] every time.
I really wish there was a GOTO statement, I'm not even kidding. As a former BASIC programmer who found it insanely useful, I don't know why many programming languages no longer implement it. EDIT: Why am I downvoted for asking a legitimate question as a newbie programmer?
multiprocessing doesn't do it for you? Or writing a C-extension (which can use OpenMP)? I was like you for a long time, coming from scientific programming in *gulp* Fortran 77/90, but once you get the hang of multiprocessing, it's quite nice and easy.
Tail Call Optimization.
maybe one day someone will make a compiler thats actually pretty to look at. even pastle coloured backgrounds to show nested statements. 
Good to Great Python dudes: Jesse Noller
GIL. Tail call optimization. 
This works for me: class A: a = 2 b = a
Perhaps it should work, but is there ever a case where you'd actually want to do either of those? Seems needlessly convoluted.
I think this has been said a bunch of times before but I'll say it again: static typing options. Sometimes (like when you're interacting close to hardware) it's difficult to write unit tests.
&gt; I don't think there's many web frameworks for Python that are really asynchronous What do you mean exactly? We can easily issue asynchronous requests from browsers using AJAX-y code and have a django server respond using JSON-RPC, or just use wsgi-jsonrpc, or lots of other server side tech. &gt; the surrounding framework in Python, in the form of async DB layers, etc, is simply not there. You might have to do a bit of hacking to deal with contention in the database but it doesn't seem too intractable.
I have a simple solution for that: Ctrl+A, TAB, shift+TAB. I have my editor (kate) configured to use 4 spaces, and it converts every tab to 8 spaces. Whenever I encounter a file with some or all tabs, I apply the select-all-tab-untab solution. Also, as keccs says, py3 defaults to -tt.
It already has optional support for that  use the #end statement.
Check out the cobra language... It fixes almost anything 
This kept happening: http://xkcd.com/292/
GOTO leads to death and destruction. http://www.cs.utexas.edu/~EWD/transcriptions/EWD02xx/EWD215.html
Well, there is the *global* keyword. Anyone know why Guido designed the scoping this way?
Using a standard IDE or standard setup across your infrastructure would be the most appropriate fix for this..... EDIT: One that knows / recognizes Python and has a default set to 4 spaces... That truly is the 'standard'.
Because it enables spaghetti code, and that's fucking evil. It's better to be forced to learn how to handle the code correctly than using goto, a use that quickly turns into abuse. //Basic lover
Base ten bigot! :)
This can be fixed by using a different IDE. Emacs python mode has block execution, for example.
Something I always enjoyed in C and would love to see in Python: while (inpt = input("&gt;&gt; ")) not in ['Q', 'q']: do_stuff_with(inpt) Basically, make assignments in conditionals. I also don't like lambdas. Anything done with a lambda would be more readable with a simple function.
What's spaghetti code?
map(str, list) looks a bit better and is probably faster.
Imports suck. Consider you have the following layout: utils.py somemodule/ somemodule/utils.py somemodule/test.py if in test.py, there's *no* way to import the base utils.py. This is especially not fun when using third-party packages with common names. I would love to force explicit imports -- meaning you either need to import the full path, or relative paths *only* when explicit relative (ie, import .utils). That means in test.py you could do: import .utils # imports relative utils.py import somemodule.utils # self-explanatory import utils # imports base utils.py
The only reason to have JMP or GOTO is to handle errors. We have proper exceptions in Python already.
I kind of dislike tuples. I hate the one-item-tuple syntax. 1,
For 1)Read some of the archived design decisions for this. There's a deeply rooted computer science distinction that was necessary for proper execution in all cases... I can't for the life of me remember where. If you add 'global' to the line with 'a', you'll find your first example works. a = 3 def f(): print a global a = 4 print a f() print a For 2) You're attempting to access a Class attribute without having first defined the class. So it wouldn't make sense to do that. However... Class A: a = 2 x = A() x.b = A.a The above should work for you just fine. And if you needed it done for every instance of class A, then you could create a property. class A: a = 2 def __get_b__(self): return a b = property(__get_b__) x = A() x.b == x.a 
fascinating... something new to learn every day. :-) yet this works: def f(x): return list(x+i for i in range(1)) class A: x = 2 y = f(x) but this does not class A: x = 2 y = list(x+i for i in range(1)) NameError: global name 'x' is not defined
&gt; GIL They tried to remove the GIL, it didn't give any speed improvement. The reason is that it's not the problem, it's a symptom of the real problem: the reference counting garbage collector. If the GC was fixed, the GIL would go away. So let's add the GC to the list of things we want fixed.
I would not code that way but try teach programming with Python as a first language and students will do that. It is hard to explain why it does not work.
Well, at times it would be nice if things like length and map where available to sequence objects. So, seq.len() and seq.map(str) instead of len(seq) and map(str). More or less, more chaining as it's much easier to follow than going inside-out. Though that would break lots of things as nearly everything is based around going inside-out (for example, "".join(seq) and so on), so I don't know if this should really be implemented.
I miss case statements. Yes you can fake them but they always look messy.
The problem is not how to make it work. The issue is: why does it not work as stated? Perhaps there is a reason it was designed that way. If possible I would like it changed and make it work.
Cheers, I'm impressed with the service, looks very promising I'm going to send them an email, thank you
How about wrapping those bits in Cython? They'd probably be faster too.
Seen it! Served as much inspiration...
Like many other features, I was once "trapped" with the mutable default args issue, but now I like it the way it is. I use it all the time for what would be called in C a static variable.
Makes perfect sense to me. Bound inside scope, don't rely on stuff bound outside of scope.
This is actually covered in [PEP-328](http://www.python.org/dev/peps/pep-0328/) If you're on Python 2.5 or later then you can use: from __future__ import absolute_import and get pretty much exactly the behaviour you need. I believe this is standard in the 3.x series.
There's someone at work that does this and it drives me up the wall. Fortunately I was able to convince him to write an emacs macro to remove those comments before submitting the code.
That's great! I use emacs regularly but didn't know that. Can you give me a quick run down?
Spaghetti code is where you have strands of code all laid out disjointedly in a file rather than having your code structured in an easy to follow manner. Think of spaghetti code as a choose your own adventure book. It would make no sense if you try to read it cover to cover.
&gt; They tried to remove the GIL, it didn't give any speed improvement. You don't seem to understand the point of removing the GIL. The point is so that you can have multiple CPU-bound threads executing Python code, e.g. acting in a producer/consumer relationship, or one event loop thread and that doesn't get hosed by a CPU-bound thread executing Python. All of this is trivial in C/C++ or even fucking Java. The *reason that they didn't* remove the GIL was the speed penalty, but speeding things up was not, in itself, *the reason to remove the GIL*.
* Not really about the language itself I guess but rather the CPython implementation (considering PyPy has this); there is no proper sandboxing, nor a way to securely execute code in a fully separate context * Some facilities for function compositing or chaining, so that instead of having to run for instance `list(map(f, set([...])))` which is read right to left in order of execution, you could write something along the lines of [this](http://markshroyer.com/docs/pointfree/latest/overview.html#examples) * It would be nice if functions that operate in place still returned `self` to further allow chaining * Personally I find proper anonymous functions rather than just lambdas very useful in languages like JavaScript, and it would be nice to have them in Python too * Needs more asynchronous functions for e.g. IO * Theading sucks in Python * As someone else mentioned, tail call optimization * It can be confusing at times when you need to use `global` to be able to reach a variable outside a function and stuff like that, maybe do this a bit prettier. How do functional programming languages handle cases where you would use `global` in Python?
I'd rather just fork(). Look at how the multiprocessing module fires up its child processes on windows. I mean, all props for making it work; but wow what a hack.
Cheers very much! I'll start doing that =)
I suspect it's an implementation issue. When inside a class block, you're executing code that will, when complete, define the class. As such, you don't have the completed class available to access yet. I guess it would be possible to do it as you'd prefer, but I suspect that would need special "class definition" scoping rules that were different from everywhere else, which might not be popular. I'm with you though, I'd like to see it.
&gt;it didn't give any speed improvement. I believe for things in which the GIL is a problem (multiple cpu bound threads) it did give a speed improvement. The problem was, it slowed down things in general, making performance worse for every single other use-case
I mean asynchronous on the server, not on the client. So you can fire off a request to the database, then do other stuff, or yield to another coroutine, while you wait for a response; most database libraries will simply halt the thread while they wait. Convincing them not to takes more effort, if it's possible at all. The alternatives are pure multi-threading or multiple processes behind a load balancer; both are very heavy-weight, and not good for real-time stuff where you can have tens of thousands of clients connected to the server at any one time.
BDFL gave a very simple requirement at the time: * The execution time must be no worse than it is on a single processor with the reference counting / GIL. Note that the work done was also circa 2001 (ish...can't recall). Back then, I don't think many (if any) people had a multi-core processor. Today, if you don't have a multi-core processor, then you're well behind the curve. And that's for desktops AS WELL AS embedded processors. So that requirement may just end up going away. EDIT: python v1.4 in 1996 [link](http://dabeaz.blogspot.com/2011/08/inside-look-at-gil-removal-patch-of.html) In 1996, we had just been introduced to the Pentium, but most people were still using 386s and 486s.
1. Lack of a first-class actor/CSP concurrency implementation in the stdlib 2. Lack of blocks or multi line anonymous functions, particularly for callbacks (other block use cases are catered for by for/with) 3. stdlib ideally should be separate pure-python repo shared between all python implementations. 4. Personally, I'd like to see greenlets as a core part of the runtime. 5. zope.interfaces (or similar) in the stdlib (as en extenstion of ABC's, maybe)
Sandboxing can be done (to some degree) with Zope's RestrictedPython in CPYthon. But it does require some setup: RestrictedPython modifies your Python code (via AST manipulations) so that your controlling code gets a chance to allow/deny attribute access. So you can do something like: your insecure code may access the "bar" attribute on your precious Foo class instance that's passed in, but nothing more I use this successfully in a commercial product; the slowdown isn't that bad. The disadvantage is that you cannot fully control memory/CPU usage, the only way to ensure that is to run it in a separate process. Python used to have a restricted mode, but it was too buggy and was eventually removed.
This is an odd one, it's unfortunately due to the fact that under the covers here the generator expression would have produced a closure: class A: x = 2 def __gen(exp): for x in exp: yield x+1 y = __gen(iter(range(1))) once you realize there's a function definition underneath the message should make more sense -- functions can't access the class scope in that manner
Why on earth would map be faster?
http://python.about.com/b/2007/09/24/emacs-tips-for-python-programmers.htm
Map is less pythonic than list comprehension, I would use the latter. And it is not slower.
1) global a # should pass a to def to override local name errors 2) class A: a = 2 b = A.a # should be 2, don't reference a class within a class if same class (think A.b)
The annoying use of ":" when a simple line-break would suffice (to end an expression/statement). I always forget it, unless I do those quick `if x: something()`. "Because it makes code more readable". My rear end. ---- Module A does `from B import foo`. Module C does `import A`. Now, in C you can do: `a.foo` Sometimes that's quite handy, but in big code bases, with plenty of packages/modules, it can get quite messy far too soon. I wish there was a better way to deal with that (a l Delphi's "uses" in the implementation section: ie, what you import is not accessible to those who import you, unless you want that to happen) than doing: `from B import foo as _foo`.
What's the alternative, without variable definitions? Is a local or global in the following case: a = 3 def func(): a = 4 It must be local, since otherwise there'd be no way at all to create local variables. Python's rule is that if a variable is assigned to within a function, then it's a local, unless explicitly declared global. Which leads to oddness when the variable is used before it's assigned to. Python chooses to give a hard error and let the programmer decide what it was that he wanted. It's not unreasonable.
A do..while construct makes for more elegant code when you need the loop to run at least once. Otherwise you end up duplicating code before the loop body and in the loop body or fudging your while condition with an indicator of some sort so that it always runs at least once. A proper fall-through switch statement makes certain code a lot less complicated, too.
1. I'd like to see the stance on "explicit is better than implicit" softened a bit. Some libraries (e.g. logging) are needlessly painful to use for the common case. 2. DictCursor as mandatory in db-api. (NB: Not necessarily default, but require modules to provide it.) 3. self annoys me. An implicit self argument, or better yet a sigil, like ruby's @, for instance variables. 4. Some lightweight syntax for basic ADTs and pattern matching ala haskell would be spiffy. Sort of like NamedTuple, but really baked in with convient syntax.
Nothing wrong with lambdas. If you don't like 'em, don't use 'em.
You don't actually need absolute_import for this, explicit relative imports always work in 2.5+ since they are syntactically distinct from normal imports.
This is what the nonlocal keyword is for.
Tell Mattias that Elver sent you :)
I would use it right away, if there were an implementation not relying on .NET/Mono (ie, I would love a compiler for it that generated standalone binaries).
I see your point. To be fair, while I've worked on several webapps, they are only intended fairly limited numbers of users. Is that why Java is still so popular for heavy server stuff?
Also, list comprehensions work as expected and its cleaner to write y = [x+i for i in range(1)]
Remember to declare variables based on their scope. You can't build a class object based off a class object in such fashion. x in class A is A.x, not x, and A.y looks for x in a global scope. You can't build A.y off A.x because y exists inside the reference class.
My stance exactly, I literally pretend they do not exist. Except for signal/slots in Qt with arguments, you kind of *have* to use them then.
But they're completely different! li = [1, 2, 3, 4] li2 = [1, 2, 3, 4] li == li2 &gt;&gt;&gt; True li is li2 &gt;&gt;&gt; False
Nah, Java's popular for heavy server stuff because managers like pretty pictures and over-designing of things, and it's also ridiculously easy to pick up a cheap Java developer fresh out of college, or outsource development, if necessary. Websockets stuff on the server, for the moment, outside of Java environments, is usually done with node.js. It's basically server-side, asynchronous javascript. Traditionally, this sort of thing has been done with custom C++ socket servers, so it's a step up from that... I'm rather looking forward to what's next, though.
In an ideal universe, we would have a distinct type of bracket/parenthesis/brace for each of list, tuple, set, and dictionary, and function calls, and expression grouping. Instead, we use () for function calls and expression grouping, [] for lists, {} for dictionaries, and ugly special cases with () for tuples and sets.
&gt; I believe for things in which the GIL is a problem (multiple cpu bound threads) it did give a speed improvement. If I recall correctly, it was very slight due to all the acquiring and releasing of mutexes for all the mutations to data structures.
Good explanation, thanks. It would get messy very quickly, especially in nested functions. 
Pet peeve: typing `exit` in the command line shell doesn't exit. Instead, it tells you how to exit "properly", using `^Z [Enter]` or `exit()`. So basically, Python knows *exactly* what you're trying to do. It's just being a bit snobby about it.
Regarding #2, The Scheme-y convention of using exclamation marks for mutation is nice for this (set! foo bar) Now we just have to come up with a similar convention in Python.
My only real problem with the language on a philosophical level is lambda. It's needlessly crippled, and could (fairly easily, I think) be made into a Real Boy. I know the BDFL doesn't see the use, and for a lot of things, he's probably right. But I think it's got its share of uses, and it seems like it's crippled out of spite. On a technical level, mutable default arguments feel hackish to me, and I really wish the garbage collector would get an overhaul, because, if I remember correctly, that would make removing the GIL a considerably better option.
Assignments in conditionals is not very pythonic, though. I'm pretty sure that was a conscious omission and will not change anytime soon. I could imagine a class to easily abstract this pattern, though. inputter = Inputter("&gt;&gt; ", ['Q', 'q']) while (inputter.next()) do_stuff_with(inputter.val()) Or even Inputter("&gt;&gt; ", ['Q', 'q']).run(do_stuff_with)
TCO is one of those things I could go either way on. On the one hand, it could make a serious improvement in certain kinds of code. On the other hand, it undermines one of the real strengths of Python: error messages that make goddamn sense. When you start optimizing tail calls, your call stack becomes either a tangled mess, or completely useless for tracing execution. In the end, I think some kind of TCO decorator would be the way to go, but I seriously doubt it'll happen in CPython.
Check out [IdleX](http://idlex.sourceforge.net) with SubCodes. It does block execution, even on indented code. EDIT: For more info, look at [SubCodeTutorial.py](http://idlex.sourceforge.net/SubCodeTutorial.html), which is provided as a demo.
Yes, but then you have to use Emacs. I may be in the minority on this one, but I'd rather suffer IDLE's quirks than have to use Emacs.
Pattern matching in Python would be awesome.
If you didn't have to place definitions before usages, then what would python do if you wanted to redefine something later in the program? I think it makes sense the way it is. And besides, it's not that difficult to move the definition to a different part of your program.
They *should* be completely different.
Very Grails like. I gave an upvote, but, IMO 99/month are totally not worth it given the choices at hand.
Without absolute_import there would still be the problem of the package's util module shadowing the top level one. 
django+orbited :)
I think the important thing to look at is : http://www.planetframework.com/pricing/
No, in test.py "import .utils" vs. "import ..utils" is unambiguous. Hence it isn't impossible to import one or the other.
Code blocks without delimiters. Switching platforms or editors can lead to all sorts of hell. I've had this happen a couple of times, it can be real hard picking out the block and applying proper indentation afterwards. 
Module system: Python's module system is a huge strength and it made the language the valuable tool it is today. But the way `import` works reduces modularity: it complects finding and loading new modules with declaring the dependencies of the code doing the import. In other words, if I type `import json` in my Python code, this says two things: most importantly, it says "My code needs a module named `json` to work properly". It also tells Python to go find a file and load it, if it hasn't already. Smushing these two concepts together results in some problems. In particular, what if there's a faster implementation of the `json` module that could be used like `cjson`? My code has committed to using one implementation and not the other. I don't _actually_ care about the implementation if the faster version has the same interface. Why can't something else take care of which version I get? Immutable objects: NamedTuple is a small start. There's no good way to write something like Clojure's immutable maps in Python, though. Comparing object identity makes sense for mutable objects. Comparing value makes sense for immutable objects. We can have one operator that does it all. "You don't have to use it" isn't a good argument when talking about language features, because I certainly do have to work on code written by other people who _did_ use it. :) Even restrictions on MI like mixins only or even just dropping C3 would be a great start.
Is it _really_ a good idea to have an equality operator that can return different results for the same objects at different times? :)
I remember now that this was one of the things I wrote in that other forum that I was disappointed weren't in Python. Someone wrote me an angst-filled response to that one proclaiming how great it was that case wasn't in there, because of how stupid and dangerous it was. To me it's just some nice semantic sugar for if/else statements.
Technically, map is ever so slightly faster than a list comprehension if the function argument is native, but quite a bit slower if a lambda is used. List comprehensions have consistently good performance. I seem to recall Guido explaining why this is, but I can't find it. However, you can test it yourself: http://stackoverflow.com/questions/1247486/python-list-comprehension-vs-map $ python -mtimeit -s'xs=range(10)' 'map(hex, xs)' 100000 loops, best of 3: 4.86 usec per loop $ python -mtimeit -s'xs=range(10)' '[hex(x) for x in xs]' 100000 loops, best of 3: 5.58 usec per loop $ python -mtimeit -s'xs=range(10)' 'map(lambda x: x+2, xs)' 100000 loops, best of 3: 4.24 usec per loop $ python -mtimeit -s'xs=range(10)' '[x+2 for x in xs]' 100000 loops, best of 3: 2.32 usec per loop 
The current mechanism can determine what scope a variable is in at compile time, which affects how the bytecode is generated. In other words it's a language requirement that makes optimization easier.
I used to fill up the type prototypes in ActionScript (Flash 5/MX) with string methods and what not, and I loved being able to write like this: myStr.split('|').remove('f','j').sort().join(':').reverse() It made perfect sense to me, and read almost like a verbal language. My string would be split into a list around | chars, then any elements of the list that were 'f' or 'j' would be stricken from the list. The list would then be sorted (with optional parameters), joined again with semicolons into a string, which would then be reversed. I've experienced quite a bit of vitriol from many people who sincerely hate that style and find it woefully unreadable, however, it's as clean and readable to me as this sentence.
Just had this one happen to me yesterday. Someone sent me a chunk of code pasted in an email. The email killed all the indentation. There was absolutely no way for me to discern which parts were part of which blocks. It was the first time where I realized how confusing a lack of closing delimiters can be.
I too recently had this flash of insight that lists or dicts as default args could simulate C's static variables (which I miss in Python and can only otherwise really by simulated by module globals). Then I came to my senses and realized how ridiculous of a contortion it would be to abuse default args like that. Do you really do this, and is the intent clear at all?
&gt; To me it's just some nice semantic sugar for if/else statements. Then you are doing it wrong. Especially in Python where you have mostly sensible coroutines and lambdas. I know it's a hard habit to unlearn but switch is fugly and the wrong choice in most situations where you actually should use an if/else chain.
And dictionaries are still indexed with []. I've always wondered why that is.
Knowing nothing about TCO other than having just read the Wikipedia page on it, can you explain how much efficiency could realistically be gained from this optimization? 
Isn't {} used for sets too?
this stackoverflow post may be of interest: [Python 2.x Gotchas and Landmines](http://stackoverflow.com/questions/530530/python-2-x-gotchas-and-landmines)
Perl already exists ;)
http://www.reddit.com/r/Python/comments/mejfc/are_there_any_things_about_python_that_you_do_not/c30b1u7
How in the world can I be using if/else wrong? This is what I was talking about in my post. Something that seems quite benign to me is considered horrible to users of Python, which they quite vehemently express. "Fugly" is an opinion. I find it to be quite attractive in appearance, though perhaps you meant fugly in underlying implementation or logical flow. I'd love to hear some elaboration on this. I also don't see how it's different than an if/else chain. I even like the break statements, because I can stack up alternatives and allow the program to fall through sometimes related possibilities. I don't mind if/else, but if/elif/else always looks very fugly to me.
What's the difference between a hypothetical multi-line lambda and a def block without side effects?
I used to feel the same way, but now I prefer this: if val == 1: do_something(val) elif val == 2: do_something_else(val) elif val == 3: log_it(val) elif ... to this: switch (val) { case 1: do_something(val); break; case 2: do_something_else(val); break; case 3: log_it(val); break; case ... I've come to appreciate the readability of it.
Assignments in conditionals are a nightmare to debug and don't help readability, while the only benefit is you save one line of code. Not worth it.
I always found Pascal's repeat...until to be a great complement to regular while loops. 
I hate you.
The issue is more that it prevents using certain types of algorithms making use of tail recursion because there's a limit on how deep you can recurse in Python.
That's more of a comment on Windows sucking than Python.
I don't know, it's clear to me. The most common thing I do is a sort of quick-and-easy memoization: def choose(n, k, cache = {}): key = n, k if key not in cache: cache[key] = 1 if k == 0 else 0 if n == 0 else choose(n-1,k-1) + choose(n-1,k) return cache[key] What do you think, is that incomprehensible?
 class A: a = 2 b = A.a # not allowed IMHO if you know how metaclasses work it would be clear why the above doesn't work. There is no `A` class until the body completes. Have your colleagues learn metaclasses first, see how awesome and great they are, then your example will look pretty natural to them. I don't think the first impressions of folks outside of a system are really the best judge. 
I was referring to structural pattern matching (basically, uber case statements as in ML, Haskell, Scala, etc), not to regex pattern matching.
I hadn't though of that. Thanks.
That's fine if you have one level of package between yourself and the target module. Once you get nested packages it becomes more unwieldily . The dot import also breaks if you need to move your module within your package hierarchy. At least using absolute import works every time, and it's obvious where the module is coming from.
I hadn't though of that. Thanks.
&gt; mostly sensible coroutines and lambdas Yeah, that's **way** clearer than a friggin case statement.
I love Ruby for using this convention as well.
I love python the language and I know way too little to want things to be done differently at a language level. Implementation however is a completely different thing. I would love to see an implementation with a sane way to produce .app, .exe and linux binaries for beautiful GUI apps out of the box. I'm just too tired of juggling py2exe, py2app and the myriad of cross-platform related issues from wxPython. 
 * Threading. Threads in Python are just shit. * The standard library HTML parsers. Painful. * from X import * # congratulations on polluting your namespace * The hassle you have to go through to fake a static variable. * IDLE being a smartass on *exit*
Well there *is* an importable module to add label and goto: [http://entrian.com/goto/](http://entrian.com/goto/)
Just because you're not familiar with it doesn't mean it's not a better way to do it.
Check the neat [sudoku solver](http://norvig.com/sudoku.html) Peter Norvig coded in Python. It uses two mutually recursive functions. It works very well and is reasonably fast but using that kind of algorithm with something that's bigger than a sudoku grid might turn problematic.
For code that's going to be maintained, one of these is objectively superior to the other. (Hint: it's the one that's clearer, not the one that's fancier.)
Thats all fine and good, but the fact remains that there isn't "no way" to do it as originally postulated :-) Style and formatting is a different matter entirely.
IPython has that one fixed. exit exits.
&gt;from X import * # congratulations on polluting your namespace You don't have to do it that way, and there isn't a way to get the good bits of that (the convenience of referring to the names without a namespace qualification) without the bad bits (polluting the namespace) except with an absolutely atrocious violation of "explicit is better than implicit" (adding a gazillion implicit look-up-attribute-in-module rules). &gt;The hassle you have to go through to fake a static variable. Seriously? class Foo(object): static = 42 # refer to and/or modify Foo.static as desired def bar(): bar.static += 1; return bar.static * 3 bar.static = 0 Done. &gt;IDLE being a smartass on exit `exit` is a callable object, so being expected to call it for it to have any effect is completely logical. The fact that it prints a message otherwise means they've actually taken a step to help you understand the problem, by overriding the `__str__` and `__repr__` of the class so that you don't get the cryptic `&lt;site.Quitter instance at 0xDEADC0DE&gt;`. The bit about Ctrl-Z is borrowed from the built-in Python interpreter, where it works (following normal command-line conventions). IDLE traps that keypress and uses it (following normal GUI conventions), so the command line it wraps won't receive it. But you can still quit IDLE with Ctrl-Q or by clicking the red X. It would be wrong for IDLE to go about replacing builtins like `site.Quitter`, because how could you trust that your code will work the same way on the command line then?
Using map, filter and reduce (or multiple generator expressions) feels inside-out compared to LINQ's awesome chainsaw goodness.
Multi-core processors are certainly ubiquitous, but unless you go to the extra effort of making your code multithreaded, it will still be running on a single core. So it's still a very important requirement. Besides, most software doesn't actually spend much time CPU bound. And we have multiprocessing to handle many of the situations where you do want to use more than one core.
Same thing happens on Linux/Mac too. It's ugly, but it usually works.
well I REALLY miss var_dump(),... as a beginner I can tell you that having such a tool to debug makes your life really easy. I am just starting with python but I haven't figured how to check for the contents of an object yet... :'-(
Because it **isn't a command line**, it's an interpreter for a programming language. They go out of their way to tell you what to do. Without explicitly coding for the purpose, you would get a message like `&lt;site.Quitter object at 0x12345678&gt;` instead. Much less newbie-friendly. Besides, special cases are bad. Simply referring to an object shouldn't have a side effect. The newbie gets a Zen lesson in how Python works.
Just a note on the module system. What you are looking for is: try: import cjson as json except ImportError: import json Then you use the fast version if it is there, and if it's not use the slow version, if that's not there, it will throw another import error.
How is a class or function attribute not "really static"?
Right. As they should be.
On import *: yes, I'm aware you don't have to do it that way, which is why I stay away from it. Doesn't mean I have to like it. On static variables (not class variables/methods): exactly the way you wrote it, it's a hassle. The bar.static = 0 , out of scope, is absolutely atrocious. On *exit*: does it being a callable object serve any purpose at all, considering the existence of *sys.exit*?
The new IPython QTconsole also has block execution.
I'm talking data variables really, in a function you can't have an attribute that's static like in, for example, C. You can implement it with classes and the like but it's not a *true* static member.
*This* is the best argument for *much* of these complaints people have over Pythonisms that are less than clear (Python Decorators- which was a horrible name for what they ultimately do- can be lumped in with these). Honestly I think it's a problem of the times. People today tend to write disposable code, and finding someone with experience writing software for maintainability is increasingly rare.
They're two different operators, end of story. == :: is the left item's data equal to *in value* the right item's data? is :: is the left item the exact same item as the right item?
Of the python code I have looked at the pythonic solution seems to be... def do_stuff(items=None): if items is None: items = [] foo() I am not sure why, but it pops up in code a lot.
The recommended indentation style should be tabs not spaces \*`braces for indentation war`\* 
 { 1: do_something, 2: do_something_else, 3: log_it }.get(val, handle_error)(val)
[Stackless Python](http://stackless.com/)
It is, since 2.7. But you still have to define an empty set with set(), because {} is already an empty dict.
[Stackless Python](http://stackless.com/)
Module System: What if the faster version has a bug, and Python isn't aware of it? I think you ask too much of your module system, and of the developers of said modules. Name distinction is crucial for code re-use. (yes, I'm aware you can get around name distinction.) Immutable objects: I think this may boil down to a syntax issue. I bet it'd be pretty easy to implement something like this. Comparators: In a language with only immutable types, the distinction is unimportant. In Python, it's crucial. Even with mutable types, you may want to compare value. In a system where mutable types is an option, you may need to compare the identity of immutable types. Keeping this distinction is crucial. I think you're going to have to take a nice "deal with it" on multiple inheritance ;)
If it is complicated enough to have multiple lines, it is complicated enough to have it's own name. Use def.
BTW how's cython type inference ? 
In 2.7 and up, yes.
What else would you index them with, and why?
Can you be more specific? An example where a case statement would be worse than a if-then-else chain would be appreciated.
Actually (C)Python performs an optimization to decrease lookup of locals by using an array instead of a dictionary but this also requires knowledge of whether a name references a local or global object at compile time. That's harder to tell if you allow using names to reference both globals and locals an exception is raised in this case. So it is actually unreasonable, it is just not so inconvenient that someone seriously tried to solve the issue.
Well, stack traces resulting from infinite recursion do have the nice property of being very recognizable, but they're also pretty spammy...
I hate the syntax for lambdas in Python. The written "lambda" annoys me. Why not simply go without it? E.g., instead of: sorted(l, key=lambda o: o.id) why not this? sorted(l, key=o: o.id) or sorted(l, key=(o =&gt; o.id))
I'd describe it as: code where everything connects to everything else. If you change one part of it, you have to go through the rest of the program checking that you haven't broken anything else. I started coding in BASIC, and I remember the fun of adding some lines, having to change line numbers below, then having to track down any GOTOs that needed updating. In general, code is easier to maintain if you break things out into well-chosen functions and classes. You can change the internals of a function, and be fairly confident that the rest of your code will carry on working right. This is also described as having 'loosely coupled' parts. Of course, you can go too far, and introduce so many layers of abstraction that it's hard to see what your code actually does. I've seen this called 'lasagne code'.
Ew. If you really somehow need that, and don't want to make a closure or object for some reason, that's what function attributes are for. A "static variable" that you can accidentally and silently override by passing an extra argument to your function is pretty misfeatureful.
I don't want "exit" built into the language, but support for it is simple; make it a control-flow statement like "return" instead of a function lookup.
I think most people use a memoization decorator and avoid the need to actually write the memoization logic each time.
If `cache` is never meant to actually be passed into the function there should be a comment explaining that. With such a comment I wouldn't find it confusing, but I might wonder why the cache isn't just an instance variable (or top level, wherever it makes sense).
Everything is indexed with [], why would you want to add a special case for dictionaries?
That makes sense once you explain it, but is an unfortunate asymmetry. Off the top of my head, I can't think of a good reason for why functions shouldn't inherit the scope of their lexically enclosing class, the way they do with lexically enclosing functions.
Despite much effort, no one has ever been able to come up with a good do..while syntax construct. So you're stuck with the Knuth "loop and a half" style "while 1: pre-code; if test: break; post-code."
This little gotcha xs = dict.fromkeys(range(2),[]) vs. xs = {i:[] for i in range(2)} then try xs[0].append(1) And see what each gets you. I make this mistake about once every other month. Dynamically defined methods are not serializable. Because multiprocessing and threading pickle everything before they pass it around, you can't do a parallel map of a lambda function. For instance from multiprocessing.pool import Pool p = Pool(processes=4) p.map(lambda x:x+1, range(10)) won't work. Generally, I think parallel support is weak. The best parallel implementation I've found is the one built into IPython. Edit: Formatting
They also make it hard (if not nigh impossible) to pinpoint an error in the recursing code. That's been the main reason that I've seen for leaving TCO out of CPython.
I'll add: Proper documentation for metaclasses in particular, rather than having to rely on outside articles or examining the implementation for details.
I dread using urllib/urllib2 for anything other than basic URL requests.
Or you can enable the beta hashless "end" feature with `end = None`.
Is there any difference between that and the generator expression `(str(x) for x in list)`?
I tend to prefer using a data structure to dispatch instead of a big if/else or switch/case but I don't think it's the *right* way to do it, it's just a preference. I'm sure that some don't like using data structures to dispatch, and that's ok with me. (Of course it's much nicer in JavaScript or Ruby since Python has castrated anonymous functions, but you can just use named functions in Python at the expense of convenience and brevity.)
Only one pass over the data instead of two, and it doesn't have to materialize the result. Though I don't know why it would be better than a generator expression.
It's also the argument that leads to Java. Be careful.
Every once in a while it is nice to have fall-through.
Yep that makes sense. The problem I have with a decorator is that often I need the arguments to be "normalized": def rotatedimg(filename, angle, cache = {}): angle = int(angle) % 360 key = filename, angle etc.... Any idea how to accomplish that with a decorator?
Cheating a little, because it's one of the main changes for Python 3, but Python 2's unicode handling is just nasty: * Most APIs that expect 8-bit strings will accept unicode strings...so long as they only contain ASCII characters. English speaking coders like me almost never think to test with non-ascii characters, so there's tons of code that breaks as soon as it meets "caf". * Some APIs do something different, just to keep you on your toes. compile() treats 8-bit strings as if they were in cp1252, but treats string literals inside unicode strings as if they were encoded in utf-8. * 8-bit strings have an encode method, and unicode strings have a decode method. When a newcomer tries "caf".encode('utf-8'), they get a UnicodeDecodeError. In case you're scan reading, that's a *decode* error when you try to *encode*. Needless to say, this doesn't help anyone understand what this unicode thing is all about.
Heh, actually I personally find Java lends itself to *horribly* un-maintainable code... But I get your point anyway :-)
I don't see why a lambda block couldn't be delimited with indentation just like every other block construct in Python. Although it leads to ambiguity with the `return` statement, I think it's sane to make `return` return from the lambda. # behaves as it does now inc = lambda(x): x + 1 print inc(1) # does exactly what it looks like inc = lambda(x): return x + 1 print inc(1)
This works? /python n00b here... 
Fair enough. On the other hand, having the ability to override the cache lets me disable the memoization, if I know it's a call I won't ever be making again and I want to avoid growing the cache too much.
Convention exists: In-place functions don't return a value. Copy functions return the copy. The problem may be in library functions that don't realize the convention.
&gt; What I did is I wrote a little python scipt that takes a UNIX command as input (through URL GET method), executes it and prints UNIX output. You **need** SSH, if your hosting provider doesn't provide it find another host. Seriously, setting up a Python app by passing commands through GET arguments is going to be unimaginably painful. Also use `virtualenv` and `pip` so that you don't need to install things to the global packages. That will solve your permissions problem. $ curl -s https://raw.github.com/brainsik/virtualenv-burrito/master/virtualenv-burrito.sh | bash $ mkvirtualenv foo $ workon foo (foo)$ pip install sqlalchemy numpy scipy 
I said you were using switch/case wrong but I assume that was a typo on your behalf? switch is all about optional case fall through. If you a switch with no case fall throughs logically you should probably be using an if/else block because it probably explains what you are trying to achieve better. Otherwise people are going to have to hunt for that case with the missing break; to work out what's going on. If you have a long if/else chain with identical comparisons you don't like in Python, just get rid of it. Use a dictionary for where you would have had the key labels and use a closure or other callable for the code that gets run.
Oh, absolutely, I don't expect them to be added, but if used simply, they're quite nice and add a smooth flow to programs. Look at K&amp;R examples to see what I mean. Sure, we can shoot ourselves in the foot, but the same difficulties can be accomplished through multiple inheritance, which is allowed. I'm not arguing for its inclusion, I always find a way around its lack, but sometimes, it'd be pretty convenient. In the example case, I'd do something more along these lines: def dispatch(inpt): call = {'do this':this_function, 'do that':that_function, 'etc':yet_another_function} call[inpt]() return inpt while dispatch(input('&gt;&gt; ')) not in ['Q', 'q']: pass 
Actually you are right. I meant a closure not a coroutine in this instance. Seriously, it's not that hard. You just have to unlearn the broken switch/case patterns and learn the much more useful functional patterns.
The Python interpreter does not know anything about the object `exit`. What you are seeing is the value of `str(exit)`, just like any other expression you type in the console.
He made a dictionary of val/function pairs. The get returns a function and that function is called with val as the arg. Give it a shot.
This is most useful in regexp matching. Compare: if (m = pat1.match(line)): print "Content:", m.group(2) elif (m = pat2.match(line)): print "Sent from", m.group("from"), "to", m.group("to") ... to: m = pat1.match(line) if m: print "Content:", m.group(2) else: m = pat2.match(line) if m: print "Sent from", m.group("from"), "to", m.group("to") The amount of code doubles and the intent is less obvious because of the increased indentation. The indentation is improved a bit if you can put it inside of a loop, with a continue for control flow m = pat.match(line) if m: print "Content:", m.group(2) continue m = pat2.match(line) if m: print "Sent from", m.group("from"), "to", m.group("to") continue but now it's even more verbose. I've sometimes made a helper object: class Matcher(object): def __init__(self): self.value = None def __nonzero__(self): return bool(self.value) def __call__(self, pat, text): self.value = pat.match(text) def group(self, *args): return self.value.group(*args) m = Matcher() just so I can write the code like this: if (m(pat1, line)): print "Content:", m.group(2) elif (m(pat2, line)): print "Sent from", m.group("from"), "to", m.group("to") 
No, they're not necessary, but they can be nice at times. I've never been a fan of taking away the tool because someone put a nail through their foot with it. Still, as you say, it isn't necessary, even if we do have confusing things like multiple inheritance and metaclassing.
There are third-party decorators for TCO. Here's one: http://code.activestate.com/recipes/496691-new-tail-recursion-decorator/
Dispatch tables.
 * Signature typing (a few `assert`s in the first line do the job for now I guess) * Statements in lambdas (I don't have a Py3K interpreter to test this on, but it's unsupported in 2.x) * `elif`s on the 'for/break/else' pattern * `tuple.__iadd__` needs to support lists! (I don't understand why it behaves this way) * Labelled breaks ([damn you Guido!](http://www.python.org/dev/peps/pep-3136/)) * Explicit iterator stepping / labelled continue (there's a few hacks around it - you can assign the iterator and next(iterator) or iterator(next) within the loop, you can use a C-style while+index, but it would be nice to be able to say, eg, `continue 3` and hell, `back 3`) * Set signature to support list-ish methods (append, etc). The vast majority of my sets are meant to be cheap/transparent uniqueness-enforcers, so I don't want to always wrap it in a lambda, or worse, a `ListishSet` subclass. * C-style `for` loops! (Python's `for` is `foreach`).
Yeah, I remember there being several different TCO workarounds, the craziest of which would rewrite part of the bytecode to jump instead of call. I call that dedication.
This is horribly ugly - do people genuinely use this?
No *idea* why you're getting downvoted. Emacs is a choice and while it's a great IDE, it's not to everybody's tastes.
&gt; Then you are doing it wrong. In several languages (I believe both C# and Java do this), case/switch statements are compiled directly into if/else chains. That really is *all* they are - a bit of syntactic sugar to help make extended if/else chains less onerous. One could make the case that if you've got a chain so big that you need some syntactical help to make it readable you've already given yourself a problem, but in some cases, I've found the case/switch version more readable. Any language feature can be abused, and I think using coroutines and lambdas instead of a sensible (and simple, both syntactically and semantically) secondary language construct would qualify as abuse.
That's exactly what the normal function syntax does. You can declare functions inside of other functions and they will have local scope. def do_stuff(): def inc(x): return x + 1 print inc(1)
It depends on whether you think of parameter default values as "part of the function" or "part of the module". I think most people intuitively consider them as part of the function, i.e. in the function's scope. However python makes them part of the module. I would think that both would be correct -- it's just something you understand and then move on with.
Not incomprehensible nor an offense punishable by death. But If you think from the perspective of a future consumer of your function... I would look at that function (or its generated docs) and wonder "why would I pass a dict into 'choose', and what would that accomplish?" This makes it unclear. I would then need to reed the innards of the function to understand what you were doing, which is somewhat of a waste of time. Obviously in your minimal example, it's trivial, but in a larger function it might require some focus and distract me from whatever else I'm doing. Or you could document the 'cache' param and explain that I'm never supposed to pass anything to it and that's you're using it as a static. You would hope I would read the docs and not rely on my faulty assumption based solely on the function signature (maybe I think I can pass a memcache client connection to speed things up... who knows?) In either case, I feel like more is required of me than I get out of it, and I would prefer you to have created a module variable and dealt with it in your own context (or even better that Python would add proper support for static function variables).
Incrementing an int. Still want to var++, pain in the arse doing var += 1. Also having to datetime.datetime everywhere. Small things but I run into those all the time. 
I know *exactly* why I'm getting downvoted. Emacs is a choice, but it also the kind of choice that seems to burrow deep into some peoples' minds, to the point that a negative statement about Emacs becomes (in their minds) an attack on them, their abilities as developers, or their fitness for inclusion in mainstream society. I *hate* Emacs. I hate it only slightly less than I hate Nazis. I'm pretty vocal about it, which has proven detrimental to my karma several times (not that I'm too worried about a number on a website, unless that website is relaying the details of my bank account). But I'm perfectly willing to accept that people get shit done with it. The shit they get done is, quite often, very impressive, and more power to them for that. My dislike of Emacs is because of Emacs itself, but it's also because of the quasi-religious status it has obtained, to the point that any attempt to point out flaws is seen as an invitation to begin a crusade against the infidels. It's weird, but I don't seem to get the same vibe from vi/vim users, but maybe I just don't encounter as many of them. In summary, use the editor/IDE that you want. Get shit done with it. But just deal with the fact that someone, somewhere, is going to think you're crazy for doing so.
I'd go further and say that any time one feels tempted to use a function-scope static variable, that function should have been a method in a class that can contain state :)
Switch isn't just about optional case fall through. Switch in C does a either a binary search (O(log n)), or table lookup (O(1)) to get you to the correct result faster. Having if/else statements requires O(n) to get you to the correct block. Below are examples: if.c (assembly: [if.s](https://gist.github.com/1371527)) int main(int argc, char *argv[]) { int ret; if (argc == 1) ret = 0; else if (argc == 2) ret = 1; else if (argc == 3) ret = 2; else if (argc == 4) ret = 3; else if (argc == 5) ret = 4; else ret = 255; return ret; } switch.c (assembly: [switch.s](https://gist.github.com/1371532)) int main(int argc, char *argv[]) { int ret; switch (argc) { case 1: ret = 0; break; case 2: ret = 1; break; case 3: ret = 2; break; case 4: ret = 3; break; case 5: ret = 4; break; default: ret = 255; } return ret; } If you look at the assembly you'll notice for each case in the switch statement the code is simply: movl $0, -4(%rbp) jmp .L9 whereas the code for each block in the if/else statement looks like: cmpl $2, -20(%rbp) jne .L4 movl $1, -4(%rbp) jmp .L3
Fucking java! Sir, please...
Do the normalization in an outer function, and pass the results to an inner, decorated helper.
Very true. Take me, for instance. I inscribe all my code on the bark of pine trees and scan it using OCR. I freaking *hate* finding bugs.
 def counter(): counter.static += 1 return counter.static counter.static = 0
couldn't you write a normalization decorator that is applied before the memoization one?
&gt;On exit: does it being a callable object serve any purpose at all, considering the existence of sys.exit? it serves the purpose of enabling them to override `__str__` and `__repr__`. `sys.exit` is builtin at the implementation level, so changing how it's stringified would also require special-casing at the implementation level (i.e. not in the library). But that's an implementation detail; the same logic would apply if `exit` were an alias for `sys.exit` rather than an instance of `site.Quitter`: you still need to call it to exit because that's how the language works on a deeply fundamental level. The interactive prompt is not a command line, it's an interpreter.
See, and I think you're crazy for doing that. But if you can get shit done that way, fair play to you.
Have you tried `dir()`? Or `vars()`?
I'm not using this option enough.
Isn't a URL just a goto for my brain?
How about the hypothetical: do until condition(): # block
I fail to see what is ugly about it.
Thats interesting and helpful. Don't you think that should be enabled by default, though? 
I personally find x = y if z else w to be more confusing than x = (z) ? y : w It could be that I'm just used to thinking like that though. I also disagree that conditional operators make code unreadable if they are used correctly. 
Its not exactly a solution to a language problem to argue "Well, just convince everyone in the world whose code you have to edit to use the same IDE, editor, and code conventions." I thought the python convention was "There should be one and only one way to do things" and "resist the temptation to guess", both principles that the default behavior violates.
One of Python's warts that really bugs me is the way Python treats class methods: class num_range(object): def __init__(self, upper, lower): self.upper = upper self.lower = lower def extended_range(self, p_upper, p_lower): return max(self.upper,p_upper) - min(self.lower,p_lower) &gt;&gt;&gt; nr1 = num_range(7,1) &gt;&gt;&gt; nr1.extended_range(9) Traceback (most recent call last): File "&lt;pyshell#22&gt;", line 1, in &lt;module&gt; nr1.extended_range(9) TypeError: extended_range() takes exactly 3 arguments (2 given) When I made the method call ``nr1.extended_range(9)`` I only put 1 argument in there. The error says I put 2 and claims I need to have put 3. Where did Python get the idea that I used 2 but needed 3? The answer is that a "class method" function is actually a wrapper for the function you defined. So ``nr1.extended_range`` *is not the function you wrote*. If you want the function object for what you did write, it is ``nr1.extended_range.im_func``. That is the function that requires 3 arguments. ``nr1.extended_range(*args)`` calls ``nr1.extended_range.im_func(nr1.extended_range.im_self,*args)`` and the ``TypeError`` is generated because ``nr1.extended_range.im_func`` takes 3 arguments but only 2 (``nr1.extended_range.im_self`` and ``9``) were given. Basically you wrote one function object but two were created. This is why you require an explicit "self" parameter when you write the function but "self" is implicit when you call the function. Because you define ``nr1.extended_range.im_func`` but you call ``nr1.extended_range``.
Because when you're using `lambda` instead of just defining a function locally, it's because you don't want to give the thing a name, but instead just use a one-off as part of a larger expression. def awesome(foo, bar, baz, callback): #... awesome(hax, the, gibson, lambda x: uh_oh_now_things_just_got_really_weird(x) and will_certainly_cause_parser_ambiguities(x) )
Look into the pprint module.
&gt;Comparing object identity makes sense for mutable objects. Comparing value makes sense for immutable objects. Yes, but **so do the other comparison types**.
Assignments in nested functions are actually the weirdest thing about Python, to me. When you assign to a variable, it must be either local or module-level global, it can't be a variable in a surrounding function. Pity, that. EDIT: I just found out about Python 3's "nonlocal" statement. So that is fixed! _Very_ cool. This idiom that is commonly used in Javascript and others: def counter(): count = 0 def inc(): nonlocal count count += 1 def get(): nonlocal count return count return inc, get inc, get = counter() inc() inc() inc() print get() Should print 3 in Python 3. Furthermore, although two functions share access to the count variable, _there is no way for any other object to get to it_. Real privacy in Python! Or am I mistaken about Python 3? Perhaps there is a way to get at it that I don't know about...
Yep. I think it is the perfect language. Where it not for .net and only 50 people using it, i would switch as well.
&gt; stdlib ideally should be separate pure-python repo shared between all python implementations. This has been discussed several times before and I seem to remember it coming up at the language summit last year. I think we (developers of all of the VMs) agree that this should happen, but I don't think it's really high on the task lists of anyone with enough free time to take it on. I'm sure it'll come up again at the 2012 language summit, especially with PyPy and IronPython moving towards 3.x. I don't know that it can be pure Python, though. In CPython we can't depend on ctypes, so there are a bunch of C extensions, e.g., `winreg`, which I guess I'm the maintainer of. Perhaps we'll have to relax that rule.
I've read research that repeat...until is less error-prone than do...while. That is, the inverted sense of the condition maps more naturally to the problem most of the time, and you're less likely to incorrectly negate some boolean condition.
Thanks, TIL. Or rather, Today I Remembered, Having Previously Learned and Forgotten.
Decorate ALL THE THINGS (forgive me)
I think curly brackets make code much easier to read.
I have to say I think it is ugly, but something I have used many times (except I try to be less compact for maintainability). The main problem is that these are now function calls when I might want to just do some simple local variables manipulation. Also what the functions do is hidden in the functions. I appreciate you are redoing megamark16's code sample.
No, only decorate the helper function.
None of this is the language's fault, which is what the thread topic is.
Rather than this: def foo(x,y): statement statement pass def bar(x,y): statement statement pass xyzzy = { "foo": foo, "bar": bar } xyzzy["foo"](x,y) What I would like is something like this: xyzzy = { "foo": lambda(x,y): statement statement pass, "bar": lambda(x,y): statement statement pass } xyzzy["foo"](x,y) But somehow less ugly. No idea how. If python had this then it would be possible to do something like rspec for python.
Well, if the functionality isn't suited to being extracted into function calls, then obviously don't do it this way. If it is, then this idiom helps you discover a refactoring (it's all too easy to leave the code in blocks when it would benefit, both in terms of clarity and reusability, from being extracted) and gives you clear separation of responsibility: the dispatching vs. the dispatched-to logic. As a dispatch mechanism (compared to an if/else chain), it's also DRY WRT the passing of arguments to the functions, emphasizing the idea that the functions have a similar/compatible interface.
4a. Exceptions, please, for the love of god, a list what exceptions and what conditions will cause them. 
I'm not saying that this isn't a good python way to do stuff but I still miss my case statement.
&gt;could (fairly easily, I think) be made into a Real Boy What's your proposed syntax then? Note that Python needs to be unambiguously parseable, and we don't want to add braces.
For god's sake of course it is. a = [1] b = [1] a == b True (This is true because their values are the same At This Time) a is not b True a[0] = 0 (At *this* time, they're no longer the same value and it would make no sense to say they they are) a == b False a is not b True Both of these operators are necessary since they tell you, important, different things.
Also, dict.get's second argument (in this case, handle_error) is the default value if the requested item is not in the dictionary.
Cool, thanks for the reply! It seemed like a neat little solution at first, but I can see where you're coming from. I guess I'll think about it some more and come up with a way that's easy to code _and_ easy to read.
&gt; Still want to var++, pain in the arse doing var += 1 It is?
 def __init__(self): if __name__=='__main__': main() don't bother with underscores.
Because "things that are different should look different" - when applied to variable accesses - leads to Perl's syntax.
For backwards compatibility, I'd say any single-statement lambda (that isn't a return statement) would work exactly the same way it does now. Otherwise, I think it would be pretty obvious, and would function the way I thought lambdas worked before I got bitten: lambda x: a = g(x) return a + 2 Or whatever. Indentation works the same, and if you wanted to keep it all on one line, I suppose you could separate with semicolons. Is there some reason why this wouldn't work?
"Suppose they gave a war and no one came?" :)
Upvote for awesomely good instructions
I wouldn't say that it's ugly, but its appropriateness really depends on its usage. If you use this to select from a set of pre-defined functions, then it's ok, but if you have to create separate functions just to use this little trick, then you probably shouldn't use this method. If/else's are just so much more readable sometimes. 
Now we're talking. This is the kind of reasoning I wanted to hear in arguments, but I almost always get things like "That's just stupid," etc. I'm always willing to listen to differences in opinion if there's anything at all behind them. And now that I think about it, I am using more pythonic methods, like `if thing in dict`. I think the one case where I really used switch statements regularly was in mapping keys.
I've been finding myself doing this more and more often as a replacement for switch: def a(val): print val def b(val): pass switcher = {'a':a, 'b':b} ans = switcher['a'](val) 
Interesting post. In a lot of ways it seems to me like Haskell should be the ideal language, at least from an objective-ish standpoint. But then I think about trying to explain the way it works to anyone who hasn't been a programmer for at least 3 years and it frightens me.
Any good links on this? I don't know about it yet, and I'm intrigued.
What they're looking for is something equivalent to Java's do...while loop, where the condition is only evaluated *after* each iteration. As a consequence of this, at least one iteration is guaranteed. Here's what it would look like. As you can see, it's very unpythonic. do: print("iteration") while condition()
Yes, that's exactly how I meant my version to work; hence "do until" instead of "while". My thinking is that it preserves "pythonic look" by putting all the loop-control information in the block-introducing line.
Sounds like: `while (condition):` But what you could do is: hasRun = True while(condition or hasRun): hasRun = False #other stuff This isn't the most elegant way of doing things, but it does simulate do-while behavior.
It gets ragged on all the time, but I loved Flash ActionScript way back in the MX days ('00-ish). You could do: function myFunc (args) { } But you could also just do: function (args) { } This would create a nameless function, which could be assigned and passed about like a first class object, if it wasn't actually one (not sure): myFunc = function (args) { } or even: [function(){print this[1];}, "Hello, World."][0]() That puts a nameless function as the first element of a list, indexes to it with [0], then runs it with (), which calls implicit 'this,' which because you're calling from within a list has a scope of that list, and thus can index to the second argument and print out the message. You might see why I felt for awhile that Python was tying my hands. Clearly the above example is insane, and I wouldn't write production code like that, but ActionScript (pre 2.0) was like a candy land. I had wacko ideas all the time, and any crazy thing I thought would work, did. It was the most in-tune I've been with a language, and it was the greatest language to straight up play in, especially as it was also tied intimately to a vector drawing engine.
&gt;Sounds like `while (condition):` It's supposed to. That's the point. But it's also supposed to mean what a do-while loop means in other languages, which is why it doesn't say "while". &gt;But what you could do is: Of course. Of course you can't do what I illustrated, either. That's why I described it as "hypothetical". I was addressing the comment &gt;no one has ever been able to come up with a good do..while syntax construct by proposing one. 
Not in Python 3. 
Only in Python 2 -- Python 3 list comps are implemented via wrapping the result of a generator expression in list()
And class decorators.
yes, but how about when you have to debug an object you're passing to a django template? How can you be sure you've passed what you wanted to the template if you're using generic views? I also heard pdb is good but is there a way to see the object dump?
I will, thanks a lot...and sounds cute too...pretty print ;)
I was going to say for immediate clarity that you're accessing a dictionary, but I suppose the fact that it's a string in the []s is usually enough.
G I effin' L
I loved the old ternary conditional, but I've grown to like the if/else variant about as well. The trouble comes in when I try to nest them. It was easier to see what I was doing with single punctuation marks. It's not the best way to code, I realize, but sometimes I just get in the zone and hammer out what appears to be Perl :) What I wish was that I didn't have to specify an else if I don't want one. A simple `thing = 5 if whatever()` would be nice sometimes.
I think Python 3 should have kept integer division the way it is in Python 2.
If you always use the same parameter name by convention for the cache, it's not that confusing. You may even want to pass an arg into cache occasionally, to "restart" a memoized function from a saved state. Also, when you look at a function and see its args, you'll also see any associated default values: that should instantly alert you to treat cache as persistent (I think of them as "pseudo-closures").
Because of this I will never - as I once did in ActionScript - write an implementation of a good bit of Pac-Man in 7 lines of code. It handled random maze-building, 2 frame Pac-Man sprite creation, placement in the maze randomly, turning Pac-Man to face the direction you were moving, keyboard input, and wall collision detection. I also took the usual 6-12 lines of point-around-origin rotation code found in many books on games programming and made it a single, valid line of code, with handling of perspective (z-scaling). It was *completely* unreadable after that, and only a few days later I was unable to ever understand it again. I couldn't even figure out how to change the z-scaling amount with an hour's effort :)
I still want to be able to do it, though, during playtime. I want capabilities, and I'll decide when and how to avoid them.
I think it would be safe to assume that most developers would prefer that python's interpreter determine how things are run on a given processor or multiprocessor. It shouldn't be left up to the developer to produce buggy race conditions and code. Unfortunately, Multiprocessing is not ubiquitous -- especially for older systems (old being within the last couple of years) which do not have the option of simply upgrading to the most modern version of python. 
I ran into #1. Took me half a day to figure out what was going on.
[Learn You a Haskell &gt; Syntax in Functions # Pattern Matching](http://learnyouahaskell.com/syntax-in-functions#pattern-matching) for a Haskell perspective, or [Scala by Example](http://www.scala-lang.org/docu/files/ScalaByExample.pdf) chapter 7 for a Scala perspective. Google around for similar explanations for Erlang, OCaml, etc.
It pops up because it's recommended in a lot of places. It's [here](http://www.ferg.org/projects/python_gotchas.html#contents_item_6) in ferg.org's Python Gotchas list. It pops up on Stack Overflow [a lot](http://stackoverflow.com/search?q=mutable+default+argument), with the None solution occurring as frequently. It's in [Code Like a Pythonista](http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html#default-parameter-values), along with None solution. It shows up on many blogs from people who've been stung. I ran into the problem months back and asked somewhere and got the same solution. I'd call it secret, yet common knowledge.
It is. Thanks. I'll check it out.
Zen: Readability counts.
1- I think for..else syntax is confusing. I'd prefer for...finally. 2- Remove GIL. 3- I found myself doing things like "my_str = my_str.strip()" a lot. It would be nice to have something like my_str.=strip(). 5- Another vote for do..while. 6- Make importing modules simpler.
I guess if I think of it as "[] means access an element" then it's fine. It's like an interface.
Thanks. I have so much to read tonight!
a single real life example which cant be implemented using 5 lines generator and for loop plz 
This is how ecma/action/javascript still does functions, but writing "function" isnt much better then writing "lambda". I like coffeescripts syntax. foo = (a, b, c) -&gt; a+b+c
http://learnyouahaskell.com/syntax-in-functions#pattern-matching
That's interesting. I definitely find myself contorting logic to fit into while/do most of the time. My ideal would be having the equivalent of these 4 conditional loop primitives to work with: - while / do - until / do - do / while - do / until 
I like it! but the "do" is just line noice. until x &gt; 3: x += 1
I suppose my biggest problem with python is that it's slow. Of course, I don't use python for things that are computationally intensive - that would be crazy - but python being slow is why there are so many C bindings which is why the 2to3 migration is so painful which is why we still don't have reasonably text handling, dammit.
Cython is fucking shit. 
turning away from gtk and wx and learn Qt was one of my better ideas, best gui framework out there.
Ctrl-d is faster but seriously use Ipython, the dfault console is a toy compared to it
This language is gorgeous.
I think you'll find that, in CPython at least, if/else chains are boiled down into heavily optimised dictionary lookups.
I think you meant: class A: x = 2 def _gen(iterable): for i in iterable: yield x + i y = list(_gen(range(1))) Python methods don't enclose class variables. But I think it's a wart that 'x' would work in any other kind of expression in this context except a generator expression, list comprehension (Python 3), and set/dict comprehension. It's confusing. 
Lack of code blocks.
Ha ha, agreed. And I agree with you in this case, fwiw.
That's true, but what would the variable be set to if the condition was false?
Yes but they have to be named and are not expressions. I'm not arguing that Python needs this, just saying that it seems like it could be done.
Python has a simiar construct using the "with" statement and context managers: * http://docs.python.org/reference/compound_stmts.html#with * http://docs.python.org/reference/datamodel.html#context-managers
I don't see a problem with that (besides the fact that I find it ugly for some reason). The closing parenthesis doesn't even need to be on its own line.
I love the easy syntax of python (it is so much easier than C++, Java or Perl) and I use python all the time. However: * Python is too slow in some cases: I recently rewrote a CPU intensive method in Java and it was 40 times faster. pypy looks promising but is not included with most Linux distributions * Databases are not batteries included: at least give me ODBC so I can cobble something together in 5 minutes * The unittest module requires all sorts of jiggery pokery just to do common initialisation. No I do not want to run an SQL statement again or make a network request again for each test fixture
[IEP](http://code.google.com/p/iep) has this. It can run selected lines, a cell defined by a `##` comment, a file, or a project main file. You can have several interpreters in tabs (anything from Python 2.5, 3.2, to PyPy), which can tie into GUI event loops (e.g. interactive pylab). It's also all UTF-8 and has configurable line endings (i.e. CR, LF, or CRLF). 
&gt; The main problem is that these are now function calls when I might want to just do some simple local variables manipulation. Also what the functions do is hidden in the functions. Maybe lambdas would be useful?
Awesome list. 
If the python spec required implementations to allow infinite tail recursion, then every do-while instance could be implemented as a recursive function. This code: do stuff while condition becomes: def funcname(): stuff if not condition: funcname() funcname()
It takes extra thought to understand what it's doing. It's an interesting construct but a series of if/elif's would be better for long-term maintainability. 
&gt; It's not always self explaining (at least to me) wether a method returns a copy or works in place. Some convention would be nice. Among the core std library I think the convention is that if it work in place it simply doesn't return a value; e.g. list.sort. The wider std library is more lax though :( 
A very valid point. I suppose I'd like it more for those times when I'm trying to call a function: doThing() if whatever() It's not a very big request given that these are valid: if whatever(): doThing() and: if whatever(): doThing()
tuples are defined by a comma, except for the empty tuple; however, parentheses are often needed for precedence.
I think the implied whitespace inside parens should be extended to after operators. I understand why Guido doesn't like map, filter &amp; reduce. They feel unnatural in the language. However list comprehensions, as implemented in python, are not a sufficient replacement. Passing generators/iterators as arguments to consuming generators/iterators maintains the awkward bottom-to-top reading that the current map, filter &amp; reduce usage requires. I think approaches like [stream.py](https://github.com/aht/stream.py) are the right way to go, but currently you have to wrap the construct in parens to in order to break the iterator sequence, which introduces yet another use of parens -- syntax disambiguation in addition to normal order of operations, tuples, and function invocation. 
This was very common in perl. There was also an unless.
About #4, I couldn't agree more, the documentation is a bit lacking still. Also, it could really use a shit ton of examples. A list of function/method calls from the command interpreter are nice, but I really like actual examples of code in action. Fortunately, there's Pythit, Stack Overflow and a bunch of other places to check. I still think the core doc could be better.
 do: print_options() choice = get_user_choice() while choice not in valid_choices Assuming valid_choices is a list of acceptable choices, print_options prints out some formatted menu and get_user_choice() calls raw_input() and does some validation, this could be used for a CLI menu system. 
&gt; The written "lambda" annoys me. The written "lambda" turns into "" in my editor: x =  y:y**2 Because I have this in my .emacs: (require 'lambda-mode) (add-hook 'python-mode-hook #'lambda-mode 1) (setq lambda-symbol (string (make-char 'greek-iso8859-7 107))) 
I agree with programmer choice but it has dangers. People will misuse bad features. And you will end up with C++. 
This is more of a distribution critique, but I really dislike how difficult it is to get a modern version of Python on Centos/Fedora. They are still using python 2.4! You can install python2.6 RPMs, but good luck with anything newer. You can do side by side installs, but the package manager (yum) uses python. So when you inevitably hose things, you are no longer able to easily install any packages. 
https://gist.github.com/145b31fb4e94122df39a
A framework orientated towards web development...why that is brilliant and in hindsight totally obvious, I am indeed amazed that no-one did this.
Regardless of actuall quality, the quality of the documentation is outstanding. Due to the fact that the PyQT bindings mirror the C++ bindings quite closely, the excellent C++ documentation comes in very handy. 
Why should we turn Python into Java? Apart from mutable default args, Python also has real closures (well, read-only closures in 2.x, but proper ones in Python3).
Yeah. This thing seems aimed at business types who are impressed by conflagrations of buzzwords, not developers.
This. And something like Cython already built-in.
&gt; The hassle you have to go through to fake a static variable. Huh? Just reference the class, not the instance when addressing the static variable.
&gt;If you really somehow need that, and don't want to make a closure or object for some reason, that's what function attributes are for No, it's not, really. If function attributes are meant for anything at all, it's for "metadata", so to speak - they're not meant to be accessed (let alone modified) from *within* the function. Not that I have any real problem with that, but it's much more hackish than the solution you're complaining about. Using mutable default args this way is perfectly natural once you know how argument defaults are handled in Python. (btw, Python 2.x doesn't have proper closures, and this is probably the simplest and most elegant way to simulate one)
Creating processes is designed to be expensive in Windows. It does a ton of bookkeeping on process creation that's much more intensive than Unix `fork`, even if it's `fork + exec`. Then maybe the virus scanner gets in on the action... Windows is designed for process multithreading, so Python + GIL will always be a bit disadvantaged on Windows. But loading a process pool when the app starts is only a startup penalty. 
This is terrible. I mean, props on getting it done and all, but are you really suggesting that this is in any "Pythonic" or clean or readable or anything but a kludge? Edit: Okay, not *terrible*, but a lot more cumbersome than you'd expect for something that is a first-class control structure in almost every other programming language.
This is completely comprehensible to someone who knows the language. It's only going to cause confusion to someone who doesn't know how default args are handled. In that case, it's something that only needs to be learned once, and it's just as well for them to learn it before they accidently use a mutable default arg thinking it's going to be reinitialized each function call. 
I'd rather do while True: with an if condition: break at the end. also, for your style, I suggest you put the hasRun first (while (hasRun or condition)). If 'condition' was complicated then you'd waste time calculating it the first time when you don't have to.
That code example is not correct. The condition should not be evaluated on the first run - it should read firstRun = True while firstRun or condition: firstRun = False # other stuff
I think one that's general would be cumbersome and hard to read. 'You could create a one-off normalization decorator, but I think zahlman's suggestion (wrapping the memoized function in an outer function that performs the normalization) would be eaasier to read. It basically amounts to the same thing, though. 
shit good? or shit bad?
This always strikes me as a pretty fast-and-loose solution. It's fine most of the time, but if you want None to be a valid value to pass in, you've got a problem. I think a sounder approach is to define some object to use specifically as the "placeholder default argument" for these cases. eg arg_not_provided = object(); 
There's pretty much no distinction between defining a function and creating a lambda. The only downside is that you have to name it (which actually helps with debugging and profiling).
Having gazillions of syntax sugar is pythonic ? every single framework with pythonic syntax you use is like this in internals. https://gist.github.com/145b31fb4e94122df39a updated version for those who dunno how this code can look better
If you incorporated into the actual Python REPL, it *would* be part of the language. That's an awful idea. You could argue for doing it in IDEs like IDLE, etc, I guess, but in most cases if you're closing the REPL, you'd be closing the whole app anyway.
anyone interested in foss implementation ?
 f(lambda x,y: print x print y,42) Is 42 a second argument to f, or is it part of the print statement? As I understand it, the complication is mainly how to handle the indentation of the lambda vs other function arguments.
That assumes the reader is unfamiliar with the idiom - and even then...seriously, if you see a dict with a bunch of values paired with functions, what would you expect it to be for? It avoids repetition of val and it's concise and easy to read the table of values and associated functions. Seems pretty maintainable to me.
You could do something like this... switch(val)( 1= do_something, 2= do_something_else, 3= log_it )
Or pass in a lambda instead of the value, like: def do_stuff(items=lambda: []) But then your API changes for everyone else.
The problem is that the expectation "a newline within a block ends one statement and indicates the beginning of the next" is here fundamentally at odds with the expectation "newlines are ignored within brackets until they are matched", because we have put a block within parentheses.
Have another upvote! This was a big breakthrough to me.. now it makes perfect sense why this happens!
You have a point; pairing keywords also doesn't have precedent in Python, and really seems redundant. I was worried that "until" by itself doesn't sound distinct enough from "while", but on further reflection, I think it does.
Ah, that is a good one. There really isn't a good solution.
 class switch(object): def __init__(self, arg): self.arg = arg def __call__(self, **kwargs): kwargs.get(self.arg, kwargs['default'])(self.arg) It would only work for string `val`s and with "cases" that are valid identifiers, though.
So you've just changed the name of my variable?
Zahlman! It's you!
 &gt;&gt;&gt; zahlman is zahlman True
People don't want to have to use a def statement to name a function that they'll only use once, especially when they may not be able to define it at the point they're using it (since def is not an expression).
I miss optional curly braces for doing one-liner stuff inside REPL.
1. Global functions like len() and str() would be easier to use and more elegant if they were implemented as method calls instead. 2. A more developed standard library for things like lists and strings. For such a high-level language, they don't give you all that many tools for working with lists--there are maybe ten built-in functions, as opposed to Ruby's dozens. 3. You are probably tired of hearing this, but I'll go ahead and say it again: the whitespace thing.
I would like to see some more iteration constructs - at least just steal the ones from Perl, like until and unless. Syntactic sugar, yes, but I like it. For example... unless economy.gdp() &gt; economy.history[-365].gdp(): frc.do_qe(n) elunless world.is_safe(): print("I'M BATMAN") elif president in (obama, bush): teaparty.attend() wall_st.occupy() else: print("All is right with the world") do: activision.make_cod_sequels() until kotick.wealth() &gt; world.wealth(): activision.make_cod_sequels(with=treyarch) An unless statement is an if statement backwards: Instead of executing if the statement evaluates true, execute if the statement evaluates false. There are also elunless (elif backwards) statements which work the same way. It should be possible to mix if and unless statements within the same chain of conditionals. Else is compatible with both else and unless statements. The until statement is a while loop inverted in the same fashion: The loop continues executing until the condition is false. Also demonstrated is a do...while/until syntax. Do statements execute until the while or until statement. Then that statement's block executes if it's true, otherwise the loop breaks. We could even imagine a train of while/until statements, like so: while world.has_evil(): superman.fight(evil) until lois_lane.available(): continue There's some appeal and disappeal to this kind of loop syntax. On one hand, infinite loops are simply do statements: do: song_that_never_ends.sing() On the other hand, it's not distinguishable from two separate loops, and I'm not sure what kind of phrasing would work to split the two cases. "Elwhile" and "Eluntil" sounds wrong, since the "El" prefix usually only applies to conditionals, not loops. Switch statements with fallthrough would look something like this: switch someVal: case 0: print ("Special Case") continue case (1,2): print ("Case 0, 1, or 2") break case 3: continue default: print ("Everything else") break A switch-statement consists of the word "switch" and a python expression. It contains either case or default statements. Case statements have a single expression following; the contents of which are equals compared or, if that operation is not supported, referentially compared with the switch expression's evaluated value. The first case statement to successfully compare with the switch expression is executed. If no case statements are suitable, then the default statement is executed instead. All blocks of a switch statement must end with a statement which directs control flow. In a switch block, continue is interpreted to mean "execute the next case block in sequence". Break and return statements are valid. It is invalid to place a continue statement at the end of the last block in a switch statement.
Guido's argument for not implementing it is that due to some of the complexities/internals/dynamic nature of python, the tall call can only be removed in certain limited circumstances. And because of that, if you want to implement one of these such algorithms that requires it for proper sane behavior, you end up coding to the internal specific implementation details of the interpreter, i.e. you have to make sure your code triggers one of those paths where the optimization is able to be taken. Making the semantics of the code depend on internal optimizer details of the interpreter is not a very good situation to be in, as it is error-prone and introduces tight coupling. So he'd rather you just pick a different algorithm that doesn't depend on TCO. 
The stupid, nonsensical, stubborn, old-fashioned, Luddite, wasteful, stuck, smashing, short-sighted, and above all **ugly** recommendation that we stick to 80 characters per line. And all for the sake of some fools stuck on such antiquated hardware that is not good enough to allow installation of vim, but is somehow good enough to host Python? Python is not COBOL! 
I'm reminded of Ruby's [unless](http://railstips.org/blog/archives/2008/12/01/unless-the-abused-ruby-conditional/).
Wow, what kinda code you writing over there?
I like the whitespace, but agree strongly with your other points.
What if we just get rid of all the people?
I don't think it's ugly at all. Maybe it looks ugly because you're calling the method on the end of the multi-line dict definition. Does this look prettier to you? my_funcs = { 1: do_something, 2: do_something_else, 3: log_it } relevant_func = my_funcs.get(val, handle_error) relevant_func(val)
Not quite as confusing as sending source code formatted as html (which, AFAIK, is the only reason why an email would fuck up the indentation)
I am suggesting that the first 'a == b' should return false, and you should use immutable lists if you want that sort of comparison to be true.
I know. This is a workaround for the problem I described. The issue is that _implementation_ and _interface_ are different, but python's module system doesn't let you distinguish. When I'm writing code that uses a module, I generally don't care how it's implemented, just what interface it provides. It's often valuable to provide an alternate implementation of some interface that the code using it isn't aware of -- for instance, in unit tests.
Colon shouldn't be needed after conditional statements; newline should do it, just like CoffeeScript.
Well, if you're using code that has bugs, you should expect it to break. There's obviously no cure for that. My point is that module interface and module implementation are different issues, and Python doesn't provide tools for considering them separately.
You guys say you can't rely on `ctypes`, but take a look at `uuid.py` ;)
&gt; The Python interpreter does not know anything about the object exit &gt; ... &gt; What you are seeing is the value of str(exit) Does not compute. 
That sounds like it would give the programmer behind you trying to maintain that code a nightmare. 
Hm, never knew about that. Weird. When Jason Coombs wrote the first `os.symlink` patch for Windows, it was fairly small and used `ctypes`. It got rejected in like 5 seconds for being `cyptes` based, then it had to be re-written in C and got probably 5x larger. That patch is the reason `ctypes` was "finally" allowed to be used in the stdlib (via a Language Summit debate), but limited only to tests.
http://stackoverflow.com/questions/192109/is-there-a-function-in-python-to-print-all-the-current-properties-and-values-of
 It's not so much what I'm writing as what I' m reading. 
then that code block would probably need a comment, and a function name can nicely serve this purpose.
&gt; The Python interpreter does not know anything about the object ``exit``. I would argue anything patched into ``__builtin__`` by ``site.py`` regardless of whether one is running in interactive mode or not is most definitely an object the interpreter knows about. &gt; What you are seeing is the value of str(exit), just like any other expression you type in the console. NO. Very much NO. You are seeing the value from ``repr(exit)``. They don't have to be the same thing and the interpreter lets you know they are different by not quoting the result of ``repr``. 
FWIW I'm working on some secret sauce to address Guido and Antoine's concerns about using `ctypes` in the standard lib.
&gt; Pet peeve: typing ``exit`` in the command line shell doesn't exit. Go into your /python/Lib/site.py file. Change: def __repr__(self): return 'Use %s() or %s to exit' % (self.name, eof) to def __repr__(self): self.__call__() Problem is now fixed until you install a new version of Python. 
&gt; Without explicitly coding for the purpose, you would get a message like &lt;site.Quitter object at 0x12345678&gt; instead. No, you'd get a ``NameError`` raised. The only reason you get anything at all is because ``site.py`` patched it into the ``__builtin__`` namespace. &gt; Besides, special cases are bad. Too late, ``exit`` and ``quit`` are already special cases. &gt; The newbie gets a Zen lesson in how Python works. A pointless one. It's pretty obvious what was intended but not obvious how ``exit`` became a builtin function despite not being in the [list of built-in functions](http://docs.python.org/library/functions.html).
&gt; If you incorporated into the actual Python REPL, it would be part of the language. That's an awful idea. ``exit`` is as much a part of the language as anything can be except that it isn't "official" and isn't documented. ETA: Actually it's [sorta documented](http://docs.python.org/library/constants.html#constants-added-by-the-site-module).
Hooray Outlook.
Ew, that's ugly.
I see what you're saying. I like the simplicity of Python's module implementation system, though. I don't know how you could do it differently and have it not be difficult to use. "Difficult to use" is definitely a strong anti-motivator for getting things changed in Python.
**Threading** I do wonder if there are any half-way steps that could be taken away from the GIL, possibly by introducing a second model for integrating C code into CPython that we could start moving smaller/threading-critical extensions to instead while retaining the GIL. (I expect someone will correct me on this, though.) **Lack of static analysis** Statically typed languages tell you a lot sooner when you're doing something stupid than dynamically typed languages. It would be nice to have something of this in Python, possibly by providing (optional) load-time verification of immutable classes. (I think these are the two main reasons I've been spending more time with golang recently, in spite of the dearth of libraries available for it.)
I believe the important bit was having the variable be before the loop condition (so that the condition is not checked the first time the loop runs (do to short-circuit evaluation). This could be important if the looping condition has side-effects.
I love 80 characters per line. It allows me to have three editor panes side-by-side on a 1920x1200 screen, which I wouldn't give up for anything.
Not having even optional end of block syntax.
There are a list of existing Python libraries on [this](http://www.id3.org/Implementations) page that retrieve audio file metadata. As for editing file names then you need to come up with rules to list and rename them based on whatever rules makes sense. Those strategies can vary depending on the distribution of the data.
Martin might be the harder sell.
Mutagen looks really cool, i'm going to see what I can do with it. It would be cool if there was a large database full of music that would basically compare your songs, and if it found a match renamed it properly. 
http://washort.twistedmatrix.com/2011/01/modules-in-python-good-bad-and-ugly.html http://washort.twistedmatrix.com/2011/01/introducing-exocet.html http://washort.twistedmatrix.com/2011/03/exocet-second-look.html http://launchpad.net/exocet Hopefully I'll be giving a talk at PyCon about this.
I think with some googling you'll easily find lots of APIs to online music databases and it'll probably be a matter of linking each file to the appropriate title. Discogs and CDDB for example have developer sections offering APIs that you can use. I haven't done any work with these myself so have fun exploring!
I guess what you are saying is that people who really want a do-while can write a generator function once and put it in their personal library and import it as needed. That's reasonable, I guess. I still think it'd be an improvement to have language support, although I'll admit in my own code needing a do-while doesn't come up very often at all. Edit: I assume when you import 'true' in the newer version it's the same function that was called 'while_' in the original version?
No, there were things that sucked about Python they just all got fixed in Python 3. ;-)
The standard library is inconsistent and many parts of it have atrocious APIs, but this is mostly for historical reasons. Which kinda makes it even harder to fix.
[They don't allow ssh access](http://www.webhostinghub.com/support/website/general-server-setup/ssh-access). Most of these cheap crappy shared hosts don't. You get what you pay for. 
Neat idea, but it won't parse because `1` can't be a variable name.
When you're writing good assembly code, a switch isn't the same as an if/else statement. If you wanted to do switch on x for 0 to 9 for example, you might have something like this in memory: #1: add my current location in memory to x + 2 #2: goto that location in memory #3: goto #37374 (where there's the code for what to do in case 0) #4: goto #49494 (where there's the code for what to do in case 1)  Since you're doing a computed look up, the switching always takes exactly three instructions worth of time to get done, whereas if you had a series of `elif`s it would take between 1 and 10 comparisons to figure out which code to run. However, the Python dictionary dispatch hack is also effectively O(1), so it works out to being nearly the same thing.
In Dart, you can do: foo(arg) { return 'hi $arg'; } // named local function But also: (arg) { return 'hi $arg'; } // anonymous function literal This is nice for things that take callbacks: element.on.click.add((e) { print("I'm an event handler!"); }); And if you just need a single expression: (arg) =&gt; 'hi $arg'; 
Uh, if it didn't do that, you'd accidentally exit every time you ran vars() or something.
The lack of infinite recursion, pattern matching, and blocks/full anonymous functions. Oh, and the GIL.
That's a waste. I have literally *never* used `exit` in a program. Instead I write my modules as a series of functions with return values. Why should exit be a keyword if it never gets used?
He means it's not a special case. All that's happening is the developers put a handy message into exit's `__repr__` method. &gt;&gt;&gt; exit Use exit() or Ctrl-D (i.e. EOF) to exit &gt;&gt;&gt; exit.__repr__ &lt;bound method Quitter.__repr__ of Use exit() or Ctrl-D (i.e. EOF) to exit&gt; &gt;&gt;&gt; exit.__repr__() 'Use exit() or Ctrl-D (i.e. EOF) to exit' 
Clarification: The interactive Python shell knows nothing of `exit`.
It is missing a Hotspot compiler. And PyPy doesn't qualify. 
Ok, so it's `repr` rather than `str`. Though I don't see that affecting whether or not you see quotation marks.
I agree and now that makes more sense to me. I am still confused by why b=list(a+1 for i in range(1)) does not work in there.
I phrased that somewhat awkwardly. ``&gt;&gt;&gt; repr(my_object)`` will show as a quoted string but ``&gt;&gt;&gt; my_object`` will not. This is why ``&gt;&gt;&gt; exit`` shows the result it does.
Yeah, kinda slipped up with the vals. I thought "I can use function call syntax to make a dictionary" and then proceeded to forget that the keys would need to start as valid identifiers. Guess you could do this... switch(val)( _1= do_something, _2= do_something_else, _3= log_it ) or this... switch(val)({ 1: do_something, 2: do_something_else, 3: log_it }) I think the first one looks better, but there're obvious issues (distinguishing between numbers and strings with the form of numbers, escaping a string that actually begins with an underscore). Still, you could make it work nicely for common cases and work out some ad-hoc rules for the corner cases (although that's starting to sound disturbingly Perlish). As for the "cases" (I assume you mean the "do something" code), they'd just need to be expressions, same as in your code. In the most obvious implementation, they'd be either function names or lambdas, but if you wanted, you could (additionally or alternatively) allow strings to be exec'd, or any other means of passing code you could think up. ------------------------------------------------------------- edit: The solution I keep *wanting* to suggest is { 1: do_something, 2: do_something_else, 3: log_it }.switch(val) ...but of course we can't do that unless Python wants to loosen her chastity belt a little. I guess the most pythonic solution would be cases = { 1: do_something, 2: do_something_else, 3: log_it } switch(val, cases) ...but that's a bit dull ;-)
Yeah, I got a bit careless there. It'll work for string val, but needs to be modified to work more generally.
That would make other Python comparisons inconsistent. 5 is not (2+3) but 5 == (2+3)
I love that people wanted this enough to make an emacs minor mode for it. (I use it, too.) Lambda mode is right up there with the [nyan cat scrollbar](http://www.emacswiki.org/emacs/NyanMode) mode as something cool and useful enough to actually use, but really pretty silly.
You aren't using class methods in your example. Those are instance methods. `self` is used to refer to the class instance that is passed into the method, when you can all method via qualification like `nr1.extended_range(9)` Python does this `num_range.extended_range(nr1, 9)` that's why it says you gave two arguments instead of three. 
Functions follow an LEGB rule for scope look-up. 1. Local - local to the function 2. Enclosing - the enclosing function 3. Global - global to the module file 4. Built-in - built-in names Whereas classes are a namespace, not a scope. 
&gt; 1. The unintuitive behaviour of mutable default args Yes. It's both a horrible bug factory and pointless. 
Invoking a command and getting the output in Ruby: hostname = \`hostname\` The commonly recommended default in the docs and Stack Overflow in Python: hostname = subprocess.check_call(["hostname",]) # most people use something much worse than this, believe it or not. Pig disgusting.
Many others have mentioned the GIL/threading snafu. The lameness of the GIL doesn't matter much in the problem space where Python is popular today, but it's important for lots of things where Python can't be used today. Python lambdas are a lame implementation of anonymous functions. Only one expression? _Why_? Ruby makes functional programming into a thing of beauty with it's syntax for slapping a block onto any function. Except Ruby of course has to have both functions, blocks, procedures _and_ lambdas, all with slightly different semantics. Fail. On a more basic level, the fact that Python has statements, instead of only expressions, is silly. It bites you in lots of little ways. The "from x import y syntax" is horribly broken in that y suddenly becomes part of _your_ exported interface. And also, if you're giving the full module path to an object, why do you still have to import it first? Java gets name space importing much more close to right. Lots of people have complained about having to write self all the time. I see the advantage of being more explicit, but I'd still prefer to have an implicit self. But I can see that this is an issue where reasonable people can disagree. 
agreed, I never got this one. Let's get rid of the semi-colon, but keep the colon. huh!
That's about 40 or 50 characters, not 80. Reasearch shows that reading speed is inhibited by too long lines. The optimum line length is somewhere around (http://www.usability.gov/articles/newsletter/pubs/082006news.html)[10 inches]. With a normal point size, a 10 inch line length turns out to be pretty close to 80 characters.
the white space thing?
I disagree with your opinions, but at least your examples are awesome.
If you are only using == comparisons that seems fairly likely.
I have no idea what your pseudocode is supposed to mean. Why is the lambda before the equals? 
Forcing people to give things names is definitely a feature, not a bug.
So are you proposing that the compiler enforces 4 spaces too for indentation? I'm not sure I'd disagree with that idea, though I still find it weird to use a language that enforces indents, even though I obsessively indent my code anyway.
&gt; Switch in C does a either a binary search (O(log n)), or table lookup (O(1)) to get you to the correct result faster. That's implementation defined and depends on all sorts of things about the layout and (mandatory integer) value of your case statements. I believe if the range of values used is too large it will resort to just doing a fall through comparison chain similar to what you'd have got with if/else. These optimisations do not extend to non-integer types. To me this is more evidence that switch is not for humans. It is for compilers. I can't think of any technical reasons that a compiler couldn't detect an if/else chain of integer comparisons and compile it as a table lookup. It's just that not much code expects compilers to work that way so people don't do it that way.
You might enjoy [this quora thread](http://www.quora.com/What-are-the-main-weaknesses-of-Python-as-a-programming-language). Some people there pose a few solid critiques of Python.
&gt; I've found the case/switch version more readable. And I find them to be less readable than other alternatives. Java and C#'s switch is weird and anachronistic imo. Like in C they exist mostly to make compiler writers lives easier. Additionally C# adds a bunch of extra caveats about where break statements can go in the cases just for extra WTF.
&gt; self annoys me. An implicit self argument, or better yet a sigil, like ruby's @, for instance variables. I remember from my early days with C++, it regularly confused me to see some variable in a method that I haven't seen declared before, so I had to go hunting for the declaration (class, superclass, global, local). After using Python for a couple of years, I now always put an explicit "this" before object variables in C++, just for clarity. Yes, it might make obvious code less readable, but if code was always obvious, we wouldn't have this discussion in the first place, would we?
thanks a lot, that will be helpful
Yes. And I'm saying that 'is' should go away entirely.
&gt; So my new question is just straight up: IS there anything about Python you don't like? The use of whitespace as block delimiters, and no alternative. Experienced Python programmers adjust to it, but beginners often have programs that just won't run as they expect, because of confusion about whitespace indentation issues. For example, compare this program: import sys for y in range(1,13): for x in range(1,13): sys.stdout.write('%4d' % (x*y)) print '' With this one: for y in range(1,13): for x in range(1,13): sys.stdout.write('%4d' % (x*y)) print '' To an old Python hand, the difference is obvious. To a student, it's simply confusing. In one exchange in this forum, a student posted a program that ought to have given him the result he expected, and no one could figure out the problem. After a lengthy conversation it turned out that there was an embedded tab in the source, that looked one way in his editor and on Reddit, but produced a completely different result when scanned by Python. 
&gt;'lasagne code' Best analogy for programming ever.
&gt; I wish there was a "end" statement to close while/if/with/whatever just to shut up everyone that complains about indentation. there is: #end
No, I am not proposing that. I like being allowed to choose whether or not I use 2 spaces, 4spaces, 8spaces or tabs. Myself, I prefer tabs, but it is pretty well established that programmer spacing is a preference thing, and I don't wnat that to go away. What I am suggesting is that MIXING conventions should cause a compile error instead of attempting to infer the meaning of the code in the presence of conflicting indentations. 
Django, on gevent, socket.io or orbited or similar on the browser. * http://sontek.net/pycon-sprints-part-1-the-realtime-web-with-gevent * http://codysoyland.com/2011/feb/6/evented-django-part-one-socketio-and-gevent/
I agree with the multi-statement lambdas - coffeescript does it pretty well I think. 
The problem is, if I read that without knowing the context, I would never guess that the loop surely executes at least once. The way it reads is like a regular while loop, so I would have to lookup how true is implemented, wasting time.
We already have a very similar looking foss framework with Django.
&gt; self annoys me. An implicit self argument, or better yet a sigil, like ruby's @, for instance variables. How would you call a class method on a different object then? Example: class A(object): def hello(self): print unicode(self) # ... class B(A): def hello(self): A.hello(self) I know about super, this is just an example. You can call any class method with any object as self (which can sometimes be reasonable). 
On a related note, previous [PEP 404: Python Virtual Environments](http://www.reddit.com/r/Python/comments/lu334/pep_404_python_virtual_environments/) is now [PEP 405](http://www.python.org/dev/peps/pep-0405/).
He is proposing a syntax for lambdas that can contain multiple statements instead of just one expression, hence the "lambda".
This is an arbitrary line to draw for when you need comments and descriptive names. Why would lambdas as they are now be okay? They are also used in place without a name and often without a comment and can be arbitrarily complex.
Not when it is used as a callback, for which the purpose is clear. You don't want: def sort_callback(o): # .... # maybe even some other code sorted(l, key=sort_callback) when you could have: sorted(l, key=lambda o: # ...) This already works for single-expression lambdas. Extending it to multi-statement functions could only make it easier to read instead of having to define the callback somewhere else, and using it only once.
Example? And how is it better in 3.x?
For your first example: it is clear why it happens, though. Better stick to the dict comprehension.
It is a big request because the first one reads like an expression. Also, the valid way is only a single character more, don't see why it is more inconvenient to you.
I *love* Perl's unless (and am rather fond of having "until" available as well, though it seems more like a Pascal inspiration), but I feel integrating it would be a bit too-many-ways-to-do-the-same-thing for Python. Also note that even though the language supports it, [the Perl documentation actively discourages using unless/else for being too confusing,](http://perldoc.perl.org/perlsyn.html#Compound-Statements) which might be the reason "elsunless" doesn't actually exist there at all.
This is also on my todo list. I think MusicBrainz may have a tool to solve this problem, but I haven't tried to use it yet.
&gt; "Because it makes code more readable". My rear end. Sometimes expressions can span multiple lines. With a colon you immediately see when it's done, no thinking overhead required. Do you also forget the semicolons in C and Java?
How could Guido reject this? :'( Totally reasonable feature request, I guess almost everyone had to do some cumbersome workaround to break out of the outer loop at some point.
Pretty neat, but I am not sure whether it is worth it. Would still need to type the lambda, and I am not using them *that* often.
I'm willing to give up on this one. It's pretty unimportant, and I'm not even convinced anymore.
That is the kind of crap that would make even me question white space delimiting.
The standard library is horrifically inconsistent. For example, string contains the methods ascii_lowercase and startswith - are we going with underscores or not, guys?. unittest, however, runs with the camel-cased assertEqual. Great. \_\_variables\_\_ are super ugly. sorted(list), vs list.sort - I hate the mix of prefix and postfix for essentially the same thing. In the same vein, the len(list) method just calls list.\_\_length\_\_ - why doesn't it call list.length? Then I could write code how I wanted. Oh right, that's because the zen of python says there should be one and only one way to do things. Like sort and sorted.
Not that kind of pattern matching, in case it wasn't obvious. Here's an example in OCaml: let rec product list = match list with | [] -&gt; 1 | h::t -&gt; h * (product t)
``exit`` is not a statement; it's a function. So it does not make sense for ``exit`` by itself to actually exit. Besides, it could be worse. In the old days ``exit`` was a string, and you couldn't call ``exit()``. You had to ctrl+z or ctrl+d or whatever your OS wanted.
That would imply stuffing everything under the sun into some class or another with all that entails, but that's not what I was trying to advocate. All I'm saying is this: When you have a function that needs to persist state across calls, you're either A) Not really in need of a function, but a method, B) Need to supply that state to said function as an argument or C) Use currying as appropriate. I just cannot think of a single good use-case for emulating C-type function-scope static variables. They were a terrible idea to begin with, and not even people who are still crazy enough to code in C (like me) would ever use them there either. They tend to become a debugging and maintenance nightmare :)
I do too, even though my first real experience with OOP was Java in Eclipse, where you can right click on any variable and simply ask Eclipse to tell you where it was declared. I just can't stand not having this/self prefixing instance variables.
I dunno, I kind of like it. My first experience with functional programming was in MATLAB, where the lambda syntax is like this: foo = @(x) x.^2 So now I like to use the keyword lambda even though when it's not strictly necessary (like in Scheme).
It's because these methods are bound methods, and you must explicitly bind them with a self (ish; it's getting very late at night and I'm tired). Basically this means you could have done: num_range.extended_range(nr1, 9, 87987) and that would be the same as nr1.extended_range(9, 87987) And that is why the first argument self is required. Or something.
Well, I think it's because choosing an editor is not merely about choosing which one is fastest for you. It's also about choosing the one that makes you the happiest. For example, I like Vim because I can navigate with hjkl. I jump around in code a lot, which means that if I had to move my hand to the mouse, trackpad, or arrow keys every time I wanted to move, I'd be wasting time, and more importantly, I'd get frustrated. Even if overall, Vim doesn't save me that much time (or even takes more time) over another text editor, at least I don't have to deal with the frustration of moving my hand back and forth.
 foo(1, lambda y: return y, 3) The above is syntactically ambiguous; it could mean: foo(1, lambda y: return (y, 3)) or foo(1, (lambda y: return y), 3) or foo(1, (lambda y: return y,), 3)
Then why not just do this? while True: stuff if condition: break
yes, and i am not in love with ruby/perl style of having special syntax for everything
How about [this](http://docs.python.org/library/exceptions.html) one?
Musicbrainz has an API which can be used from Python: http://musicbrainz.org/doc/python-musicbrainz2 In my experience this is pretty useful if you already have some proper metadata, and want to correct spelling etc. Depending on your music collection you will find out though that the Musicbrainz DB is far from being complete, especially for international/non-US artists. There's also a feature which is supposed to identify a song from the audio data alone: http://blog.musicbrainz.org/?p=945 
name it true_then_cond, like you never need to look up anything while looking through someones code
I think "objects as hash tables" is a fundamental design flaw. I wish other language designers would stop copying this terrible idea.
django cannot into websockets, and requires you to build you frontend infrastructure from scratch. but yes, it possibly could be done as django application.
Of course I do, but the point is that things that could be first-level language constructs should not be something that is implemented by everyone in a different way, making people look up things that should be trivial. Luckily, I have not seen any instances of custom library functions that specifically exist for control flow.
I also do not like things like sort vs. sorted. They are different, though. Sorted returns a sorted copy of the list. list.sort() sorts the list in place and returns nothing. It's kind of frustrating to me, because I'm used to ECMA's style of chaining type methods together, like string.split().reverse().join(). Python users seem to really hate that.
You can also do this stuff with gevent/eventlet/twisted in python with great success.
While that is a very good start, I'd rather see it listed with each method in the standard library.
This is just generator which yields True before checking condition, 2.2 python, no flow broken, standart language feature.
Please elaborate.
&gt;Luckily, I have not seen any instances of custom library functions that specifically exist for control flow. you will see that if you will get into core language things that can be implemented with reusable 4-liner. Just look at perl, every library brings its own DSL
Developers might prefer it, but magically parallelising serial code is essentially impossible, at least in a dynamic language where almost any code could have side effects. If you want to use multiple cores, you have to code for it somehow.* * I think strictly functional languages might get around this, but I don't think a strictly functional version of Python would have taken off. If you can't upgrade Python, you could use [pyprocessing](http://pyprocessing.berlios.de/), the module which became multiprocessing when it joined the standard library. That will work back to 2.4. But it's moot for a discussion of removing the GIL today, because it wouldn't benefit users stuck on old versions of Python anyway.
 01 | for o in outer: 02 | outer_common_code(o) 03 | for i in inner: 04 | inner_common_code(i) 05 | for N in INCEPTION: 06 | inception_common_code(N) 07 | if breakout(N): 08 | pass 09 | else: 10 | INCEPTION_unbroken_code(N) 11 | continue # GOTO 05 12 | INCEPTION_cleanup_code(N) 13 | break # GOTO 17 14 | else: 15 | inner_unbroken_code(i) 16 | continue # GOTO 03 17 | inner_cleanup_code(i) 18 | break # GOTO 22 19 | else: 20 | outer_unbroken_code(o) 21 | continue # GOTO 01 22 | outer_cleanup_code(o) 23 | break # GOTO 21 24 | global_code()
By all means, use that style. That's the syntax I use most often. I was replying to dalke's claim that there has been no good syntax proposals. The point I was trying to make is that the semantics of a do-while loop could be implemented with syntax already in the language.
:D
Im using django with websockets perfectly well, you need to run it on some kind of async server. i use gevent and redis as message queue at the moment but believe both gunicorn and uwsgi supports it. And for frontend i rather use widespread foss js-libraries like backbone and socketIO then that, im more or less building what you're talking about at the moment, but alas its not code i can share =( 
It absolutely looks as if it is equivalent to `while not (x &gt; 3): x += 1`.
Not to mention that you are not going to find code like } while(0) { printf("this actually gets printed, you poor sod\n"); }
&gt; Just look at perl, every library brings its own DSL You say that as if it were something good.
No, no you wouldn't have to use Emacs. I said 'for example'. It's very much not the only choice of editor/IDE with block execution.
It is not me who said that &gt;&lt;
As [Zed Shaw said](http://zedshaw.com/essays/curing_pythons_neglect.html), `del` is weird. Like, really. Explicit variable declaration could solve a lot of problems, but then it wouldn't be Python any more, I guess. `StopIteration` is wrong. It feels like they did it on a dare, to prove that they can. Using exceptions for flow control is wrong, because it's essentially using a global variable for flow control. It could be assigned anywhere and used anywhere -- it's cool when you use exceptions for error reporting because that's exactly what you want, total decoupling between sources and consumers, but in flow control you usually do have a tight coupling. When you see an unguarded `next(it)`, does it mean that iterator exhaustion at this point was supposed to be an error, or that it was supposed to terminate an outer iteration normally? Oh, and of course using any of the saner alternatives, like returning two values, or using `.next/.current` methods would be just much easier. Print function in 3.x is wrong. It should have been _added_, not _replaced_ the statement, which should be directly translated into calls to the function. This would have solved every problem they wanted to solve, except for _conceptual purity_.
Ruby has .sort and .sort!, the bang-operator signifying that it is destructive, which I really like, but I recognise that ruby is a bit like marmite :) I also like chaining. I think that, in general, python's methods don't return things often enough.
Do you want to do away altogether with mutable data structures? That would change python pretty dramatically.
Suits me, most of them are garbage. Let's cull the bottom 50%. 
Objects in Python are essentially hash tables. This means fields can be added and removed at runtime. It also means that every time an object field is accessed, a hash table lookup must be performed. This means that many optimisations are simply impossible, for example: * Field lookup cannot be a simple indexed pointer access * Types cannot be inferred * Objects cannot be allocated as a single memory block (so they use at least twice as much space and lose locality) What do you lose by having a static class-defined object compared to the seemingly more flexible hash table model? Nothing. Dynamic fields can be implemented by simply having a default method which is called when an object field does not exist in the static class description. You could then use a hash table to store dynamic fields in the small percentage of cases that they're actually used. Smalltalk is an example of a dynamic language which got this right. Python, Ruby and their imitators are guilty of this sin.
Shit bad. It's implemented badly, unpredictably, and doesn't deliver. 
Do we? I would not be aware of an open source framework with the same design principle.
Obviously you can build yourself something that is similar, but out of the box, those things are very different from what planet is doing.
Note that PDEE may be a little too flaky for now. I've just opened an issue regarding its incorrect initialization. For the time being you may be better off with an already good predecessor to PDEE  [emacs-for-python](https://github.com/gabrielelanaro/emacs-for-python). Based on my experience with emacs-for-python, I think PDEE will evolve into a quite useful package.
surprise there was no word realtime 1k years ago.
Yes, this is what I'm trying to do. I'd like to have the same kind of lambdas in Python that I have in other languages.
Wait, how does the case/switch statement make compiler writing easier? And the only extra caveat C# adds (unless I'm missing something) is that cases can't fall through.
I've been bitten before when I was hacking away on a project with a couple other guys and we didn't have a proper spaces/tabs convention set up. There were some nasty bugs where scope was carried over by an extra space on a blank line when the rest of the indentation were tabs. Though I love having dictionaries and sets as primitives and with proper editor set up it has never been an issue since.
You want a list of errors that can arise from using a particular method in *every* piece of documentation? Doesn't your IDE open up the module that causes the error when an error hits? PyScripter does this. If a line errors, it'll open that module, and put the cursor on that line along with printing the error message. Quite helpful and you can see what usually is causing your error due to thinking what types/values that the module is looking for in that scope.
except that it's totally inconsistent there
There are already tools that do this kind of thing e.g. Duplicate Cleaner. Suggest looking at those to get an idea of what they do and their weaknesses. I think there is definitely a need for easier to use tools in this area especially if linked to musicbrainz which I believe will actually identify two files as being the same song even if they are in different formats.
I don't mean the receiver object, I mean, the explicit first arguement to every method, and using that argument to access the instance variables. class A: counter = 0 def inc(self): self.counter += 1 vs class A: counter = 0 def inc(): @counter += 1
yeah, thats the problem with the construct at top of the loop whilst the check should be at the bottom, we cant use an inverted block.
Number 1 is unintuitive, but simple. Any other option would add a lot of complexity, both in the interpreter and how programmers would need to use default arguments. The ideal behavior for lists and dictionaries is easy enough to figure out. If I put def do_stuff(items=[]): ... I probably want an empty list if I don't specify items when I call the function. But what if I put def do_stuff(items=MyObject()): ... I suppose we want it to call MyObject every time the default argument is used? How do we represent that in the interpreter? Then, suppose I put: item = MyObject() def do_stuff(items=item): ... Now what is the expected behavior? I've clearly passed an instance of a mutable object. Should the interpreter call item.copy(), or should it use the instance I passed. What if my class doesn't specify a copy method. Can you use objects that don't have copy methods as default arguments? Or should the interpreter just use the instance I passed? Do we want there to be a difference between my last two examples? I understand that mutable default arguments can be confusing at first, but once you look into it there's only one rule you have to remember: Mutable objects passed as default arguments are the same instance every time the function is called. Any other solution would have a lot more rules to remember giving programmers even more opportunity to get tripped up, all for the sake of making a few (admittedly common) use cases a little more intuitive.
I think the "ugly" that people are talking about is that is is unintuitive to a person reading the code for the first time. Part of Python's philosophy is to do the most understandable and least surprising thing, and writing an if/else stack like that is definitely not standard or obvious.
This is more about the language overall and less about it's implementation: -I hate the 2.x 3.x split. I wanted to code in the newer one but none of the libraries I wanted or needed were compatible. -The fact that it is interpreted. I want to be able to write an application and easily distribute it, the whole py2exe type deal was just too complicated. I can write my program in c++ click build and be done with it. 
I also agree with the no alternative to block delimiters. although now that I am writing in C++ I am still using the same indent scheme. You really do get used to it after a while, with the help of an indent guide that is!
Except that if you add a function print alongside the statement then the following line becomes ambiguous: print ("foo", "bar") If print is both a statement and a function is that the print statement printing a tuple, or the print function printing two strings?
Call it `sys.printf`.
It might be helpful if you told us what kind of Python application you're running? Django? Flask? CherryPy? There are a lot of options as far as Python hosting that are much better ( and probably cheaper ) than the ultra-low quality hosts. In order of up-front cost: * Google App Engine * Micro Amazon EC2 Instance * WebFaction * Gondor.IO &amp; Ep.IO * Linode I won't recommend any explicitly because I don't know what you're doing exactly. 
Many thanks! Basic Python user here but I really like the interface.
I don't dislike the concept of duck typing, but when it comes to function definitions with parameters, I don't like having to consider whether I should do type validation at the start of every function. 
The variable is before the loop condition. You typed up something virtually identical to what I wrote, save for the name of the variable.