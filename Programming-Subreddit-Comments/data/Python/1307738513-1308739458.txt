The Counter class was added in 2.7 and 3.2. 
You can mostly use strings or integers to the same effect. All enums would provide is a way to restrict the possible values. Python tends to follow the approach of "We're all adults here" with few restrictions being enforced directly (which aides extensibility). I would say enums and duck typing are almost incompatible as they represent entirely opposite philosophies. In the few cases you need specific marker objects, you can usually get away with creating special objects for that. If you _need_ enums, you are probably writing Java code in Python.
The only use case I've seen for any kind of "enum" type is data validation (as in Django's ORM/forms). But Django's "choices" are a good solution in that case because they simply add validation code to a field representing a regular type. There are few cases where it makes sense for the _type_ to be an enum (rather than restricting the legal values acceptable in a particular scenario).
Python's sets are not hashable because they're mutable. Try `frozenset` for an immutable version: &gt;&gt;&gt; set([frozenset([1, 2, 3]), frozenset([4, 5, 6])]) set([frozenset([1, 2, 3]), frozenset([4, 5, 6])]) Also, Python 2.7 and above have set literals, so you can write that as: {frozenset([1, 2, 3]), frozenset([4, 5, 6])} You'll find that mutable collections in Python are generally not hashable but tend to have immutable equivalents that are (`dict`s may be an exception).
You mean `import this`, right?
Why _did_ you just finish a bachelors degree in compSci? Software engineering would have been far more appropriate for becoming a programmer.
Yes, but compare the use cases. Think of which situations would require you to work with a dict that may or may not contain an item. Then think of which situations would require you with integer strings that may or may not be valid (yet not empty).
Yes, thanks, I just started learning Python :P
I couldn't even figure out if I should be using ghetto broker or django-kombu. Which makes even the simple case of using a db broker harder than it should be.
don't forget, that you can do from collections import foo, bar, quux as well, which is nicer.
And now I'm blind. Be careful coming back to reddit after that one.
as far as workflow goes, this helped me a lot. [virtualenv](http://showmedo.com/videotutorials/video?name=2910000) also, the book [expoert python programming](http://www.packtpub.com/expert-python-programming/book) and don't bother learning svn unless your job requires it I don't know shit about games, so can't really help you there.
That article is ... They demonstrate a certain obliviousness when it comes to understanding this problem domain. I wouldn't have said anything if they didn't make such bold claims. The persistency implementation is laughable. There are several race conditions, but not so important considering this only supports a single worker.
I mean systematically. They are throwing out the old recipes that are not needed, so you miss out seeing the recipes where the change is the greatest.
What makes you think it is a simple problem? What problem do you think Celery aims to give a solution for? I guess it's your use case that is simple, and that you don't currently need everything Celery offers. But Know that your requirements may change, and that we are solving many different problems. django-ztask sends tasks to a single worker over zmq sockets, and "persists" the task by writing it to the db if the task raises an exception. It may be 200 something lines but they have many problems to solve ahead of them if they want it to be reliable, and yet many more if they want it to be distributed.
Just set BROKER_BACKEND="django" and install django-kombu. Previously it was called ghettoq, but as the name Implies it was experimental. Funny though, I wouldn't call using the database the simple case, maybe from the users convenience standpoint, but certainly not for the implementation :) Do tell me what you find confusing and I'll try to make it easier.
I asked for the English translation of this one so I can take some credit ;) This guy is a genius.
Somewhat in the same boat as you - liking game programming, but not having an itch I want to scratch badly enough to spend time studying the concepts further. Plus I'm lazy, and know I can pick up a lot of things later if I need them for a given project. Some of those things you can pick up in your day job, if you do coding there and have some discretionary time (that you could spend researching on the web, to learn better practices and so on). Sometimes that's more interesting than other work you could be doing, and it also benefits your work. In your free time, unless you're pretty motivated to study in general, you usually do need an itch to scratch. I'd suggest taking some older game (arcade?) that you really enjoyed, and then making a basic clone of that. You'll pick up the basic concepts yourself pretty quickly, and it's a lot of fun too. And a great library for making 2D games is pygame: http://pygame.org/news.html It's very beginner friendly, has a lot of docs and tuts. The tutorials don't go very far (in giving you a good general grounding in game programming concepts), but you can try downloading and examining some of the games from that site, try to figure out what makes them tick, and learn a few new concepts that way, which you can try applying yourself later. If you want to learn more about tile game-based handling in practice, well you could take a brief trip over to Ruby land, and study the scripts that come with the RPG Maker VX platform: http://en.wikipedia.org/wiki/RPG_Maker_VX Those basically implement 99% of a fairly sophisticated RPG engine (although the games themself look really retro and cookie cutter, if you don't customize them further). And there's a ton of mods/custom scripts/etc out there, which you could take a look at to see how they implement things like custom battle systems, AI, or other extensions. Basically you could try playing a bit with making your own RPGs in there, and also delving into the world of scripting a bit, to learn more about how tile management, resource management, etc, can work in a larger engine. There's also some Python RPG engines which you can study, but none as popular and widely-used as RPG Maker VX. And you can take the concepts you learn there, and apply them in your Python games later, too. Probably one of the most interesting concepts (for me) in game logic design (compared to regular scripts) is state machines. Where you have objects that manage their own state (via an .update() call or similar), as opposed to the purely "do one thing, then do the next thing" that you normally see in Python scripts. And then those state machines also need to either interact independently with other state machines, or be managed by a separate "manager" logic/class/etc. Those state machines basically manage most things taking place in the game (sound, sprites, animation, sound, music, etc), and help to avoid a million global variables and complicated logic in your main game logic. About code layout/modules - you should take a closer look at how the Python standard library is organized. Peek inside those modules on your PC. Basically, each module as a clearly defined area, and related functions go together. For really tiny scripts (300 lines, etc, as in your case), it's fine to stick to one file. It's mainly when it gets larger (&gt;1000 lines), and it's hard to find stuff in the script that it's a good idea to split off. One easy way of doing that is just giving each of your main classes (and it's utility functions/etc) it's own module, and then re-importing those back into your main script later. Git is pretty awesome, even for single developer work. If you're working on one project over a long period of time - it lets you make a lot of backups and "save points", without needing to copy older versions into a lot of "old" and "backup" folders to be able to backtrack later if you made some mistakes later on. A good time to make a git commit is when you're done testing and debugging some new complicated logic, and want to start adding new logic that will break things again. It lets you easily see which changes you made since the "last good" code state, and be able to undo those efficiently. And of course, git does have a lot of collaboration features. You can take a quick look at the git tuts to see how that works, and then apply it later if you have a good opportunity. About maths - you probably won't need it much for basic games, but you can google for equations to plug in later for various things if you're not sure. Technically it's better to study maths, but it's a bit hard to study by yourself if you're don't need it for some study-related reason. If you do want to study more, there's a lot of resources on the web. 
Also, if you have a long list of imports from a module, you can use multiple lines if it's parenthesized: from collections import (Counter, OrderedDict, defaultdict, deque, namedtuple, UserDict, UserList, UserString) If you have the module name as a string, you can use importlib.import_module, which was added in [3.1](http://docs.python.org/py3k/library/importlib.html) and [2.7](http://docs.python.org/library/importlib.html): from importlib import import_module ElementTree = import_module("xml.etree.ElementTree") Or a relative import: import_module("xml.etree") ElementTree = import_module(".ElementTree", "xml.etree") 
Try forgetting for a minute what you want to do, and "execute" the program on a piece of paper, assuming input is "one two" and the file contains the lines: zero one one two Also, check set()
you iterate characters instead of lines, that's certainly not what you wanted
You don't want the read() method. That's outputting the whole file as a string. Just iterate through the file, which goes by line in text mode: def match(text, fn): terms = text.split() for line in open(fn): words = line.split() if all(t in words for t in terms): print line.rstrip() Split the line into words because you don't want "jump" to match "jumping" (i.e. the 'in' operator for strings performs a substring match). `t in words` will only be True if the term t is equal (==) to at least one of the words in the line. The generator expression does this comparison iteratively for all of the terms, yielding a truth value for each test. The 'all' function returns False at the first yielded False. In contrast, using 'any' would return True at the first yielded True. In your description you said "all of the input words", but the code you posted would seem to be for any (actually if it did what you expected it would print out the line for each matched term). Replace 'all' with 'any' in the above depending on what you want.
Nice this is something people can definitely use if it is done right, especially newbs like me. Though it's weird that this is produced in 2011 but the table of contents is missing methods like BeautifulSoup or httplib.
We were using it to streamline application distribution across a number of Unix servers in a bank from a Windows desktop running Cygwin. It worked very nicely and significantly improved the quality of the deployments.
That's not going to immediately help though when one is unclear what a method such as read() returns, how iteration works for files vs strings, how the 'in' operator works on strings vs other sequences, or what the simplest tools are for the job (such as using all/any instead of manually coding the nested loop). In that case, open the docs, launch the interactive console, and start experimenting and practicing. I'm not down-voting the principle of thinking things through offline. But programming is equal parts mathematics, science, and engineering. Experimenting and testing are vital. Know your tools. 
Do you know of any alternatives to pygame? It seems like nothing using it ever goes very far. Also, state machines sound amazingly interesting. Are there any good examples that you know of that could give me an idea of how to implement a simple one?
I have used my C++ in python, and call that python from C++, so i think i got like half the way : )
&gt; the table of contents is missing methods like BeautifulSoup or httplib This book is about the Python standard library.
an infinite loop ! See here http://tarekziade.wordpress.com/2011/06/10/continuous-load-testing-wint-funkload/
Ahhhh. Well where is httplib, it is in the standard library.
if we always fixed your code, shouldn't *we* be getting credit for your homework? You will find your error by: Assuming nothing. Printing out the variables you are using. Learn to use the debugger. 
an interesting opportunity to use sets:: words = set(getText().split(' ')) for line in open(URD, 'r'): line_words = set(line.split(' ')) if words.issubset(line_words): print line I wonder if this is faster than looping over each input words to test if it exists in the current line.
Thank alls. Upboats for all.
I don't entirely like leaving files open for the entirety of a loop, but that's just me. I would modify your code to the following. def match(text, fn): terms = text.split() with open(fn) as f: lines = f.readlines() for line in lines: words = line.split() if all(t in words for t in terms) print line.rstrip() Your method is better if the file is bigger than available memory, but I tend to be slightly paranoid about leaving files open.
My intuition was that it would take a bit longer to create a set for each line, but that it wouldn't be significant. If we're iterating by lines, then it's typically not a long list and not much savings are to be gained by making the set and checking for the subset vs., for example, searching for 5 words in a 10-word line. If the lines of text were very long, however, using set would be faster than searching through the list several times. Here's the test I set up: def match_all(text, fn): terms = text.split() for line in open(fn): words = line.split() if all(t in words for t in terms): yield line.rstrip() def match_set(text, fn): terms = set(text.split()) for line in open(fn): words = set(line.split()) if terms.issubset(words): yield line.rstrip() from collections import Counter from timeit import timeit counter = Counter(open('huck_finn.txt').read().split()) text = ' '.join(c[0] for c in counter.most_common(5)) test_all = "list(match_all(text, 'huck_finn.txt'))" test_set = "list(match_set(text, 'huck_finn.txt'))" setup = "from __main__ import text, match_all, match_set" t_all = timeit(test_all, setup, number=10) t_set = timeit(test_set, setup, number=10) print(t_set / t_all) In the above test based on the 5 most common words in "The Adventures of Huckleberry Finn", using 'all' was typically about 1-2% faster on my system, and occasionally using set was 1% faster. It's mostly a wash. Here's the copy of [Huck Finn](http://www.gutenberg.org/ebooks/76.txt.utf8) that I used. 
&gt; That's not going to immediately help though when one is unclear what a method such as read() returns, how iteration works for files vs strings, how the 'in' operator works on strings vs other sequences, or what the simplest tools are for the job (such as using all/any instead of manually coding the nested loop). None of these are the OP's main problem. Rather it is basic control flow - which he/she will much better understand by working it out rather than some dude explaining it.
On my machine, your test gives the set-version as ~20% faster.
~~You could have an outer loop that opens the file, seeks to the current position, reads a fixed number of lines, and updates the position with tell():~~ ~~not a good idea~~ ~~I welcome a better implementation of this idea -- or a better idea.~~ 
Thanks. I'm using win32 Python 3.2.
Usually things like dictionaries or classes achieve much the same thing in Python Where the concept is useful, it's easy to do manually. For example in [this OpenEXR image file parser](https://github.com/dbr/pyopenexr/blob/master/openexr.py#L9) I wrote a while ago. I think those definitions came from [these bindings](http://excamera.com/sphinx/articles-openexr.html) - now I would probably use a dict, maybe wrapped in a class to simplify looking up by name, something like: compressions = { 1: "NO", 2: "RLE", ... }
The condition to check for is when the set of words of input (A) is a subset of the set of words of each line (B). If this is true, A - B is empty. Therefore: for line in open(file): if not (set(input.split()) - set(line.split())): print line 
I'm amused when people post questions obviously from homework assignments without even trying to dress it up a bit.
Well, if it actually was iterating by lines as crunchygranola clearly wanted, and if 'in' wasn't matching substrings, then it would be close. I think the logic problems would be more obvious and easily fixed, such as this small modification: for item in input: if item not in line.split(): break else: #all items were in line; break skips this print line This works, but I think using all or a set, as you suggested, would be simpler.
Just out of curiosity, why are you paranoid about having a file open for the duration of a loop? In the common case, this shouldn't be a problem at all. If you're opening 100s or 1000s of files at once, then you'll need to start worrying about this. 
Have a look at [this article](http://blog.delroth.net/2011/06/reading-wii-discs-with-python) that demonstrates using namedtuples for the fixed data structures in a Wii DVD. 
I'm not sure what the advantage is here, but admittedly I'm having a hard time getting past `while 1`. If the input file was huge or I was otherwise worried about memory consumption, I'd do something like this (untested): def get_matches(file_name, batch_size=1000): matches = [] with open(file_name) as fp: for line in fp: if is_match(line): matches.append(line) if len(matches) == batch_size: yield matches matches = [] if matches: yield matches def is_match(line): "Return `True` or `False` depending on whether ``line`` matches criteria."
I would consider comparing variables that have been assigned object() to be bad practice. It is not obvious what the order is, and I think it is not Python standard that the ids of objects are ordered. In a different implementation than CPython, it would be anything.
I think your code is a good example that shows how much bloat there is in Python for something as simple as an enum. A class, all ints assigned manually (btw., what do you need those ints for? you pass the name/string to __init__, not a numeric value, right?), etc. Ruby's named symbols would be much nicer here. 
More interestingly, on my linux box: the ratio-result is the same on py3.2 as with py2.7 although both run marginally faster on py2.7. Using pypy (JIT'ed), the match_set becomes twice as fast as match_all, with match_all running slower on pypy than CPython, but match_set running a good deal faster on pypy.
considering that everything in python is an object, and all python objects are at the very least dictionaries... this seems like pointless nitpicking sort of like complaining about the bloat added by a pimple to your head
You could try [pyglet](http://www.pyglet.org/index.html). Haven't fiddled with it myself though so I don't really know anything about it other than what the website can tell you.
The book is close to 1300 pages, so there's not enough room for every package in the standard library. It appears he covered urllib and urllib2. I'm not familiar enough with httplib to comment on whether or not it's exclusion is that meaningful, but I can get by with urllib/urllib2.
I don't get your point, could you explain again please? With bloat, I mean code bloat, not memory bloat or something like that.
Connect Four is a [beaten game](http://www.connectfour.net/Files/connect4.pdf). The fist player should always win when playing correctly.
Thanks, that works better. While I'm certain that the '`while 1`' isn't a problem since `readline` will return an empty string at the end of the file, I asked for a better idea because it's clear to me that what I wrote is not idiomatic Python and the style has potential for bugs. Your version could still end up keeping the file open for a long time, but on 2nd thought I don't know what MereInterest has against this since it's only open for reading. (Even when opened in append mode it's only a quasi lock, at least in Windows.) I also don't think it comes down to memory consumption since the function iterates by line and yields matches. Memory management is up to the consumer, which could use a 'matches' list as a buffer for writing the results back to disk.
Thanks again. Clearly on Linux using set is the winner. I'll have to download pypy to see how it fairs on win32. Here's a set of 10 results on my system: def test(): t_all = timeit(test_all, setup, number=10) t_set = timeit(test_set, setup, number=10) return t_set / t_all results = [format(test(), '.2f') for i in range(10)] print(', '.join(results)) Results for Python 3.2: 1.02, 1.01, 1.02, 1.01, 1.00, 1.01, 1.01, 1.04, 1.03, 1.01 Results for Python 2.7: 0.91, 0.94, 0.94, 0.95, 0.94, 0.93, 0.94, 0.93, 0.92, 1.11 
run `python` at the command line (Use Terminal, in /Applications/Utilities/Terminal).
right, but I liked how the python shell that comes with IDLE has color formatting, displays function options, etc... that's what I'm looking for
I'm not sure how it's installed in Mac OS X SL, but to launch idle you're going to want to find the idlelib directory in your Python Path and run python idle.py (or idle.pyw to omit a terminal window if you're launching from a shortcut). Keep in mind the baked-in Python that comes with SL may not include IDLE. For example, it's installed separately in Debian Linux. Try doing "find / -name 'idle.pyw' -print" in the terminal and see what shows up.
ah ok, i was thinking you meant the latter. i don't really see the code bloat side of your argument.
You're awesome, thanks for helping! It was there, buried deep in the python 2.6 framework directories. 
&gt; It is not obvious what the order is I was making the claim that most of the time, when people use an enum, they don't actually care about the order. If they do, then sure, that's a requirement that comparing objects won't help with. 
I agree, comparing the elements of an enum is the same kind of bad, most of the times. Edit: however, still better, since in languages supporting it you know what the order is for sure.
Now that I think of it, there isn't much of a reason. I suppose that part of it is wanting to make sure that I can always later increase the amount of processing done in the loop without keeping the file open for unreasonable amounts of time.
I've been programming for quite some time (boring enterprise stuff mind you) and haven't done games but just thought I'll speak my mind here instead of resisting the temptation of a rant and in the process robbing someone the chance of learning from someone else's experience. Regarding everything, the worst thing you could probably do right now is try to be perfect and learn everything in a single go. That's the death of creativity right there. Learn things on a need basis. Started with Tic Tac Toe and want to add intelligent computer behaviour? Start looking around for other similar implementations and therein you learn how to code AI and gain greater understanding. Have created a Zuma clone but want to add a bit of spice and glitter to your game? That's when you start looking for resources to learn about particle effects in games. You'd find this kind of learning more rewarding and less boring since there is a strong motivation for you to learn it and not just learning because you *might* end up using something in the future. Asking specific questions at the right places is the key to getting answers and not hearing the sound of crickets. ;-) Regarding source code; don't fall for "pippin' hot" stuff. Git v/s SVN? I might sound a bit harsh here but these two SCM's have different models and can't be compared! Who said you can't learn multiple of these? Why not just try learning the basics of these and stick to the one which you find most comfortable? Anyways, for Mercurial you can try out [hginit](http://hginit.com/) and for Git try out [git ref](http://gitref.org/). Good source code management habits come from actually colloborating with a real team but you can always refer some good open source projects on Github or Bitbucket to have a look at their project structure and how changes are introduced to the code base. Regarding Math; unless you are actually aiming for a game programming degree, not many books or tutorials will outline "game related" Math for you. You are right in saying that there is a difference in what you learn and what you apply for games. For game specific math stuff, you can always hang around at game related forums (e.g. gamasutra and others) or reverse engineer existing games to find out how stuff works (quake etc. come to mind). Look into numpy for Python related numeric processing. For generic math related stuff, look into Khanacademy for videos. Good luck! 
I believe it is possible to have a function written in C++ and another written in python be mutually recursive. Just create bindings for a C++ function which imports/calls a python function, and have the python function call the bound C++ function. In the simplest case, you'd have a program that crashes due to a stack overflow. As for embedding in a python app a C++ app, which embeds a python app, which embeds a C++ app, *ad infinitum*... It really comes down to what you mean by "C++ app", since this scenario makes little sense if you're actually talking about standalone C++ applications. One possible setup is to have an executable, a shared library implementing core functionality and another shared library which exports python bindings for this functionality. Since the implementation library is free to call python code via the CPython API, and the python code is free to import the corresponding python bindings as a module, it is perfectly possible to create circular dependencies between the two languages. The executable itself, however, is not embedded in anything in this example.
Regarding GIT; the reason I want to learn it is that I will be posting my stuff and actively seeking collaboration. I want to learn it because I want to code with others. Coding with others in a collaborative environment will allow me lots of things: Bouncing ideas off of one another, I can learn from that person the best practices for certain things, and it should teach me a little bit more organization than I currently possess. This is actually an itch for me. I wouldn't be learning it because I "need" to, but rather because I *want* to. And as for the game programming degree...does such an accredited degree even exist? I know there are a bunch out there that are from non-accredited colleges, and I've never seen one otherwise. I do have full-sail here in Orlando that I should probably check out...but no job, so I'm kinda screwed there.
Available if you're willing to pay a subscription fee. Misleading title...
The title doesn't suggest that it's free or make any mention of cost, so I'm not sure how it can be misleading. It's just a title, and it's already long enough...
You're right; the misunderstanding was entirely due to my own inference. When I see a post on reddit about a book, and see no mention of price, I'm used to it being freely available. It's a matter of expectation, but you're right, it doesn't mention that anywhere in the title. I disagree with your second point, though; this is a comparatively short title and there's plenty of room to explicitly state that the book is available **for sale** as opposed to for free. I feel that a link to a book for sale on the Python subreddit adds little value. Reviews of books are great, because they help me to choose whether the book is worth purchasing; links like this to me seem to mostly be advertising. Don't get me wrong, it's very relevant and targeted advertising, but it's less valuable than posts like [this](http://www.reddit.com/r/Python/comments/hxlh8/some_notes_on_slots_and_class_hierarchies/) or [this](http://www.reddit.com/r/Python/comments/hx654/book_review_python_testing_cookbook/).
Um ... lambda functions? Is this really hot python news?
Why write `lambda word: len(word)` when you could just use `len`?
If you change your mind later or want it to be a different function for other languages you can change that lambda, while it wouldn't be a good idea to assign to "len" (aliasing/shadowing).
Next post: 'For loops in python'
I think I fucked up the submission.
Tommah is talking about the following line: lengths = map(lambda word: len(word), words) If you typically use lambda functions with `map`, then you might unthinkingly use lambda when it's not necessary.
This is clearly the best implementation: def length(word): return lambda word: len(word)
He's talking about eta-contracting the lambda expression.
Then it wouldn't be a tutorial on lambda functions. 
One legitimate use that's similar to this is to have a property bind to a lambda instead of the getter. Then if you subclass you can redefine the getter without having to rebind the property: class A: def getf(self): pass f = property(lambda x: x.getf()) class B(A): def getf(self): return 'spam' &gt;&gt;&gt; B().f 'spam' For what it's worth...
Because &gt; Python doesnâ€™t provide a built-in enum type That's it. A nice enum data type is often more useful and readable than various hacks Python programmers use in its place. But it's not useful enough to go through the hassle of installing external libraries. If an enum class becomes part of the standard library, it will be used.
Is there something wrong with this test? Marking me down without explanation is so very, very helpful....
To be honest, I just don't see the reason to use map and filter anymore, because list comprehensions and generator comprehensions give you exactly the same behaviour, however, they are easier to read for me, especially if you need to map and filter. 
I think you meant for your implementation to be correct, but redundant. It is incorrect as well as redundant, though. Perhaps you mean: def length(word): return (lambda word: len(word))(word) 
The GL calls themselves are not slower, there is significantly more overhead on the Python side -- the act itself of a function call in Python costs quite a bit more than it does in C++ due to implementation details of the CPython interpreter. That's what the hype is behind the PyPy project's JIT: a way to optimize away some of this.
you see this problem creep up periodically when you have created a python module yourself that shadows a stdlib module. have you defined a urllib.py anywhere? urllib.__file__ will show you the actual file name that corresponds to your imported urllib (if you get a .pyc then it's the .py with the same name that you want to check). I have seen the ubunutu-packaged stdlib have differences from the official one, but removing a documented (and widely used) function would be pretty egregious.
Yeah I checked and there are urllib(2).pycs as well as urllib.py files in the lib folder. Should I try to remove the *.pyc files?
I tend to agree in general, but how about if the function is already defined and being mapped to several lists? map(f, a, b, c) (f(*x) for x in zip(a, b, c)) #or (f(x, y, z) for x, y, z in zip(a, b, c)) 
pylint raises a warning about filter(), in fact, for precisely this reason.
I subscribe to Fredrik Lundh's guidelines for using lambda in Python: 1. Write a lambda function. 2. Write a comment explaining what the heck that lambda does. 3. Study the comment for a while, and think of a name that captures the essence of the comment. 4. Convert the lambda to a def statement, using that name. 5. Remove the comment. *(via [the docs](http://docs.python.org/howto/functional.html))*
Thanks for the tip. So it's likely all the overhead from function calls that are invoked during those 1000 batch additions make up most of the slow down, as opposed to the fxn overhead from the one draw call at the end?
Haskell has a really cool tool called "hlint" that suggests eta reductions such as those automatically. Also suggests replacing various patterns with standard library functions, etc. I wonder if something similar for Python exists.
I would think so, yeah. There'd be a minor overhead from the 1 draw call, but the majority of he slowdown probably comes from the additions.
If you ams interest in a language whats am pretty like Python but whats would have real low overhead for supports OpenGL like through Clutter, coulds look into Genie.
agreed. `reduce` is still useful though and can lead to some very elegant solutions to problems.
Just for reference that code works perfectly on Ubuntu 11.04. ie it is something about your system that is the problem.
1. Sanity test: urllib.urlopen('http://python.org/') 2. Try copying it somewhere else and using os.chdir("/home/your_user_name/documents/testpython") and importing again. This gets rid of errors from multiple copies. 3. If still failing, use ctrl+f to find urlopen in the urllib file. 4. If not using the IDLE, do. If using the IDLE, use something else(Pydev plugin for Eclipse is my editor of choice.) This works more often than it should.
Okay, so now do partial binding of predicates :D
It is for people still learning it. Honestly, I don't always learn very much from reading many /r/python posts, but I realise that some people do, and that's enough reason to have them there.
enum use cases: - You want something that's actually an "enumeration". Use range(). - You want something that's type safe or limited in value/magnitude. You're probably looking at defining a class at that point. Say you wanted to define some weapons typedef enum { wp_fist, wp_chainsaw, wp_pistol, wp_shotgun, wp_supershotgun, wp_rocketlauncher, wp_plasmarifle, wp_bfg, wp_max } weapontype_t; You'll probably also have associated methods that work with these values, like how much ammo each weapon has, the reload time, firing behavior, ammo expenditure, blah blah blah. This sounds like a job for... object oriented programming (most people would say, anyway). - You want constants. Just define them. - You want to define an array in terms of the number of members in the enum. Python doesn't specify sizes during array declaration. === It's maybe also worth saying that one of the things enum does (in C) is put the constants in global scope. This is considered bad practice in Python. Generally when I find I need constants, I place them inside classes so they're namespaced, although you can go the module route too. Overall, the simple answer to your question is that enums aren't really Pythonic.
It seems like the trend is to integrate your acceptance test (selenium) code with your application code. Is there any advantage to doing this? It seems like it might be better to have your acceptance tests completely separated from your application code.
or use Cython.
Or use any lower levels language, benefit to Genie ams for if someone wants to write code that ams looks like Python, whats ams pretty and simple and alls that. 
They are automatically recompiled. It's safe to delete them.
Be aware, though, that there are serious problems with the IDLE 2.6.1 that is distributed with Mac OS X 10.6. Actually, the problems are with the version of Tcl/Tk 8.5 that comes with 10.6. Symptoms include IDLE hangs and crashes. There is more information here (http://www.python.org/download/mac/tcltk/). There is no particularly good simple solution other than to use a Python that links to a different version of Tcl/Tk 8.5, like the one provided by ActiveState. Another possibility is to install Numpy and Python and all of their dependencies with a third-party package manager like MacPorts. Or use one of the NumPy installers (http://sourceforge.net/projects/numpy/files/NumPy/1.6.0/) that is designed to work with the python.org installers.
I wrote a library that makes it *much* easier to do all of these things: Requests. http://python-requests.org
It's not in Python, but I should mention [Mumble](http://mumble.sourceforge.net/). Call me stupid, but to me the words Real-Time, High-Performance &amp; Python don't really go together. At least, for a real-time streaming voice chat program that's intended to run in the background of a PC game while dealing with 12+ voice streams, I'd want it to be written in C/C++.
 filter(None, map(f, lst)) becomes [f(x) for x in lst if f(x)] which requires calculating `f(x)` twice for each element. You could avoid that by doing [x for x in [f(y) for y in lst] if x] but that isn't as easy to read as the version with `map` and `filter`.
Is it possible to use only PyOpenGL/cython to draw my primative graphics, and then use pyglet to control keyboard/mouse events? Or is there a more standard way of mixing python events/logic with lower level graphics management?
That looks similar to Ruby's way of handling strings. my_string[5] yields an integer not a character.
 l = (f(x) for x in lst) l2 = [x for x in l if x] The drawback is two lines and an extra variable. But that helps readability. 
I think f = property(lambda self : self.getf()) is clearer than calling the `self` parameter `x` because it is obvious at a glance that our lambda represents an instance method. 
What exactly is then the purpose of subreddit [reddit/learnpython](http://www.reddit.com/r/learnpython)?
&gt; But that helps readability. Nope. It takes twice as long to read and understand, which in my book means that it has worse readability. Unless, of course, we are talking about someone who is making their first steps in programming and whose mental capacity for code is in fact limited to one function call, so that they like to take their intermediate results and give them meaningful names. Not that there's anything wrong with that, just you maybe shouldn't write your code for that kind of lowest common denominator, if it makes readability that much worse. (also, Steve Yegge has a [post](http://steve-yegge.blogspot.com/2008/02/portrait-of-n00b.html) about this).
Since posting this, I've come across those serious problems first hand. =) If I understand this whole MacPorts thing correctly, once I install MacPorts, I can use it to install [py27-scipy](http://www.macports.org/ports.php?by=name&amp;substr=scipy) and it will automatically install all of those dependencies, including python 2.7? Thanks for your help! Edit: I'll probably go with 2.6, because the other package I need, rpy2, seems to only support 2.6. 
try this one: `(lambda f:f(f))(lambda f:f(f))`
I agree with burito on Mumble, but disagree on Read-Time etc. But binding to Speex sounds pointless, when CELT is the new kid on the block.
 sys.setrecursionlimit(1) One liner that breaks *working* code.
"Note: This module is available for backward compatibility only. If you are writing code that does not need to work with versions of Python earlier than Python 2.2, please consider subclassing directly from the built-in list type." check your facts, dude :)
You don't actually need an argument: overflowStack = lambda: overflowStack() overflowStack() 
I agree with the recommendation at 3:23 to read [Another Do-It-Yourself Framework](http://pythonpaste.org/webob/do-it-yourself.html)
You have around 10+ lines to define an Enum, when it could be zero, if something like Ruby's named symbols existed in Python. Having many lines to express something trivial is code bloat and undesirable in my book.
Reading speed is a reasonable metric for readability. But, illustrating the point with a post by Steve Yegge is a bit ironic. I like his writing, but it's not written with speed in mind. Just kidding.
For writing a series of heterogeneous structures to a file, I like how Dave used the combination of bytearray.extend and struct.pack. But if I were just writing a sequence of points, I'd use an array: import array with open('points.bin', 'wb') as f: a = array.array('i', [len(points)]) a.extend(p for vec in points for p in vec) a.tofile(f) 
That's why they're bindings isn't it? All the actual work is done within PortAudio and Speex libraries...which are written in C. Python is merely the glue for it.
CELT is much higher bandwidth and is also a moving API target. The API can break older builds at any point in time. http://www.celt-codec.org/comparison/ For voice-only applications, Speex is still the place to go. CELT is meant for closer-to-realtime high-quality applications on something closer to a local network. (for example, streaming audio across your house)
&gt; At least, for a real-time streaming voice chat program that's intended to run in the background of a PC game while dealing with 12+ voice streams, I'd want it to be written in C/C++. Well, maybe not on CPython, but I think if PyPy isn't there yet, we'll get there soon. A few of our developers are working on a conference paper, and one of the examples used in it is real time video analysis, ATM we're doing 38FPS at 640x480. Not C levels yet, but we'll get there :)
Yes, pyglet is easily interleaved with standard OpenGL calls. Just be aware of the calls that pyglet makes itself (check the source for more details, and/or use the debug_gl_trace option).
Not sure why someone downvoted you: although you may not have answered the "how to use urllib" issue, it seems quite clear the original poster doesn't have any particular tie to that library and just wants to collect data from websites, and your library is far superior for that. +1 from me.
Mumble uses CELT already (in addition to Speex) and as far as I have used it with friends, it worked quite fine.
The 'd' dict is constructed but not used anywhere. This looks wrong: for i, body in l.items(): title = l[i] title and body will have the same value, always. Why are you constructing dicts anyway? Just loop through the tuples directly.
the same rule applies to subexpressions, for all the same reasons. Actually, since def statements are essentially variable assignments, the generalized rule would be: * Write a subexpression. e.g. "x = f(x+1)" * Write a comment explaining what the heck that subexpression does. "# increase x" * Study the comment for a while, and think of a name that captures the essence of the comment. "incX" * Convert the subexpression to a variable assignment statement, using that name. "incX = x+1; x = f(incX)" * Remove the comment. In any subexpression, it's always a matter of readability and audience. Guido can't read lambdas, so you always lift them if writing code he might read. Same for complex subexpressions and a novice. But the cost of pulling out the lambda expressions is an increase in the number of identifiers and lost locality. It's not free, and should not be treated as such. 
From what I gather, [Beginning Game Development with Python and Pygame by Will McGugan](http://www.amazon.com/Beginning-Game-Development-Python-Pygame/dp/1590598725/) may be closer to what you're looking for than InventWithPython is. But it's still just the basics. I believe you can borrow a copy from [Library Genesis](http://gen.lib.rus.ec/). C++ books and resources still dominate the game development field, so once you get to the 'advanced' stage where you need them, you're going to need to either use it, or translate the books to Python. There's a definite gap waiting to be filled by anyone willing to write an advanced book on the topic. Until you reach the advanced stage, I think Pygame may be the best you're going to get. At least to my knowledge. Regarding version control, install either of the TortoiseGit or TortoiseHg frontends, learn the basics of adding files, committing/reverting etc, then leave the more advanced things for later, until you need it. The bare basics of Linear Algebra can be found here [Vector Math for 3D Computer Graphics](http://chortle.ccsu.edu/vectorlessons/vectorIndex.html). These are just the tip of the iceberg though, and you should learn more if you've enjoyed the material on that site. There are some really good books on 'Math for Game Development' out there. Look for these at the library (mentioned above). * Beginning Math And Physics For Game Programmers - Wendy Stahler (2004) * Mathematics for 3D Game Programming and Computer Graphics - Eric Lengyel (2003) * 3D Math Primer for Graphics and Game Development - Fletcher Dunn, Ian Parberry (2002) * Mathematics for Game Developers - Christopher Tremblay (2004) I think they use some C++, which you may have to learn eventually anyway. If you find that you enjoy Linear Algebra and would like to know more of it -- it's very useful, MIT offers both lecture videos on both [programming in python](http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-00-introduction-to-computer-science-and-programming-fall-2008/video-lectures/) and [linear algebra](http://ocw.mit.edu/courses/mathematics/18-06-linear-algebra-spring-2010/video-lectures/). Don't expect to be able to learn how to apply the material by just watching the lectures without doing the accompanying exercises though. I really wish there was more material on the subject for python, as I'm also fascinated by it. Until such material exists I've resorted to downloading source for my favorite C++ game and stepping through bits of code, learning things the hard way. Good luck! If you ever do encounter useful resources, or write your own, please post links to it here, as I'm sure there's lots more like us.
Burn
Thank you; I've already checked out the book you mentioned -- Amazon reviews leave the book sounding kinda iffy. I'm going through it at the moment though so hopefully it'll get me where I'd like to be. As far as GIT; yeah -- screw the advanced stuff, all I want to really understand is enough to commit, swap branches, merging code from other maintainers, and reverting changes. Thanks for the links on math - I &lt;3 me some math.
Thanks for noticing that, I accidentally all my notes. I really feel like I owe you one. I karmafied you a bit in hoping that's proper compensation. Concerning the dicts, it was just a trick to match row id's from one table to the other.
A ***huge*** thank you. I've been looking for some good example code for something like this. It's also nice and small so I should be able to easily figure out what's going on. :)
Thanks a lot, I'm just about to learn a little Python and your blog and book is awesome :)
Not that there's anything wrong with collections.defaultdict, but you can also use `dict.setdefault`. It's like `dict.get`, except it will also set the default value if the key isn't found. def group_by(seq, attribute): d = {} for item in seq: attr = getattr(item, attribute) d.setdefault(attr, []).append(item) return sorted(d.items()) class Person(object): def __init__(self, age): self.age = age persons = [Person(age) for age in (25, 75, 15, 75, 15, 25)] persons_by_age = group_by(persons, 'age') age_list = [(age, len(group)) for age, group in persons_by_age] print(age_list) [(15, 2), (25, 2), (75, 2)]
pylint. But I don't think it looks very closely at lambdas the same way hlint does.
"the lib folder" is this a part of your own package or do you mean the standard library on your system? the short of it is that you don't want to be naming any python modules the same as standard library module names. If you do have a urllib.py in your own python package, rename it (and change imports that were using it), and delete the .pyc.
The rest of the blog has other examples of commented code, though it could probably use some tidying up. http://inventwithpython.com/blog/category/games/
Ran in Linux, I get the following error: $ python starpusher.py Traceback (most recent call last): File "starpusher.py", line 692, in &lt;module&gt; main() File "starpusher.py", line 149, in main levels = readLevelsFile('starPusherLevels.txt') File "starpusher.py", line 447, in readLevelsFile assert startx != None and starty != None, 'Level %s (around line %s) in %s is missing a "@" or "+" to mark the start point.' % (levelNum+1, lineNum, relativePathToThisScript(filename)) AssertionError: Level 1 (around line 24) in /home/sam/work/external/starpusher/starpusher/starPusherLevels.txt is missing a "@" or "+" to mark the start point. Which appears to be this line in the level file (when I throw in debugging print line statements in the loop): ; Starting demo level: So it looks like it's not even getting through to your actual level data. Looking at your code, it seems the problem is line 398: line = content[lineNum].rstrip('\n') You're only stripping \n, but (probably because you made this in Windows) leaving the \r (Windows does new lines plus carriage returns for line endings). The [.rstrip(..) ](http://docs.python.org/library/stdtypes.html#str.rstrip) string method should just "do the right thing" for the native platform it's on if you don't specify anything. So changing the above line to line = content[lineNum].rstrip() Fixes the problem and it runs. With that fix, it should be more portable (I don't know what Mac uses for end of line, but I'd wager it's simple /n as well). 
Hmm... I wasn't able to get the game to run. Well, it ran, but it crashed when I tried to load up the first level. I get this error: AssertionError: Level 1 (around line 24) in /home/user/Desktop/starpusher/starPusherLevels.txt is missing a "@" or "+" to mark the start point. I opened the level data file and verified that there is an "@" symbol in the level. 
never did it. i suggested cython because when it comes to mixing c libraries with python, it provides an easy way to do it.
Ah, that makes more sense. I just love how sqlite replaces opaque binary formats everywhere.
Who said any thing about becoming a programmer ? I like programming as much as the next geek, but i guess I felt compSci would offer more "emergency exits" from the cubicle, if desire arises.
OS X uses \n. Pre-Unix MacOS used \r.
I had no idea `operator.methodcaller` existed. Looks pretty awesome.
Likely the end-of-line-ism I reported [here](http://www.reddit.com/r/Python/comments/hymjn/source_code_for_a_sokoban_box_pushing_game_in/c1zh0nf). TL;DR- Change line 398 to read: line = content[lineNum].rstrip() and it should make that error go away.
Yep. That worked. Thanks for the tip.
defaultdict is much more elegant because it doesn't evaluate the default value except when needed. Consider: d.setdefault('foo', ReallyExpensiveDataStructure()) On the other hand, it feels wrong that a lookup on a defaultdict changes the dictionary by adding a key if it's missing -- in this case get() versus setdefault() is more explicit.
I don't think JIT can actually help with function call overhead to C/C++ libraries, it's good at optimizing Python code itself. I suppose Cython is more suitable for that -- you can write the parts that call opengl functions a lot in Cython so that it's mostly C code.
Note that they are not strings, though, and you can't use them as such, because they're not encoding-aware (as far as I've gathered). If you split or iterate over a byte-array, it will actually give you bytes, not characters.
Ack! You're right. Though it should probably be .rstrip('\r\n') since it needs to remove just the newline, not all whitespace (a line full of spaces is a valid level). Basically, I needed something like Perl's chomp(). I'll update the code.
Thanks for the advice. I tried all of that I am still getting the same error message. I have been using Geany to execute the code, but I also tried compiling at the terminal and I keep getting the same message.
Yeah, I'll admit I've missed chomp() (though I've not written anything in Perl for over 7 years now :-)
Thanks. Your module looks very useful, however, I tried to run a bit of sample code and it looks like urllib is a dependency, so I cannot get it to function unless I fix urllib.
Yeah when I upgraded I was given an error message and I have had to reinstall all of my applications. Is there a good way to reinstall python? I'm afraid that if I remove it, 90% of my programs will stop running.
I mean the standard library. I have multiple instances of python installed, apparently, as the result of an upgrade from Ubuntu Lucid to Natty.
Well it's not "One Hundred and One *Tenths* Dalmatians"?
http://docs.python.org/py3k/library/collections.html#module-collections Please show where your quote is in the documentation for this module, because I can't seem to find it. 
Misguided with the rest of the discussion. I was complaining that magic should not go into a beginner book.
you seem to have gotten him going pretty good http://twitter.com/zedshaw
That's the downside of having such discussions on twitter instead of IRC: it's hard to read the whole discussion. I honestly feel bad for the direction it went, especially because I sortof forced him to rewrite the chapter against his wishes.
Is there something wrong with the first lambda or is that just an example of normal usage? Great and humorous "tutorial" though!
What are those *asser*s for? From documentation it seems that they are executed only in some sort of debug mode. So they are not actually run in the game?
The first one is "normal" usage of lambdas. A quick introduction for those unfamiliar. 
"Those who do not know Lisp are doomed to reinvent it"
Well that was inappropriate...
... or in reddit's case, doomed to abandon it for python? ;)
Amazingly confusing. 
It's like an extra-verbose Lisp. Also, the `new` module is deprecated. Don't use it.
My eyes. Oh, my eyes. Should there be anyone who leaves things like this for the maintainers to find, there is shame upon them.
As I read your code, [this song came into my head, except with "lambda" instead of llama](http://files.samhart.net/humor/flash/LLAMAsongish.swf)..
It sounds like you have a system that is partially upgraded - probably have some Python 2.6 from the old and 2.7 from the new mixed together badly. Without exact details of the error message and what you did afterwards it would be far too time consuming to diagnose. What I recommend you do is a clean install of Ubuntu as that will ensure your system is in a good state. You only need to backup your home directory. Many people put their home directory on a different partition and can then reinstall with impunity.
I don't quite know what to tell you then, your standard library is really busted. You could try just overwriting urllib.py [from the repo](http://hg.python.org/cpython/raw-file/5395f96588d4/Lib/urllib.py), or maybe better is to install 2.7 yourself (might as well go with [2.7.2](http://hg.python.org/cpython/archive/8527427914a2.tar.gz) now that it's released). untar the archive, then from the generated directory: ./configure make sudo make altinstall "altinstall" will install it so that if invoked with "python2.7" you'll get your new installation, but it won't overwrite the system "python". maybe give that a shot.
Don't use any of this code.
Naw, even the original Lisp has `LABELS`, an analog to `def`. Maybe you were thinking of [lambda calculus](http://en.wikipedia.org/wiki/Lambda_calculus)? 
Here's a video of the game: http://inventwithpython.com/videos/StarPusher.html
Perhaps I should write a code munger that takes regular python and converts it to all lambda functions.
Here's a milestone: The first time you realize that a particular list comprehension is too complex and approaching incomprehensibility, and you revert to easily-understood nested for loops. Whenever you're tempted by clever one-liners, "import this". 
Al, have you considered putting your code on GitHub ... so that others can fix it and directly send pull requests? Makes collaboration easier. If you need help with that, let me know!
I looked at it and my brain exploded.
Yes. Write it in [this style.](http://www.reddit.com/r/Python/comments/hyxle/python_fun_with_lambdas_or_how_to_never_use/c1zjlff)
I agree. My style is way too readable.
Heh. Good idea. I should take the time to post my code projects there as well as my person website. Here's Star Pusher on github: https://github.com/asweigart/starpusher
It's interesting to note that the way in which you apply a series of lambdas is a frequently used pattern in Javascript to create classes and factories. It's also similar to the work Haskell's do-notation does behind the scenes.
that's a 2 liner because you need to import sys
aha! nice!
Yeah I tried running it in PyPy (with JIT) and it was a little slower. I'm definitely intrigued with Cython + openGL...seems to make sense. The googles is not too helpful so far in terms of examples where people have done this. You wouldn't happen to have any links/code I could reference would you?
This "how to" won't help anyone. Those lambdas are obviously ugly, unreadable and useless. No sane person would ever do this. However I have caught myself using oneliners with one or more lambdas. At first, me thinks it's elegant and clever and clear. Then, a coworker asks me to expain what the code does....
I would say there are two things, which once understood, give you quite a boost: * Understanding that everything in Python is an [object](http://www.markus-gattol.name/ws/python.html#objects) and can be treated as such. * Python does so-called [call by sharing](http://www.markus-gattol.name/ws/python.html#call_by_sharing).
Still, it's cool that you *can* do that. Meanwhile, Java is standing outside the window of your big silly house that you've built entirely out of lambda functions, looking in, knowing how silly it all is but still jealous that it couldn't even do that. A house made of `Runnable`s and `Callable`s just wouldn't be the same.
Not for OpenGL but I've been using Cython a lot for my treebank parser. It has sped up the parser a lot. Things like direct access to arrays and statically typed variables or casts can help a lot in crucial places. It generates a html file where you can see how much Python versus C code you're using, and from that you can try incremental improvements.
That should be the case (except py26-scipy) but the MacPorts scipy port also seems particularly big; it looks like, unlike most MacPorts, it requires its own gcc toolchain to be built, and not use Xcode's gcc. Ugh! You might want to ask on one of the [SciPy mailing lists](http://www.scipy.org/Mailing_Lists). I hesitate to mention this because it is not perfect and it violates a cardinal rule of Mac OS X: "Thou shalt not modify anything in /System/Library". But, because the alternatives are not good, you *could* try to modify the Apple-supplied Python 2.6 so that it will look for a newer version of ActiveState Tcl. If you are not comfortable with working in a shell, you probably shouldn't try this. The overall idea is described [here](http://bugs.python.org/issue10537#msg130424) for Python 2.7. So you'll need to make a few changes. It should look something like this [untested!]: $ cd /System/Library/Frameworks/Python.framework/Versions/2.6/ $ cd ./lib/python2.6/lib-dynload $ sudo cp -pE _tkinter.so _tkinter.so.BACKUP # just in case $ sudo install_name_tool \ -change /System/Library/Frameworks/Tcl.framework/Versions/8.5/Tcl \ /Library/Frameworks/Tcl.framework/Versions/8.5/Tcl \ -change /System/Library/Frameworks/Tk.framework/Versions/8.5/Tk \ /Library/Frameworks/Tk.framework/Versions/8.5/Tk \ _tkinter.so Then install [ActiveState Tcl 8.5.9.2](http://www.activestate.com/activetcl/downloads), making sure that your usage is compatible with the ActiveState license. If everything works, you should have at least a not totally broken IDLE for the Apple Python 2.6 but it will still have some bugs and problems, some of which were fixed in later versions of 2.6 and/or 2.7.
http://docs.python.org/release/2.5.2/lib/module-UserList.html
The article's intent is more or less to show what's possible with lambdas and warn readers to NEVER do any of it.
Here are the diveintopython3 instructions to install Python/IDLE 3 on Ubuntu: [Installing on Ubuntu Linux](http://diveintopython3.org/installing-python.html#ubuntu).
thanks so much!
Ugh, camelCase Python identifiers?
I'm in love.
Why don't you just pay for advertising?
For me (I just picked up the Animal: Python book) and it was when Classes just went *click*, that was a huge step for me and it really sent shivers down my spine. Also, the moment I realised iterating over lists with 200+ objects was a severe resource hog.
I can confirm this. My only complaint is missing support for parallel deployments.
You are a monster.
&gt;Also, the `new` module is deprecated. Don't use it. Challenge accepted. &gt; `myFunc = (lambda(types): types.FunctionType((lambda a: a + 1).func_code, {}))(__import__('types'))` This creates an increment function named "myFunc". It works. It's an abomination. To quote the OP: &gt; Don't use any of this code.
Oh, just this being r/programming not r/compsci and all that.
It's not _really_ fun until your lambdas are recursive.
Is "the Animal: Python book" [Learning Python](http://oreilly.com/catalog/9780596158071/) or [Programming Python](http://oreilly.com/catalog/9780596158118/)? Or another?
So when did sharing knowledge became an immoral? Why I don't pay for advertising? Why would I, I don't have any commercial interest, something you'd have found out if you had taken a closer look. sigh.
You're making it look like as if 200+ objects in a list are a bad thing. That's not true. As usual, it depends, are your objects videos or do you store integers? Also, you bash on lists but don't say what someone should use otherwise. The answer here is lazy evaluation: http://www.markus-gattol.name/ws/python.html#generator_expression (links to my own website, obvious from my username/URL) Now, please make another sneaky comment about self-advertising, still, better than just pointing out a problem without presenting a solution ...
This is a list of tips I wish I'd had when I started out learning Python.
This is often the case when I see code with lambdas in it. I can see the potential utility in lambdas but I'm not convinced they make for more readable and maintainable code. Or maybe I'm missing something, but I suspect that isn't the case. 
The [ez_setup.py](http://peak.telecommunity.com/dist/ez_setup.py) script self modifies by opening itself, changing the code using regular expressions then writing itself back to disk. Scroll to the bottom of the file and look at the *update_md5()* function as an example. You could do something similar, but skip the part that writes it to disk, and instead *exec()* the modified code.
How about: sorted(names, key=lambda s: s.upper()) Lambdas can be incredibly useful for simple transforms, they just cause trouble if you try and mix orthogonal functional paradigms into Python. 
Funny, because I see no advertisements on his site which obviously means he doesn't have any commercial interest other than sharing knowledge. Get off your high horse.
My comment wasn't sneaky. I've noticed you generally only post in order to promote your blog. An example of what I mean: If for instance, you want to find all prime numbers in a range. You could increment a single variable, and use that to find the modulo of the number you're using, and then check if that number has more 0 modulo answers than it should. Using lists this takes a lot more time than using a single variable. That's what I'm talking about.
I *did* look at your site. And whilst not being strictly about making *money* you're doing it to promote yourself. You want a job. You want exposure, you want to get your name around as a decent programmer. This sneaky tactic of inserting your blog into every single post of yours is walking the fine line of being spam. I'm pretty sure other users have been banned for such activities. Users that post Amazon affiliate links which are on topic, yet have their affiliate code in the URL, got banned. Yours falls in a very similar category.
Sorry, yeah, I was at work when I posted. It's the Learning Python book, highly recommend it if you've just started learning.
Try and think why *else* he would create a site solely about himself and programming.
We could hope for nicer syntax, though, for such simple cases: sorted(names, key=upper)
perhaps more useful would be a de-lambdafier
how exactly do you make an anonymous function call itself by name?
True, but how would you pick names for these lambda functions?
3.1.4, 2.7.2 3.14: Pi 2.72: e PIE!
You can't, obviously. Doesn't mean you can't do recursion with only lambdas (see: y combinator). (Once upon a time, like half of all posts on Reddit were about how cool the y combinator is, most of the rest were about Haskell...)
We're in for a world of hurt, I'm afraid. The S-combinator and Y-combinator do this trick. You can google them, but I warn you that it will hurt the brain. First, let's take the factorial function and cheat by referring to the global scope: fact1 = (lambda n: n * fact1(n - 1) if n else 1) If we don't want to access the global scope, we'll have to pass in the function. So let's define a thing called the S-combinator: S = lambda F: (lambda x: F(F, x)) So `S` is a function that takes a function named `F`. It then returns a function, the lambda between parentheses, that takes one argument, `x`, and calls `F` with itself and `x` as arguments. So with the help of `S`, the function `F` can refer to itself. We can now rewrite `fact1` like this: fact2 = S(lambda f, n: n * f(f, n - 1) if n else 1) Notice how the 1-argument call to `fact1` got replaced by a 2-argument call to `f`. If we want to keep the original definition, we'll have to resort to the Y-combinator, and I'm afraid I can't _explain_ to you how it works, because I can't really wrap my own pitiful mind around it. I can show you though: Y = lambda F: (lambda h: h(h))(lambda g: F(lambda x: g(g)(x))) fact3 = Y(lambda f: lambda n: n * f(n - 1) if n else 1) You might or might not be happy to know that this indeed works. Sorry I'm not the teacher I'd wish to be. :S [One oversight is that `S` and `Y` only work with 1-argument functions, but they could be modified to take `*a` and `**k` as arguments instead of just `x`.]
Think long and hard about installing MacPorts. I ended up hating it so bad i uninstalled and hand built the apps i needed. That is a personal thing of course. I've heard good things about home brew though. In my case I skipped the 2.x series and went to the 3.2 Python. I seldom use Idle on the Mac either. Instead I us Eclipse with PyDev. I actually see PyDev as one of the best Python IDEs going, at least in the sense of Free IDEs. 
Also, a release for the 3.2 branch is coming, 3.2.1-rc2 is going to be released soon.
This actually is directly supported after a little work: sorted(names, key=str.upper) I thought there might be problems binding the upper method, and I turned out wrong. Lambdas really shine when you need to do a small adjustment on the simple case, or add just a little more logic: sorted(names, key=lambda name: name.split(' ')[-1]) Or the more explicit: last_name = lambda name: name.split(' ')[-1] sorted(names, key=last_name) Honestly, I understand the shorter form perfectly fine and prefer its brevity.
&gt; Also, the new module is deprecated. Don't use it. First I've heard of this. Any information on this and why?
Recently I wondered the same. Pyjammas looks like it will create a nice GUI for you in the browser. I have only glanced at it though, and not sure if it does Python3.x.
For Python developers, this is NSFW
Why a web based GUI? Does your application need a client-server architecture? My take is, if you really need local file system then dont do the web. But if you absolutly need many clients to use the same application on the same or similar data, then a client-server arcitecture such as http is nice, and for that there is Pyjamas which is a binding I believe to GWT which you can look into. It compiles your gui "widgets" into javascript and html, and you get seemless transfer of data between client and server which is handled by the server-side of the pyjamas output. 
Hmm, there will always be stuff that is never upgraded - you don't need to let that prevent you from upgrading programs that aren't dependent on it. I know of code that won't run on 2.2 - but that hasn't stopped my code base from moving up to 2.7.
"someone" made a tool and a site and a repository for this: [https://launchpad.net/acire](https://launchpad.net/acire) [https://aciresnippets.wordpress.com/](https://aciresnippets.wordpress.com/) [http://bazaar.launchpad.net/~jonobacon/python-snippets/trunk/files](http://bazaar.launchpad.net/~jonobacon/python-snippets/trunk/files) (somewhat ubuntu specific)
thank you
I've currently got a large deployment of applications, running on a mix of python 2.5 and 2.6. The general improvements in 2.6 are nice, but not enough to make it worth my time to migrate everything (just yet). That said, my packaging pipeline is somewhat complex, and I'm looking towards the future (py 3), and ran across the following - * Python 2.5's distutils/distribute/setuptools environment - the install / develop commands don't support the "--user" installation flag, and can't handle multiple package indexes very well. The 2.6 versions fix this. There are also some other behind the scenes things (esp on debian-derived distros) that make things a little better arranged under 2.6 and up. * Python 2.5 lacks the .format() method added in 2.6 &amp; 3.0. Not really a show-stopper for existing code, but keeping 2.5 compat means you can't use any code that uses it. * Python 2.5 lacks the b'' prefix added in 2.6 to distinguish bytes from unicode. This isn't really an issue under 2.x, since b'' is just a noop; but it's nearly critical if you want to transition your apps to 3.x, as the 2to3 script relies on b'' and u'' for hinting. Unless one of those issues is going to bite you, I don't see a reason to actually bother upgrading from 2.5 until you have to. 
 If you have knowledge, let others light their candles at it. -- Margaret Fuller (1810 - 1850) You see, that's the beauty about knowledge if I give it away, it only gets bigger/better. Saying what you throw at me, for no reason, is just childish.
Ooh, I was hoping someone would notice. :)
If your code is married to the GUI main loop, Tornado &amp; websockets should be pretty easy to adapt to you situation. I've ported a few smaller things from PyQt &amp; twisted over to tornado &amp; websockets with relative ease. You'd probably need to roll your own UI though.
Supposedly the next release is pi\*j. I imagine the exponential jump from e to pi\*j is a real negative one for the true believers in the complex powers of e. Edit: Oh well, I thought it was funny. kwds: I, imagine, exponential, `e ** (pi*1j)`, real, negative one, complex powers. Time to clean these rotten tomatoes off. Tough crowd.
Well, as the [documentation for it](http://docs.python.org/library/new.html) says: &gt; Deprecated since version 2.6: The `new` module has been removed in Python 3.0. Use the `types` moduleâ€™s classes instead. You can do everything you could with `new` using `types`anyway. You just call the type objects as constructors.
&gt; Why a web based GUI? Oh lots of reasons. Number one is that I already know how to build a basic, interactive web GUI. So the learning curve, at least where I'm at now, seems much smaller than trying to learn pyQT or wxPython. I know I talked about writing applications for personal use on my local machine, but I'm thinking ahead and like the idea of being able to easily share my application via the internet. Maybe I buy a new smartphone some day with a standards compliant browser and I want to run my application from that phone. I don't want to have to worry if the phone supports pyQT or even learn how to write GUIs using that phone's preferred framework. Likewise, it seems that I'm freed from having to learn a GUI toolkit ever again. If I switched over to say Java today (just an example) I would have to learn Swing or SWT to build a GUI there. Or I could simply have a head start in creating a GUI from a basic Java program by just figuring out what the Java equivalent to Flask was. The biggest disadvantage to a web gui, as far as I can tell, is the local sandbox issues and lack of interesting widgets, especially widgets used to interact with the file system. I get the sense, however, that it is changing and have been very impressed with how sophisticated they have become. HTML5 seems to promise even more good stuff here. 
asserts are still run by default in Python, unless you run python with the -O option. The asserts are in there for basic sanity checks about the format of the levels.
Now that I finally fixed [this](http://bugs.python.org/issue12084) `os.stat` bug we can finally move along with 3.2.1. RC2 will be this weekend - 6/18-6/19.
If I got you wrong, then *ok*. But I honestly choose to believe that you linking to that page almost in every post is just an attempt to get yourself some exposure. If it was purely about the 'knowledge' on there, you wouldn't *really* have a section explaining what people need to do in order to interest you in a job offer. It just smacks of a thinly veiled CV to me.
Java has GWT, which is exactly like you describe, you learn its details once and should be set to go for the future, as it compiles your "gui" down to html+javascript and manages async-calls over the web for you. Pyjamas is the python binding to GWT. Another option you have is to learn gtk and a python binding to gtk. GTK3 can render to html5+javascript. Yup thats right. You can even now render GIMP which is a pure gtk app, to a browser. The disadvantage is still there though, sandboxed access to local filesystem. 
Thanks. And are there any (dis)advantages compared to try statement for things like opening a file or if/else statements for values comparison?
I think Raymond originally tweeted it :)
Pyjamas is unlikely to support Python 3 in the next 5 years or so. They have to change too many things in order to support it.
My spam senses are tingling. If I were you, and I'm almost definitely not, I'd consider purchasing advertisement space or creating an RSS feed and not posting release announcements here. I'm sure the community would much rather have you post something informative about Python, IDEs, or a combination of the two instead of what are, essentially, advertisements.
Thanks!
Missing the point, shsmurfy is using a simple example that can be replaced by what you suggest. However what if, say, you have something like the following: sorted(names, key=lamda s: foo(s.bar, s.baz) + s.bat) It's much nicer to inline as a lamda rather than creating an passing in a full fledged method.
Why did you hate it?
If you find the time, have a look around the `operator` and `itertools` packages. They can often come in quite handy.
Wow that looks really useful. A big thanks to you. Having finished the Python Tutorial (and the Python Koans, which are really good imo - https://bitbucket.org/gregmalcolm/python_koans/wiki/Home) - I always looked for a resource to explain "the python way" to do things :)
Yea, I'm a big fan of `itertools` already. I had no idea `operator` had anything of interest beyond `add`, `sub`, `or_`, etc. I also love `functools.wraps` for decorators and `functools.partial`.
OK, it's time to stop being such a panocha and get this over with. Two things are fucking with my brain here; one is the Y-combinator itself and the other is Python's lambda syntax. Luckily, we can get rid of the second one. #!/usr/bin/env python import functools def trace(f): @functools.wraps(f) def trace_dec(x): print '--&gt; {0} {1}'.format(f.__name__, x) r = f(x) print '&lt;-- {0} {1} = {2}'.format(f.__name__, x, r) return r return trace_dec @trace def make_recursive(F): @trace def start(h): return h(h) @trace def fix(g): @trace def call(x): return g(g)(x) return F(call) return start(fix) print '### Defining fact4' fact4 = make_recursive(lambda f: lambda n: n * f(n - 1) if n else 1) print '### Calling fact4' fact4(3) print '### Done' This is what happened: ### Defining fact4 --&gt; make_recursive &lt;function &lt;lambda&gt; at 0xb77719cc&gt; --&gt; start &lt;function fix at 0xb7771aac&gt; --&gt; fix &lt;function fix at 0xb7771aac&gt; &lt;-- fix &lt;function fix at 0xb7771aac&gt; = &lt;function &lt;lambda&gt; at 0xb7771b54&gt; &lt;-- start &lt;function fix at 0xb7771aac&gt; = &lt;function &lt;lambda&gt; at 0xb7771b54&gt; &lt;-- make_recursive &lt;function &lt;lambda&gt; at 0xb77719cc&gt; = &lt;function &lt;lambda&gt; at 0xb7771b54&gt; ### Calling fact4 --&gt; call 2 --&gt; fix &lt;function fix at 0xb7771aac&gt; &lt;-- fix &lt;function fix at 0xb7771aac&gt; = &lt;function &lt;lambda&gt; at 0xb7771b8c&gt; --&gt; call 1 --&gt; fix &lt;function fix at 0xb7771aac&gt; &lt;-- fix &lt;function fix at 0xb7771aac&gt; = &lt;function &lt;lambda&gt; at 0xb7771c34&gt; --&gt; call 0 --&gt; fix &lt;function fix at 0xb7771aac&gt; &lt;-- fix &lt;function fix at 0xb7771aac&gt; = &lt;function &lt;lambda&gt; at 0xb7771cdc&gt; &lt;-- call 0 = 1 &lt;-- call 1 = 1 &lt;-- call 2 = 2 ### Done **scratches imaginary beard**
This is why I'm reluctant to really try Python. At least with Java, C# etc the language stays consistent,
You'll need pyglet but this is pretty damn cool. Especially for such a small program. http://29a.ch/2009/5/12/rendering-the-mandelbrot-set-using-python-and-opengl-glsl
Awesome, if I can get this to work that would be a great thing for my students to see what you can do with Python. 
And for those who prefer reading from dead trees, Mark Summerfield's [Programming in Python 3](http://www.amazon.com/Programming-Python-Complete-Introduction-Language/dp/0137129297) is one of the best publications available. Although Learning Python is infuriatingly verbose, [Programming Python](http://www.amazon.com/Programming-Python-Mark-Lutz/dp/0596158106/ref=pd_sim_b_1) is wonderful for intermediate Pythonistas.
I love the Wing IDE, thanks for making it. I agree with ThomasBayes though, purchasing a advert would be very nice :)
&lt;3 e where you at
I think I'm using `functools.partial` more frequently than lambdas these days.
can I ask what code works on 2.5 but not 2.6?
I like the more explicit one; it's very elegant imho. To each his own.
and thus was born ycombinator.com ? ;)
Consider Tkinter. It isn't the most pretty of GUIs tool kits but it is very simple to program against, has a good selection of widgets, including a feature-full canvas and comes built in with Python. If you are comfortable with Python, I bet you can learn how to program against it and graft a GUI onto an existing Python module in a weekend. In my experience, learning how to program against a GUI tool kit is not the hard part. The hard part (for me) is designing a good UI. I imagine if you can do that well already with a web-based UI you can do it with whatever GUI tool kit(s) you end up with. 
I thought it was quite good. I've actually played around with lambdas in Racket doing this sort of stuff.
Doh. Looking back, none of the things I listed would have prevented 2.5 code from working in 2.6, they only would have prevented the reverse. Glancing at the [2.6 changelog](http://docs.python.org/whatsnew/2.6.html), the only things that stood out as likely to cause problems were: * "with" became a reserved keyword, as with-statement usage no longer requires a \_\_future\_\_ import * under windows, python now compiles against VC9. Neither of those sound like a real show-stopper by any means. Now I'm kinda curious what rushoffailure has that won't work under 2.6.
One night, somewhere deep in western Europe while most lay slumbering, a lone developer contentedly hacks on some Python of his own design, accompanied only by the rhythmic ticking of a distant grandfather clock elsewhere in the household. As time passes slowly, and as the wind blows gently outside the window, one lexical token after another is inscribed into the eerie glow of a weary terminal. But wait! What is that? Startled, he looks to an empty part of the ceiling and ponders momentarily, "doesn't this function remind me of something?" For a moment he considers a fleeting dream-like memory of an idea of a truth he'd once deemed to learn, then recalls the near-forgotten promise of an interesting series of articles covering the very subject of his present craft! "Aha! Now here is a problem I may yet solve," as a Firefox tab flickers into life. Scrolling through his Reddit comment history, at last the goal is found: the record of promise, not yet broken, yet, but perhaps in need of a little encouragement. Bleh OK I'm bored now :) You going to finish the series or what? :P Take care, David.
My goodness. You must be a dedicated soul to still be using Java 1.0 :) Seriously though - every single language out there is changing, if it's being actively maintained at all. Even the undead ones like COBOL have some form of advancement. I'm not sure how new things being added to later versions of a language or library could possibly make someone *reluctant* to use it. In fact, Python is one of the smoothest-evolving languages out there. The \_\_future\_\_ imports &amp; the deprecation warning system makes it incredibly easy to migrate code to newer versions of the language. Through the PEPs and other community processes, Guido van Rossum has done an excellent job of making short-term changes in a manner that fits in with an overall goal, with very little of it happening without the community's involvment *prior* to the change being made.
I've yet to dip my toe into Python 3, I'll check that out when I do.
Dear God why?
It works fine for me: &gt;&gt;&gt; x = range(10) &gt;&gt;&gt; for i in x: ... print x ... x.pop(0) ... [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 0 [1, 2, 3, 4, 5, 6, 7, 8, 9] 1 [2, 3, 4, 5, 6, 7, 8, 9] 2 [3, 4, 5, 6, 7, 8, 9] 3 [4, 5, 6, 7, 8, 9] 4
&gt;decrypt it, exec() it, reencrypt it and rewrite it Are you working on a project for Daft Punk?
well it doesn't throw an error, but the loop terminates before it gets to the end. it basically says "hey i have a list that is 5 long, and i iterated 5 times, so i'm done".
In the first example you're assigning a new `x` and not modifying the original `x`, so it continues through all 10 iterations of the loop as you expect. In the second example you actually modify the original `x`. Here's an example that shows what's happening a little more clearly (I'll show the first for reference): &gt;&gt;&gt; x = range(10) &gt;&gt;&gt; y = x &gt;&gt;&gt; for i in x: ... print i, x ... x = x[1:] ... 0 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 1 [1, 2, 3, 4, 5, 6, 7, 8, 9] 2 [2, 3, 4, 5, 6, 7, 8, 9] 3 [3, 4, 5, 6, 7, 8, 9] 4 [4, 5, 6, 7, 8, 9] 5 [5, 6, 7, 8, 9] 6 [6, 7, 8, 9] 7 [7, 8, 9] 8 [8, 9] 9 [9] &gt;&gt;&gt; print y [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] &gt;&gt;&gt; &gt;&gt;&gt; x = range(10) &gt;&gt;&gt; y = x &gt;&gt;&gt; for i in x: ... print i, x ... x.pop(0) ... 0 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 0 2 [1, 2, 3, 4, 5, 6, 7, 8, 9] 1 4 [2, 3, 4, 5, 6, 7, 8, 9] 2 6 [3, 4, 5, 6, 7, 8, 9] 3 8 [4, 5, 6, 7, 8, 9] 4 &gt;&gt;&gt; print y [5, 6, 7, 8, 9] First iteration, `x` is `[0, ..., 9]`, you pop off `0` so `1` is now the first element, then the iterator driven by the `for` loop goes to the *next* element (at `2`), and so on. Make sense? Edit: updated the example to show the contents of the original list after each loop.
I *think* what is going on is that pop() is reducing the number of items in the list by one each iteration. So after 5 iterations there are 5 items left in the list. Python checks the number of iterations and checks the number of items in the list, and when they are equal, it thinks that it has iterated through every item in the list. With the slice method, x is set to a new list each iteration, which must be enough to reset Pythons for loop counter. Edit: Keith beat me too it. What he said.
thank you, i sometimes treat a slice as the original and need to remember that it is indeed a copy.
&gt; we have three accepted languages for scientific computing. In this order they are C/C++, Fortran in all its dialects, and Python. I count 4 programming languages there, bub.
If Vpython doesn't have them drooling to do some Python, then nothing will! Wish it had been around when I was in school. Good luck!
Are you looking for something like this? x = range(10) while x: print x x.pop(0) 
Here's a snippet of the code from listobject.c, `listiter_next` that confirms what you think: if (it-&gt;it_index &lt; PyList_GET_SIZE(seq)) { item = PyList_GET_ITEM(seq, it-&gt;it_index); ++it-&gt;it_index; Py_INCREF(item); return item; } 
shhhhhhh.
They are scientists, not mathematicians!
at first I saw this and though, "Hmm... I rarely use lambdas anyways... how will this be any different from just naming a function beforehand and using that?"... bad name, but funnny!
I'll be sure to give William some crap for that, especially given that C99 further [breaks](http://en.wikipedia.org/wiki/Compatibility_of_C_and_C%2B%2B) the concept that C is just a subset of C++.
That's not a very useful reply. Homebrew, MacPorts, and Fink are the three leading third-party package managers for Mac OS X. All of them can usually get the job done if you invest the necessary time to figure out how to use them to your advantage. Or you can install a mixture of binary installers and building stuff from source and spending a lot of time getting all of the components built in a compatible way. A sampling of questions on StackOverflow or on reddit about building third-party libraries and apps on Mac OS X can be enlightening. It depends on what your longer-term priorities are: do I want to invest the time upfront in understanding how my chosen package manager works and can help me or do I want to do it all myself and go through the tedious learning process that others have done before me.
Take a look at the [Appcelerator Titanium](http://www.appcelerator.com/products/)
May be better over here: [/r/django](/r/django)
That's a totally different module for a totally different version of Python - do try to stay on topic especially if you're going around asking others to fact-check. 
- packing a GUI app for a standalone execution on Windows, OS X and Linux - writing a C extension and wrapping it for use in python - wrapping an established library in python - contributing a package to PyPI - building Python from scratch on Windows, OS X and Linux - contributing code to CPython - implementing a cross-platform python interpreter - optimizing the above python interpreter to be as fast as CPython or faster ;) - optimizing the above python interpreter to work on limited resources platform and on different CPUs (ARM, PowerPC, x86, x64). 
Hello, friend!
with statement by default and new way of declaring properties are the two every-day-useful-features that spring to mind with Python 2.6. 
For those of us using Wing, or interested in the Python IDE space, it's newsworthy. That's the advantage of a community moderated site with voting of course. If people really *weren't* interested they'd vote it down...
Theoretically, to write a virus. Although i'd never write a virus in python. I just want to understand the theory.
erm.... no?
What stuff still only works in 2.5? Actual question too.
also, from my point of view, it's easier to say "works on 2.6" than try to walk people through installing the ssl module on 2.5 ;)
Which is, by the way, horribly inefficient. For popping from the left, use `deque`.
ok, then http://docs.python.org/py3k/library/collections.html#collections.UserList says: "The need for this class has been partially supplanted by the ability to subclass directly from list; however, this class can be easier to work with because the underlying list is accessible as an attribute." I'm a bit surprised this was kept in python 3. But then, a lot of crap was kept around for lack of time or by popular demand (however disputable the demand may have been). Also let me repeat the (important) point I made initially: deriving People from List is nonsense.
isn't pyjamas more of a python port of gwt? &gt;What is Pyjamas? &gt; &gt;Pyjamas is a Rich Internet Application (RIA) Development Platform for both Web and Desktop. &gt; &gt;It contains a Python-to-Javascript compiler, an AJAX framework and a Widget Set API. **Pyjamas started life as a Python port of Google Web Toolkit, the Java-to-Javascript compiler** from the [pyjamas website](http://pyjs.org/)
Your choice depends on whether your object is a kind of list, actually so close to a python list that you may only want to add a little and redefine small parts of it (if possible only extend it), hence inheriting; or something that behaves like a list but has a completely different implementation (then you build a list-like object, possibly playaing with ABC registration, but do not inherit); or is made of list(s). As for the gtk thing, it looks like you really want to wrap it. By inheriting, your object will have both the inherited complexity and the simplified API you want to have. But I do not really understand what you are doing. Important question to ask: in the end, what will be easier to maintain, for you later, or for peers ? How hard is it to explain to some random joe ?
This is a good idea. But remember the "client" part becomes then untrustworthy (however you may not need to trust a GUI). Google did it with Refine (http://code.google.com/p/google-refine/) and it works pretty well (try it !). The server side is coded in Java, but you only download one package, run one executable, and it opens right in your browser. EDIT : I would say this works well when you only need to sporadically display the internal state of your application, but if you need to constantly display a huge amount of data with high user interactivity, it isn't the right solution. EDIT2 : Still, we need a JS Library with a protocol communication that wigdetize some OS accesses. (Or it may already exist somewhere on the net ?)
The language, in terms of the grammar and syntax and all of that, does stay consistent on par with the changes in just about any widely used language. 3 and 2 have their differences, but within any 2 or 3 major version, "the language" is the same. A significant majority of the fixes are to standard libraries, which those languages have and are fixing. It's not like we're changing "5 + 5" to be "5 5 +", we're changing stuff that returns 0 in the Windows implementation but None in the *nix implementation to consistently return None across the board. Java and C# do the same stuff.
what you want is: x = range(10) for i in x[:]: print x x.pop(0)
&gt;... that C++ is just a superset of C. FTFY. ;) 
Why not? I'm using django for intranet apps, be they small or big. The UI work can be done by web people, databases are modeled and thereby abstracted and the network code is a given in a web framework. This approach allows me to mainly care about the server side, the client side is maintained by browser vendors, one less thing to worry about. Browser UI's are easier to make, change and maintain in my opinion.
awesome stuff, i look forward to doing many of those things, especially writing C extensions :)
To make a copy of the list, I prefer: list(x) instead of x[:] e.g.: for i in list(x): ... I think it's easier to understand what's happening. I've never been a fan of the x[:] syntax, it will undoubtedly confuse some new Python user.
If you enjoy the community, you should encourage commercial entities to purchase advertising space when they seek to advertise, because, really, are "minor features and bug fixes" newsworthy? I can't imagine this subreddit if every commercial and open source software python project made reddit their announcement feed, but if this is something you'd like to see for Wing IDE, perhaps you should create and moderate /r/wingide/. Also, as a Wing user, you might find subscribing to their announcement feed, twitter, or mailing list to be a more efficient way of getting your Wing IDE news--that way you won't miss anything that gets down-voted.
Wouldn't a decorator be a bit more useful? Less boilerplate anyways.
&gt; in my actual program i will be popping multiple items each loop. It's generally a bad idea to modify the list you are iterating over if you can avoid it.
 x = range(10) x.reverse() # WARNING: reversed() returns an iterable but sorted() evaluates. use list(reversed(foo)) if using reversed. while x: print x x.pop() 
I don't think there is one yet. There are some PyGTK tutorials, though, which is the previous version of the same idea.
This is more general. A decorator would only apply to a single function, not a whole block.
It's a different use case. If you use a decorator you need to put your block in another function, and hence a different scope. Perhaps you don't want to do that.
I had to ask myself this question 4 years ago, and I decided to go with a web based GUI and have never once regretted the decision. I used the TurboGears2 framework for this prior project, but am now moving to [Pyramid](http://docs.pylonsproject.org/docs/pyramid.html) for future projects. Also note another big decision can be which widget toolkit you use. I used Dojo quite a bit in the past, but it seems jQuery has risen to be the defacto standard these days.
It's been a while since I checked in on Pyjammas, but they still don't seem to have very much selection in the widget department, which is the most fundamentally important aspect of choosing a javascript library for GUI. Stick with Dojo or jQuery.
Have you had a look at [developer.gnome.org](http://developer.gnome.org/)?
Did you even look? http://live.gnome.org/PyGObject#Examples
It's not pretty code and I don't recommend using it. It's more a fun experiment if it could be done :)
Just a note: class names in Python are usually BiCapitalized.
not necessarily.. and in fact, context managers are typically lowercased.
[Official PyGTK tutorial](http://pygtk.org/tutorial.html) [Articles and Tutorials on PyGTK and others](http://pygtk.org/articles.html) [Reference Manual for PyGTK and PyGObject](http://pygtk.org/reference.html) [PyGTK FAQ](http://faq.pygtk.org/index.py?req=index) **NOTE** PyGTK is no long supported. PyGI PyGObject is what you should use when you write new code. However the tutorials should provide a sound foundation for using PyGObject. **One more thing read the PyGTK FAQ FIRST! It's one of those things I wished someone told me to do when I first got introduced to PyGTK years ago.** 
Is there a list of changes from the 1st edition somewhere?
Thank you.
It seems a little bit less sexist in the scenario's, otherwise they generally seem the same and the lack of explanation of __init__ is still there...
Yes. However, I was asking about a tutorial. Of course, examples != tutorial. 
No, had not looked there. I see there's a GObject reference manual there that might be of some use. Thanks. Still though, a GObject reference manual != PyGObject tutorial. 
Dammit Jim!
What a jerk! Now everyone will learn Python and I will no longer be special.
As someone new to GTK/PyGTK/PyGI/PyGObject, I've got no idea what PyGTK and PyGObject might have in common, or how they might differ. Any idea how applicable the PyGTK tutorials are to PyGObject? 
If he had the 1st edition in html, or the 2nd edition in pdf, you could probably export the text and do a diff.
It's still a work-in-progress. Ex50 and Ex51 haven't been finished yet. Shameless plug: I did the [Chinese Translation](http://lpthw-cn.ducktypist.com/)
I can vouch for this guy. His writing style is pretty funny. &gt;"A programmer may try to get you to install Python 3 and learn that. You should tell them, "When all of the python code on your computer is Python 3, then I'll try to learn it." That should keep them busy for about 10 years."
I know it's a work-in-progress, but is there a pdf available somewhere?
While I agree that stating that a book is available "for sale" doesn't help this reddit, there is a small difference here. Safari Bookshelf, while being a subscription service, is often provided for free through a local library. Additionally, many campuses and workplaces will provide a subscription to their students/staff. I got one over a year ago through Loudoun County Library (I live two hours from there, but I do work in the area, so I was able to give my work address to get the card). It might be worthwhile checking with the libraries close to you to see if you can get Safari access through them. 
With that kind of mentality, python 3 will sure take years. We still have some legacy code, but writing new code in python 2 sure won't fix the problem. I don't understant why some people prefer to ignore the successive improvment of the language for a few years instead of learning the little bits of syntax that changed (I'm not talking about those who don't switch because of libs, I'm talking about those who don't switch because meh, it's too early, there's no use)
Thanks for your hardwork and especially for sharing it to the world. 
 (lambda a, b = __import__("time"): (lambda c = map(lambda d: __import__("thread").start_new_thread(lambda e: (lambda f = b.sleep(e): __import__("sys").stdout.write(str(e) + "\n"))(), (d,)), a): b.sleep(max(a) + 1))())([4, 1, 3, 2])
When I learned Python (~10 years ago), a friend and I had a competition going on about who could find the shortest possible solutions to programming puzzles. The resulting code violated all style principles but it was fun and in order to win you had to know the syntax and libraries very well. This will not make you a proficient programmer but it's very useful to familiarize yourself with the language, which is a first step.
Mainly it's because Python 3 broke a lot of stuff, and the Python devs decided to freeze the 2.x codebase, except for security issues. Coupled with the fact that not everything is upgraded, and a lot of time is needed to upgrade incompatible code, it's going to take perhaps years.
Working my way through the first edition now. This book has been a great resource; if the author is reading this, thank you!
&gt;I'm not talking about those who don't switch because of libs, who else is there? languages are just as much about the runtime and the batteries included as they are about syntax. 
time.clock() is a more accurate wallclock on Windows. It's not wallclock on Unix though. wallclock = (time.clock if sys.platform == "win32" else time.time) 
I wish more people would understand the [Advice From An Old Programmer](http://learnpythonthehardway.org/book/advice.html). There is so much need for programmers in non-programming environments. So much opportunity to change things for the better in vertical markets. I recently cooked up a small app that allowed me to automatically generate a PowerPoint with before and after images that followed a specific template. All the doctors that visit our clinic and see toys like this think I should work for NASA or something like that... :)
Why is the book named this way? I mean everyone wants to write python the easy way. Isn't it? Python newbie here.
There is also a great need for non-programmers in programming environments. Programming isn't a domain in itself, it always supports some greater whole. But even more important is all kinds of people realizing that data is useful when used, not when hoarded. Free and inexpensive data enables programming, even in crude form.
Oh yes! Designers are the easiest example of non-programmers. UI designers, interaction designers. etc. People with nonviolent communication skills working in the management of communities are also a great example of non-programmer that could bring a lot to the team. 
More milestones: When you realize that "import * from package" is not worth the savings. When you realize that imports in functions/methods have more potential to trouble than module-level imports. The flip side of that: When you first get bitten by cyclical imports. When you first get bitten by mutable data-structures on class-attributes or in default parameters of a function/method.
It's a joke, to stimulate interest. It also makes ther point that typing out things and trying them is the best way to learn.
It seems a pity not to have a Python 3 version. I'd prefer to learn that. As a Python newbie I don't care overmuch about the fact that Python 2 has better libraries or whatever. I want to learn the more future-proof version.
The people bitching about goto surely must not have heard of super().
Thanks very much for the .pdf. To a total newb it isn't trivial though. When a piece of typed code doesn't work my first expectation will be that I typed it wrongly, not that the syntax has changed. I was planning on working through this guide but while running Python 3, but that would make it a bit harder for me. I'll use Python 2 though for now. I bet though, that by the time I need to know about Django, it will work with 3.
Practise a lot and you will be proficient. You can try these websites: http://pyschools.com and http://codingbat.com
Thank you for contributing to this project. I think it's a pretty awesome idea, and having it available in multiple languages makes it even more so. Thanks.
I am just starting to learn Python and I tried Python 3 first but pygame seemed buggy and I couldn't find a nice plotting tool for it yet so I am focusing on 2.6 now. That was my experience at least.
You gotta remember that improvement is in the eye of the beholder. Not everyone likes the changes in Python3.
yeah that's kind of point. thanks
Good to know, but I must admit I have no need to litter up my python code with windows optimizations ;)
For someone with his ability to reach people with quality writing and code, it would be nice if his attitude on the topic wasn't so blatant and overly negative, or just not say anything at all as I'm not sure who that comment helps.
PyGTK is the manually written Python binding for GTK+. New versions of PyGObject contain PyGI, which is an automatically generated Python binding for GTK+. They're similar but not identical. I suggest following a PyGTK tutorial then (if you want) following one of the porting guides to convert your code to PyGObject.
...and everyone who wanted to know knew that going into it. This wasn't some secret closed door discussion 2 years ago - the breaking changes were discussed, the decision to push forward on 3.x was discussed, and the thing about security issues isn't up yet because 2.7 will continue to receive general bug fixes for *a long time*. 2.6 just entered security fix because 2.7 is taking over for the 2 branch. Everything can't be upgraded immediately, and not everything will be upgraded even given an infinite amount of time. We're close to 3 years into one of the original estimates that it would be 5 years until a large scale adoption of 3.x, and we're ahead of the curve in terms of that. It's not going to be a sprint to 3.x, it's going to be a crawl, and there's nothing wrong with that.
I do, and other people who might use your code might too. :P
Absolutely. For beginners, just the mere fact of running into something that doesn't work (e.g., a library that won't install or isn't available) is enough to make them give up. The attitude here, to me, isn't negative but highly pragmatic. Go Zed.
I'm waiting for "Lean Python the Harderest Way".
yep people whining about python 3 not having the adoption *they expect at this point* in time can barely articulate the benefits of python 3 in any way that is convincing to me. :) i get tired of those fuckers putting comments on my blog about my articles not being about python 3, of course the simple answer is they should start a blog, but they wont. 
It's a shame it doesn't teach python 3. This python noob will have to look elsewhere. I bet most new programmers want to learn the current codebase, not the older status quo. That's why I'm not studying LISP or Perl or other common but older languages.
I agree.
You can pretty much use the old PyGTK documentation (http://pygtk.org/tutorial.html) the syntax is nearly identical. If you replace import gtk with from gi.repository import Gtk as gtk Most of the code will work as advertised. The only other real noticeable change is that the constants (formerly things like gtk.ICON_SIZE_BUTTON have become Gtk.IconSize.BUTTON). There's a script that will clean these up for you (http://git.gnome.org/browse/pygobject/tree/pygi-convert.sh)
How does this compare to [Skulpt](http://skulpt.org)?
[Learn Python the hard way](http://learnpythonthehardway.org/book/index.html) appears here often as well. It's a great tutorial for building basic practical proficiency. I like having dead tree references around, too, so I keep *Programming Python* by Lutz and *Python Scripting for Computational Science* by Langtangen close at hand.
I hear ya. I had to go to a training class on Office '97 and haven't been able to use any other office suite since since they're all so radically different. I hear Office '10 doesn't even allow you to center text!
Hey it made me laugh &amp; it actually peaked my interest.
I wish I could agree with you, but the Python3 libraries needed to do many basic things just are not there. It is hard to recruit believers when you have something that doesn't meet their needs. Also, between virtualenv and the general ease of installing multiple python versions on the same machine I do not see a problem.
&gt;more future-proof version No such thing.
That isn't what Python 3 is. People program to DO things. Not all those things can be done in Python 3. Learn Python 2 and DO things. The transition to 3 is easy and you can do it once you have the capability to get things done.
This sort of thing is called codegolf, there are sites that specialize in it.
As with all of the gnome stuff, it is largely un/under documented. Lots of googling with sporadic snippets here and there have allowed me to figure it out. It depends on what you want to do with it but I found the python dbus examples to be helpful as well as stackoverflow. EDIT: I don't care about the GUI aspects of it - I needed to figure out the threading/dbus/console-ish parts.
Or you can use something like [pythonbrew](https://github.com/utahta/pythonbrew)
&gt; Writing code in an imperative style has become the de facto standard Oh really? Guess I missed the memo on that. 
nice! it might be useful for [r/webdev](http://www.reddit.com/r/webdev) as well
It helps the beginners for sure. See [bcofrman's](http://www.reddit.com/r/Python/comments/i0spr/learn_python_the_hard_way_2nd_edition/c201gfz) comment. And if Python 3 is just some syntax diff then it would not be hard to migrate once you are at intermediate level. 
&gt; With that kind of mentality, python 3 will sure take years. Correction: python 3 already has taken years. And will take many more.
What, no such thing as 'more future-proof'? I cannot agree. Blu-ray, is for example, more future-proof, and a better investment for that reason than VHS, at the time of writing.
/s/peaked/piqued
from __future__ import *
Both perl and lisp have relatively new variants/versions..
I was just reading the other day about the new parallel deployment feature in Tomcat (http://www.javacodegeeks.com/2011/06/zero-downtime-deployment-and-rollback.html) and would love to see this capability in "python web framework of choice". I don't think your approach here would be the right way to go, but I could be wrong and so would be interested in seeing how far this experiment could be pushed. 
No, I mean with Python. The libraries for Python 2.x are never going to disappear. Installing Python2.x alongside Python3 is incredibly easy and doesn't cause any sort of conflicts. Us wise Python users say learn what you need to get stuff done, then learn what you need to grow. I know what you are feeling.
thank you :-)
I actually had code reloading implemented a while ago in zine for plugins. It was horrible. Python as a language was not really designed to support that :)
I'm sure any python project maintainer who hasn't moved to python 3 yet would gladly accept a patch whenever *you* get a moment. WTF is taking *you* so long?
As far as I can see, Skulpt (which I haven't known before) has a built-in compiler (so a parser and lexer as well). My script ist purely an interpreter of the Python bytecode, so no need for implementing the whole language syntax, just a reasonable amount of bytecode operands. The disadvantage of my interpreter is that you have to compile your python app on your computer first (and then putting the pyc online). That might be an advantage for someone who wants to hide the plain sourcecode though. 
Ah, somehow I missed that. That's pretty interesting, though isn't the byte code pretty mutable between releases? I don't know how much variation there is between versions, so it might not be a big deal, but did you (or do you have plans to) deal with this in someway?
thanks
Well neither was Java :) But this isn't "reloading", it's more like invisibly adding a version number to the namespace based on user session for the url dispatcher. Modules/packages can be unloaded once all sessions using those old versions are closed, but until then they are running in parallel with newer versions. You've got the parallel part here in your experimental project. If it works well then we just need a url dispatcher/router part.
Since the bytecode isn't that well documented and I haven't digged deeper into the topic (version changes) for now, I'm sorry I can't tell you how big the changes are (hopefully not that big - at least within the 2.x series; the change to 3.x might be heavier). Currently I make sure that the version-depended magicbytes (first 4 bytes of every pyc) are equal to these from Python v2.7 to avoid any unknown problems when playing around with the script. I've developed the JS/Python for fun and for learning reasons mainly; but I see somehow potential for a few cases where this might be helpful or funny to play with. I plan to implement the rest of the bytecode operands to get to an almost fully working implementation (even if most of the python libs are missing). Very interesting is to connect python and the browser by providing a modul in JS/Python for python (as shown in my example "JS from Python"). That allows interaction with the browser world (execute javascript, sockets, cookies, etc.). In python on your computer, you're calling dummy functions (like my webby-modul in my example, see .py-source) which are being filled out with function when running on JS/Python.
&gt; As with all of the gnome stuff, it is largely un/under documented. This is unfortunate. Any idea why it is so? I'd prefer to use GTK rather than Qt or Wx, but GTK isn't even in the same ballpark as Qt/Wx with regard to beginner documentation. Even though I've been using a Gnome-based desktop for years, and generally prefer C to C++ libs (after having programmed in C++ for a while), I'm getting ready to throw in the towel and just start using PySide or PyQt. 
What?
Nice work!
sorry I thought you were one of the python 3 whiners bitching from the sidelines but re-reading you do have a more reasonable take on the situation. my point was for those that are bitching about it, they are likely more than welcome to jump in and help out those library maintainers that haven't switched yet. 
&gt; Very interesting is to connect python and the browser by providing a modul in JS/Python for python (as shown in my example "JS from Python"). That allows interaction with the browser world (execute javascript, sockets, cookies, etc.). In python on your computer, you're calling dummy functions (like my webby-modul in my example, see .py-source) which are being filled out with function when running on JS/Python. Well, that was my next question: what are your plans for providing some sort of access to the DOM &amp; the like from Python? :D
I tried this and hit some problems (some leaks in the binding I was using). Then found out about [GraphicsMagick](http://www.graphicsmagick.org/). It was too late to change, so I went with a solution of: - Wrapper script starts the gimp in headless mode - Gimp starts a pythonfu script that did the work I needed.
Once I've implemented a feel-good and simple module system for JS/Python (I've worked on it already, but it's - of course - not finished yet), I begin to implement some of the interesting functions, first of all sockets, cookies and of course DOM manipulation - shouldn't be that hard to implement since it's possible to pass a (javascript) object to a pythonapp (which can itself work with it like with other objects). For the future I plan to make it possible to easily hook your own javascript modules into JS/Python to provide special functions. There are treated in JS/Python as normal modules which you can import in Python (see below). So, two built-in functions are already implemented using this JS/PythonModule technique: function PyModBuiltIns() { this.functions = { 'range': this.range, 'int': this.int_conv, } } PyModBuiltIns.prototype = new PyModule(); PyModBuiltIns.prototype.int_conv = function(params) { var number = params[0]; return parseInt(number); } ... The module is registered this way: jspy.register_jsmodule('__builtins__', new PyModBuiltIns()); For example reasons, I've already implemented some gimmicks by providing 3 methods: webby.js_eval, webby.ask and webby.redirect. All three methods are hooked (and hardcoded by now) into JS/Python. Example: import webby # provides all the dummy functions to compile the pyc file if webby.ask('Do you want visit google?'): # Runs an confirm(msg) .. webby.redirect('http://www.google.de') # Makes a window.location = url
Thanks for posting these tools.
&gt; I bet most new programmers want to learn the current codebase, not the older status quo. That's why I'm not studying LISP or Perl or other common but older languages. I bet all (new) programmers want to learn the language they will actually be productive in and that will be widely supported and understood. Now and in the near future. The python noob will have to stop right here and learn 2.X. Good luck in finding anyone who would advice you differently. In the meantime, make sure to check out the differences between Python 2 and 3. You will not find them shocking, i assure you. Lastly, you will always be coding against a status quo. Haskell, Python, C, Erlang, any language will release versions for you to work with. Stop and think for a moment why it works that way. 
Here's something to get you started: import socket # change the following LISTEN_ADDRESS = "" # blank means listen on everything LISTEN_PORT = 8888 # some port &gt; 1024 that isnt already used def main(): serverSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) serverSocket.bind((LISTEN_ADDRESS, LISTEN_PORT)) serverSocket.listen(5) while True: (clientsock, clientaddr) = serverSocket.accept() # do stuff with the clientsocket here...like reading/sending data
I agree - I prefer it to Qt as well. I have no idea why. I think that the people that use it a lot are immersed in it and around others that know their stuff. Once you figure a little of it out, it is not too bad - it is just that initial hill that is rough.
I just worked on the module system and outsorced my modules (except of __builtin__). You can find them here: http://dl.dropbox.com/u/92987/jspy/modules.js In addition I've added rudimentary support for HTML5's Web Storage and a Python example how to use this JS/PythonModule (see modules.js above for the implementation). You can run my Storage example from the website; the sourcecode is located here: http://dl.dropbox.com/u/92987/jspy/files/storage.py
Why did you change the port number to 289? that one's apparently already in use. 8888 from the original code should have worked just fine
[this](http://www.ibm.com/developerworks/linux/tutorials/l-pysocks/section5.html) may be a helpful continuation of what stoplight posted. client is telnet (in this example), so you'd have to write a client that connects to the server. 
Not sure how much you know about client/server programming, but generally the pseudocode goes like this: def runServer(): loop forever: connection = acceptConnection() serve(connection) #this method might, for example, spark a worker thread def runClient(): connection = connectToServer() connection.sendRequest(request) response = connection.getResponse() Don't be afraid to ask your professor how sockets work (during his office hours, maybe?) as I'm sure (s)he is more than willing to explain it to you. The basic idea is, well, to use sockets to connect 2 computers together, and then send and receive messages. The server waits for a request, and sends a response. The client sends a request, and then waits for a response.
Hm... I was lucky in that it was an internal tool ... still had a quite nasty installation batch file (I couldn't be bothered to learn an installer). Yes... tricky...
This line: serverSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) creates a new TCP socket using IPv4. This line: serverSocket.bind((LISTEN_ADDRESS, LISTEN_PORT)) will bind the socket to the specified address and port. Nothing else must be bound there. **Make sure the port number is greater than 1024 or you may run into errors** This line: serverSocket.listen(5) listens for incoming connections with a backlog of 5 (it queues up to 5 connections and any more than 5 connections will not be able to connect until you accept a connection from the queue). The while loop simply blocks until a connection arrives. This line: (clientsock, clientaddr) = serverSocket.accept() Will grab a connection from the listen queue and assign it to clientsock. clientaddr is the IPv4 address of the connecting client. At this point clientsock is of type socket and you can issue commands on it (e.g. send, recv). This is where you need to implement your chat server logic. As for the first error, you probably started the server too soon after shutting it down and the socket was still cleaning up. The second is not an error. The program loops infinitely waiting for clients to connect to it.
Have a look at tkinter.messagebox: Dialog Message askokcancel askquestion askretrycancel askyesno askyesnocancel showerror showinfo showwarning 
This works but the syntax I have doesn't work with it. Any hints?
I'm using confirm=tkinter.messagebox.askokcancel('title', "Are you sure ?', \ ICON=QUESTION)
nevermind, fixed it
Have a look at the [select module](http://docs.python.org/library/select.html). Then read this tutorial on using it to [build an echo server](http://ilab.cs.byu.edu/python/select/echoserver.html)... that should help you get an overview of what you need to do to get the results you want without giving you the answer outright.
.... "First you must invent the universe" ....
If the job isn't enormously complicated, you could use the [Python Imaging Library](http://www.pythonware.com/library/pil/handbook/). It's pretty good, with a nice pythonic interface, and it's quick since it's a C module. It can't easily do everything that ImageMagick can, but if your job isn't too complex, it has the advantage of being included by default in many distributions. Plus it's native to the python code, which has its advantages.
 (lambda time, thread, sys: (lambda args: ([ thread.start_new_thread((lambda i: (time.sleep(i), sys.stdout.write('%i\n' % i)) ), (i,)) for i in args], time.sleep(max(args) + 1)) ) )( __import__('time'), __import__('thread'), __import__('sys') )( [4, 1, 3, 2] ) The proper way to do it wrong IMO.
By the way, you don't need a line continuation if there's an open parenthesis. from tkinter import messagebox confirm = messagebox.askokcancel('', 'Are you sure?', icon=messagebox.QUESTION) 
 (lambda i:(lambda t=i('time'),r=i('thread'),s=i('sys'):(lambda *a:([r.start_new_thread(lambda i:(t.sleep(i),s.stdout.write('%i\n'%i)),(i,))for i in a],t.sleep(max(a)+1))))())(__import__)(4,1,3,2) compacted. 
I've never had PIL not recognise a file format, it supports over 30, but yeah it looks like neither of those are on the list, so you're right, PIL isn't for you. Unless someone's [written a custom decoder](http://www.pythonware.com/library/pil/handbook/decoder.htm).
oh? my CS teacher (Highschool) is wrong on yet another count. Thanks
Another tip for long lines is implicit concatenation of string literals. The bytecode compiler will join adjacent string literals as a single string. For example: &gt;&gt;&gt; print("This is treated " ... "as a single " ... "string.") This is treated as a single string. Note, there are no commas or '+' operators. 
nice
standard library helps a little with that from operator import methodcaller sorted(names, key=methodcaller('upper'))
I think incrementalizing the changes and putting in updated code to deprecate the old features still would have been better. That way we'd have something compatible with 2.7 syntax fully, but can just be upgraded using 2to3 with one pass. Example. `print ...` to `print(...)`. Just deprecate the old syntax, and put in the new one as a built-in function. The `__future__` module probably does a lot of this, though, and I'm not aware enough. The trouble is that 2.x is still the most common, so that's what I develop in.
yo,sup dawg, I herd you like interpreted language, so I put an interpreted language inter in your interpreted language so you can interprete while you interprete
Tastes great if you like eating shit I guess.
import universe Universe.universe()
That's awesome; I'm going to have a run at your work this weekend when I've some free cycles. Until then, accept my thanks for a job well done. This is a pretty neat idea.
&gt; I think incrementalizing the changes and putting in updated code to deprecate the old features still would have been better. This is basically how it went. 3.0 was a first pass, 3.1 got a lot better, and 3.2 got even better. All the while 2.6 got some of the backported features from 3.1, and 2.7 got even more features from 3.2. &gt; That way we'd have something compatible with 2.7 syntax fully, but can just be upgraded using 2to3 with one pass. Syntax-wise that's just not something you can have. The entire 2.x branch has to be backwards compatible in APIs and in syntax, and while the APIs may have slipped (and been fixed), the syntax can't. On the 3.x end of things, the entire reason to make that break was to simplify maintenance, and supporting dual forms of syntax is just something no one involved in the development end wants to get involved in. In terms of both APIs and syntax, the gap between 2.7 and 3.2 can generally be bridged with good success via 2to3. Any failure there is a bug and should be reported. &gt; Example. print ... to print(...). Just deprecate the old syntax, and put in the new one as a built-in function. The __future__ module probably does a lot of this, though, and I'm not aware enough. You are correct - `from __future__ import print_function` is available going back through 2.6. It wouldn't make sense to deprecate features at the end of an evolutionary period. 2.7 is the dead-end and making *that* version incompatible with 2.6 wouldn't be acceptable to anyone from a usability perspective. Instead, that's why 3.x exists in the first place. Backwards incompatible stuff is developed in parallel and people can take it when they and the tools are ready.
thanks
high school ?
troll is a troll but i thank god it's not my job to read code like that. 
Very impressive, though they code as if they have to pay a penny for each time they hit the space bar and get paid a dollar for each extra parenthesis. I couldn't work out which series they were using...?
That tastes at most like 1970s Fortran greatness. This thingie might be a great achievement in terms of mathematical thinking, but from the programming point of view it's a nightmare. +1 for the troll in your thread. EDIT: Programming is about mananging and reducing complexity, not creating complexity.
The solution I'll try today: Redirect download requests to a PHP script, called with 3 parameters: file path, real filename, content-type. :-( 
You should probably be using ['dcraw'](http://www.cybercom.net/~dcoffin/dcraw/) made by Dave Coffin as it supports CR2 and NEF and can easily export data to PGM format which is very easy to read. You can use command line options "-d -D -4 -j -t 0 -W -M" to export to PGM with completely RAW data (no color filtering, raw bayer matrix data). "-d -D -4 -j -t 0 -W -M -i -v" will print out information about the NEF/CR2.
This construction is not an endorsement of the style. I was writing Python even back in my C days, even back in my Applesoft Basic days.
Omg lol, you so totally went there and dont care WHO knows it. 
What's your expectation? How should people react to smartass code like this? This is not reddit/r/maths.
Have a look at [gevent-socketio](https://bitbucket.org/Jeffrey/gevent-socketio/src/1b7378eb1e62/examples/).
Might as well create an International Python Code Obfuscation Contest and make this the first entry. It is as unreadable as it is un-Pythonic.
Can someone explain why all these lambdas and reduces are supposed to be faster than imperative code with some `for`s and normal local variables?
Unless persons are standing in a queue, or a thousand other real-world use cases as to why you'd want to describe a sequence of people and work with them. 
If your object requires the behaviour of a list, it should inherit from the list class so that it can be used as a list with regular Python idioms. Re-implementing the wheel is stupid. &gt; But I do not really understand what you are doing. This pretty much sums up your contribution in this entire thread. 
Programming can also be about fun, and challenge. Nobody is suggesting that this code should be actually used for anything.
You want to [look here](http://www.asheesh.org/note/preso/post-pycon-2010.html). Specifically, grab these two: - [Cheat sheet](http://www.asheesh.org/pub/pycon-2010/scraping-cheat-sheet.pdf) - [Full slides](http://www.asheesh.org/pub/pycon-2010/scraping-slides.pdf)
"Many more"? Define many. I would say 2-3 for most of the larger libraries to move over and that is within the timeline they laid out.
If people *didn't* appreciate this news they would vote it down, or wouldn't vote it up. The community *has* voted on this issue. And by the way, you would be hard pressed to find a company that does more to support the Python community than wingware (relative to their size anyway).
"persons are standing in a queue" Then you'd put persons into a queue (two truly different kinds of objects), as the relationship between persons and queues is temporary or accidental, but not essential. 
"If your object requires the behaviour of a list, it should inherit from the list class so that it can be used as a list with regular Python idioms." Untrue. It _may_ inherit from the list class but there are other important options to consider (while remaining under the "regular python (&amp; common sense) idioms"). "This pretty much sums up your contribution in this entire thread." Ad-hominem attacks on public forums may haunt you later. You should refrain, if only for your own well-being.
Sorry... but could someone explain what these two Modules are and what they could be used for?
Two great tastes that taste great on pie. (Some had to say it.)
They aren't supposed to be faster.
 &gt;&gt;&gt; re.split(r'(?&lt;!\\)\.', 'foo.bar.1."2".file\\.txt') ['foo', 'bar', '1', '"2"', 'file\\.txt'] 
argh, you probably want "2.3" to be preserved, right? Not sure if that's possible with regular expressions...
I'd rather have a Pythonic contest and reject this entry.
Affirmative. That's what I did first, a negative lookbehind assertion.
What's the real problem you are trying to solve? That will make it much easier to recommend a pythonic solution.
What troll? I only saw posts making helpful comments and criticisms. The one asking about rounding errors and suggesting the lambdas are not necessary has a point.
What would you do with `test."so.me"thing`?
It's ambiguous, but it should probably resolve to: ['test', 'so.me', 'thing'] Although that's not a requirement, an acceptable alternative would be: ['test', 'so.me"thing'] As long as it is consistent. I'd like it to be as lenient as possible.
after re-reading this... &gt;The code contains absolutely no 'obfuscation', except the use of '+' for string concatenation. All the 'lambda's and 'reduce' and whatnot actually have to be there for the efficiency of the algorithm; to make the code run as fast as a straightforward implementation. I see, so it's not "faster", just "as fast as". But why then is it an example for "what good are 'lambda' and 'reduce'"?
I just thought if you would assume that there should be no such cases, you could combine strings after splitting with regular expressions (check first character of each part, if a quote - search for an ending quote and combine). :)
I am sorry you are having problems with the google group. I have been having problems too recently with posts disappearing. Try use the new interface vs the old interface. There are two problems here: - your version of windows seems to have a problem with the rocket web server + chunked encoding. I will forward the issue to the rocket developer. - The admin interface is disabled. If you are running off port XXX you can enable admin with: python &gt;&gt;&gt; from gluon.main import save_password &gt;&gt;&gt; save_password(raw_input('admin password: '),XXX) This will create a parameters_XXX.py file. It must be in the main web2py folder. Caveats, the admin interface is disabled if you are not form localhost and you are not using https. Hope this helps. Hope to have you back on the mailing list. 
I would strongly disagree that this code shows good use of lambda and reduce. I hope that the submitter and author intended it in a tongue-in-cheek manner of how they can be _abused_ to do something complicated with a small amount of code. Reduce and lambda should be used very sparingly, because they can usually be rewritten in more idiomatic, pythonic and readable code.
&gt; The basic notion is that these strings can be stored in xml to reference data from nested objects. Stored in xml to reference data from ...where? XML also? XPath FTW! Also, if you're just using xml for persistence, then transforming to/from JSON (or just pickling) is much easier than XML.
Bottle is a micro web framework (the best, single file). Web2py is a full stack web framework (does lots of stuff for you). Martin is working on merging the best of both worlds by porting some of the web2py libraries on top of Bottle, in particular the Database Abstraction Layer and the form handling.
I concur, but the strings will be used to reference Python objects, and I'm using xml for its hierarchical nature (not just for serialization).
I'm mostly surprised about the author's claims that "the code contains no obfuscation" and that the lambdas are somehow necessary. For me it's a very good example of intentionally obfuscated code.
Rocket developer here...transferring large files is something that I normally test. Having said that, I've made mistakes before. Keep us updated with what you find. I won't have time to look at this until the weekend sometime. Side note: Rocket is up to 1.2.4. I'm not sure if this would make a difference for web2py users yet. (I haven't had time to submit a new patch.)
Well, it looks like they have bindings for many languages: http://www.graphicsmagick.org/programming.html
Glad to see there are people out there who are interested in this :) Appreciate your feedback! Please keep in mind that it's not fully functional working since not all operands and parsing capabilities are implemented by now (e. g. long and float datatypes are not parsed yet). I will complete it asap. I'll keep you up2date if you like.
Maybe it's a little dirty, but I would use a magic string to protect the backspaced points, and replaced quoted string with another magic, in order to use split. After that, a little iteration to remove the magic, and it's all good
[Bottle](http://bottlepy.org/docs/dev/) is a micro web framework, and [web2py](http://web2py.com/) is a full-stack web framework. They are used for building web applications. This [web2tools](https://bitbucket.org/mulonemartin/web2tools) library integrates some of the web2py modules with Bottle, in particular: * The [DAL](http://www.web2py.com/book/default/chapter/06) (database abstraction layer) * [Forms and validators](http://www.web2py.com/book/default/chapter/07) * [HTML helpers](http://www.web2py.com/book/default/chapter/05#HTML-Helpers) (and [server-side DOM](http://www.web2py.com/book/default/chapter/05#Server-side-DOM-and-Parsing))
&gt; I concur, but the strings will be used to reference Python objects So `eval`?
Too powerful. I want some control over what can be referenced.
If you haven't already, try posting via the [new Google Groups interface](https://groups.google.com/forum/?fromgroups#!forum/web2py).
[Here](http://pastebin.com/69JkhVqj)'s my attempt. It's probably not much faster (if at all) but it's definitely more readable ;).
I agree. He doesn't specify _why_ the lambdas would make the could more efficient, I can only guess it has to do with the overhead of normal function calls; but if that is the problem you might as well code it in C in about the same amount of code with better readability.
Your code does look neater! Although I tend to prefer the approach of not using indices. Slight issue is that I think it will break with tokens that contain numbers at the start. i.e. foo.5bar should be two strings. Also it won't work with negative integers.
[This](http://pastebin.com/7mi47GXb) should solve both of those issues. Edit: A shorter, uglier, more generalized version: http://pastebin.com/7YrMe3RZ Edit 2: Your version is a lot faster though. [This](http://pastebin.com/up7vDhet) outputs: $ python2 reddit.py 19.6099359989 11.4123859406 
Have you considered using spaces instead of periods? Then you could call on shlex to do the work for you. Why your choice of periods? 
Periods felt natural since it is intended to reference Python objects. I wonder if I can configure shlex to use periods as the delimiter?
Wow, that's pretty compact!
You can. See [shlex.whitespace](http://docs.python.org/library/shlex.html#shlex.shlex.whitespace) and [shlex.whitespace_split](http://docs.python.org/library/shlex.html#shlex.shlex.whitespace_split)
&gt; â€¦ google group â€¦ Try use the new interface vs the old interface. I'm trying Gmane now, with the newsreader [TIN](http://www.tin.org/). I'm an old-timer. &gt; your version of windows seems to have a problem with the rocket web server I have to add 1 information: Windows XP is used locally for development. Testing and deployment is on a Linux server. Problem exists on Windows and Linux. Only difference: I've tried the newest version of web2py on Windows XP only. It's so simple to download the package, unzip it an run it. &gt; This will create a parameters_XXX.py file. This file already exists and I've tried tornado via anyserver.py with the same IP and port. With and without changing current directory to the web2py directory. But this was with web2py 1.91.6. Haven't found anything regarding this issue in the changelog, though. 
BTW, check out the attrgetter, itemgetter and methodcaller functions in the operator module before you re-implement too much. :) http://docs.python.org/library/operator.html#operator.attrgetter
Why would they help?
Ok, this is the fastest version I could invent: http://paste.in.ua/2611/ It's roughly twice as fast as yours. If you'll remove this check for negative numbers, it'll be 7% faster. :)
Ok, managed to make it 30% faster: http://paste.in.ua/2612/ Any other ideas? :)
A solution for this problem, using shlex: http://pastebin.com/gUatfkwS EDIT: It won't catch escaped parens well, and it doesn't anything that can't be done just by splitting with "." and removing empty strings. My bad.
Now you are just showing off. :-) Why do you pass in NORMAL, ESCAPE and STRING to tokenize?
Oh, that was an attempt to check if it's faster. But actuall 2612 is wrong. :( I'm trying to fix it. Btw, this guy is quite fast as well, a bit faster than 2612, but doesn't strip backslashes: http://paste.in.ua/2613/
Aha, this one is fixed, but it became as slow as 2611: http://paste.in.ua/2614/ I don't really understand why right now... no hardcode logic here.
Once I remove check on STRINGESCAPE, it because 30% faster. That's interesting. I'm wondering if I did everything in correct way, since I don't see how can it be made faster in this case... Well, by removing generator, maybe. EDIT: switching from generator to list collection doesn't change performance.
Because you use strings to look up arbitrary Python objects, just like you wanted to.
Cool thing, never seen this.
writing a bot are we? ;)
Last one has a flaw I'm afraid. Double quoted strings should have their quotes stripped. foo."bar" should produce ['foo'.'bar'] 
Oh well, I thought it should other way around, but that's easy: http://paste.in.ua/2615/
Sorry! That version turns "7" in to a integer, but it should remain a string.
Cannot be explained, because it is not true. The lambdas and reduces are necessarily to maintain performance while keeping it all as a single expression. The construction is a humor-type joke para lolz.
So if I understand the only constant is the browser? Let's move this discussion on the web2py mailing list so other users can help. 
Some idjit confused an iteration of quadratic convergence with a geometric construction. If the number of correct digits doubles with each iteration up to the desired number of digits, obviously you have successfully dealt with "rounding errors".
Very Pythonic. I indented.
FWIW, I prefer slashes as path delimiters.
In C you don't get arbitrarily large integers and Karatsuba multiplication for "free". Crank up the number of digits, eventually the Python version will beat the C version, if the C version multiplies naively. A C version with an implementation of arbitrary length longs and an efficient multiplication algorithm would be impressive, to me, if it had the same length. I have no idea how I would code such a thing, but I am not a C expert.
ah, certainly... http://paste.in.ua/2616/ it became a bit (3-5%) slower because of that, though.
Yes, this is for high school students. So far they have learned a few lines of code and they are learning very basic things. Going better than expected. 
Looks good. I wonder if checking that a string could be an integer is faster that way than with a try and except...
Based on the times I have interviewed newly-minted programmers, my pessimistic expectations are being met magnificently.
Is there a name for really impenetrable functional code, along the lines of "spaghetti" for imperative and "lasagna" (too many thin layers) for OO? 
Yes. The name is "Haskell". ;-)
I tested it, and it is twice as fast to do it with logic. I guess exceptions have a significant overhead.
I propose "Dysfunctional Programming."
Interesting. This could be very useful. There currently isn't really a GUI library for Python that is the clear winner for making truly native cross-platform applications. wxPython is about the closest thing that we have for making really native-looking applications that work across the three major platforms, and it can be a bit hard to use.
I'm getting this error when installing: ImportError: No module named distutils_extensions **UPDATE: PyGUI just got updated to 2.5.1. It works now.**
&gt; define many Maybe we'll get to Python 3 by the time we should start migrating to Python 4.
There's also [PySide](http://www.pyside.org/), which I'll admit I like better than PyQt (it's still Qt behind the scenes, but seems more natural to those who come from the pure Qt realm). Honestly though, by depending on Qt it means the install requirements might be larger on those platforms lacking native-Qt installs (Windows and Mac :-) PyGUI has a goal of being "lightweight", so that makes me interested in checking it out.
For something entirely improper, I'd have to say this is much better than my way. I'll have to try to follow this technique in the future.
Do you have it installed? This might be it: http://code.google.com/p/python-xbee/source/browse/distutils_extensions.py
I doubt it. In the setup.py file, there is this line: from distutils_extensions import pygui_build_py The file you linked to doesn't have pygui_build_py. EDIT: Seems I'm not the only one with the [issue](http://mail.python.org/pipermail/pygui/2011-June/000182.html)
&gt; (lambda i: (time.sleep(i), ...)) This is a horrible, horrible abuse of what python will allow in lambdas, imho xD
I think there are some tutorials on building some really basic apps (like an image viewer) on there. Would something [like this](http://developer.gnome.org/gnome-devel-demos/unstable/image-viewer.py.html.en) be helpful? I know that tutorial was written during the gnome3 docs-sprint. If that doesn't do it . . . you're probably right. I'm not sure what other tutorials are out there. Best of luck to you! 
I did NOT know that # was also called an octothorpe
as much as that's cool and I agree with a lot of it, programming is NOT the only form of interactive art EDIT: talking about the link, not you btw
The difference is the license, I believe. PyQt (developed by Riverbank Computing) is GPL, or a commercial licence can be purchased for use in closed-source applications. PySide (developed by Nokia) is LGPL, which means it can be used in closed-source applications for free. If you're developing under GPL anyway, it doesn't really matter which you use.
you have to look at the source code of the universe library and debug it beyond the point where there is any real code that wasn't written by you before you actually have invented it... unfortunately
That would be harderest.
There are ready made libraries to handle bignums, just like what Python uses. So instead of a+b you write something like bignum_plus(a, b). It doesn't make the code much longer. And length of code is a useless metric if you end up with an unreadable mess...
So? He posed a serious question that was based on a misunderstanding; hardly an argument to call him a troll. His other comment about why you would code this with lambdas as a one liner was very pertinent: you needlessly obscure (obfuscate) an otherwise elegant formula.
you're welcome !
I heard about the term ravioli code for OO, but I suppose that is the opposite: heavy objects that do too much.
&gt; There are ready made libraries to handle bignums, just like what Python uses. So instead of a+b you write something like bignum_plus(a, b). It doesn't make the code much longer. And length of code is a useless metric if you end up with an unreadable mess... What part of "5000 digits of Pi using Python built-ins in a single expression, when Python is known for purposely limiting the power of pure expressions, using an efficient iteration with quadratic convergence" don't you understand? ...Oh, I see, all of it.
I am accusing you of being a half-wit. Happily, you can prove me wrong by posting the code for a straight-forward efficient implementation of iteration in the paper, or another of equal or greater rate of convergence. Lets agree to meet back here in 5 years time. You can turn in your assignment in less time, if you wish. &gt; hardly an argument to call him a troll Yes, hardly an argument. Because it isn't an argument. It is an assertion. Like the assertion I am making that you are a half-wit.
Hardest Python is Best Python!
thanks... just used it as part of my deploy script, works like a charm
so whats better about this then other things like pygtk or pyqt?
"Linux - requires pygtk" is just a wrapper.
[Link without Google login](http://www.cosc.canterbury.ac.nz/greg.ewing/python_gui/)
"Python" doesn't need to be an adjective.
Is it really the case that we're up to Python 3 and still stuck lugging around Tk like 20 year old blender we've had since we were twelve and just can't bear to let go of, even though it's been in a cabinet for the last 18 years?
For people who don't know why python is or are just starting, describing something as "pythonic" only adds to the confusion. The language describing programming is obfuscated enough as it is, no need to muck it up more by being flowery with your wordings.
It is one that existed, improved. :)
If you're going to do cross-platform development, you should always separate the program logic from the user interfaces (it goes without saying). To build a modular application I'd recommend using some plugin framework. I've used [yapsy](http://yapsy.sourceforge.net/) in the past with good results, and I recommend it a lot.
One piece of advice. When thinking about applications do not limit yourself to desktop application (one user interface and one user). Think about an application that performs one task in background but can have many concurrent users. In other words do what you do best, create modules, then turn them into an application suing a web framework. Most modern web frameworks deal with storage for you, create user interfaces for you, and are more portable than regular applications (and can be accessed remotely).
A piece of object oriented advice in general: Devise a **System Context** in terms of **Actor Interaction**. In case you don't know, real quick: Actors are the people (customers, managers, admins) and computer systems (databases, servers) that comprise the entire spectrum of use for the application. Figure out what each actor does, be liberal and loose about it. Then you're ready to define a system context. A System Context is a precise understanding of what falls inside and what falls outside the scope of your program. It lets you define conceptual boundaries between the actors and program. This boundary is the interface. Let the interface be it's own layer and you can implement the GUI on many interfaces Once this is done, the course you sail your code-boat is up to you, but you'll have a high quality map to work with. Seeing as you're a PhD student, chances are you know this stuff and I've just wasted my time, but I'm always surprised when people don't know it, so I try to spread it around as much as possible.
Not terribly impressive. First, the fabulous argparse module, which is part of the stdlib since 2.7, is not used in his example. This would at least give him for free a comprehensive help function, handling of unknown commands, etc. And while the magic solution is certainly wrong, gathering the functions which should be exposed either via a module-wide variable (an array of function) or via an annotation would be fine in my book (certainly much better than blindly gathering all functions of the module).
pythonic is an adjective, and a pretty common one too.
Looking forward, I'd recommend targeting Python 3 and PyPy (using ctypes instead of the python c-api). I really foresee that PyPy will overtake python2.7 and python2.6 environments in the next two years. It is crazy fast. Pyglet works on PyPy, but Pygame isn't compatible so a new game framework that is compatible with PyPy would greatly help adoption. 
Thanks for the great info!
Thank you also, I'll look into all those links!
In Python 2, re-raising an intercepted AttributeError as a TypeError prevents `__getattr__` from running. In Python 3, however, any raised exception after an AttributeError seems to get swallowed, even RuntimeError and SystemError bounce you to `__getattr__`.
Obviously a v0.10 is released without an announcement on the mailing list: http://bottlepy.org/docs/dev/ See: https://groups.google.com/group/bottlepy/topics?start=10
Love the fancy scrollbar extension :)
[argparse](http://docs.python.org/dev/library/argparse.html)?
People in the same thread provided such alternative implementations, I don't see the need to do it again.
Doing something in a single expression is just stupid, it's not some kind of achievement. The quadratic convergence just comes from the formula, you didn't invent that. I don't see how Python is purposely limiting the power of expressions at all (statements are not excluded in order to limit expressions); it's just bad style to make long expressions.
Will adapt the example to use argparse. That's why I do it -- to learn -- so thanks for the comments!
So what's the alternative? "Doing things in a certain way which is designed and intended to work well within the confines of the Python programming language and using these to one's advantage"? "Pythonic" sure sounds a lot better to me...
I haven't messed with sqlite much but why is he using LIKE instead of =?
&gt; btw., what do you need those ints for? you pass the name/string to init, not a numeric value, right? The compression types are read as integers from the EXR file - the class is to map the numbers into human readable strings: if datatype == "lineOrder": return LineOrder(ord(value)) ..and to provide access to the integer values by name: if self.headers['compression']['value'].value == Compression.NO: ... 
Because ''like'' is a standard sql operator? I don't know your operator instead!
Yes, please do keep me up to date; I'll be checking the website of course. I showed it to several coworkers, and they were intrigued. My first thought was to port it to node/narwhal &amp; add integration libraries, much like your `webby` module. Very neat stuff. *edit*: also, do you need help?
Define your core application first. Don't even make considerations for the GUI yet or at all. Ask yourself if this core can be run on its own. Do you have sufficient interfaces? The frontend should be dependent on the core's interface, never the other way around. Take a look at some design patterns like observer, mediator, possibly strategy, and MVC for your GUI interface. There might be some platform-dependent considerations you may have to make. Select on windows for example only accepts winsock sockets meaning you can't select on file descriptors like you can on unix. 
How about "python-based" or "mostly python" instead of pythonic? I don't understand the infatuation with new words and acronyms in programming communities. 
Question: why would somebody choose Bottle over Django? Phillip.
I guess he wants to slow it down a bit. 
Because it is in a single file. The source code is really well written. Some people prefer micro frameworks to full stack frameworks and among micro frameworks it is one of the best.
I've only played with django, which seems big compared to this. How does Bottle compare to web.py and other micro-frameworks?
Holy Crap what is that! It's gorgeous!
micro framework doesn't mean single file... But I'm unsure what the advantages are over flask. The flask authors wrote flask as some kind of improved bottle. Wouldn't flask be better?
Because 'pythonic' is referring to the programming style, not the programming language. If you were to use your alternatives, people would assume that you were referring to how much of the code was written in Python.
great tutorial... 
It always depends on what your doing, I've used both bottle and flask and like them both. I think of Django as everything plus the kitchen sink; Good for full blown website development and has a large support base. And I think of Bottle/Flask as the goto tools for knocking out portable and personal web applications fast, while still being suitable for full blown web development. I can throw apps on a flash drive and run them anywhere I have python installed. My opinion is that choice of which framework to use is a personal one. Generally speaking, there is no such thing as "a better" framework. Although you may find one better suited for your specific needs out of the box, they all perform reasonably well. Any gaps can easily be filled with third party libraries and tools (Bottle + Sqlalchemy + memcached for example). 
Simply put, Bottle is the no fluff get the hell out of your way framework. 
&gt; As we use SQLite3 as a database, make sure it is installed. You need at least Python 2.5 to run bottle. No need to install sqlite.
You clearly don't understand what the idiom "pythonic" means; not everything done in Python is by default pythonic. Here's what Wikipedia has to say about it: &gt;A common neologism in the Python community is pythonic, which can have a wide range of meanings related to program style. To say that a piece of code is pythonic is to say that it uses Python idioms well, that it is natural or shows fluency in the language. Likewise, to say of an interface or language feature that it is pythonic is to say that it works well with Python idioms, that its use meshes well with the rest of the language. &gt;In contrast, a mark of unpythonic code is that it attempts to write C++ (or Lisp, Perl, or Java) code in Pythonâ€”that is, provides a rough transcription rather than an idiomatic translation of forms from another language. The concept of pythonicity is tightly bound to Python's minimalist philosophy of readability and avoiding the "there's more than one way to do it" approach. Unreadable code or incomprehensible idioms are unpythonic.
I think Like works the same as = but you can also use the wild character % for comparison.
Do some hobby projects to show what you can do and what you're interested in. Host code on github and have videos on youtube to show employers. Doing this really helped me get my current job.
Looks like it all takes place in [http://bottlepy.org/docs/dev/_static/default.js](http://bottlepy.org/docs/dev/_static/default.js). I was hoping to find the name of a jQuery plugin or something, but it might be custom. Great effect, either way!
Should be cited, I guess it's custom!
It is just a matter of taste or style and people like one or another for varied reasons Bottle, web.py, Tornado, webapp, tipfy and Flask are all fine small frameworks. They all do their job.
It is custom. I wrote it :)
The 0.10 version is the development version available on github. The last stable one is 0.9.4
They are using sqlite for the sake of the tutorial. Since Python 2.5 sqlite has been included in the standard library. Obviously you can use any data store you like. 
You've never seen this? SELECT id, task FROM todo WHERE status = '1' LIKE is for pattern matching: SELECT id, task FROM todo WHERE task LIKE '%groceries%' 
but he's not using wildcards
Will check it out. Thanks! 
great job :)
Thanks!
I didn't interprete the question mark as part of your question - i thought it was an operator called "=?" ;-) Of course I know "=" and also "like".
That's not what stesch meant. He meant that the sentence that he quoted is superfluous for the reason that he stated below, namely that you need at least Python 2.5 to use bottle, and that Python &gt;=2.5 comes with sqlite.
This is great, I do wish they were organized somehow (tags perhaps?).
Which industry? Robotics or software? 
Do you have any experience with either Pylons or Pyramid to be able to make a comparison to the others you mentioned?
Ahh that makes sense. I am not familiar with the system requirements for bottle. Thanks for clarifying!
More than anything, don't be afraid to contact people. Companies aren't going to scout you out and request that you come intern for them. The worst that can happen if you apply for an internship and don't get it is that you don't have an internship, which is where you are right now.
One tip would be to look into this much further in advance. You may still be able to find something last-minute, but the chances are much lower than they would have been if you started setting up your summer in March.
Not sure if I get the joke...
I can run it on my CGI only web host.
Flask, unlike Bottle, cannot use Python3 because of its dependencies.
Yup, added an example in the post
I love robotics very much but while out of school, I am working with Python.
It depends what you want to put on the website really. For Python web frameworks, there's many - Zope, Turbogears, Pylons and more - but Django is great. If you have a decent background in Python, you'll pick up Django in a few days. There's a book that takes you through setting up a project - it's a bit out of date now, but it's a great introduction non-the-less. http://www.djangobook.com/en/2.0/ The Django docs are also pretty decent. If you want a list of options, look here: http://wiki.python.org/moin/WebFrameworks You could also take a look at Google App Engine. You can write Python on it, it's very similar to Django, and it's basically free hosting for your app and database. 
You might enjoy http://python.mirocommunity.org/ which tries to bring together and organize PyCon and other wonderful python videos.
Is this solely content? I'm learning web programming too and you have to match the tech with the goal set in mind. You may not need Django if you're only making an online brochure. Put that up first quick - and then second rev could have more bells and whistles. 
A simple framework to start out on might be flask.
Okay, well this is pretty neat that you should mention it. I'm actually doing a college level internship right now. Where, you ask? Hillsboro, Oregon, a suburb of Portland. Talk to Intel, they do lots of internships, and they even do high-school level internships. I do have to ask though, how much experience do you have, what would you like to be doing, and when would you like to be doing it? I can tell you right now you won't be programming in Python.
Most companies aren't going to be that picky (or interested) if he's just looking for an internship. They just want to know that you're ready to learn, and are somewhat competent.
Thank you for responding. I live in the Clackamas area. I have experience in [RobotC](http://www.robotc.net/) which is a C-based programming language for robotics. And also I am working in Python. Right now, I am learning with the help of books and I am hoping to continue to teach myself throughout the summer. I like the language very much but if I have an internship wanting me to learn another, I would learn their preference as well. What languages do you think most internships will ask me to learn? And do you know if their are any websites, companies or organizations that I should submit my resume to?
One of the stated goals of PyGUI is to one day be included in the main Python distribution. If you want to see that happen (where it might then possibly replace tkinter): * start using PyGUI, * blog about it, * report any bugs you find, * help others to use PyGUI * ask on the ML for other ways that you might be able to assist PySide/PyQt, Wx, and PyGTK/PyGObject are not going to replace Tkinter. PyGUI on the other hand... 
that is not solely the main reason, i would like to learn in case in future i find a need for another website!
Okay, so here's what you can expect at Intel: * Good Hours * Perks * God knows what kind of work I'm working on regression testing for the wireless driver division. For me, that means writing in C#, Jscript, and editing XML, as well as working a little with VBScript. Most interns aren't even put up to these kind of tasks, but I work on a small team, so I do work comparable to a full time employee. I didn't know any of these languages when I started, so being a quick learner is a must. I've not heard of anybody using Python at Intel, but it's a huge spread of languages. Knowing the typical industry compiled languages (Java, C/C++) and a couple good scripting languages (JScript, VBScript) is a plus, but who knows? Not to mention, as a high-school intern, you'd probably be doing even less interesting work (sad but true). [Here](http://www.intel.com/jobs/jobsearch/index_js.htm?Location=200000016&amp;JobCategory=30160190084) is a link to the software engineering jobs in the United States for Intel. You should refine your search to the area you like, and make sure you specify internship. Like others have said, it may already be too late if you're looking for something this summer, but Intel is a very valuable employer. There's also a few microchip fabrication companies around, but that's not really up your alley.
As a heads up, most companies do not work strictly with Python. You will need to learn a few languages well to maximize your chances of getting internships. Does your school offer AP Computer Science? Looking through Wikipedia, it looks like Comp Sci AB was discontinued a few years ago, but if you learn that material on your own and can do the exercises in C/C++/Java/Python, you will be very competitive in the internship market ;). Also, make sure your GPA is as high as possible. Many companies use this, unfairly I might add, as a way to filter candidates. 
That sounds brilliant! You wouldn't happen to have that interpreter online would you?
There's nothing I hate more than having some upstart take the time to create something useful only to bloody share it with me when it's relavent in the vague hope they'll be rewarded for their efforts. Western civilization's favorite passtime is finding and denouncing no good shits and you sir should be commended for having found a stinker.
ah I see the confusion, sorry.
Very interesting :)
&gt; My mom wants a website django is overkill. look at flask or web2py &gt; so i am pretty good in python. makes me wonder why you need to ask the question. I guess you don't read much Python-related material. I'm new (2 years) to Python and I have at least heard about several frameworks to the point I said grumpily to myself a year or so ago "Jesus, not another framework...."
I use django on a daily basis, and highly recommend it. It's got a clean code base, lots of extensions, and a huge userbase. Plus, it's awesomely easy to use =)
How does this compare with Flask?
Django is excellent. Anyway, spend 5 minutes with it, then spend 5 minutes with web2py, then come back here and tell us, in your opinion, what will be easier to maintain for you and your mom. 
&gt; [PyGUI] is just a wrapper Being "just a wrapper" may or may not be a bad thing. The wrapper may provide a significantly more appealing API than the toolkit it wraps. And then, of course, since it *also* wraps *other* native toolkits on other platforms, the wrapper gets you nice cross-platform support. All with that same appealing API. (BTW, Wx is -- afaik -- *just* a wrapper, and seems pretty useful and popular.) 
Is there some place to download the actual presentations, paper or proceedings or do you only get them if you attend the conference? Its typically faster to skim through to see if there is any useful information. 
well the reason i am asking is that because i have never done anything web related, html php or asp ever. so i was not sure how much of web scripting is involved, i am currently reading the tutorials and find it easy flow for now
If you are looking to add another tool to your chest - I would definitely recommend Django as well. There is excellent documentation compared to many other projects, and you get to learn MVC! Your mom could also easily edit the content in the admin interface.
Would you mother be able to manually size images and upload them with an FTP client or will the ap need to take care of all of that? If you are looking to create something more CMS like, Django or Turbogears would be your best bet. Be aware that python ap hosting can be more expensive than php hosting. 
You need to learn HTML and CSS before you think about trying to learn these frameworks. They're not particularly easy at first even if you do know HTML and CSS, I can't imagine how much it would suck to have to simultaneously learn them both.
Looks good, thanks
Tips: - Use URL dispatch, as you did under Pylons. Ignore traversal. - If you are happy with Pylons paradigms, use Akhet, which is a Pylons- esque development evnironment for Pyramid. See http://docs.pylonsproject.org/projects/akhet/dev/ . It has a "migration guide" that helps map Pylons concepts to Pyramid. - Visit the IRC channel (#pylons or #pyramid on freenode.net) we can help in real time. Or ask questions on the pylons-discuss maillist. - Please try to put aside your Zope allergy for a bit, as there's really nothing in Pyramid exposed to end users that has much to do with "Zope". Pyramid uses Zope libraries, but does not expect its casual users to know anything about those libraries; it's purely an implementation detail. FTR, I am the primary author of the Pyramid docs. I'd like to know what I can improve, as long as it's reasonable. Also, there are plenty of folks willing to help in IRC and on the maillist. That said, we can't help the "don't wannas"; if you have those, nobody is going to be able to help you except you. Over time, I've found that lots of people who take it out on the framework tend to have this particular disease.
This. Ignore traversal, ignore resource trees. Just start developing with Akhet, which is a pylons-like thin layer on top of pyramid (just a project template/scaffold). As you become more comfortable with that stuff you will explore the other things like pyramid's great auth system which works with url dispatch as well.
Python 3 *right now* is not something we care too much about and neither do our users as far as I can see. We will eventually upgrade to Python 3 and with the finalized specification for Python 3 that shouldn't be too much work. I can tell you that Jinja2 was broken for Python 3 for a long time and nobody noticed or filed a report, despite Jinja2 being a dependency or recommendation for many libraries including Sphinx the documentation tool which makes me believe that we're lacking users on Python 3 in general, not just the web world.
Less features, but fits into a single file.
So you can do with Django. Django might actually be a better choice for CGI only deployments as many parts of Django uses on-demand importing.
&gt; But I'm unsure what the advantages are over flask. I really wanted to merge Flask and Bottle into one project, but defnull is opposed because he wants to keep Bottle in a single file and without dependencies which I personally don't like. I don't see the reason why to reimplement things we already have.
Thanks for the detailed (and quick!) reply. I've read the design defense document and several pylons-discuss threads, so I'm a bit familiar with some of the points you mentioned. Specifically, the issues I have with documentation: * Like Pylons, it feels more like a collection of HOWTO's, wiki entries, and recipes piecemealed together. I felt that the introduction of the Pylons book online greatly helped with this. Having everything laid out in a more linear fashion makes it much easier to follow. * The docs are very dense with new terminology that obviously has it's roots in Zope and reads like it was written by someone who was a Zope developer. I've read "[Application Configuration](http://docs.pylonsproject.org/projects/pyramid/1.0/narr/configuration.html)" probably a dozen times now and I still don't understand any of it. And that's the first meaningful chapter of the docs... * My favorite part so far is "[Much Ado About Traversal](http://docs.pylonsproject.org/projects/pyramid/1.0/narr/muchadoabouttraversal.html). Rob does a great job with a more informal (and approachable) writing tone. More importantly he backs up far enough from the subject matter that I'm not having to run to catch up, e.g. I immediately grasp the concept of the directory hierarchy on a web server. I'd rather the docs break things down Barney style and allow me to skim over a redundant paragraph or two, rather than having to refer to the glossary after reading every sentence. In short, there isn't enough hand holding. I understand that this might be a "won't fix" but I'm not a newbie when it comes to web dev in general, or Python/Pylons specifically. I know that documentation is the most thankless and least glamorous part of any OSS project. So I don't want to knock the authors' too hard. But I'm finding it nearly inscrutable and immensely frustrating.
Pyramid is a powerful and flexible framework, flexibility brings some kind of complexity. If you liked pylons you can also consider using TurboGears2 http://www.turbogears.org which is quite straightforward as a framework. While based on pylons the team stated here https://groups.google.com/d/msg/turbogears/OvaEYMhE2GQ/6PQBopGVKTAJ that it will be maintained. You probably just have to avoid accessing pieces of pylons directly due to the fact that it might be removed in the future.
I'm sorry if you think the docs feels like a collection of HOWTOs, wiki entries and recipes piecemealed together. I've personally spent a truly obscene amount of time on docs and we even paid to have them edited professionally by someone-who-is-not-me. I'm not really sure what more could be done given our current resources (save for moving our description of traversal further towards the back, which is a fair criticism). I'm disappointed that you don't understand "Application Configuration". However, a plain "I don't get it" isn't really actionable on my side. You might alternately take a gander at the quick tutorial at http://docs.pylonsproject.org/docs/pyramid_quick_tutorial.html . As far as traversal, you really should just ignore it. It's a fair criticism that it's introduced too early; I hope to move it to a later section of the book soon. But really I think you probably just need to break through your mental stop energy and write some code. Try.
why is it not on http://pypi.python.org? easy_install PyGUI would be nice
blobedit.py fails on Ubuntu 11.04 (python2.7) $ python blobedit.py Gtk-Message: Failed to load module "canberra-gtk-module" Gtk-Message: Failed to load module "canberra-gtk-module" /usr/lib/pymodules/python2.7/gtk-2.0/gtk/__init__.py:40: Warning: specified class size for type `PyGtkGenericCellRenderer' is smaller than the parent type's `GtkCellRenderer' class size from gtk import _gtk /usr/lib/pymodules/python2.7/gtk-2.0/gtk/__init__.py:40: Warning: g_type_get_qdata: assertion `node != NULL' failed from gtk import _gtk /usr/lib/pymodules/python2.7/gtk-2.0/gtk/__init__.py:40: Warning: g_ascii_strncasecmp: assertion `s2 != NULL' failed from gtk import _gtk Segmentation fault 
as a fellow documentation-writer a took a quick look, it seems like a lot of academicy and enterprisy words and sentences, remember that a lot of your visitors will have english as a second or third language so using words as "implies", "imperative" or "locality" in *important* sentences isn't helping for a big part of your readers. Its a good piece for us that already knows the terms non the less!
I don't think that's an issue here. The OP said he's an **experienced** python dev, which *imperatively implies* that he must've read tons of docs in English...
Read some papers on economics or lawyership and you may get his point. Sounds like you spent an obscene amount of time compressing the information and making assumptions about the readers interpretation of certain words. Fail.
&gt;django is overkill. look at flask or web2py Even that might be overkill, if it's real simple and will very rarely be updated, you can just use simple html/css. But, I disagree that django would be overkill (or rather, I don't think it being overkill matters in most cases) where flask or web2py would be acceptable. 
I have absolutely no idea what that means.
Now you know how Chr0me felt at your own writing. Still, fail.
Your comment history makes that criticism completely credible.
might be true, imho such things should not be called "gui toolkit". because it uses another toolkit. is just a bit misleading. for me personally it is an important information, that it wraps eg. pygtk, because that means it will produce "gtk" look and feel. there is no such thing as "native linux look and feel" and i may not like the look and feel of (default) gtk on windows. the website only shows mac screenshots, which i think is a bit ignorant considering one is developing a *crossplattform* *gui* "toolkit".
This must be your stackover flow answer here: http://stackoverflow.com/questions/4941145/python-flask-vs-bottle/4943851#4943851 I'm a big fan of the Pocoo projects like Sphinx and Jinja. Keep it up.
disclaimer: English is not my first language, and I started to learn python only 2-3 years ago so your main problem is the docs? while I agree the docs isnt quite satisfactory (for me), but I feel the complete opposite when reading the docs. IMO, It's like a giant theoretical book that only explains its concept and design with not so sufficient examples to get going. It's like learning music theories when all you want is just rocking on with your guitar ASAP. It's so intimidating. I think the official docs is meant as a technical book, not as guides/tutorial to get things done. IMO, we have to read it to understand/get the big picture about the framework. Pyramid really needs official 'getting-things-done' guides/tutorial to attract more users. I agree with others opinion on suggesting Akhet, ignoring zope/traversal stuff altogether. You also should seek small pyramid projects on github/bitbucket
Agreed.
Notepad++
In a way I agree. English is also not my mother tongue. Even though I consider myself very proficient in English, reading a large text with less common words makes it exhausting. *However:* Sometimes using a *correct* and *concise* word can save a whole lot of text. As such, there's also less text that can be misunderstood. If you understand the word properly that is... Unfortunately, such words are often the more "complicated" ones. Instead of "dumbing down" the text, it may be worth considering a translation workflow. If people who's mother tongue is *not* English are given the option to read it in a language that is more comfortable to them, they may have an easier time reading it. So they can focus on what's important: understanding the concepts of the framework. Not the language. Translating the docs surely has one big challenge: Keeping all the languages up-to-date. But I am convinced it would be an awesome bonus for the framework!
what?!
Writing with pyramid using Akhet scaffold feels very pylons like - i've converted on project and it took me 1.5 day to convert from pylons to pyramid using pyramid_handlers. I fail to see the issue to be honest, yes some things indeed changed but not that dramaticly that "an experienced pylons user" couldn't handle easly.
working with both pylons and pyramid, i think the real issue is he only thinks he is experienced
Is TG2 not supposed to be replaced by Pyramid? As far as I recall, the devs of Pylons and TG are now working *together* on Pyramid, and TG2 and Pylons have - as a consequence - been deprecated.
Coulds look for an online service whats ams format code. This codes would be parse into colorations from something like HTML tags, not on-the-fly in editor. Pygments ams one I knows of.
No, i've switched from pylons to pyramid with great success, porting one semi big project to it. No issues at all. Learning curve wasn't that step as one would think after i've read all the documentation. 
10 minutes [Confusion](http://www.youtube.com/watch?v=kLwrdp8RV5A) for you both to clear your minds. 
[pygments](http://pygments.org/)
Go for CherryPy or Bottle. Thin, efficient and not coming into your way.
Not sure if on my side or just trolling.
You are a god
Something I've been wondering, they didn't record PyCon US 2011 tutorials this year?
When I read about Pyramid and the answers here, all I see is layers above layers above layers above layers â€¦ 
Are your grammatical errors on purpose? Are you a novelty account? If not: You would say Pygments is one that I know of. etc etc
I've found the documentation really impressive. It was one of the reasons I decided to stick it out with Pyramid. Good work and keep it up.
IDLE2HTML is an extension for IDLE that exports code with syntax highlighting in HTML format. 
As a new web developer, can you walk me through the reasoning to conclude that Django was not a good fit? I only know django so it's hard for me to compare options out there.
There's always webpy [http://webpy.org]
Bottle is one of the fastest frameworks out there and includes various optimizations for CGI and Google App Engine environments. I really doubt that Django is "faster" in hat regard. 
Novelty account. He gets kind of annoying.
&gt;Pylons book online greatly helped with this. What the pylons book did for me was teach me how all those pieces fit together, wsgi, paste, webob etc.... [Chapter 3](http://pylonsbook.com/en/1.1/exploring-pylons.html) Particularly the sections "How HTTP Works", "Exploring The Environment", "The Request and Response". I don't think there's anything similar in the pyramid docs, at least all together like that. But, I don't think the docs were targeted at the beginner web programmer either. Obviously if you are developing for the web, you should know what HTTP is and how it works. So covering that in the pyramid docs may seem to be a waste of time. What's cool is, that information is still applicable in pyramid because pyramid also uses wsgi, paste, webob etc.... Alas, I think I see where you are coming from even though I think the docs are great for my purposes. Perhaps a guide more in the style of the pylons book is in order where the reader is assumed to be a programmer but not necessarily a web programmer. I can't understand your criticism of the Application Configuration Section though. It's short and to the point, and the code examples are short enough you could recite them from memory. It doesn't strike me as zope-ish but more software engineery, though I have not heard the term "locality of reference" used much, the subsequent sentences describe what that means to the author pretty well in my opinion. other frameworks that use decorators for view configuration probably don't even bother explaining why it's good to do it that way(better locality of reference for one thing). FTR, I fled pylons to repoze.bfg because I couldn't break up my apps the way I wanted to and I found bfg offered a lot more in terms of flexibility and it stayed pretty much out of the way most of the time. Needless to say, I was pretty happy when pyramid was announced. 
Completely tongue in cheek. You were being a dick. :P
It's free advertising, regardless of what content the site has.
I don't get it though, he just replaces pro-nouns with ams. That's not funny?
Even better. This is great. Thanks.
Would it be any different if he'd used IRC as the medium to help people out, hoping a potential employer was present? Have you sent Reddit an angry letter yet for turning *your* presence and contributions into a commodity the Conde Nast corporation can purchase, without even compensating you? Of all the shit you can be faux outraged about surely you can find something better than some nerd helping other nerds out.
i know what this is. its the "lofty lingo" problem. I have it a lot. When writing docs, especially once you get going, it's easy to just start using higher level linguistic constructs to get across the reality of the library in a non-ambiguous way. But then you've just sounded like a college professor and there's a real block there - these days, as I'm writing a book, working on a chapter for another book, and always writing more docs, I'm often being told about my "professorial" tendencies. But I also remember having an argument with a co-worker, back in the 90s, that I couldn't understand any of his docs because of the same issue (he was hyper-educated), to which he replied something along the lines of "so ok 'HEY MAN HERE'S LIKE, AN XML FILE AND JUST CODE IT UP YO'", let's just say the conversation didn't go well. I know I'm not giving a solution here but there's something here, would be nice to identify, codify, work out the correct course of action to take either on the part of the documentation author and/or reader, when this "lofty lingo" issue is identified. Edit: so i think what happens in that section, the word "imperative" just blows away some readers pretty quickly. I'd do it like, "One way to configure is to have all the information about how to map URLs to view functions all up front, typically in one single Python file. Such a configuration may be called "imperative", i.e. a series of statements to define the program state. This may be fine, but it introduces the issue that you might find yourself flipping back and forth between a particular set of view functions and the configuration module that links them to their URLs. For this reason Pyramid offers "configuration decorators", that move the association of URLs to view functions to the view function itself. (example of decorator). To use a decorator, Pyramid needs to scan for all of them when the app starts up. (do the scan thing). The configuration decorator approach can be said to provide "locality of reference" to application configuration - everything you need to know about a view function contextually is right there next to it". So the two "fancy" terms here, "imperative" and "locality of reference", are supplied *after* you describe in very simple terms what we are doing. Then when you name the term, the programmer goes "Aha !" and tags that term to the concept they just learned.
It's different sitting in IRC explaining concepts to people. The guy was literally just sending links to his site in every comment. Would it be any different if I started linking to amazon affiliate links to books?
Not at all. I'd be happy amazon went out of their way to reward you for pointing me in the direction of something I evidently felt was worth purchasing. The IRC based analog would be him linking you to his blog every few lines which is just a way of saving time, which now has me thinking what if this guy copied the pertinent entry from his blog verbatim, posted it here (instead of linking to it) only for you to google it and then start insinuiating plagiarism. You'd probably start asking him to just link to his shitty blog.
Not really. Plagiarism isn't on my list of things to battle. My internet superheroism includes only free advertising and soggy cookies.
Currently TurboGears2 project management has been took by Michael Pedersen which has gathered a new team of people that shares the idea that a technology change might harm the project like what happened with the cherrypy to pylons switch and so is committed to giving new life to TG2 as a standalone project. A new high level framework based on pyramid and probably named Orion might get life sooner or later made by some of the members of the previous TurboGears team, but still nothing released or visible around. 
It got cut out of the AV budget, is my understanding. Budgets gotta get adjusted somehow...!
TG2 was planned to be deprecated with pyramids. I believe, however, there are a few developers who felt that pyramid obfuscates web development and have tried to resurrect TG2.
[TurboGears2](http://www.turbogears.org) is a really quick to grasp and flexible web framework. You might consider giving it a try. The [Explore Quickstart](http://www.turbogears.org/2.1/docs/main/explorequickstart.html) documentation section gives a nice overview of a TG2 project structure. Also for your case you can consider using [stroller](http://pypi.python.org/pypi/stroller) which is an easy to embed eCommerce for TG2 projects.
Adding additional operators and slicing would be the final blow to Matlab. Python will be able to do everything Matlab does with a comparable syntax. 
How big is 'semi big' One of my apps has 234 controller methods and 144 mako templates.. not looking forward to having to update all of that :-) When I do I'll probably end up writing a program to do most of the busywork for me.
I'm mildly embarrassed to admit that although having been using py and django for a little while I had no idea TurboGears existed. Thanks for posting the ad, I'll be giving it a try. Gratz on new release as well.
via: http://coder.io/tag/python
I've created a public github repository to manage the project: https://github.com/flosch/jspy Once I've committed the source to the repository, feel free to send me patches or feedback , if you like to work on JS/Python or want to improve its libraries. It may take several days or so until I publish the whole source - I try to comment the sourcecode as much as it would need to get easily into it and try to almost complete the parsing procedure and bytecode operations. In the meantime I will publish the other available sourcecode (especially modules.js). :) Related to node/narwhal: I don't know them, but I will take a look on it! :)
Hm, not so much in the graphics area. Using them did make me think I wanted some sort of jquery style api that would work with gimpfu or other backends. We were doing batch processing, where the original images, and even intermediate steps or the output could have been the same between operations, so lazy evaluation would've been nice too).
What exactly do you mean by 'an application' ?
http://en.wikipedia.org/wiki/Dethklok#Skwisgaar_Skwigelf
thanks for the lolz. 
Just today I read (on reddit) that TG is being deprecated.
The documentation for Pyramid is invaluable. It took me a little while to wrap my head around the concepts but overall I really like Pyramids. Thanks!
I am not the op, but I figure I can put in my 2 cents here. I've used Django in the past for projects and it has always seemed like it is massive overkill. It includes pretty much everything and the kitchen sink, and while that is fantastic for a lot of projects it also means it has a high computational overhead compared to others. Pyramid is light and you can bolt on the stuff you want/need without it getting in the way. I've always found Django to be extremely overwhelming and Pyramid just fits in my brain better.
[a2ps](http://www.gnu.org/software/a2ps/) -g -E myscript.py -o myscript.ps does the job for me...
You mean Pylons?
[No.](http://www.reddit.com/r/Python/comments/i3fo6/as_an_experienced_pylons_dev_pyramid_is_melting/c20lidg) But some replies cleared it up as I see now.
TurboGears 2 is built on top of Pylons 1 which is superseded by Pyramid.
Thanks for the suggestions. 
This is the ultimate compliment one can receive for something such as this. e000 should be proud.
I have never heard from any of the existing TG2 developers that they feel that Pyramid "obfuscates web development". Unless you yourself are a TG2 developer, that's your spin, not theirs. TG2 development never stopped, nor did anybody expect it to stop with the release of Pyramid.
Use vim to output to pdf. Here's the beginning of a shell script. You probably want to loop through each file and pass to your printer #!/usr/bin/env bash # the temporary directory to use tmpdir="/Desktop/shellprint" # make sure the tmp dir exists mkdir -p $tmpdir VIM_APP='/Applications/MacVim.app/Contents/MacOS/Vim' PDF_FILE=$tmpdir/`basename "$1"`$RANDOM.pdf PS_FILE=$tmpdir/`basename "$1"`$RANDOM.ps $VIM_APP \ "+set number" "+syntax on" "+color slate" \ "+set printoptions=number:n,paper:letter" \ "+set printfont=DejaVu_Sans_Mono:h10" \ "+hardcopy &gt; $PS_FILE" $1 "+q" ps2pdf $PS_FILE -o $PDF_FILE
It should honestly be the only way to do this. Don't even steer readers to the possibility of parsing by hand when argparse does everything for you. 
no not that big, the app ive migrated was about 100 controller methods . but i also have to maintain an app that is ~70k LOC so i know your pain, we havent decided when if ever we want to migrate that ;-) so far pylons is working fine for us too.
I don't understand why you keep submitting stuff where there's absolutely no code to see.
Does code imply legitimacy of a programming related post? This post is a short introduction to a wrapper whose code will be released soon. Is there a problem with that?
probably something like: def read_file(filename): numbers = [] with open(filename) as data: for line in data: numbers.append([ int(i) for i in line.split(',') ]) return numbers
&gt; Does code imply legitimacy of a programming related post? Yes, at least if you're taking about something like this. It's more or less pointless to talk about something you're going to release or considering to do. You could do away with the code, if you're talking about the process of coding but not much else. If you talk pure computer science then "no" you don't need code, math will do just fine, but this is programming. This however in programming the end result is always code.
In addition to Django and some of the others mentioned, definitely check out [web2py](http://www.web2py.com). It's [very easy to set up, learn, and use](http://www.web2py.com/book/default/chapter/00), yet is quite full-featured and powerful. It includes a web-based IDE ([demo](http://www.web2py.com/demo_admin/default/site)) with a new-application wizard ([demo](http://www.web2py.com/demo_admin/wizard/index)), a web-based database administration interface, [jQuery integration](http://www.web2py.com/book/default/chapter/10) for AJAX, and a scaffolding application. Other notable features are [components](http://www.web2py.com/book/default/chapter/13#Components) and [plugin_wiki](http://www.web2py.com/book/default/chapter/13#plugin_wiki). It runs on Google App Engine out of the box (including the database abstraction layer), and it's easy to deploy apps to GAE via the IDE ([demo](http://www.web2py.com/demo_admin/gae/deploy)). To try it out, just [download](http://www.web2py.com/examples/default/download), unzip, and run (the Windows and Mac binaries even include their own Python interpreter). If you need any help, there's a very friendly and responsive [mailing list](https://groups.google.com/forum/?fromgroups#!forum/web2py).
While I do understand the importance of code, I just couldn't find a way to put any in this post. This is the first installment and I have only tried to explain the motivation behind Shiv. I think if you read the article more keenly you will realize that with the amount of info that I have dispensed about Shiv, providing code sample would not have been possible. However, I do plan to elaborate on Shiv more in the near future aided by code samples and hopefully a test application. I hope you understand and remain patient for the upcoming posts. I have found Shiv to be extremely helpful to me and hope you guys will benefit from it too in some way or other. Thanks
I would agree the Shiv looks interesting, it seems to address at least one of the issues I have with Django, but it's pointless to write about code that you may release, without it we're just two people with a similar issue. It's very hard for someone to tell if Shiv would actually be any help without at least snippet of code that shows how the problems is mitigated. The point is that your post does not help anybody, because there's no hint of a solution to any thing. You might have helpful code or insides, but you reveal nothing. Code would be a quick way for other people to determine if you actually have something of value. 
Or use a list comprehension: def read_file(filename): with open(filename) as data: numbers = [[int(x) for x in line.split(',')] for line in data] return numbers num_square = read_file('numbers.txt') You'll want to replace 'int' with a conversion function that handles exceptions (i.e. ValueError), or stick to using the for loop and handle the exception there. 
&gt; I would agree the Shiv looks interesting, it seems to address at least one of the issues I have with Django Thanks for that. I hope this means that you agree with the basic idea behind Shiv. Keeping in mind your comments, I will try to push a bit harder and publish more stuff complimented with code examples as soon as possible. I will keep you updated of all the developments related to Shiv.
You won't need to publish all code at once, but throw in a small snippet or two, sort of like "This is how Django does it" and "This is how I believe it should be done". You'll also get the add bonus of people being able to help with commenting on syntax and uncovering edge cases. 
The syntax in the operator proposal is awful.... ~+=, ~*=.. etc. This kind of thing would turn your code in to a bunch of symbol soup in the vein of Perl.
&gt; Is this a good idea to append an item to a list currently being worked on? From my experiments it seems it takes the original object as a whole and does not iterate through any items added to it during the iteration, so it seems to be ok? It just doesn't feel right. list.append operates in constant time, so it's fine. see this document on the [time complexity of python data structures](http://wiki.python.org/moin/TimeComplexity). **edit**: just realized you're operating on the same list. The numSquare.pop(0) will operate in O(n). See eryksun's version for a better way to do it. 
I think there's a difference between "wrapping" a library (like how PySide or PyQt wraps Qt), and actually being a new API that uses another library under the hood. If you wrap GTK with Python, when programming you're basically programming GTK (I think) but using Python. When using PyGUI, it's PyGUI -- your code doesn't look like GTK, Win32, Cocoa, or something else -- it's PyGUI. 
everything on reddit is true :)
These proposals are small things that'd make my everyday code a little nicer. I find them sound. I'd even be happy to see a more radical feature: custom operator literals through a generic protocol that can implement all current operators. There's a lot of good uses for operators that aren't what Python language implementors would want to think about.
After seeing this I realise that I don't have to store the output of the split method before using objects inside it! Wow, that's crazy useful. Thanks. Prior I was thinking that I'd need to store anything split with split() and *then* iterate through the objects.
@AeroNotix, in the actual file are the numbers delimited by spaces instead of commas? for item in numSquare: numSquare.append(numSquare.pop(0).split(' ')) As sibsibsib points out, popping off item 0 is O(N), which makes this overall an O( N^2 ) operation. There's no reason to mess around here with in-place mutation since it's better to build the list the way you want it in one pass. However if you needed to do something like this (i.e. pop(0) and append), you should use [collections.deque](http://docs.python.org/library/collections.html#collections.deque) (pronounced 'deck'), a double-ended queue. It's listed on the time complexity page that sibsibsib linked.
Hi Jenner, I also consider myself an experienced py dev with English as second language. Even with years of experience reading docs in English, I find "imperative" a difficult word, that I did not understand when I read this specific paragraph.
Strings are immutable, so many string methods return new string objects and can be chained, such as `mystr.strip().lower().replace('\r', '').split('\n')`. You can use any object in place without assigning it to a variable, but watch out for mutable objects. For example, remove and append return None. The following raises a TypeError: `', '.join(mylist.append('3'))`. It's the same as executing `', '.join(None)`. 
Yeah because ams annoying to get the right answers. Did Pygments works?
Interesting, I'm 100% with you on the in-place and mutable object stuff. I've re-read the chapters in *Learning Python* and it's all just gone **click**. Thanks again! If I may ask, how are you so adept with Python, yet manage to post in every single thread? What job do you have?
Try modifying some PyGame examples. It's a good way to jump into coding, it's nice to see things happening on the screen when you code.
I'm not a professional programmer. But I did do reasonably OK in a double major in electrical and computer engineering before grad school, so I'm not *completely* clueless when it comes to CS (just mostly clueless compared to many folks around here). I probably do post too often lately, but maybe I've helped more than I've annoyed.
i think python is a great fit for writing a roguelike. check out this blog article, it has some solid advice and a bunch of links that will interest you if python is your language of choice. [How to write a roguelike in Python using libtcod (#1)](https://kooneiform.wordpress.com/2009/03/29/241/)
It appears you have forgotten to post a link....
Making database drivers "batteries included". At least the open source ones and ODBC would get people out of trouble.
Awesome, I'll watch this. I almost certainly will be making pull requests; I mostly work in Scheme &amp; C, but do quite a bit of consulting in Node &amp; Python, so I'd be happy to help out with core or libraries. The reason why I mentioned node (an event IO framework for Google's v8) &amp; narwhal (a server side framework for Mozilla's Rhino) is because I'm currently working at a mostly Python company, but a good portion of what I'm working on consists of Node.js based middleware. I didn't start the project in JavaScript, someone else did. I was thinking it would be neat to use something like this, but add traces that compiled to JS functions (similar to how the Mozilla guy published a few months ago), so as to avoid having "yet another language". It's an interesting project, most certainly. *edit*: [this](http://weblogs.mozillazine.org/roc/archives/2010/11/implementing_a.html) was the article I was thinking about, when I was talking about adding traces that compiled into JS functions. I think it would be a neat idea.
Link: http://david-web.appspot.com/cnt/KrowtenEmagyp/
Indeed!: http://david-web.appspot.com/cnt/KrowtenEmagyp/
Not 100% sure yet, but it has to be used by non-techie people. I wanted general information about making applications so that when it comes times to choose how to do it, I have the information needed.
I'm currently attempting something similar to this. My goal is to eventually have an RPG that combines elements of Chrono Trigger (party-based combos, unrestricted movement except for on world map, central teleportation hub) and Breath of Fire (Special abilities on-map like Ninas bird form, combining characters into different morphs) I'm actually having a very hard time finding the information I need in regards to program layout, inheritance hierarchies, etc. I already know how to do animation in PyGame, I already know how to do collision detection, etc -- I just don't know how to actually go about organizing the game structure in order to get started. (I've never actually had to build my own classes to inherit from, I've always simply inherited the things I needed to from existing libraries like wxPython)
There's nothing in Django that precludes you not being able to develop simple websites. I've used it in everything from 2 hour projects to extremely large projects serving millions of users. 
If you have to develop the user interfaces, it would be a good idea to follow the advice in some [HIG](http://en.wikipedia.org/wiki/Human_interface_guidelines). The [HIG for Gnome](http://developer.gnome.org/hig-book/stable/) is quite sensible, but you might also want to check [the one for Windows](http://msdn.microsoft.com/en-us/library/Aa511258.aspx), if you're going to develop for that platform too.
Wow great find there, thanks!
I downloaded pygame 1.9 and a compatible version of python (I believe 2.5.4) and am starting to look at some demos. Thanks
Sounds ambitious. I think an RPG sounds difficult with all the dialogue and story elements involved in a large world. I'm personally trying to recreate a modified version of crawl's stone soup. Randomized dungeon layouts so each game is different, potions and gear thats unknown until identified, a simplified version of the monster AI. I think the dungeon layout creator is going to be hard to work out, but I have some ideas about going at it (making a randon selected number of random sized square rooms get drawn in space, then a method of creating tunnels/corridors connecting and overlapping the the existing rooms, then a method of randomly selecting items from a database that can be placed on that particular depth of dungeon in these rooms. In my head its a bunch of simple ideas but I'm sure I'll running into brickwalls immediately.
I fundamentally disagree. I'm a non-native speaker of English, but my understanding of technical terminology is far better in English than in my native language. My problem with the Pyramid docs chapter linked (Application Configuration) isn't that I don't understand the words. I don't understand the way in which they are used. At least not intuitively. Other frameworks don't talk about plugging your code into the framework, they talk about using their framework in your code. They don't call a minimal application an example of imperative configuration either. A lot of the terminology is rather unique (I have no experience with Zope, so I can't tell whether they really are Zope-isms, but it's definitely different from Pylons, Django, Flask, Java Servlets and PHP). The language is very dense, no matter which language you translate it into. Also, I found that a lot of the uses of the word "implies" feel weird. INI files certainly don't "imply" any configuration in most frameworks. If anything, they _supply_, provide or define it. It's not the language. It's the way it is used.
Of course you didn't. Because you only understand the meaning if you realize that it's intended to contrast with "declarative" (this is the way these terms are also used in SQLAlchemy, for example). Of course the distinction doesn't make any sense unless you know there is one, so the use of this terminology isn't helping in any way. It's not adding any information (other than the hint that there might be some kind of declarative configuration (... implication... or whatever) coming up next). Compare the language with that found in the Django or Flask documentation. Some of the concepts (many of them, I would assume) are quite similar, yet Pyramid's language is very distinctly unique.
No Zope-isms in here; I'd hate to see Zope blamed for my writing style.
You've got even tougher requirements than I have. :) Path finding algorithms are going to be tough. Procedurally generated dungeons even tougher (though more rewarding). Generated items will still need stat tables for min/max stat allocations - which is tougher than just a gear list because you have to look for fringe items that could throw off balance.
Regarding path finding for my monsters, Im thinking if they arent in view, they will be "sleeping". Once in view, will need a line of sight algorithm to determine if they can see the hero and begin approaching while factoring in collision detection on the walls. I think this will be the most difficult part, but I've seen public examples of line of sight algorithms for similar projects. For the generated items and stats with each item, I feel somewhat confident about. A big part of my background is doing lots of database work, if python lets me work with linked tables of some sort then I should be good here. Like you said though, balance will need found for certain types of possible enchantments that can be found. Thats probably step 300 though and if I get that far I'll be really happy! (planning for this to be completely 2D, topdown view)
:) I've used my intuition NOT my experience (I'm not that good). However, if you want to see code, check [TinyPy](http://www.tinypy.org/), [pypy](http://pypy.org/) and [luaJIT's FAQ](http://luajit.org/faq.html) 
 Thanks, this is very great/helpful information. I have a question though. You are a **great** help. *Will I be expected to already know their preferred language or will I be able to learn the programming language that the job requires while working(after I am hired)?
You've helped me more than once!
Yeah, well, I'm not sure what you're talking about with these O(n) operation stuff and I've consumed way too little coffee this morning for it all to make sense. I *am* at work though, which is where I do most of my best Python learning ;) And yes, they are delimited by spaces in this case, I just have some other data delimited via ', ' .
Can you do this with Django (this is an extremely simple REST-style wrapper around the EC2 API)? https://gist.github.com/1035249 Of course you *can* do that in Django ([see this example](http://olifante.blogs.com/covil/2010/04/minimal-django.html)), but I think it's fair to say Django isn't built with the intention of doing that (and it would be a bit of a headache to turn that into a larger "proper Django project" vs the Pyramid example which *is* a "proper Pyramid project").
I knew none of the languages that they now want from me. I don't think they would even test to make sure you know any specific languages. The way a team at Intel works is this: You've got some group (like, mobile wireless group, for example) which has a manager, and several sub-managers for each sub-group (WiMax, Bluetooth, Wifi). I was hired by one of these sub-managers, but I got put onto another sub-manager's team. What you'll be doing depends entirely on what your direct supervisor needs when you come in. It's not set in stone by any means (they wanted to just put me on simple testing before they realized I was a decent coder). When I was hired, I was in a new hire group of 1,600, 150 of them at my campus. My group employs 1,100 in Oregon and Israel. Just to put things into perspective. Intel is big. Again, my guess is that if you're entering as a high-school level intern, you won't be doing much at all. It's not about that though. Once you've gotten an internship at Intel, life gets a lot easier (I'm fairly sure I'll be able to remain at Intel after I graduate this December). In short, no, you'll probably be okay so long as you can show them that you're adaptable. Just apply as soon as you can. PM me if you've got questions more specific than this.
I am not sure: Symbol soup is a pretty subjective term. Someone not used to numbers, simple arithmetic operators, colons, parenthesis would see Python and think it was a "symbol soup". I think the problem here is *unorthodox* use of symbols. The symbols used in Python are familiar as they are taught in elementary school and other contexts.
You could set up logging with a [MemoryHandler](http://docs.python.org/library/logging.handlers.html#memoryhandler) with the target set to NullHandler. This will buffer the log messages until the buffer is full then send them to the NullHandler, which will throw them away. Then if you get an unhandled exception or other error condition that you want to log you set the target to a FileHandler, flush the MemoryHandler then set the target back to NullHandler. This will result in the events leading up to the error being logged, and everything else being thrown away. There is a potential issue - the MemoryHandler buffer could have filled up and been flushed just before your error, so you get little or no logging recorded. If this becomes a problem you could write your own MemoryHandler variant that uses a fixed-length [deque](http://docs.python.org/library/collections.html#deque-objects) for the memory buffer, and only flushes it when explicitly told to.
1. Get a Mac. It is the only system that will comfortably allow you to run all 3 main operating systems (considering *nix as one). 2. Learn as much as you can about MVC and MVP. 3. Decouple GUI code from app logic. Make GUI code as dumb as possible (getters and setters for complex GUI components, GUI events translated into higher level app events, etc). 4. Learn about py2exe, py2app, cx_freeze and use them from day 1. 5. Develop on one platform BUT test as frequently as humanly possible on all relevant platforms. 6. Externalize platform specific stuff by using a solid cross-platform GUI toolkit. 7. I prefer to bundle everything (kinda like statically linking in a C world). This loads the user's system with some MB but simplifies dependencies handling by an order of magnitude. 
How about posting some output from the crashing server? A few things: * Should "s.send(..." in the server be "clientsock.send(..."? * Shouldn't "c.resv" in the client be "c.recv"? * The server should probably use "clientsock.close()" instead of "s.close()" * Your client will probably never cleanly shutdown because it expects a response from the server when it transmits the empty string (and the server subsequently kills the connections.) * The "bool(rawinput(..." bit probably doesn't work like you expect. If you type anything, you'll get the server; only the empty string gets you the client.
"Native-looking apps" sounds good but I think its value is frequently poorly understood. Besides some very frequently used Open/Save dialogs and some key-bindings there is very little need for truly native looking. People will accept a polished UI in a heartbeat even if it doesn't look native. What Python needs is GUI toolkit that has a pythonic API and implements in a very consistent and beautiful way a bunch of widgets that are very very frequently used providing the users with a very solid and feature-full canvas for them to implement what they need and it isn't there yet. [Shoes](http://shoesrb.com/) canvas could be a good inspiration. 
I learnt a lot of these concepts in my undergrad, but haven't used them for ages. Thanks for reminding me!
Cross platform is good - I like the idea of yapsy as well, it seems to suit my coding style well.
Anything I've written so far has been with web or command line interface. I think I'll try push that as much as possible, writing GUIs only when needed.
MVC is the way to go (at least, until I read about MVP).
On (7), considering these are custom apps (i.e. they won't be getting millions of downloads), having a few more MB in a release won't matter too much. Thanks for the pointers - I'll be reading on all of them. I got told that one of my options is a Mac. As a avid linux user, I was always thinking against it, but I'm not 100% sure.
You have a couple of problems with your program. 1. If a second client connects it will only be addressed by your server, after the first client is finished. 2. You are not correctly ending communication between the server and client. You should have a look at this for inspiration: [select chatserver](http://code.activestate.com/recipes/531824-chat-server-client-using-selectselect/) 
All I said are details... and as such, not all that important. If you want a successful application, go for big strategic stuff. I recommend at least the following 3: - [Making Apps That Don't Suck](http://www.infoq.com/presentations/Making-Apps-That-Dont-Suck). See this presentation! I cannot stress enough how important this is. - Read [Kathy Sierra's blog](http://headrush.typepad.com/)! Read ALL of it! Take notes while you do it! - Learn about [Dieter Rams' Principles of Good Design](http://en.wikipedia.org/wiki/Dieter_Rams). Apple is paying attention to this guy. Apple is not stupid! ;)
\*shrug\* Anyhow. The style is too academic. It reads like a research paper, not an instruction manual. I know that this can be hard to judge for "insiders" as they will be familiar with the terminology and the style, but -- to paraphrase Jakob Nielsen -- most people on the Internet are not you.
When you're suitably caffeinated, check out the following: * [Analysis of algorithms](http://en.wikipedia.org/wiki/Analysis_of_algorithm) * [Time complexity](http://en.wikipedia.org/wiki/Time_complexity) * [Big O notation](http://en.wikipedia.org/wiki/Big_O_notation) * [Best, worst and average case analysis](http://en.wikipedia.org/wiki/Best,_worst_and_average_case) * [Amortized analysis](http://en.wikipedia.org/wiki/Amortized_analysis) Those Wiki articles should give you a passing familiarity with the terminology. You should probably take one of the free online classes in data structures and algorithms if you're not in a university program already. Here are [some lectures](https://wiki.cse.unsw.edu.au/openlearning/computing2/Contents#contents) from UNSW; they have the video lectures up through the intro to graphs on [YouTube](http://www.youtube.com/user/UNSWelearning#g/c/E621E25B3BF8B9D1). 
With all this criticism, I feel some encouragement is needed. I have done a fair amount of Zope programming in the past and documentation was ... non-existent or outdated or sprinkled all over the internet. So coming to pyramid and reading its docs is like a breeze of fresh air. Every detail of the framework is documented, its up-to-date, its all in one place. Compared to what I was used to, this is just awesome! There is always room for improvement, sure, but I don't want to forget to give appreciation for what is already accomplished. Thanks a lot!
As a general rule, you shouldn't call a [list](http://docs.python.org/tutorial/datastructures.html) an [array](http://docs.python.org/library/array.html). They are two different data structures. 
 def shutdown_and_start(request): inst_id = int(request.matchdict['id']) if 'password' not in request.params: return {'success': False, 'reason': 'No Password Specified'} if request.params['password'] != AUTH_PASS: return {'success': False, 'reason': 'Bad Password'} if inst_id not in request.registry.settings['instances']: return {'success': False, 'reason': 'Unknown ID'} inst = request.registry.settings['instances'][inst_id] conn = EC2Connection(AWS_ID, AWS_SECRET) match = conn.get_all_spot_instance_requests([inst['spot_id']]) if match: # kill old # since we're using spot instances, have to dig around a bit to get # the instance itself match = conn.get_all_instances([match[0].instance_id]) if match: match[0].instances[0].terminate() # start new request.registry.settings['i_counter'] += 1 inst_id = request.registry.settings['i_counter'] r = start_instance(conn, USER_DATA) request.registry.settings['instances'][inst_id] = {'spot_id': r[0].id} return {'success': True} 
Why are you downvoted for being on topic and providing alternatives? 
APL programmers say the same thing.
Wow, thanks a lot for putting that together! You're a credit to this community!
Oh noes, sob sob. Would have been nice seeing them
People are protective ;)
Using a deque is a great idea. Here's a class to get you started. It's working OK in my simple test on Python 3.2 and 2.7. In the test below, using a normal memory handler with a capacity of 5 causes the buffer to get flushed twice to the NullHandler. All you're left with in the log file is the exception. But the deque version retains the 4 previous info log entries in addition to the exception. It automatically flushes based on the trigger level. In this case logging an exception triggers the flush. Edit: Switching between a NullHandler and FileHandler is possible, in case you need to manually clear a large queue of records without storing them. But it's probably simplest to flush the most recent N records to the log file, in which case just set the capacity to N and only use a FileHandler. import logging import logging.handlers import collections class DequeMemoryHandler(logging.handlers.MemoryHandler): def __init__(self, capacity, flushLevel=logging.ERROR, target=None): logging.handlers.MemoryHandler.__init__(self, capacity, flushLevel, target) self.buffer = collections.deque(maxlen=capacity) def shouldFlush(self, record): return record.levelno &gt;= self.flushLevel def flush(self): if self.target: for record in self.buffer: self.target.handle(record) self.buffer.clear() if __name__ == '__main__': LOG_FILENAME = 'my_logger.out' file_handler = logging.FileHandler(LOG_FILENAME, 'a', 'utf-8') memory_handler = DequeMemoryHandler(5, logging.ERROR, file_handler) my_logger = logging.getLogger() my_logger.setLevel(logging.INFO) my_logger.addHandler(memory_handler) for n in range(10): my_logger.info('Test Info') try: raise Exception('Test Exception') except Exception as err: my_logger.exception(err) 
You're not a player until you've made your own web framework, such a project is really fun.
Yes, I would use Python. It's one of the easiest languages to learn, one of the most convenient languages to use, and has a lot of libraries. I used Dive Into Python to learn Python, many years ago. It's designed for people who already know other languages. If your programming is really rusty, you might want to start with something more basic like Learn Python the Hard Way.
enscript
[this is a lie.](http://en.wikipedia.org/wiki/Liar_paradox)
So you've said already. Here's your money back.
I am sure APL is convenient notation for those who have become used to those symbols in other contexts. The nice thing about Python's symbols is that they are from very basic education curricula so almost everyone happens to be used to them. 
Does ShedSkin make everything an "any" type and try to determine the type of things at runtime, like python or does it try to determine the type of things at compile time? Also, has anyone tried to see how well it would work with a C++11 style compiler and move semantics?
So you don't think there's anything wrong with operators which are 3 or more different symbols in length? I think that's pushing it a bit. Even the === in some languages rubs me the wrong way, but it's tolerable since it's all the same character. Once you start mixing the symbols, I think the readability of the code goes down a lot. With words your language comprehension ability helps you read the code without having to inspect every character in detail. Long strings of symbols require the reader to look at every character to understand what is happening. 
[I think it's surprising that bottle is faster than web.go.](http://www.reddit.com/r/programming/comments/i3o6j/the_great_web_framework_shootout/c20mywg?context=3)
It determines the types at compile time, note that Shed Skin simply bails on programs that it cannot infer the types for, thus it is *not* an implementation of Python.
 import cgitb import sys try: raise TypeError("HURRR") except TypeError as err: html = cgitb.html(sys.exc_info()) with open("traceback.html", "w") as tb: tb.write(html)
I don't believe it's good practice to replace stderr. Unless you are and ever will be the sole maintainer of your application. Replacing either stdout or stderr with non standard destination may cause some gray hair for other maintainers. Also, if you run your application through another app (f. ex. cron) it's best not to touch these internals as the calling tools may do something with the output. In the case of cron for example, it will send an e-mail to the crontab owner with the content of stderr. In my opinion, the best way to do this is to redirect the output when running the program. For example: `python my_cool_app.py 2&gt; /path/to/errors.log`
Wait. There are ten of them?
You may also want to post this along with your experience using these techniques over to /r/LearnPython
For experts: sys.excepthook You should not be using this, until you know enough to ignore me.
What do you think about =/= or &lt;-&gt; or &gt;&gt;= ? They are "readable" despite being of a length of 3. I agree =*~ is less readable, so I guess the measure needed is "visual entropy". Symbols with low entropy regardless of length can be visually recognized at a glance and are easy to get used to. 
And if you ever realize that you didn't really need to roll your own thing to create your mom a showcase site, you can always turn to something like Drupal, Wordpress, Google Sites, etc.
It seems like you can just install a CMS - what does she want to do that requires any programming on your part?
I just tested it out on Windows and I noticed that the buttons and everything looks ugly (windows classic style). The same button in wxPython has the native Windows 7 look. Give that PyGUI is supposed to use native widgets, I don't understand why this is. Do you happen to know anything about this?
what? I thought they were the same thing... so what's the difference?
No, because people should work within the standards, not replace stderr. See http://www.reddit.com/r/Python/comments/i4jni/til_how_to_catch_and_write_errors_in_python/c20uia6
Good point. These types of symbolics are used a lot in other languages (eg: Haskell) and they look quite natural there. I guess the point I'm trying to make is that Python has traditionally tended towards having a low symbol : word ratio and the decision to add more symbolic operators to the core language is not one to be undertaken lightly. I guess that may be one of the reasons the PEP in question got stalled in the first place.
After running around all day, finally had the time to try it. Much better. Is there a way to supply python to make this happen automatically though? Without the user needing to launch it with the added commands themselves?
I can only see a use for this in debugging; so for debugging, why not just wrap your execution command in a redirect? Like, python /path/to/myprogram.py 2&gt; /path/to/mylog.log Or Windows, C:\Program Files\Python\python.exe C:\Path\To\myprogram.py 2&gt; C:\Path\To\mylog.py For releases, you can just something like `logging.Logger` to generate "expected" errors (that is, errors that have tests written for them). That keeps unexpected behaviour from being silently suppressed (eg, imagine your python-level redirect failing because of a permissions error or a full disk).
Also, note that I'm trying to figure out a way to do this to where my users do not need to know anything about launching via command prompt -and- to where it will still work once I've converted it using py2exe. ^.^
The logging module lets you log to both stderr and a file if you want: &gt;&gt;&gt; import logging &gt;&gt;&gt; stderr_handler = logging.StreamHandler() &gt;&gt;&gt; file_handler = logging.FileHandler('log.out', 'w', 'utf-8') &gt;&gt;&gt; logger = logging.getLogger() &gt;&gt;&gt; logger.addHandler(stderr_handler) &gt;&gt;&gt; logger.addHandler(file_handler) &gt;&gt;&gt; logger.setLevel(logging.INFO) &gt;&gt;&gt; logger.info('Some Info\n') Some Info &gt;&gt;&gt; file_handler.close() &gt;&gt;&gt; print(open('log.out').read()) Some Info 
I tried hitting 'report abuse' but it said the post was removed.
I did not mean that as a slight in any way. I was just stating it matter-of-factly. Hope you didn't take offense. I like both micro-frameworks. In fact, if Flask were P3 ready, I would use that one.
Disk is cheap, and knowing what led up to an exception can be invaluable. Use a variety of handlers with decent propagation rules, and individual logging levels for each component. I'd rather have a ton of logs I can ignore, than that 1 chain of events I need to have not been logged at all. Seriously, disk. cheap. 
Had you clicked the array link and read the first paragraph, that question would be answered: &gt;Arrays are sequence types and behave very much like lists, except that the type of objects stored in them is constrained. The type is specified at object creation time by using a type code, which is a single character.
You are missing three points. 1) it is not an image or a phone. It is an app itself. You are supposed to click on it. 2) It is a web2py layout. It means it is a single file that you apply to a web2py app, kind of like of drupal skin. There is nothing else to do. 3) if you really need documentation the jQuery Mobile documentation is linked.
It is not an image. It is a demo. Click on the phone.
I tried and it did not work for me. Some loading appeared, then it flickered and then it wen't back to its original state. Browser: Opera. Might sound obscure but I believe its javascript and rendering engine is same as in the mobile/mini version - which together make the most popular mobile browser. Tried seeing error console and on each "failed load animation" I get four errors about some wrong pseudo class. So it might not be an javascript error after all. Don't see that much into it though. might come handy: http://www.opera.com/developer/tools/mobile/ 
downvoted for asking about downvoting. :)
I don't think the demo is actually supposed to *do* anything. When you click a button, it should say "loading", and then the screen should swipe to the left and the same page should simply reload (there's no real content other than the home page). However, the swiping does not appear to work in some browsers (as you can see here: http://jquerymobile.com/demos/1.0b1/#/demos/1.0b1/docs/pages/docs-transitions.html). Here are the currently supported platforms: http://jquerymobile.com/gbs/. 
Chances are this is because it is talking to its controlling terminal rather than stdin. You would have use ttys (Python does have a module) in order to do the I/O. In any event there is a simpler solution to your problem - use one of the programs that makes a process use readline even if it wasn't built with it such as [rlfe](http://www.digipedia.pl/man/doc/view/rlfe.1/) or [rlwrap](http://utopia.knoware.nl/~hlub/uck/rlwrap/#rlwrap). My top match in a search for [rlfe man page] is a [PDF](http://www.utsc.toronto.edu/~atafliovich/11w/cscc24/assts/a2/smlnj.pdf) that talks about using rlfe with SMLNJ!
rlwrap is exactly what you want. It's really simple, just pass the sml executable path into the rlwrap executable, and put that in a script :)
Python is a very good language to know, but it's not particularly useful in the robotics industry. Echoing what most of the other guys have said, host code on github (open source is great!), build a resume, maybe even a n about-me type of web site :) Meanwhile do shit with robots in your spare time.
cProfile is meant exactly for this.
logger is the shit. knoxontholos, definitely give it a try in your program. checkout the different logging levels (error, critical, info, etc) and play with how they print to console, file, etc.
What an old thing! Once upon a time, when I didnâ€™t discover SQLAlchemy yet, I really was excited with it.
that's ok. At least some might have paid attention and compensated for the downvotes. 
if you want to do it without downloading anything off the internet (libraries) then python is not your program unless you don't care at ALL about your graphics (it will flicker and have no titlesets, or go very, VERY slowly in tkinter [and if you're new to python you probably won't find it fun to figure out all the stuff you need]) Edit **otherwise, if you don't mind downloading, you're fine!
&gt; In fact, if Flask were P3 ready, I would use that one. We're getting there :)
Python's very good as a first language. It's a high-level, often highly abstract language. Learn the basics, then wait until you have an itch to scratch and use Python to help you out. If you're very interested, get a book and stick to it. The one I am reading at the moment is *Learning Python* by Mark Lutz. It's a great book and for the most part is in a logical order. It's a good one to use especially if you've never programmed before since the first few chapters are very broad and explain a few key computer science concepts to you. I didn't require it, but it's still a good thing to read in a structured way. There are many free online lectures as well, I forget which University put them out, but shouldn't be too hard to find out. If you're mathematically inclined you could try the Project Euler challenges, they are mathematics based problems which often require creating and authoring efficient algorithms to find answers. They really helped me back when I was learning C and things, now I go back through and use them to learn Python. Very helpful in efficiency and getting your programs down to realistic timeframes. Finally, get involved with the community here, there are some *very* well informed and great programmers here, I've picked the brains of a few and come away each time with a solidified new concept. Above all else, have fun! Programming is not some highly advanced subject that most people think it is! It's easy when you apply yourself! Think of programming as some sort of Rubik's Cube crossed with Sudoku crossed with a word-search.
Maybe http://www.noah.org/wiki/pexpect will help.
thanks, that's exactly the use-case I wrote it for myself
Python is a great first language. It depends on your learning style, but a free online book that I've heard can be quite effective is called [Learn Python the Hard Way](http://learnpythonthehardway.org/). The title is a bit tongue in cheek. It's not "hard" because it requires prior experience with programming. It's "hard" because it starts from nothing and makes you practice everything, a lot, until you *get* that experience: &gt; This book is a very beginner book for people who want to learn to code. If you can already code then the book will probably drive you insane. It's intended for people who have no coding chops to build up their skills before starting a more detailed book. Many new programmers on Reddit have sworn by it. But if you find it too overbearing or too repetitive, by all means try another book -- I'm sure this thread will be full of recommendations soon.
Good suggestions from steelypip and eryksun. Another way: for each task, create and add a FileHandler specific to that task (e.g. named using the task identifier), and log away. When the task is completed, just before finishing, remove and close the handler and delete the log file. If an error occurred during the task, don't delete the log file, so you have a record of what led up to the error. This approach does not have big memory requirements, and yet allows you to avoid the "Too Much Information" problem.
gst dude, you submitted 4.6 release 18 days ago http://www.reddit.com/r/Python/comments/hq2ze/ Are you a bot or something?
You may want to try this as well: http://beginpython.com Learn by coding, very similar to Learn Python The Hardway
What's the advantage of Pyro over Twisted? Does Pyro support asynchronous calls?
&gt; (a) If python is a good language to start out with. Definitely. &gt; (b) How I would go about learning python. Take a simple tutorial and go through it (for example, [this one](http://www.sthurlow.com/python/)); Then, choose some problems to solve, and write some scripts :) Program ideas (beginner): - find duplicated files on your HDD - write a script that downloads your email from a server - write a command-line "find file" utility 
http://www.learnpython.org/# this page has a interactive IDE that should be good for helping you get started. Also think much more, just about how to do things most efficient, practice your logic and problem solving.
dude, I asked this question before, and some body told me gst is a bot,:)
Python is definitely a good first language. Since you have no programming experience I would suggest that you read one of Byte of Python (http://www.swaroopch.com/notes/Python) and How to Think Like a Computer Scientist (http://greenteapress.com/thinkpython/). Both are available for free. One thing to note is that there are two versions of Python: Python 2 and Python 3. The first book deals with Python 2 and the second has a version for each. My recommendation would be to start with Python 2. Another book worth mentioning is Invent Your Own Computer Games With Python (http://inventwithpython.com/). 
I looked at this a couple of weeks ago because I wanted to read the Million Song Dataset. Unfortunately, it's based on the HDF5 C code and NumPy, so installing it requires NumPy and the HDF5 C header files etc etc. I wound up taking a different route.
As someone with a Zope background I have no problem understanding this piece of text; I can't evaluate very well how difficult it is for someone without my experience. But yeah, let's not blame Zope. Constructive criticism here (overall I'm impressed by your documentation!). There are three possible problems: * talking about configuration as an abstract concept very early in the documentation, as mentioned by someone else in this thread * the concept of configuration such as Pyramid uses it * language ("imperative", "declarative", etc) as already mentioned in this thread. Concerning imperative/declarative - I think the concept of declarative style in development is *so* important that I think every developer should understand taht. But too little (no) space is given to the declarative approach before the "normal looking" approach is introduced and called "imperative". This is a somewhat intimidating word if you don't know that there is going to be a declarative approach described later. A little section constrasting imperative and declarative styles of configuration to head the whole thing off might help. I think however that the conceptual issue is the one that trips people up more, however: constructing an application and plugging in pieces by "configuring them together" tends to be pretty unfamiliar to people. They try to read more to understand and can't integrate it in their brains. I think expanding the explanation of why this is useful, cool, powerful, etc, without referring yet to particular ways to do it would have the biggest pay-off in improving the text. Then there's the problem that these concepts get introduced early in the overall documentation. I realize people can read quick tutorials and such first, but if they dive into this documentation they're confronted with alternative methodologies to do configuration just after they are done installing things. You could try to reshuffle the text moving this chapter to a later point, and then trying to avoid the words "imperatively" and so on in the "creating your first pyramid application" section. There's in fact a whole discussion about configuration in that section that might enlighten people who get stuck in the previous chapter! 
He might want to avoid *Learning Python* if he has no programming experience. Mark Lutz is a great guy and he's written a lot of classic Python book, but you might find it to be a wee bit heavy. (but an awesome book, I have a copy myself and I still use it. The newest edition, however is over 1000 pages). Still he SHOULD check it out at some point.
You might also want to try [**How to Think Like a Computer Scientist**](http://openbookproject.net/thinkcs/python/english2e/) which is an excellent (free and a *classic* Python book) start specifically for people who have no experience with programming. Also, how you learn programming is different for many people, so don't get discouraged if it doesn't work out at first. Wiggle around until you find something that fits you. The Python website also has a list of [resources](http://wiki.python.org/moin/BeginnersGuide/NonProgrammers). 
It seems that it is copying all announcements from the comp.lang.python.announce newsgroup.
Pyro is not a complete framework for everything related to network programming, it is a small efficient library focused on making remote object calls transparent to your program. It doesn't enforce a way of living on your application. And yes, it has async calls (see the announcement). 
I wouldn't go with the newest edition. I remember seeing it when I had my older edition in my bag, and I realized that it's probably because of the Python 3 stuff.
I am currently starting with how to think like a computer scientist. love it so far. going to go through a few books to affirm my knowledge. 
No offense, but if you're not already using NumPy, then you're probably not the target audience anyway.
I have this book: http://www.amazon.com/Beginning-Python-Professional-Magnus-Hetland/dp/159059519X mostly because it is written by a norwegian man :P So it might interest you too, if you really are norwegian. If not, your nick is deceiving me. 
Sorry, no idea. Best bet would be to ask this on their mailing list. 
Any idea when we will see a "TurboGears3" based on Pyramid? 
I haven't used Cython or weave, but is there any way to program them and apply optimizations?
**Video** I'd go with those books and also add video instruction: * Python 101 and 102 http://www.rexx.com/~dkuhlman/ http://www.blip.tv &lt;-Where the videos are. * Python Osmosis A quick run down of major components in Python **Books** I recommend Introduction to Python 3.0 Programming. http://www.qtrac.eu/py3book.html Starts off with core features of Python and gives you a little view of modules included with Python at the end. 
Find a project you care about. Read a couple of free books (giyf). Join irc, stackoverflow, etc ask lots of questions.
I'm getting through it at alright pace. I have, however, had about 2 years experience with several other languages such as C/Wiring and AHK(lol). I'm not sure how long ago you read *Learning Python* but it seems slow enough, but I guess *slow enough* is subjective really.
Haven't seen this one mentioned in a while and I agree that this is a great intro to CS for people with no prior knowledge of the subject matter.
I've got the newer version. It's *not* different, it's just got added sections for the 3x stuff and he makes it clear which methods/modules/functions/syntax do not work for 2.x. It seems like Lutz *wanted* to focus on 3.x though, but 2.x is a clear focus throughout.
No, cProfile is meant for profiling, not for logging.
I wonder what pypy would do with the benchmark.
I constructed an equivilant benchmark using the array module (we don't support multi dimensional arrays in numpy yet): http://paste.pocoo.org/show/416241/ at the N=200 displayed here: CPython: 13.891s PyPy: 0.170s Edit: Running at N=1000, I get: CPython: 357.689s PyPy: 2.175s
My understanding is that you can get it to emit the code that it would compile so that you can customize it.
I found the best thing is a project or goal to focus around. I learned python after I had been programming for a while, but found http://projecteuler.net/ to be a great place to practice. The gist is there are math problems like 'what is the 100000th' prime that you can solve by writing a small program, and you just submit the answer. Haven't read many of the books, but this could complement one that didn't have exercises (or not ones that you enjoyed).
I can't believe no one's mentioned this yet. [Try MIT's Open CourseWare into to computer programming](http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-00-introduction-to-computer-science-and-programming-fall-2008/index.htm). I'm currently finishing up assigment 5 and watching lecture 12. It has required reading with links to all the reading online. The lectures are really good. I'm taking it way slower than the real pace of the class, but I'm in school full time with a full time job. Even with those obligations I find I spend most of my free time working on this course.
Why no love for Boost.Python? It rocks if you want to do anything that's not trivial.
h5py is simply excellent. The dictionary style syntax fits HDF5 perfectly as it is, but you still can access the C-style API if you want to do things the hard way.
I might be a bit skewed, but article on speeding up Python that doesn't even consider existence of PyPy makes me kind of sad. And as kingkilr pointed out, PyPy performs ok at this kind of benchmark anyway.
Post your job opening on the Python Job Board: http://www.python.org/community/jobs/
Did that a few weeks ago, actually. Lots of replies but all from overseas...
Just [dive into it](http://diveintopython.org/)â€¦ :)
I'm working at a startup in Virginia Beach. I'm not currently looking for another job, but we could exchange information if that changes.
I'm just about to dive into LPTHW but I'm a little worried that it only covers Python 2 and not 3. Should I tackle 3 or can I start with 2?
You should start with 2, even though Python 3 is a nicer language. An important part of learning to program will be finding Python code and discussion about Python online, and the majority of it is in Python 2. Ideally, you'll learn Python 2 and then it'll be a breath of fresh air when you get to switch to 3 in a few years. It would be harder to learn 3, and then learn about the warts in 2 by reading release notes backwards.
I don't mind downloading.. Not sure what you mean about tilesets and flickering. I started using the pygame class with python 2.5.4 and doing basic animations to display and there is no flicker to speak of with moving graphics and such. Could you elaborate on what you mean exactly.
i second this- my route was to go through the django tutorial project [here](https://docs.djangoproject.com/en/1.3/intro/tutorial01/), and then read through the djangobook, which was excellent. You might feel a little confused for a while, but its worth it!
Thanks!
Thank you so much! That's exactly what I needed to solve this problem. However, just for my knowledge, how would I tackle this problem in Python? I looked at ttys and termios packages but couldn't figure out how to exactly go about doing this. What would I use for the file descriptor needed for all of the termios functions?
Thank you so much! This was exactly what I needed. :)
The [pty](http://docs.python.org/library/pty.html) module is what you would use to get the file descriptors. Depending on how SMLNJ deals with output and if you need to separate its stdout from stderr, you need to carefully fork and exec SMLNJ (which is what the subprocess module also does). The amount of work you then have to do depend on what you are trying to achieve and what SMLNJ does with its terminal. For example terminals can be in multiple modes which you would have to detect and react to. You can read the source code to rlfe/rlwrap to get an idea of what they do. Most of the relevant library calls are wrapped as is in Python so equivalent Python code would look pretty much the same as the C code. The books by [Stevens](http://www.kohala.com/start/) are very good, a little dated but the interfaces haven't changed and the traditional way people learned UNIX and network programming. You'll find psuedo terminals covered in [this book](http://www.amazon.com/Programming-Environment-Addison-Wesley-Professional-Computing/dp/0201563177) and should be able to find it very cheap second hand. There is also [this book](http://www.faqs.org/docs/artu/) available free online which goes into what is "normal" for Unix if you don't have much of a Unix background. The [Unix Haters Handbook](http://simson.net/ref/ugh.pdf) (PDF) is also an excellent Unix reference.
I hope the :) means this isn't a serious recommendation. Dive into Python is for people who already know how to program, just not in Python. 
I am considering python for scientific computing. I am still learning, but python is so simple that I think that I should be able to run some code soon. This is really interesting, are there good resources to learn Cython or Numpy available? 
What do you mean?
The Cython program generates C or C++ directly actually, then you can compile it like any extension module. But it's an automatically generated file, you're not supposed to customize it. The Cython language already supports most Python features.
X-posted from /r/reddit.com http://www.reddit.com/r/reddit.com/comments/i5dhd/bbc_to_dramatise_monty_python_life_of_brian/
**HAHAHAHAHAHHAHAHAHAHAHAHAHA** I can't upvote this enough
I think I might still be owed some issues. grrrrrrrr
I was wondering if you could apply compiler optimizations to Weave or Cython code. I find my C code can be run much faster if I use some of the optimization tags like -O2 or -funsafe-math-optimizations . If there was the option to add optimization flags maybe the benchmarks in the article could be improved.
Um... no.
I can't see your reply in the original thread for some reason. If I remember correctly, the extensions are built with -O2 by default. But you can pass any option you want, as for any extension module.
What is your startup trying to accomplish? We're actually very invovled in the Nashville Entrepreneural Center - it's an incubator of sorts for local startups so I'm always interested in what people are up to. I'll message my contact info to you...
Yeah - it sucks, but Nashville is very much a .NET/Microsoft town. Over the past few years, though, there have been a host of start up companies emerge using Python, Ruby on Rails, et al. Java seems to be more in demand as well. Lots of cool stuff happening these days. 
Yeah, I had the same problem, but it seems to be fixed now. I will have to look into this, because ideally I'd like to do most of numerical work in python. 
well, for curiosity's sake, I'll enlighten you, but if you're using pygame, you're fine. I'm guessing you know about Dwarf Fortress (I don't know much, my friend showed me), well, you can have tilesets (e.g. make stuff not ascii) but with tkinter, it's extremely difficult. (actually I forgot about the python image library cause I'm doing 3.1.2 but that's a lib too) because tkinter SAYS it supports about 3 image formats for both color and on/offs but it really only works with .xbm's and those are stupid. that is the problem with tilesets, but even if you just did it in command prompt (and I noticed this with a tetris game I made) it isn't made for stuff like that, and flickers really weirdly when you print multiple lines at once. pretty much, python is a bitch with graphics unless you use foreign libraries because tkinter is inconvenient and slow with pictures (it updates them very slowly unless it's about 150x150 or smaller) TL;DR in python you have 3 choices (imo): slowness, terrible graphics, or foreign libraries
Python: confusing basic concepts since 1995.
When it all shutdown I think I was 6 months into my subscription, but I have no idea when that was or if I ever got the remaining months refunded. Probably not.
Uhhhh.....not Python.
It gets a whole lot easier when you stop thinking of blocks and scopes as the same thing. 
Oh.
I've read all of the editions. I also have a copy of the most recent one. It's a great book and I frequently re-read bits of it, but I think it may frighten off people who've never coded before. The amount of information in it is fantastic!
They're both good.
I don't get the threading.lock example. Does myLock become a lock forever, which can be opened and closed whenever you run any with command?
I have issues.
Python documentation is excellent because of its recent popularity.
... you *do* know what Python is named after, right? Hint: it's not a snake.
From the example: with threading.Lock() as myLock: Creates an instance of threading.Lock and a local binding of 'myLock' to the created lock instance. When the 'with' block is entered it calls \_\_enter\_\_ on the lock and then calls \_\_exit\_\_ on block exit. In the specific case of locks \_\_enter\_\_ acquires the lock and \_\_exit\_\_ releases it. The next section: with myLock: Simply reuses the local binding of 'myLock' and calls myLock.\_\_enter\_\_ and myLock.\_\_exit\_\_ the same as before. You can use any object that supports the context manager protocol (\_\_enter\_\_ and \_\_exit\_\_) as the context manager of a 'with' expression. For instance, x = threading.Lock() with x: ... is just fine. The 'with' statement is basically* of the form: 'with' expression ['as' name]: You can see it has two parts, the 'expression' that evaluates to a context manager, and an optional binding to a local name. If the 'as' portion is not given then no local binding is made (the context manager instance only exists an internal temporary kept around for the duration of the block). We can see it rather well if we examine the bytecode: with threading.Lock(): return produces 0 LOAD_GLOBAL 0 (threading) 3 LOAD_ATTR 1 (Lock) 6 CALL_FUNCTION 0 9 DUP_TOP 10 LOAD_ATTR 2 (__exit__) 13 ROT_TWO 14 LOAD_ATTR 3 (__enter__) 17 CALL_FUNCTION 0 20 POP_TOP 21 SETUP_FINALLY 8 (to 32) 24 LOAD_CONST 0 (None) 27 RETURN_VALUE 28 POP_BLOCK 29 LOAD_CONST 0 (None) 32 WITH_CLEANUP 33 END_FINALLY while with threading.Lock() as myLock: return produces 0 LOAD_GLOBAL 0 (threading) 3 LOAD_ATTR 1 (Lock) 6 CALL_FUNCTION 0 9 DUP_TOP 10 LOAD_ATTR 2 (__exit__) 13 ROT_TWO 14 LOAD_ATTR 3 (__enter__) 17 CALL_FUNCTION 0 20 STORE_FAST 0 (_[1]) 23 SETUP_FINALLY 17 (to 43) 26 LOAD_FAST 0 (_[1]) 29 DELETE_FAST 0 (_[1]) 32 STORE_FAST 1 (myLock) 35 LOAD_CONST 0 (None) 38 RETURN_VALUE 39 POP_BLOCK 40 LOAD_CONST 0 (None) 43 WITH_CLEANUP 44 END_FINALLY 45 LOAD_CONST 0 (None) 48 RETURN_VALUE We can see that the only difference (aside from the \_[1] temporary assignment) is the STORE_FAST of 'myLock'. This makes a local name binding in the same way any other assignment in the scope would. *It actually supports multiple context/assignment bindings and the 'name' can actually be any acceptable assignment target (slice, sequence unpacking, etc)
This should clear it up for you: &gt;&gt;&gt; import threading &gt;&gt;&gt; my_lock = threading.Lock() &gt;&gt;&gt; with my_lock: ... my_lock.locked() ... True &gt;&gt;&gt; my_lock.locked() False From threadmodule.c: {"__enter__", (PyCFunction)lock_PyThread_acquire_lock, METH_VARARGS, acquire_doc}, {"__exit__", (PyCFunction)lock_PyThread_release_lock, METH_VARARGS, release_doc}, The `__enter__` and `__exit__` methods define the context manager protocol, called when entering or exiting a `with` context. For a Lock this simply acquires and releases the lock. 
When Alexis and Steve gave their keynote at PyCon a few years ago someone asked them if gst is a bot, and they said he was not.
&gt;Creates a local binding of 'myLock' to an instance of threading.Lock To clarify, the local binding is to the value returned from the `__enter__` method: class A: def __enter__(self): return "Spam" def __exit__(self, *args): pass &gt;&gt;&gt; with A() as obj: ... print(obj) ... Spam Often the value returned is `self`, such as for a file object. 
I do know! But it's not so completely based on the show that news about Monty Python should be posted to the Python subreddit. [This](http://www.reddit.com/r/montypython/) might be more helpful.
True. Still, a very occasional reference to it isn't the worst thing in the world.
load_options() doesn't return anything (it just changes some instance variables). Because of that, it's considered that it returns a None, which, as you can guess, doesn't have a borders attribute ;)
 game_options=options.Options() means that game_options is an instantiation of the class Options (since you called the constructor). game_options2=game_options.load_options() holds the return type of calling the method load_options() from the class. But load_options doesn't return anything! So its type is None and therefore has no borders attribute.
Did they not think to maybe *test* this instead of clogging up Stack Overflow with a question they could have answered for themselves? &gt;&gt;&gt; with open('/dev/null', 'r') as foo: ... x = 3 ... &gt;&gt;&gt; x 3 &gt;&gt;&gt; print foo &lt;closed file '/dev/null', mode 'r' at 0x1004890c0&gt;
Wow. Not only did I overlook that, but i was also changing self.box_color_1 twice whilst loading, thus no changes where being made that i wanted.
This means it's time to take a break or fill your coffee mug again ;)
Yes, good point. I didn't make that distinction clear in my explanation.
Thanks Martijn for the suggestions.
This + http://www.engadget.com/2011/06/21/nokia-n9-first-hands-on/ = Python Nerd heaven 
And thus the example from Stack Overflow is wrong (I overlooked the mistake at first, but didn't repeat it in my own demo). The `__enter__` method returns a boolean to show whether or not it was successful. You can check for yourself in [threadmodule.c (lock_PyThread_acquire_lock)](http://svn.python.org/view/python/trunk/Modules/threadmodule.c?view=markup) and one of the platform thread headers such as [thread_nt.h (PyThread_acquire_lock)](http://svn.python.org/view/python/trunk/Python/thread_nt.h?view=markup), or simply experiment: &gt;&gt;&gt; my_lock = threading.Lock() &gt;&gt;&gt; with my_lock as lock: ... type(lock) ... print(lock) ... &lt;class 'bool'&gt; True 
Good catch. I use locks in 'with' statements all the time (but never with a local binding, because I mean, really, who manipulates lock state inside lock-scoped context?) and just assumed the dude's example was correct. 
If you read the question he did test it (against Python 2.6.5) and his actual question is whether this is an implementation detail of CPython or if it is part of the required language semantics.
And as you've already pointed out, in Python blocks aren't scopes, though they can be contexts in which the system behavior is radically altered: &gt;&gt;&gt; from decimal import Decimal, getcontext, localcontext &gt;&gt;&gt; getcontext().prec = 2 &gt;&gt;&gt; Decimal(1) / Decimal(3) Decimal('0.33') &gt;&gt;&gt; with localcontext() as ctx: ... ctx.prec = 10 ... Decimal(1) / Decimal(3) ... Decimal('0.3333333333') &gt;&gt;&gt; Decimal(1) / Decimal(3) Decimal('0.33') 
I think this is pretty standard for the very beginning 1) print "hello, world" 2) variables: a=1, name="Doug", b = a + 3 3) logical control: if, elif, else 4) arrays: list = [1,2,3], list = range(10), list[0] = "one" 5) loops: for, while 6) functions: return values, arguments then maybe string operations, file IO, classes, etc
First, I wouldn't recommend posting your API keys. Second, download and run scanwin32.py from [http://pyserial.sourceforge.net/examples.html#finding-serial-ports] to see what your port names actually are. 
Thanks.. forgot about the keys.
OK.. so managed to get the port working.. now get this error after like 10sec of running.. Traceback (most recent call last): File "C:\Users\Craig\Desktop\Craig.py", line 76, in &lt;module&gt; driptwit() ## call driptwit function File "C:\Users\Craig\Desktop\Craig.py", line 50, in driptwit drip = checkIt[0].split() ##split first tweet into words IndexError: list index out of range &gt;&gt;&gt; 
You are getting that error because `checkIt` is empty (there are no new tweets?). You need to add some logic that checks if `checkIt` is empty, and if it is empty, you should skip the current loop and check again after sleeping the 15 seconds.
AH dont worry. Fixed. THanks heaps!!
I think I know what phone to get next. 
"don't nitpick my code habits" ok, but it's really hard not to ... :P please look at configparser for reading/writing configuration
Totally agree with the amount of information in it, and it's definitely written very clearly.
Wen you're ready to step it up a notch, web2py makes it easy to program a whole database driven web site right on your Mac or pc.
I vote for merging both reddits. Nudge, nudge, wink, wink. Know what I mean?
Exactly, they aren't, that's what imo confuses a lot of people. Here's a link to my website that's hopefully helpful: http://www.markus-gattol.name/ws/python.html#context_manager
pyximport provides a quick alternative to setup.py. For a package distribution it's probably best to compile extensions with setup.py, but pyximport keeps the clutter down for one-off scripts, and hides all the compiled files in a subdirectory of your home folder, named .pyxbld. For example, I put the cy_update function in _laplace.pyx. Then I imported it at as follows: import pyximport pyximport.install(setup_args={'include_dirs': [np.get_include()]}) from _laplace import cy_update At first I wasted time trying to get NumPy's dependencies into the .pyxdep file that the docs recommend. I don't know what I was doing wrong with the glob... I switched to using the setup_args option, and it worked smoothly. Note, if you're on Windows and using Cygwin, you'll need to configure distutils for gcc. Add a file named `distutils.cfg` to `Lib\distutils` that contains the following: [build] compiler = mingw32 [build_ext] compiler = mingw32 
I know that people constantly complain about me using scribd, so the PDF is available separately: http://pocoo.org/~mitsuhiko/badideas.pdf The code is on github: https://github.com/mitsuhiko/badideas