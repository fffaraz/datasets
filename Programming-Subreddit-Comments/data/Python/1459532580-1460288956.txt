I've never wished for the power of php in python, lol.
Definitely. Yes, we code and create/design big programs and can talk at length why a specific practice is bad. However, you need to speak to your audience. When I teach new hires to code, I tell them to do things that I don't follow because they're new. More often it's I see them do something confusing, so I say don't do X; do Y because reasons. There are best practices that are different depending on your application and the tools you use to accomplish that task. Numpy/scipy best practices are different than more standard packages.
Also Android: Froyo + Gingerbread = Ice Cream Sandwich ^(Just ignore that it was actually Gingerbread + Honeycomb.)
What power?
The power to increment and decrement null.
C-can it actually do it?
Not only is it inefficient memory-wise, but it also makes the call much slower as it must copy the entire dict.
I asked myself this very question when wrapping up the numbers. I search for a Brainfuck compiler (not an interpreter), to run the same benchmark. I could not find a working one, and I did not think of looking for a Brainfuck to C translator. I am going to look for one and run the tests, thanks for the idea!
Hmm... but why? Why would python need PHP features? Why would a very well designed language need a poorly designed language's features? I am not trying to undermine your work or anything, nice work you got there, however I simply fail to see any practical need and/or applications.
Right now i want to freelance from home office. My current idea is to make just enough money to survive and study subjects that i never had the chance to because of my previous job. Thanks for the tip.
And finally added English rules as well
/r/lolphp
`from __future__ import braces` is a good place to start, so you can get your JS-style curly brace on.
Hi plogston! Thanks for the initiative. This will surely help a lot of Pythonistas. Yes, I'd love to be part of this work and would like to help. Here is my git repo: [kmario23](https://github.com/kmario23) Please let me know the specific task that I should contribute :)
Finally I can utilize the power of ```str_pad``` in Python, thanks OP.
You're close. This *is* Python 8.
That's an interesting approach. Thanks!
From your descriptions, it sounds like SimPy (https://simpy.readthedocs.org/en/latest/) might suite your needs. Is a library for discrete-event simulation and sending/receiving packets via a network is very much event-like … :)
I switched recently from pycharm to tmux/vim. I don't even use NERDTree because I want to be accustomed to navigating around in files on servers with stock vim. After some initial inconvenience I think I'm more productive now than I was with pycharm, and it takes a lot less resources. The one thing I haven't been able to match is the visual debugging you get in pycharm.
Perhaps this is a matter of terminology or perspective, but it seems to me that if type annotations are used, and if the annotations are accurate enough for tool or human usage, then the code is effectively statically typed.
Does Atom have same memory issues on Linux as it seems to have on Mac? I love/hate the thing. It would suck dry my 16gb of RAM until it would become unusable. 
What is everyone's opinion on Eclipse PyDev?
You should take a look at [Scapy](http://www.secdev.org/projects/scapy/doc/introduction.html).
I suggest you to learn how to use pdb to debug code (it covers all of my needs) and use a text editor instead. Because text editors don't do much beyond autocompletion, you end up doing things with your bare hands, hence they are likely to stay simple. Here is a good tutorial to help you get started with pdb: https://youtu.be/g49UECaIDOs
Stop thinking in terms of Python programming and start thinking in terms of business problems you are going to solve. Your main goal is to create business value. You've mentioned you made an Android app - what problem did it solve? Do you know other businesses with a similar problem? If not, start asking around. Writing code is just a small part of freelancing. You can write the most beautiful, bug-free software that ever graced the Earth, but if you won't find clients for it, you will struggle.
I've used it, and I like it for Django projects. I prefer a minimal text editor most of the time.
I've contributed to pyvideo.org (I recorded about 1/2 the talks from pytexas one year) I like it having its own top level domain, but the point is to have the instruction centralized, even if it is just a youtube channel that keeps the videos from pycon, and other python conventions in playlists. The centralization is key, because sometimes there is a topic that a programmer doesn't know they need to know.
Thanks buddy I have already tried this but my specifications do not meet the standard packages . Though i can draw interarrival time using exponential distribution using these libraries but i have to draw packet size from packet distribution too and moreover i have to keep track of packet loss and collision rate at each node too . And it lead me to write everything from scratch for necessary calculations. I need someone who could look into my code and help me in making it better. I would really appreciate that.
I like Geany. It is simple enough, but not barebones.
Wow, I post on /r/python and get an actual person from the VS IDE Team, nice! My question would be does this still work with the GIT extension so my team can push it up through GIT in VS? Also since I am comfortable with the full blown IDE I assume I can still use that and they can use this? Lastly, and I am assuming this is a no, but is this mac compatible? If they do run windows on their mac as well I may suggest this to them. I like the idea of it keeping it all in a project but I have a feeling they may already have an IDE they are happy with.
I wouldn't call it static as long as the python interpreter ignores the types. 
I use [eclipse](https://eclipse.org/) with the plugin [pydev](http://www.pydev.org/) and i like it.
Thank God
Does it give Python the popularity of PHP?
That’s the power of your Web server, not the power of PHP. You can do that with Python as well.
Why don’t you read from STDIN instead of dumping the JSON in a string? Edit: oops I see it was answered.
Now, if only we could `import python` inside that PHP, we'd have perfect recursion.
I think you can fairly easily represent this behavior in simpy. Use a simple pattern of representing each entity of the simulation and think about what governs the behavior. Besides physics, there should be general network protocols that you can represent through logic. Think in events. What kicks everything off. What reacts or depends on the events.
No no, the Python 8 release notes said that the version numbers double, so this will be Python 16, not ten. 
Try [bfc](https://github.com/Wilfred/bfc).
Huh, that's a good question, not really sure. I don't see it hogging too much of my RAM as a rule, not nearly as much as Chrome. I'll occasionally see it creeping up, but that's more when I have a bunch of directories open
Patches are accepted to port it to Python 3 and work is underway: https://github.com/lektor/lektor/pull/187
&gt; Not to mention that mitsuhiko is stuck in 2010, with aggressive push on mainly supporting python 2 for many of his projects. And I am not alone who thinks like this. And by many of my projects you literally mean one which is Lektor? All other projects support Python 3 just fine.
Neither is a "brand". I just moved all Flask related projects under a new org without historical baggage.
You can also do much much better as well (with WSGI for example) in a way you don't have to deal with environment variables or output streams yourself.
&gt;Another factor is the languages themselves. Java, for example, is almost unbearable without some solid IDE support - the type system is too weak to leverage the compiler for proper type-driven development or safe refactoring Can you talk a little more about this? Quality post btw
Date
Is this an April fools joke? 
I'm very happy with pycharm. The benefits of an IDE become more apparent as the projects you're working on get larger. I'll fire up emacs if I need a small one-off script, but pycharm is very useful once I have 5 developers working on 8 different modules, and want to run unittests while going through the git revision history for a file with code editing windows across multiple screens. Arguably, emacs can probably replicate 90% of pycharm's (are any other advanced IDE's) functionality, but you'll waste at least a week trying to tweak it exactly the right way. That's a problem when time is money and you want to ensure a certain level of tool consistency within your team (if you have one).
`from sarcasm import detection`
The only thing I hate more than pandas is buzzfeed
Maybe this will cause a ruckus but: I really love PyCharm community edition. TLDR: It's great for noobs. I am a noob. If you are just learning Python it's great. Not only are all the lazy features like auto indent and matching quotes, braces, etc. really nice and make me more efficient, but the other features are great too. All of my code is well organized into Projects. Error checking saves me a lot of headaches (not unique) and switching between anaconda kernels is seamless. Git and Github integration are amazing. Extensions for so many other languages keep me from needing to learn other IDEs just to use other languages. iPython terminals, bash terminal are integrated for testing code lines quickly. Project structure visualization is really neat also. More shortcuts than I think I'll ever learn. I'm sure not all of this is unique to PyCharm, but it's really well implemented to me. Lastly and most importantly, PyCharm makes PEP8 suggestions. This is great not just for me but everyone. I would not be following PEP8 if it wasn't so easy and PyCharm wasn't bugging me I was doing it wrong. Shit, I wouldn't know about PEP8 otherwise. Sure it's a resource hog, but I have RAM to spare. 
&gt; ImportError :(
I hope you have an up-to-date packet hunting license, as well as an appropriate tag for the packet you've captured.
Certainly, I meant in addition to the other info given. ActiveState Python sets the file association, but not PATHEXT.
**FINALLY**
I think it's better to move in this direction, but even libraries converted to Python 3 throw errors. I am having a lot of trouble with Tweepy, for instance. All I am trying to do is print out data and I keep getting unicode errors.
Not sure, but based on the description in your text, you probably want `{0:10**4, 1:1.0}` or `{1:10**-4, 0:1.0} ` Btw. it's just a factor that you can use to balance the classes in imbalanced problems if this is desired. In your case (decision tree &amp; entropy) it's simply used to adjust the "information gain" computation. Btw. if you are interested in the details, the function is actually quite short, you can find it here: https://github.com/scikit-learn/scikit-learn/blob/master/sklearn/utils/class_weight.py
Why not Youtube? Everything gets uploaded by a few weeks after the event and organized into a playlist. [This](https://www.youtube.com/watch?v=S1Nx3zSkd40&amp;list=PLs4CJRBY5F1KMMpoEWMuBRvHvjBJeAJoS) is PyCon AU 2015, which were added to Youtube months before they were indexed by PyVideo (according to the Latest videos section).
It's the secret sauce that makes Node.js web scale.
I don't think state[x] == y will work since state[x] returns the value at that index and not the index int. Not sure if this is what you're looking for... def make_move(state, position): move_list = list(state) y = position for x in range(0,len(state)): if x == y: move_list[y], move_list[y+1] = '_','_' return ''.join(move_list)
Years ago, when I was moving from PHP to Python, I wrote a module to handle the quirks of some PHP formats. For example, its *special* way of handling `.ini` files. It's on PyPi too. Just `pip install php`.
Nah this didn't do anything =/
Mostly clicking with a couple of copy-pastes. Two web consoles. And now my Alexa asks and remembers (briefly) my favorite color. No knowledge of Python required so far, but now I can go back and look at the code I saw in the first console. I told it my favorite color was "pineapple" which wasn't in my color list, and it told me my favorite color was pinapple, so I'm not sure what the purpose of the list is, but I'm off to figure it out.
Looks like the govt gravy train has almost reached its destination
I tried duckduckgo when they started up and i didn't like it, but it looks like I need to give them another chance.
well put, I'm in the same scenario.
I know this isn't exactly what you're looking for, but looking at the source code has saved my skin a million times. There are a lot of un- or under-documented libraries out there - some of them have surprisingly well commented or written code that makes it easy to figure things out. Just throwing it out there because I sometimes spend too much time looking for something that isn't there... only to remember that I can just look at the source. Good luck, OP!
I want to believe, but duckduckgo is such a terrible name. Can you imagine using it as a synonym for "search" in everyday conversation. *shudders*
This is a good observation, drawing contrast with *google* as a verb, which these days seems to roll off the tongue nicely. If we were to imagine DDG replacing Google entirely, utterly, as-if-time-travel-existed, it's definitely a terrible name in that sense. But since DDG is merely a competitor today, against a search service so fundamental to the modern Internet as Google, I imagine the best-case scenario is that we collectively eventually stop using a verb meaning *to search using google* and start using one that means *to search using whatever*. Because popular language just doesn't give a fuck and doesn't generally have to show up in court, that verb could even just be an expanded form of the original *google*. &gt; I just googled it on bing and it turns out the term originated from an old search engine literally called Google I guess my point is duckduckgo would be a terrible replacement for google in the common vernacular, but it would never have to be anyway. Ideally we end up with more than one dominant player and a more generic verb.
It lets you predefine setup and teardown activities to be preformed when running function, then runs them for you. It makes it so you dont have to write the same boilerplate every time you do something.
So I ran the tests, using a simple Brainfuck to C translator, then compiling the output with gcc with -O3, it takes about 2 seconds. So in this particular case, compiling is still about 7 times faster than the fastest interpreter I could run (in C or in Rpython with the JIT). I updated the [page with the results](http://alexprengere.github.io/PythonBrainFuck/) with the sources and the numbers.
The equivalent is more like: f = open("filename", "r") try: lines = f.readlines() finally: f.close() Your's would only close the file if there was an error, whereas this closes the file no matter what happens. The other thing is that exceptions in the try block are possibly swallowed. The context manager decides if the exception is one it handles, or if it's one it should pass on. In the case of files, you'll probably find IO exceptions get swallowed, and anything else is propagated. https://www.python.org/dev/peps/pep-0343/
This is going to look weird now because I edited my post with this change a few minutes before you posted. Thanks, though.
If you know the index you don't need to iterate over the entire list. def make_move(state, position): temp_list = list(state) temp_list[position] = "_" temp_list[position+1] ="_" return ''.join(temp_list) Of course I didn't check if the index is out of bound but you can do that yourself. EDIT:To anyone please feel free to inform me if there is a better way to do this. 
Elaborate?
https://8ch.net/tech/ddg.html Overall they shouldn't be shadier than Google.
lol i wish
Why import PHP 7 when we got Python 8 which is greater than 7?
!bang will give you that list.
what does this even mean
I'd argue that they're not giving value in return, since they trap you in a [filter bubble](http://dontbubble.us/).
&gt; doesn't generally have to show up in court Generally not, but the usage of *Google* as a generic term will probably end up in court some day. If it does become generic ('I just googled it on bing'), then the name 'Google' is no longer a trademark.
I've been using it as default search for a few years and there has been a noticeable improvement in results. Just in the last year I've seen a couple of searches where duckduckgo actually gave better results than Google. You can always type "!g my search terms" and it drops through to Google.
My bubble feels more like a constricting forcefield. I'm really aware of it and it's quite annoying when I'm seeking new knowledge. 
missing noscript fallback ?
Sublime Text 3 is a great option because of its flexibility. Here are two posts setting it up for python development: http://piotr.banaszkiewicz.org/blog/2013/08/24/sublime-text-3-for-python-development/ and https://realpython.com/blog/python/setting-up-sublime-text-3-for-full-stack-python-development/
The dictionary definition of "set" is worth looking at - this isn't exactly a new phenomenon.
Sounds good. With `get`, I'm saying you can save implementing it twice. It's basically just this: def get(self, key, default=None): try: return self._data[key] except KeyError: return default You could avoid duplicating logic in `set` in a similar fashion.
Incognito. 
I'll do someone's homework as long as they're willing to pay my hourly rate.
This is why IT jobs are being outsourced to India and China.
I had the same problem while using a VPN once...
Go to www.ddg.gg and search !bang
That is interesting. 
[removed]
I do the opposite! When I'm looking for a gisted question or can't be bothered to type the full URL, I'm Feeling Lucky or Google do the job so that's what my omnibar is set to use. But if I'm looking for something specific, google tends to pick up sites which don't actually include all of the words I searched for, or it corrects an acronym to a completely different acronym or a real word, because it assumes I'm an idiot who can't type, and there's no way to get it to just search for websites containing all of the words in your query.
I enjoy using my Mac for data analysis as well but our company uses Windows only. I've slowly just started only using my work laptop because due to laziness 
I'm not a python guru but... Are you are trying to assigned 1024 to the variable "multiple" and then do an if then else? If so, shouldn't the assignment and if then else be on separate lines? Doesn't the "if a_kilobyte_is_1024_bytes" require a colon (:)? 
I have the feeling that copying'n'pasting directly into the interpreter may have actually pasted it as a single thing, not lines and such. I'd recommend pasting it in a text editor (like Atom, VIM or that pure text editor in OSX, which I completely forgot the name) and running as described in the site. You can run the whole thing in the interpreter, if you want, but it would either go back to "&gt;&gt;&gt;" after each statement. The fact that there is no indication is what makes me believe the problem is that it actually got pasted as a single thing. *Edit*: Here, on my Windows box: http://i.imgur.com/yTEEZI1.png As you can see, when the interpreter is waiting for something, it will show "...". This is missing on your screenshot.
Notice in the REPL the &gt;&gt;&gt; prompt only exists before and after the block. It is trying to interpret the entire thing as one block of code when it is really 3 main blocks, the `SUFFIXES` declaration, the `approximate_size` definition, and the `if` statement at the end to make the script library-like. This would evaluate fine if it were in a file like `test.py` and then executed with `python3 test.py` but the REPL/idle has problems with this. An easy way around it is to remove the blank lines within the chunks and make sure there are at least two blank lines between main chunks when pasting. Pasting the following should work (it works in the python3 REPL on my linux machine, not sure about IDLE on OSX), or alternatively, pasting each of the 3 main chunks i mentioned above separately would do it. SUFFIXES = {1000: ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'], 1024: ['KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']} def approximate_size(size, a_kilobyte_is_1024_bytes=True): '''Convert a file size to human-readable form. Keyword arguments: size -- file size in bytes a_kilobyte_is_1024_bytes -- if True (default), use multiples of 1024 if False, use multiples of 1000 Returns: string ''' if size &lt; 0: raise ValueError('number must be non-negative') multiple = 1024 if a_kilobyte_is_1024_bytes else 1000 for suffix in SUFFIXES[multiple]: size /= multiple if size &lt; multiple: return '{0:.1f} {1}'.format(size, suffix) raise ValueError('number too large') if __name__ == '__main__': print(approximate_size(1000000000000, False)) print(approximate_size(1000000000000)) 
I mentioned in my post that I didn't add it. That was intentional :) 
It's a pretty capable language with a variety of libraries available. I have books from computer vision, to how to build a rootkit, to parsing and processing data, and that's just a few small examples. There's a lot you can do; it's hard to provide a single direction when there's so much you can do with it.
Yeah, I also get captchas from google whenever I'm searching with code-related strings. Its really annoying, especially when you get 2,3,5 captchas per minute. Sounds like I should give DDG another try...
Probably best to tell us what your interests are, and then see if anyone has pointers to libraries that fit them. It's actually hard to find a subject that someone hasn't created at least a primitive library for.
Now all you need is to add PHP versions of the standard types where operators are overloaded to match PHP's behavior. For example, you should be able to do `PHPStr("42 is a number") == PHPInt(42)` and get `PHPBool(True)`.
If it helps I like science and minor in chemistry. Maybe something in that area. 
Great article. In the last section when you're using a pool to execute a map - is Gevent necessary here or could one just use the pool from multiprocessing.dummy?
(Just for the record it would probably be better to post your future questions in /r/learnpython) You seem to be copying a full program (multiple statements) into the python shell, which expects only a single line of code (a single statement). This is where the error comes from. To fix this copy the code into a text editor (notepad, IDLE, etc), save it, and run it using the `python your_file.py`. Or if your are using IDLE just press F5.
Gevent gives you much better concurrency for I/o heavy applications. Processes through the OS are heavy weight, and are much better for CPU intensive workloads. 
Python has pretty strong scientific computing libraries. Scipy and Numpy might be useful for your coursework or research.
Is this from inside a corporate network? My company has a small handful of shared exit IPs for a couple thousand employees (many of us sysads), so the sheer volume of Google queries used to get us throttled or capcha'd. Haven't seen it in a while, though.
That usually happens to me when I use proxy.
Is Google down?
Just a small suggestion. At present, clicking the video hyperlink in PyTube.org takes the user to youtube. What I feel is, it'd be of much better user experience, if we can embed the video source from Youtube similar to how PyVideo.org does. Loading the youtube directly would completely distract the user experience.
No. I just thought that I should get some primary research along with some secondary.
Here's a list of sites that list remote Python jobs http://remotenation.co/blog/top-6-sites-for-finding-a-remote-python-job/
Also, ipython/Jupyter (recent name change there) was designed to support scientific experimentation that needs computer support. As a professor who tends to use games as driving models, please note that you can actually learn a lot making games. I claim that all of computer science hides in there: performance issues, graphics (okay, not in text adventure games), language processing (both in making design tools and in processing player input), and even the standard input-update-display loop at the core of ever GUI program. So, I would claim (in my totally biased opinion) that you are learning transferable skills. If you're feeling bored, see if you can set up a game that permits players to write macros. Just a thought.
You are aware of the csv module [python 2](https://docs.python.org/2/library/csv.html) or [python 3](https://docs.python.org/3/library/csv.html)?
I find their searches are much better these days. I still rely on using Google Image (!gis, then they shortened to !gi, now to !i--thank you for the tip!) to search for images because in the past their default bang command for searching images went to Bing and it didn't work unless you have JS enabled.
Don't be. I guess it happens. If this was /r/privacy we would be swimming in karmajuice.
more retarded than false
It's an irc bot. Well, a slack bot.
You need to be behind at least 7 proxies. 
I can look for it when I get home. I have a bit of a backlog on material and haven't got to it yet so I can't tell you how good it is, though. I'm working through computer vision right now.
That's terrible design. Not intuitive and violates the principle of least surprise. I can't tell you how many times I wanted to click on images and clicked on videos or news because the order had randomly changed. Design that can't be learned is not good.
Relevance? DDG returns shit. That is why I don't use it.
Thanks, just saw this, I need part one. I think I have wsgi configured in apache but never got it to work. I abandoned it after that frustration
I switched to ddg in maybe 2013, haven't looked back. Its awesome once you learn the shortcuts and tricks. Its like the VIM of search!
PyCharm
What about some kind of data analysis? That's a big topic at the moment.
I've only ever had one search on DDG which didn't return what I want because it wasn't personalised. It was a search about the *panda* library in *python* and DDG returned pages about snakes and panda bears. (The search was just `panda python`.) So I tried the same search in Google, with the filter bubble switched on. I expected that since Google knows I search for a lot of programming help, it would know to give me stack exchange questions and man pages for the panda library. Nope. It just gave me pictures of snakes and panda bears too. I then went back to DDG, added stuff to my search query and got what I want. Everyone *expects* personalised search to return better results, but I have really seen nothing to demonstrate that it does. I suspect Google advocates have a bit of confirmation bias in this respect.
I really like PyDev for Eclipse but don't like Eclipse that much. Sounds like a contradiction but PyDev is really nice. PyDev is a fat IDE compared to the light weight solutions so you do need a decent computer. 
the only way I found to disable this is removing all my search history and disabling it.
Here here for giving up for a week or so
Given he titled it with "CSV" he's probably aware of this but just in case: if you have Excel files you have to explicitly save them as .csv files to work with them using the standard CSV module. Otherwise you'll need a module capable of reading .xls/.xlsx files.
The site is not yet optimized for mobile I am currently working on an update to fix that. Edit: currently this is just the first prototype to get the site up and running so i scraped just enough data to have people test it out
Huh I typed "Reddit" in the search bar, and got nothing back. Not sure what I'm missing here...
It's a news search engine.. I'm cataloging news and news events that go on around us to stream line the user experience in reading them.. So far I have only done the three filters on the sidebar and the news articles fro m those filters.
I wonder what will happen to the Slack fad now that MS is making Skype similarly easy to extend with web-based bots.
Can you link to more about this? I actually have a use for making a Skype bot, but last time I checked I couldn't find anything about it. &gt;_&gt;
For parsing data from excel look into using openpyxl Here's a link that shows how to use it: https://automatetheboringstuff.com/chapter12/ Chapter 12 – Working with Excel Spreadsheets
Well it depends on what you typed..Its just a prototype so I used a small number of titles from 3 channels to test it out. If you want.. Pick an object from one of the filters on the side bar and search for it
I just ticked the newspaper checkbox, left search box empty and searched..
Try searching for the items in the filters.. Like search for the articles with the name "Sanders" or something. Also if you are on mobile, it isn't optimized for mobile yet
For me (and the company I work at) it depends if they release a useable Linux version ever.
Hey, cool project! I think the core function makes sense. When I search for something, you will give me all the results back. If I check the box of a news site, my results will be *filtered* for that selected site. So I was a little confused when the behavior on the dashboard to the left gave me *Top Stories* for a particular site though it was labelled as "Filters". I thought it was a little weird that the other poster said that some menus didn't work on mobile. I can't try ATM nor can I replicate (iPhone). I see that you're using Bootstrap elements and I would believe you should get the cross-platform portability for free as a tenet of Bootstrap. With that said, I'm really interested on how you're working in the background: are you web crawling for news? How so? Are you going to the sites themselves? How are you *ranking* results to return as in are you doing anything to consider how relevant an article is to a query? Or are you only string matching on article titles? Don't want to sound like I'm grilling you. These are purely out of intrigue because I love this stuff. Thanks!
Does anyone know of a Chrome extension that only switches to ddg when there's a bang shortcut in my omnibar? I would prefer google as a default.
Gotcha. Was wondering why it wasn't working that we'll on my Android. Even so, looks good and functional.
This sub is for news about python, not questions. Try /r/learnpython.
Sorry mate!
Looks down now. Did you use tf-idf? If not, Google it 
Just use irc
http://alternativeto.net/software/dreampie/
If you're taking a course that's giving you homework, but you haven't managed to pick up whatever they're teaching you, in _python_, arguably the easiest programming language there is, I'm afraid you're beyond help. Go read [LPtHW](http://learnpythonthehardway.org/), and follow along with it.
The site is down on my end - seeing the typical 503 Service Unavailable error. Any chance that you have the source code on Github? Thanks!
I have kept trying to use DDG, but the fundamental nature of DDG is the reason why the results weren't as great as Google. That said, for someone who is constantly trying to branch out and learn new things, Google has actually started to go down hill. They have learned, for example, that I like Python. If I ever wanted to learn about Pythons, the animal, I'd have to really be smart about my queries. I am also to the point now where if I ask something like "how to split a string" to Google, my entire first page is how to split a string, in Python specifically, which can be cool, or restricting. The other thing I don't like is finding NEW sources for content. I am almost always served content that is older, by at least 2-4 years, and almost always the same sources as I have previously liked. When it comes to programming, practices and modules have changed. Even syntax for those modules has changed. That's one reason why I am both interested and a bit skeptical of "instant answers" for programmers. Almost every language changes over time, time moves quick in the tech world, and that's a massive corpora to maintain and keep up-to-date. 
I would love to but I wouldn't enjoy explaining to our managers (who use slack) how to use IRC. Slack is just easy.
Mod there, we welcome those sorts of posts.
right now i just ranked the results on the date and the time it i scraped it into the DB, so the latest addition would pop up first and the rest was a pure string matching based on the title and Description of each individual title
Hi there. You have posted a learning question to /r/python. These types of questions are far more suited to /r/learnpython, where users are actively interested in helping people to learn. Please resubmit it over there! Make sure to read their sidebar rules there before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." If your question is about homework, show them that you've tried to solve your problem in your post and you should get all the help you need. For anything else, the reason you are seeing this message is still that you will likely get a better answer there! Warm Regards, and best of luck with Python!
Hi there. You have posted a learning question to /r/python. These types of questions are far more suited to /r/learnpython, where users are actively interested in helping people to learn. Please resubmit it over there! Make sure to read their sidebar rules there before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." If your question is about homework, show them that you've tried to solve your problem in your post and you should get all the help you need. For anything else, the reason you are seeing this message is still that you will likely get a better answer there! Warm Regards, and best of luck with Python!
Yeah, this is probably more functionally by using a real lambda* as opposed to a closure: increment = lambda x: x + 1 f(1) 2 *a lambda as defined by PL theory / lambda calculus
I'm happy to see people writing things like this. I think the functional paradigm is a useful one - not for everything, but there are lots of areas it makes sense. That said, this was a haskellers intro to python, not a pythonic intro to functional programming. - using map and filter instead of comprehensions. Yes, map and filter exist, but comprehensions are generally thought to be more expressive. - defining functions with lambda. It's a bit of the language which is rather week and limiting. Just don't. Lambda is spelt "def" in python. - recursive functions are a bad way of looping in python. You'll blow the stack before you know it. - The section on lazy evaluation. Generators? Think of them as explicit "Thunks" All in all, I recommend not writing code this way in python. Design in a functional style for sure, but don't express it in code like this. 
It's not formed a closure, because it doesn't close over anything, instead it's just poking global state. f = lambda x: lambda y: y+x g = f(1) That forms a closure.
Yep - I'm not saying it's a great function to define, just that python's lambda (as opposed to a lambda in the lambda calculus) has no qualms about such a thing. As of parallel reductions - I wouldn't say it would *necessarily* require them to be the same type, no. A good example would be something as simple as sums. Sum each pair, then each result of those sums until you have one final value.
Ah my mistake
Agreed. The examples aren't Pythonic.
Thanks for the reply, It's definitely piqued my interest and I'd like to try it out but my math skills are not sharp and it feels like Functional Programming is quite mathematically oriented 
In general, functional program makes functions and systems easier to reason because of the properties mentioned in the blog post (primarily immutability, which naturally leads to data flow style programming). This gains importance as a system becomes more complex and codebases grow. Put another way, OOP (primarily inheritance) is great as long as you can fit the entire system in your head but it doesn't scale cognitively. In practice, my team forces immutability by using `namedtuples` for a web framework where persistent mutation is only performed within the model layer. If you do GUI stuff (web / desktop), Facebook's React uses [FRP](https://en.wikipedia.org/wiki/Functional_reactive_programming) vs the jQuery / Angular. Lazy evaluation is not a core concept unique to FP. For example, Python 3 defaults to generators. At a coding level, `map` / `reduce` / `filter` are higher level abstractions that make code easier to read and write. In the land before `for` loops, there was assembly code. Let's say we wanted to do something in pseudo-assembly: # I'm kinda ignoring registers i = 0 size = 4 array = 0x123 cmp i, size jeq istrue # load array value from heap into register # cmp if even # add 1 if it is # check number of results # if enough, jump to end of iteration # store back in array on heap # jump to the beginning of iteration People were like for loops are a useful abstraction, so you get: for (int i=0; i &lt; input.size(); ++i) { if (input[i] % 2 == 0) result.push_back(input[i] + 1); if result.size() &gt;= n: break; } For each loops are even better: for x in input: if x % 2 == 0: result.append(x + 1) if len(result) &gt;= n: break; Then we get into list comprehension and map / filter land. They're two ways of doing the same thing, but just at a higher abstractraction so you don't get tied down into the mechanics. List comprehensions are more Pythonic: [x + 1 for x in input if x % 2 == 0][:n] # less efficient, only example that evaluates all results With map / filter: is_even = lambda x: x % 2 == 0 increment = lambda x: x + 1 take(n, map(increment, filter(is_even, input))) In other languages you can change use a left to right evaluation order making it easier to read: $ cat input | is_even | increment | head -n &gt; results.txt Input.toList() .Where(x =&gt; (x % 2 == 0)) .ForEach(x =&gt; (x + 1)) .Take(n) You'll notice until the last few examples, iteration and calculations are mixed. When you separate them it makes it easier to test. Also the code becomes more declarative, making it easier to understand what something is achieving instead of getting bogged down in the mechanics. How easy something is to read depends on familiarity. Java / C programmers find `for` loops the right level of abstraction. Python programmers prefer list comprehensions. I argue that the last few examples are easiest to read and test once you're familiar with those abstractions. &gt; for me it seems anathema to everything ive learned about programming for software development. It is because: 1. Computers / performance are generally not a bottleneck anymore. Now developers are: correctness / fixing bugs, cognitive load, hiring, etc 2. People don't like change, particularly if they're already mastered solving a problem. They've maxed out local optimum and changing will result in a temporary efficiency loss. 3. Easier reasoning about systems only matters to those who have / desire a holistic view. Most people just want to solve immediate needs.
Another good example is high frequency traders. See https://www.janestreet.com/technology/. I use OCaml and Python, and actually prefer OCaml for anything large or principled, and Python for sketching out ideas. Static type systems and functional paradigms enforce discipline for me much better than alternatives, but YMMV.
this helps a lot: http://funcy.readthedocs.org/en/stable/
If it's short pieces, http://codereview.stackexchange.com sounds like a good place.
Aha, I see what you were getting at. 
&gt;The section on lazy evaluation. Generators? Think of them as explicit "Thunks" I agree with this. I really like functional programming and python is my go to language for writing small scripts, gluing things together and scipy stuff. For me the functional parts of python IS iterators and generators and I use them as much as I can. I think I import stuff from itertools in pretty much everything I write. The author does make a point about iterators not being pure and therefor not used in his version of functional programming in python. I think that point is rather weak though. Especially considering he then proceeds to talk about map and filter which both return iterators. Nobody is saying functional programming languages have to be 100% pure. In fact, if they were they would have no way of doing IO(Haskell separates pure from impure code using the type system, but you still have things like references and IO if you want to use it). The statefullness of iterators in python can also be nifty sometimes. For example this function I found on stackoverflow which checks if a set is a subset of another were the sets are represented as sorted lists without duplicates: def issubset_ord(a, b): b_iter = iter(b) return all(e in b_iter for e in a) The b_iter keeps track of the position in b, so we don't have to scan the entirety of b for each element in a (remember these are sorted lists) TL;DR you can get a lot of the benefits from functional programming with iterators in python, and in practice you will not be writing 100% pure code in python anyways. 
You can also do like this: take(n, x + 1 for x in input if x % 2 == 0) in my opinion this is the nicest way. It is as efficient as the map/filter version and as readable as the list comprehension version. (Note, this also has the same result as the map/filter version, namely an iterator. The other versions return lists. To get a list you just call the `list` function on the result) I guess this would be the "generator comprehension" version. 
&gt; (lists are objects and not arrays--most languages use arrays), which leads to some weird behavior That "weird behavior" is due to `a` and `b` being `names` (as opposed to the [variables](https://en.wikipedia.org/wiki/Variable_%28computer_science%29) of other languages), and not due to `lists` being `objects` (as opposed to arrays)
I don't think people thing imperatively, either; not from birth. They're both learned methods of thought. Mathematicians tend to find it far easier to think about and prove things about functions when defined recursively. Imperatively defined looping constructs mutate state; this is fairly well known to be problematic and difficult to think about. 
yeah i had to upgrade my heroku subscription since the free dyno was dead. It should be alive and running now
Did you use a web-framework to make this? If so, which one?
this fucking post again
Also check out /r/pygame.
thanks alot i will keep on working on it adding more stuff and creating a better front end.
term frequency, inverse document frequency for query relevance?
Yup, it's extremely straightforward and if you implement that, you'll have a decent search engine on your hands.
I've used it once for a project but it was for a recommendation system. I'll look up how it applies to search engines.
I think the biggest contribution of functional programming is the avoidance of side effects. Side effects make it much harder to reason about your code, regardless of language. In any modern language (e.g Python, C++11/14), it should be possible to write code that doesn't depend on side effects. Obviously, there are some exceptions to this, where is just is harder to write side-effect free code, but in those situations, you can at least encapsulate all of it in a class. (I make the distinction of modern language pretty much because of C). A lot of the other paradigms / idioms of functional programming don't translate as well. Stateless code (which a pure functional language like Haskell demands) is a poor model of the computer's operations. Yes, a computer has a processor, but it does have state. It has a hard disk drive and random access memory. Abstracting away from that makes a lot of things harder, in my opinion. (Don't get me wrong, I think functional programming is elegant and fun to write. But I think it's important to acknowledge it's limitations and weakness as well.)
The current state of SOAP in Python is abysmal -- I have high hopes for this project, and any others.
Yeah, this project was born out of my frustration with the current soap libraries. The idea is to leverage lxml for most stuff where possible. This makes it incredibly fast compared to suds, especially when soap response get bigger.
Is there anything on par with [`suds`](https://fedorahosted.org/suds/)? That's what we use at edX to interface with CyberSource (payment processor).
`suds` is a good library, but it's not really maintained anymore. It's also not great at custom types. [`spyne`](http://spyne.io/#inprot=HttpRpc&amp;outprot=JsonDocument&amp;s=rpc&amp;tpt=WsgiApplication&amp;validator=true) is also very good, but very complicated.
This explains *how* to do it, not *why* I should do this. Not really that useful of an "introduction" to me, it doesn't solve any of my problems. Nor does it inspire me to think of problems that would best be solved this way.
http://scrapy.org/
&gt; I don't consider myself a "good" programmer. Good programmers never do; they know there's always more to learn. /r/learnpython, as /u/ironmanmark20 said.
I'm finding it hard to conceive that looping - repetition - is an unnatural human construct. There has been research about learning to program. Tests were administered to CS101 students before they began the class. It turns out that there was a huge correlation between the results of the test and the final grade in the course. This was depressing for teachers, which suggested their actual teaching methods had little impact. Popular articles on the subject made the rounds with headlines like "Is programming skill hard-wired"? The single most predictive factor as to whether the student would pass of fail the course? Whether they got the QUESTION ABOUT RECURSION right or not. I had an "A-ha!" moment reading that as I'd independently formed the same opinion. While tutoring several people when I was in college, I observed that there were indeed some people who simply "got" recursion and some who did not. I was never able to come up with a way to help folks "get" recursion if they didn't follow it, unlike some other concepts. 100% of those I was tutoring who didn't get recursion ended up switching majors. Fast forward more than 20 years and I was working at a new job (not IT department, but lots of computer use). Some colleagues were talking and one of them said to the two of us who worked with computers that he had actually started as a CS major in college but it was too hard for him so he switched. A light-bulb went off and I asked him what specifically led him to switch. "That thing where functions call themselves." Recursion! I'm interested in genetic programming and genetic algorithms. Many years ago I was reading a popular science article about the use of evolutionary code to design computer circuits. One example was given where engineers commented how different and hard to analyze the final (working) result had been of one experimental circuit-evolving run. One of the weird things involved intermediate output being fed back into the input; it didn't make sense but it didn't work if they stopped it. In essence, it was recursion. The engineers commented how "alien" the circuit design was and how it didn't look anything like what "a human mind would designed to solve the problem". Given all that, it's really difficult for me to think of recursion as something intrinsic to most people. Linear problem solving, A-B-C-D, and breaking down problems into smaller ones (subroutines) are typical human problem-solving approaches. Heck, even parallel computing doesn't come easy to human programmers!
Why do you think the author did not want to show the Pythonic way of functional programming?
Functional programming is good for programs that rely heavily on events occurring based on a particular state. You could program a finite state machine iteratively, but you'd honestly get a somewhat less neat version of a functional equivalent. It can also be good for programs that need to be fault-tolerant, concurrent, and/or high in parallelism. I suggest reading up on why some people use Erlang. Some problems don't lens themselves well to looping and OOP, and this is a nice alternative. 
After some practice, you'll find that in many situations a comprehension will be more flexible and therefore more readable. If you already have a function defined, a map or filter may be better. A comprehension tends to be better than using a lambda. Reduce is a more complex alternative to things like sum, min, max, etc. Comparing reduce to a comprehension is apples and oranges. I'm not sure what benefit an "ireduce" would have as the goal is to create a scalar, not a sequence.
I already have PyQT, will PySide conflict with it?
Of course there is no ireduce, I don't know what I was thinking :). My mistake. I do use reduce when doing things more complex than min/max/sum. I might build out a data structure from a list for example. Don't get me wrong, I'm not against comprehensions. I don't see a problem with using comprehensions for something straight forward like, `total = sum(product.price for product in products)`. That said, I have worked in a code base that over used comprehensions. There would be loops with multiple nested conditionals that made it hard to read, like the programmer was showing off how clever they could be. I get avoiding labmdas, they are slower because the interpreter needs to make a new function. I was wondering if there is something similar for comprehensions, like maybe the interpreter has optimizations for them or something.
That's something I've been confused about - if third parties can provide windows binaries regularly for Numpy why can't the project do this? 
Well Python 2.7 will be supported until 2020: https://docs.python.org/devguide/#status-of-python-branches
try portable python
Avoiding lambdas is more about readability than speed. In most cases, a comprehension is similar speed to map/filter. The important thing is to avoid doing a for-loop with repeated ``.append``. Even then, the speed gain isn't huge. And of course, generators are usually better/faster when viable. Outside of map, filter, etc. sometimes lambdas are cause mistakes due to the late(r) evaluation of globals than some people might expect. It's no different than a regular function, but I've seen people misinterpret when terms in the return expression are looked up. You should probably use ``functools.partial`` instead of lambda to create a callback, for example.
Yeah, good suggestion and its in the queue. 
Fault tolerant and used telecommunications. http://learnyousomeerlang.com/content Or take a look at http://elixir-lang.org for another.
Everyone can argue about what "pythonic" really means, but examples use `+=` to modify an attribute, and that's definitely not pythonic to me. I reproduce the example below: &gt;&gt;&gt; task = Task('2016-03-20 write docs for a +todo.txt-pylib') &gt;&gt;&gt; task += '@foss' &gt;&gt;&gt; task '2016-03-20 write docs for a +todo.txt-pylib @foss' &gt;&gt;&gt; task += TaskDueDate(datetime.date(year=2016, month=3, day=25)) &gt;&gt;&gt; task '2016-03-20 write docs for a +todo.txt-pylib @foss due:2016-03-25' &gt;&gt;&gt; task.is_overdue True &gt;&gt;&gt; task -= TaskDueDate Having said that, this is your project, and you're allowing the rest of the world to read, use, and modify your work as they see fit, so I still think that's awesome.
Python has declarative bits in it, it has some support for functional programming, but it's not really a declarative language just because it has array comprehensions, and it lacks sufficient support for functional programming for it to attract community momentum. I would say Python is an imperative language with object oriented support. The top post suggests that a common tool for functional programming, recursion, is bad due to performance reasons. A little searching suggests that Python had to make a technical tradeoff to exclude tail-call optimization, and that this might be a permanent decision. I think it's a violation of some implicit contract to look under the hood of Python, but in order to not do that, Python has to make whatever strategy sufficiently performant that you don't have to be conscious of internals. Anyways, the top post is about what's Pythonic, which means a community norm to speak the same way, and given that (1) Python is used as an introductory language, (2) a lot of people who use Python value a "getting things done" pragmatism, (3) functional strategy is alien to a lot of people, I don't think the Python community is going to shift its norm anytime soon.
I'm aware that functional programming allows for implicit state, but I think the fact that it must be implicit that's the (occasional) problem. Sure, you can pass around an array or whatnot from function to function, but that sometimes causes the program to be formulated in a very unintuitive way. Plus, as you say, that can make reasoning about performance difficult. &gt; You can also turn the correspondence with machine architecture around and argue that because it's so abstracted from the hardware, there's more room for the compiler to decide how to properly optimize a program. I don't have enough Haskell experience to conclusively disagree with this, and I am aware that Haskell can be quite fast. Still, I don't buy this. For a given bit of C++, I can be reasonably confident in what will be allocated in memory (even how it will be laid out in memory, to some degree) and what instructions will be run. I don't think that can be said about Haskell, but I'd be interested to hear your take. Also, like I said, I enjoy writing Haskell (I've just started playing around with it), but I do have a hard time imagining when I'd use it, especially compared with Python and C++. What are you uses?
Are you currently interning in a lab? The first thing I'd recommend us to automate any data analysis you'll encounter. Build in automatic quality checks, maybe use machine learning to identify abnormal experiments, or write software to control instruments in new ways (I recently wrote software to give my UV-Vis all sorts of functionality, as well as integrated a bunch of ADCs to assist in high speed data collection - so something like that). Maybe see if any of your experiments could benefit from lock-in amplification techniques or write a PID controller for some experiment requiring a temperature ramp. Make some software for multicomponent spectral deconvolution, write a fitting algorithm for XPS or other well-characterized spectroscopies. Write your own DFT code and turn on/off forces/fields in your functionals. Basically, just get out there and write something that interests you and makes your life easier.. Build your own tools. 
suds is currently maintained under this fork: https://bitbucket.org/jurko/suds
Thanks! This helped a lot! Now I just have to figure out how to store the results in a MYSQL database
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/functionalprogramming] [A introduction to Functional Programming for Python coders : Python](https://np.reddit.com/r/functionalprogramming/comments/4d9jgu/a_introduction_to_functional_programming_for/) - [/r/sametmax] [A introduction to Functional Programming for Python coders](https://np.reddit.com/r/sametmax/comments/4da1id/a_introduction_to_functional_programming_for/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
Did you have a stroke halfway through that title?
If you're going to down vote, can you explain why he's wrong? 
They can. **If** they have non-broken compiler etc. As the note "Windows binaries are not available.. due to broken toolchain" implies, this is not the case. What can be involved in 'broken toolchain' here is potentially complicated, but thinking of it as 'dependency hell' is not too far off. An example of broken toolchain.. is when multilib gfortran for Arch Linux was broken.. well, essentially I could have a working GCC or a working GFortran, but not both at the same time. That effectively prevented me from compiling NumPy, because it needs both C and Fortran.
In accordance with [Poe's law](https://en.wikipedia.org/wiki/Poe's_law), I'm not sure if this is serious or not. I'm guessing not, since it mentions left-pad as a positive example and has 'ONE TRUE PACKAGE MANAGER' in all caps, but there are some genuinely nice things about project-local package management, and it seems like a fair bit of code to write for a joke (not that that's a reliable indicator).
We shouldn't need a compiler to install python libraries. 
How else do you generate the binaries that enhance numpy so much? 
&gt; Those pay walls are what keeps many of these publishers in business. You say that as though it is a good thing. Scientists write the articles, sometimes having to pay to have them published. Scientists review the articles for free. Scientists edit the journals for free. The publishers then charge the scientists to read the articles, usually using using bundles to force universities to pay for journals they don't even want. And for what? Web hosting? The ad space the journals sell can cover that (or the fake industry-sponsored "journals" the publishers try to sneak in periodically, pun intended). Journals made sense when you needed paper journals, but pretty much nobody uses those unless the online copy is not available (which is usually only the case when the publisher's bundle arbitrarily excludes articles older than a certain date, even though they are available online from the publisher for an exorbitant price). They are making massive profits off unpaid labor that really has no choice in the matter. So yeah, she is stealing and breaking the law. I don't agree with that. But I won't shed a tear for the publishers.
Have a look at [WinPython](http://winpython.github.io/#releases). You can either go for the Zero variant which is a portable distribution of Python, or the Full, which bundles Python with quite a few of the most used packages.
Linux distros usually compile from source for their own packages.
I'm saying that the binaries should be included for those platforms (like Windows) that don't have compiler toolchains.
Yes, I realized I misunderstood, and had just deleted my comment. 
It's faster, and more beautiful from timeit import timeit setup = ''' bbs = '01110011001000000110111001101111001000000010000001101001001000000111001101101110001000000110010100100000001000000110100000100000001000000110010100100000011100100010000000100000011100000110110100100000011011110010000001100011' ''' statements = ''' octets = list(map(lambda i: bbs[i:i+8], range(0, len(bbs), 8))) ''' statements_comp = ''' octets = [bbs[i:i+8] for i in range(0, len(bbs), 8)] ''' print('no comprehension') print(timeit(stmt=statements, setup=setup, number=1000000)) print() print('comprehension') print(timeit(stmt=statements_comp, setup=setup, number=1000000)) --- no comprehension 5.815302666308642 comprehension 3.9982997207760835
Issue is third parties might be providing wheels for their environment only. They only need to check they've done it right for one situation that they fully control. If numpy are putting wheels up on pypi, those have to generally work (and work well - a slowly compiled numpy by default would be bad advertisement) for many different pythons that are all accessing pypi through pip. When numpy put up their own wheels, they need to get it right the first time, and work for everything. Not the same task as Continuum building wheels just for their own Python.
pysimplesoap is pretty decent.
Most of the publishing system is auto-referential. Costs are there to support things that would not be needed to begin with. A scientific journal has zero expenses when it comes to its source material: it doesn't pay its authors, and doesn't pay its reviewers. 
&gt; you are a thief if you take something that belongs to somebody else Exactly. The publishers are thieves. The research is almost exclusively financed by the public and the results belong to the public. 
What about the editors? As in, the ones actually editing wording and making sure the style is confirmed to?
Roughly three million per year, apparently
Claims made do not match evidence provided. Would not download. 3/10
Yeah this is was I was afraid of. Thanks for your reply. 
For anyone who doesn't know about Aaron Swartz, there is [a great documentary about him](http://www.imdb.com/title/tt3268458/) and I highly recommend that you watch it.
I have a condition that in the future can blind me and I have been scared of it because programming is all I like to do. You post as given me hope
So he is a troll?
404 for the given link. Only found an npm project: https://github.com/orinocoz/pirateflix
delete previous crap what I got is import feedparser d = feedparser.parse('feed.rss', 'r') meLikes = open("./mystuff.txt", "r") meLikesContent = meLikes.read() #print ( meLikesContent ) #print ( "feeds: \n" ) for post in d.entries: post.title + ": " + post.link + " \n" if post.title in meLikesContent: print ( " \n Yes:" + post.title + ": " + post.link + "\n" ) # print ( post.title ) #else: #print ( "Just garbage. Ignore" ) 
Glad it helped ! Now choose your ORM: https://github.com/vinta/awesome-python#orm 
&gt; r the product and pric No. The python scrapper would walk trough every page for you, you just needed to define the structure for each of the 100 websites. For example: Website A product view page as the following structure: &lt;h1 class="product-name"&gt;Bike X&lt;/h1&gt; &lt;p class="price"&gt;200&lt;/p&gt; and the website as 30 products Website B product view page as the following structure: &lt;p&gt;Bike Name&lt;/p&gt; &lt;span&gt;59&lt;/span&gt; And the website as 50 products You just needed to define in the scraper the product view structure and the selectores for the information you want (bike name and price) and the script would search the data in the 80 product pages.
Would OP essentially need to write separate scrapers for each website since they all (usually) differ in structure? Doing a somewhat similar project where I scrape websites for apartment listings and as much as I'd like one script working for all of the websites, it seems unlikely. Feel like I'm gonna end up with quite similar code for every website I scrape. Any advice?
This has nothing to do with Python.
Would it be possible to leverage a search engine to get the page you want from each site? e.g.: for site in sites: https://duckduckgo.com/?q=bike+I+want+site%3A+{site}.com&amp;t=ffsb And get the links from the search results and parse the page on the site for whatever data you might want. Of course, getting the price out of each page without writing specific selectors might be really tricky. Or maybe, all the sites have their own search box you could try and use. 
Since this sounds like a one-off thing, what I would do is search the 100 websites for the name of the bike and if it, or shorthands/product codes, shows up anywhere on the page, just grab the whole page and make a pool of filtered pages you can feasibly look through manually. This assumes that your websites themselves will have the product. If you need to go deeper and follow links then it gets more complicated. I've wrestled with this before and by the time you find and set up a tool to do automated searches you'll have had to have done some manual pruning and selection anyways. 
So how you might actually go about doing this is to use Requests and BeautifulSoup. Use requests and possibly an asynchronous add-on like grequests to download your webpages. For each webpage you can [follow this example](http://stackoverflow.com/a/866050) to search for the node in the HTML document containing the bike's name or product code. Once you have the node in the tree, you can go up a level in the HTML and search all of it's children for a pattern matching a price (a regex like: `r"[$£]?(\d+(?:[.,]\d{0,2}))"`). The idea here is that in an HTML document the price should be a sibling node of the product or inside of a sibling node of the product description. If you find the name and a price, then you can log that info or just print it to the screen. If you find just the name, I would dump the website and look it over manually anyways to avoid false-negatives. If you need more specific help on getting this set up, let me know. --- ### Edit: I've never used scrapy before so I was just suggesting using requests. It looks like Scrapy should be able to do everything you need. You can just give it the list of all your websites in the `start_urls` list, they don't all need to be on the same domain. Then you could use scrapy to use beautifulsoup like this comment as a good heuristic for finding the info you want. 
thanks for the reference and the code. i was looking briefly for a more appropriate sub but did not find that one.
I don't think haskell abstracts away from the realities of the gritty details of the computer more than other high level languages e.g. python. It just uses the type system to separate pure code from impure code. You can create variables and mutate them in haskell. If the code is externally pure, you can even use the ST monad and use it in pure code. For example, you can implement in-place quick sort which is externally pure but internally requires mutating state and use it in pure haskell code.
how did you download a file with selenium?
&gt; it doesn't pay its authors, and doesn't pay its reviewers. In fact, journals not infrequently *charge* their authors to publish papers.
Shitposting is a venerable and time honored tradition. This just plain doesn't belong.
IMHO numpy, scipy, etc. are severely crippled if they are not compiled with MKL, and the only easy way (that i know of) to do this is to use anaconda.
Or use pip-compile and have it re-generate your requirements.txt from version specifications automatically.
&gt; I find it easier to model a problem when I can think about its components as objects and their interactions. I find it easier to model problems functionally so I can think about the functionality of components *without* worrying about an N^2 explosion of interactions. Throw threads into the mix, and it becomes practically impossible for me to reason correctly about all the states of the program.
This article is 5 years old. Anybody know if the software has been updated?
I am such an idiot. Selected_ID was an str Appointment_ID was an int (Autonumber on Database) You have literally just saved my life - thank you.
&gt; I'm finding it hard to conceive that looping - repetition - is an unnatural human construct. Looping is perfectly natural *in some situations*, but most of the real-life situations where we use iteration are completely different from those in the computer. When's the last time you looped over an infinite sequence in real life? When's the last time you had to repeat an action 20 times, and also prove before you started that your original plan would always work correctly for any inputs? &gt; I was never able to come up with a way to help folks "get" recursion if they didn't follow it, unlike some other concepts. 100% of those I was tutoring who didn't get recursion ended up switching majors. Computer science is an extremely young field. Isn't it possible we just haven't figured out how to teach it yet? I've been reading some 3000-year-old myths recently, and the language is rather simplistic. It's striking when they use metaphors because this language construct is so sophisticated for them that it's only used in a couple places. Is it a failure of "metaphor" as a concept that after thousands of years of writing they still thought it was a rare and special case that people would have trouble with? I'd say that today metaphor is one of the more powerful tools we have in language, and while many struggle with it in grade school, everyone eventually learns it and uses it. The same is true of recursion, except for some reason we wait until college to try teaching it. Imagine someone who never got through 4th grade being thrown into a college language class. *Of course* they're going to struggle with the basics. &gt; I'm interested in genetic programming and genetic algorithms. Many years ago I was reading a popular science article about the use of evolutionary code to design computer circuits. One example was given where engineers commented how different and hard to analyze the final (working) result had been of one experimental circuit-evolving run. One of the weird things involved intermediate output being fed back into the input; it didn't make sense but it didn't work if they stopped it. In essence, it was recursion. The engineers commented how "alien" the circuit design was and how it didn't look anything like what "a human mind would designed to solve the problem". That's interesting, but I'm not sure what it has to do with recursion. Remember, recursion and iteration are equivalent in computational power. Feeding the output of a function back to its input could also be written with iteration -- though if you think it's hard to reason about recursively, imagine how hard it'd be to reason about iteratively! (With recursion, at least your invariants are explicit.) It's true that machine learning often leads to counterintuitive designs, but that's hardly a strike against recursion. &gt; Given all that, it's really difficult for me to think of recursion as something intrinsic to most people. Linear problem solving, A-B-C-D, and breaking down problems into smaller ones (subroutines) are typical human problem-solving approaches. Heck, even parallel computing doesn't come easy to human programmers! Except the type of problem solving people tend to need to do in their normal lives is not the same type of problem solving they use computers to do. It's not surprising you'd need different tools. "Check every paint can in the garage to see if it's empty" is a fine task for iteration: there's a finite number of them, and each step takes about the same amount of time, and you can assume that there's no malicious input, and if something goes horribly wrong halfway through the loop you can stop and re-evaluate. Something as simple as "Parse a list of search terms that somebody passed to your web server" might not have *any* of these properties. Yes, it would be nice if computers were as simple as real life, but they're not, and we can't expect people to solve problems without the proper models. We've tried programming computers with English, too, and that failed miserably. As Alan Kay said, "Point of view is worth 80 IQ points." We teach recursion poorly, and much too late, but that doesn't mean it isn't a great and useful model. It just means we still suck at teaching computer science. I don't think anyone would disagree with that, in 2016.
Adding image support, so that they are encoded and inlined. I did a markdown to webpage (with my own extensions) and needed to send out emails, so I made it so that I could use markdown to generate html and plain text version of email (with simple mail merge features, so Hi {{To}}, it then went through and inlined styles (since Gmail strips out css code unless it is inline on the element). {image|page_logo.png|attach} This replaces the content with a &lt;img src="CID:&lt;file&gt;"&gt; and attaches the file to the message.
Not at all. He just would need to createa table with the domain of the website, the query for the place where the name of the product and the price on that domain. If you can give me 3 or 4 domains and the data you want I can build you a sample of the code you would need. In you case I think it would be possible to use regular expressions
The script won't upload the file online. It just shows the upload page, but don't upload the file. But, when I rename the file and remove the character and then upload it (via script obviously), it works just fine.
BADTIE: Bytes Are Decoded Text Is Encoded
They often do so by linking against the proprietary Intel MKL to provide the performant linear algebra routines. They can do that and provide the resulting binaries without fee, but those binaries are not open source. In particular, they are GPL-incompatible. That's a perfectly reasonable thing for a third party to provide with the appropriate documentation, but it's not really a friendly thing to do for the project's official binaries on PyPI.
/r/learnpython
I've not seen anything that imports portions of the JSON as bytes, just ones that read the data on the wire as bytes, e.g. b'''HTTP/1.1 200 OK Content-Type: application/json; {"this": "is some json", "which": "will then be some text"} ''' That's what would be bytes, but `response.json()['this']` would return the text, not bytes, `'is some json'`. Anything else is *definitely* wrong.
I like spyder as it allows me to simply run and debug a script without lots of setup or creating a project structure etc.
I guess the question would be "What does Python say when it breaks?" More importantly, what's the error message? Also, which side is breaking? Your upload script or the server? Your script may require something like # -*- encoding: utf-8 -*- To force Python to use UTF-8 for all strings.
If you want to build a game using Python you should have a look at pygame, it's a well documented library for creating games in Python. http://www.pygame.org/hifi.html
Have you tried # -*- encoding: iso-8859-1 -*- Instead? I see you're using Windows and my old memory says Windows uses ISO-8859-1 as its encoding (I think they may be using UTF8 these days, but still, maybe it's worth the shot). Another solution is trying to convert the filename before uploading it. So you get your filename and filename = filename.decode('iso-8859-1').encode('utf8') (or the other way around -- decode utf8, encode 8859-1. I'm never quite sure about the order of those things.) 
Just tried it. No luck... Just saw that I had added my function in 'try/exception' so it didn't output any error. Now this is the error : UnicodeDecodeError: 'utf8' codec can't decode byte 0xc2 in position 0: unexpected end of data
I would also like to know this. I learnt programming as a kid using QBASIC in MSDOS which made it dead-easy to print characters to arbitrary locations on-screen. Combine that with a clear-screen command and it was possible to develop animations and games without having to make art assets. I think it's a shame that this simple access to the display is now missing in modern programming environments.
Basically, I want to be able to supply some parameters (number of bedrooms, location - city, price range) and scrape several real estate websites for matching listings and return the ones that match. Seeing as a lot of these websites are slightly different, I thought I'd have to write separate scripts for them, some functions could be reused though (eg parsing the pages with BeautifulSoup). If you take craigslist, it's [city].craigslist.com/apa, if you take say another one, home.ie, it's something like home.ie/[city]/... Pagination is another thing I would need to account for. For now, I'm thinking of scraping maybe 2 or 3 websites and return the matching listings, just to get it working but would like to expand it to more in the future. Just want to get a decently sized project working for the sake of learning Python (3), Django and some modules (requests, BeautifulSoup4). You reckon it's possible to minimize the code duplication much?
Though I've (thankfully) never come across it in my own code, this is not the first time I've heard of this surprising behavior of Python 2. Part of the reason I love Python is that, faced with a design challenge, it almost always does the sane and intuitive thing. *What on earth* prompted the decision to order incomparable types according to their type names?
It's always the simplest things that get us. 
I wanted to created something in simple text only, I found this to be of use http://inventwithpython.com/pygcurse/ :) It's essentially a mixture of curses and pygame, it's well documented and was enough for me to make exactly what I wanted :D
Actually, my mistake, that seems to be just what I wanted! Fortunately I found something else, a mixture of pygame and curses that was well documented, I was able to make just what I wanted. Edit: I remember why it wasn't what I wanted, it's because I couldn't get it to work.
Being a novelty account is not an excuse. That trend on reddit rightfully died years ago.
/r/learnpython
Yeah, I did a pip install of numpy on a fresh Ubuntu system recently and it came linked against no linear algebra libraries. Granted it wasn't too hard to set this up once I started googling around, but many people wouldn't even know to do this in the first place. Linking against something like openBLAS provided about a 40x increase. However, through Anaconda it automatically came linked against ATLAS and was blazing fast. And now they link against Intel MKL by default so it's even better. 
I was gonna defend this title, but the title makes more sense if you just take the pointing hands and asterisks out and rearrange the sentence a little bit. It's also overly poetic.
Hi there. You have posted a learning question to /r/python. These types of questions are far more suited to /r/learnpython, where users are actively interested in helping people to learn. Please resubmit it over there! Make sure to read their sidebar rules there before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." If your question is about homework, show them that you've tried to solve your problem in your post and you should get all the help you need. For anything else, the reason you are seeing this message is still that you will likely get a better answer there! Warm Regards, and best of luck with Python!
Python 3 reasons.
It really is. You don't have to worry about the pagination thing for example. You can use a graph structure to store links of a domain, when a page is scrapper it extracts the content you want and links that where not visited yet by the scraper after that it looks at the graph for the first link stored that that was still not visited and scrapes and do this until there is no more links available. And the scrapping process itself can be very simple, for example if all website have some label before the information you want like "Number of bedroom: 3" you can use regular expressions. If it's not possible to use regular expressions you can the method I mentioned above that is using a "Table" or a list of dictionaries with the domain name and xpath queries to extract the infromation you want with BeautifoulSoup 
map doesn't work.
&gt; ctly what I wanted :D pygcourse looks awesome. Thanks for sharing it with us. You should recreate a retro game with it :)
Yeah, I'm running on a 2010, but running Ubuntu on new hardware is always hit or miss. 
I don't know what I'm going to make with it :P I wanted to originally set myself the task of making a space invaders game with a menu and everything, but that's a big task and I don't really know where to start :P I can paste my current code if you like?
What's your browser? Mobile or desktop? I checked desktop on Chrome, IE, and Firefox, and all seemed to work okay. Mobile on Chrome worked well too. Mapbox-GL maps occasionally have computer GPU specific issues. Can you view the following web page map from the Mapbox-GL examples page? https://www.mapbox.com/mapbox-gl-js/examples/
ncurses is a cross platform (partial) implementation of the curses api standard the curses api is pretty low level and ncurses doesn't support all the fancy advanced features, but neither did any other curses implementation really so nobody ever used them in curses programs. most people end up writing their own higher level wrapper around curses.
I thought I'd never come across this in any code I worked on, until I upgraded it to Python 3 and started getting TypeErrors. The problem with it silently succeeding (even when returning nonsensical results) is that you can't even tell you're using this behavior, without an audit. 
For a one-off like this, esp. If you're not interested in the coding aspect of it maybe mechanical Turk or similar would be a better idea? https://www.mturk.com/mturk/welcome
Nuped, which is a shame 'cause I'm interested in seeing which libraries this uses.
/r/learnpython Bookmark gohlke Also `ctypes`. from ctypes import windll user32 = windll.user32 GetAsyncKeyState = user32.GetAsyncKeyState def is_keydown(keycode): #Highest bit = bool(is_keydown) # Other bits = unintelligible bullshit. r=GetAsyncKeyState(keycode) return bool(r &gt;&gt; 15) Also also win32api. http://timgolden.me.uk/python/win32_how_do_i/catch_system_wide_hotkeys.html
Doesn't it make more sense, though, for the authors to provide binaries? Ideally, they'd know more about their software and it's dependencies than others. I get that's not how it usually works on Linux distros, but for Macs and PCs it's the standard. 
It's not enough that what you want exists, but it needs to be carried out by someone specific you choose? Those damn debian maintainers compiling numpy for debian, it should be the numpy devs doing it!
It does not. The numpy code has to link against other libraries that are on the system and not provided by the numpy project. Seems like the maintainer of the user space should decide which of those libraries to have, where those libraries are located, and to compile numpy against them. Linux has distro maintainers to do this, macs have homebrew, and windows has a middle finger for anyone who wants properly maintained packages for windows. This is part of why it sucks programming on windows and why windows is so well known for viruses. Fortunately, a well known scientific computing company stepped forward to provide this maintenance for windows in regards to numpy, scipy, scikit-learn, and tons of other packages. And they provide numpy compiled against intel's MKL which the numpy people would not even legally be allowed to do. &gt;Ideally, they'd know more about their software and it's dependencies than others. The anaconda people aren't some random people who don't know the details of how numpy works or what it depends on. They are professionals on the level with the numpy devs, taking on a project that is broader than numpy and which is rightfully not the focus of the numpy-devs. Other comments in here discuss other challenges with compiling widely used software with third party dependencies on windows, so I'm glad Continuum stepped up to do this.
Yet the project type on github is 'shitpost'?
This becomes part of the list why people should use Python 3.
The question was why the numpy maintainers don't provide binaries, which would allow you to pip install numpy in whatever Python environment without needing a compiler, not how to get binaries of numpy. I don't have this issue since I use a mix of anaconda and distro binaries, but a windows user setting up a server might not want to use Anaconda (or might not be able to for some reason).
Hi there. You have posted a learning question to /r/python. These types of questions are far more suited to /r/learnpython, where users are actively interested in helping people to learn. Please resubmit it over there! Make sure to read their sidebar rules there before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." If your question is about homework, show them that you've tried to solve your problem in your post and you should get all the help you need. For anything else, the reason you are seeing this message is still that you will likely get a better answer there! Warm Regards, and best of luck with Python!
Hi there. You have posted a learning question to /r/python. These types of questions are far more suited to /r/learnpython, where users are actively interested in helping people to learn. Please resubmit it over there! Make sure to read their sidebar rules there before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." If your question is about homework, show them that you've tried to solve your problem in your post and you should get all the help you need. For anything else, the reason you are seeing this message is still that you will likely get a better answer there! Warm Regards, and best of luck with Python!
Hi there. You have posted a learning question to /r/python. These types of questions are far more suited to /r/learnpython, where users are actively interested in helping people to learn. Please resubmit it over there! Make sure to read their sidebar rules there before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." If your question is about homework, show them that you've tried to solve your problem in your post and you should get all the help you need. For anything else, the reason you are seeing this message is still that you will likely get a better answer there! Warm Regards, and best of luck with Python!
Definitely possible, I just don't really know where to start! I'd have to find the players last position to find at what angle it came into contact with the block, and then make that block move the angle it was pushed. I don't know how I could really do this in Python, I'm just a beginner really.
Hi there. You have posted a learning question to /r/python. These types of questions are far more suited to /r/learnpython, where users are actively interested in helping people to learn. Please resubmit it over there! Make sure to read their sidebar rules there before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." If your question is about homework, show them that you've tried to solve your problem in your post and you should get all the help you need. For anything else, the reason you are seeing this message is still that you will likely get a better answer there! Warm Regards, and best of luck with Python!
First make the program display the sokoban boards
Oh, okay I wasn't looking for how to actually write a program, just what module I could use.
Because Continuum paid for the licensing fee to distribute Intel's MKL via conda, which the numpy-dev team can't do. Numpy-dev's are starting to provide a slower option for people who don't want to compile or use conda. http://www.mail-archive.com/numpy-discussion@scipy.org/msg50024.html
&gt; lacks sufficient support for functional programming A function is an object in Python, just like any other. What more support do you need? Since you don't believe me, I'll appeal to authority. I think Peter Norvig would disagree with you. If I remember right, he gave a talk once called "Python is a Lisp". That's a bit of an exaggeration, but it's not as far off as it sounds. [Norvig's comparison of the two languages](http://norvig.com/python-lisp.html) is a little out of date. Python has gained more lispiness since he wrote it, mostly through the growing importance of generators. &gt; recursion [in Python] is bad due to performance reasons. Memoizing is a classic Python tool, made easier by functools.lru_cache in Python 3. Memoizing is often even more effective than tail-call optimization would be. &gt; I don't think the Python community is going to shift its norm anytime soon. I'm not suggesting the Python community shift norms. I'm saying the norm is functional style. It's alien only in that you might not realize you're coding in a functional style.
Start hacking Windows support into the Adafruit library. It looks like a really clean codebase. Looks like a good weekend project.
What's wrong? I use this tool myself and would be glad to fix problems now.
I will look into contributing to pip, but i doubt they will be happy about package.json and such.
My guess is that it's for being able to sort a heterogeneous list and get *something* consistent, even if it doesn't make a whole lot of sense.
You might want to take a look at https://github.com/Deepwalker/pundler - very similar approach, but probably more serious :) Also, does it actually work? I don't see any tests.
I thought about this, but the real strength of NPM is that you can depend on two different versions of the same project. Python has top-level packaging, so you can only have one version of a project installed at a single time. Doing multi-version with Python is possible, but you'd have to re-write the import loader.
If you want that behaviour, it's still easy to get in 3.x: `key=lambda x: (type(x).__name__, x)`. Explicit is better than implicit.
Glad you like it!
The PPM name is already in use by ActivePerl's package manager: [ppm](http://www.activestate.com/activeperl/ppm-perl-modules)
I use pandas pretty extensively to process daily files. I know I need to optimize this. I now keep things fairly organized but it's still a mess. I have explicit file paths on the top of each py file near my imports such as /raw (for unprocessed data), /output (daily processed data), /Modified (this folder has monthly files and jt is mirrored on a shared drive for people to use), /dashboard etc. Each file also has a filename (raw_filename, modified filename, etc). Sometimes the raw_filename is actually modified data. It can get confusion and each file has like 10 lines of code dedicated to this. 
Thanks for all the wonderful tips. I downloaded python data analysis and python for probability statistics and machine learning on allitebooks. 
There is a download button on the website I interact with. I fill in fields to select data and then click an export button 
Beginner question here : What exactly is Data Science referred to in here?
So I currently use Eclipse to write my Python code, especially for work in school. I would use neither of those to do that? How would I write code using the various packages in Anaconda then? I feel like I am missing a major piece of information, sorry. 
try this on your terminal &gt; pip install urllib2
Could not find version that satisfies the requirement urllib2 That's what I get
Are you using Python 3? The script you're trying to run is written for Python 2, an older, incompatible version. 
Yea im running 3, I had a hunch it might be for an older version Is there a quick syntax fix or something to make it run or a newer script for 3 for reddit image downloads? This is the firt time im using python to do anything btw
I'm up to the challenge--will report back.
Because I didn't realize I could just pass it directly. Afterwards I read the other comments and realized but decided to just leave the comment as is.
Rather than encouraging use of a deprecated Python 2.7 why not just use the Python 3.x `urllib.requests` module? PRAW and Pillow (replacing PIL) are Python 3.x compatible.
You are useless. Please support your claims
Sure, why not? Can't hurt to learn new things. Except PHP. Stay away from PHP. It's an awful language that needs to die.
For users of Python 3.4+, if you use the built-in `venv` module, you get the same functionality (with `pip` etc.), and a much simpler implementation which doesn't suffer from having to support every Python version. The `virtualenv` module has done a great job over the years, but keeping it simple for users means the price is paid in internal complexity.
It's worth it to learn everything you possibly can. Python and C# are not all that dissimilar -- they are both high-level multiparadigm languages, and they share several features in common. The hardest part is going to be learning the syntaxes and switching between them, but if you have some C under your belt, then C# should look pretty familiar, and Python is just different enough to not be horribly confusing. Learning new programming languages is an excellent way to avoid pigeonholing yourself into a certain mode of thinking: Python and C++ are highly polymorphic and make great use of object-oriented and functional programming features to supplement a very traditional procedural style; C# and Java have strict tightly-coupled type systems and memory models and tend to use generic and functional programming as layers of syntactic sugar on top of native object-oriented constructs. Some languages look radically different from all of these; no model of programming is better than any other, and by learning as many as you can, you will be able to think more critically about your code and come at programming challenges from a variety of different angles.
This subreddit isn't really the right place to ask questions like this, that being said... A function like input() or raw_input() will block until it gets results, which is why it is stopping your loop. You can just use Ctrl+C to break out of your loop.
Anaconda is more than just a Python interpreter plus additional libraries, contrarily to what others say. It also includes Jupyter and other IDEs like Spyder. It also supports parallel computation. If you are on Windows, then it saves you hours in installing all the pieces manually. Re data science, best way is to learn by doing. If you want to understand machine learning, then I recommend Andrew NG course on coursera (Stanford Machine Learning course). It is free. If you want to learn about Python tools for data science, then you'll have to learn at least matplotlib, numpy, pandas, and scikit-learn. There are good introductory notebooks at: https://github.com/donnemartin/data-science-ipython-notebooks Study the code in these. Lats advice: google search and stackoverflow are your best friends when you want to know how to do something in Python. 
/r/learnpython
Two years ago people discussed this: https://www.reddit.com/r/Python/comments/1knw7z/python_interview_questions/
Why are you so mad? Im not here to debate the pros and cons virtualenv. Its unintuitive and i created an alternative.
The title is fine.
Thank you so much this has opened my eyes, because I was thinking that coming out of school a company would want me to be experienced enough to jump straight in and not need much help. 
Depends on your goals. Of course it doesn't hurt if you learn other languages, but it depends on what you want/need to accomplish. For me, I learned Python initially because I needed something better than batch file syntax in Windows *and* did not want to open something as heavy as Visual Studio just to write something that a small script should be able to do.
No, but I remember picking up virtualenv a few years back and thinking "neat". I don't agree about it being unintuitive
True, but cultural and stylistic differences are much easier to deal with.
I think this answers it mostly: http://www.scipy.org/scipylib/building/windows.html Basically getting set up with BLAS on windows is difficult and there are a few different ways to do it, each of which has its own dependencies. Choosing one and making sure it works reliably is difficult. Thankfully it looks like different parts of the ecosystem (like wheel packages, openBlas, etc) are now getting to the point where this might be possible.
I would really like to see more support for immutable data structures in the python standard library. I've started to adopt a more functional style and found it really helps avoid over-engineering systems and makes it much easier to figure out what is happening where. But I find the lack of immutable built-ins beyond `tuple` limiting. There are some packages for data structures but none which seem to have enough traction to be 'de-factor standard' and therefore safe to include as dependencies (unlike e.g. requests. No one is going to question you ever for taking a dependency on requests. But taking some semi-obscure immutable lib... eeahh)
How can a script identify complexity? How do you pass an algorithm as input to a script?
Binary search on a sorted array is O(log n). Merge sort on any input... sorted or unsorted is O(n log n).
The CPython distribution of Python, which is the most widely-used distribution, is extremely close to C. If you already know C, then learning Python as well as possibly Cython gives you enormous flexibility in how to approach problems. Probably as much flexibility as is possible right now with any other choice of tools. You can build a very strong career on only those three tools, with applications across a wide number of industries.
vomit
nice..thanks
If all you want to do is find if the bike is sold on each website and the price, the best would probably be to write a script that uses Google search (I assume there's an API). For each website URL have the script do a Google search equivalent to "site:bikeshop.com bike name" and return the top hit. Then just click through those results manually. Google's page rank should do a good job of finding the relevant page on each site which will save you lots of time.
One small point to add...PyCharm now has IPython Notebook support.
And indeed, comparison methods skipping the instance `__dict__` lookup is exactly so this type of thing works - otherwise `Foo &lt; NotFoo` would try to use *that* `__lt__` that you just defined and break horribly.
The fatal flaw in the opposing view is that it costs nothing to do a peer review and to manage that process. There also seems to be a belief that it cost nothing to publish research. Even if you setup your own web server it still cost money to publish. If you set up your own server you cant ethically handle peer review. The problem is more involved than people make it out to be. As to the small portion of publicly funded research out there should access be better - certainly. That does not imply free though. 
Operators are looked in the instance's class dict, which is what I think you meant. In CPython, it looks like this: type(foo).__lt__(foo, bar) Except in C. Jython and others are free to implement the actual semantics differently as long as the general semantics remain. Anyways, with operators defined in the metaclass, it looks like: type(FooCls).__lt__(FooCls, BarCls) As for my side note, I'm not entirely sure why metaclass instances (classes) aren't accessible from instances of those classes.
Mostly some kind of immutable dict/Map - although getting the design of this right and pythonic could be tricky. I guess ImmutableJS pretty much covers the feature set that would be nice to have, but the semantics would have to be adapted for python...
first i read it like TrumpScript.
Any chance you are trying to setup your second connection after you have called ws.runforever() ?
Show some respect. If someone does not speak English well, that only means that person know another language fluently. 
Why would anybody move from Python 3 to JavaScript?
&gt; No standard libs ಠ_ಠ
In 9 years since college and a number of job moves, I've had zero "technical interviews". Your mileage on that might vary. Some managers like them. Generally I get questions along the lines of, "How would you go about solving a business need where Xyz happens?" I can then answer based upon knowing what solutions are generally appropriate. I could say, "Well, I think this would be most accessible as a mobile app, but since it only displays simple data, I would recommend a mobile friendly web page--perhaps with a Cordova wrapper--instead of spending the time on a native application." In short, be personable and friendly. People want to work with someone they can get along with. If you have enough technical talent to do the job, it will come out in conversation. If you have a technical interview, I'm guessing they will only look for general indication of competence because every developer will forget basic things when asked on the spot now and then. :)
[Nah](https://youtu.be/EBRMq2Ioxsc?t=45m15s)
Trump seems like the type to use PHP.
Which opens the "Save/Open" dialog, correct? Is this an alert that can be interacted with? Or how do you interact with it? How precisely can you save the file? I'm asking as Selenium is reportedly not very useful in terms of downloading files..
imagine if you could code web scripting in python instead of javascript. Also imagine that you didn't have to use a 5+ year old tool to achieve this that is what transcrypt is for
An interesting concept albeit one which is closer to coffeescript (alternate language, preserves JavaScript semantics[1]) than a Python to JavaScript transpiler (preserves Python semantics). I'd have more confidence if there was a strong focus on making sure it's Python rather than JavaScript. (See, e.g., pyjs.) OTOH, having a Python-flavoured JavaScript is nice enough in its own way. That being said: &gt; extensive tests on Windows and Linux have shown it to be stable Looking at https://github.com/JdeH/Transcrypt, it's not immediately apparent where the extensive tests are located or how to run them. [1] The author explicitly notes in the README that Python features which do not map one-to-one to JavaScript features are not considered in scope. **Edit:** Found them! The tests are hidden in https://github.com/JdeH/Transcrypt/tree/master/transcrypt/development/automated_tests which is a novel directory structure w.r.t. usual Python conventions. It strikes me that there are a lot of files inside the "transcrypt" module which should be elsewhere in the repo. Instructions: http://sterlicht.alwaysdata.net/transcrypt.org/docs/html/autotesting_transcrypt.html
learn the fibonacci sequence, the cool, non-recursive, pythonic way. def fib(): a, b = 0, 1 yield a yield b while True: a, b = b, b + a yield b This returns a generator, so know what they are too. edit: yield a so 0 is the first term
&gt; imagine if you could code web scripting in python instead of javascript. &gt; Also imagine that you didn't have to use a 5+ year old tool to achieve this Like this: http://www.skulpt.org/ (Note: obviously, skupt is *different* to transcrypt but your use case is achievable using the more mature skulpt.)
It seems that way, but there must be a way to run 2 websocket connections off 1 script? ie both alive and working, but each can call each other. So if something happens in the 2nd channel, the 1st channel can be told about it etc?
either way you're still looping every time step. Above i recommended a low pass or kalman filter which are better suited to streaming data 
Thanks for the great article. Have you compared this with Pyomo?
I'm afraid I have no good resources, but look into Dependency Injection for the outlined method, it's closely related. Look at the 'scrapy' library as well.
Fun fact: Trump and Hillary are the only candidates in the race not using Wordpress for their website. Trump's opting for a fairly standard stack, mostly static site; and Hillary's site packing a few things like backbone.js, modernizr and other JS bells and whistles.
Windows 7, installed it using python -m pip install requests in the command line and it downloads with (seemingly) no problem. And no, I do not even have a virtualenv. module installed atm :/ [Link](http://i.imgur.com/NOCJ4iU.png) of how I import it in code, and another [link](http://i.imgur.com/VaCF2in.png) of the error message I get.
There's a great overview of the differences between PuLP and Pyomo in section 4 of [this paper by Stuart Mitchell et al](http://www.optimization-online.org/DB_FILE/2011/09/3178.pdf)
and skulpt is pinned to 2.6 syntax from the looks of things. I guess I should of perhaps phrased better: transcrypt is for when you want to code javascript, but don't want to code in javascript, so it won't come with an entire stdlib, memory management, etc etc.
The phrase 'should have' indicates a missed obligation or opportunity in the past. In informal speech, it is contracted to should've, not should of.
Trumps site is on ExpressionEngine, a php based CMS.
Are you on OS or Linux? Either case what would you recommend using when coding in Python? Getting kinda tired of the bullshit that occurs when you try to use Python on Windows sometimes...
Are you using Python 2 or 3? I've seen it a lot where someone has both installed, which means pip usually points to the python 2.7 version, while pip3 points to the python 3.x version.
This thing should probably better indicate that it's a bot.
No, this is python. Coffeescript is preprocessor for Javascript. It is Javascript. [Rapydscript](http://www.rapydscript.com/) is like pythonic Coffescript. I prefer a javascript preprocessor to trying to convert one high level language to another.
At least in the latest version, cursession seems not to exist anymore: `ImportError: cannot import name cursession`. Not sure what to replace it with
Im assuming OP is ignorant on the topic of filters Here are a few resources for him http://stackoverflow.com/questions/3760506/smoothing-values-over-time-moving-average-or-something-better http://www.analog.com/media/en/technical-documentation/dsp-book/dsp_book_Ch15.pdf http://www.ltrr.arizona.edu/~dmeko/notes_8.pdf
To use create Python scripts, you need a text editor. I would recommend either notepad++ or sublimetext. To get started with basic syntax and stuff, look up some video guides.
You mean, like easy_install and pip? Or eggs and wheels? Since when is doing something better than an existing solution is a bad thing? Virtualenv is far from perfect, but we probably have to fix pythons import machinery and site.py behaviour before we can have a better virtualenv.
&gt; If you set up your own server you cant ethically handle peer review. why?
not an excuse for what? he has an opinion and brought arguments. downvotes don't make them go away.
&gt; this is his job. it's your job to find the flaws in his arguments 
While that's the approach you use if you want to land the job, I prefer my method to get the n'th term (good to about 8 digits): def fib(n): g = (1+5**0.5)/2 return round((5**-0.5)*(g**n))
[GIFV link](https://i.imgur.com/1BKr16n.gifv) // [FAQ](https://www.reddit.com/r/livven/wiki/gifv-bot)
Added to my stars and watch list!
There's also matrix form. Add memoization to speed things up.
So true. When I interview people I do not look for people that have experience with the languages we are using. I look for competence and if they were able to talk to the Customer, design and build something. If you are getting asked gotcha or obscure language questions it is typically a red flag that you don't want to work there. I am an encyclopedia where to find out how to do something, but probably not off the top of my head. At this point I have probably forgotten more software programming than I currently know, but I can build stuff much faster now.
It will be tough to gain an understanding of your problem with the two lines of code that you've presented. Could you edit and provide some more information? Particularly how you are generating the 'x_low, x_high, y_low, y_high' variables, and what libraries you are using. It also appears that you may be using numpy and slicing the array incorrectly. The first dimension is the row-wise index, which is the y-direction, and the second is the column-wise index, which is the x-direction. If you are unable to provide additional code, my guess is that your index variables are somehow incorrect, or you are modifying the 'image_data' array elsewhere, and getting a view of the modified data with every slice. 
For a 2 years experienced position, you should probably be familiar with the internals. I'd especially be interested in things like - Iterator vs Iterable - Mutable data-structures vs Immutable - the internal implementation of python datastructs like list, dict, set. You'd be expected to use this so you should be familiar with how efficient are these w/r/t to different things like search, insertion etc. - whether you are aware of useful Python tools like generators, Context managers which improve the efficiency and readability - whether you are thorough with aspects of testing (unittest, TDD, mocking etc). There's no good Python code without good tests. - be prepared to whiteboard simple exercises. Start with the most straightforward implementation and feel free to use Pythonic idioms (like list comprehension) as you optimize the code. you'd be expected to know the tools Python provides and know how to use them. 
Thanks for the `ruamel.yaml` link. I can't tell if PyYAML has been abandoned, but for me it's as good as abandoned. I posted an issue *4 years ago* about a fairly basic problem - [yaml.load() fails to load a dict just saved by yaml.dump()](http://pyyaml.org/ticket/264), which was never progressed at all, but has collected a dozen or so random spam comments. I might as well try and see if `ruamel.yaml` can handle that dumped content which stymied PyYAML - though AFAICT it's a fork and has a total of 28 issues ever opened (5 of which are still open), so I'm not sure how much it's been exercised. Can't hurt to give it a try, though!
Yeah, PyYAML also seems to have suffered from a half-complete migration to BitBucket from somewhere else (where your old issue is reported), and people still [find it confusing to tell where exactly the project is hosted](https://bitbucket.org/xi/pyyaml/issues/44/where-is-this-project-being-maintained). FWIW, though relatively new, `ruamel.yaml` is active (latest commit is from [early March of this year](https://bitbucket.org/ruamel/yaml/commits/all)) and saw [~36K downloads last month](https://pypi.python.org/pypi/ruamel.yaml). I wonder if, among the [changes the fork author has made](http://yaml.readthedocs.org/en/latest/pyyaml.html), your problem has been fixed. Let us know!
It comes with an **integrated debugger** and support for **multiple threads** as well as **greenlets**. Because these features are bought with performance, it's slower than most other Python-to/in-JavaScript approaches.
Will look into it, Linux seems good! Any recommendation on what OS to use on Linux? Fedora, ubuntu, mint?
Anaconda is a free Python distribution that has most of the modules already built in on Windows. This includes requests. [Here's a list of what they supply](https://docs.continuum.io/anaconda/pkg-docs#python-3-5).
How can you share code between backend and frontend? Does frontend not need to be a wrapper around the backend over a network API? I guess you could share the code, *somehow*, but we're talking about a very light level of code sharing here.
I don't understand why asking a question like this should be on /r/python. You did the research; you already know that the last commit was 4 years ago. I use packages from 8 years ago; I just don't expect them to get updated anymore. &gt; I am not suggesting I could maintain pydot, I just want to know who is able to upload pydot packages PyPI, and if there is another version being maintained somewhere. It seems childish to call out a project for not being as active as you want, especially when you are unwilling to help.
Sadly, not: $ python yamlfails.py 1st: unable to load dumped YAML: while scanning a simple key in "&lt;byte string&gt;", line 81, column 3: !!python/unicode |- ^ could not find expected ':' in "&lt;byte string&gt;", line 81, column 20: !!python/unicode |- ^ 2nd: unable to load dumped YAML: while parsing a block mapping in "&lt;byte string&gt;", line 1, column 1: !!python/unicode 'data': ^ expected &lt;block end&gt;, but found ':' in "&lt;byte string&gt;", line 6, column 1: : ^ 3rd: unable to load dumped YAML: while scanning a simple key in "&lt;byte string&gt;", line 16, column 5: !!python/unicode |- ^ could not find expected ':' in "&lt;byte string&gt;", line 16, column 22: !!python/unicode |- ^ The "unable to load dumped YAML" is printed when an exception occurs while loading. I'll log the issue on the `ruamel.yaml` tracker and see what happens to it ...
Oh my God. [He was right…](https://www.destroyallsoftware.com/talks/the-birth-and-death-of-javascript)
&gt; Question #1: With getting a Bachelors in computer science and a advanced software developer certificate what does that limit me to? The degree will let you get your foot in the door, and could help you land an interview. We have no idea of your skills or interests or how you interview or where you live, though, so we can't say what paths might be available. The certificate might be handy when you need someplace to sketch out a class hierarchy and you don't have a napkin handy.
"Nobody"? &gt; You missed the most obvious way to grab every third item from a list: a[2::3]
Mint or Ubuntu are great for beginners. 
I'd love to see the examples also comply further to PEP8 standards. There's additional whitespace before brackets which makes all the code look strange to me. But very interesting implementation.
We are guaranteed id is constant over the lifetime so (on CPython) you may want to use it to provide some kind of consistent ordering without having to create additional member variables (say if you weren't planning on persisting the data to disk). The comparison operators required for ordering do work on IDs because it returns a memory address.
duly noted, thanks. /r/python commenters were helpful enough and i did find a solution to my problem. I will certainly post future requests in /r/learnpython instead. 
Uh, know Python? You've got the interview, I assume you know your stuff. If you're going for a good place, there won't be any "what is x?" "it's when y does something to z" type questions.
Not to mention developers flitting between github, bitbucket and Google code (well, flitting from) and not always leaving breadcrumbs. 
Some issues I saw... Don't use `from xxx imporrt *`. Write out the stuff you're importing. Don't import matplotlib in that file. Make a separation between graphics and analysis Don't do: def distance(node1, node2): return math.sqrt((node1.x_pos - node2.x_pos)**2 + (node1.y_pos - node2.y_pos)**2) use: np.linalg.norm(node1-node2, axis=1) That code scales very poorly, though if you only have 5 points, it doesn't matter. Don't do `list = [1, 2, 3]``. That's a reserved word. Use something like `alist` or `lst`. Avoid code like: for i in range(len(x)): xi = x[i] Do: for i, x in enumerate(x): pass if you really need indices. Avoid them if you can. return round(m, 2), round(m-h, 2), round(m+h, 2) You should use `numpy.round`, especially since you already have numpy arrays. Flipping back and forth is not a good thing. Finally, document your functions, inputs, outputs, and what is the purpose of the function at minimum. Obviously, who cares about `size`, but what does the Node class do? What are the limitations of it? What's the biggest problem you intend to run? &gt; what is that something concrete that could get me a healthy mentorship What could get you a mentorship? Offering to help on a project and paying someone money are the two biggies. I run [this](https://github.com/SteveDoyle2/pyNastran/wiki/GUI). The GUI is the fancy part, but it's so much more. What could you get out of it? Why is vectorization so important and how to do it. I got a factor of 500x speedup parsing a binary file using numpy vectorization, which required shockingly little work. Implementing numpy arrays led to a factor of 10 reduction in the memory usage. Just adding numpy arrays without vectorization caused a 20% reduction in speed.
Thanks for your notes, I will consider them for future development. I am not sure what you mean by running ExecCommad as a class variable. The variable named Terminal is an object instance and ExecCommand is its method, or function if you like it a more Pythonic way. As such, it is instantiated for each connection on each thread and therefore are distinct objects so definitely work for multiple connections. TimedOut is a return value because the Python objects mimic their underlying CLR object as IronPython projects them. And in the .NET object model it is defined as an out variable of the method ExecCommad. Could have equally been an Exception, but throwing exceptions are not always the best approach in my view unless they relates to something unexpected. ActionResult is not explained well, I appreciate. It is a global string variable and forms a way of communication between the hosting environment and the Python script object. It can contain any string and its value will be displayed in the CommandResult column of the PGT script. PGT script is basically a list of devices to run the script on along with connection parameters and this list can be save or loaded as a CSV file. In its simplest form, this GT script does not need to call any script but can just define a single router command, like "sh version". Then the CommandResult would contain the result of the command:-). However, when a script is called, it has the possibility to return any string value. This is the role of ActionResult. I think you might find interesting to create a simple Visual Script (or load the provided sample) and check its runtime generated Python object model.It would explain your questions I believe. I appreciate my example lacks deeper explanation, but this is on purpose as I did not wan to write a complete user guide in this first post :-). But any questions or suggestions are really welcome and I may implement good ideas in next release. Thank you. 
This link should contains almost all materials, including solutions http://open.umich.edu/education/si/coursera-programming-everybody/winter2014/materials.html
I don't think it's as much code sharing as it is to have a single programming language to use - it helps a lot with the context switching.
My advice was not a personal attack as you seem to have taken it. You've posted your question in an English speaking sub and so it is a fair assumption you will be writing at least some code and documentation in English.
From the StackOverflow link, this one used the same method I did: http://stackoverflow.com/a/3760671/4322433 Instead of a circular buffer I used a deque, but the algorithm is similar.
Have you seen this page? https://wiki.python.org/moin/WebBrowserProgramming Specifically the 'Python Wrappers around Web "Libraries" and Browser Technology' section. There are a few libraries there built around WebKit rendering engine which provide access to the DOM, that's just what you need.
So is this something in PyCharm itself, or a library, or...?
The GIF is a sneak peek showing a Python interpreter written in JavaScript which supports remote debugging with PyCharm and other tools.
Why are there so many seperate python to javascript projects? This debug feature is cool, but why not integrate it into a more mature project?
You can't be serious. Selecting the scientist to do a peer review of your potential publication is unethical. 
They have the same interface but different behaviour, right?
X-Post referenced from /r/codereview by /u/infinity404 [(Python) I wrote a structured data format and parser similar to JSON. Let me know how I did!](https://www.reddit.com/r/codereview/comments/4dk2oq/python_i_wrote_a_structured_data_format_and/) ***** ^^I ^^am ^^a ^^bot ^^made ^^for ^^your ^^convenience ^^\(Especially ^^for ^^mobile ^^users). ^^P.S. ^^my ^^negative ^^comments ^^get ^^deleted. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
Selenium.
i think this may help you to understand my requirement https://www.youtube.com/watch?v=TeKk3DjN_gs (3 min 14 sec) in that they used mean function in matlab.. but i want to use moving average filter in python.
I installed it and it seems to be working! Thanks a lot! :)
Except the back-end one is very likely to be an ORM class which will not get you far on the front-end.
Because I said I could not maintain pydot does not mean I cannot help. I want to report issues and send pull requests at the right place, that is all. If somebody somewhere is already fixing issues and integrating pull requests, I just would like to know. If nobody is doing that, then I could think about using my own fork. After some more research I found out about https://pypi.python.org/pypi/pydotplus, I am going to check it out. As for asking on r/python, this is just to gather other people feedback on this topic, I really do not see the problem, or what other appropriate place I should have posted this in the first place.
Hey. The S3 Part is currently malfunctioning. (AWS implemented some security components and they aren't supported with boto afaik) Is there any chance of it coming back anytime soon? I have actually started developing something like that myself. (integrated with PyFilesystem)
Honestly I just felt like writing something of my own, although I might take it in that direction later.
Check the main post. I fixed it. There is no longer any difference.
thank you very much
How do you run this with windows.(Py file)? I need to install python or something.
those semicolons are really necessary?
Hi, I was wondering which IDE for python you would recommend. Are there any that are similar to rStudio in capability? 
Unless you have some specific reason for writing your own implementation it may be best to use something like "[RQ](http://python-rq.org/)" instead. It'll save you some effort, make it significantly easier to process multiple types of jobs at the same time, and simplify direct interaction with the queue for debugging and the like.
Not to be pedantic, but recreating a very well used library with very little to no added benefit and then asking for feedback on that library is not a great use of community time. I am on a phone so I only read through your readme, but I just don't understand why you spent effort on this. There are a lot of problems that haven't been solved or have been solved poorly. Python's json library is not one of those problems.
Looking at the code, it appears so: elif char == ';': return BONNode(key, value) elif not char == ' ' and key == None: buffer.push(char) raise Exception("Expected token ';' not found.") I'm going to have to agree with /u/bixmix that there is really no benefit of creating this and it is extensively covered by existing libraries. Also, semicolons? No thanks.
Ansible is free, and will push out couple of new ios modules with 2.1 - https://docs.ansible.com/ansible/list_of_network_modules.html . Ansible tower does cost. This can be replaced with rundeck, if you need a management console. ansible semaphore is another alternate. ps: I have not used the management console, as ansible is more than sufficient for our work. 
You'll have to return them from the function, otherwise their scope is gone and they're likely to be garbage collected. def func(): x, y = 0, 1 print(x, y) return x, y a, b = func() print(a, b)
I 100% agree, however to play devil's advocate, my guess is OP was trying to do this as an experiment to scratch a personal itch. And sometimes the only reason "why" is "because." OTOH, between json, yaml, pickling, and XML to name only the most popular formats, there really is no need for an another ML that doesn't bring anything different/new. 
why do people keep posting questions in here when it clearly says to post things like this at /r/learnpython. Honestly I'm curious...
If you are going through all this work why not just port it?
I thought about that, but having `isinstance(value, six.string_types)` in the code did not seem any better.
keyword: global variable http://stackoverflow.com/questions/423379/using-global-variables-in-a-function-other-than-the-one-that-created-them edit: why the downvotes? If he wants to save variables outside a function then the solution is global variable. 
Is there a Pythonic implementation of this? Did not see on the post
Other than the pseudo code below, I didn't see any def choose(): if math.random() &lt; 0.1: # exploration! # choose a random lever 10% of the time. else: # exploitation! # for each lever, # calculate the expectation of reward. # This is the number of trials of the lever divided by the total reward # given by that lever. # choose the lever with the greatest expectation of reward. # increment the number of times the chosen lever has been played. # store test data in redis, choice in session key, etc.. def reward(choice, amount): # add the reward to the total for the given lever. 
That is all I saw... If this post is 3 years old, there must be an implementation somewhere. Would this be considered a Bayesian method?
Why is this posted in python? Is it because the psuedocode uses python formatting? 
Yes.
Jesus Christ that guy's a self-assured haughty asshole. I'm not quite sure why he felt the need to insult everyone who came to mind before getting to the actual point of the article.
i think the actual implementation would vary too much from project to project to be able to abstract it in some kind of module. i'm not qualified to answer the bayesian method question, sorry about that
Hi there. You have posted a learning question to /r/python. These types of questions are far more suited to /r/learnpython, where users are actively interested in helping people to learn. Please resubmit it over there! Make sure to read their sidebar rules there before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." If your question is about homework, show them that you've tried to solve your problem in your post and you should get all the help you need. For anything else, the reason you are seeing this message is still that you will likely get a better answer there! Warm Regards, and best of luck with Python!
You return them and pass them back out of the function. 
If you want to do A/B testing, just throw up a sixpack server. https://github.com/seatgeek/sixpack 
wrong sub
whoever coined the term serverless should be shot.
Great example! Thanks a bunch for this. I couldn't find anywhere what's the best process for selecting like this: ``` ('product_name', 'LTTextLineHorizontal:in_bbox("40, 48, 181, 633")'), ``` ``` ('product_details', 'LTTextLineHorizontal:in_bbox("885, 48, 1140, 633")'), ``` From the official docs they say to use photoshop/gimp for locating 4 coordinates. Is there better way for doing this? If there is none then if you could drop me a link where I can learn more about selecting in this way that would be great! Thanks once again.
There is another simple task queue that uses Redis called [HotQueue](https://github.com/richardhenry/hotqueue)
I didn't assume, it's just a form message for when people post stuff that isn't appropriate here.
I always thought that A/B testing was simply artificially restricted ANOVA, the result of which is a dramatic reduction in the ability to speak about models.
This is a cool Python trick to allow excel to be used as a front end but for a business I still think using Access, the web, or even a bi platform like qlik or tableau to act as a front end and perform the etl on the db is a better long term solution.
Yeah, he isn't even curing cancer, wtf
I'm probably stupid, but I don't understand the concept of reward. We just need to know failure/success in his example. But if you get more paid if someone click this or that type of button. plus: # This is the number of trials of the lever divided by the total reward # given by that lever. Shouldn't it be the other way around (which he is showing in his example: reward/nb_trials
If they could read instructions, they would have already found their answers in the Python documentation, and wouldn't need to go to r/python in the first place.
Yeah this was 100% just for my own learning - I'm mostly just looking for an analysis of quality / what can be improved technically. I'm a CS undergrad and for a couple of assignments we weren't allowed to use any libraries at all which led to me writing a much more basic format/parser for storing data that I wanted to improve on. 
Lower in the post I did mention that &gt;You probably won't need to add all the \_\_future\_\_ imports, as most of them have been added to Python &gt; 2.6
I find it much easier using [Splinter](https://splinter.readthedocs.org/). browser.execute_script("$('body').empty()") - [documentation] (https://splinter.readthedocs.org/en/latest/javascript.html)
About time MAB got some respect.
I won't complain. It's interesting.
Hopefully your experience helped you learn something new :-)
Multi-armed bandit dates back at least to Goldberg 1987.
Same deal with Julia
Re: your second question, Python is a garbage-collected language. The interpreter keeps track of a reference count for each object, incrementing it each time you get a reference and decrementing it each time it goes out of scope. When it reaches 0, it's freed. There's some additional logic to detect cycles. Apparently CPython also has the concept of generations [according to Quora](https://www.quora.com/How-does-garbage-collection-in-Python-work).
This is definitely not an easy question to answer. I've had a long-running curiosity with the Python runtime for probably a year and I have a lot of trouble understanding. Also I'm assuming you're talking about the cpython interpreter (there are many others that do things differently...) I believe it's the job of the actual type to allocate necessary memory and things like that. It contains the constructors/destructors necessary. See here: https://github.com/python/cpython/blob/master/Objects/longobject.c#L5346 The actual values are stored in much lighter structures. See https://github.com/python/cpython/blob/master/Include/longobject.h#L10 and https://github.com/python/cpython/blob/master/Include/longintrepr.h#L89 Of course all of this happens after your python file has been converted to bytecode. Save `i = 1` in a file called `test.py` and then run `python -m dis test.py` and you'll see the following (*your output may differ since I'm using python2 here...the code I've been linking to is python3...sorry) $ python -m dis test.py 1 0 LOAD_CONST 0 (1) 3 STORE_NAME 0 (i) 6 LOAD_CONST 1 (None) 9 RETURN_VALUE The function that actually evaluates this is an enormous switch statements on different bytecodes found here: https://github.com/python/cpython/blob/master/Python/ceval.c#L797 To better understand this I'd recommend going on youtube and watching lectures on python's internals. I can recommend Philip Guo's videos starting with https://www.youtube.com/watch?v=LhadeL7_EIU&amp;index=6&amp;list=PLzV58Zm8FuBL6OAv1Yu6AwXZrnsFbbR0S edit: To clarify, your intuition in the last few lines of your post seem roughly correct. The type is a collection of functions that are called (constructors, destructors, maybe addition, etc.). The big bytecode switch statements checks if operations make sense with types, allocate new values' memory, do operations and put results in new values, etc. The memory management in cpython is done by reference counting. In the code when something decreases a reference to an object (say by going out of scope), it checks if the reference count hits zero. If it does, then a function is called to free memory (which will probably be something which is basically just `free` behind the hood coming from `malloc`.)
Google Content Experiments uses multi armed bandit for a/b testing.
Huh. So I was right. Thanks!
&gt; so how does Python know how much memory to allocate floats use float64, ints are dynamic based on need &gt; It just feels weird that I can take a variable and do: It seems ridiculous that a C compiler can't figure that out based on context. It seems to me like the type of `x="Hello"` is pretty easy to figure out. You want a float32 vs. a float64, OK, fine define that, but does it really matter? BTW, there are compiled languages that do that. I believe Haskell does. &gt; And I guess when I first do x = 15, it sees an integer, sets up a space appropriate for an integer, then send the pointer to be stored in X. For numbers less than 255 (I could be off on the exact number), they're preallocated such that all 10s point to the same place, but yeah. Yes &gt; When does it clean up the data? More or less at the end of a function plus some minimum time I believe (think of it like flushing standard out).
I find the Struct module incredibly frustrating. In Python 2.7.6 and previous, they felt it would be a good idea to only accept binary strings. Thus the following code cases apply: from __future__ import unicode_literals import struct from six import b struct.pack("i", 4) # fails struct.pack(b"i", 4) # passes struct.pack(b("i", 4)) # fails because six.b doesn't do anything in Python 2 Thankfully, Python 2.7.7 fixed that, but if you try to write code that supports older versions of Python, it's better to just not use six in that case.
/r/learnpython will be more helpful.
I can't find it on the playstore. 
If you want to recommend the perfect food recipe and people choose differently depending on the time of day. It might also lead to prematurely killed experiments or too quickly drawn conclusions. At which point is it statistically relevant compared to a random streak? This algorithm won't tell you.
many people consider python a pseudo-code dialect that you can actually run.
A/B testing is done out of convenience, nothing else. It is simply not possible in many cases to do multi-armed bandit, because evaluating the cost function is, well, too costly. For example, imagine that your objective is to increase 7-day retention of users signing up for your app. That's a completely different issue than figuring out whether users are going to click on button A or button B. It may not take 7 full days to figure out which users are staying, but it certainly takes more than a few hundred milliseconds. And the results can't be evaluated in the client, you generally have to go to the data in the back end of the app. At least, in my experience.
Thanks for the constructive feedback. I updated the article.
Pandas already does this. You get a list of dataframes back.
Expected. in python 3, range returns a range object which is optimized (like a generator). In Python 2 it returns a list
My understanding is that in CPython there are a number of structures (PyObjects) that have a consistent header. The header includes a pointer to the object's type, an instance of a structure which contains a lot of data and member functions. For example the type might have a function for the `+` operator. The rest of the PyObject is arbitrary and can include any data storage needed for the type of PyObject. This means that objects can be passed everywhere as pointers to PyObjects, but their types can have functions specific to the arbitrary data at the end of that type of PyObject. In memory, Python variables are essentially pointers to PyObjects. When variables lose their value, another part of the PyObject's header - a reference count - gets decremented. When an object's reference count is 0, it is freed using a function in the PyObject's type which can properly deal with any data stored at the end of the PyObject. I may be wrong about a good chunk of this because it's been a little while since I've done anything with CPython, but hopefully it gives you at least some idea how it works. If you want to learn more about the implementation of Python, you can look at the CPython source online.
Also you shouldn't do this: from farm2table import * It pollutes the name space and makes tracking of objects impossible for both other devs and the IDE
Welcome to /r/python. You should have posted this question in /r/learnpython. `range` in Python 3 returns a range object that doesn't need much memory compared to a large list. You can convert it to a list or iterate over it with a for loop: &gt;&gt;&gt; list(range(2, 6)) [2, 3, 4, 5] &gt;&gt;&gt; for num in range(2, 6): num 2 3 4 5 In Python 2, `range` just returns a list whereas `xrange` behaves more like Python 3's `range`. I guess you also have Python 2 installed which you accidentally open when you use the "regular Python console", so there you see a list when you enter `range(2, 11)`. 
I've played with many message queues, and this is the one that has appealed to me the most.
This is the problem with benchmarking dramatically different software systems. It may be perfectly reasonable to include JIT time is the expectation is the kernel will only run once or so. If the kernel is used many times then we have a different discussion because pre compiled kernels obviously have an advantage. Much of this can be mitigated by running many interactions. I don't want to dismiss this benchmarking because it does highlight that things like Julia have come a long ways and can't be dismissed out of hand anymore. The really bothersome thing here is that contorting Python to be a high performance solution often makes the code less readable or more complex. As much as I love Python and it's easy to use profile I'm not sure there is a lot of value in using libraries and extensions if the code ends up more contorted than in other languages. 
 &gt;Not to be pedantic, but recreating a very well used library with very little to no added benefit and then asking for feedback on that library is not a great use of community time. I have to disagree with this. Exploring new ways to effectively do the same thing is what has gotten the programming community to the point it is now. To say that researching new solutions is a waste of time strikes me as a bit on the ignorant side. If not ignorant certainly an indication of a bad attitude, if people adopted your perspective we wouldn't have all the new programming languages we have today. No Julia, no Python 3 , no Go , no Lua, no C++ and especially not the improved standard, basically nothing new. After all anything these new languages can do can be done by BASH and plain old C -- right? &gt;I am on a phone so I only read through your readme, but I just don't understand why you spent effort on this. There are a lot of problems that haven't been solved or have been solved poorly. Python's json library is not one of those problems. Why wouldn't you spend time on something like this if it interests you? Really though what is wrong with taking a different approach, if only slightly, to the problem of serializing data? Maybe he learns something. Maybe he has an insight that nobody has come up with yet, who knows. What we all do know though is that he will come up with nothing if he is told to not do it because it has already been done and he actually listens to that poor advice. I just think you are way off base here, not every library developed must be a smashing success. 
 &gt;I 100% agree, however to play devil's advocate, my guess is OP was trying to do this as an experiment to scratch a personal itch. And sometimes the only reason "why" is "because." I can't agree with that sort of attitude at all. As you note he may be satisfying a personal itch which is good enough reason to move forward, maybe he wants to learn something. Who knows? &gt;OTOH, between json, yaml, pickling, and XML to name only the most popular formats, there really is no need for an another ML that doesn't bring anything different/new. Actually some of those formats are good reasons to be searching for something new and more suitable for whatever you are working on. I've never been fond of XML for one, as it is overkill in many applications. In any event come back in 5 years and you are certain to see a new solution being adopted as the latest shiny. Why? Because somebody will come up with a measurable better solution or the problem set will change to reflect new technology giving opportunity to handle data differently. The last thing the programming community needs is to develop an attitude that innovation is no longer required. Such an attitude nearly killed the American automobile manufactures. 
Don't let the negative Nellies get you down! The last thing this industry needs is an attitude that everything done to date is good enough and we should ignore those trying to innovate. As for your school I glad to hear that they are making you do this. To many schools teach students to cut and paste code together but don't force them to understand what is happening on a deeper level. I certain you have already learned a bit about data handling. Sadly you have also learned a bit about what you will be up against when you get out of school. 
Hello dunkler_wanderer My apologies for posting in the wrong reddit, I will be more careful next time. Thanks a lot for your answer, it explained all and my question is now fully answered! Once again thanks 
 &gt; &gt;I 100% agree, however to play devil's advocate, my guess is OP was trying to do this as an experiment to scratch a personal itch. And sometimes the only reason "why" is "because." &gt;I can't agree with that sort of attitude at all. As you note he may be satisfying a personal itch which is good enough reason to move forward, maybe he wants to learn something. Who knows? We know, OP replied it was to help with a school project where they were not allowed to use libs. &gt;&gt;OTOH, between json, yaml, pickling, and XML to name only the most popular formats, there really is no need for an another ML that doesn't bring anything different/new. &gt;Actually some of those formats are good reasons to be searching for something new and more suitable for whatever you are working on. I've never been fond of XML for one, as it is overkill in many applications. In any event come back in 5 years and you are certain to see a new solution being adopted as the latest shiny. Why? Because somebody will come up with a measurable better solution or the problem set will change to reflect new technology giving opportunity to handle data differently. The last thing the programming community needs is to develop an attitude that innovation is no longer required. Such an attitude nearly killed the American automobile manufactures. Your misunderstanding me, I'm saying a format that is just like the existing ones, is not helpful. A new format with new features is however, even if it is not successful. 
Python is an excellent interpreted language that anybody with an interest in a technology field should learn. Programmers are just a subset of the technology workers out there but even here Python is a highly usable language. I would suggest learning Python because it is likely to be a useful tool no matter what you do in the future. The use of the word "tool" is important because it brings into the picture the concept of a tool box. Tool boxes don't contain just one tool but rather a variety of tools. As a programmer you will need access to a variety of tools and Python is a very good tool to have in your tool chest. &gt;Like I mentioned in title, I'm currently in highschool and I pretty much have good knowledge of C and we're still learning C# and Asp .NET. I tought it would be funny to learn Python since I'm very interested in Arduino and Raspberry-Pi involved projects. Frankly I not sure why your school is bothering with C# and asp,net. From my perspective it would be better to learn via standardized or widely supported languages. These are very MicroSoft specific languages that have nearly zero uptake outside of that environment. Comparatively Python is every where. You find a version for all major operating systems and a few not so major. Plus it can be embedded standalone in a MicroProcessor. New things like Jupyter Notebook just makes for a more interesting Python world. &gt;But, I have dilemma about wether I shoud learn Python or Php or nothing at all because I may get cofused cuz I'm learning C#? What do you guys thing should I learn it or I should wait say it 1 year till I "finish" dealing with C#, and is it worth learning in my case? Unless you have some sort of mental defect that makes learning languages difficult I don't see an issue with learning Python right now. Knowing more than one language often makes learning or transitioning to another easy. Never learn PHP, hopefully by the time you are programming professionally the language will be completely dead. As for C# if it is part of your program you don't have much of a choice but to learn the language. I just think it is very bad form to be teaching platform specific languages this early in your education. Hell even Apples Swift has a larger adoption outside of Apple. Almost all use of C# outside the Microsoft world has died or dried up to the point of being as good as dead. That doesn't mean C# won't be useful to you in the future just that you are only likely to see it on Microsoft platforms. 
list[:] does a shallow copy, i.e. it makes a completely new list with the same elements. It's handy if the thing you're copying is some iterable thing and not a normal list.
Right now there is a lot of interesting things happening around Python. I mentioned Jupyter Notebook in another post as Python was a key component in getting that project to the point it is. Then there are things like Numpy, OpenCL support and other initiatives that have made Python popular in engineering and research. Not to mention is that it is the best system scripting language out there. To put it mildly Python has been a "hot product" for a few years now and is still picking up steam. The fact that it is used so widely just gives me confidence in suggesting that it is a good language to learn right now. You aren't likely to find a dwindling demand for Python skills in the next few years. At least that is my theory right now, as I don't have a crystal ball think of it as a somewhat informed opinion. 
thanks. The rest of the code makes sense as it was copying, modifying &amp; reinstating the list in the original object. 
How exactly it breaks? What error it gives? The slicing operation makes a shallow copy of the returned list. If the code breaks without the copy, it's probably breaking encapsulation and someMethod is returning a reference to someObject inner data, instead of a copy. 
&gt;We aren't talking about cooking, let's set that example aside. No, we are talking about recipe recommendations. &gt;We're talking about statistical experimentation here. I know, I used to do this regularly when I was in graduate school. &gt;To say "you're not accounting for a variable!" assumes there already is a correlation... Yes, between the unaccounted variable and at least one of the variables you are trying to observe. Confounds exist and must be accounted for, if you ignore them your results will be biased. There are reasonable assumptions you can make to remove these confounds, and these require domain knowledge. If this wasn't important, grad students in the sciences wouldn't need to take additional classes in their field. &gt;In the case of "time of day" bias, we can control for this by taking samples at all hours of the day. Even better, across the span of multiple days, though this may not be necessary if sufficient* data is collected across a single day. Yes, but you should compare like to like, rather than comparing all searches across all times, because you'll confound the results. This is pretty basic design. The answer to confounds isn't always more samples. &gt;In the post-experiment analysis, we can see if our design worked, by seeing that there is insufficient* variance from hour to hour to claim any sort of correlation. Now you are taking into account the variable you claimed shouldn't be accounted for earlier in your post. This post-hoc test would be unnecessary if you used your domain knowledge of how people look at their meals to design a better experiment (perhaps the same experiment in separate time bins). We aren't trying to see if there are differences in time bins, we are tailoring our testing of the recommendation engine to take into account different times of day. Recommending waffles for dinner, while delicious, won't be of use to many. Other things testing live should take into account could be country of the consumer (dosa to an Indian customer would be a better recommendation than steak and eggs), personal preferences (this could be skipped with an easy personalized filter), etc. That being said, /u/Sukrim answered all this in his initial post already, so I'm not sure what you're trying to argue here by (kind of) describing an extremely basic experiment. tl;dr 'more samples' is not a good way to address confounds. 
 &gt;Show some respect. I'm not convinced that his intention was to cause you problems. He has no way of knowing what you native tongue is. It isn't a bad idea to indicate your native language when starting a thread like this, it can actually help us understand the phrasing you use. &gt;If someone does not speak English well, that only means that person know another language fluently. Well sadly not. You would be surprised to find out how many in the USA actually do worst than your posting. These are supposedly native speakers of English. So in a sense you have done better here than some Americans would with English. This doesn't mean that you can't improve things though. It is important because so much of the IT industry is operating around the English language. I'd suggest chilling out. Language isn't everything but even so you managed to get your concerns addressed here. 
I disagree. Many people know and are comfortable with Excel, switching to something else would be too costly for them. The solution above beings python into THEIR tool set. They can use the tool they are familiar with to further enrich the workflow. Your alternative front-end solutions are a pointless diversion if all most users are going to do is take that data and put it into Excel to continue their real work. You might like to this of the solution above a short-term thing, but there is no difference between short-term and long-term in most businesses. This gets them 90% of the way "there", and in most cases getting the extra 10% isn't worth the extra pain or effort.
I once had to do something similar, I used the the os.system to pass instructions for the command line, all zip programs support a command line interface. Here is a link where you can read more about execution of command line with python: http://stackoverflow.com/questions/450285/executing-command-line-programs-from-within-python
I don't see the issue. In A/B or this, you need to assess whether the choice was effective or not. The OP is just suggesting you weight how often A or B is shown based on how often they have been effective in the past. Or did I miss something?
If you're comfortable using gdb, there are [Python extensions to gdb](https://docs.python.org/devguide/gdb.html). It's not really the same as using pdb, but you can do things like `py-bt`, which is hopefully helpful enough for e.g. debugging a production process. I don't know if there's a pdb-like debugger to attach to an existing process. Maybe someone else does.
Thanks for such useful info! Also, my school is Microsoft-oriented cuz teahers find it more practical to learn SQL Server, IIS, Asp .NET and C#, idk why. Although my school profile is experimental, in fact there are quite a few schools in my country with same profile, where students learn Java, Php and MySQL, idk why.
Hi there. You have posted a learning question to /r/python. These types of questions are far more suited to /r/learnpython, where users are actively interested in helping people to learn. Please resubmit it over there! Make sure to read their sidebar rules there before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." If your question is about homework, show them that you've tried to solve your problem in your post and you should get all the help you need. For anything else, the reason you are seeing this message is still that you will likely get a better answer there! Warm Regards, and best of luck with Python!
I don't think trying to python-3ize python2 strings is just a very good idea in general. Too many things expecting stuff to work the python 2 way will break. Save the unicode enlightenment for when you finally get to run on a python 3 interpreter. Also you can use `u'unicode'` as well for when you explicitly want that.
Future proofing python 2 code? Simple use python 3. Python 2 will be dead by 2020. Thank god. Time to move on people. I understand that maybe if I project were inherited and was coded using python 2 then that's unfortunate. But if you start a new project on python 2? then you deserve all the misery that goes with using it.
Sorry, I was being a bit lazy and didn't want to get too in-depth into that. The classic a/b tests are very directly tested, like seeing if a differently-colored 'buy' button creates more sales. However, much of the time you actually want to test things that are much more subtle. For example, you might want to know (if you were reddit) how changing some aspect of the account creation process affects users' behavior on the site. That's the type of thing that you'd want to track over the course of weeks or months, which means you have to make sure you still know which users went through that process a long time later. Some large web companies take this to an extreme: they've got a whole set of metrics, and every time they deploy a change, they start rolling it out to a small group of users, then gradually increase the pool more and more as time goes on. Simultaneously, automated systems monitor every single metric for anomalies, and any issues there trigger a rollback; so if a change to Facebook's photo album display causes a decrease in the number of posts that people are making, that'll cause a rollback, even if no one ever anticipated the one affecting the other.
I haven't seen your project jet but it's a fantastic idea! Maybe I will try to contribute.
Looks promising, thanks!
EDIT: Actually, I'm not sure where I got the impression that it worked on Mac. I may have just assumed because Python and Mac. If it's not supported, then I guess i'll have to wait / play it on a VM. Sorry for the trouble! Hey, just as a head's up, it may not be plug and play on Mac. If you don't have the required dependencies, you'll have to install them. I don't know if Python has a dependency manager, so I don't know if this is something you can fix, just thought i'd ping you to let you know in case you missed this during development. I'm looking forward to it! Example: $me ~/D/INJECTION_0.9.0_src [125]&gt; python main.py Traceback (most recent call last): File "main.py", line 70, in &lt;module&gt; import rsa ImportError: No module named 'rsa' $me ~/D/INJECTION_0.9.0_src [1]&gt; pip install rsa Collecting rsa Downloading rsa-3.4.2-py2.py3-none-any.whl (46kB) 100% |████████████████████████████████| 51kB 1.7MB/s Requirement already satisfied (use --upgrade to upgrade): pyasn1&gt;=0.1.3 in /Users/$me/anaconda/lib/python3.5/site-packages (from rsa) Installing collected packages: rsa Successfully installed rsa-3.4.2 $me ~/D/INJECTION_0.9.0_src&gt; python main.py Traceback (most recent call last): File "main.py", line 71, in &lt;module&gt; import pymsgbox ImportError: No module named 'pymsgbox' $me ~/D/INJECTION_0.9.0_src [1]&gt; pip install pymsgbox Collecting pymsgbox Downloading PyMsgBox-1.0.3.zip Building wheels for collected packages: pymsgbox Running setup.py bdist_wheel for pymsgbox ... done Stored in directory: /Users/$me/Library/Caches/pip/wheels/2c/a8/ed/24e18e118cd17eaa6d581eea79f3ffc37f56b3bf1d9df0f6cd Successfully built pymsgbox Installing collected packages: pymsgbox Successfully installed pymsgbox-1.0.3
&gt;When does it clean up the data? Some people gave the "its garbage collected" answer, which is true. Specifically, python is reference counted for garbage collection. Whenever you do something like `x = "Zardeh"`, python increments the reference count of the PyObject that contains the variable. Similarly, if you put something in a dict or a list: a = "a" my_dict = {a:"string"} the refcount for "a" is now two, it is referenced in two places. the refcount for "string" is one. When you delete an object, it leaves scope, or a referencing object is GC'd the refcount is decremented by a corresponding amount. So in the above example del a # now a's refcount is 1 from my_dict del my_dict # both are collected now
Library bug, I'm working on a workaround.
It's not a gui framework like Kivy, but a packaging tool like [python-for-android](http://python-for-android.readthedocs.org/en/latest/). I've not looked deeply at it and I'm sure the OP can give more details, but it looks like this is focused more on creating APKs (or possibly python scripts run in other ways) using SL4A. python-for-android can package non-Kivy apps but doesn't currently have any SL4A integration and you'd normally (including with Kivy) use pyjnius or plyer for Android API interaction instead.
`six.b` is only for versions that don't allow the `b` prefix (i.e. 2.5 and below). Unless you're targeting that far back, you don't need it at all.
Did you read the article? The first two paragraphs talk specifically about why you would need to do this.
[removed]
You can use PyDev (http://www.pydev.org). 1. Open the debug perspective (window &gt; perspective &gt; other &gt; debug or if it's already open cycle to it with Ctrl+F8). 2. Select the menu PyDev &gt; attach to process. 3. Select the process that you want to attach to. 4. profit ;) You can see better instructions at: http://pydev.blogspot.com.br/2014/09/attaching-debugger-to-running-process.html Now, attaching to another process is actually a tricky process, so, if for some reason it fails, another option may be using the remote debugger and adding a programmatic breakpoint in your python code -- access http://www.pydev.org/manual_adv_remote_debugger.html for more information on setting up/using the remote debugger (note that after attaching to it programatically, it'll respect the breakpoints you added in the UI and you can use the UI to add/remove breakpoints as needed). 
That's great to hear, thank you very much!
Really interesting. Is it possible to use the Android API from Python code?
Suggestion: add something that lets me copy/paste things properly. Like iPythons '%paste' magic. This would be very helpful, especially for programming the drones. As I said in my other comment here, REPL and multiline code don't work well together for me.
Okay. Those string format expressions are sexy enough that I might have to migrate to Python 3 soon.
Linux *is* supported (OSX isn't, though) but I'm a Windows user so the game doesn't really get tested on Linux. Come to /r/INJECTION, we've got a big ol' discussion about Linux issues.
Oh. Well all right then.
Unfortunately, unless there's an iPython REPL emulator like the `code` module in the standard library, nope. But you can write stuff in another editor and ctrl-V it in, multiple lines works fine when I try it anyway.
Thanks! I'll check it out. :)
Huh...looks like I learned something new today. You can charge with MIT, [this page](https://programmers.stackexchange.com/questions/255227/meaning-of-mit-license) basically sums it up. The other restrictions makes sense. Am I correct in understanding that you'd like to finish the game first before putting it on github, or before charging? 
You should be able to paste stuff in with ctrl-V; does that not work for you?
I think that a limit about the growth of Python on android is the type of devices we use android on and the OS that hasn't an accessible command line. It is difficult to "install" Python scripts on android and the APK packaging is not a comfortable way. So, I'm sure that the best way to run Python in android is to have a PYTHON MARKET app, that integrates pypi and allows developers to push their program.
Thanks.
It works for a single line, but as soon as i paste multi-line text it breaks down in interesting ways I haven't yet fully understood. Sometimes it pastes only the first line, sometimes it pastes multiple lines but i get an indent error (the indents are correct though), sometimes it just posts an empty line and that's that.
[RQ doesn't currently have any built in concurrency](https://github.com/nvie/rq/issues/45), though there's nothing stopping you from running multiple worker processes manually or via whatever means you use to manage your processes (supervise, daemontools, etc). The big advantage of RQ when compared to celery is its simplicity, and that's why I recommended it as an alternative to the solution in the linked article. If you're already using up and running with celery and aren't hitting any problems with it then there's no reason to switch.
Not for longer code, no. [Best continued in the other comment](https://www.reddit.com/r/Python/comments/4dp2za/new_version_of_python_programming_puzzle_game/d1ti7m2)
Nope, it's been in the dev builds. So no need to worry. Edit: wording
I'm torn. It saves some typing, but I like explicitly handing a namespace to a template. Just pulling in the local namespace implicitly sets off some kind of red flag in my brain, though I'm not sure I've fully thought it through.
Cathy, this question is not related to python but you were super helpful and it may or may not be your expertise: https://www.reddit.com/r/VisualStudio/comments/4dr0ls/trying_to_install_vs_2015_w_update_1_after_update/ My sneaking suspicion is that there is something lingering in the registry from update 2 that is conflicting with the update 1 install. If I am overplaying my hand by asking for help on this more complicated issue then I totally understand.
Are there any interesting upcoming PEPs?
Well, the empty line thing is actually purely graphical, your code still goes through. It's the terminal emulation library again, you should see the hacks (look at the InjectionConsole's getline method in levels.py) I had to do to get it to work at all. I'm gonna rewrite it from scratch before I call the game "done" and that'll fix all these issues.
Could make refactoring a pain - have to make sure you search in strings too. 
f strings look like fun and the ISO formats for datetime.strftime are something I'll definitely make use of. Cool. 
I want to move to Python 3, but I'm working with libraries that only support 2.X. Frustrating!
Last time I used it, python3 -m venv didn't work for me and I had to use the script.
It's not 100% yet, according to the Python 3 wall of superpowers it's [174/200](https://python3wos.appspot.com/). That's the 200 most downloaded packages on pypi, so if you're using a smaller package chances are you're out of luck. 
I disagree with your opinion related to this specific library (json), but I don't really have a moment to hash it out.
Thanks. I will. Just wanted to verify first what to_sql is doing before going that route.
Python definitely needed yet another way to do string formatting /s
Yeah I think it's getting a little ridiculous with all the different methods. I really am not a fan of the f"" string formatting. I just don't like the fact that it grabs variables from current scope. I understand that people want to avoid the repetition when using the format() method, but it just feels a little too dangerous to me. Also while I see the convenience of basically embedding code in the string, it also feels a bit dangerous to me.
The wall doesn't tell the whole stories. Some libraries haven't been ported to 3 (and some will never be), but in many cases their functionality is available in other packages (python-ldap, python-mysqldb, etc). Still, you gotta rewrite code, and that's not always a simple proposition.
It works for me with Python 3.5.1.
The PEP should include an ammendment to the Zen of Python: "There should be one-- and preferably only one --obvious way to do it -- except for string formatting: we need more ways to do that." 
Even then, it doesn't do anything...Here's the code... if PY3: def b(s): return s.encode("latin-1") def u(s): return s else: def b(s): return s It's just a `return s`. It literally does nothing on Python 2. I want it to do: def b(s): return s.encode("latin-1") because I have `from __future__ import unicode_literals` 
Python definitely needed f-strings because it's solved all of its problems and there's certainly no more room left for improvement of the language other than string formatting. I think it was Flask's author who once said core developers are out of touch from the real world but I honestly didn't expect this.
It runs using cron on a home server (raspberry pi), Monday through Friday.
&gt; There should be one-- and preferably only one --obvious way to do it.
Well, "unless you rewrite a bunch of stuff" is sort of implicit whenever you're talking about 2 to 3 porting and package availability. When people say that the packages they need aren't running under 3 yet, that's what they mean: my dependencies aren't there yet and I don't want to/can't get greenlit by my boss to rewrite the project to work without those specific dependencies. But sure, you have a point. 
´format´ and these f-literals are meant to replace the older methods, so while there are many ways to do it in practice, you're only supposed to use one of two (similar) methods. 
Because of this article, I discovered this awesome package and virtual filesystems. Using it turns out to be a great way to solve a number of my problems trying to locate missing files across a large number of sources. One thing I can't figure out though. Can I mount a SMB share? 
Makes me wonder why they did not change the tokenisation rules for [f string interpolation](https://docs.python.org/3.6/reference/lexical_analysis.html#f-strings). Having to type f'{d[\'k\']}' or to alternate between quotation marks will be getting tedious. Especially since the syntax even allows for yield expressions. The following runs in 3.6 HEAD: def q(): print(f'a{yield from range(5)}b') qq = q() res = list(qq) # prints aNoneb print(res) # prints [0, 1, 2, 3, 4] 
Human readable string operations of one form or another are probably by far the most common use case for Python. It should be no surprise if string operations get the most attention for expansions and improvements.
The most interesting feature of CPython 3.6 for me is the optimizing compiler: http://faster-cpython.readthedocs.org/fat_python.html It's not yet showing up in the release notes as far as I can see and there is still much to be done.
It is also a real pain in the butt to refactor, but I absolutely agree on the danger of blindly pulling in the local environment. It is also not that hard to do explicitely, by just passing `**locals()`. Honestly I would have preferred if this were done by having `f"foo{value}bar"` return a string class with an exec method: `__exec__(*args, **kwargs)` that simply dispatches to `format(*args, **kwargs). Then if you want the behavior that the f-strings offer you simply say `f"foo{value}bar"(**locals())` which is nice and explicit, but you could also use them as slightly more compact format strings `f"foo{}bar"(15)`.
the project packages with SL4A so there are may API calls that are already incorporated into the package, and we are working on adding new ones if requested. if you need a call that isn't already there you can create the java method to access from your python script. the whole problem with on the fly calls is that java code needs to be compiled to dex format so all this needs to be done at compile time. i am working with the maintainer from the SL4A project to add custom loading dex files to so it can be on the fly as much as possible. you can also launch almost any intents which is pretty cool. 
It doesn't “grab”. It's an expression. Think of it like applying an operator on those variables or passinh them to a function call.
You didn't. It's not a string literal, but an expression evaluating to a string. Just like using variables in a function call or operator application, there are no flags to be waved.
I struggled so hard to even get virtualenv to run. virtualenv command not found, then permission denied, etc etc. I couldn't believe it. I can't wait to never do anything but `-m venv` ever again.
So use all three. Got it!
I'm not ready to dismiss my apprehension so easily. There is still something implicit going on here. It is an expression that uses the syntax of a literal, and maybe that's where the uneasiness comes from.
I would be ok with having those two methods (format and f-literals) alone (since the second seems to just be syntactic sugar for the first) if they would deprecate the old printf-style formatting and `string.Template`. Maybe this will happen with python 4? 
I do. It gives me a sh activate script on Windows, which I can use in msys or msysgit.
Bummer.. I just learned about WHY I should care about using virtual filesystems. Now it looks like I'm going to have to learn how to make my own. It's going to be so useful for me. For now, I'll have to do a hack for this job until I can learn how to build my own implementation when I get the time. Thanks. 
isn't it equivalent to `fstring.format(**globals())` or something?
Strings that get evaluated at runtime which includes evaluations of python expressions that might have side-effects just seems like a security nightmare waiting to happen. It just feels wrong when it's auto-magic as opposed to the explicit use in .format(**locals())
Of course it is not the only solution, but to know and how to use global variable should be basic knowledge for beginners. And for his 2-3 functions that would be a good practice also. A full answer is here: http://stackoverflow.com/questions/484635/are-global-variables-bad 
Does Flask provide admin control like Django? I am new to Python and those framework and I tried Django and felt it has things ready for me like managing the admin side. 
IIRC, it also works for expressions like `data['x']` or `data.x` or `data.x * data.y`
Pretty sure python supports that just fine since it has utf-8 encoding support for source files.
This framework is actually truly compelling if you take the time to [read some of the docs](http://morepath.readthedocs.org/en/latest/) - I've been a long-time user of CherryPy and [Nagare](http://naga.re) and finally see some of the benefits of both and beyond in it.
&gt; I never think that string formatting isn't powerful enough, but when I'm writing Python, I often think it's too complex. I have no problem with string formatting. I have a problem with lambdas and I've been coding python for 10 years.
&gt; every time they deploy a change, they start rolling it out to a small group of users That's not A/B testing, [that's a Canary Release](http://martinfowler.com/bliki/CanaryRelease.html).
I've had good experience building Flask APIs that connect to Neo4j. While Django has some powerful features (like Models and Forms), I much prefer to start with a more micro and unopinonated framework like Flask. You might find this a good reference for getting started with Neo4j and Flask: https://github.com/nicolewhite/neo4j-flask
I can't specify exactly which ones I am using (corporate policies), but they are libraries for accessing a manageability suite of tools for virtualization. 
It was originally intended to deprecate the old way in Python 3. Too much complaints about that made the developers revert that decision.
I can also give a hand with setting up source control =) 
Who ever wrote this ignored every recommendation about keeping the image size low.
&gt; https://github.com/nicolewhite/neo4j-flask Thank you so much. my question here is that I am building a scalable app. it will start small but I am gonna expand it in the future and add more functionality so, Do you think Flask is good for large Applications? I am asking because I keep hearing the word "Micro". 
What if you forget that "f"?
[One way to deal with defaults is update-alternatives](http://linux.die.net/man/8/update-alternatives). Letting the default package manager (i.e. apt) sort things out, there won't be collisions in libraries. It'll just be the case that one needs to use a different command name to invoke a different version (ex. python -&gt; 2.7, python3 -&gt; 3.4). A virtualenv is created with a specific version of Python, and hence, it isn't designed to be upgradable. You'll just need to create a new virtualenv with each new Python version and reinstall the requisite packages. If you use a package manager such as pip, or even better, a requirements.txt, this reinstallation shouldn't be much work. HTH
Agreed, I don't think there're many excuses anymore not to switch. The only (minor) issues I've had are with `print()` and some `bytes`/`unicode`/`str` incompatibilities (fixed with `encode()` and `decode()`).
Correct me if I'm wrong, but I don't enough much progress on this to have it land in 3.6, except for a couple of smaller patches that got accepted. Also, apparently FATpython itself [doesn't provide noticeable improvements yet](https://mail.python.org/pipermail/python-dev/2016-January/142902.html). Currently I'm most excited about the [wordcode patch](https://bugs.python.org/issue26647).
How would I go about upgrading my interpreter to python 3.6? Currently on ubuntu with python 3.4, tried apt-get update -&gt; upgrade but I remain in 3.4.
Bytes is actually one change I kind of like, especially dealing with individual bytes Python 2.7 &gt;&gt;&gt; x = b"\x7B" #123 - Python 2.7 &gt;&gt;&gt; x[0] == 123 False &gt;&gt;&gt; ord(x[0]) == 123 True Py 3.5 &gt;&gt;&gt; x = b"\x7B" #123 &gt;&gt;&gt; x[0] == 123 True Granted, dealing with mixed string/byte streams has been frustrating at times just because I was so used to how Py2.x dealt with them. What about you? What have you run into?
I do think such things should be reported, even though they commonly aren't. There's no existing tool that measures it AFAIK. I think generally people consider it a one-time cost that amortizes to 0 over a long run. I don't know that that's always true. 
There is probably a PPA for it somewhere. Or you can compile it yourself. Ubuntu probably won't have it for a while, but I don't know their release schedule for packages (I don't use it).
Micro means the framework is small but that doesn't mean it cant scale. If you use anything other than djangos default orm. You're better off using flask
PyCon US is sold out at this time. :(
It's not a library, exactly, but Supervisor doesn't work in Python 3 yet.
I have had g-strings break on me in weird ways. When trying to build some dynamic db queries, If I use "${a_db}.${a_schema}" I actually end up with two strings split on the "." This may just be a grails thing though. 
There is one other problem with lamdbas.
&gt; (since the second seems to just be syntactic sugar for the first) At first glance it would seem to be, but I'm getting downvoted for suggesting that I wish it were actually syntactic sugar for `.format(**locals())` so some people seem to think it is really important that it NOT be seen as sugar for `format`.
Personally, I add Felix Krull's "deadsnakes" repository, which has the latest 3.5.1. It lags official releases but not by much, and it's hugely convenient to be able to use my system package manager. 
&gt; Release: 3.6.0a0 &gt; Date: April 01, 2016 I was expecting a late April Fools joke
In terms of refactoring, the f"..." string is *exactly* like code. It's *exactly* like writing "Hello, " + str(expr1). There is no way in which it is harder to refactor, except that an editor's syntax highlighting might be unaware. It is *easier* to refactor than .format, in general, because it is forcibly fully written in exactly the place it will be evaluated by virtue of necessarily being a literal. As for f"..." returning a callable, the real problem is that your suggestion is just the same as passing around "formatstring".format, so it certainly doesn't buy us anything. But what I was talking about isn't really a "safety" issue, but only a "hard to find bug" issue, which is that you can make the evaluation happen at a later time. Such as: strs = [f"{i}" for i in range(10)] for s in strs: print(s(**locals())) Essentially all the problems with dynamic scope and not use closures can be reintroduced (that's essentially what the returned object is: a dynamically scoped non-closure). The full extent of these problems are among the most nefarious you could imagine. You can of course always evaluate it right away to avoid this problem - but then, there is no reason to have the intermediate callable exist in the first place. EDIT: Finally, a benefit of f"..." over exec: the interpreter knows that the expressions need to parse. A malformed string passed to exec can only be caught at runtime, even if you wrote it as a literal.
Correct me if I'm wrong (and there's a good chance I'm missing something), but allowing expressions in a string seems like it would open up any websites that upgrade to 3.6 without whitelists on every input to pretty easy attacks by people much smarter than me. Is there anything preventing somebody from sending a formatted string with something that can execute and provide access to things users shouldn't be able to get? Script injections are a common issue and this just seems like it's opening up doors that were otherwise closed. 
If you override the classes of the logging implementation you can use `.format()` in logging. The issue there is that logging needs to know which formatter to pass the arguments to, but the interface establishes no way for the `logger.LOG/WARN/INFO/ERROR/etc...` functions to express which formater they want. From what I understand f-string literals cannot be used at all for logging (because they need to be evaluated at the expression point, and can accept mutable arguments).
In Python 2, .format will coerce to the caller's type and % will coerce to unicode if one of the two operands is unicode. This inconsistency has caused bugs for me at work. 
`%` was promised to be deprecated, then it never was.
People like to snipe on this a lot. Designing a language is hard. Compared to the feature redundancy that's crept into other 20-year-old, general-purpose programming languages, Python's done well. 
Except for byte strings, which only support % formatting and not .format :-/
Flask doesn't come with an admin module built in. You can add one in but it's an extra module. I would suggest if you are a beginner with Python that Django would be a good choice. Some reasons it might be good: * Clear opinionated ways of doing things, makes getting started quicker and easier. * Django comes 'batteries included' meaning you can worry about your app instead of which library is best for X,Y,Z to add to your project * Great learning materials online and available in print (2 Scoops of Django) * The excellent Django REST Framework makes getting an API up and running with best practice baked in pretty easy. (Great docs too!) * Clear, defined and documented project structure making it easier to figure out where to put different bits as you build your app up more. Flask is a great framework but personally I think it's a better choice for experienced developers/those more familiar with the language and ecosystem of available packages. Hope this helps a bit!
Yeah, you have to either recompile or comment out all references to the `fx` module. On Linux doing the first one is easy, not so much on OSX, and even if you did there's other issues. It just doesn't work. You might have better results with WINE though, if I haven't mentioned that before.
I did that, but I want to step thru the python code - not the compiled code or trace thru the Linux C system calls or deb uggg a segfault etc... Its a large server process that runs as a daemon
3.6 isn't officially released yet. These are just the notes for what is currently expected to be included in the release: https://www.python.org/dev/peps/pep-0494/#id6 The current expected release date for Python 3.6 is 16 Dec, 2016.
Exactly. I have no problem with change where the new version replaces the old with something that's better. Like you, though, I have no idea which is the recommended Pythonic approach to string formatting these days. 
"String formatting is a honking good idea, we should do more of those"
While you can't run arbitrary code, you might run code you didn't intend because you weren't expecting to look inside the " for executable code. I think that is going to be a challenge for a lot of people. 
Backport it all and call it Python 2.8 /s
Multi-threading.
I don't know. It just seems like a fair bit of hassle to do an install and update to another version of Python for such a small amount of changes. Personally I'd prefer updates to happen only once every 3 or 4 years, but I've been spoiled by Python 2 where Python 2.7 had really good longevity and was able to be off the release-update merry-go round for a long time.
I think you're misinterpreting the feature. PEP 498 introduces the syntax `f"..."`, which is essentially just syntactic sugar for `"...".format(...)`, where scoped variables are passed to the format. So... name = "foobar" s = f"Hello {name}!" print(s) ...would print "Hello foobar!" Strings that aren't prefixed with `f"..."` are not affected, so programs built on Python &lt; 3.6 are by definition not affected because `f"..."` is invalid syntax on older versions.
I'm not yet convinced they aren't worse than %. I can say `logging.info("x = %s", x)` and have `x.__str__()` evaluated only when logging is enabled at this level (which is one of the only cases I have for actually needing to format strings). I can come up with some way to do this that uses `.format()` or f-strings but all the ways I've seen have been much worse than just using % style.
If you reimplement the same functionality four different times in four different and incompatible ways then I'd hope there was something fundamentally broken because otherwise it just leads to needless fragmentation, wasted effort and confusion.
Not to mention, even if it was all strings, the transformation from f'' -&gt; ''.format() happens during the bytecode compilation pass... so can only apply to literal strings in the code, never strings provided at runtime.
In defense of the Python Zen, there was 1 non-obvious way to do it, which was superseded by a cumbersome way and now there is a good, fairly obvious way. The problem is they should have come up with `f"{}"` at the same time they came up with `print()`, so they could remove the `%` and the `"{}".format()` way and only have one way.
I take issue with the way that it looks, not what it does. When I am working in PHP or Bash, I can't just skim over string literals, because they aren't just literals. With the addition of f-strings, python becomes the same way.
It's not hidden. If your syntax highlighting highlights the contents of braces in f-literals in the same color as strings, that's a bug. Those inner expressions aren't more “inside” or “hidden” than when doing `'x' + str(y) + 'z'`. f-literals are simply expressions.
Actually they kept % because people wanted to keep it that hard.
I don't get what's so great about it. So...I can do the exact same thing as I was doing with .format(), only now I can do it another way? Why?
If a syntax highlighter doesn't make clear that the brace contents aren't part of a string, they're not doing their job and a bug report should be filed.
 import datetime my_variable="something" f'''This is my string. I can have dynamic content that was updated {datetime.datetime.now()} without having to provide any additional context. And when I come back later to add more content, I won't be plagued by messages indicating that I forgot to add {my_variable} to the context.'''
Eh- I feel like we're talking past each other. I don't particularly care if there are many ways of doing things. I care if there are many ways of doing things that actually get used in reality. So yes, it's a problem that there are multiple string formatting solutions in use in Python code. But if a new one comes out that's superior in the vast majority of use cases, that becomes significantly less of a problem because more of the community will standardize on it for future code. If it's equivalent in strength, I agree that it will only add to the problem. Fortunately, I don't think that's the case here, and if it had been I doubt PEP498 would have been approved. I don't think deprecating %s or .format() in 3.6 and removing them in 3.7 would change much- it will just make people take longer to move beyond that point, since they'd have to change a bunch of their code. I think 3.0 showed that incremental progress is overall superior for the community- alternative solutions can win market share on their merit, not by fiat. &gt; No, I'm not, and that's a great example. Everything went Bluetooth a couple years ago ... okay, and what is your bluetooth transceiver plugged into? :p &gt; Yes, and that is a fundamental change in how Python is going to be used. Not at all. That's been the case from the beginning, and PEP8 is explicit about it: ` A style guide is about consistency. Consistency with this style guide is important. Consistency within a project is more important.` Every company I've worked for has gone beyond PEP8 in choosing specific styles, whether it's something simple like agreeing to a maximum line length or something how to format and indent multiline dictionaries. And, even more relevantly, for how to format strings. Does your codebase already just mix and match between %s and .format() whenever people feel like it? These things are obviously outside the realm of "Pythonic", but they also already exist- your problem of &gt; it's getting to the point where string literals are taking a non-trivial amount of mental effort for me to parse. will likely become significantly less of a problem if your team chooses to adopt the new usage. If enough teams choose to adopt the new usage because they find it superior, then EVERYONE's problem lessens. 
You didn't understand. There aren't dynamic f-expressions. They're always static and therefore always written by you. No security implications whatsoever.
&gt;I don't know. It just seems like a fair bit of hassle to do an install and update to another version of Python for such a small amount of changes. Then don't update. There's nothing that says you have to be running the bleeding edge if you're not going to use the new features. 3.6 will still run your 3.x code if and when you do upgrade. 
&gt; I fear for my terminal wielding comrades, though. Rope already handles [variable renaming in strings and comments](https://github.com/python-rope/rope/blob/master/docs/overview.rst#renaming-occurrences-in-strings-and-comments), I see no reason that it should find this difficult.
Holy shit, that is awesome. I love it.
 $ wget https://repo.continuum.io/miniconda/Miniconda3-latest-Linux-x86_64.sh ~/miniconda.sh $ ~/miniconda.sh -b -p $HOME/miniconda $ conda create -n py35env python=3.5 $ conda create -n py34env python=3.4 $ conda create -n py27env python=2.7 $ source activate py35env This was typed from memory, you may have to fix some things.
You mean you don't like the many different ways to do concurrency, all of which have enormous pitfalls that aren't immediately apparent? Asyncio, Threading, multiprocessing, concurrent.Futures, and the proposed SubInterpreter support? \s
https://docs.python.org/2.3/whatsnew/section-pymalloc.html
Unfortunately, f-string expressions are evaluated after escape sequences. So f'\{4\*10\}' can be written as f'\u007b4\*10}' or various alternatives. This makes accurate refactoring tools, syntax highlighting, or just grepping more difficult than it should be.
I'm assuming you're using python 3. I think the StringIO module is for python 2.
This looks like it should be part of the equation here. I see that pyenv puts different python installs into its own location. I'm assuming as you do pip install, it will put the packages into that directory structure too. I guess we'd also want to layer virtualenv on top of that.
Which is...?
A backwards incompatible syntax change is justifiable enough. 
Lam***db***a.
Reminds me a lot of string formatting in Swift: let multiplier = 3 let message = "\(multiplier) times 2.5 is \(Double(multiplier) * 2.5)" // message is "3 times 2.5 is 7.5" 
&gt; It shouldn't be that hard, try and format one way, if that throws an exception try the other way. Because that's horrible?
More horrible than: 1. Actually deprecating the old format? 2. Having three different active string formatting methods? 3. Having code randomly fail when you import new modules because they use conflicting string formatters?
If it is 95% done then it should be easy to add to the standard library.
Other than PyPy or building some other JIT interpreter, is there anything else that you could use RPython for usefully?
The string literal is evaluated at runtime, ie. when the string literal is defined in your code. So x = "bar" s = f"{x}" x = "lol" print(s) will print "bar". Unless you do an `eval` on user input, there's literally no chance of getting an f-prefixed string *literal* from the user.
I need to use python 2 for the tableau API to write tde files. Everything else is in 3 though
3.6 isn't even remotely finished yet (it will be released this december or later). The "What's new" page will grow substantially in the next months.
Why would you be sharing your logger with a library?
All loggers are shared. They all share the same root.
I don't really use Python's `logging` library (I imagine you can tell), but I thought you weren't meant to ever use the root logger, only ones you got from `getLogger`.
Django and its ORM are designed to connect to a RDBMS such as MySQL. You can't just connect to a graph database such as Neo4J, because the concepts of the database are wildly different. So if you use django, all you will effectively get is URL routing, and maybe form helpers. You can achieve this with other frameworks such as flask and pyramid (my favourite), or with REST specific frameworks such as falcon. To throw another spanner in the works, I prefer OrientDB to Neo4J. OrientDB also comes with a built in REST server, so that might make your job even easier. This way you may be able to use a python framework for the user authentication and session control etc, and the orientdb rest server for the data. I imagine this would be rather easy to setup with nginx. Another thing to consider is apache tinkerpop/gremlin, which as I understand it is a common language for graph databases, that can run on top of the likes of Neo4J and OrientDB, and allow you to swap the actual database whilst maintaining the same code. You could also look at using the python package [Bulbs](http://bulbflow.com/overview/).
That is the one you get from getLogger. That you haven't used the logging module is abundantly clear. You should prefix your logs with your module name, but that just identifies what unit they came from, you still want to capture at the root level for actual logging. If you call a module function and it fails, then the root logger will have all the useful messages about why it failed.
&gt; That is the one you get from getLogger. Only if you call it with no arguments, which is discouraged. &gt; you still want to capture at the root level for actual logging. But surely you don't want to apply formatters to the root logger.
I don't know why you are persisting in commenting on a library you don't use and clearly don't understand. Of course you consume the root logger. You don't emit to the root, you emit to its children, but the format issues occur on the consumption side, and you cannot control what the consumers do. The idea is that the logging system is a hierarchy that many different users can use for different purposes. `__main__` might attach a formatter to only its logger but at an info level with no format beyond the message, and dump that to the console. The `Database` class may log debug information to its own systems for later analysis of query performance. The sysadminn might dump all errors from the File class to the system syslog. And sysops might stream debug information across the network to some monitoring tool. You should never assume that you know who is using logging or for what purpose. The only guarantee is that you all go into the same heirarchy, and that someone may grab the root of that tree. Otherwise there would be no reason to implement the heirarchy in the first place. Just let it be the wild west with each module using its own independent logging instance. Of course then the logs would be an incomplete clusterfuck.
Would this stuff replace using Windows task scheduler to yum a.py file?
I think the danger is that it will be very easy to write unclear code and unclear code + future refactoring leads to weirder bugs. I don't think security is a huge issue (these are only done in string literals) and I don't think side-effects is the real issue as someone else mentioned since those would still happen if you used functions with side-effects in your `.format()` stuff. I just don't like the non-explicit variable binding. Maybe it's just because I'm not used to it or maybe I'm just grumpy, but I feel like this (and the fact that there are like 3 other ways to mess with strings) is only likely to produce code I that will be harder to debug months down the line. Well I guess time will tell...
Wait, what? how does the generator replace the return value of `print`, let alone of `q`? I thought that `f'{expr}'` was supposed to be equivalent to `'{}'.format(expr)`?
I honestly don't care if lambdas are removed at all. They're hard to read, so I don't write them 99% of the time I can. Depending on the code base, that's not a big deal or a big deal. If you have people that are new working on the code...bad idea. Not that I mind. I'm all for backwards compatibility, but if the Python devs twisted my arm, sure. It's kind of like the operator module. I just learned about that the other day.
Are you comfortable with unicode? Unicode is wayyy harder. I guess same with lambdas, but you're forced to learn unicode.
Is this something you could do with pandas? 
Hi there. You have posted a learning question to /r/python. These types of questions are far more suited to /r/learnpython, where users are actively interested in helping people to learn. Please resubmit it over there! Make sure to read their sidebar rules there before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." If your question is about homework, show them that you've tried to solve your problem in your post and you should get all the help you need. For anything else, the reason you are seeing this message is still that you will likely get a better answer there! Warm Regards, and best of luck with Python!
a, b = a[b] = {}, 2
Is anyone working on a to_tde function for pandas by chance? Or a tde API for 3x python? That's the only thing I need a python 2 environment for. 
You have the basic types you need "to construct more advanced tools". I've shown what you asked for takes roughly ~6-7 lines of code on top of built-in types. It can't really be much simpler since as I've pointed out you can't make a `FrozenDict` that can wrap an arbitrary `collections.Mapping` and have it be correctly hashable. If you have an actual criticism of the standard library that demonstrates a problem, you've not given it.
you're smart
Eh, smart or I've done this long enough that I appear that way? :) Thank you for the compliment.
I'm simply speculating at this point, as I know little to nothing about systems programming, nor python internal programming, so take this all with a grain of salt, but I'd say it's most likely because some systems in the past were coded poorly and had additional overhead with the regular malloc, and because the core devs wanted cross platform performance to be comparable, they implemented this change. It also provides a standard api to manage memory, so if python in the future decided to change how it allocates memory fundamentally (regardless of how malloc regularly does it), it would allow them to change the memory management layer without breaking any existing programs. I have no idea about valgrind, I haven't messed with it a whole ton. 
&gt; ...break on me in weird ways. Sounds like Groovy, all right. A neat little concept, but I'd hate to do anything serious in it. Gradle build scripts is where it should stay.
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, we are sure you should get good answers. If you have a question to do with homework or an assignment of any kind, **please** make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Yes, it means the same as != (&lt;&gt; used to be the standard in Basic programming language). != is used in C and derivative languages.
Wow! I've been seeing this as a 5 years old for 10 min. What is this for?
Any plans on putting it in a public repo?
It already is if you use [logbook!](http://pythonhosted.org/Logbook/)
nharding meant `&lt;&gt;` and `!=` mean the same. You shouldn't use it in Python 2 and it doesn't exist anymore in Python 3. Also, questions should be posted in /r/learnpython.
It's still available (in fact required) with `from __future__ import barry_as_FLUFL`
Yes, and it's the same as !=. But you shouldn't use it. It was removed in Python 3, along with `x` being the same as repr(x).
That's got to be the most-suspicious-but-legitimate URL I've seen in a long time.
We are back at perl/tcl baby!
It's deprecated, so don't use it.
Anyone who would do this would be insane, and likely has committed far more nefarious deeds.
There's a solution for logging, shown in the [docs](https://docs.python.org/3/howto/logging-cookbook.html#use-of-alternative-formatting-styles). Basically create a small "logging3" module; implement a getLogger(name) that uses the StyleAdapter shown in the link above, and the rest of your code can be like that: logger = logging3.getLogger(__name__) # ... logger.debug('{}.{} has IP {} in the DNS', host, domain, recorded_ip) Ultimately, the module is 24 lines of code that you can simply put in your projects and not think about % formatting anymore.
Now you can do it without the `.format(data=data)` at the end! Also I interpreted "static" as just a plain old string. However, /u/rouille is incorrect that it only works with static strings. I think that requirement was in an earlier draft, but removed from the final release.
but then you would have to change all your strs to bytes in 2.8!
If your text editor's syntax highlighting doesn't handle that once 3.6 is released, you should file a bug. Giving the expressions in f-literals a “string color” is plain wrong 
It's Punycode, used for international URLs: http://stackoverflow.com/questions/9724379/xn-on-domain-what-it-means
Not really, since they support `str.format` syntax. So you could say that the transformation goes like: f'foo{bar + 2:.05}baz' ➡ 'foo' + '{:.05}'.format(bar + 2) + 'baz' Or: 'foo{:.05}baz'.format(bar + 2) So f-literals are good because they're least verbose and still maintain locality (expressions go in the code where their formatted version goes in the output)
The "in 500 lines of code" part is rather misleading since this depends on tons of third party code.
Thats pretty old, that's why I asked.
What does this mean for newcomers?
I tried, it's 66% polite!
Yes. 5 months old.
I wasn't sure if you were joking so I tried it. I'm not going to spoil what happens because it needs to be experienced.
These features are cute but are they ever going to allow me to compile straight to binary?
Yeah, the amount of legitimate criticism fogleman got for his naming conventions is a big part of why I renamed the project instead of doing a simple fork. Also, it's a pretty bare-bones implementation of minecraft. 
You're reading the goals for the NEXT release. &gt; Current state &gt;Pyston should be considered in alpha: it "works" in that it can successfully run Python code, but it is still quite far from being useful for end-users.
I don't normally comment from a mobile app... 
You never know until you try :) From what I've seen of the sources, everything is pretty nice and clean, even such luxury items as comments and documentation is present... I don't see why people wouldn't contribute.
&gt; everything is pretty nice and clean ***HA!*** I mean, now that people are actually playing maybe I'll see a bugfix or two, who knows. There's bigger priorities just now but I'll get it on GitLab by the end of next week.
Sure but in traditional coding competitions "in X lines" refers to code depending on the standard library and nothing more.
Cool idea. What is your stance with regards to refactoring the codebase? 
 def export_daily_balances_to_txt(balance_data, date_format='{y}-{m}-{d}', currency_format='{0:.2f}$'): # exports your daily account balance to a txt file, # using the provided formatting strings ... You wouldn't be able to do this with f-strings as they are "evaluated" immediately
Heavily in favour. It's 500 lines, so there's not a lot to rewrite. Mostly, I see it as a tiny base so that people can see what they're doing *immediately*. I don't expect any of the original code to survive. I've already talked a bit about the idea of object oriented blocks. So that creating a new block involved inheriting from other blocks and changing a few methods. There's basically no random world generation, so that will need to get created. My hope is that it could be used as a generic engine for roguelikes (like nethack and dwarf fortress) as well as voxel games. But I'm not in any hurry on those points. It will evolve as people scratch their own itch. Later on, I'd like to implement a lot of the ideas in GURPS, so that you can make a custom game by grabbing some traits/entities out of a resource pack. I plan to be pretty permissive of code changes. I'd prefer it if they don't lock us into a super-specific path. Think of it as a voxel-game framework, like django is a web framework. I think python, and the approach of duck-typing, could be the perfect way to make very detailed, very malleable game environments. Mostly, I'm just interested in what this could be if it *did* accept pull requests.
(&lt;&gt;? That's a syntax error. Actually I can't get &lt;&gt; to compile in Python 3.whatever so I would avoid it. Nothings wrong with != 
So there is no dependencies for end users? Like there might be a team who has access to excel but they might be in a different city. I assume that I would create this excel workbook linked to xlwings and save it somewhere they can access with the fields that they can filter on. They fill in the fields and they pull the data from somewhere... I assume it has to be in the same folder on the network (since they would not have access to my computer directly). Yeah, so I just want some clarification for remote users basically who have 0 knowledge about anything other than opening excel. 
Short answer - yes, pandas could definitely do this. Pandas is great but for this it might be overkill since the standard library has everything we need. If I were to package this and ship it to users there would be no 3rd party dependencies. Which is a plus. 
Makes sense. Yeah I started python with pandas and numpy and only recently started to learn the standard library 
Any experience im working with data? I ask because im using python and pandas everyday but I never used itertools. I have very few list comprehension and no generators. I have a lot of map and apply and loops.
Use whatever you are being paid to use or being required to learn first else learn C first.
PyWeek has always been about "writing from scratch" but using whatever existing *shared and documented* libraries are out there. I have no issues with "in 500 lines" here.
Hello everyone, Recently I, along with my amazing colleagues, won the Google Startup Weekend (St.Cloud) event (it's basically a hackathon). After winning that hackathon I came to the realization that if one of my colleagues hadn't pointed out that this event existed, I would have never known about the event. I began to look at the App app store the following day to find an app that provided a comprehensive list of hackathon events with an attention to detail and great organization. Unfortunately, I couldn't find one. What I found was a pile of apps from different universities and non-profit organizations for their own hackathon events. I needed something with all events from various organizations, and so Hackathons was created. I created Hackathons in order to find local hackathon events around me and to also find events around the globe in the event that I may someday travel to participate in these wonderful events. The Hackathons app currently allows users to search local and global hackathon events, save events to their calendars, find location information, find out whether or not a particular hackathon event is free, and register for events.
Is there much past NLTK for python? 
With my limited experience I agree. C was the first language class I took in community college and I didn't experience any of the problems that people look to Python for beginners for. One year or so later I transferred to a public university and took a 161 level Python class and that was fine as well. Now I'm taking C++, which is one level above Python, and the only trouble people are having in my class are accidentally creating null loops and forgetting semicolons. We're also required to use the Linux shell with terminal-based text editors instead of IDEs. People are adapting pretty well, though I think most people are using pico/nano. Vim/emacs is required for anything above this level.
The end users do need to have python and xlwings installed on their system. The excel sheet needs to be able to find the python program via the runpython command. So, yes you could run all this off the network - I just can't promise what the performance would be like!
That it makes this impossible is the problem. Ultimately I don't care about the details, I just want the thing. Frozen is a meaningful property, as is ordered, as is dict. I want to have arbitrary combinations of these properties and types.
I may try porting this to my Entity System, esper.
first C then Haskell then Python. 
Hi THis is Jupneet
So? Doesn't mean that they cannot ship a working work-around to allow the use of `{}` format strings. I can think of three different ways to handle this that should not affect the original code: 1. When the formatter tries to format a message first try with `%`, if that throws an error fallback to `format`. 2. Include a derived instance of the logger class as the example in the docs demonstrates is possible. 3. Add a keyword argument to all the logging functions with a default of "%", pass this keyword argument along with the message and arguments to the formatter, and have the formatter pick the format method based on this. We already know that one of these would work, and I suspect all three would work. So just pick one, and ship it. Python is like a new car where the radio gets really bad reception, and the dealer says "Oh don't worry about that, 5 minutes with a soldering iron and you will have crystal clear stereo." I don't want to have to look up and copy code from the documentation so that the standard library works as a cohesive whole. It should just be that without any action required on my part.
&gt; I will likely never use an editor that understands the f-strings, because I do everything on the terminal. If vim can understand interpolation in Ruby and Perl, I don't see why it (and other editors) couldn't also understand Python: http://i.imgur.com/Iw1S2Uz.png
Thanks, this is really helpful !!! 
1. They aren't buggy. They support what they support. 2. Adding a keyword is a fairly minor change. The highlighter just has a list of keywords, and you append them to the list. Parsing inside strings, is much more complex. You have to define the parser, and figure out how to have parser bail out/reset when someone writes something that doesn't parse correctly. 3. There is also no real danger to failing to highlight a keyword. The parser will simply reject the line and the program won't run. 4. There will be a delay before these things are available on systems because of packaging and upgrade times. Saying that these are dangerous because they won't be highlighted properly is a real world concern. They won't be highlighted on some developers machines. Those developers will not know that they need to refactor the inside of the string when they refactor the surrounding code. This will lead to actual bugs. The world doesn't revolve around python. The core python developers cannot just make decisions like this and say "well the tooling is buggy" when it causes problems.
Classes are used. Ecs is a different design philosophy in contrast to object oriented. This series is a good introduction: http://t-machine.org/index.php/2007/09/03/entity-systems-are-the-future-of-mmog-development-part-1/ as well as http://gameprogrammingpatterns.com/component.html 
Myself I'd go with Python over Haskell, solely for the employability angle. Tons more python jobs then Haskell out there. If your'e trying to build a foundation of what this whole programming thing is about....go with C/C++. Ive found that years exp in C opens doors regardless of language that you'll actually be working with. If you're just wanting to mess around for fun....do whatever grabs you
Well, my very first programming language was surprisingly Lua. I haven't learned know it so well, but it gave me some understanding of the basic concepts of programming and (surprisingly) encouraged me to learn Python. Speaking about Haskell vs Python, I'd definitely choose Python, because it has many concepts built-in, like conditions, loops, functions, OOP, then modularity etc. Haskell is _exotic_: most popular languages aren't _pure functional_, so chances are you'll have to work with a non-functional language when writing (very) serious projects. 
Thanks. I worry about accessibility, and that seems like a big change in the way you program. I'll give it a read through, and see if I can figure out a good way to make it approachable. Might be worth opening an issue on the general topic.
I downloaded the app. Two issues: 1. I can only see the tips screen, nothing else shows up. Tried to restart the app but still only see the 4 pages of tips. 2. For this type of app I would normally only allow it to use my location while using it, but the only location options are 'Always' and 'Never'. 
&gt; I get the feeling you may be trying to personally attack me, suggesting that I have claimed it is a security risk. no. i was actually complimenting you on your understanding of the feature. the “security risk” guys think they can pass around such a literal without evaluating it and think it will grab the local environment at some other point in the code, which is obviously wrong.
It's tedious, full of gotchas, and obscures the basic concepts by adding unneeded complexity that new developers end up spending time worrying about, instead of worrying about what they should be trying to learn. Everyone should learn C/C++ at some point. But a first programming language should be able teach basic concepts clearly and develop a love for programming. I started with C. I did not love development at first. Nobody in my class did. It sucked. Too much to think about, too much to worry about, too much thrown at us too fast. A lot of people hated it and dropped out before Data Structures. Then my school started with Java with the next freshman class, then moved to using Python for freshman before I graduated. Those students didn't drop out at nearly the same rate and they were not inhibited one bit in senior level courses.
I am going the other way (Python-&gt;PHP) due to my current job. Gaining experience in different languages doing a similar task (building web applications) has been incredibly valuable. Best of luck with your project. It sounds ambitious but a cool set of new technologies to try!
&gt; if they aim to support the newest version of python, the’re buggy as they misrepresent the language. Who has ever said that they do? Vim aims to support text editing. It doesn't aim to support any particular language or version. It aims to be useful. If a language feature is used by many people, and those people use vim, then someone might write a syntax highlighter for that feature, but vim doesn't advertise that it is capable of editing particular file types, and it doesn't refuse to open files just because a syntax highlighter isn't available. "Please upgrade your version of VIM to be able to edit this JSON file."
I find it more accessible than object oriented design, specially when the inheritance tree starts getting several levels deep and mixing is involved.
“they” are syntax highlighters. language definitions of the former, to be precise. they can go out of date with the language they claim to support, at which point they don’t fully support them anymore. atom’s highlighting component supports python 2.0 - python 3.4 ATM (no 3.5 async/await, no 3.6 f-literals) [atom](https://github.com/atom/atom) won’t have an issue filed, but [language-python](https://github.com/atom/language-python) (the [highlights](https://github.com/atom/highlights)-powered language grammar) will
that should really not be a recipe, but built in and advertized as the best way to do it.
More of a focus on not having auto-complete than anything else, at least until the upper levels of CS where it becomes more language independent I think. It's kinda silly, but I am enjoying using vim at the moment.
what? * formatting an inline string that is used in one place only and not translated → f-literals * reuse or translate a string template used for formatting → `str.format` * `logging.*` → `%s` syntax it’s pretty obvious for me, because * f-literals are the best option when you can use it * when not possible, `str.format` uses the same format specification and should be used * `logging` historically used the `%s` syntax so it has to stay the way it is for backwards compatibility sadly the “preferably only one” doesn’t apply, but such is life
I agree it should be built-in. I don't know if it's the best way to do it though, maybe the performance is not the same. For typical light logging, it works just fine.
I would go for Python first for the amount of community support behind it. Also because Haskell requires a huge mental shift to learn as a functional language (which you obviously don't have deal with if its your first language.) This might put you at a disadvantage when OOP languages are king right now.
It took me a second to realize I was on /r/haskell, and I was so confused by the circle-jerking.
&gt; solely for the employability angle I don't know. If you get to grips with Haskell I think you'd find work. If I see a CV with Python on it, I'll tend to think yeah, fine, consign it to "all the other Python coders" pile. If they've Haskell I'll become more curious about them (mainly because it's unusual). I'll probably assume that they can get to grips with Python if needs be, so in my mind it's not a negative. But who knows, I might be miles off in this thinking. 
It is not possible without some kind of messy hack. When you access an attribute, python has no way to know whether you intend to use the resulting value as-is or if you intend to call it to get the real value. The way to really drive this understanding home is to consider what should happen if `obj.fullname` would return a callable; is python supposed to call your `property_method` code or should it call the value itself. There's probably something else you can do other than trying to add an optional keyword argument. Either a method on the value itself that can do the transformation (`obj.fullname.upper()`), or a separate method or property on the object (`obj.fullname_upper`).
wtf? i filed [a bug](http://bugs.python.org/issue26713), let’s hope they come to their senses
The documentation for this Entity System is a good introduction. Basically it's composition based instead of inheritance based design. It makes it easy to keep things uncoupled. http://python-utilities.readthedocs.org/en/latest/ebs.html
Thank you so much, Yes definitely. I am working on idea just to learn the language and trying to use different new technologies, such as Neo4j as DB and Python as backend, as well as Reactjs for frontend. All new to me But that's the way to get knowledge. nd good luck to you with your PHP, there are a lot of contributed stuff out there for PHP. I recommend Symfony Framework, it's modern and components-way framework,I felt Django share some similarity. 
Link to the code, otherwise this is irrelevant to the Python sub IMHO.
There is a windows binary which works wonderfully with cmd.
&gt; I don't particularly care if there are many ways of doing things. I'm not sure why you responded to me, then, because that is all my comment was about. &gt; ... okay, and what is your bluetooth transceiver plugged into? :p Some traces on the motherboard, I guess? I have no USB devices plugged in. &gt; Does your codebase already just mix and match between %s and .format() whenever people feel like it? We mostly stick to %. I haven't seen significant benefits from upgrading yet, and .format() had some issues during the Py2-&gt;Py3 transition. &gt; will likely become significantly less of a problem if your team chooses to adopt the new usage. That's great if you live on a desert island, but I have a couple dozen dependencies installed from PyPI, and *every* non-trivial one I've submitted patches and/or bug reports to. Most of the code I deal with at my job is not managed by my team. &gt; If enough teams choose to adopt the new usage because they find it superior, then EVERYONE's problem lessens. So it's another Py3-style "boil the ocean" solution. Just get everyone to cooperate -- only this time with even fewer incentives to change, because the old ways are sticking around forever. Great. Anyone care to place a bet on how well the plan is going to work this time around?
xkcd to the rescue! [Haskell](http://xkcd.com/1312/) [Python](http://xkcd.com/353/)
So it gives the same functionality as &gt;&gt;&gt; 'Coordinates: {latitude}, {longitude}'.format(latitude='37.24N', longitude='-115.81W') 'Coordinates: 37.24N, -115.81W' But it's more intuitive because you dont have to look to the end of the string to see what the replacement is?
Yeah, every path I started down got into very messy hack territory. The transformation after the fact is not possible - the upper() was just an example, in reality the calculated return value depends on the kwarg. A separate method could work, keep the `obj.fullname` property that would just wrap a new `self.fullname_method(**kwargs)`.
1. Are you sure you send and receive *all* the data? 2. Does send send the data after the \0? To elaborate on the first question: send doesn't always send all data, but it returns the number of bytes sent. I'm not sure whether recv receives as much data as it can, or not. Second question: Seems like it should, but I never tried.
You can use ctypes to simplify this. import ctypes user32 = ctypes.windll.user32 def get_window_title(): hwnd = user32.GetForegroundWindow() title_length = user32.GetWindowTextLengthW(hwnd) title = ctypes.create_unicode_buffer(title_length + 1) user32.GetWindowTextW(hwnd, title, title_length + 1) return title.value print(get_window_title()) 
Android app is coming soon. Need to find a niche to differentiate myself from my competitors online in order to finish the web app. 
The name is youtube-dl, but actually, it has a [huuuuuge list](https://github.com/rg3/youtube-dl/blob/master/docs/supportedsites.md) of sites it supports. It's quite impressive actually. I guess it just started as a youtube downloader and grew to support all these other sites.
Yes. But it also goes deeper. It actually evaluates the *code* found in the brackets. It's not a simple name replacement. If you put a {string_variable}, you'll get the value of that variable. If you put a {function_call()}, you'll get the return value of that function call. If you put a {classinstance.member} you'll get that member. You can even have a {(lambda x: x.lower())('LAMBDA')}. And you'll get all these within the context of wherever the actual string appears in your code, so if they're valid python where you write the string, they'll format properly into the string any time you print/return/send/whatever that string.
I'm quite comfortable with Unicode -- I have a hard copy of the spec in arm's reach right now, and I've written UTF encoders/decoders by hand in a couple different languages. Some parts of Unicode are hard (normalization, collation), but I don't think encoding is one of them. Python just seems to make it more confusing than most other languages. In Python 2, for example, it's not at all intuitive to me when Python will auto-upgrade a `str` to a `unicode`. `print(""+u"\u00f6")` works, and `print("%s"%u"\u00f6")` works, but `print("{}".format(u"\u00f6"))` is an error -- you need to say `print(u"{}".format(u"\u00f6"))`. Maybe I'm just bad at searching the documentation, but I've never found where it says which promotions work and which don't. You just have to try and see -- and then try to memorize the rules you discover. Python 3 is light-years better than Python 2, but still not great. The str/bytes split was a good start. The new IO classes are pretty confusing, though.
It's incredibly fun to learn, just not easy. I enjoy'd learning Haskell more than learning Python in the same way I enjoy'd learning calculus more than learning how to tie my shoes.
You might be right on the money, I'm just going from previous experience, which obviously comes with small sample size alarms. From my search experience over the last few years, I think I can count the amount of haskell jobs on one hand, while I get emails about Python work opportunities daily. This is also in Eastern Canada (Ontario, the maritimes, to a lesser extent Quebec), so that could colour perception as well.
Personally I'd say Haskell, it was an absolute joy to learn, and will teach you some incredibly useful things that you may never naturally come across in a language like Python. It's also much faster than Python, and is very strongly typed, while still managing to be even more concise.
Use an orm for whichever web framework you're working with. And if you *really* don't even want to deal wih db management at all, use stormpath. It has support for a bunch of languages/libraries and handles users and any custom data they might have. 
Awesome! Huge thanks for the tip, I'll refactor that :)
As someone who's used this a lot, the title really doesn't to it justice. * It supports every site I've ever tried it on. Not sure what's the total number, but it's easily in the dozens. * It allows downloading any and all versions of the available video and audio files in any combinations. * It can download subtitles, without the video if necessary. * If memory serves, I believe it also has some rudimentary media convertor functions. That's only the stuff I've personally used. I'm sure there a lot of other stuff in there I have no idea about. The man page only is 3-4 screens long. As for downsides, after an update about a year ago, the default settings kinda suck when downloading from youtube. It tires to download video and audio files separately, then merge them, but fails at the merging step. So I always have to specify the quality I want via an argument. Still an excellent piece of software.
The hardest thing about lambda is that they called it "lambda". Every other language I use has this feature, and people use it all the time (even newbies), and nobody seems to have much trouble with it. It's just that other languages call it "fn" or "function" or use a more visual syntax (little ASCII arrows or whatnot). I consider the "operator" module a wart that's only necessary because Python lambda syntax is so awkward, and there's no syntax for symbols. In Ruby you don't need `operator.add` because you can just say `:+`. In Clojure it's just `+`. Doesn't it seem weird to have an entire module that does nothing but assign names to things the syntax doesn't let you say directly? 
I had no idea. I just use it for scripts that finish at the end of a calculation. Longest I've had was about 20 minutes. I'll keep the fact that it might be numpy in mind if it affects me.
Thanks. Working in CodeIgniter (the horrror!) but the hope is to move to something like Symfony or Laravel in the future. :)
As someone who learned Python years after being scared off by C, I could not agree more with this post.
You can't imagine someone using an f-string, and then needing to put a literal brace in it, and deciding to try writing it as an escape? That is exactly the kind of thing I think a lot of people would try. This reminds me of C trigraphs. Back before compilers started disabling that feature by default, how many newbies tried to print "hello??!" and were shocked that it didn't print "hello??!" on the screen?
Have you written to them to ask to upgrade to a version that was released in like the last 9 years? It's possible they don't realize what a pain point it is for their users.
Yeah. I can't really say. I'm not really interviewing that many people these days, and I'm not looking through CVs much. I tend to think Haskell is this weird case. I guess it's a bit like the case where "If we get chased by a bear, I don't have to outrun the bear, I just need to outrun you." Maybe if you are even an OK Haskeller, you're going to get offers, whereas if you're an OK Pythonista you're going to have to fight for attention, you're going to have to be better than the other guys. I'm very much heading into Supply and Demand land, and vague hand wavy territory. 
That makes sense, thanks. It seems like it's architectured wrong, though, in that things would be fine if it just added its local settings to the tuple it sends up the chain, and those settings included the formatting style. Or it could send a `lambda`. But fair enough.
kinda circular argument there.
No, I am not convinced that will be a very common mistake.
Sorry for the silly question, but I am a complete novice. How exactly would I go about printing tqdm output to a GUI? I have gotten as far as using this in the command line.
It isn't, but excitement is unnecessary if you are trying to educate people at the college level and that is after all the level at which people learn "computer science". No introductory university level engineering, science, or math classes are exciting to everyone. Kids on the other hand should be enticed into wanting to get a job that requires computer science training via other means: maybe show them how games are made, give them some user scripts so they can tweak their favourite websites, etc.
CodeIgniter is really nice actually, I like it because its simple and clean. But yeah is good start, its fast framework and and it let you know what you are doing and writing, without putting to much components and crazy stuff.
Prefer I python would haskell over personally.
Haven't tried this yet. But could be useful for people. https://addons.mozilla.org/en-US/firefox/addon/cliget/ (https://github.com/zaidka/cliget)
Less confusing version a = {} b = 2 a[b] = a &gt;&gt;&gt; a {2: {...}} &gt;&gt;&gt; a[2] {2: {...}}
There are a bunch of different python drivers. The best one to use is pymysql, in my experience it's the best maintained one: pip install pymysql You'll probably find it easier to use pymysql through a higher level library to make it easier to do stuff. In sqlalchemy, you can do basic connections as follows: &gt;&gt;&gt; from sqlalchemy import create_engine &gt;&gt;&gt; e = create_engine('mysql+pymysql:///nameofdatabase') &gt;&gt;&gt; results = e.execute('select * from ...') But sqlalchemy has lots more powerful features and different ways to work with it as well, the docs and some tutorials should see you right.
[Candy](https://candy-chat.github.io/candy/) - javascript client for jabber.
So I think this basically does what you want. There might be a more suitable proxy in [wrapt](https://wrapt.readthedocs.org) somewhere, but I fall back to `ObjectProxy` so often it's second nature. from __future__ import unicode_literals from wrapt import ObjectProxy class Callable(ObjectProxy): def __call__(self, *args, **kwargs): result = self.__wrapped__ if 'upper' in kwargs: result = result.upper() return result class Test(object): __slots__ = ('name',) def __init__(self, name): self.name = name @property def fullname(self): return Callable(self.name) test = Test(name='test') assert test.fullname == 'test' assert isinstance(test.fullname, unicode) is True assert test.fullname(upper=True) == 'TEST' assert test.fullname()[3] == 't' Here's a [gist](https://gist.github.com/kezabelle/43f45edefdcd1377b70eb171d4cffd1e) in case that's useful.
I specifically saw operator module being used to sort based on the last value in a list of list. Nevermind it should have been done by numpy in this case, but it was just ugly.
I remember hearing about psutils having sort of a very similar issue http://grodola.blogspot.com/2013/12/making-module-constants-part-of-your.html shows how they went about it, probably won't kep too much, but might be food for thought. messy hacks are absolutely fine, as long as they are kept seperate from the main code base (like, implement it as a decorator or something), and as long as they are easy to remove (like, implement it as a decorator or something :u)
I use the current version on Linux and it works perfectly, including youtubes. You need to youtube_dl -U and try again.
Can you give me a quick run through of how to get the python version of mysql connector installed on ubuntu? I can't seem to find the steps
The originator and current devs were in this old thread https://news.ycombinator.com/item?id=8647943
I played with Haskell for about a week, after writing Python every day for a decade or so. It wasn't hard to learn, and while I wouldn't recommend it as a first language, it certainly has its place.
Eh, we use Haskell at my work. It has its uses. It's not just theoretical. But Python's definitely a better generalist language to start with.
It's not that simple, what I do is: * Manually `wget` the HTML page. * Search for all links on the page. * Resolve all directory-relative, domain-relative, and protocol-relative URLs into absolute ones. * Filter those according to what looks like the same sequence as the original URL.
Sure can't, never done it, I'm a windows kid. Want me to figure it out for you?
I always use classes for this. Set up several classes, each with their own individual attributes, and set them up to look at other objects' attributes and act accordingly. I'm not sure I entirely understand your question, but let me give you an example. Let's say you have two objects, a horse and an apple. Now the horse will want to eat the apple, but only if it's fresh, not rotten. So you would set up the horse class as: class Horse(object): def __init___(): #Horse stuff And then the apple: class Apple(object): def __init___(): self.fresh = True Now just do a conditional. apple = Apple() horse = Horse() if apple.fresh: horse.eat(apple) apple.die() In this case, the horse get's affected by the apple and the apple get's affected by the horse. The horse may gain health and the apple get's deleted.
for completeness, [jwz](https://www.jwz.org/blog/) also maintains a [youtube downloader](https://www.jwz.org/hacks/youtubedown)
What will be the next string formatting method you will add to the language?
Agreed, a first programming language should focus on teaching people the constructs of logic and control flow in programs. Then they should eventually work with something like C/C++ that introduces them to the intricacies of what a computer is doing.
&gt;many 
Jesus.. that youtubedl class file is quite large. 2k lines
YouTube playlists are supported. 
Is this homework? Look at the subprocess module
No, not at all. This is for research I'm doing, but I'm admittedly not a programmer (astrophysics). 
He left Google because Dropbox let him spend 50% of working time for Python Language development.
Yes. Statically verifiable parametric polymorphism and ad-hoc polymorphism. Laziness / call-by-name semantics. Immutability, referential transparency. Extremely generic code. (functions without type classes at all such as `fix`, `const`, `$` and `.`, as well as functions with really generic restrictions, such as `&lt;$&gt;`, `&lt;*&gt;` and `=&lt;&lt;` working on pretty much anything container-like, as well as functions and even IO.) Partial application / currying `threes = filter ((== 0) . (flip mod 3))`.
Oh cool! I played a bit with Disco a few years ago. I really liked DDFS. If you need any help with Dask folks a fairly responsive in the gitter chat: https://gitter.im/dask/dask
There was a browser wrapper for it that I came across at some point, you'd have to host it with a webserver with PHP capabilities IIRC, easy enough to do. Edit: this looks like it: https://github.com/p1rox/Youtube-dl-WebUI
If wds015.dat contains a line with my string in it, more will generate lines in the Linux terminal. If I could, say, count those lines, I could say that lines &gt; 0 is a match, lines = 0 is no match. This would tell me whether or not that string is contained in the file. I'll also note that it has to go through wds000-wds240, in intervals of 5, so there are 48 different files it will check. If there is a better way of doing this, I'm open to it, but the only way I've figured so far is to count the lines produced in the terminal with the "more" command.
C is a good first language if and only if you already know the data structures. 
hmm, which python?
It's even able to somehow download region restricted Comedy Central videos outside of USA
They've used literals, they've used classes, they've used methods, they've used operators. They've used C-style %, and they've used Perl-style {}, with and without names. Clearly, next on the list will be the with-statement, with Lisp-style ~ interpolation. with fmt("~A, ~A") as out: out.params = ["hello", "world!"] 
grep -c -f STRINGS_LIST_FILE wds???.dat 
You dont really need python, you could just grep with a pattern file. If you're on Windows, download mobaxterm or cygwin. It will be worth your while in the long term..
Looks like an interesting project, but I think you're asking for trouble by using fallout shelter in the name, which is trademarked, unless of course you've gotten permission. How about "Sim Nuclear Silo" or "Nuclear Bunker Story"? The official website say, "Fallout® Shelter" so you might be okay still using the word "shelter". I'd also not say it is "a text-based version" of the other game. Both your title and that description make it sound official as if it is just another version that Bethesda has decided to release which is exactly what trademark laws are aimed at preventing. You should probably just keep it to "A text-based game inspired by Bethesda Fallout Shelter", "tribute to", "based on", "parody of", or something along those lines.
+1 for object-oriented blocks. Great idea. I hope the intention for this repo is to move to Python3?
Agreed. Then again, OP is an astronomer and, as an astronomer myself, I can guarantee he/she will have to learn Python anyway. So I guess we can try to help with both Python and shell.
You could try something like this. You open one file for reading and the other for writing. `pattern in line` does a simple string match. patterns = '12482-2958', '02274+2482', '23381-3857' with open('wds015.dat', 'r') as inputfile, open('matches.log', 'w') as outputfile: for line in inputfile: for pattern in patterns: if pattern in line: outputfile.write(line) It's not clear from your question exactly what output you want. It might be even simpler to use a simple grep command If your list of patterns to match is in a file called `patterns` (one pattern per line), this will search all .dat files for any line containing one of the patterns, and output filename, line number and the matching line to stdout. grep -Hnf patterns *.dat
OK. I think that you want to "count the occurrences of a string in a file". In quick-and-dirty Python, with as little "weird" syntax as possible, you could write filename = "wd234whatever" to_find = "1234+4567" f = open(filename) lines = f.readlines() f.close() my_counter = 0 for line in lines: if line == to_find: my_counter = my_counter + 1 print(my_counter) This is not pretty idiomatic Python because it doesn't use anything fancy; it could fit in two short lines but I tried to keep it as simple as possible. Does that make sense to you? Would that solve your problem? It's possible I misunderstood.
What format does it download the subs as?
A while ago I made this if anyone finds it useful, it has some issues with windows that i haven't had time to work on but the new bash update might allow it to work fine. https://github.com/dszopa/youtube-song-downloader
As beneficial as learning functional programming may be, I would strongly hesitate to recommend Haskell as a first language: - It's very unforgiving. When you make a mistake in Haskell, it's more likely to result in a compiler error that a complete novice to programming would have a hard time deciphering. In Python, it's more likely to run but produce wrong results, which gives you a chance to see for yourself what you did wrong. (Haskell's strictness is excellent for helping experienced programmers produce reliable code, but it's just going to be frustrating for a complete newbie.) - Even when things do work in Haskell, it's sometimes not obvious why or how it works. - Haskell is great for learning algorithms, but it's hard to progress beyond simple examples into real-world projects — anything involving IO becomes ugly. - Haskell culture encourages the use of indecipherably short variable names. It encourages the use of extremely abstract functions (Applicative, Lenses, etc.) in search of "elegance". I get the sense that it's a quest to reinvent APL. Python emphasizes readability. - While immutability is a useful way to improve code, sometimes it just isn't appropriate to require it everywhere the way Haskell does. - Python is an excellent language for learners. It has a reputation for being "executable pseudocode". [OLPC](https://en.wikipedia.org/wiki/Sugar_%28software%29) chose it. There's [turtle](https://docs.python.org/3/library/turtle.html). At the same time, it's also used for [serious computing](https://www.scipy.org). If forced to pick only between Haskell and Python as a first language, I would clearly recommend Python. I'm not saying this just because we are in /r/Python. That said, if you are interested in functional programming, I highly recommend [_Structure and Interpretation of Computer Programs_](https://mitpress.mit.edu/sicp/) (in Scheme). It teaches functional programming and higher-order thinking without being dogmatic about it. You can then apply those FP ideas to Python (but keeping in mind that there's a limit to how much functional programming you can do in Python while still staying idiomatic).
Switch to a rolling release distro.
Release based distros generally don't update packages between releases of the distro except to fix security and other major bugs, and even then they generally only release a patch for the current version rather than a new version. This is to make sure only versions of packages that have been tested to work well together are used. An update can break other packages that depend on the package. Python 3.5, for example, broke a bunch of important packages and 3.5.1 broke at least one other. So the more important the package, the less likely it is to be updated and the more difficult it is to update it yourself without breaking things. Python is one of the most important packages on Linux, so updating your system python is not a trivial matter to say the least. This isn't an issue on Windows because windows doesn't have a system python, not to mention use it for critical operations. MacOsX, on the other hand, does.
¿You really think that pypy is te future?
What an oddly phrased question. If you want to be a professor of computer science, learn Haskell first. If you want to be a pointy-haired manager, learn Python first. If you actually want to understand how computers work, rather than being a clueless academic or a clueless user, then perhaps you should start with something a bit more fundamental. And if you just want to get a high-paying job, might I suggest banking or finance?
This is true.
You can download them using youtube-dl --all-subs --skip-download YTLINK And the format will be a .vtt. You can change the format by using --sub-format FORMAT So to download the subs in srt you may just do youtube-dl --all-subs --skip-download --sub-format srt YTLINK Easy as that! You can find more options with youtube-dl -h, relevant part is: Subtitle Options: --write-sub Write subtitle file --write-auto-sub Write automatically generated subtitle file (YouTube only) --all-subs Download all the available subtitles of the video --list-subs List all available subtitles for the video --sub-format FORMAT Subtitle format, accepts formats preference, for example: "srt" or "ass/srt/best" --sub-lang LANGS Languages of the subtitles to download (optional) separated by commas, use --list-subs for available language tags 
shit.
&gt; Now I'm taking C++ Universities tend to teach C++ as if it were much more like C than it actually is. "Real" C++ tends to be a lot more complex than C-with-classes. Here's a quick litmus test: how frequently do you use raw pointers?
I noticed you don't handle decoratoring descriptors. [Maybe this can help out](https://github.com/justanr/objtoolz/blob/master/objtoolz/descriptors/undescriptor.py)
You're not a Python programmer so you wouldn't understand. Talking about Python like it is "for small scripts", "for getting things done quickly", "not for serious projects" That's the second most upboated comment. Also, note how I didn't actually say anything bad about Haskell itself... I didn't even say anything about Haskell programmers in general. My comment was about the people in that thread who clearly (by their comments) do not know modern day Python. So you can throw your nonsense accusation of "disparaging comments" into the trash.
GUI is a different beast to a terminal. I honestly could not tell you, you might want to engage with the author of tqdm to see how they might integrate their code into Qt or Tkinter
Speaking of which... Guido has found himself once again working for a company that is trying to make another implementation of Python, where as he himself is not working on said implementation. 
&gt; guaranteed purity / immutability. What's the difference between "guaranteed purity / immutability" and what Python has, if not static verification? It's entirely possible to make an immutable Python object, you just don't get static errors if someone explicitly breaks the privacy contract. Saying that you can't implement `apply` or whatnot is just wrong. It's true Python programs don't provide it by default, but that's just because they transform collections in a different way (which has its upsides and downsides). The argument that this has to be supported through methods is somewhat true, but it's not really (you just use free functions with type dispatch). Anyway, that's more saying "typeclasses are cool", which wasn't in your feature list either. Mentioning speed now is unfair, since I never argued against it. It's not on your original list.
Fair. FWIW, the litmus test would test *negative* with what people call "modern C++"; you're meant to use wrappers like `std::unique_ptr` instead. And there's nothing wrong with teaching C-with-classes as it's a nice way to teach some reasonably low level concepts while allowing some standard abstractions.
it doesn't forbid it, just requires a different approach (ast transformation)
Haskell is a very niche sort of thing... my understanding is that it's great for threaded applications (which is where we use it). Python is a lot more similar to the majority of commonly used languages (like Java), and thus is a better generalist language. I wouldn't ever bust out a random script in Haskell, but I do that in Python on a semi regular basis.
So I can't add to my original list when I come up with more ways that Haskell is better? That seems unfair in itself. You can't practical have apply / fmap etc. work for every Python class you use, as you would have to monkey patch / create a type dispatch for EVERY SINGLE CLASS IN EVERY SINGLE LIBRARY THAT YOU USE. But yeah typeclasses are really cool. Also for immutability static verification is massive, if you wanted to implement something using only immutables you are basically fucked unless you can do it without any external libraries, as all those libraries probably have half their design based around mutability, to the point where it is just completely impractical.
Just to explicitly state it, it is equal to 1 modulo 5 because we have `x*1082525 + 97531=x*0 + 97531=97531=1 (mod 5)`.
The only link between that comment and Python is the sub it was posted in. It read solely as anti-Haskell sarcasm.
&gt; So I can't add to my original list when I come up with more ways that Haskell is better? You can, you just aren't allowed to claim that I was commenting on those points. Though I don't get what "Haskell is better" has to do with this; I'm arguing neither for nor against that. &gt; You can't practical have apply / fmap etc. work for every Python class you use, as you would have to monkey patch / create a type dispatch for EVERY SINGLE CLASS IN EVERY SINGLE LIBRARY THAT YOU USE. So? The same would be true for using Haskell had it not a built-in `Monad` class. It's not like Python doesn't have abstractions over collection types; it just divides them a different (more Rust-like) way to Haskell. For example, `map` works on `dict`s, `list`s, `tuple`s, `numpy.ndarray`s, `OrderedDict`s, etc. &gt; Also for immutability static verification is massive I never said it wasn't. &gt; if you wanted to implement something using only immutables You said *Haskell has imutable things*, not *Haskell avoids mutable things*. I said Python has the former, not the later.
Not sure how generically you want to make this, but for something I recently did at work Python 3.5 added the [Subprocess.run](https://docs.python.org/3/library/subprocess.html#subprocess.run) command that made it much better than previous. But you're sacrificing backwards compatibility.
That's really useful, thank you!
Cool. Does AT&amp;T still do stuff like that these days? I actually handle some AT&amp;T business but it is entirely consumer side (billing, sales, tech support, chat, etc). 
You may want to look at a package I created: [Propel](https://github.com/mardix/Propel). Propel allows you deploy multiple Python sites/applications (Flask, Django) by isolating each app into its own virtualenv, using Virtualenvwrapper, then puts it online using Gunicon+Gevent under Supervisor, to make sure it's always up. Then uses NGinx as proxy to access the sites. 
Thanks a lot for the advice! I definitely think expanding this tool to Linux and OS X will make it much more useful. I'll play around with some of the commands you mentioned and try integrating them into the script :)
What is "soon" ? Python 3.5 has been out for quite a while now...
Does it really make a difference? It's on github. Releases could be a single binary for all the matter it makes.
Thanks! I joined Gitter and bookmarked the Dask chat. I'm sure I'll be humbly begging for help soon :).
"Will you have coffee with me?"
Well alright it seems like you aren't actually arguing much, so sure I guess I concede that you aren't wrong about the very little you are actually arguing. I still think Haskell is an all around better language in pretty much every way not to do with popularity. Which admittedly is a pretty big deal.
Yeah that's an idea. I'm not planning on making any money or publicity on the project. It is just a technical exercise to help me learn game development. But had I may change the name.
I mean that the main game is an object and the rooms,people and items are all defined as objects within that object. There are many functions that take game as an input and return it, and yeah, now that I'm thinking about them, it maybe better to move them into the game class. It shouldn't be too hard. Just move the code, replace Game With Self And fix the calls. 
Yep. 3.5 only, so we can take advantage of async for networking.
Speaking of Dropbox, how successful is it relative to the other cloud storage services? Personally it seems the wors t since you only get 2.25GB free but I'm guessing they have corporate appeal?
init or systemd, either way. I have never hosted flask or django myself, but I heard about this thing called circus for those apps?
Hold up, so you're concerned about your experience of circlejerking here in /r/python, and also in the haskell thread? It's reddit (or, it's a platform that large volumes of human beings use), it's a popular programming language... 2 + 2 = circlejerking Still, the fact is that the people in that thread are circulating common myths about Python that have been dismissed for at least 10 years. Hence my comment.
I remember Condoleeza Rice coming on board at some point, and i said goodbye to it forever. BitTorrent sync is where it's at.
Shiggles.
You could make that work today without a language change. `fmt` would return a object containing the format string, which you then attach the parameters to. The `__exit__` method of the object would then combine the two. Small matter of getting the return value out before it gets destroyed, but I'm sure there's some nasty nasty way it could be done ;-)
What do you want for chrismas ?
I use YouTube-dl with clipboard manager copyq. I can run command to download video or mp3
Yeah, [circus](https://circus.readthedocs.org/en/latest/) is good. It's to monitor the processes and ensure they stay alive.
I just want a printf.
Hey, how you doin?
Fantastic! Is your research with distributed systems within the context of resource managers ? I ask because YARN may just be a distraction -- you can work directly with Dask
That's not a question, that's a non sequitor with a question mark dumped on the end. Would you like to explain what on earth you're talking about?
Careful, that sounds like a [God Object] (https://en.m.wikipedia.org/wiki/God_object). If you're going down that path you probably want to use the game object to compose a few other objects (really you have a game loop and then a few different handlers you need to use). [Here's](http://learnpythonthehardway.org/book/ex44.html) the first relevant to python link I found on Composition vs Inheritance for you.
Awesome question!
Thanks, have you used this at all? Any good?
Thanks, I stumbled across this one earlier. Do you rate it or are there any gotchas/limitations that I should be aware of?
Don't you remember? He gave you the keys in 2023, and you will return them to him in 1997. 
Do you have an actual question, or are you just sharing?
I have been giving a hard look at Cartridge, which is part of the Mezzanine framework. I'm interested in some custom flows, and will take a look at the others mentioned here as well. My first reaction to Cartridge was that it was a solid framework, but not yet developed enough to mature processes defined. I will look at these others to see if they can speed up the curve a bit.
Yes, I agree that lack of money or publicity makes it fair use, though I am not a lawyer. But the fair use you're talking about is copyright fair use. Trademark fair use is very different and doesn't have nearly as many protections. You should still pursue your project, but just be careful with how you name it and represent it.
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, we are sure you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Golden mean fallacy. Part of Haskell's charm is what it lacks, not what it has.
&gt; I'd argue that Lisp (or better yet, Clojure) would be a much better language to learn first than assembly. Wow, you praise Lisp so highly. (Also, Clojure ⊆ Lisp)
Fallacy fallacy. I can do that too. Honestly, I found Haskell a chore to work with, not because I found it lacking but because doing anything non trivial requires deciphering academic documentation. 
What is the answer to the best question nobody has ever asked you?
Will we ever have a good enough python sandbox to replace javascript on the web?
It's good for typical browse product, add to cart and check out model. If your catalogue model and checkout process is very different from the typical flow, it could be quite a pain to customize it. Then it would perhaps be better to use a loosely coupled bundle of your own product/checkout apps together with other packages like django-cart, django-simple-rating, django-paypal. That being said, I basically learnt django by using django-oscar :)
Ah, okay. Sorry!
Awesome, thanks. I think that the simple checkout flow applies to my wife's idea, so django-oscar might be a good solution.
Just shove it into globals. I've never heard of any negative consequences arising from that!
You can for debugging purposes (if you use GHC), just not production code.
It some ways, it is better than drive. I don't understand why people keep comparing how good it is, by how much storage space we get for free. By that logic, mega.nz is the best solution, since it gives 50GB free! Features Dropbox has, which Drive is missing: 1. LAN Sync 2. Linux Client 3. Dropbox takes your files as is i. Doesn't try and convert them to a different format. ii. Drive has corrupted many .dwg, .dxf, .prj files
Thanks, this one looks really good.
Is this a fork of Satchmo? Because goddamn, I used Satchmo for a project a few years ago and it was an absolute nightmare.
What backwards-incompatible changes would you make to the language if you didn't have to worry about, well, backwards-incompatibility? If you were to implement a new systems programming language (e.g. Rust) how much would it look like Python? What would be different?
Dropbox also has selective sync for subfolders by default, which I find incredibly useful. With Drive you can only do this with parent folders, which is terrible. Oddly enough the third party Drive client I use for Linux lets you selectively sync subfolders, so I'm not sure why Google hasn't added that to the official client.
I see. I've never heard of meganz, what's so bad about it? And for me and probably most general users, we just want to back up our stuff, so that's why GBs are the most important for me, of course after security and reliability.
OpenERP (now called Odoo) introduced ecommerce features not long ago. https://www.odoo.com/page/e-commerce
I actually solved it by just uninstalling and reinstalling pyinstaller. I had the latest version, but something was missed up during the pip install and was making it fail when making the exe. I realized it when I finally figured out how to look at the traceback, and saw the problem was not in my code. But thank you for all of this info as well!!! I am still pretty new at python so I appreciate it. 
CSV is obviously slow, what's the surprise? Compare to HDF (for exchange with other software) or pickle (if it's internal). It seems the official source code for Feather doesn't build with Visual Studio, or I would have run that benchmark and reported the results.
Can you easily append or overwrite files? I receive daily csv files which are messy. I clean them with pandas and output daily.csv.bz2 files. I then read these compressed files (post cleaned with the columns I need) for analysis, to store in a database, and for the basis of tableau dashboards. These intermediate compressed files are only used by me personally. I guess they serve as an archive and if I need to go back and add a column or something it's easier (quicker) to read in a hundreds of days worth of bz2 compared to normal csv. Can I replace these with something like feather? 
TIL some people don't know how to use enumerate
Sure. You just need to make sure that your computer starts your program on startup.
OTP != Open Telecom Platform (Erlang) OTP = One Time Password article = a snippet with Flask
Good to know it's possible! How many hours do you think it would take me to learn Python to this level of complexity? I have some basic coding background. Have dabbled with Python, but stopped for lack of projects to chase.
On a mac: http://superuser.com/questions/229773/run-command-on-startup-login-mac-os-x You should be able to find similar guides for other OS's.
This question would probably be better suited for stack overflow.
It's not really possible for me to answer that question. My suggestion: instead of worrying about how hard it'll be or how long it will take you, just go do it. *Ever tried. Ever failed. No matter. Try again. Fail again. Fail better.* -Samuel Beckett
I'd be curious to hear from someone that has used both dg and https://github.com/i2y/mochi. Mochi has pattern matching, which is a big advantage.
Not right now, I'm still working on it and making improvements every day! I'll release it eventually when I've optimized it, packed it with features and cleaned up the code to be PEP8 compliant. I also want to try my hand at making an ascii rpg game with it to really push the limits of the engine. If you want to see the progress I've made this week, Look at the last few videos on my channel. There's a library similar to the one I've made called Pygcurse but that library was too slow for anything more than simple GUIs, So I made my own version specifically to work for high refresh rate games.
You can use nohup instead, Uwsgi had documentation on how to run Flask on Ubuntu via systemd why not use that instead?
/r/erlang is that way, /u/dzecniv
And the sky is blue.... Q) how do I make my analysis pipeline faster A) stop using csv Me, every second day
No worries. It's important to remember that learning takes time, and it's one of the best investments you can make. I recommend hanging out in /r/learnpython if you have questions about doing specific things with Python.
python has .format() which allows you do do basically the equivalent. - https://docs.python.org/3/library/string.html#format-string-syntax
MVC as a design pattern has been interesting to watch evolve. I've worked with people who insist on super lean controllers with almost the bulk of the logic in the model, others who believe complexity should be in the controller. Even more there have people who insisted on pushing everything into the view itself in PHP style or stuff like ExtJS which is a MVC structure at the view level. &gt;Views are the entire HTTP response, Yeah, I've worked with frameworks like Pylons, Flask, and even a bit of Django that I only really think about the headers when dealing with caching/content-types. Definitely important to take those into consideration. That all aside, I always try to ask this for my own curiousity"ORM or domain models? Do you have a preference?"
You can use the [`datetime`](https://docs.python.org/3/library/datetime.html) module to manipulate dates and times. Call `datetime.date.today()` to get a date object representing today, then use the `weekday()` method to get the day of the week (0=Monday, 6=Sunday). For opening up webpages, you can use the [`webbrowser`](https://docs.python.org/3/library/webbrowser.html) module. 
A domain model is just a visual representation of the problem that your software solves. Nothing to do with databases. As for ORMs, I like SQLAlchemy quite a bit. I think they're a useful tool, but not so much that you should lean on them without any understanding of SQL or the implications of using an ORM.
Don't know you but I think everyone runs into this eventually, all time favorite abuse of ORM's has been when I would take on a new client's software to find a spot where the past developer(s) would load almost the entire data set into memory, filter it programmatically, and then return at worst one record. Plus side was looking like a genius when that was replaced by either a stored procedure, a more specific query, or a quick bandaid fix like a materialized view (eg in context of say SQL, a trigger based sub-table with pre-computed data).
Gross. I've definitely seen that. 
You'll get a lot more help on /r/learnpython especially if you post what OS you're on and what you're having problems with. 
Some tips from my brief glance at the game: ###Human.py Specify errors in the except statement. For example that except statement in the `__init__` function looks like you're looking for an `AttributeError` Stuff like self.hunger -= amount if self.hunger &lt; 0: self.hunger = 0 would look prettier IMO as `self.hunger = max(self.hunger - amount, 0)` `if isinstance(self, Player)` is a really weird way of doing things. Since `Player` is a subclass of `Human` why not just do something like class Player(Human): ... def level_up(self): super().level_up() # paste the stuff from the if statement here And then do the same thing for `NPC`'s `level_up` and for `die` method. It looks like the reason you did the `isinstance` thing is because `level_up` creates the variable `choice_dict` which would make it impossible to just copy over the code as-is. You might consider making a method that creates and returns a choice dict, making it so you can use the choice dict wherever you want. You can even move some of the code like for perk in perks: choice_dict[perk] = self.stats[perk] into that choice dict method. I don't really know what all you need `self.stats` and `choice_dict` for so you may need to adopt this suggestion a bit. The Human class seems overly long and complex. I don't have any real suggestions for that though. ### general_funcs.py `input_int` again uses `except:`. When parsing an `int` fails, you'll get a `ValueError`, check for that. You can also replace the `break` and the `return x` by simply doing `return int(input(s))`. `return` will break out of the loop for you if there are no errors evaluating the statement. For `default_input`, why bother extracting answers from your text? Seems like it would be way easier just to have a function like def default_input(question, answers): """ The first UPPERCASE answer in answers is the default """ default = next(filter(str.isupper, answers), "") answer = input("{question} ({answers}): ".format( question=question, answers="/".join(answers) )).strip() or default # personally I'd raise an exception if this fails, but I'm trying to make the function as close as possible to yours if answer.lower() in map(str.lower, answers): return answer `validate_input` can be reduced to `return text` unless you are dealing with some really weird type in which case you should reduce it to `return len(text) &gt; 0` (but you probably aren't dealing with weird types given that the argument is called text) Same thing with `validate_name`. If you do if something: return True return False you can usually replace it with `return something`. Occasionally you might want to replace it with `return bool(something)`, but it's just a little silly to do an if statement For `print_line`, why not have constants like `FAST = 0.1`, `SLOW = 0.8`, and `NORMAL = 0.4` and change the signature to def print_line(*messages, end="\n", speed=FAST): then you can do `sleep(speed)`. Not only have you shortened the function but you can pass whatever speed you want (well actually speed is a delay, so maybe my choice of names is bad but it matches with the original function better) If you find this useful I might look at some more files, but this got way longer than I intended, so I'm going to stop for now.
I've seen some discussion about it but it's not something I've tried myself. I'd ask on the kivy mailing list and/or irc if you haven't already, as the people most likely to have tried it are probably more likely to see the question there than on reddit.
There's nothing 'bad' about Mega. Mega was started by Kim Dotcom, after MegaVideo/MegaUpload was raided and shutdown. However... &gt; I'm not involved in Mega anymore. Neither in a managing nor in a shareholder capacity. The company has suffered from a hostile takeover by a Chinese investor who is wanted in China for fraud. He used a number of straw-men and businesses to accumulate more and more Mega shares. Recently his shares have been seized by the NZ government. Which means the NZ government is in control. In addition Hollywood has seized all the Megashares in the family trust that was setup for my children. As a result of this and a number of other confidential issues I don't trust Mega anymore. I don't think your data is safe on Mega anymore. But my non-compete clause is running out at the end of the year and I will create a Mega competitor that is completely open source and non-profit, similar to the Wikipedia model. I want to give everyone free, unlimited and encrypted cloud storage with the help of donations from the community to keep things going.
alright, thanks.
I haven't tried it myself yet, but [Plumbum](https://plumbum.readthedocs.org/en/latest/) looks neat. The other one I couldn't remember earlier is [sh](https://amoffat.github.io/sh/).
Me too. I'll tell you in a few months :p Dg has a nice `if` syntax though, maybe it can fill the gap of pattern matching (can't say myself). But look: https://github.com/pyos/yoboard/blob/master/viewserver/markup.dg Look how he chains the `if` ( `=&gt;` is 'then'). Also dg has a shortcut to check for type equality, `::`. I find this dg code highly concise and readable. Wow !
So is pyston nowadays from what I've gathered. 
dg is even greatier than I thought. I didn't see in the doc at first that it has the pipe operator (`|&gt;`), and that (it seems) functions are curried and lambdas accept a short form. Example: list $ sorted $ map (10 * ) $ (3, 1,2) # (10, 20, 30) pipe example: requests.get url |&gt;.text |&gt; json.loads is short for json.loads(request.get(url).text)
Why do you hate lambdas so much?
Huh, what a strange thing to say.
For starters, all type information is lost. Storing strings in CSVs doesn't really work (e.g. how do you differentiate between "NULL", null, ''). A lot of times people using other languages (like matlab) will only write the data to csv, and omit headers, etc. Size on disk for CSV representation is large too, so it takes a lot of processing power and IO to read+parse while reading it back.
so... JSON? I heard it is web-scale (joke)
Also, obviously white people are genetically predisposed to enjoy enjoy and succeed at programming more. Of course! \s
I've never seen Pyston claim to be a "branch" of CPython. I've always heard it described as a new implementation. For example, that's how Dropbox described it in the initial announcement: &gt;Hello everyone, I’m very excited to announce Pyston, a new open-source implementation of Python, currently under development at Dropbox. https://blogs.dropbox.com/tech/2014/04/introducing-pyston-an-upcoming-jit-based-python-implementation/ I don't know much about Pyston, but I did make a quick look over the current git tree. It does look to reuse some parts of CPython, like the parser and modules ( https://github.com/dropbox/pyston/tree/master/from_cpython ). But the rest of the runtime is a clean-sheet rewrite in another language (C++, not C). Its engine and runtime environment are very different from CPython's: tracing GC, no reference counting, and of course the LLVM-based JIT. It seems to have its own implementations of many Python objects, though they also include the CPython versions in the source tree for some reason. Unladen Swallow added an LLVM-based bytecode JIT to CPython, but *everything* else was the same. Their goal with the project was to get it merged back into CPython trunk--and indeed there was a PEP calling for that at one point. I sincerely doubt Pyston has any such goal.
Django does many things... As the other commenters here have noted, it may be easier to start with understanding the basic features of a web framework given by something lean by Flask, and then supplementing that with knowledge of the extra features Django provides. Some things Flask (or one of its libraries) provides: - Escaping HTML to prevent XSS attacks - Routing (matching URL's with logic) - Providing a consistent model for accessing requests and providing responses Some of the things Django can provide on top of this (if you're using the features): - An opinionated SQL database layer sufficient for CRUD (creating, reading, updating, and deleting otherwise largely static data) applications with automatic translation of Python objects to database entities and data entry/modification forms - An administrative suite for rapidly prototyping forms for modifying database objects, if the SQL database layer is being used - Protection from CSRF attacks if the aforementioned forms utilities are used - A robust and extensible user management and login, authentication, and authorization/permissions system for ensuring that access is maintained and controlled (generally meant to be used with the SQL system) You'll find that the conventional wisdom is that Django provides a lot of goodies if you can use it with all the features it provides and not have any complex modification needs. 
Wow, thanks for this. I didn't think anyone would understand me but here this is! Wow, really man thanks.
As a heads up, there was something weird with wrapping around `staticmethod` in Python 2.7. It has to do with the `is not` in `undescript` and how methods are resolved in Python 2 (namely they're bound/unbound method type vs Python 3's function/method types). But other than that it seemed to work like a charm. 
Cool analysis! You could have got a little more in depth if you used version control as well ;)
A naive implementation would be built as a wrapper around the system's existing C time interfaces (cf [`&lt;time.h&gt;`](http://pubs.opengroup.org/onlinepubs/009695399/basedefs/time.h.html).) Those functions use a `struct tm` that represents the year field as the number of years since 1900, making it impossible to represent dates older than that. You can blame this on the ancient legacy of C dating back to the 70s and 80s. Apparently somebody rewrote the module in 3.x to not rely on the C standard library and to have a separate implementation so as not to carry that baggage. 
Look up projects on github with open bugs and fix them
I know scipy has a sparse lining module, [scipy.sparse](http://docs.scipy.org/doc/scipy/reference/sparse.html)
I literally laughed out loud, thank you.
I was using iOS 9.2.1. On the last page the button didn't show up. Anyway good luck! I'll check the app out again a bit later.
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, we are sure you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Because if OP wanted to post this (pretty standard) piece of information otherwise, he may have had to make it a self posts which doesn't get an karma
Though a bit different from HDF5, Solr also allows large csv inserts as well.
Why in all heck would you want to make this depend on a 'random number generating' website to be functioning? from random import SystemRandom charset = '01234556789' random = SystemRandom() passcode = ''.join(random.choice(charset) for _ in range(6)) And deleting items from a list you're iterating over is a bad practice in general.
Go through the [Django Tutorial](https://www.djangoproject.com/start/)
Hi there, this post being removed as it is not directly related to the Python programming language. It might be more topical on /r/programming, /r/coding, or /r/technology. Cheers, /r/Python mods
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, we are sure you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
My (non-PhD) thesis is in a git repo, with the headless remote/origin in Dropbox. (I should be writing right now)
This is awesome. As someone about to start my Ph.D in a lab science, this is pretty interesting to me. Would love to try it out.
Any good guides on how to set this up? I've been using LaTeX for a while, but am a complete noob at Git.
Yes, this is more or less the textbook method of refactoring a program to make it more modular and easier to maintain. I can't definitively say that the specific way you've chosen to organise your code is the best way to do it without actually seeing your code, obviously, but from what it sounds like you're not far off from the mark. Reducing copy/pasted code, lifting functions out into re-usable modules, centralising configurations so that they're specified once and only once, calling functions to operate on your data instead of hardcoding your business rules, that's all *exactly* what you should be doing. The next step for you is to figure out whether `rules.py` should contain *all* of your functions, or if you can further break it down to make it easier to work with in the future. For example, you might want to make a `dates.py` file that contains all your helper functions for managing dates and timezones. Parsing them, converting them, etc. This way if you want to start a separate but related project you can import just `dates.py` and get the same date management functions in your other project, without also importing the code for exporting files for example. And for me personally I find it easier to work with modules when they contain one set of logically related functions, and aren't as long. Even if it ends up being just 50-100 lines. If I am working with dates I don't want to scroll past file export functions, dataframe concatenation stuff, etc.
Automate your home: https://home-assistant.io/
You just discovered the DRY principle (Don't Repeat Yourself), or, the name I prefer, the Single Source of Truth. The idea behind both is to avoid redundancy, that is, if you have anything in your code that is used more than once, don't write it twice, instead write it once and refer to it twice. In short, yes, this is a very good idea, please keep doing it.
I don't that would let you do the sort of hourly analysis the author did, since you'd be limited to the changes you actually committed. 
Rather than sending an email, using a telegram api is so easy that telegram could be the new email. I have a bot on telegram that sends me a message daily that tells me the status of latest backup, temperature forecast and the IP address of my server in case dns malfunctions
Cool I'll do that. Makes perfect sense. All of the tutorials I viewed when learning pandas were more straightforward.. You read a file, did stuff to that specific data, then you were done. I didn't have exposure to kind of reusing stuff but it comes naturally after a while. Pretty exciting. 
I'd suggest using Bitbucket since it let's one have a private repo to keep the thesis. Unless one has a github private account.
This isn't funny.
Is this still up to date?
I, too, can highly recommend using latex and git together. However, due to the workings of git, you might want to change some of your tex behaviours ever so slightly. The most important thing is to &gt; write each sentence on a separate line. Git was written to version control source code, where each line is distinct and has a specific purpose. [This Stackoverflow answer ](http://stackoverflow.com/questions/6188780/git-latex-workflow) is very much worth a read! Also, [the (official?) git tutorial](https://git-scm.com/book/en/v2) is very well written! 
I did a similar thing when I was writing my Masters. I tracked page count based on the generated PDF, and wrote a small python script that would compare that to the planned page count and the due date. I even had a small notification bar widget to show me that difference as a value to keep me motivated. It had a laughing smiley when I was on track, a sad smiley otherwise. In hindsight, I think doing it was just a form of procrastination. 
You don't have to write every sentence on one line if you use `git diff --color-words` instead. But the diffs on Github/Bitbucket will look shitty of course :/
I just did something similar a few days ago, I wrote a python script that can classify my music and movies based on its genre, artists, imdb rating, etc. Python is beautiful. Anything else I could add that you might recommend would be helpful. 
Of course you don't have to, it just makes merging easier since merge conflicts are not as likely, and the `git diff`s are more comprehensible, as you pointed out :)
No we named it to be the exact opposite of Satchmo. Satchless: less is mo' ;)
Yell if you need any help, I am the maintainer.
Yep, we are. It's just a fact.
Sure, that was the initial announcement. But then things changed: http://www.slideshare.net/KevinModzelewski/pyston-talk-111015 slide 14. 
I'd try the usual. Restart the IDE, then the PC. Uninstall it and put in a fresh version. Try downgrading to an older version and see if it goes away or upgrade to beta if ones available. You should also log a bug, they get onto them pretty quickly in my experience. 
Outline the problem you are trying to solve.
But it doesn't use the GPU AFAIK.
After a lot of googling I've come to the conclusion that my best bet is cuSPARSE, but I'll have to use Julia for that. For now, just to test my method, I'm going to use pyViennaCL which does what I want but is slower than cuSPARSE.