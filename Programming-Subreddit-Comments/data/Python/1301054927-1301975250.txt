First, wouldn't this eat any actual assertions that come from the calling code? That seems like a deal-breaker right there, if your replacement for an "if" statement has to make assumptions about the implementation of its conditions. Plus, slow and dumb. Code is supposed to communicate to both the machine and the reader, and this technique is misinforming everyone. Python isn't fast, but throwing exceptions instead of branching is adding insult to injury.
Using assoc and ftype to register a new extension such as py25 to run Python 2.5 isn't very hard, but adjusting the system PATHEXT variable to make .py25 files executable in a console window requires tedious registry hacking or going through the GUI's "Advanced system setting". Getting shebang support will simplify this process a lot. But I'd love to see this generalized instead. Make a system that uses an extension such as .bang that handles shebangs for more than just Python scripts.
Too clever. This should be done with a simple 'if' combined with 'and', that's what they're for. I'd say this is the opposite of Pythonic. Worse, when the Python interpreter is started with the -O ("optimize") option, _assert statements are ignored_. So it's completely bugged as well.
Interesting post; which tool/library are you using to perform the tests (benchmarks)?
Feel free to bring this up on python-dev.
Using *assert* will be problematic. It might not be now, but in the future a bug will surely creep into it, reason being *assert* is not intended to be used like that. *assert* is intended for debugging purpose ;) you're asking for trouble ahead.
Well on CPython it's indeed probably slower, on PyPy it makes not a difference in the world.
You interested in seeing it? but no, just joking around.
Looks pretty awful to me. I have a couple hackish try... excepts in my code that can catch and hide other exceptions, and I had to shower like ten times a day to stop feeling dirty afterward.
As someone on SO suggested, I'd just use `all` there. The `try/except AssertionError` isn't unreadable, but it is unnecessary and won't always work.
This http://code.google.com/appengine/docs/python/datastore/transactions.html ?
Yup, `all()` is way more pythonic compared to `try/except/else` in this case :-] http://www.markus-gattol.name/ws/python.html#all
you know somehow I missed this, I guess I assumed it was for like a string of queries but wouldn't work for concurrency thanks! It seems like this should work perfect.
But all() is different. if a() and b() and c(): does not call b and c if a() is false, while if all(a(), b(), c()): does.
Yes transactions is what you need
Try/Except is much slower than if/then. Just to provide some hard numbers, I ran this quick test... plain branch: 0.55704498291 try/except, no error: 0.326560974121 try/except, with error: 2.35640120506 This shows (for cpython) that while a try/except falling through with no error is pretty cheap, a try/except catching an error is 4.2 times more expensive than branching. So, assuming T total passes through our branch or try/except, of which we have E exception cases (going to the else or being caught, respectively)... the break even point cost-wise will occur at "T\*.55 = E\*2.35 + (T-E)\*.32". Doing some maths, that gives a breakeven point of "T/E=.11". In other words, unless your exception case is occurring at most 1 out of 10 times the try/except runs, it's going to be slower than using an if/else. That's *exceptional*. For reference, my test script: from timeit import timeit def case1(): "cost of if/else" if isinstance(ValueError(), ValueError): return True else: return False def case2(): "cost of try/except with no error" try: return ValueError() except ValueError: return None def case3(): "cost of try/except that catches error" try: raise ValueError except ValueError: return None print "plain branch: ", timeit(case1) print "try/except, no error: ", timeit(case2) print "try/except, with error:", timeit(case3) 
This specific example should really be written with `if`s and `and`s. But if you're asking about general case, this is my comment from some old thread: &gt; Exceptions are a tool. If you are using them carefully and documenting every non-exceptional usage, they might be quite a nice weapon in your arsenal. The same is with dreaded goto or fallback switch statement in C. &gt; &gt; For example, I see nothing wrong in using exceptions to force going out of a heavily recursive code--as long as you make a proper documentation! It certainly makes code easier to understand, compared to a cascade of return statements--even if it breaks some style guide. Also note that Python already uses exceptions for signalling an end of iterator. &gt; &gt; Bad style is just bad style--there is no law that would limit using exceptions only to errors. Style guides are good for most cases, but once in a blue moon you need something that your style guide didn't predict.
Yep, you are correct. I had attribute access in my head instead of function calls (as the example does), which would work for this.
I'd never thought about that, but it makes sense why that is. Thanks for enlightening me a little bit today!
I crossposted this here in /r/Python because it hasn't even so much as gotten a glance over in /r/LearnPython. Replying here or there is fine either way, I just can't seem to find any OO-based socket information.
**\*YUCK\*** One of the things I love about Go is that there are no exceptions to make control flow a convoluted mess that makes COME FROM sound sane. Python already abuses exceptions in too many ways. And that is without going into the atrocious performance implications.
Not to mention, if someone runs your program in cPython with a -O flag, all of those asserts will disappear.
Only because you are passing all a tuple of arguments. If you make it an iterator instead, all() will exit False the first time its iterator input yields False i.e. do: if all( f() for f in (a,b,c) ): blah... 
I need to use the work 'shebang' in more technical documents.
I don't know if this is right, but maybe you can update atomically. Never SELECT out a value when you're not also updating right then. UPDATE t SET c=CONCAT(c, 'value') WHERE t.id = 'blah'; I don't know that *c* is a known value right then. If not, go with a full transaction.
I use the all function with a tuple myself
I didn't know that, and it's not immediately obvious from the code, but it makes sense. I'd be tempted to use for...else, but then not many people know that idiom either so it's not that explicit either: for f in (a,b,c): if not f(): break else: blah... That is, in case (a,b,c) is a really long or variable length sequence. In the examples he gave, it should just have been and 'if' with a few 'and's, of course.
For comparison, PyPy: alex@alex-laptop:/tmp$ python test.py plain branch: 0.587804794312 try/except, no error: 0.382617950439 try/except, with error: 2.52351593971 alex@alex-laptop:/tmp$ ~/projects/pypy/pypy-c test.py plain branch: 0.0100870132446 try/except, no error: 0.0239868164062 try/except, with error: 0.0253450870514 Edit: the numbers are a tad misleading though, because timeit has a loop in it, which first gets specialized for `case1`, and then has to be re-specialized which isn't quiet as efficient.
http://www.osix.net/modules/article/?id=187 http://docs.python.org/library/socket.html#example What do you mean by OO-based? Edit: obviously, object oriented. But the socket library already is OO, is it not? 
nice work!
Sorry, that should have read *python*.mirocommunity.org, read pycon earlier. Fixed :)
Naah, seen most of them anyways. Good idea for a prank tho
Love the sphinx theme.
I have been using m2crypto and its tedious. This looks nice! 
I found what I was looking for (I think) here: http://www.nightmare.com/medusa/async_sockets.html If the socket library is already OO, can I inherit some portion of it into a class to get the event handlers I need?
Here's a really crappy, basic irc bot you can play with if you want. import sys import socket import string import time HOST="irc.freenode.net" PORT=6667 NICK="ExampleBOT" IDENT="blah" REALNAME="john q public" CHANNEL="#example" readbuffer="" s=socket.socket( ) s.connect((HOST, PORT)) s.send("NICK %s\r\n" % NICK) s.send("USER %s %s bla :%s\r\n" % (IDENT, HOST, REALNAME)) s.send("JOIN %s\r\n" %CHANNEL) close=0 while 1: readbuffer=readbuffer+s.recv(1024) temp=string.split(readbuffer, "\n") readbuffer=temp.pop( ) for line in temp: line=string.rstrip(line) line=string.split(line) print line if(line[0]=="PING"): s.send("PONG %s\r\n" % line[1]) if(len(line))&gt;=4: if(line[3].lower()==':!stab'): movie2=' '.join(line[4:]) s.send("PRIVMSG %s :\x01ACTION stabs %s\x01\r\n" %(line[2],movie2)) if(line[3].lower()==':!join'): s.send("JOIN %s\r\n" %line[4]) if(line[3].lower()==':!part'): s.send("PART %s\r\n" %line[2]) if(line[-1]==':!quit'): s.send("PRIVMSG %s :fine, then!\r\n" %line[-2]) close=1 if(line[-1]==':!sayhi'): s.send("PRIVMSG %s :HELLO\r\n" %line[-2]) if close==1: break
Thanks! I'm hoping to get it's code cleaned up so others can use it :)
Looks interesting. I've been thing about looking at distributed computing. 
looks like "ab" the apache benchmark tool, comes standard with apache. 
http://pastebin.com/ktCxUgW9 ? right from the docs http://www.nightmare.com/medusa/async_sockets.html
This is great work, especially considering the amount of detailed documentation that goes with it!
Does your company do security?
&gt; wtf does "lightweight" mean? Something as lightweight as LDAP
Wow, nice! Good work.
"security" is a rather far-reaching noun, can't rightly say we don't :) I'm part of a 3-man IT shop that does IT support/mainteance for various businesses in our area. This library came out of various custom applications and foreign databases I've written and had to interact with over the years... due to the sensitive nature of some of 'em, I've been really paranoid about authentication issues, which is why this library is unittested so tightly :)
a similar one: http://code.google.com/p/devicenzo/source/browse/trunk/devicenzo-pep8.py
Awesome, salt and key strengthening by default. If you're looking for future directions, [scrypt](http://www.tarsnap.com/scrypt.html) support would be incredible :)
fsck qt, lets fire all or programmers and just use microsoft :^(
It's quite possible to write code that works unchanged in both Python 2 and Python 3. 
mind if i ask how many pythons you have installed?
This is the kind of stuff that makes Python so awesome! No use for it now but bookmarking for future reference, thanks a bunch of making it!
Is qt the best option for GUIs in pyton?
No Python 3.x support? That's kinda lame.
`nonlocal` is supported since Python 3.
Depends on what you're doing, and how many backflips you're willing to do just for the sake of that cross-compatibility. There are plenty of things (mostly involving strings) which the natural way to do is very different between python2 and python3.
Why does noone ever recommend [**Discover Python**](http://www.ibm.com/developerworks/opensource/library/os-python1/)?? Seriously.
Fuck dat IBM bullshiet. I'mma drop some deep shit - dis shit so deep you need to *dive* into it. yee. http://diveintopython.org/ It's a great e-book
Yes. Note that there're two binding projects: PyQt and PySide. While Qt is the best in my opinion, you don't make a mistake choosing wxpython. 
Pygame will do this for you: http://pygame.org/docs/ref/draw.html
Then what about PHP? It has the widely established practice of version numbers in file name extensions, yet some newer minor releases can't run code from older minor releases because of incompatible changes.
Yes, but PHP sucks. Python should strive to not suck.
Seconded. I've used pygame for years to do lots of fun stuff. In fact your pseudocode practically matches pygame's interface exactly.
Thats what it is.
Indeed. However, drawing single pixels is almost never a good idea, it leads to very bad performance. Blitting images with an alpha channel or color-key is way faster, usually. Drawing single pixels might work for very very small regions.
If you want to do it pixel by pixel, I would say that numpy is one of the faster ways. At the pixel level an image and and 2D array are similar. The numpy array can then be converted to an image and shown. Don't expect a frame rate in any case.
Oh, thanks.
Please bring this up on the web2py mailing list and we will be happy to help you. Exceptions in services (for example jsonrpc) are caught and handled by the service itself but you can use a decorator to tell it to log it first and then re-raise it. This should work: def log_exception(f): def g(f=f): try: return f() except Excetpion, e: from gluon.restricted import RestrictedError RestrictedError('Service', '', '', locals()).log(request) raise e g.__name__ = f.__name__ return g @service.jsonrpc @log_exception def oh_my_god_an_unexpected_error(): return 1/0 
Wait, with the numbers you posted below, it is 2.3-2.5x slower. That's not nothing. Still, performance is probably the smallest problem here. To summarize the points made by myself and others: - Executing assertions is optional, and the whole condition will be skipped with optimizations turned on. - Even if the conditions were executed, any functions they call might hit asserts of their own, which will be turned into a false branch rather than a reported failure. It actively subverts the good behavior of other code. - It is supposed to be an improvement for readability...and it isn't. It requires more redundant code, it isn't capable of logical disjunction, and it forces you to treat an "except" clause like an "else" clause. - The whole concept of "pythonic" is tied to using common idioms for simple code constructs, rather than obfuscating things in gross and unexpected ways. By any definition, this is actively anti-pythonic. From PEP 20: &gt; There should be one-- and preferably only one --obvious way to do it.
PIL [python imaging library](http://www.pythonware.com/products/pil/) Offers a put pixel function just as your looking for, and PIL can be wrapped up in a Tkinter(or other GUI framework) to create your GUI. im = Image.open(im) im.putpixel((x,y),RGB) Or to save some time and effort and handle all timing, interactions, etc. you can use pygame which gives you a lot of help.
Well. On a modern CPU, you can easily do single-pixel draws over a full screen in realtime. It is unbelievably inefficient, but 1920\*1080\*60 = only 125 million or so operations per second. A modern 3GHz CPU can do some ~3-9 billion instructions per second, so as long as a single draw op is less than 24-96 machine instructions, you're fine. It's mind-boggling how inefficient our modern machines allow us to be.
Thanks for the link! I hadn't heard of scrypt before. Skimmed that over briefly and really like his addition of "memory-hard" to the list of qualities a good password hash should have. Going to have to give that a more thorough reading, see what I can do with it. 
Try that with pygame, I guarantuee you it won't work well. I've done that kind of thing to create small "dynamically computed" shaders over smaller regions, and that works, but if it gets anything larger than 200x200 pixels, I pretty much had to switch to using some serious numpy + cython optimisations. The overhead of switching back and forth between python and pygames sdl code (which is in C) is too large, I presume, as well as python not really looping fast enough. Disclaimer: I tried all of this with only single threads. Using pure python, I managed to do real-time drawing of effects (blurring, drawing some basic patterns, drawing filled beziérs) and such on regions maybe 100x100 to 200x200 pixels, using psycho it got a little faster (so I could go up to perhaps 300x300), using cython it got a little more faster still, but the real benefit came when I used properly typed indices for the numpy arrays, as well as using integer values for the color values, which allows cython to translate the code completely to C, keeping the python interpreter out of the loop. In that case I managed to apply the thing to the whole screen (1024x786px), but the framerate was around 5fps, which is still too poor for a game. Now, I did all these tests on my laptop, which isn't exactly the beefiest machine, and I bet you get a good speedup on more modern machines, but I think 1920x1080x60 is out of question, especially if you want to do anything useful, not just fill the pixels with a static color. Additionally, you'd have to ship cython code, which might make things a bit more complicated. So all in all, I still think you shouldn't do it, precomputed transparent images that you blit on the screen are the way to go.
Yeah, yeah. Actually I'd like it too (even have it on my issue tracker). I'm currently not able to use python 3 in a production environment (I've got a lot of webapps, so the toolchain isn't there yet). So business-wise, haven't had the motivation. Personally though, I'd like to just for the learning experience. Main thing I'm working through is unicode issues - given that password hashing is very dependant on exact byte values, making sure every byte/string is in the right format at every point is rather time-consuming, which is the main thing I'm working through. (Also, if anyone's got links to best practices for simultaneously maintaining a 2x/3x library, I could use them).
Just to reply to myself... for those who like the theme, it's now available at http://packages.python.org/cloud_sptheme It's pretty rough around the edges, but probably is still useful.
It's also okay as long as you're just doing it once, or occasionally. For example, if you want to designate an orange glow around the border of something, it will be a bit slow the first time, but then you can reuse the picture. However, if you're directly drawing individual pixels on the window surface, then you either don't care about performance or you have no idea what you're doing.
pygame already uses numpy (or, optionally, the older *numeric*) internally, and you can get direct access to the numpy object that represents the image you draw to. That also allows you to get pretty optimized code in conjunction with cython, which can convert all of your code to pure C if you type your numpy indices properly. But as I've mentioned in the other comment, the framerate will still probably be poor.
In the case of a glow, I would just have a pre-computed glow saved in a transparent image file, that I'd then blit over the object (or under) that is supposed to glow. If that doesn't work, because the object that is supposed to glow is transformed or created dynamically (and the glow can't, for some reason, be transformed with the image), I'd build the glow at least from faster primitives such as a bunch of circles or rectangles with varying alpha, something like 5-10 circles (or lines), blitted to the screen with a fixed surface-alpha would probably be enough to produce a decent glow, and it would be very fast (so you could do it in real-time)
Don't forget http://diveintopython3.org for Python 3. Best computer related book I've read. Explanations along with examples, it doesn't faff around and gets right into the details.
Do you have anything that uses PBKDF2?
There's a raw [pbkdf2](http://packages.python.org/passlib/lib/passlib.utils.pbkdf2.html) function, but I was wary of just inventing my own hash format... so many people were doing that, I was hoping I'd find an existing scheme I could support. (grub2 has one, but the format is kinda odd). I may give up soon and just define my own custom pbkdf2-based hash, since it's definitely the cleanest algorithm out there. There is support for [sha1_crypt](http://packages.python.org/passlib/lib/passlib.hash.sha1_crypt.html), which uses a modified pbkdf1 scheme (using hmac_sha1 instead of sha1, so it's really a simplified pbkdf2)... it's currently in use on NetBSD, which gives it some street cred. The docs describe the algorithm, if it looks safe to you, feel free to use it.
I'm a fan of [Building Skills in Python](http://homepage.mac.com/s_lott/books/python/html/index.html)
Thanks a lot for your fast answer and help! I think this will help catching exceptions from my middleware that I might not try/except or possible raise upwards for logging with web2py.
Maybe...wxPython is really good as well.
Looks good, thanks for the link. Just put it on my E-book reader and I am looking forward to reading it.
&gt;1920\*1080\*60 = only 125 million or so **pixel draws** per second. Big difference, depending on how you interpret 'operations'.
Saving this thread for later, anyone recommend one in particular for someone totally new to programming? It's not for me, but I might be teaching a couple people some basic programming over the summer.
To whet your appetite, here's an example using wxPython for the GUI and Cython for fast pixel-twiddling (and numpy as the go-between). First a simple Cython function for drawing a spiral out of 100,000 pixels (it would be more efficient to use line primitives or a proper graphics API like cairo but you wanted pixel-tweaking...). Put this in spiral.pyx: import numpy as np cimport numpy as cnp cimport cython cdef extern from "math.h": double sin(double) double cos(double) cdef int TOTAL=100000 def spiral(cnp.ndarray[cnp.uint8_t, ndim=3] data not None, int w, int h): cdef: unsigned int i, x, y, double r for i in xrange(TOTAL): r = &lt;double&gt;i/(3*TOTAL) x = &lt;unsigned int&gt;(r*w*sin(50.0*i/TOTAL) + w/2) y = &lt;unsigned int&gt;(r*h*cos(50.0*i/TOTAL) + h/2) data[y,x,0] = 128 See the Cython docs, but it's basically python plus some C-style type info. This is used as follows: import pyximport pyximport.install() from spiral import spiral import numpy import wx class Canvas(wx.Panel): def __init__(self, parent): wx.Panel.__init__(self, parent, -1) self.Bind(wx.EVT_PAINT, self.on_paint) self.Bind(wx.EVT_SIZE, self.on_size) def on_size(self, evt): self.Refresh() def on_paint(self, evt): w,h = self.GetClientSizeTuple() dc = wx.PaintDC(self) dc.Clear() bmp = self.get_bitmap(w,h) dc.DrawBitmap(bmp,0 ,0) def get_bitmap(self, w, h): data = numpy.zeros((h,w,3),numpy.uint8) #do stuff with pixels here spiral(data,w,h) bmp = wx.BitmapFromBuffer(w,h,data) return bmp def main(): app = wx.App(0) frame = wx.Frame(None, -1, "My Frame") canvas = Canvas(frame) frame.Show() app.MainLoop() if __name__=="__main__": main() The pyximport module is part of Cython and it automagically builds your Cython extension module. No other build files needed. Thus, for this approach, you need wxPython, numpy and Cython (and a C-compiler).
A pixel draw is a single array write on an array that fits entirely in the last-level cache. I don't know how pygame implements it, but regardless of how it's done, the vast majority of the cost of drawing a single pixel will be in the overhead of the python function call. The cost of deciding what to draw in that place should vastly exceed drawing there in any reasonable implementation. If I wrote it in C, I'd expect a single pixel draw to cost a single clock cycle. During which I'd also be able to start working on the next pixel.
But please follow up on the mailing list. This will benefit others. Moreover I have not tested the code above and I it can be improved. Now that you raised the issue, I feel there should be a standard api in tools to do it.
I always like to plug [Invent Your Own Computer Games with Python](http://inventwithpython.com) for people who are new to Python and programming itself.
[Here](http://kmandla.wordpress.com/2010/05/24/the-1-2kb-python-browser-script/)'s the GTK version. 42 lines. 43 if you add the address bar (instructions in the comments). --- And for what it's worth, the original post throws an error for me: Traceback (most recent call last): File "qtbrowser.py", line 278, in &lt;module&gt; browser.main() File "qtbrowser.py", line 268, in main self.newtab() File "qtbrowser.py", line 71, in newtab settings.setAttribute(QtWebKit.QWebSettings.ZoomTextOnly, True) AttributeError: ZoomTextOnly 
upvote for that sys.excepthook trick
it's not that good ?
I like it too
I guess it's time to back another horse.
Also /r/learnprogramming and /r/learnpython. 
tl;dr bunch of slackers start something and were too lazy to see it through
Sad. The [two](http://www.reddit.com/r/Python/comments/cilk0/anyone_know_whats_going_on_with_unladen_swallow/) [times](http://www.reddit.com/r/Python/comments/dl1d6/askpython_anyone_know_whats_happening_with/) I asked the folks here what Unladen's status was, the answer was that it was "being merged". I kinda suspected that wouldn't happen.
When will [PEP 3146](http://www.python.org/dev/peps/pep-3146/) be revised? I'd hate to see someone refer to the PEP and find what looks like still-valid merging timelines.
It's nice to finally get some authoritative closure at least.
...like PyPy.
I remember you're a blockhead so I'll mostly comment for everyone else, what you call "views" is actually the controller and that is always a callable function in any framework in any language; likewise what you call "template" is the view, which is html enriched with the programming language the framework uses and that is also the same approach as the rest. Django is no different in any way to other MVC frameworks out there, you're just unable to accept the possibility of being wrong :)
[Try Pyglet](http://code.activestate.com/pypm/pyglet/) -- it is easy to install, as it has no external dependencies. Also see this [similar StackOverflow question](http://stackoverflow.com/questions/326300/python-best-library-for-drawing).
I hope PyPy gets third-party library support soon (particularly NumPy/SciPy), though I suspect that's years away.
We have alpha-level support for C-extensions, which works moderately effectively for extensions written for compatibility. However, extensions written for speed like NumPy will really never be fast under it, so they'd need to be rewritten in RPython or Python. NumPy's ubiquity makes it an interested case, and we've done some experimental work and demonstrated that we can write something even more performant than the origin NumPy, and without the penalty when you drop into pure-Python. That said, we don't really have the manpower to develop it to full compatibility, and work on the JIT, and keeping up with CPython, so NumPy is really only experiments at this point. If there's interest I'm more than happy to answer any questions on it.
Thank you! :) I am brand new to Python. This was handy.
Sounds about the right type of project to use Django. Make sure you grasp how reusable apps are written and check out www.djangopackages.com for apps that do what you need. 
If one python coder want to learn RPython to write some code for speed, could you recommend some tutorial for RPython, last time I just check PyPy's website and don't know how can I go on.
If you want something quickly, try Pinax. It is a library for Django that offers stuff like fully-baked user registration and other CMS-ish functions.
When I was working on my first python webapp I started with Django. It took me a couple weeks to realise I hated it, then I moved to Pylons and fell in love. Now Pylons has been abandoned for all intents and purposes and I don't really like the look of Pyramid... so I'm not sure what i'll use for my next Python project.
Unfortunately the site is even dated. They are hinting towards RPylint which has been abandoned for years. Now since PyPy is going to support C-extensions why not write in C again instead of a stripped down, vaguely defined Python subset? "Writing for speed" is an own discipline anyway and I can't help but think that garbage collection is not part of it.
I am sorry to here that you have no resources to work on C extensions compatibility. Without this PyPy will not get broad acceptance and will not be considered a replacement for CPython. 
the c extension support can never be as fast as native extensions for pypy (which are rpython)
I don't understand. Why Google is not interested of speeding up Python? Even if it is currently used in internal prototyping and not speed critical projects, being able to scale without rewriting to another language would be big win in my opinion. What is the problem? 
I'm trying to explore Django. Could you tell me (us?) why you hated it and what do you recommend? 
It's faster to jump into a [web2py](http://www.web2py.com/) project. Early feedback.
True, but I don't talk about "support time" which means the added costs for calls into the extension and from the extension back into the runtime. 
that's not what kingkilr said. he said they don't have the manpower to develop their experimental numpy module to full numpy compatibility in parallel to do the needed ground work for pypy (which as I understand includes a C-extension compatibility layer). And NumPy, while important for some areas, is not the "oh without it nobody will accept pypy" case people sometimes make it out to be - there are tons of stuff you can do without ever needing to touch scipy/numpy. Even without c extensions you can allready do tons of stuff successfully with pypy today (like for example build web apps with django). Actually I am even doing number crunching stuff with pypy allready - just not with numpy, because my numbers are more on the business side than on the science side and that often reduces (hah!) to simple base math over large lists of numbers. Pypy is fine there, as is pure python (think pivot tables if you want to get an idea). To me, compatibility with 2.7 would be much more important than numpy or scipy support.
im talking about the issues of gc emulation, wrapping up native objects to a cpython wrapper and the like calling into the c stuff is the smallest issue emulating the cpthon c api on top of a much more modern vm is costing some
I don't think you can take a prototype and run it at Google's scale, even if you get a magic factor of 100 from a JIT compiler (which was an unrealistic number for the LLVM-based approach, at least). You likely need fundamental architectural changes, and better support for operations.
The speed gains of Unladen Swallow were not enough to justify not rewriting in another language for speed.
really the only thing i ever got out of looking at pinax was just seeing how reusable apps could work, its sorta okay to install as a test and see a good deal of example code. I can't really imagine building on it though as it has alot of dependencies and it does things just every so slightly different than I would
I love-hate reusable apps in Django, some of them work great, but then others I need to modify just slightly to get working properly, one awesome thing though is that almost all of them are hosted on github / bitbucket so its pretty easy to see if other people before you have forked them. I do think that maybe Django should consider hosting some on their own source control though, as some basically become abandoned (see http://code.google.com/p/django-tagging/). The reusable apps might be misleading to a django newbie as you might expect them to work out of the box everywhere, but they are in general pretty well written example code.
I suppose another thing is... it's target for merging was py3k which is already a bit troublesome in terms of getting large scale adoption. If unladen were landed in py3k, the Google projects that were using it would all have to be migrated to support py3k along with all the dependencies of that code. I'm not saying this issue was make or break, but I imagine it adds inertia.
Why is this? Is this just because the C extensions are black boxes to the JIT that can't be optimized? Edit: I guess maybe you're talking about [this](http://www.reddit.com/r/Python/comments/gc7fg/unladen_swallow_retrospective/c1mjkp5). What about making a restricted C API that extensions could adjust to rather than rewriting?
Seems to be rather dated right off the bat so I didn't read far beyond the first couple of paragraphs. The problem is that it is dated as python 3 is now at 3.2 and the library issue is no where as bad as it was in the 3.0 days. Great idea though. 
I'm quite happy about the death of this project. Small speed gains were achieved with bigger memory usage, higher startup times, increased code complexity, massive increases in binary size and dependence on the C++ runtime. The whole thing is just not worth the costs, and that's also what the people at Google seem to think.
No, it's worse than that. Take the C-API function `PySTRING_AS_STRING`. On CPython this just returns the internal `char*` of the PyString_Object. On PyPy however objects (include strings) can move, and C code assumes that pointer will be valid for the lifetime of the object. Since the C code is opaque we can't patch up the pointer if it moves, so instead we have to allocate a seperate non-moving buffer.
I agree with this proposal. It may not solve everything (you still can't specify what version of Python 2 or Python 3 to use), but it definitely will help. edit: pingveno, below, is right about specifying the version. It's not an elegant solution though, because that version might not be installed...
I have a secret fantasy that rather than google upgrading appengine to cpython 2.7 at some point(figuring it's not worth upgrading to 2.6 at this point), they adopt pypy. it seems that the ability to sandbox would make it an attractive option, and then maybe google can throw some support towards pypy. I'm a dreamer. 
Someone answer me this: If CPython is fast because of so much implemented in C, and PyPy is fast, because some core functions are reimplemented in Python, doesn't that mean if the PyPy algorithms were ported back to the C functions that make CPython, wouldn't everyone benefit??? I must be missing something big.
I always use /usr/bin/env python(x) where x is the version it needs to be, if it matters, and /usr/bin/env python if it is version agnostic code, allowing the user to chose what their "python" is.
Their implementation of the C API should really help with library support, though apparently the implementation layer isn't great for performance. For most pure Python programs, the Python implementation shouldn't be an issue. IIRC, Python 2.7 support is now in trunk. For NumPy specifically, there was even an effort over the summer with GSoC to implement NumPy support in RPython (the implementation language for the interpreter).
Oh? I was under the impression that (for example) /usr/bin/python3.2 will *always* be the executable, and (for example) /usr/bin/python3 will be a symlink.
But some people are doing it anyway. Should they now have to have two copies (or a symlink I guess) for each of their files so that one can have a different extension for Windows users?
Yeah, I don't use it myself since I find it easier to configure the two or three apps it pulls in that I care about, but if you aren't familiar with Django and want something ASAP ...
This choice shouldn't come from upstream, just because arch broke something doesn't mean everybody else should be stuck with python as a symlink to python2, what happens when nobody is using python2 and everybody is on 3 or 4? Where python points should be up to the distro, any code which needs a particular version should call that version
You are: JIT. PyPy produces native compiled code, rather than simply interpreting Python code directly.
I didn't like the built in user authentication. Much preferred writing my own in Pylons. Two database queries for a single user with a profile by default? What the hell is that? I loved the templating language, but hated the convoluted way you had to write addons for it just to do simple things like pagination (pagination which doesn't suck like the built in pagination). I went on to use Jinja2 with Pylons which is more or less the same language, but which lets me import simple functions to be used in templating. The ORM wasn't to my liking. I prefer SQLALchemy because it lets me write queries in the way I understand them, as opposed to Django which trys to make it "simple" for me. I just prefer being in control, and Pylons gives me that.
How can you have fast, custom data types in PyPy? Would a RPy implementation of NumPy have to use lists as the underlying datatype? Would it necessarily be slower than the current CPython version of NumPy?
Why is he comparing PyPy to Python 2.**4**?
Seems to me like that's just gonna further hinder the transition to Python 3. Why can't Linux distributions just bite the bullet and upgrade entirely?
So the JIT compiler is the focus of PyPy... or just another feature? Right, I have heard unladen swallow having a CPython JIT. Without the JIT does PyPy have a speed difference? Are those PyPy reimplementations necessry for the JIT functionality? I have seen those benchmarks. I don't see the benefit beyond the JIT.
Yes, look at virtualenv/virtualenv-wrapper (rvm) and pip (bundler). To get started: http://www.arthurkoziel.com/2008/10/22/working-virtualenv/ http://www.clemesha.org/blog/modern-python-hacker-tools-virtualenv-fabric-pip
If you implement an equivalent Python JIT in C, then the JIT phase itself might be faster than PyPy's, but the execution speed of the JITed code will be identical. Well, that'd be true if PyPy was written in Python, anyway. Given that large parts of it are written in RPython, I'm not so sure. I don't know how RPython compares to C in speed - presumably C isn't slower, but I don't know how much faster it is either.
So it is more about the feasability of implementing such JIT. Ok, it makes sense now that unladen swallow had approached simply porting the PyPy JIT back to CPython. 
You don't know if that version is installed though... which is why people use a generic symlink in the shebang, right? Thanks though, I updated my comment.
You can't simply upgrade to Python 3. There are a very large number of packages that don't support Python 3. Python 2 is here to stay, due to how well it works and how many packages aren't ready for Python 3.
That policy definitely should come from upstream. People need to be able to depend on a shebang that goes to Python 2. It provides a basic environment that everyone can depend on. Some distros (aka Debian/Ubuntu) were refusing to do that without upstream insisting on it.
Brilliant, thank you.
No, in RPython you'd have an array of unboxed ints. In fact we think we can make NumPy faster (and our initial expirements prove this).
When some fundamental packages like PIL either support Python 3 or are forked/rewritten due to lack of updates, then we can start worrying about various distro's updating to Python 3. I think you will find that the distros will update pretty quickly, once it becomes practical. They are not the roadblock here.
So RPython has additional datatypes then?
(Just tried posting this, but I think reddit ate me comment). Here's what I came up with to guess when you want tab and when you want complete.. Just stick it in your .pystartup. You need to import readline and rlcompleter of course. It uses a nested function so that you can safely del everything in .pystartup (including make_new_completer()) and still have it work. def make_new_completer(): completer = readline.get_completer() def new_completer(text, state): if state&gt;0: return completer(text,state) elif text.strip()=='': return '\t' elif text == completer(text,state): return text+'.' return completer(text,state) return new_completer readline.set_completer(make_new_completer()) readline.parse_and_bind('tab: complete') EDIT: Alternatively, you can set a different key to complete or use [ipython](http://ipython.scipy.org/moin/) if you're using python 2.x. ipython would be my recommendation, I only use the above when I'm working with 3.x. Oh, [bpython](http://bpython-interpreter.org/) is supposed to be good too.
It'll be gone. To anyone who thinks "Python 2 is here to stay," you are a fool, it is done; it's being supported, but its over, Python 2 will go, just like Python 1 did. People will use it foolishly or out of necessity for a little while longer, but soon Python 3 will have almost all of the packages transitioned to it. 
At the time you asked the question, that was the plan. It's still possible for someone to step up and do the work...but it's a significant body of work to be merged and ported and continued with. None of the current core team has enough knowledge of the intricacies of the system, nor do they have the time to continue their current activities and also take this on.
Those projects need to be installed in two separate `PYTHONPATH`s anyway, so you might as well have the install script rename the files with the appropriate extension while you're at it.
Read the post?
I don't think a single major Python project I've worked on could switch to Python 3 today. There are still third party dependencies that don't work. :-/
Well, RPython has lists, which must be composed of homogeneous datatypes.
RPython is a restricted subset of Python, the restrictions keep it directly translatable to C code.
Ah, okay. Didn't realize they were homogeneous.
I would be glad if everyone suddenly started using Python 3. The question is, "Why bother?" Python 3 doesn't really offer anything worth upgrading for. It's foolish to say that using Python 2 is foolish (not to put words in your mouth, I understand you didn't exactly say this). It's extremely practical. Python 3 is the future, yet barely an upgrade, just a change in syntax. Plus, there's a package dependency nightmare to resolve. Some packages can't upgrade until the packages they depend on are upgraded, and vice versa. And who really wants to maintain two separate versions of a library? I recently spoke with the creators of the Pyramid web framework, and in their minds, Python 3 is an eventual future, but not something that's exactly a priority in any way. (I think they mentioned it as one of their goals for PyCon?) A list of which packages are Python 3 ready: http://python3wos.appspot.com/ If I may ask, how are you using Python today? And what libraries do you use in your Python 3 projects?
PyPy is two different things. The first is a framework for building language interpreters. The second is an interpreter, built with that framework, for JIT-compiling and running Python code. That framework makes the development of interpreters easier. As a result, PyPy the interpreter is actively developed and moving forward, while Unladen Swallow is [basically a left-for-dead abandoned project](http://qinsb.blogspot.com/2011/03/unladen-swallow-retrospective.html). You ask if PyPy has a speed difference without JIT. You might as well ask how fast Ferraris go without wheels. You're asking a question that has no point. When it comes to speed of execution, the whole point of the PyPy interpreter is to produce fast code through JIT compilation. Don't get overly caught up in the project's confusing name. The PyPy framework can and is being used to write interpreters for languages other than Python.
i see a lot of pygame suggestions on the menu. not trying to answer your question but don't do pixel-by-pixel drawings, no one does it these days even with the fastest languages. with python, you are in for a ride. it is not because it's primitive. but when people were doing it that way, there were less abstractions between your memory screen buffer and your application. today, there are so many abstractions that it's not even fun. use what your library or framework gives you to blit on your screen. they know better the metal these days.
using akhet paster template you can code stuff like you would do in pylons (already migrated one project to pyramid), so why just not give it a shot? pyramid_handlers lets you write handlers who are rough equivalent of pylons controllers, and you get a bunch of good tested well documented stuff in pyramid. Give it a spin before you say "you dont like the looks" because you can really do things same way in it
I like this choice. No argument from me. :)
&gt;The upshot is, using “#!/usr/bin/env python2” and “#!/usr/bin/env python3” in your code will become the gold standard **(unless of course your code can run on both python-2.x and python-3.x)**. If you're doing this, just stop.
I use Python for everything I program, at least initially (Many times I'll prototype in Python, then optimize in C, then perhaps optimize in assembly) I do think it's foolish to not move on as fast as you can, because like you've said... there is a package dependency nightmare, so in order to upgrade, everyone has to upgrade; it doesn't matter if people don't consider to benefits of the upgrade to be nominal, because the future upgrades to Python 2 will be nothing. ANYTHING new is Python 3. Any features that roll out tomorrow and everybody wants will require the dependency mess to be resolved in order to use. I use Python 3 for web development. I've avoided Web2py because of it's stance on Python 2 v 3, even though I like it. I've avoided Django for it's stance on Python 2 v 3 (along with some other reasons that will likely piss off fanboys -- so I'll leave that to another time) and I'm currently using CherryPy and Mako due to their speed, lack of desires to tell me how things should be done, and namely Python 3 support. I mostly use the Python Library, NumPy/SciPy and CherryPy/Mako for what I do, but I've used a few others in a bind, that I simply can't remember because I've only used them minimally. I tend to avoid Python 2 packages, and have easily managed to do so since I began learning the language around Python 2.6, and transitioned to 3 before using libraries was a part of every project I was working on. I've only used Python 2.7 when I've absolutely needed to (I had to use it for Immunity Debugger scripts and some in-application scripts -- I think it was a media player)
Upgrading to Python3 simply isn't feasible in most cases, but I like what ArchLinux has done. Their decision to upgrade to Python3 as the default may have been controversial and caused a little hassle at the time, but it's what is needed to push progress. Without distros like Arch taking these decisions, the Python community risks slipping into a vicious circle. There is little incentive for developers and users to move to Python3 while there are very few ported libraries, but there is little incentive to port libraries to Python3 when it has no users. The ArchLinux devs have attempted to break this cycle. I would like to see other bleeding edge distros do the same.
Thanks for the reply. I'll look into CherryPy / Mako for some simple Python 3 web services (I've used Pylons and Django mostly up to this point). If you look at how long it's taking to move away from Python 2, one thing is certain: Python 3 will be around for a VERY long time.
Uh, what? If you're not doing this, it's a great time to start.
Give what a spin? Pyramid? Will be trying Pyramid for my next webapp.
I found CherryPy/Mako to be at least noticeably faster than Django and offers quite a bit more freedom to just code your application. I'd say its probably slower development than Django if you just do as Django tells you, but CherryPy is significantly less opinionated than Django.
If you use Twisted (a good library), there are loads of great examples here, including a chat server: http://twistedmatrix.com/documents/current/core/examples/index.html
Is it really possible to write a library that runs on both with the same code?
Yes. There's one I maintain that I've been meaning to test to make sure it actually works on both.
A question from me. How stable is RPython? The docs tell the reader that it is somewhat of a moving target but it tells this since the docs are up on the web i.e. since 2004 or so. Is this true to an extent that RPylint was abandoned short after it was launched? 
I've never used Django, but I've written a couple small/medium sized projects with Flask. I really like it. I wrote a in browser podcast client using Flask, FeedParse, MongoDB: https://github.com/bgianfo/pod-tracker/blob/master/python/caster.py I'm currently writing a web service API in flask for a graduate class project i'm working on. It's Flask + a Riak data store: https://github.com/bgianfo/distributed-systems/blob/master/src/server/distrivia.py Flask is really neat. In my mind it takes the best parts and idea's from other frameworks and let's you use what you want/need. From reading the code of some other project's it also seems like the code scales well as your codebase get's larger. 
RPython is a pretty stable language, but we also really don't intend it for use by outside developers. It's for writing interpreters, not general use programming.
How about writing extensions in RPython? I thought that Rpython, was in general, higher level than C and, I'd guess, it'd integrate easier with python code while retaining efficiency of C. Basically, use RPython for extensions rather than C or weird hybrids like Pyrex.. 
OHHH ok. So you memorize a small, easy to remember phrase (not a password, no need for caps, special characters, numbers, or minimum length). You then put it into a hash, which generates a 10 character length password to plunk into the login, ssh, or other password protected system. This eliminates the problem of having short, dictionary attack friendly passwords. It also removes the need for password management software on the client side. (since the tokens can be easily memorized and can be short enough to type quickly). I'm really hoping the master password is different per machine. Even so, it would mean that if you were able the access the machine on which the password was generated from the token, dictionary and brute force attacks become even more trivial than with previous password schemes. Edit: Ohhhh, YOU provide the master password. I'm dumb. So you memorize ONE password and however many tokens you need for different services. (flickr, reddit, even just f and r). Still, it would be nice if the generator used something unique per machine. This would eliminate a weaknes: if you were able to deduce the master password, and the tokens (which are easy to guess or brute force if you're correct about the master password) you could access all the services used by that person. Of course, the master password is never sent over the wire. This helps in eliminating man-in-the-middle attacks, but does not stop key logging or other schemes. Edit 2: EUGH dumb again. Having something unique per machine means that the master password / token hashes are only good from one machine, not many. Not portable. Would make for an interesting manual 'authentication' mechanism, though. Try logging in with a new machine, fail. Go back to old machine, enter password/token, see the hash which tried to get in on the previous attempt, check that it's the same as the one the new machine generated, authorize it. So only my home machine and my work machine can access my bank account. If you lose a machine, you need to call and confirm a new hash over the phone, using lots of checks. 
I'm really the exception to the rule for the PyPy developers, I kind of like RPython, and I wrote a postgresql wrapper in it (mirroring psycopg2). However there's a major blocker for this being a real option for end users, it's not presently possible to compile an RPython module separately from the `pypy` binary, it must be included at compile time, and we think it'd take a pretty serious engineering effort to fix this, unfortunately.
O.K. thanks for the info. 
So it copies the password in plaintext to the clipboard? And with clipboard managers like klipper... Overall I like it, it's still hasslefull and vulnerable in some ways though. Maybe a click on box, shortcut opens window which then pastes directly into the password box?
Arch didn't break anything.
There’s a garbage collector that is missing in CPython (instead, it does reference counting) also.
I use service-specific passwords for years, but I prefer algorithms that are solvable on paper. My personal hash algorithm is a combination of 6-8 simple rules (number-counting, search-replace, key-shifting, ...) that completely distort the token and include a lot of numbers and special characters. So, basically, the algorithm is my master password. To say something on-topic: As far as I understand it, once an attacker get his hands on one token/password pair, he could brute-force the master password. The algorithm is known, so he can do it on a GPU or cluster. Am I right? And the token is quite easy to guess, I guess. Most people would just use the domain or service name.
Don't like Django user authentication? Use RemoteUserBackend or write your own... http://docs.djangoproject.com/en/1.1/ref/authbackends/ Just use Jinja2 with Django! What is stopping you? You can use SQLAlchemy with Django... you will give up the Admin and other things... but you don't have them in Pylons... So... it seems you started hating Django before trying to do a simple read of the manual???
The Japanese are somehow fascinated with Germany, so that's not too surprising. Every other anime has German characters or words in it, Neon Genesis Evangelion being among the more obvious cases.
&gt; It's not an elegant solution though, because that version might not be installed... If that version is not installed, how do you expect it to work? Automatically run the script on whatever version the user install doesn't work if it's python2 &amp; python3. * If your script only works with Python 3.2, then the shebang line should point to `python3.2`. * If it only works on Python 3, then make the shebang line point to `python3`. * If it's going to work on any version of Python 2-3-4-5...., then make it point to `python`.
Very cool, I love the design. Did you make this for you and your buddies? Or just an idea?
Sounds like [Hashapass](http://www.hashapass.com/).
I hope to use it for myself, but also hopefully add more features that I won't necessarily use. I think it could be useful for some organizations that hold fundraisers and the like. Just a fun thing in general, really. Glad you like it!
So you were born in 4 B.P.? I'm born in 3 B.P. \0/
&gt; That Py is no lie! F*TFY \* sort of...
Web faction?
these days you can get a VPS w/ root for ~20 a month that you can do w/e you want with.
this. Their support is top notch too
To be honest: Your app looks a bit like a flask app - but it does not use any web framework like flask. After a short look into your code one must say: It better should! You implement a whole bunch of things yourself, what a framework allready delivers for you. So perhaps you would better use a webframework like flask and use its nice API, secure mechanisms. As a database layer is not included into flask: Inform yourself about SQL-Injections. Your code is not safe against it. So I would definitly not recommend anybody to use your aoo right now.
I think he meant "stop making your code run on both Python 2 and Python 3, just make it run on Python 3 only". Making your code single code base run on both Python 2 &amp; 3: * Slow down Python 3 adoption rate. * Complicate your Python 3 development. * Prevent you from fully utilize Python 3 feature. Writing Python 2 in Python 3 is like writing COBOL in Java. It makes sense someone would propose you stop doing that.
It isn't meant to be an equivalent to python foo.py, it's meant to be an equivalent to ./foo.py
Linode is great for *. PM me if (1) you decide to sign up and (2) you are feeling charitable enough to allow me a referral credit. 
I see no one else mentioned that framework... it sounds like the more important aspect of PyPy. All I ever heard about PyPy is execution speed, so pardon me for being fixated on that.
If you don't mind doing everything yourself, AWS EC2. You can't beat $0 a month for a year. 
Google app engine. With caveats of course... 
If that's the case, then I'm all for it. With so much Python 3 hate around here, I figured it was a suggestion to forget 3 and stick with 2.
Google App Engine is actually pylon?
GAE is an infrastructure, just like EC2 or cloud computing as you call it. There are some restrictions to what you can do on a GAE app but pretty much all the web frameworks out there can be deployed on the GAE with a couple of tweaks here and there. For e.g. [Tipfy](http://www.tipfy.org/) is a framework specifically meant for GAE
You'd have to pick out a common set that will run the same amount of tests across all 4 OS'es and their default configurations for a fair comparison. `test_abc` is the same on all, but many others are not.
Can't recommend Linode enough, a really great service.
It would be cool if you named one.
I've used both a fairly good bit. In my mind, it helps to think of Django as FlaskPlus (or some other corny name). Django is basically Flask plus stuff like: - Built in admin (which you may or may not want in this case) - User authentication (which would be nice in this case) - Regex routing (which is almost always just an extra headache compared to how Flask does it, IMO) - The addition of the model layer and all the niceties that come with that (usually nice but sometimes just an unnecessary extra layer) - A huge community - Tons of pluggable apps - Lots of other small niceties So I'd say, look at that list (which is obviously not complete but it hits the high points), and see if you'd like those things. If not, it would be simpler to go with Flask as it's easier to learn. As for your points, I think they're mostly wrong. You can switch out ORMs and templating languages easily in both Flask and Django (though if you switch ORMs in Django, you lose a couple things), so don't let that sway you too much. Also, I was able to get Flask up and running on a shared server with mod_wsgi with absolutely no prior knowledge of it in like 20 minutes just using the docs, so I wouldn't say you have to learn your way around WSGI any more than you would with Django. 
I have been very happy with their services.
cloudnext.com a2b2.com
Is this what you built? http://supergenpass.com/
the cheapest is probably burst.net, but be warned any oversold vps is likely to have periodic problems with high iowait as you'll have someone else on the machine swapping out 24/7
&gt; what happens when nobody is using python2 and everybody is on 3 or 4? Everybody still uses python3 and python4 in shebang strings.
This would be pretty baller if it could generate and track brackets as well.
Damn libertarians are invading everywhere.
[prgmr](http://prgmr.com/xen/) is a quality host and one of the cheapest ones you'll find. However, there is pretty much no systems level support so you have to be pretty savvy in the unix admin department. I've had an instance with pylons on it for a couple years now with no issues.
Yes, it's the same concept as SuperGenPass or Hashapass. However, I'm not really comfortable doing this in my browser in general. Beyond that, the SuperGenPass and Hashapass bookmarklet implementations have you type your master password **directly into a web page form**. That's insane - the web page can log your keystrokes and steal your password (it's the same JS technique as search completion). Unlikely? Perhaps. Insecure? Definitely.
Yeah, this is the only part I'm not thrilled about - I have the same problem with parcellite (and there's no way to tell it to ignore certain entries or even to clear the list entirely, which you'd like to do on suspend/hibernate at minimum). Perhaps an additional command (bound to a hotkey) that finds the current X11 window and then pastes/types the password to the window? That'd avoid the clipboard entirely...
http://www.lowendbox.com/
just got around to trying it out once again, there are couple of minor issues still. so i forked the above gist. can you please incorporate stuff from https://gist.github.com/890679 into your base code. changes mentioned above make things work just fine. thanks !
Agreed. Stand on the shoulders of giants by using tried and tested frameworks (e.g. Flask, SQLAlchemy). However, nice to see your project and even better that it's open source!
control-v tab
Seconded. I use nearlyfreespeech.net for everything but Python-based sites, there Webfaction can't be beaten.
I know it's insecure, which is part of the reason I wanted to release the code--I haven't done much by way of security. I know psycopg2 handles most of the SQL injections, but I have to circumvent some of the psycopg2 niceties in order to get some things to work with the database. I'm not sure about a framework. I think it could make things easier, but I also want to be able to play with this app a lot, and keep the dependencies small....I already had to add gevent as a dependency, which seems like a big jump to me, especially since older versions of Debian and Ubuntu don't have it in the repositories (from what I recall). Maybe I'm being too paranoid. I'll look into some frameworks today, but I can't promise much, I worry that it will be overly simple. Flask, and jingleman suggests SQLAlchemy, and whatever else I can find. Thanks for the awesome input, mate! EDIT: As a side question, what makes flask better than gevent, and what makes flask better than other frameworks? (pylons, django, and the like)
I was only thinking about linear, informal game play when I originally came up with the idea, but I suppose a tournament designer could come in handy. I will add that to the things to do, since I already have quite a few!
&gt;Unfortunately, LLVM in its current state is really designed as a static compiler optimizer and back end. LLVM code generation and optimization is good but expensive. This is kind of depressing, because getting LLVM do most of the backend compilation gruntwork seemed better than rolling three or more JITs (x86, x86-64, ARM, etc) together to get decent speedups. I hope the LLVM people work on some more dynamic-friendly tools.
If you want to be able to just type `python` and have it work, you need to add your Python installation folder to the PATH. See [this blog](http://geekswithblogs.net/renso/archive/2009/10/21/how-to-set-the-windows-path-in-windows-7.aspx) for an example of how to set it.
hmm I don't have a "path" under that listing I don't think that's a good thing /sigh I have more issues then I thought..Thank you for helping.
When I wrote my last post I was actually going to mention how, when I state my objections in using Django, there's always somebody who comes along and says I can swap out the components of Django which I don't like. First of all, I did read the manual, so fuck you. Second, I don't see the point in using a framework if I'm swapping out all the key components with something else. Pylons is built for this purpose, so why would I use a framework that isn't?
Glad you went with gevent instead of BaseHttpServer, but like everyone else has said, you should have used Flask and SqlAlchemy!
You have to make sure that you set the enctype="multipart/form-data" set in your form. Then the field turns into a cgi.FieldStorage object that has the filename, an io stream of it, and the path it's located at in /tmp at the moment. In order to store it, you'd just use something like shutil.copyfile() to copy the path/filename over somewhere. The pylons docs here are still handy for some examples: http://wiki.pylonshq.com/display/pylonsdocs/Form+Handling
As noted you just need to add the Python directory to the PATH environment variable (eg, ...;C:\Python27). Look for "Python (command line)" or "IDLE (Python GUI)" in your Start Menu or whatever. They will give a prompt just as typing python at a prompt would. The working directory will be your Python install directory. 
Nifty. Longer example: http://code.google.com/p/struc/source/browse/example.py
Thanks just got this working! Note that the git file in 885214 is incorrect but 890679 is correct
In the meantime, you should be able to just run Python by pointing to the full file path. If you have 2.7 installed, `C:\Python27\python.exe` is the path. All versions follow that format, so replace `27` with whatever versions.
Stuff like this scares me because it's so easy to mask errors, but it is fun :)
I apologise in advance for my obtuseness, but why is it a troll, complete with trollface icon? What am I missing?
Yay Python! Still a Disqus hater though...
i have to use Wing for class, and it sucks. sorry for the reverse-answer
I use two. PyCharm and Vim. I really like both of them.
I like PyDev, but I've heard PyCharm is very good too.
Emacs
There is a library named MediaCore that is part of Microsoft Auto PDK.
I use netbeans or notepad++ I don't mind netbeans, bu then I don't use all of its functionality. I love notepad++, but i had to hack in build/run commands.
Komodo IDE is nice but not free. Komodo Edit is free though.
&gt; What IDE do you use, **and why?** FTFY. The comments so far are braindead versions of "oh, I use ___"
IDLE - simple for quick scripting
vim
I use VIM and Eric4 I write a lot of PyQt4 and eric is great, but I use it to debug web apps too.
+1 for pydev. It has probably the best code-completion / intellisense of any. For systems wiithout the memory for eclipse, I use IDLE.
SPE is decent and has some nice features (UML introspection, for example) but the code completion features are a bit weak. (It can handle the methods of a class, but not an instance of the class, as well as any previously-used attributes of an object.) The code completion in Komodo edit is quite good. It even handles custom libraries if the library is included in your project. Just map the python command to a function key and it really does all you need. For bonus points, you can also program in your other languages in the same editor. The free version of Komodo is fine, and it's available for all major OSs. Personally I'm still a fan of emacs, but I don't impose that on my students unless they're ready for it. Notepad++ for Windows is a good choice, as is gedit for Linux. 
You're already there - just use the `.text` property to get the tagless representation. For example: &gt;&gt;&gt; from BeautifulSoup import BeautifulSoup &gt;&gt;&gt; html = "&lt;html&gt;&lt;p&gt;Para 1&lt;p&gt;Para 2&lt;blockquote&gt;Quote 1&lt;blockquote&gt;Quote 2" &gt;&gt;&gt; soup = BeautifulSoup(html) &gt;&gt;&gt; soup.text u'Para 1Para 2Quote 1Quote 2' No muss, no fuss. And, best of all, no brittle regexes.
Notepad++ ...with optional NPP python plugin.
Not sure if this is the best way but here you go: **Template** (upload.mak) &lt;HTML&gt;&lt;BODY&gt;&lt;h1&gt; Monstrado's Porn Depot &lt;/h1&gt;&lt;h3&gt;Upload Fapware&lt;/h3&gt; &lt;form method="POST" enctype="multipart/form-data" action="upload"&gt; Image: &lt;input type="file" name="image" /&gt;&lt;br /&gt; &lt;input type="submit" value="Upload"&gt; &lt;/form&gt; &lt;/BODY&gt;&lt;/HTML&gt; **Views** def write_some_porn(image): uid = generate_some_unique_number() open('/path/to/storage/%d.jpg' % (uid), 'wb').write(image.file.read()) return uid def upload(request): if request.method == "POST": image = request.params['image'] uid = write_some_porn(image) return HttpResponse(str(uid)) In this example I'm calling some arbitrary number generator and then saving the image to disk with that uid. You can easily make another view which accepts the UID and returns the image. 
At least we got the weekly IDE thread out of the way early. `import random` `random.choice(["wing", "komodo", "pycharm", "eclipse+pydev", "spe", "vim", "emacs", "other"])` (edited to separate the lines, which was apparently confusing)
cool! thank you!
Sweet! Thank you
If you have web2py: &gt;&gt;&gt; from gluon.html import TAG &gt;&gt;&gt; html = "&lt;html&gt;&lt;p&gt;Para 1&lt;/p&gt;Para 2&lt;blockquote&gt;Quote 1&lt;/blockquote&gt;&lt;/html&gt;" &gt;&gt;&gt; text = TAG(html).flatten() Flatten takes arguments and can also convert to MARKMIN, MARKDOWN or other user-defined markup. Caveat: TAG(..) only works with well-formed UTF8 text. (EDIT: web2py uses HTMLParser and it inherits these limitations). BeautifulSoup is more forgiving and I believe it can guess the encoding. 
The unplugging anecdote is from 0:11:20 to 0:14:12 in the video
Static analysis for a heavily dynamic language like Python is incredibly tricky. PyCharm does a pretty good job, but there's really no substitute for actually running the code through a REPL like IPython and using the introspection features there if you need absolutely up-to-the-second semantic analysis. For large codebases, I've found the (very easy) setup/maintenance of PyCharm's cache to be worth it in order to gain access to its project features and refactoring. I didn't like the free IDEs as much, and I haven't tried the other commercial ones like Wing. For smaller stuff, I prefer Emacs with ipython.el/python-mode and heavy REPL usage.
Hmmm, I guess I'm confused on how to use this with individual tags. Here's my current code with "soup.text" implemented. for url in urls: current = urllib2.urlopen("http://" + url) soup = BeautifulSoup(current) soup.prettify() soup.text current2 = str(current.geturl()) title = str(soup.title) descrip = str(soup.find(attrs={"name":"description"})) keywords = str(soup.find(attrs={"name":"keywords"})) h1 = str(soup.h1) final = current2 + "*" + title + "*" + descrip + "*" + keywords + "*" + h1 savethefile.write(final + '\n') I'm still getting all the HTML tags in my output, so I'm definitely implementing it wrong. EDIT: deleted some of my newb code
I don't have much experience with it yet, but I think Spyder is worth a look. It takes advantage of python code analysis tools if you have them installed. 
You are right, BeautifulSoup have no problem with encoding, and all tags are parsed to unicode. So you can reencode in your application charset whenever you want. 
Sublime Text 2 is nice, wish I could find something that would debug properly and had tmTheme support.
Yes, someone on Reddit actually convinced me to switch to a more helpful server library. Maybe you could elaborate as to why Flask or SqlAlchemy are better?
Is it your first Web App ? * the good * You have split your code into function, so you can test your code. * the bad * You don't write test methods (unittest ) * You write your sql in your code and you don't let the driver bind the parameters =&gt; SQL Injection... * You don't use a framework, nowadays why writing a web application without a web framework ? * the ugly * read PEP 20, import are done in the wrong way (1. standard library, 2. reladed third party,... ) lines are too long, and you mixedCase * if you dont refactor your sql in an ORM, let your driver bind your parameter for sql injection, and extract your query ouside your function. This cur.execute("INSERT INTO stattrtbls VALUES ('%s', '%s', '%s', %s, %s, %s)" % (query_string['id'][0], query_string['activity'][0], query_string['descr'][0], officials, fieldstring, typestring)) Should be somethid like that INSERT_STATTRBLS = """INSERT INTO stattrtbls VALUES (%s, %s, %s, %s, %s, %s)""" #... cur.execute(INSERT_STATTRBLS, (query_string['id'][0], query_string['activity'][0], query_string['descr'][0], officials, fieldstring, typestring)) * Never write "select *" in sql production code cur.execute("SELECT * FROM pg_tables WHERE tablename='%s'" % query_string['id'][0]) Keep hacking !
Used to use Notepad++, but recently moved to Komodo Edit (not the IDE). Works fine for me, it's free, it has code hinting and auto completion, and it can pick up the semantics and hint packages and class elements. That's useful. It also handles projects nicely. All in all, I seem to be happy with it so far.
What does the plugin do?
herewegoagain
SyntaxError: invalid syntax
The 'text' attribute/function can work on any element. If you use str(soup.title) it will include the html tags but if you do soup.title.text it will give you just the text. Same with soup.body.text or any other element. 
I'm currently using http://pfaide.com/ In order to support the developer. Not sure if it has what you want, but the dev is active and open to suggestions.
That's what I thought. But, I tried it a couple of different ways and it gives me a UnicodeEncodeError on each of them. I tried it a couple of different ways in my code: * title = soup.title.text * title = str(soup.title.text) * final = current2 + "*" + soup.title.text * final = current2 + "*" + str(soup.title.text) All return UnicodeEncodeError now. Any insight into that? I took a look here - http://docs.python.org/howto/unicode.html - but wasn't sure how I would apply it to my code.
i thought ubuntu already came with python... just start typing up a .py file, then "python /wherever/whatever.py" should run it... though, i haven't touched my ubuntu installation in weeks, let alone python on it. also, as a tip, [Dive Into Python](http://diveintopython.org/) is a good way to start. also, the docs are the best i've seen of any language.
[PyScripter](http://code.google.com/p/pyscripter/). I use windows as my main OS, so that's what i script on. it's nice a featured, and if you hover over variables/objects, it tells you information about them.
I'd do it like most ORMs and form libraries: class User(Struct): name = Byte(32) password = Byte(32)
It's there by default in most Linux distro's.
I didn't see it on mine, searched the whole thing for just ".py" and only got the files that are in my 2.7.1 file. And Thanks, I'll look into that, I just started reading "How to Think Like a Computer Scientist: Learning with Python v2nd Edition" since that was on the python website for books. 
yeah, it's probably stuffed, figuratively hidden, in the computer. just try something like... print "THIS WORKS" raw_input() and see if that works. other than that, iunno. never had to install it on a linux machine.
&gt;"How to Think Like a Computer Scientist: Learning with Python v2nd Edition" That's a great resource. Also, launch gnome terminal and type python You should enter the interpreter, and get a prompt: &gt;&gt;&gt; If this happens, you have it (and trust me, you do have it). Ctrl-d to exit. HTTLACS covers the use of the interpreter. Mostly I code in vim. You can also sudo apt-get install idle for a great IDE.
Pretty.
I doubt the example is syntactically valid without parenthesis or escaping the linebreaks.
Yes, it is, which is why I'm glad to have the community keeping me in check.... Thanks for the help! I've had some severe trouble with SQL in particular, since the psycopg library doesn't seem to like my data structures (variable-length arrays in variable-width tables), and a big pile of my statements need to be %-formatted (or at least, that's what I think). I will look into SQLAlchemy, at least. Everyone seems to think I need a framework, so I may wind up doing that. I'll ask you, too: Why *should* I use a framework? Could you explain further how the imports are wrong?
PyCharm 
Yes, the why is an important part of the question. I was hoping there would be a clear winner, but it looks like everyone has their own favorite. At least I have a few more suggestions to try. 
That worked perfectly. Thank you.
No you don't sound retarded. It's counter-intuitive. Python is an interpreted language (like BASIC). To launch a terminal hit ctrl-f2, then type gnome-terminal, or go to Applications &gt; Accessories &gt; Terminal. That will launch a command line. Then type python And you be in business. You should eventually familiarize yourself with working at the command line, but if you prefer, gedit and idle will suffice for learning python. Read the beginning of How to Think... it explains all of this. It's easy after a few minutes of dinking around. If you begin to live at the command line you will find (after about a year), that it's hundreds of time more efficient. Don't want to sound like a retro-snob or anything, but it's true. The IDE (integrated development environment) and text editor path is a great option for you if you are more comfortable with the GUI. Also, eventually you're going to be amazed at how much of Ubuntu (and desktop Linux in general) relies on and is composed of python. the Linux system lives and breathes python. Have fun!
&gt; To me, compatibility with 2.7 would be much more important than numpy or scipy support. Fortunately, you can try PyPy with 2.7 compatibility today! Download one of the nightly builds: http://codespeak.net:8099/nightly/trunk/ These are automated builds from the development trunk, so treat them with some caution, but in practice they're generally stable. 2.7 compatibility will also be a feature of the upcoming 1.5 release. 
Why doubt? [Try it](http://pypi.python.org/pypi/pipe/1.3) and see!
http://buildbot.pypy.org/nightly/trunk/ is the official URL. codespeak's one works only by accident.
The download links don't work. It has "Pype" instead of "Pipe". I haven't tried it yet, but here it is: https://github.com/JulienPalard/Pipe/tarball/master EDIT: I just tried it out. It works as advertised. It uses a decorator class to overload "__ ror __". A slight caveat is that each line needs to end with "\" to allow for multi-line pipes. 
Good question. CPython does not evolve much over time though and 2.6 is ~20% faster than 2.4 (2.7 being the same as 2.6).
Editra (Not really an IDE though, but a great text editor with some IDE functionality)
Thanks a lot! I'm slowly getting the hang of this.
F# has an operator specifically for this |&gt; It would be good to have it in python instead of overriding the behaviour of an already existing operator.
This is one of those Python hacks that looks cool, but I will never actually use.
Yeah, ditto. :-)
I'm confused too. This seems very useful, more like the opposite of trolling.
Is there an elegant way of dealing with variable width fields using `ctypes`? Like if the length of a text string depended on a one byte integer stored right before it?
It's a good idea.
Doesn't install because the download links refers to 'Pype' on GitHub.
&gt; I don't have a "path" under that listing just add it man, this is basic (windows) computer stuff....
It is and the implementation is lightweight. The overloaded `|` operator is right-associative and one has to read the expression from right to left i.e. `| f` binds the expression to the left, not vice versa.
Change it to "Pipe"
Kill it with fire!
To add to what was already said, you *can* [add custom paths](http://stackoverflow.com/questions/4284767/add-the-current-project-to-the-python-path-with-komodo-edit/4290101#4290101) (where your custom modules live) to Komodo's intellisense system. 
WHAT is this ?
But then you'd need Python 3 (which lets metaclasses track assignment order) or make Byte instances have a serial number (so you can determine the order in the metaclass). tl;dr: order matters in C-level structures
&gt; Python 3 (which lets metaclasses track assignment order) What's that called? Never heard of that ability before.
Sort of... There's a piece of software called [LLVM - Low Level Virtual Machine](http://llvm.org/). The idea behind this... framework was to allow projects to build on it, compile different source code (i.e. C) into new instructions for this minimal "virtual machine". By having this virtual machine (a program) execute the LLVM instructions (another program) it can understand the code and know/understand things that traditional compiled source code can not, and with that knowledge it can do different things to speed it up, techniques including JIT. [Unladen Swallow](http://en.wikipedia.org/wiki/Unladen_Swallow) was a project to port CPython to this new "virtual machine", using the LLVM framework, which would allow the underlying virtual machine to introspect the code and implement techniques to make it faster. Unfortunately, Unladen Swallow ended up [not achieving its goals](http://qinsb.blogspot.com/2011/03/unladen-swallow-retrospective.html). PyPy, on the other hand, is another system like LLVM. It has it's own instruction set, it's own techniques for speeding up code that runs on it and instead of compiling C code it compiles code written in RPython. The PyPy Python interpreter is a Python interpreter written in RPython. This code runs on the PyPy VM. You can write an interpreter for any language in RPython and have it run on the PyPy VM, JIT and all.
I used to use **Kate** (a free text editor for Linux/KDE) until I decided I want an IDE instead. I picked up **Komodo Edit**, liked it and paid for the IDE license. Now I use **pyCharm**. The reason I switched is that Komodo has no automated refactoring tools ("extract method" and "rename variable" saves me a lot of typing). The biggest drawback with pyCharm so far has been that I can't figure out how to make it behave more like other IDEs when it comes to editing and saving files (there appears to be no easy way to discard all changes in a single file or to save a single file or to "save as" -- maybe I wasn't looking in the right places). It's pretty neat if you work on projects. It's not so great if you work with individual files. It does come with lots of debugging and server control stuff I haven't had the time to look into yet, however. A big advantage of Komodo is that it supports various languages, so if you are looking for something you can use for PHP and Python at the same time, look no further. I decided to buy phpStorm to complement pyCharm for PHP and more "lightweight" web development, but it's a shame the two can't be integrated although they are both based on the same IntelliJ codebase. I gave **PyDev** (Eclipse) a try, but discarded it quite quickly. If you also do a lot of Ruby coding with Aptana or use Eclipse for Java, you may like it, but to me Eclipse just instantly feels bloated and it just didn't feel right at all. You don't need an IDE, strictly speaking. Kate/**Gedit** (Linux), **TextMate** (MacOSX) or **Notepad++** (Windows) should do the trick. If you find that you want a little more power and language integration than syntax highlighting, auto-indentation and code folding can give you, just try a few and find out which one you like best, personally. Komodo has a free (as in speech) version which comes with most of the features of the commercial version (some examples for what's missing: VCS integration (git, mercurial, etc) and debugging). Most commercial IDEs offer trial versions that give you enough time to take them for a ride (iff you actually spend most of your day working with them). Of course there's also **Eric**, which is open source and ridiculously powerful but has a learning curve you may find prohibitive (I certainly did).
Yeah, I've played around with creating this kind of thing on my own machine for utility function stuff (clipboard manipulation, process launching, ...), but I basically never use it.
PyPy's design automates much of the work in getting the different backends. It is a much more powerful technique than Unladen Swallow, that is why everyone is surprised it got so fast so quickly.
I've found that vim and textmate are both great for raw text editor coding (vim has some nice intellisense type features that can be very smart...). I find that most of the time IDE's can't be very smart with python because they have no type information to go off of. I get around this by using bpython side by side with a standard text editor. I create the objects in bpython and use that completion then copy my code back to the text editor. PyCharm is probably the smartest IDE I've used, it's python completion is top notch and it's refactoring/import handling is very very nice. 
and my vote places vim on top of emacs.
Use [HTMLParser](http://docs.python.org/library/htmlparser.html) in the stdlib: &gt;&gt;&gt; from HTMLParser import HTMLParser &gt;&gt;&gt; class StripTags(HTMLParser): ... def handle_data(self, data): ... #store it somewhere... ... print data ... &gt;&gt;&gt; st = StripTags() &gt;&gt;&gt; st.feed("&lt;html&gt;&lt;p&gt;Para 1&lt;p&gt;Para 2&lt;blockquote&gt;Quote 1&lt;blockquote&gt;Quote 2") Para 1 Para 2 Quote 1 Quote 2
Screen + Vim
Metaclasses in Python3 can have a magic method \_\_prepare\_\_ which is called to create the class dictionary. The body of the class definition is then executed in the scope of this dictionary. If you have \_\_prepare\_\_ return an ordered dictionary (e.g. collections.odict) then you can easily track the assignment order in the class body. All the gory details are in [PEP 3115](http://www.python.org/dev/peps/pep-3115/)
Thanks! Metaclasses are still pretty much magic to me.
Thanks! Metaclasses are still pretty much magic to me.
tmux + vim
you might find this interesting [PyCon 2011 IDEs Panel](http://blip.tv/file/4883406)
Fooking awesome. I'll be daring enough to use this in production code.
It does look pretty nifty, but at the risk of sounding horribly condescending, when I want Haskell-like syntax, I'll just Haskell.
Hrmmm..... tmux you say.....
committed. thank you!
Emacs is amazing for python(with the proper .emacs file)! http://www.emacswiki.org/emacs/PythonProgrammingInEmacs http://python.about.com/b/2007/09/24/emacs-tips-for-python-programmers.htm
Just to support the other suggestions here saying to use a proper HTML parser. This is because a regex approach won't know how to deal with input like, &lt;h1&gt;&lt;!-- &lt;/h1 --&gt;The H1 of the page&lt;/h1&gt;
&gt; At least we got the weekly IDE thread out of the way early. yep, who wants to post the "what web framework should I use" thread, so we can all go home early. 
[indeed](http://tmux.sourceforge.net/)
As others have pointed out, it looks like the pypi link is broken for the moment. You can download directly with pip using pip install git+https://github.com/JulienPalard/Pipe.git
**gvim** for scripting (I would use vim but I like the bigger color support gvim has for fancy easy on the eyes syntax highlighting). **pydev/eclipse** for programming
I like that a lot better than wrapping a generator around another generator.
there's an up vote for someone using this with Hadoop :)
That would work better as: pip install -e git+https://github.com/JulienPalard/Pipe.git#egg=pipe 
Dive Into Python is a good way to start if you're already a programmer coming from let's say Java or C++. You may want to give [Learn Python the Heard Way](http://learnpythonthehardway.org/index) a try instead. It's aimed at a beginner level. edit: duh, not the same author, correction
Their prices are great and I also very much don't mind no support, given how I never use that option. I need to migrate my server from slicehost to prgmr I am just too lazy.. Can you suggest a good DNS host? edit: I really like slicehost's service $ uptime 03:22:46 up 775 days, 3:07, 3 users, load average: 0.09, 0.12, 0.07 It's just that I can get a far bigger slice from prgmr for the same price.
Is "infix syntax" the right term for this? I thought "infix syntax" meant the position of + in the expression "1 + 2".
&gt; but it's a shame the two can't be integrated although they are both based on the same IntelliJ codebase. I think that if you buy IDEA you get all the plugins (python, php, ruby, ..) for free. Of course that $249.
Too bad there is no way to use numpy with it yet. So its not useful for most scientific projects.
How would you do this? class Users(Struc): User.users[666] Hint: User(666) is an instance 
Why? don't you like haskell-ish features in other languages?
Contrast filter(lambda x: x%2==0, [1,2,3]) [1,2,3] | where(lambda x: x%2==0) Instead of having the params after the function, you sandwich the function between its parameters. That's what "infix" means. This is anifty syntax boost for Python, but it's infix powers are limited: the catch is that the "left-side" parameter always has to be iterable.
You are welcome. Good luck with your project. :-)
And it's powered by Django.
It's powered by OSQA and LBForm, they are powered by Django.
The way flatland does that is ``User.using(overrides...)`` to create new classes.
``ast.parse()`` and ``inspect.getsource()``? ;) OK not serious.
Meh, why go to all that trouble when you can just use sys.settrace()? ;-) 
Generally speaking, Python is not well suited to real time multimedia processing. It can be on the order of 10-50x slower than Java depending on the task. There's always ways around this, but they require a lot more work than simply scripting things naively in pure Python. If you want to learn Python, I suggest you move towards tasks that don't involve lots of real time number crunching, that's not a task Python is well suited for.
Ok but first I want to get that app done that is analyzing the audio. Can you recommend any other easy language to do this (apart from java)?
and when you want OO, you just use Smalltalk, i presume.
Not true. Using numpy and the other tools python has for numerical processing, it is an excellent tools for multimedia processing. While it's not quite multimedia, I develop scientific data acquisition and processing application working an psuedo-realtime with an average samping rate of ~ 1MS/s. I expect no more than 20% CPU load on this data stream for the acquisition (although the DSP work can be higher). I think PyAudio will provide data in chunks (frames?). Looking at the PyAudio API, it is a shame it doesn't provide a means to read the data directly into a buffer object. Seems like you need to get the data as a python string, which you'd need to copy into a numpy array for further work (a bit wasteful). Even so, you should still be able to handle 44.1KS/s easy.
Pyscripter is nice, just don't us it for programming OpenGL. It slows to a crawl every time typing occurs.
I'm going to be a little unhelpful, but I would say that C is easy and extremely fast. Its just not as expressive as Python. The fight for your particular use case is really between expressiveness and speed at byte-level operations on large streaming data sets. The sweet spot to me would be python with some functions written C using the FFI (foreign function interface). High level stuff is python, but sample-analysis functions in C. Now, I *believe* this is what PyAudio provides, but I've never used it. I'd look at the documentation, tutorials especially. My guess is that you did some sort of list operation on a PyAudio C-language data structure and PyAudio happily let you copy and wrap every little byte in your 100 MiB data set in a python list, or something like that. My guess is that there is a PyAudio way to do what you want to do.
**Why**: amazingly configurable. large number of available libs/scripts to make it do what ever you want it to. For example, I've recently integrated a mumamo mode for mako templates, so I get syntax highlighting, code completion and on the fly error checking for python, html, css and javascript all in the one buffer. Also, things like yasnippet for quickly dropping boilerplate code into your files. The learning curve is high, but if you can surmount it, it's a bit like what I imagine it would feel like if gandalf were a programmer.... magic. 
It's funny. I can't understand the written language, but I could understand their code.
What you need is Cython. You start with a pure python function. Cython compiles this to a C-module using the python API (it usually gives a modest speed up). Then you add C-style type declarations and Cython knows how to compile this to efficient and fast C, to get &gt;100x speedups. Write C-modules using Cython is much less of a mental gear-change coming from pure python, compared to writing in C. The other really cool thing is you can make C Extension classes (python builtin types) really easily. These let you use OOP style design and benefit from python memory management while still getting the speed of C. And interfacing with numpy arrays is a cinch.
You don't need fancy machinery for it. Django's declarative metaclass cooperatively tracks the order the ordered members are instantiated, storing the resulting ordering internally. Caveats apply: the members must be instantiated once per declarative class and not reused out of order.
All the features you mentioned are extremely buggy in my experience. Also as someone who's fluent in emacs lisp, I can assure you I feel nothing like Gandalf and that no level of proficiency causes emacs to cease being frustrating.
What can I say... we have different experiences of emacs then. I personally find it awesome, and find it much less frustrating than vi.... then again, I used an editor called `joe` for years, so emacs just felt like a natural progression to me when I picked it up. For anyone who is used to key-chords (Ctrl-something something) over command codes like vi uses, I suspect this would be the case.
They're not by the same author.
Our experiences are probably the same, I'm probably just more jaded than you after having put up with emacs' nonsense for a decade. For instance I agree that emacs is the lesser of the evils and I also have a strong personal preference for chording, but to be honest though the only feature that really keeps me with emacs is [Ido](http://www.emacswiki.org/emacs/InteractivelyDoThings) because it makes jumping through files so quick and easy. The closest thing I've ever found to it in another editor is TextMate's Command-T buffer switching feature, which is rather shoddy by comparison.
Putting my enthusiasm for Cython aside, I think what I probably should have asked was - what sort of analysis do you want to do? Using Cython or C is almost certainly a premature optimisation. numpy has a lot of functionality out-the-box (FFTs, linear algebra, advanced array indexing ops). scipy has a dedicated packages for signal processing (http://docs.scipy.org/doc/scipy/reference/). There are many other packages available for machine-learning, optimisation, wavelet analysis. There's rarely any need to roll your own. My guess is that numpy is all you need.
I've never had it slow... then again, i've never wrote with opengl :P
This is what I meant by 'more work'. Of course it's possible, just not trivial.
It's all about Python in Chinese.
Ah, true, but phpStorm and pyCharm are already € 88 each, so the difference isn't that big.
http://pycon.blip.tv/posts?view=archive&amp;nsfw=dc&amp;
I doubt it's valid *with* parentheses. How can he wrap the function when he calls it? EDIT: Oh, wait. He decorated the functions to do that, didn't he...
Rackspace Cloud. $11/month
ep.io Da bomb. 
I realize you have narrowed your decision but in case you overlooked web2py I'd like to mention that it would be quit suitable for the project you describe. It's considerably easier to get started with than django and includes much more (optional) functionality than flask (user auth, uploads, etc).
Here is a complete list on a single page (2009-2011) http://rbw.goe.net/pycon/
&gt; I know psycopg2 handles most of the SQL injections, but I have to circumvent some of the psycopg2 niceties in order to get some things to work with the database. I saw that you use the "%" Snytax to concatenate dynamic Parameters with a query-String. In the DB 2.0 API from Python there is a recommended way, that all DB-Libs should support a secure replacement via placeholders. Example for sqlite3: cursor.execut(r'select foo from bar where data like ? and id=?', ("hello", 42)) Whether the DP-lib uses "?" or some other syntax depends on the used database. So you must look in the documentation. Using this idiom SQL-Injection is neraly impossible! &gt; As a side question, what makes flask better than gevent, and what makes flask better than other frameworks? gevent, as far as I understood what it does after reading the introduction, is rather a server component but a webframework. So you can't reallay compare both ones. If flask is "better" than another one is hard to tell, as you don't give us a metric for "better" ;-) I like flask, because of the good documentation, the usage of two libs I used before (werkzeug and jinja2) and the good API desgin. Other frameworks might be good as well. You have to take a look and see yourself. I had the impression, that your app does not use much administration tools, for which django is famous. So I think flask offers all you need. (flask includes session management, which other mico webframeworks do not) The jinja2 template engine ist also quite similar to django's. In fact the author liked the django template engine much and tried to improove it, so jinja was born. 
IIRC Ubuntu 10.10 comes with Python 2.6 by default. You may want to install Python 2.7 (luckily it's in the repository as of Ubuntu 10.10). You'll also want to install pip/distribute and virtualenv. [Here's how.](http://pypi.python.org/pypi/distribute#distribute-setup-py) Virtualenv will help you working with versions of Python that are not the OS default and avoiding version conflicts between various packages you may need as you dive deeper into existing applications. Pip is the easiest way to install packages from PyPI, which you'll do a lot. Whenever a tutorial tells you to run `easy_install &lt;package-name&gt;` substitute that with `pip install &lt;package-name&gt;`. You'll also need the Ubuntu package `build-essential` if you want to install Python packages that need C-extensions (e.g. cryptographic libraries and such). You can install that via `apt-get` (also install the `-dev` packages of the Python versions you want to use, e.g. `python-dev` for the OS default and `python2.7-dev` for the 2.7 version).
 fib() | take_while(lambda x: x &lt; 1000000) | where(lambda x: x % 2) | select(lambda x: x * x) | sum() In Haskell: fib = sum . map (^2) . filter odd . takeWhile (&lt;1000000) Or with a list comprehension: fib = sum [ x*x | x &lt;- [0..1000000], odd x ] or: fib = sum $ map (^2) [1,3..1000000] 
Why not use Haskell?
 pip install pipe seems to be working now, looks like the download issue is fixed.
Ok :) I am not a postgres user, so i can't help you about this, but i am pretty sure the driver can do that. &gt; Everyone seems to think I need a framework, so I may wind up doing that. I'll ask you, too: Why should I use a framework? Because it will help you to structure your code, and secure it. And more you will write less code for the same functionnality, and it's will be most readable and less buggy. &gt; Could you explain further how the imports are wrong? From the pep 8 Imports should be grouped in the following order: 1. standard library imports 2. related third party imports 3. local application/library specific imports So from gevent import wsgi import psycopg2 import psycopg2.extras import json import urlparse import hashlib import random import os import sys should be: import os import sys import json import urlparse import hashlib import random import psycopg2 import psycopg2.extras from gevent import wsgi 
What I want to do is: My amp sends the IR signals that it receives from the remote to an output. From there I can easily capture it with my soundcard and analyse the signal to know which button was pressed (to trigger "next" or "pause" on my mpd). So it is just an issue of counting pulses; nothing too heavy. But if I just check for each sample whether it is above a certain value (to check if there are any signals at all, without wanting to analyse anything yet) PyAudio already gives me "warning: dropped frame" because the code does not get past the incomming samples. [Here is my code](http://ideone.com/8aMQA)
Yes, I considered using C, also because PyAudio is based on PortAudio which is a C library. But I don't know C. I have nothing against C and nothing against learning C. But not now. At the moment I have more important things to do than lerning C and I don't want to learn C for this little app.
Sounds interesting. But sounds too like it would be nearly the same effort as learning some C.
You're not the first one asking this question here (if you search you'll find at least three other threads). Anyhow, the short answer is: *Python 3 where/if you can, Python 2 where you still must*. Here are links that might help you * http://wiki.python.org/moin/Python2orPython3 * http://www.markus-gattol.name/ws/python.html 
I would say figure out what you want to learn most, find the right python library that covers that topic, and learn whatever the latest version is that your library supports. For a quick example, someone asked about being able to create graphics one pixel at a time, and a lot of people suggested pygame. pygame currently only supports python 2.5 (I think).
actually i am not so sure about what i want to learn. but i may that say since i know and use cpp for daily use. i'd consider using python in web development. but before searching the right library for my purpose, i think it will be good to learn the basics of python. i skimmed through some python 3 documents yesterday and especially after tough days of struggling in cpp it seemed very easy to me. i've read the first wiki @markusgattol posted above and i think i see the point. find out what you wanna do and dig into it. but don't forget 2.x wont last forever, keep 3.x in your pocket too.
they are very similar; don't worry about this too much. start with 3 and if you need to switch to 2 because some 3rd party code isn't available, it's very easy to do.
Be sure to specify which version you are using in every script. #!/usr/bin/env python3 There's mine opinion.
thanks for the advice. but im coding in windows right now and that is not necessary in it.
This is not going to answer your question, but it is a great resource to learn Python: http://www.youtube.com/watch?v=tKTZoB2Vjuk
The way functional programming is implemented in Python is not pythonic enough in my opinion. Even Guido is not happy with the way functional programming paradigm turned out in Python. In a recent PyCon talk when asked about which feature he wished he opposed. He mentioned the functional programming patch that introduced FP to Python. As to your other point, OO is a first rate citizen in Python. For one everything in Python is an object to begin with.
It certainly helps to know a little C. Cython allows you to move seamlessly from python-semantics to C-semantics. I guess if you've never used C before, I'd recommend learning this first. The point about Cython is that as soon as you try to *do* anything with it, it becomes easier than straight C because you can write all your code as python, then add Cython type declarations to speed up the performance critical sections (loops). Writing python compiled extension modules in vanilla C involves a certain amount of boiler-plate which Cython generate automatically.
There are about four million modules/libraries out there that only support Python 2. Various web hosts only have Python 2 installed. Google app engine only supports Python 2, etc. I believe Python 2 would be vastly more useful for 99.99% of everyone than Python 3, at the moment; Python 3 is not that different, and it can easily be picked up later if you need it / when third party support increases. Most of the books out there are about Python 2, also. You're just giving yourself a headache if you start with 3. You can look up "what's new in 3.x" after you learn 2. I think that would be the best way to go. That being said, they're so similar, it doesn't really matter, you'll be able to use either. You *will* be using 2 in practice, though, just due to the number of useful 2.x only modules out there, at least in my opinion.
This is an easy numpy task. Here's an example: import pyaudio import wave import sys import numpy chunk = 1024 FORMAT = pyaudio.paInt16 CHANNELS = 1 RATE = 44100 RECORD_SECONDS = 5 WAVE_OUTPUT_FILENAME = "output.wav" p = pyaudio.PyAudio() stream = p.open(format = FORMAT, channels = CHANNELS, rate = RATE, input = True, frames_per_buffer = chunk) for i in range(0, RATE / chunk * RECORD_SECONDS): data_str = stream.read(chunk) data = numpy.fromstring(data_str, dtype=numpy.uint16) #find the mean level, to use as a threshold threshold = data.mean() #find where the data exceeds the threshold segmented = data &gt; threshold #calculate the differences steps = segmented[1:] - segmented[:-1] # get only the positive steps pos_steps = steps&gt;0 #count them count = pos_steps.sum() print count stream.close() p.terminate() print "END" This is a modification of one of the PyAudio examples. It runs using about &lt;20% of my CPU on my five-year-old Athlon64 (if I comment out the print statement: a scrolling console uses more CPU!). It's a bit more work to carry values or counts across the chunk boundaries. Pythons "generators" are a great feature for processing data streams BTW.
&gt; Python 3 is not that different, and it can easily be picked up later if you need it / when third party support increases. I think this is more a reason to use Python3 then to Python2. My reason for saying that is that Python3 is the future and when you start learning you are not dependant on the use libraries. It is better to learn the future and get irritated with the past then to learn the past and get irritated with the future. Then you'll just get left behind when the switch comes.
And to be sure, even if you learn Python3 writing something in Py2 won't be a stretch for you. Just an occasional hiccup that will quickly be shown, and some library changes. (For practicalities sake)
Generally, using cython is much, much less effort, especially if you already have the function written in python (then you just slap some type identifiers on, and you're golden).
&gt; Even Python standard library is poorly documented and sets a very bad example (missing manual ???) A bunch of people have said this, but few have actually backed it up. Where exactly is the documentation *poor*? We know the standard library documentation often lacks examples, so it's less helpful to some levels of newcomers, but it usually is not missing much in terms of API coverage. Sure, here and there functions appear that aren't documented, and that sucks. A lot of the documentation bug reports tend to be trivial things like highlighting, linking, formatting, etc., not so much of "this entire class is undocumented". Overall, I wouldn't say it's poorly documented, but I would say it's poorly targeted in some areas. It really needs more example snippets, and it would be great to see users chip in samples. Doug Hellman's PyMOTW fills a lot of the example void, and there was some discussion about linking or including his work in some way, but I'm not sure how far that got. &gt; Should Python community stop in some point to focus on delivering better documentation instead of focusing on new features and goodies (like the syntax moratorium which was recently lifted)? One of my broad targets for 3.3 work is improving documentation of things that I know pretty well, including examples. However, that's not really as fun as stuff like trying to speed up interpreter startup, so documentation isn't on the front of my mind. Most others tend to operate the same way, but it seems more of us are thinking about the state of the docs than may have been the case in the past, so there might be some improvements on the way. If people are interested in contributing to the documentation, you would certainly be welcomed because we need more help.
 | take_while(lambda x: x &lt; 4000000) ^ IndentationError: unexpected indent And? I'm kinda pissed that donri was at -3 at the moment, and your wise-ass comment was at +6. "Try it and see", my arse.
Python3 cleans up many inconsistencies in the language and the standard libraries, so it should be easier to learn. You can always read up on the tiny differences in python2 if you ever need to use a library that is not ported to 3 yet (and it might be by the time you get there!).
I'd love for 2.x to go away so I could just learn 3.x and get on with my life. Unfortunately, there are way too many packages that aren't compatible with 3.x and don't look like they are going to be compatible any time soon. I think 2.x is going to be around for a looong time.
&gt; you'll find at least three other threads three hundred
&gt; not necessary ORLY...the point is to give an indication **"which version you are using"**
Guido is not happy with the current situation of functional programming in python. So what? In my view, this library is an improvement of the current situation that we should constructively support. Citing Haskell doesn't help. I like the idea of functional programming but i am just not seduced by Haskell. I therefore welcome this addition to python.
I was thinking of replacing my shells with Python. I guess I'm on the right track.
&gt; Should Python community stop in some point to focus on delivering better documentation instead of focusing on new features and goodies...? Yes. (ish) &gt; I believe the success of Django was mostly driven by its good documentation. Ditto.
How does this compare with method chaining?
Here is the funny thing: one can read/write Chinese, read/write Kanji or Hanja, one can speak Mandarin or Catonese, but really, no one *speaks* Chinese. Chinese means the written language.
Emacs Lisp: (loop for x from 1 to 100 when (oddp x) sum (* x x)) 
Where's your "fib = ", cheater? :-) EDIT: And 1000000, not 100...
I would actually recommend this to beginners, it does look cool and makes code readability easier.
I just ran this several times in ipython for fun . . .
Thanks a lot!
The SQL stuff, I know, it's messed up. I had to use the % syntax to replace things because I have variable length tables, sometimes, which means I can't pass it a finite, exact number of (%s %s %s), because I have no idea how many columns there are. Hm, maybe I should use dictionaries? OK, now I can start. But I'm not so sure I need Alchemy for that....I guess we'll see. Frameworks sound cool, so I'll look into those later in the week. Flask, especially, looks like fun--and you're right, my site almost looks like their home page :P Your help has been much appreciated, my friend. Thanks.
This is a lot of Java programmers flailing in Python land again. Yep, dynamically typed programming is different. Yep, you're going to have a hard time coming from years of statically typed dogma. Nope, we're not going to change everything for you to help that.
3
http://npppythonscript.sourceforge.net/
My vote would be for 2.x, a lot of stuff out there is written for 2.x and while the differences between 2.x and 3 are minimal, there are some things that might be frustrating while you're starting out if you're following a resource written for 2.x. Once you're familiar with 2.x moving to 3.x would be a breeze. Really though, it doesn't matter that much. Also, for future reference, [/r/learnpython](http://www.reddit.com/r/learnpython).
Thanks a lot for this example. It seems like if you are just using the builtin tools of Python it gets a lot better. But as soon as I use my own stuff and start iterating over "data" it gets unusable and drops frames. Also the 20% of CPU are still way too much for just a simple daemon running in the background. Your version was by the way better than mine because in the line: data = numpy.fromstring(data_str, dtype=numpy.uint16) you use a uint16 and not a int16 like me (it took me about half an our to find the difference). uint is a lot faster but unfortunately gives rubbish numbers for me. I think in the end I am going for C; Python was just the wrong choice. But thanks a lot for all the advice!
the .text is in the wrong place. &gt;&gt;&gt; from BeautifulSoup import BeautifulSoup &gt;&gt;&gt; import urllib2 &gt;&gt;&gt; urls = ['slashdot.org'] &gt;&gt;&gt; for url in urls: ... current = urllib2.urlopen('http://' + url) ... soup = BeautifulSoup(current) ... title = soup.title ... &gt;&gt;&gt; title &lt;title&gt;Slashdot: News for nerds, stuff that matters&lt;/title&gt; &gt;&gt;&gt; title.text u'Slashdot: News for nerds, stuff that matters' thus: for url in urls: current = urllib2.urlopen("http://" + url) soup = BeautifulSoup(current) soup.prettify() current2 = current.geturl() title = soup.title.text descrip = soup.find(attrs={"name":"description"}).text keywords = soup.find(attrs={"name":"keywords"}).text h1 = soup.h1.text final = '*'.join([current2, title, descrip, keywords, h1]) savethefile.write(final + '\n') 
netbeans 
I could be mistaken, but I think the DJing talk was censored due to "objectionable content", although maybe Jesse Noller or Van Lindberg could comment.
Python 2.7 -- it will be in use for 2+ years imo
&gt; Because of duck-typing, you should rigorously document how methods should be called I'm fairly certain you should rigorously document how methods should be called anyway. Static-typing does not magically make an API transparent and clear.
Either one, they are similar enough to one another. If you have a particular library you need, learn the version that the library supports.
Whilst you are as unfocused as you seem to be, I think it would be good for you to learn that version of Python in which they have taken pains to remove more m mistakes and blind-alleys. Learn the latest version i.e. Python 3.2, moving to Python 2.x if you later find you must, should be a breeze! 
That might be the reason I couldn't find it anywhere. Thanks for the info. 
gvim, idle, vim most of the time.
terminator + vim :)
I've got my domains registered on godaddy and they have a complimentary dns service (as do most of the major registrars), so I just need to enter my prgmr vps ip and it's all set.
Pygame is definitely not only on 2.5... I'm running it on 2.7. And according to their [FAQ](http://pygame.org/wiki/FrequentlyAskedQuestions#Does%20Pygame%20work%20with%20Python%203?), it builds on Python3 (although possibly not all libraries are ported) 
Does unicode matter to you (your code)? Will you have any dependencies on other modules?
I'd pick what resources you want to use to learn python (a book, web tutorial, or whtaever) and use whatever version of Python they use. Which will almost certainly be python2. Make an effort to find good learning materials, whatever methods they use. Don't make hay out of a non-issue... just have fun! Really, the differences between the languages are trivial from a programmer's perspective except for the fact that they break backwards compatibility. You will not be intellectually challenged by the fact that print requires parentheses in python3 but not python2. Most of the features currently available in python3 have been backported to 2.7 (e.g., dictionary comprehensions). We'll all be moving into python3 in time, but after working for years in Python2, I'm not going to have to buy a textbook or anything to learn Python3, there's just a couple nitpicky things to keep in mind.
That's only necessary when the contents are ambiguous. Leaving out the #egg... installs the module correctly. However, in general, you are correct.
Hmmm... I just looked this up last week. Now I'm confused. I'll take a look again, though. Thanks.
Please read the python-dev thread: http://mail.python.org/pipermail/python-dev/2011-March/110215.html
www...what !?
&gt; IMHO Python's official documentation is *absolutely* the best documentation comparing to other language's. I like Python as much as the next guy, but that's just incorrect. The Python docs at python.org are certainly quite good, but the ones I get from using `help(foo)` at the REPL are completely lacking. Just compare them to what you get in Perl 5. Now, I much prefer Python to Perl these days, but give credit where credit is due -- at the command line I can run `perldoc foo` and get really excellent documentation on any function or topic. And the Perl doc pages usually even come with a synopsis (examples) at the top, so I can immediately see the most common usage in action and don't have to pore through the whole doc to figure out what I want. 
Oh yeah and it's got command line (using argparse) and web service (using bottle) interfaces, and it returns a ZIP of the conversion. The main website is at http://docvert.com/
Wierd that int16 is so much slower than uint16. I don't understand that. Anywhere you are iterating over the data value-by-value in a python for-loop will indeed be slow. If numpy vector operations (i.e. looping in C) can't do what you want, then its time for Cython... I just realised if you use numpy.frombuffer instead of fromstring, you get an array which shares the same memory as the input string: no data copy. If you use Cython to iterate over the array, you'll get C-speed. This way to can use python to set up the IO (see the PortAudio C examples to get an idea of how much more hassle this is to do in C compared to python) but scan the data in a compiled Cython function for minimal interpreter overhead.
That's one thing that has grated me with Java and Python3: the assumption that, once you have unicode strings and use them as the default, you can simply do away with byte strings and/or stop worrying about encodings. Considering that people who can change the default encoding can also change other things like LD_PRELOAD, LD_LIBRARY_PATH, PYTHONPATH and friends, the security problem is not as big as it seems to be, but given that encoding settings would be treated as both important and non-harmful (i.e., the user wants his favorite encoding to be used, even for SUID or other programs), it is indeed something to consider. 
Who said anything about fancy machinery? I just said, "or make Byte instances have a serial number".
Wise-ass? Dude, chill out. It's ridiculous to complain about something without trying it first. You tried it and it didn't work? Good on you. Give the creator some feedback to help them out.
Sadly I found another reason to stay at 2.7. Being 2.7 at the end of the 2.x branch, and frankly not having any super cool reason to move to 3.x, 2.x warranties my code will work for a while. As in the 2.7 release notes: good release for the long term Well, I bet I'll move when my favorites packages don't release for 2.7 anymore 
Oh you're right. I've been using slicehost's DNS but I could go back to godaddy's for this, forgot it was complementary. Thanks!
*(Not related to the post, but to PEP-383...)* Eugh. Having invalid strings running around your program is just ... nasty.
&gt; Wise-ass? Dude, chill out. It's ridiculous to complain about something without trying it first. It is ridiculous to ask the guy to try it without trying it yourself first. Because when you roll like this, you give a distinct impression that you did check it out, and now are teaching him a lesson. Which turns out to be wrong. And the way your comment lead to drones downvoting the guy who was absolutely correct, without even trying it out, and upvoting your snarky comment, is disheartening. I thought that in this small subreddit we can have people interested in the subject, genuinely interested in understanding Python, or finding useful libraries, or understanding how they work. Nah, it's the same stupid shit, as it turns out. &gt; You tried it and it didn't work? Good on you. Give the creator some feedback to help them out. GET. THE FUCK. OUT. You don't belong here. You don't know the basics of Python. Why are you here? Get the fuck out.
Whoa. If you calm down I'd be happy to continue this discussion and try to understand where you're coming from, but the amount of hostility you're displaying isn't conducive to any of the things you say that you want this subreddit to be.
matelot, Not sure if you're genuinely asking that, but what lambdaq is saying is pedantic but correct. Written Chinese is distinct from the spoken language as it's character based, so the site is really for readers of Chinese rather than speakers. As an example Cantonese Chinese has similarities to Mandarin Chinese (the "official" Chinese) and while they are essentially different languages both use the same written characters.
Cannot upvote BeautifulSoup enough. I had to write a web-crawler for mining data, and this package saved me so much time and effort. 
This looks like a cool idea. A mobile app for Android/iPhone would really compliment your web-app. I'd be happy to lend my skills if you are interested. 
I want this subreddit to consist of people who know Python and exchange useful information about it. You don't know Python. You don't belong here. Get the fuck out. What's so hard to understand about it?
If you want to write a mobile app that queries the server, sure! I wouldn't start too soon, though, my API is bound to change when I switch to a framework....but I'll keep you posted.
Using Celery for sync tasks kind of defeats the point. It only supports this for testing and rare special cases. If you need the results of one task passed in to the next, send the first task a callback which launches the second task.
That's what I thought, but I've been doubting myself on this particular issue since I'm new to celery. I hadn't thought of chaining the celery tasks though, that sounds like a great idea. Thanks for the comment. 
Thanks a lot! I'm just learning python though, so do you think I really need to install 2.7 or would 2.6 suffice until I become more educated with python?
I learned 3 and then picked up 2. I think that that is probably the best way to go. Plus, I think Dive Into Python 3 (http://diveintopython3.org/) is one of the best ways to learn Python. 
&gt; In addition, is there any particular reason why he's setting object = object like below? &gt; &gt; def calculate_z(x, y): &gt; x = x &gt; y = y &gt; z = x - y &gt; return z I've never seen that before, and I can't think of a good reason for it.
To be blunt, he doesn't know what he's talking about. Celery gives no benefits for syncronous tasks like what you're describing. An "x = x" like in the code you showed does literally nothing but waste a few CPU cycles. My guess is that he thinks he's creating a new "x" variable inside the calculate_z() function so as not to change the calling code's value for its "x" variable. He's not. The "x = x" won't change whether his actions in the function have such side-effects.
Maybe I don't understand haskell syntax from what little I know of it but your examples are assigning something to fib, not actually generating anything. The pipe example is using a fib generator taking numbers less than 1000000 which are even then squaring them, then computing the sum of the list. It seems you are just summing all squares of even numbers under 1000000.
&gt; Written Chinese is distinct from the spoken language as it's character based I tried but still no idea what you're talking about there &gt; essentially different languages.. same language.....dialects, different DIALECTS !!!!!!!!!!!!! 
&gt; My guess is that he thinks he's creating a new "x" variable Maybe it's some badly refactored code that was previously doing self.x = x and he removed references to self.
&gt; is there any particular reason why he's ___ Protip: ask **him**! And at least pretend to ask in a sincerely interested way (rather than condemning or doubtful). But yes, that baffles me too.
Bluntness appreciated ;) Follow-up question: We need to start another .py which loops forever (independently of parent script). I figured subprocess could handle that but it seems his fancy for celery had him put a subprocess call within a celery task. Wouldn't it make more sense to either call the subprocess directly, or have the celery task run the loop (import looper_stuff)? That loop has a bunch of db read/writes though, and he said something to the effect of db access being bad in a celery task, and I seem to remember reading that the celery task should be light-weight (which makes sense if you're trying to distribute the workload to many cpus). On a single cpu though, it seems that an asynchronous call to a celery task which imports the looper_stuff.py would be an acceptable alternative to subprocessing the python script. 
From Wikipedia: "There is no universally accepted criterion for distinguishing a language from a dialect. A number of rough measures exist, sometimes leading to contradictory results. Some linguists[3] do not differentiate between languages and dialects, i.e. languages are dialects and vice versa. The distinction is therefore subjective and depends on the user's frame of reference." http://en.wikipedia.org/wiki/Dialect So if you prefer and it makes you happy: Dialect it is. While you're checking my wikipedia reference take a peek at: http://en.wikipedia.org/wiki/Written_Chinese
[This post](http://mail.python.org/pipermail/python-dev/2011-March/110221.html) was good &gt; Here's the line I'd say is contentious: blacklist = open("blacklist.big5", encoding='big5').read().split() The blacklist file contains a list of filenames. However, this code treats it as a list of strings... he should really be doing this: blacklist = open("blacklist.big5", 'rb').read().split()
[Also good lols](http://mail.python.org/pipermail/python-dev/2011-March/110226.html) from that thread &gt; The lesson here seems to be "if you have to use blacklists, and you use unicode strings for those blacklists, also make sure the string you compare with doesn't have surrogates". &gt; //Lennart
An astute diagnosis. 
oh, I copied and pasted the command above and it didn't work so I changed it to the way I've always done it, which is what I pasted.
Hmmm, I'm amazed that noone suggested using either psyco or PyPy. But, in general checking 44100 samples per sec should not be a problem even with std python...
I had planned on it, but was too baffled, and didn't want to sound condescending. holloway mentioned bad refactoring (self.x = x), which makes sense.
This should be your guide. Well with an extremely strong bias towards 3.2. Also not that some of the negatives expressed here about Python 3 are really old news. Python 3's support is picking up at a rapid pace. In the long run you are far better off using and learning 3 where ever you can. 
You have already gotten some good Pyrhon advice, but you can't escape the reality that realtime depends upon hardware. So you need hardware that is capable which should be any relatively recent PC. Even if you get this task working up to snuff in Python I'd still recommend C++ for long term audio processing projects. Mainly because it seems like people often try to get more more work out of their audio processing chains. That is adding more channels or addingt more filters and such. 
Oops! You're right, I misunderstood the pipe syntax :-) And there's really nothing to misunderstand. My bad. Here's the revised version: sum . map (^2) . filter odd . takeWhile (&lt;1000000) $ fib 
gpl?
Not really xf86enodev. A tag can serve to categorize a program outside of its intended purpose. If I have a program that changes headings in degrees to points on a compass i.e. [boxing the compass](http://en.wikipedia.org/wiki/Boxing_the_compass); I might wan't to tag it 'pirate' or 'navy' to aid in search, but those words are not *neccessary* from the point of view of adding *code* comments.
yep they are the best bang for buck in python webhosting 
I didn't know about the _replace() trick to create new objects using a prototype class &amp; named tuples. That's pretty cool. Thanks markusgattol and Raymond Hettinger. 
It doesn't matter. They're almost the same. Any good Python programmer should be comfortable with both. Personally, I vote learn 3 first then 2, so you don't learn bad habits, but it's not very important. 
The developer might be a friend of yours. I find it in very very bad taste to ask for money for an unfinished product. It's like asking me for money for the opportunity to work for you as a tester. 
I always have two shells open: one Python, one bash. :-)
Dude, haven't you noticed that 2/3rds of the posts on /r/Python are "I'm thinking of learning Python and I was wondering, 2 or 3?" These days very few people in this subreddit actually know Python. :-(
I think it's important for coworkers to be able to critique each others code and thinking. In fact, the coworkers I respect the most are those who do, probably because I often do stupid stuff. The value of code reviews come to mind.
What is the correct license? If Snappy from Google is BSD License, then what the bindings are expected to be? 
I don't have anything about people asking questions and being in read-only mode otherwise. But, as this situation shows, when they try to contribute using common sense and stuff, it doesn't work and can be quite disruptive in fact.
Maybe a level 2 troll: trolling by telling you troll, but don't (but in that instant, you do.)
I think it would make the most sense for the Python bindings to be BSD licensed as well.
Any version suffices, but 2.7 has some syntactic niceties backported from Python 3.x (e.g. dict comprehensions).
I think that the license of the bindings should not be more restrictive than the license of the original software, because that is the will of the original authors. Also it can not be less restrictive, because the whole package can not be used. So only it makes sense to use the same license. 
Would be cool to have multiprocessing support. But seems a cool library nonetheless.
You got any experience with OSQA? I've heard it's not very well-tested and has a few rough edges, so been looking into AskBot instead.
Celery, no. Lettuce however....
Bindings with bad licenses tend to be rewritten. This is not the first time I see bindings with "inadequate" licenses. The curious thing is that bindings code is usually just that and quite small. I don't think it justifies a license such as GPL. When I found situations like this, I first try to contact the authors. Most of the time they just say "sorry, it's GPL", so I just use ctypes or write my own limited bindings if needed... 
&gt; I have variable length tables, sometimes, which means I can't pass it a finite, exact number of (%s %s %s), because I have no idea how many columns there are. Hm, maybe I should use dictionaries? That sounds like a bad database design! If you need flexible Tables, you might have a look at a document based DB, like mongodb or couchdb? If you just use tables to store flat attributes and all tables have no relation to each other, then I think you will be getting more comfortable with a non relational database. &gt; Your help has been much appreciated, my friend. Thanks. Your're welcome :-)
If you don't need more than one year of service, that's dandy
Hi, I am the author of the binding, thanks for the appreciation. I wasn't sure about the license, it's my first project in which I adapt a license. I have changed the license to use the New BSD License as Snappy does. Here is the commit with the change : https://github.com/andrix/python-snappy/commit/dcd795d28be38793195446072bd87aed98001695 Thanks for your thoughts about that.
wahaa: I've just changed the license to use the BSD one. 
introducing reliability issues is a really big deal in hosting generally; that may go double when you are trying to turn hosting into an electricity-like utility
Actually, I gave him a lot of feedback and he gave me a free license.
what about adding an alias so that snappy.decompress() also works? would be more in line with the current zlib module that way.
nice idea dotbot, can you create me an Issue over github? thanks!
dotbot: I've added the alias here : https://github.com/andrix/python-snappy/commit/8cb0629a250798b1a1ad4e322f3c65cac7b8428b. Thanks for your suggestion!
It's ~$15 a month thereafter, $10 if you pay for the year. Not great, but certainly less than a lot of places. 
Thanks for the binding =)
thanks capt. obvious. that is a big deal for sure, but so is features, and one of the annoyances about appengine right now is that you have to target python 2.5 which is fast becoming more and more antiquated and more of a challenge to keep on your machine as more OS's that use python internally ae moving to later versions. It's on their roadmap to move to a newer version of python. I think pypy might be worth investigating as a replacement for their tricked out and sandboxed py2.5, maybe it would take less effort....who knows? Which is why it's my fantasy.
http://code.google.com/p/pytailer/source/browse/trunk/tailer/__init__.py#243 try try if if if
Use emacs for * Because if there's a life long pursuit worth anything at all it's customising your edditor. \o/
? Isn't this the fault of the person who keeps using the editor that keeps failing?
Lots of different editors do this randomly. And you can't tell just by looking at the source.
I don't get it, what's the problem with removing trailing whitespace?
Just to point out, there is also a Python 2 version of Dive Into Python. But I agree with your path, at least it's what I am doing. Whichever version you choose, you should at least be cognisant of the main differences between the two versions, in case you are reading code or getting help from someone more familiar with the other version.
/shrug Never had this problem -vim user
My editor strips trailing whitespace, never seen this error. Also I hate rage comics.
*shrug* Never had this problem -vim user
this isn't related to trailing whitespace. Indentation is not trailing... what editor are you using? Some can cause problems sometimes with auto-indent messing things up, or using hard tabs instead of spaces
neither do I
are you a girl ? and oh you're doing it wrong.
Randomly, or as an intended feature? Any editor that modifies my file without my consent won't be around very long. 
Say you have this code: 1 if this: 2 dothis() 3 dothat() 4 5 nowdoanotherthing() 6 else: 7 die() If your editor removes the indentation from line 4, Python will kick an error. 
that is incorrect. your editor must be doing something else to the code.
That works fine for me. Even this works fine: if True: print "hello" # No problem with comments or empty lines being unindented print "there" 
[Geany.](http://www.geany.org/Support/RunningOnWindows) You're welcome. Edit: I sounded like an arrogant prick there. But seriously, Geany is awesome.
you can if your editor can show invisible characters.
also, I'm reminded of this: http://www.youtube.com/watch?v=S-SXkNbyiPI
Is it possible you have a mix of tabs and spaces in your source file? Mixing tabs and spaces makes very, very bad things happen. The interpreter and your editor may disagree on tab length, and then the interpreter gets totally confused while your code looks normal.
I just checked, no it doesn't (Python 2.7).
And people ask "why are there no girl programmers?" You're why.
The worst offender is TextWrangler on Mac. The setting is buried somewhere, but you *can* turn it off. Vim doesn't do this, which is delightful.
what ??!! I'm only asking just to confirm because that's a girl in that "comic", that's it, not implying anything.
Here's a nickel, kid. Get yourself a decent text editor.
Funny I have a vim autocommand that trims trailing whitespace in python files. It runs every time I save my files. I don't seem to have any problems.
I've had some issues with textmate's 'Re-indent pasted text'. Turning that off cleared up a lot of indentation issues on pasting. 
How do you know if someone is a vim user? Don't worry, they'll tell you.
why does it matter? The OP being male or female has no bearing on the issue at hand.
I always have expand-tab turned on, so this is unlikely, but it might be a text encoding thing, actually... 
Hah. Yeah. TextWrangler's going in the bin.
And now I can't seem to replicate it. Heisenproblem.
Cool. I'll check it out.
Never had this problem. Mine actually fixes this for you when something/someone else messes it up. --Notepad++ User
Just checked, python 2.5.4 and it works. Did you try to do it in the interpreter? or in a file. Interpreter will not work, file will.
I have this problem with winmerge. I tell it to ignore whitespace for merging C code, but when I merge Python, it messes up everything.
First try block is entirely redundant and can be merged with the inner try. Probably an artifact of refactoring that can be confirmed by source control archeology.
If you paste into the Python console? Blank lines like that won't work in the Python console, as they are treated as end-of-expression. 
How do you know if someone is going to use this joke? Don't worry, they'll tell you.
If you find that your editor does this then find another editor. 
So the title "Every. Single. Time." was just a teensy bit **BOLD**.
How do you know if someone is a Notepad++ user? Don't worry, they'll tell you. sorry couldn't resist
:D I've tried the others and while they're good I always seem to default to this or gedit.
How the hell do you use a joke without telling it?
Just built MacVim. Really nice, actually.
Hmmn, possibly, yes. But this was my *entire* *fucking* *day* yesterday.
I already opted for C. I never programmed in C but I am already halfway throu :-) I think I got the taste of low level stuff now …
pfft, you could at least try to try.
Notepad++ is great. As long as the editor you choose has the ability to find/replace using RegEx you are A-OK in my book.
I write python code in textwrangler on Mac almost daily and have never had this issue. Are you sure you have all the same line endings? Mine default to unix (LF).
This is the likeliest culprit.
Stop prefixing package name with "python-" in `setup(name='...')` (thus [PyPI](http://pypi.python.org/pypi/python-snappy)) ... is it not already obvious that it is a Python package?
[](/like this)
Since when did indentation become trailing whitespace?
On Windows, it would be interesting to see this combined with PEP 397 (adding a launcher with shebang support). 
If you want something free on Mac, perhaps Eclipse + PyDev. http://pydev.org/ A little heavy maybe, but the project management and code completion are great. (Although I don't see the problem with TextWrangler myself..)
I've used Textwrangler/Bbedit for years with Python code. Also, pretty much every .py file I've written has extra lines between statements inside `def`s &amp; `class`es…and Textwrangler cleans trailing whitespace from all of them. &gt; &gt; How does trailing whitespace equal indentation? That doesn't make sense. More likely your problem was from mixing tabs &amp; spaces.
 try: .. except: .. finally: .. wouldn't work if He's trying to keep it python 2.4 compatible
what makes you think I think it matters ? whatever is in your head - don't make assumption out of it and dump on me man.....can I just be fucking tiny-bit curious, please ???
Why does your coworker want to use celery so badly? All this stuff reeks of premature optimization. It doesn't sound like you need a "worker" model at all, so bringing celery in is just using technology for technology's sake. Do the easiest thing, see if it's fast enough, and if it isn't, profile it to find the bottlenecks. THEN think about bringing in worker queues and all that junk.
[](/That's more like hiding it than not telling it.)
I just started to pick up Python a couple weeks ago, and when confronted with the version problem I looked up what was supported on the server I'd be deploying most of my stuff to - 2.6 (Dreamhost) - so I went by that.
Not sure what's available on mac but I generally code in gedit with a bunch of development features turned on, most importantly, the one that draws dots and tabs and other whitespace
The hidden message is basically what I meant to comment on my comment. I thought I would be better off not posting two comments.
Make sure to get an editor which allows making tabs visible. Ideally, it should also have the option to make spaces visible. Problems like this often result from mixing tabs and spaces. Most editors are set to a tab width of 4 spaces, but Python intentionally defines a tab as equal to 8 spaces, so a mix will easily break. Even if your editor automatically expands tabs as you type them, it may still treat copy/pasted incorrectly. Empty lines should be ignored for indentation. In fact, IIRC PEP8 is often interpreted to suggest stripping all trailing whitespace (the suggestion that certain blocks should be separated by "blank lines" is a bit ambiguous in this regard). EDIT: Also, some editors preserve the original line endings in files, which may be a problem if you're writing code using different operating systems. Some cross-platform editors unhelpfully try to use OS defaults rather than the one true line ending format.
That sounds like a threat.
pure white space lines are ignored in python
macvim for the win
You appear to be getting downmodded despite novel and genuinely interesting content. I'd like to suggest some amendments: * Add a totally meaningless bar chart showing how fast this design is vs. a single thread * Include a link to an empty Github repository * Come up with a bullshit test strategy and speculate on how it's the best available for this particular task. * Link to a web framework, preferably several, even if they're not used. At least make a comment about one * Add another bar chart demonstrating how much faster the web framework is for this particular task compared to some other, arbitrarily chosen framework. * Retitle the post "DISTRIBUTED BRUTE FORCER FTW?!@#? LOLCATS"
Yes, it is still in beta, it is not well tested, there are batch of defects, especially in encoding and deconding.
Thank you! And sorry if I seemed rude...
lol'd. Writing the SSH scanner post now, its going to be a long one so I think I can drop a few of those points in.
I suggest cross-posting to /r/hackbloc.
Done.
That is _extremely_ false. There's a Vim plugin that I and my Vim-inclined friends use which blatantly highlights those trailing spaces in red so that you can delete them. ReviewBoard (a Django/Python project for code reviews) does the same thing.
I used to use TextWrangler, actually. It was pretty much OK, although showing all spaces is somewhat irritating.
The point of ctypes is to provide data types as they appear in C. What you ask for is simply not possible with a C struct, IIRC; that's not how strings work in C. Alternatively, you could put a normal python string in a class with __slots__, which is the python equivalent of a C struct.
I wasn't looking for something that directly corresponds to C structs, just some that was convenient and Pythonic. It's a common enough requirement in my experience. Fields that don't have a fix length usually need some way of recording their actual length.
It seems like you want to do two different things: for most tags, just throw them away and keep the rest of the text; for meta tags, keep the value of the content attribute. Write a regex for each and decide for each data point which regex to apply. The same goes for if you use beautiful soup (recommended): you should get the value of the content attribute in the meta case. This might be as simple as soup.find(attrs={"name":"description"})['content'] or soup.find(attrs={"name":"description"}).content.
Then I recommend a class with the fields marked as _ _ slots _ _ to make it efficient. Recording the length is redundant, a python string is dynamic.
I don't think you get what I'm talking about. Say you have some data stored in a binary file like this. * &lt;field x&gt; - 1 byte * &lt;field n&gt; - 4 bytes * &lt;field y&gt; - n bytes * &lt;field z&gt; - 10 byte So that the length of &lt;field y&gt; (maybe a char string) depends on the contents of &lt;field n&gt;. Using the `struct` module, you need a bit of logic to get that work. It would be nice if somehow it could automatically cater to any size for &lt;field y&gt;, based on &lt;field n&gt;. **EDIT**: [found a website](http://utcc.utoronto.ca/~cks/space/blog/python/StructBinaryWeakness) with someone else discussing this very issue (second item).
Don't forget some unrelated yet visually appealing copyright-violating clip art lifted from Google image search :) (I subscribed, looking forward to the rest of your series!)
People who SSH brute force are assholes. This is an interesting project, but anyone who uses it should be lynched.
Thanks for making the internet a more dangerous place.
And to defend against this sort of thing you can use [fail2ban](http://www.fail2ban.org) and the following in your sshd.conf: PasswordAuthentication no PermitRootLogin no RSAAuthentication yes
Why not use a distributed task queue like Celery or the other hojillion libraries?
By providing a pack/unpack hook, I have already implemented it in "an elegant way" and will merge it to struc when I find time.
Awesome. I'll be keeping an eye out for it!
happy reddit b-day!
Can someone explain in plain English what exactly is going on here? Is this some sort of code which tries to SSH into a random machine by trying out various user/password combinations?
 snappy.compress("hola mundo cruel!") '\x11@hola mundo cruel!' I think that benchmarks could be done on a bit bigger examples.
You're evil.
I didn't know that. Seems like a fine reason to use nested try.
While interesting post I think it's also a good idea to mention things that might actually help people protect themselves. I found that using *disabling password based login* and *enabling public key authentication* and also maybe setting the `AllowUsers` setting is a good start: * http://www.markus-gattol.name/ws/ssh.html#best_practices * http://www.markus-gattol.name/ws/ssh.html#allow_users_groups * http://www.markus-gattol.name/ws/ssh.html#public_key_authentication 
Hacking is hacking. Use your free time in what you want... I find interesting the architecture, espectually the queing system with ircd. I don't care about the project goal.
CLIT, but you had to add the N in there, I see.[](/troll)
Same here, but I haven't got the debugger to work.
The link actually seems to claim it can't work with the struct module, rather than requiring work. It seems to me you would have to read the data element by element, whether you're in C or Python. With the class you could add a read method to the class that hides the logic in the object. I don't know about the construct module that's mentioned in the link, but this approach seems pretty straightforward and reasonable.
I've looked and looked for an easy solution to this, and the best I've been able to find is using lxml. You can use the Beautiful Soup Parser, as well as xpath, and cssselectors to select the exact text that you're interested. It's also about 5x faster than Beautiful Soup from my tests. The downsides to lxml are the documentation, and it's a bit harder to install. 
Yeah that's about it.
Yep, I will do a post at the end on how to stop this kind of attack.
OT question: what app did you use to make those nice diagrams?
Google docs, click "Create a new drawing". They look very nice, don't they?
lxml + xpath or css selectors is a very nice way to extract text also see pyquery, html5lib
No, you didn't seemed rude. This thread help me understand better licenses and how to adapt one. Thanks to you and all the guys that commented here!
I agree with you, I need to test the library on more data, and also I need to implement two operations that work with Soruces (a source from the google library is a stream of bytes that you can read til some end - seems to be an interface to operate over files or sockets). I'm gonna continue implementing this functionalities, I need some time only :)
Maybe take a look at BBC's [Kamaelia](http://www.kamaelia.org). It constructs the pipelines and producer/consumer components using Python's generators, and IIRC there was a graphical pipeline builder available. The concepts are straightforward enough they even encourage you to [implement the core by yourself](http://www.kamaelia.org/MiniAxon.html). Sadly, at the moment the project's page seems to have a lot of broken links so I doubt Kamaelia is very widely used outside BBC.
I took a look, unfortunately a lot of the most interesting bits (such as how to create a component) are on dead links...
[Mechanize](http://wwwsearch.sourceforge.net/mechanize/) is pretty awesome for pretending to be a browser and scraping information from pages.
There's a pipeline api for google app engine http://code.google.com/p/appengine-pipeline/ also http://code.google.com/p/python-pipeline/ which is different
The short answer is that the output is a 20x20 matrix (plus a few for outputting the axes). You scan every point in the matrix and if the point in question is on the line then output o. The function in your example is y = x + 2. When you are scanning the matrix you have the coordinates of the point in each run (x, y), then you just put them in the function to check if y actually equals x + 2 (then it's on the line). You might have to do some approximations if a point is not exactly on the line but close to it, so that a point is not skipped in the output.
You're right... Sorry. It was a couple of years since I used it and I don't have a local copy of the docs anymore. Thought it was worth a shot.
To me, the most interesting part is the renderer. I don't really know how/want to explain this without using code, so here goes; render_line=[] # buffer for symbols to render for row_num in range(-10, 11): for col_num in range(-10, 11): if col_num == input_function(row_num): # if y = f(x) render_line.append("o") elif (row_num, col_num) == (0,0) render_line.append("+") elif row_num == 0: render_line.append("-") elif col_num == 0 render_line.append("|") else: render_line.append(" ") print("".join(render_line)) render_line.clear() # flush buffer Note that this is a very messy proof-of-concept that I haven't tested or cleaned up. The order of the if/elifs/elses is important - a "o" (plot point) should always take precedence, a "+" (origin) should take precedence over a "|" (vertical axis) or "-" (horizontal axis), and a " " (whitespace) should not take precedence over any of them. input_function is stand-in code for the user-supplied function. Ideally, you'd have a bunch of sanitisers for the input function (try and figure out what the user meant not what they said, and make sure they're not being naughty ;) ), but you can get away with a one line `input_function=input("Please enter a function: ")` (DO NOT USE IT IN LOOP, or they'll get asked 400 times..). Presumably the math and exec part would work together, I don't know the math library. ______ Edit: I just realised you could make this buffer-less. Replace every `render_line.append(whatever)` with `print(whatever, end="")`. Then remove all the lines that mentions `render_line`. Done! Though this is entirely academic, it's probably more inefficient to do it this way (I don't know how expensive a `print()` is)..
+1 for PyQuery. If you are familiar with CSS selectors (jQuery like syntax) then it can make the job quite easy - much better than trying to do it all with regex. 
"An Arousing Command-Line Library"
hahaha, this was absolutely discussed as a possible name before CLINT was picked :)
Does it work with _(u"String should be translated with %s" % "pylint") errors? Does it work with django templates / mako templates / etc. ? Also, we have pretty much big project and lots of phrases should not get to translation, so that would be pain to use pylint))
This is basically [my day job](http://openstates.sunlightlabs.com) so I'm happy to help. BeautifulSoup really isn't worth the hassle anymore, lxml is far faster, more robust, and leads to more readable code (learn a bit of xpath and you will have code that describes what you're scraping rather than just .child.child.child kind of stuff) If you're writing a scraper that is going to run repeatedly, scrapers break and having code that has class names in it actually can lead to things breaking earlier, but breaking early is a good idea as the other option is often to take in incorrect data (which *will happen* if you simply use relative traversal via something like BeautifulSoup) Also as far as retrieving pages, we wrote a wrapper @ work around httplib2 that you might find useful: [scrapelib](http://scrapelib.rtfd.org), it provides error handling, retries, etc. -- particularly useful if you're scraping a semi-fragile site
Worth checking out: http://www.pypes.org/ http://www.pyfproject.org/ ...though I fear these may be too heavyweight for your needs. There's also the infix syntax module as posted here recently which might help you take a more declarative approach: http://dev-tricks.net/pipe-infix-syntax-for-python 
Take a look to [scrapy](http://scrapy.org), it will make your life a lot easier.
A lot of people are going to recommend lxml. Personally, I still love BeautifulSoup — bs4 is an alpha right now, but it can use lxml as pluggable parser (it can alternatively use html5lib, too). I've used mechanize before (found it pretty awesome when dealing with forms), but for the majority of tasks, urllib2 gets the job done.
&gt; However, most Python programmers tend to just read the entire file into one huge string and process it that way. I feel funny doing that. Having used machines with very limited amounts of RAM, I tend to try to keep my file processing to a single line at a time. However, that method is going the way of the dodo. We do what!?
Just to third for Linode. My company has got a number of pylons-based applications that we've got running on some debian-based Linodes. Incredibly easy to setup and administer - I had the first one up and apps running within *minutes* of giving them a credit card. Haven't had a single thing go wrong. Mind you, you have complete control over your virtual server, which means administering it fully your problem. But the imaging/backup/remote console tools they offer for that task are *wonderful*.
Instead of IRC as a control channel, you might want to look at [Execnet](http://codespeak.net/execnet/). I worked on a similar project, and Execnet made things much easier.
You might want to check out [bein](http://madhadron.com/bein/)
I was raising an eyebrow at that too. with open('filename.txt') as f: for line in f: #do stuff with line iirc this does not read the entire file into one huge string. [The docs here](http://docs.python.org/tutorial/inputoutput.html) say it's memory efficient, but doesn't elaborate. Can anyone illuminate the situation?
&gt; Does it work with _(u"String should be translated with %s" % "pylint") errors? This script is designed to find places where you forgot the _(), so that text would pass. I can't see the error there, unless you mean the % being inside the _(). This script doesn't find that, you'd need another pylint plugin for that. &gt; Does it work with django templates / mako templates / etc. ? For the Django templates, I've written a sister script that finds non-translated text: http://www.technomancy.org/python/django-template-i18n-lint/ &gt; Also, we have pretty much big project and lots of phrases should not get to translation, so that would be pain to use pylint)) If there are phrases that shouldn't get translated, you could add them to the whitelist section, it's fairly easy to extend.
Nice. BTW, do you know how to make partial installations of Twisted? pisses me off having to include so many packages and dependencies when I distribute stuff with Twisted.
I've found the arduous part of scraping isn't in the actual parsing and extraction of data your target page, but rather in the post-processing, working around incomplete data on the page, handling errors gracefully, keeping on top of layout/URL/data changes to the target site, not hitting your target site too often, logging into the target site if necessary, respecting robots.txt, target site being utterly retarded, keeping users informed of scraping progress, sane parallelisation of requests, and general problems associated with long-running background process. Good luck :)
Maybe something like Ruffus might do what you need: http://code.google.com/p/ruffus/
No, twisted is pretty inter-twined. If you are distributing to Linux I suggest rather than packaging the twisted files with your script you make an install script that sets up easy_install and simply runs easy_install on the packages. Its not hard on Linux at all: wget the setuptools package, extract and install then call easy_install.
oh yes , only fucking retarded morons code in php. python and ruby rocks !!!, because they webscale and i can copy paste solutions to make the shit work, yay !!!
Here's a page on the python wiki http://wiki.python.org/moin/FlowBasedProgramming
Yeah, that isn't how I spell it.
There certainly is a higher concentration of sloppy and mediocre programmers in the PHP community, than there are in the Ruby and Python communities (probably even combined.)
I won't do the whole thing for you but here's how I would go about doing it. import numpy from math import sin, floor xmax = 10 xmin =-10 ymax = 10 ymin =-10 f = lambda x: x**2 + sin(x) Make a 2D array of the function and use a conditional to determine if you need a dot there. A = numpy.zeros((abs(xmax)+abs(xmin), abs(ymin)+abs(ymax))) for i in xrange(xmin,xmax): f_x0 = floor(f(i)) for j in xrange(ymin,ymax): if f_x0 == j: A[i,j] = 1 Print out the array and add axes for i in xrange(xmin,xmax): for j in xrange(ymin,ymax): if i == 0: print '-', elif j == 0: print '|', elif A[i,j] == 1: print 'o', else: print ' ', print '\n',
A better way to do this, I think, is to populate a 2d list with spaces and lines before hand and then over-write any of those with a 'o' once you've determined where it goes. size is 10 and rng is the range from [-10, 10]. graph = [['|' if x == 0 else ' ' for x in rng] if y != 0 else ['-'] * len(rng) for y in rng] graph [size][size] = '+' this way, for f(x) = x + 2 we just make graph[x][y] = 'o' This has the disadvantage, though, of introducing some index-to-coordinate trickiness. 
without using numpy, you can get the same 2d array effect by using a list of lists. size = 10 rng = range(-size, size + 1) array = [[0 for x in rng] for x in rng] 
It currently requires the Zope2 CMF, but Transmogrifier (http://pypi.python.org/pypi/collective.transmogrifier) sounds like exactly what you are looking for.
The official Perl 5 docs at http://perldoc.perl.org/ are a mirror of what you can access at the command line. You can access *all* of them in your terminal using the `perldoc` command. It's tremendously useful. In Python-land, the docs you get via `pydoc` (or `&gt;&gt;&gt; help()`) are separate and distinct from the ones at http://docs.python.org/ . 
so, break it down into steps. What are you trying to accomplish here, what do you need before that? You have: * a list of x values (the range of the graph) You Need: * to figure out the y values * to plot the y values How do you get the Y values? Do you iterate over the whole graph and say "is this a y" or is there an easier way? Can you calculate them on their own? Start by answering these questions. The question on how you're going to display your data should only come up after you have some values to display. Good Luck! 
The project is still active since the last release was only 3 months ago. I suspect the website has had a reorganisation and the links are not up to date. ... Yep, the [sitemap page](http://www.kamaelia.org/Sitemap.html) says: &gt; This is an automated full list of (almost) all pages &gt; Yes, I'm aware that this is slightly bust for some pages at the moment, it's being sorted. This is a static copy of the dynamic site whilst the server changes physical location. &gt; And yes, .html needs to be appended to some links (sorry). Kamelia is a mature project and will probably do everything you want and lots of stuff you don't know you want (yet).
True, numpy is just for convenience in this case. On that note if you need to init a m by n zero "array" of nested lists there is a nice one-liner: zeros = lambda m,n: [[0]*n]*m
Sorry but this http://pleac.sourceforge.net/pleac_python/index.html seems 100x more useful. 
One request; Please nullify the bruteforcer gist/post. Or make it not run at _ _ init _ _, that you have to debug it. Or leave some parts to the reader...... Theres enough of scriptkiddie tools around at http://packetstormsecurity.org/files/ We don't need any more, particulary this much documented.
Some good pipeline processors can stream the results from one node to another before the former node has finished processing (e.g. between XSLT processors). For [Docvert I wrote my own](http://github.com/holloway/docvert/blob/master/core/docvert_pipeline.py) but it wasn't that sophisticated. It took an XML file like, &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;pipeline&gt; &lt;stage process="TransformOpenDocumentToDocBook"/&gt; &lt;stage process="Loop" numberOfTimes="xpathCount://db:chapter"&gt; &lt;stage process="SplitPages"/&gt; &lt;stage process="DocBookToXHTML"/&gt; &lt;stage process="Serialize" toFile="{customSection}"/&gt; &lt;/stage&gt; &lt;stage process="GetPreface"/&gt; &lt;stage process="DocBookToXHTML"/&gt; &lt;stage process="Serialize" toFile="index.html"/&gt; &lt;/pipeline&gt; The attribute 'process' named the module/function, and then it was a just a matter of iterating through the results and importing/calling them by name.. In this case they were in a core/pipeline_items/ directory, class pipeline_processor(object): """ Processes through a list() of pipeline_item(s) """ def __init__(self, storage, pipeline_items, pipeline_directory, pipeline_storage_prefix=None, depth=None): #various assign to self here def start(self, pipeline_value): for item in self.pipeline_items: process = item['attributes']['process'] namespace = 'core.pipeline_type' stage_module = __import__("%s.%s" % (namespace, process.lower()), fromlist=[namespace]) stage_class = getattr(stage_module, process) stage_instance = stage_class(self.storage, self.pipeline_directory, item['attributes'], self.pipeline_storage_prefix, item['children'], self.depth) pipeline_value = stage_instance.stage(pipeline_value) return pipeline_value 
Excellent! I was actually building my own set of python bindings for snappy for this reason alone. Now I don't have to :)
I was the one that brought this up both with Graham and Ian, and I really think he is too dismissive of how important Jenkins' user story is. Silver Lining is flexible, but it is still a lot of infrastructure to require in the name of making things easy. I really do want the instructions to be 'wget http://example/reviewboard.par &amp;&amp; ./reviewboard.par'.
1. You want to run it locally on your computer? That's so not useful! 2. If to get "good experience" you limit us to tools like wget (and git is being used similarly) then you've set us up for a poor set of tools 3. In so far as an application can actually be made to run so simply (i.e., with sqlite, with whatever version of Python, throwing its state into random locations, etc) you can make a tool that creates a self-executing server from an application described in this application format
Yes, the whole point is simple deployments, not things that need to be backed by a SQL cluster and umpteen NoSQL stores. My target can be very narrowly defined as ReviewBoard, Transifex, Pootle, Graphite, and my own Commis project. All are Django based, though I've been trying to ignore that somewhat in the interests of generic-ness. These are the kinds of things that people want to just dump on a company server somewhere and not think about. I want to let them not think about it.
Well, even if we disagree on the utility of that goal, it doesn't *really* matter, as I'm pretty confident that a format like this would be useful when building a tool to create self-executing application bundles (which still places more constraints on the apps than the general case, and the upstream developers may or may not be interested in supporting those constraints, but that would be between you and upstream).
Sure, being able to mount these things into a more complex environment is very important as a growth path (be it silverlining+mod_wsgi or chef+gunicorn, or all of the above). I agree that this is constraining, for example you can't assume there will be a memcached server (though most Python apps can usually swap out a dummy cache backend) or anything else like that, but I think the gains outweigh the benefits. The author can still offer memcache (or PostGIS, or Casandra, etc) support, they just have to be able to scale down and disable or simulate the functionality.
I've never used an IDE for python. Is it a big help? Is Wing particularly better than the competition? 
I second that -- Scrapy is definitely awesome. I have done some really neat stuff with it.
Let me know what you think. [We](http://massive.immersedcode.org/) just released this extension for the Flask eco system.
Where can I purchase support incidents?
Nice! I hope I don't ever have to use this, but it will be very useful if I do. =)
You could make your own framework over stackless tasklets.
I wanted to like Komodo. However, does it still have that weird bug on OSX where the I-bar mouse cursor is completely black even when using a dark theme, making the cursor completely invisible in that case?
A bit expensive when the same stuff is available for free. What about it makes it worth the money?
Never use regex to parse or strip HTML. http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#1732454
As much as I grinned when I saw this, Python desperately *does* need a decent SOAP server library (with decent WSDL auto-generation support). I'm suffering through the Java "enterprise" world instead :&lt;.
ASP.NET is way ahead of Python when it comes to publishing and consuming web services for some reason.
This is quite nice for a first release. What's your schedule for supporting EPG3 (Enterprise PythonEggs)? 
As much as it really sucks not having a decent SOAP lib in Python. (SUDS is a pretty decent SOAP client lib but needs more work). SOAP is generally not very popular with pythonistas. Microsoft on the other hand was one of the companies that created SOAP and I would imagine still very much want to see it succeed. 
Best way to find out is to try it. In my opinion none of the free IDEs come close, where PyDev is the best of the free ones. Note that wing has a lot of different licenses. 
Currently it's still the best. PyCharm is very promising, but I tried it and it was not mature enough for me. It didn't run my tests (showed some strange errors in standard-lib modules) and some other stuff like find usage didn't work. The PyCharm guys were very helpfull but couldn't resolve the issues which don't seem to be issues generally. So, those issues are likely related to my system, but still a showstopper for me, naturally. Best features of Wing: Debugger and Debug-Probe (interactive debugging with code completion in a python shell on the current stack)
lxml
I know it's still got it in Windows as recently as a few months ago, particularly when using RDP. It's impossible to read a thing, really ruins the vibe. **UPDATE:** They fixed it! Holy crap, and they fixed other stuff too! It's downright damn pretty now! Back to Komodo!!
Particularly look at `lxml.builder` as a convenient way to build XML trees.
Thank you
http://pypi.python.org/pypi/dexml/
Best april's fools joke so far. EDIT: wow the code is really available, and doesn't serve me a "555: Enterpise Server Error" or something like this. I'm sure you'll find some users in the wild long after everyone has forgotten it was a joke ;) 
Seems like a crock of buzzword shit to be honest. Several Python frameworks (Django and web2py) make packaging web applications extremely easy. Both allow come with test servers as well.
Try XSLT first.
I'm a always a bit skeptic about IDEs for python. What does it bring to me on top of the base toolchain (vim/emacs, ipython, nosetest, pylint, pyflakes etc...) ? The only benefits of python IDE I've tried so far is filling your codebase with annoying "project" files. 
SiteScrapper (http://code.google.com/p/sitescraper/) Not really new, but if you get lucky, you won't need to do almost any programming.
Hi, where can I sign up for certification classes in Flask-Enterprise?
What I meant is there's a reference to a blog post that's nowhere to be found, which (according to the text) covers creating components.
Ruffus is likely the closest to my needs, but works with files while I'd rather pass objects around. 
Interesting solution. I might do something like this if all else fails.
f u how can you get the joke and not get the joke at the same time.
Are you joking?
Last year's joke from Armin was better - but this one rocks too. This looks so great :-D @enterprise.soap(_returns=enterprise._sp.String)
I wouldn't be surprised if this results in some real project or another. IIRC Flask started out as an April Fool's joke mocking the bottle framework.
A good IDE shouldn't litter your codebase at all. The biggest benefits I've experienced are being able to jump to definitions, auto completion, being able to organize imports on the fly (e.g. being able to switch from `from x import y` to `import x` or introducing aliases -- without having to rename every instance of the imported name myself). Also, of course, things like method/variable extraction/inlining and global renaming. In short: it makes refactoring easier and less error-prone. Of course not all Python IDEs have (good) refactoring suport. So far I like what PyCharm can do, although its unique design decision regarding how it handles changes and saving files is a bit unusual -- the devs say its lack of Save/Save As options is a central decision that won't ever be changed, so I better get used to it. OTOH its built-in VCS is pretty neat.
I enjoyed Komodo IDE, but I really don't understand how an IDE with zero automated refactoring support can get an award like "Best Python IDE". This was what made me switch to PyCharm. Although I miss Komodo's multi-language support. Being able to switch from Python to PHP to ActionScript in the same editor can come in incredibly handy. OTOH, its support for the languages it doesn't focus on tends to be a bit shoddy at times (in most cases it only offers syntax highlighting anyway).
I thinkni knoW what it is :) edit is using tabs instead spaces? And mixing the two? (I'm typing from an iPad bleurgh!)
Seriously though, I'd like to see something that takes a virtualenv, builds compiled modules down to all dependencies and packages them into something reasonably self-contained for a particular Python version + platform. That's only half the battle though. I also need to deploy my own code and configuration there, and I'd rather not formalize them into proper packages with setup.py and all. I'd rather just throw some module structure in a magic directory and simply be able to use them in the surrounding, bundled environment. And throw script (and module) entry points into another magic directory. Then I could just go to my server's admin and upload that package, the admin then introspecting and listing the entry points I can work with: at least daemons, WSGI apps, batch scripts, interactive configuration apps. The admin app could be anything, it just works with the bundle's standard entry points.
The main reason why my enterprise hasn't adopted Flask is lightweight syntax. My boss never considers a language or a framework with 'hello world' taking less than a screen of code. Could you please fix it in the next release?
The are pretty good about listening to the bitching of their user base. :)
PyCharm and vim
Yeah, Denied. People fell for that so hard. Including myself &gt;_&gt;
The IDE keeps everything in one window and out of the terminal, for whatever value that has, but any decent programming editor like vim or emacs can theoretically do the same. That includes the 'project' features which let you keep a persistent session and associated configuration, these are not fundamentally so hard to do (although they do mark a divide between your average text editor or lightweight code editor and the heavier stuff). This contributes to the feeling that you are not working on individual files which I think is a big part of the IDE "feel." In my opinion, what usually distinguishes an IDE from a well-provisioned extensible programmer's editor is the heavy integration of static analysis tools: scanning all your code, letting you jump around across files semantically, fully language-aware autocompletion/tooltips, refactoring operations, etc. Although one can construct an IDE using (say) vim, it is not packaged this way and takes significant effort and is not going to be that well polished without even more effort. Last I checked, for example, the rope module was kind of sketchy even if it looked promising. Almost nothing in these worlds is totally smoothly integrated. The distinction is not at all sharp.
I wish PyDev wasn't so pig slow. It also takes way too much effort to do basic customizations (say I just want to use zenburn, for example...) and when you do have to get hands dirty with configuration, it is a Java-typical nightmare of deep hierarchies and sketchy XML files. (Who makes the IDE for editing Eclipse configs? No, please forget I asked that...) Wing is better as a layer over SciTE with easier configuration and shiny gtk widgets.
It gives you a good feeling to work when you like your tools.
I prefer pysimplesoap personally. ;) http://code.google.com/p/pysimplesoap/
pyflakes and pep8 support out of the box? please? for those of us who have to read and maintain code that is also maintained by wing ide users. k thx 
There seems to be some syntax errors
 Python 2.6.5 (r265:79063, Apr 16 2010, 13:57:41) [GCC 4.4.3] on linux2 Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; def happy(): ... print "Happy Birthday to you!" ... &gt;&gt;&gt; def hpNestor File "&lt;stdin&gt;", line 1 def hpNestor ^ SyntaxError: invalid syntax &gt;&gt;&gt; oops
also: &gt;&gt;&gt; hpNestor &lt;function hpNestor at 0x7f9a296c1410&gt; 
looks tasty though
Yeah, transcription errors, the coder didn't follow full specs according to the instigator :-). It hasn't been cut yet but it smells very good.
"Now add 64 bits of frosting on top"
Came to see how many people pointed out the transcription errors. Was not dissapoint.
Everyone who is pointing out the syntax errors is just mad cause they don't have a cake.
so true :( I WANT CAKE
everyone knows you need 64bit cakes for maximum flavour
Shorter version: happy = "Happy birthday to you.\n" print happy*2, "Happy birthday, dear Nestor.\n", happy
I think most people just wanted it to be true. I think I'm not alone in that I don't care much for how something is implemented as long as it does the job, isn't totally broken or slow and has a good API.
thank you, I felt a little bad that this was all I could think of when looking at this.
AFAIK, not out of the box. but it easy to install [pyflakes](http://wiki.wingware.com/PyFlakesPanel) and [pep8](https://bitbucket.org/stj/pep8panel/wiki/Home) for WingIDE.
 [print('Happy Birthday{t}!'.format( t = ' to you' if x != 2 else ', dear Nestor')) for x in range(4)] 
Best features of WingIDE to me: Graphical Debugger and Code Intelligence
That is what web2py incudes and uses for SOAP services. web2py provides an API which is similar but more concise than the one Armin is mocking in this thread. In web2py you simply do @service.soap('MyFunction',returns={'result':int},args={'a':int,'b':int}) def myfunction(a, b): return a + b and the decorated function will be exposed by pysimplesoap. We had this for more than one year. We also support xml, json, xmlrpc, jsonrpc, rss, amf0 and amf3 services (requires pyamf).
I don't use wing, but I can only assume that though it is possible as you have pointed out, it is not easy because if it were I wouldn't be asking for it :). 
&gt; so_true(): &gt; I WANT CAKE FTFY.
It's certainly less redundant, but it's not really _shorter_, is it?
Abusing list comprehensions is my favourite part of Python.
I didn't point out the errors, does that mean I get cake?
Pull Request #2, makes the greeting generic and callable so the cake can be reused across a variety of birthdays. This was requested by my boss, so that we can sell this cake to more than one customer. It's an enterprise feature. def happy_birthday(name): greeting = "" for i in range(3): if i == 2: greeting += "Happy Birthday, dear %s " % name greeting += "Happy Birthday To You " return greeting happy_birthday("Nestor")
It's not very hard neither.I have installed both of them, it needs install pyflakes/pep8 and itself, and setting config parameters like file path, that's all. Just that, works for WingIDE 3 and WingIDE4.
If you have ever tried to debug a cake through PuTTY, then you understand how those errors made it to production. 
It seems kind of pointless in this case: for x in (0,0,1,0): print "Happy Birthday%s!"%(' to you',', dear Nestor')[x]
The qtconsole looks amazing: [qtconsole sympy][1] [1]: https://sympy.googlegroups.com/attach/66676fbcb7ef469d/pythonScreenSnapz001.jpg?gda=3Zu8GEUAAABDhEBJMM28HW84_HUG_PVL8tKfdVkZwZ5gt7tu83gH19wv1g3kCFMVT-yL17XH1oaO3f1cykW9hbJ1ju6H3kglGu1iLHeqhw4ZZRj3RjJ_-A&amp;view=1&amp;part=2
Procedural loops [rot the teeth](http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_sec_2.2.3)!
Finally, a piece of Python code on here that a relative newbie like myself can instantly understand. :P
so_true(): sadness = 1 print "I want cake" return sadness FTFY
&gt;shortlink: redd.it/ggbsg good game bull shit generator
&gt;web2py provides an API which is similar but more concise than the one Armin is mocking in this thread. Does this kid have a job? I'm impressed with the technical work of the Pocoo team, but having observed this kid for the last few years, I am quite disappointed with his behaviors and attitudes. 
&gt;IIRC Flask started out as an April Fool's joke mocking the bottle framework. I knew Flask was borned out of an April Fool's joke, but I wasn't aware that it was a mocking of the Bottle Framework (which is pretty nice). It turns out this guy just goes around mocking other projects? Isn't this pathetic or what? 
You might get some mold!
i'll pass that info along to the wind user, then hopefully I won't need to edit their code anymore :)
nhom nhom nhom
It wasn't really _mocking_ it and it wasn't directly aimed at Bottle. IIRC the two projects were in talks about merging at some point, but the philosophies were too different. I'm pretty sure the name was a play on _that other microframework_, but as a fellow redditor pointed out, the original prank was called DENIED. The joke was mostly aimed at the hype surrounding microframeworks at the time (with everybody obsessing about minimizing dependencies and code size while at the same time demanding as many features as possible). Don't jump to conclusions regarding individuals over what you hear other people say on sites like reddit. Mitsuhiko et al are doing a great job and Flask is great despite being inspired by an April Fool's joke. A little mockery and friendly rivalry is part of any healthy competition. Things like this should be taken with a grain of salt. It's important to be able to laugh about yourself at times. I think highly of some NoSQL databases/stores yet I found the "web-scale" `/dev/null` NoSQL store (I forgot what its brand name was) quite amusing.
"Cease and Desist" - mdipierro
xslt might be "purpose build" for transforming xml... Still xslt is written in xml... And we all know how good xml is as a "pythonic programming language" ... Imho lxml is the way to go....
Nice! I am new to python and for some reason little tweaks like this get me more excited than anything else.
Awesome cake, fix the syntax errors and make it an xterm instead of a putty session, and it's perfect :)
wow, ok I have finally figured out what is going on here.
pleease it's 1st April!
Code golfing is fun and addictive. They're like little brainteasers with no fixed answer.
Yes, but it doesn't fit as well on the cake.
The syntax error and incorrect output bothered me, but the non-pep8-compliant function name damn near killed me.
I've heard that web2py for python 3 will be called webpy3, is it true?
Intrsting.
I knew that Max Lager would change the world at some point.
The joke is they made the page in web2py. 
I love the design. If the author ever needs a job, please contact me. :-) EDIT: Your screenshots from web2py show artwork that is one year old. Did you really not upgrade it in one year? You are missing lots of new features guys! 
No they did not. It is a static html page.
That's cool. I had no idea about this. Thanks.
Can you please explain?
but it says "Web2Py is up to date" lol
In fact we wanted to backport new features to the old admin design, and there's also a possibility to use Zope2 ZMI on top of the current stack.
In fact it says "web2pyramid is up to date" ;)
I wish this wasn't just aimed at web-applications. Python would be a great platform for desktop app development if only someone would sort out the deployment issues. It needs to be easy to build totally self-contained apps which don't make or need any assumptions on the host environment.
Many good choices are linked in this thread and here's another possibility: http://www.trinhhaianh.com/stream.py/
&gt; web2py provides an API which is similar but more concise than the one Armin is mocking in this thread It's not mocking the pysimplesoap API. The Flask-Enterprise API is a wrapper around [soaplib](https://github.com/soaplib/soaplib) and [suds](https://fedorahosted.org/suds/), both of which are very nice libraries if you have to deal with SOAP. This Flask-Enterprise basically just adds a silly enterprise object in front of those libraries. EDIT: clarity
Finally, a desktop background that will earn me the respect I desserve!
Great joke. But.....The documentation is a complete ripoff of soaplib's documentation. I hope whoever did this at least asked the maintainers before doing this.
Did you contact the soaplib maintainers before you copy and pasted their documentation?
I like the old admin design better.
I think that was a joke.
Funny, if a little mean-spirited. I guess the reverse would be something like: RePylOpeMid2Py.bfg * Doesn't use exec because, well, it doesn't use exec! * Code your entire program with imports! * Choose from 274 templating engines! * Re-write all of your apps every 18 months!
Last I saw pysimplesoap doesn't support marshaling complex types and generating XSDs on the fly. Has that been addressed yet; soaplib's had that capability for many years.
And a "Zope Inside" sticker, mimicking those from Intel.
I do not know. It has never come up.
These tutorial notes are more up to date: http://www.kamaelia.org/Europython09/A4KamaeliaEuroPython09.FINAL.pdf All the used in that tutorial is inside the release bundle in Apps/Europython09. The tutorial covers building your own version of the core, going from standalone programs to components, through to building and evolving your own systems. It's (naturally) divided into chapters, but each is designed to have the feel of a blog post in terms of readability (I hope :-). Currently the website is rather chaotic due to a bunch of internal re-orgs resulting in the current version of the website being a bit of an emergency dump. Probably worth noting though that the project is still under development, releases happening 3-4 times per year now, and most recent usage is described here: http://www.bbc.co.uk/rd/publications/whitepaper191.shtml The static snapshot of the website incidentally was checked into SVN here: http://code.google.com/p/kamaelia/source/browse/website/ With the content in "as_published". Any suggestion on how to create a not crap website welcome :-)
Oh, sorry for the multiple replies, but just wanted to add - even if Kamaelia's specific API doesn't work for you (some people like it, some don't), I'd encourage you to use the approach -- it does work. In addition to Kamaelia there's also Pypes (pypes.org) which is cool. There's also cool stuff built ontop of greenlets and stackless channels. There's also alot of really nice noise being said about Celery at the moment too. http://celeryproject.org/ Also, don't discount the actor model. The actor model is directly equivalent to Kamaelia's model and pipelineing in general with one difference - pipelines don't hardcode where outbound messages which is akin to late binding. You could actually get the same flexibility by hardcoding a mock receiver actor and in a real system transplant in the real destination. That in itself might be pretty neat because it might simplify the usage API slightly, but retain isolated testability. (Which for me is the real killer benefit of this approach)
Oh python... you and your simplicity. I wish I was better at playing with you tho.
You can't wish it. You just gotta do it.
You coulda said "Fascinating," you know.
So hard to debug ... have to eat an entire cake every time you make a syntax error.
 def so_true(): sadness = 1 print "I want cake" return sadness Fixed that Fixed-That-For-You for you
 print "{0}{1}{0}{1}{0}{2}{0}{1}".format("Happy Birthday", " to you\n", " dear Nestor\n"
facepalm() \#My bad.
Why not: a="happy birthday to you" b="happy birthday dear nester" def happy(): print """ %s %s %s %s """%(a,a,b,a) happy() ?
If you download the source you can find a LICENSE file that provides the appropriate copyright information.
ActivePython users can [install lxml using PyPM](http://code.activestate.com/pypm/lxml/).
April Fools?
Pylons, a full-stack web framework, is pulling a joke on its user base by saying it's merged with web2py, another full-stack web framework. I assume the Pylons community is rabidly anti-web2py (evident by the rather mean jabs it took in the faux quotes).
I had to do a double-take on the name. Thanks so much for web2py and your [awesome documentation](http://web2py.com/book).
You would because that framework even with those components swaped is a lot better! And I told you could swap just to show you had choice., It seems that you have your first acne growing in your face, so its really nonsense to keep some type of talk with you. Just don't forget to drink your hot milk before bed ok? Ask mummy! Btw, fuck you too! You are a retard and you better stay with pylons! Django users don't want persons like you that are arrogant and rude when someone answers their questions trying to help! 
&gt; Everyone that is... Everyone who\* is...
Oh haha, it even has censoring!!
I didn't see that on your website where you copy n pasted the documentation and passed it off as your own.
I think you're comparing apples and oranges a bit there. - **Python twisted** is an asynchronous network programming framework, it's pretty complex and it's been around for awhile and many projects depend on it, so it's natural there would be more google search queries on it. Twisted if anything can be compared to Gevent and Eventlet. - **Python django** is a full stack framework, most popular one in the Python world at that, it's only normal there would be many google searches on it. - **Tornado** is mostly a simple web server, easy to use as opposed to Twisted and much smaller as opposed to a web framework like django. You should compare: Python tornado, Python paste and Python cherrypy if you want to compare apples and apples. But the trend numbers are so low for all of them that you really wouldn't get any meaningful data.
Lol. Putty.
Isn't that part of the joke?
Thanks for the summary. I agree that they are all quite different. What I was trying to do, is to get a sense of how active the interest is. Django is, I think, the python framework with the most traction. Twisted is the closest thing I could think of in the python world to Tornado. I was a bit discouraged by the comparison. As for cherrypy and paste, I wasn't sure how much traction they have and I didn't think they have simple asynchronous support.
Putty?!
Np. My guess would be that most google search queries on things like this are when people have issues with a certain module. So complexity and wide usage will skew the popularity results. Paste for instance ships with Python and Pylons use it as the default web server. For example I've used tornado quite a bit in my past projects but it's so simple to use that I rarely google search it. (which is what google trends shows). Twisted I don't use often but I spent more time googling on it, because of its complexity and size.
cool, thanks!
&gt; passed it off as your own Where did I pass it off as my own?
Touché.
You win! Yay!
paste does not ship with python, fwiw (it's still a third-party package)
Whether it's better is completely subjective. Anyways, have fun trolling you silly little prick.
It was a joke
This is an incorrect assumption 
It's true. I looked carefully at this hoping it was for real. I'm implementing a soap service and client app and the state of soap libraries in python is poor. soaplib and suds worked for us in the end, but there were bugs... 
Dude chill. I am the current maintainer of soaplib and I don't mind nor do I think any of the contributors mind as well. If you are one of the contributors send me an email and we can resolve it without out an internet forum fight.
Yeah, we've got the complex models but pysimple soap still has a cleaner implementation at this point. I am at least the fourth maintainer of soaplib as it keeps getting abandoned or others have to move on for whatever reason. It has left the code a bit schizophrenic in places.
I've been saying this for a while. I've recently taken over maintenance of soaplib but I find I just don't have a lot of time to really tackle some of the issues. If you still have issues with soaplib please feel free to post to the list or add them to the github issue tracker. I'd love to have more people contribute but I can understand that a) the soap specs are horrible. b) who wants to spend their fun-time working on soap. 
I would stress that tornado is much more than a simple web server, and it's application can well overlap those of twisted or node.js We are, for example, using tornado as ampq &lt;-&gt; postgresql async gateway. The real problem of tornado IMHO is exactly that is marketed as a "simple web server" while it's much more "a pythonic version of node.js" The Tornado ioloop and iostreeam are really powerful and it's really easy to build async libraries on top of them. See for example: https://github.com/zeromq/pyzmq/blob/ffe89125ece7b814a69ed30a70b0a738c6532b97/zmq/eventloop/ioloop.py
I think this is a more worthwhile [comparison](http://www.google.com/trends?q=python+tornado%2Cpython+flask%2C+python+pyramid%2C+python+pylons) Flask is quite a nice lil framework too with very good documentation. While I haven't done much with Pyramid, it looks very promising as well - I like the ZOBD usage. The Pylons is thrown in for reference, as it is now (more or less) integrated into Pyramid.
There will be more interest in Tornado as people discover node.js and then find that there has long been a Python equivalent. A lot more applications being built where long-polling is required, real-time web client stuff, so Tornado was a bit ahead of its time, but it will get there. Not really approp to compare it to Django, better comparison is Tornado v Twisted v Node.js
Oh my bad, there, thanks.
Then why were they so... mean?
Don't get me wrong, I loathe SOAP with a passion, and I'm 100% on-board with mocking the "enterprise" bullshit. It doesn't change the fact that a lot of the upstream tools and software I work with speak SOAP, and nothing else, which leaves me up shit creek :/.
Neat. I'd like to try it out more, but maybe you can help me with a problem. I use a black background and when autocomplete kicks in it make the cursor invisible. Do you know how to change it to default back to white?
Are you using a particular color-theme? Have you tried to force the ac-cursor-color to be white? like putting this in your .emacs, after the loading of auto-complete: (setq ac-cursor-color "white")
Interesting theory. It's like check in two moves :). My thoughts about node.js is that a good JavaScript server would let you run the same code on the server and client side. I just hate writing the same code twice.
No standard deviation, no timeit module...
They tend to support reasonable formats also. You can use JSON as the interface language even in .NET or JAVA. Why would you voluntarily work with software that only supports SOAP? Get a job that doesn't suck. I protest design decisions all the time. It leads to better software and faster development. You are thinking like a Perl programmer.
When I think of tornado I think async. Until I read about it, I wasn't aware it had some other good stuff baked in. One thing I wanted was a postgresql async "driver" for tornado (I guess https://github.com/FSX/momoko#readme ?) and zeromq.
It was a joke, all in good fun. I don't see how it was mean. 
Perfect! Thanks a lot. :-)
Except that this arrow syntax: foo &lt;- bar is actually this: foo &lt; -bar Clever. But not very Pythonic. Could have used this instead: foo &lt;&lt; bar
If I wanted to do something Pythonic, I won't pretended to write `do`-syntax as in Haskell. Monads are not Pythonic, and neither is my lambda-hack, and neither is laziness, et cetera.
That arrow syntax is quite possibly the worst abuse of operator overloading I have ever seen
Maybe, but that hack of a pseudo-operator is making it worse and erasing any kind of legitimacy the idea may have had on its own. It doesn't add anything at all.
&gt; I really do want the instructions to be 'wget http://example/reviewboard.par &amp;&amp; ./reviewboard.par'. Tip: put a \_\_main\_\_ module in your setuptools-based project, then use 'python whateverproject-version-py2.6.egg', and there you go. (Of course, your \_\_main\_\_ module has to then do whatever it is that you were wanting that command to do... and it'll need explicit require() calls if you need to depend on other packages.) 
Everything works flawlessly (ido, ropemacs, autocompletion) except for this [error message](http://i.imgur.com/CCkGB.jpg) when I try to load a .py file. I'm using GNU Emacs 23.1 under Win7 32bit with Python 2.71 and a bare init.el except for the load init epy line. Thanks! 
this is gonna cause your eyes to bleed http://www.xs4all.nl/~weegen/eelis/analogliterals.xhtml
The main advantage is that webapps can assume Python is installed (though not much beyond that, and it might be as old as 2.4). Having something like .air files or MS' .application (or even just Java Web Start) would be something for desktop tools though.
Django? The state of Django turnkey deployments is what instigated this entire discussion (see my earlier comment to Ian). The whole thing is in a massive state of disarray, and it is honestly embarrassing as a Django supporter.
Thats the general idea. To start with it will probably be a Django management command that analyzes the current virtualenv and spits out a zipfile with all the libs, static files, etc etc.
Monads are not directly implementable in Python because they were formed for Haskell. But they can be converted to yields and generators with decorators making them consistent with Python philosophy. So the Monad concept can fit inside of Python, provided you work with the syntax rather than fighting it using a lambda construct.
"Symbol's function definition is void: region-active-p" when trying to open a file. can't do anything actually, that error is blocking all editing, saving. looks interesting though.
Thank you for the report, actually he just wants the "pyflakes" program to be installed to have the syntax checking, I'll solve that disabling (or bundling) it by default. Otherwise if you don't need it it's ok to just to set (setq flymake-enable-pyflakes nil) After the (load "~/path/to/epy-init.el")
That is quite strange, I suspect that you're using emacs 22, and you're triggering this bug: https://code.google.com/p/yasnippet/issues/detail?id=169 The fix is to put in your .emacs this line: (defun region-active-p () (and transient-mark-mode mark-active)) I've not tested on 22 so I can't tell much. Thank you anyway for the feedback and the report!
So, I started in on Flask.... I have since realized that I must discard my carefully-constructed class, and instead rely only on functions.... I recognize the benefit, now, though. Not having about five utility functions for return values is very nice, now I can just do return json.dumps({blah: 'blah'}) Thanks a lot! I will probably release a new version, with Flask, within a week or so. The next step is looking into mongodb....
Anyone who takes it to be mean is 'looking' for an attack. I'd say the web2py community has a bigger problem with pyramid than anyone I've known in the pyramid community, although it's unfair to make such sweeping accusations.
*than The quotes at the bottom of the page come off pretty sarcastic.
If you are interested in tornado, you should hang out on our mailing list (on google group) and follow the forks, wiki, and pull requests on github. Tornado is quite popular among startups that are more comfortable writing server side code in python. Example of some of these startups: bit.ly, quora, greplin, etc.
Not to me. :)
Better, but string arithmetic isn't very pythonic. def happy_birthday(name): s1 = "Happy birthday to you!" s2 = "Happy birthday, dear {0}!".format(name) return "{0} {0} {1} {0}".format(s1,s2) I just wish I could think of a better name for the lines than s1/s2. 
yeah. Would also have been nice if he'd used a bigger dictionary. Like several megabytes big.
yes, 22. i suspected something like that, so I got emacs 23.3 (separate app on the mac, not terminal based) and also then put in your starter kit. then I got some stuff to work. snippets were giving me problems though. import datetime insisted on being a django datetime field. it will take me some time. just the other day I downloaded rope and all that and thought I should try it, so this comes at the perfect time, thanks for your work ! eclipse is bugging me but I can't live without import cleanups and the underline-errors-as-you-type stuff. but that popup thing they have around the cursor is so distracting. its a constant perceptual stress just to visually process all the flashing crap around the cursor. and I can't figure out what the colors are to customize it.
Cool, just joined.
I can't exactly call Juniper and say "hey guys, please change your entire stack to support something other than SOAP because it's no longer in vogue", realistically. And I'm more than happy in my job, other than the part that involves working with SOAP (which isn't a major part). I don't think it's unreasonable to point out that Python's SOAP libraries are a bit of a mess, and I don't see why mentioning that it'd be good to have better support for a standard that's still fairly widespread makes me a "Perl programmer".
I completely sympathise; the SOAP specs are horrible and every implementation in every language (JAX-WS, .Net WCF) differs subtly. It's a sucky situation :(.
haha, u like perl i tried to get some quotes from Juniper about a year ago, their sales team is such a mess! i also know a defector from there to Cisco, so i sort of understand why they aren't a bigger company i feel for you
Neat
I strongly agree. XSLT is exactly what you need. Once you wrap your head around XSLT, the code to do the transformation will be much shorter, cleaner and easier to read than Python code. Having said this, it does not mean you couldn't use lxml to call the transformation from within Python.
EPD includes lxml
&gt; I wondered if monads (I probably mean do-syntax) could be implemented in Python. I even googled, but the results[1] were not good: in particular, the implementation I found couldn’t work with List monad. I disagree and of course the yield trick captures lazy evaluation quite well and is even built into Python. The implementation is a bit more complex than necessary and when it was first published I took some time doing refactorings on it. Playing with several monads including List, State, Maybe and Continuation was fun. More wasn't expected.
On the flip side those of you constantly bothered by Google recruiters will be pleased to know that they do have a do not contact list, but you have to ask to be placed on it. Sadly they keep separate ones for Europe and for the US. Google is probably a good place if you [don't care about people](http://www.reddit.com/r/business/comments/cqo9x/is_google_at_risk_of_becoming_the_next_microsoft/c0uj0ro).
Just curious, how do you intend to prove that you are actually from Google?
I was on linkedin for two days before a teh googlez sourcer pm'ed me. They can be relentless. 
Even if someone posed as a Google employee to encourage people to apply...what would it matter?
GMail users are not customers, they are product, but but from everything I've heard Google has terrible customer interaction at almost all levels. I'm not sure that means individual engineers 'don't care about people' though.
I suppose using reddit comments as a 'reference' could potentially be advantageous for some (not in my case, haha). Assuming they'd take the time to scope out the applicants.
That kind of power would scare me more than anything.
Google is an interesting place. As a company Google is definitely biased against adding processes that require human participation, (versus processes that can be automated) and that kind of thinking isn't best for activities like customer support or professional services. But there are two reasons I have to be cheerful about it: First, I have personally seen how passionate individual Googlers (especially engineers) are about doing what's right for users. And second, our output is often flawed, because (and this is my opinion) we learn in public. Each thing we release has tons of customers overnight, and so our mistakes are pretty public. But -- and this is the point -- we learn from our mistakes. And there are lots of really smart people who learn from user experiences and work as hard as possible to make each new version significantly better than the last. If you don't like today's version, perhaps we'll do better for you tomorrow. My two cents. :)
I don't know, I guess I'm not too worried about that. If you're interested, PM me and we can start a conversation. If you think I'm not legit, that's cool too -- this is a casual thing for me and I thought it might be fun.
This is the second time I submit wikipl to reddit. The [first time](http://www.reddit.com/r/programming/comments/efuve/wikipl_the_free_programming_language_that_anyone) I received some harsh criticism which I think I addressed with this new version. Anyway.. what do you think?
Thank you again for your feedback and idea-sharing, this is extremely useful to me to design a better user-experience. I've just edited the datetime snippet to dtime. I tried eclipse too before switching to emacs, but the eclipse heaviness and the project-centered approach gave me reason to switch. Emacs have a decent python support but it's scattered all around the web, I'm trying to reproduce a good environment that does not come in the way.
CamelCase functions are the python equivalent of derping, why not just encode everything in ROT13?
I kind of do wish it gets popular though, I think reading stories about vandalism would be pretty entertaining.
 __builtins__.False, __builtins__.True = __builtins__.True, __builtins__.False
Do you think this didn't cross my mind?? quoting from the FAQ: "Anonymous users and recently signed in users are allowed to edit only the "Development Code" section of the articles". This code isn't tested. You have to be "promoted" somehow in order to be able to edit the code and this is done by making positive contributions in the "Development code" section (and of course being signed in).
Mediawiki treats underscores in titles as spaces. Overcoming this should be easy though..
..and fixed!
Except that this syntax: foo &lt;&lt; bar is actually this: foo &lt;&lt; bar ...sigh.
'self' is an implicit first argument to methods. You need to do something like this: server = smtplib.SMTP('localhost') server.login(user, pass)
What version of Python are you using?
3.2
My original is basically what you suggested: s = smtplib.SMTP('outgoing.verizon.net:587') s.login('asdfasdf@verizon.net, asdfasdf') s.sendmail(me, [you], msg.as_string()) s.quit()s.sendmail(me, [you], msg.as_string()) s.quit() IDLE still wants three arguments. 
You forgot a comma after verizon.net.
I have no idea what you're trying to say, but `&lt;&lt;` is the left shift (`__lshift__`) operator, not a double "less than" (`__lt__`) comparison. The reason that fictitious `&lt;-` operator is particularly unpythonic is that it's not an operator at all, it's an unary negation followed by a "less than" comparison.
That gives the following error (I'm tempted to try this in Python 2.x). s.login('asdfasdf@verizon.net','asdfasdf') File "C:\Python32\lib\smtplib.py", line 614, in login raise SMTPAuthenticationError(code, resp) smtplib.SMTPAuthenticationError: (500, b'5.7.0 Unknown AUTH error-1 (Internal authentication error).')
&gt; smtplib.SMTPAuthenticationError: (500, b'5.7.0 Unknown AUTH error-1 (Internal authentication error).') You need to add parameters to authenticate against your SMTP server, or set up your server to accept connections from localhost without authentication.
Verizon would let me do that?
Does anyone know if there is a way to write a plugin for inkscape in the same fashion. I need to edit some PDFs which I can open in Inkscape. I know I can use PyPDF or ReportLab to get granular but I was looking to add a plugin that would globally replace an image across a large number of PDFs. Perhaps there is an Inkscape alternative more python plugin friendly?
Oh, I see that you have the params there. Check that they're correct, and if you need to, turn on SSL/TLS/whatever. Also, try turning the debug level up: &gt; SMTP.set_debuglevel(level) &gt; Set the debug output level. A true value for level results in debug messages for connection and for all messages sent to and received from the server. 
base64 your email + password. import base64 base64.b64encode('asdfasdf@verizon.net') base64.b64encode('asdfasdf') Use telnet to troubleshoot smtp issues telnet outgoing.verizon.net 587 HELO AUTH LOGIN copy/paste b64 encoded email copy/paste b64 encoded password Gonna guess you get the same error message along the way. This will at least tell you if it's your code, or the remote SMTP server.
&gt; and neither is laziness All the stuff like range/map/filter is lazy in Python3. &gt; Monads are not Pythonic Your notation is definitely not Pythonic, that is true. Also, rather cumbersome and magical (`Var('a')`, ugh). Why don't you go back to the basics and rewrite the more interesting things as desugared function applications? coin = Probability(lambda: [(1, 0.5), (0, 0.5)]) f8 = coin.bind(lambda fc: coin.fmap(lambda sc: fc == sc)) (where `.fmap :: M a -&gt; (a -&gt; b) -&gt; M b` and `.bind :: Ma -&gt; (a -&gt; M b) -&gt; M b`) Do-notation is neat, but hardly necessary, and you'd be better off if you understand the underlying principles of monad composition and learn to use them in any language, rather than try to implement the superficial syntactic semblances. Also, you might want to read [this post](http://blogs.msdn.com/b/wesdyer/archive/2008/01/11/the-marvels-of-monads.aspx) about how C#'s LINQ is a monad comprehension. Again, looking at different implementations of the same concept is immensely useful for understanding the full meaning of the concept.
And Py2.7 wants three arguments for login() also.
In other words it's me, not Python, that's at fault.
Yes. Because you put the comma inside the string rather than passing two strings. So you're passing _one_ argument in addition to the implicit `self` argument you pass by calling it as a bound method, i.e. _two_ where it expects _three_ (two plus self). The other error you're getting is raised by smtplib instead of Python and indicates the authentication fails for some "internal" reason. The quoted message stems from the server.
It's fairly simple, but gets the job done! Basically it uses latex, dvipng, and base64 to create base64-literals out of the LaTeX expressions. Here is an example: %Hello, world!% This is regular text, but this: $y = mx + b$ is not. The output: $ markdown -x latex test.markdown &lt;p&gt;&lt;img class='latex-inline math-false' alt='Hello, world!' id='Helloworld' src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFwAAAAQBAMAAABpWwV8AAAAMFBMVEX///8iIiK6urpUVFTu7u6YmJgQEBDc3NxERESqqqqIiIgyMjJ2dnZmZmbMzMwAAAAbX03YAAAAAXRSTlMAQObYZgAAAVpJREFUKM9jYICDOgb2BwzYAVji8AQg8fb/PZ79u4AMvv0Mrz/gUA6W8F7AmcLAsJuBYT7Y1PcMfLiUgyWYF/B8Z2DYAVReABKrZ2DHpZwdopzrA0nKOeHKj66CKOcKPQJWwJo2NVFhfwCQyymhYwCUYD0avIApgYFh2927/QUcE3gDwMpvMhRCDJzNMIPhKZg7UW8DUOIMg9sCPgGo6e8ZODeAlAP9xLEArNy/IIwhAMx9D3IM+3cgi70BqnxZaNQFkHJWAQbeBrByjgURExaAuc9AyjnB5hjAlEO9ygVXzrplpskEMPchQvkBmGMcGApgjjkAVs7yhyWVAcwFK2f/AlJeAI0m5gMsEK+aMhQ6aDuA1DcDIZirBg7IOwxlB5g2QBJBF8OZVUz95hqfC3hOXWGYrwBSHskwk4EByGXab8QAlOBaGizFKYAtUlgUGEgBTCSpZnDCLQUA+y6MXeYnPDgAAAAASUVORK5CYII='&gt; This is regular text, but this: &lt;img class='latex-inline math-true' alt='y = mx + b' id='ymxb' src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFIAAAAOBAMAAABOTlYkAAAAMFBMVEX///9ERETu7u4yMjK6urp2dnZUVFSIiIjMzMwQEBDc3NwiIiJmZmaYmJiqqqoAAADS00rKAAAAAXRSTlMAQObYZgAAAOtJREFUKM9jYCAACsCk4wYGgiABTLInEKuS+QGxKvkVGBj47jBwI8tcffI84e45BoZ7GVcLECo9751iWLeSoRPITBQEggMMDBy9sxj2MDgz8DIE8yCpPMxwjWFBGUMMkpFcbAEMvxjKGLgYxIE8NkHBiYIyQMY+hmoGhi0Mdsi2czawbGCQBTJ+ILvzE0MaA9MHIIWwnWE9A+sBpk8LGDgmMCnAVXJNYPgCJHhRQvUiA/cDXoECZx4DXoSZTBtYgaaEPw5AVnkOGBRc5xTcbsReQrL9+nWwyxbgC88DcJZ+QygDcYD1+QPiFAIAtLA8KPZOGFEAAAAASUVORK5CYII='&gt; is not.&lt;/p&gt;
[/r/LaTeX/](http://www.reddit.com/r/LaTeX/) might like this
This deters vandalism at best, you have too much faith in humanity.
Best viewed with Readability http://www.readability.com/
Definitely! Sounds good.
For some reason they've made the [bookmarklet](https://www.readability.com/bookmarklets) version hard to find now. I guess they want to push their browser extension. I have enough of those, thank you.
Ugh sorry about that, I'm not sure if something changed, but I've gotten a bunch of complaints about that. I'll try to fix it.
What's the problem? I can read it, but maybe it's been fixed ...
Very interesting insights. The ctype hack is only for writing, right? Wouldn't there be a still huge speedup without it? However, I can understand that they don't allow ctypes tricks; but then they should be clean about.
&gt; However, I can understand that they don't allow ctypes tricks; but then they should be clean about. It seems not to be about a ctypes *hack*, but about using ctypes at all: &gt; ctypes =&gt; "interesting alternative" &gt; Shortly, I had an email saying this has been accepted as an "interesting alternative" because it used ctypes, which is to say it won't be included in the cumulative timings for each implementation, nor will it be listed with the normal implementations for the per-benchmark scores.
I haven't changed a damn thing :/
Thank-you for working on soaplib! SOAP may be horrible but there's few alternatives for a (programming) language agnostic RPC standard. CORBA anyone? In fact, the main issues we had were in suds rather than soaplib; we submitted bug-reports upstream. The biggest issues with soaplib is the confusion over which version and which git-repo is official.
I'm sure the shootout hackers are doing their best to be impartial and try to avoid gaming the system, but this post really highlights a problem with the way they run things. If you don't clearly and unambiguously declare what constitutes «cheating», then people are going to get very frustrated when they try to write the fastest code the can, only to be told that their solution violates some unwritten, secret rule. 
It's a big wall of text. You might want to restrict the paragraph width for starters. Much like it's bad form to have code that is wider than 79 characters, it's generally a good idea to limit prose to about 70-90 characters per line because it requires less eye movement, making it harder to get lost and easier to scan. You may also want to keep your paragraphs a bit shorter. The current height is okay; I would say you should try to keep your paragraphs about 2/3rds of the size they are now (this would allow you to reduce the width while keeping approximately the same height you have at the moment). To make the smaller column width work better at higher resolutions, you may want to look into a bit of JavaScript and CSS to turn the layout into a multi-column one for higher resolutions. Alternatively, you could just add some pictures (e.g. graphs of what you're referring to) or code samples where relevant. Of course, sub-headings help, too, and allow people to skip straight to parts that interest them.
This is pretty neat, but I can't make flymake nor ropemacs to work. Emacs 23.3.1 in archlinux here. Any idea ?
This SOAP library works surprisingly well for me: from suds.client import Client Then it is like this: GS = Client('https://api.yourservice.com/v3/GlobalService.wsdl') print GS and you see the methods 
Thanks, I was already thinking they retired the bookmarklet.
Same experience here with LuaJIT. My submissions using low-level types (byte arrays and such) were put into 'interesting alternative', too. Almost all other languages can use byte arrays, when they are the appropriate data structure for the job. The C submissions make heavy use of GCC extensions, Haskell gets to use mutable (OMG!) byte arrays and Free Pascal has about as much in common with Wirth's Pascal as the name. But Python and Lua are not allowed to do that? Apparently not all languages are treated equally. Dismissing submissions by resorting to a flawed definition of 'standard' and then suppressing further debate is really lame. I contributed almost all of the Lua programs to the shootout, but I do not feel particularly encouraged to continue contributing any programs.
Seconded on the soaplib confusion - I recently started using it and I'm not sure which repo(s) I should be looking at. But otherwise, excellent library! We were able rewrite some very painful 1500+ lines of ZSI junk into about 125 lines of equivalent soaplib code in an about a day.
We use and love Tornado and ioloop.
I'm on Arch aswell, i have the same problem. I guess it's because flymake and ropemacs require Python 2.x where Arch default is Python 3.x
We're pushing the addons because they're easier to install (= less support emails) and have a keyboard shortcut. We're totally cool with sticking with the bookmarklets, we just didn't want to muddy the experience.
What same stuff is available for free?
I'll just go ahead and preemptively answer the reply with "Eclipse/PyDev sucks"
Too bad the firefox addon button looks ugly and misplaced :(
I'm sure they are more inclined to say something is cheating than not if they don't fully understand it.
I'm on arch as well! I've put in my .bashrc this line: export PYMACS_PYTHON=python2 It doesn't work if I open emacs from the menu thought (bashrc in this case isn't loaded) For flymake this is quite strange it just needs 'pyflakes' (community/pyflakes)
If you're considering changes, my top two would be: more whitespace—especially between paragraphs—and either a variable width column or a narrower column. Testing in Firebug indicates `1 em` is probably enough for the `padding-bottom` rule you attach to `p` tags. As for the column, if you go the "narrower fixed" route I expect some people will complain bitterly, so I'd say it's lower priority, but something along the lines of 600-700 pixels is probably enough for the body content at that font size. To my eyes, 720 and 640 both looked very nice.
That solved the problem for ropemacs, but still nothing with pyflakes. Maybe a conflict with something else. I'll to deactivate other things in my .emacs
I think this was brought up on reddit or in the web2py bug reporter before, but I remember mdipierro remaining adamant on not porting it to python 3 any time soon. edit: found it: http://www.reddit.com/r/programming/comments/dwe6f/who_is_using_web2py/c13fzjh
He should really work on his english and design skills if he wants anyone to read that.
This, and that is the problem with not allowing disputes via their current system. It's an understandable situation to be in, but you should recognise when there is a flaw with your design and they haven't. So it's too understandable when you start losing credibility and participants, if you can't keep up and adapt you're going to fall to the wayside. 
Or [iReader](http://samabox.com/extensions/iReader/). This article prompted me to investigate both options, and I found iReader to be nicer in my opinion.
&gt;speed (as it’s normally defined) is really really uninteresting I use python for numerical stuff, and I care **a lot** about speed. I've been writing performance critical stuff in C and wrapping it into python for ages. If PyPy allows me to run numerical code written in python at a speed close to what I achieve with C, it will improve my productivity a lot. tl;dr: web developers, you're not the only users of python.
Alternatively, if you are impressive academically and professionally with a strong entrepreneurial drive and desire to do things that aren't possible at most companies... start your own business.
Beginners mistake most likely. For this type of processing you need to be aware of the data structures you are using. Using numpy arrays or a bit of inline C makes all the difference.
I think you're looking to deep into it. The creator of web2py ([mdpierro](http://www.reddit.com/r/Python/comments/ggh70/the_pylons_project_announces_web2pyramid/c1ndhjf)) has a sense of humor about it which earns him a good deal of respect. Honestly, it's difficult to pull off an April fools joke without offending at least one person lol. 
I think pretty much anyone that use numpy cares a great deal about speed.
&gt; I think the most interesting work in programming languages right now is about the runtime, not syntax or even the languages themselves With a profoundly novel observation like this, there wasn't much hope for the rest of the post, which seems mostly a bunch of hand-wavey bollocks apparently totally ignorant of the history and goals of PyPy. &gt; Shared objects across processes with copy-on-write; then you can efficiently share objects (like modules!) across concurrent processes without the danger of shared state, *Bla bla this would be amazing, implement my amazing idea even though I don't appear to have a clue how it might be made to work, what it might look like or what benefit it might have, but it sounds cool..* &gt; Being a web programmer *..and that's what matters* &gt; # Cython — it’s doing a lot of good stuff, and has a much more conservative but also more predictable path to performance (through things like type annotation). I think it’s worth leaning on. I also have something of a hunch that it could be a good way to do FFI in a safe manner, as Cython already supports multiple targets (Python 2 and 3) from the same codebase. Could PyPy be another target? I can't even decipher what he's suggesting here. On the one hand the project should discard Python's semantics/heritage/binary/API compatibility for a bunch of unproven buzzwords, while in the other they should *lean on* a source-to-source translator fundamentally shackled to the C runtime model. Smoke crack much?
why do you say that? I think the web2py community has a lot of respect for Pyramid. I for sure do. I also stated in another post that I did find the joke funny and not a bit offensive. But just think for one second... pyramid people pulled a joke on web2py while the web2py community never pulled a joke or said anything negative about pyramid. Somebody pointed this out to you and you conclude "web2py community has a bigger problem with pyramid than anyone I've known in the pyramid community"? I see a problem with basic logic here. Unless you know something I do not know. In this case please prove your statement. 
okay, so you have three lambdas and say that your code is pythonic? please don't take all of these seriously. I wanted to release it at April, 1st, but got drunk. I like my syntax and I don't like an idea to make a complicated syntax more complicated by annoying object oriented syntax and shit I should have overriden `&lt;-` operator for strings in cases where you're in the monad, and maybe `'a' &lt;- blah-blah` will prevent myself from haters by dropping more directly in the funny zone. sorry for that 
&gt; I think the most interesting work in programming languages right now is about the runtime, not syntax or even the languages themselves. I disagree. I think the forefront and most interesting work is in the Dependant types field, where proof-carrying-code is quickly becoming more and more practical...
I would use this.
Indeed. The post seemed incredibly focused on "changes that can make some version of python do something that I want". I liked the idea of getting memory usage down; but even as a web developer, his lack of concern for speed seemed - strange. And as for the other ideas, the idea of taking PyPy (or any major python runtime) in a non-compatible direction seems foolhardy at best... WIth the emergence of PyPy as a real contender, and Jython / IronPython getting themselves well established as mature projects, it seems to me like the overall goal for Python would be to do everything possible to keep the runtimes as to feature parity as possible, so as avoid fragmenting the overall community. I think they are moving in this direction, as I've read talk about the stdlib development track moving away from being so closely tied to cpython, towards providing a common codebase usuable by all the runtimes (thus reducing their need to fork &amp; patch it for compatibility). Towards that end, I think it would probably be unwise for PyPy to try moving in a divergent direction. Some of his suggested features would be interesting; but as a major development direction, not such a good idea.. especially given how stackless was always mindshare-limited due to developers trying to avoid runtime lockin. While he says he chooses runtimes based on features they offer, I think most of us choose runtimes based on which one best satisfies the environment we're trying to drop python into. As such, their best feature is that they all behave reliably the same on the python side, while integrating as close as possible with their host environment (C / the host os, java, .net, or whatever). Given that, I think the best goal for PyPy *should* be Cython compatibility, speed, and memory usage. Which seems to be generally where the project is heading.
&gt; okay, so you have three lambdas and say that your code is pythonic? Two lambdas, and yes of course it's Pythonic. I don't know where you got the idea that lambdas are unpythonic. Look, the most important question is how to make the code as clear, clean and simple as possible. When you do that, it is "Pythonic", by definition =) I think it should be obvious that my variant is cleaner than yours, in this particular case. Also, don't get me wrong, but I think you have to work on your attitude to all this stuff, for instance you obviously have a misdirected Java-fueled hate for OOP, which prevents you from seeing that monads (and their numerous functor cousins) are typical objects, encapsulating things and providing opaque methods for manipulating their state (in an immutable fashion, but that's details). So it's _natural_ to implement functors and monads as classes and operations on them as methods, in languages which allow that. Moreover, it actually results in a cleaner code than the traditional right-to-left function application approach. You can't achieve satori until you shed your prejudices and learn to see the single truth beneath superficial differences!
&gt; Bla bla this would be amazing, implement my amazing idea even though I don't appear to have a clue how it might be made to work, what it might look like or what benefit it might have, but it sounds cool.. First, microprocesses: isolated interpreter states that run concurrently in the same OS process. That's not rocket science, CPython even implements this (though in a dark and unused corner of CPython). Second, shared objects: It means implementing copy-on-write for objects. This is of course only interesting if you have multiple interpreters in-process that all have access to a single object. This is similar to when you use `fork()`. Right now CPython doesn't work well with an OS fork because it's constantly writing to objects to do reference counting. Also not everything can be easily shared over a fork, but with careful programming you could do more sharing and not be constrained to what Posix (or even worse, the subset of Posix and Windows) allow you to share. Without this sharing of objects you are basically reverting to doing a complete subprocess, loading up all the libraries all over again, and duplicating all the necessary memory even when it's not strictly necessary. As a result creating new processes is heavyweight, while this would make it lightweight. Re: Cython: There are efforts underway to make Cython target more than just CPython's APIs, and as mentioned IN THE FIRST COMMENT there is a GSoC project proposed to get Cython to target PyPy. Now exactly what that means is a little fuzzy -- PyPy itself isn't what you'd target, but you would target a runtime specific to PyPy (which AFAIK is essentially nameless, or at least they are all bundled together as one project).
Actually the proposal on the table is to have it generate pure python and use ctypes for FFI calls :)
pip 1.0 and new virtualenv, both with Python 3 support. You have no more excuses.
&gt; but even as a web developer, his lack of concern for speed seemed - strange. I think his point was that it's already fast *enough*, and he'd like to see them focus somewhere other than raw speed. &gt; the idea of taking PyPy (or any major python runtime) in a non-compatible direction seems foolhardy at best Remember that PyPy can have many backends; he's arguing for the creation of a PyPy backend that he thinks many people would be interested in. Creating a new PyPy backend != abondoning the CPython-compatible one.
I somewhat disagree and believe it leads to code which is overspecified and rigid and where compiler errors are hard to understand. Anyway, this is pretty much off-topic for Python which will never get dependent types and is mostly indifferent to the love and care of academics.
&gt; tl;dr: web developers, you're not the only users of python. numerical developers, neither are you. Why hate on ianb for simply presenting his viewpoint as a web programmer? He never claimed that they should do what he said, and implied with the title of his post that he knew that other people had other priorities. And you wouldn't find microprocesses interesting?
&gt; code which is overspecified and rigid Why would it be overspecified? You get to specify exactly the properties you want proven, and leave the rest unproven. In fact, such powerful types make specification changes and drastic code rehaul easier, because unlike unit test, types would continue to give valuable feedback even as you shift the code around and make drastic changes. &gt; and where compiler errors are hard to understand They are still easier to understand than a customer bug call in the middle of the night :-) On a more serious note: A hard-to-decipher compiler error at the initial implementation phase, where you have to stare at the error and mess around for countless minutes is far cheaper than a bug that slips through to production. 
I don't comprehend what copy-on-write for objects might mean. In terms of fork() as you likely know, it refers to page-sized chunks of memory that can be efficiently shared (and unshared) thanks to CPU/MMU support that's been ubiquitous for decades, but a Python object (module, or whatever else) is something more like a small, highly granular spine attached to which are many 4/8 byte appendages referring to yet more objects. What it might mean to 'copy' one of these when a modification occurs isn't clear at all. What gets copied, and how might it be implemented on any current hardware in any kind of efficient/beneficial way, except by putting everything into a single address space (at which point, I'm confounded the post's mention of doing this inter-process). Thanks for the clarification on Cython, in that PyPy might benefit by encouraging its adoption as the standard approach to writing native library bindings, when it targets both runtimes transparently, this makes some sense.
&gt; First, microprocesses: isolated interpreter states that run concurrently in the same OS process. That's not rocket science, CPython even implements this (though in a dark and unused corner of CPython). All of it is implemented except the GIL is shared across all interpreter instances. Additionally many C extensions use static data items which means they can only work with one interpreter instance in a process. 
i have one more excuse
I can't find the very statement, but from this particular blog post we can see that Guido does not like the concept of lambda in Python: http://www.artima.com/weblogs/viewpost.jsp?thread=98196 &gt; you obviously have a misdirected Java-fueled hate for OOP thank you for that. I actually don't think I want to argue with you anymore. Please make stupid conclusions from this decision too if you want to.
Single-script installer: $ curl -O https://github.com/pypa/pip/raw/master/contrib/get-pip.py $ python get-pip.py 
So say we all! (as long as your threshold for uncertainty and rejection is high enough)
I use pip when I can, but its inability to locate or install eggs and binary distributions means I'm still using easy_install quite a bit.
#1 excuse http://code.google.com/appengine/docs/python/overview.html everyone that upvoted you is an idiot. :)
hint: run `pep8` on that, it will tell you quite a bit :-)
Waiting for pyuno...
IPython, Matplotlib (officially).
i was referring to sixohsix's claim that there's no more excuses to not use python 3. :) 
&gt; It cannot install from eggs. It only installs from source. Does that mean it can't install stuff like NumPy unless you have a compiler?
Yes. 
Fabioz did a great job with PyDev, but the underlying platform is a problem. I used Eclipse for a year and a half, but after various updates, I found it unstable, and horrible Mac keybindings (which I've had to fix a few times), dodgy version control integration. I gave up tried Aptana, found the same problems, and then back to Eclipse. I tried getting friends on Eclipse, they had a horrible mess on their hands which I could not dig them out of. For some reason, Eclipse was just messed up out of the box on their systems. The whole platform has become quite brittle and buggy. I finally switched to PyCharm, and the thing just works out of the box. [**EDIT** PyCharm=&gt;PyDev]
:(
Twisted is my main excuse.
how do i do that? [edit] figured it out. that was really useful! thank you very much. obviously my format needs a bit improvement, haha. i think i am getting a hang of it though. would you say it looks like i'm doing well, though, of being about 4 chapters into my first book? (plus, a little research on python modules... haha)
Ahh...this is a big issue. soaplib has had a tumultuous past, the official repo is https://github.com/soaplib/soaplib it shows as being a fork because it was time for Burak to take some time away and opted to take soaplib in a bit of a different direction (hence the name rpclib). The 'fork' was as friendly and genial as a fork could be. He willing shared the pypi key with us and actually gave us the organisation soaplib....he didn't appreciate the whimsical (and rich in the pythonic tradition of silliness) name for the organisation I had chosen. Burak is still welcome as an owner of the organisation and I hope that when comes back he decides to contribute.