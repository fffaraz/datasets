All ye who have *not yet* started designing a blog engine, please consider designing a Typesetting engine.
i prefer: globals().__getitem__("b"). I find it clearer ;)
 def bottle(): global b import bottle as b bottle()
Whoa, web programming in Python 3! The linked image is not shown for me. (img.ur seems under maintenance.) 
It's a synchronous HTTP call; you don't give it callbacks. It will block until the response comes.
*self
It was under maintenance when I went to check it to, I changed the url from http://imgur.com/a/O1NcN to http://i.imgur.com/O1NcN.jpg NSFW (removing the 'a' and adding a '.jpg'). The op has some interesting blogging software there.
I looked through the source code and noticed: class Post: At that moment firstly I think it is an old-style class, but after a while I realized it is written in Python 3.
Check the latest updates of [PyPI][] ([RSS][1]) and [PEP index][] ([RSS][2]). [PyPI]: http://pypi.python.org/pypi [PEP index]: http://www.python.org/dev/peps/ [1]: http://pypi.python.org/pypi?%3Aaction=rss [2]: http://www.python.org/dev/peps/peps.rss
I have the same feelings. I recently made a Stack Overflow account and a GitHub account - so far I'm not sure if it's helping but it's certainly motivating me to code more and hopefully someday put more of my own code out there and share it with people. It's also cool to look at other people's code for their (better and more interesting) projects and use some of their techniques in your own code. I've been trying to find code problems on StackOverflow that match my skill level and answer them - they say if you want to truly understand something you should try to teach it to someone else... 
Steve huffman is going to host a class at udacity.com starting on the 16th. It's web application development and the goal of the class is going to be to develop a blog. 
Unless you were a bad monkey and wrote code that depends on the order of elements returned by iteration over a set/dict (and then, only if you run in randomized seed mode).
More like uprooting HTML+CSS. But yes, fundamentally within CSS, and markup agnostic. Devote real work to extracting the maximal functionality from a simple subset of the existing toolbox. Make people want to use your layout and typesetting engine like Adobe did way back when they wrote postscript. I want to give the web new life, not more blogs.
&gt; Do I have too naive idea to security? I'd say so. It's not as heinous as the PHP `register_globals()` debacle but given how ubiquitous dictionaries are, it makes sense to consider it a language-level security flaw.
I prefer counts[character] = counts.get(character, 0) + 1
I do too, davidwosterfallace, and `setdefault` is a good method to know about as well. I wanted that example to be intuitive for OP though, incase there's some serious stress about "learning python" going on. The concise idioms are intimidating when you haven't learned the manual way yet.
David Woster Fallace! People usually go for Dallas Wort Forth, or Dallas Worth Fort. It annoyed me that `setdefault` did not seem to be applicable here, except insofar as it emulates `d.get(key, default)`, but then I remembered `get`.
I think in Python we have a case of the cobbler's children going barefoot. Dict is so fundamental to the language yet acting on dicts is always a touch hairy.
A ["planet"](https://en.wikipedia.org/wiki/Planet_%28software%29) is a news aggregator. It basically collects posts from a bunch of blogs into a single feed. 
Read r/python, read planet python, follow some pythonistas on twitter or google+ (Guido van Rossum, @holdenweb, @raymondh,...), listen to radio free python, watch all pycon/djangocon videos or even better go to these events, visit local user groups, subscribe to pycoders weekly. (sorry for no links, I'm on my tab, google should be helpful here.) 
this isn't working for me, i did an easy install of pyglet. Any ideas?
Python powers Reddit, of course you can!
http://stackoverflow.com/questions/2557193/python-dict-fromkeys-returns-empty
Thats great :D Any books you can recommend about learning it?
[http://www.pythonweekly.com/](http://www.pythonweekly.com/)
Ah of course, thanks!
http://mail.python.org/pipermail/python-dev/ http://mail.python.org/pipermail/python-ideas/
Next you build your own interpreter loop that looks like the builtin one.
It takes a some time to initialize the program. First time I ran it I just got a blank window. Second time I ran it, I waited and the program ran fine.
repost. this has been floating around
I’m working on this: http://weasyprint.org/ Is it what you mean? You can use Markdown with WeasyPrint. We use a combinaison of Jinja and docutils.
Heh, came here to say the same thing. I hate (well, hate's a strong word, dislike) having to watch a 10min video expressing something that could have taken me 2 minutes to read as a blog post.
Python &gt;=2.7 required
A few installer issues have popped up. Although really, it's not so much Git On Windows, it's just that I've been raised in the Cult Of Hg and I need to spend a good amount of time learning Git so that I can decide if I actually like it or not.
Why thank you, fine sir! I just started work on categories as well, if you're interested.
Or by using one of dozen asynchronous networking libs for net IO heavy apps.
Don't. Stop.
Forked it: https://bitbucket.org/dAnjou/blatherblog Sorry, I wasn't able to split up the commit. I don't know Mercurial and I missed `git add -p`. Maybe you can use it. If you agree I would like to put the fork on GitHub (with attribution of course). Then I pull once in a while from your repo and push it to GitHub ... as long as I'm interested, which may not last very long, but still.
A correction to the top answer: fromkeys() is a static method, not a class method. Class methods are for manipulating the class itself (as opposed to manipulating an instance). Static methods live inside of the class to bundle together functionality.
 email = mailinator.get_newest_mail('my_username', time_delta=5) Is this supposed to time-out to exception in 10 minutes if there's no message ?
Seems like this might be a bit overkill, but I guess if you are already using redis and you don't mind posting your tracebacks to a public service, it might make sone sense.
Start with http://pythonmentors.com/
I almost got myself to implement something like this for xmpp conf, but new sentry/raven is too good to be overthrown in a hackathon-style like this.
Why? Just because this person asked for it, or because you want to move to Github? You just posted the Bitbucket link not long before this was asked.
[This stackoverflow answer](http://stackoverflow.com/questions/3622455/what-is-the-purpose-of-mock-objects) gives a good overview. In your case, the idea would be to create objects that simulate IMAP and SMTP interfaces and then allow you to test that the caller did what it was supposed to. These objects wouldn't send any mail, but would simply store each message they were given and then let you validate the messages they received were correct. 
As an advice, you should also check the differences between unit test and system test. After that, you will know that why mocking is important in unit test.
It's super easy to setup logging to email with the logging module's SMTPHandler.
I like the MVC stuff in Django. Its easy and fast to develop in and I am used to it - plus it integrates really nicely with my IDE (Pycharm 2.5). I partly agree, but I never use the admin stuff anyway. Flask seems a little bit too small and lightweight to use for a large project and Pyramid seems too alien and large.
In general, you can tell a mutating method from a non-mutating method on the basis that a mutator will return `None` and a non-mutator will return something.
So, static site generators projects are the new blogging engine projects? :) What makes this one better than all the other 378032 similar projects? Honest question.
In the Perl world, writing your own templating system seems to be a "right of passage". Or at least it seemed so a couple years ago. :) Every language has something I guess.
I see. Thanks. 
From skimming through the documentation (not tested it yet), the support for posts in multiple languages is a big plus, not to mention the "auto" image galleries.
I would say choose the areas that interest you most. Even though I'm impacted by core dev discussions and decisions, that's not an area that interests me. I follow the tkinter-discuss and python-win32, which are the core modules I use the most.
I don't really care about either one. Sometimes I type `easy_install`, sometimes I type `pip`. Whatever works.
haha, yeah i'm inclined to agree. i hope the ideas were interesting, though -- it was a fun hack to throw together.
used it a couple times , now r/python is my go-to place
I'm also enrolled in the new classes and last hexamester. Your search engine looks great! Out of curiosity, what did you do to implement it so nicely in a web page?
Nice.
it uses mako ! woo hoo
Thanks! I wrote a lot of notes [here](http://davedavefind.tumblr.com/) on how I implemented everything, but short answer is the [Bottle](http://bottlepy.org/docs/dev/) web framework on [Google App Engine](https://developers.google.com/appengine/), with style help from [Bootstrap](http://twitter.github.com/bootstrap/). Bottle and Bootstrap were pretty easy to learn, but I struggled a bit with App Engine. The documentation isn't really aimed at beginners. 
This is awesome, and your post is inspiring.
&gt; reStructuredText as input language IMO this must be an option in any blogging platform.
Did you use all the 7 weeks for the course or did you complete it earlier than that?
Oh god. You just made my brain explode with images of this: class Foo(object): def bar(*self): return "Why would you do that?" 
The two exception being pop(k[, v]) (remove by key and return the value or v) and popitem() (remove an arbitrary key/value pair and return it as a tuple.
I started the cs101 course a few weeks into it, but it was easy to catch up. I was in a similar situation as you in terms of not having any cs background, and found udacity very helpful and instructive. I'm really looking forward to the next classes (honestly I keep checking at work to see if they've released the videos yet, haha) I'd highly recommend udacity to anyone who is interesting in learning to code
&gt; We never actually implemented the search engine Wait, what? Explain. That would seem to knock several points off of the experience. 
Pfff, it's [broken](http://davedavefind.appspot.com/search?search_query=porn). On a more serious note, I watched the first 2 sets of lectures and gave up. I already know python and since I learned on my own without any books or classes, I thought that it would help me fill the gaps. However, lack of time and lack of interest forced me to quit the course. I am now taking the coursera's nlp class and I really enjoy it! Good job on the search engine!
Where are the screenshots ?
Thanks for the recommendation and example.
I'm glad that you're learning cool stuff, OP! However, I sort of wish you could do it with a different site.... Udacity appears to revolve around Flash, which is a non-free technology. On top of that, I doubt they properly teach you about licensing and digital freedom, so you'll probably be more shaped by the people around you who make non-free software than, say, the folks over in /r/freesoftware. If that's the case, all of these new programmers will end up being a force for evil, helping software manufacturers further their goal of enslaving software users. Please, do better. Learn about free software, and use those principles to guide your newfound skills.
A cursory glance tells me none of the courses focus on any non-free software. You're expected to use Python for the beginner ones (I can't find any language information for some of the advanced ones) so you're not locked into a specific OS. I doubt they're using Flash for their videos because they don't care about Freedom; it probably has to do with it being the most-supported video format. What gives you the impression Udacity is anti-Freedom? It appears to be fairly agnostic.
First, I'm pretty sure "most-supported video format" is debatable, since many people don't have a Flash player. Second, my entire point was that Udacity is agnostic. When a programmer doesn't learn about digital freedom, they're easily corrupted by people who want to work against it. Udacity should better serve the community by actively defending digital freedom, not by being agnostic!
Just FYI: Your search engine page doesn't work at all for me. Firefox 10.0.2 on Linux. I cannot access or type into the textbox and the search button does not click (also no hover icon). The About and Help dialogs work fine. I disabled AdBlock Pro and Ghostery in case they were blocking some kind of functionality. Now the Twitter and G+ icons appear, but still no ability to type or search.
No other one could recreate my blog without moving pages around, so I did one that could :-)
at least I didn't reinvent make, mako and bootstrap while I was reinventing that other wheel ;-)
And your argument is that all kids care about evolution? Or do we teach it to them because it's something that they need to know about, an important part of who they are that will ultimately shape their worldview as people? We *need* to teach people about digital freedom, because it is *objectively* important, just as evolution is. This digital age runs on software, and if the people don't have control of the software, they will be subjugated just as they were when the Church controlled the printing presses. My opinions, maybe, are stronger than yours, but letting people know that digital freedom is important isn't an opinion, it's stating a fact. Admittedly, the GPL isn't the freest license, it is somewhat restrictive in order to fight a battle that nobody, apparently, cares about. If the GPL weren't around, Free Software would have died out, and the people would already be under the thumbs of dictators, and *not* just in the Middle East.
Thanks for making it open source
The spec is sufficiently picky that I would just use an existing library. For example [I trust you are using `\r\n` as a line-separator][1]... [Postel's law][2] is worth following because you can be confident that people will actually be able to read the data your code emits. And since in this case someone else has already done the hard work (vObject even has work-arounds for specific crappy consumers like some versions of Apple's iCal) then why not? [1]: http://tools.ietf.org/html/rfc5545#section-3.1 [2]: http://en.wikipedia.org/wiki/Robustness_principle
The spec is not as simple as you might think. Definitely worth using a mature and tested library. http://tools.ietf.org/html/rfc5545
http://xkcd.com/353/
Upvote for one of my favorite XKCD's.
I sometimes type easy_install and sometimes pip. I can't care less as long as the library is installed.
My question wasn't why was a static site generator (SSG) better than a blogging engine. It was what makes this SSG better than all the other SSGs.
I want to argue that development of non-free software is unethical, because you're telling users that they cannot do things that they rightly *should* be able to do, absent a *compelling* reason. Those things are closely tied to freedom of speech in this age, so it's a very high standard to uphold. And a law professor tries to defend free speech, even when the Patriot Act and similar bills are continually passed. Free software, by the same token, should be defended by its proponents, even when non-free software is not universally accepted. As to people not caring, or not agreeing, I cannot accept that those two things are a product of people actually disagreeing with freedom--are people so jaded, now, that they no longer wish to be free? Because that's insane.
If you're trying to do scientific python on windows, consider [python(x,y)](http://code.google.com/p/pythonxy/), which installs python, most scientific packages you need and spyder.
:D (plus it sounds really well featured so hopefully this will mean fewer reinventions down the line)
I'll have to crawl again. This is the internet: there must be some in there somewhere!
Most Pythonistas prefer the hg philosophy - after all, it's pretty Pythonic. I'm one of the strange ones who more closely identifies with *nix, which is where git gets its ideas from. After all, it was created to manage the Linux kernel, so if you have fundamental issues with the way Linux is, you probably won't like git so much either.
I'm starting from an expectation based on facts, as above: That tools should give freedom, not restrictions. Without the freedoms to use, modify, and distribute knowledge, we would be stuck in fiefdoms, toiling in farms. Instead, we were allowed, after many years of revolutions, to print and read books. There *is* a natural correct solution, and I don't assume it, I know it! Tools aren't meant to be secret, they're meant to help everyone, not just their creators. And the creators' "rights to control and profit from" aren't somehow lessened by allowing the users' rights. The author of a program can still change it, and can still charge for the service of modifying or adding to it, *and* can still charge for the distribution. Nothing about free software makes it impossible for a programmer to make a living, that is a common misconception. &gt; The vast majority of people can't program, so the freedom to examine the source code is meaningless to them. Actually, no. They can hire someone to modify the source code, or use the source code to *learn* to program. In fact, without source code to study, it would be nearly impossible to learn. &gt; GMail gives us freedom [Riseup](http://riseup.net) gives me that freedom, *and* I can tell what's running on the server, and modify it. &gt; Flash can represent freedom - to watch things that would otherwise be inaccessible. I can find those videos on YouTube in WebM format, which is free, or on archive.org, which distributes *free* content. Free software, admittedly, is only one part of true freedom, but an important one. The other aspects you've listed fall under free culture, but the examples you gave don't help that any more, since YouTube and Flash stop free culture in their tracks by taking down copyrighted works and including DRM in the distributed materials.
I was looking at some of the modules that were included and found out that is exists. I opened it up in notepad++ and laughed. Thought /r/python would get a kick out of it
&gt; the creators' "rights to control and profit from" aren't somehow lessened by allowing the users' rights I think it's pretty clear that the user's right to redistribute conflicts with the creator's right to control distribution. And so far, proprietary software has seen much more success as a business model than open source, which definitely suggests that controlling distribution is linked to profit. &gt; They can hire someone to modify the source code, We could also take our clothes to tailors to get them modified and repaired. But most of us, most of the time, go and buy something ready made off the shelf, wear it until it breaks, and throw it away. The option to pay third parties for custom modifications to code just isn't that important to people. If it was, they'd look for software that allowed it. &gt; Riseup gives me that freedom, and I can tell what's running on the server, and modify it. Even if they can detect spam as well as Google, I note: "Your email quota will be 20 megabytes. This can be increased upon request." I have &gt;25 times that much mail. Maybe that trade off makes sense for you, but don't claim the freedom of the software is the only difference. &gt; I can find those [Flash] videos on YouTube in WebM format, which is free, or on archive.org, which distributes free content. And you're forgoing content that's not in your preferred format, so again, it's a trade off. I prefer to watch iPlayer, even if the content is copyrighted. Neither of these examples strengthen your case, because in both cases you've given up things that most people care about (convenience, content), for a principle that most people don't (free software). I think we must agree to disagree. I'm going to bed now, so I won't pick up further messages on this thread. Goodnight, Mark.
&gt; And so far, proprietary software has seen much more success as a business model than open source, which definitely suggests that controlling distribution is linked to profit. Actually, that suggests to me that people have been ignorant of other models, and the few who were aware of other models either refused to try them, or tried them briefly and halfheartedly before returning to their old ways (like the Humble Bundle, for example, with DRM). &gt; most of us, most of the time, go and buy something ready made off the shelf, wear it until it breaks, and throw it away. Actually, most of us will give a try to sew it ourselves, since it's elementary to sew up a hole in a shirt. But software doesn't degrade like that, it works in perpetuity, absent any action on the distributors' part to restrict people from installing more than once. &gt; Maybe that trade off makes sense for you I think it's a pretty minor trade, since it's relatively simple to delete big emails when they come, and clean up once a month or so. I have had no trouble with spam. And no, the freedom they give me isn't technically the only difference, but it is the most important one. &gt; given up things that most people care about (convenience, content), for a principle that most people don't (free software). The problem is, people *should* care about their freedom! The freedom to choose the wrong choice may be important, but having chosen the wrong one, you can't turn around and defend the stupid choice as being the best one, simply because it was a valid choice. In this case, digital freedom is an overriding interest, and having chosen mindfully to forego it, you cannot turn around and defend the wrong choice as an exercise of freedom. &gt; agree to disagree This is a ridiculous concept! Even if parts of our arguments are right, and parts are wrong, we should be able to come to some form of agreement, here.
The ".dev" in `v0.11.dev` means that this is an unreleased development version, i.e. it represents what's in git right now. When a release is made, it will be called `v0.11` without the .dev. To use those features you'll need to check the code out from git and build it yourself. That's going to be quite a chore. You'll need python development headers, a C and Fortran compiler, and you'll need to build the prerequisites (ATLAS, LAPACK, etc.) or install their development headers and libraries from a prebuilt development package. All the instructions are on the SciPy wiki. 
Spyder is a pretty neat IDE, esp. in a Windows environment. The more fancy features like matrix inspection are kinda cool, but I find myself shying away from the bells and whistles of it and just going back to command line/shell prompt. If you are running "big" scripts in there (i.e. lots of memory, CPU) you might want to stick to the command line so your machine is not waiting to give its kill command through the Spyder IDE which isn't listening anyway :)
Type `import antigravity` in the interpreter.
Python.
Udacity came with captions, so he probably means transcriptions.
Or, [TIL] People use Python on non-free operating systems. EDIT: Let this be a lesson, the Python reddit doesn't tolerate people who value freedom.
I have a Linux server I was just at work when I came across it
Thanks. I just started python about a week ago so I'm still confused about stuff like this. I guess I was just confused because every single source I could get through google was giving me 0.11 by default, so I just assumed it would be out. Anyway, thanks again.
Sorry didn't understand your question quite well. IMHO, there aren't many choices with python SSG engines. Pelican was among the few that's useable. But this one (Nikola) ships with a lot more features than Pelican. Professional looking default templates (jQuery and bootstrap), reST and markdown, mako templates, debug server, auto reload preview, i18n support... After a little using I'd say the features feel right to me.
[Here's](http://www.gnu.org/) some cool software that really makes a Linux kernel useful :) most notably, [GNU coreutils](http://www.gnu.org/software/coreutils/), [GNU bash](http://www.gnu.org/software/bash/), [GNU tar](http://www.gnu.org/software/tar/), but many others are useful too. And of course, what I'm really getting at is that you should learn about [the philosophy](http://www.gnu.org/philosophy/) that helped to create the software you use every day :)
40-50% people at a conference using GNU/Linux == awesome. EDIT: Or maybe 10% were on BSD or LoseTHOS?
Wow, I've known about that XKCD for a while, but I had no idea they'd made an easter egg for it. Awesome.
Yeah it was probably about half linux (or bsd or other unix, you can't tell them apart at a glance) A very high percentage of linux users were on thinkpads.
Oh! Clever! You've parodied my speech to make me look less intelligent! I support free software because I don't like being chained. Do you enjoy being chained?
hmm weird maybe I need to do an update my chrome at work never seems to work properly.
[so is he](http://www.reddit.com/r/Python/comments/sagwt/how_do_you_stay_uptodate_and_active_in_the_python/c4chfhu)
Snobbery? Snob: &gt; One who tends to patronize, rebuff, or ignore people regarded as social inferiors and imitate, admire, or seek association with people regarded as social superiors. I don't do any of those things! I argue with people I view as making silly decisions, and if they walk away with the same viewpoint with which they came in, I count it as my own failure that I couldn't get through to them, to reach a better mutual understanding. EDIT: And hence, I'd say it contributes an enormous opportunity on the part of people who might not understand my viewpoint to learn about it :)
You're doing god's work.
Hijacking/trolling to push some OS holier than thou view hasn't been cool since ever. Please take it elsewhere.
I'm quite not sure what to make of your prompt here. You're clearly worried about quarrelsome discussion, but the questions don't really raise any particularly controversial points (though perhaps the internet will prove me wrong...) #1 isn't really a question if you take some time to read the content of the OSI Approval Process/["Open Source Definition"](http://www.opensource.org/docs/osd); it means precisely that. I suppose we could touch on the "Free as in Beer and Free as in Speech" stuff, but that's pretty well-trodden ground. #2 begs for an alternative. If not free, then what? Closed source, expensive license? Think about what kind of community that would create, and whether python could exist (let alone thrive) atop that community (I believe my opinion is clear). #3 As a developer, I generally prefer Free software when I'm looking for libraries and components; I'm happy to license or buy software when it does the job I need, but will often try several open solutions before turning to a closed one. I like open solutions for three main reasons (which are interrelated): they have less incentive to create lock-in, they tend to play nicer with other tools and have less "magic" (simplifying versioning, maintenance, configuration, and deployment) , and it is often (though not always) easier to quickly prototype to see if the tool will do the job I need. #4 I have released one medium-size codebase (~10k lines) as open source as well as various smaller scripts and tools; using everything from GPL to the [WTFPL](http://sam.zoy.org/wtfpl/). Personally, I release tools for three reasons (in no particular order): to give something back to the community that has shared the fruits of *their* labor, to create a public track record of my ability to write useful code, and to offload the work of implementing features that I don't care about as much as some potential users. 
Now that you mention it, so do Coursera's. 
There are a ton of Python web libraries or frameworks. Check out this [roundup.](http://www.konstruktor.ee/blog/python-web-framework-roundup/) You should be able to find something that suits your tastes. Django is the big kid on the block, both in popularity and sheer size. If you want to talk about capabilities: a few months back, Mozilla said they serve 200 million page views per day via Django. If you want to start simpler, there are still plenty of options. If you're up for a 45 minute talk, check out [this overview](http://www.youtube.com/watch?v=AYjPIMe0BhA) of basically all Python web micro-frameworks.
Now look what you've gone and done, gotten me all signed up for another free online university -.-
Supporting is different from bitching about it. I don't use proprietary software, either, but each kind of software have its purpose. (And just to be clear: I HATE that Windows is not POSIX, and every night I dream about a popular POSIX system which will surpass Windows and start a new era of portability.)
Like I always say: Linux is a real mom for developers.
Well, you indeed can make a business model on a free MMORPG (because the data of your character is not on your computer and yadda yadda). But tell me, kind sir, how could I gain any profit from a free single-player side-scroller? Or... how could I make a MMORPG from scratch like this?
Here is what I do. Take this with a grain of salt :) I develop web applications for a living. I use Flask, Jinja2, SQLAlchemy, flatland, PostgreSQL and various other tools. I'm considering using bootstrap from twitter, but I've been pleased with buying cheap templates from themeforest. I use Sublime Text 2 as my text editor with a console on the side to start and stop my python scripts or other tools. I do not see a need for an IDE as of now. I use mercurial as my source control with SourceGear DiffMerge as my visual diff tool. I host my web applications on [the cheap and flexible servers from webfaction](http://www.webfaction.com/?affiliate=delizseemack). I use a combination of nginx and uwsgi to host my apps. I rely heavily on virtualenv and pip to setup my environments and dependencies. I usually develop on my mac, on windows 7 or inside a vmware ubuntu vm for various reasons (mac laptop, pc desktop, I'm a gamer too). I often check out various news feeds including this reddit to stay up to date.
Well, generally, I'll link ye to my summary on the topic: http://blog.marktraceur.info/blog/2012/making-money-ethically.html In the case of the single-player side scroller, I'd combine two models: First, crowdfund the original development, include in the target enough money to make some profit. Second, offer your services as the original developer to develop addons, more cool features, or extra content.
CherryPy is pretty easy to pick up. The documentation is lacking, but in terms of getting something up and running quickly, CherryPy is great.
Well, the other option would be donations, which is generally pretty viable. Alternatively, form a temporary organization to hire you to make the software, to the same effect! And the second option could be done by an individual easily--step one, "I have a cool idea for an extension to this game", step two "Denomnus, here's some money to make it", step three you release the additional content to the users.
I bring it into threads where it's relevant. It happens to be forefront in my mind, and I subscribe primarily to software reddits, so it appears like I do it everywhere. Also, how does this make sense: Spread the message to fewer people, and more people will understand? The biggest problem in the free software movement is lack of understanding, so I'll keep pressing the issue if you don't mind :)
You are such a troll. Stop posting your propaganda and realise chaining people to a resposibility to use free and open software is more damning than *using* non-free software.
Hi, As a frequent flyer round these parts, this guy does it in literally *every* post he makes.
This very comic was the start of my Python adventure. I almost forgot! Thank you.
I am absolutely not a troll, I have a legitimate concern about the freedoms of others. I chain nobody to anything, but surely you must realize that choosing to be free is much better than choosing not to be!
[Bottle](http://bottlepy.org/docs/stable/) supports Python 3.x. It doesn't have all the bells and whistles that other frameworks do, but it's a lean, mean, fightin' machine ;-)
1. That quote is really a bit of a *non sequitur* actually. It's free to use for any purpose because it's licensed under a permissive, non-copyleft license. If Python were licensed under the GPL then it would still be an OSI-approved license, but it would be much harder to incorporate into proprietary commercial products. Not impossible of course, but difficult. 2. Of course. Who wants a language that has a hood you can't look under, which you cannot contribute patches to unless you work for its benefactor company, and which you can't have installed on a Debian server easily? Your example of C# thriving despite not being open source is rather baffling because Free Software enthusiasts had to go out and re-implement the entire platform from scratch, creating a second tier platform that will forever be behind. I want nothing to do with such languages. 
Having a concern doesn't mean you can almost constantly berate people about their choices over software. *In my opinion* choosing non-free software is the *less-correct* choice, yes. But there are a myriad of reasons why people do not wish to use such sofware. You and your free software evangelists *do* chain people, like I said previously, you chain them to the *responsibility* to choose between non-free and free software, you chain them to the responsibility of educating themselves of the difference. You *personally*, chain people to the responsibility of defending their choice of software. Your methods are incorrect and you have probably turned more people *off* free software than you have onto it.
What are the reasons, then? I'm always interested to hear, because I've very seldom heard a compelling reason. That being said, I don't force people to choose; I have very clearly recognized that a sudden switch is unlikely, and I cannot advocate for such a drastic change. But I do advocate for understanding and knowledge. And how can you say that I've turned people off? You can't possibly have any evidence of that! What's more, what is wrong about my methods?
I "preach" nothing; I simply state facts. My realistic sense is that, absent freedom, oppression reigns; and I have been through enough history books to know that oppression is a bad idea.
You come across as a zealot. A kind of religious nutjob. A special kind, who's religion is little more than a preference for a specific license of software. People may enjoy non-free software precisely *because* they don't have access to the source, it alleviates them of the burden of maintainence. I'm sure you don't demand blueprints for your car, or circuit diagrams for your TVs or any other electronics. I am almost sure of that, and why are they different? My logic follows like this: OP posts a pic of some mindless feature he found within Python, you berate him because of his choice of software (which is ridiculous, btw) and his view of the open-source and free software community is forever tarnished because of that. You are the Westboro Baptist Church of the software world. Enjoy your title.
1. Interesting; do you generally disapprove of copyleft licenses, or only in major infrastructural libraries or software? I ask because I've met many people who do so generally disapprove, and those people generally have some of the best insight into the movement. 2. I definitely agree with your opinion on the C# issue; I have also avoided it.
Interesting that you tie me to religious, irrational beliefs, considering that I have extraordinarily good reasons for my principles. Did you want to know what they were? I don't demand blueprints for my car, but if the dealership put a lock on the hood, I wouldn't buy the car. Similarly, if my TV came padlocked together, I wouldn't buy it. But both things are easy to disassemble, so I can fix them if I want to. The ability to maintain does not directly translate into the burden of maintenance--it just means that, if my car breaks down, I can make a fool of myself (and learn something) by trying to fix it before I bring it in to the shop. Finally, I didn't berate anyone. The berating that occurred was in response to my post, equating me to a bunch of hatemongering bigots! I don't hate anyone; I simply disagree with the corporate practices of a bunch of people. Absent those choices, I know those people are good. In fact, I like a whole bunch of them. But since they make irrational choices (and I haven't), I try to talk sense into them from time to time :) Seriously though, did you want to hear why I use free software? I'll note you never asked, which means you think you're right beyond all reason. And you tie me to religious beliefs?
I have you tagged and I see your posts everywhere. I actually tried to work with you on a project a while back, your beliefs got in the way of open source development. Isn't that ironic? Your beliefs were/are actually more important that what the beliefs are about.
Thank you for posting this. I have just started the course form April 16th. Your search engine works for me, Firefox 11 on Win 7
Check http://www.djangobook.com/ It should get you started quickly. I always use Vim for development, but if its too much to start with, use Eclipse. BTW, Eclipse has neat support for Django projects.
Same here, chrome. Edit: Site works with my plugins disabled (i.e. incognito mode), but doesn't work normally. Version: 18.0.1025.162 m
1. I'd say it means 'Python is not copyleft', and 'OSI-approved' is marketing spin. 2. Yes. It's hard to imagine Python would be the language we know today if it you needed a licence to run it. But I don't feel Guido had any obligation to make it FOSS. 3. Yes, but I'm quite prepared to compromise if proprietary things do what I want (Flash, GMail, Github, etc.). I'm not entirely sure why I prefer it, but there's a certain satisfaction in using tools when I feel part of the community making them. 4. Yes. At present, I'm fortunate not to need to make money by selling code, so I do it as a hobby, and enjoy knowing that people use it. I'm also aware that my open source work is a kind of portfolio of my technical skills.
I like python(x,y) a lot but I haven't found a way to update the packages easily. For example it comes with [IPython](http://www.ipython.org/) but not the latest version which supports the web based IPython Notebook (which by the way is one of the coolest things I've seen happen in the Python for scientific computing field). It also doesn't support the latest version of Sphinx. I have on occasion tried to update the packages manually and managed to break parts of the distribution. On the other hand the [Enthought Python Distribution (EPD)](http://www.enthought.com/) also looks like a really good scientific python distribution and supports the latest version of IPython and Sphinx. However only the base packages are freely available. The whole thing is commercial. In the scientific python world there are a lot of packages that depend on each other and there is a need for package/module management along the lines of Linux distributions. 
&gt; Also, what certain tools are a must have for Python devs? You'll get answers all over the place on this. I wouldn't call this a "must have" (certainly), but I've started to use Eclipse as my Python IDE, and it works great. The integrated debugger is fantastic, and when a breakpoint hits, you can use the terminal window to run methods and adjust parameters, as if you were running in interactive mode.
Good advice. Although in my case (where I'm creating quick, portable scripts with minimal dependancies) it can be handy, using a library is a good idea.
Check out [/r/learnpython](/r/learnpython) 
All the options mentioned are quite valid, but it wouldn't hurt to also install Python 2.7.x so you can try out Django et al.
Not for 3.2 ? Look: http://www.lfd.uci.edu/~gohlke/pythonlibs/#pygame
That is great. If you work in another field and have knowledge of analysis heavy stuff such as economics (or any other field, medicine, finance, you name it...) knowing Python and being able to process data and write scripts can really really boost your career. 
A moment to learn. A lifetime to master.
It is worth noting that on windows there are several other libraries that have a similar problem. Most of the time the best solution is to just install the 32bit version of python itself so that it can use the 32bit libraries. 
Always, always put a link to screenshots on the front page for any kind of GUI software. Even better, put an actual screenshot itself on the front page.
&gt; copyright infringement So copyright it! Better, copyleft it! &gt; somebody taking credit Copyleft also deals with this problem! :) &gt; alpha versions This is problematic, but if their ultimate goal is to release free software, I'd say it's a good thing. I would even argue in some cases that it wouldn't violate a GPL. &gt; So what. Well, your data is being controlled entirely by forces you cannot even see! I'd say that's a very dangerous proposition. You have the assurances of the company in writing, maybe, but I'm almost sure you didn't read it. Even if you did, their employees could maliciously circumvent the privacy policy, or they could get attacked. [Gitorious](https://gitorious.org), on the other hand, is a service you can see absolutely; so before you post the code up, or private messages, or whatever else, you can read the code for things you think are important. If they aren't there, add them yourself (or hire someone!), then either run your own instance or ask Gitorious to patch. Finally, no, I don't see why. But please don't decide that the topic is already discussed! If you have cool reasons for something, I'd love to know them. :)
I usually use the 32 bit version for compatibility with a few of the modules (though I admit I haven't looked at the 64 bit versions in a while). For the most part I don't think there would be many noticeable advantage to using the 64 bit version unless you plan on your script using more than 2 GB of RAM.
Ah.. nevermind me. I'm just an idiot.
IMO the most outstanding features of python are the 'dynamic nature' and the easy integratability of existing C/C++ libraries. The 'dynamic nature' leads to clean and compact code, e.g. no interfaces necessary (we have duck-typing), functions and classes can be passed around (as parameters, return values), decorators and context managers allow the clean implementation of cross cutting concerns ('mini' AOP included, Java / C# need frameworks for stuff like that). Most of the OO-Design-Patterns come naturally or are muuuuch easier to achieve than in static langugages. Then you can use huge powerful frameworks like Qt (via PyQt or PySide) almost seemlessly within your beautiful Python code. Pure awseomness; the best of both worlds! So far I've used Django, but plan to check out Flask and SQLAlchemy soon. [Request](http://docs.python-requests.org/en/latest/index.html) is a must to check out (and use). We all love it very much :-). Opposed to others I'm an IDE guy. I used to use Wing IDE but recently changed to PyCharm. Both are exceptional good. But surely you can pimp your VIM to have the most useful features as well. Also, you should also check out IPython as interactive interpreter. I don't have the need for it, but like it.
I am that MarkTraceur! OK, but I don't remember anyone trying to kickstart the project. How did I stop you from doing anything? The GPL would allow you to move the project forward. I happen to think that "being an extremist," as you put it, doesn't hurt anything of itself unless the *other people* in the discussion, for whatever reason, choose to be opinionated, stubborn, and irrational. I have met those traits many times here on reddit, I'm lucky enough here to have found a fairly reasonable person :) &gt; that's what you get for using a non-free OS I'm pretty sure I don't say things like this; someone doesn't deserve punishment for a mistake they made. I only point out that certain things are inevitable, like so: &gt; that's what happens in the non-free world Now, the last two stanzas here appear to be in direct conflict: &gt; showcasing how a free version of a non-free suite of software now has killer feature X that people need. and &gt; ideals which I agree with The whole point of the philosophical ideals is to show us how the features don't matter; the freedom is the important part. Therefore, and comparison chart I would make would look like Free | Non-free ----------------------- Has freedom | Doesn't However visual that is, I doubt it would be helpful.
In most cases, 32 bits should be enough and good for you even if you are on 64 bits.
Scrapy is written in Python.
&gt; If you’re choosing a Python interpreter to use, I highly recommend you Use Python 2.7.x, unless you have a strong reason not to. How long are we going to cling to 2.7? I'm not saying it's bad, but 3.x made backwards-incompatible changes because they were believed to be better -- am I wrong? If I time-travelled back to 2008 when Python 3.0 was released (after *copious* amounts of blood, sweat, and tears), and told the devs that 4 years later we would still be recommending 2.7, how would they feel about that? If when we start working on Python 4.0, I told you that 10 years from that time we'd still be using 3.x, how would you feel about that? (Hint: Perl 6 is not the situation I'd like to be in ಠ_ಠ) tl;dr I find the recommendation to continue using 2.7 to be highly irritating and counter-productive. [n.b. other than that, I find this guide to be fantastic; sorry for killing the mood]
yes
Really? Are you serious?
Yes, really, I am serious. I don't want another Internet Explorer 6 and we're heading exactly there like this.
Each one of these updates makes me feel like it's Christmas :)
It's still recommended because a large number of libraries still don't have Python 3 support.
Huh. I honestly do not remember those conversations. I'm sorry it came to that, but again, I'm not stopping you from working on the project. I realize that people react to me in a negative way, but my understanding is that they are reacting more to the *idea* I'm promoting than anything else--they have *already* perceived the Free Software movement as being somehow overzealous and stubborn. An "extremist", which as you correctly note I don't deny being, is someone who holds an opinion which is extremely different from the status quo. However, I *do* deny being stubborn and irrational, and unmoving. I am welcoming of others' views (in fact, I elicit them actively), and will readily admit when I am wrong. As to the comments, I also apologize if I came across as being vindictive against users--I will try to avoid that in the future. It may be that I had a bad day :) &gt; Showcasing freedom....gets you *nowhere* So freedom is absolutely unimportant, to all people? That seems a little counter-intuitive, given the various recent protests against SOPA, against corporations, against dictators in the Middle East. Even if it's not the most important to *some* people, can't it be a guiding principle on a different level? Moving on, &gt; freedoms appear *nowhere* in that [list], nor should they Why not? It's a very important part of the consideration, since it *directly* leads to improvement of all three things in your list. Freedom to redistribute = lower functional price. Freedom to study/modify and freedom to redistribute modified copies = more features. Freedom to use in any way = ease of use. So why is freedom, to you, not at all important? And again, even assuming that *some* people will *never* look at freedom, why is it so wrong for me to put digital freedom at the top of *my* list, and ask others why they don't do the same? That's the essence of free debate, which, last I checked, was still legal in America. Finally, why is it that my position, showing that morally my product is superior and everyone else's isn't, is somehow more abhorrent to you than vegans and "organic" growers, who say much the same thing? Or is it just a matter of persuasiveness, which I admit I could work on--but even then, the "organic" folks make plenty of money.
But does the idea of installing the package into egg-dir and then modifying easy-install.pth to point to that dir really that bad ? Pip after all still create the egg-dir but move the package dir out of it unlike easy_install. I've start looking into pip source to see if it's possible to provide this (optional) behaviour to pip.
I'm very excited by the effort being put into getting NumPy to work with PyPy but i am also confused. Is the user-base for NumPy that large? I use python/NumPy,SciPy,Pylab all the time in my research but I don't know anyone else at my institution that does this. Is there a large userbase for NumPy that I don't know about or is this just a case of the PyPy developers tackling a cool and interesting challenge?
I just started learning Python and I began with 2.7 because every guide I've read recommends it. Curiously… what are the most important libraries that aren't Python 3 compatible?
in python.org there's a poll there about that, you can check it out. django for example.
Since taking potentially good discussions off topic seems to have become the norm, I'll just go ahead and say it: please take this up elsewhere.
I agree. You have people who have devoted their entire scientific career making these incredibly fast Fortran codes over 40+ years... reimplementing them in PyPy over a couple months probably wont be faster.
My understanding is that the ultimate end of Cython is to create a superset of Python that includes additional features (such as type annotations) to make it easier to interface with C libraries, whereas the ultimate end of RPython is to create a subset of Python that allows global static type analysis to be done so that all types are inferred. So in short, the two projects have goals that are quite different, albiet not entirely unrelated. Fortunately I have heard talk of an implementation of Cython for PyPy that would allow scientific libraries to be more easily ported over.
Wouldn't it be possible to debug it in Cpython?
Superset and Subset are misleading in this context. While Cython does allow for more optional features (like direct C library interface), there is a specific portion of Cython allows static typing for speed improvements, something that Rpython's "subset" (not allowing dynamic use of variables) was intended for in PyPy. So why bother to **make** Rpython and all of the tools associated with making it work rather than just taking Cython and only using the feature that was needed, the static typing? IIRC and Cython/Pyrex was used on some of the numpy/scipy module - this would have made porting it to PyPy significantly less problematic, not to mention it would mean 1 project with more people rather than 2 projects with less people. So if Cython has static typing interface that was needed in PyPy and accomplished with Rpython, I ask again, Why Rpython?
Wrong kind of "python", numb nuts.
&gt; Premium plan Which is negated by GitHub being free software? I think not. &gt; shitstorm Not at all! I'm just asking questions, trying to learn cool things :) &gt; shove it down everybody's throat Well, I'm trying to think of the reasons, and see why *you* (or anyone) are ignoring the reasons to be free! I have yet to come to a compelling reason to give up freedom, so I continue to search for one. &gt; money earned And yet, we haven't come to a point where you show that money cannot be earned with free software. You posited that people are frightened of the possibility of failure, but that's not proof that it's impossible.
You should fork it and submit a pull request https://github.com/kennethreitz/python-guide
Here's [a guide](http://py3ksupport.appspot.com/).
there is a defined point in the future where it *will be* python3 compatible, so django is (finally) not an argument for 2.x anymore.
I remember when I used to do `for i in range(len(my_list))`, accessing elements with `my_list[i]`. Then I learned about enumerate.
I can't speak for all software, nor can I compare to Java, but I wrote an MMO server in Python for Windows which, once the dependencies were installed, worked on MacOS and Linux first time. (I think the biggest problem was that git keeps changing the shell scripts to DOS format.) When you program for a while you get a feeling for the sort of things that are platform dependent, and you learn to use the libraries that abstract that stuff away.
I think this post on repository structure is going to fit in there somewhere: http://www.kennethreitz.com/repository-structure-and-python.html
No, I wouldn't say it's more "write once, run anywhere" than Java. There are more platform differences than in Java, though the OS abstraction of Python is good enough to be *able* to write portable code. In addition the various Python virtual machine implementations (PyPy, Jython, IronPython, CPython) differ more from each other than Java implementations do. Java also is better supported on a few more platforms, such as mobile. I don't this is bad, by the way; while Java tries to be a world upon itself, Python doesn't try that and is less isolated from the environment it is running on (OS, libraries) and tends to integrate better with it as a result. It's not difficult to write code that runs on CPython environments on all platforms it is supported on. It's harder, but still possible, to write code that runs on any Python 2 implementation anywhere. It's harder still, but still possible, to write code that runs on any Python 2 and Python 3 implementation anywhere. 
Yes, I did this too... :(
but if you start a project today, you can be sure that python3-django is available once you’re finished, so…
Java != Javascript
well, i’ll simply wait a few months, then this conversation will be obsolete ;)
no, but then even java isn't "write once run anywhere" either, that's the bullshit that sun and oracle sales people tell your boss and what your college professors tell you in your freshmen compsci classes. "write once run anywhere" is a marketing myth. 
What do you mean by "there are too many kinds of Python that you can write non-backwards-compatible code for?" If you're referring to the x in 2.x, you have the same issues in Java. In fact, I'm pretty sure that if you compile Java bytecode on Java 6, it won't run on Java 5 even if you didn't use any Java 6 features. I regularly develop Python software for Python 2.4+ using Python 2.7, I just have to know what features aren't available. This becomes more of an issue with Python 3, though it's relatively easy to write code that is compatible with Python 2.6+ as well as Python 3.x. If you're referring to Jython, IronPython, PyPy, and CPython it's sort of true, but it's very rare for an end user to be using an interpreter other than CPython unless the application has a very specific reason for it. I often write code for Jython, and so long as the code doesn't use C extensions I can use any Python library I can find. With Python, if you target 2.4, use pure Python code, and handle path separators with os.sep instead of assuming '/' or '\', your code should run on any Python 2.x installation from the last six to eight years. I'm not terribly familiar with Java, but I imagine they have a pretty similar set of guidelines for writing applications that will run anywhere.
True, I noticed that after I posted. Although this is a post about Java vs Python.
That's unlikely, though it depends on what is acceptable to you. Fast FFTs have to be aware of the cache, and I don't think that straightforward FFTs are either cache aware nor cache oblivious.
There are many OS-specific functions in Python libraries. But I guess it has to be the same for Java.
yeah, someone else suggested this, and i already elaborated why i think that while it isn’t standard, it shold become one. note that i don’t want every browser vendor to go nuts with proprietary shit, quite the opposite, but read why i think that styling `&lt;select/&gt;` tags, checkboxes and scrollbars shold be possible.
Wow, that is impressive, and Google App Engine supports it now?! I just googled GAE and numpy and apparently a ton of people use numpy for general data crunching. It sounds like you work on Numpy... from the bottom of my heart thank you. I'm in the middle of my dissertation right now and elbow deep in code that uses Numpy. It has been a joy ever since I switched over from MatLab. 
IPython 0.13 will attempt to respect virtualenvs without you having to do anything (though installing inside the virtualenv is still recommended to get advanced virtualenv features working).
&gt; How long are we going to cling to 2.7? For as long as 3.x has inferior library support. You can't blame people writing guides for **not lying to their readers**. You can't blame people who write and maintain libraries for not spending lots of effort due to the lack of a sane official transition plan (basically, you have two options: 1) maintain 2.x version as primary, then regularly run 2to3.py plus a set of custom patches, 2) rewrite it in a rather uncomfortable subset of both languages plus a homegrown compatibility library). The only people you can reasonably blame for the current state of affairs are the devs themselves. When people come up with constructive criticisms re: 2 to 3 transition, other people [reply](http://www.reddit.com/r/Python/comments/qp3xg/how_python_3_should_have_worked_according_to/c3zef38?context=3) that Py3k adoption is actually going according to the plan, so no worries. Oh well then. Regardless of how well it really goes, I find shaming people with stuff like [this](http://python3wos.appspot.com/) and comments like yours to be highly irritating and counter-productive. It's not like we "cling to 2.7" because we are lazy/irrational/evil.
Oops, pasted the wrong symbol. Thanks!
It's not this particular recommendation, it's the general recommendation. Lots of people in the Python community continue to recommend 2.7 to newbies due to library support, which completely baffles me. The more we sit on 2.7, the less likely those lingering libraries are to move to 3.x anytime soon.
How exactly does Django fall short on customizations? 10 seconds of google-foo tells me that Pylucid is a CMS written for Django, so the disparity of `Pylucid &gt; Django` implied by your description does not exist. Did you have a specific question?
Please alter the CSS of that page to put a closing quote on your `&lt;blockquote&gt;`. Thank you.
Given the admittance that it is an "opinionated guide" and the author "highly recommends 2.7" (and on top of that, recommends module-writers target 2.5 and 2.6, and add 3.x support later ಠ_ಠ), I highly doubt the pull request would be accepted. I did [leave a comment](https://github.com/kennethreitz/python-guide/issues/48#issuecomment-5201687) on a relevant thread, though.
feel free to comment [here](https://github.com/kennethreitz/python-guide/issues/48) ;)
Not to worry, I'm not a troll :) I just want to talk to interesting people about the stuff I love! For your first stanza, I have to ask: Did you try to *make* the user experience you wanted? Maybe that's a high order for one desktop user, but I'm sure you know others with a similar situation, could you not have hired someone to work on a cool new distro that would better suit your needs? Certainly with the cash required to purhase a Mac....:) Do you use free games, as well? They are just as important for the ecosystem as anything else! I'm sure you'll tell me that they aren't the same, but I'll ask again, have you tried to come up with better solutions? Does free software *in general* not work, or is it that the *current, specific* free offerings don't work for people? In that case, assuming all other things equal, would you choose the free solution? This is the base case, but it's important to know. I'm not ignoring any part of your post, friend. Nor am I trying to "keep hammering" anyone. All I want to do is learn about what you think of the subject, and possibly change *my* own views. I happen to think that, if we talk long enough, you should at some point learn something yourself as well :)
Good point. Currently on our systems we usually develop with site packages enabled otherwise we'd be installing and compiling for quite a long time every time we wanted to make a virtualenv for one of our projects :)
How does one acquire the 'twitter' module referenced in the code? As far as I can tell, there are several Python APIs for Twitter, but none are official. Edit: None of the modules listed [here](https://dev.twitter.com/docs/twitter-libraries#python) are called just 'twitter'. I'm sure I'm missing something simple.
I have been using IPython (and Python) for a year now, and this video is just amazing: I never realized how much work had been put into this project, the quality of the intricate work and I had no idea about most of the things I am seeing! And I watched only about one hour of the video! I highly recommend it, even if you think you know IPython
sorry it baffles you. it makes perfect sense to me since the available libraries is one of the big selling points of python, and the good stuff, for the most part is still in 2.7. especially for web development. Newb wants to learn python because they want to do cool django stuff. django does not (at this time) run on python 3. It will by the end of the year I predict. And another scenario.... newb wants to learn python and run stuff on app engine so that it will be ROFLSCALE like all the big boys. App engine, has just now started support python 2.7(thank the lord), python 3 is not even on the radar(at least publicly as far as I know). I think those 2 scenarios cover a significant portion of the python interest that brings the newbs. Why would you want to set newbs on the road to quick failure? Furthermore, who cares what people are recommending to newbs? Or even what people are using? I wonder how many of your upvoters actually have jobs solely using python vs being a java/php/.net programmer who dabbles. And whether any of them would care to weigh in on how this "Community" recommendation to avoid python 3, especially newbs, is making their job suck, or has in anyway been a hassle. For me it hasn't. 
And yet, here I am, *not* in /r/freesoftware, in /r/python, *trying* to learn. Can you help me learn, rather than condemning me for past mistakes? The EDIT in my original comment was sarcasm, satire. I made light of the fact that I was downvoted for my opinion, which (according to community standards) should not happen. I made a comment about the picture, a comment which *I saw* as the key part of the image. Do you go to /r/art and tell people not to interpret paintings in one way or another, and wage downvote wars against them because their interpretation is "wrong"? I tolerate people who have reasons, *when* they are able to articulate them. I *respect* people who are able to teach me something new, which is why several people in this thread have won my respect in spades. Finally, I admit that "pro-freedom" and "pro-life" have similarly vague meanings, but in both contexts we can understand the meaning. Limiting oneself to free software limits one choice, but it gives you so many more freedoms that the burden is hardly noticeable. I am able to do a *lot* with my computer, and I can make it do even more, on a whim. On a Windows machine, I would still be able to do a lot, but I would *not* be able to expand. That's not the sort of world I grew up in--I was taught that I should always grow, and learn. That's not possible in a dictatorship.
Well this widget is not a canvas so expect many difficulties, but it may have some advantages like search facilities, you can mark some part of the screen with tags and even include another widget (like images) in it. This widget is very advanced btw.
So you would advise using Canvas instead? The only thing about Canvas is that it is a bit harder to place text exactly where you want it (relative to characters, not pixels.)
OP was using Python on Windows. It doesn't have to do with the subject matter that OP wanted me to see, but I interpreted the material differently! That's why they have this nifty "comment" button, so I can share *my* interpretation of the material with others. Someone who looks at a picture of an exploded bus entitled "THIS JUST HAPPENED OUTSIDE MY WINDOW", and comments to say "Hey, what's up with the clown in the corner of the image?" will be upvoted, not downvoted, though his apparent primary interpretation of the post is fundamentally contrary to OP's. And clearly this thread has contributed to the discussion, or we would not be here, *discussing* :)
I'm a huge Python fan but I have to ask. Have you actually experienced this or do you just hate Java? The main product (Java-based) at the company I work for was initially developed and deployed 100% on Windows. After we started to get more customers and needed to add more servers, we moved to Linux. We had no major issues. All of our dev machines are now MacBooks (which we also run our stuff on for testing) and all of our deployment servers are Linux and it all just works. I hate to say it, but I find actual cross-platform *deployment* much easier with Java than Python...
Yep, I have system site packages enabled too, because I don't want to compile numpy. But now that's no longer the default, an increasing number of people can't use the alias trick. Another neat way to do it is to edit `/usr/bin/ipython` so the first line is `#!/usr/bin/env python`. We were recommending that, but it suffers from precisely the same flaw as making the alias.
Well, it's almost in there; it says "in depth". ;)
&gt;Java could be a pain to install on *nix though, while there's a good chance there's some kind of Python in the OS' distribution already. My experience has been a bit different. I can generally count on having both available, but while the java installs are kept up to date, I can more or less count on the python install being whatever came with the OS, usually some 6 year old version. Java is everywhere in enterprise environments and patching it is a routine security concern while Python is an afterthought.
TIL you can automatically restore the state of a program (run from an ipython prompt) that raised an (uncaught) exception by typing debug (or %debug). Life will never be the same.
Our software suite depends on numpy, scipy, matplotlib, scikits-learn, and a ton of other compiled libraries. It itself needs compilation, so setting up a virtualenv from scratch with all the dependencies takes about 30-40 minutes. Not really that great if you need to test some minor changes with a clean build :) You can always use --system-site-packages even with the new version.
Thanks for the heads up.
Thanks! This is the best implementation I've seen so far. First one I've seen that you can import with as well.
https://github.com/adamv/wcurses
Haha, Don't Press F5 out of habit. ಠ_ಠ
Well, IPython can be used for a lot a cool stuff, like data visualisation, or even parrallel programming on a network... but also has a ton of simple awesome features. The first that pops in mind would be autocompletion. I think that autocompletion in itself is already a great win, and a totally legit reason to use IPython.
I have looked into this as wel. But more important than a certification is having a lot of quality code to present to employers. Also, Python is open source with many active projects, contributing to them will get you lots of experience. You can also write your own packages too to get your name out there.
 def update_comment(self): print self.ItemList.currentRow() Is that what you want?
I recommend * Using QtCreator to get a feel for how these objects work. * Adding a keyword search to your browser that points to local documentation (something like file:///home/jerakin/doc/PyQt/q%s.html) so you can type "q tablewidget" into your address bar and get the api docs.
It's a very good course though. Written by Steve Holden.
*3 fucking hours?* I know the internet has ruined my attention span but even 20 years ago a 3 hour movie was a serious commitment that would give me a sore arse. If that much information was given in documentation form, at least I could skip and search through it. And it would probably take much less than three hours to read. Is there a tl;dr? Or any justification for the mammoth undertaking that attempting to watch this will be? Does the presenter at least have a sense of humour?
I did not take the course so I can't judge... But I guess the course itself is the core value and not the certificate you might get...
No, and I almost hope that there isn't one. It would probably be worth about as much as being certified in Java; you can do it, but I never got turned down because I didn't have it.
If you can move for a couple of days, these courses are good to have under your belt. They are taught by David Beazley and he is very respectable in the Python Community- http://www.dabeaz.com/chicago/index.html
I think labs.codeacademy.com is a fork of repl.it with additional functionality, and the aim to be a medium to deliver interactive lessons to prospective coders.
I would suspect so; if only because there is a popular JS interpreter written in Java, but AFAIK no Java runtimes written in JS.
Having already installed one of the other 'twitter' modules, is there any way to disambiguate? Short of setting up a sandbox, I mean. 
You said you want to use vanilla Py3, but you should still check out Libtcod anyways. It's amazing.
If you stick with it, C# shouldn't be that difficult to learn. Once you have the fundamental concepts of computer programming down, picking up additional languages aren't all that difficult. That said, each language has their own quirks.
why are you asking ?
i think you're looking for a course-with-an-instructor type of thing..... 
 if #python is None: pujuma.Quit()
Thanks, i am using it on Ubuntu and love it so far, it was quick to install using 'pip install'. I have been using numpy a lot lately for machine learning and the object lookup and variable explorer is already helping. Good Work!
This is correct. Thank you!
2. Not arguing that communities based on closed source can't survive, just that the barriers to entry will inevitably make it smaller and less inclusive, and correspondingly reduce the number of small libraries and toolkits available. It's network effect &amp; feedback loop. (And seriously, python has a module for *everything*; that's one reason to love it). 3. a. Both. 3. b. Not often. I'm amenable to contributing, but don't usually find that I can tackle a large missing feature (time, expertise, etc). If I'm making a small change locally to fix a clear bug then I'll make a pull reques.t 4. a. Heh, again, I'm not sure what to make of the question. I use "open source" because that's the correct term. If you're asking why I choose Open Source instead of Free Software, it's because the term Free Software has a slight whiff of zealotry (to me at least), and it can muddy the waters. Both are largely interchangeable to me. 4. b. User's freedoms are what it's all about. Part of open source is the idea that no one need be just a user; they can be a hacker/maker/contributor as well. (Bad metaphor warning) If closed source software is a machine shop/fabrication facility where you send away plans and get back more or less the part you wanted, then open source software is like owning the shop; you can still get parts made, but you can also walk the shop floor, see how the tools work, use them in your own way, or change them to suite your needs. 
Thank you so much! I don't even know how I could have missed that. Should maybe stop trying to learn when I am tired.
For those of us who're wondering what on earth MQTT is, here's the description from [mqtt.org](http://mqtt.org/): &gt; MQTT is a machine-to-machine (M2M)/"Internet of Things" connectivity protocol... It is useful for connections with remote locations where a small code footprint is required and/or network bandwidth is at a premium. ibeka, can you tell us a bit about what you're using it for?
Whether the language itself is more difficult than python is debatable I think. But you may find the .net framework/library a hell of a lot more cumbersome. - All the various data access strategies(and no definitive ORM) - WebForms vs. MVC - WFC - All the various Desktop UI API's - IIS(/shiver) It's pretty extensive and has a lot of cruft. /opinion by me from 2008
I dont use HomeBrew but I have heard good things. I would guess that you have installed the opencv libraries but not the python bindings?, or if the bindings are installed they are in a different location than your python path. Try using macports sudo port install opencv +python2.7
I will certify you for free if you live in the USA. And my certification will be worth as much as any other computer-ish certification. All I need is - Your **Full Legal Name** - Your **Date Of Birth** - The **City** you were born in - email address: to send a printable pdf that you can put on your cube wall, or include with your resume. For those that don't realize that this is totally a joke, the above list of information is supposedly enough to reasonably guess a Social Security Number. 
import antigravity 
I use it for 2 projects * to collect sensor data. In small size sensor, i use C mqtt library. In medium size sensor and the collector side, i use nyamuk. * In an abandoned hobby project that similar to [roomahost](https://github.com/iwanbk/roomahost). Note : roomahost is not released yet
antigravity fails too :(
Oh, it's a pity, ep.io was perfect for my projects. But well, I'm waiting for [whatever is coming soon](https://twitter.com/#!/epiohq/status/192720959831154689).
I am.
All my love goes to this. This'll be great for demoing concepts to my son.
Definitely a pity. Now I have to decide whether to move my site to Heroku like they suggest, or host it on my VPS. What bums me about Heroku is that I have to use something like Amazon S3 for assets, and I only have a handful of them. Edit: I'm also glaring at [Gondor](http://gondor.io).
Some tutorials would definitely be good :)
I took this one last year, really enjoyed the program. Definitely more about the material than the piece of paper at the end.
Have you considered Google App Engine. You can use the Blobstore or Google Cloud Storage. Blobstore gives you 5GB free, and then costs $0.13 / GB / month. You can also store your static resources when you deploy and are allowed up to 150 MB (a single file must be less than 32 MB).
Selamat sore, nice to see some python coming from Indonesia :-). Have you had a look at zeromq for messaging? I did look at MQTT a while ago, but was already into ZMQ so didn't really dig very deep.
Okay, it seems to work in IPython, but in Eclipse I'm still getting errors: Traceback (most recent call last): File "/Users/username/Documents/workspace/Project/test1.py", line 1, in &lt; module &gt; import cv ImportError: No module named cv 
LINQ permanently changed the way I iterate over data. The single best feature of any language I have yet seen. 
You are able to us both "/" and "\" in Windows. In explorer, command prompt, run, ... Only the latter is default.
Alright, here's my pythonpath as it shows up in IPython: ['', '/Library/Frameworks/EPD64.framework/Versions/7.2/lib/python2.7/site-packages/nibabel-1.1.0-py2.7.egg', '/usr/local/lib/python2.7/site-packages', '/usr/local/Cellar/opencv/2.3.1a', '/Library/Frameworks/EPD64.framework/Versions/7.2/lib/python27.zip', '/Library/Frameworks/EPD64.framework/Versions/7.2/lib/python2.7', '/Library/Frameworks/EPD64.framework/Versions/7.2/lib/python2.7/plat-darwin', '/Library/Frameworks/EPD64.framework/Versions/7.2/lib/python2.7/plat-mac', '/Library/Frameworks/EPD64.framework/Versions/7.2/lib/python2.7/plat-mac/lib-scriptpackages', '/Library/Frameworks/EPD64.framework/Versions/7.2/lib/python2.7/lib-tk', '/Library/Frameworks/EPD64.framework/Versions/7.2/lib/python2.7/lib-old', '/Library/Frameworks/EPD64.framework/Versions/7.2/lib/python2.7/lib-dynload', '/Library/Frameworks/EPD64.framework/Versions/7.2/lib/python2.7/site-packages', '/Library/Frameworks/EPD64.framework/Versions/7.2/lib/python2.7/site-packages/PIL', '/Library/Frameworks/EPD64.framework/Versions/7.2/lib/python2.7/site-packages/IPython/extensions'] In Eclipse, I added the directory /usr/local/Cellar/opencv/2.3.1a to "External Libraries" ([see screenshot](http://imgur.com/GziEr)) and then looked up the path. This is what I got: ['/Users/myUserName/Documents/workspace/myProjectName', '/Users/myUserName/Documents/workspace/myProjectName', '/usr/local/Cellar/opencv/2.3.1a', '/Applications/eclipse/plugins/org.python.pydev_2.4.0.2012020116/PySrc', '/Library/Frameworks/EPD64.framework/Versions/7.2/lib/python27.zip', '/Library/Frameworks/EPD64.framework/Versions/7.2/lib/python2.7', '/Library/Frameworks/EPD64.framework/Versions/7.2/lib/python2.7/plat-darwin', '/Library/Frameworks/EPD64.framework/Versions/7.2/lib/python2.7/plat-mac', '/Library/Frameworks/EPD64.framework/Versions/7.2/lib/python2.7/plat-mac/lib-scriptpackages', '/Library/Frameworks/EPD64.framework/Versions/7.2/lib/python2.7/lib-tk', '/Library/Frameworks/EPD64.framework/Versions/7.2/lib/python2.7/lib-old', '/Library/Frameworks/EPD64.framework/Versions/7.2/lib/python2.7/lib-dynload', '/Library/Frameworks/EPD64.framework/Versions/7.2/lib/python2.7/site-packages', '/Library/Frameworks/EPD64.framework/Versions/7.2/lib/python2.7/site-packages/PIL', '/Library/Frameworks/EPD64.framework/Versions/7.2/lib/python2.7/site-packages/nibabel-1.1.0-py2.7.egg'] So it looks like there's pretty good overlap apart from Eclipse and project specific folders in the Eclipse path. Despite this, here's what I get when I try to import cv in Eclipse ([see screenshot](http://imgur.com/AT7FP)) Thanks!
See my latest post in this thread - I played around with Eclipse's PYTHONPATH but didn't get anywhere.
fuck! i just started using it. cool thing they are open sourcing it
If you're using Gunicorn with asyncronous workers (e.g. gevent), you can get fantastic performance for static files. Serving static responses aren't that different than dynamic ones.
I know the hosting industry is a tough business to be in but is there any news as to *why* they're closing down? From their Companies House record they only incorporated about a year ago!
Why did you not use the [reference](http://mosquitto.org/documentation/python/) binding to Mosquitto? What sets yours apart? Why is yours better / different / more pythonic?
I think we take portability almost for granted these days. In any modern language, as long as you're not using platform-specific APIs (big caveat, yes), you'll be okay. This was not always the case. Even the simplest things used to be a giant pain in the ass to make portable in C or similar languages. Even today, C is a pain. Every language of the past 15-20 years has had portability at least on the list of design goals. Java was really one of the first to pull this off. Sure, it sucked, and it still DOES for most purposes (except when portability is thrown out the window, e.g. Android), but "write once, run anywhere" was more than just a marketing term. It was Java's raison d'être.
Link?
http://www.matthewdaly.co.uk/tag/django/ I'm sure there's plenty I could have done better on it, but I do feel like I understand it a fair bit better now.
Use UDP. Accept TCP connections on another socket.
as far as fundamental things go, i've never been very satisfied by "self" - it can get quite messy when writing classes and its a bit redundant typng it over and over.
Thx for replies. I figured out the noobish mistake. Obviously it was one of those... And bananatastic was correct. I was using the same port on UDP and TCP. As for learning Python. The question might be better suited there, but this was not a learning situation, more of a "god damn, I'm stuck, what have I done wrong now?!"-situation. EDIT: code for those who are interested(TCP* and UDP* + Communicator) https://github.com/magnuskiro/ttk4145/tree/master/elevator
I find PyCharm to be quite speedy for an IDE. If you are used to using only a text editor (Notepad++, TextMate, etc.) then *any* IDE will feel slow. Also, when you first open a project or directory in PyCharm it indexes everything involved. This can load down your CPU pretty heavily.
I like its simplicity.
It has been released a few days ago but nevertheless, thanks for posting it. Anyway, PyCharm for me is sometimes slow and always lags when typing. The lag is very subtle (maybe a couple hundred ms) but noticeable, the annoyingly noticeable. What IDE (no, not text editor) do you guys recommend? 
I keep hoping that one day there will be an adequate Python IDE. Until then, text editors it is. This release of PyCharm actually sounds like the closest thing I've seen to adequate! Seriously, I've never previously seen a Python IDE with all of * support for multiple installed versions of Python without getting confused * virtualenv support * git support (that isn't just shoddily ported SVN support) * code completion on code you actually have (not just the stdlib or a few extra libraries) All of those are pretty much required for an IDE to actually be an advantage and not a handicap. So I had my hopes up, but pity about the speed.
You can do all of that with Eclipse + PyDev. it's not quite as well integrated as with PyCharm, though.
Really? Because I remember trying PyDev. And I just googled for *pydev virtualenv* and found blog posts explaining the less-than-obvious way to do it, while comments point out the features that break. Also I have a couple of less-than-required criteria I might as well add: * Speed (most IDEs fail, Eclipse included) * Doesn't look like an industrial accident at the widget factory (PyCharm might actually be doing okay here, but not Eclipse)
You can configure your virtualenv interpreters as you would any other python interpreters, and then configure your projects to use the appropriate one. More info: http://www.michaelpollmeier.com/eclipse-pydev-and-virtualenv/ It may not be as polished as PyCharm, but it does work.
Hi, Yes i have take a look at zeromq. I also already use it in my other project.
There be some value of a certificate for those people who may not be super-talented, however. Not the norm, perhaps, but there's a wide range of people, and some might want or need the help, and the paperwork to prove it. Another good reason for a "certification" in the form of course work is that it's something you could conceivably get paid to do, by doing it at work!
My personal feeling is that 2.5 is faster than 2.0 (very few testing)
Not *any* IDE, just Java one :) Try KDevelop or Visual Studio for example.
I'm messing around the Heroku at the moment, and trying [this](http://matthewphiong.com/managing-django-static-files-on-heroku) hack to serve mainly my CSS and JavaScript files. urlpatterns += patterns('', (r'^media/(?P&lt;path&gt;.*)$', 'django.views.static.serve', {'document_root': settings.MEDIA_ROOT})) urlpatterns += patterns('', (r'^static/(?P&lt;path&gt;.*)$', 'django.views.static.serve', {'document_root': settings.STATIC_ROOT})) And run a `collectstatic` command in the Procfile. Maybe there's a better way? I'm not sure how to tie Django models.ImageField and models.FileField to a remote service like Amazon S3 for example. Edit: Running Gunicorn with gevent.
I wish I would go. Is there a free pass (pun not intended)? 
My guess would be it has sort of limit to stop non-ending while loops.
We are still planning the grant program. This is one of the activities that we would like to improve, but in order to keep ticket price as low as possible we highly depend from sponsors. We are always looking for new sponsors to help us make this conference greater and bigger.
Mandatory emacs recommendation comment goes here. ;)
`while 1:` This breaks my heart.
High five. I was just pondering over this tactic during last night's commute. I was wondering how I would intercept parsing of the Python script, and here you've already done it. Are you rewriting the script as a string, or do you use the Python tokenizer? How do you handle the AST? Thinking out loud here before my morning commute... Here's my goal: I want some awk-ish things in Python. There are some areas, particularly with scripts that parse lots of text, where awk really shines. Overall, Python's a much better language, and I'd rather write these scripts where I can take advantage of the more modern features in Python. So basically, I would just need code blocks as the author has here, plus an implied looping switch kind of statement that uses boolean expressions for each case. Wrap it up inside a with statement to keep things clean. Maybe sprinkle in some automatic variables. (You know, the shortcuts that help make Perl such an ugly language.) Syntax-wise I'm thinking something like this. This will get fed /etc/passwd , and returns either the user description or name, also the default shell; also we only care end-user accounts plus two system accounts though: with awk(FS = ':'): int(_3) &gt;= 1000 or m(r'root|www(?:-data)?') == _1: return _5 if _5 else _1, _7 The with statement triggers the rewrite rule and sets up the awk read-test-process loop. Any line that consists entirely of an expression followed by a colon (the "condition line") marks the beginning of a code block. The condition line is used as a test in the read-test-process loop, while its body is rewritten into an anonymous function. I'm probably not going to get much actual work done today, playing with this. Heh. 
I agree. I cannot see a single thing that this has over just defining a function in the same place. You still have to name your "blocks", you still can't embed a "block" as a part of a normal expression. Additionally, this: def id(x): return x with my_block &lt;&lt; id() &lt;&lt; 'x, y = 3': print(x, y) my_block(4) my_block(1, 2) print(my_block) The syntax here is entirely non-obvious. id() should be an error as you're not passing it any arguments. The fact that it does syntactic rewriting instead of rewriting bytecode also, from what I can see, means that you're effectively parsing the file twice, since the imported module is already parsed once by the time the codeblocks line gets to run. tl;dr: Use named functions. There's no reason not to as compared to this.
Thanks, pure gold!
What languages do you know?
java, c#, some C, php
The section that starts with "There's a full range of inspection methods:" gives some example attributes. It states 'https' for the scheme and then the default port of '80'. That doesn't make much sense to me. If the scheme is https, does the default port change to something more appropriate (443?).
thank you so much. unfortunately, one of the requirements is that i cannot install anything per say so I am out of luck as far as using a framework. but i will certainly use the rest of your advice. thank you.
Bottle is a single python file. You don't have to "install" anything. You just put the code next to your code. Magic! Edit: Also: *per se*.
Translation: &amp;#3232;\_&amp;#3232;
I use Bottle for an Apache CGI that transforms XML and the only access I have to the server is FTP. Wish I could run it under mod_wsgi and with full access to install newer versions of the libraries, but it works great.
I guess "you need to improve" == use django as far as I can tell by looking at the top 10 L O L 
Python definitely needs a URL class. The "http core" project has another one in its early stages here https://github.com/core/uricore It's built on top of werkzeug and will be used by it and possibly others in the near future. (kenneth reitz has a blog post about "http core" here http://kennethreitz.com/the-future-of-python-http.html )
It doesn't really bother me. Can you elaborate?
Simple and nice API. I am already using gevent for serving a couple of wsgi applications. Should I use tornado instead, now that gevent also has a threadpool?
Just so you all know, if you join codecademy.com, you can design lessons and things like that for their new Python section. It's really cool.
I love the name.
Thanks for the feedback. &gt; Why URL.from_string(s) instead of just URL(s)? You're probably right. I started with the keyword constructor as I was copying [urlparse.ParseResult](http://docs.python.org/library/urlparse.html#urlparse.ParseResult), which is about as close as Python gets to a URL class. I might rework that. &gt; url.query_param('q') is also awkward, why not just url.query['q'] ? Only as 'query' is already a method that returns the query string. Again, this is a hangover from ParseResult and is probably worth reworking to better match the most common use cases. &gt; I'm not sure why you use functions instead of properties. I was experimenting with using jQuery-style method overloading where the function can be a getter and a setter depending on which args are passed. As some methods support additional arguments, I can't use properties. I'm not 100% sure on this, but it seems better than having lots of set_* methods. 
I also wrote [nurl](http://codeinthehole.com/writing/nurl-an-immutable-url-object-for-nodejs/) for node.js. I've just found out there's also a [furl](https://github.com/gruns/furl) that provides similar functionality for Python.
I think `url.clone(**attrs)` would handle the proliferation of setter methods (assuming you want immutability, which I personally like as well). You could also allow constructor keywords, `URL(url_object_or_string, **overrides)` that do the same thing.
Well, if you think yours is the best, put that. If you think yours is the most clever, put that. I guess you're right, though.
Why not? I've never heard things against lambdas before, so I'm genuinely curious.
&gt; Why URL.from_string(s) instead of just URL(s)? Seems like the most natural constructor. If you want to make URL(full_url) the constructor that's fine but then I'd suggest making some other class method on URL to construct a URL from pieces (i.e. scheme, netloc, etc.) Personally I'm not a big fan of a constructor like `def __init__(scheme_or_maybe_its_a_whole_uri, netloc=None, fragment=None, ...)`. I don't like methods that go two totally different directions based on their first argument like that. And unfortunately I can't think of a name as nice as `from_string` to correspond to "make a URL from its various parts."
Because lambdas are limited (can't have statements, only expressions) and add complexity. Lambdas are just anonymous functions. At the insignificant cost of a named function the limits go away, and you gain re-usability. Lambdas are only acceptable as trivial callbacks, but I'd rather use named functions in general. I find that trivial callbacks often become non-trivial, multi-client functions. Some people claim that lambdas let them code without breaking the flow of ideas. For me, when I did use them, lambdas (and map &amp; reduce etc.) broke the flow because I used them so infrequently that I could never remember their syntax. Not using them made Python a simpler language, easier to fit in my brain.
Please don't delete your question after it gets answered this time. For reference, the current text is: Hey guys, I asked question earlier and got some great responses and I'm stuck yet again. My next task is to take XML that looks similar to this: &lt;persons&gt; &lt;person&gt; &lt;name&gt;Ed Um&lt;/name&gt; &lt;age&gt;22&lt;/age&gt;&lt;/person&gt; &lt;person&gt; &lt;name&gt;Bill Nye&lt;/name&gt; &lt;age&gt;43&lt;/age&gt; &lt;/person&gt; &lt;/persons&gt; And convert it into a JSON object that looks like this: {'persons': [ {'name': 'Ed Um', 'age': 22}, {'name': 'Bill Nye', 'age': 43}] } I found an example that mentioned make a list of dictionaries and then using dump to convert. The only problem is is that I'm not quite sure how to do this. Any help would be great. Thank you. 
I think the most clever way is make the use short and readable. It's not meant as a second function-form, nor as an code-block, so don't make it more complicated than it should be.
I'm the author of [PyTomCrypt](https://github.com/mikeboers/PyTomCrypt), which is a wrapper around TomCrypt. TomCrypt does support CCM mode, but since it is designed to be used to encrypt packets instead of streams I haven't quite figured out an API that I think would be appropriate in contrast to the rest of the cipher modes. If you took at look at my project and had a solid idea about what the API would be like, I could quickly implement it. 
Out of curiosity what do you need CCM for? I've only really heard it being used in tape backups. I think SUN was really big on it for storage.
Is u.subdmains() a typo or saving one char?
completely agree when it comes to using a framework. but the guy just wants to see if i'm capable of doing this first. it's by no means going to be used. 
.NET, (relevant to this sub due to ironpython, monad) has a system.URI class and a system.URIBuilder class. UriBuilder helps you construct URIs part by part, but it is not without it's issues. See this: http://petemontgomery.wordpress.com/2009/01/27/query-string-extension-methods-for-systemuribuilder/ If I were writing a uri builder in python, I'd definitely add support for adding on query string name/value parameters like mentioned in this article (Perhaps the OP's code does that, I haven't looked closely) If you took this the same direction, you could have both (or all four if you go URI/IRI/URIBuilder/IRIBuilder). 
Hi mikeboers, your project looks very promising! Looking at your documentation, it would be nice if I could do something similar to this: decryptor = cipher.aes(key=myKey, iv=myIV, mode='ccm') decryptor.decrypt(message) No worries if you can't get around to this quickly (or at all), but I'll definitely keep an eye on your project in case you implement this! Thanks!
Hmm that's good to know. I imagine that will decrypt much faster than a pure python-based implementation anyway. I will look into this, thanks!
apparently they do, but I didn't realize that until after I posted the last comment.
Giving up? I told you exactly how to fix it...
does this support python3?
Another oldy. Written for 2.2. Doesn't work under 2.7. print (lambda A,D,B,C,E,F,G,H,Q:"\n".join(["".join([(Q[int( __import__("math").log((reduce(lambda x,y:abs(x[1])&lt;=D and (x[0]+1,x[1]**2+y[1]) or x,[(0,complex(r/B,i/B))]*A))[0]+1) )%len(Q)]) for i in range(F*B,G*B,H)]) for r in range(C*B, E*B,H)]))(1500,4,100.0,-2.25,1.5,-1.25,1.25,4,".^:/I&amp;@*%$#") 
... Oh, Guido would have a field day with this. :-) 
&gt;As some methods support additional arguments, I can't use properties. sure, you could, just have fget return a function if you need arguments (so the getter would be the same in that case) and have fset take a tuple u.path_segment(0) # returns 'codeinthehole' u.path_segment = 0, 'tangentlabs' # sets path_segment(0) Of course, it wouldn't be immutable any more. edit: Mind you, I'd probably just make path_segment a list so you can get and set naturally using indexing (overloaded indexing if necessary)
Okay..I will admit that I'm definitely a python novice. I have a fairly good handle on the syntax and what-not, but I really haven't done much with it. That said, I'm curious: Don't these lambdas really violate like...half of the Zen of Python? Beautiful is better than ugly. ... Simple is better than complex. ... Sparse is better than dense. Readability counts. What am I missing? They are ugly, complex, dense, and hard to read. EDIT: After posting I realized I'm coming across rather harshly. I swear it isn't written angrily..I'd just like to understand this concept.
The best/most clever ways I've used lambdas (or similar) was in Ruby, not Python.
Are you using a *word processor* as a *text editor*? If so, they are two **very** different things. When typing code, it needs to be in plain text, not in formatted text, which is found in many word processors. Check out some popular text editors, which you can write code in, like [vim](http://www.vim.org), [emacs](http://www.gnu.org/software/emacs/), etc.
I've got a number of lambdas in [this blog post](http://ra3s.com/wordpress/dysfunctional-programming/some-parser-combinators-for-python/) on parser combinators.
Was just going to start to look into this stuff, wonderful timing. Keep us posted as you add new content!
Thanks! I almost feel like I should ask you to repost this on /r/community :)
Throwing this in my favs, will check regularly. Definitely a subject of interest!
instead of creating a new app, consider joining one of the existing ones you like/find interesting feedback from patches you provide is great for learning
Do the tutorial (flaskr), re-type all the code. Try to really understand the underlying concepts. Then read the Flask source code itself. One thing that will amaze you is that you are no longer working with a black-box framework; you CAN read the source code, and you should. As for what to build, that's a whole different problem... Good luck!
i'm excited, thank you! :)
awesome advice! how do I find existing projects?
Content encoding error on firefox from behind enterprise firewall. Explorer 8 is not supported.
I think they can be pretty and make things easier to read. For example, define something like `random_letter = lambda : random.choice(string.letters)` You didn't want to have to create a whole function to do this - that might make your module untidy. But on the other hand, you wanted a shorter, more descriptive name than random.choice(string.letters). So you wrote this lambda and everything is simple! They're also useful for keys when sorting. Pretty much everywhere you only need a tiny function, a lambda is good. Of course, some people take this too far, but that's their problem. 
Great! I'll be one following!
You are a little bit of an ass not telling what to use instead or giving any current resources.
lol. Shall I redirect you to the openGL specification?
Because one article is out of date?
pypi, github, bitbucket are places where projects are at *edit* also google is your friend :P
There's nothing like a free lunch. We can now stream live on YouTube as Python Italia is a YouTube partner, so in a way it's "free" for us, but the real cost is the capture hw and the encoding hw, plus having enough people to look over everything, fix problems, fix the lights, etc. 
By the way, the f\*\*\*ing [OpenGL Programming Guide](http://www.glprogramming.com/red/chapter01.html#name2) tells me to use `glBegin()`
Check out [VPython](http://vpython.org/) for easy 3D fun with Python.
Ha! Glad somebody noticed!
You fooled me.
I looked into graphite but I think it's a bit heavy and not really easy to use. (has to get installed into /opt and needs django 1.3. I just googled statsd and from the description it works with graphite.
graphite doesn't need to be installed into opt.. you can fix it to install somewhere else pretty easily.. Once installed graphite is pretty easy to use. some statsd implementations can also send data to ganglia. Having stats information in your logs is useful, but being able to graph them is even better.
The sub-title of which reads : &gt; [The Official Guide to Learning OpenGL, Version 1.1](http://www.glprogramming.com/red/) The red book is something they really should update, OpenGL v1.1 is from 1997.
As with most new languages that you might want to start working with professionally, I would recommend logging some hours personally with Python. As far as python goes, getting reviews through an existing project is one of the best ways to learn. Try to do something really difficult, or rebuild some basic thing with Python. That'll get you asking good questions on IRC, SO, and Reddit (of course). This is how I migrated from being a .NET developer to being a Python / open source stack developer. 
It's unfortunate that you started with outdated tech. glBegin() et al have been marked as deprecated since OpenGL 3.1 (march 2009) and will be removed from the specification. 
Perfect... I'm just getting started with pyglet and OpenGL. Thanks!
Well, it's a fucking complex topic which I have no experience with whatsoever, so I'd really be glad for a guide that covers the right, up-to-date way to learn the basics without mentioning obsolete functions.
Agreed. Many ex-Java and ex-.NET developers write excessively verbose code due to not knowing Python and the standard library, especially the standard collections. You should try to master most of the methods and idiomatic uses of at least str, unicode, int, float, list, dict, tuple, set. Doing some [Project Euler](http://projecteuler.net/) problems can be a good way of doing that. Also, a key principle is this: expect more. Expect more of Python. Ask yourself, "how has Python already solved this problem? How has Python already made it possible to write this code much more succinctly?". **Essential reading**: http://dirtsimple.org/2004/12/python-is-not-java.html Expect more of libraries and tools too. With Django, I often ask "how has this problem already been solved by a Django app?". Probably the same is true of Flask and its ecosystem of plugins.
Yep, that one comment now has me questioning whether this is worth investing the time in :(
You have incredible timing. I owe you a BJ.
wow this is great coming from someone who has done it. thanks! any more advice that you can give?
Oh yes! you're using PySide! I really hate the KeyboardInterrupt behavoir though, it seems that pyqt/pyside don't listen to it and won't let the app close. This is how i fixed it: #!/usr/bin/env python2 import sys import signal from PyQt4.QtCore import * from PyQt4.QtGui import * #Classes here app=QApplication(sys.argv) main=DataPresenter() main.show() signal.signal(signal.SIGINT,signal.SIG_DFL) sys.exit(app.exec_())
I just put this here: [how to NEVER use lamdas](https://gist.github.com/1023982)
I'm the kind of person who learned TeX before LaTeX. Does this mean that I'll like your approach to OpenGL? Btw, I've always wanted to learn some graphics programming. Thanks for starting this. 
Yes I prefer PySide to PyQt. Having used both extensively, I feel like PySide is being more actively developed (though I'm not sure if that's true). Also, PySide's documentation is better (since it's translated to Python while PyQt's is in C++) Plus, PySide's license is LGPL. 
In your playlist, the second and the third video need to be swapped
What religions do you see fighting here? Almost all tutorials, documentations, wikis, how-tos, ... are outdated according to *double*. Are there any **nice** and **readable** getting started guides yet for programmers who never touched OpenGL? Or does *double* expects me to read the specification first? Wouldn't that be a little bit overkill for an introduction?
Thanks, done.
It would appear with `any` as well (except for the colon). submit = any(w in page.text for w in buzz_words + async_sexiness) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Stay tuned for part 2 then, as I'll be going over what you should be using, although I still recommend you read part 1 because it'll make understanding part 2 much easier.
I usually use Arch Linux, however, the project I am working on right now is a Windows-only application (commercial) so I prefer to work on it in Windows. I also need Visual Studio for some stuff. Though I prefer Linux, Windows too is a great operating system. 
$2000 to be a certified Python programmer? Ouch.
but this will also apply to devs using Linux right?
Sorry for droning on, but I honestly wouldn't be where I am in life if it weren't for people dedicating their time and effort into teaching the next generation of programmers. And for some reason, video tutorials just work so much better for newbies :P
I dunno, the PHP I've read certainly looks it, but that's because the people who write it are just learning how to write English :P
Loved it. When is part II ?
I'm going to watch the rest of the videos soon (only watched the first for now), very nice. Here's some feedback from a fellow pyside dev: - A little long, you tend to go on a lot on small irrelevant things (the backslash differences for example). - Do highlight that the c++ docs are the best and give some advice on how to read them, a lot of python devs have never touched c++ :) - If you know QML, please make a video about it! I'm very interested myself but never really got into it. - I'd also love a video about best practices on actually organizing and packaging your app. There's a lot of confusion there and I myself never felt comfortable with the way I package my apps.
How many IPs have you tracked?
The PySide doc is a mess -- it's autogenerated from the Qt doc. I always prefer the C++ docs, once you know how to read the minor c++ differences it's awesome.
Yes, but IMHO they're better than the PyQt docs (for Python-only developers). In a later video I will show people how to read the Nokia's docs. 
- c++ docs are great but these videos are primarily tailored Python beginners who have no knowledge of C++. That being said, I intended on making a video in which I show how to read the Nokia's official Qt docs. - I am still learning QML (which is awesome btw). Unfortunately I haven't found too many great resources online, but still. I'm hoping that I'll have a grasp on it by the time I decide to make a tutorial about it (towards the end)
Actually PyQt is on top technically. It's more complete, mature and the bindings for new Qt versions are available faster. PySide seems probably more actively developed because there's still more to do. However both are extremly well done and I'm glad that PySide was started.
I respect your sharing this work for the benefit of others. However, personally I avoid video tutorials because... well, life is too short! The same content presented in a written form with code samples and screenshots is anywhere from 2 to 10 times faster to consume than hearing a video explaining everything in detail. Moreover, written material is much better for reference. If I recall having seen something in some tutorial, I can easily find it in seconds. Not so for a video where I have to laboriously browse through it trying to remember where you talk about what.
Hahah this made me laugh. What a random thing to put in a TV show, "I'll create a **GUI interface using VisualBasic**"
TIL "icebreaker"
Well, len('status') &gt; len('ls') &gt;&gt;&gt; True
Because it goes much further than just using a VCS to look at files on your *filesystem*. Git status has nothing to do with listing files anyway, it lists the status of files in the context of your working tree vs. index, using it to list files is totally not what it's for, but you know what is for *listing files*? `ls`.
I personally prefer to show them, since they are indeed here, but to keep them in low contrast through dircolors...
Yes. I find them incredibly distracting to wade through when looking at a listing of say, 30+ files.
Wut? You're giving really stupid black&amp;white advice. I called you out on it.
Interesting. How do you actually set a color with dircolors? The documentation doesn't seem to say.
I just edit my `~/.dir_colors` [coming from https://github.com/huyz/dircolors-solarized] and add a line like: .pyc 01;33 
Lambda functions are almost exactly the same as def functions except that they only contain an expression and that the expression is automatically returned. So if you have a generic function that looks something like this (replace `a`, `b`, and `c` with actual contents): def a(b): return c Then you can turn it into an equivalent lambda like this: a = lambda b: c
You can install a third party ~/.dircolors file from a number of websites. If you want to take the default and modify that, you can: dircolors --print-database &gt; ~/.dircolors Make changes to that as needed, it should be pretty well-commented. Then verify that something like this is called during shell startup (it's in my ~/.bashrc on Debian "squeeze"): eval "$(dircolors -b ~/.dircolors)" ...and: alias ls='ls --color=auto' 
What would be more useful would be the ability to hide them from autocomplete so when I type `vim myfile` and hit Tab, the terminal doesn't beep.
To the best of my knowledge, there is no such thing as `git ls`. `git status` is entirely unhelpful for listing the full contents of a directory.
TIL about --group-directories-first. Good post!
Here is [nice screencast](http://www.youtube.com/watch?v=fAEjgeh6FYY)
python does not have nice lambdas and isn't designed to be used with lambdas most of the time. Most of the time you will want to use list comprehensions,dict comrehensions,generator expressions,explicit looping, and/or defining locals functions with a name and then using then instead.
in smalltalk controls flow use methods(on true/false for if/else, and on collections) and block closure literals. I believe lisp usually prefer macros to remove explicit anon functions, no?(note: I have very little lisp experience, and a small amount of smalltalk experience)
this looks pretty damn sweet. 
Which is "New in version 2.6" unfortunately. I'm stuck with an embedded 2.5.1 for now.
&gt; Nested functions using def are more confusing to me than lambdas. Missed your edit, can you show this with an example?
Editing your .gitignore for .pyc files is a good habit to get into.
Thank you for this :)
But that's... not true. The second one is MUCH easier to read.
It's subjective. But it's better to be on the side of the many, so I will have to train myself to like the second over the first.
You better make more.
Yes I do, but it is not part of my workflow. My initial comment was a gut reaction about something I did not find terribly useful, I should have asked "why are you using ls for?" to begin with. Also, to be useful in my case, the alias should be extended with --hide=*~ --hide=*.o --hide=*.rej --hide=*.orig --hide=*.so and so forth. And then I would get something a bit similar to "hg st -mardc .". But who cares, we apparently both know how to use these things (yay man ls), I was more interested in the OP reasons. Edit: this was more "hg st -mardc .", not "hg st -mard ."
&gt; but what splashscreen are you talking about? Can't blame you for asking. 18:35 ~ 18:55 - this is the kind of pointless, often subconscious "stray" that happens all the time in real classrooms (i.e. unscripted). 
i'm on 10.7.3 and --color=auto isn't an option, neither is --hide
I'm not comfortable posting it to [/r/wow](/r/wow) until I have an actual GUI that works fine on Windows.
You say "text file", but inherently that means coming up with some kind of file format, and that means knowing what kind of data this list stores. Maybe it's numbers, in which case you could store the list as simple whitespace-separated values all on one line. But maybe it can contain words or strings, in which case you might want one item per line, or something that uses quotes, like CSV. You need to work out all the details. The actual file opening/reading/writing is easy. 
my favorite way: rm *.pyc :P
I think Lisp might, but Scheme is very heavy on anonymous functions.
Apache.
We use gunicorn. It is working quite well but, it does not have the ability to serve static content. So you have to put it behind another web server, (nginx for example).
In case you weren't aware, lambda was almost cut from Python 3 (well, Python 3000 at the time) by Guido: http://www.artima.com/weblogs/viewpost.jsp?thread=98196 One major difference with lambda is that it can only hold one expression. While this may seem obvious as stated, it is a bit more subtle: it's because lambda definition is itself an expression, allowing it to be used in-line. There are many, many things you can do inside def that you can't with lambda, because it is, in fact, a statement. The statement/expression distinction is the real reason why there are both. Named vs. un-named is somewhat of an over-simplification. While it's true that only a lambda can be used in-line, it doesn't mean it's wrong to use it otherwise. There are also some style guides I have worked under that made strong proscriptions about line length and spacing around functions, which would make named lambdas preferable in many cases for readable code. PEP-8 doesn't really weigh in definitively on the matter.
Not a problem, already running nginx.
Apache, which would be mod_wsgi, seems a bit heavy weight just to act as an app server. 
I tried gunicorn (for serving Django) but found the latency to be unacceptably high in my testing. I used it both with cython and pypy with no better results. I also tried uwsgi and found it to be very good and highly configurable; it'll take a few minutes more effort on your part to get running but I'd say it's probably the front runner for my future deployments.
like everything though, they can be abused and in the wrong hands, they can yield a mess of stuff that you can't read or debug or maintain. 
uWSGI behind nginx is what I use in production and it's great.
We should say that if you're running a program regularly that imports a lot of modules, that setting will slow it down. The speedup is why .pyc files exist in the first place.
BSD ls in general uses -G.
If you use curses, you may be surprised: many roguelike fans love the ASCII interface. My SO was actually a bit put out that I decided to do my roguelike with graphics. Also, you could put in a boss key, so people can hide it if someone decides to hover by their cube ;)
we currently gunicorn in all of our new deploys. Dunno about the dude complaining about latency... it runs just fine for us. Put Nginx in front of it and serve your static files through it. Nice and easy. Apache + mod_wsgi is another option. 
I think so. I don't have any CL or Smalltalk experience, but Scheme sort of encourages unnamed functions. 
I am giving it a try, but kinda surprised I'd have to pay.
Apache + mod_wsgi has proven to be a fairly stable, well supported and easy-to-configure deployment setup. It's not the fastest and lightest in terms of system resources but setup is super easy and mod_wsgi provides a nice advantage that you don't have to manage a seperate application server process (just `touch` the wsgi file and apache will restart the app server) Edit: That being said, nginx and uwsgi is a much much better performer but does take a bit of effort to set up correctly.
Another vote for nginx+uwsgi. nice easy setup, simple monolithic binaries, straightforward config.
You're welcome. It occurs to me I should introduce those unfamiliar with Julia to http://julialang.org/ as a starting point. [Octave still has a lot of gaps, no?]
Ok, I'm an idiot... But can someone explain to me how Julia, which is JIT compiled, could run interpreted CPython scipy code?
Add this to your bashrc to ignore pyc files with autocomplete export FIGNORE=$FIGNORE:.pyc
if you install bash it should work. 
That's one of my least favorite ways, because they all immediately come back when I import or reload something that drags in the rest of the library. Also, it's dangerous to be typing that. I might accidentally hit enter before the c drops. I would be typing that all day long. Now listings just sensibly hide the files I don't want to see.
You could do that, you could also have the Julia runtime embedded in a Python process. I've done it with e.g. Matlab, which is also JIT-compiled, it can be fairly straightforward.
Here's some random/assorted notes I took while watching it. They probably won't be entirely coherent, but may give you an idea of what was covered. http://bpaste.net/show/27565/
On the flip side, you can run like 100 WSGI apps with just one Apache instance. Still haven't figured out how to do that with uWSGI or gunicorn, but I'm not sure I want to keep doing that anyway.
[Here is a picture](http://i.stack.imgur.com/2YWYt.png) of the two candidates for our code base.
Thanks for the article. Have you run across anything benchmarking more recent versions? This is two years old.
when you setup a wsgi application on webfaction, you get an apache instance with mod_wsgi that is sitting behind nginx. Webfaction throws it in your webapps directory with the push of a button. (1 apache instance per wsgi app) I would guess that if it was sooooo like heavy man, they probably wouldn't do things that way.
[1TBS]( http://en.wikipedia.org/wiki/Indent_style#Variant:_1TBS) d = { 1: 2, 3: 4 } 
We wrote this at work for our planning poker game, among other things. We might release the game itself if there's any interest.
I'm not too fond of this format for Python. It definitely is a classic style for C, Java, JavaScript, etc, but Python deliberately avoids braces for a reason. Why not... *embrace* it? :) As mentioned in my other post in this thread, here's my preference: d = { 'firstkey': 1, 'secondkey': 2, 'nthkey': 3 }
[Here is the image](http://i.stack.imgur.com/2YWYt.png) this poster is referring to.
Second one is the only acceptable choice.
The downside to your strategy is that if you add a new item to the dictionary later, the diff will show one line added and one line changed. So I prefer to have the closing brace on its own line, and add a comma to the last item, so that you can add an item with just one line inserted.
 export LS_IGNORE=*.pyc
This is a bit hard to read. You'd be better off putting it into a [gist](https://gist.github.com/gists/new), which has better pretty-printed formatting.
Wrong subreddit.
More people should know about Scrapy.
is it possible to make a copy of an actual authenticator currently running on a mobile device if you got the serial number and the recovery code ?
Maybe it's not explicit, but it's an obvious waste of space and no example anywhere in the doc uses that format. If you Ctrl-F and look for "Continuation", it agrees with your starting on a new line, but everything brings the closing bracket in-line with the last item.
Can you please stop posting images of code? Just post the code...
Just a heads up, that the pip install fails on Win7.
 My personal preference is: mydict={ 'key1': 'value1', 'key2': 'value2', } I like each key-value pair to end in a comma. This trailing comma keeps a consistent line format for each pair. Next I like the last brace to not be indented, this way when viewing the code, I can see the indented code and keep all of it visually associated with data in 'mydict', not with the constructs around it. A side note, many people seem to get emotionally charged over code style, almost to the aggressive point of vi vs emacs. To avoid this ,Stack Overflow disallows posts that only lead to debate over style or irreverent opinions, thus why your post was "trashed." Opinion posts on which library to use are allowed as those often discuss bugs, flaws, and strengths between different libraries, this rarely happens in a code style post, and from what I have seen there, rarely lead to a thrashing session on why ones brace choice is stupid.
Ok... I just noticed that on iPhone you can now write down a recovery code that allows you to recover the App after a wipe of the phone. But I guess that's not the secret.
Gotcha with this one: If you're going back and forth between Python and JSON, that trailing comma bites you. (ie. I use both python source and json as configuration/data files) 
Never confuse popular with good choices. See: Node.js.
fails how?
No problem. I've always wanted to make a roguelike (although completely in ASCII and played in the terminal) and your posts really help.
Seems it actually gevent that fails. My bad. If you install a prebuilt package for gevent, then it installs cleanly. http://www.lfd.uci.edu/~gohlke/pythonlibs/#gevent &lt;- The one I used.
&gt;If you're going back and forth between Python and JSON, that trailing comma bites you. Are you saying that the python-to-JSON converter barfs on python dictionaries formatted with a trailing comma? 
I'm not sure if we can fix that in womack's setup/requirements, but at least we can document it. I put an issue in the github project so we don't forget. Thanks! [issue link](https://github.com/leapfrogdevelopment/womack/issues/1)
Good point.
I am actually married to the object method, for reasons outside the scope (mostly because this will be a factory module). 
There is recent activity in its [Mercurial repository](http://code.google.com/p/pyglet/source/list).
Be careful what you're naming things! I see you're using `type` as a variable name. That's a big no-no, at least in a lot of people's (metaphorical and literal) books.
wow there's some good suggestions there. I've got lots of things to think about, though appengine has it's own answer for deployment. "The trick is to build a debian package (but it can be done using RPMs just as well) with the application and the whole virtualenv inside. The configuration goes into Puppet and Puppet also takes care that the respective servers have always the latest version of the DEB" OMG How to do this? THAT is the question. 
Build your virtualenv into /opt/myapp and then run [fpm](https://github.com/jordansissel/fpm) over it.
The IRC channel is also vibrant, much more so than some time before. #pyglet on Freenode.
fpm has fucking revolutionized how I think about packaging software. I'm in the process of turning everything custom, both at work and at home, into Jenkins+fpm.
Why is there no convenient link to the beginning of the series? I want to read the whole thing from the start but it's so hard to find old posts :( edit: Nevermind, I guess I missed the 'tag' section at the bottom of a post.
It's impossible for the package to be fine as-is if it's *broken* "Release early, release often" is relevant to open source, too. In fact, these days it's even more relevant. The landscape changes so much that if you're not keeping on top of things, your software breaks in a year or so. More importantly, prospective contributors may see a project that hasn't had a release in two years, and not be drawn to assist. Last time I checked the HG repo, there's only three guys doing anything, and they're practiaclly begging people to help them with the MacOS port. I'm not asking for new features or API changes. Commit the few bugfixes you have to a minor release. It's all a matter of perception. 
I just learned some basic programming in the last couple months and this is my first project built on Google App Engine. any feedback/questions/comments would be greatly appreciated.
Nothing stays that simple for long.
That throws off the line-oriented vim operations, though; I can no longer insert a new key-value pair by pressing merely `o`.
are there real companies that do that? I mean big ones with departments of developers and departments of network administrators and departments of power hungry IT folks who all hate each others departments. 
Yep, people should look at scrapys code for the "right" way to write a python app
I think it looks pretty good for someone who's just started. An original idea, at that. Hope you can make it work. Keep in mind that GAE will get expensive at some point, so you might want to think about some other python framework on a more conventional server. I use bottle.py quite a lot on a server at rackspace, for instance. Also pythonanywhere is pretty nice. Anyway, nice start. Keep up the good work. 
Come on... It gets rid of unnecessary curly braces to delimit blocks by using indentation. You really kind of hate that the brace characters are still used?
Great idea and a job well done! I'm a GAE noob, so is there any way we can see your code? Of course if you want to share it with us.
no, but what does "good" have to do with reality?
devopsborat is numerous weekly lulz on twitter
The blog post says to use Puppet or Chef. I suppose it makes sense for people who run things like server farms, but not me.
It has to contain the secret; or perhaps it's a code that gets sent to blizzard servers but that seems insecure. I had never heard of that before. Edit: Sweet, it seems the android authenticator has that too. I'll run some tests and see if I can implement it. Thanks for pointing it out :)
I was a GAE noob up until a few days ago...oh wait, i'm still one. I really just used the bare minimum in GAE, just as a framework to put my project on the web for free. As for the python code, show info lookups and stuff, the two modules that I used were BeautifulSoup for web parsing and oembed, to embed videos. I'd be more than happy to PM you some code, if you have any specific questions.
Aww really? Are there any other libraries using openGL that aren't dying? 
Google App Engine
Oh, just the "[webapp](https://developers.google.com/appengine/docs/python/tools/webapp/overview)" framework that comes with GAE?
Yeah, don't use that, just build your own venv and then use fpm to cram it into a deb or rpm :-) Works with anything else too, just a way to version and deploy a folder of stuff.
I prefer [devops_jerk](http://twitter.com/#!/devops_jerk), myself. But then again, not really a fan of Borat.
In my experience, pygame performs better for lots of 2d games, especially in Windows. This is especially true if you make use of its higher-level facilities, like LayeredDirty and DirtySprite. (awful names, but they work great!) I'm not saying Pygame is a great library. It's ugly as sin, and the website maintainers are blind. But I have to give it credit for actually working. 
Gunicorn.
DEBs/RPMs for code + virtualenv, Puppet/Chef for config. Once you’ve set it up, you won’t want to go back.
I now [implemented](https://github.com/Adys/python-bna/commits/master) the restore feature. Run the following: bna --restore [serial] [code] This will recreate your serial/secret pair and, if you don't have an authenticator set, set it as default. If you want to get the restore code, just do: bna --restore-code [serial]. If serial is not specified, it will give you the restore code for your default serial.
I hope you go into more detail about the DEB/RPM thing in the next part of the article. This sounds like a really interesting approach!
Nice. I knew all of this once, but I forgot some stuff. Thanks for the reminder.
I used to love Pyglet, but it hasn't worked usefully on Mac since Carbon was deprecated. It seems like abandonware. Quite sad.
I'll go against every one here and say that: d = { 1: 2, 3: 4, } is correct. Before I get down-voted into oblivion, my reason is thus: **every** editor on my machine automatically indents in this way (emacs being my primary editor). Also, **it's python**, so keeping the indentation level the same for the block makes a hell of a lot of sense, in the same way that it's preferable to write an if as: if True: do_something() rather than: if True: do_something() That's logical to me, and feels Pythonic. But what do I know. Down-vote away!
With `shell=True` you are expected to pass a string that can be parsed by `sh -e`. You're passing a list, so it fails. The reparenting is probably happening because you're forking a process from inside your wrapper script. If you post your wrapper script then I might be able to confirm this.
Why are these called "anti-patterns"?
Looks like the recent mercurial activity is based around mac support so might be good.
 len(fdict)
so whats the different between an app and a web app ?
Note that there's a bit of what philosophers call "recurrence" in this discussion: "package==1.3" vs. "... &gt;= ..." has been in and out of fashion through several cycles (not just in Python) by smart, deep-thinking people, as have use of system packages (no, really), home-grown RPMs, ... My conclusion: it's a very good thing to talk these matters over; and it's perhaps equally good to recognize that patterns are to help us think about our own situations, and what's truly best for them. I still see a big role for an experienced practitioner to figure out how to adapt "the rules" to local requirements. I'm jaundiced about the formal style of "Things not to do" articles. Mr. Schlawack made the best (that is, the least) of it. I'm big on buildout, myself. I'm currently trying to figure out where to put the Puppet/Chef boundary ...
Typo perhaps? A web app is on the web...
&gt; Note that there's a bit of what philosophers call "recurrence" in this discussion: "package==1.3" vs. "... &gt;= ..." has been in and out of fashion through several cycles (not just in Python) by smart, deep-thinking people, as have use of system packages (no, really), home-grown RPMs, … If you look at the discussions on HN and here you’ll see that it is necessary to reiterate from time to time. I knew all this stuff too, or else I wouldn’t have been able to blog about it. ;) &gt; I still see a big role for an experienced practitioner to figure out how to adapt "the rules" to local requirements. That’s why Mr. Schlawack (that’s cute, I think I’ve never been called like that on the Internet in the 10+ years I’m using it :)) gave a context right in the beginning. There is no such thing as a universal truth. However, I claim that most of the points are valid for most people trying to deploy Python applications.
How about "dvcs-version" ? Also, I expected a way to configure the returned version format and not crash on a tag-less git repository.
Sadly it's *planning* poker, not the fun kind. You use it to estimate stories in Scrum, not play Texas hold 'em.
&gt; I’m still shocked how many people argue against isolated environments. I can see at least two potentially relevant arguments: 1. The isolation means you won't even get a warning about a virtualenv that is out-of-date with its security patches. 2. It might be the wrong level of virtualisation. If you're running multiple instances off the same hardware, you might be better to have virtual OS instances running, which means you can have bespoke and independent configuration for everything else in your deployment as well.
Agreed. Could do with a bit of spit and polish, since it was written in 2006, but it is still as useful as it ever was!
its just funny that they got rid of them for everything else, and now the one thing they left them in for is causing arguments and confusion over how to format them properly.
&gt;With shell=True you are expected to pass a string that can be parsed by sh -e. You're passing a list, so it fails. Oh right, thanks for pointing that out. The wrapper script is an executable that I don't have the source for (i.e. it's not just a shell or Python script). 
This is a thread to just type things on the internet. This isn't a real problem and it's not actually confusing anyone.
Read "Code Complete".
I like naming functions verbs and variables nouns. find_result() a_number
Clean Code: a handbook of agile software craftsmanship is also a great book. Everyone should probably read both of these books. 
Applicable to every language: Don't over abstract. It will impact modifiability of your code negatively.
PEP8 makes no mention of that, I am not sure where he came up with it.
My point was that they need to release. All the mercurial activity in the world doesn't mean squat. If I wanted to distribute an application without *also* distributing pyglet, I'd be SOL. Releases mean I can target a version of the code that I *know* works.
It may be using 12 year old techology, but it still works. I've had numerous issues with pyglet. Most are fixed in mecurial. However, developing an application to target a specific snapshot in a VCS is just silly. My point is simple: they need to release.
Another disadvantage to that setup, (related to the first), is when testing. It essentially eliminates the possibility to mock parameters easily.
Why don't you start with reporting the PyCharm performance problems to the development team? http://devnet.jetbrains.net/docs/DOC-1212
Code completion (at least somewhat intelligent), project management, ability to run the code from within the IDE, and also a Git integration would be very nice. 
[IdleX](http://idlex.sourceforge.net/features.html) provides a very simple IDE with some interactive programming extensions. I use it daily for my research computing. If you have questions about it, ask me. I'm the developer.
If you're someone that makes typos all the time, an IDE like Sublime can be a lifesaver. The trick is picking one that doesn't make your system grind to a halt.
Emacs. 
-or-? Heathen! Choose!
PyCharm performs well for me. If you have a slow or low memory machine, you should consider using a text editor instead of an IDE. I like TextPad. But not as much as PyCharm.
Memory is not that much of an issue (I have 6 GB), but CPU power is. How is PyDev when it comes to CPU consumption?
vim
I love BBEdit on my mac
I tried WingIDE for a while and while I liked it, I couldn't figure out how to get console output within it? 
&gt; What part of an IDE do you need? Here's a sample of things PyCharm does for you: - Completes your code (based on all your code and the libs you're using) - Helps you in refactoring code, for example moving or renaming methods, classes, files whatever. Most of the time you can just rename something and have all its usages be renamed too. Boom. (This stuff works perfectly with Java code in IntelliJ IDEA, but Python is trickier, being dynamic) - Points out irrational things (ie. you doing them). For example pointing out something like "You're editing a class, and methods tend to have "self" as their first parameter. Yours does not. Is this alright?" - Shows you all the directories in your project and their contents - Lets you jump to any file, class or symbol you need to find, through a search box invoked with a keyboard shortcut. - Lets you jump to any implementation of anything at your cursor, through a keyboard shortcut (or shift + clicking) - Lets you jump to a superclass of whatever you're working on (shortcut) - Lets you navigate to whatever location you edited last (and before that, and before that) (shortcut) - Lets you navigate back and forward through whatever you've been looking at. (shortcut) - Shows you a documentation pop-up of whatever's under your cursor (shortcut) - Completes your HTML tags, and their attributes (according to HTML specs) - Completes your CSS definitions (according to CSS specs), and points out things that are wrong, etc. - Completes your JavaScript code - Helps you work with Jinja2 or Mako templates (yes, in a syntax-aware way) - Helps you run your code and debug it (with a debugger). .. and a shitload of other things. It may be slow, but it's just a completely indispensable tool, without which I wouldn't have shipped any Python apps of my own. It just boggles the mind how there are people _not_ using PyCharm for Python development. 
I use SPE.
If you are on windows you could also try pyscripter, i heard good things about it.
It's not a bug. It's called a massive java app that uses 1GB of RAM. All the JetBrains stuff runs like a dog. Sorry, but it's just the truth. All the bits of little lag just make it an infuriating experience for me. ***There should not be an observable framerate while typing.***
You can do all of this within an editor like vim. Jus sayin.
Yeah, the JetBrains products are wonderful. Well worth the money for the code completion alone. People who have only ever used things like Eclipse don't know what they are missing. As for people complaining about 500MB I just don't understand what year they are living in. I built my current computer in 2008 and it has 8GB of memory. Why would I care about a program wanting to use 1/16th of that?
Download it and see yourself. It's a zip package so you dont have any worries. Many complain about mem &amp; cpu usage of eclipse, I never had any big problems with it. Just be sure to download the naked platform runtime(51 mb), it's really hidden in their site, so here is the [link](http://download.eclipse.org/eclipse/downloads/drops/R-3.7.2-201202080800/) Then install pydev and report your impressions ;)
I'm currently away and not near my desktop computer. My laptop computer has 6 GB of memory (upgraded), but the AMD's E-350 Fusion APU (dual core @ 1.6 GHz). It's not the memory that worries me - it's the CPU usage. 
Oh! Disk IO is your problem, then—Mac Minis have shitty 5400 RPM laptop hard drives in them (I have one and know all about how it takes 15-20 seconds just to open a command shell ... ouch.). You can probably improve performance considerably by enabling "Power Save Mode" which should stop all background tasks. I would also strongly recommend upgrading to an SSD for a big performance improvement. 
Eclipse + PyDev +Git/whatever plugin of your choice. Works very well out of the box, including for Django development.
Yep, after asking the question here, I get the feeling that "YOU EITHER USE VIM OR FUCK YOU!" Seriously, vim is not for everyone. I used it before, many times, and I simply do not like it. 
Wing IDE. I have used it for years on Windows and on Linux. It works just as well in both environemnts. When I have issues with it, the dev team has been responsive.
Console output for wingide is in Tools-&gt;debug I/O, it will be on a tab where the python shell display is. I code python both for fun and for profit and i will not use anything else other than wingide. It is not free but the email support is worth it. A simple shot to the mailing list about your problem and either another user or a support person would have answered you. The product support is worth the price of paying for the IDE. You also get the source code if you get the professional version. Disclaimer: I am in no way affiliated or work for wingware. I am just a very happy and satisfied user.
Scumbag Reddit: OP specifically says he does not want a text editor, majority of people respond with 'vim'. 
I was never much of an ide guy in the first place. I've always been a fan of a basic programmers editor - I just need syntax highlighting, and that's about it. I actually started just using IDLE way back in the day (e.g. 1.5.x). PS: Yea, I wish budgets for hardware here were a bit higher. Downside of being a dev at place where software isn't the product, and profit margins on our _actual_ product are not astronomical.
umm, because code is text and terminals do text well?
Are you on a Mac? Vote up this: http://youtrack.jetbrains.com/issue/IDEA-84652?projectKey=IDEA
so what do you believe is not so easy exactly?
Sublime Text2 and Package Control are a confirmed Godlike-headshot-kill.
consider using vim if you haven't yet
I'm not even a huge emacs nerd, but I can't resist it's charm. Now when I try to save files in any program, I instinctively think C^x C^s instead of just C^s.
I use PyCharm now but I liked WingIDE when I tried it a few years ago. There were some annoying X-Window-related quirks at the time, though. For PyCharm I would give the "Power Save Mode" a try. It's available from the File menu and it should disable some of the background processing. You might check to see that there aren't any (unnecessary) very large files or packages in your project path. You can also try turning off "Synchronize Files on Frame Activation" in the "General" settings. (you can always right-click on a folder and manually tell it to synchronize) Here's a link to some [IDEA optimization tips](http://hamletdarcy.blogspot.com/2008/02/10-tips-to-increase-intellij-idea.html). It's very old, though. Maybe if you sent an email to JetBrains they can give you other recommendations. Best of luck!
i use Chocolat + terminal chocolat has built in code completion etc, as well as error checking though this is a little less verbose than ideal. chocolat also supports "Vim Mode" if you want to keep the vim keyboard shortcuts
Yep, I have. OpenJDK was just... horrible (when it comes to PyCharm performance). 
"I don't understand it, or have the time to learn about it, therefore I think it's wrong..." I prefer the circle jerk :P
I'm sure whatever is making it that slow is fixable if you want to put some effort into figuring it out. I've seen the delayed keystrokes thing before in other Jetbrains IDEs. It was always able to be remedied. If its just slow to do things like completion, that's a different problem. 
That's beside the point. I asked for an IDE. Not a text-editor-with-plugins. An IDE. 
The jetbrains devs absolutely suck at customer interaction. It's the one thing that makes me a little reserved when I recommend their products (which is a few times a week.) 
You think you hate them? I'm color blind.
I don't know... I never use my mouse while dealing with text...
I do - that's why I'm asking for a non-terminal (and non-terminal-like) IDE. 
Do you use virtualenv? Any tips on setting it up w/ virtualenv?
ok just checking.
So you were forced to use it in school. got it. Seems you missed the point. :)
&gt;When check to see if an object is true, use "if object:" rather than "if object == True" or "if object is True" This has bit me in the ass before, and it's a consequence of python's type system. If you are testing to see if something is true, then you better be sure it's true.
with Pycharm you must set your project structure and file scope to include only those files that have to be checked by Pycharm for autocompletion, etc. Not doing this produces an important speed penalty. I suppose you already tuned it, but just in case...
Sublime Text 2 is great.
Link please?
So you want an IDE without a text editor? That will be a tough one.
Just because vim(or emacs on which I worked throughout the one year, but then start using vim) works perfect with text(and yes, with text is **better**, much better, work **without** mouse). The sadly part is learning curve for vim very different from notepad/pycharm/etc. If your objection is "I like my IDE" - then fine, use your IDE, but vim is a **more** then text editor this is a *"way of thinking"* and it suitable not for everyone.
I think the point is to reduce the amount of time spent on learning and configuring emacs/vim and other text editors to do basic things that IDEs like eclipse do out of the box. The endless configuration crusades and masturbation with .emacs/.el extensions can drive a man crazy. And eventually you end up compromising on some features that you want because you don't have 2 years to learn elisp internals and then reimplement the kernel inside of emacs. 
To most of us it's sort of like asking for a brand of hammer to do a saw's job. Of course you're going to get a lot of people saying: just use a damned saw.
in fact I already see the point with two folders and 10 files
PyCharm is one of the few IDEs I've used that actually helps me connect with the code better. Unfortunately, speed is definitely an issue. Anybody done any profiling on the biggest performance hits? Otherwise, I can't imagine coding with anything else.
Thank you.
I really have no idea what kind of IDE you're talking about if you don't want a text editor. Maybe python doesn't have what you want. The price on PyCharm is prohibitive enough for me to discount it because it doesn't do exactly what I want it to do... or said differently, it feels foreign enough that I don't want to spend time learning it. I personally use Visual Slickedit (http://www.slickedit.com/) on many things. It's not perfect by any means, but it does integrate with most things if you want to spend some time tinkering with the settings. I especially like most of the default settings. I generally have a terminal / command prompt open (depending on the OS I'm using at the time) if I need to test something out quickly. Slickedit works best on Windows, second best on Linux and worst on Mac, though I have to say that their latest version is a step up from what they had before. That said, I agree with most here: vim/emacs are the best text editors for a reason. They have matured and are so widely used that they have plugins where things are missing. And I use vi(m) about 50% of the time. Incidentally, slickedit has a vi emulator so I get all of the same power in slickedit with the same keystrokes. VI has a bad learning curve. That's the worst part about its power. But once you start using the keystrokes you'll find it saves you time that your mouse cannot give you. Seems like that was the part you were interested in most: the time. The suggestion by most people is a sound one for that regard. That said, if there really isn't an IDE that fits what you want in an IDE, perhaps you should consider starting up a business that sells your perfect IDE.
I like the [eric ide](http://eric-ide.python-projects.org/)
I don't see how "I don't want to use vim. Or emacs. Or gvim. I simply do not want it. Is that not enough? How hard is that to accept?" is wrong? Also, I am very glad for you. Very glad. You keep using Vim/emacs/notepad, but it would be nice if you stopped shoving it other people's throats when they ask "anything BUT vim/emacs". 
Right? And the Vim suggestions keep coming even though he explains in 10 different places he understands Vim can be made to do stuff but it's not for him... 
My search isn't a real search, it just returns a form (picture) of the show that you type in. It has to be an exact match, string that I have in the code. Even 'parks and recreation' wouldnt return anything. only 'Parks and Recreation', exactly how I have it typed in the code. I know I could easily change this, but it wasn't the most important feature, and I plan on changing it when I find an alternative.
True - I have never used the free version. You can try out the pay version for 30 days before deciding if you want to buy it. It is also not that much for the pro version.
Since you are using windows you could try [PyScripter](https://code.google.com/p/pyscripter/). It has the following [features](https://code.google.com/p/pyscripter/wiki/Features). I used to use pydev and it has similar (if not more) features but it was slow on my below average work computer. Now, you already noticed that a lot of people are suggesting vim. At first they might look like those annoying door to door preachers (Mormons, Jehovah's witnesses and whatever they are called) but actually the vim preachers are really trying to help you. Learning vim takes time and in the beginning your performance will drop. However, once your vim skills improve it is really a second nature. Just like typing without looking at the keyboard, at first it looks impossible but soon it's quite easy. If you choose a path to master vim may I also suggest [pentadactyl](https://addons.mozilla.org/en-US/firefox/addon/pentadactyl/). It's like vim for your (firefox) browser and it helps quite a lot to stop using the mouse and learn the shortcuts. TL,DR: I really hope you are not a Mormon and that you can touch type!
Exactly. That'd be like me saying you should definitely use OS/2 or BeOS, because it can do anything other operating systems can. 
indeed, i find that waiting on someone to do something for you is generally the best way to achieve goals.
What's the difference between "IDE" and "text editor" anyhow?
 sudo python setup.py install
no, however, while *I* respect that and have appreciation for the fact that we're getting direct contact with the devs.. I many bug reporters don't see a benefit in that, because they don't have the technical expertise to take advantage of that access. the webide devs often come across as defensive in the threads on the bug tracker. It's a natural tendency since it's your code, but it's part of the reason that most companies have QA personnel as intermediaries. there are a number of issues that I follow that lead to simple answers that can be summarized as "can't reproduce, not our problem." even if that is accurate, it's not the best way to represent your products. I say this as someone who is a huge fan of IntellIJ and the webide spinoffs, and have converted at least a couple dozen people to your company's offerings.. so it's probably worth considering how it impacts those who aren't yet sold on JetBrains.
Just use Linux? 
Because you don't understand how someone else can do it, you assume they must be *pretending* to like doing it that way. That's a very immature way of viewing the world. I prefer working without a mouse, but I can also understand why someone like yourself might prefer using one. I don't assume that you are pretending to like using a mouse in order to keep up appearances.
Eclipse can be pretty stripped down. I start with the Javascript dev distribution and install pydev on top. It still isn't what you'd call light weight, but it's better than starting with the java dev version. I typically use a syntax highlighting text editor for small stuff, but pydev had the right balance for bigger projects. 
What kind of machine are you running PyCharm on? I use PyCharm on a large project and it has not given me any troubles. Perhaps you are just in need of a fresh machine, to get the speed you are after? I doubt that you have overlooked that, but if you are running it on a 4 year old Core 2 I could understand why it might seem slow. Also I'd like to assert that you should not be all that concerned with 400 MB of RAM being used. That's like 1/3 of what Firefox uses or maybe 1/2 on a good day. ;)
My experience, having filed a few bugs, is that if you file something clear and reproducible (i.e. something that you as a developer would find useful), then they're quite good at addressing them. If you file a vague "complaint", then yeah, good luck with that, but then, what did you expect? Garbage in, garbage out. Having said that, they've fixed every bug I've reported in the next release, or even next EAP release, so I've got no major issues. Having said that, I'd really kill for better documentation of some of the features.
Along with Pyscripter, I found spyder to be very nice as well.
If you don't have write access to the 'site-packages' directory on your local machine, [virtualenv](http://pypi.python.org/pypi/virtualenv) is the way to go. It creates a wrapper environment for you, allowing you to install python packages directly to that environment, without disturbing the system as a whole. You may need write privileges to install virtualenv and pip, however. Once you have virtualenv installed: `bash$ virtualenv pyglet_venv` `bash$ source pyglet_venv/bin/activate` `(pyglet_venv)bash$ pip install pyglet` `(pyglet_venv)bash$ pip freeze` `pyglet==1.1.4`
Really, that's crazy talk by your managers. Let's suppose that you make a niggardly $50K, and it costs the organization an extra $25K to put your butt in a seat in front of a machine (rent, networks expenses, etc), and let's suppose that your development machines are amortized over three years, all very conservative assumptions. Then it's worth $75,000 * 1% * 3 = $2250 to buy any enhancement to your machine that makes you 1% more efficient as a worker. If you work 50 hours a week, a 1% improvement is 30 minutes a week... and that's ignoring the incalculable cost of "losing your flow". Whenever I've been involved in the money, we get fewer, smarter developers and spend as much money as we can on their development machines and getting obstacles out of their way. My general target is "a development machine that would have been absolutely top-of-the-line last year" - because you save a lot of money being one step behind the bleeding edge and you don't really gain too much with that last step.
Then use emacs FFS! Emacs is blazingly fast, has a great integrated Python debugger, a "Python command line mode" and does all the syntax stuff you need.
I can't believe geany wasn't mentioned: http://geany.org/ Cross platform, open source, light weight yet highly configurable. very python friendly. It's like an Text Editor and IDE had a baby. Give it a try.
Strongly consider training yourself out of this, then. I've written hundreds of thousands, perhaps over a million lines of code in my life. My preferred editor is emacs (though if I were going back to Java I'd probably use either Eclipse or IntelliJ). I'm incredibly fast with it, and I have a huge number of tools right within my editor. I have emacs on my servers, and I can move seamlessly back and forth between editing on the server and editing here. I run multiple terminal sessions within the one emacs instance. AND there are emacsen with a fairly decent GUI on most platforms (I use Aquamacs on OS/X for my primary development...) I assume most if not all of this is true for vi (though I think emacs is better). Given you have shitty hardware _and_ you are intolerant of slow development system, it seems to me that you can either choose a programmer's editor like emacs or vi, or give up.
&gt; Why would I want to work without a mouse? That's just making things deliberately more difficult to work with. emacs handles the mouse perfectly well _and I almost never use it._ In fact, I resent programs that force me to use the mouse. The mouse is _much slower_ than the keyboard. It's also a lot more strain on your hands. Using a mouse is perfectly good for a beginner, don't get me wrong - it's great if you don't know what you're doing and want to pull down the menus and go through them. But when you want to move to that next level, you need to lose the mouse. Don't get me wrong - IDEs definitely have their advantages. In particular, either Eclipse or IntelliJ really give you a competitive advantage for Java - if you have a big machine with a big screen and a lot of memory (but even when I use them, I make heavy use of keyboard accelerators). But if you don't have the monster hardware, or you're doing server-side development, or working on scripting languages like Python or Javascript, so far there's nothing that beats emacs (or probably vi...) My main job is C++ and I write in emacs. Even though the C++ IDEs are pretty decent, and I use them for debugging, I just can't equal the productivity I can get in emacs.
I've been running pycharm for ages and it's quick for me. I'm running it on a 16gb i7 iMac with an ssd tho...not a lot is slow on that. I strongly recommend considering extra ram if that's an option for you. Honestly there isn't anything else that I'm aware of that competes with pycharm for python at the moment.
I beg your forgiveness, I've never run it in power saver mode because my workstation is everything but a light touch on the electricity bill—As I think I stated already, I've used it on a laptop with no problems. Mind you, I think that may have been with an SSD installed.
The same reason you'd use ANY CLI as opposed to a GUI. You can do everything much faster in the latter. There's absolutely no reason to use a bloated IDE unless you have no other choice or unless you're working in some kind of GUI framework or something awful like .NET. There's a reason at every job I've had as an engineer (senior software, here) has never entertained the idea of even suggesting engineers use an IDE. Every engineer I've met worth a shit uses the best tools at their disposal. Not one of them, ever suggested a part of that toolset was an IDE. Most people I've met who use an IDE either don't understand the tools at their disposal, have no Unix experience, or are simply just starting out in their careers. Take some time to learn about either one. It'll likely serve you well professionally at some point.
[Sublime Text 2](http://www.sublimetext.com/2)
not much because I am copying the same code for many other suffixes (ness, ed, s, ful, etc) I think I just have to manually code exceptions for each :/
Intro to, and I'm not very good at it haha but your rule worked perfectly and saved me from programming seperate functions for m's, n's, p's etc so thanks so much! If you have time could you elaborate on "generate functions for each suffix"? (also never heard of porter stemming algorithm) EDIT: you werent the same guy as OP but thanks for any help anyway!
Well, you could use one function for all those independent functions (or generate those functions instead of writing them out). A single function that describes what you've got here is something like "for a word ending with stem from list of stems trim stem from word". I'm afraid if I say any more I'll be doing your homework for you, lol.
Don't understand all the downvotes. I think it's a just question. To me, a good IDE has it all build-in out of the box and a lot of small GUI helpers for uncommon tasks. It has a lot to do with convinience rather than being able to get the job done. What impressed me quite a lot was the abilitly of PyCharm to work with databases (SQL console with completion). Then you get the file structure of all kind of files (e.g. xml), sanity checks for all kind of files. All build-in, where you would need to search/install/configure vim/emacs.
So buy a modern computer and continue using the tools you know that suit your needs
Wouldn't it be better to use properties in your password example? 
Give [IdleX](http://idlex.sourceforge.net) a try. It has a lot of methods for running code in a shell. You can highlight code and press F9, or use SubCodes and press Ctrl+Enter to run any code in between ## comments.
&gt; The jetbrains devs absolutely suck at customer interaction. I wouldn't go that far. I had my frustrations, too. But they were/are all with bugs the PyCharm guys couldn't really reproduces. On other occasion it was not outstanding, but OK.
False. It's like the OP asking for a brand of chainsaw and Reddit suggesting to buy a hatchet. Your opinion of IDEs is irrelevant, the OP is specifically not asking for what the community keeps suggesting.
I saw you're using ArchLinux. Have you tried another distro or W7? Maybe it's a Java-related issue (as yole pointed out)?
IDEs integrate the ability to run and debug code along with text editing. Some offer tools like code completion and other kinds of analysis.
...he says to a bunch of Python developers
Debian is my favorite IDE.
&gt; aReallyCoolFunction Why not follow PEP8? Conventions in Python are very important when the code base grows and &gt; 1 dev are working on it.
I use eclipse+pydev day-in-day-out for working in Python professionally. Other than a couple hiccups now and again it runs very quickly if you have enough RAM (and if you don't, buy some... it is cheap). I love emacs but it doesn't scale for larger projects. There is a reason IDEs exist and for python I prefer eclipse+pydev. I have a license for pycharm but it never really seemed to offer a compelling advantage over eclipse and didn't work well for my workload (several projects at a time and c/c++ projects as well).
Haiku would be a better example than BeOS. BeOS isn't under active development, and neither is vi. Yes, I'm just being facetious. Carry on.
Just curious, but are you running PyCharm atop OpenJDK? If so, you might want to try switching to Oracle's Java distro before ditching PyCharm altogether; all Jetbrains IDEs tend to run better on Oracle's Java.
sounds like emacs, vim, and sublime then. :-)
I'm a huge fan of Spyder
Check a dictionary to see if the result is a real word. If not, try adding a 'y' or removing a letter and test again.
Vim's integrated debugger is fantastic. I especially like the part where it lets you hot-swap code while it's running.
This is where I'd start. Depending on the constraints of the assignment, you might be able to do something more clever once that's working. However, without more information on what you're trying to do, it sounds like a rather painful assignment without an elegant solution (assuming, for a moment, that the intended solution doesn't involve dictionaries). Programming classes should not assign problems with meaningless extra brute-force exception catching, at least, not when catching the outliers teaches you nothing about the system or a concept. That's my opinion, anyways.
Emacs with pymacs and rope has all the features you've asked for and more – intelligent code completion, git and mercurial integration, refactoring, integrated debugging. It's frankly a better "IDE" for Python than anything else out there. Now you're free to ask a stupid question, i.e. "what Python editor should I use, *except for* this particular one which would suit my needs extremely well just cause I said so"... but don't get short with people for calling you out on it, when you've failed to provide a reasonable explanation for why you're prematurely rejecting the best answer to your own question.
That's also true. However, I haven't really seen much in Python that would necessitate use of an IDE. * Code completion isn't as critical in Python other than function names and class names (which are not exceptionally difficult). I use Vim's built in omnicomplete and the pythoncomplete plugin to get good completion in seconds. Plugins like SuperTab show the completions when your press Tab or plugins like AutoComplPop automatically shows completions if they are available. * Bicycle repairman is pretty damn good at automated refactoring and can be used through the command line or through Vim or Emacs. * Unlike Java, C, and friends, Python doesn't need to be built and linked to run each time. You just run the main python script in the project. * Tests can be run through an IDE or through the command line or through Vim/Emacs without an issue. Test runners are plentiful. * Both Vim and Emacs can be wired up to automatically show function and class documentation painlessly (mine automatically shows up in a small buffer above my code in Vim). * The Pyflakes plugin for Vim shows syntax errors as you type like Eclipse does. * Both Vim and Emacs have incredibly good Git integration (fugitive.vim for Vim or Magit for Emacs). Other version control systems like SVN and Hg are also well supported. With some IDE's, you are forced to use another graphical tool. IDE's are helpful when you have a large project with multiple build and linking steps or to reformat code or refactor large complex code, which doesn't happen very often. IDE's are also helpful if you want to build for different build targets and debug remotely (neither of which happen often because Python is widely used for embedded systems code) and also if you want to create a project from a template (which doesn't seem to happen very often in Python either). Also, lots of Python development happens inside virtualenvs and it can be a huge pain to get an IDE to play nicely with a virtualenv. If you aren't developing inside a virtualenv, you're making it much harder on yourself. The real use cases I can think of would be if you want a browser or something to automatically update as you change your code or something. While this can be done in an advanced text editor like Vim or Emacs, it requires a little more work. Honestly, the best choice in my opinion for an IDE for Python would be Eclipse and Pydev (which many have mentioned but the OP has ignored). It's got a nice Git plugin, project support, refactoring (not great), and a whole host of features and plugins. Configuring Eclipse is a pain though and doing something simple like changing the color scheme (a pretty basic text editor requirement) requires installing a plugin. The Eclipse config window has lots of redundant and confusing panes, but once you have it set up right, it can be really, really nice. I've never had an issue with speed or memory from Eclipse on my machine (Dual Core 2.0 GHz and 2GB RAM), but I understand that many have speed or memory issues. Honestly, the main thing I do when coding or maintaining code is edit and write text. That is something that Vim and Emacs are exceedingly good at and modern IDEs still suck at that and have to rely on pretty poor Vim and Emacs plugins to regain some of that text editing speed.
That's exactly why he recommended Sublime.
This is nonsense in my opinion. Shortcuts are great, but so is being able to select and drag text with the mouse
A whole bunch of people are recommending Eclipse + PyDev and he hasn't even commented on it or said he tried it out. It really sounds like he is just flaming. We suggest IDEs and some advanced text editors (we're not suggesting Notepad or anything). All he does is comment a few times about how he hates Vim and Emacs and that the require more work to do the same thing as clicking (which is the exact opposite). He says text editors are hard to configure even though IDEs suffer from the exact same issue.He says he wants to click things rather than type, despite typing being a fairly major part of *writing* code. And he is strangely silent and provides next to no feedback on the IDEs that we suggest other than they are slow on his slow hardware without explaining his setup. I have yet to hear any of his serious, specific feedback on an of the IDEs we suggested. The community recommends advanced text editors because *that is what we use*. It's like walking up to a bunch of guitar players and asking what types of drums they'd recommend. We can attempt to recommend some stuff, but the majority of the commenters on this thread don't use an IDE. Anything we recommend is met with silence. It's up to the OP to respond.
upvote for aptana, I really like it as well.
"World Plone day"? FFS
Have a look at the Porter stemmer for some ideas: http://tartarus.org/~martin/PorterStemmer/
pydev is quite fast , and i think it can be tweaked to work faster (add more memory to the java vm , gc collector tricks )
If you never felt like you need one and never used one you probably don't need one. If you need an IDE you'll know. But with that said I encourage you to try it if you work with anything more than 3-4 files. For one file scripts, etc... a simple editor is fine. IDE indexes your whole project, gives you smart auto-completion based on your code in other files, gives you immediate access to documentation, gives you code refactoring features, version control features, shows you a tree structure of the file (list of classses their attributes, methods, etc...) lots of stuff... When your project is sufficiently large not using an IDE is simply not an option.
perhaps I was a little harsh. I was writing from my phone and probably should have offered more details and less absolutes. also my interactions aren't with the PyCharm guys, but PHPStorm/IntelliJ
I explained a specifically subjective standpoint. You have called it "False." In reality you just disagree with that standpoint. So you added absolutely nothing but "Nuh uh".
&gt; get to where its going You've got the preconceived notion that you're going to change the OP's mind. Instead of providing useful information to suit his/her existing workflow and mental model, you're providing unwanted distractions.
You know that not every single "best" answer to any given question is necessarily one that the asker is happy hearing, so now you're just quibbling over which questions are allowed to have less than paletable answers and which aren't, which I hope you can agree is an unwanted distraction.
NTLK isn't the only tool for the job. There are several other stemmers for English that have been implemented in Python. And, not to be condescending, but if you google it, you will find more.
I'm very glad with Komodo IDE
Have you looked at PyCharm? 
Here is the [python source code](http://tartarus.org/%7Emartin/PorterStemmer/python.txt)
Thanks. I did read through the python documentation on repr(), but it made almost no sense to me. :[
funny to see how all the vim related comments have been downvoted. Have a down vote and use emacs of vim like all the other users out there.
Also, check out /r/learnpython :-)
I kinda like Geany. Used it for quite a while. But now I've switched to Sublime Text 2. 
Thanks. The solution you gave there is pretty similar to what I originally had, I was just trying different ways of achieving it. So, if I understand this correctly, the only downside to using %r is that it may mess with my formatting? Cheers
+1 one this, - am on a mac mini with 8gb ram and ubuntu, it seems alright.
&gt; and it often spikes the CPU (both cores) to 100% This should be reported to Jetbrains, it's not normal at all. The only moment I can see that behavior on my copy (2.5 final on OSX) is when it needs to reindex a complete project. *Unless* it's "forced" into this by frequent GCs due to memory constraints, this is definitely the major issue for PyCharm (and java-based IDEs in general). My PyCharm is currently sitting quite happily at 730MB private, which I don't mind too much for I have 8GB RAM for that kind of purposes.
A concept applies to this whole conversation, first of all, whatever works for you. If you feel you are happy and *efficient* with a couple of plugins sure it's not a rule to have to use an IDE. I personally don't like Aptana and Eclipse. I use PyCharm on a fast system and it works well. It's certainly not as snappy as notepad++ but the extra features are worth more than the speed for me. Even if you separate your stuff in modules your project is still big, I mean you can't say a project is small because it has 20 small files than one big file, it's still the same project. IDE gives you navigation and connectivity (e.g. code completion) in your project and between modules. Also a big feature of IDE is debugger. I absolutely cannot live without a decent debugger in my IDE. If I don't use a debugger chances are I'll be fired in a matter of weeks. If you can just try a decent IDE, be patient with it for a little while just to get past the learning curve and see if it makes you more efficient and happier.
It basically means literal representation of x. repr(Exception) -&gt; &lt;type 'exceptions.Exception'&gt; repr(4) -&gt; '4' repr("hello") -&gt; 'hello' repr([1,2,3,4]) -&gt; [1,2,3,4] And so on. When formatting *%r* stands for the representation of x. So now go and format some strings with *%r*. print "HerpdyDerp = %r" % 100.34 print "Derpydoo = %r " % "Hello World!" print "DoopyHurrr = %r, %d" % ( Exception, 1337 ) Do you understand now?
mind sharing the rest of your vim setup? 
there is a reason that people use vim, it's not like they are trolling and suggesting nano/pico or notepad. Search for vim + janus and you'll find a great vim distribution for ruby, works great with python as well, lots of awesome tools in there.
Invalid/WontFix :)
Yes! Thanks!
Emacs does all that.
But that's where you're wrong. Vim *is* an IDE.
Look around the thread; the background tasks—which are *all* based primairily on Disk IO—are typically what make IDE's special. I suggested turning those background tasks off, and a developer of PyCharm stated that if you do, you may as well use Vim.
How about VIM? Sorry couldn't resist! Personally PyDev on Eclipse is a great way to get into Python. 
&gt; It's a great way of creating a gateway to other filesystems. [It is also utterly awful](http://mywiki.wooledge.org/FtpMustDie)
It wasn't a waste of my time until you brought it to my attention! :)
I felt that way for a long time, until I started using PyCharm. Different run configurations and debugging are handy, autocomplete and go-to-definition is great, and the Extract Method refactoring is amazing.
Glad you're liking it! Are you on Mac or PC?
Thank you. I'll certainly look into that one too! Mucho appreciated. 
I'm familiar with memcached. I would still run into the same problem of intelligently retrieving single row vs. many rows on the fly depending on the request. The actual data caching part is trivial, whether it's local or network cache. My main reason to implement a cache is to avoid network traffic to the database altogether, as well as saving some cycles on the DB server. Or, if the DB is unreachable for a moment, we may still be able to serve some requests.
Hmmm...I can only say that I don't find it insanely anything but great and it is getting better with every release. I have filed bugs and I have chatted with the developers and they have always been responsive. I don't use Wing IDE because it needs X11 on the Mac. No thanks.
I'm on Ubuntu Linux at work, and Mac OS X at home. I've been coding in Python about a year (did Java for 8 years before that), but haven't really assimilated all nuances of the coding style (PEP 8) yet, so using SublimeLinter will help me a lot in this regard. And you?
Color coded [trove classifiers](http://pypi.python.org/pypi?%3Aaction=list_classifiers). Hover over the colors to see the classifier name. Click on the classifiers link to get a better view of them.
Before I answer your question, I'll state that I'm not really a Python developer. Part of PEP8 calls for not making code longer than 80 characters. You can can go to View&gt; Ruler and set it to "80". You can also enable wrapping so when you're coding and hit 80 chars wide it drops to a new line. Some people consider this outdated but I still follow it even though I'm not doing python (PHP/JS is all I do in ST2). I also follow this when doing Ruby/Rails/CoffeeScript at home in MacVim, I feel it keeps things readable. To answer your question, I always had an interest in programming from about 7th grade but once I reached high school and started considering attending a university with a CS program I saw there's quite a bit of math involved. I'm not a fan of math by any means, we don't see eye to eye, I'm great until you start mixing the alphabet in with some numbers. Anyway I ended up attending a technical school and learning PC Networking and repair (no trigonometry required to replace a hard drive, graduated around 2004). As I worked in a professional setting I interacted more with some of the web developers at a few places and started following some developers on twitter, the interest never left. It became clear that I wouldn't need to be Einstein to do web app development so I started learning on my own. I started by taking a free instructor led course on http://p2pu.org that covered developing Webservices in Python with WebOb and Paste. It was taught by Jeff Hammel from Mozilla (works on Firefox test group). This course was in October 2010. I enjoyed python and started messing with Django. I found all of the peripheral technologies overwhelming and was pretty confused as to what each thing might do and in what situation you might turn to a specific piece of middleware or product. Things like supervisord, celery, south, SQLAlchemy, and Fabric were all things that I felt like I'd need to know if I wanted to have a chance and being a decent Python web guy. In February I took another P2PU course that covered beginning Rails development taught by [Andy Lindeman](http://alindeman.github.com/) of [Highgroove Studios](http://highgroove.com/). To my new brain Rails seemed to be "batteries included". I wouldn't need South to manage migrations at least, nor would I would I have to worry about SQLAlchemy versus some other ORM (ActiveRecord works fine for most things). I've done quite a bit of contributing to open source including Rails and Ruby core. I've started slowly working on Python again as time allows me to. I feel like I have a _much_ stronger grasp on what goes in to building a good app and so I think all the peripheral knowledge that comes with Python won't be so overwhelming to me. Rails also has a ton of related tech so I'm not playing it off like one is more simple than the other, I just seemed to "get" rails better as a beginner than I did Django. Looking back, I think the real issue was trying to jump into Django first instead of starting off with something like Pylons/CherryPy and getting my feet wet. Rails isn't the ideal framework to start learning Ruby with either, I'd leave that to Sinatra. So with all that in mind, there was a job opening in November of 2011 where I was already working, for a PHP developer on the Zend framework. I got hired and started in mid December so it's what I do for a day job (along with ExtJS4 for this recent project) but I do freelance on the side for both Rails and PHP now. I'm where I'm at now thanks to Open Source so it's something that I feel very strongly about regardless of the language. Chris Wanstrath (defunkt) of Github [has a gist](https://gist.github.com/6443) of the talk he gave at RubyHoedown2008. The whole thing is great but the relevant bits start around line #206 where he talks about how he is where he is because of open source. Sorry for the long reply but there's a lot of background I wanted to lay down.
I think I'd rather use meliae, because it profiles the whole unmodified program rather than making you decorate functions. But memory_profiler probably has its uses.
TIL PyFilesystem can serve any of it's supported filesystem types over FTP, SFTP, and XMLRPC.
When it’s ready, KDevelop’s plugin for Python might be good.
actually, he said why he disagreed with it and you are just nitpicking the way he said it.
Really cool, thanks for posting!
first of all I don't like putting "}" inside a box
I will check this library out! Thanks!
so brave? *sorry. my first time making this comment, but it seemed so appropriate.*
do other JVM-based IDEs have the same problem for you? i.e. eclipse?
actually you are technically correct. you were saying to most of you, "it is like" and then bastawhiz was sayng "no it is like this". and then you were all like "well yeah but i was just saying that is what it felt like" and i was all like "YOU ARE FUCKING WRONG YOU MORON" and then you were all like "False. I'm Dwight" and i was all like "WHAT THE FUCK IS THIS IDIOT TALKING ABOUT I BETTER GO RE-READ EVERYTHING." whoops. i get what you are saying now. so bastawhiz should have just told you how you should feel. then you should have felt that way. 
intellij/pycharm is programmed in java, yes.
The best mirror https://crate.io/ :)
Well, I'm lost. But I do agree with you, because you are megaman.
I think this is an excellent idea. Already, slicing is applied to a wide variety of types. List slices are lists, string slices are strings, bytes slices are bytes. So I don't see why we can't have iterator slices that return iterators. Slicing features that don't work with generators, such as indexing from the right, should cause an Exception to be thrown.
that joke always makes me [hungry](http://www.monzy.com/intro/killdashnine_lyrics.html).
What kind of objects can these tables store?
False. You are incorrect.
Thank you.
I tried that. It looks great and all, but I actually found it buggy - most notably IntelliSense not working properly. Does it work for you?
Thanks A LOT! This actually solved most of my problems. I turned off all the plugins! I also enabled the "Power Saving Mode" and now it works great!
&gt; I'm deliberately trying to make the OP aware of the alternative. The OP already knew about the alternative, as he said in his original post: &gt; Note: I need an IDE, text editors are out of the questions.
Well the IDRE joke was just dumb, but this one I rather like.
You can find my Vim setup on my Github [dotfiles repo](http://github.com/techwizrd/dotfiles). I am still working on fixing it up as I have switched from using Pathogen for automatically managing Vim plugins to Vundle. I try to keep everything well organized and very well commented so that it's easy for me to keep understand later.
Could you link me to this rant, it sounds hilarious.
PyCharm is meant for quad core+ with SSD IMHO. Your computer is insanely slow for what you are expecting from it. You can drop the SSD, but the backend services of the ide, like the indexer seem to be very threaded and will max out all cores... which is great! I use PHPStorm and PyCharm on a Q6600 w/8GB and SSD under CentOS and have no speed issues This is now a *5* year old computer, except the SSD upgrade. I use vim on my E-350.
Don't show yourself out; show the racist joke out. Having a problem manoeuvring the english language =/= complete lack of competence.
Alarmist statement is alarmist.
It *is* pretty racist and only serves to alienate East Asian members of the Python community.
Ouch, that's a really convoluted data-structure. def setval(dic, lst, value): for item in lst: dic = dic[item] dic['val'] = value
ingolemo's is definitely what you want to use if you want it to be readable. You can also do it with `reduce()` but I think this is too cute for its own good: &gt;&gt;&gt; first = {"second":{"third":{"fourth":{"val":6}}}} &gt;&gt;&gt; path = ["second", "third", "fourth"] &gt;&gt;&gt; reduce(lambda d, k: d[k], path, first)['val'] = 42 &gt;&gt;&gt; first {'second': {'third': {'fourth': {'val': 42}}}}
I lost you at "BUT! I have a list that leads to "val":" don't understand
I know, but i want something to code! is it possible or not?
Yep, it was that one.
Thanks a lot!
If I was typing in a foreign language, you could be damn sure I'd check my spelling VERY closely before filing a ticket. I'm not saying that he has just simply misspelled it, but when you're dealing with a programming language - the fact that he's not a native English speaker is a lot less of an issue.
No. Eclipse, while slow, is not as slow as PyCharm. 
This is not acceptable. Shame on you for posting it, and shame on the fact that this has almost twice as many upvotes. Next time just show yourself out.
request and beautifulsoup are much superior to urllib and HTMLParser. To get a program to run daily, there's cron jobs for linux and the built in Scheduled Tasks for windows. Both super easy to use. The image always have the alt attribute "Cyanide and Happiness, a daily webcomic". It's not that hard.
Probably the biggest reason is breaking the common "x[:]" idiom for copying a list. In general it doesn't seem like this would come up a whole lot.
Whatever, I'm Japanese. Just poking fun at myself.
Yeah, the key thing to understand here is that OSX won't let you add just anything to the launch bar and .app are the easiest thing to add and have run when clicked.
IMO, simplicity is best, especially since there is no standard structure of a case. You assume a single line per case, but GCJ has had stuff like [Problem D in the most recent qualification round](http://code.google.com/codejam/contest/1460488/dashboard#s=p3). My "template" is [here](https://gist.github.com/2495148), but even so I find myself just tapping out a file from scratch every time. It's too easy anyways.
Cool. Poke fun at **yourself** and leave others out of your 'jokes.'
You're not poking fun at yourself (since you're not involved...), and you know that.
Nice slides.
Solved problem; or it will be in about five seconds. SPOILER ALERT! import urllib htmlcontent = urllib.urlopen('http://explosm.net/comics').read() print 'Got the comic page' imgurl = htmlcontent.split('&lt;img alt="Cyanide and Happiness, a daily webcomic" src="')[1].split('"')[0] imgname = imgurl.split('/')[-1] imgcontent = urllib.urlopen(imgurl).read() print 'Got the comic image' open(imgname, 'w').write(imgcontent) Suggestion: Put it in a function, make it a module.
HTML parsing? Pfah, I have the native `split` function for this sort of thing! imgurl = htmlcontent.split('&lt;img alt="Cyanide and Happiness, a daily webcomic" src="')[1].split('"')[0]
I don't know that term, sorry.
I like your thinking with urllib, but using HTMLParser to get *one* string of text that's easily identifiable by the surrounding text? That's overkill. imgurl = htmlcontent.split('&lt;img alt="Cyanide and Happiness, a daily webcomic" src="')[1].split('"')[0]
I shouldn't have to add "don't be an asshole, be accepting of people of all races, creeds, colors, types, etc". Thankfully you've never posted this crap here before so it hasn't been necessary, but it will go in the header of the page if it becomes necessary. Plus, do you really have to be told what not to do? This is a subreddit about Python. It's not /b/.
Are you even Asian? Or are you just offended by proxy? You're out of your element, Donny.
May I ask how you know that the person in question didn't triple-check his assumptions? It seems like a pretty big assumption on your part to assert that. That was a pitiful error report, I agree, but it's also within the expected bounds of quality I expect from a n0ob in a panic. And look. I can quote something too. From the same article, even. &gt; The definition of racism is controversial both because there is little scholarly agreement about what the word "race" means, and because there is also little agreement about what does and doesn't constitute discrimination. Some definitions would have it that any assumption that a person's behavior would be influenced by their racial categorization is racist, regardless of how seemingly benign such assumptions might be. Other definitions would only include conscious malignant forms of discrimination. Racism is a really broad subject and there are terabytes of posts and discussions about the phenomenon from the perspective of both people of colour and allies. Look them up.
While I don't know that he didn't, I certainly do know that he didn't bother to check his spelling or grammar. While I agree that doesn't prove anything, it puts into doubt the level of care he took in his own programming.
No, I'm not dense. I'm interested in making Python and open source a more diverse place, welcoming of people of all kinds. Whether you are a Japanese person or not, jokes like this are just steps backward. It's as simple as that. Think about more than yourself and comedy routine. Imagine a first time bug reporter coming in and reading your comment. They probably think this community is more like a gym locker room, not an environment where they can contribute and learn.
It's a Big Lebowski joke, the first good post they've made in here.
Not really...? His writing is a bit annoying to read, but it doesn't cast any aspersions on anything else. This doubt you cite is really more an example of *ad hominem*
I only ask because when you comment in green, you comment as a mod.
Thank you //_^
I never said it was. You don't seem to get it so I've been busy responding to you.
I disagree. Programming and typing are essentially identical activities with regards to accuracy.
"I never said it was." - I never said "Engrish" was acceptable. "You don't seem to get it" - You don't seem to be comprehending why your comment is not an acceptable response in this community. "so I've been busy responding to you." - I've gone back and forth with you for the last while on this, so I haven't responded to that person. However, I'll probably stop reading this thread soon because it's not worth my time.
I tried something like that, but instead of just setting the variable it returned the dictionary - so I think I'll try that. EDIT: I don't think it works. EDIT2: Nevermind, it does.
Like a path to a file, but more like a path to a value.
&gt; stop reading this thread soon because it's not worth my time We agree on something, then.
Prgrammng is 100% srs bsns! /s
For the last example, why not inject the `spreadsheet` dependency, and have the generator make the `get_cell` call? In a more practical example, the unfortunately Java-like `Spreadsheet` API presumably also exposes `get_width` and `get_height`, and it makes sense to me to do all of that work in one place and expose a more Pythonic interface. (Those more heretically minded might even consider monkey-patching `Spreadsheet.__iter__` and `Spreadsheet.next`, assuming implementation details don't prevent it.)
there were too many good spots to ask
if you don't know, I'm not going to tell you
Here you go * [Vim as a Python IDE](http://blog.dispatched.ch/2009/05/24/vim-as-python-ide/) * [Python and Vim: Make your own IDE](http://dancingpenguinsoflight.com/2009/02/python-and-vim-make-your-own-ide/) * [Turning Vim into a modern python IDE](http://sontek.net/turning-vim-into-a-modern-python-ide) * [;)](http://lmgtfy.com/?q=vim+python)
I can tell you why I'm not using vim. It's the same reason I still can't typewrite properly. I just didn't felt the strain and pain to learn it. It's like cleaning up. I do it when it really needs to be done. I'm just lazy, it would save me trouble to do things on time and to organise myself, I know ... ;-) So, I don't use vim, but I'm 100 % convinced (I saw it with collegues) that in an *nix environemt there's nothing faster then to work with 'key-stroke-only' tools. You need to invest by learning all the shortcuts, then you'll be rewarded. On the other hand, nice IDEs serve you with their GUI and pre-build integration. You can discover things more easily. To pimp your vim, I'm aware of this: http://sontek.net/turning-vim-into-a-modern-python-ide But I've never experienced the tool to be the bottleneck in developing code. Desing is the by far most important aspect. So, the whole tool discussions are highly overrated. 
Saving for later by replying. Am on phone.
can you try making a blank somefile.py and opening it in PyCharm without creating a new project? that is to say- just opening it from the main screen, having closed any project(s) you have open do you still have the whole keyboard-lag?
I have no idea why this isn't getting more attention. I think it's awesome. For instance, I have a little python project sitting on there that I can play with from *anywhere*. Sitting at work at lunchtime, kid's computer, mother-in-law's house, wherever, I can log into this system, get on the console, and vi my way to code nirvana. Don't want to use vi? You can also map folders to Dropbox, edit them on your local box using the Dropbox directory, and have them automagically show up in the resulting web app (where the Dropbox folder on PythonAnywhere has been included in the web app path so you can store modules there.) In other words, it's really remarkably useful. Even at the free level. It's the closest thing to a free virtual computer in the cloud that I'm aware of. Oh, and did I mention it runs my bottle.py apps, no problem... [ No, I don't know the people doing this, other than through their excellent support emails -- I just want them to get props for a really nice effort that I hope to continue to use... ] 
Personally I prefer emacs for extended coding sessions, and vim for quick edits... that said: IMO, the advantage of emacs/vim over something like pycharm is the level of customization available to you. Both are not unlike a framework designed specifically for building fully fledged IDE's. Out of the box they don't look like they do much, but once you become proficient at putting things together, you realize there's really nothing that provides the same level of tweakability as they do. 
you can start from here: https://github.com/onjin/vim-startup and then change it for your preferences
Well to be fair, you can do at least rudimentary mouse navigation in vim too. :set mouse=a gives you scrolling, highlighting etc. If you use something like gvim, you get file menus and the like as well.
I am curious - what mouse based functionality does an editor like sublime have that gvim doesn't? Gvim supports menus, popupmenus, selecting text through clicking or dragging etc, and it is all configurable. It also has a toolbar of icons to perform common actions, although I turn it off since for me it just wastes screen real-estate. Even the console version of vim has mouse support, although it is usually disabled by default since not all terminals support mouse events.
Emacs, Emacs, Emacs. I've been using PyCharm lately though and I loved it.
I use it as my primary editor for most languages and I love it. Add SublimeLinter and SublimeCodeIntel and you've got yourself a good Python IDE indeed.
This is why they have clones of major services in China instead of the real things. The damn bug reports. 
That's neat :)
I'm using both Sublime and Eclipse. Sublime isn't an IDE, it has autocomplete, but no where as good as a real IDE, the code refactoring features isn't very good, it only provide basic features. That's why it's lightweight. So I think, you should try Sublime for a project, and see how you use it and compare to Eclipse, you may not use Pydev's advanced features, but sometimes you use it without knowing. Personally I used both, Eclipse when I need to code much and Sublime when I need quick editing. Edit: and yes, I have Sublime Package Control 
What can I use if FTP is bad? Serious.
I second this – I use Sublime (previously I used TextMate) for Python and especially Django programming and it works fine for me. That said, I have never made any serious attempt to get work done in Eclipse; last time I tried it just showed me a page of mystery meat with no hints as to how to actually edit files …
My sincere apology! This post is just my random rant.
Ditto, I use sublime on windows, and textmate on mac.
Where were you in my thread... People jumped on me for not using vim.
Aptana is really good, not just for python. Most web dev stuff is really nice with it too.
You don't seem to have permission to create the file there. 13 is the code for EACCESS, which means 'permission denied'. You can get the errno map like this: import errno print errno.errorcodes[13] # prints 'EACCESS'
Show us the actual code and actual error. I'll just put on my psychic debugging hat and say that you're trying to use a path with backslashes in a non-raw string context without escaping them. 
I personally like emacs, it is light weight out of the gate and you can configure it to do all the auto compete stuff as well. But before emacs I was vim guy so I like that too
It's a breath of fresh air in the hey-look-its-courier-new-and-toolbar-buttons Windows environment.
I do, and use SublimeCodeIntel that is very good but has its bugs also.
Your mother.
To be fair, there is no somewhat like Sphinx for Ruby.
I think that's not a fault of Python( or pythonistas). Rubyist just does too perfectly. See other popular languages like Java, C++, PHP or else. Quality of Python documentations aren't inferior than their's one.
"Content is king"
Well, for one, Pythonistas are programmers, so what we do best is program. Rubyists I've met and seen at the events seem to be more about flair, rock-stardom and sounding all-knowing than actual programming. Focusing on the first impression and hoping no notices on the second impression that, eh, I really just need some info out of it, I don't care about it being all pretty.
I've kinda considered Ruby and Python to be left-brain/right-brain implementations of one abstract super-set language for quite some time. I find the Ruby community has an obsession with beauty and design at almost every level, from the source code (DSLs) to console output (colors, unicode checkmarks, etc) to their code documentation which often features some attractive custom mascot. It's because the language supports avenues for this type of expression that people with these focuses are attracted to it. I remember when Rails was first released, the aesthetic of that community was so particular that you could tell when something was a Rails site by how it looked. I was surprised to eventually learn that Rails didn't facilitate this in any way in its toolset; 37s was merely a taste maker, and eventually sites not written in Ruby adopted the aesthetic to the extent that this is no longer true. The Python community has an approach that is much more in line with the languages rigidity (compared with ruby). It's analytic and focused primarily on clarity. I think it's relatively more important in the Python community that people use sane defaults or fall in with the standard orthodoxy, whether it's code (use stdlib when appliccable) or documentation (use sphinx, fullstop). There is a focus on ergonomics, especially in the last couple years, but it's still not quite the same thing as the focus on aesthetics Ruby has. Sometimes I envy that aspect of the Ruby community; not the nice webpages, but that focus. In Ruby, you can write something that merely changes the interface to something else, and if that is enough of an improvement, it will be embraced. This was historically much harder in the python community; for a long time, things like this were greeted with a "What's the point?" reaction. With things like `requests`, hopefully we're adopting some of the good of that culture without taking the bad. As an aside, one of the remarkable things about Django, early on, was how well designed its website was; writing python web stuff at the time was generally a question of using and reading [mod_python documentation](http://www.modpython.org/), which was considerably worse. EDIT: I also wanted to add that it felt, in the early to mid 2000s, that the Python community was more Unix focused. Ruby started to really gain mind-share around the time that macs started to gain popularity among developers. If you grow up with beautiful things, you'll inherit some of that design language through pure osmosis. The old python docs, on the other hand, look like man pages with some blue at the top.
I agree with most of what you stated there. Vim (or emacs) are basically the best text editors in a posix environment. I also agree that design is critical. However, the last thing you want to fight is the tool environment when you're trying to design. It's one of the reasons I vastly prefer python over c/c++: I just don't have to deal with the tools and that piece of setup. It's probably a bit easier if you've already got an established code-base and a working toolset. However, when you're starting from scratch or you're still mostly in hacker mode, the environment is critical.
https is fine. anonymous http is fine. http with basic authentication (passwords sent in the clear as part of the URL) is insecure.
I put the flask example up on google appengine. This being my first appengine deploy I'm hoping it doesn't break spectacularly, but check it out if you're curious. You can try out youtube videos, flickr photos, vimeo and hulu urls as well. http://micawberdemo.appspot.com/
[Mine, using a lot more dependencies...](https://gist.github.com/2500031)
If you're a solo developer, use whatever you like. If you're working in a team, use whatever the team is using. I love vim, but I've used Eclipse+PyDev in a team environment where the rest of the team were doing Java work in Eclipse because we could all share the same editor, plugins, code repository, etc. and I didn't have to waste work time explaining my editor choice when peer reviewing code. Whatever you do choose, learn it well. If you're going to be spending incredible amounts of time typing text into a computer, you should master your text editor (or, at least, get very intimate with it). Most IDEs use the Microsoftish keybindings for editing, which gives you just shift to select text (or ctrl-a for all), cut, copy, paste, backspace, delete and single-char movement with the arrow keys. More powerful editors like Vim give you significantly more features that will cut down your editing time, but you have to learn them (e.g. movement and selection by word, line, and other regions; mark points; multiple cut buffers; macros; repetitions; easily extended in one or more scripting languages; etc.). PyCharm is one of the best Python IDEs, if its more familiar to you and your environment don't give up on it lightly because some random internet extremist wants to call editor jihad in every thread because you dare not conform to their personal preference. 
i'll add tooltips and dragging/rearranging tabs.
I get this: &gt; python2.7 -mhgdistver Traceback (most recent call last): File "/usr/lib/python2.7/runpy.py", line 162, in _run_module_as_main "__main__", fname, loader, pkg_name) File "/usr/lib/python2.7/runpy.py", line 72, in _run_code exec code in run_globals File "/usr/local/lib/python2.7/dist-packages/hgdistver.py", line 318, in &lt;module&gt; print('Guessed Version %s' % (get_version(),)) File "/usr/local/lib/python2.7/dist-packages/hgdistver.py", line 263, in get_version version = method(root=root, cachefile=cachefile) File "/usr/local/lib/python2.7/dist-packages/hgdistver.py", line 195, in version_from_git tag, number, node = out.split('-') ValueError: need more than 2 values to unpack &gt; git describe fatal: No names found, cannot describe anything. 
today I've installed sublime txt 2. Starting a small python project. Began - obviously - with imports. from PyQt4.QtCore import [ctrl-space]... nothing happens. Now, is that a nomal behavior that there is no module auto-completion and I can uninstall this already, or I have something misconfigured?
I love sublime text! First new ide to take me away from good old vim/notepad ++ in almost 10 years.
ok, i made sense of it, your git somehow ignores/doesn't support describe --always i just commited a workaround, and will need to work some more on git support
The only think that prevents me from switching from Apatana Studio is that I can't open a file more than once. I often want to look at a file on one pane, and edit it at a different position on another. That doesn't seem possible in Sublime. Correct me if it is!
Opening folders and sub folders is one of the big sells for Sublime Text for me, as crazy as it sounds. Why is this so hard for every other text editor and IDE!?
Noob question: how does Sublime work with python? I've been using notepad++ for creating python files. After saving the file ---&gt;cygwin---&gt;execfile('filename.py')---&gt; run the functions. Does Sublime work similarly to above? I've recently started the cs101 course on udacity which is in python. I would like to know if there is any way to write and run python programs more easily. 
I've used both Sublime and Vim for a while and I can honestly say I prefer Vim. Sublime may be prettier, but Vim's text editing capabilities shoot Sublime out of water. Sublime actually added a Vi-like mode, but it's missing some of the more powerful features of Vim and it just feels strange. So, I prefer Vim. The only feature I really wish Vim had that Sublime has is the pane on the right showing where you are in the document.
I did try Sublime. To me the appeal of a straight text editor is that you aren't using one thing for quick edits (say, /etc files) and another for code editing. The idea of one unified text editing environment appeals. But, I actually do use features from PyCharm and/or WingIDE, especially the amazing ZOMG search/replace features both those IDEs have. And the interactive debugging is critical. I think if you write your own code from scratch, you can be perfectly happy with something like Sublime. For me the problem is that when you're working on a big codebase, you need more code intelligence and discovery features to be productive.
If the massive codebase you didn't write isn't well documented, how much can an IDE compensate for that? (I'm curious)
... Not sure if sarcastic or not, but Sublime Text is not an IDE. It's a text editor (gasp!).
damnation, that's some clever shit right there
I'd actually suggest using the [feedparser](http://code.google.com/p/feedparser/) Python library to grab the feed and extract all the URLs from it. Then you can use the Python [Requests](http://docs.python-requests.org/en/latest/index.html) library to download the images. I wrote [something similar](https://github.com/techwizrd/MangaFox-Download-Script) to download mangas from MangaFox, although it actually scrapes all the pages using BeautifulSoup. It's due for a rewrite actually, so I'll probably rewrite it in a couple weeks when my semester is over.
Why are you confused? He said: 1) Don't know Sublime, so can't say I prefer it to Vim. 2) In using Vim, I've encountered no deficiencies that would cause me to invest my time in exploring other editors. Both seem pretty straight forward. Plus, why the downvotes on his post?
I used to use Taglist (although now I use the far nicer Tagbar plugin). However, what I mean was the [code viewport pane](http://i.imgur.com/MZLXz.png?1) on the side.
If it solves your problems better and makes you more efficient and effective, then use it. Editors/IDEs are such a personal thing. We each work differently and internalize an application architecture differently, which is why we prefer different environments and editing styles. If you're looking for comfort in know others use Sublime, cool. I think a more interesting question to ask would be "why do you love your editor". You'll probably see some answers that resonate with how you work and think about your code. For the record, my IDE/editor history is as follows: Emacs (Perl, Java, C), Visual Studio (C on Windows), Emacs (Java), Eclipse (Java, Python), Vim (Python). One thing that always bothered my when working with Eclipse was navigating the code, having to go to the mouse. Emacs has some decent keyboard navigation, but the vim model fits me better.
made my day.. i didn't even know there was a sublime package manager/community 
A lot. And it's even better if it's documented inline, since the IDE will pick up on doc strings. The #1 killer feature, in particular on Wing because it implements it better, is an interactive debug prompt. I can import the debug library on a process I'm running over ssh. When an unhandled exception happens (or breakpoint, whatever), the editor not only lets you see your variables, but you can type interactive Python commands that execute inside the stopped thread. I often find myself prototyping a fix right there while the application is frozen in time. I can do introspection on variables, use auto-complete, and when I'm happy with it, put it in my editor. That's huge. In terms of just code editing, code intelligence is helpful. Hold down ctrl and identifiers become hyperlinks to their definitions. Wondering how some_eggs_method() works? Hit ctrl and click it. If the editor can't figure out the definition of the function because there's no way the identifier came into the scope you're editing, it shows you a list of likely definitions based on name and what's imported overall. Stuff like that really help you navigate an unfamiliar codebase. 
Seriously, fuck Ubuntu. I'm so glad that I ditched it last year, it's all been downhill.
I can do a bunch of these with Sublime, namely printing the doc strings, going to code source, renaming variables (with SublimeRope), running the code via pdb (with SublimeREPL). Basically, I'm wondering if I have much call for anything heavier (the above plugins I run on demand rather than always-on). Probably not, for now, but I'm generally only dealing with my own codebase.
Very nice. The name is deceptive. I thought it did Octopus merges - something that bzr does but mercurial doesnt. I guess git does that already 
i also use sublime text 2, and its great. However, as you said, with other codebases (like open source projects you are trying to fix a bug of), the greatest feature i love about eclipse is the ability to ctrl/command click a variable or a class and it will go to the definition of it, or what file its defined in. Is there anything like this for sublime, or is that getting into the heavyweight pydev ide territory? Its just annoying where I can't find where a class /method is defined and there are a huge amount of files =.
I agree that vim provides superior text editing speed. But IMHO I don't find that to be a large component of my time anyway. Other than that, vim seems to offer many IDE features - if you are willing to put the investment into setting them up. PyCharm has pre packed the features of all those vim plugins, and then some, which make it really useful for a Django dev such as myself: * intellisense for HTML, JS, CSS, django templates * python and JS debugging, linting * integrate into task repositories and task context support * even virtualenv manager &amp; support But even these could be made into vim plugins, or perhaps already are. Perhaps the true benefit of an IDE vs vim-plus-IDE-plugins is that it integrates into one convenient and easier-to-use visual interface? 
True, but the topic implied it.
It's not an IDE ... but as an editor it looks nice. However, a bit expensive.
Let's say: You're on your way to an IDE. If you call sublime an IDE you don't do it a favor. People will be disappointed when starting to look for features real IDEs provide (like Wing, PyCharm, PyDev). 
I don't see the little star next to the timestamp, but I do next to yours (not accusitory). He does have that todo.py thing though. Maybe that's munging things.
That's okay. We're still on Lucid :( 
Setting up Vim plugins is fairly trivial nowadays with plugins like Vundle. If Vim is really almost equivalent with an IDE, it's superior text editing features really make it awesome. Honestly, I would love it if Vim had a nice pretty interface, but the text editing features outweigh everything.
The barrier to entry for using Sublime for Python is ridiculous. Notepad++ was ready for use with Python immediately. Sublime does look nicer, obviously. 
It is in File-&gt;"New view into file", you can open same file more than twice if you need and you can have more than 2 panes. 
Python 3 default on Arch Linux for quite some time. It fucked up some stuff (some deps and packages that weren't updated to use /usr/bin/python2 instead of /usr/bin/python) but they eventually got fixed...but still it was damn annoying for the first 1-2 months.
To clarify what this means: Python 2 will still be available in the repositories, and will still be `/usr/bin/python`. What's changing is that core applications like update manager will run on Python 3, rather than Python 2, and when that's complete, the default installation won't include Python 2. I think the goal is rather ambitious for Quantal: there's [quite a few parts](https://docs.google.com/spreadsheet/ccc?key=0AiT4gOXSkmapdFA1anRkWERsaXgtWnllUG9QWXhDVWc#gid=0) that need porting or packaging. Hopefully at least one application can be ported this time, and the rest will make it for R.
It's okay, you can come back now. I promise we will still be friends :&gt;
Because it crashed PyCharm just as often as it crashed IntelliJ, IME it has always proved unusable
Nope. Made the post and didn't go back. You may have misread it. I'm not on here often enough to bother editing and most of my posts are from reddionic which doesn't have the ability to edit posts.
I don't post here frequently enough and I've only received downvotes for asking a question I knew wouldn't be well received because it was a bad idea. But if people have memories that long and vindictive then I'd be surprised. Maybe it is because I didn't add to the discussion besides making my opinion known. :shrug:
You do know is going to be a headache, oh my twisted!! PS: The internet is small.. ;-)
Thanks! 
If you go file-&gt;Open and select a folder, it opens the folder and shows you a nice tree view down the side of all the files and various folders and you can re-arrange, rename, create new, and organize everything right from there. TextMate requires a project file to manage this and other IDEs handle it in an awkward way or not at all, which seems weird to me for such a simple feature.
I'm not sure what you thought I'd said. But yes. Duckshake. Or is that atillashake?
I can program my text editor to do what I want. Macros, custom keybinds, and tons of magical plugins make my customized world a beautiful one, with only the colours that I like (figuratively and literally). On the negative side, I end up spending a reasonable deal of time maintaining that environment. This is less an issue with plugins like Pathogen, but there is still time spent customizing or learning a new addition. Use what ya like. I happen to like Vim.
You are essentially asking why it doesn't have a feature that is universally recognized to be an IDE feature and not a text editor feature — so you are actually implicitly calling Sublime Text an IDE.
Yea, but that's one of the uglier lines of code that I've seen (not including the HTML). It's fine when confined to a single function or something, but I'd much rather maintain something that uses lxml. Hell, I'd rather use regex.
Well, the regex would largely be the same thing, except it would use a different function. My point is largely that including external libraries is a nasty thing to do for such a simple function :)
these days I tend to write functions that work on iterables instead of lists so I'll stay away from list specific stuff when I can. I sort of get what people are saying though. islice can destroy the input iterator so it's import to make it distinct. It's funny you mention tuple unpacking. The one place I still use slices is when I don't know how much is in a byte array that I'm trying to unpack with struct.unpack. unpack won't let you pass more than you need so you always have to use slices: key, length = unpack("II", input_data[:8]) value = input_data[8:] 
never actually used them but yes, they're mentioned as an available option in the `git merge` man page.
Then great for one release, then changed for the worse for no readily apparent reason, then break more and more on subsequent releases, and finally abandoned and replaced with a new scripting language developed in-house by Canonical.
line 57 lacks a level of indentation? side note: please be good to web servers, add a sleep between GET requests for this sort of program.
Yes, I am running it like that, but I will put that in. Thanks!
Came from using Netbeans (for PHP/HHTML/CSS/JS development) and moved across to Sublime for the speed. I'm now picking up Python and with SublimeCodeIntel and SublimeLinter it's pretty solid for all languages I work with. Can't beat a NATIVE application compared to a bloated Java solution (for speed)
Fair enough, if text editing prowess is more important in your daily work, you may even emulate emacs or vim commands in PyCharm with plugins for that purpose. But I'd rather all my editors' IDE features were native to the editor, designed into the interface, than use a patchwork of features bolted-on. Plus I can be productive when teaming up with a colleague on his workstation. 
And the default Python is going to be 2.7, which is also great news. Transitioning code from 2.7 to 3.x is relatively easy, and many folks writing new code today tend to make it run on both 2.7 and 3.x so a full jump to 3.x in the future will be even easier.
documentation?
How about building a system to make it easy to support any language?
He is doing that. It's going to connect to the language runtimes over a TCP socket. However, quite a bit of work needs to be done in the python plugin side to support the kind of dynamic visualization of data flow he is doing.
This is even worse in IT. "My server is slow. Please fix it. Kthxbai"
Then what about helper methods? Shall we just encapsulate them inside of the methods that they help? I see nothing wrong with prefixing them with an underscore and letting the end user recognize the convention. If they want to play with them, go right ahead, but I'm simplifying the API by not *including* what isn't necessary.
Interesting. This can be seriously useful when it comes to writing web crawlers. 
I've been enjoying your videos, particularly since I found them as I'm going through *Rapid GUI Programming* at the moment. I do have one suggestion, and that's to use the new style slots and signals: self.okButton.clicked.connect(self.accept) as opposed to: self.connect(okButton, SIGNAL("clicked()"), self, SLOT("accept()")) http://www.riverbankcomputing.co.uk/static/Docs/PyQt4/html/new_style_signals_slots.html Link is for PyQt, but applies to PySide as well. I've been translating the examples from the book as I go, and I think that this is a much more pythonic method of handling slots and signals. Thanks again for the videos, I'm hoping that there's more to come.
Why do i need this when i have PEP8?
The unit test aspect could be golden! 
This looks like an IDE that flows like my brain. Make it span a few monitors and I'd never look back.
&gt; Then what about helper methods? Shall we just encapsulate them inside of the methods that they help? I do that. If the helper method only helps one method and the method isn't performance sensitive, I embed the helper methods within that method. Makes refactoring considerable easier. My rule of thumb goes something like this: Put your callees as near to the caller as possible. &gt; I see nothing wrong with prefixing them with an underscore and letting the end user recognize the convention. If they want to play with them, go right ahead, but I'm simplifying the API by not including what isn't necessary. True, but that's not the point. The example used by nerdzrool doesn't lend itself very much to using standardized HTML form classes if you use methods to set the password. Most form classes use attributes to populate the object. If you use a property you can use them and still have only a salted hash stored.
It requires Qt, but none of the demos look like they are using any UI. Can Ghost do this as well or is it requiring some other Qt dependency?
Perhaps the Webkit renderer requires QT?
I have this error so it really needs pyside raise Exception("Ghost.py requires PySide or PyQt") Exception: Ghost.py requires PySide or PyQt On my debian sid server apt-get install python-pyside The following extra packages will be installed: ... many qt packages http://packages.debian.org/sid/python-pyside.qtcore 
Front page of ST2 has (at this moment) has 10 mentions of Auto Complete feature. While it may be one of IDE features, ST2 has it too. 
I can call a individual function directly in IDLE, say some new function that I wrote that I want to test. I haven't been able to figure out how to run an individual function in sublime. If I try to call a function directly from the command line, it doesn't work (I can run a complete python script from the command line, but not just a single function within a script.) I realise there's probably something quite basic that I'm missing, it's more of a display of my lack of experience more than anything. 
Hmm... Seems a bit unclear to me? I think set([]) is not such a bad way of writing it!
It's very hard to find. [I found this](https://github.com/jeanphix/Ghost.py/tree/db2d82b8bba4b9b4bd550422d3079d93277ee319) [I opened an issue](https://github.com/jeanphix/Ghost.py/issues/3) to tell the dev about this problem.
Just set() does fine, too.
The Python interpreter packages will remain the same. This is just a matter of which one some applications use.
Those are also good editors. But lets be honest, they carry like 100 years of accumulated cruft, and esp vim's interaction model is quite specialized (mostly a vim guy myself). But I've gone over to Sublime. It's got sensible defaults, looks visually great out of the box, and the configuration isn't some arcane shit, but done using sensible python and json.
Or `{()}-{()}`!
Actually, you *could* cut a log in half with a hammer - it would just take a serious amount of dedication :)
The [WSGI Apps](http://jeanphix.me/Ghost.py/#wsgi) piece is kind of cool but why does it have to run on a port?. Seems it should be possible to send the request and get the response directly.
I can't believe this doesn't have more attention.
I've been doing something similar as a learning exercise though I'm focusing on the back-end. Since you're looking for things to learn, you might want to switch to MongoDB. You might find it more flexible than SQL for storing game states and the like.
&gt;is it possible or not? This is so far within the realm of possibility! Most any interaction you can think of between your program and a website is possible, given enough work.
I know its not python, but since we're talking about headless webkit browsers phantomjs is also pretty nice (http://phantomjs.org/). It also doesn't require install Qt. The only deps I needed to install were freetype and fontconfig. Runs on linux/mac/windows.
You'd have to define ಠ first, and it would only work in python3. 
the suggesting is really great. I am trying pycharm and also starting off w/ virtualenv for the first time. it really made the transition great. git suggestions, virtualenv support, requirements suggestions etc. very neat.
Useful for evil bots as well. I've been using a simple bit of javascript to thwart spam bots by inserting a known value in to a hidden field on a form. That way the server 'knows' it was done by a browser and not a bot. A bot using 'Ghost' could work around that quite easily. *sigh*
This is nothing new, and is a pretty unfair attack against ghost.py. People have been doing what you describe with Selenium for ages.
It wasn't an attack exactly, more of an observation. It's a cool technology, even if it could be used for evil. I guess spammers haven't discovered Selenium yet. Or if they have, they haven't targeted my sites.
The syntax inconsistency in creating empty sets kinda bugs me :( I wish they had just changed the empty dictionary notation to something like ```{:}```.
Waaay too much backwards-incompatibility, not worth it. Like it or not, curlies were for dicts first.
So it's kinda like making ```print``` a function? :P
heh, fair enough =)
Recently it has been going up at a rate of about $10k per day, so it looks like it will get funded. If that rate holds up then it could get the $300k. We shall see.
Different enough that you can't expect 2.7 code to automatically run on 3.x, but similar enough that if you learn one, it will be easy to pick up the other. For now the advice is: if you want to learn to start a project straight away, learn Python 2 (especially for web projects). If you're learning mainly out of interest, start with Python 3. More and more libraries are supporting Python 3, and you can already do a lot with it.
It's ridiculous to call this Python's "hardest problem". It's an optimization in CPython.
I would agree with that, tbh I do a lot of my development over ssh while I am away from my main computer in spare time etc. Because of this post I decided to check Sublime out for shits and giggles, seems decent and very similar to notepad++ but cross platform which is a HUGE plus as I use windows at work linux at home. (Windows pays the bills, Linux is for thrills). But your point is noted.
no shit? can you provide an example? that makes it even better. i just wish it wasn't java based.
No, because print as a function means that existing code doesn't even import, and you must fix it. Making {} a set would change behaviour to all existing code in a far more subtle way.
&gt;can anyone shed some light? The terminal is not created by your script, nor is it created by the Python interpreter; it's created by the operating system, as a temporary context for the interpreter's process. When your script is done, the interpreter quits, and the terminal closes, as there is no longer any reason for it to be open. To work around this, you can: * Explicitly open a terminal window, and run your script from the command line; or * Create a batch (Windows) or shell (Mac; Linux) file that invokes your program, and then invokes some sort of "press any key to continue" utility program after your program is done (on Windows, this program is called `pause`).
This article is bunk. I can't get why people are *still* going on about this. All of the people that wail about the GIL are screaming about performance. Performance? You need performance, and you're using *Python*? Don't get me wrong. For an interpreted language, Python is fast enough. But, if you have the kinds of workloads where you'll benefit from occupying more CPU cores, then maybe you're using the wrong tool for the job. Python's threading module is fantastic for IO-heavy applications (working with multiple files, sockets, etc). Most IO ops release the GIL in Python, so you actually *do* see a performance improvement. If you have a CPU intensive task, and you MUST use Python, then write a C module! It's not *that* hard, and you can actually take advantage of those extra cores without the overhead associated with multiple processes and IPC. Heck, if you're writing the critical sections of code in C, you may not even need to resort to multithreading... I think that asking why Python doesn't do real multithreading is like asking why moving trucks don't have race-performance suspension. 
an _optimization_? seriously?
&gt;it would only work in python3. *Said in a different way:* &gt;it would only work in ~~python3.~~ the main version of python.
You really want this? OK: * Download the CPython source with mercurial. * 1 hour figuring out how the source tree is organized. * 1-3 hours reading about parsing. * 1 hour modifying the parser for CPython. * 1-5 hours testing, fixing, leisurely adaptation and experimentation. This is an obvious problem with the grammar. Tuples suffer a similar thing. How disgusted do I feel when I call `Process(target=proc, args=(1,))`, having to put the comma after a single item to create a tuple? I think, "is this Python or is this Perl?" The syntax isn't robust enough to support perl-ish literals or macros. That's why we don't have them. You, a computer science student on reddit/r/python, may be the one to implement this in some time. Your company might pay you to do it. Learn how this works, and maybe `{0}-{0}` won't have to happen.
Clever!
I would start off with Dreampie. This is a great tool to help you develop scripts.
Additionally, it's easy enough (I've done it, so I'm speaking from experience) to profile your Python code using the standard library [cProfile](http://docs.python.org/library/profile.html#module-cProfile) module, and just reimplement the Python bits that take most CPU time in C (or in my case, C++ using [pycxx](http://cxx.sourceforge.net/)). The cProfile profile gets a bit messy around your non-Python modules, but that's OK, you can use other profilers to measure the C++ code (on Linux, I've used sysprof and perf for this purpose). This approach gets you the best of both worlds - the ease of coding in Python, and the speed up of C when it matters.
Thanks, it grows even more interesting the more I hear about it
Lambda is nothing but an anonymous function. Lambda does nothing that a normal function could not do. It's just a way to let you create a simple one line function and pass it around. Anywhere you see lambda being used, you can take the code for lambda, put it in a named function and pass the function instead of lambda...
They're semantically equivalent, but not syntactically—so their value in terms of code readability is different. So the question is: when is it worth to turn a named function into an anonymous one?
I use lambda functions quite often. I wouldn't say they're "very rare." That's a term I'd save for something like metaclasses. They're commonly used in things like sorting functions. Suppose I have a list of dictionaries and I need to sort them by the "name" key: dict_list.sort(key=lambda item:item["name"]) or sorted_list = sorted(dict_list, key=lambda item:item["name"]) Depending on whether you want the sorting to be in place or not. You can also use lambda functions similarly with min and max function. max_value = max(dict_list, key=lambda x: x["value"]) You could also use it with objects that don't have `__cmp__` defined, (or have it defined differently than you need for this use case): min_value = min(obj_list, key=lambda x: x.value) Now, I wouldn't generally use it in map and filter functions, as suggested in the article. List comprehensions tend to be a more readable means of accomplishing the same thing. filtered_list = filter(lambda x : x%2 ==0 ,list) becomes filtered_list = [x for x in list if x % 2 == 0] and mappped_list = map(lambda x:x**2,list) becomes mapped_list = [x**2 for x in list] And these could be combined: filtered_mapped_list = [x**2 for x in list if x % 2 == 0]
7 &amp; 2 are odd numbers. I need only 1 to rule them all. And I propose to add some sexyness to your solution : eval(AssertionError.__name__[1:1&lt;&lt;1&lt;&lt;1^(1&lt;&lt;1|1):1&lt;&lt;1]).__call__(*[({})]) edit 1 being a shortcut for : 1 &lt;&lt; 1 &gt;&gt; 1 ^ 1 | 1 &amp; ~0 
What is the advantage of me using this instead of QtWebKit (since it already requires it)?
I think the unspecified behavior is part of the impetus for the with context. The __exit__ function is called at a well specified time for with, so many places that previously relied on the calling of __del__ (e.g. temporary files), can now rely on __exit__ as well.
Are you a greengrocer?
I use them in Tkinter so I can have several buttons call the same function with a different parameter. Tkinter expects a function reference, which does not allow a parameter, but you can easily wrap the call in a lambda: from Tkinter import * class Counter(Tk): def __init__(self): Tk.__init__(self) self.lblOutput= Label(self, text = "output") self.lblOutput.grid() Button(self, text = "One", command = lambda: self.say(1)).grid() Button(self, text = "Two", command = lambda: self.say(2)).grid() Button(self, text = "Three", command = lambda: self.say(3)).grid() self.mainloop() def say(self, number): if number == 1: result = "uno" elif number == 2: result = "dos" elif number == 3: result = "tres" else: result = "I don't know" self.lblOutput["text"] = result 
You could use 6 instead of 7 in the slice and get the same result. Then the slice would look like this: [1:1&lt;&lt;1&lt;&lt;1^1&lt;&lt;1:1&lt;&lt;1]
Why use threads? I understand that shared memory is important for some applications, but certainly not all of them. Why not use multiple processes instead? Python has good support for MPI through mpi4py. No locking and you can parallelize across multiple computers. Or you can use the built in multiprocessing library. It also doesn't use threads.
Simple case: they're frequently used for sorting lists of complex objects. For instance, if you have a list of dicts: people = [ {'first': 'al', 'last': 'allison'} {'first': 'zeke', 'last': 'zekeson'} {'first': 'bill', 'last': 'billson'} ] And you want to sort them lastname, firstname, call: sorted_people = sort(people, key=lambda u: u['last'] + u['first']) 
Yeah, it's a sound idea, but I'd add variables for stuff like wether there's a loop singleton (don't remember the usual name right now, I just woke up), or the type of gc.
[The Tragedy of the Commons](http://en.wikipedia.org/wiki/Tragedy_of_the_commons). :(
I can't believe I just read through all those comments of people bitching and then saw this at the end. TO THE TOP WITH YOU!
This applies to resource depletion, not resource abuse (or whatever you call spreading child porn links via a pastebin, or whatever "highly illegal" activity it was)
I use it when I want to confuse other people that read my code.
&gt; So this is what it takes to get people to try Python 3. Yep, I have actively refused to use python 3, and I have publicly spoken out against it's use, but now that Mark Shuttleworth has put it on the desktop, I am ready to fall in line. *jokes* because you are over simplifying the issue of python 3 adoption. I bet most people that care about python 3 adoption at this point or hobbyist anyway. Who here makes a living with python and is poorer because of the lack of python 3 adoption. And why is that? 
Seconded - specifically a `DataFrame` for table-style data with rows and columns. It's fast, flexible, and integrated with tools like IPython and matplotlib. [Here's pandas' website](http://pandas.pydata.org/).
Actually that makes perfect sense, thanks for the correction
Thanks. :)
&gt; The lambda is really not doing any good at all in this case, **since it's being called right away**, Not sure I agree.... In [5]: x = lambda: str(1111) In [6]: x Out[6]: &lt;function __main__.&lt;lambda&gt;&gt; In [7]: x() Out[7]: '1111' In [8]: or ... In [23]: def hi(): print "you called?"; return "hi" In [24]: x = lambda: hi() In [25]: x() you called? Out[25]: 'hi' In [26]: 
Last repository I found was on Christopher Grebs' bitbucket: https://bitbucket.org/EnTeQuAk/lodgeit-main
What "highly illegal content" was the pastebin used for?
ahh that should do it :) thank you
Hack is a nebulous term. Could you rephrase your question, but remove the teenage 'just-watched-The Matrix' factor.
When sorting, it would be better to use a tuple of strings than concatenate the strings together. Suppose you had the following contrived example: people = [ {'first': 'xyz', 'last': 'a'}, {'first': 'def', 'last': 'abc'}, ] If you sorted with sorted_people = sorted(people, key=lambda u: u['last'] + u['first']) You would get "axyz" and "abcdef", so "abcdef" would sort first, even though the last name "a" sorts before the last name "abc". If instead you used sorted_people = sorted(people, key=lambda u: (u['last'], u['first'])) The sorting function would sort by last name first, then break ties with the first name, rather than treating them as a single unit.
Yeah, are we talking about something mild like copyright infringement or something more serious like cp? When I ran a pastebin briefly, 99.999% of the pasted content was just regular spam. 
Fuck yeah! Lesbian is fine too :D
Noooo my pastes :(
You can also do apt-get install python-pyside.qtwebkit, as Ghost.py only requires QtWebKit module. 
Lambda in Python is almost useless until you begin to do functional programming
Could this be used to extract resources such as GIFS and JPGs? How would this be better than something like [Scrapy](http://scrapy.org/)?
Can you post a link or any amount of information on it?
I'm guessing this was the intended link: http://www.pythonlearn.com/ seems like it could be an interesting course.
Honest to God, I've been programming for over thirty years and this is the first time I've ever heard emacs referred to as lightweight. I suppose on some scale it might be considered that, but if so it's a scale I've never put to any practical use. For instance perhaps Visual Studio is a more complex product in terms of lines of code or CPU &amp; RAM required, but it is still more lightweight in terms of what you need to know to start using it. No knock on emacs here -- though I've been a vi/vim user since 1970-something (I don't really know vi, but my fingers do...) But lightweight? Have to think about that... 
Will have to jump to Pandas soon. But for right now lists and nested lists are pretty amazing themselves. Nested lists are an especially useful tool to use, especially for data which has multiple characteristics. 
I do the same with wxPython
Probably data dumps, credit card lists, and alike
Works like a charm here, have it running solidly for months now.
Why do you think `{}` and `{:}` is more consistent than `set()` and `{}`? And why do you even need consistency at set-dict level? Especially if you pay for it with more substantial inconsistency in {'a': 1, 'b': 2} {'a': 1} {:} - WTF
Thanks for the feedback. I generally use config files instead of config in code because of the multiple environments my code runs in. I use an internal pypi instance at work and applications are delivered via it and installed via pip. I find it's much easier to tweak a config for an environment than to have separate instances of code laying around, different for a global development instance, test instance and production instance for example. I find it also helpful when I am working on my own machine (OSX) and deploying to Linux. A simple example there is how in Linux I use syslog via /dev/log and in OSX, syslog listens on /var/run/syslog. Also, said configuration is usually different, not based upon the daemon parameters (though that can vary), it's more in logging and application specific configuration. For example, options such as which database cluster it will be talking to, which message broker should it connect to and what credentials should it use, etc. My goal with clihelper was to reduce the often repeating patterns in my own code into a single, usable module. Given your example, if all you care about is making your app a daemon, python-daemon is the way to go and is very similar to what you wrote.
Generally you'd want to sort by last name and break ties by first name. Combining the two into a single unit before sorting has the potential to sort in unintuitive ways.
Sorry, I also missed commenting on the disconnect with regard to documentation and extra complexity having the config file adds. It does add a level of disconnection and complexity, no-doubt. I hope the README is pretty clear on how it all fits together, I've updated it with more information. Please let me know if it does not clear things up a bit: https://github.com/gmr/clihelper#readme
I think your README is very clear -- it pretty well answers my questions. I do bristle a bit though at `Controller._get_config()`. What does the leading underscore denote? I'm used to this meaning "internal function, avoid using". Also, it sets up your Application to depend on a global Controller object with a distinguished method which .. etc, where in my humble opinion a constructor argument would make the Application's interface much more obvious and reusable. Perhaps that's an anti-goal for code using a framework. Perhaps I just don't get it :-). Actually, I think you've answered that in your other reply. I'm used to plumbing in a different fashion, where the main entry point is responsible for routing runtime parameters through to each component. Controller._get_config() captures that complexity in your environments .. name aside, it has its merits :-).
Until I saw replies I thought you were making a joke (Ponies?) .. why have I never heard of Pandas before? It looks nice.
&gt; something more serious like cp? The latter.
This would actually look much nicer if you use functools.partial
It's meant to be called by your extended class, so it is specifying that it's an internal function. The avoid using part, not so much. Edit: it's also worth noting that this is a fork/port from an internal version at work that uses a dynamic configuration system where config is loaded via a database (CouchDB) specified by SRV records in DNS for a given host/cluster/service.