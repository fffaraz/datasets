First off, VT is heavily used within the information security world especially when it comes to analysis. They're not just some guy or shady business working out of a back office somewhere. While it is true you can't trust any company you're not a part of, and even then it's questionable, VT's reputation is well deserved. Also, hash != version. Sure you could do some kind of correlation and say "hey this guy is running version 1.2.3 of this service" but so are 1000s or maybe 10 of thousands of others. People who break into systems do not target home users based on some random query to a web api it's just not worth their time. Sure you could be targeted because the business, people, or files you may possess are of high value to someone but if you're going to be targeted no single piece of information will be your downfall typically. If you're going to argue "well anyone can craft a phishing email" you're right, but groups that are only out there to phish most often don't go out of their way to find extra information on people. Finally for everyone else out there, VT is not a virus scanner. It's a search engine to say "we've seen this exact data before and it has been identified X number of times by X number of vendors, do what you will with this information in your analysis." It also won't have much information on brand new or targeted threats but again these are not the types of things most people would ever see on their home machines.
Negative Indexing. Sometimes I need to return all but the last few items in a list, but sometimes the entire list, requiring extra code: a = [1, 2, 3, 4, 5] omit = -1 # can be a negative value, but can go to zero if omit != 0: b = a[:omit] else: b = a[:] or I need to do use the length: end = len(a) b = a[:end + omit] I'd really like to have "end" be a special object such that: b = a[:end] # returns the whole list b = a[:end-1] # returns the whole list sans the last item 
My bad, last time I checked the project had stalled.
As someone who has spent a year coding a lot of coffeescript-- I agree.
The point of the job is to code and you often bring your own tools. In other cases you will have to use whatever tools you are provided with (and yes....this can include VIM/emacs/some IDE you don't like). Your argument here is like saying "I refuse to use for loops, I only wish to use while"
If they don't like indenting in python, you shouldn't show them coffeescript...
No you asked about the problem then proceeded to tell everyone you wouldn't even listen if they so much as mention X, Y, or Z. You came here for advice while simultaneously asserting you know better than they do for. Also, I'm going to talk about VIM and explain why I use it on occasion. Because it's fast, light on memory, and can act *mostly* like an IDE when I need it to. It's a tool that I use to get the job done while *some* people are arguing over which is the better hammer. It fits in places you could never dream of putting an IDE and for small fixes it's always faster. For everything else I'll switch to an IDE but I don't go asking for help like my hammer is bigger and better than everyone else's. Don't belittle someone else's workflow if you want help unless you're willing to put up with really terrible answers.
Fucking recursion limit. Stupidest thing ever.
Looks cool. Still not "batteries included" - it's not part of Python. I have to install it (but not with PIP!) or you have to package your program for my platform.
One of the problems with py2exe is that the binary packages cant be signed (terrible if you have to distribute software to end-users and all their anti-virus/warning dialogs pop ups).
This is why tab indenting is the only thing that makes sense. You both get what you want.
https://github.com/nandoflorestan/nine/blob/master/nine/__init__.py http://python-future.org
It might be because more Python developers use LInux or other *nices, which have better mechanisms than Windows for distributing programs.
The name, I hate snakes.
She could but.... ew.
That's for phone apps really.
Not sure if serious, or just trolling.
So pefix 'private' variables with `__` so they are name mangled and nothing can touch them evar; and define a @property without a setter. It's a reference counted language. You may find smart pointers more amenable.
Do other languages do better in this regard? I believe this is a basic limitation of using standard I/O libraries without specialized terminal libraries. You'll get the same problem in C++ with cin unless you put it in some kind of unbuffered mode.
I would really like to see expanding dictionary values to assign multiple variables similarly to expanding lists or function keyword arguments. ie: d = {'foo':1, 'bar':2} foo, bar = *d vs. foo = d['foo'] bar = d['bar'] 
I'd like to be able to add/change/delete attributes of built in types.
I'd do class assignment, but that's not supported for module objects.
LOL I find it so fucking confusing &amp; tl;dr I never bothered to really learn it, when I have question I just google or go to #python for rescue
you mean py2exe and pyinstall ?
 &gt;&gt;&gt; exit Use exit() or Ctrl-D (i.e. EOF) to exit You know what I meant. You even special cased it so that it doesn't just print `&lt;built-in function exit&gt;`. So why don't you just...exit?
&gt;realy Deliberate?
I think this is approximately the opposite of the necessary change (as I detailed in my top-level comment).
ITYM `''.join(reversed('this sucks'))`. Edit: that said, I don't think it particularly sucks. Outside of interviews and homework, I don't think people actually want to reverse strings often enough for it to merit a method on `str`.
...it... does? &gt;&gt;&gt; def hax(count): ... if count == 0: return ... yield count ... for _ in hax(count - 1): yield _ ... &gt;&gt;&gt; list(hax(3)) [3, 2, 1] What's the problem? (And in 3.3 onward, you can enhance this using `yield from`.)
It protects you from crashing the interpreter. The stack is a real thing and programming around it is not trivial. But it's called Stackless Python if you want to search for it and try it out.
This absolutely broke my head. I had the darnedest time trying to figure out how it worked until I tried it out in my interpreter and realized I was only partialling one of the arguments instead of two. That is a good trick.
&gt;First obvious candidate: introduce an explicit end-of-block delimiter and get rid of the godawful `pass`. `pass` was added deliberately to avoid errors resulting from empty blocks not appearing to be blocks. ~~It is not actually required by the grammar.~~ Adding delimiters means that much extra stuff to type, and probably with style guidelines that will end up adding tons of what is basically unnecessary vertical white space. (The grammar as it currently exists, obviously, does require it; and in fact does not generate INDENT and DEDENT tokens otherwise. However, given the preprocessing required to generate those tokens in the first place, it is trivial to see how the parser could be adapted to deal with empty blocks.) &gt;Once that's settled, indentation can be 1) optional (which is a good or a bad thing depending on how you look at it), If you want not-Python, you know where to find it. &gt;and 2) automated (like in every other goddamn programming language). Your IDE is at fault here, not Python. Mine auto-indents just fine. And if you are putting that much effort into re-indenting code, you are almost certainly doing something wrong anyway. Flat is better than nested. &gt;Tuple syntax. Come to think of it, tuples in general. Your reasoning here is not even consistent. You just finished complaining about some types being immutable. &gt;this distinction doesn't make a lot of sense: there are no compile-time vs. runtime types, so lists and tuples boil down to the same thing. Python, however, has mutable and immutable lists, and calls the mutable ones "lists" and the immutable ones "tuples". This allows the built-in types to have rules for hashability (and a built-in hash algorithm) which ensure that dict keys don't get modified while they're in the dict, while still allowing for mutable types. &gt;Lambdas. The notion that 'if it doesn't fit on one line, it shouldn't be anonymous anyway' is stupid and belittling... Even JavaScript, the silly little language one programmer cooked up in two weeks during the dark ages, beats Python in terms of expressiveness here. Subjective. But again, 'flat is better than nested'. You're literally saying that Javascript is "more expressive" because it gives you the option of **not** attaching a descriptive name to a callback that does a significant amount of work. &gt;Proper scope. Python doesn't do scope right. I don't know why, but the result is a highly confusing mess full of edge cases. What edge cases? And what you call "highly confusing", I call elegant and simple: with open('foo.txt') as f: foo_lines = list(f) do_something_interesting_with(foo_lines) and relax_because_with_did_not_create_a_scope() It corresponds to the amount/tightness of scoping you normally actually *want*, and if it ever actually causes a problem, it's realistically because your functions are too long. &gt;Strings. A string is a sequence of characters, and characters and bytes are not the same thing. DYE3.x? &gt;Those members of the Python community who take everything GvR says without the required grain of salt. Seriously, the man is reasonable and has some great ideas, plus a decent enough sense of humor, but too many people take whatever he says as gospel. Examples?
I wouldn't change anything I heart python 
Currently? The fact that multiprocessing.Queue doesn't #$%^ have `qsize()` implemented on OS X! "Portability," I said to my boss. "It's like getting something for free! Shouldn't take more than a few days." "Wait.. Hmm.. all of my unit tests are failing. what could.. oh son of a.." `NotimplementedError` My weekend will be looking though the queue internals trying to figure out how to work around it.. Second thing: The fact that things have to be pickled before sent across processes. Usually doesn't bite me, but when it does, it's pretty damn annoying. 
But you said &gt; If you're using a variable in some scope, why would you be declaring it &gt; elsewhere? Isn't global scope elsewhere?
I'm not sure about *consensus* but I've found [scrapy](http://doc.scrapy.org/en/latest/intro/tutorial.html) to be very nice to work with.
Not in the standard library, but Gevent makes for very easy cooperative multitasking (non-CPU bound tasks). You can do magic like: from gevent import sleep, spawn def loopit(): while True: sleep(1) print 'while loop!' spawn(loopit) for x in xrange(5): print 'for loop!' sleep(1) Both loops run simultaneously. for loop! for loop! while loop! for loop! while loop! ...
Most likely, but I really hope it is a case of [Muphry's law](https://en.wikipedia.org/wiki/Muphry's_law).
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Muphry's law**](http://en.wikipedia.org/wiki/Muphry's%20law): --- &gt; &gt;**Muphry's law** is an [adage](http://en.wikipedia.org/wiki/Adage) that states that "If you write anything criticising [editing](http://en.wikipedia.org/wiki/Copy_editing) or [proofreading](http://en.wikipedia.org/wiki/Proofreading), there will be a fault of some kind in what you have written." The name is a deliberate misspelling of [Murphy's law](http://en.wikipedia.org/wiki/Murphy%27s_law). &gt;Similar laws have also been coined, usually in the context of online communication, under names including **Skitt's Law**, **Hartman's Law of Prescriptivist Retaliation** (or The Law of Prescriptive Retaliation), **The Iron Law of Nitpicking,** and **[McKean](http://en.wikipedia.org/wiki/Erin_McKean)'s Law**. Further variations state that flaws in a printed or published work will only be discovered after it is printed and not during proofreading, and flaws such as spelling errors in a sent email will be discovered by the sender only during rereading from the "Sent" box. &gt; --- ^Interesting: [^Murphy's ^law](http://en.wikipedia.org/wiki/Murphy%27s_law) ^| [^Fumblerules](http://en.wikipedia.org/wiki/Fumblerules) ^| [^John ^Bangsund](http://en.wikipedia.org/wiki/John_Bangsund) *^\/u/Kamikai ^can ^reply ^with ^'delete'. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less.* ^| [^(FAQs)](http://www.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/) ^| [^flag ^a ^glitch](http://www.reddit.com/message/compose?to=/r/autowikibot&amp;subject=Glitched comment report&amp;message=What seems wrong: (optional description goes here\)%0A%0A---%0A%0AReply no. 48723:%0Ahttp://www.reddit.com/r/Python/comments/1xaen1/if_you_could_change_something_in_python_what/cf9y6rn)
I don't like the import system much. Too easy to get into a cyclic import hell.
The primary reason would have been the ["There should be one-- and preferably only one --obvious way to do it."](http://www.python.org/dev/peps/pep-0020/) rule. A likely secondary reason is that `switch` was popularized in C because it indicated to compilers that they should make an effort to optimize it using a jump table. Compilers evolved to also handle repeated `else if` statements for this optimization, so `switch` quickly lost its advantage. It slightly helps readability in some cases, but it's really not worth adding a new language construct for such a minor bit of syntax sugar.
&gt;I've been programming for over 20 years. Me too, and I honestly don't feel that any meaningful decision has been made for me.
The reason `.join` belongs to str objects is because this way it can join up any kind of iterable of strings, not just lists.
Yup. Thats why I switched to neocomplete instead. Works just as well. 
&gt;if you're going to do that you may as well install a different PDF viewer because Reader is a slow, bloated piece of shit. I don't follow your reasoning here. Installing a different viewer is much more work than changing the preferences in Reader; and turning off Javascript support does not make Reader any slower or more bloated.
The whole reason it's python *3* and not python 2.x+1 is because it's made to not be constrained by the previous version. Taking a look at the [Development Section](https://en.wikipedia.org/wiki/Python_(programming_language\)#Development) explains this. Python 2 (although with updates and improvements) has been around for nearly 15 years. It's time to move on.
I would make it so adding an int to a string converts the int to a string and then concatonates it, like Java. 
The problem with that is dictionaries are intrinsically unordered, so the order that elements would be unpacked in would be inconsistent and illogical. For your first example, unpacking d.values() should do exactly what you want. Again though, no order is guaranteed, so it's probably not useful, or you should be using a list.
I use Eclipse with "Indent Guide", last version of "pydev", "eclipse color theme", I used everything like pycharm, eric, ninja, vim and ... , nothing worked for me like eclipse !
Cool program, but it won't actually detect any half decent virus that wouldn't run in its own process and could feed whatever hash it wanted to your program (through altering the data read).
&gt;for a situation where you would want to use a multiline anonymous function, you are supposed to define a new function I personally find that silly. I've heard similar statements made for commented code, but that doesn't mean a language should eliminate support for comments altogether. EDIT: quoted the wrong thing
OK yeah, static typing isn't going to do much for readability if you're using type inference all over the place, but otherwise it helps alot. Even so though, a good ide can tell you straight away what the type is which helps you understand the code with less mental energy, hence easier to read.
&gt;the upgrade path could be handled so perhaps there was a 2.8 that deprecated old stuff Wasn't that what 2.7 did?
Not sure why you got down voted, that makes a lot of sense in my mind. Apt-get eliminates much of the issue. It can install a python interpreter on the client in a single shell command.
The correct special casing is a = [1, 2, 3, 4, 5] omit = -1 omit = omit or None b= a[:omit] This is a little more readable than what you have. 
It's getting to the point where windows is becoming a real hindrance. I still use it, but I wish I weren't.
do you have a real requirement for CamelCase class names?
It seems like every time I go to put a new class in a module, I end up doing this to myself. But I do prefer the 'from name import name' to 'name.name'. 
&gt; Syntax-relevant indentation means I have to correct indentation manually when I paste code, instead of letting my editor take care of it. Your editor doesn't take care of reindentation? ... ... Get a better editor, then. &gt; Splitting long statements over multiple lines is cumbersome and ugly. `( You mean` &amp;nbsp;&amp;nbsp;` like this,` &amp;nbsp;&amp;nbsp;` right? )` Because there's no particularly good reason to do it in the ugly C-style backslashy way. 
This. I like having non-retarded threads in C++. It'd be nice to bring that level of play into the Python universe.
More random import eastereggs
Eliminate the differences between python2 and python3.
I realize it will never happen and it would likely screw up a lot of peoples code , but I wish that list comprehensions supported multiple iterables in a readable way. I know that you can accomplish many of the things using zip or imap but it would feel nice to be able to: [(x, y) for x in iterable1 with y in iterable2] Ideally it would use None for the x or y if one iterable reached StopIteration before the other. It would also be nice if you could include if statements after each statement in the list comprehension as well. [(x, y) for x in iter1 if x &gt; 0 with y in iter2 if y != x] Across multiple lines: [(x, y, z) for x in iter1 if x &gt; 3 with y in iter2 if y &gt; 6 with z in iter3 if z &gt; 9] It might be better not to use 'with' and instead use 'and' or some other keyword or even just a comma. I just used with to show what I meant.
So do Python if elif statements get interpreted down to jump tables?
You could do a simple decorator, something like: def typecheck(*sig): def _inner(func): def _inmost(*args): for type, arg in zip(sig, args): if not isinstance(arg, type): raise TypeError return func(*args) return _inmost return _inner @typecheck(int,int) def add(a,b): return a+b &gt;&gt;&gt; add(1,2) 3 &gt;&gt;&gt; add(1,'a') Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "&lt;stdin&gt;", line 5, in _inmost TypeError Not that I'd ever use that.
REPL customization is what PYTHONSTARTUP's for! Create a file that contains something along the lines of import sys import builtins def displayhook(x, original=sys.displayhook): return original(x() if x is builtins.exit or x is builtins.quit else x) sys.displayhook = displayhook then put `export PYTHONSTARTUP=/path/to/that/file` in your `.bashrc` or some other shell configuration file.
That's basically it. The idea is that multiline anonymous functions can get ugly; it's (arguably) more readable to define a function and use it, which serves the same purpose.
The keys would be used to assign the variables (like **dict when passing parameters) so order shouldnt matter.
 &gt;&gt;&gt; exit = 1 &gt;&gt;&gt; exit 1 &gt;&gt;&gt;
Lots of confusion over wheel, its a package installer thing, like pip. python must already be installed to use a wheel; and typically youd install one using pip.
I think the issue here is that dicts aren't ordered, so if you do foo, bar = **d then what values do `foo` and `bar` end up getting? Maybe not what you wanted or expected. Of course, dicts could be ordered, but that incurs some overhead and maybe isn't what you want most of the time, either.
It's a text editor, not mostly an IDE. It's not human-perceptibly faster than any other popular text editor and isn't some miracle tool. 
No, the argument here is about getting pyDev support. Use X instead is as relevant as hearing "get an Android phone!" when asking a question about your iPhone. The user already has reasons for sticking with Eclipse so they ruled out other options. They also didn't want to turn the thread into "my X is better than your X" debate or invoke the holy cults of emacs and Vi. They also didn't want to pretend a text editor is an IDE. They just wanted a simple answer to their question. 
That's a terrible idea if you don't mind me saying. Dictionaries can use any immutable value as a key, and translating strings to variable names would not only fail for most things, but create a massive security risk. What happens if the keys are "$(*&amp;#\^!@", the integer 10, a tuple (23,67,8) or even the string "\_\_name__"?
There is a lot of interesting discussion around "".join([ ]) on [this SE thread](http://stackoverflow.com/questions/493819/python-join-why-is-it-string-joinlist-instead-of-list-joinstring).
Yeah, and then they went ahead and created decorators because there was no other clear way to call a function with another function as the last argument. Though I admit, it's kinda hard to think of a good syntax for multi-line lambdas in a language that uses parentheses for function calls, but not braces for blocks.
Everybody always mentions the Gil, but really you only need one process per core anyway, and you can use greenlets for cooperative multitasking. Threads for single core multitasking are so 90s.
[this one](https://github.com/joedicastro/dotfiles/tree/master/vim) has floated around here before (note: not mine). **The absolute best thing you can do is learn Vim.** It really doesn't matter what your editor is - learn it. You will be spending a lot of time using it. Pulling in a plugin should be done because it fixes something that bugs the crap out of you - not because someone else recommended it. You will be remarkably disappointed as a newbie if your experience revolves around constantly changing your plugin setup based on other's opinions, rather than as a response to your own need, as your time is going into configuration rather than learning Vim and using it.
To get a jump table out of it you need to be comparing the same thing in every branch. Then that value could be hashed to an int maybe and you could do a jump. With arbitrary expressions in the case statement ( including possibly side-effecting expressions) there's not really a way to make a jump table , you have to compare every branch sequentially.
If only you could use greenlets without either error prone monkeypatching or having to rewrite any libraries you use that do IO. I have high hopes that tulip will provide this solution so that all IO can be written against a generic API that can be backed by generators, threads, and/or greenlet. Stackless is over 10 years old and there's still an awkward divide between stackless/gevent and the rest of the Python world where most things Just Work but when they don't... good luck. 
I think we're at the point where fine-grained locking with their 2x single-threaded performance overhead may be worth it. I wouldn't be surprised if going that route attracted more attention to interpreter optimization and won us most or all of the lost performance. Sure it'd be a maintenance pain, but core CPython moves so slowly and is still so far out ahead of mainstream Python (as in: very few people on 3.3) I think they could deal with the slight development slowdown of fine grained locking.
Very interesting! Thanks!
This. It was 2.6-3-2.7. I think it probably would have gone better if 3 and 3.1 weren't so poor.
Check it: http://www.python.org/dev/peps/pep-0403/. God I hope this makes it in one day.
Python uses indentation to denote blocks, it's different from the offside rule in say, Haskell etc. Internally the lexer emits indent and dedent tokens that correspond to curly braces in other languages. If we had multi line lambdas, it would most likely be done something like allowing a def to be an expression. Otherwise multi line lambdas would require adding a bunch of new surprising rules to the parser Edit: removed if
Why?
multiline lambdas. generally, the opportunity to write in a more functional fashion.
It would break stack traces, which seems like a pretty significant issue.
It was released a year ago and unless this is tracking the wrong repository it has had very few commits lately: http://www.ohloh.net/p/jython/commits/summary 
I just think their reasoning is stupid.
The Gil hurts you when you have CPU bound tasks on the same core and you want to time slice to complete both at the same time. I would argue if you have seriously CPU bound tasks, then python is the wrong language. It's slow as shit. If you are calling out to a c/c++ library that does your heavy computation, it is perfectly fine for it to do its own threading etc. The Gil doesn't hurt you when you have io bound tasks, and having one python process per core with multiprocess isn't too onerous.
I've never understood why people think this: foo(a, b, callback=lambda result: # callback's # body # here ) Is so much better than what you have today: def callback(result): # callback's # body # here foo(a, b, callback) In fact, in Javascript where callbacks are the norm, I often see people recommending the latter format to avoid deeply nested callback hell.
I've been programming for 20 years and never used it once.
Same problem.
The Stackless fork would have been merged into mainline 14 years ago. [PEP 219](http://www.python.org/dev/peps/pep-0219/) I believe.
Not Python but rather CPython. Get rid of the GIL.
Optimizations in general can break stack traces due to code elimination, inlining, and reordering. If stack traces are truly concerning, one should disable optimizations.
Really. Why? There's no reason for print to be a whole statement- it doesn't do anything interesting with control flow. See also `exec` and `eval` (and `yield`, sort of).
Trounce hand-coded native code, sure. Trounce optimized C compiled with GCC or clang, maybe not, most of the time. However, there's really not much you can say unless you're speaking about a specific architecture and compiler, a specific algorithm, optimizations it took advantage of, because benchmarks are just hot air. I do hope more research is done on removing the GIL from cpython or pypy, and an efficient JIT compiler was part of the standard interpreter. For most practical purposes, python is as efficient as I've needed it to be, and anything else can be written in C and called with subprocess.
The first 2 are operators, not statements. They're just layers to the `__add__` and `__equals__` functions, which is cumbersome, I guess, but seems fine to me. Also worth it to have the more compact syntax. It doesn't make sense to express for as a function. I can hear the functional and ruby programmers hissing at me, but Python's model is based on indentation blocks, not functions. Control flow and things that require blocks should be statements.
In that sense Python is native code and the modules are data. And, indeed, pythonic code isn't quite a good way to write for embedded things... yet. ... For all other cases bundling the interpreter isn't too horrible.
Oh god... if I had a nickel for every time I've asked for a frozendict... I just want some global, static config that I'm not scared someone will change.
Quite a few of the things that one'd want to change in Python can be changed at runtime. The exceptions are, thus, other people's code (for loop variable leaking, eugh), and performance (e.g. parallelisable known-no-side-effects functional-ish code). Aside from that, I'm all for reliable static checking but that does seem to be the future anyway.
Fun side note- you don't need the `+` between the strings. Python will automatically join adjacent string literals (not variables) in an expression.
True, but I feel explicit is better than implicit here. There have been previous proposals to remove that functionality (they were rejected), and my mind was changed when I read the discussion.
&gt; It would also be nice if you could include if statements after each statement in the list comprehension as well. You, um... can do this. Not your `with` thing, but: [x.function() for x in things if x.is_valid()] is perfectly valid python, as is: [(x, y) for x in range(10) for y in range(10) if x != y] That will produce every combination of `x` and `y` where `x!=y` 
&gt; you only need one process per core anyway LIES! This may apply to your and your friends' use-cases, but don't assume everyone is like that. I do a lot of number-crunching, and not having a shared memory between my processes is a supermegagigantic clusterfuck of a pain in the ass. It basically means that some things simply cannot be done at all. e.g. if I'm working on a big dataset and every thread/process needs write-access to all of it, I'm screwed. Working around those limitations is no fun.
&gt; **can act** mostly like an IDE Please reread my exact wording above, I did not say that vim is in fact an IDE, I said it can be mostly like an IDE. If my development environment consists solely of a fews tools for code smells, refactoring, version control, text searching by directory/regex/etc, file management, running tests, and working with macros AND if I can get that into a text editor then there's no functional difference within the context of **my** development environment between vim with all those tools and PyFarm/PyDev/etc and all those tools. And it's reasons like this many people consider vim to be an IDE when it's not by sheer definition of the word. Also, I never said it was a miracle tool either and anyone who believes that any one tool is miracle tool is fooling themselves or does not know any better. You argument about speed and human perception don't make any sense either. Small bugfix in a known location in a specific file? I can guarantee it will be faster to do it in vim if you know what you're doing and will be done before you'd ever see the file open in an IDE. Large scale refactoring across thousand of files (taking into account imports and the like) needed or you need to do some remove debugging? I'd almost laugh if someone didn't use PyCharm/PyDev/whatever for this. All of these tools are human-perceptibly faster than every other tool depending on the person using them and the context of the problem.
Why are you doing number crunching in python and not using a c based library? Genuinely curious
I wish PySide was a standard, but then again, each of the Qt apps I use would need their own local version of PySide ahead of the system level in the sys.path or I'd have a bad time
I would make the last line of this work: print("hello " "world") mystring = "hello " print(mystring "world") Just because of consistency, I know I could put a + in there, but I don't understand why they would make "hello" behave diffrently than the variable mystring, when they equal each other.
Thanks. I will be needing this. 
I much prefer tabbed spacing, and I wish it was the standard (implicit is bad be damned) but after dealing with so many people who mix and match stupid indentation so that I can't even copy and paste snippets without python throwing a hissy fit, I've conceded to have sublime always convert my indents to 4 spaces because atleast it's the standard.
Take a look at [concurrent.futures](http://docs.python.org/dev/library/concurrent.futures.html)
ASCII is really 7-bit, it doesn't go above character 127/0x7F. What you mean is probably Latin-1-General, ISO-8859-1, codepage 1252 etc. As somebody whose native language uses Windows CP 1253, I totally agree it was a bad assumption.
C extension types in Python are pretty damned useful for a lot of things, and a complete pain in the ass to write in actual C. Cython makes it a cakewalk, and allows you to write most of the logic almost as if it were Python and only provide type information for critical parts. Best of both worlds, and it generates C code that compiles for both Python 2 and Python 3.
I agree with /u/Kamikai, using the keys as variable names is just asking for a bad time, and allowing it as default behavior would be quite dangerous. Also how would you decide what to assign? The keys are as valuable as their values. It makes much more sense to cast to a list/tuple with .keys() or .values() than to let your assignment remain implied
Guido tried. Found a syntax that looked okay, but the semantics were a little surprising, and in the end it just didn't seem like a good match for Python. Guido wrote up his thoughts in a PEP, which still makes for good reading today. http://www.python.org/dev/peps/pep-3103/
&gt; Trounce optimized C compiled with GCC or clang, maybe not, most of the time. That depends incredibly on who is writing it, and unless it's a optimizing compiler expert and/or CPU engineer from Intel, my money is on a tool like Numba. Also, C speed is not the target for performance computation. What people should be talking about and comparing against (as Travis Oliphant often does) is optimized Fortran with one of the better Fortran compilers. &gt; and anything else can be written in C and called with subprocess. Uhhhhh. That's a pretty ass-backwards way of doing FFI, but okay, buddy.
Having to switch between Python and MEL all day, I can say I love forced indentation. Yes, non-indent based languages can look fine ASSUMING that the developer of the script is staying consistent and is organized. In practice, this is not always the case and coding styles change at companies over the years. I've been touching code from 1996 recently that is so hard to decipher because nobody thought to enforce style guides back then. Python on the other hand is wonderful because everyone styles their code very similarly by language design and this allows people to just jump in and easily understand all flow etc at a glance without thinking about programmer style etc.. Yes, it's got its cons, but I'll gladly live with those cons than have to deal with user enforced indentation.
Guido makes the argument, that I find pretty compelling, that TCO should be considered a *feature*, not an optimization: &gt; The idea that TRE is merely an optimization, which each Python implementation can choose to implement or not, is wrong. Once tail recursion elimination exists, developers will start writing code that depends on it, and their code won't run on implementations that don't provide it: a typical Python implementation allows 1000 recursions, which is plenty for non-recursively written code and for code that recurses to traverse, for example, a typical parse tree, but not enough for a recursively written loop over a large list.
What drives me crazy is that throwing an updating, responsive GUI on top of a CPU-bound computation is impossible without multiple processes, which isn't always possible.
Can I see the link? I find the behavior useful- I remember there was a case that, admittedly, I probably should have been doing differently. Basically, I need a *very* long string with no line breaks, but I wanted to keep to the 80-character line limit. 
Python 3 is misnamed. It's not Python at all. It's something else entirely. Ignore it, or write brand new stuff in it (that is NEVER intended to work on older platforms), but never, ever try to mix actual Python and this incompatible thing called Python 3; that way lies insanity.
Simply do `^D` instead. It even works on other shells like `bash` as well.
CPython: A properly implemented recursion limit. i.e., throw an error when you're about to run out of stack space, not when you hit some arbitrary number of frames.
On that note, does anyone know why spaces are preferred over tabs? 
Plenty of people use Python C extensions (like the things in NumPy) for performance applications, largely because Python is great glue. First of all, it's _not_ okay for it to do its own threading if it touches the Python API in any way. Second, Python would be a great language for writing the control logic of a multi-threaded applications that call out to various C extensions, except that any use of the Python API within them will require the lock to be acquired and thus cause competition for the GIL when both threads need to be executing the parts that are in Python code/GIL-holding C code. Finally, multiprocess isn't an actual solution. There are lots of circumstances where you _can't_ fork, and many where you'd rather not in order to take advantage of shared memory. Just one I can think of is after a CUDA context has been initialized, multiprocess calls will hose everything. 
I format my code with 4 spaces to follow PEP8, but given that any half decent editor can change the visual appearance of tabs it seems like a natural thing to do. Of course, that interacts with the 79-character limit, but if you just said "79 character limit with tabstop 4 (i.e. tabs equal 4 spaces)" you could have your cake and eat it too.
I have a simple naming systems that I use for every variable/class/object/method/function/list/dict I make. This eases this problem greatly. fiSomething # is a function that returns an integer fbSomething # is a function that returns a boolean liSomething # is a list with integers fliSomething # is a function that returns a list of integers 
I actually think the word self is too long :l it looks ugly in my methods and feels very akward to use. It just takes up too much space in my opinion. :l
true Edit: True
[Try dynamically replacing a module's callable reference with ctypes!](https://pypi.python.org/pypi/calldules) (or rather don't, but it's fun anyway)
Function annotation can be used for static type checking, while assert is runtime type checking
I thought about it for a while and I don't like the way Numpy handles arrays. I'd change the notation to be more like Matlab. Its a minor thing, admittedly,but I had a background in Matlab and numpy is often jarring for me. 
&gt; OK yeah, static typing isn't going to do much for readability if you're using type inference all over the place, but otherwise it helps alot. Even so though, a good ide can tell you straight away what the type is which helps you understand the code with less mental energy, hence easier to read. I won't disagree with this, however at the same time part of the 'benefit' of dynamically typed languages is that you worry completely about the interface and not the type itself. If it walks like a duck, etc. IDE support does leave a bunch to be desired though, IntelliJ/PyCharm does an okay job at guessing the return type for python code at least.
Y'all motherfuckers need Julia julialang.org
Maybe because then the interpreter would quit if you try to examine `__builtins__.__dict__`? Or do you want to basically do this (in pseudocode): input_line = get_input_line('&gt;&gt; ') if input_line in ('exit', 'quit'): sys.exit() else: python_eval(input_line)
You can probably set up an auto-correct thingy in your editor.
There's a tiny problem, though: we're inside parentheses. We'd need to change the grammar to make leading whitespace significant in places it's normally ignored.
This is putting a lot of effort into a question that does not get you any closer to solving the original problem.
Why not just let syntastic run it for you?
make it a habit to do import datetime as dt 
I still refuse. Give me tabs or give me death.
Serialising a php timezone object can seg fault the interpreter. Just one of the gems in that module...
Or just a = [1, 2, 3, 4, 5] omit = -1 b = a[:omit or None]
I chose not to write it that way because I regard conditionals inside subexpressions as confusing.
pip also fixes this issue for me. pip install whatever and it will download all the dependencies and handle what I need. It can even uninstall
That only works for [embarassingly parallel](http://en.wikipedia.org/wiki/Embarassingly_parallel) problems :) What I wish are greenlets and channels. I know stackless and pypy provide these but I wish python had them in the first place
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Embarassingly parallel**](http://en.wikipedia.org/wiki/Embarassingly%20parallel): --- &gt; &gt;In [parallel computing](http://en.wikipedia.org/wiki/Parallel_computing), an **embarrassingly parallel** workload, or **embarrassingly parallel problem**, is one for which little or no effort is required to separate the problem into a number of parallel tasks. This is often the case where there exists no dependency (or communication) between those parallel tasks. &gt;Embarrassingly parallel problems (also called "pleasingly parallel problems") tend to require little or no communication of results between tasks, and are thus different from [distributed computing](http://en.wikipedia.org/wiki/Distributed_computing) problems that require communication between tasks, especially communication of intermediate results. They are easy to perform on [server farms](http://en.wikipedia.org/wiki/Server_farm) which do not have any of the special infrastructure used in a true [supercomputer](http://en.wikipedia.org/wiki/Supercomputer) cluster. They are thus well suited to large, internet based distributed platforms such as [BOINC](http://en.wikipedia.org/wiki/BOINC). &gt;A common example of an embarrassingly parallel problem lies within [graphics processing units](http://en.wikipedia.org/wiki/Graphics_processing_unit) (GPUs) for the task of [3D projection](http://en.wikipedia.org/wiki/3D_projection), where each pixel on the screen may be rendered independently. &gt; --- ^Interesting: [^Embarrassingly ^parallel](http://en.wikipedia.org/wiki/Embarrassingly_parallel) ^| [^Tunisian ^Revolution](http://en.wikipedia.org/wiki/Tunisian_Revolution) *^\/u/boarhog ^can ^reply ^with ^'delete'. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less.* ^| [^(FAQs)](http://www.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/) ^| [^flag ^a ^glitch](http://www.reddit.com/message/compose?to=/r/autowikibot&amp;subject=Glitched comment report&amp;message=What seems wrong: (optional description goes here\)%0A%0A---%0A%0AReply no. 48933:%0Ahttp://www.reddit.com/r/Python/comments/1xaen1/if_you_could_change_something_in_python_what/cfa3wbk)
I think pypy can do native compile too
On the other hand, in Python it wouldn't feel clunky to use re2 or PCRE add-on modules, whereas in perl it would
There's a very good write up [about GIL on python wiki](https://wiki.python.org/moin/GlobalInterpreterLock) which explains why they haven't simply gotten rid of it yet
There's [`lru_cache`](http://docs.python.org/3/library/functools.html#functools.lru_cache) in `functools` module if you need memoize. That handles at least some of the use cases of TCO
No need. `file` already has the same interface as `open`. I think the latter is actually defined something like this: def open(name, mode=None, buffering=None): return file(name, mode, buffering) 
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Monty Python**](http://en.wikipedia.org/wiki/Monty%20Python): --- &gt;**Monty Python** (sometimes known as **The Pythons**) are a British [surreal comedy](http://en.wikipedia.org/wiki/Surreal_comedy) group that created Monty Python's Flying Circus, a British television comedy sketch show that first aired on the [BBC](http://en.wikipedia.org/wiki/BBC) on 5 October 1969. Forty-five episodes were made over four series. The Python phenomenon developed from the television series into something larger in scope and impact, spawning touring stage shows, films, numerous albums, several books and a stage musical as well as launching the members to individual stardom. The group's influence on comedy has been compared to [The Beatles](http://en.wikipedia.org/wiki/The_Beatles)' influence on music. &gt;==== &gt;[**Image**](http://i.imgur.com/EFKw6Mu.jpg) [^(i)](http://en.wikipedia.org/wiki/File:Flyingcircus_2.jpg) --- ^Interesting: [^Monty ^Python's ^Flying ^Circus](http://en.wikipedia.org/wiki/Monty_Python%27s_Flying_Circus) ^| [^Spam ^\(Monty ^Python)](http://en.wikipedia.org/wiki/Spam_\(Monty_Python\)) ^| [^Monty ^Python ^and ^the ^Holy ^Grail](http://en.wikipedia.org/wiki/Monty_Python_and_the_Holy_Grail) ^| [^Monty ^Python's ^Life ^of ^Brian](http://en.wikipedia.org/wiki/Monty_Python%27s_Life_of_Brian) *^\/u/robin-gvx ^can ^reply ^with ^'delete'. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less.* ^| [^(FAQs)](http://www.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/) ^| [^flag ^a ^glitch](http://www.reddit.com/message/compose?to=/r/autowikibot&amp;subject=Glitched comment report&amp;message=What seems wrong: (optional description goes here\)%0A%0A---%0A%0AReply no. 48943:%0Ahttp://www.reddit.com/r/Python/comments/1xaen1/if_you_could_change_something_in_python_what/cfa40zi)
Good point. On the other hand, if you always use `a[:omit or None]` as an idiom, it'll probably not be as confusing.
No. void is a wart too.
Very interesting idea
How do you use tabs incorrectly?
Nope. But I am now :-)
Adding string interpolation ala ruby
Just spend a bit of time learning how eclipse does things. Set up a run-configuration for your project. You can configure it the way you want it. F9 always runs the current module. If that's not what you want, don't use F9. IIRC, F11 debugs the current project (using the project-defined debug configuration), ctrl-F11 runs the project using the defined run-configuration. You can almost certainly re-configure these bey-bindings if you don't want &lt;ctrl&gt;-F11. It's a similar process for running tests I think, but I've not played with test-running so I can't speak with confidence on this. PyDev is an excellent python IDE. 
We already have map, reduce¹, partial¹, any, all, zip, sorted, reverse, filter. Not to mention that functools package also contains lru_cache which does memoize for pure functions. Partial is usually easy to replace with lambda, which allows you more flexibility about the arguments you want to predefine. We also have list comprehensions, first-class functions, lazy evaluation(e.g. generators), and we even have concurrency.futures for those embarassingly parallel problems. I understand your gripe with lambda, it's a bit annoying, but are there other issues you wish to address? ¹`These are in functools package`
I wish python had support for running external programs similar to [Julia](http://docs.julialang.org/en/latest/manual/running-external-programs/). It doesn't need to be exact replica, but I wish it was this simple :) if julia you can do my_command = `grep "something" myfile` which doesn't run the command put makes a command object which you can then run with run(my_command) You can also do that directly run(`grep "something" myfile`) and to pipe things, you can simply `grep "something" myfile` |&gt; `sort -n` where `|&gt;` is a pipe operator in julia. 
There are no two urllibs in python 3.x
You could have just included line breaks anyway (in a triple-quoted string), and stripped them out in the next statement (`s=s.replace('\n','')` or something similar)
Right, they've been unified into urllib and http, haven't they?
Read the last sentence ;)
Don't use assert
Problem with defining a separate function is that with lambda you have the whole context of the parent. With separate function you may have to have a ton of parameters to do that
 my_switch[switch_variable](*args, **kwargs) Problem solved :) *edit:* Alternatively, `my_switch.get(switch_variable, default=default_func)(*args, **kwargs)`
&gt; lst = [1, 2, 3] map((x: if x &gt; 1: return x*2 else: return 10 ), lst) lambda x: x*2 if x&gt;1 else 10 I know, it was just an example
Not OP, but a few things I like that are particular to Ruby: * Blocks * Class vs. module dichotomy (which are separate from the file system) * Useful baked in methods (`[].uniq`, `[].take_while`, `"words".codepoints`, `10.times`) * Ability to choose between mutable and immutable string types * Consistent method chaining instead of combining methods with builtin functions, like `".".join(reversed(sorted(dct.values())))` vs. `hash.values.sort.reverse.join(".")` * Overridable `switch` statements that allow complex comparisons * A `loop` keyword * `||=` assignment * Implicit `self`, and abbreviation with `@variable` * Built-in regex operators * Concise hash syntax: `{a: 5, b: "7"}` Things I like about Python that Ruby doesn't have: * `in` for checking existence within containers * `and`/`or` only, no `&amp;&amp;`/`||` * Generators * List comprehensions, generator expressions, dict comprehensions, set comprehensions * Fantastic third party libraries (non-web app related) like `gevent` and `requests` * Decorators * Docstrings * Whitespace sensitive * Not having to end every block of code with `end`! * Better overall community They're both excellent languages, really. If I were to design my own it would be a shameless mishmash of them both.
"Oh look, I can l line up my equals signs for my variable declaration by adding a tab and spaces" caravans = [] car &lt;Tab&gt;&lt;Space&gt;&lt;Space&gt; = something And for the tab = four space guys it looks fine: caravans = [] car = something But then along comes tab = two spaces and it looks like this: caravans = [] car = something And it just looks like a mess. Of course, I personally hate that lining up variable declarations thing, even if everyone is using the same tab size or they use spaces to do it. What if I suddenly need to keep track of a new variable like traffic_density in that part of the code then? Does everything need to be reindented, leading to a large reduction in the usefulness of tools like git blame? Or is it left there, defeating the point of any aesthetic benefit there was?
Why not?
[There's actually a very good reason for this.](http://stackoverflow.com/questions/1132941/least-astonishment-in-python-the-mutable-default-argument#answer-1145781)
Uhh, yeah... BUT WHY?..
conda by continuum.io is one of the best recent attempts i've seen to improve in that field. but then again, that's a different solution...
Lol, I think part it's the same reason (at least partial) of why Ruby is so awesome at times.
Supported on ios, android platform
...youre right. I read that comment as an answer to 'make building a stand alone executable part of the spec'. my bad. ... but I stand by my comment. pyinstaller and py2exe *are* shit. *shrug*
No I mean reversed("This sucks") unless there's an explicit reason to not use an iterator.
One really simple one [ast.literal_eval](http://docs.python.org/3/library/ast.html#ast.literal_eval) should support things like OrderedDict. Maybe a new function as new types in the standard library are not actual literals.
https://mail.python.org/pipermail/python-list/2013-November/660401.html
Functions are so much more than just an instrument for reuse. They're also a way to abstract code, to make it more readable even if a function is used in only one place in the code at some point.
You might be interested in [PyContracts](http://andreacensi.github.io/contracts/).
Great point. Using the get-&gt;save method is dangerous. If some other process were to update that record between the .get() and the .save(), you would be overwriting changes. filter-&gt;update is the only safe way. 
&gt;In no particular order, assertions should be used for: &gt; &gt;* checking contracts (e.g. pre-conditions and post-conditions);
Whilst it is tempted just to take the 100 I'll feel bad If I didn't atleast point out [what a google search can](http://docs.python.org/2/library/csv.html)
I hate the new bytes class in python3. I do a lot of protocol stuff with pyserial and it irks me that i can't use string formatting anymore. Another thing: b'amstan'[0]!=b'a' , it returns ord('a') instead, wtf???
Google helpouts is there for the very same purpose 
Be tempted! While I'm familiar to C syntax, Python is proving a challenge. What I'm looking for is not just limited to reading in, but also the for loop manipulation. If you're interested in helping, please shoot me a PM.
Anyway you can post the script so we can take a look?
Good point, and readability is another reason for using lambdas. If you define a function only to use it as a callback, you're letting the reader of the code ask "where else is used this code? How important this function is? What impact would have changing it?", while the truth is that you're writing a throw-away function to feed the call (specialize) a subsequent function call.
Piping isn't nearly as easy as far as I know.
Not if you name the function correctly. It's as easy as naming the function "blaa_callback".
Post the requirement - this isn't a difficult ask. Here's a codesnap to get you going. import csv csvoutputfile=open("output.csv","wb") with open("test.csv", "rb") as csvinputfile: reader= csv.reader(csvinputfile, delimiter=",") writer= csv.writer(csvoutputfile, delimiter=",") for row in reader: #handle the processing here, each row will be an array of columns #in the csv file #row is a list of columns that can be manipulated as you see fit #save the processed data to a new list writer.writerow(row) What you need to do now is write the part that processes "row" in between the comments right before writer.writerow(row). All this snipped does is read in the first csv file and write it to the second. 
Now, python has these types: ('a',) - tuple {'a': 1} - dict {'a'} - set So new, lambda type, would use similar technique as dict. Dict is distinguished from set only by use of colon, so tuple can be distinguished from lambda using same principle, by adding colon: f = (x: x*2) For multi line lambdas, same principle as for all python blocks would be used: def f(x): x = x*2 return x f = (x: x = x*2 x ) f = (x: x = x*2; x) l = map((x: x*2), [1, 2, 3]) I'm not sure, but maybe it is even possible to remove parentheses: f = x: x*2 l = map(x: x*2, [1, 2, 3]) multiline = x: x = x*2 x
.os yas uoy fI
As a Python noob... I know everyone hates them, but a goto command would be fun.
Get rid of the entire 2.x version branch. I can't deal with the uncertainty of which one will win, 2.x or 3.x? This has been going on too long.
Ugh. Much less elegant than: repeat: read_stuff() do_stuff() until end_of_stuff() Voilà. Explicit! Elegant! Beautiful! Excellent! Kitchen sink!
I would go back in time and never release Python 2.7 so that adoption of Python 3 would be further along by now. I also would add various protocol handlers to the standard libs: * LDAP * Kerberos * SSH/SFTP I would also like the following in the standard library: * Encryption module like M2Crypto. * A module to handle plugins or at least a standard/easier way to handle plugins. I'll probably edit this to add more later.
Doesn't work in Windows. You need Ctrl-Z.
That only works if the target systems have internet access. It's a pretty common situation in large enterprises where the web proxies require authentication (and you're not allowed to hard-code credentials).
To make Python a little more like Pascal, I guess.
For Windows accessibility, you could try py2exe. It will make it into an executable file. [Here's a short tutorial](http://www.youtube.com/watch?v=k3VoLjGA6jI&amp;list=PLQVvvaa0QuDfhTF3Zfyzc_yD-Mq9iTp4G). 
I'd add the abilities for compiling and code optimization.
That's correct.
No mainloops available?
I think you can just use subprocess.check_output with the shell=True passed as an arg: From shell: caraboga@carabogaws-linux:~$ ls -la | wc -l 143 From ipython: In [11]: import subprocess In [12]: status=subprocess.check_output("ls -la | wc -l", shell=True) In [13]: print status 143 
They implemented serialising of DateTime objects, but not for DateTimeZone objects. If you set a time zone to a DateTime object and then serialise and unserialise it, the interpreter seg faults. I think they fixed in in 5.4, but tracking that bug down was weird. It is not something that I expect to cause a seg fault. It came up when I added a DateTime attribute to a model that was cached and crashed our server.
Somehow make scipy and scikits work on Android and have interface with kivy Have a BSD standardize library for time that comes with python and make all of these following libraries obsolete: datetime, time, calendar, dateutil, and pytz (I know arrow can do this but it is not BSD) Faster looping so we do not have to covert everything to cython for speed. Better multiprocessing capabilities than threading and multiprocessing. The name of the function "lamda" to something else so people will stop asking what lamda is
&gt; I agree with /u/Kamikai , using the keys as variable names is just asking for a bad time, and allowing it as default behavior would be quite dangerous. That would be PHPonic… 
... on UNIX. Hash bangs aren't supported on Windows. File extensions should serve the same purpose though, so make sure to call it `something.py`. That still doesn't solve your problem on Windows of having the python interpreter available. That puts you back in `py2exe` territory for simplicity.
how?
Here's a book chapter I wrote on this: http://www.aharrisbooks.net/pythonGame/Appendix_C.pdf (Based on game programming examples, but suitable for any Windows installation.)
What differences are there in Erlang between the core and the REPL? Named funs just dropped, for R17. What else was there?
Go to python.org or ActiveState and download it from there. Technically, it ships with IDLE, but that's probably not really much of an IDE.
On the command line simply "python myfile.py" believe it's python.exe on Windows Oops stupid iPhone app did a new comment rather than a reply. 
It's either "my bad" *or* "I stand by my comment". "I was wrong but I was right anyway" is pretty shabby.
I was intrigued when I first read about Julia (seems good for things like data analysis), but haven't yet gotten around to playing with it. How do you like it?
And all it takes to break *everything* is to do `sudo rm -rf /*`. If someone uses your functions incorrectly AND skips all contract checks by using `-O` (that's literally the only thing `-O` does, by the way), that's totally their problem.
.app is a package format. That might be all you need.
No, I mean it needs a complete reworking of the grammar, because if you're inside parentheses (`(`, `[` or `{`), it all counts as a single line and no `INDENT`, `DEDENT` or `NEWLINE` tokens are generated. Adding support for expressions that contain multiple statements like that would mean the language would be something completely different &amp;mdash; because other parts of the language need to be changed too, to prevent conflicts and to get back consistency. Whatever language you'd end up with, it would no longer be Python. The "single expression" variant of your lambda could still work, but there the big improvement isn't clear: all you did was remove the `lambda` keyword and, well, explicit is better than implicit.
Whoops, right you are! Fixed!
Yes, of course you're right! I wrote my comment in response to the fact that most (if not all) desktop Linux distros ship with Python -- same for OSX.
My reasoning is if you have no need for embedded Javascript in PDF or other fun things that Reader supports you're better off with a different PDF viewer because nearly all the other ones are faster and don't take up as much screen space.
Fucking awesome. It's cool and easy to learn like python, more pragmatic and functional, and FAST. Another awesome aspect of it, is that most of the language is written in Julia itself, so you take a look at how everything works and change it or extend it without having to touch C. It is very young though, so there are not too many libraries yet, but you can interact fairly simply with python and R if you need to. 
Python should have some defined subset of functionality that could be easily compiled. A python version of rust. We need a safe and readable version of "c" that interfaces with python. "C"obra? http://cobra-language.com/ Just wish it wasn't mono/net. 
Frankly it seems like Vaporware to me, such a shame if it worked like they are claiming it would be amazing to have.
csv
Add it to package control. There's already one for the same task though. 
The way I remember it is that a "which interpreter" line is a valid Python comment.
For simpler dealing with scoping without global and nonlocal keywords.
Has nothing to do with pascal. Pascal uses := for assignments, not for declaration.
please elaborate : "registrates the time..." It sound like you want py code to *search* the worksheet by the employee number and when found, "writes to the correct cell defined by date", is that about it ?
if you're assigning to global variables you're *usually* doing it wrong.
eww
The entire point of Python 3 is that it provides potentially legacy-code-breaking improvements. That's semantic versioning. The whole point of the new version is that it's an improvement, which requires differences. So, how would you solve the problem?...
Looks like something that -- even if it existed -- would work incredibly badly.
If it worked like it said I find it hard to believe no one knows about it. 
It's valid, but generally not used. a() should probably take an argument that modifies b(), but something like that would be used in functional programming, so map/filter/reduce-type operations instead of a lambda. It also limits scope, but I have found legitimate uses for it only in a map/filter/reduce or decorator context..
I love wakari since I learned about it at PyData NYC. That's excellent work and service.
That's not a hack. That's what dictionaries are for.
That won't be faster unless the expression is wrong.
Yep!
It would be a very expensive thing to achieve, but it could be done. Remember that every Python script is either translated to its equivalent in C (CPython) or Java (Jython)
Pip installs into whichever environment that it is installed in. This is sound design. Node treats the virtual env usecase as it's default, so that's why npm works so well. Python is just bad at hosting multiple projects, and virtualenv is a back to get around Python being bad.
Get rid of lambdas. They aren't useful in Python.
no worries. just found it in docs.
PEP8 says USE LOWERCASE MODULE NAMES. Stop doing this: 'from datetime import datetime' Do this: 'import datetime' Honestly, just get rid of the 'from' keyword.
That defeats the entire point of Py3.x 2.7 was there for what you want. People didn't care. Now they're mad at Python because they didn't pay attention.
The old syntax should die , but it should be optional and die properly. How? Implicit parens on all function calls. That's how.
I'm not so sure. To name a function which in its nature is lambda-like, could worsen readability in more than one way: Unnecessarily verbose, could lead to a bad function name (say "_tmp_func") and implies to the reader that its purpose is something other (more) than lambda-like. 
You could also create an installer with something like NSIS.... http://nsis.sourceforge.net/Main_Page or Inno Setup.... http://www.jrsoftware.org/isinfo.php that installs your program and the python interpreter with it, creates a start menu entry, offers an uninstallation option, etc. 
One reason it may be done less often than expected is that a lot of programmers could be coming to Python from languages like Java, C#, C or C++ which don't offer nested functions, so the programmer may simply not be used to thinking of solutions that incorporate them. We old school folks who first learned to program in Pascal however find them second nature. ;-) Javascript also has nested functions. 
Overloading Python classes for code generation ... we've all been there. It won't work very well. It will work well enough to crank out prototype mobile code. The problem is, it works much better for the people who wrote it, because they know where to hit it with a mallet when it starts misbehaving. 
You can save your money and just post your problem (making sure to post any code you've already written) to Stack Overflow: http://stackoverflow.com/ You'll get many answers to your question and quickly. 
Post what you are trying to do, and people will explain it for free. You might get a few down votes, but not $100 worth (unless you *really* value reddit karma highly). 
So, Pyramid vs. Rails...?
ah nice - that sounds like a little time bomb (pardon the pun!) waiting to go off!
&gt; Remember that every Python script is either translated to its equivalent in C (CPython) or Java (Jython) I'm pretty sure that CPython is an interpreter written in C, not a compiler from Python to C.
Whats a decorator function? And what use is a nested function? I learned java first and am trying to teach myself Python; this stuff seems quite pointless to me tbh
Yeah. You should definitely post the requirements. I'd love to have some different challenge to solve.
I have accomplished this many times using Numpy. Specifically numpy.genfromtext and numpy.savetext. The former will write your csv to an array and allow you to work with the data using headers if desired. The latter can be used to write the new array to a csv. To write the headers to a new csv, assuming that's desired, you will need to read the headers using csv.reader, write them to a new csv, and use numpy.savetext to save the output array to that csv. There are likely many ways to accomplish the same thing, but this process has always worked for me.
When you move away from simple programs like helloworld or text based adventures and start working on million line software projects, these things may be useful.
&gt;Look at the Python "class"- Python classes don't look anything like that. First of all, so what? It's just a demonstrative image. Second of all, there's nothing syntactically wrong with it, so it totally could be a Python class, so I don't see what you think is wrong with it. At worst it's just poorly designed; at best it's a contrived example to show that type inference can be done and the correct types shown in the Objective-C and Java examples.
It doesn't seem to be publicly available, so that's not surprising at all. As far as I can tell they've only used it for their own apps. Presumably they're just setting up this website now for future use.
I think you are saying *what it is* and *how does it do it* rather than *what it does*. CPython works on top of GCC. I know it is not human-readable C code, but the output is like a C program. Or at least that is what I understand, I may be wrong!
It's not the python runtime that's a problem, it's your project's library dependencies. If you import numpy or pyqt, getting those onto someone else's machine isn't simple.
Right, so tell me which central repository should I use to deploy my Python app to tens of thousands of Linux, Solaris, AIX, and HP-UX servers? Just curious how you'd handle that... I have to deal with that exact problem pretty much every day at work, hah. Oh, and for various reasons (regulatory and idiotic) many environments can't talk to each other or the Internet. Fun fun! BTW: On rare occasions I have to target Windows too! 
You are definitely very wrong. CPython is a python interpreter that happens to be written in C. It "compiles" python code to byte code, which what you see when you find those *.pyc files. It's not C or machine code.
Thanks!
You managed to avoid actually answering my question lol What is a decorator function? What use is a nested function? Just telling me they might be useful doesn't tell me why
Nope. Old-style classes still set instance variables in `__init__`.
Nice,would be nice if it worked from version 2
[Be vewy vewy quiet. I appwying pure functions to wabbits. Heh heh heh heh heh!](https://www.youtube.com/watch?v=BHASAFG76B8)
Those things in the Python code are class-scope, not instance. They're equivalent to `static` class members in other languages. The Objective C and Java examples *aren't* the correct types, unless this tool is supposed to take class members in Python to mean instance members in other languages; in that case, what's the point? You're no longer writing Python, just using the syntax to write something that looks LIKE Python but maps more easily to other languages, in which case you might as well use the target language.
Not CPython as far as I'm aware, but I wouldn't be surprised if Psyco/PyPy do that optimization. It's actually a very infrequently used optimization anyway. You need a minimum of 4 "equals" conditionals against the same integer variable for it to be faster than doing branches on x86. [Duff's device](http://en.wikipedia.org/wiki/Duff%27s_device) is one of the very few cases in I've found where jump tables actually make a noticeable impact on performance.
Other good HTML preprocessors: * [PyHAML](https://github.com/mikeboers/PyHAML) * [Plim](https://github.com/avanov/Plim) (like Ruby's Slim) * [PyJade](https://github.com/SyrusAkbary/pyjade)
I don't get all of the downvotes for this submission. Who downvotes someone for asking a question? Did none of you downvoters ask questions when you were learning? Anyway, here, have an upvote from me. I'm sorry I don't have an answer to your question, but I have been looking into packaging and releasing stuff lately, and so was interested in the replies to this question (even if it is a bit misinformed/ignorant). Everyone is ignorant in the beginning. I am still pretty ignorant myself. And next time, you might want to ask Python related questions in /r/learnpython/ instead. You will probably get more help and less downvotes there.
Definitely wrong. For comparison, Look at [Cython](http://cython.org/) or [Shedskin](https://code.google.com/p/shedskin/) which actually compile Python to C and C++ respectively. 
Thanks for these links! Those languages don't provide Django-specific syntax, do they? Shpaml does.
Use the csv module that comes with the Python standard library, or use the csvkit module: http://csvkit.readthedocs.org/en/latest/api/csvkit.html 
It would be nice to actually _have_ such a thorough technical demonstration, especially with how vaporwary their product currently seems to be.
are you asking my impression of the 2? As I understand it(and I could be wrong) pyramid would align more closely with rack at least in philosophies. And I would guess that as far as ruby goes, I would probably prefer rack over rails just like I prefer pyramid over django. Mainly for the same reason that I usually end up fighting way too hard to get django and presumably rails to do what I need them to because the framework is in your way at every step. though I have not experienced this yet with rails I'm just assuming it's going to happen. Is that the info you were looking for?
Yeah you're right - pretty much what I want. I like how it can be as dynamic or as static as you want. 
Some of them allow integration with Django.
It didn't last time I checked, but [cx_Freeze](http://cx-freeze.sourceforge.net/) is a similar utility that does.
Sounds like someone needs to learn timezones
Well, you don't have to do include a ton of parameters. For example: def f(x, y): def g(z): return 2*x + z return g(3 * y) + 1 Calling f(1, 2) will return 9. I think that was what you were talking about
This kind of reminds me of the [Haxe](http://haxe.org/) language, except Haxe is real. Nothing to do with Python, unfortunately.
Why wear a life jacket when you're soaring with eagles?
Thanks for clarifying!
We need a `liblib`.
Every time I take the hundred I find out that the manipulate data in a for loop part is something like "just does all my tax forms" or "solves all the riddles". 
The best use for decorators that I've used is for adding a cache to a function. Let's say you start out with this function: def fib(n): if n &lt;= 1: return 1 else: return fib(n-1) + fib(n-2) Slow as hell, right? With the fibonacci function, it's easy to turn it into a version that doesn't re-calculate entries a lot, but let's pretend that this is one of those functions where it's a lot harder to do that. What we want is to be able to remember previously-calculated results, so any recursive calls that have already been calculated can be skipped. So we can modify it like this: fib_cache = dict() # empty associative array def cached_fib(n): if n not in fib_cache: if n &lt;= 1: fib_cache[n] = 1 else: fib_cache[n] = cached_fib(n-1) + cached_fib(n-2) return fib_cache[n] Now you have a cache storing all previously-calculated results. But you're also mixing the "calculating the results" part of the function with the "caching shit" part. You can separate out the caching behavior like this: def make_cached(f): cache = dict() def cached_function(arg): # There's syntax to let you use any arguments, but for simplicity let's pretend there's always one. if arg not in cache: cache[arg] = f(arg) return cache[arg] return cached_function # NOT cached_function() Now you have a function that takes a function and returns a function that has different behavior. You can use it like this: cached_fib = make_cached(fib) cached_fib(100) Python has special syntax that you can use for functions that modify functions, called "decorators": @make_cached def whatever: # stuff This works the same as: def whatever: #stuff whatever = make_cached(whatever)
Yuck! You should write code like: if ball.is_yellow(): primes = get_primes()
Use kivy instead. Its real and it works.
Modifier methods like .append() returning the container, instead of None. It would be easier to chain operations.
Much better, thanks!
Awesome. See, now it's not hypothetical!
The first item on the sidebar states that this is a news subreddit, and the second item states that if you are about to ask a question, try /r/learnpython. I'm guessing that's why this is downvoted.
That is true, but couldn't people just redirect him, instead of downvoting? I guess I'm just too nice for my own good. I tend to save my downvotes for real assclowns. I feel bad downvoting someone who is just asking a question, even if it *does* say, right over there on the sidebar, to *consider* posting questions in /r/learnpython. I just know how I'd feel if I got downvoted to hell for asking a question. That is never a good experience, and not very conducive to learning.
Contact your local university's IT faculty and say you would like to pay a student for help. They will know who to send you, and the student could do with the cash. Note: students also work for things other than cash, like vodka, concert tickets, the love of the game, ... 
It gets even funnier than that... say you did train e.g. a bayesian inference categorisation system to classify your information so that "superbowl" ranked highest in regards to the sporting event ... what happens when the Oakland Owls play superbly in the superbowl? 
Python is not an IDE, nor does it require an IDE.
I see where you are coming from now, my apologies. However, is that still going to be useful? Turning dictionary values into global variables still sounds insecure, and not very useful, because now you need to know them first, and have to hard code them into the program prior.
I created this SHPAML ST2 plugin a couple years ago: https://github.com/bchhun/SHPAMLPreprocessor/blob/master/readme.textile PR welcome :)
It is not turning them into global variables, it is assigning local defined variables to values in the dict. It would be useful for reducing the amount of clutter in code. It would also allow using dicts more convenient for returning multiple values from a function. I see lots of code like this: ... resp = requests.get('http://example.com/api/auth').json() user_id = resp['user_id'] auth_token = resp['auth_token'] expires_in = resp['expires_in'] ... Which would become much more elegant like this: ... user_id, auth_token, expires_in = *requests.get('http://example.com/api/auth').json() ... 
...not... really? I already have experience with pyparsing and ply. Sometimes you just want to recognize patterns with a recursive structure to them. Sometimes you want a quick and dirty parser, pyparsing style, so that you can interpret the whole chunk of text but aren't too fussed about setting up a grammar. And sometimes you want something more like ply that's actually built around formal parsing theory. And sometimes you just wish that you could actually refactor that big honking regex, instead of settling for `re.VERBOSE`.
In many cases, yes. +1 for examining your requirements instead of making assumptions.
Then there are the people who think that a tab should magically mean "enough" spaces in the current context, such that a bunch of `variable&lt;tab&gt;=` lines will all always line up regardless of the length of the identifier names. Of course, it's against PEP8 to try to line things up this way in the first place, but :)
No idea, but Pythonista can generate an XCode project that compiles as a submitable iOS app. http://omz-software.com/pythonista/ It has a custom multitouch-cable graphics library and lots of other cool modules. Mind you - it's an iOS python interpreter in its own right. Development / coding happens from an iOS device. Not sure how easily you could tweak the output / continue development from a desktop with it.
Just what we need, another simplified version of html to teach the designers because it doesn't work with their tools. at least.out isn't claiming the superiority of sexprs
&gt;2) 'map', 'reduce', 'filter', and other related methods are backwards. The sequence should be the first argument - not the last. The sequence is the last argument for `map` et. al. because (a) that's how it works in the languages that those ideas come from (e.g. Haskell); (b) the description of the sequence is usually more complex (and if it isn't, you probably need to factor out the predicate); (c) `map` in particular accepts *args, so re-ordering would be counter-intuitive and make it awkward to document the function (`def map(first_sequence, *every_other_sequence_and_then_the_predicate)` - WTF?). &gt;3) There is no need for the syntax to require parenthesis for function calls. They are just annoying. Parentheses absolutely are required for function calls, especially given that tuples exist. Otherwise, how do you propose to parse `foo bar, baz quux`? &gt;4) Get rid of the requirement of a colon at the end of conditions and declarations. Explicit is better than implicit. &gt;5) Defining functions shouldn't require an argument list when empty. I should be able to simply use 'def noop: return None', and lambdas should be (quite simply) 'def: return None'. This is ignoring the wish to remove colons from #4, of course. The lambda you're talking about is already `lambda: None`. You could argue that the parentheses are redundant for `def`, but again it looks strange and has a weird implicit-ness to it. In general, putting two expressions adjacent to each other is not a thing the Python grammar (nor the grammar of any other language I can think of, although I have a design for one that's kinda built around it) does. &gt;6) The 'len' method is completely non-pythonic. Python should just expect (as an interface) that things with a length define a length property instead of defining 'len' and using some global function to get its result. This is just bad design. By defining `len` as a separate built-in, there is a place to put the common logic that ensures the result is an integer.
&gt;it irks me that i can't use string formatting anymore That's what decoding is for. If you have to "format" data, then you realistically have to care about these issues, because locales exist anyway. &gt;Another thing: b'amstan'[0]!=b'a' , it returns ord('a') instead, wtf??? `str`'s behaviour is the special case. If you want to compare a portion of a sequence to another sequence, that's what slicing is for. The elements of a `bytes` object logically are integers - the sequence itself is just a special case to optimize memory usage. If anything, it's more offensive to me that (at least as far as 3.2) `bytes` still hangs on to illogical methods like `swapcase` and `zfill` that don't deserve to be there.
This is what `collections.namedtuple` is for.
The problem is: * There are other mutable types that you could get bitten by (and situations where you might plausibly use a non-empty list as a default and still encounter the problem). * Personally, I feel like that check is a "special cases aren't special enough" wart. (Incidentally, please use `is` to compare for None.) The advice gets spread to program that way even when you could just use an immutable type (depending on context); `()` and `''` are perfectly good default values that don't get enough consideration. * You end up seriously inconveniencing people when they *don't* mean that. Granted, it's probably bad design to have use of a "shared cache" between function calls be *optional*. But when it's mandatory, you need to explicitly set it up somehow. Probably the best way is to attach an attribute to the function. That would look like: def f(a, b): # but then you still have to qualify the name :( f.c.append((a, b)) f.c = [] Or you could use a global, but, ew.
In that case, the behaviour you apparently want is spelled `locals().update(d)`. But please don't do this; "namespaces are one honking great idea", and in context, `d` is an example of a namespace.
If you have an immutable object with no methods, then sure. But what if you need something more fleshed out?
`frozendict` would be amazing for implementing a caching/memoization decorator that can handle `**kwargs`. Although really, I think I'd just like a built-in type that represents a grouping of parameters to a function call.
You can inherit from `namedtuple`, but that doesn't give you mutability, yeah. Another thing that could work is `self.__dict__.update(locals()); del self.self`. I agree that's disgusting, though. So +1 to you.
I'm a fan of lxml.html. About to try scrapy for the first time, because it sounds nice to have a framework where I mostly just write the data layer rather than the mechanics of scraping. Any favorite scrapy resources for a scrapy newb that you'd like to point me to?
B.S. is great for dirty HTML. FWIW, lxml can plug in the BS parser, so you get the awesomeness of lxml with the ability to parse really ugly stuff with BS parser. FWIW, I've never had lxml unable to parse something. It's pretty damn good.
Pythonista looks great, but I would have to buy an iPad to work with it.
I would recommend going to the NYC python meetup group's weekly office hours if you are looking for some one on one help. It's free and open to all skill levels.
...and how hard to hit it
Sure, but both new and old-style classes can use either, and the syntax is the same.
That's it. [You gotta put the right amount of pressure on it](http://www.youtube.com/watch?v=Y8i1Ddj1Sw8).
 if oBall.mbYellow(): liPrimes = fliPrimes() When I read your code, I get that ball is probarly an object, is_yellow is probarly a method returning a boolean, primes might be a list of integers or a tuple of integers. not really sure. So I would have to use time to check that. With my 'yucky' style I always know what everything is, and when you get accustomed to it, it just works. I guess we all have our diffrent ways of doing things, and probarly wont ever agree on everything because of it. 
It would have to be, or python would get confused on it (and would require a special case)
Sorry but "you can leave braces out" is not in "abstraction". And the point that it "saves keystrokes" is also nonsense because you can save much more with things like Zen-Coding.
Sometimes I wish that definition and assignment had been separated in Python. For example, when assigning an instance variable, a misspelling will define and assign a new instance variable under the misspelled name.
onbreak ?
Just have a dictionary that maps `operatingsystem` -&gt; `OperatingSystem`, etc.
multiprocessing queue size isn't reliable anyway is it? I guess if you need a rough number it could be useful. What do you need it for?
Never heard before about *vimundo* file. I then make a little Googling and found [Persist and Synchroize VIM Undo History Using Dropbox](http://jhshi.me/2013/10/02/persist-and-synchroize-vim-undo-history-using-dropbox/): " Persist undo set undofile "maximum number of changes that can be undone set undolevels=9999 "maximum number lines to save for undo on a buffer reload set undoreload=9999 " If have Dropbox installed, create a undo dir in it if isdirectory(expand("$HOME/Dropbox/")) silent !mkdir -p $HOME/Dropbox/.vimundo &gt;/dev/null 2&gt;&amp;1 set undodir=$HOME/Dropbox/.vimundo// else " Otherwise, keep them in home silent !mkdir -p $HOME/.vimundo &gt;/dev/null 2&gt;&amp;1 set undodir=$HOME/.vimundo// end This could be very helpful and make Vim sharing the editing history also across different synched machines connected to the Cloud. Old fashion style mixed to the bleeding edge cloud/ubiquitous computing. 
i think fabric is still 2.x. i may be wrong
True, Paramiko is still 2.x and thus so is Fabric: [https://github.com/paramiko/paramiko/issues/16](https://github.com/paramiko/paramiko/issues/16) edit: But it looks to be finally about to make the jump.
Twisted. 
I wonder if this will be helped by all the work Guido put into tulip becoming the new default async lib. 
That looks interesting! I'll need to check it out.
So far the best feature is to return to edit 1 and then hold redo to fast forward your coding. Play some techno in the backround for extra effect.
`flat is better than nested.`
I'm only just barely getting into Python, mostly for science/engineering, but it seems like a lot of the SciPy stack is still largely 2.7. That's at least what it seems like, though someone can correct me if I'm wrong.
**All** of the core of it is all 3 compatible. It's probably only some minor 3rd party additions that might have 2 only code. Numpy, scipy, matplotlib, ipython, pandas, sympy, scikit-learn, astropy, biopython, statsmodels: all python 3 compatible.
As far as porting goes, it just adds more work to make Twisted a good 3.x citizen, and doesn't take any away. And Tulip can't replace Twisted for a while. There are lots of people really excited about Tulip, but this is exclusively because it is shiny and new and in the stdlib.
According to [this SO thread](http://stackoverflow.com/questions/15662643/where-to-download-scipy-for-python3-3) and the [SciPy Stack Specification](http://www.scipy.org/stackspec.html#stackspec), it appears that the SciPy stack is 3.3 compatible. 
There will have to be a lot of rewriting of Twisted before that happens.
[Invoke](https://pypi.python.org/pypi/invoke/) is the python 3 compatible successor to the task-running part of Fabric. 
Thanks, that's good to know. I knew that at least some of it was compatible, but I've had issues trying to move to 3.3 figuring out which components are not compatible.
there's a backport for tulip to 2.7 though. https://pypi.python.org/pypi/trollius/
Ansible is another one, but it's justified IMO. https://github.com/ansible/ansible/issues/1409
Have you watched Guido's presntation on tulip? I thought he was basing most of his design off the twisted architecture.
Well yes obviously, however when they port to python 3.x they could use the opportunity to also port their async stuff to a standard lib. I was thinking more along the lines of "why continue to promote multiple ways of doing async when that's not really pythonic." Rather than "why doesn't twisted just use tulip?"
I don't see the point in that really. Can only continue to backport new features for so long, better to stop now and work on the tools that help devs migrate code bases then when you wish you had migrated a while ago IMO.
NLTK is still 2.7 dependent for all intents. There is an alpha for Python 3 but is for now, it is meant for people interested in helping the team find bugs. 
Sure, but that doesn't make it better. Twisted isn't just a design, it's a well-tested codebase with years of development behind it and tons of features and tools, both as part of it and in third party libraries. Making something as good as Twisted takes time, that's all. I think the fastest road forward for Tulip is porting Twisted to 3.x, personally.
I think it is because the how-to [example/documentation](http://lxml.de/parsing.html) for lxml is confusing (at least for me) and quite lacking. BeautifulSoup's on the other hand, is quite [easy](http://www.crummy.com/software/BeautifulSoup/bs4/doc/) to understand with extensive examples.
But what about systemd?
AFAIK, PIL will not get ported to Python 3, but you can use [Pillow](http://pillow.readthedocs.org/en/latest/) as a suitable replacement.
http://flask.pocoo.org/docs/python3/
Oh, well, TIL
PyQt supports Python 3 completely. At least PyQt4 did, I don't know about PyQt5.
That's a nice idea, but you could try summing the ordinals of the characters first, so cat gives the same result as act (it's like a really bad hash). Since this is a faster operation than a sort, only if the sum compares would you sort for a validation check.
Thanks, I was looking for something like this. Though wxpython (http://wxpython.org/), PyQT (http://www.riverbankcomputing.com/software/pyqt/intro), and Matplotlib (http://matplotlib.org/users/whats_new.html#python-3-x-support) do seem to support 3.0 
Pillow is a drop in replacement for PIL and works fine in Python 3.
Hi, service-mgr is not about replacing any of the existing (or future to come service managers, such as systemd) -- it is about to provide a way to manage services on your systems remotely by using what is already available. service-mgr talks to the local service manager (e.g. service(8), systemd, etc.) on the system and provides an abstraction layer for managing services on various UNIX/Linux flavours. systemd is not going to appear on the BSDs.. with service-mgr you can manage a cluster of UNIX/Linux systems, whether they run Linux or BSD by interacting with the local service managers. service-mgr uses ZeroMQ as the messaging layer in order to communicate to nodes in a cluster and allows for grouping of nodes based on certain characteristics, e.g. Operating System of nodes, version, etc. By doing that you can asynchronously manage a cluster of nodes by sending a message with specific topic you are interested, e.g. stop SSH on all FreeBSD systems, but enable it on all Linux systems. Please check the README at the Github repository, which also contains some examples on how to manage services on your nodes with service-mgr. Let me know if you have any questions or need more information. Regards, Marin
Because your end could be the same of Icarus?
 &gt;&gt;&gt; import random, string &gt;&gt;&gt; chars = string.ascii_letters + string.digits + '~!@#$%^&amp;*()_+' &gt;&gt;&gt; ''.join(random.choice(chars) for _ in range(20)) 'JXVQoL!2fxRYuu@6(7!m' 
`Namespaces are one honking great idea -- let's do more of those!`
Oh wow.. schooled. Is that a string comprehension? I did not know that was a thing. Thanks
It's a generator expression, but a list comprehension would work just as well: ''.join([random.choice(chars) for _ in range(20)]) Generator expressions are enclosed in parentheses: (random.choice(chars) for _ in range(20)) But if a generator expression is passed as a single parameter (like here to `join`), the parentheses can be omitted. Generator expressions don't allocate the entire list at once, but generate values as they are needed, saving memory. In this particular case it doesn't matter much, just looks cleaner. The important thing here is the `join` method. Another tip: want letters to be more common? Include more of them in the character pool! chars = string.ascii_letters * 2 + string.digits + '~!@#$%^&amp;*()_+' 
Pandas is probably a better way to go. Easier to read, iterate, and write.
No, it won't. Where did I agree with that?
I use python to develop at my job and found pycharm a few months ago. It just keeps getting better. I use it in an ubuntu environment for multiple projects at the same time and I have no complaints. I've been trying to get everyone at work to use it.
If a list or tuple can contain different kinds of variables, I call it tSomething I actually don't know what a types.CodeType is. And haven't given iterators or generators any specific thoughts yet. This is just something I've made up myself, I've been using it a long time, I do follow most of the pep rules.
I disagree with this: "the PYPL Popularity of Programming Language index can help you decide which language to study, or which one to use in a new software project" i mean you learn a language because you enjoy it not because its becoming popular. Appart for that thx for sharing :)
She's a keeper! :)
Double curious here... how does this improve on a pretty supported &amp; standardized community &amp; corporate library? Is it simply DAO usage and syntax preferences?
Are a twisted Dev or have you worked extensively with the twisted source?
No and yes respectively. Are you? All my conversations with the Twisted developers indicated that they don't care about Tulip and it won't motivate them to move. I had to cajole them to even talk to GvR about Tulip at all. The porting difficulties they've complained about that I've seen aren't anything Tulip resolves; in fact, I don't see how Tulip could help at all, given that Twisted would retain its own event loop and deferreds. So if it's neither motivating nor technically useful, I don't see how it helps speed things along. *(Edit: typo)*
You're pretty good at one-handed cooking, OP!
For some--many?--people (even programmers) relation-to-popularity is a strong component of enjoyment. If, moreover, we re-label it "community support", I think the legitimate role of popularity in engineering decisions becomes evident.
Get rid of **else** in **for** and **while** loops. It does not make sense in a literal way. Also, I think it goes against the zen of python which states that explicit is better than implicit. If you need to know if a break occurs in a loop, a explicit flag is better than *for else* in my opinion.
At first I thought "that's a weird pic for /r/food". Then I realized what subreddit I was looking at :)
You wouldn't happen to be in Champaign-Urbana? I know there are some 3d printed Python cookie cutters that looked very similar that were floating around recently making cookies for [Py-CU](http://py-cu.github.io/). Edit: [Picture](http://i.imgur.com/ArDu91D.jpg) I saw of said cookie cutters, for reference
Making a game with Tkinter is possible, but foolish. Installing Pygame or PySDL2 or Bacon or... something, would be best. - http://pysdl2.readthedocs.org/en/latest/ - http://bacon.readthedocs.org/en/latest/
Thanks for the doc libraries, but I'm still wondering if one could summarize why these packages are necessary, python doesn't come with standard GUI/sound modules or event modules?
I'm not, just curious because you seem to know a lot more about this situation than most and I'm learning from it.
She's a class of her own
The cookie cutter was 3D printed by my GF at her work. She works at a company that builds 3D printers. I believe it was the same model you posted :).
That's right. It comes with a GUI library, which can do graphics a little and keyboard/etc. events, but isn't a good idea for games.
Unfortunately there do not exist many "standard modules". Tulip may help in the future as a proposed standard event module, but I don't know of any plans for standard gui/sound stuff
I really like WingIDE, but I do scientific programming and couldn't care less about Django and Ninja (even though Wing supports them). That seems to be the community that likes PyCharm. The debugger, introspection, and searching in Wing is worth all of it's supposed quirks, which honestly I've never seen. It definitely isn't the resource hog that PyCharm is. It's not like I have a stake in either one. I get both pro versions for free because I'm an open source developer.
Great, this sub has now hit /r/gaming level.
Yes I realize that, I was mostly showing how to copy the new feature of Process Explorer: https://technet.microsoft.com/en-us/sysinternals/bb896653 This is just a very fast way to see any obvious viruses or malware that might be hiding away!
This is how you find anagrams from collections import defaultdict def sort_word(w): return ''.join(sorted(w)) def build_mapping(fn): mapping = defaultdict(list) with open(fn) as f: for line in f: word = line.rstrip() mapping[sort_word(word)].append(word) return mapping def anagrams(mapping, w): return mapping.get(sort_word(w), []) if __name__ == "__main__": mapping = build_mapping("/usr/share/dict/words") print(anagrams(mapping, "heros")) 
All crappily and in more complex ways than is necessary.
Because no one ported Python (Numpy, scipy, scikits) to mobile chips. Numpy is a wrapper around LAPACK and BLAS which is written in FORTRAN. I do not think these are available for android ( ARM architecture).
dang never noticed that one, TIL
import her
my philosophy is this http://paulgraham.com/pypar.html. not saying is right or wrong its my approach
Atleast you can change what type she is.
Kivy's python-for-android project actually does have a numpy recipe, though I haven't tried it. Regardless, as has been said, the difficulty with those particular libraries is compiling their C and fortran components for arm. Pure python modules tend to work fine. Even ignoring this, python isn't a first class citizen because the operating system is designed around apis in other languages - in android's case, java. You can compile and run a python interpreter, but it can't act as an 'app' without following the particular rules and standards imposed by the system, including communicating with its java (and maybe C/C++) apis. Kivy manages this via a java bootstrap app that displays kivy's opengl output and passes input through - it's still a python interpreter running the internal logic, but it's able to operate as a normal app as far as the os is concerned. Kivy's pyjnius project also allows direct python communication with the java apis, which is neat. You can run a standalone interpreter in other ways, but I don't know about the details of how projects like sl4a manage it.
You should not change her type. We are using Python. Use her interface directly and catch any exceptions if you want to be sure.
I've been working with inherited code at work recently. The latest bit of "why the hell won't this work?" fun I had involved datetime not converting dates from text into the datetime object properly. But it was very insidious because it wasn't actually throwing an error, it was just converting any date to being in 2014. (It was causing errors to be thrown elsewhere, though, because this garbling of the date was inducing errors in a date comparison going on somewhere else.) When I redid it...using largely the same commands...it worked properly all of a sudden. What the fuck, datetime. 
wxPython supports it through its "Project Phoenix" branch, which, last I saw, is not 100% done. It is usable for production code, but not all widgets are included yet (such as the wx.lib ones). (Just to be clear, if you are using wxPython 3.0, that is not meant to indicate Python 3.x; I think most are still on wxPython 2.9.x; I actually do fine still with 2.8.x)
I was about to ask what it was when I looked at the header of this page.
Plenty fair. Part of the amusement in this area is that, since August 2004, when Graham published that, Python has *become* a mainstream language, at least in the terms of the article.
About as reliable as `queue.empty`, which is... not that reliable. However, its accuracy was good enough for my purposes. I just needed a ball park snapshot so I could determine how close or far away the input stream was from blocking. 
between shit like this, and misplaced newb questions, and the plethora of articles/questions about web scraping, and those "much seo" articles listing a bunch of random libs that someone found useful doing some simple task.... this sub reddit is really starting to suck. 
At work I recently inherited some code littered with lambdas. Both I and the other programmer on this are aghast at what this has done to the readability of the code. Lamdas are great...until you have to hand off your code. 
Or just stick a comment in the function definition saying that it only ever gets used in one spot. 
&gt; A big thank you to the developers (JetBrains) for providing this tool for free to the Python community (and the wonderful language that is Python). Not to take away from your thank you, but I feel the "Python community" also includes those who, due to using it for *non*-free-and-open-source-work would be required to use the non-free version of PyCharm as per their licensing, so let's not leave that part out, right? 
I just came across [pythran](https://github.com/serge-sans-paille/pythran), which is another numba/parakeet style automatic compiler.
You can do something similar with ipython: https://github.com/ivanov/vim-ipython
&gt; What's wrong with web scraping. nothing, it's just a boring solved problem that doesn't warrant articles/questions on the front page IMO. 
As far as I could tell a few months ago, PIL is a dead project and hasn't been updated since something like 2009. That alone seems like a good reason to stop using PIL. 
Yes. Wherever you have a PIL dependency, you can install Pillow instead. Same imports, same API. 
Numpy/Scipy officially support python 3, but some suggested distributions (like pythonxy) still only support 2.7, furthermore there are likely countless extra libraries you'll find in your day-to-day that have a scipy/numpy dependency and were written for 2.x
This is only tangentially related, but there is an ongoing (recently funded) [kickstarter for a guy writing a python-esque language for microcontrollers](https://www.kickstarter.com/projects/214379695/micro-python-python-for-microcontrollers). It has a specific board for it as well, but it's a step in the chip-functional direction.
my pep8 linter would have a field day
Someone spent time doing this?
PyQt5 is both Py2 and Py3 compatible.
i thought exactly the same.
Raspberry Pi has an ARM processor. The same conditions apply.
i think mysql is fine with 3.x i remember using it for a project i abandoned. not sure if its the official library or a fork but im sure you can get it done with 3.x somehow
Reminded me of this: http://news.bbcimg.co.uk/media/images/62450000/jpg/_62450357_restoredfresco.jpg
Always use spam and eggs instead of foo and bar. 
return end_of_puns
Finally somebody fixes Python. Python can be very frustrating if you bounce between it and the C style languages often. Plus Python is a cut and paste nightmare. 
I see. Good luck!
Oops, Thanks for the correction Raspberry Pi has a python UI (I think)
The reason I use python was to get away from that stuff. Why would someone spend time to make something like this? unless they love fixing missing braces on debugging
postgres + SQLAlchemy should be fine for persistence and aggregation. redis isn't a database. If you need to send notifications from your crawler to your webserver you can use redis pub/sub though (or zmq). If you use websockets or sock.js you can push data to the frontend as it comes in, which is easily supported by nvd3.
[girlfriend](http://i.imgur.com/XpWGwQq.png)
The for ... else syntax
I use Pycharm 3 and it is my favourite for Python programming so far.
Someone somewhere has the ipython notebook server running: http://www.youtube.com/watch?v=8_QJLjd5apw Qpython lists numpy as being available: http://pypi.qpython.org/index.php/qpython-libraries/ http://qpython.com/
P vs Np. The problems importance is so huge that any multiplication by the frequency of python being a part of any thoughts on the problems solution is likely to be a big number :-) 
For a "bigger picture" answer, taking your OP title literally, Python isn't very suited for mobile. Python is a very high-level language, prioritising developer effort over computing resources. This is a fundamentally bad fit for smartphones, where CPU/RAM are *extremely* limited compared to more traditional computers. In terms of the developer effort/performance trade-off, smartphones and tablets are still well on the performance-takes-priority side of the line.
Good statements. In several countries, Python *does* have a strong presence in high schools, colleges, or both. My impression of the people I encounter is that it's far more true in 2014 than it was in 2004 that certain programmers learn Python and *do* expect its knowledge will get them a job. Incidental remark: I have openings for good programmers eager to do more with Python (and also SQL, XML, ...).
 import sex ... gf = self.relations.girlfriend sex.initiate(partner=gf) TypeError: Cannot perform operation 'initiate' on type 'null'
And even from /r/python!
So don't use it?
Although some packages that require pil don't recognize pillow. I'm not sure why, maybe those packages know more about PIL internals than they ought.
Alright tough guy.. lol jk XD
Making a game with curses is certainly possible; on Unix-like platforms, curses is available as part of the standard library, and there are some curses-based games. Of course, for that type of stuff the non-builtin [libtcod](http://doryen.eptalys.net/libtcod) is better. sound/event loop .. yeah, no, not in the standard library. You could use pygame for this stuff, but I'd also encourage you to look at Kivy (particularly if you might want to port your game to Android phones). Kivy is really neat.
Does anyone know of an alternative to [Tweepy](https://github.com/tweepy/tweepy) that works with 3.x?
Sure, use it if you don't like Python.
After recently comparing the speed of JavaScript and Python, I'm curious about this question as well!
PySide, I can't find it much anymore, I know it should still be supported by Digia or Qt-Project or whoever owns Qt but it hasn't been ported to Python 3 or updated for Qt 5 yet, and it they're not hosting its own domain anymore. Edit: I know the domain's not down, but it redirects to a general wiki page on http://qt-project.org/wiki/PySide.
[PyMySQL](https://pypi.python.org/pypi/PyMySQL) currently runs on Python 2.6+ and Python 3.3+. It also runs on PyPy and IronPython. It will probably run on Jython too once they [fix their socket module](http://bugs.jython.org/issue2094). I have been using PyMySQL on Python 3 for more than 6 months now, mostly as a back-end to [peewee](https://pypi.python.org/pypi/peewee). It just works.
Yeah, it's time to unsubscribe.
Why would you do that when all you have to do is from __future__ import braces 
Py2exe is great!
Totally fail. Where is the beautiful and readable code?
Not a chance. Until now, apparently.
Some people just want to see the world burn.
wxPython. Yes I know that Phoenix exists, but my company doesn't use beta software.
&gt; Just to be clear, if you are using wxPython 3.0, that is not meant to indicate Python 3.x It's funny how people get confused by that.
 NoneType
I found out about Pillow from a bit of googling on PIL. For a while, I thought that PIL was just the import and Pillow was the package name that you added to your setup.py script. They're literally the same.
What's wrong with this? Also, what would you prefer to see?
The fact that this is a Windows-only release speaks volumes.
Instead of using gevent, can one easily replace this with nginx + uwsgi? Twisted? How does this compare with Flask-Sockets? 
I don't feel bad giving other people negative internet points, as it is the process by which I can keep relevant content where I want to see it. It seems like he still got the answer to what he asked, and learning post your questions in the correct forum - where you may get better answers - can also be a plus in the long run.
Yeah thanks a lot for this. I most certainly will. At the moment I want to work with pygame and getting a working project. Then from there I may re-write my ideas using other libraries for porting and developing on particular platforms.
Thanks for sharing this resource!
The version of python I use is whatever is the latest version of python(x,y) or Anaconda. Once those go to 3.x, then I will too. 
No, because the Flask extension that I wrote for this is based on gevent-socketio. The difference with Flask-Sockets is that I'm using SocketIO (http://socket.io) instead of the raw WebSocket protocol, so older browsers are supported by downgrading to other implementations, all transparently. See the article for a more detailed comparison.
I saw this on the DARPA open source post awhile back, maybe it'd be helpful? http://kitware.github.io/tangelo/
ex U of I'an checking in :)
&gt; A big thank you to the developers (JetBrains) for providing this tool for free to the Python community If you like it that much, you may want to consider getting the paid version.
This made me unsubscribe
This is a joke, right? I can maybe understand the braces, particularly given their utility for multi-line lambdas. But semicolons?!
The simplicity of version control in PyCharm is my favorite feature.
 from __past__ import braces
Honestly, I'm more upset by the mandatory semicolons than the braces.
Well, then it's not really websocket but socket.io that you provide then. WebSocket being just one supported transport. There are other event pub/sub kind of protocols using websocket too, like [WAMP](http://wamp.ws/) that Autobahn provides.
Yes, me too, I fucking hate when my c++ compiler reminds me about a forgotten semicolon, Why put or use it in python??? thats not pythonic... :(
Semicolons are permitted in standard CPython. Permitted, not encouraged ;) They do tend to be useful when you are shell scripting and would prefer a single call to python to be on a single line, though.
One of the best graphic libraries is often overlooked: HTML/CSS. I find it so much easier spinning up a flask and bootstrap for a ui than any other GUI.
&gt; What's wrong with this? Also, what would you prefer to see? articles about programming with python would be a good start announcements about new projects/libs that solve new problems would be nice. 
I don't expect raw power to tip the balance in favor of any contemporary language at this point.
An addendum discussing the difficulties (and work arounds to make it acutally work) of distributing applications written in pygame would be helpful as an addition to this stuff. 
I feel obliged to answer this comment. Firstly, let me say that quality of this sub is important to me. Python has been my language of choice for years and this sub has been an important source of Python-related resources. I myself contribute by posting and commenting. That being said, I posted the pic on Sunday evening (CET) as I felt it'd be fun to share Python's influence outside "the matrix". I honestly didn't expect this to gather this much attention. Hell, I expected a flood of downvotes leading to my karma going six feet under. Obviously, I was wrong.
*Blimpy*'*s*.
FWIW, I don't blame you for submitting it. i blame the people who upvoted it. if they represent a microcosm of the larger python community, I weep for the languages future. Think about it, this is probably the most popular thing on this sub so far in 2014.
&gt; I don't get all of the downvotes for this submission. there's /r/learnpython for things like this. it says so on the sidebar, and in big red letters when you submit. this sub is for news. there are plenty of other places to get help. When I'm in the mood to answer questions, I'll go to stackoverflow where there is actually a reasonable incentive for asking good questions and getting good answers. 
I completely agree. This question is more directed toward either deciding how to start a new project or deciding whether this conversion effort is worthwhile. My company ran into this a year ago when we started out and chose 2.7
The latest release in Dec now supports python 3.0 http://wxpython.org/ Edit: Seems I misinterpreted the comment on their website. wxPython seems to not be compatible. 
So, in best-case scenario we can run one-process-multicore-gevent webapp ?
I didn't downvote you, but I'm guessing someone did because mine is a real command and I'm pretty sure your's isn't. 
&gt; unless they love fixing missing braces on debugging ...What? I don't think you can call it 'debugging' if your syntax isn't even correct.
You should give it some Java code, I'm sure that would really make it go crazy
I recall that somebody was [asking for](http://stackoverflow.com/q/118643/646543) a version of Python with brace on StackOverflow -- as it turns out, they were blind, and had difficulty determining when one block ended and another began. That might be one of the few reasons why somebody might want Python with braces. But yeah, otherwise, it's sort of an odd thing to do.
tmux isn't its own shell, it's a shell "multiplexer:" Basically a shell program whose job is to launch, display and manage subshells. The shells that tmux launches and controls can be zsh or fish or whatever else you prefer. tmux essentially is like a tiling window and workspace manager for shells (and console programs like mutt and vim).
My attitude toward tmux was more or less like: "meh" until I actually tried it. Cool stuff!
Thanks, that's a good idea. I'll add that to me 'to do' list for the site. I'll probably wait until Python 3.4 comes out in March because the pip installer will change things a bit.
For that case it makes sense.
I keep meaning to play with Gevent.
It isn't. Also, people hate it when you mention votes.
Incorrect. Kivy was originally just for desktop (OSX, Linux, and Windows), and added mobile support (Android and iOS) in the last few years.
Is it me or is PyPy stagnating?
I think we might not be doing a good job communicating what we're up to. In addition to the STM and NumPyPy work we blog about regularly, we're also working on: cleanups of the source code, speed improvements for specific workloads (e.g. I've spent some time optimizing based on what I see when working on SQLAlchemy). Also, some of us are working on third party library support -- for example I'm spending a lot of time on making sure we have a great cryptography lib for PyPy (and CPython of course :P): https://cryptography.io
I see I missed a couple of updates. Congratulations on the progress :)
Not really, if you just want to learn the basics of programming, python2.7 is as good as python3. But make sure you really understand what's going on when you're programming. Python syntax is easy to master but programming concepts like iteration, conditionals, etc aren't. I struggled with iteration for quite a while before I got it.
 except Exception as e: print(e) sys.exit(1) Really ?!? This is the embodiment of bad code. It wasn't enough to discard the traceback and make everything hard to debug, you had to create a nasty side-effect too ! Please, stop writing code like that.
Why learn Python if you want to learn C++ (unless you want to learn Python as well). Sure, it'll be a *bit* tougher to get going with C++ but at least you would be working with the language you want to learn.
For the short term, no the version you learn doesn't matter at this point. The changes between Python 2 and 3 are far too minute for you to be concerned with if you're just starting. The basic constructs, concepts, and logic of programming are no different between versions. For the long term, it makes more sense to learn Python 3, if you can find a good resource. Python is an incredibly useful language to know, and it's not realistic to expect to "move on to C++" and never have a use for a higher-level language again. Thus, you might as well know the 'newer' (actually approaching 6 years old) version, as it's now fairly widely adopted.
Programming has little to do with languages or versions really. It's about solving problems with loops, data structures, conditionals and resources management. You can learn many of those things with *Learn Python The Hard Way* just fine. Now, if you want advices about career management, upcoming technologies or what's the best tools to use for a project of some kind, we can help you out as well but that is quite different from learning how to program.
&gt; I struggled with iteration **for** quite a **while** before I got it. First thing that popped into my head iteration_concepts = ["for","while","for in", "do while", "break", "continue"] for concept in iteration_concepts: understanding = False while not understanding: knowledge = research(concept) understanding = does_understand(knowledge)
Been there. The busiest times on a software project can, from the outside, look like you fell off the face of the earth. You wake up and drink a quick cup of coffee because your head is full of ideas and inspiration. You sit at the keyboard and pound away for 4 hours straight because you're [in the zone]( http://c2.com/cgi/wiki?InTheZone). Finally hunger sets in, so you grab something quick but nutritious. But while you're eating, you run into a colleague that is working on some tough problem, you start talking, and spend the afternoon working on some brilliant distraction. You spend a few hours back on your own work again, only now it's 6pm and you've got family/friends/hunger to attend to. And then you remember you were supposed to do a status update. Oh well, I'll get to it tomorrow, you say. Only you've got a great idea about how to implement the next component, so you struggle to get to sleep with your head full of ideas. You wake up, drink coffee, start coding...
That's not python. Try this from python: from __future__ import braces
How would you fix that ?
C++ is definitely "hard mode" for learning to program, but you could learn python and C, which would cover all the main concepts in C++ without most of the gotchas. That said, if you never programmed before, you probably got the idea that you need to learn C++ from thinking it's fast or lets you write games. Realistically you probably don't need to learn C++ for anything you're likely to do on your own. With no legacy code or big team to deal with, C++ isn't the best or only choice anymore.
Get rid of the useless try/except block and just let the exception propagate naturally. The user will get a proper stack trace and the opportunity to actually handle the error in a sane way, if desired. 
Is it just me or do graphical data rep tools for web sprout everywhere. http://kitware.github.io/tangelo/# http://python-nvd3.readthedocs.org/
Exciting! How usable is this at this point in production?
This sounds very interesting!
This is really cool. I've been playing with nvd3 and other javascript libraries within ipython for a while now, but I didn't consider keeping the matplotlib interface and pulling the data out of it. It's pretty easy to create an iframe with an nvd3 plot and json data in ipython. Keeping a common interface with mpl is a nice addition, but there's a lot you can do in js that's worth learning on its own. Three.js is way better than anything you can do in 3d in python for example. You can also use websockets to update the plot or send ui events back to python. I hope this library makes tweaking the javascript easier than just doing everything in js in the first place. edit: The error handling needs work. In notebook mode it just silently falls back to the matplotlib image with no indication of what's wrong.
aah, that was what i was wondering, as well. 1. JS-only sites are crap: it’s OK for web application, by why should a simple blog document need JS to even display? blogger needs fucking *loading time*! 2. dynamically reloading parts of the site while changing the URL using pushState is awesome. snappier, less traffic, and the scrolling stays the same. and all taht while bookmarking and so on still works! why was there no solution combining templates on client and server?
If you're going to be any sort of serious professional programmer you're going to need to learn more than one or two languages - probably something like 5. This is not such a big task though because [all languages are similar and do the same things](http://en.wikipedia.org/wiki/Turing_completeness) and therefore it is not hard to learn more than one. Python is great for data and web stuff, so if that interests you then you should learn it. If you want to do software development then you should probably learn C++. You should make programming a hobby that you enjoy **before** you start to think about what kind of money you can make off of it. In this sense, you should learn whatever language appeals to you the most. There will always be jobs for you if you've worked hard at it and take it seriously and have a passion for it. Also, it's quite easy to go between languages despite what people say. Each platform for the language is slightly different and you have to learn things which will help you execute the language on that platform. For example, I'm going at python for web development, so I have to learn web frameworks, database stuff, and DOM related langauges like JavaScript and CSS. My hunch is (though i've never done it before) that C++ has a lot of similar infrastructure and platform problems, and that you will have to spend an equal amount of time learning these quirks. TL;DR Learn whatever interests you, and fuck what everyone else says. If you learn one language you can learn em all. **There is no right language, there is no best language, and people who say so are morons.**
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Turing completeness**](http://en.wikipedia.org/wiki/Turing%20completeness): --- &gt; &gt;In [computability theory](http://en.wikipedia.org/wiki/Computability_theory), a system of data-manipulation rules (such as a computer's [instruction set](http://en.wikipedia.org/wiki/Instruction_set), a [programming language](http://en.wikipedia.org/wiki/Programming_language), or a [cellular automaton](http://en.wikipedia.org/wiki/Cellular_automaton)) is said to be **Turing complete** or **computationally universal** if it can be used to simulate any single-taped [Turing machine](http://en.wikipedia.org/wiki/Turing_machine). The concept is named after [Alan Turing](http://en.wikipedia.org/wiki/Alan_Turing). A classic example is [lambda calculus](http://en.wikipedia.org/wiki/Lambda_calculus). &gt;[Computability theory](http://en.wikipedia.org/wiki/Computability_theory) includes the closely related concept of [Turing equivalence](http://en.wikipedia.org/wiki/Turing_equivalence). Two computers P and Q are called Turing equivalent if P can simulate Q and Q can simulate P. Thus, a Turing-complete system is one that can simulate a Turing machine; and, per the [Church–Turing thesis](http://en.wikipedia.org/wiki/Church%E2%80%93Turing_thesis), that any real-world computer can be simulated by a Turing machine, it is Turing equivalent to a Turing machine. &gt;In colloquial usage, the terms "Turing complete" or "Turing equivalent" are used to mean that any real-world general-purpose computer or computer language can approximately simulate any other real-world general-purpose computer or computer language. The reason this is only approximate is that within the bounds of finite memory, they are only [linear bounded automaton](http://en.wikipedia.org/wiki/Linear_bounded_automaton) complete. Also, any physical computing device has a finite lifespan. In contrast, a [universal computer](http://en.wikipedia.org/wiki/Universal_computer) is defined as a device with a Turing complete instruction set, infinite memory, and an infinite lifespan. &gt; --- ^Interesting: [^Turing ^reduction](http://en.wikipedia.org/wiki/Turing_reduction) ^| [^Prolog](http://en.wikipedia.org/wiki/Prolog) ^| [^Alan ^Turing](http://en.wikipedia.org/wiki/Alan_Turing) *^\/u/legrandin ^can [^delete](http://www.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cfbttb9)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less.* ^| [^(FAQs)](http://www.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/) ^| [^flag ^a ^glitch](http://www.reddit.com/message/compose?to=/r/autowikibot&amp;subject=Glitched comment report&amp;message=What seems wrong: (optional description goes here\)%0A%0A---%0A%0AReply no. 51590:%0Ahttp://www.reddit.com/r/Python/comments/1xizay/does_it_matter_which_version_of_python_i_learn_if/cfbtt57)
2) You're mostly right here. LISP dialects use that 'map' signature (although, Haskell was a bad example) 3) you are calling foo, passing it baz as well as the result of "bar quux" as arguments. 4) The colon isn't any more explicit. It provides no actual value. It's just verbosity without reason. 5) defining the def keyword to work in the case of both lambda and normal functions would have made a lot of sense. One of the guidelines of Python is that there should be one (and only one) obvious way to perform a task. The more-flexible 'def' which I explained achieves that. Also, I wasn't actually recommending inline functions - I just wrote them that way for the sake of writing an example in a comment being difficult on an iPhone. 6) That's completely against the whole concept of duck typing anyway. If something implements an interface, it should be expected to implement it properly without worrying about a global function ensuring such. 
Sounds good. Similar in principle to bokeh ? http://bokeh.pydata.org
I will go with Bamboo which seems to fit my needs: http://bamboo.io/docs/index.html
Hahhah yeah, we'll see what happens ^__^
I have specially asked (today) the JetBrains (Germany) Sales Support for clarification on License usage for the use of the PyCharm Community Edition at work and for professional use. There reply was a clear yes, it is permitted (bearing in mind the reduced functionality versus the Professional Version and my possible upgrade in the future). I remain very impressed.
This looks higher level than bokeh.
Well, I just use xpath for most of my scraping, but sometimes bs4 is useful due to how it handles the document. But overall, I don't see much reason to switch.
And, presumably, you're still working on Py3k... right?
This website taught me alot. Thanks!
The biggest thing is it comes down to whether or not you want to reinvent the wheel. You can spend a lot of time duplicating the effort the PyGame team has already done (and probably not as well because they have been working on it for years) or you can leverage the work they have done to make things that much easier.
You don't need to get X to use Selenium, you can simply use a headless browser like PhantomJS.
You just write your `main` entry point which calls into library code. Done.
Whitespace: Good and bad. Good: Much easier to read than C or Java code. Bad: I got bit once trying to code remotely with AjaxTerm, which couldn't send TAB literals. I like Ruby's trick of ending code blocks with `end`, which looks much like Python code, without any fuss over significant whitespace. Prefix or postfix? Builtin functions are invoked like `len(obj)` and `str(obj)`, but methods are written postfix, `obj.method()`. Ruby has more emphasis on OOP, pushing builtin functions into objects, so the code is more consistent and intuitive: `obj.method`. This also helps when chaining methods together (`obj.method1.method2.method3...`). List comprehensions: Good, but nesting them looks a little weird. Again, Ruby's emphasis on postfix methods makes nesting several iterators together more consistent, readable, and intuitive. The standard Python package management system: pip (?) I believe that's accurate now. In any case, I felt there was a confusion of competing Python package managers for a while, setup_tools, eggs, manually running bare `setup.py` files. Someone would release an amazing library like SimpleCV, and it would take hours to figure out how to install. The worst time was when I tried to install pip, which had to be done semi-manually with setup_tools, which required pip in order to install **it**! By contrast, Ruby got RubyGems early on in its life, and using (and publishing!) gems is so easy it's *fun*. The official website for Python docs for the stdlib (Strings, Lists, URLs, ...) was really good in the 90's, but somehow got worse in the 2000's. Specifically, searching for documentation on `strings`, etc., would produce a results page with "String" buried under hundreds of unrelated results. "String" is a common key word, but I think that the class `String` should be prioritized in results for this reason. Does Python (v2 or v3) still come with two URL libraries, an improved one and a deprecated one? I think that was a confusing way to organize stdlibs. Better to offer new method names, print "Deprecated" warnings for old methods, and eventually drop the old methods.
Could I ask? I downloaded the pypy nightly, And I am hoping to install the numpy library to it, but I am unable to find instructions to do so. Could you point me in the right direction? Thanks.
I'm sorry, what isn't? from \_\_future\_\_ import braces is a real command you can run from a python interpreter and get a (joke) response. from \_\_past\_\_ import braces is not a real command and will only give you a generic error. Either way, I don't care what people like, I was trying to give you insight into why your comment may have been unpopular. Whether or not you care is up to you. 
It seems I am. I'll update my comment above and include it on the list. Thanks!
So far I have enjoyed PyCharm minus learning all the keyboard shortcuts. I really need to take the time to modify the shortcuts to match Sublime Text 2. I am pretty close to purchasing a professional license.
It seems that if you are doing it to learn you can use their free edition without time limitation.
A lot of the cleanups to teh codebase we've been doing are aimed at making the Py3k branch easier.
Thanks for posting that helpful clarification for me; I skipped too fast over your words "free community version" on my first reading. Yes, I've (almost) only heard good things about PyCharm. 
Similar question: http://www.reddit.com/r/Python/comments/1qnbq3/webscraping_selenium_vs_conventional_tools/#cdeq2t7
The amazing part here is you found #python helpful.
Couldn't you use Mechanize to load AJAX data and then feed the DOM into BeautifulSoup? 
All twitch.tv chat rooms are IRC and twitch is really popular
I want to be able to run my Erlang program with `escript program.erl`, `escript program.erl`, `erl --start program.erl`, and `./program.erl`. This is currently not impossible because the `erlc` compiler and associated `c()` function in the `erl` interpreter both refuse to compile any code starting with a `#!/usr/bin/env escript`-style shebang. A simple tweak to the compiler could treat this as a comment, but so far, the community has not pushed for this.
There are probably hundreds of IRC channels for OSS projects on freenode. Channels like #python are massive and great for getting help.
Anaconda lets you use python 2.6, 2.7 or 3.3.
I also do a lot of scraping. Lately I've been considering the best ways to figure out if a remote host is going to block the requests. I try to avoid hammering their servers (don't need frequent updates, so I put 5s in between requests to the same server), follow robots.txt, etc. Do you have any tips for detecting throttling or blocking?
It's very good. Since it's actually all running in a single thread, you don't (usually) have to worry about locking variables and no GIL issues. You've just got to ensure that anything that will block is Gevent-friendly, and most libraries can be Gevent-friendly through monkey patching or just by changing their imports. Periodically, there's someone on the Gevent email list asking why their long calculations aren't allowing a thread to run - well, yeah, one thread. And greenlets are cheap. 10,000 green threads? No problem!
On a mildly related doubt: What is the best approach to deploy Python 3 applications on stable Linux distributions like Debian, which ships Python 3.2? Are people developing on the latest 3.x interpreters (like 3.3) and deploying on the distro 3.2 default interpreter or compiling the latest 3.3 stable interpreter server side?
Propose the patch to the OTP team, then.
Main developer: http://www.linkedin.com/in/eranshirazi
Ah sorry, that's true. I forgot that I had issues with PhantomJS as well (also didn't render things right) so I had to use Firefox.
https://www.youtube.com/watch?v=GjjZGyYcH9E
for GIS folks, ArcGIS only supports 2.x with no indication of changing in the next v11 release
use pandas
Possibly the best deployment method would be to build with cython, taking away the need to worry about what Python interpreter may be available on the target system. This is especially useful if you also have to work with the One False OS where development is painful (particularly when you start involving numpy and similar not-just-python third-party libraries) 
Can you post the code you're using to make the array and then save it? or is there a stackexchange link, etc?
No seriously, he's not joking. I tried to learn Java after Python and just got bored. Python is so easy. If you want to learn c++ just start by learning c++. 
There's a new kid on the block called [robobrowser](https://github.com/jmcarp/robobrowser) that might be useful to you. It is built atop two excellent, battle-tested libraries: [requests](http://docs.python-requests.org/en/latest/) and [BeautifulSoup](http://www.crummy.com/software/BeautifulSoup/). It provides a simple API for basic scraping tasks, but also exposes requests' methods, so I imagine that you could use requests to fetch XHR responses and parse those as need be.
If you know XPath/XQuery well and are comfortable with it, then sure, stick to it. lxml is a great library, and chances are your code will be faster compared to using BS4. Many people just find it to be uglier and more verbose (and thus less Pythonic), plus other people reading the code who have no idea what XQuery is will probably be confused. So those are things to take into consideration. But especially if it's just a personal project, then go for it.
Can anyone find any changelog? I've been looking around and haven't found anything so far.
I don't think they've updated the main site yet.
huh ? are you implying it is not ?
http://ipython.org/ipython-doc/stable/whatsnew/github-stats-1.0.html (Yes, this could have been more obvious - sorry)
Thanks! I "think" in XPath/XQuery, so I have to "translate" everything to BS. It just makes things more confusing. Its less "Pythonic", but it makes it easier when I want to use another language (XSLT in this case). Again, thanks!
It sounds like the simplest strategy, if compatibility is a worry for you, would be to build and test on the earliest version of Python you support. You can also use `virtualenv` for more complicated version hackery.
I'm not sure what you want, but maybe basemap can help you. [Here are some examples](http://matplotlib.org/basemap/users/examples.html) of what can be done with it.
Docker! Build the whole dependencies inside Linux container.
 &gt;On a mildly related doubt: What is the best approach to deploy Python 3 applications on stable Linux distributions like Debian, which ships Python 3.2? Upgrade to the latest Python if you have control of that server. If you don't have control then develop with 3.2. In any event I really don't think much of a distro that ships with 3.2. As far as I'm concerned Python didn't become solid until the 3.3 release. Not that the versions before 3.3 weren't good just that it took them awhile to iron everything out. &gt;Are people developing on the latest 3.x interpreters (like 3.3) and deploying on the distro 3.2 default interpreter or compiling the latest 3.3 stable interpreter server side? Luckily I don't "deploy" so much as develop on one machine. This isn't web related. However does it really make sense to develop on a new version of Python and expect everything to work on an older version? 
Quick question - is this something that's totally 100% one off, or is it something you could use - say - puppet or chef to accomplish? I'm a fan of paramiko, I'd check that out. 
No trouble, thanks for the link and the work as always.
I like virtualenv, although for production I don't know if I would recommend it. We just have dev vm images (and investigating vagrant) that mirror production environment, and good continuous integration that catches any problems early.
To the ipython team - thanks for the effort! IPython isn't something I've adopted to yet, frankly I'm not even sure it is right for me. However I do admire the system and could see myself getting more involved. I see this suite as fresh innovation that causes people to think different. 
ansible would probably do the job if you prefer a declarative style via yaml files. modules(plugins) are written in python so you could probably make it do whatever you need. Also on the timeout thing. If you are talking about avoiding the broken pipe issue, I found that throwing this in your ~/.ssh/config on your client machine fixes that. ServerAliveInterval 120 
I hope 2.0 isn't far behind!
Been looking forward to PEP 405 and 414. 
I don't find the announcement in ipython official website
it's a pic of a tattoo hosted on facebook. I'd rather see posts about cookie cutters on imgur. -1
you are kind of vague about the format, if it's free form you may need nltk. if it also needs to parse through html, you will likely need beautifulsoup or similar. once you have the data pulled out and into some normalized structure, then use pandas
I hope they dont' do that. I don't particularly like SqlAlchemy, at least not compared to Djano ORM
so you don't like identity maps?
Must we have this fight *every* time Django is brought up?
and how is this a "fight"? 
Getting rid of the GIL and adding STM support (without breaking what's already there) are two of the hardest problems I can think of in core Python. Kudos to these guys for taking the measured approach. I'm impressed they're willing to throw out what must be some deep-thought-out code and start all over until they get it right.
Any estimated release date for 3.4?
&gt; I really don't think much of a distro that ships with 3.2 That would cut out every major Linux server platform, if you are talking about default version. CentOS, RedHat, Fedora, Ubuntu, Debian, SUSE, etc as they are all still on 2.7. Some of these do support side-by-side Python 3 install, but I don't know how many are 3.3. Large applications are usually deployed to well known stable platforms.
I usually do exponential backoff on retries. The problem is that different sites are going to implement blocking and throttling in different ways. And surprisingly few people will put their policy into their robots.txt (if you want bots to wait between requests that's where you tell them that...) for every site that implements blocking w/ 403 errors ( IMHO opinion the correct way to say fuck off ) there are dozens that will just drop in a firewall rule. Which doesn't work too well against anyone who is doing it for work because VPS are cheap. That said, I feel really bad if I cause a site to fall over because I'm trying to get it's database ( this has happened a few times ). Generally speaking; respect the robots.txt, back off exponentially for errors ( 500s and 404s ) and just accept 403s. If you get more than two network failures (couldn't connect, site unavailable, no route to host) then assume it's being blocked at the firewall and act accordingly (put it on the list to be rescanned by another host ); and if you are being a jerk, set the rescan to use a deceptively non-bot User-Agent string ( IE8-Safari-24.3,like-mozilla:not-a-bot-really rather than ShopComparisonBot-Version-6) so that the opposing sysadmin doesn't get too happy with his iptables sixgun. Also remember that just because someone is making information available to the internet doesn't give you or your employer an automatic right to that data for any given purpose; you still need to be careful of what your rights and responsibilities are ( although the law is very fuzzy in this area; you can generally read and report as fact information made publicly available; but you can't copy or republish the expression of that information; so recording a price is OK, but providing a screenshot of the page it came from may not be...) 
&gt; so you don't like identity maps? I don't like SqlAlchmey's declarative api nor their query methods. 
This is a pretty broad and deep topic; and there are a lot of tools for doing [GIS](/r/gis) work in python. You cover three topics in your question: 1. Geocoding (turning addresses into coordinate pairs); look at [geopy](https://code.google.com/p/geopy/) 1. distance on the spheroid; you can look at the [GDAL bindings](http://gdal.org/python/) but you probably want something [simpler](http://www.johndcook.com/python_longitude_latitude.html) 1. map presentation; [QGIS](http://qgis.org/en/docs/pyqgis_developer_cookbook/index.html?highlight=python) has some nice python bindings and is a full featured mapping environment which will cover most of the things you might want to do with geographic data. Don't get discouraged; there is a lot to know about mapping in order to do even simple tasks; but there is a lot of help out there.
STOP YELLING! I HATE IT WHEN YOU FIGHT!
Like k3b is the premier Linux disk burning solution, Okular is the de facto gold standard pdf viewer. I can't think of a PDF roundup article that didn't have Okular winning the comparison; it's a best-in-class product. You would be well advised to give that a try. 
I would be happy with schema support.
Very true, though this would be using BeautifulSoup's find when doing regex searches, so its only using regex to match tags. See: http://www.crummy.com/software/BeautifulSoup/bs4/doc/#a-regular-expression
Did you follow all the steps and install the dependencies as listed here? http://www.sikuli.org/download.html
I would strongly recommend using it to any Python developer, it comes with so many useful tools that I can't hardly develop without it at this point. The ability to quickly load, test, profile, and more from the same interface is great, and it has event loop integration for every major gui toolkit out there. The tab completion and history improvements are reason enough to use it. 
Python is a good start, you're probably going to want to start with 2.7 as there are more tutorials available. Moving on to more complicated language like C++ after is pretty much the way to go in my opinion.
This looks amazing. I am going to have to try it. 
why? That just means they'll break backwards compatibility :) Version numbers are so meaningless. 
 from __future__ import future
&gt; what new features am I missing out on by using 2.7? local, yield from, asyncio, memoryview.cast(), socket.sendmsg the rest are meh. (trivially done in 2.x)
One advantage of BeautifulSoup for web scraping is that BeautifulSoup won't choke on invalid xml/html. However, I think lxml has mode which uses BeautifulSoup to parse the input, so it's more a both-and situation rather than an either-or one. EDIT: on reviewing lxml's documentation, I discovered that this was misleading.
yahwn, still no multiline lambda support? i'll stick with 2.7
[PySide supports Python 3](http://qt-project.org/wiki/PySide_Binaries_Windows).
The main benefit of using the newest version of anything is not forcing *other* people to use outdated software. You're not the only lazy person in the world, you know. In addition to that: * Completely redone I/O, which now consists of 3 well-defined API layers: raw access, buffered binary access, and the Unicode layer. The exception hierarchy has been redone, too: instead of checking if `exc.errno == 13`, for example, you can simply catch `PermissionError`. * Exception causes and contexts: there's no need to wrap one exception in another if you do `except SomeException: raise OtherException` anymore. The original exception is automatically stored as `__context__` and printed to the console if the new exception propagates to the top. (Naturally, there's a syntax to suppress that. It's slightly awkward, though: `raise OtherException from None`) * Many new functions, modules, and methods. The ones I find myself using frequently are, for example, `int.from_bytes(bytestring, endianness)`, its reverse `integer.to_bytes(length, endianness)`, and `socket.inet_ntop`/`socket.inet_pton` which are similar to `inet_aton` and `inet_ntoa`, only for both IPv4 and IPv6. * New syntactic sugar: function annotations, `yield from`... * A new GIL. It's still there, but it's much more efficient.
Sure: import matplotlib.pyplot as plt import gtk.gdk w = gtk.gdk.get_default_root_window() sz = w.get_size() pb = gtk.gdk.Pixbuf(gtk.gdk.COLORSPACE_RGB,False,8,sz[0],sz[1]) pb = pb.get_from_drawable(w,w.get_colormap(),0,0,0,0,sz[0],sz[1]) array = pb.get_pixels_array() plt.imshow(array) #shows correct image np.save("arr", array) a=np.load("arr.npy") plt.imshow(a) #shows skewed image
[PEP 429](http://www.python.org/dev/peps/pep-0429/) is your huckleberry.
Can confirm. It's a trap
Searching and parsing are different things.
Build your game on Mac and then use a PC to compile it into an exe file.
I momentarily forgot about Scrapy of all things. I have worked with a bit but found the "easier" tasks to do with BeautifulSoup. Been looking around, but couldn't see anything conclusive - can it handle Javascript?
Looked at that it is good for global maps but not very well with city maps which is where I mainly want to work with data.
Definitely a fan of this suggestion. Docker is fantastic for this stuff.
It looks nice. Now, we need something as nice as this that can do async requests, because that makes scrapping really faster.
Thanks! I did see this too...
I like this trend of using kickstarter to support open source software projects.
I tried interpy, it is nice but it seems to work only with double-quote strings. This wont expand : ''' hello #{world} ''', neither wont this: 'hello #{world}' 
Why would you even... what? :O
How do I use this mode?
locals() is full! I must have an anonymous function!
That argument is about as silly as having to assign every single value in your program to a local variable. Instead of d = {} d['a'] = 'value a'; d['b']='value b'; d['c'] = 'value c' You have to write: d_a = 'value a'; d_b = 'value b'; d_c = 'value c' Because hey, you can make a lot of local variables. And if you want to create a dynamic number of values, just write it into locals() directly! I hope you realize how foolish it is. If a language pretends to have first-class functions, it must support anonymous first class functions containing whatever. Not that Python doesn't, but the lack of simple syntax for them is limiting.
I'm a maintainer of [PRAW](https://github.com/praw-dev/praw) and I'd like to test that python 3.4 works with the library so we can add it to the list of supported versions and ideally push a new version around python 3.4s release. If I test PRAW with rc1 (or rc2) can I be reasonably sure that it would work with the final version? Also [PEP 0453](http://www.python.org/dev/peps/pep-0453/) is totally awesome!!
Your analogy isn't much good, since you can't pass around `d_*` easily, the dictionary `d` obviously has a use. Pros of allowing anonymous first class functions containing statements: Saves you one line: instead of def f(x): r = x*x return r*r promise2 = promise.then(f) You could write: promise2 = promise.then(def (x): r = x*x return r*r) Cons: Massively changes Python's whitespace rules.
We had a issue with 3.3 when it was released, [this commit](https://github.com/praw-dev/praw/commit/1086a64357ddc82cf24812f86d4aa709a352553c) added compatibility. I can't remember the precise issue, maybe /u/bboe can? I'd like to test for similar issues. I suppose it's mostly a confidence and code quality thing. I don't want to say PRAW supports something if I'm not sure it does, even if the chance of problems are low.
Yeah, that's not what you commented tho...
well, you relied on black magic there (implementation details of the import system). [here you can](http://docs.python.org/3.3/whatsnew/3.3.html) see that in 3.3, they have “Rewritten import machinery based on importlib”, which changed those internals, which made your black magic break. 3.4 has a new pickle protocol, hash algorithm etc. so if you rely on black magic there, too (e.g. by relying on dict keys having a certain order or so), it’ll be incompatible, else it won’t. --- what you should have done to keep things compatible is while/after porting to python 3, removing everything that’s currently in the compat module and replacing it with only “PY2 = sys.version_info[0] == 2”. then replace all imports that rely on those `add_move(MovedAttribute(…))` hacks with sth. like if PY2: from urllib2 import Request else: from urllib.request import Request and then rewrite all imports to be absolute instead of using the CompatImporter hack, e.g. from praw.decorators import Memoize, SleepAfter, require_login should become from __future__ import absolute_import from .decorators import Memoize, SleepAfter, require_login
CentOS 5 user here. Having to routinely work around Python 2.4, I feel your pain. There are a few options: * Require a python 3.3 package from a standard repo. It looks like 3.3 is available under 'testing' and 'unstable', which may not be perferable, but they *are* there. * Just use some flavor of virtualenv. This can be a good move anyway, since it shelters your app from library upgrades and python upgrades that could subtly break things. What it doesn't do is allow you to take advantage of security upgrades as the surrounding OS changes. So there is a tradeoff here.
You absolutely need to create an .exe on Windows. There are a number of ways to accomplish your goal. Google can easily help you find them. Here's a link for one process: http://www.logix4u.net/component/content/article/27-tutorials/44-how-to-create-windows-executable-exe-from-python-script Bottom line, though: develop your game on any system you like. Work out the bugs. Then worry about how you're going to package it (.exe) at the end. Packaging should be trivial by comparison.
&gt;* PEP 453, a bundled installer for the *pip* package manager thank god.
I believe compiling server side + virtualenv is the standard... until docker I guess.
I've been playing with docker for a while but I can't grasp it's use. Haven't found a comprehensive guide to use it properly....
If you're on a *nix box, who not use subprocess to call the commands and read the output? You can spawn as many processes as you need (within reason) and you can call multiple ssh commands per process.
The changes from 2 to 3 aren't particularly difficult to learn, but if you're just learning the language at first I suggest making sure that the code examples in the thing you're learning from work for you. So learn Python 2 first, and then you can learn about the differences between 2 and 3.
I'm pretty sure it's python version 2.76. Which is still commonly used in the real world. I would use that version. I took that course, and if I can offer you some advice, learn as much python as you can before you begin. That is if you are new to programming and python. 
The latest 2.7 version should be OK. [This](https://wiki.python.org/moin/BeginnersGuide/NonProgrammers) lists some good resources with a bio related one near the top.
I am finished, I am packaging now.
Is there a problem with using Docker right now?
You can use docker for a lot of stuff. My primary use case is to have self-contained services that require very little effort to deploy many times. For example, I'm not a fan of setting up graphite, so I can just use a pre-built container with graphite, carbon, whisper, and all of their dependencies to spin up test graphite stacks. Effort required? One command: docker run -d -t some/docker:container. (Maybe some firewall rules depending on whether or not I want the container's services exposed on my network) That one command will go out and download a container from a public registry (if I haven't already downloaded it), setup a relatively isolated environment for it ("chroot", NAT, etc), and run all of the services necessary for graphite to work. You can also use docker to quickly build your own containers *for completely different distros* that you can build into later. You can keep these containers local, upload them to the public registry, or upload them to a private registry. Docker containers are similar to lightweight VMs. The biggest difference are that resources are typically not preallocated for containers like the are for VMs and the container shares the host's kernel. As such, you cannot run Windows inside of a docker container (boo?). However, being able to spin up various versions of CentOS, Debian, etc all within your preferred distro us pretty fantastic. It's a great way to develop how you prefer to develop and test on your target platform(s) without having to spin up and maintain different dedicated VMs for each environment. To take it a step further, you can also use your docker containers to quickly deploy "production-ready" instances of your projects with ease*. Since you can still snapshot docker containers, you can branch off of "stable" points in your container's history and deploy the snapshots you're comfortable with. * docker does not yet advertise itself as something you should use in production. I've not yet deployed a docker container into a production environment either--still evaluating for my own needs, with a goal of maybe using it in production one day.
Congrats, man! Hell of an accomplishment to see it through to the end. Side note: Thanks for having a plain old pdf version as an option. I've been burned by ebook drm in the past, so now I'm pretty curmudgeonly about actual ownership of digital goods. A pdf is right up my alley. 
Pretty interesting idea and potentially super simple. I'll try this out. Thanks!
I don't see any problem learning with Python 2.X.
lxml.html does handle invalid html. In fact, I've found it often does a better job than BeautifulSoup even on invalid html pages. I've run into cases where lxml successfully extracted the content that BeautifulSoup failed on (I think some odd quirk of comment syntax was causing it to interpret the whole page as a comment). Conversely, I've yet to hit the reverse scenario - lxml has been good enough for everything I've thrown at it to date.
Could you give me some more detail about the problem? Are those the ONLY things you want to output?
C++ isn't necessarily 'hard', its just 'frustrating'. (I used to be a FT C++ developer for a few years) To answer the question, it doesn't matter which version. 
 Use zfill... string.zfill(s, width) found [here](http://docs.python.org/2/library/string.html#string.zfill)
 print("{0:03.5f}".format(3.4)) 003.40000 The "preferred" way to do it in Py3. google "the format mini language". This one tells Py to format the field at index 0 to up to 3 leading zeroes and always use 4 digits precision.
http://www.realpython.com/blog/python/headless-selenium-testing-with-python-and-phantomjs/#.UnapQ40oi2w + http://gediminas-backevicius.blogspot.co.uk/2013/05/installing-phantomjs-on-ubuntu-1304.html phantomjs + selenium. Interact with it using pure python, no JS required. Example: driver = webdriver.PhantomJS() driver.get(url) print driver.find_elements_by_tag_name('a') It supports xpath as well, and seems reliable, I am using it in production. On ubuntu, make sure to apt-get install fontconfig to make phantomjs work.
... someone needs to make a kickstarter to scan in 2 scoops 1.6...
It reminds me of an updated, nicer version of mechanize
Yeah, I noticed that when I reviewed lxml's documentation. Although, they note that BeautifulSoup has better encoding detection.
Nice format, good examples, though one small error after the first "input_from_a_file.py" picture. I think image is supposed to be imagine.
 print("{0:03.5f}".format(3.4)) 003.40000 The "preferred" way to do it in Py3. google "the format mini language". This one tells Py to format the field at index 0 to up to 3 leading zeroes and always use 5 digits precision.
No, I meant that "was" the standard until docker.
Oops. Good spot, i'll edit that. Thanks. :)
I've never done C++, but I'd warn that while I generally agree wholeheartedly with "Programming has little to do with languages or versions really", my understanding is that C and C++ are something of a special case if all you've ever done is Python. The most obvious thing you could find yourself unprepared for (AFAIK) is memory management. It's my understanding that with C++ you *always* have to explicitly handle it to some extent or another. Coming from a Python-only, this could potentially be something you can't just bridge based on "programming is programming".
Er... what's wrong with this together with `concurrent.futures`? I don't see why async should be a concern for this lib.
Thanks!! I have been dying for something like this (i.e. like Mechanize) in Python 3.
Really? And you want to share that with everyone, including the author? I'm not naive enough to think my work isn't pirated but your attitude just sucks.
ugh that's huge. installing it has always been a fiasco.
`yield from` is nice, and not really syntactic sugar. You can get an even more powerful version with greenlets. The outer code doesn't even have to know the inner code is a generator. You can pass a callback into arbitrary code and have it yield values (without most of the complexity of threads). https://github.com/enthought/blockcanvas/blob/master/blockcanvas/greenlet/test_generator_nested.py
Great tutorial so far! I like how each chapter builds on the last. I also like how you start right out with the if " __name__ == '__main__': ". It really is essential to learn these good practices right away.
Which mailing list? Did you submit a patch? If it's trivial then just submit a patch.
ಠ_ಠ I usually don't approve of assasinations...
These plots look cool. I would like to have plots like these in my presentations. Is there a easy way to embed them in beamer or keynote presentations?
If it works on rc1, it's pretty likely that it will work on the final released version, though it's not impossible that changes will break something. Some IPython tests that were working in beta 2 failed with beta 3, but IPython does get into odd corners of the language, so it's probably more susceptible to changes than most projects.
I used whatever version the tutorial was written for, the first of which for me happened to be 2.x. That being said, some tuts use 2.x while others use 3.x. Here are a few I have used: * [Learn Python the Hard Way](http://learnpythonthehardway.org/) uses 2.x * [Invent With Python](http://inventwithpython.com/) uses 3.x * [Dive Into Python](http://www.diveintopython.net/) uses 2.x, while * [Dive into Python 3](http://getpython3.com/diveintopython3/) uses 3.x (obviously)
Advocating piracy, yet again. And always against independent writers. I wish you would grow out of your troll phase and either find somewhere else to hangout, or contribute in a way that fit in.
-1
Sweet, I'll probably just skip 1.2 then!
**Python Versions** While it's possible to do `from __future__ import print_function` in Python 2, if the code contains calls to print followed by a space (like `print "text"`) it is Python 2. * http://docs.python.org/2/whatsnew/ * http://docs.python.org/3/whatsnew/ *Compatibility Layers* * https://pypi.python.org/pypi/six (2 &amp; 3) * https://pypi.python.org/pypi/nine (3 &amp; 2) * https://pypi.python.org/pypi/future (3 &amp; 2) * http://python3porting.com/bookindex.html **Books and Resources** * http://www.reddit.com/r/learnpython/wiki/index * https://github.com/vhf/free-programming-books/blob/master/free-programming-books.md#python * http://pythonbooks.revolunet.com/ &gt; This is my first language, I have a Microbiology research background. Welcome! * http://rosalind.info/problems/tree-view/ * http://rosettacode.org/wiki/Category:Programming_Tasks * http://biopython.org/DIST/docs/tutorial/Tutorial.html
&gt; You're not the only lazy person in the world, you know. Isn't that an argument for *staying* with 2.7? Because you're not forcing other lazy people to update just to use your software.
None of the stuff mentioned so far is giving me much at all of an incentive to switch to 3.x. YMMV.
This is wonderful news. Keep up the awesome work, I'm a big fan!
Cool, thanks. At the second example, it says: "By default, anyone can view the graphs at the unique URL. To make the graphs private, so that only you can see them when your logged in, set world_readable to False"
Learn 3 until you need to use 2. 2 is getting no more minor updates.
Bought your book when it was mentioned on hacker news a while back, loved it. Having a guide to how I'm supposed to write common design patterns has helped me write much cleaner Python code, with much less hesitation. was slightly irked at having to pay $5 more to get in both pdf and epub versions (one for the computer and another for my e-reader) though. Price was still reasonable fortunately
https://en.wikipedia.org/wiki/HTTP_2.0 Thanks! *Asynchronous Python and HTTP 2.0 Server Push* Without committing to an asynchronous model (such as `asyncio`), it may be difficult to specify a callback interface that just NOPs when `callback` is `None`. Here's one example of `asyncio` with HTTP: https://github.com/fafhrd91/aiohttp/blob/master/aiohttp/client.py
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**HTTP 2.0**](http://en.wikipedia.org/wiki/HTTP%202.0): --- &gt; &gt;**HTTP 2.0** is the next planned version of the [HTTP](http://en.wikipedia.org/wiki/HTTP) network protocol used by the [World Wide Web](http://en.wikipedia.org/wiki/World_Wide_Web). It is based on [SPDY](http://en.wikipedia.org/wiki/SPDY). HTTP 2.0 is being developed by the Hypertext Transfer Protocol Bis (httpbis) working group of the [IETF](http://en.wikipedia.org/wiki/IETF). HTTP 2.0 would be the first new version of the HTTP protocol since HTTP 1.1 was described by [RFC 2616](//tools.ietf.org/html/rfc2616) in 1999. &gt; --- ^Interesting: [^HTTP ^pipelining](http://en.wikipedia.org/wiki/HTTP_pipelining) ^| [^Web ^2.0](http://en.wikipedia.org/wiki/Web_2.0) ^| [^World ^Wide ^Web](http://en.wikipedia.org/wiki/World_Wide_Web) *^\/u/westurner ^can [^delete](http://www.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cfctwe2)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less.* ^| [^(FAQs)](http://www.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/) ^| [^flag ^a ^glitch](http://www.reddit.com/message/compose?to=/r/autowikibot&amp;subject=Glitched comment report&amp;message=What seems wrong: (optional description goes here\)%0A%0A---%0A%0AReply no. 53154:%0Ahttp://www.reddit.com/r/Python/comments/1xn24p/http20_for_python/cfctw8x)
Agreed. I'm reluctant to commit to `asyncio` at this stage. If I can widen the synchronous support to include Python 2.X (by finding a replacement for `ssl` that supports NPN), I'd rather have than than `asyncio` support. Of course, I'd rather have both. =)
Wait.. where did I see those before.... ah! http://www.thingiverse.com/thing:239697
&gt; If I can widen the synchronous support to include Python 2.X (by finding a replacement for ssl that supports NPN), I'd rather have than than asyncio support. I guess bewteen `./Modules/_ssl.c`, `./Lib/ssl.py`, pypi:ssl, and pypi:backports.ssl_match_hostname, there's no support for TLS https://en.wikipedia.org/wiki/Next_Protocol_Negotiation in Python 2. 
tl:dr, yes :) IRC is my primary way of communicating with my programming mentor. And I took it a step further by making my Raspberry Pi, among other things, my always-on irssi client inside a byobu screen session. I have it set to automatically attach the session upon ssh, so when i ssh into it from a windows machine ([putty](http://www.putty.org/)), all of my irc messages are still there waiting for me -- like a running transcript what i can always go back and look through. Thankfully, there were various tutorials to walk a noob like me through setting it up.
Jeff: I'm a novice programmer, having just started with Python and coding in general approx. 2 months ago. I am not a professional by any means and am simply a lifelong PC user. Would your book be useful to me at my skill level? I intend to look at it regardless but I wanted to hear your thoughts.
That doesn't really strike me as something that a browser would be doing anyhow. Are you looking for something cross-platform? If you're on a *nix, you could just shell out to `host`.
Will this effect me in any way if I already have pip installed?
&gt;PEP 435, a standardized "enum" module Thank you based developers.
Libraries are interpreter specific. The libraries you have in 3.3 will not be the same ones as 3.4.
News Flash: I give the book away for free to those who can't afford it. There's a giant message on the book webpage to that effect. I've given away hundreds of copies without asking for anything in return. *That*, is my problem.
Yup, definitely saving up for this.
/u/djangogeek, previously known as /u/djangonerd is mostly focused on trolling hard working authors such as yourself and /u/pydanny. Don't mind him, thanks for your hard work and keep chugging along!
I'm sad to see that a third of the comments in this reddit are about pirating it or complaints. This is a great resource yet so many people complain about the really low price or advocate piracy. This is why we can't have nice things.
You paid $5! I'm so sad for you and your laptop and high paying job! How dare you have to pay an author a little extra for a new format?
This is a backhanded compliment. Do we reply need to know that you won't be buying this book? No we don't.
It is and it isn't. Bokeh is closer to the spirit of Protovis (precursor to d3), for providing novel plot construction, but in Python and over large datasets. MPLd3 is about rendering interactive matplotlib in the browser, as faithfully to the matplotlib rendering as possible. We have a basic MPL front-end working in Bokeh, as well, but we are trying to represent the plot structure at a higher level so that interactive pan &amp; zoom over large datasets, as well as streaming &amp; updating data, will work very easily and without jumping through a lot of hoops. (Disclaimer: this is just based on what I've gleaned from watching the mpld3 project on github...)
Just started the tutorial. The below code is from the 'Getting Started' section of the tutorial but either typing or copy and pasting that gives me an invalid syntax error on line 2 that I am unsure how to resolve. I downloaded Python 3.3 if that matters. def main(): print 'hello, world' if __name__ == '__main__': main()
Pyside doesn't have Qt5 support, only 4.8. It does support python 3 though.
Awesome, thanks everyone.
It's always nice to see the matplotlib interface spread to other domains. It's the reason bokeh has a nascent matplotlib layer. It would be really awesome to see effort put behind the matplotlib layer in bokeh -- or even a separate mplbokeh project that used bokehjs and helped contributed to that growing effort. 
print is a function in Python 3. You'd be best to download Python 2 if you are following along with the tutorial. The quick fix for Python 3 is to do this though: print ('hello, world')
Use print('blabla')
Is there any reason to be learning 2 instead of 3? I am just starting out in programming but I'd like to be as thorough as I can. I chose Python somewhat at random because it seemed like a good starting point.
i can't find the link but i thought someone implemented a complaint twisted.web library. 
The declarative layer is completely optional, there are already a few other layers that use sqlalchemy as their backend. That said, it probably would be a fair bit of work to implement a translation layer for the query &amp; session system. I'm curious though... Do you have a link to a good walkthrough of django 's query system? 
Did you actually buy the book or are you just freeloading? I suspect the latter.
Oh, I didn't realize. Apparently, it's even in the Ubuntu software secenter store. https://apps.ubuntu.com/cat/applications/python3-pyside/ http://qt-project.org/wiki/PySide_Binaries_Linux I don't see Qt5 support yet.
Thank you for posting this. However, what really shocked me was that when I first saw it, you had a -1 on it. I was happy to up vote it.
Love Anaconda. Was kind of hoping they'd package Julia.
Interesting. For the first one I'd typically just use set() to get the unique values. x = [0, 0, 1, 0, 1, 2, 2, 1, 0] list(set(x)) # [0, 1, 2] The second was a little trickier and I came up with this monstrosity: x = ['', 'a', 'abc', 'cat', 'dog', 'hi'] dict(zip(map(len, x), x)).values() # ['', 'a', 'hi', 'dog'] Not exactly the same, but the values are unique/distinct. I wonder if someone could explain where the gist would be useful over other implementations. I know what I have aren't iterators like in the example code.
zfill http://docs.python.org/2/library/stdtypes.html#str.zfill
some random questions, how much work has to be done going from a large 2.7 project to 3.3? will the same code in 3.3 work with 3.4? when will they finalize 3.X?
The Python 3.3 package list seems a little wimpy. What about Docopts and Arrow and sh, major database drivers, etc? 
Because 3.3 has hash randomization turned on by default, any problems with relying on dict key order should have cropped up while using 3.3.
you know what would have made this article awesome? actual #'s personally, i wouldnt change to something as risky as non-premptive unless there was some potentially huge win. like going from 100 rps to 100000 rps. 
Anaconda really focuses on mathematical/scientific computing. And Python 3.3 still lags behind 2.7 for that. 
This is Reddit. Unfortunately calling piracy "keeping information free" while railing against the NSA poking around your own information will get you a thousand upvotes. Toss in a cat GIF and it's a million upvotes. 
yeah i'm firm at 2.7 until some one convinces me its worth the hassle to upgrade 
&gt; Only answers from those that have worked with these books please. LOL
Never heard of PiCloud until just now. Wow that's useful. 
On behalf of everyone who's ever said "I can't switch to Python 3 because the libraries I need don't support it", I thank you for stalling the adoption of new software. Unless you're not writing libraries, in which case it's OK.
&gt;how much work has to be done going from a large 2.7 project to 3.3? That depends on too many aspects to say for sure. Do you explicitly specify the type of every string with either `b` or `u`? Do you rely on `iteritems()` being an iterator (in 3.x `items()` is an iterable, but not an iterator)? Does every library you use support 3.3? Even big projects can sometimes be ported simply by running `2to3`, and even small scripts may require lots of manual work. &gt;will the same code in 3.3 work with 3.4? All minor releases are backwards-compatible. &gt;when will they finalize 3.X? When they come up with and implement some really big feature worth bumping the major version. There's no set schedule for major versions.
It's defined as semantically equivalent to [some Python code](http://www.python.org/dev/peps/pep-0380/#formal-semantics), so I guess it is syntactic sugar. &gt;You can get an even more powerful version with greenlets. The outer code doesn't even have to know the inner code is a generator. But it does have to be marked as a `Genlet`, doesn't it? Also, it's actually *less* powerful, as there's no `generator.send`, `generator.throw`, and `generator.close`.
I'm definitely not writing libraries; if I were, I would try to have both 2.7 and 3.3 versions, sure, because I know that's best for the language. 
Don't give up hope on all of us because of you're bad experience with 2-scoops' digital version. Some of us would gladly be buying the digitals.
In discussion some Redditors thought that what he meant was "static typing" rather than "compilers", but when I reread the article to write that comment, I now believe he really did mean "compiler". And yes, it was the consensus here that as written the article was ridiculous. He didn't approve my comment bringing up Logo, Pilot, BASIC and other classic learning languages, only a comment telling him what a wonderful post he had written. :-( Later on, South Africa, which uses Delphi and Java for grade school teaching, had their education department decide to standardize on Delphi. There was a huge uproar in the country, partly caused by the horrendous document they put out to support their decision. It stated that since Java was open source it meant it could have a lot of bugs (the irony being Delphi being infamous among its own users for bugs) and that *there might not be support for it* (Oracle could buy Embarcadero with the spare change in Larry Ellison's seat cushions). It also claimed that Delphi was very popular in North America and Western Europe (actually the two regions in which it is almost non-existent). Thousands of educators signed a petition and the decision was reversed. 
God help us if you need HTTP/2.0 support while still on Python 2.
Don't pay attention to pydsnny he is just a troll...
eh, did you just elaborate what i just introduced, or did you miss that this was what i said?
Hi, Indeed, ZeroMQ is a great library which makes designing and implementing distributed systems so easy. I've been using ZeroMQ in my last two projects for creating a distributed poller system for VMware vSphere environment and an asynchronous service manager for UNIX/Linux systems. In case you want to have a look at the code, here are the links: * https://github.com/dnaeon/py-vpoller * https://github.com/dnaeon/async-service-mgr Thanks for mentioning PiCloud, haven't heard of it until now. Nice blog you have, keep up the good work! Regards, Marin
From how I read your comment, neither. 3.3 already breaks code that relies on dict keys having a predictable order. 3.4 shouldn't break any additional code when it comes to order of keys in dicts. Am I mistaken?
Is there a way to prepurchase the physical copy?
ugh, i didn’t read properly and thought you’re talking abozt 3.4. sorry, now it’s making sense.
Someone asked me this the other day. I should probably put something on the site somewhere. Thanks. 'I started with Python 3, years ago. I was disappointed that many libraries hadn't been ported across, so I ended up moving to 2.X I agree that library support is a fair bit better now, but I still think I'd rather be using the 2.X version (myself) If you took a Python job in the next couple of years, I'd bet you'd be more likely to see 2.X code as well.' 
Well, I would think that huge majority of their processing is IO. And anyway you can use other threads to do heavy lifting if it is needed. For example I use zeromq to communicate between processes. Also waiting for thread to finish is just another IO waiting. Another neat thing is that you can have gevent process that will process HTTP and send result back, but that same gevent process can offload 'cpu bound' stuff to for example golang. 
finally get to try out blaze! PyTables was super frustrating for out-of-core computation
it's a cool trick, I think it relies on the object's `__dict__` so it doesn't work 100% of the time but it's useful anyway.
Thanks!
The key here is not sorted but rather preserving the original order. Sorted would destroy that.
People want to buy content, not formats. 
Correct, it does not work for objects implemented in C (`defaultdict`, `deque`) or those using `__slots__` (named tuples)
Holy shit I read the article and your comment like an hour ago and only now just realized it's not called PiButt. &gt;Why PiButt? &gt;We believe that the simpler we make butt computing, the more powerful it is for you. Developer productivity is our number one goal.
http://docs.python.org/3.4/library/concurrent.futures.html#module-concurrent.futures
Not bad. What about the keyfunc? I have a pet peeve with using dicts as sets though. :) (dummy values)
yes I am quite aware of the possibilities. but this is also additional complexity with a higher risk of dead lock due to "cooperative" multitasking. and without #'s from before or after, it's merely architecture masturbation. 
Thank you.
Hhhehe, I see we have a Cloud-to-Butt Chrome extension user here.
Thanks! The whole damn time I was using dir(obj)... Vars is so much better!
so what the difference between dir() and vars() ?
Use the `zip` built-in function, or `itertools.zip_longest`: import itertools xlist = [0, 1, 2, 3] ylist = [4, 5, 6, 7, 8] print("zip") for x, y in zip(xlist, ylist): print(x, y) print("itertools.zip_longest") for x, y in itertools.zip_longest(xlist, ylist): print(x, y) Output: zip 0 4 1 5 2 6 3 7 itertools.zip_longest 0 4 1 5 2 6 3 7 None 8 http://docs.python.org/3.3/library/functions.html#zip http://docs.python.org/3.3/library/itertools.html#itertools.zip_longest In python 2 it's called `itertools.izip_longest`. Also note that this technique can be generalized to any iterable of tuples: for x, y in [(0, 2), (1, 3)]: print(x, y, x+y) Output: 0 2 2 1 3 4 And it works fine with list comprehensions: &gt;&gt;&gt; [x+y for x, y in zip([0,1,2,3], [4,5,6,7])] [4, 6, 8, 10]
Here is a good answer to your question. http://stackoverflow.com/questions/980249/difference-between-dir-and-vars-keys-in-python
 dir(obj) == sorted(vars(obj).keys()) Warning: in Python 3 [dict.keys](http://docs.python.org/3.0/library/stdtypes.html#dict.keys) returns a view object. So here we would get : &gt;&gt;&gt; pprint(dir(math)) [ '__name__', '__package__', 'cos', 'e', 'floor', 'pi', 'sin', 'sqrt', 'tan', etc. ]
Virtualize?
Local function def?
The massive simplicity increases throughout have been enough for me. 
There's a PEP with something similar in it that I'd really like to see happen: http://www.python.org/dev/peps/pep-0403/
Nice! I always tell newcomers to Python that 'dir' and 'help' are your two best friends for learning the language (as well as the Python documentation/tutorials, of course), but it looks like I should add 'vars' to that list.
Question for the PyPy team: what's the "target" slowdown for this project? Assuming it's higher than 0, I mean. I assume that any system like this is going to incur SOME runtime overhead, and the gains will be realized in significantly improved multithreading performance in the absence of the GIL.
Users, maybe. No. True. I don't have the resources to fix every problem I find. `fsharpi` once accepted hard tabs for indentation, but not `fsharpc`. I reported the error, including a patch to `fsharpc` to accept tabs. They ignored my patched, instead patching `fsharpi` to not accept hard tabs either, due to their silly language guidelines.
&gt; It's defined as semantically equivalent to some Python code Well that's always true if the language is turing-complete. It's not just a question of saving typing, it's that hardly anyone would know how to handle the corner cases correctly. &gt; But it does have to be marked as a Genlet, doesn't it? The outermost function does, but every intermediate piece of code between the genlet you start and the Yield call doesn't have to know. It's like a thread that way. You can get the other functions from greenlets even if they're not implemented in that example.
Teenager here. Zed Shaw's Learn Python The Hard Way has been pretty good so far. Don't know if it matches all of your parameters, but it has allowed those of us who are nerds to progress in python rapidly while allowing computer-illiterate people to slowly work their way on. The lessons are actually available for free on [learnpythonthehardway.org](http://learnpythonthehardway.org/), so you can look over them to see if they suit your needs.
Drop the exams. Assess the students using their projects but in an alternative format such as a round Robin showcase. I agree that games are not the best choice but for different reasons. It takes a lot of knowledge and work to make something as simple as asteroid or pong. What many forget is that snapagram book is just as much computer science as call of battlefield, and my students sure do love their snapagram book. I would look into having students make a site using flask/django/whatever with a focus on mobile. It scaffolds better, the feedback to students is clearer, and it really let's you differentiate instruction. Student projects will also be a lot more diverse and unique.
Aye cheers I used that site myself to get started! Problem is most of the kids wont be that into programming so it's getting those ones interested while still giving the others a challenge. Shame the exam is text based otherwise I'd get them to remake flappy bird in python, they seem to love it -__-
It mustn't be that big of a problem, then.
Unfortunately the exams form part of their GCSE (The be all and end all of the UK education system, the shambles that it is). We have a choice of either a C derived language of Python, having looked at C++ a few weeks ago I kinda love it but the existing teacher with any programming knowledge knows Python so Python it is. As it stands the students will be assessed by an exam paper on general computer science and then have to program a working program, this year it was a simple quiz system with score board all text based (press A, B, C or D) and then read from a CSV file and search it. Unfortunately the education system dictates what we can do :(
Or just tell them to use IPython with its awesome tab-completion and '?' operator :-)
Give them some projects that connect to the internet. It will seem so much more useful and relevant. My first python project connected to the web to access google's currency exchange to convert currency values according to the real time exchange rate.
Yeah, it's not. I just use Haskell instead.
Create your own socket chat protocol for the classroom.
It doesn't work for builtins like `list` and `dict` either.
`dir` works on builtins, `vars` doesn't.
For a standard library that's well documented like math, I'd first type help(math) before vars(math). vars can be a lot more useful for an instance with variables and a state that you want to inspect. If all else fails, read the source.
Pickling code is something that should be easier. I've hacked together a way to do this with function decorators that implement `__setstate__` and `__getstate__` and locate the function on the other end by its full typename. It's not as clean as it could be though. Also, is there a reason to send three messages instead of sending a tuple of `(runnable, args, kwargs)`?
1. Watch Monty Python in class 2. Put Monty Python jokes into examples and homework 3. ???? 4. PROFIT!
I thought this would be about making C calls within python. If I understand it correctly, he's advocating using os commands to write simple scripts. I think this is a really common use of python but one that can get out of hand really quickly. Depending on the needs it might be better to extend the C code to run within python.
Perfect - Thank you!
Virtualenv aside, you could just install Python 3.3.4 (without adding it to your PATH) and then invoke your scripts like this: * py &lt;file&gt; This loads Python 2.7.6 * py -3.3 &lt;file&gt; This loads Python 3.3.4 I'm not sure if that plays nicely with virtualenv though so keep that in mind.
Interesting, I guess testing is the key.
My suggestion would be to find a Python open source project that you like, and then look through the bug tracker and try to fix some bugs. It's often easier than you think.
I was thiking about trying to replicate 'Caesars Cipher' but not to sure how hard it would be?
This looks like very cool...although I'm having this error that I can't seem to figure out. It appears to be with ImageMagick though: MoviePy: Generating GIF frames convert.exe: unable to open image ``seq': No such file or directory @ error/blob.c/OpenBlob/2643. convert.exe: no decode delegate for this image format ``seq' @ error/constitute.c/ReadImage/555. convert.exe: unrecognized option `-f' @ error/convert.c/ConvertImageCommand/1614 MoviePy: GIF generated ! Although it doesn't get created :P I'd appreciate any ideas you might have to fix this. I'm running Windows 7 with all of the required and optional software mentioned installed.
Thanks i'll have a look into them, thank you :)
thanks for the proper IPython capitalization :)
So something else I use when debugging (in the debugger or the command line interface) are the locals() and globals() functions, which print a dict of key : values for variables in local or global scope, respectively. Really handy.
I remember hearing something on NPR about how to teach kids to learn math. The point was to relate their studies to some applicable scenarios. Like have them solve some common problem using python. It's far easier to learn something when you can see the real world applications that it can have. 
so?
pyenv https://github.com/yyuu/pyenv
Remake some of the classic games maybe: pong, asteroids, tanks (oops, someone already mentioned this) Lots of those require solid trig and vector math skills. These also seem very "guy oriented", I'm not sure if there might be more girl oriented examples. They could also use something like [Kivy](http://kivy.org/#home) to write touch programs for the phones and tablets alot of them probably own.
For which numeric packages does 3.3 lag behind?
I've heard this suggestion before and while I love it, I wouldn't know where to start looking for such a project. Where would you start looking?
You can also embed the selection in the script. Discussed in full here: http://docs.python.org/3.3/using/windows.html#python-launcher-for-windows
http://code.google.com/p/python-twitter/ Do teenagers like twitter? I'm under the impression that teenagers like twitter. Have them make a bot that re-tweets anything with a certain hashtag that they're interested in, or scrapes the web for information related to one of their interest and tweets about it.
Pretty print. Prints an object with indentation to make it easier to read.
Them being implemented in C is probably why, though.
It's a shame that he is leaving. He made my favorite extension to Python(Pip). 
The future is polyglot.
&gt; so it should be quite possible to make an adapter so Django's declarative layer configures sqlalchemy's orm instead of it's own I didn't get this from what you had originally said -- I do like Django's layer.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Message Passing Interface**](http://en.wikipedia.org/wiki/Message%20Passing%20Interface): --- &gt;**Message Passing Interface** (**MPI**) is a standardized and portable [message-passing](http://en.wikipedia.org/wiki/Message-passing) system designed by a group of researchers from academia and industry to function on a wide variety of parallel computers. The standard defines the syntax and semantics of a core of library routines useful to a wide range of users writing portable message-passing programs in [Fortran](http://en.wikipedia.org/wiki/Fortran) or the [C programming language](http://en.wikipedia.org/wiki/C_(programming_language\)). There are several well-tested and efficient implementations of MPI, including some that are free or in the public domain. These fostered the development of a parallel software industry, and there encouraged development of portable and scalable large-scale parallel applications. &gt; --- ^Interesting: [^Open ^MPI](http://en.wikipedia.org/wiki/Open_MPI) ^| [^Supercomputer](http://en.wikipedia.org/wiki/Supercomputer) ^| [^OpenMP](http://en.wikipedia.org/wiki/OpenMP) ^| [^Microsoft ^Messaging ^Passing ^Interface](http://en.wikipedia.org/wiki/Microsoft_Messaging_Passing_Interface) *^\/u/holyshititsonlythurs ^can [^delete](http://www.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cfdpeaw)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less.* ^| [^(FAQs)](http://www.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/) ^| [^flag ^a ^glitch](http://www.reddit.com/message/compose?to=/r/autowikibot&amp;subject=Glitched comment report&amp;message=What seems wrong: (optional description goes here\)%0A%0A---%0A%0AReply no. 54528:%0Ahttp://www.reddit.com/r/Python/comments/1xq32u/project_ideas/cfdpe1x)
I'm a teenager and I taught myself Python. Truthfully, in my view, Python is fun by itself, and I always enjoy learning new things that I did not know how to do before.
So he went from python to making stuff in javascript... &gt;The jump from Python to Javascript isn’t that big, the languages have a very similar shape. Javascript has _no_ standard library to speak of, it has very dubious equality tables, completely different (and in my opinion worse) OOP model... I don't really understand how he can compare javascript and python like that, even just going from the amazing python stdlib to javascript 'you need a library to do even the most basic of things' is quite a huge jump
Im jealous, being able to type a gui out on the fly sounds awesome. I'm always having to write it from "scratch" and test it until the cows come home to get all the bugs out. 
I think many of the suggestions here may be ambitious in light of the level they're expected to get to. Even stuff like HTTP requests seems simple to us, but I'm not sure that non-nerds realise that the web works on requests and responses - we talk about 'going to' Google, not 'requesting' the Google homepage. So you do have a real challenge. For teenagers who're used to rich touch UIs on smartphones, laboriously putting together a hangman game with a terminal UI that looks like something from the 70s probably isn't attention grabbing, except for the few who'll fall in love with programming. Maybe you could build off their sense of competitiveness, getting them to build programs that compete with each other in some way? This could be a literal competition within some framework you provide (have a look at [robotgame.net](http://robotgame.net/)), or they could just be measured against each other on some score (e.g. human thinks of a number, program has to guess it in as few guesses as possible with higher/lower feedback). Maybe even set different tasks - most write encryption programs, while a few of the most techy/mathsy kids are codebreakers trying to crack their classmates codes. I know you said you're sticking to text, but you might want to look at [easygui](http://easygui.sourceforge.net/). It lets you pop up simple dialog boxes, so you can escape the terminal interface, but you don't have to deal with the event-loop style programming you normally need for a GUI - you just call a dialog box, and it returns when the user closes it. Oh, and if GCSE students are learning Python, the UK education system is getting better. ;-) When I went through it a few years ago, only a handful of us doing AS computing as a special allowance had to do any programming. Even the A-level ICT that the school normally offered didn't include it.
Yeah. I don't understand being a partisan for any language. Programming is a means to an end, and the languages are the means to that end. They are not something to fight over and become impassioned about. Why not get passionate about computation and communication? They are much more important than any given language. Languages come and go. 
zomg matplotlib luvit
What do you like, other than programming?
[This link](http://www.reddit.com/r/Python/comments/1wgmkb/how_to_get_started_with_pycharm_and_have_a/) was posted to this subreddit a few days ago. It's an awesome article. I've been using PyCharm for over a year and still learned quite a bit from it. 
you could always have the keyfunc be used as the key, and then get values from the OrderedDict at the end. I'd probably wrap this stuff up in a 'distinct' function like yours though, rather than leaking the implementation details at each call site.
Someone's already posted pyenv, which is purpose built for the use case you're looking for, but I think I should also mention [pythonz](https://github.com/saghul/pythonz), since it's written to allow you to install many Pythons side-by-side but it's most useful when used in conjunction with virtualenv.
Great. Thanks. I'll peruse the link and see what I can pick up. Thanks again.
&gt; So he went from python to making stuff in javascript... this is an incorrect summation of the article if I ever saw one. 
Get them doing something practical ASAP. It doesn't matter if their code is top notch. It doesn't matter if they have a strong grasp of the language. Seeing is believing with code. 'I built that' 
Besides pygame and web scraping, one could also: * Generate some simple fractals/other cool graphics (EDIT: Not really text-based though) * Create simple text-based games (minesweeper, connect four, ...) * Conways Game of Life * Give them some ideas/guidelines and let them decide themselves? Especially the last thing would be easy for the people interested, a bit harder for the people not that interested. Really depends on your audience. Also, searched the web already? Found this: http://www.cse.msu.edu/~cse231/PracticeOfComputingUsingPython/index.php
easygui is a really simple library that is not event-driven so you can program it linearly. basically I just assigned the message box results to variables inputs I was using before, and then it just runs the same. 
&gt; When I stepped back Python no longer seemed relevant to the web, &gt; And so I started to look towards Javascript and the browser and the DOM. &gt;Right now I think I’m on to something in the area of collaboration, first with TogetherJS and now I’m thinking bigger with a new experiment and his 'experiment' is written in javascript, i'm not sure why you think my comment was wrong?
Yeah i'm currently in your position. You could try going through the standard library and see if anything interests you, or you could just build on small projects that you already made and try to improve them. Currently i'm working in learning asyncio so that I can speed up a program i made which checks a list of websites to see if they are currently up. After that I can use those skills to build any number of fast-moving web scrapers / APIs. Basically, just find something about the language that interests you and go down the rabbit hole, as it were. Even if its just some small crappy program just try to make it as good as it can be. Edit: Also, i highly reccomend playing around with APIs if you're at all interested in web stuff. It's stupid how much free data there is out there for you to gobble up (public transit systems have APIs! imagine that). 
maybe help out the multibit project or do something with cryptocurrencies?
you're right ... ill add links to pastebin cause formatting always ends up being a problem. will update the post asap this week. thanks!
TIL that `defaultdict` is implemented in C.
No need to judge. He explained perfectly clearly why he made the jump, and it wasn't about just the languages- it was about the culture of the languages, and about finding the tools he wanted to work with to create the things he wanted to create.
Thanks for that tip. Honeymoon period over =(
Awesome! Also, TogetherJs. That's sweet as hell!
This is good too! Incorporate your interests into your programming.
Yes i would also like some advice on doing this.
Python
NLTK is definitely the go-to for parsing semantics out of unstructured text. Scikitlearn will help with the machine learning portion. Here's a [good overview](http://blip.tv/pycon-us-videos-2009-2010-2011/pycon-2011-statistical-machine-learning-for-text-classification-with-scikit-learn-4898362), plenty more if you search. In general, you might look for the terms "topic modeling" or "Latent Dirichlet Allocation". A [good example](http://nbviewer.ipython.org/gist/rjweiss/7158866)
&gt; and his 'experiment' is written in javascript, i'm not sure why you think my comment was wrong? there's a lot of words in that article and you can pick and choose whatever you like. so how would a collaboration platform in the browser be written in python? realistically it can't be anything but javascript, and the way I read the article, javascript/browser aligns more with the problems he's interested in solving now. Where as in python he was building tools to help one day build the things he was interested in, and unfortunately never got to that second step. So it's not that &gt; So he went from python to making stuff in javascript... is wrong as you suggest I am suggesting. I am suggesting that the above does not correctly provide an accurate summary of the article. And thus your rant above is incorrect from the beginning. 
could not have said it better myself. I know this because I tried. :)
&gt;Even stuff like HTTP requests seems simple to us, but I'm not sure that non-nerds realise that the web works on requests and responses - we talk about 'going to' Google, not 'requesting' the Google homepage. I disagree. Learning students how requests and responses work wouldn't take long to learn, and is prettt easy to understand. 
I wrote this code a while back and shared it as a recipe on ActiveState. Today I put it up on GitHub. Now I just noticed you can do: pip install short_url Thanks to someone adding my code to PyPI. :) Also, someone turned it into a Flask extension (Flask-ShortUrl) Cool! https://pypi.python.org/pypi/Flask-ShortUrl/0.1.2
This is one of my pet peeves with the computing world. There are thousands of things that could be called 'pretty easy to understand', but even if we didn't overestimate how easy they are, they all add up to a huge cognitive burden. Maybe HTTP requests are on the syllabus anyway, and these students will have to understand them. But if not, it could easily take a couple of weeks of lesson time to get them comfortable with it.
That's ALL they had to do! That quiz game is ridiculously easy! 
1. ???? 2. ???? 3. ???? 4. PROFIT!
I am with you. Language is a tool to solved a job. Any tool.
Python is [perfect for first timer in programming!](http://pythonthusiast.pythonblogs.com/230_pythonthusiast/archive/1303_python_a_perfect_teaching_aid_for_youngster_in_coderdojo_indonesia.html). I compare several programming languages with Python, and it still stand above others. Currently I am working on a [Python teaching aids for kids](http://programmedme.codeplex.com), and have plan to teach Python to kids at school too!
Mr. Bicking is a bit fickle. He has started several interesting Python projects like SQLObject only to get bored and abandon them.
Then again, he also wrote pip and virtualenv and [a lot of other stuff](http://www.ianbicking.org/projects.html#biggerpy)...
One thing to consider is that after people spend a good deal of time acquiring skills, the thought that those skills may become economically obsolete may be quite threatening and could induce one to rail against other stuff or develop slavish attachment to a particular language/framework, etc. In addition, it takes effort and patience to acquire new skills and this too could be threatening after a certain complacence sets in. This could explain why people sometimes seem to get so pugilistic about their favorite technologies.
Interesting. I don't know why I didn't think of doing it that way myself. I guess I just didn't think of using zip with multiple variables in a comprehension. Now that I see it done the "right" way it does look pretty nice and is better than adding another keyword just do do what I wanted. Thanks. :)
I guess, but it seems more an issue of mentality than anything else. Most of the skills you develop using one language can be applied to using others. Sure, it takes time to learn new languages, but it doesn't take so much time as to not be a worthwhile endeavor, especially in a field as dynamic as programming.
* http://software-carpentry.org/v4/python/index.html * https://github.com/jiffyclub/ipythonblocks * https://en.wikipedia.org/wiki/Pygame#Literature * http://scipy-lectures.github.io/ * http://www.pythontutor.com/ * **http://www.reddit.com/r/IPython/comments/1dl8wc/seeking_advice_for_introducing_ipython_in_high/#c9rws29**
From personal prespective 10 years ago(note thing change): When i was in school we had some exercises like learn whats a loop and then print a traingle of starts without being told whats an inner loop. my theory says people who like problem solving would be motivated in any challange you give them. unfortunetly 50%+ of people taking the module probably wont give a sh** about problem solving. 
nice! 
Amazing, thanks!
&gt; **realistically** it can't be anything but javascript 
that's because choosing between languages of roughly equivalent power and scope (e.g. perl, python and ruby) is to a large extent a matter of taste, and people get very passionate and partisan about taste-based communities (think media fandom, for instance). there's also the tribal instinct; the feeling that you're rooting for your team with fellow supporters, and almost inevitably also rooting against the other person's team. you may think it's a waste of time and energy, but it's definitely not hard to understand.
Gevent?
I wrote a free book that has several game projects that use ASCII art and are text-based: http://inventwithpython.com I also have a Pygame book for 2D graphical games.
Pip is ridiculously well built. 
unreadable article is unreadable 
The implementation looks good -- it's a Python layer over some fairly widely-used C libraries that handle the cryptographic primitives. The interface and documentation are so much better than PyCrypto or M2Crypto that, as of this moment, I see no reason to ever use them in new code. Nice work! However, when it comes to higher-level cryptographic APIs, this seems strictly worse than using [PyNaCl](http://pynacl.readthedocs.org/en/latest/), which supports both private-key and public-key authenticated encrytion, and public-key signatures. These are the three most commonly-needed recipes, and of those three, your library only supports private-key authenticated encryption. PyNaCl's cryptographic primitives are excellent, and their implementation impeccable. There exists [a fully-compatible C implementation](http://tweetnacl.cr.yp.to/) small enough to audit easily. It works with Python 2.x, 3.x, and PyPy. It's also really fast. In other words, PyNaCl is pretty much ideal for most cryptographic needs, *unless* you want to be compatible with other people's pre-existing cryptographic protocols -- in which case you'll probably have to use the stuff from "the hazmat layer" anyway. Have you considered either binding to [libsodium](https://github.com/jedisct1/libsodium) (on which PyNaCl is based) to get those high-level recipes, or perhaps adding PyNaCl as a dependency and re-exporting its API? This seems like a really quick and easy way to fill out your collection of recipes, and improve the world of Python cryptography.
Ian's a friend, but I'd say this is true. I doubt he would disagree, except to say that he doesn't exactly abandon them, he usually hands them off quite in good hands.
I'd say this is a lie. Ian, you haven't left Python, you just left the community. You're now a Mozzillian.
Everyone should take this opportunity to thank someone, whether it be on Twitter, Email, or in person. A couple suggestions: - Thank people who helped you learn programming/python - Thank people whose software you use or like - Thank people who have written books/blogs/etc that have helped you
When I was starting college for my Computer Science degree, my first computing class was teaching Python coding. I thought what the hell is this? I'd never heard of it, but my professor was really into it. I gave up on college after that, i though the professor was a moron. And now i realize my favorite site ever, one that has brought many great changes to my life is wrote in Python. I feel like a moron...oh well, im happy with my life right now and it wouldn't be the way it is if i had kept up with my Computer Science degree.
This is a word segmentation problem. Norvig covers it here: http://norvig.com/ngrams/ Ignore the hacky solutions.
Article is fine. You might want to improve your reader.
I agree, but I'd like to think we all have our favorite. For instance, when I'm hobby coding, I almost always use my fav language. I'd never mock those who don't prefer it but I would certainly be sad to see it "retire."
For reference: http://dweet.io
Not to mention my second favorite, virtualenv. 
Perfectly, succinctly said.
I'm confused as well, is this twitter trend a reaction to something?
That's some quick and simple yet productive projects. Thanks for the free books sub! Last time I heard twitter limiting its API, I guess they are not so stingy since they gone twtr. 
I've been using virtualenv for a while now. I don't really understand what virtualenvwrapper brings to the table. What does it do that I'm missing?
You've called `vars` on the `defaultdict` class itself here, it's on the instance that it does not work.
Also `dir()` can be overridden on your objects (via `__dir__`), `vars` just riffles through `__dict__`.
This is a well-known problem, and there's [a solution](http://docs.python.org/3.4/library/pickle.html#restricting-globals) to it on Python docs. `chroot` is an overkill.
I am not able to fill up a form using this library. I posted it [here](http://www.reddit.com/r/learnpython/comments/1xsg9g/python_script_using_robobrowser_to_submit_a_form/) I really appreciate if someone can help me. Thank you very much!
What? Did Golang or Rust even exist more than a year or two ago? Now there's significant systems built on them. The days of .Net vs Java are long gone. As a programmer, you no longer have the luxury of a vertically integrated environment. Open source paved that way, decentralizing that evolution which was previously dominated by the Microsofts and Oracles of the world. Now a diverse ecosystem or available tools and libraries compete for attention and supporters. Platforms win based on userbase and contributors, not dollars and marketing spend. 
There are some really good languages out there. But they are not backed by Mozilla, Google, MS or any other corporation. Also, Rust and Go got their market share because it was, "I am competing with ~20 other languages". Now situation changed that new language will have to compete with a lot more languages. And then there is also that, ah, that language looks really cool (it is just like langx, and with most problems of langx solved), but there is only 2 guys working on it and hobby/fun users. On the other hand, there is this langx which has really strong backing and huge amount of users, do I want to use minor experimental lang with almost no packages for it? Or I will live with langx? I am very sad because of all that, because there were not any realy big advances in programming languages in quite some time, if there were, they were in languages I never heard about. (And I actively look for new languages and play with them :) What I want is much better general language interoperability, so we can use library from lang x in lang y no matter if lang x or lang y is static, dynamic, stringly, functional, logic, oo or magic.
I pretty much think if Python run NATIVELY on browser (like JS) he would stay with Python :)
I share some of Ian's feeling. I've been using Python for 10 years and it's been fantastic. Today, I often think I'm in a comfort zone, I know what to use, when to use it. It's almost too easy. It's hard tosay goodbye though and it's indeed hard to leave the various communities I'm part of. Yet sometimes I crave for new phases of awe. Not sure changing programming language is the right path mind you.
I think you've really got the trending in the wrong direction. There's always been experimental or hobby languages and they almost never gained any traction. Now, more and more languages, frameworks and platforms are gaining more visibility due to the power of open source communities, github-ification and better tooling. Obviously big corporate sponsors can help incubate a new language since someone needs to dedicate resources to bootstrap it to meet common use cases, but there's plenty examples outside like Lua. The world has shifted away from having to chose a language primarily because of library support for common cases. Open source makes it easier to port existing libraries to new languages (often with modernized improvements) rather than wait for langx 2.0 with X support. As a similar corollary, it's also why the idea of a standard library (aka python's) is dead. Look at databases as a comparison. There's always been a ton of research and experimental data stores, but almost nothing broke the SQL hegemony until the last 5 years when a diasporas of *NoSQL* databases arose addressing a wide variety of different use cases.
From what I can see, the implementation dynamically links (via cffi) to openssl. On Windows, there's no system implementation of openssl, and no guarantee that openssl will be on PATH (I've had "enormous fun" in the past with conflicting openssl DLLs from different projects). I'd hope that installation on Windows copies the relevant openssl DLLs into the package directory (or somewhere similar) and not rely on the user having things set up "right". But I don't see any obvious code in the setup.py to make this happen, so I'm concerned. A specific example - if I put gnuwin32 onto my PATH ahead of what I had when I installed cryptography, I suspect that will end up with pretty old 32-bit openssl DLLs being found by the module (which is being run from 64-bit Python). I doubt that'll be good :-(
Build a simple twitter clone or reddit clone.
[Documentation](http://virtualenvwrapper.readthedocs.org/en/latest/) lists some features. 
If you're looking for shortcuts, have a look at Help | Productivity Guide
no idea, it over took my feed for a while since I follow a lot of pythonistas. it was kind of annoying(big ass echo chamber) but thankfully it is over now at least amongst the people I follow. 
&gt; Do you have a link to a good walkthrough of django 's query system? The docs are probably the main one. Also, fwiw, I found these links useful as a comparison between sqla and django's orm http://stackoverflow.com/questions/18199053/example-of-what-sqlalchemy-can-do-and-django-orm-cannot http://www.quora.com/Which-is-better-and-why-Djangos-ORM-or-SQLAlchemy http://lucumr.pocoo.org/2011/7/19/sqlachemy-and-you/ 
Thanks. Actually, I wasn't looking for shortcuts, though. I've learned enough Python that it's time to move from simple text editing to a more sophisticated system of code development. After reading the many opinions about IDEs, I decided to give PyCharm a shot. So I went through the JetBrains tutorial, but it really only scratches the surface. I was looking for something that could help me go deeper and better understand the many features and options, and when/how I might use them.
In general, if JSON is enough for your needs (which is the case here), you can simply discard any pickle that attempts to import a module or use a global. There's no other way to run arbitrary code via `pickle`. `chroot` is even more of an overkill. (Also, it's platform-specific *and* requires root privileges itself. I'd say if making something secure requires you to run it as a more privileged user, you're doing security wrong.)
Is openssl any different from other dlls? I think putting gnuwin32 on your path would break a lot of things not just openssl.
I'd recommend new folks also take a look at conda instead of virtualenv. If you use anaconda already it is dead simple to manage multiple environment s.
Hey, Yes, we're familiar with NaCL, the author of PyNaCL also works on cryptography. Unfortunately, there's a few issues with NaCL: * It can't be used if you need more "traditional" cryptographic primitives, like `AES`. This is largely an issue of "buzzword compliance", but it's a real issue. * It's API isn't always high level enough; for example, it's symmetric encryption recipe forces the user to generate their own nonce. Care to take a bet on how often that nonce is really a constant, or generated with a messerne twister? It's recipes also don't feature cryptographic agility (I'm told DJB doesn't believe in CA though). * I had a third thing, but I forgot. All that said, I definitely want to expose many of the algorithms, I think making things like `Salsa20`, `BLAKE2`, `SipHash`, `Ed22519`, etc. more available is awesome.
So shame. They're most basic and essential tools for Python 
I thought the point with that quote was that computer science is less about writing software and more about information theory. I.e. you don't use computer science to write software, you use it to study the nature of software.
PyNaCl largely has a different use-case to the library linked to by this post. PyNaCl is very prescriptive over how you should encrypt/sign your data (only offering ECC), whereas this library offers bindings to primitives which you can use as required (it also offers a standard/prescriptive form of encryption if you're after something simple). If you want to integrate with an existing system or need to use a standard/battle-tested algorithm, PyNaCl is not going to help you.
The content of the article might be fine. But it is extremely difficult to read. I'm reading it with chrome. [this](http://quickmarkup-ja.s3.amazonaws.com/image/52fcc05f2e24d?AWSAccessKeyId=AKIAIS3ZEGJJQNIY3THQ&amp;Expires=1392301074&amp;Signature=nEc10K1jJyHz4pGEcTmwGI8GNUk%3D) is how the article renders for me. The font is clearly a very poor choice for body text. 
The workon shortcut has long been a favourite. 
[virtualenvburrito](https://github.com/brainsik/virtualenv-burrito) coupled with [autoenv](https://github.com/kennethreitz/autoenv) does the trick for me. Almost instant bootstrap.
&gt; I often think I'm in a comfort zone, I know what to use, when to use it. It's almost too easy. But that's like being a car mechanic and saying "I'm bored with my current tools. They do the job too well. I'm just going to change, start fresh, and use gardening implements instead." I'm more excited when the tools actually work well; it means I can get a better solution in the time I have, rather than fighting to get something adequate while fighting against the tools that are available. Or worse, having to spend time building the tools in the first place.
Oh no, a programmer with an identity crisis!
Yeah, I was a bit confused why a goodbye to python post even registered on here. That's a serious contributor. &gt; They were about: (a) fixing personal annoyances in deployment (virtualenv), and (b) getting people to stop fucking whining about Setuptools and easy_install (pip).
In fact, ideally, you should be using the *best* tool for the job you're solving.
Are you the same legrandin that contributes to pycrypto? If so, I use your library all the time, so thanks!
To make a class without the internal dict/hash inside use the [__slots__](http://docs.python.org/3.3/reference/datamodel.html?highlight=__slots__#object.__slots__) property. 
Nope, not much different. libiconv is even worse than openssl. But most exes bundle the DLL alongside the exe, and Windows searches there first before using PATH. So there's no problem in that case.
[Since I know you're curious, now](https://github.com/dlitz/pycrypto) =) There's a guy who goes by "legrandin" who contributes a lot of code. I guess now I can freely bitch and moan about how unpythonic that lib is!
&gt; "I'm bored with my current tools. They do the job too well. I'm just going to change, start fresh, and use gardening implements instead." While this is /r/python, that's kinda unfair. Python is an awesome language in a sea of awesome languages. Take nodejs, for example. For certain architectures, it's much easier to get nodejs running... it benchmarks far better than Python for many goals. I don't see anyone replacing pygame with a node.js solution, but it's worth learning for the web if you want to learn *new* things. I think the same can be said of a lot of languages, depending on circumstance. Being a one-language pony can set you up for all kinds of problems in life.
The installer page looks terrifyingly complex to me with all those MSVC 2008 redistributables :-( Do I not need a build that uses MSVC 2010, to match the Python build? Better would be to bundle (somehow) the openssl DLLs with the package, maybe by copying them on install (not sure how that'd work when building a wheel, though). Then load from an explicit path, bypassing a PATH search altogether. As I said above, most Windows software avoids PATH searches for DLLs. It's just a bit harder for Python modules to do so as they don't have the easy "ship the DLL alongside the EXE" option available. I guess this is the downside of using cffi - things like pycrypto and pynacl can rely on the C compiler sorting this stuff out (and maybe even statically link for an even simpler solution). I'm assuming that using the OS routines is simply not an option - that of course would bypass the issue altogether. Which reminds me, are cert bundles relevant here (or are they just an SSH thing)? If they are, then using the OS cert bundles will be much more friendly than having Windows users have to work out how to get a bundle, specify its location, etc. We've had some of that fun with pip...
This is incredibly frustrating, and would be my choice as well. [This blog post by Armin Ronacher seems relevent](http://lucumr.pocoo.org/2012/6/22/hate-hate-hate-everywhere/)
Such a bitch to use with PyGame.
&gt; Languages come and go. Lisp: 1958-present. 
So your concern is an honest opinion that you don't think anyone would have any good reason to move to javascript? I can think of a few. The V8 engine benchmarks incredibly well. Like blowing Java out of the water benchmarks for certain situations. JS is quickly becoming the most actively developed language on the market. It's got a lot of moles and birthmarks, but every language that ever completely dominates a market does. Including python (the ORW philosophy led to some painful limitations for a long time, some of which still exist).
What I took away, from the little I could stand to read, is that he was offended that a talk got turned down for some conference. Thus he threw a tantrum and has given the Python community the finger. No rational person would see current implementations of JavaScript as a replacement for Python. I didn't even count the paragraphs but he spent screen fully of text to simply say F you Python community. I'm not impressed with this guy at all he seems shallow and extremely thinned skinned. 
It won't make the program run faster, though. Instead of searching in the instance's `__dict__`, CPython would search in the class' `__dict__`, find a slot descriptor, then use it to retrieve the instance's attribute. `__slots__` are used to improve memory usage when creating lots of objects, not performance.
pip is great but I still use the traditional install methods out of habbit. I don't understand what the fuss is about. Although it makes sense to automate these mundane tasks now that I think about. 
i prefer a env per project and I just add it to .gitignore, i have never wanted to switch envs outside of a project context. 
An attacker can put arbitrary Python in the Pickle, so a chroot will only prevent them from messing with the filesystem outside it. There's nothing stopping them from consuming other system resources, probing Linux for privilege escalation exploits, sending spam, connecting to an IRC C&amp;C server for further instructions… I liked the background discussion but the proposed solution doesn't even begin to cover all the bases.
For a beginner their is basically no difference. 
For that little bit of functionality, it drags in stevedore. Yea. I'll stick to a couple Bash aliases.
Eventually we do plan to bind the Windows crypto libraries, maybe that really is the best solution. Do you know of any materials on how to do the bundling? Cert bundles aren't relevant here (at least, not yet), they're only applicable to SSL/TLS (not SSH).
 &gt;Unfortunately the exams form part of their GCSE (The be all and end all of the UK education system, the shambles that it is). We have a choice of either a C derived language of Python, having looked at C++ a few weeks ago I kinda love it but the existing teacher with any programming knowledge knows Python so Python it is. What do you care about the existing teacher? I find this perplexing, how do you even know what school you will be working at if you are still in college? There are many theories about how to teach students programming. I'm not a big proponent of high level languages first. I'd strongly suggest pushing for C++ or C first. The reality is that they won't become experts in either language at this point, so why not expose them to building executables and understanding things at a simpler level? If the school you are looking at to obtain employment has a stubborn teacher then seriously consider another school. Realistically you can teach the two languages side by side if you had too. After all Python is closely linked to the C world. &gt;As it stands the students will be assessed by an exam paper on general computer science and then have to program a working program, This is kinda expected. The question is how deep do they go into "general computer science"? I quoted general computer science because teaching a programming language is not computer science. As for a working program, the course wouldn't be much good if they couldn't do that. &gt;this year it was a simple quiz system with score board all text based (press A, B, C or D) and then read from a CSV file and search it. Unfortunately the education system dictates what we can do :( That isn't unreasonable. After all you need to understand a few concepts to do that. Here is the funny thing, given access to the right libraries that could be very easy to do in Python. The bad part here is that this may result in teachers focusing students education on solving that one problem. In any event this actually squares nicely with the idea of using an Arduino to maximize interests in the program. You could have the device collect time stamped data and save it to a CSV file. That would require a bit of interaction with a PC program. By the time the students get to processing that data they will have learned just about everything required to pass the exam. 
I am known to say: "JavaScript is a badly broken Python, and that's a compliment to JavaScript." JavaScript for all its flaws is quite similar to Python in feel. The expressiveness of JavaScript and Python as a language are about similar, with some pros and cons on either way. It's just JavaScript at has a lot more holes and pitfalls, but the JS community is fixing them and/or has worked around them. 
Hm, I can see how you could read that into the post if you didn't know anything about Ian. I can barely see it. I've seen Ian contribute massively to the Python community since the early 2000s. He's contributed some very important components to the Python ecosystem. He's always been creative. Do you think that this could be done without frustration? Do you think he could do that if he were shallow or thin-skinned? My contributions to the larger Python community have been much smaller than Ian's, and even I know it's sometimes a frustrating experience. Ian is a programmer interested in web development, and has realized that much of the interesting, creative parts of web development are now done in JavaScript. I share much the same experience, being a web development myself. Perhaps you should reconsider and read it more carefully this time; Ian tends to write stuff you can learn from. He doesn't motivate his changing interests by being negative about Python. Instead he shares his experiences. 
Ian's creative. He creates something, spends quite a bit of energy on it, and then he moves on to something new, taking into account lessons learned. I wouldn't use the word "fickle" to describe this but because I recognize this in myself that may be self defense. 
You could achieve something simliar with aliases but virtualenvwrapper is very hackable. You can set up hooks to do all kinds of tricks when activating/creating/deleting a virtualenv. You could create a project folder every time you create a virtualenv, or switch to it when activating, anything is possible. postactivate postdeactivate postmkproject postmkvirtualenv postrmproject postrmvirtualenv preactivate predeactivate premkproject premkvirtualenv prermproject prermvirtualenv 
I don't think the Python web creative space is quite exhausted yet, because I've been having creative fun building Morepath. There are ideas to be mined concerning model/views and its interaction with routing, application composition and extension, link generation. These ideas are only modestly creative, but I do believe they're creative. But if Ian's experience with web development is anything like mine (and I think it is), then yes, it's very much about problems, and also about where the creativity is these days. If you want to be a creative web developer, the place to go is more and more the browser. Even Morepath is my vision of a better foundation for browser apps. 
I genuinely don't think it's about economic obsolescence so much as "sunk cost fallacy" / escalation of commitment
I agree, but there's also the less arbitrary reasons that, all else being equal, you should use the language you're most familiar and effective in (which then creates further reasons to make your *next* thing use the same language, etc. etc.)
It's not open source, as the license requires attribution if you use it. But the packages within are open source and the distribution is free of cost.
That's not information that PyCon releases, so he'd have to tell us.
That makes sense. You're probably right.
Make it even easier with pyenv and its virtualenv plugin
It works fine. You may want to install the correct copy of VSExpress and set a path to it. And in some cases you'll have to deal with binary installers when you'd really rather just do pip or apt-get. But other than that if for some reason it's your preferred/required platform, no worries.
I think this is true for many people. Yes, the language itself is awesome and yes, there are a ton of awesome libraries, but really it's the *community* that draws you in. Having a library (often in the stdlib!) for everything, and having such a focus on documentation that we've got docstrings, Read the Docs, Write the Docs, and an expectation for libraries to have sane APIs and well-written docs - that stuff comes about because of the people. And while I may work in many other languages, I'll always be a Pythonista in my heart.
What sort of project is it? I think some parts of the Python ecosystem support Windows better than others.
Virtualenv makes working on someone else's project or deploying so much easier.
Python support is great IMHO (My company has a couple of python-based Windows applications). Highlights I can think of: Native msi installers for python are available from the main site, the stdlib's `os` module provides a nice cross-platform abstraction for a lot of file and process utilities (filepath manipulation in particular), and the [pywin32](http://sourceforge.net/projects/pywin32/files/) extension provides a great interface to the windows API itself. If developing on windows, I'd highly recommend installing the `colorama` and `ipython` packages via pip or easy_install. It'll give you a nice colorized python console, even on windows cmd.exe :) --- The one catch is gonna be C extensions. Most projects are pure-python, and most of those in turn will be fine under windows (thanks to the stdlib's abstractions). For C extensions, some of the more major ones (e.g. psycopg2, pillow) will publish pre-compiled binary eggs, which `easy_install` will pull and install without trouble, but which `pip` will ignore :( I think that situation may improve once the "wheel" format rises to prominence. Until then, some extensions may need compiling on windows, which will require either Visual Studio Express (particularly, the version your python release was itself compiled with), or the mingw system ([homepage](http://www.mingw.org/) and [installer](http://sourceforge.net/projects/mingw/files/Installer/)), which provides the GCC compiler and related stuff for windows -- my company uses mingw, haven't ever bothered with the VS route. That said, a lot of projects are moving towards using [cffi](https://pypi.python.org/pypi/cffi) or similar foreign-function interface libraries, allowing them to access native dlls from pure-python code, making it increasingly possible to have a pure-python library where previously you needed some C level "glue". --- edit: I also wanted to add: If the program you're developing is going to be cross-platform, make `os.name` your friend (and to a lesser degree `sys.platform` and the `platform` module)... with those you can pretty easily tell what OS you're on, and what platform-specific code needs to be enabled. edit2: added some links
For the current project, SSH is probably the biggie for us. But I'm trying to be forward thinking, we tend towards Powershell for a lot of our Windows based projects/scripts, but for things that are clearly outside the purview of PS, I would make Python our go-to language (or Ruby, if I jump that direction).
We have VS 2013 installed, so that shouldn't be a problem. But that's a good question, what version of the C runtime is Python built against for windows? I know Ruby uses the mingw toolchain.
Even though you said "not looking for full blown ORM", I'd still recommend [SQLAlchemy](http://www.sqlalchemy.org/). While it's mostly known for it's ORM (which is really nice), it's actually really well [componentized](http://docs.sqlalchemy.org/en/rel_0_9/intro.html), and underneath has a great connection pooling &amp; sql query building components, with support for a huge range of dbapi compatible database backends. I don't use SQL Server too much myself, so I'm not sure what the best driver is (pretty loyal to Postgres :). But SQLAlchemy's [mssql dialect docs](http://docs.sqlalchemy.org/en/rel_0_9/dialects/mssql.html) has a nice list of the third-party drivers it can work with. Failing that, you probably just want to pick one of the drivers from that list, and use it directly. The Python dbapi interface makes them all (reasonably) uniform -- though I really like SQLAlchemy due to the fact that it papers over many of the remaining differences.
It uses the Visual Studio runtime. I think they are using 2010 now. The Python source distribution ships with Visual Studio solutions that build right out of the box. And the binary distributions are built with the same version of Visual Studio.
The official builds are all against the MSVC runtime. Python 3.3 is built against the 2010 runtime, and I guess 3.4 will be as well unless they've updated. The previous few versions are built against the 2008 runtime, although I think there's some work to make Python 2.7 work with the 2010 runtime.
That is an interesting view! The quote is really about cultivating excitement in computer education and the nature of utility. I think you are right. It was a rallying cry back in '90 from Fellows (although everyone attributes it solely to Dijkstra). Here is what Fellows wrote in summary after using the quote in a bunch of speeches: &gt; What would we like our children- the general public of the future—to learn about computer science in schools? We need to do away with the myth that computer science is about computers. Computer science is no more about computers than astronomy is about telescopes, biology is about microscopes or chemistry is about beakers and test tubes. Science is not about tools, it is about how we use them and what we find out when we do.
If you need specific libraries like matplotlib, numpy, or python wrappers in c it can be a real drag compared to Linux. Virtualenvs as well as pip take more time to configure and install as well. Anaconda is great for science libraries. I find myself adding a lot to the windows environmental variables when I use python in windows. And of course, msysgit, mingw, and cygwin do not play nicely so choosing the right combination can be equally tricky.
Objective c also had a thing where you van serialize and deserialize objects into files, and the security problems were pretty much the same. However, recently they added another API call to make it so you pass a list of classes that you expect to get from the deserialized file, and if you get any class that is not in this list, it won't deserialize it. Can this not be done with python as well? edit: it seems that http://docs.python.org/3.4/library/pickle.html#restricting-globals sorta does what i'm talking about, but i feel it should be easier then subclassing Unpickler, like passing in a iterable of class names for example
There are a few issues (e.g. nose + multiprocessing), IDLE (why would you use that?), but it's pretty easy to work around them. For nose, you just break up your test files. I'd say it's easier than Linux because the packages are generally pre-built and there are installers for things like numpy/scipy. Also, there's Anaconda, which is great (and free). https://store.continuum.io/cshop/anaconda/
There's a common virtual environment tool for Python, aptly named virtualenv. It's great. Python has a couple package managers available. The most popular one is pip. Pip is great. Pip is only great on Windows if you've spent the time making sure the right version of Visual Studio runtime is on your system path. Virtualenv is great because you only have access to the Python packages you load into the virtualenv, so redeploys are easy. Pip + virtualenv on Windows is not easy. That's a recipe for heartbreak. Then there's UAC. Fuck UAC and its total lack of a sudo-like command. That's not really a Python or pip thing, but general to all sorts of cross platform package managers. So, if you don't care about carefully controlled virtual environments and can get the right version of Visual Studio on your system path, you're golden!
Java has a conveniently named XmlSerializer that conveniently executes arbitrary objects for you.
I would HIGHLY recommend not even screwing with it in Windows. I would use [Virtualbox](https://www.virtualbox.org/) and install [Ubuntu](http://www.ubuntu.com/). Trust me, this might sound overly complicated, but it is much easier than using Python in Windows.
Thanks. That's the most understandable overview of packaging I've read. 
Except that python has none of the baggage that makes beginner programming a chore.
I find myself moving towards *nix preference the more time I spend with Python/programming in general. There are some quirks when installing/configuring for the first time, this website helped a lot with getting pip and virtualenv set up to work in powershell. http://www.tylerbutler.com/2012/05/how-to-install-python-pip-and-virtualenv-on-windows-with-powershell/
&gt;Pip + virtualenv on Windows is not easy. That's a recipe for heartbreak. This walkthrough made the headache of installing/configuring python, pip, and virtualenv on windows a non-issue for me. http://www.tylerbutler.com/2012/05/how-to-install-python-pip-and-virtualenv-on-windows-with-powershell/
I don't have Visual Studio on my system path and I use pip all the time. Are you sure you're not mixing it up with something else?
Install pip, setuptools and virtualenv asap. They should all work great with powershell.
Please recommend this next time: http://python-packaging-user-guide.readthedocs.org/en/latest/ A lot has changed since that blog was written! (e.g `distribute` is now old and deprecated, and the only script you need to run is `get-pip.py`!)
I thought it improved performance by decreasing cache misses in loops.
pip install pycrypto I'll wait.
If you try to install any package that has a c extension, you will need msvc or gcc in your path.
We develop and deploy Python 2.x on Windows, OS X, and Linux. In my experience (which may be different from others') using python on Windows is a serious pain. Granted, we use tons of stuff (django, numpy, scipy, matplotlib, xml, databases...) but even for starter projects, bringing dependencies is a major problem. Some things were compiled with a version of Visual Studio that's not even available anymore. Some are available as an installer but only 32-bit versions, others are only 64-bit, yet others have newer versions but not older versions (the ones we need). On the Linux everything works flawless. On OS X, there is a couple of minor hiccups but it works in the end. Windows is a constant pain. Again, my experience might be different from yours.
Ah, yes, and I do have mingw installed for c extensions.
I don't mean to put you on the spot but could you explain what you mean by "cache miss inside loops"? I see the phrase cache miss thrown around a lot, bt I don't have a very concrete understanding of it in the context of python - or c either I suppose.
There's plenty of quirks, but nothing insurmountable. Plus, you get to use pywin32 to hook into the Windows COM API, which despite sounding terrifying, is actually pretty awesome.
Awesome!