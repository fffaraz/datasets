Oh, so you are JimmyR!
Excellent post :) made me look up a few things and found a few new stdlib modules. For example, a portable way of getting the current user is implemented in the getpass module. import getpass user = getpass.getuser() http://docs.python.org/library/getpass.html
You can also use SHGetFolderPathA and SHGetFolderPathW (ANSI/Wide character) directly from shell32.dll: import ctypes from ctypes import wintypes SHGetFolderPathW = ctypes.windll.shell32.SHGetFolderPathW SHGetFolderPathW.argtypes = [wintypes.HWND, ctypes.c_int, wintypes.HANDLE, wintypes.DWORD, ctypes.c_wchar_p] The tedious part is typing in the defined constants. Below I've grabbed some of them from win32com.shell.shellcon: from collections import OrderedDict, namedtuple CSIDL = OrderedDict( (('PROFILE', 40), ('PERSONAL', 5), ('MYMUSIC', 13), ('MYPICTURES', 39), ('MYVIDEO', 14), ('DESKTOP', 0), ('DESKTOPDIRECTORY', 16), ('FAVORITES', 6), ('RECENT', 8), ('SENDTO', 9), ('TEMPLATES', 21), ('STARTMENU', 11), ('PROGRAMS', 2), ('STARTUP', 7), ('ADMINTOOLS', 48), ('NETHOOD', 19), ('PRINTHOOD', 27), ('APPDATA', 26), ('LOCAL_APPDATA', 28), ('CDBURN_AREA', 59), ('INTERNET_CACHE', 32), ('COOKIES', 33), ('HISTORY', 34), ('COMMON_DOCUMENTS', 46), ('COMMON_MUSIC', 53), ('COMMON_PICTURES', 54), ('COMMON_VIDEO', 55), ('COMMON_DESKTOPDIRECTORY', 25), ('COMMON_FAVORITES', 31), ('COMMON_TEMPLATES', 45), ('COMMON_STARTMENU', 22), ('COMMON_PROGRAMS', 23), ('COMMON_STARTUP', 24), ('COMMON_ADMINTOOLS', 47), ('COMMON_APPDATA', 35), ('WINDOWS', 36), ('SYSTEM', 37), ('SYSTEMX86', 41), ('FONTS', 20), ('RESOURCES', 56), ('PROGRAM_FILES', 38), ('PROGRAM_FILES_COMMON', 43)) ) CSIDL = namedtuple('CSIDL', CSIDL.keys())._make(CSIDL.values()) And here's a simple loop to print out the values using SHGetFolderPathW: path = ctypes.create_unicode_buffer(1024) for k, v in CSIDL._asdict().items(): result = SHGetFolderPathW(0, v, 0, 0, path) print("{0}={1}".format(k, path.value)) 
Noticed you made that change to the code. You can get rid of the Darwin elif it will work there as well.
What is the best platform independent way to find the filename if I am given the path of the file? This is with reference to [the script](https://github.com/shadyabhi/pLibraryOrganizer) I made a while back which works only for linux. I simple searched for a "/" from the right. Also, after reading your comment, I will implement os.path.join &amp; read the whole PEP 8 to improve my code quality. 
Thanks!
Sweet! Love this idea. Hope all the critics who know Python are sending you pull requests. 
`os.path.expanduser("~")`
doh ... thanks!
Nice :) One thing I noticed (as of 2ef73f1d253d27f8a0db38fd1dc1ada5a4c195c1), should you be using os.sep instead of hard coding the '/' in the directory construction (or better, [os.path.join](http://docs.python.org/library/os.path.html#os.path.join))?
We aren't quite sure what the limitations are just yet, and the foreign function interface to c is a little goofy, but if you have a Maple Native or a Maple RET6 - run it and let us know what you think!
Please see my answer to another post... http://www.reddit.com/r/learnprogramming/comments/jtrkz/if_im_trying_to_learn_how_to_program_which/c2f2wvp
Isn't it easier and better to just use a proprety decorator for the first use example ? class Person: def __init__(self, salutation, forename, surname): self.salutation = salutation self.forename = forename self.surname = surname @proprety def display_name(self): parts = [] if self.salutation: parts.append(self.salutation) if self.forename: parts.append(self.forename[0] + ".") parts.append(self.surname) return " ".join(parts) 
To quote from TFA: &gt; Of course, the same goal could be achieved by using a display name property. By using a descriptor, however, we can create as many display name attributes as we like, in as many different classes as we like—all getting their behavior from the descriptor with a single line of code for each one. This design eases maintenance; if we need to change how the display name attribute works (perhaps to change the format of the string it returns), we have to change the code in only one place—in the descriptor—rather than in individual property functions for each relevant attribute in every affected class.
Oh absolutely I think that's the right way to do it, that's exactly the route I'm advocating. I only believe this because I worked on a commercial product written in a functional-only language for a few years.
thank you!
strange...I had a project with pyqt and it's work fine, just exclude the dll in the build script.
Nice, very powerful. Particularly liked the validation example.
As a learning experiment, that's pretty cool. However, I'm not sure it has much utility given that it's pretty much duplicating the standard `shelve` module, just using a different back end.
Why are you storing 'Hist' as a pickled list, and not just as items in a database? e.g. multiple entries with the same Key but with a different revision_id, or something like that - after all, being able to query relations in interesting ways is what a database is about. Storing data as a pickled list does not allow this. EDIT: after re-reading my comment, this sounds a bit negative. Overall it's a nice project - this is just a general comment on how to improve it :-)
I'd recommend you get learned up on DBs as well. When we would try to hire GIS people we were very frustrated they didn't have any DB knowledge. Unless you go into GIS development you'll use DBs far more often than you will programming. Not saying don't learn programming, it just won't be used as often as databases. 
I wish I had time to contribute with code, but hopefully my small donation will help some. We need PyPy!
by preventing PyPI downtimes ? The mirroring infrastructure was built to solve this. (PEP 382) A dedicated service sounds like a useful thing though, if there's a way to push private packages as well, with some kind of auth
 &gt;&gt;&gt; import os &gt;&gt;&gt; os.path.basename('/jingle/bells/all/the.way') 'the.way'
Maybe I'm just blind and can't find it, but is it possible to see how much has been donated so far somewhere?
not yet, we'll get there though
Awesome news. and this puts all those frameworks that depend on webob a heck of a lot closer to supporting python 3. looking forward to the onslaught of those announcements. 
Granted, I've only made one site before, but I used webfaction and it's Django/Python support was great even for this noob.
What advantages does this offer over using generators?
Can someone say what splinter is?
Np. I find that even if the project isn't at that stage yet, it still kinda saves time and gets you in the right mindset to start off a new project with all of that stuff already in there. I forgot if my code had authentication. I forgot why I wrote it when ask had already written one; I think that Github API v2 had come out and his code didn't support it yet. I use my code for [my website's](http://jmoiron.net) github integration on that little stream there on the front page. Once I got what I needed, I didn't really polish off the library.
I'm really into moving things into the 3k zone, I chipped in a few bucks.
yep that is what I was leaning at. :)
has hylje said above, isn't it just os.path.expanduser("~")? This also works on windows so you don't have to have silly if not windows: if /else statements
Am I the only person that prefers Python 2.7 to 3.2? Phillip.
Maybe now, because 2.7 has (almost) all of the features of 3.2, but presumably future releases will be markedly better than 2.7.
Why do you prefer 2.7 over 3.2? I only use Python 2.x currently and can't move to 3.x for anything at the moment. I can see that the using to 3.x can be limiting because of current library support etc. Although 3.x seems "cleaner" to me, the changes don't seem compelling reasons to switch, but what do you actually think is worse? 
Woo, good timing: I'm a master at Python and am really interested in music generation/editing with it. I can see why the "Python in Music" page is overwhelming. There's tons of stuff I hadn't seen -- thanks! It looks like most of the projects are... unbaked. I suggest looking at these two: PyAudio: very simple: http://people.csail.mit.edu/hubert/pyaudio/#docs Pyo: being developed: http://code.google.com/p/pyo/wiki/Introduction post what you find! 
here we would be an implementation on top of web2py DAL that would work with any DB class SQLdic: def __init__(self,uri='sqlite://storage.db'): self.db=DAL(uri) self.db.define_table('values',Field('key'),Field('value')) def __setitem__(self,key,value): key,value = pickle.dumps(key),pickle.dumps(value) rec = self.db.values(key=key) rec and rec.update_record(value=value) or self.db.insert(key=key,value=value) def __getitem__(self,key): rec = self.db.values(key=pickle.dumps(key)) return pickle.loads(rec.value) if rec else None 
Thanks.
I've fooled with pyaudio a bit, it's really easy to use. It doesn't seem to support MIDI as such, but since you want to use Python in the first place instead of any of hundreds of existing trackers, you probably want more control over what you do, don't you? So just create/load raw waveforms using pyaudio, modify/mix them using numpy (google "pyaudio numpy" for examples), feed the result back to pyaudio. I'm not sure if you'll be able to achieve sufficiently close to realtime performance, even using numpy, though.
Sure. [Splinter](http://splinter.cobrateam.info/) is an open source tool for testing web applications using Python. It lets you automate browser actions, such as visiting URLs and interacting with their items. 
How to use that? Could you paste here the command-line command with all the options? Thanks.
Borland's compilers were bought by a company named Embarcadero. Seems to be going strong. http://www.embarcadero.com/products/delphi
I think that's the point though. Python 3 was released without cooperating with library creators and now after nearly 3 years most libraries still don't support python 3 and some don't see support any time soon. You don't rip apart a mature language for the sake of being "clean". Guido fucked up big time.
Thanks for the advice! Appreciated.
My reply is not just that they're common, but that they're common in some of the most complex and widely-used open source projects that exist.
Please try splinter on Windows: http://www.reddit.com/r/Python/comments/kq4u4/please_try_splinter_on_windows/
You have to be a bit careful with using IOError because it could arise for other reasons. For example if a WSGI middleware was attempting to read all content and save it to a file before then returning the file handle as wsgi.input to inner WSGI component. You couldn't then distinguish between a IOError in reading original or an error in code dealing with wsgi.input. To be totally thorough it really needs to be a distinct error type or at least a derived IOError exception. In either case, only way for the exception type to be available is in the WSGI environ dictionary. Have you looked at Apache/mod_wsgi handling of chunked request content? Apache/mod_wsgi would likely do what you want in embedded mode but not daemon mode. The propagation of an error across to daemon mode isn't going to happen and would just finish with empty read. 
If languages do not evolve, they tend to stagnate. Python 3 as a language is better in many ways, IMHO. I don't see a reason why not do it. Implementation may not be as fast or as compatible but that's just the way it goes with all new stuff. 
Chipping in a bit. If donation campaigns like this are successful, maybe more projects would be willing to update to 3.x.
I ended up in the solution I did because I wanted to support list access and slice notation. This is something you cannot do with a generator based one. I admit using generators can be handy at times. In fact [itertools](http://docs.python.org/library/itertools.html) provides a few iterators like this.
Thanks for clarifying. I'd still say that your solution could be a bit more syntactically elegant.
I'm all up for language to evolve and I do agree that Python 3 IS a better language in many ways. But don't you think that it's slightly silly to create a backward INCOMPATIBLE version of the language simply to make it "cleaner" and ironically not share the same performance as it's predecessor (in some areas)? Django is the perhaps the most popular web framework for python and the devs don't plan on supporting python 3 any time soon. Why would anyone use python 3 when there's hardly any support? It's been 3 damn years already and it still hasn't caught up.
Care to share how? It's always interesting to see alternative solutions. :)
I don't really see the problem here. If you prefer using Python 2, use Python 2. Apparently Python devs just feel like doing more than just maintenance work. And that's ok too. Backward compatibility is a very difficult problem to solve if you want a clean language without any legacy cruft. For example "print" is not a statement but a function. That's a good change and an incompatible one. Honestly I don't see how it could be done any differently, unless you want to stop the development of the language entirely and just concentrate on libraries. Django not supporting Python 3 is about Django devs and Django users, not necessarily about Python devs or Python users.
Well for, one thing, and this might just be the Ruby talking, but I'd make zip and all that jazz not functions but methods of the class. Some of it is personal taste I guess.
How does this argue that it's good coding practice? It isn't. There are laws against murder, but this doesn't prevent it from being a popular pastime.
&gt; I'm not so sure that the WSJ really understands how software is built ... It really doesn't matter, because they relied on the views of someone who does know -- Jim Allchin, who had nothing to gain and everything to lose by decrying Microsoft's coding practices. &gt; It's quite a non-sensical statement that the software was "stitched together into one sprawling program". Yes -- unless it happens to be true. A bunch of coders working independently, writing modules they hope will turn out to function together, can't be compared to a tightly organized group working toward a single conception of the outcome -- the conventional expression of good coding practice. 
It's not about preference, it's about what we're left to use. If python 3 has as much community support as python 2, I'd use it but unfortunately, more than half the libraries I use for development purposes aren't supported. And what do you mean by Python devs or python users...python users ARE python devs. Django users ARE django devs. Django is just one example, there are plenty of other non-trivial libraries out there that just don't support python 3 in anyway. This makes development extremely hard. You try telling your boss to move your python 2 app to python 3 when there's no library support. Using python 3 for the sake of python 3 is stupid. You should only use a development tool if it makes sense, python 3 just doesn't make sense right now unless you're using it purely for scripting purposes and not writing a webapp. I don't agree on that print statement change is a good change. It's a logical change, but not a good one. A better example would be turning xrange into range and even making dict.keys() return a view instead of a list.
Righto. I just followed the Python convention there. :) It would be easy to write a wrapper class that allows you to treat them as methods. I guess this kind of wrapper should support chaining as well. Something like a.map(lambda ...).filter(lambda ...) seems kind of cool.
Yeah and, as you pointed out, implicitly anyone, if you implemented zip as a method, you wouldn't have to give it that "lazy_zip" name. Also, I'm not a big fan of isinstance, on the Pythonic wisdom "EAFP". But come to think of it ... if you polished this up a bit you could probably put it up on PyPi. 
&gt; ironically That's not ironic, your ironic!
Good point about PyPI. I'll muck around with it and get something up there. Now that I think of it, the monkey-patched zip and co. probably should support regular iterators (ie. itertools.cycle) as well. Now something like "map(lambda a: a * 2, cycle(1, 2, 3))" fails to terminate. Instead it probably should return an iterator that handles the map. I guess the package should contain the wrapper we discussed about as well. Thanks for the input. I really appreciate it. :)
I hope I didn't seem like I was busting your chops too hard.
Nah. It's good to get honest feedback. :)
I'm actually teaching myself Python 3. I did not know any Python before I started.
&gt; Honestly I don't see how it could be done any differently Maybe there could have been a way to make the transition a lot smoother. For example, the bytecode of old modules could maybe still be interpreted/exectuted, so we didn't loose all the cool libraries because of the transition. Or have a version that both interprets Python 3.2 and 2.7 depending on whether there is a special mark at the beginning of the 2.7 module, with a deprecation timeline of 5 years.
Actually, it might be interesting to split this project into two seperate goals: (1) generating the data, resulting in a generator (2) a list wrapper to allow list access to *any* generator (1) is indeed approximately equal to count(), but not quite, as your code can generate the fibonacci sequence (2) would be - in general - a very useful addition to python, imo.
Niiice. Well, I think I'll start looking at Python 3 now.
Neat idea! I'll split it up this way in the PyPI package.
Great idea! Maybe Software Transactional Memory can follow suit.
And if you just need to iterate over it (as in the zip example), you can just do: def infinite_list(n1, n2): step = n2 - n1 while 1: yield n1 n1 += step
&gt; python users ARE python devs...Django users ARE django devs. You seem to be confusing the idea of writing Python code with creating Python, and writing Django apps with creating the Django framework. There are maybe 25-30 active CPython developers, and some huge amount of CPython users.
PySide? I've never done much GUI myself, so sorry if it doesn't fit your description.
Tkinter, it even comes with python. It just takes a while to get used to.
wxPython's version of Glade is poor. Try using Qt and PyQt. The base layout inside QT's Designer (pyQt) allows you to place widgets exactly where you'd like to put them. You can then add sizer layouts more intuitively if you decide you need them to dynamically resize and align. However, sizers are still needed to dynamically resize widgets when the windows themselves are made larger / smaller either by dragging their sizes or hitting maximize. There's no way to get away from that unless you create windows that are stuck at a specific size.
I can recommend the following if you (or others) are looking for a dedicated python + arc web course: https://www.e-education.psu.edu/geog485/node/17 One of its writers taught me at another university using it as the main text.
I strongly recommend pyqt. I have multiple projects using pyqt and pyserial.
Use PySide and QML with the QML components additions. Makes writing GUIs bliss compared to everything else.
Does MySQL even have cursors?
tkinter is ugly! I used it on a medium size project and wish I would have gone with a different library
[PySide](http://www.pyside.org/) may be better for commercial uses since it's LGPL licensed.
You obviously haven't used ttk the comes packaged in Python 2.7+.
&gt; Django is the perhaps the most popular web framework for python and the devs don't plan on supporting python 3 any time soon. Python 3 porting is currently in progress. It is a priority for several core developers, but porting can be difficult to get right. Martin von Löwis has [a branch on Bitbucket](https://bitbucket.org/loewis/django-3k/) that has since been added as a branch in Django's official repository.
Cool, bro.
There is also pygtk. It has Glade (from which I think wxGlade is inspired) which allow to do quick GUI. Never tried PySide and QML but I heard it's great too
You can find my slides here [Secrets of PostgreSQL Performance](http://bit.ly/nOTub7)
There are a decent few with [PyCharm](http://www.jetbrains.com/pycharm/) and [Wing IDE](http://wiki.python.org/moin/WingIde) being popular. [PyScripter](http://code.google.com/p/pyscripter/) is a nice free one and I just purchased a license for [Sublime Text 2](http://www.sublimetext.com/), myself. There are also plugins for eclipse and Visual Studio. Finally, the Python Wiki has some charts: * [Editors](http://wiki.python.org/moin/PythonEditors) * [IDEs](http://wiki.python.org/moin/IntegratedDevelopmentEnvironments) 
You should just watch it.
FYI, despite the description in IDE's, I suggest ignoring the Ironpython Studio stuff. If it sucked any harder, it would take the paint off your walls. 
Obligatory vim
eclipse+pydev is pretty phenomenal and free
Eclipse+pydev if I need an IDE or gedit otherwise.
http://editra.org/
I guess I can switch from print x to print (x), stop using the % for string formatting, but some of it just seems to be going backwards such as no longer being able to unpack tuples from function definitions and changing dict. There don't seem to be any really big differences, and unicode support by default is nice, but like you I can't see any reason to switch. Phillip.
+1 from me, been using that exclusively for years.
upvote for gedit. It's a great all around text editor and it's cross platform.
You might try [Camelot](http://www.python-camelot.com/), which uses Qt and Sqlalchemy in a Django-like admin framework or Desktop apps. I haven't used it myself but it's what I would take a look at if I was creating desktop apps in Python
You rock, dude :)
Sublime Text 2 is great, especially with the [CodeIntel plugin](http://www.sublimetext.com/forum/viewtopic.php?f=5&amp;t=2202) for completion and [SublimeREPL](http://www.sublimetext.com/forum/viewtopic.php?f=5&amp;t=2964) for a Python command line. I definitely plan on purchasing a license for it some day soon.
I don't think "how many developers work on Python vs. users of Python" is a very interesting metric. There are hundreds (maybe thousands) of people who create librarylike/framework-y Python code that does not live within the python.org version control system. At this point, it's somewhat uninteresting to an experienced Python developer what's in the stdlib and what isn't; what's really important is the totality of libraries and frameworks available on top of the platform.
Geany is the best when it comes to simple python editors.
I think on Windows you can do the windows-theming which makes it look much better. On Linux it will look a bit off. 
I am a Vim user myself, but not sure Vim is a good editor for jroot if he isn’t a programmer, but a 3D graphic designer.
Have you considered just using HTML for your interface?
emacs ... because emacs isn't an editor, it's a lifestyle...
That would not be a problem, its just a college/personal project.
but for pygtk I would have to install a lot of libraries right?
Interestingly never thought about it. How would one do that?
Ah, thanks for that clarification. Are people downvoting me because they don't agree with me? I'm a huge python fan but I've recently come to grips with myself that Python is going against the tide at the moment. Python 3 as a language is heaps better than python 2. It just needs the community to catch up and after 3 long years...the community is slowly catching up. I honestly wonder how many people use python 3 on their production servers.
Ingineer, you _could_ use the property as a function rather than a decorator to get similar behavior. In fact, this is basically creating a descriptor for you: def display_name_func(instance): parts = [] if instance.salutation: parts.append(instance.salutation) if instance.forename: parts.append(instance.forename[0] + ".") parts.append(instance.surname) return " ".join(parts) class Person(object): display_name = property(display_name_func) def __init__(self, salutation, forename, surname): self.salutation = salutation self.forename = forename self.surname = surname 
What? Are you implying vim/emacs isn't the absolutely best editor for every person who ever wants to do any kind of editing regardless of background or intent? Heresy!
Check the PYTHONPATH variable. It's like CLASSPATH in Java.
If it's not in sys.path, it will not import it, so it might have been installed. If you want to check: import sys sys.path 
emacs isn't a lifestyle, it's an operating system
Depends. If you just want syntax highlighting, use a multi-language editor of choice (e.g. Notepad++ if you're using Windows, Kate or gedit if you're using Linux or whatever shiny thing is currently hot (TextMate?) for MacOS X). If you want to get fancy, feel free to check out Komodo Edit for a free cross-platform option. If you want a few more extras, look into the various IDEs that are out there. Komodo IDE is a pretty good multi-language cross-platform IDE, Eclipse + PyDev is free (though some people really dislike Eclipse), WingIDE also has a lot of supporters. Personally, I like PyCharm the most because of its strong code intelligence and refactoring support, though it is somewhat Django-centric. Since you're just starting out, a full-blown IDE may be a bit too much for the moment (especially since most of them carry quite a price-tag).
You should be using "import reddit" instead of "import reddit_api". "reddit_api" is the name of the github project, but the name of the module is "reddit" Btw, you should use a more descriptive title when asking questions.
Well, I'm new at reddit too, so...thanks!
That really depends on what you want / are willing to learn. For your information, Python has a kind of ghetto IDE called IDLE which allows you to edit Python and interact with the shell simultaneously. It's got syntax highlighting and a few other nice things. But I generally use Vim for anything more in depth than a one-off script. (YMMV.)
Burn the witches! ;-) :wq
a .vimrc starting point: set expandtab set sts=4 syntax on bs=indent,eol,start WAH-LAH! 
My company has switched to Python 3.2 entirely. We're lucky in a way, though, as we aren't really making use of any of the major python libs that haven't yet come to 3k.
emacs isn't an operating system, its an ... ok i give up. It is.
python 3 gets a couple things right that python 2 got wrong, but the expense of switching is far higher than the benefit of these minor improvements.
Such as?
There isn't enough library support yet. Perhaps once Django is fully Python 3 compatible then it will be time to switch, to name one major library.
Yeah, the sea of red on the [Wall of Shame](http://python3wos.appspot.com/) is disappointing.
Until you need them :P
Django is probably the main if not only reason as to why we havent switched.
Komodo edit has a feature i love: Open remote file, save remote file. Just configure a ftp connection and you open and save the remote files like local ones. I don't know if other editors can do it. The other plus is friendliness: I guess Vim and Emacs are the pro choice, but for a beginner is a plus not having to learn Python + editing Python. 
PyScripter!
What do you do with it?
A better title for that page: "Items In Red Written By People With Jobs"
But non-OOP programming feels boring, unsafe, repetitive and downright incorrect at times. Especially with how easy Python makes it.
Web development + computer usage statistics
Right. We'll cross that bridge. I'd rather not be part of the crowd that's holding back python from going to 3k. It's 2011. Get the f* on board. It's time to deprecate python 2 and stop development.
&gt; python 3 gets a couple things right that python 2 got wrong And it also gets a ton of things wrong that worked better in Python 2.
Such as?
Text IO in Python 3 has horrible defaults regarding encodings which many people don't seem to know. Depending on operating system or environment the default charset changes and it appears to be UTF-8 to many users but it silently falls back to ASCII if it can't detect an encoding. For instance it happened to me on SSHing in to a different box that it picked up a broken locale consistently and failed to install virtualenv or something because the setup.py was reading a README textfile without providing the encoding. The filesystem API really shouldn't be unicode based on environments that don't have unicode, so it feels incredible misplaced (even after the new revisions) on Linux environments. The fact that filesystem unicode != HTTP unicode regarding filenames is not in any way helping there. Bytes are not enough of a string API that writing with low level protocols is a major pain in the ass. The URL module does not support arbitrary encodings anymore, everybody now has their own implementation etc. And that is just a very short list.
[PyGUI](http://www.cosc.canterbury.ac.nz/greg.ewing/python_gui/)
I want to downvote you so hard with all my might for posting that link again. I am happily accepting large sums of cash and patches. But you know what ... nobody provides either.
Rumours of PySide's death may be greatly exaggerated. INdT/OpenBossa, the group which Nokia funded to work on PySide, [has said](http://lists.pyside.org/pipermail/pyside/2011-August/002818.html) that they "intend to maintain this project even without monetary support from Nokia."
Any GUI framework other than Tkinter requires extra libraries. Tkinter ships with Python, but it's quite basic.
FWIW, % for string formatting still works in 3.2, and I don't know of any plan to stop it working. I know it's officially deprecated in favour of .format(), but it doesn't look like it's going anywhere soon.
What do you use for web development? Also, what server do you use and what scale does the web application operate at? Do you use anything outside the standard library?
The prod servers where I work are mostly rhel5.5, with python 2.4.2 iirc. Although they all run C code, it's only me that runs python on them when they're offline. Really frustrating, I build python on my desktop, and tar ball it, because they don't even have GCC.
£450 was raised at PyConUK for PyPy.
Nah, I stick to the standard library. HTTPServer is grand :-D The web side of stuff is only run on an internal network. Most of our work goes into the statistics collection and report processing.
Depends on what's you base plateform. If you already use Gnome, all these library are already included. If you want to develop for KDE or windows, other choice may be more interesting
I gather this subject is a rather touchy one...
To reuse a common meme these days: "I never asked for this".
2.4? Damn. (Mumble mumble ubuntu LTS mumble 2.6.)
Try converting to [HSV](https://secure.wikimedia.org/wikipedia/en/wiki/HSL_and_HSV) first, and then check on the H-value. For the conversion, use the colorsys module. But for a computer vision app I did (it plays [Set](https://secure.wikimedia.org/wikipedia/en/wiki/Set_(game)), I ended up using K Nearest Neighors to classifiy into 3 colours. 
Where can I find the full list?
If you don't require Python 2 only libs then you should use python 3.
I just got done spending about 160 hours or so porting about 10K lines of code from Python 2 so that it will run on both Python 2 and 3. I was fortunate enough to get a grant from the PSF to do a portion of the work I just completed (for WebOb). That portion took about 80 hrs or so and I'm still not really finished with it (I have to make documentation changes, fix bugs reported during an alpha phase, do integration testing, etc). The other 80 hours I had to pay for out of my own pocket (to port Pyramid and its dependencies). Google was also kind enough to give $10,000 towards GSOC student work, which went towards porting other dependent packages over the summer, too. As of this point, I have received about $15 an hour to do the work I've done to port software I've written (or depend upon) to Python 3. Because the result has to run on Python 2 as well, I don't get any immediate benefit from being able to use new language or library features. The work itself was a pretty thankless slog, too, not much fun at all. I rely on roughly 100K lines of code on a normal basis that are not yet ported. As a rough estimate, given a similar rate of porting, that's going to take 1600 man-hours. Let's pretend that there are people with the requisite skill with enough availability from their day jobs to do that porting for roughly $15/hr, as I did (doubtful, but let's pretend). That's still $24,000 and a year and a half of solid effort. That assumes that the code being ported already has a solid test suite; if it does not, one will have to be written to ensure that the porting effort doesn't break anything. So wrt "get the f* on board" I think people are doing all they can afford to do, but it's a pretty bare scenario financially.
I was looking for the list of "things that worked better in Python 2".
I set up an initial project at https://github.com/bebraw/iterplus . I haven't published it or anything. There's still some work to do (optimizations, API design) but the basics are working.
I set up a project at https://github.com/bebraw/iterplus . If you have time/interest, feel free to check it out. :)
herp derp
Well, you have a choice: * Depend on an external web browser * Bundle your own * Depend on wxPython and use the HTML component I suspect there are other options as well. Depending on an external web browser's the easiest, but gives you the fewest opportunities for customizing the way the UI looks. Basically you create a local webserver, and open a URL to it in the local webbrowser. (There are tons of frameworks out there for serving webpages, so this should be a pretty easy option to look into) You will have to make your app somewhat stateless, though, since someone might open up a URL you aren't expecting. If you include your own, you have better control of how the interface is skinned on the desktop, plus you know which engine will be used so you have a bit more flexibility in terms of not having to worry about browser incompatibilities. Depending on how much system access you need, I think there's a project that converts Python to Javascript out there? Thing is, if you're bundling already, why not make the whole thing in the same language and just go pure Javascript? The wxPython option is decent if you don't care about any advanced HTML features. It doesn't have to depend on a system HTML component (although it can; on Mac OS X you can use system webkit through wxPython), but the included HTML engine is written in python and extremely stripped down. No Javascript, slow for large pages, etc. But it might be enough to get the job done, and the experience will be pretty consistent across platforms. Also, you're keeping everything inside Python, which can be a plus. There are other options out there that I know less about. I believe the dashboard apps in Mac OS X are HTML-based webapps (with round corners, etc.), and I keep hearing about Metro apps in Windows 8 having some sort of web stuff in them. But I don't know much about those. Personally, I'd recommend either going webservice (option 1) or wxpython (option 3). Option 3 is actually quite elegant, and I've used it for a couple of internal tools for work, marking up large documents in html with links as necessary. The results aren't always pretty on all platforms, but it gets the job done.
While I do understand what you're saying, I have a seriously hard time believing you had to actually touch 10K lines of code. If it's Python code, there are tools that get you 50% of the way there very quickly. If It's C code, then I sympathize, but ideally C code would be quite separate from the Python interface to the actual work of the code. And to some high schoolers, 15$/hour to just port code is a pretty good salary, if you ask me. I understand there are a few major projects that are holding back "the world" from moving on from 2 to 3 (is numpy still python 2 only?), but it's frustrating when end-user projects (as opposed to large libraries) start anew with python 2. It just continues the broken cycle. 
A soon as Debian Stable ships it as the default python interpreter... ;)
Excellent, I'll try this next!
2.6 is a pita too, there's a load of nice changes in 2.7 which I miss when I'm stuck with 2.6.
It's actually sort of all down in black-and-white. Here's what I've done recently: WebOb: https://github.com/Pylons/webob/compare/1.1-branch...master Pyramid: https://github.com/Pylons/pyramid/compare/1.2-branch...master (really 1.1 to master would be better, most of the 1.1 to 1.2 features were in support of python 3 too, but that's just the work I did recently) transaction: http://svn.zope.org/transaction/branches/chrism-py3/ (compare to trunk) zope.interface http://svn.zope.org/zope.interface/branches/chrism-componentregistry/ (compare to trunk) http://svn.zope.org/zope.deprecation/branches/chrism-unittesting/ (compare to trunk) I won't bother with the repositories that were worked on by the GSOC students over the summer. And we've all done more work than that over the past year or so mentoring, helping other folks, sprinting at PyCon to provide WebOb with 100% test coverage, removing non-Python 3 dependencies from Pyramid, and other things. Anyway, it was a lot of work. There's really not "tools that get you 50% the way there", not at least if you want the result to run on both Python 2 and Python 3, or if you're doing a lot of work with bytes. I mean you can bring up 2to3, but it doesnt help at all with bytes to unicode straddling, or straddling 2 and 3 at all for that matter. It's not really an option to not straddle 2 and 3; all of our actual users still use 2 and nobody is going to maintain two versions of the same codebase. So that's the story. I'm not fibbing. ;-)
Right but this is why it was a nightmare for you, you wanted the same code base to run on both 2 and 3, but just the "except" clause change makes that a nightmare. Add in strings and it's even worse. I don't know much about your project, but IMO, it would have been faster (and saner?) to fork, deprecate your python 2 branch, and backport only the major bug fixes while leaving new features to python 3. 
You can actually use 2to3 to help straddle Python 2 and 3. It can be run as part of the build/installation, so you can maintain one Python 2 codebase, which works in Python 3 post-translation. It doesn't sort out unicode for you, but it does sort out simple things like print. We're using this to make a single IPython codebase that can be installed on Python 2 or 3. Thanks for all your porting work!
In the market I'm in anyway, Python 3 isn't really a "feature".. most people just want websites, and they want software to make websites (I'm a consultant who makes both). I can't really "go full-on Python 3" without having a market on the other side of the gap. Limiting my audience to the intersection of people who want websites and want Python 3 (and whom are willing to live with all of its limitations like no PIL, limited database support, no WSGI middleware, limited server choices, limited hosting choices) would leave me a small market. The market will still be small a year from now, probably two, maybe even three or four or five. Maintaining two separate versions of the same software on two different platforms for that amount of time when only the older one actually has a market now would make no sense. I'm glad that you are positive about Python 3, but I think, for the most part, software follows money. It's natural to be frustrated by this, but I don't think it helps much if *all* you do is to be frustrated. What helps is helping to port software or giving money to people who want to port the software but can't afford to do it.
As another point: *Learning Python* by Mark Lutz has an excellent overview of Metaclasses and their lookup orders.
I'm using bottle for web stuff on python3 and that seems very minimalistic and nice to work with. IIRC they tell you to run 2to3 on the code and that this is supported.
Yeah, I started out trying to use it, but it was a little too slow and didn't really do enough to be worth the effort. Thanks for yours as well! 
why not just use matplotlib
Let me just thank you for you efforts which will help us all move towards python 3.
&gt; You can actually use 2to3 to help straddle Python 2 and 3. Having down both approaches: both are horrible in their own regard. 2to3 changes behavior between Python 3 versions. Writing custom fixers is a horrible experience since you have to manually deal with comments and whitespace, it is butt slow which makes it a royal pain in the ass when you need to iteratively work on it and on top of all that Python will constantly spam into your support channel that their package does not work uninstalled on Python 3. With my next port I am writing myself my own 2to3 tool that is handcrafted for my code and shoots the problem with regular expressions and some preprocessor comments.
&gt; I don't know much about your project, but IMO, it would have been faster (and saner?) to fork, deprecate your python 2 branch, and backport only the major bug fixes while leaving new features to python 3. As much as I would love Python 3 to take off, that totally does not work. Few people use Python 3 and even 100% of the cheeseshop packages were ported people would still have to port their own applications. Being currently in another migration to Python 3 I really just constantly want to hit people in agony.
You are not.
&gt; I don't think "how many developers work on Python vs. users of Python" is a very interesting metric. It's very uninteresting indeed. I was just helping make the distinction between the two groups.
matplotlib will just plot stuff. I need to add a few basic buttons to make my controller do some stuff.
&gt; I honestly wonder how many people use python 3 on their production servers. "Production" for me is a bit different than the majority of others because I don't do web stuff, and my Python stuff at work is internal anyway. However, we do still have the feeling of development versus production. I think it's a little over two years now that I've been using Python 3 for all of our testing tools: a minimal continuous integration server, a few C extensions, performance, load, and regression automation, etc. For a while before that, I supported 2 and 3 at the same time, but dropped 2 because I wasn't using it. As for your actual question of "how many", I think the answer is "not enough", but realistically I'd guess it's in the single digit percentages of all users. I think the number that have some working 3.x versions or are in the process is quite higher, but they're probably a ways off before they flip the switch and officially go with 3.
I already responded to you in some other thread, but for the general question: I've been on 3.x only for about two years. For maybe a year or so prior to that I was on 2 &amp; 3 simultaneously until I felt comfortable giving up 2 entirely. For me, "production" is a bit different than I imagine it means for the majority of others, who I tend to imagine are web developers. I write trading software and use Python for all types of internal tools and test automation. We still have somewhat of a sense of "development versus production" for those particular tools, but not like what a web developer of a public facing website has.
I don't see how any problem is created if people can continue to use the latest python 2 version that you've deprecated. They'll even get the big bug fixes.
I should check it out. How is its https support?
&gt; I'm glad that you are positive about Python 3, but I think, for the most part, software follows money. I would say that your work follows the money; and if that's the case then more power to you. If you get paid to do Python 2 dev work, then good. Do what you can to further the success of python if you want, otherwise I completely understand. 
I seem to be the only person I know who uses it as a cross platform scripting language. And yes, I've moved to 3.
&gt; I don't see how any problem is created if people can continue to use the latest python 2 version that you've deprecated. They'll even get the big bug fixes. This would mean that I do bugfixes on two entirely different code bases. Many libraries have to change their APIs in order to be able to support Python 3. This will affect for instance every project that provides custom stream classes that supported operating on unicode and bytes. On top of that you're assuming that someone would be deprecating Python 2.x versions of their libraries. Now why would I do that? Python 2 is what everybody is using. Force upgrading people to Python 3 is not only a horrible decision it's also one that harms the ecosystem of Python. We will still be writing Python 2 code 10 years from now.
If you want to do plotting with a few extra control buttons, Traits + TraitsGUI + Chaco is an excellent route. Traits was more or less designed with this type of application in mind. Chaco is a plotting library based on traits. Under the hood, traitsGUI can use either wxPython and Qt as the GUI toolkit. I develop professional scientific data logging and analysis applications based on this tool set and it is excellent. The only downside is the large dependency set when deploying. However, it is not too problematic to build ones own set of Eggs for each of these packages. Also, distributions like PythonXY or the Enthought Python Distribution or the ActiveState python distribution all bundle the Enthought Tool Suite (which covers traits, traitsGUI and chaco). Traits is an MVC framework which makes GUI creation trivial (or in some cases automatic). See http://code.enthought.com/projects/traits/docs/html/tutorials/traits_ui_scientific_app.html for a good introduction. Note this tutorial uses matplotlib for plotting. For a traits-based app it probably makes more sense to use Chaco. A Chaco tutorial can be found at http://code.enthought.com/projects/chaco/docs/html/user_manual/tutorial_1.html 
[r/learnpython](http://www.reddit.com/r/learnpython) may also be helpful if you're still learning Python.
A large number of these packages are simply unported because they have dependencies which haven't been ported, yet. If you would group those by dependencies the situation would look a lot better already.
They'll get the big bug fixes if you do the work of porting those back and maintaing two code bases.
ReStructured Text, no less.
The return statement is inside the loop. Change it to: def bounce(): firstHeight = int(input("Enter the initial height: ")) bounces = int(input("text") bounciness = float(input('Enter the bounciness index of the ball: ')) finalHeight = 0.0 for bouncing in (1, bounces + 1): nextHeight = firstHeight * bounciness finalHeight = firstHeight + nextHeight*2 return finalHeight Also, your numbers are the same each iteration, it doesn't use 'bouncing'. Try using the in place addition '+=' operator. Like this: def bounce(): firstHeight = int(input("Enter the initial height: ")) bounces = int(input("text") bounciness = float(input('Enter the bounciness index of the ball: ')) finalHeight = 0.0 for bouncing in (1, bounces + 1): nextHeight = firstHeight * bounciness finalHeight += firstHeight + nextHeight*2 return finalHeight For future reference, any situations like this can be debugged by printing all the variables being used, usually this will tell you that things are not happening like you think they are. Below outlines an approach you could take in order to do this. def bounce(): firstHeight = int(input("Enter the initial height: ")) bounces = int(input("Enter the number of times the ball is allowed to bounce: ")) bounciness = float(input('Enter the bounciness index of the ball: ')) finalHeight = 0.0 for bouncing in range(1, bounces + 1): print bouncing try: print nextHeight except: pass print firstHeight print finalHeight nextHeight = firstHeight * bounciness finalHeight+= firstHeight + nextHeight*2 return finalHeight print bounce() 
use the range keyword to define a range, like so: **range(1, bounces+1)** But in your case this would be better: **range(bounces)**
The loop only runs once because you return after the first iteration, since you have the return statement inside it. Even if you have it outside it, it will only run twice, because the tuple you are looping only has two items, 1 and bounces + 1. What you want is for bounces in range(1, bounces): ... return finalHeight However, why not just multiply your values? def bounce() firstHeight = int(input("Enter the initial height: ")) bounces = int(input("Enter the number of times the ball is allowed to bounce: ")) bounciness = float(input('Enter the bounciness index of the ball: ')) return (firstHeight * bounciness * bounces) * 2 EDIT: I tried to make the looping variant work. It doesn't as it stands because you do the same thing with the same values every iteration of the loop (so finalHeight never increases). It should be: finalHeight = 0.0 for bounce in range(bounces): finalHeight = finalHeight + (firstHeight * bounciness) * 2 return finalHeight EDIT: Forgot to take in account that the ball goes up AND down.
I am so excited for PyPy, but every time I see it I only get depressed as there seems to be little progress being made on numpy compatibility/replacement. Being able to use PyPy for scientific computing would be amazing! I'd donate to that cause.
uhhhhh, what?
You have 2 problems. One is: for bouncing in (1, bounces + 1) The other is: return finalHeight Problem 1 is, your limiting your loop to 2. You will only ever loop through at least twice *but* even that should not happen because the return statement is executed at the end of the first loop. Could you have meant for bouncing in *range*(bounces) If you backspace the return statement to the for column your loop should finish and calculate correctly. In other words, move the return out of the loop so your loop can finish. Does any of this help? 
&gt; We will still be writing Python 2 code 10 years from now. Sounds terrible. Imagine if we still wrote HTML like we did in the 90s.
trading here. python3 also
haha fuck oath! :D +1 from me
yep. i use it. i have a long stream of py3 projects. i've not found a need to use much outside of the standard library, often the popular libraries are frameworky rubbish. the big hold backs are things like gui and math toolkits but these rely on system deployments anyway.
I'm not sure what you're getting at. But it's kind of slowpoke.jpg to be saying "If you don't require Python 2 only libs, use Python 3" LIKE THAT'S THE WHOLE FUCKING POINT PEOPLE DON'T USE PYTHON 3. FUCK.
Agreed. But I was feeling lazy and didn't want to talk about those :)
Interesting that you bring up HTML as an analogy. Remember what happened with XHTML? XHTML to HTML is Python 3 to Python 2. And guess what replaced HTML4: a gentle migration that was entirely backwards compatible.
Yes. The stupidity of toadwarrior's comment is why I +1'd you... Herp derp indeed.
Just FYI I think CherryPy+Mako+SQLAlchemy already works on py3k if you fancy something different ;)
IronPython Studio is very, very different from the Python Tools for Visual Studio project. IPS was third-party abandonware. PTVS is a Microsoft product run by a former IronPython developer (and others) and it works very nicely inside VS2010. I've been using Vim since forever, Komodo for over 5 years, and PTVS is really making a play at becoming my main editor since I'm already spending most of my time inside Visual Studio in the first place.
I'm in your boat broski(centos 4-5.7). On our machines, all the Python used are for systems programming related, so there isn't much justification to upgrade. Maybe when it becomes painful enough, we'll use virtualenv.
I am on my iPhone and can't get to my code right now but I have a very fast implementation of this in numpy. I have it up at blog.insightvr.com I'll come back later and post from the lappy. 
When you're doing operations like summing over all pixels, I've found it's often far more efficient to turn it into a numpy array, and then do the operations on that.
Either lines 34 and 35 are skipped or two first imports. Hmm?
DjangoCon had a hosting panel with several of the up-and-coming services. Definitely worth a look. Here's the vid link: http://blip.tv/djangocon/django-hosting-panel-5572201 -- not a feature comparison, but shows some of the reasoning behind the services and the direction.
Haha, I upvoted the above two replies too. :-)
Are you saying that Python 3 is likely to follow the path of XHTML? I am very interested in seeing that, if so. I'm very happy with a few of the changes to Python 3 (strings &amp; bytes being separate objects, for example) and have yet to come across any shortcoming that truly bothers me. But, who knows, it could very well not succeed. 
Except the remote editing feature is worthless in Komodo IDE because the code intelligence doesn't work remotely. This is actually a problem with all IDEs that I know of.
&gt; Are you saying that Python 3 is likely to follow the path of XHTML? I don't know. Seeing how many alternatives to Python exist nowadays and how painful the transition to Python 3 can be I wouldn't be surprised if people would stick to Python 2.x with existing code and consider writing it in other languages instead of Python 3 depending on the use case. I can only overlook the part of the Python world where I am most active in and that is certainly web development. And there Python 3 does not seem very relevant for the next few years. &gt; I'm very happy with a few of the changes to Python 3 (strings &amp; bytes being separate objects, for example) and have yet to come across any shortcoming that truly bothers me. Implement an HTTP client on top of Python 3 that is RFC compliant. A task that is incredible simple on Python 2 turns into something incredible complex on Python 3.
&gt; Implement an HTTP client on top of Python 3 that is RFC compliant. A task that is incredible simple on Python 2 turns into something incredible complex on Python 3. I'm honestly curious -- why?
Where to start ... For starters because the bytes object is horrible compared to the str object in Python 2. You have not formatting operations for starters. A lot of things have to go through the unicode layer even though they have nothing to do with that. Many modules of the standard library now have forced unicode like the URL module and you have to reimplement large chunks of it if you are doing low level operations. Python 3 enforces the "use unicode or die" mentality which is totally wrong for protocols that are not unicode (HTTP for instance). You end up with a lot of bogus encode/decode calls in Python 3 for a simple string operationg. For instance this code in Python 2: for key, value in headers: socket.write('%s: %s\r\n' % (key, value)) Becomes this monstrosity in Python 3: for key, value in headers: header = '%s: %s\r\n' % (key.decode('latin1'), value.decode('latin1')) socket.write(header.encode('latin1')) And that is assuming that all your headers are byte objects which they most likely will not be. But if they are unicode objects like they will be with WSGI at times you now have to do an encode/decode dance (x.encode('latin1').decode('utf-8') etc.).
Ooooh. I like the chaining() function (then again: most map/filter operations can easily be implemented using [mapfunc(x) for x if filterfunc(x)]. Only reduce() cannot be used in that way, but as reduce transforms the array to a value, having it as a seperate function is not too bad.
I understand your complaint but the case you provided could easily have been: header = key + b': ' + value + b'\r\n' socket.write(header) But I do grok your point. A format (of some kind) would have been nice to have on the bytes object. It does unnecessarily complicate things, but technically even with plain-text protocols like HTTP, you *are* transmitting in some encoding. 
`range` is a built-in function, not a keyword
&gt; I understand your complaint but the case you provided could easily have been: But only if you are dealing with bytes all the time. As soon as you have a single object that does not correspond to bytes you are out of luck. For instance a header value that needs to be converted from an integer. &gt; but technically even with plain-text protocols like HTTP, you are transmitting in some encoding. I did not argue otherwise. But having to decode something just because the type does not provide the operations and to encode again is not a clever API decision. Also horrible for performance.
Try resizing to 1x1 pixels
I feel your pain brother. We should get together and pour some Hennessy over some smashed RHEL/Centos disks.
People do use Python 3, mong.
&gt;Text IO in Python 3 has horrible defaults regarding encodings It was pretty awful in Python 2 as well. I've had issues with the output encoding defaulting to ASCII, but nothing like the amount of pain that dealing with Unicode in 2.x is. &gt; environments that don't have unicode There are environments that don't have Unicode? Sounds broken. &gt; on Linux environments Am I misreading? Linux has Unicode.
&gt; There are environments that don't have Unicode? Sounds broken. The linux filesystem for starters. Legacy linux installations with the locale set to iso-8895-15 which is incredible common. &gt; Am I misreading? Linux has Unicode. Not on the filesystem.
I honestly don't konw. I'm doing a REST API over plain HTTP and then putting a reverse-proxy in front to do host-based redirection and HTTPS wrapping. Or, well, I expect the deployment guy to do that anyway :)
Do you want the object (e.g. "foo1" with contents) or a property? Either way, the best thing I can think of would be a list comprehension. Interestingly, the inline `for x in dict` will grab the list of keys and iterate through that. foo_list = f['foos'] result_list = [foo_list[a_single_foo]['property2'] for a_single_foo in foo_list if foo_list[a_single_foo]['property1'] == "blah"] That will grab the property2 value (e.g. "blah blah") for every item in the larger dictionary that matches the `if` statement at the end. If you want the entire object instead, just remove `['property2']` from there. I'm not sure if you'll run into trouble if the keys are objects or anything else more complex than simple strings like the example, however.
Ok, I have open a ticket on the coverage bug tracker. 
I don't really see the point here. If you have write access to something that is executed, then yes, you can execute arbitrary code. The fact that they're replacing python instead of, say, compiled binaries, doesn't change anything.
Hi, I want to thank the web2py team for making a great framework. I recently used it to create my first web application, and my first "production" application that someone other than me uses. I'm so happy web2py is around. I also want to ask a question-- my app has been running without fault on version 1.98.1 for the last six weeks. It's really important that it keeps running. Is it worth it to upgrade to 1.99.2? Is there any risk during the upgrade? Thanks.
Thank you. It should be 100% backward compatible. A few users have reported issues with the new web server. I cannot reproduce them therefore I cannot say if they are bugs in their code yet. I suggest you join the mailing list. Do a backup before upgrading just in case. 
There is quite some serious effort and we'll run a fundraiser soon. Numpy won't happen overnight though, but we still have quite a lot of functionality extra since 1.6
I would assume its to do elevation of privileges. I don't know if this is the case with Python, but I've seen several "developer tools" that leave their binary directory world writable on Windows. I believe the default when creating a directory is that all users can write to it, if it isn't inheriting otherwise. That means if you happen to store some .pyc files in c:/mydirectory, they are likely world writable, and if I can get partial file system access (like, say, a bug in your webapp), I could escalate that to an attack like this to get access when a more privileged program executes the .pyc.
Well I don't use it a hell of a lot yet, but it's useful, for example with Python you can launch a Python interpreter in the REPL, and then from your files you can send bits of code to it and see the result without needing to rerun your program in another window.
I don't think this is much of a proof of concept, more like a neat trick. I tried it though - interesting :)
You (or your OS) would have to be pretty stupid to leave files executed by a privileged user world writeable. Yes, in situations where systems are horribly improperly configured, this can be used for privilege elevation, but so can any number of other things.
I can't wait for this. Would love to know what changes you guys have made in your server architecture and libraries since 2010's PyCon.
And if so *that's* the vulnerability - not rewriting the .pyc files. 
&gt; (Yes, I know. This is not how physics works. Again, it is fro a literature class.) Who says that's not how physics works? Just replace "Bounciness" with "Elasticity" and you're talking like a physicist. Out of curiosity, how does this relate to literature?
Are you going to do this more than once? It might be worth creating a dictionary that maps property1s on to Property2s. Something like this: foo_foo = dict((foo['property1'], foo['property2']) for foo in f["foos"]) foo_foo["ABC"] &gt;&gt;&gt; "DEF"
The crux of the problem is that RGB values that are close (by euclidian distance) together in the RGB color space don't necessarily map to colors that humans perceive as being close together. There are other color spaces that do a better job of clustering colors that humans perceive as similar. For example, as Loyvb points out HSV tends to do a better job than RGB. There are also color spaces like [CIELUV](http://en.wikipedia.org/wiki/CIELUV) where the main objective is to cluster colors based on perception. If you use one of these color spaces with better perception-based clustering you can basically just carve out sections of the color-space and assign the color based on the section that it falls in.
well when you put it like that....
are you guys joking? You can install 2.7 alongside it with virtualenv so that it doesn't affect the system default. It's... not at all difficult.
Oh yeah, it's trivial. It's a pain in the ass without gcc though.
I use spyder right now (mainly because it was contained in the Python(x,y) package which was great). It loaded Maya, reportlab, etc. as far as modules go. But I want to move to Eclipse/PyDev soon.
I... will never understand the hell that is CentOS.
I hate to be "that guy" but is Python 3 support on the roadmap?
I'm sure, like us, it's a "security thing." Not having a compiler is somehow more secure than having one. Don't ask me, ask the security auditors.
This comes up all the time. web2py will always be backward compatible therefore it will not ever support python 3. It is likely there will be a web3py that runs on python 3. It will borrow some idea from web2py but it will be different in many ways, not just because of the python version.
This sounds odd at first, but it's actually a great answer; it uses the [fast library] scaling algorithm to average the colors present in the image.
It’s not in Python, there is one in C: &lt;http://j.mearie.org/post/1181041789/brainfuck-interpreter-in-2-lines-of-c&gt;. He is the best guru about esolang I know, and made [PyFunge][] as well. [PyFunge]: http://packages.python.org/PyFunge/
[filter](http://docs.python.org/library/functions.html#filter) and [itertools](http://docs.python.org/library/itertools.html) are your new best friends
http://docs.python.org/release/3.0.1/whatsnew/3.0.html "A new system for built-in string formatting operations replaces the % string formatting operator. (However, the % operator is still supported; it will be deprecated in Python 3.1 and removed from the language at some later time.)" It works for now but you don't want to write code that will inevitably be deprecated in the near future. Again, the change is one that move away from GTD to chasing some abstract notion of theoretical 'pure'. A minor hassle but for me a step backwards. Though I am no python expert, just a happy user. A lot of us love python because it just "feels right" and is so productive in so few lines of code. I don't want it going the clunky route of Java. Phillip.
Makes sense. Thanks!
I didn't say it was a good coding practice. What I'm saying is it's not a bad coding practice. You seem to want to be puritan about this, insisting that there's some law from on high dictating that multiple return statements are utterly anathema. Yet when I point out that some of the most high-profile, highly-tested code in existence uses them all over the place, you change the subject. This goes back to one of my original statements: Programming is not a purity test. Multiple return statements can be bad. But so can single return statements. It depends on what you're doing. Seems reasonable to me, but apparently I'm not too convincing. C'est la vie
&gt; Yet when I point out that some of the most high-profile, highly-tested code in existence uses them all over the place, you change the subject. I *did not* change the subject, I *addressed* the subject. The first time you did this, I said you were trying to change the subject. I said, "True, and a different topic." Same answer here -- the fact that people do it is not an argument, it's a diversion. I know what times I'm living in when a self-evident argument for coding discipline is downvoted. 
Interesting question! I suppose this is a guise for whether developers should work on polishing their app in 2.7 or convert it to 3?
Sorry, it's not a different topic. You say a thing is a best practice. No one practices it. Therefore it's not a best practice. Simple as that. Self-evident? That's your clue right there that you have no good justification for believing this dogma. Things are either true or they're not true, and when they're true, they're true for a reason. Unless you're arguing that this rule is somehow encoded into the fabric of the universe -- in which case, forgive my sinful ways. Coding discipline is not a goal in and of itself. Someone who has a lot of bad programming habits has coding discipline. What does that say? Positively nothing. 
&gt; Sorry, it's not a different topic ... Yes, it is. I start by saying [and proving](http://c2.com/cgi/wiki?SingleFunctionExitPoint) that it's bad coding practice. Your reply is that everyone does it. Different topic. Everyone drinks and drives. Everyone gets fat. And so forth. Popularity is not a measure of merit. &gt; Coding discipline is not a goal in and of itself. You don't debate much, do you? The topic is coding discipline and best practices. &gt;Unless you're arguing that this rule is somehow encoded into the fabric of the universe -- in which case, forgive my sinful ways. Honest to God. Try addressing the topic. 
Here is my [detailed blog post](http://blog.insightvr.com/laser/pysight/laser-tracking-with-numpy-and-pysight-and-v4l-too/) on using NumPy to detect red pixels. Here's [some code](http://insightvr.com/download/LaserMissile0_01.zip) that uses it on a mac to use the iSight to look for red lasers.
I recently got into a pointless debate with some Python acolytes about the perils of allowing whitespace to have syntactical significance. Your program proves my point -- as a beginner, you couldn't tell where one of the problems was, and that problem (not the only one) was a few extra spaces. You were unable to see that "return finalHeight" was written correctly but *indented incorrectly*. There are a lot of very happy Python programmers, myself included, but the syntactical role of whitespace is a definite negative in an otherwise terrific language. 
I think your problem needs some more definition. An image might be all green and blue pixels, but many solutions, such as scaling to 1x1 would result in yellow even though there are no yellow pixels in the image. Do you want to know the percentage of pixels that are a particular color? 
This is great. Glad you posted it. 
I like it. Only criticism so far is that I think it should require you to specify a path and print usage if you don't specify one. The primary reason is that I'd hate to accidentally tab-complete it (it's in my local path) and end up sorting something ridiculous. Either that, or maybe always have a confirmation dialog that can be bypassed by piping `yes` to it, or having a `--silent` option.
If you want a fairly simple but good GUI editor, look at (in no particular order): * [Geany](http://geany.org/) - GTK-based, some IDE-ish features * [Komodo Edit](http://www.activestate.com/komodo-edit) - Mozilla-based * [Scite](http://www.scintilla.org/SciTE.html) - solid, simple, fast * [Kate](http://kate-editor.org/) - Qt-based, comes with KDE * [gedit](http://projects.gnome.org/gedit/) - GTK-based, comes with Gnome 
I'd say Qt with QML is probably on the absolute opposite side of the spectrum from Tkinter. Take a look at this introduction video, he runs some of the demo QML applications in the video so you can see some of what's possible. http://www.youtube.com/watch?v=TN4RrBIft6A
Who would you be donating the money to in order to keep 2.x going? With the 3.x porting option, the target would be the library developers, so that works. I don't think many (any?) of the CPython committers are interested in adding new features and continuing to evolve the 2.x line. I know I'm not, whether or not money is involved.
Lot's of other neat stuff on that site too. Bookmarked.
&gt; web2py will always be backward compatible therefore it will not ever support python 3. It's certainly not an easy task, but people have supported even early 2.x versions at the same time as 3.
The problem is not making web2py work. web2py executes code written by users and that has been written with 2.5 as target. If web2py were to run on py3 their code would not work. This is a semantic issue, more than a technical one. There will be a web3py which runs on 3.
Probably it not a viable option. I am positively surprised that 80% of the people would prefer to invest in py3.
If I wasn't on the shitter right now I'd link you the documentation of the python os module which says os.mkdir() defaults to 777.
Python 3 is the better language. The only reasons to stay with 2.x are missing libraries. To me, there's nothing to choose, really. It would be interesting to get to know people's opinion about trading 2.x maintainance vs. porting all libs of a prior defined need-to-have list.
The other 20 % haven't had to work with string encodings, I guess ;-).
Okay:)
&gt; But having to decode something just because the type does not provide the operations and to encode again is not a clever API decision. Also horrible for performance. But adding an API to format bytes (even if you custom write it) is not an impossibility in the future. Handling unicode in Python 2 wasn't anything better than handling non-unicode in Python 3. 
This one? http://docs.python.org/library/os.html#os.mkdir
Yes, having Py3 bytes object support all the methods that the Py2 str did would help a lot (despite the shivers it provokes from python-dev). It would also be very helpful if u'' literal syntax was permitted in Py3.
Sorry, should have provided a better example. I want the object back, it won't always be property2 that I need.
Yeah, something like that. So reading about list comprehension, looks like I can do: foo1 = [f for f in foos if f['property2']=='blah blah'] which returns a list, and I'd just take the first item. That's great!
I did use hue and it was, much better at pulling out the reds than the red channel compared to the sum of rgb, thanks
I tried this with the thumbnail function and each image was black for some reason. It might be because the images are all scanned items against a black bacground causing a bit of a border, instead I sampled every 50th pixel and averaged that, it worked ok as I could bias away from the border
Thanks, i'll look at this later!
Exactly! What prevents you from modifying the py file? Nothing, so the same kind of "attack" can be done against any other scripting language, just add your own code to the existing file, lookup all the modules from something like sys.path and done. On the other hand, playing with bytecode can be fun :)
Thats an interesting point,.basically we have a system which receives about 120 images a second for processing. It has difficulty with red images and pulling out what it wants from the background. My code was doing a pretty menial task of taking every 100th image and checking if it was red, if it was then put it aside for future analysis. The images were nearly all white with some exceptions which were close to primary colours
$ python &gt;&gt;&gt; import os; os.mkdir("aaaaaa") $ ls -l drwxr-xr-x 2 ok_you_win ok_you_win 4096 Sep 27 00:05 aaaaaa &gt;&gt;&gt; a = "bah!"; with open("perms.py", "w") as f: f.write(a) $ ls -l -rw-r--r-- 1 ok_you_win ok_you_win 4 Sep 27 00:24 perms.py $ chmod 777 perms.py $ ls -l -rwxrwxrwx 1 ok_you_win ok_you_win 4 Sep 27 00:24 perms.py Rebuttal? 
I wish I knew how this code worked. It seems to be writing to disk often. I bet it would go a lot faster if it would construct the full image in memory, then write it once it is complete. It is quite a feat, though. Especially given python's sensitivity to indentation.
I actually prefer koans for learning a new language. Just google for "python koans".
Maybe this then? foo_foo = dict((foo['property1'], foo) for foo in f["foos"])
It's really changed things for me. I've been wanting to switch over to python but I always had trouble installing libraries and worrying about compatibilities. Just enough to make me give up after a few tries. Finally found enthought and seriously my research has been going so much faster. 
I havent had too much trouble installing libraries...yet. i am sure I will come around to using them soon. Right now matplotlib is starting to give me headaches in regards to IDLE.
That's because umask already removes unwanted bits from the privileges. That's what it's for.
Clever. Can you shrink it down enough so I could tweet it?
I am not sure I get it. Whay is there a pay version that is full with free packages too?
Nice spreading technique. I wonder if it's possible to perform privilege escalation with python?
I grabbed the pycharm-sale just now - quite happy with it so far, it does what I need it to do and then some more. I'm normally not an IDE guy myself, usually prefer VIM, but when working on a very large project I found the navigation features of PyCharm be quite charming.
I'm upvoting this just for the fact that you made something that plays Set. Also, good advice with the HSV idea.
Geany is nice :3
Is that a problem caused by having two event loops trying to run at the same time? You might want to try IPython, which has code specifically to handle that situation. IPython is included in EPD.
If I understand correctly, enthought is the company behind most of the work in numpy and scipy. They really do an awesome work building a free replacement for Matlab.
Because people are prepared to pay to get the software pre-packaged, linked with proprietary software like MKL, formally supported, and so on. It's an interface between the open source world and the business world, with the handy bonus of being free for academia.
I also use enthought, but never understood how i was able to upgrade it to the latest version? Anyone to help?
I shortened your version to 236 bytes. You don't need two loops, the ']':0 hack is unnecessary, and some other shortifications. See [here](http://pastebin.com/zDnmDDX5).
That's the goal... :)
Doesn't python recompile the py, if the pyc is different from it's current py? Or is it time based or something?
Have you used that combination?
And that is probably when I will take a look at it...
I'm using it all the time but still on 2.7, I haven't had the chance yet to roll with it on 3.x
[Carved off another 6 bytes by using the ordinal value as keys in the dict and the fact that False=0, True=1.](http://pastebin.com/9D8tKApR)
I have the code on [Github](https://github.com/yol/SetVision). Its quite picky on the sharpness of the pictures, but it works good enough. [Screenshot](https://github.com/yol/SetVision/wiki/Screenshots)
The .pyc will always be different from the .py, that's the point ;) But yes, it is time-based. 
Note that you are introducing an evil subtle problem here: You only support half the slice and index notation. Depending on your implementation, InfList(-1, -2)[-1] will either crash and error or take a long time.
I like [this repository better,](http://www.lfd.uci.edu/~gohlke/pythonlibs/) mostly because I can cherry pick the packages I want and install. 
PyGTK being replaced by something called PyGObject. Unfortunately, there doesn't appear to be a tutorial for learning to use that. At the moment, new users are expected to learn PyGTK, then learn to port to PyGObject by osmosis. 
Sweet!
As far as I can think of, there is no need for a library for that (it's straightforward to iterate the files, parse them and output a list of matches ... Here's some code: import os import re IGNORE_RX = [re.compile(x) for x in ['^.*.orig$', '^Makefile$']] def get_files(path): ''' recursive generator for all files in a path, whose names do not match the regular expressions in IGNORE_RX ''' def pass_filter(p): for rx in IGNORE_RX: if re.search(rx, p): return False return True for file in os.listdir(path): p = os.path.join(path, file) if os.path.isdir(p): for x in get_files(p): if pass_filter(p): yield x else: if pass_filter(p): yield p You have to add code to this to take the output, open each file and parse it; Then, match files by parsed results. Additionally, the pass_filter should probably be re-written using `any()` (but I don't have the time to do that now :( ). 
Excellent point. I tried this out while implementing it. -1 returns the last cached result. It's not ideal but at least it doesn't crash. :) How would you solve this problem?
I use mac, but could see why that would be useful for windows users. One thing I liked about enthought is that when I discovered a package I wanted to use, chances are it was already in enthought. So I just google something I want to do then import packagex.
Can you describe a bit more how to identify the files? is there a numeric sequence or string inside a text file that needs to be matched?
I think this line is really cool: p+=c in'[]'and 92-o It took me a while to realise that this is the language feature that powers the idiom maybe_empty_string or 'default value' Learning by golfing - it works!
Go read the docs. I can't tell you anything about what your particular environment provides.
That would be the one.
Aye, umask is our friend.
Newbie here. What is "Py-Science" exactly?
This is much easier with PyQt. Granted, I'm not a Tk guru, but I've got a lot of experience with Qt and I can say what you're asking (pretty much, dynamic widgets). Then go with PyQt, as each widget has a .hide() and .show() method, that you could iterate over surrounding tiles and choose whether to hide or show. I'm imagining some kind of 2D array with X,Y tile values which the button's function iterates over whilst changing them. EDIT: I've just spent 20 minutes fixing your indentation and it still doesn't work. Fix it and we'll help. 80 character lines maximum. www.pastebin.com GO GO GO
I finished my phd in physics last December only using these tools for all the figures and data analysis in my publications and thesis (Inkscape and LaTeX too). Also, I wrote 4 or 5 larger programs with matplot, numpy, wxpython and comedi for controlling various pieces of equipment in the lab, including [this beast](http://code.google.com/p/possm/) for running our scanning tunneling microscope. Now as a postdoctoral scientist, I continue to use python for everything and I haven't run into problems yet.
A buzzword probably referring to the Python + Numpy + Scipy + Matplotlib + IPython + related packages.
$199, whoa. 
I would also point to alternative open source python distribs for OSX and Windows (under linux, you can use the distro packages directly): - http://www.pythonxy.com/ - http://stronginference.com/scipy-superpack/
This is great, thanks. I do lots of sciency Python on OS X and Windows XP (lab, ugh) and getting all the libraries installed similarly is a pain. I'm definitely going to check this out.
I think `'^.*.orig$'` should be `'^.*\.orig$'` or simply `'\.orig$'`.
I'd throw errors, because the last element of a list is not defined and whenever I see foo[-1] in Python, I think of "last element in foo".
That'll do. Thanks. :)
Nice try, Enthought sales drone.
well the files are separated into data segments. The end of each segment is marked with a '~'. The segments may not be in the same position everytime, but the number used to match the files will always be in the same position within the segment. An example of one of the segments: OTI*BA*55*2011926232412148 2011926232412148 is the number i would need. Would I use a reg ex or something to find the number 7 places after OTI is found in the file (It only occurs once in each file)? 
While that might seem like a lot for what appears to be a bunch of free software, it comes with: * Support. * Proprietary math libraries whose licensing fees exceed that amount. * The ability to put a number on how much it costs. The last point might sound silly, but the sorts of organizations who pay through the nose for MATLAB licenses are often the sort who would be deeply suspicious of adopting something approximately equivalent for zero dollars, especially if it didn't come with support. It's still a great deal cheaper than MATLAB licenses and helps to support numpy and scipy. 
i use python(x,y), it is pretty convenient as well. plus free
Why not have a GameView object with the buttons which places said buttons according to the state in the Game object? Of course the GameView object needs to somehow 'know' when the state of the Game object changes so I'd suggest having some mediation object, e.g. GameController which is the only one allowed to change the state of a Game and makes sure to notify GameView when something changes. So you have GameView, GameController and Game. The original 'Game' class name looks a bit naked there so it should probably get another noun to match the other two. Choosing a name at random, I'd suggest GameModel. So you have a GameModel, ...View and ...Controller triplet of objects that between them separate the GUI stuff from the data stuff. I find that this pattern of design is one I quite commonly use. I imagine it's got some name, but I've not yet managed to come up with the right words to Google yet :(.
What's the goal here? To identify the files, to re-format and/or re-package the data?
I just tried installing the scipy superpack on os x 10.7, for pymc mainly, but there are numerous errors... im still wading through them... advice?
Let's pretend I implement this design. Inside my field class I call the procedure that creates the board and populates it with point objects. If the button objects are going to live in their own separate class, how do I marry them to their corresponding point objects? It sounds like this is done somehow within your game controller, but if you could elaborate I'd appreciate it.
&gt; Would I use a reg ex or something to find the number 7 places after OTI is found in the file (It only occurs once in each file)? Yes: import re from my_post_above import get_files # or just define it here number_seven_places = re.compile(r'OTI.{7}(?P&lt;your_number&gt;[0-9]*)') paths = ['path1 here', 'path2 here', 'path3 here'] files = {} # will contain the result for path in paths: for file in get_files(path): full_path = os.path.join(path, file) for line in open(full_path).readlines(): match = re.search(number_seven_places, line): if match: # we have a winner your_number = match.groupdict()[ 'your_number' ] if your_number not in files: # this could be optimized by using files=groupdict() instead of {} files[your_number] = [] files[ your_number ].append(full_path) for key in files: print( '%s: %r', (key, files[key]) ) This will probably not work if you try it, because I wrote it here, not in a python file(i.e. it probably won't compile). Still, I think it should give you an idea ...
I'm at work and the file's on my laptop; I'll supply working code later this evening if I can. Thanks for the help!
 grep -R 
Sorry. I just want to identify files that match. There are 3 files to match. The parent file has two numbers in it, and each number matches up with a different child file. The files are actually one long string of text separated by a '~' for each segment. I have no trouble splitting up the different data segments and navigating through the different directories where the other files are. I'm just not sure how to go about finding the exact numbers I need in the parent file. The two data segments from the parent file I need look like this: # There is lot more text in the files surrounding these lines. ST*837*093175508 BHT*0080*00*201192623125560*20110926*231255 On the first line, I just need the 093175508 number, and on the second line I just need 201192623125560, which I will then use to match up the 2 children. The problem is that there are around 50 - 70 sets of these 3 files, and it gets tedious to match them up one by one. Also I want to learn more Python.
Am I the only one that read this as "Ent thought"? That'd be a brave package name and only lord knows what it'd do...if you like brave package names however, look no further than Dictshield, the source is hilarious to read at times...and surprisingly useful. https://github.com/j2labs/dictshield
You could look at [grin](http://pypi.python.org/pypi/grin/), it works as a command-line tool as well as [a library](http://pypi.python.org/pypi/grin/1.2.1#using-grin-as-a-library).
I tried my best with it, but there are some logic loops where I'm not sure where they are appending lists and I'm not sure if you're doing inside or outside the loop. Look forward to the update.
I'm still not really clear as to what you want to do. This code assumes that one ST/BHT pair exists per file, but modifying to produce as many FileConnection (which is a terrible name) values as the file contains is pretty straightforward. from collections import namedtuple FileConnection = namedtuple('FileConnection', 'parent st bht') def make_FileConnection(fname): ''' Builds a FileConnection (namedtuple) of parent_fname, ST, BHT. All elements are string values. Implicitly assumes only ONE FileConnection can be made per file. ''' st = None bht = None with open(fname) as inf: lines = inf.read().split('~') # the read() may explode your machine # if it does ,implement something similar to what is described here # http://mail.python.org/pipermail/chicago/2007-December/002968.html for line in lines: if line.startswith('ST*'): # your example was ST*837*093175508 # if it's always 3 values delimited by * symbols you can substitute # _, _2, st = line.split('*') for the next 2 lines split_by_asterisk = line.split('*') st = split_by_asterisk[2] elif line.startswith('BHT*'): split_by_astrisk = line.split('*') bht = split_by_astrisk[3] # same as above but with _, _2, _3, bht = ... break # assumes `bht` always follows `st` else: # made it to the end of `lines` instead of hitting `break`. Bad raise Exception('Failure to find `bht` (and, implicitly, st)') return FileConnection(fname, st, bht) 
Better report your error messages directly to the author of the superpack. I am still using 10.6 and did not have any error.
I wonder why vim is more popular than emacs. Sure, it is installed on every system (which seems to be the main point in favor of vim), but that is not a deciding factor for me as I mostly program on my own machine.
The two are not mutually exclusive.
Though I assume it is irrelevant to your problem, I'd be interested in knowing what it is that you're doing, and why you're capturing 120 images/sec if you're throwing nearly all of them away. Would 1 image a second at higher resolution be more useful? 
 def pass_filter(p): return not any(re.search(rx,p) for rx in IGNORE_RX) I also like using lists in python instead of recursion: paths = [path] while paths: p = paths.pop() if os.path.isdir(p): paths.append(os.path.join(p, f) for f in os.listdir(p)) elif pass_filter(p): yield p (code hasn't been tested). I like this better because it's easier to change breadth-first search if that suites your fancy and you're not at the mercy of the Python call stack (though it won't be an issue in this case). 
Sure, they have offices in downtown Austin and host sciency/Python meetups quite often. With pizza. The fellas that work there are great as well; you can spot them at the bars on 5th/6th street as well, drinking beer and talking about programming (not that that's an unusual occurrence in this city) and answering questions about EPD.
Interesting idea. Why not make a super version which offers several different sorting / filtering options, all linking (via shortcuts) to a single instance of the files. So you could have top level folders for: By type By date By file size Original All files would be in Original, with the other folders providing different sorting down to a folder of shortcuts.
That's really really cool. Have you tried it with a screen capture from one of the online versions?
Hey, experimental scientist here (photonics mostly). Did you manage to automate your lab experiments with python? What were you using for interfacing with DAQ or other hardware? So far, we are using Labwindows/CVI but it sucks and cost an arm and a leg. I'd be glad to get more details on running experiments with python or other free softwares...
Even better, [this](https://github.com/yol/SetGameWinner) uses autopy to also click the cards. Visit http://thebreretons.com/setgame/, have your browser and python side to side on screen and run the script. 
[Quora](http://www.quora.com/) is running on pypy.
I was under the impression people don't really use it for web stuff at all. Its mostly used in high performance computing stuff. I could be wrong however.
&gt; I like this better because it's easier to change breadth-first search if that suites your fancy and you're not at the mercy of the Python call stack Good point. Thanks.
A few things: * Reality trumps documentation. * You have a problem with your package maintainer.
yes I run its distro on mac
ok....wtf is this ? what to do with that module ?
Unfortunately, it is an invitation only site.
If you by high performance computing mean scientific/numerical, then no. These folks use lots and lots of C/C++ modules to get the desired performance. I'd say this part of the python world will be the last one to move over to pypy. The web side of python OTOH uses mostly, to my knowledge, pure python modules. Hence I expect them to evangelize pypy.
Hello. Nice to meet you. My native language uses non-standard letters. This makes coding much more fun.
I have considered incorporating this into a file manager, but I have little experience with GUI's and have generally avoided them like the plague. Most file managers and `ls` are capable of sorting things by size and date, so I'm not quite certain I understand exactly what you're getting at.
Are you saying that unicode makes it more difficult for you? What language?
both of you are fairly wrong. PyPy is not used much by high-performance computing because it does not support full numpy yet. It'll change at some point in the near future though. Python is used a lot there as a "glue" language and being able to write more stuff in Python would be great. Regarding the web - the main part that's not usually in pure python is DB bindings. There are DB bindings available using ctypes though (a very recent addition).
It seems nice, and I like what the project is trying to do, but whenever I use PyPy I run into minor, but annoying hiccups. Things like minor dependency packages in a web framework simply not installing correctly. When it comes to web systems, CPU performance is rarely the bottleneck. Usually it seems to be database, network, or caching. Rather than investigate PyPy and fix the avalanche of relatively minor issues, the common solution is to buy another server or two and move on with life.
&gt; let us know your experience with pypy * As with most JITs, works incredibly well with e.g. numerical stuff * Otherwise, it's kind of a hit-or-miss, you'll have to test it out on your own workloads (good news: that's absolutely trivial, I've yet to encounter any incompatibility so testing pypy is as simple as creating a virtualenv with `-p pypy-c` [or whatever your pypy binary is] and installing your dependencies). I've encountered quite a few sticking points in slow(er than cpython, sometimes significantly) stdlib modules. [json](https://bugs.pypy.org/issue868) or [bz2 &amp; gzip](https://bugs.pypy.org/issue733) for instance (pypy seems to have issues with generators currently, so there's that). Short run-times will also negatively impact pypy as the JIT won't have the time to warm up (in the future, this could be mitigated by injecting static analysis data into the JIT, I think mozilla is trying to do that right now in Firefox)
Quora is not invitation only site.
If you like simplicity, Sublime Text 2 is one of the nicest.
&gt; both of you are fairly wrong Alright &gt; PyPy is not used much by high-performance computing because it does not support full numpy yet. Wait, that's exactly what I meant. They have lots and lots C modules, among them numpy, that won't work with pypy out of the box. I'm actually part of this subculture of python. From time to time I do write native modules just for the sake of performance (nested loops being the prime reason). Knowing that pypy is about to come, I went from boost.python over to using ctypes.
Danish. Not really a problem now that I have found the coding PEP (forgot the number), but finding it was non-trivial. I know because I lost the link after the first time :) I should also add that my current project is primarily learning Python. 
&gt;New Users Sorry, you must have an invitation to create an account on Quora.
They use execnet: http://www.quora.com/Quora-Infrastructure/Did-Quoras-switch-to-PyPy-result-in-increased-memory-consumption
I've had good results with [PyVisa](http://pyvisa.sourceforge.net/ ) for VISA / GPIB devices; you might also check out [O'Reilly's book](http://shop.oreilly.com/product/9780596809577.do) on the subject.
It'd be great for browser scripting like [pyjamas](http://pyjs.org/) does because you could use it to spit out javascript code and have it behave 99% the same. At the moment pyjamas is kinda 95% I think and has some performance problems. I think they killed their JS implementation though, not sure why.
&gt; You don't need an invite if you're connecting from the UK or US. I don't understand the reasoning for this. There is no IP/licensing issues like Pandora/Hulu, so what gives? This is the first time I've heard of Quora, but now their brand is permanently damaged in my mind. I want nothing to do with it, even if they open signups later. How short sighted of them.
[citation needed] regarding CPU is not an issue
I use pypy for a bunch of internal EDA utilities at work. Most of the tools do simple geometry manipulation on large (sometimes very large) sets of data. It doesn't make much difference on short runs but it turns long runs into interactive experiences and night long processing into something that can be run over lunch. However... if you havce custom C extensions it can be a bit of a giggle getting them to work under pypy. In some cases I reverted to a pure python approach and let the JIT compiler deal with it and everything was good enough. Other times. I had to puzzle out exactly what was going on. Basically this involved digging through the source which is something I end up doing when writing C extension for CPython anyway. I've never used it for for anything having to do with the web.
The lack of numpy support makes it nearly useless in HPC
sixohsix qualified his statement with "rarely". Moreover, he didn't state it "wasn't an issue," but rather, isn't typically the bottleneck.
all I can tell you is that it disappointed me a lot when I tried text manipulation (compared to cpython). For example this: https://github.com/koblas/ngramj-python runs 3 times slower in pypy compared to cpython. So just don't assume it will always perform better.
Any interest in [a subreddit for everything PyPy related](/r/pypy)?
This is odd. I am not from either of the US or the UK and I registered without an invitation months ago. They must have changed the rules recently.
Like this?: import json from pprint import pprint # I add a foo to make the result a little more interesting json_str = """{ "foos": { "foo1": { "property1": "blah", "property2": "blah blah" }, "foo2": { "property1": "ABC", "property2": "DEF" }, "foo3": { "property1": "blah blah blah", "property2": "blah" } } }""" f = json.loads(json_str) # all foo's with "blah" in property1 using list comprehension pprint([foo for (key, foo) in f["foos"].items() if "blah" in foo["property1"]]) # again, using filter print pprint(filter(lambda (key, foo): "blah" in foo["property1"], f["foos"].items())) 
I use python to control my lab experiments. As long there is C driver, wrapping it up in python is easy. For NI-daq there's pynidaq, the libarys for serial and usb communication also quite nice.
Can you create a benchmark out of that? We're always looking for benchmarks on which we're slower, it's the only way we improve (also: someone having a crazy idea and then implementing it).
This should do: #!/usr/bin/env python # -*- coding: utf-8 -*- import re,sys,os def read_file(path): with open(path) as f: return f.read() search_path = '/path/to/root/directory' accept_suff = re.compile('\.(html?|php|txt)$') accept_content = re.compile('\s(first_term|second_term|etc)\s') for root, dirs, files in os.walk(search_path): for fn in files: if(re.search(accept_suff,fn)): path = os.path.join(root,fn) data = read_file(path) if(re.search(accept_content,data)): print path Just change the path, the accepted suffixes, and the accepted content. 
It's common sense. "Most" python web apps are a glue between components which are written in lower lever languages and/or invoke other system calls. A typical web call traverses following layers: kernel net stack -&gt; web server/reverse proxy -&gt; thin python WSGI wrapper like WebOb -&gt; Python app code -&gt; Database API lib -&gt; Database server -&gt; file system. In most cases the heavy lifting is done by the database server, as it has the most challenging task of retrieving data. Your actual app code takes up very little time, again in typical web app use cases. This is the best I can find as far as [citation needed] is concerned: http://www.distractable.net/coding/google-appengine-java-vs-python-performance-comparison/ Even though Python is a significantly slower language than Java or Scala it still manages to outperform Java in a typical web app scenarios.
As you said they are very similar. I believe Jinja is a tad faster but I came to Mako from Myghty so stuck to it :P https://twitter.com/#!/zzzeek/status/118850575243808768
 &gt;&gt;&gt; seq = [1, 2, 3, 4, "lol", "rofl"] &gt;&gt;&gt; sum(x for x in seq if isinstance(x, int)) 10 ...but you should really check out [r/learnpython](http://www.reddit.com/r/learnpython).
Thanks. I will in the future. 
Would you like an invite? I signed up but I haven't really used it.
PyPy is Python, so I'd hope we could keep these things together and not fragment the readership, news, etc. Anything you could post in there, you could post in here. Plus, r/Python isn't super high traffic or anything, so it's not like there's a lack of space for PyPy talk. (I also have a sour taste in my mouth from posting in the r/Chicago subreddit, and people made sub-subreddits for every little Chicago related topic under the sun and it is absolutely terrible.)
Templating systems tend to chew up a good number of bytecodes. For already-optimized systems (ones which do a lot of caching of database results for the common case), the bottleneck is often not the database system, but is indeed Python code.
They're both great. Choose one based on the syntax you prefer.
My team at sf.net did a lot of work in Jinja2 -- we ended up moving to Genshi because the designers liked the syntax better. It turned out to have some performance issues so Rick Copeland created Kajiki --http://kajiki.pythonisito.com/ -- which is basically Genshi-style syntax with some Jinja mix-ins that has a lot of runtime optimizations. All are robust solutions -- mostly it depends on how much you care about performance for your project and the aesthetics you prefer.
Also, for your grade's sake (since your teacher will probably ask how you knew that), make sure you understand the suggestion. It's a [list comprehension](http://docs.python.org/tutorial/datastructures.html#list-comprehensions) filtered through the [`isinstance`](http://docs.python.org/library/functions.html#isinstance) function and given to [`sum`](http://docs.python.org/library/functions.html#sum) function.
That twitter is funny...lol
I actually find them both okay syntax wise. I guess I will just have to choose then.
I get how it works, we just weren't taught the isinstance function. I looked up a list of functions and I guess I missed that one. &gt;.&lt;
Some of them are really not that bad. Like Mako (reddit uses it). It leverages a lot of caching and it uses pre-compiled re (regular expressions) which is pretty efficient as it's written in C. Mako will deliver a simple 3 page layout in just over a milisecond, which is pretty fast and very low overhead. Benchmark on their site: http://www.makotemplates.org/ &gt; For already-optimized systems (ones which do a lot of caching of database results for the common case), the bottleneck is often not the database system, but is indeed Python code. If you're caching your database and optimizing your system and you have hot portions of python code, why not cache those results as well? I mean you're already caching your persistence.
I like the power and consistency of using Python inline with Mako. Why invent a new syntax when you already have a really good one you're using everywhere else? That said, I work with small teams and only trusted competent people touch the templates. If the templates were written by people who needed to be babysat and censored from doing "evil things", I could see why Jinja2 and such are attractive to people.
fails if there are floats. ugliest would be to make a for loop with try/except
With `--exclude` if necessary. Also of use: zsh's (and bash 4's) fancy recursive globbing. $&gt; ls **/*.txt
One of the advantages to Jinja is that it's very similar to Django's default templating system; since Django is (afaik, still) the most popular Python web framework, you're more likely to find people who are familiar with it. Also, editors are more likely to understand the syntax.
You don't know until you do some benchmarking and profiling, I guess. I've had database speed be an issue. But I've also had the slowness of my own Python code (and the code in libraries on which I've depended) be an issue, totally independent of database speed. Sometimes that's just dumb algorithmic bugs, sometimes it's just my own crappy design. Sometimes the interpreter really could help more, and PyPy might be able to help me there. But I'll always benchmark, profile, and test to be sure. 
Agreed. I was mainly talking about most common cases. Where an app does a DB look-up and renders the result back.
heh...Mako was written to erase the embarrassment of myghty ! kept just the good parts IMHO
You could do this: def floatordie(n): try: return float(n) except: return 0 result = sum(floatordie(i) for i in thelist) 
I've worked for years with many language embedded systems including JSP, HTML::Mason, and of course Mako. HTML-centric people can work with all of these systems perfectly well, as they steer clear from the directives completely. I've never seen anyone do "evil things" except actual programmers. As always, it's only crappy programmers that cause problems, so better they at least don't end up stringing HTML concatenations inside of modules.
&gt; Some of them are really not that bad. Like Mako (reddit uses it). Haha, reddit and performance.
IronPython Studio is useless at this point. Check out [Python Tools for Visual Studio](http://pytools.codeplex.com/), which is just saw a major release. It's being developed by Microsoft (which IPS was not), lead by one of the former IronPython developers.
HTML in your Python or Python in your HTML?
It's shit like this python.
I am using it for a highly efficient python web service. My stack: * pypy * django, piston, gunicorn, psycopg2-ct (ctypes implementation of psycopg2), thrift (without the fastbinary module) * cassandra, postgresql * ELB (amazon load balancer) to nginx with 3-10 worker processes Some statistics: * with python2.6 the throughput of my server was about 12mb/s (megaBYTES per sec) - CPU LIMITED * with pypy the throughput of my server was 100mb/s (megaBYTES per sec) - NETWORK LIMITED What this does is pull information from cassandra, assemble it neatly and spit out a shit ton of JSON. Before pypy I had used uwsgi for the serving and ujson for the json module (the two fastest available), but now the entire stack is native python and extremely fast. Give your pypy lots of memory. Give your pypy lots of time to warm up. You won't be sorry. EDIT: Questions? Just ask. I spent the last week testing and deploying it.
For what it's worth, if you know you'll be using pypy, it is going to be faster to use ctypes to wrap your C code. The CPython extension API is and will likely always be slow under pypy.
Is it really ugly? Using a try is kind of elegant because it either works or it doesn't, you don't need to care about the type of the object. I'm guessing using a try is part of the exercise.
It is not a list comprehension. It is a generator expression.
This is a waste of a try! What about: try: x += b except: pass If b is an int or a float, or whatever that can be added, then it'll add it, otherwise it'll ignore it. OP: study the try close in details, look for finally and else.
 grep -R "OTI" . | awk -F* '{print $4}'
+1. Say NO to fragmentation :)
I missed the joke - could you elaborate?
I've worked in only one large mako codebase, and it was a complete mess. The temptation to fix something with a little python snippet in the template was too great, so it ended up having very few large, messy templates with lots of one-off nearly untestable code modifying variables from a context that were often difficult to track down (I find mako inheritance and self/parent difficult to follow). I was also bothered by the fact that, since lots of mako can look like (or even be) python code, it's difficult to make your templates *look* right; I generally want template tags in line with the markup, but that puts all this python at different indentation levels, and it feels icky. And while I'm discussing superficial matters of taste, I find that mako syntax blends in with HTML syntax where I actually want it to be visually distinct. I work on a few jinja2 codebases now, and some Django Template codebases before that, so I'm comfortable with the syntax. Although it's much more limited than Mako, it just feels like it's easier to keep things that don't really belong in the template either out of the template or tucked away in a macro-library. This isn't really "evidence", it's just my experience; I'm sure that the relative quality of the codebases, irrespective of template language, probably accounts more for its tidiness. **edit** One awesome thing about mako was that it was easy to insert a debugger set_trace and inspect the template context to see what was going on. It was just unfortunate that this was actually kind of necessary.
I find it funny _this_ is the post you choose to respond to :-P
I used the COMEDI library for controlling some NI cards we had. I think they were the 6030E multifunction and the 6731(?) analog output cards. Anyway, COMEDI is an open source library which has a python library that was wrapped by swig. It used to be a pain in the ass to install the linux drivers, but since kernel version 31 (I think) the drivers have been added and the libraries are in the Ubuntu repositories. I've also used the GPIB python module with some success and the NI-daq C driver, which I was writing extensions into python for. I prefer to use COMEDI though because unless they've been updated, the NI-DAQ drivers for linux haven't been updated in half a decade and don't install on anything but Red Hat or Mandriva. Here's a list of the cards that COMEDI supports: [http://comedi.org/hardware.html](http://comedi.org/hardware.html) Otherwise, I used serial communications (pySerial) with some DSP-based Analog Input/Output circuit boards I made custom... which is always the most fool proof way if you have a decent grasp on digital electronics and can spend the time to learn to design PCBs.
The joke is that reddit's server has had a lot of performance problems in the past. Actually, it seems to be doing pretty well lately. So, go Python!
Won't work with `sum`. That was my whole design goal: no for-loops.
My experience is somewhat opposite, but then my templates tend to be pretty small - all my forms are rendered using deform, many other components are created via javascript. So I mainly like mako for the nice ways to structure the templates via inheritance and namespaces.
It is an interpreter of the [Brainfuck language](http://en.wikipedia.org/wiki/Brainfuck). The goal is to make it as small as possible.
As the author of myghty what was so embarrassing about it?
Make it faster to compile! PLEASE! Please please :(
PM me if you want an invitation.
Glad to hear that.
go for mako. more freedom. faster. 
are there any problems you've faced with pypy in production? the difference between 12mb/s and 100mb/s is significant.
Wait a minute. This just uses dictionary.com, doesn't it? In production you'll probably get shut down faster than you can say "Terms of Service".
which other did you have in mind?
 import numbers seq = [1, 2, 3, 4.1, "lol", "rofl"] sum(x for x in seq if isinstance(x, numbers.Number)) also works for floats
all numeric types are subclasses of numbers.Number, so you can use that with a simple isinstance
Better to use isinstance(numbers.Number). No new functions to define, no try/except.
Well, embarrassingly enough when I was preparing the benchmark I discovered that the ngramj test was full of silent exceptions, and it was the rising of those exceptions what was slower in pypy. In normal conditions pypy was actually faster. But there is this other library (http://code.google.com/p/guess-language/) I have also been testing and if this time I didn't make any mistakes is (much) slower on pypy. I've prepared this test for you: http://ninibe.com/personal/pypybench.tar.gz On this system: Linux s23 2.6.32-5-amd64 #1 SMP Mon Mar 7 21:35:22 UTC 2011 x86_64 GNU/Linux Python 2.6.7 (r267:88850, Jul 10 2011, 08:11:54) [GCC 4.6.1] on linux2 Python 2.7.1 (d8ac7d23d3ec, Aug 17 2011, 11:51:19) [PyPy 1.6.0 with GCC 4.4.3] on linux2 This is the difference I get: root@s23:/tmp/pypybench# time python test.py 10:14:43 loading files... 10:14:46 detecting... 10:17:27 processed: 5043 errors: 13 real 2m45.561s user 2m45.402s sys 0m0.128s root@s23:/tmp/pypybench# time /usr/local/pypy-1.6/bin/pypy test.py 10:18:00 loading files... 10:18:02 detecting... 10:38:01 processed: 5043 errors: 13 real 20m1.616s user 20m0.787s sys 0m0.864s In case you are interested in the performance of raising exceptions I guess I could also prepare another test for the ngramj errors. Thanks for your work btw
I tried 3 times and for some reason I can't get the formatting right :/
Freedom to do bad things is not a good freedom.
Exceptions should be fast, unless they escape and are printed somewhere. Please
depends on the definition of bad.
&gt; [...], psycopg2-ct (ctypes implementation of psycopg2), [...] Awesome, another item I can strike from my *things I want to do once I have some free time* list.
Only if you are a bad programmer.
Reddit is often slow because of the database performance, I think they use Cassandra but it's not even cassandra's fault it's actually Amazon cloud hosting.
Thank you for the offer, but I just pointed it out because it was a bad example :)
Thank you for the offer, but I just pointed it out because it was a bad example :)
[Here's the PEP](http://www.python.org/dev/peps/pep-0263/)
it was my first python project, terrible code
Derp, good catch.
even better.
Mako's &lt;% %&gt; system is really most useful for building custom tag libraries like that of http://techspot.zzzeek.org/2008/07/01/better-form-generation-with-mako-and-pylons/ . I don't put literal blocks of Python into most templates, they should not be a day-to-day occurrence. It might be nice if I added some best practices to the docs on this. Also I would think the "temptation" to put Python code where it shouldn't be would be tempered by your experience in how badly that turns out...guess not. Here's your straightjacket !
you are totally right, it not the exceptions, is something else. I'll post another example as soon as I isolate it.
i don't have a lot of formal programming experience but i was told that catching errors should be a last resort because it can lead to unexpected results or make it really difficult to debug funny business. here, it wouldn't make much of a difference. it can also make the code a little slower in python, i'm told, but i doubt that would make a difference here either.
also, what if the list is something like [ ..., 5, '5', ... ] ? then he will be changing a string to a numeric and get a different answer.
His ironic what?
Ugly hacks I am not proud of have saved my ass from time to time. I just like having that choice.
We settled on Python 3 for the scripting language for a new product two years ago, purely because we don't want to have to re-educate our developers in a few years when the "sea change" happens. This product targets a pretty slow-to-change user base, and I'd rather be part of the sea change now than scramble to get everyone to react to it later.
at the end everything seems to be reduced to string concatenation, or at least it plays a big role, which I guess will be a known issue. http://ninibe.com/personal/concat.py time python concat.py real 0m5.349s user 0m4.240s sys 0m1.080s time /usr/local/pypy-1.6/bin/pypy concat.py real 0m36.107s user 0m30.470s sys 0m5.640s http://ninibe.com/personal/concat2.py time python concat2.py real 0m31.176s user 0m17.425s sys 0m13.757s time /usr/local/pypy-1.6/bin/pypy concat2.py real 0m52.653s user 0m51.207s sys 0m1.448s
Uh... Ok, yeah, youbetcha'!
Ok. Number one is a bug, and it'll be fixed. Number two isn't a bug, it's how string concatenation should work, CPython has idiotic hacks to make it work, but no other Python implementation has them, nor will it ever. Do not concatenate strings in a loop, use the list append and join method.
That's relative, many believe that having HTML tags in your Python modules is worse than a little view logic in your templates.
alright, glad to not be just wasting your time then :) you might still want to take a look at the language guess thing, the difference is more significant and it might not be all due to concatenation issues. 
Dialog box to "approve this important update" please enter your root/sudo password? 
Could you elaborate why this one is not as good as the "much better intros"? It seemed pretty straightforward to me.
I use Mako because of it's built-in preprocessor support, and [PyHaml](https://github.com/mikeboers/PyHAML) which converts directly into Mako syntax. You become so much more productive and experimenting with HTML is much faster and pleasant. It's possible to make your own function that runs the preprocessor separately, but I've always used the built-in. The fact PyHaml was made just for Mako syntax is even better.
They are both good and widely used. Have a read of this: http://lucumr.pocoo.org/2008/1/1/python-template-engine-comparison/ 
The only issue which isn't as ironed out as runtimes like JRE is JIT warmup. Your apps will take a little while to start screaming, so in production you will want to either stagger deploys a little more or time them more strategically. I don't use pypy on my worker apps. Celery, multiprocessing and PIL are what these they are composed of and none of them work very well with pypy. Besides that I would say pypy is absolutely ready. Any adjustments I had to make to my stack when transitioning to pypy had to do with different library requirements (i.e. no uwsgi, ujson psycopg2 support). Everything else just worked^tm
It works great so far, haven't had a single issue with it.
One serious advantage is that pypy is able to handle increased workloads with ease. Before I had to limit my service to returning only 40 results, where now I can return 100 in the same time it took it to return 10 on cpython 2.6. Returning 1000 for larger jobs was impractical but now totally usable. 
&gt; I don't understand the reasoning for this. They want to keep the website English only and are afraid that people from other countries lack the necessary English skills to keep the content on a high quality.
Use whatever you want. The only thing I can say about that question: if there is anything you are missing in Jinja2 or think needs to be improved, before abandoning it invest a minute to let me know what could be improved.
No, but software changes. For example, apparently Pathogen is no longer the cool thing to use? I don't even remember the name of the replacement right now...
Code looks pretty cool. I like that you just basically pickle an object and throw it in redis. 
I prefer Mako because I like the syntax and doing something like `&lt;%def name='func(name)'&gt;`, very handy. You really wouldn't care which one is faster but [here's a small benchmark](http://stackoverflow.com/questions/1324238/what-is-the-fastest-template-system-for-python/1326219#1326219).
Did I wander into r/java ?
That last paragraph was a bit unfair: "Well, if you were good you wouldn't do that, but I guess you suck!" It was a big project that had existed for 3 or 4 years when I got there. I'd had a little mako experience, but not in a "production environment". The guy who had written the templates had made the decision to port a ton of very poorly performing Django template code to Mako about a year earlier, so he lacked in experience with Mako when he'd started out using it (which I bet isn't an uncommon situation.) Code in the templates: once that ball gets rolling, it's hard to stop. If a feature is there, and it reduces the friction for doing something slightly uncomfortable, people are going to use it. You can blame those people for lacking discipline or experience, which is likely true in lots of cases, but sometimes it's better not to leave chainsaws just lying around. If you took my comment as criticism then I'm sorry, because it wasn't constructive. I've have superficial problems with Mako that I'm sure you disagree with, but they're significant enough for me to keep me away from it.
The slow down is really occurring in the re module. In guess_language.py, if you comment out in the normalize function that uses the nonAlphaRe compiled regexp, both CPython and Pypy are majorly sped up. Pypy was actually faster on my machine after this change. The nonAlphaRe compiled regexp's pattern is basically u'[^' + 99537 unicode characters + ']'. The 99537 unicode characters are all of the unicode characters that are true for isalpha() on my machine. So obviously the regexp module needs some work in Pypy. I'll take a look at it soon.
Certainly, templating is where we see the most Python load on our app stack. However, caching is often a more effective solution. I'm not saying it *always* works, or that it's *trivial* to implement, but often it's not that hard.
Often when you hit an interpreter speed problem you can winnow the issue down to a single routine. If you're running PyPy, it will probably deduce that for you and make an intelligent JIT call from it, which is awesome. However, if you don't have PyPy you can reimplement that critical loop in C. If you're running CPython and have just deployed some terribly inefficient code, moving your stack to PyPy is not the most logical solution because you don't know if it will solve the problem and it may be a lot of work. (If it isn't hard, go for it and try it out!) So far I've found benchmarking and coding the bad bits in C to be the most powerful approach.
I tend to use engineering speak. Nothing is technically impossible, but some things are more probable than others until you get better data.
Yeah, that always weirds me out about PyPy. It's this lightning speed JIT thingy, but when you compile it, it draws ASCII fractals for an hour. The messages are mysterious. It's like they've discovered an entirely different way to compile program code. (Someone should probably write a paper on it.)
That is *sexy.* What's the site? (Or is it an internal thing?)
By that logic, Canada and Australia should be included. I'd wager this has something to do with monetization and the perceived irrelevance of smaller markets. 
Actually I am not a big fan of Jinja2, it’s still true that there’s no alternative template engines that can replace Jinja2 for me. Its implementation makes sense (I think it’s following the standardized compiler design and it is a small compiler in fact as well), is fast enough, can be faster if you would like do some small work by yourself, and is well balanced between “logic in view is evil” and “avoiding it is stupid” (see also: [1][], [2][]). [1]: http://pydanny.blogspot.com/2010/12/stupid-template-languages.html [2]: http://lucumr.pocoo.org/2010/12/5/not-so-stupid-template-languages/
OK sorry if I riled you on that comment, my only point is, bad code can be written in any platform and I'm personally not interested in tools that try to defensively shield against it. Basically just what I expressed [here](http://techspot.zzzeek.org/2010/12/04/in-response-to-stupid-template-languages/).
FWIW, you normally shouldn't rely on `isinstance` in real code and instead use duck typing. A more forgiving approach would be the following: total = 0 for val in data: try: total += val except ValueError, e: pass This would work for anything that can be added to an integer even if it's not directly related to any numeric type. I can't think of a sensible use case for that, however, so in practice `isinstance` is a bit more terse and spiffy.
you could also use type() if you don'l like the idea of using a try.
&gt; before abandoning it I haven't started with either one.
INSERT COIN
I remember a site called uselesspython.com or something. Does anyone know what ever happened to it?
Alot of our automation looks at data based on filenames and filename changes. We use filename-R for resends and filename-R2 for 2nd resends ect. etc. I made a script that adds the -Rs for me in a certain directory, just out of pure laziness. However I was new to python at the time so I put way more work into it then I've gotten out of it so far. import re, os path = r'C:\Users\myuser\Desktop\-Rbin' os.chdir(path) files = os.listdir(path) for i in files: search1 = re.search ('\-R\.[mov|mpg]', i, 2) search2 = re.search ('\-R(\d|\d\d|\d\d\d)\.[mov|mpg]', i, 2) if search1: split = re.split('\.', i) nameold = split[0] extold = split[1] namenew = nameold + '2' fileold = path + '\\' + nameold + '.' + extold filenew = path + '\\' + namenew + '.' + extold os.rename (fileold, filenew) exit elif search2: split = re.split('\.', i) iterstring = re.findall('(\d|\d\d|\d\d\d)$', split[0]) iterstring = str(iterstring).strip('[\']') iteration = int(iterstring) iteration = iteration + 1 iterstring = str(iteration) nameraw = re.sub('(\d|\d\d|\d\d\d)$', '', split[0]) nameold = split[0] namenew = nameraw + iterstring extold = split[1] fileold = path + '\\' + nameold + '.' + extold filenew = path + '\\' + namenew + '.' + extold os.rename (fileold, filenew) exit else: split = re.split('\.', i) nameold = split[0] extold = split[1] namenew = nameold + '-R' fileold = path + '\\' + nameold + '.' + extold filenew = path + '\\' + namenew + '.' + extold os.rename (fileold, filenew) exit
Why do you dislike decorators so much?
[This one reads ascii text on stdin and outputs text in various hilarious mathematical symbol unicode ranges](http://bazaar.launchpad.net/~rasher/+junk/cursify/view/head:/cursify) producing cursive or fraktur letters text. Edit1: Technically not all letters are defined in the ranges I output (I think they're defined elsewhere), but it turns out fonts fill them out anyway. Edit2: Example usage: $ echo "Dongs" | cursify fraktur 𝔇𝔬𝔫𝔤𝔰 Edit3: Just pushed a fix for edit1 so the script now produces valid unicode \o/ (or should I say 🙌)
Here's one. Just a python cgi script for displaying the results of ruptime. Used in our research group for everyone to check the usage of our machines, not very elegant, but it works. Names of hosts have been changed to protect the innocent. [Code [paste.ubuntu.com]](http://paste.ubuntu.com/698722/)
I did not have much experience with decorators, had only used them, when creating the script, and i never really needed to change it.
Had to scrape US Postal Codes for [one of my projects this summer](http://www.madewithdata.com) at Code for America — so I used this to [scrape the USPS ZIP Code site](https://github.com/zachwill/usps_zipcodes) and this [script to interface with the EPA's water polluters API](https://github.com/zachwill/epa_pcs_zip_codes).
CRAZY COMMA USAGE DETECTED. DEPLOY [PREZI](http://prezi.com/4yyv4ewqpsbp/become-a-comma-charmer/).
Impressive.
http://ficture.it private beta.
Basically you can wrap up other functions into other functions, effectively calling one each time you call another. Very useful for situations like this where inside another you're calling something like you do. You'd do something like this: def decorator(f): def wrapper(*args): #code return wrapper @decorator def function(*args): #code That way you can call the other functions explicitly without calling them like you are doing. It just makes for easier maintenance. Remember that a decorator is just syntactic sugar for: def decorator(*args): pass def function(*args): pass function = decorator(function) I actually work at HP so obviously we've got a few of the printers about so you've reminded me how much I like to fuck with people. Tomorrow.
 import winsound winsound.Beep(392, 100) winsound.Beep(38, 100) winsound.Beep(392, 100) winsound.Beep(38, 100) winsound.Beep(349, 100) winsound.Beep(38, 100) winsound.Beep(392, 300) winsound.Beep(38, 100) winsound.Beep(294, 300) winsound.Beep(38, 100) winsound.Beep(294, 100) winsound.Beep(38, 100) winsound.Beep(392, 100) winsound.Beep(38, 100) winsound.Beep(523, 100) winsound.Beep(38, 100) winsound.Beep(494, 100) winsound.Beep(38, 100) winsound.Beep(392, 300) winsound.Beep(37, 0)
Put this all over the place in your code :D import winsound import random if random.random() &lt; 0.001: winsound.Beep(32767,300) 
^^ this
For pedagogical purposes it might be nice to see where one would prefer to use a decorator in the OP's code. I know generally how decorators *should* work, but I never use them so I don't have much experience knowing why I'd want to use them, aside from apparently avoiding foo(bar(baz()))? Is this just about the wraptext function in OP's code?
This is wonderful, thank you. 
This is just what I needed.
I do think I win this thread so far. All the other scripts do stuff you might actually want! Except OP, possibly.
decorators *should* be used sparingly; They are not syntactic-sugar, they have a runtime 'thing' going on...
𝔇𝔢𝔱 𝔢𝔯 𝔟𝔢𝔯𝔯𝔢 𝔰𝔶𝔫𝔡 𝔞𝔱 𝔲𝔫𝔦𝔠𝔬𝔡𝔢 𝔰𝔦𝔱𝔱 𝔣𝔯𝔞𝔨𝔱𝔲𝔯𝔬𝔪𝔯𝔞𝔞𝔡𝔢 𝔥𝔢𝔳 𝔦𝔨𝔨𝔧𝔢 æ 𝔬𝔤 ø, 𝔞𝔳 𝔡𝔦 𝔢𝔤 𝔥𝔢𝔳 𝔰𝔬 𝔪𝔶𝔨𝔢𝔱 𝔩𝔶𝔰𝔱 𝔱𝔦𝔩 𝔞𝔱 𝔰𝔨𝔯𝔦𝔳𝔞 𝔩𝔞𝔫𝔡𝔰𝔪𝔞𝔞𝔩 𝔭𝔞𝔞 𝔣𝔯𝔞𝔨𝔱𝔲𝔯. :( But yes, if it were up to me, I feel like you win. Also, by the way, I have a narrow build of python, so unichr wasn't accepting integers over 10000, but I fixed it by using python3.2 and the chr method instead.
Some time ago Ask The Pony blog made a detailed tutorial on deploying Django on Heroku and how to make it perform 8 times faster than usual using some simple tircks: http://www.askthepony.com/blog/2011/07/getting-django-on-heroku-prancing-8-times-faster/
This script makes silly "sparktweets": https://gist.github.com/967783 $ python sparktweet.py &lt;&lt;&lt; 'OMG TRENDS {5683112}' OMG TRENDS ▅▆█▃▁▁▂ #sparktweet 
I assume we're talking Python code (because I have plenty of non-python useless scripts). * [fgijagotchi](http://dev.samhart.net/fgijagotchi/) : Very stupid thing I did one afternoon from some IRC conversation talking about how profile pictures people had looked like Tamagotchi. * [FGIJ Productivity Invaders](http://dev.samhart.net/fgij-invaders/) : Even stupider-er-y thing I did where I took the above and evolved it into a game (both this and the above need pygame). * [mrpeabody](http://dev.samhart.net/mrpeabody/) : Quite possibly the dumbest Mercurial plugin in the world. Alters timestamps in commit messages. Why? [Because sometimes you have to fight stupid with stupid.](http://dev.samhart.net/mrpeabody/file/e64319986ecd/README) * [picolator](http://dev.samhart.net/picolater/) : Some overly complicated image prep thing to mass-tweak images to very specific settings for some web-project I've long since abandoned.
No luck setting the value on an HP LaserJet 2600n, though I could read the value. Anyone have success?
Convert string representations of number in a given base to another base. def value_of(string,digits): digit_val_dict = dict(x[::-1] for x in enumerate(digits)) base_n = len(digits) total = 0 e = 0 for d in string[::-1]: total += digit_val_dict[d] * (base_n ** e) e += 1 return total def make_number_rep(n,digits): digit_val_dict = dict(x for x in enumerate(digits)) base_n = len(digits) rep = '' e = 1 while n &gt;= base_n**e: e += 1 e -= 1 while e &gt;= 0: m, n = divmod(n,base_n**e) rep += digit_val_dict[m] e -= 1 return rep def convert(string,ndigits,fdigits): return make_number_rep(value_of(string,ndigits),fdigits) e.g. convert('64', '0123456789', '01') = '1000000' convert('255', '0123456789', '0123456789abcdef') = 'ff' Also works as a form of compression... if you know how to swing it 
Assuming you are on a Mac, this calls a game of Bingo. import os from random import * import time nums = [] for x in range(89): nums.append(x+1) while len(nums) &gt; 0: picked = choice(nums) nums.remove(picked) print "%d" % picked if picked == 1: os.system("say kellys eye, number 1") elif picked == 10: os.system("say Maggies den, number 10") elif picked == 11: os.system("say legs, 11") elif picked == 22: os.system("say 2 little ducks, 22") elif picked == 16: os.system("say 1 and 6, sweet 16") elif picked == 88: os.system("say 2 fat ladies, 88") elif picked &lt; 10: os.system("say on its own number %d" % picked) elif picked % 11 == 0: os.system("say all the %ds,%d" % (picked/11,picked)) elif picked % 10 == 0: os.system("say %d oh blind %d" % (picked/10,picked)) else: os.system("say %d and %d, %d" % (picked/10,picked%10,picked)) time.sleep(7) 
freedom can't be good or bad... it's a state... and it's up to you to do bad or good things and it all depends of your point of view.
I wonder whether your script would work on [these unassuming public printers](http://www.shodanhq.com/search?q=LCDispatch) :)
Upvoted - some of the others seemed almost useful.
Someone I work with did this only a few days ago. Small world.
Changes the status message on printers? Useless? Tell that to RMS.
FEED ME A STRAY CAT
A minor issue that I see for PyPy HPC adoption is support for PPC. Some of computers on the TOP500 list are IBM BlueGene systems which have 32 bit PPC CPUs. Of course there are a lot of non-PPC computers out there! I'm not criticizing PyPy for not support PPC, just mentioning that there are other architectures that are used in HPC other than x86_64.
Hmm, hard to say in the abstract. Maybe the teacher wants that behavior? You can't really say without knowing the design requirements, what problem you're actually trying to solve, etc.
I think they got it already...
Yeah, the message got along. If you can find someone to pay money for that effort, it would happen faster, but other than that just stay tuned. PS. I can imagine being hired to work on numpy, pull your strings.
guess what... https://bitbucket.org/pypy/pypy/src/ppc-jit-backend
Very cool. You guys amaze me! I didn't see this advertised anywhere on the website but it looks like it has been in the tree for a while.
Try it, at your own risk :)
It's there, but it's not complete.
Whats the sale price? Is it just the 50% off they have on the site? 
That's not what I meant. Everyone in the world has been asking for NumPy and the PyPy devs know it. They've known it for a long time. They'll figure it out. It's not like they forgot or didn't know about NumPy...
And that run time 'thing' is the name rebinding that I mentioned.
There's a single function that's used to call the 'main' function. There are at least two places where I would decorate the functions. I've not had my coffee yet, so I'll need to inhale that and then I'll change it to show you. 
I realise it's a longshot, but would you happen to know where I could get a CUPS-PPD for network-attached HP LaserJet 2600n, or at least a *nix (OSX and Linux, BSD would be nice) driver? I've tried everywhere.
Well volunteered.
My HP printer seems immune to these shenanigans. Sad face.
Yes, it's always not hammer's fault, but man's who used it to kill. But if you can give someone a hummer by which he can still do his job, but without having possibility to kill anyone -- it would be nice, I guess. Like variables in Erlang, they did it not because it's hard to make variable have an ability to change it's value.
Yeah, we need python zen for template languages.
That dictionary literal is a tad verbose don't ya think? :-P How about this? dict(zip("&gt;&lt;+-.,[","p+=1|p-=1|s[p]+=1|s[p]-=1|write(1,chr(s[p]))|s[p]=ord(read(0,1))|while s[p]:".split('|')))
And if you are a good programmer -- then you don't need a freedom to do bad things. And since there are bad programmers out there and everyone make mistakes -- then there's no reason to keep freedom of doing bad things.
Never been there. Now I'm interested :-)
Freedom to do bad things usually comes with freedom to do good things as well.
There are at least bounties of £1,200 for numpy integration: http://www.opensubscriber.com/message/pypy-dev@python.org/15617217.html
Freedom to do good things can go to Jinja's mailing list/IRC, while you can't take all the freedom to do bad things off from allowing running regular Python code inside Mako. 
Have you tried it? How many bytes would be your version? Edit: compared to [this one](http://www.reddit.com/r/Python/comments/ksawz/my_294_byte_brainf_interpreter_do_you_know_of/c2mx39a).
I don't quite follow the first part of your sentence, but try writing a simple calendar using Jinja, without putting any display logic (e.g. `import calendar` in your view/controller).
The best guide to writing recursive functions I've ever read is _[The Little Schemer](http://www.ccs.neu.edu/home/matthias/BTLS/)_. Of course it's using Scheme, but the book teaches what Scheme you need to know from first principles too.
On Windows: C:\Python27\Lib\encodings You will need to take a look at how they're setup on there and create your own for what you're using. It's rather simple if you follow the pattern and label everything well enough. Also: C:\Python27\Lib\codecs.py 
yep, the september back-to-office sale.
http://morepypy.blogspot.com/2011/08/pypy-16-kickass-panda.html &gt; Preliminary support for NumPy: this release includes a preview of a very fast NumPy module integrated with the PyPy JIT. Unfortunately, this does not mean that you can expect to take an existing NumPy program and run it on PyPy, because the module is still unfinished and supports only some of the numpy API. However, barring some details, what works should be blazingly fast :-) They are working on that. Want to help?
As concerned as you are about numpy support in pypy, it occurred to you that the best way to help was to post on reddit? How about getting on the mailing list and volunteering or something? Or pay them money, or pay someone else money?
I don't know, I like much more herminator´s aproach, using that try-except seems a little odd to me.
Not yet. Will give it a bash later. Not sure if I can improve on your version.
As I said, this is the forgiving approach. It handles all types that can be added to a number, even if they are not based on an existing numeric type. In other words: this is the duck typing approach. It doesn't matter what you like. This isn't a matter of preference. The two approaches are different and serve different uses. Neither approach is wrong, they just do different things. Which one you should be using depends on what you mean to do.
Submit a bug report, submit a patch, or submit to ridicule.
I'm not a fanboy of pypy, but I do detest ungrateful attitudes from developers who should know better.
It would be more readable with "from random import choice" instead of "from random import *"
You can register your own codec with codecs.register. [The rest of the docs is here](http://docs.python.org/library/codecs) ([py3k](http://docs.python.org/dev/library/codecs)).
I went with Wing for its integration into Maya. Thanks everyone! =)
I don't have the script on this computer, but I wrote one a week ago that takes lines from a text file and adds quotes and commas ("line",). A friend was adding a very large number of entries (1000+) to some arrays in another script and wanted some help.
Well, we have started it in our spare time (and I'm getting some funding via credits from my university) anyways :) But yes, if you want a full-time effort, it needs a full time salary.
PyPy developer here, what can I do for you?
...and that would be [224 bytes](http://pastebin.com/QAzvzy68). And it looks better, too. Only 84 to go! :)
On reflection it should also be be nums = range(1,90) rather than the futile loop, but curiously enough I did not write it for maintainability :)
Get to work.
Paper or plastic?
You're going to need about 10 times that to get NumPy support working. That kind of money might be able to buy 4 weeks of a developer's time. You need at least 6 months.
Are you offering to pay my salary? When I work on my time I do things I care about, whether that's because they're technically interesting, I think they're high impact, or just straight up fun. Sometimes I manage to do all three at once: https://bitbucket.org/pypy/pypy/changeset/c2297d1b6a6b , this was fun as hell to work on (decomposing things like string formatting from the ground up and making them fast), and I know it was high impact: this merge was worth 40% in some of our benchmarks. CPyExt on the other hand is neither fun, nor high impact (a slow C-API isn't that interesting, there's a reason most people use C). So I'm going to keep on doing things I care about on my time, and you know where to find me if you want to hire me.
(x for x in iterable) create an iterator, a lazy evaluated iterable. Join loop over the iterable passed as parameter, whatever it is.
This is terribly outdated: it's quoting PyPy-speed-benchmarks from 2009 and is still talking about Unladen Swallow.
It is a generator expression, similar to list comprehensions. x = (f(x) for x in y if pred(x)) The above example is equivalent to: def gen_x(): for x in y: if pred(x): yield f(x) x = gen_x() del gen_x And its parentheses are omittable when it is used as only one argument in function calls. So, the code you quoted is equivalent to: chars = (random.choice(string.ascii_lowercase) for i in range(10)) ''.join(chars) Note: List comprehensions are equivalent to `map()` and `filter()`. Generator expressions are equivalent to `itertools.imap()` and `itertools.ifilter()`. Variable names defined in list comprehensions are exposed, but names defined in generator expresions are not. If you want to use list comprehensions but don’t want name pollution, use `list(f(x) for x in y if pred(x))` instead of `[f(x) for x in y if pred(x)]`.
Thank you! Explained everything... and more.
divide and conquer: first work on a python script that reads text from the command line or from a text file and prints it back out with spaces. Then worry about the issue of making it into an application that someone could use. So focus on the specific technical challenge you want to solve before you get bogged down and overwhelmed by everything else.
Where did you mention this? In any case: (Google Python Style-Guide) &gt; Use decorators judiciously when there is a clear advantage. and &gt; decorators execute at import time. Failures in decorator code are pretty much impossible to recover from That's the thing I meant.
Wow, thanks for the free advice...
care to offer a decent alternative?
1800$ / (4 weeks * 40 hours a week) = 11$/h before taxes. This would be slightly less than 4 weeks of my time I believe.
Leaking variables to the outer scope in list comprehensions is a ~~bug~~ misdesign that's fixed in 3.x. The new set/dict comprehensions in 2.7 don't have this ~~bug~~ misdesign.
Okay, the pound has come down in comparison to the dollar from the last time I checked.
http://www.google.com/search?q=python+performance+tips First hit is from the official python.org site.
Since I can't read Japanese or find some decent documentation in English I used this [example](http://hideki.posterous.com/using-mecab-from-python-on-mac-os-x) and adapted it to accept user input. [Here is the code.](https://gist.github.com/1251912). Hope it helps. **Edit:** This code is meant for Python 2.6.x or 2.7.x. In Python 3.x *raw_input()* has been renamed *input()*
Also, the fact that it still has a GIL makes me skeptical of using it for anything that has to run faster than python can currently give me. A 4x speedup would be nice of course, but if I need the speed and have to explicitly target PyPy by not using most existing packages, I'm probably going to pick another ecosystem or structure most of my code as an extension.
The part where I said: Decorators are just syntactic sugar for [..example code..] name rebinding. In this case there is a clear advantage to using them, albeit small. Could you link to what you were referring to?
I think starting with the GUI might be more rewarding for someone new to programming. (It's fairly easy and get you get something pretty that you can be proud of.) Have a look at wxwidgets for python ([wxpython](http://wiki.wxpython.org/How%20to%20Learn%20wxPython)). Some alternatives are Tkinter and Qt's python bindings.
The quote is from [here](https://google-styleguide.googlecode.com/svn/trunk/pyguide.html), the 'Function and Method Decorators' section. Decorators aren't just syntactic sugar, they don't execute at runtime. I think the advantage needs to outweight the risk of complicating debugging.
Your life will be made 100x easier if you learn to use lxml to parse the page
Catch an error only if you need to, i.e. if you expect to see an error. You shouldn't take every operation and catch all possible errors, but use input, io, anything that is less predictable. If you need special handling for ctrl-C, catch that too.
map(lambda x: re.sub('(&lt;.+?&gt;)', '\n', x), re.findall('&lt;div class="definition"&gt;(.+?)&lt;/div&gt;', query_urbandictionary.replace('\n', ' ').replace('\r', ' '))) This works for me. You can replace \n and \r to something like $newline$ and change it back to \n after the regex, if you would like to preserve them. Above would return an empty list if there is no definition, and even though I have not tested it, it should be able to return all definitions if there are multiple definitions for a word. I changed the inside tags to new lines because I only had &lt;br /&gt; tags. You can change them to something appropriate if there are other inside tags that could be included and I assume that could be done more easily with string.replace. Also, you do not have to explicitly compile the regex expression each time. It is known that re module caches them automatically after the first use. I did not take a close look at your codes, but I would like to suggest you to take a good look at the reduce function. You may have missed something. 
&gt; Note: List comprehensions are equivalent to map() and filter(). Generator expressions are equivalent to itertools.imap() and itertools.ifilter(). This is Python 2.x only. For Python 3, map/filter correspond to itertools.imap/ifilter of Python 2.x.
Do yourself a favor and use lxml or pyquery to scrape the data for you. 
Marcofalcioni's starting point is perfect. Find a specific technical "bite" and chew on it for a bit before worrying too much about how it interacts with the rest of the application. Once you've got it working, move on to another piece, then tweak and modify the interfaces so they'll work together. To break it down a little more specifically, you might want to start by thinking about a class that would accept text input (don't worry about how to acquire the input yet, just assume you've already got it somehow) and reply with your parsed data. That's pretty easy to test by passing in string literals with your character data. From there, once you know you're parsing the input, you can go in two directions; toward the input, or toward the output. Your next step could then either be a class that can accept input from the keyboard until a predefined terminator (like a carriage return) and pass it into the class you just wrote, or you could work on the piece that accepts the data from your parser and turns it into spaced output.
Wow, thanks! I mean, this may seem like common sense but I just didn't think about it in this way. I could even make a few modules and just start importing them in when I get them all together right? edit: modules as in .py files
I'm going to use this method to approach it. FakePlasticSoul seems to have given me a way to work with that string literal by passing it into a variable (makes sense). I'm going to mess around a bit more and try and link a few classes together. Thanks!
I get this when running the code: &lt;bound method Tagger.parse of &lt;MeCab.Tagger; proxy of &lt;Swig Object of type 'MeCab::Tagger *' at 0x03181FC8&gt; &gt;&gt; Have you gotten this? (I'm using Python 2.7 btw) I'm pretty sure it's on my end, but don't know what's up. Maybe I have to def Tagger and init it?
Thanks for that link. I'm going to check it out. I'm basically trying to absorb anything I can get my hands on, but without knowing a previous language I don't know where to go. All I know is, the more diverse the material the easier it is to create new synapses in my brain.
Hello, I have alerted the devs and they called an emergency meeting in a secret pub in hamburg austria to discuss how they can remove the GIL as quickly as possible so as to not lose one of their obviously most important potential customers. I hope you can find it in your heart to show just a teeny bit more patience so that they can be given the time come up with a plan to address this. And whatever you do, please don't write a blog about it. Of course if I was one of the devs, I wouldn't care if you used it or not. And I would use the time at the emergency meeting to get hammered and laugh about it. 
Uh, you're here asking a question because you're having trouble with the beginning and end clean up bits, but the thing in the middle is a huge, *huge* can of worms. There's no simple, algorithmic way to determine where the spaces go in Japanese text. At best, you can make an algorithm that guesses---by creating a huge dictionary of all Japanese words and particles and then making a best guess effort at where the spaces might go. In fact, even what counts as a solution is highly disputed. In 私は田中です, should there be a space before the _wa_? A hyphen? Is there a space in どうぞよろしく? どういたしまして? What about 冷蔵庫にはキュウリあってたのに… should there be a space between _ni_ and _wa_? Between _atte_ and _ta_? Between that and the _noni_? If you can't define what the solution to a problem looks like, you cannot make a computer program to solve the problem. Sorry, that's the core limitation of computers.
yeah it is a little dated but, there's still some good stuff in there like the profile stuff and runpythonrun and graphviz
[JSON + requests](http://pastebin.com/PqSQ3FJ0)
Or BeautifulSoup.
That's where MeCab comes in. It can already parse the Japanese language and labels them with a multitude of extensions. It understands that 'watasi' is a pronoun, 'ha' is the topic particle, 'tanaka' is a name and 'desu' is a copula. It can also parse that 'atteta' is 'au' in the '~te' form with 'iru' attatched in a past tense form. MeCab is doing the heavily lifting, and I'm very grateful for that even if it doesn't give me 100% perfect results. Natural Language Processing for Japanese has come an incredibly long way computationally. edit: [here's](http://www17.plala.or.jp/tamradio/achi_i/mecab.jpg) a drool-worthy screen shot.
You need to learn how to use various string functions, plus regular expressions. The Internet has sites that show Python examples of all kinds. Just Google for what you want. 
Read [this](http://docs.python.org/library/stdtypes.html#string-methods). reply = raw_input('Type a string.\n&gt;&gt;') print '%s is %i characters long' % (reply, len(reply)) 
Open an interactive interpreter and experiment: Open a terminal. Type "python". $ python Python 2.7.2+ (default, Aug 16 2011, 07:29:45) [GCC 4.6.1] on linux2 Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; len("123 456 789") 11 &gt;&gt;&gt; "123 456 789".count(" ") 2 
Sure, keep treating threading as a big joke that will never catch on, and watch your language go the way of Pascal. I have a feeling the language devs who don't care if anyone uses their product are mostly working on Haskell.
Is the Python support limited to frameworks that follow WSGI?
BeautifulSoup is amazing. It saves tons of time trying to come up with regexes to parse HTML and can deal with malformed markup.
I dont see where you defined d and b. Also it might be important how you define y. 
+1'd for the lulz like all of a sudden I'm a spokesperson for python. Well lucky for me, the living I make from using python/pypy is not impacted by you. FWIW, given that processes are as easy to spin up as threads(multiprocesing... look into it), i think they are a better choice. Sure you have problems with communication just like you would in threads, but you get around the GIL limitation and processes are infinitely scalable (clouds... look into it) where threads are machine bound. So from the looks of it, you are bitching about a limitation in something that has limited scalability(cpu bound threads/GIL) and has easy workarounds(multiprocessing it's in the standard library). Am I wrong?
Perfect thanks. I have a few done. Right now I'm trying to solve "Print the 'first word' and 'last word' problems. I figure split() will get me somewhere but don't know how to print just the first and last
You can try using subplot which will let you place 8 separate graphs in a single figure. You also might want to try using plt.show() right after plt.plot() (in the for loop) 
Try without ion() and do a plt.show(); raw_input() after the loop. See if that fixes it. Also, I'd recommend IPython over vanilla Python cli for these kind of things.
[Slice](http://docs.python.org/tutorial/introduction.html) s = "this is a string" first = s.split()[:1] last = s.split()[-1:]
I have heard much about it, but not sure how to get it installed on Windows correctly. I installed it supposedly, but have no idea how to get it to run.
Baha! I forgot about the '[]' dealio. This stuff is exciting when I get it to work :) I'm nearly done now. trying to work on displaying if there is a number in the test entered by the user. Should just be a straight boolean method, but I'm getting something messed up. here's my code: if userInput.isalnum(): print "You have a digit! Congratulations, want a cookie?" else: print "You don't have any digits, but you still can have a cookie." 
Look for the **ipython.bat** under the Scripts directory of your Python root. Also install [pyreadline](http://ipython.scipy.org/Wiki/PyReadline/Intro). 
That’s not a bug, but just a misdesign. If it was a bug, it had to be fixed in a minor update of Python 2.0, the version that introduced list comprehensions.
Thanks, will probably have to try this install again. The window closes automatically after I double click the ipython file even after installing pyreadline.
That's because you're supposed to run it from Windows command line.
Hmm, and what about this? I can't seem to center the string. . &gt;Display the text entered centered within 50 columns I've tried string.ljust(50) with no luck... 
If there is a space in the string isalnum() will return false. I'm assuming that's your issue. You could use regex. if(re.search([0-9], your_string)): Or this would work but requires a bit more understanding of python. Read up on list comprehensions. string = "number 9" any([letter.isdigit() for letter in string])
Thanks for the help. Still not working, and neither did the enthought install. Probably time to bail on windows lol
Hurray!
Flask 0.8 also released: http://flask.pocoo.org/docs/changelog/#version-0-8
You're familiar with shared memory I hope? So your cloud isn't really equivalent to a single machine unless you're doing something where performance is barely an issue - in which case, why bother with PyPy? And you'll find that processes aren't remotely as fast to spin up as threads on Windows. If all you're doing is some embarrassingly parallel map-reduce type thing then by all means use a message queue and separate processes. If you're writing scientific code using numpy, you'll eventually want higher performance on a single machine than you get from single threaded python (even after resorting to cython). It would be nice to have the same tools available that you get from essentially every other modern language.
&gt;Probably time to bail on windows lol Probably, these things are far better integrated and tested under linux. But if you want to try a little longer, try installing the Python XY distribution. Also, where is the show() function? Where do you call it?
I got all of them wrong :(
"Python 2.5 is relatively recent" Is this a joke, or an archaeological find?
I've incorporated it into plt.plot() and then plt.show() one right after the other. I will check out python xy for right now. I can now get multiple figures for simple graphs, but multiple figures for stochastic simulations is screwing things up. arrrgh
1a, 3 and 4 correct! I only got 3 right because of the 'oh, this must be another stumper'-mindset, though.
Why does it have to be Python...?
Freedom includes the ability to do bad things, by definition. Doesn't mean it's encouraged, though.
You sure you got MeCab and the python bindings installed correctly?
Don't give up! I'm sure you will sort it out eventually (you can also ask on Freenode and Stack Overflow, and if all else fails, the matplotlib mailing list). I've been using matplotlib for a few years now and I'm still very happy with it.
Please see [this](http://www.python.org/dev/peps/pep-0318/#current-implementation-history), they are syntactic sugar and syntactic sugar only.
I don't understand question 3. Why the generator churns out 31, 41, 32, 42?
I got 2 only. I now understand most of the others, except what the hell is going on in the first example of 4?
I'm surprised they're talking about SWIG over Cython.
(2) is ancient trivia. I guess it was interesting back when Python 2.5 was "relatively recent". (4) is about [operator precedence](http://docs.python.org/reference/expressions.html#summary). (3) is [clearly explained](http://docs.python.org/reference/expressions.html#generator-expressions). (1) is a common gotcha. In case a, the lambda is created only with the name i in its `__code__.co_names`. The function loads i with the op LOAD_GLOBAL. However, by the time the for loop ends, global i is 99 . For case b, in Python 2 the list comprehension leaks i, so the lambda function references the global i just like in the first case. But in Python 3 the list comprehension is a closed scope, which triggers the creation of a closure. The reference to the local i is stored in `__closure__[0].cell_contents`, and the name 'i' is stored in `__code__.co_freevars`. The function loads i with the op LOAD_DEREF. The end result is similar, except it no longer depends on global i. So 'del i' won't break it (since there's no i to delete). To use the value of i as a constant in the function definition, you could double up on the lambda: adders = [(lambda k: (lambda x: x + k))(i) for i in range(0, 100)] I prefer this over altering the function signature with a default argument. 
chengelog https://github.com/mitsuhiko/flask/blob/master/CHANGES 
These lines are equivalent: print "word" in a == False print "word" in a and a == False In a same manner, you could do: print 4 &lt; x &lt; 6 print (4 &lt; x) and (x &lt; 6) In the example above it's obvious what the expression should produce, but not so much in the first..
 In [28]: print adders[17](42) 141 In [29]: print adders[16](42) 141 In [30]: print adders[3](42) 141 Why is this ? Shouldn't the lambda use the value that *i* had when the function was created? Why is the last value of *i* used for all functions ?
OK, sounds cool. Using Python as "glue code" is definitely a recommended usage. \* Nitpick: _atte_ is from _aru_ in this example, not _au_.
What you need to do is separate the mechanics of the game from the display - you can then implement an interface and have two instances, one which draws using text and another that draws using Tkinter, but both sharing the same interface so the game class doesn't care. Rather than have your field class 'print' the board with `__str__()`, just have a generator method that yields the next point. Your drawing class will call this method. The point class should have a method that's used as a callback so the drawing class can change its state (i.e. when the user clicks on the point). Pretty much every Tkinter widget has a way of passing in a callback function. Forget about changing GUI toolkits, Tkinter has everything you need for minesweeper and the way the toolkit works is pretty much the same as Qt, GTK, wxWidgets, etc. - all you're getting with those is a more expansive widget library and stuff that doesn't matter for minesweeper ;) Definitely check out the 'ttk' module which uses Tkinter and gives you some better options - I thought it was only in Python 3.x but 2.7.1 seems to have it too. 
Just to back that up, here's the AST dump for each expression. It compiles to the same form for both cases: &gt;&gt;&gt; import ast &gt;&gt;&gt; args = ('&lt;string&gt;', 'eval', ast.PyCF_ONLY_AST) &gt;&gt;&gt; ast.dump(compile('4 &lt; x &lt; 6', *args)) "Expression(body=Compare(left=Num(n=4), ops=[Lt(), Lt()], comparators=[Name(id=' x', ctx=Load()), Num(n=6)]))" &gt;&gt;&gt; ast.dump(compile('"word" in [] == False', *args)) "Expression(body=Compare(left=Str(s='word'), ops=[In(), Eq()], comparators=[List (elts=[], ctx=Load()), Name(id='False', ctx=Load())]))" 
I should hope so considering that's its target audience! :) Out of curiosity, do you make use of the traits/chaco libraries? I really like that enthought aren't just repackaging and adding a fee, but actually value-adding to the suite with stuff like this. Also, I've found the staff to be keenly interested in their product, I tweeted once about EPD and was contacted almost immediately by them. Makes me wonder what their paying customers get (in a good way!) 
http://www.enthought.com/products/upgrade.php 
Wow, that is really odd. I often run matplotlib scripts that produce 20+ windows each with a couple sub plots, each with many curves plotted, and I have never had any trouble. I don't use ion() though, so my guess is that is the issue.
No if you're not talking about absolute freedom or something.
You can't always apply a predefined function. Programming is (or should be) about thinking things through. Think about it mathematically. Every string has a certain length, and that string can be centered at the 50 column point (if the string is equal to or less than 100 columns itself). You do this by adding 50-(length / 2) spaces to the left of the string. For example, a 20-character string needs to have 50-(20 / 2) = 40 spaces added to its left side. This makes that string extend from the 40th to the 60th columns, exactly centered in the 50th column where you want it. Example: #!/usr/bin/env python # -*- coding: utf-8 -*- def show_centered_string(string,center): print( (' ' * (center-len(string) / 2)) + string ) center = 50 show_centered_string('+',center) show_centered_string('*' * 80,center) show_centered_string('-' * 100,center) show_centered_string('this is my string',center) 
Well dude, looks like you are going to have to write your own language/virtual machine :) . Good luck with that. I hope these performance requirements(which can only be solved by cpu bound threads on windows) are for some noble purpose like curing cancer and not some high frequency trading bullshit. Good luck 
The file's lastmod is 2008-02-26 19:19
Not to be confused with ".werkkzeug": http://www.theprodukkt.com/werkkzeug1
&gt; standardized compiler design What standard is that? :)
codeneme: Rajika
Are you doing any realtime communication? What async worker are you using with gunicorn if so? What web framework are you using on top of all this?
Btw, we're planning to make JSON faster. Stay tuned :)
First: I never said one of both aproach is wrong. Don't try to look like a smart ass putting words that I didn't say on my lips*. Second: of course it's a matter or preference, since I am giving my opinion. Or should I better stay quite and just lurk proggit? ; ) And as you say, it really depends on what I need to do, which is not really explicit in the assigment sentence. *Fingers.
meaning lexer-&gt;parser-&gt;generator, as opposed to lexer-&gt;interpreter (i.e. if you generate output directly from a regular expression against a source template)
This issue comes up from time to time in mailing lists. It has to do with updating the event loop of the matplotlib window. In Windows you can solve it like this: If you have PyQt4 installed and you're using the Qt4Agg matplolib backend, you can add these lines to your script: -&gt; from PyQt4.QtGui import QApplication for j in b: for k in t: #some equation of y plt.figure() plt.plot(t, y, label = 'something') -&gt; plt.show() -&gt; QApplication.processEvents() This will update the window and you could see one plot after the other. You can check what your backend is with: &gt;&gt;&gt; import matplotlib &gt;&gt;&gt; matplotlib.get_backend() If you don't get 'Qt4Agg' see how to change it in these links: http://matplotlib.sourceforge.net/users/customizing.html#customizing-matplotlib http://matplotlib.sourceforge.net/faq/troubleshooting_faq.html#locating-matplotlib-config-dir I you install Python(x,y) you'll get PyQt4 and could use this backend. I'm not sure about EPD because I haven't used it. Hope this helps. J.
FYI - If you could get this working on the arduino you'd have like 1000x the users and co-debuggers.
I'm not sure what you are trying to achieve. Just exiting the program will kill the threads. If you want to do something else after the SIGINT, you can add a reasonable timeout to your Queue.get call and check some boolean whether the thread should keep running. Another solution would be to put a special "Quit" object into the queue that tells the threads to shut down. You'll have to put as many of those objects into the queue as you have threads.
[Rakija](http://en.wikipedia.org/wiki/Rakia). Why codename Rakija? Flask 0.4 was named Rakia.
... I've contacted one of the owners of the 'Google Python Style-Guide'.
For what, exactly? I don't see what you're getting at exactly. You're saying that there's some extra magic going on with decorators that I'm failing to see, but everything I have read and learnt about them always states before introducing decorators is that 'decorators are syntactic sugar for what is essentially name rebinding'. Please link me to something that removes this belief if it truly is the case, but you haven't so far.
unfortunately arduino lacks the performance specs (mostly RAM) necessary to run it. 
Dammit Jim. Would have been lovely. I saw your post a few days ago and went through it with glee thinking what I could do, I would LOVE to write uC code in Python.
it should also run on the Maple RET6, which is more similar to Arduino in form factor, but we havent actually brought that up yet. 
Some of the trading guys are using OCaml in part for the reasons I mentioned. Clojure owes a lot of its popularity to the expectation that it will make it easier to exploit concurrency. Unfortunately there isn't anything yet that gives you scientific/machine learning tools of the maturity of numpy without the drawback that you have to drop to C for anything that can't be vectorized. People like me and OP feel like pypy is misdirecting dev effort away from this requirement. Some of us probably will have to write our own language or interpreter eventually.
is your application going to only be returning http status codes? if so I would use apache benchmark http://httpd.apache.org/docs/2.0/programs/ab.html Other than that, if your application will be doing anything significant, it's highly unlikely that webserver is going to be anywhere close to being THE bottleneck. Effort would be better spent on query optimization and caching. To put it another way, does a 1ms difference between webservers really make a difference when you have queries that are going to take 100's of times longer? Other than that....LMGTFY http://www.google.com/search?gcx=w&amp;sourceid=chrome&amp;ie=UTF-8&amp;q=python+webserver+benchmarks http://nichol.as/benchmark-of-python-web-servers
I still don't understand (4) In [1]: ("word" in []) Out[1]: False In [2]: "word" in [] Out[2]: False In [3]: False == False Out[3]: True In [4]: ("word" in []) == False Out[4]: True In [5]: "word" in [] == False Out[5]: False 
Yes, but because that's what the 'Google Python Style-Guide' said, which I did link to; But now I'm not sure, so I've contacted them about it.
I've read that Google Python Style-Guide, and I can't see where you picked up the 'background runtime magic' thing from, if you quote it directly, I can help decipher what it says if it's ambiguous.
Well, keep posting in here with your results. Eventually you'll grab some proper attention.
Yes, the webserver does make a big difference. Its definitely more than 1ms per request difference. I don't want to see other peoples benchmarks, I want to benchmark *my* application. My use case is different than their mini-examples they are using to test benchmarks. The question wasn't which is faster, its how do I test which is faster. I've optimized my database and caching as much as possible. Now i'm looking to see if I can squeeze out more performance from pypy and a webserver that works well on top of it.
In the 'Function and Method Decorators', under 'cons': &gt; Additionally, decorators execute at import time. I never said 'background runtime magic'
optimizing without measuring is not a good practice. :) Also a fast webserver does not speed up a slow database query or help with a poor caching strategy, that was my point . if apache bench isn't going to work for you because of application logic, then you are going to have to write your own stuff and capture metrics. Which can be done in several ways. I'm fond of the webob + Paste TransparentProxy solution for building requests to throw at an application. Sooner or later someone will chime in and say that you should use the requests library because it is awesome. It doesn't matter, the point is there are libs to help you build request to throw at your application. If you want to scale that up, do it in process/thread pools. That's how I would do it. 
I have used bottle.py several times for small personal projects. I have seen lots of talk about Flask. Does it compare in how quickly you can get a project up and running? Do the built in default servers work good?
I think you may already know this, but I usually just create threads of urllib2 requests to the server from the local. This way, the bandwidth could be less significant factor to consider, which is better for testing. You can generate random requests based on certain rules and time it (you wanted to see which one is the fastest). If you would like to see the memory usage, use the top utility. I usually used this approach to see at which levels should I cache the data in order to give out the fastest results. Your comment is correct about the milliseconds. It is usually the caching that is relevant to dramatic speed and performance improvements instead of what setups you choose to use, at least in my cases though. I use django with mongodb along with apache, and I saw up to 80% speed improvement with caching. This result would not have been available to me if I did not test my web service with the said approach. 
Huh. That's kind of weak.
Have you looked at [jmeter](http://jakarta.apache.org/jmeter/)?
Yeah, I think so too, and before MeCab I was entirely overwhelmed by the idea; scared even. I'm tackling Japanese first because of MeCab now. Korean is going to be much harder because I haven't yet found an equivalent. As for Thai, I may have to just write my own. * bunpou nazi nitpick/ question: shouldn't it just be 'atta' then? I don't know what the first noun is so I guessed 'au' only on the premise I've never seen 'aru' in the past progressive participle or w/e they call it. (sorry no Japanese support on this computer :( )
Absolutely not. I actually installed them willy-nilly because I had no idea how to. I can import it, and I've even gotten it to work once, but I had to __init __ Tagger or something (just mucking around). How did you go about the installation, and which version did you download?
I am trying to learn Python so I was hoping to have something where I could understand some of the code. If this doesn't exist than it wouldn't surprise me. 
I've got 7 downvotes for some reason. Did I ask in the wrong format or violate some rule of the subreddit? Sorry i'm new here, if there is a better way to ask it than please let me know. Thanks all. 
http://stackoverflow.com/questions/4941145/python-flask-vs-bottle
It's a chained comparison, like 1 &lt; 2 &lt; 3 &lt; 4 &lt; 5. All pairwise comparisons in the chain have to be true for the chain to be true, and evaluation short circuits at the first False. If mzial's explanation and the ASTs posted below aren't helping, try the disassembled bytecode: &gt;&gt;&gt; dis.dis(compile('"word" in [] == False', '&lt;string&gt;', 'eval')) 1 0 LOAD_CONST 0 ('word') 3 BUILD_LIST 0 6 DUP_TOP 7 ROT_THREE 8 COMPARE_OP 6 (in) 11 JUMP_IF_FALSE_OR_POP 21 14 LOAD_CONST 1 (False) 17 COMPARE_OP 2 (==) 20 RETURN_VALUE &gt;&gt; 21 ROT_TWO 22 POP_TOP 23 RETURN_VALUE It loads 'word', builds an empty list, duplicates it on the stack, rotates the stack, and compares "'word' in []". If the latter is false it jumps to line 21, rotates False to the top, pops and returns it. Otherwise (back at line 11) if the result of the comparison is true (thus not in this case) it pops the True value, leaving the empty list at the top. It then loads False and compares that to the list, returning the result of "[] == False". But none of this branch actually executes in this case since it short circuits at line 11. 
Hamburg is not in Austria, it's in Germany ;)
hah I knew there was a chance I would screw that up. i don't get(of the country) out much(at all) :)
they do stuff for money just like everyone else man. throw them a big enough bone with your demands attached. They are all pretty smart and could probably make it happen. Posting bullshit demands on reddit is probably the least effective strategy of getting what you think you are entitled to (which for free software is nothing except that it's free). 
 data = ["abc", 5, 3, 1] total = 0 for val in data: ... try: ... total += val ... except ValueError, e: ... pass ... Traceback (most recent call last): File "&lt;stdin&gt;", line 3, in &lt;module&gt; TypeError: unsupported operand type(s) for +=: 'int' and 'str' 
&gt; Experimental Python 3 Support That is from the docs...is it still so?
q.join blocks the current thread until the count of unfinished tasks is 0 (i.e. calling task\_done for each item put in the queue). So it won't process a SIGINT until 'join' unblocks. How about using the following instead: while q.unfinished_tasks: #do something #sleep Then you can install a SIGINT handler that sets a global variable that triggers the threads to gracefully exit. 
Hey weren't you on the gunicorn IRC channel last night? I am using the default sync worker with django/piston. For realtime(y) apps right now I just use polling. When I need realtime I will use twisted because that is what I am comfortable with and it's a proven and tested code base.
Awesoooom
It's still experimental. We have too few Python 3 users that we would get any feedback. It works, the testsuite passes but that does not say much :-)
No, Heroku uses a per-process model; you're essentially running an arbitrary python process in a sandboxed environment. So you could use SimpleHTTPServer if you wanted, and the example in the article uses Flask's built in HTTP server, not WSGI. However, you'd probably get the best performance with WSGI + [Tornado, Gevent, Gunicorn]
&gt; Rakija. Why codename Rakija? Flask 0.4 was named Rakia. Ah damn. I picked one form the list of alcoholic beverages I had prepaired but with different spelling and I missed that it was already used. Will improve :-)
Now we're talking :-)
Well, there's pretty much only one usable keylogger for Mac OS X, logKext, and since (as its name implies) it's a kext, that means it can't be in Python.
Thank you sir, I was not aware of that but this is exactly the information I was looking for. I will give up my search and just settle with Logkext. 
I'm using 0.9.8 on MacOS X. If you're on Windows try putting all of the files inside this [zip](http://min.us/mhEr58S0H) in your Python\Lib\site-packages and run it again.
I can't tell from your post if you have control over the thread code, but the preferred way to deal with this is to have each thread process examine a flag and exit if the flag is false. In other words, don't try to exit the thread from outside, but inside. When it comes time to cause a thread to exit, you simply reset the control flag, and the thread exits by itself, without needing to force it to a halt. 
No, but it might get me to use it to help find any bugs. :)
Thank you, looks like I didnt have the qt4agg backend. Will have to try with python xy.
It’s really cool.
That did the trick, and I was indeed using that same build. I put it in it's own folder at first in site-packages and when that didn't work put it in the main Python dir and was able to import it. Thanks for clearing this up. I guess for future modules without python installs I just toss them into site-packes, right? I'm now getting an unsupported characters, but I'm sure it's just because this laptop doesn't display JP chars. Is there a way to display JP chars in Python regardless of whether the OS has the ability to? Kinda like in browsers. Again, you're a life saver. I'm excited that I can now parse.
The best way to install python is via **pip** or **setuptools**. Google it how to install either. About the unsupported characters read about [Unicode strings](http://docs.python.org/howto/unicode.html) in Python. And since you're new to programming and learning Python, take the time to work through [Learn Python The Hard Way](http://learnpythonthehardway.org/). 
Just wondering, do y'all have any plans to support regular expressions in routes? I enjoy doing my routes with regular expressions in Sinatra. I know it's possible to do by overriding something, but when I looked in the past it seemed hacky and like something that should be built-in.
nope, it stores the name 'i' and refers to what ever value 'i' happens to have when you call the function. The last value of 'i' is the value 'i' has when those functions are called, so that's the value used.
Ah, I see.
Pretty cool. I am looking to do something similar only with hummingbirds instead of gerbils. One question though: In the merge_collided_bboxes function it looks like you are changing the size of the bbox_list while you are iterating over it. Is it just me, or would this cause you to drop (not examine) the box that occurs after the second .remove()? 
&gt; Just wondering, do y'all have any plans to support regular expressions in routes? I enjoy doing my routes with regular expressions in Sinatra. We're not using regular expressions for routing because they are not reversible. The Werkzeug rules are unique, can be reversed and support type conversions. Is there a usecase where you need regular expressions?
Not working for me, but I understand the server is under a lot of stress at the moment. This would be more awesome if it didn't require a Twitter account. Preferably no accounts at all, but at least OpenID or something.
&gt; This would be more awesome if it didn't require a Twitter account. Preferably no accounts at all, but at least OpenID or something. I wanted to use OpenID first but last time I did this I got terrible feedback that I should rather use Twitter and this time I went with Twitter and got feedback that I should rather use OpenID. Going with both I did not think was worth the troubles. And yes, I think ep.io is limiting my accounts now.
&gt; last time I did this I got terrible feedback that I should rather use Twitter and this time I went with Twitter and got feedback that I should rather use OpenID. Always the way, you can never please everyone. It's great that you took the feedback into consideration at all. I'll check back on this in a few hours and try it out.
No it's not. Moonshine rakija is 53%Vol and up. My grandfather makes 60%Vol Rakia.
Ah, thanks for explaining. I don't have my ruby code handy, but it was nice to be able to do stuff like this: `get /weblog(?:/archive(?:/\d+(?:/\d+(?:/\d+(?:.*)?)?)?)?)?/ do` That's probably wrong, and it's after lunch and I've had a margarita... In any case, I was able to take each capture separately and easily handle urls like /weblog/archive/2011/09/30/postname. I've also never used Flask's support for reversing URLs, I always prefer to just generate all the URLs for a given app in a class and keep the code in one place. I'll have a model with methods like `WeblogEntry.urlforday(...)`, or `entry.permalink`, and so on. **Edit:** Home now, here's the bit of my Ruby code: get %r{^/weblog(?:/(archive)(?:/(\d+)(?:/([A-Za-z0-9]+)(?:/(\d+)(?:/(.+))?)?)?)?)?$} do archive, year, month, day, name = params[:captures] ... That makes it really easy to take a url like /weblog/archive/2011/Sep/30/postname and drill down to each possible page you can show as part of my weblog. Ruby's "looseness" with nil values is helpful here too: whereas Python throws an exception if you "need more values to unpack", Ruby will just stick `nil`s in the rest, letting you write straightforward code to the effect of "if archive, but not year, show the archive page. Then if year and not month, show the yearly archive" and so on.
Very cool. Reminds me of [scriptlets](http://www.scriptlets.org/) or [akshell](http://www.akshell.com/) or [appjet](http://en.wikipedia.org/wiki/AppJet) if anyone remembers that. Do you have any plans to make the source code available?
pretty version: http://flask.pocoo.org/docs/changelog/#version-0-8
Yeah, unlike previous one this is from 1996 mostly.
Yes! Better yet, start by writing your first test and make it pass (read about TDD)
Whoa, that's what I was doing at first just to get the errors to shut-up! Glad there's a method of coding for a lazy guy like me. :D Really though, this is an excellent way to approach a lot of things. Sometimes I get caught up in lower tiered priorities and end up wasting way too much of my time. I'm taking my current understanding of TDD from this: http://powertwenty.com/kpd/downloads/TestDrivenDevelopmentInPython.pdf 
The meeting was in Hamburg, Austria though
As always, awesome job Armin.
Nice. If you're a Chrome or Chromium user, you can also just highlight the address, right click and 'Search Google for X'. It will bring up a link to Google generated map of the address in the very first entry. 
edit: After six hours, coffee and a slight case of carpal tunnel here is the meat of the code: import MeCab import codecs write_to = codecs.open("pholder.txt", "w", "utf-8") text = raw_input("Please insert Japanese text here: ") write_to.write(text) write_to.close() read_from = open('pholder.txt').read() mecab = MeCab.Tagger("-Owakati") print mecab.parse(read_from) Maybe it's because I'm on this Windows Vista system. I don't know, but I'm just glad it parses and spaces now. This has been hell, but I've learned a lot. Now to start patching this together with a GUI.
Who let this fag in the party? Oh wait, hi Dej!
I'm not the author; I merely posted the link here because I thought his story is very interesting. 
fricking awesome. Ubiquitous machine vision is the future.
you are doing it wrong.. your application should be in a virtualenv where that lives outside of the system python. 
It's okay. This was stuff the great uber genius "Reid" felt was worthy of attention.
I run a web dev shop and most of our projects are Python. Everyone has a separate virtualenv setup on their workstation for each project. This is specific to the OS, so it lives ourside of the SVN repository and each developer is responsible for maintaining their own. A separate virtualenv is setup on the staging server. When a developer commits to the repo for the project, a post-commit hook fires that executes a script via SSH on the staging server. This script kills the current process, performs an SVN export, rebuilds the database, and restarts the daemon. Automated regression tests using unittest and Selenium are then executed to simulate a browser stepping through various parts of the site. If a test bombs, the development team is emailed to ensure that the commiter is appropriately shamed. The virtualenv that lives on the production server(s) is the same as the staging server (binary compatible) since the whole point is to keep the two environments consistent. QA rolls code to production using some simple rsync scripts. Though I'm thinking about looking at trying some stuff using Fabric.
I thought of that, but I wanted to reduce the number of clicks I'd have to do and pages I'd need to load.
Any raw benchmarking you try and do of a web server, will in the main be of little use because the dynamics of your real world application under load from actual users is likely to be very different. What you should be concentrating on is setting up systems to allow you to monitor your actual application when deployed in production as that will be the only source of actual information which can be relied upon to guide you as to what you need to change in your stack, application or database. You can use system monitoring tools like Munin. You can also utilise database specific tools to work out what the database itself is doing. Using something like Google Analytics can also give you details about user traffic etc. For deep diving into what your application itself is doing, at the moment the only thing really available for Python is New Relic. Disclaimer. Yes I work for New Relic and I am working on the Python agent for New Relic. I wouldn't be working there though if I seriously didn't think this was a missing tool for Python web developers. Too many times have I had to deal with questions about how to best tune Apache, mod_wsgi and other WSGI servers yet one could never give a good answer because it depended on the specific application being run and the hardware and OS it was being run on. With a tool like New Relic and support for Python I can finally provide a way of helping work out how to tune your server as well as help to identify the true bottlenecks in your system. In summary, for synchronous web applications pretty well any WSGI server can be made to work, without decent monitoring though it can be hit and miss as to whether you get it right and those initial raw benchmarks will be of little use.
for the OP, here's a brief bit on setting up your own virtualenv: http://johntellsall.blogspot.com/2011/06/proper-way-to-install-pip-virtualenv.html
Why are you changing views on your server so often? Are you actively developing? If so you should be using the built in development server not your production server. 
If you google, あってたのに you can see it attested in sentences about existence. The sentence means, "Even though there had been pickles in the fridge" (although you're probably just translate it as "were"). _Atta_ is also fine for this use, but _atte ta_ gives bit more of a sense that the thing had been in there for a while for a reason.
ep.io and gondor.io
Thanks! This is a great idea :)
upvotes for you, good sir!
If you indent all your text by 4 spaces it is formatted as code, this will make your post more readable.: test this is a test this is a test
We have a default server image that we spin up using puppet. This gets us a clean box with all the standard libraries we need to run a basic Django project(Django, MySQLdb, and so on). Then we use GitHib to manage source. Once this is all good we use fabric to deployment. So we have a command "fab deploy_production" and it ssh's into the production box, puts up a maintenance screen, pulls from github, does a sync db, runs south migrations, restarts apache, and pulls down the maintenance screen. Before we had that fabfile written up deployment really sucked. That is just my two cents. I am relatively new to Django.
Hey Armin, This works for me although it's very simple - am I missing something? from werkzeug.routing import BaseConverter class RegexConverter(BaseConverter): def __init__(self, url_map, *regex): super(RegexConverter, self).__init__(url_map) self.regex = regex[0] app.url_map.converters['regex'] = RegexConverter @app.route('/foo/&lt;regex("bar|baz"):obj_type&gt;/') EDIT: show import
Ahh, that makes sense. TIL :)
[Relevant!](http://www.youtube.com/watch?v=1lBeungEnx40)
[I am sick and tired of having to pause my media player whenever I want to go out.](http://pastebin.com/ss5hmMWn)
I was messing around with Pygame today and made this. It's not much, but it's practice. Reddit Collect!
[I tried to parse a string... and I think I killed 20 people!](http://www.youtube.com/watch?v=1lBeungEnx4)
Pastebin is your friend.
Shit bro, format that shit! import numpy as np from scipy.integrate import odeint import matplotlib.pyplot as plt plt.ion() mumax = .8 #1/d maximum growth rate K = .01 #umol/L Monod constant q = 2.0*pow(10,-9) #micromo/cell nutrient needed to make one cell m = 0 #mortality rate 1/d D = .3 # dilution rate 1/d S = .5 #umol/L supply concentration Solving dN/dt def chemostat(N,t): Ni = N[0] funct = ((mumax*(S-Ni*q)*Ni)/(K+S-Ni*q))-m*Ni-D*Ni return[funct] Rstar = ((m+D)*K)/(mumax-m-D) #Equilibrium concentration of nutrient in vessel Nstar = (S-Rstar)/q #Equilibrium population density N0=.45*Nstar #setting initial conditionss to half of the equilibrium population density t = np.linspace(0, 50, 200) #creating a time vector for fifty days with 200 intervals soln = odeint(chemostat, N0, t) #solving the ode for the chemostat function plt.figure() plt.plot(t,soln, label = 'N0=.45') N0 = .30*Nstar #setting initial conditions to less than half of equilibrium soln = odeint(chemostat, N0,t) #solving ode for chemostat function again plt.plot(t,soln, label='N0=.3') # more changes in initial values N0 = .2*Nstar soln = odeint(chemostat, N0,t) plt.plot(t,soln, label = 'N0=.2') N0= .1*Nstar soln = odeint(chemostat, N0,t) plt.plot(t,soln, label = 'N0=.1') N0 = .05*Nstar soln = odeint(chemostat,N0,t) plt.plot(t,soln, label = 'N0=.05') plt.xlabel('Time in days') plt.ylabel('value of population density') plt.title('Simulated Logistic Growth in Chemostat') plt.legend(loc=0) raw_input("Say") Stochastic model of birth and death rates in a population: Stochastic growth model simulating birth and death in a population import numpy as np import random import matplotlib.pyplot as plt plt.ion() plt.figure() b = .005 #birth rate d = .0025 #death rate k = 10.0 #carrying capacity tend = np.linspace(0, 1000, 1001) #time to run n = 20.0 #initial population nt = [] #a vector storing the population changes counter1 = 0 while(counter1&lt;100): #several stochastic runs for i in tend: #creating a loop across the entire time period with discrete timesteps change = 0.0 #creating a variable to measure change in population counter = 0 #creating a counter variable for the while loop if(n==0): #stopping loop if n = 0, cannot have growth of zero population while(i&lt;len(tend)): nt.append(0) i = i+1 break else: nt.append(n) #adding on to the nt vector to map population changes while (counter &lt;n): #looping for every individual in the population if (random.random()&lt;(b*(1-n/k))): #if the random number is less than the given birth rate, one birth change = change+1 if (random.random()&lt;d): change = change-1 # subtracts one from the population change if random is less than the death rate if (n&lt;=0): #populations cannot be negative n=0 break n = n+change #the new population counter = counter +1 plt.plot(tend,nt) nt = [] counter1 = counter1+1 plt.xlabel('Time in discrete units') plt.ylabel('Number of animals') plt.title('Stochastic model of birth and death in a small population') raw_input("Say") 
I may be able to help you out. I am one of the developers of SimpleCV (simplecv.org). We have a built in function that does frame differencing. I should be able to replicate most of the functionality here in maybe 20 lines of python. 
Maybe you should do it in matlab too and compare. (I think I used scilab at school). I made a gui in matlab for an internship. I felt like I was bending the rules of programming. I also made a sudoku generator in matlab. That interniship was extremely boring, and I didn't have internet.
The problem with posting Python code without indentation is that, without the indentation, the code loses all meaning -- just as though you had left-flushed the original listing in your editor. Python is almost completely unique in this regard -- whitespace is structural, and without it, the program's meaning is fatally undermined. Always indent Python program listings by four spaces, or they lose all meaning. 
&gt; python main.py Traceback (most recent call last): File "main.py", line 13, in &lt;module&gt; background = pygame.image.load(os.path.join('data', 'background.JPG')) pygame.error: Couldn't open data/background.JPG Sounds like a Windows/Linux case-sensitivity issue. I'm using Linux where case matters. EDIT: Confirmed, after I changed JPG -&gt; jpg and PNG -&gt; png it worked. Well done.
Huh, glad you figured that out. Thanks.
Even easier: # Use a session for cookie persistence. with requests.session() as s: # Form data. data = dict(username='username', password='password', login='login') # Send the request. r = requests.post('http://projecteuler.net/index.php', data=data) print r.cookies
Actually I added pickle and cPickle after I posted this -- predictably non-c pickle was an order of magnetude worse than most, scoring something like 38 seconds on karel.json, which all the other modules did in under 7. cPickle was competitive with yajl, which is nice. In the real world, pickle has always caused me trouble, with its opaque protocol levels (the highest of which has a thing for stratospheric Unicode values that are non-trivially annoying to stash anywhere) and its uselessness outside of python-land (as masklinn poins out). I am sticking with json, despite msgpack's elegant efficiency -- the nice thing about having a shitload of json implementations to choose from is you can use whichever works best when you need to. ujson writes like a champ, but simplejson is a faster reader for some deeper trees. If you're just writing API calls that puke out some dicts to a browser, the json library's speed won't matter much in like 19 out of 20 situations; I often reach for simplejson because it can pretty-print something that I might need to debug. Programmer time vs. user time, etc etc. TL;DR neither pickle nor cPickle blew my mind in this context.
yeah, I din't quite "get" netstring/tnetstring; this was the first time I looked at those libs. If you have anything on them, post it!
I don't. If python3 had the '%' string-substitution operator I would port all my stuff to it like yesterday. Without the casual string templating, it feels like a different language altogether.
I was a MATLAB TA in the ECE dept at my school... If you'd simply used python I'd probably just have just marked all your papers "check plus." Syntax and compilation be damned. Told a couple of smart kids to try this and no one did :(
Incidentally, at my current job I hear "Oh Python, I've always wanted to learn that" at least once a day
Please warn if you are going to link to the archive instead of a webpage. The alien collects the upvote before touching it so it's a bit perturbing because you don't know if you collected it or it just moved. Maybe you should add some effect (modify the icon or add a sound) and/or reduce the hitbox. Maybe the game would be more interesting if the arrow moved. Nice attempt otherwise. 
&gt; rather than SQL which was designed decades (note the plural) before the web was invented FTFY.
Simple answer; 1) Ask how many Python hosting providers are available 2) wait for a bunch of replies listing the multitude of providers 3) count the number of Python hosting providers 4) Ask how many PHP hosting providers are available 5) Don't even bother counting because you'll never finish counting them all. 
&gt;The possibility the ecosystem moves on doesn't affect the stuff you write now that will continue to work the way it does now. I'm not a big Jesus freak but have you ever heard the bit about "Let he who is without sin cast the first stone"?
While the machine vision part of the story is interesting in its own, what struck me the most is that his child was able to actually use it (python) in her 6h grade school science project and also learn a lot from it. As he writes; "I’m convinced that Python is the best language currently available for teaching kids how to program.". That, and Gerbils.
Relevant book: [Python Scripting for Computational Science](http://www.amazon.com/Python-Scripting-Computational-Science-Engineering/dp/3540739157). Includes a good python primer, use of numpy, making gui's for scripts, and interfacing with matlab, fortran, c and c++. Its well written and packed with examples.
Actively developing, but unfortunately we're slowly replacing perl sections with django, so I need the full server up for the perl aspects or many things stop working... However, you do bring up a good option, I guess I *could* have a sys param set to determine if it's dev or not and have the links to django use a dev port # if it's set, but that seems sloppy... I'd rather just not have PyISAPIe keeping module open between page refreshes if that's possible. I understand that would be bad for production, but you'd think there would at least be an option for turning it off... 
Yeah, PC LOAD LETTER, What the fuck does that mean?
Truly the approach is not to put a GUI object inside of your existing objects. The approach is to wrap your existing objects with GUI code. I also recommend qt and pyqt (GPL or purchased license)), though some may recommend pyside (LGPL). The signal / slot mechanism is simply superior to anything available in other toolkits and qt designer is excellent for facilitating GUI creation. Regardless of your choice of toolkits, you will need to eventually give the GUI portion of the code control with a blocking call which returns only after the GUI is finished. Consequently, any approach which attempts to execute code external to that blocking loop will be unsuccessful. The simplest way to start learning this is to use a hello world and note the blocking call at the end (see: main() in pyqt). Also this type of a question is generally better served on stackoverflow.
You two are talking about the same thing. 1. They execute at runtime insofar that the decorator is a method that will be executed after the decorated method has been defined. 2. It is syntactic sugar, insofar that: - @decorator def foo(): ... is the same as def foo(): ... foo = decorator(foo) In the last example you can see that the decorator method will be executed after foo has been defined. So both of you are right. It is syntactic sugar and it is executed.
One that I made called [Pyks](https://github.com/cbooth/pyks) that converts time to kiloseconds and back to HH:MM:SS. Put far too much work into it to be fair...
Actually I did indent. For some reason the reddit window did not like it and just jumbled them together :/. Probably because I posted the code directly.
Yeah it was formatted, and it loked okay when I tried to paste it here, but then after submitting it got jumbled up.
Use xrange. return list(xrange((math.floor(a/x)+1)*x,b,x)) 
I started learning Python in the last year in college. I liked it because it was easier to use than C++, Java and C#. I used it in the project for the compilers course (using [pyggy](https://github.com/sprymix/pyggy)). I was able to write the compiler from scratch for a tiny language in 4 days, and my colleague was able to learn Python from scratch &amp; write the editor for this language in the same period. Everyone else in the class was fighting with C code generated by lexx/yacc for more than 2 weeks, and we got the highest marks in the class :)
I'm using python3, where range acts like xrange.
It was a c++ and a java class that made me never want to do computer science again. So I got into biology. My prof wanted someone who knew some programming though. So I typed in 'easiest programming language' into google and stumbled across python. 
uhhh `list(xrange(...))` is the same as `range(...)` removing the `list` would fix the memory usage, but the program in general isn't even close to being correct. It's syntactically correct, but what it actually does has nothing to do with what the problem is asking for. I would talk to the people in this programming league of yours. The problems with the program are not the kind you are going to fix and understand by posting on stackoverflow.
pppppppppppaaaaaaaaaaaassssssssssstttttttttttteeeeeeeeeeeeeeeeeeebbbbbbbbbbbbbiiiiiiiiiiiiiiiiiiinnnnnnnnnnnnnnnnn
seconded on ep.io, its an excellent service.
If you use [Reddit Enhancement Suite](http://reddit.honestbleeps.com/) you can simply select everything after you've pasted your code and click that *code* link, and everything will get indented for four more spaces.
You might also consider creating an account on [github](http://github.com) or similar, that way you would get both a place to effortlessly publish your code and an external incentive to finally learn version control (which is a truly amazing technology).
Fabric. Learn it, love it,
as a computational biologist who uses python almost exclusively, upvote for you.
Thank you, that was hilarious :P ... I was just taking a break from writing some matlab code for class
I think the process could be better. Others do as well. See [A Python Web Application Package and Format](http://blog.ianbicking.org/2011/03/31/python-webapp-package/) for some ideas. Also take a look at some services like Heroku, dotcloud, ep.io and gondor.io to get some ideas on how to streamline the process. Some tips: use virtualenv, pip and requirements.txt to set up your initial environment. fabric can do more than just transfer files. Build yourself a small library of fabric scripts to automate most of the process for you. If you're managing a bunch of servers, have a look at Puppet or Chef. Some hosts, such as Linode, have libraries of package setup scripts. You can use these to bootstrap a new environment quickly. Use preconfigured server images instead of 'mint' distros. ------ My typical setup: * app: running in a virtualenv, using gunicorn wsgi server * nginx: instead of apache, serving reverse proxy to gunicorn * supervisor: to keep processes up and running * fabric scripts to bootstrap a new python environment, push a code update and reload app servers. most of the above are quite easy to setup.
it works the same in firefox
You can always **edit** your posts. *Update:* just indent the code block with 4 spaces. It's still not too late...
Explain, why? :(
reddit interprets as code anything that has 4 spaces in front of it. So indent all your code one more level. 
Ha, I used the python threading library to do this. People were coming in with 1200 line code sets in c, my code for the whole project was like... 350 lines max.
Cool, what do you work on? My area is population dynamics and evolution of disease resistance in populations.
http://www.minecraftprint.com/ &lt;-- link to the actual site
I'm very interested to know if your professor would "downvote" you for using Python when he specified Matlab. Let us know how your grade turns out! Also, I second another commenter's request for equivalent matlab code for comparison... if you're bored :)
 The code repository is hosted on bitbucket: https://bitbucket.org/san/luisito/ To get it just run: System Message: ERROR/3 (&lt;string&gt;, line 65) Unknown directive type "code-block". .. code-block:: bash $ hg clone https://bitbucket.org/san/luisito You say that is "should be used when a lot (maybe thousands) of low traffic sites are deployed.". Is there a reason not to use it on only a few sites?
Also known as "Lego".
&gt; which is a truly *necessary* technology FYFY :)
Not realy. If you want to deploy more sites that your memory allows it will be useful too. Currently I am using it with ~50 sites.
Developing apps for a framework via a web interface, this strangely reminds me of web2py.
Yeah well, I didn't want to risk sounding all fanboy-ish here.
I just started using PyInstaller. Nice if you need a specific version of Python and mix of modules not already on the target machine. I even packaged a WSDL file in the executable. 
Only in the same sense that carpenters are hammer fan boys. ;)
Okay, that's a solid point.
Just curious, what was your reasoning behind using the core `subprocess` module instead of Twisted's `reactor.spawnProcess()` or an existing Twisted-based process pool implementation like `Ampoule` in your `Server` class? I realize that all you're doing is a `popen()` for each Server, so "simplicity" is probably the answer... I wonder if using one of these would help with your blocking FIXME. 
&gt;For given integers a and b your task is to find how many integers in the range [a,b] are divisible by a number x, and have the additional property that the sum of their digits lies in the range [l,r] for given l,r. how_many = sum(1 for n in range(a + ((x - a%x)%x), b+1, x) if l &lt;= sum(int(digit) for digit in str(n)) &lt;= r) Or more verbosely: sumdigits = lambda n: sum(int(digit) for digit in str(n)) offset = (x - a%x) % x generate_numbers = (n for n in range(a + offset, b + 1, x) if l &lt;= sumdigits(n) &lt;= r) how_many = sum(1 for n in generate_numbers())
Good explanation, but your definition of "easy to setup" is miscalibrated. Remember, what we're competing against is "rsync PHP files to the server. Done." Any process that includes two new web servers and two kinds of external scripts is not there yet.
The program isn't too far off working for small cases, although I don't know quite what count_to_single is for. I think what Justin means is that you've not appreciated the full scale of the problem: remember b can be up to 10^100 . The error means you're trying to hold in memory all numbers divisible by x, which won't work. But even if you didn't do that, no program could go through all those numbers within 2 seconds. You need to find a smarter solution (unless the actual tests they run are more gentle than the constraints they put on the input).
Seems like a stupidly roundabout way to do voxel printing.
didn't check your code, this is how I do it: https://gist.github.com/1256635 you owe me ten points.
1. Giving people complete solutions to problems without any discussion is not a good way to help them learn. 2. a = 1, b = 10^100 and x = 1 are perfectly legal inputs according to the problem statement. Try iterating over a googol of numbers.
Why are you using a while loop instead of `for current in xrange(a, b, x)`? It makes the code harder to follow. (I would also probably rename `current` to `n` or something, and maybe put the sum digits thing into its own function for clarity.)
1. well that depends, one can learn by example and investigation and it's not like I won't answer questions if asked. in any case the single fact that the question was based on homework and not a specific problem demonstrates bad attitude and I'm not responsible for that or for the way people use my contibution. 2. other than overflowing the int/long type I don't see a problem, now you try storing a googol of numbers in memory...
Actually, you are correct. 
I'm grateful for your code, and for everyone's replies, but I got time limit exceeded still. Nevermind, thanks.
I prefer straight loops for this kind of things, the generator might not accumulate the list on memory depending on the implementation as a lazy list would do but I'll be forced to verify that in order to be sure, with this I already know there won't be any more memory consumption than the variables used. the rest is just coding style and regardless of your taste it's ok anyway.
next step would be to parallelize the algorithm (whichever you're using) but unless you figure out a math property that allows you to do less operations it's just a matter of cpu power.
That was so so good. It belongs as a top level post, though I'm not sure what the right subreddit would be: maybe Python, or maybe somewhere where they actually use Matlab. Do it!
Kinda, but not so much if your Minecraft creations are already built.
Bingo. Thanks for posting this.
Please no, doctest is a really bad way to write tests, it has a number of distinct disadvantages: * It tests the repr of things, rather than for any concrete attributes/properties of them. This can lead to extremely brittle tests. * It doesn't work well with other testing practices (setup/teradown) * Any test that is remotely complicated becomes a pain to read (read: have even a single level of indentation). * Static analysis tools can't see them, your editor can't highlight them.
Well, old time professors will not change their minds so easily. I did mention that I am not using matlab and he seems okay with it. The code for matlab is almost the same. Just change the syntax of the for loops and if statements and that's it. But this is why I hate matlab: "This program not for research or commercial use but for instructional use only." This is displayed on all the lab machines on our campus. 
The trick is to put the entire listing into an editor, apply a block indent of at least 4 spaces, than copy the result into the Reddit submission window. What I mean is that all the lines have to be given the same treatment for the listing to come out right. 
Not a clue — we're an all-Mac shop. (Except for our fileserver, which doesn't need to print.)
This, this, a million times this.
https://docs.djangoproject.com/en/dev/ref/django-admin/#runserver-port-or-address-port
It's all coding style. I'm just saying what I think looks better.
* [python](http://www.reddit.com/r/Python/comments/iy6zt/matropolis_scientists_of_the_world_unite_aka_the/) * [matlab](http://www.reddit.com/r/matlab/comments/iyjce/matropolis_scientists_of_the_world_unite_aka_the/) * [opensource](http://www.reddit.com/r/opensource/comments/iyaj5/matropolis_scientists_of_the_world_unite_aka_the/) * [videos](http://www.reddit.com/r/videos/comments/iynu3/matropolis_scientists_of_the_world_unite_aka_the/) * [engineering](http://www.reddit.com/r/engineering/comments/iyry7/xpost_from_rpython_matropolis_one_persons_take_on/) * [ucsd](http://www.reddit.com/r/UCSD/comments/iy7ks/the_ucsd_awesome_python_experience_presents/)
If they want you to do anything other than a NOOP on 10**100 elements, it's not feasibly doable. So, either there's some goofy mathematical shortcut way of doing the program (although none jumps out on casual inspection of the problem), or they just threw in the numbers for no particular reason and they don't mean anything.
..Mac drivers are what I'm after? (Mac printer drivers also work on Linux/BSD, or should) If you're interested in helping me; [CUPS administration page](http://localhost:631) --&gt; "Printers" tab -&gt; Your HP2600n -&gt; copy-paste "Driver:" and "Connection:". Thankyou very much in advance!
that's ok but there's a difference in what is coding style and what is performance, not all solutions are equivalent.
Try a Heroku free account. You can really do a rather lot of things with it. Here's a hello world Flask (microframework) app: http://devcenter.heroku.com/articles/python Personally, I prefer some additional cohesion at the cost of weight, so here's the Django variant: http://devcenter.heroku.com/articles/django If you start wanting to see how far you can push your one-free-process on Heroku, consider futzing around with gunicorn and gevent (you can even combine them, last I checked, for omgoptimized. It may not even be hard.) Hope this helps. Disclaimer: I work at Heroku, and am peripherally involved in the Python support.
cool stuff. i work on gene expression evolution. my background before grad school was more biochemical, so to have any hope of hitting the ground at something like a really slow trot in grad school, python was pretty attractive.
It is not just you. In fact, that is one of the reasons we made web2py.
is this called "lazy evaluation" ?
&gt; ....you could double up on the lambda: &gt; adders = [(lambda k: (lambda x: x + k))(i) for i in range(0, 100)] wow hot damn ! 
It's no more difficult than installing apache + modphp from scratch. Most of what I mentioned can be installed with a package manager. I get what you're saying though. PHP is dead simple, especially when using a host that's already configured.
The reasoning is that i didn't knew about reactor.spanwnProcess() neither, Ampoule. luisito is my first, and very humble, approach to Twisted. And yes, you are right, reactor.spawnProcess may be the key to don't block when killing the processes. I will check Ampoule too. Thanks a lot for the feedback!!
Perhaps I should have started off with a statement of purpose. I view doctest a certain way, and others view it another way. The way I view doctest is, not as a testing tool on the level of unittest, but as a way to test documentation, or as a way to make documentation testable. All documentation includes examples, and doctest offers a way to test those. If we didn't have doctest, there would be no way at all, and our examples could get out of date without us ever knowing about it. So what I mean to say is that things like setup/teardown functions don't *make sense* in this context. That's for unit tests, not doctests. As for readability, if the examples aren't readable that's not really something doctest helped or hurt with. Does that make sense? Does it seem reasonable to develop doctest in this direction? I definitely want to move away from doctest as a first-class testing tool. That was the original author's intent, but he was weird. To me its purpose is to make documentation testable. I feel like if we can really make doctest a well written piece of software that works well on larger sets of input and does the Right Thing more often, then maybe more people would use it and our documentation can be easier to maintain. I really don't want people using it the way e.g. Django uses it, or the way Doctest itself uses itself (in its test suite). Doctest-based regression/unit tests are absolutely terrible, I agree. *It tests the repr of things, rather than for any concrete attributes/properties of them. This can lead to extremely brittle tests.* So to fix this, doctest needs to stop doing string comparisons. (In particular, it can try to eval first, before executing -- this keeps the object around). As I also mentioned, there's already support for doing literal-eval on both sides before comparing (this fixes the terrible dict repr issue everyone comes across). How does this plan sound? It's sort of incomplete in that there's still the possibility for string comparisons (and fragility), but this should at least avoid simple dumb repr comparisons completely. Also, FWIW shell tests suffer from no such fragility issues -- there are no objects, just strings, so that extension makes a lot of sense. *Static analysis tools can't see them, your editor can't highlight them.* I sort of feel like to a degree this falls under the complaint above, where I feel like you're treating doctests as an alternative to e.g. unittest. At the same time, it's a legitimate issue that they aren't highlighted or analyzed. In reST files they should be highlighted because python doctests (for good or ill) are part of the reST syntax. But editors don't really check embedded doctests for syntax errors. Perhaps that's OK? Or perhaps I could start submitting patches to the highlighting syntaxes of various popular editors to make this work. Static analysis is great, though. Probably doctests work alright covered by actually executing them as tests, so it shouldn't be a huge concern. 
Very interesting! I often rethink hosting python web sites because I'm afraid of them taking up memory.
I had good results with funkload http://funkload.nuxeo.org/
Not an expert here, but try adding a raw = pygame.image.load(image).convert() at the end of where you load your image. [Pygame Image load Docs](http://pygame.org/docs/ref/image.html#pygame.image.load) Which I am sure you have already seen.
sadly, if you feed the code to itself as the string, you do not get functional code :(
Thanks, I tried this right after I put up the post, though. It's a pretty frustrating problem, and I bet it's plainly obvious too.
Yes, in most cases it is. I find I struggle with something for days only to find I forgot a return statement or something. Why don't you upload the image and I will play around with it and see if I can figure it out?
Here's the [image](http://i.imgur.com/ZjdeS.jpg), real simple. Here's the entire[ source code](http://pastebin.com/gupLEFx9) for my project, but beware it's not cleaned out, and I'm a beginner.
Well it is going to take me some time to actually be able to play with this code, I am on 3.2. But I recall I had similar problems with the colorkeys, so this is what I ended up doing: image = pygame.image.load(image).convert() image.set_colorkey(self.image.get_at((0,0))) this will take the color of the pixel at 0,0 and set that as the colorkey for transparent, this will allow you to use whatever image you want with out really having to figure out what RGB color to set the colorkey to. Also I am a total novice myself, so this may not be the answer either.
Oh, sorry, shoulda mentioned, python2.6. I'll try your snippet in my code and let you know. Thanks so far. gah! no good. 
Also, the offending code is in class anything, method ScaledImages
How are you liking ep.io? I've been considering them lately. 
Probably because you mentioned "keylogger".
Thanks!. You are right, hosting python is not really great for some sites or applications (small to medium sized) as PHP is. Currently there are nice wsgi "cloud" services but i think the *real* solution will come from some sort of python interpreter sharing (copy on write, kernel hints from memory management, etc). Maybe it could be easily implemented on pypy.
Are you scaling your images?
It looks like you're setting colorkeys on the wrong surface. You set the colorkey on the surface you want to have transparent pixels, not the surface you end up drawing to. So I think you want to set the colorkey on raw.
&gt;to itself as the string, you do not get functional code :(
We use the continuous integration software, Hudson. http://hudson-ci.org/ Then we use fabric. We have different deploy methods in fabric that will build the server, set up nginx, uwsgi, and the pyramids app. We have hudson pull down the repo. Run the unit test. If those pass, it pushes it to a dev-stable branch and then fires another build on the dev server. It will then run integration tests and if and only if those pass then it pushs the code to the production branch. From there, we look things over on dev, then if all is well, which it should be if unit tests and integration passed, we will do the same thing for the production server. Fabric is the way to go though The nice thing with hudson is there are a lot of extensions for it. For example, we have a work irc channel that we all chat in since we are in remote locations and we have a hudson irc bot that will tell in the channel if the build is successful or failed. We also have hudson email users when builds fail. It also has an extension that checks for pylints and will report that back to you. 
Yay! Forced memes!
Driver: HP Color LaserJet 2600, 1.3.0.261 (color, 2-sided printing) Connection: dnssd://HP%20Color%20LaserJet%202600n.\_pdl-datastream.\_tcp.local./?bidi The Mac driver came directly from Apple via Software Update on 10.6 &amp; later; drivers for 10.5 &amp; earlier came from the [HP site](http://h20000.www2.hp.com/bizsupport/TechSupport/DriverDownload.jsp?prodNameId=446154&amp;lang=en&amp;cc=us&amp;taskId=135&amp;prodTypeId=18972&amp;prodSeriesId=446153). I guess you've already checked out http://hplipopensource.com/?
I was about to post something similar. Upvoted instead :].
 &gt; It tests the repr of things, rather than for any concrete attributes/properties of them. This can lead to extremely brittle tests. It tests what you want it to test. You can just as well write "&gt;&gt;&gt; foo.bar" to examine the property of an object. A lot of the time you control the result of repr() anyways, so it doesn't seem like a big deal to make __repr__ return what you need. Also, having __repr__ return useful data is good for debugging/logging purposes anyways. So, I don't see how this a knock against doctest. &gt; It doesn't work well with other testing practices (setup/teardown) I tend to write whole files for doing doctests and not just in docstrings. Since doctests, in general, are narrative in form, there isn't a whole lot of tearing down and setting up going on. Just once at the beginning and a little at the end. &gt; Any test that is remotely complicated becomes a pain to read (read: have even a single level of indentation). This is pretty subjective and depends on the writer. I would actually say that unittests are much harder to read in most cases. The doctest for checking the result of something is pretty straightforward: &gt;&gt;&gt; doSomething() 'I did it' vs. def testSomething(): self.assertEqual(doSomething(), 'I did it') &gt; Static analysis tools can't see them, your editor can't highlight them. The tooling can always be updated and there is already some support. There is an emacs doctest-mode that will execute the doctest, show you a diff of a failed test and give you the option of updating the failed doctest with the new output. I find this workflow to be incredibly efficient, especially compared to having to manually update the assert in a hand coded unittest. As for static analysis, it's trivial to strip the leading '&gt;&gt;&gt;' or '...' strings from the python lines and run the output through pylint. I have done this for my emacs setup so that errors are highlighted just as they are for regular python code. 
Yes, for now, from 16x16 to 160x160. 
I like the idea and have implemented something similar for work. I also added support for PowerShell and Sqlite. There is also support for automatically round-tripping variables between the sessions. For example: &gt;&gt;&gt; MSG = "Hello, World!" PS&gt; echo $MSG Hello, World! PS&gt; $REPLY = "Goodbye, World!" &gt;&gt;&gt; REPLY 'Goodbye, World!' SQL&gt; CREATE TABLE messages ( "value" text ); SQL&gt; INSERT INTO messages ("value") VALUES ($REPLY); SQL&gt; SELECT value as SQL_VALUE from messages; SQL_VALUE --------------- Goodbye, World! &gt;&gt;&gt; SQL_VALUE ['Goodbye, World!'] Support for shells is done in a client/server fashion, so you can run the doctest on a linux box and it will run the powershell code on a windows machine running a powershell script. 
Thank you, however I've tried doing that initially. Just for fun, I went through and toggled colorkey on all the surfaces in play, raw, ref and finally, screen. So long as raw and ref's colorkey is WHITE, I'm getting the mostly black image, instead of the image proper. Also, my understanding of colorkey is this: - load image to first surface - set colorkey(COLOR) to surface - create 2nd surface - blit firstSurface to secondSurface where all the COLOR pixels are treated as transparent.
I think that you're confused somewhere. Can you post a full bit of working code that the rest of us can run, as it's hard to tell exactly what you are doing when we can't actually see it. Try making a minimal example which exhibits the strange behavior you are seeing.
I think I must be. I posted the code in reply to sec_goat yesterday, [here it is](http://pastebin.com/gupLEFx9)! I appreciate the effort you guys are putting in.
Wow, frontpage! Thanks, guys! &gt; Thanks, guys!
to format for reddit, you must lead each line with 4 spaces, and have 1 extra space between each line.
Thanks for pointing that out. I guess it should be TypeError. Or a tuple of both. That's what you get for not checking code against the interpreter, I guess.
I don't thinks so, since it's more than just delayed execution.
the first 30% of the code should have been comments
 = int(round((0.3) * theStringLength)) firstSpace = theString.find(' ', WadsworthsAmount) if firstSpace == -1: FinalString = theString[WadsworthsAmount:] else: FinalString = theString[firstSpace+1:] print FinalString Alas, my only regret is that this will never run.
 $ wadsworth 'This is a simple program to calculate the last intelligible 70% of any string of text, also known as Wadsworths Constant' program to calculate the last intelligible 70% of any string of text, also known as Wadsworths Constant I'd say it works.
Dude, wait what? how do you scale an image? this is something I want to do but have not figured out yet.
My way which works well, is just to use the[ image.transform.scale\(\)](http://pygame.org/docs/ref/transform.html#pygame.transform.scale) which works really well! 
jeesum crow, it's amazing how many times I can read the Pygame documentation and still miss exactly what I am looking for, thanks!
Haha, I've been there quite a few times myself! Hopefully a genius will be able to point me in the right direction for my code too!
Too long! (lambda sys: (lambda str: sys.stdout.write(str[str.find(' ', int(0.3 * len(str)))+1:]+'\n') )(' '.join(sys.argv)) )(__import__('sys')) And in one line: (lambda s:(lambda r:s.stdout.write(r[r.find(' ', int(0.3 * len(r)))+1:]+'\n'))(' '.join(s.argv)))(__import__('sys')) [How to NEVER Use Lambdas](https://gist.github.com/1023982)
This is great. Anyone got a link to the original video that inspired this?
Why don't you use a frontend proxy to route part of you request to a django dev server ? You'll have to manage both the django's urlpatterns and the fe proxy server config but it's not that bad ...
It's pretty messy because 1. I wanted no dependencies and 2. Microsoft seems to change things a few times a year (this is pure screen scraping), but I use this all the time (nice for GeekTool) and I thought it might be useful to somebody!
Yes, this is a very simple game, but I'm trying to stumble through the basics right now. [Here](http://dl.dropbox.com/u/8069033/Reddit%20Collect%21.7z) is a dropbox link with all the resources so you can run it. Thanks!
Cool stuff.
Here is my solution: def wadsworth(s): return s[int(30*len(s)/100.+.5):] **Update:** I've made a pseudo-scientific blog post about it (see [here](http://ubuntuincident.wordpress.com/2011/10/02/the-wadsworth-constant/)).
You might be interested in [r/learnpython](http://www.reddit.com/r/learnpython) if you're starting out with Python.
Is the problem in pygame trying to load the font? You'd probably benefit by giving some more detailed information (like error messages and whatnot).
Why not use [mechanize](http://wwwsearch.sourceforge.net/mechanize/)?
I had it working once before, but I wanted to move the routine out of the main loop to make things easier on any expansion or changes I might want to make.
You've given a very vague problem with no detail. If you want somebody to invest time into trying to help you solve it, you need to at least invest in describing the issue better. What have you done to try to debug the issue? Can you change your code (e.g. by disabling features) and get it to a state where it works? If so, what's the minimal thing you need to do to make it crash? Which line of code does it crash on?
Three things: 1. If you're using os.path.join() you might as well use it for the full path i.e. os.path.join('data', 'images', name) 2. You forgot to flip the display. That's why your text doesn't show up. 3. And also you've pulled this code out of your game loop so you are no longer polling for key presses. It would make more sense to have a "switch" (python doesn't have a switch statement, use an if/else block or a dict dispatch) to call the appropriate code from inside the game loop.
I've only done a few things in Python, but does this call main() recursively?
At first I thought it was some sneakiness regarding whether a function refers to a non-local identifier directly, or via some kind of indirect lookup through the namespace. Then I suspected that the generator expression is implemented as two nested generators, and the outer one is evaluated immediately, where it obtains the reference to the current value of `units`, and the inner one doesn't lookup the name `tens` until `next()` is called. But this is simply [documented](http://docs.python.org/py3k/reference/expressions.html#generator-expressions) in the reference manual as a quirk of generators: The left-most iterable is evaluated immediately simply for improved error-reporting. The other iterables would be evaluated too except that they may rely on the first one, so this is not possible (while keeping generators lazy).
Start with getting valid input then get look for things you can divide into functions. Does your assignment spec not give you any hints on how to start?
3 is the key. The only reason you should ever exit the gameloop is when your game is actually exiting. Not for game over, not for anything. The most obvious consequence of what you're doing is that each time you "continue" you're actually starting up another main function from within the current main function. If someone keeps continuing and continuing and continuing, you will waste a lot of memory and run out of stack space, you can only recurse functions so deeply before the program crashes. Another problem is that you'll end up needing to duplicate a lot of code every time you want to make a new screen and eventually you'll miss something (like in this case, the event polling) and your code will just turn into a mess. I'd try making your game loop do something like this: while not quit_to_desktop: for event in pygame.event.get(): if event.type == pygame.QUIT: # QUIT quit_to_desktop = True # etc... if quit_to_desktop: continue elif splash_screen: show_splash() elif player.lives &gt; 0: play_game() elif player.lives == 0: show_gameover() else: assert False quit_to_desktop = True continue pygame.display.flip() clock.tick(60) pygame.quit() Obviously you don't need to use functions for each game mode if you don't want to, although it's probably a good plan.
Thanks for the help! I actually figured that first one out myself. Turns out I didn't know what I was doing. Did some reading and quickly fixed that one.
That helps a lot. I am trying to get the hang of the proper structure of the game loop and your example helps quite a bit.
Turns out that, yes, it does. That was unintentional.
I used mechanize+beautiful soup before but it was slow(er) and I wanted to remove dependencies. No doubt it would make things cleaner, but the overhead of all the extra parsing made it too slow for my taste.
I was sort of considering how various tests might share state. It seems a little too "magical" to do it implicitly like this, though. I don't suppose you'd want to publish the source code? I've been looking at doing execution of doctests across process boundaries. For example, it's the only way to run python 2 and python 3 doctests at once. Machine boundaries are cool too (although less exciting for me because I am not educated as to why this is awesome).
[It keeps saying I have 0 friends.](http://s3.amazonaws.com/kym-assets/entries/icons/original/000/003/619/Untitled-1.jpg?1288903617)
In my opinion it is not polite to use a standard library package name (with an added version number) for a project that is not blessed by the Python community at large. It may also cause some confusion for newcomers. Other packages I know that do that are unittest2 and distutils2, and both are backports of the functionality of python 3.x standard library modules to previous releases of python.
remands me of the time I tried to parse the xhtml with lxml and then found a simple json api.
I was learning Python. I'm just having problems using knowledge.
As far as scientific computing is concerned, there is no alternative to Python. Python is the do it all language. If I want to perform a statistical analysis, then model some data, and then come up with a gui and web platform to share with other users, you can only do this with Python.
People may also find that using Minecraft is way more intuitive than other methods.
&gt;The accretion of tools built upon tools. This is similar to my previous complaint. When I read about some clever Ruby library/utility that I might consider using, the installation instructions often refer to gem or rake or rmv or some other add-on. I appreciate that experienced, expert Rubyists can get a lot of leverage out of these tools, but they’re a barrier to entry for newcomers. Just like all, not just the clever Python stuff refer to `pip` (or `easy_install`) for installation instructions, and help you to `virtualenv`.
Doesn't seem like a problem with sqlalchemy to me. Can you paste the code somewheres? Looks like maybe Point() is getting redefined somewhere. 
I'm trying something like this: from sqlalchemy import * from sqlalchemy.orm import * from collections import namedtuple Point=namedtuple('Point',['x','y'],verbose=True) p=Point(3,4) db=create_engine('sqlite:///pointtest.db') metadata=MetaData() pointxy=Table('pointxy',metadata, Column('no',Integer,primary_key=True), Column('x',Integer), Column('y',Integer), sqlite_autoincrement=True) metadata.create_all(db) m=mapper(Point, pointxy) Session=sessionmaker(bind=db) session=Session() f=Point(3,4) The main idea is that I want a named collection of stuff that can be easily stored in a database. So the very pythonic: class Bunch: __init__ = lambda self, **kw: setattr(self, '__dict__', kw) is not going to work with sqlalchemy (I think). I can create a Bunch class but I won't know beforehand how many ints I want to store in my collection.. I will set it before I create my database. I hope I'm making sense.. 
Hmm, a reverse proxy in IIS that redirects the django path to the dev server on another port looks like a great idea, thanks for the input! 
Nice clipboard interface.
I don't know any for Mac either... try the guys at r/netsec they might be able to help you. Cheers
That is odd, lots of scientific computing does not involve python at all. edit: grammar
I have nothing against ruby, but I work in IT, not programming, so I just need a good scripting language. Ruby always seemed more like an actual programming language to me, I guess because it can be compiled. Even python kinda walks the line.
I think you're right. I did try to trick it round the init error, and got the same TypeError msg as you. I can create instances of Point (after the mapping) if I delete init, or use Point.__new__(Point,3,4) but I can't add them to the base, without getting Class '__main__.Point' is mapped, but this instance lacks instrumentation. This occurs when the instance is created before sqlalchemy.orm.mapper(__main__.Point) was called. so I'm guessing that has sth to do with init. Trying to use init with some instance of Point, directly results in the TypeError you described.. Thanks anyway for your answer. (the things you learn the hard way, you never forget) 
import whynot
So, how are you guys doing? When will we see a donation progress report? Need to know how hard we should rally.
I've heard it, and I disagree with it. Casting stones provides a framework for rapid improvement on both sides, so long as people are debating rather than arguing (in which case improvement seems unlikely in my experience.) To adopt the idea that criticism should only come from a source of perfection is to paralyze progress. In this spirit I welcome grammatical as well as typo corrections, so feel free to provide a positive contribution, secure in the knowledge that it will be considered with an open mind.
It could have been phrased better, but I think what Howardula meant is that no other language spans the range that Python does. You can do interactive exploration with R, but you wouldn't use it on a website backend. You can write calculations in C++, but you can't use it interactively. Python can go from exploration to scripts to more serious software. Historically, the limitation of Python has been execution speed. But using numpy removes a big bottleneck for scientific work, and tools like Cython and now Pypy improve the situation.
Here's a usage example with Django as context: http://bruno.im/2011/sep/29/streamline-your-django-workflow
His claim that 'you can only do this in python' is not correct. Most other languages span the range. I don't know what you mean by interactive exploration, if you mean with a terminal, then I do not think it is relevant for choosing a programming language. 
To test the primality of num, you only need to set your initial range as 2 .. sqrt(num). While it won't help with really huge numbers, for smallish values it'll speed it up no end.
sqlalchemy needs to attach attributes onto a mapped class, which include one for each column mapped, as well as an attribute `_sa_instance_state` for bookkeeping. It also, as someone mentioned, needs to create a weak reference to the object. So a SQLAlchemy-mapped class needs to be a "new style class", extending from `object`. If you look at how `namedtuple` works, it has quite a bit of trickery going on, not the least of which is that it sets `__slots__` to `()`. Then there's some super-nasty frame mutation stuff after that to somehow make it pickleable. That said it's straightforward to make your own class that is SQLAlchemy compatible and acts more or less the same as a namedtuple. Just define `__iter__`, `__len__`, `__repr__`, other methods as appropriate. Plus it will be pickleable without injecting variables into stack frames.
You have a fundamental misunderstanding of what the sieve does. The sieve filters out all non-prime numbers in a list so you are left with only prime numbers. Instead of starting from 1 and checking whether each integer is included in the list produced by the sieve, why not just print the list directly? Also, you should not modify a list while you're iterating through it (in generateSieve).
It's async, you can just have it running in a shell and look at it when you care. I was using it with nose which gives you quite a few options for how you slice and dice your tests. You can just change the command to point only to tests that you're working on (nosetests test/test_subset.py) or only run failing tests (nosetest --failure) both of these could cut down in the runing time enough to make it useful.
http://www.daniweb.com/software-development/python/code/217082
For *scientific computing*, interactive exploration is absolutely critical, because you often don't know what you want to do with some data before you start working with it. I couldn't imagine doing my work in a language without a good interactive mode. It doesn't have to be in a terminal - IPython has a rather nice HTML notebook in development. R also works interactively, as do proprietary tools like matlab.
For checking prime, I recommend the miller-rabin teszt: http://www.daniweb.com/software-development/python/code/216880/968739#post968739
This smells suspiciously like a homework problem.
What do you mean by interactive exploration? I was saying that the python prompt is not much of an excuse for choosing python over another programming language. Interactive exploration does not require a command line interpreter, and if it does there are better tools.
Suggestion: read from stdin if no words on the command line.
The Sieve of Eratosthenes can be intensely fast, but has a tendency to consume a lot of memory. For reasonable numbers, here is a breakdown of a fast implementation. -Create a list of integers from 0 to the MAX -Start with 2, set all list indices which are multiples of 2 to 0 --Find the next non-zero integer in the list, this is the next prime --Zero out the list indices which are multiples of the new prime -Repeat until you have reached the sqrt(MAX) + 1 -Now your list is all primes and 0s, remember to also zero out number 1
&gt;Interactive exploration does not require a command line interpreter, and if it does there are better tools. Err... yes it does. 
I enjoyed this solution; I'm still trying to get used to a python way of doing things and it's good to see examples like this. But this line I didn't understand: siv[2*i:n/i*i+1:i]=[0]*(n/i-1) Why :n/i*i+1: instead of just siv[2*n::i]? 
While the Sieve is frequently a homework problem, it's also a go-to problem when you're starting any number-theoretic computations in any language, and has some interesting real world applications for code optimization, and understanding basic concepts in coding. Which is to say, it's a great homework problem, but also a great *learning* problem.
No, you can write a program that is interactive, and explorative without using a command line interpreter.
You can copy a list like such: phrase = sys.argv[:] and if you don't want the first value you can do phrase = sys.argv[1:] Integer division is pretty useful for computing an index at a certain percentage: start = (len(phrase)*3)//10 and the similar to before we can use that to remove some elements from our list: print " ".join(phrase[start:]) Or in python3 (with read from stdin if there aren't args as per Lexarius' suggestion): #!/usr/bin/env python3 import sys phrase = sys.argv[1:] if len(phrase) == 0: phrase = sys.stdin.readline().strip().split() print(*phrase[(len(phrase)*3)//10:], sep=' ') 
Better suggestion: wrap it in a function so it can be reused.