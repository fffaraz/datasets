Hi! I just started coding a few weeks ago, I'm currently enrolled in two different courses at school -- and I am dying. Seriously - props to you guys for killin this cause this does not come easily to me (also my professor is shit) so I decided to turn to the internet in hopes of some help with these exercises, because I am so lost and trying not to totally fail. Any help, guidance, or anything would be SOOOOO appreciated 1.) Write a function called print word that takes two parameters. The first is for an integer (assume it will always be non-negative). The second is for a string. The function will print the given string the given number of times each time preceded by a count. See the examples below for the format of the output. 2.) Write a function called bacteria that will print out information showing the number of bacteria in a Petri dish at equal time intervals. The function takes two parameters. The first is an integer giving the number of minutes it takes for a bacterium to split into two new bacteria. The second is an integer giving the number of bacterial generations to include in the output. Assume you always begin with a single bacterium in the dish and every bacterium always splits into exactly two bacteria at the end of each time period.
Oh, I missed that &gt; I think VTK recently finished python3 support They have not; it's close, but not done. It's already been announced that the next release will **not** support Python 3.
a [PDF warning ] in the subject would have been nice...
It would be a lot simpler to skip Excel and PowerPoint and generate graphs using Bokeh, for example, that can be incorporated into a web-based report, perhaps using Tornado or Flask. Or is there some reason it needs to be a PowerPoint output?
I'm not 100% sure adding Excel charts to powerpoint will do what you want. However you can review the following article that shows how to create your powerpoint slides from python - http://pbpython.com/creating-powerpoint.html 
It's due to an ambiguity between integer literals and float literals: 1. -&gt; float 1 -&gt; int 1. anything translates to (float) anything, which is a syntax error. (1).anything, however, disambiguates. 1..anything -&gt; getattr(1.0, 'anything') And finally, 1 .anything is disambiguated from a float literal. Whitespace can disambiguate in a clash between literal and attribute access.
I think it is a carry over from ASM where it was needed for complicated logic.
I think there's a general consensus towards a new "secrets" module for generating random tokens, etc using SystemRandom. But last I checked there was still ongoing bikeshedding about what exactly it's going to provide.
I suggest cross posting your guides over in /r/learnpython and /r/learnprogramming. New programmers can use these a lot more than most in /r/python, I'm sure.
I'd rather not involve myself in their marketing methods. 
Really helpful, thanks a lot!
I use the Crayon Syntax Highlighter in Wordpress to get those code listings. Once you get the hang of it, it really produces some nice output. It also has nice highlighting features if you're doing updates to existing code and you want to show the reader where to slice and dice.
What about using [fluentd](http://www.fluentd.org) instead?
Welcome. Glad I could help. :D
Thanks! This is thing I want to learn.
Because the way most browsers react to PDFs is very different from how they react to ordinary web pages. To suddenly have a plugin activate and take over the browser, or to suddenly have a file download dialog pop up is startling. C.f. [Principle of Least Astonishment](https://en.wikipedia.org/wiki/Principle_of_least_astonishment)
Cython
Rad!
I don't know of a reference but a few things off the top of my head: Have standards about code style and use tools like pylint to enforce them. Unit testing is important to ensure that side effects are introduced. Have a continuous integration tool like Jenkins to run tests over the whole project and produce code coverage and pylint violation reports.
Having had a closer look at the package, it is listed as OS independant and as the PortAudio library (that sounddevice is essentially just a python wrapper for I think) works on Windows, I think it probably should work on Windows.
Thanks for pointing that out. I'll fix them.
So should this work by just going Run &gt; Run Module in Python Shell (Thing I'm editing with)? It seems to just be printing whatever's in the quotation marks. 
I highly recommend using [colorama](https://pypi.python.org/pypi/colorama). It's cross platform and is much easier to work with than using raw ANSI escape sequences.
Hm, alright. Thanks for your help anyway.
@karouh Could you try again on windows? I've made some changes and now i am expecting the script to run on windows too! :)
Why not use an n-gram approach?
Exciting! It'd be nice to see this come out and have full support for the new HDF5 SWMR features that should be available soon. I know h5py has the support, but without an unreleased version of HDF5 it doesn't yet work. This has been the main blocker for me using HDF5, whenever I'm working with data at a scale big enough to justify HDF5 I'm also trying to pull that data from multiple processes at once.
Like storing inverted list of 3-grams for our dictionary, pull the inverted list for all of the 3-grams of our query? There is several reason why I don't want to use this technique, the main one is probably that I don't know how it works in practise.
The world always needs more Dwarf Fortress.
I don't use Simulink (or anything like it) myself, but my understanding is that openmodelica is the closest, but it still has a long way to go. xcos, as I understand, it also has some similarity to Simulink. Both projects interface nicely with Python code. You will need to check whether either of these fit your specific requirements. openmodelica has code generation capabilities, but I don't know about xcos. That being said, you can interface Python with Simulink, both calling Simulink from Python and calling Python from Simulink. So you don't, strictly speaking, need an alternative. There are code generation tools for python, like PeachPy for Assembly. You can also write code very similar to python with Cython, which then gets compiled to C or C++ code. But Python itself isn't going to have a model-based design tool. That is outside the scope of the project. Python is a text-based programming language, like the MATLAB programming language proper. Mathworks bundles the Simulink graphical programming language with the MATLAB text-based programming language, but they are not the same thing, and Simulink can interface with other programming languages besides MATLAB. The Python project is much more strict about what it bundles together than Mathworks is.
[Details on PEP 495](https://www.python.org/dev/peps/pep-0495/)
Thanks man.
I'll second colorama, I have a little testing CLI and simply wanted to color 'Pass' in green and 'Fail' in red to have some quick visual cues. Works like a charm.
Hi there. You have posted a learning question to /r/python. These types of questions are far more suited to /r/learnpython, where users are actively interested in helping people to learn. Please resubmit it over there! Make sure to read their sidebar rules before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." Show them that you've tried to solve your problem and you can get all the help you need. Cheers &amp; best of luck!
I've been transitioning from SAS to python+pandas(+others) and longing for the analog of SAS's dataset. CSV is ok, but a binary store should be more space efficient, and, hopefully quicker I/O.
Maybe for your case is more simple just use string constants. Or look similar concepts: * [circuits](http://circuitsframework.com/) event; * dbus [signal](http://dbus.freedesktop.org/doc/dbus-python/doc/tutorial.html#emitting-signals-with-dbus-service-signal); * [my decorators](https://github.com/hugosenari/pydbusdecorator)
I have all of this so far. import sys __version__ = '0.0.0' # The minimum and maximum values allowed in this program. min_value = 2 max_value = 100 # A variable to store the converted input value. number = 0 # A variable to keep a running total. total = 0 # Gather the user's input from the console. user_input = input( 'Enter a number between {} and {}: '.format( min_value, max_value ) ) ############################################################################# # YOUR CODE STARTS BELOW THIS COMMENT ############################################################################# if user_input.isdigit(): pass else: print ("That is an invalid response. Please Restart.") ############################################################################# # YOUR CODE STOPS ABOVE THIS COMMENT ############################################################################# # Display the results of the program. print( 'The sum of all integers between 1 and {} is {}.'.format( number, total ) ) Most of it was provided
Have you looked at [bcolz](http://bcolz.blosc.org/intro.html)? &gt; bcolz provides columnar, chunked data containers that can be compressed either in-memory and on-disk. Column storage allows for efficiently querying tables, as well as for cheap column addition and removal. It is based on NumPy, and uses it as the standard data container to communicate with bcolz objects, but it also comes with support for import/export facilities to/from HDF5/PyTables tables and pandas dataframes.
looks like missing the [KISS principle](https://en.wikipedia.org/wiki/KISS_principle)
There are rubicon-java library, which based on ctypes and small jni wrapper https://github.com/pybee/rubicon-java/ But it has no multithreading support.
"Unit testing is important to ensure that side effects **are** introduced." that's always been my experience too ;)
I'm a little confused by the examples. The bot doesn't seem to summarize the conversation so much as it returns something completely different and make it not about 'your mom'. Am I missing something? 
what did he mean?
ah, thanks!
How long do you guys think it will be until the official version 1.10 comes out?
ML, data analysis, security (my field, and I use it extensively), finance, mathematics, general automation, sys admin, devops, etc......
another noob question. Since Python is limited by speed (I mean it's slower than Java), is it still used in Machine Learning Industry? or performance is not a factor here? Also, I know that python is heavily used in academia, but I wanted to know where it's used in industry edit: typo fix, lower -&gt; slower
One common mistake with IDLE is that the window that IDLE first opens is not actually an editor window; it is a Python console. After first opening IDLE, click on "File-&gt;New File". Try typing your code into the new window, and then clicking on "Run-&gt;Run Module" in the new File/Window.
Those are all fields that exist in industry. And yes, it is certainly used for machine learning. Python is a favorite across all fields of industry.
Python is generally used as a "glue" language that makes it easier to work with high-performance tools written in languages like C, C++, or Fortran. So when you write something in Python, the heavy number-crunching is usually being done using a library written in a language like C behind-the-scenes.
thanks you for the response
Can you write somthing more about security and python? 
On top of what other have said already, it's used in a broad range of scientific analysis related fields, mathematics (https://www.youtube.com/watch?v=HfvQ6O7Di0g), chemical engineering (https://www.youtube.com/watch?v=IsSMs-4GlT8), computational neroscience (https://www.youtube.com/watch?v=mvBhrgwo4TI), gaming industry (https://www.youtube.com/watch?v=A0nTEbsQRTE), robotics (there's a lot of videos on this one), and internally at various enterprises for other system automation jobs... Edit: I've used it in finance and generic e commerce related warehouse/inventory management type software...
I didn't even notice that. I read "slower", lol.
&gt; This means that there's a high degree of internal method dispatching that keeps the language flexible and conceptually high-level but is also, in my understanding, largely responsible for the speed differences. The speed differences are ore due to using fixed-width arrays in memory. Modern processors have high-performance instruction sets designed to do operations on such arrays in an extremely efficient manner, and there are libraries built to take advantage of these capabilities. numpy, in turn, uses these libraries. Operations on numpy scalars, for example, are actually slower than operations on built-in Python data types. &gt; Numpy is actually a combination of Python, C, and Fortran which is especially optimized for numeric processing. If you want to get technical, Numpy only uses Python and C. Scipy also uses Fortran, but there was a specific decision to avoid any Fortran dependencies in Numpy since Fortran compilers are harder to find than C ones. This is why some operations are faster in Scipy than Numpy, the Fortran versions are faster.
I use Python nearly 40 (50..60..) hours a week working in Geographic Information Systems/Data Science.
Yes, Python is slower than Java but the not all machine learning experts are programming experts. So Python is an easy to learn language with powerful libraries which allows the machine learning guys to implement new algorithms in shorter times. In general an hour of computation is much cheaper than an hour of development. Also most of the times it is much cheaper to buy more or faster hardware than invest many hours of debugging or performance tweaking. If the new approach (implemented in Python) gains you very good results, the company may translate it into a "faster" language. 
You do not need to understand object oriented programming to making use of test classes. They are a way of organizing code and they allow a granularity between module and function. This episode covers some of the confusion around using test classes, and a few benefits of using classes.
Honestly I don't know. But it definitely [doesn't need Fortran now](http://www.scipy.org/scipylib/faq.html#why-both-numpy-linalg-and-scipy-linalg-what-s-the-difference): &gt; One of the design goals of NumPy was to make it buildable without a Fortran compiler, and if you donâ€™t have LAPACK available NumPy will use its own implementation. SciPy requires a Fortran compiler to be built, and heavily depends on wrapped Fortran code.
Many operating systems include Python as a standard component; the language ships with most Linux distributions, AmigaOS 4, FreeBSD, NetBSD, OpenBSD and OS X, and can be used from the terminal. A number of Linux distributions use installers written in Python: Ubuntu uses the Ubiquity installer, while Red Hat Linux and Fedora use the Anaconda installer. Gentoo Linux uses Python in its package management system, Portage. Python has also seen extensive use in the information security industry, including in exploit development. Most of the Sugar software for the One Laptop per Child XO, now developed at Sugar Labs, is written in Python. The Raspberry Pi single-board computer project has adopted Python as its principal user-programming language. Source: https://en.wikipedia.org/wiki/Python_(programming_language) I'm amazed that Python is used in Security Industry, It means that Python is suitable for computer hacking, even Python is lacking from speed and real hardware manipulation like you do in C and C++
Just saw this. I'd recommend you make a brand new post is /r/learnpython, because experienced people might not check this stickied post now that it's several days old. ALSO, when you ask you question again, be sure to include what you've done so far! That lets people see what concepts you understand or don't understand, so they can offer helpful advice. People are very unlikely to do anything for you if you just post the question; the only thing the could do in that case is give you the answer, which is a waste of time (both theirs and yours).
INCLUDE A DESCRIPTION
Oh my gosh, I think you're onto something!! I will see if this works and report back this afternoon.
system administration 
Mozilla develops buildbot, written in python, to run test campaigns against farms of hardware (phones). It's like a concurrent to jenkins. It is used by other big firms too.
Exploit prototyping, network sniffing, some proprietary stuff I can't mention... What exactly are you curious about?
I'm not too familiar with PyTables, but I've been using HDF5 since I realized it was a great format interoperable with Matlab and R, that doesn't require me converting my floating point numbers to and from ASCII, and allows storage of metadata. It's really fantastic. Can't recommend it enough.
Generally I check to see if they actually know Python in the vaguest sense by printing out a very simple python program (like a hello world that uses a function to count from 10) and asking them to mentally step me through what happens when they run it. No trickery or gotchya's. Maybe 20 lines at most. A lot of people lie on resumes and I just want to weed those fuckers out. If you don't know python functions are created using def then.... well... you can only google your way out of a paper bag if you know it's a paper bag.
We're using python to create an extensible ERP framework. Some people are using this framework to build an hospital information system (http://health.gnu.org/)
excellent stuff... does anyone can think of a use case in web development except the API example in the docs?
Here's a good Python-specific question. Let's say you want to calculate the millionth power of numbers. You could write a function like def pow(n): answer = 1 for i in range(1000000): answer *= n return answer One of the problems with this snippet is that the expression `range(1000000)` takes up a lot of memory (and it takes time to allocate all that memory). How can you avoid this problem?
Dropbox uses it for desktop software, though I don't know of any other examples in industry (there's plenty of open source examples).
I've been working in the Game Industry for a couple years in multiple companies, we use Python to make web-services consume by the games.
np :)
Can you give a quick summary of the main differences? The github says that it doesn't create the extra .so .c and .py files to clutter up the working dir. Is that all? (that IS useful, don't get me wrong)
Visual Effects. I work for a large animation production studio and I program almost exclusively in Python.
So you don't have to give your name/email address for marketing: http://www.oreilly.com/programming/free/files/python-for-scientists.pdf
As a huge fan of h5py, this is great news! PyTables had a few extra data types that have always seemed useful, but not enough for me to move to it. With this refactor, it seems likely that those datatypes will end up in h5py directly. Sweet!
Python is an awesome language to programmatically test tools/products written in other languages. It's the QA language.
If you're worried about data-type integrity, get comfortable with `collections.namedtuple` (and its `typing` module equivalent in 3.5). 
Can I ask how you got into the field? Did you get a graduate degree? I'll be graduating with a computational physics bachelors and I'm trying to think about how I can leverage that into some kind of industry.
UTC still has leap seconds, doesn't it? 
It's used a lot at Disney for their animation pipeline, gluing their C code together.
It does it by adding an extra second at midnight, by having a 23:59:60 second. There is never a duplicate time. 
Geospatial stuff is relatively easy in python. Might be better to say that is has some nice modern libraries for geospatial analysis, the quality of the GIS work is up to you! Do some kind of analysis where you figure out how many people in location X are doing Y and then create a shapefile. Plot it with some of nice python GIS libraries and voila. Really a typical GIS/Data Science python person (which is my job pretty much) needs to be handy with python but more of just programming in general. You will be using cloud systems (potentially) which requires networkign knowledge, database systems usually come into play, distributed systems so you can crunch 1000x times more data. You end up becoming a jack of all trades!
Could you recommend a read or two on exploit prototyping with Python?
Scientific computing. It's great as a nearly drop-in replacement for matlab.
The other replies to this comment have coveredeverything I would say, I just want to also plug [numba](http://numba.pydata.org/) as an example of how python can see some performance improvments. I had some heavy methods being called from a script's innermost loop, and with numba time per iteration went from 80 ms down to about 4 ms, iirc.
&gt; Python is limited by speed (I mean it's slower than Java), is it still used in Machine Learning Industry? or performance is not a factor here? For a lot of compute problems, runtime is such a small part of the total time taken. Total time taken = time humans take to write the code + run time. For example: Both in academia and in industry, I've had to use clusters of machines. Basically, we write some code and submit hundreds (sometimes thousands) of compute tasks to run on a few dozen, or over a hundred, machines in parallel. The slowest part of the whole process is unfortunately, us, the humans who write code. Maybe it takes Python code minutes to analyze gigabytes or terabytes of data when running on a cluster. But the reality is that it probably would take you a day or more to write the code anyway. Runtime is such a small part of the total time taken - so write in the language that minimizes human development time.
I second this, id love to read up on this. 
I get emailed job listings for pretty all of this, with python as a desired or required skill
I've got Gray Hat Python and Violent Python, both good reads. There's also Black Hat Python, which I don't own. 
If I understand this correctly, the problem is that datetime instances can map to two different UTC times. That is the ambiguity that the PEP would solve.
You never need more than 2
Mechanical engineer checking in. Use it every day for data analysis.
And in visual effects in general. Most of the major software packages (Maya, Houdini, etc) have python interfaces.
I work for an Software Company and most of our security code code base is in Python. A lot of open source work these days is also python 
&gt;"How do you determine when Python is not the right tool for a given problem?" As a learner, how does one figure out the answer to this question?
I did, somewhat, through experience and reading. Surrounded by people smarter than myself, I also ask lots of questions. I still don't have all the answers and it's something one never stops learning. The very quick gist of what I've learned so far: 0: Python is quick to write, easy to debug, and very easy to read and share (if written properly). So I find myself wanting to use it first unless I find a reason not to. Admittedly, I also suck at Java, C++, etc. so that probably encourages me to find a Pythonic solution unless it's absolutely the wrong choice. Then it's not me writing it or I'm getting the opportunity to get better with another language. But I will never allow a bad solution to be implemented because I'm most comfortable doing it in Python. 1: Python can be VERY slow in some contexts compared to other languages such as C++. I had one case where it was 100x slower than the equivalent C++ solution for capturing messages on a TCP stream, processing them, and re-publishing them. The challenge is knowing when performance matters. Don't obsess over making things fast, but know when they need to be. This means getting cozy with performance analysis tools and having a general understanding of what kinds of processes are very slow/complex. 2: Python has parallelization and threading capabilities but you'll find yourself fighting with it to do embarrassingly parallel work. I avoid it for things that can be significantly parallelized. But there's still lots for me to learn! I suspect there will always be things that simply shouldn't be Python, but that list might shrink a little. 
I think you should consider re-phrasing the question, based on the answers you gave. "For what cases is Python not a good fit?" You can also invert it and say: "For what cases is Python a good fit?" If you would have asked me "How do you determine..." I would have started talking about looking at the project requirements, as that is *how* you begin evaluating whether it is the right tool for the job.
I've used it for data integration, networking, and general mundane tasks. Python earns its keep on the web, but it's so dang awesome because there's a library for EVERYTHING.
Very true. How do you know? Determining if you're going to need to do a lot of one of the things Python isn't good at. How do you do that? That's the useful question but I'm going to be really cheap and apologize. Not about to try to answer that on a phone. :) On that note, it is definitely time to get some sleep...
Why *"suffering"*? Pyshp, Fiona, Rasterio, GDAL/OGR are just some of the high quality libraries I use when I do my GIS scripting. I produce complete workflows by using IPython Notebook (Jupyter) that is reproducible and platform independant. My desktop is Linux, my laptop is Mac OS X and my collegues uses windows. Python itself, which is the defacto GIS programming language is open source. Really? Since when is using open source tools, suffering? Granted, I have never used Arcpy in my life. But why would I want to?
Most of OpenStack is Python.
Good idea, it's just a package to easily get a list of active proxies. They are also available as dictionary format compatible with requests, so you can just do for proxy in checkerp.proxies_requests_form: requests.get("http://example.com", proxies = proxy) Checkerproxy usually returns around 1400 proxies
The backend for Dropbox and YouTube are both written in predominantly Python.
I'm using it on a telecom company for modeling one of our products that we are selling to mobile network operators. In that way we can estimate the amount of hardware that's needed given a customer's number of users in a certain region.
It seems to me that Python has displaced Perl all over the place. Once upon a time Perl was the hot language for system administration and web apps. It's still around, but usually in legacy form. 
I use it to automate some sys admin tasks. Used to use Perl at a previous job but for the last 5 years it has been Python only.
&gt; There's also Black Hat Python, which I don't own. \*wink\* \*wink\*?
You can't execute javascript from python. You need to figure out what the script does and emulate it from python.
How do you write statically typed python? Using comments in variables and type annotations? Yes python does have more powerful interfaces in that sense and it also has abstract classes.
QA here, I used python to build testing automation that would get integrated into my company's release CI for our product's map reduce features built using our python API. 
Our QA team uses it with the help of some test framework to write automated tests for our java application.
to start with, sqlmap. 
Pure python is slow, but in reality it's not. There are tons non-Python components in Python
Torvalds made an edit of the code? Hah.
Check out pwntools to see how the general infosec community uses python in various ways for CTFs and in general. https://github.com/Gallopsled/pwntools 
I think you are looking for Python - PEP 8. I recommend you re-read the PEP 8 and some of blog of Guido in his blog-site. Don't forget the zen of Python. import this The zen of Python will help/guide you a lot in creating large projects and its good programming practices for everyone. 
The company I work for uses python for testing embedded systems. We also use it for general automation tasks like pulling together data for verification reports and any data processing tasks that pop up.
Also check maxinet.
Actually, can you advise some geospatial libraries for python? I'm using shapely in my little projects now and it lacks some functionalty. 
`help()` starts and interactive help session, or you can just do `help(print)` to see the help for print, for example.
There is no actual competition, R for fast small-scale data analysis and prototyping, Java and C/C++ are for hardcore production algorithms (after prototype is ready), and Python to be jack of all trades from data preparation/testing/prototyping/analysis to temporary production. Anyway, R cannot into production and it's too time-consuming to prototype in Java.
Please indent four spaces to get the code properly formatted.
It's available from version 3.4 only.
I'll give it a try thanks!
Or bpython
Python is big the Scientific Computing community. Check out the various [SciPy Conferences](http://conference.scipy.org/)
QA &amp; Testing - used Python in projects ranging from acceptance for huge telecom, to prototyping for aerospace-defence company. Python is just but a tool, the skills that land you the job are not about what language you use, but about what kind of problems can you solve.
use fabric
Embedded. We're big on python on medium-sized Embedded devices. [Embedded Python in Practice](https://www.modio.se/presentations/Embedded_Python_in_Practice.pdf)
I've worked ~6 years for a telco that uses Python for everything (call routing, billing, sms routing, reporting, ...) that doesn't have to run on the CISCOs (and that, sadly, is written in TCL). Said telco has been around for ~15 years now.
arcGIS and arcpy are gross, get away! look into open source python GIS... shapely, fiona, GDAL, rasterio.. and you can use qgis it's free unlike arc
Yeah, to add to this Cython makes writing C extensions very simple and scipy/numpy provide a lot of really nice packages for importing fortran code. There is a lot of overhead compared to C, but the speed of development more than makes up for it.
I believe you are correct.
Use an IDE. If autocomplete surprised you, pycharm would blow your mind. 
Me too! I work on a (200 workers) 3D animation studio. Python is everywhere, backend stuff, render farm, etc. Maya, Nuke, Houdini and a lot of CGI software is programable on Python. 
https://cos.io/ https://www.sciencelogic.com/
Awesome. Those RS specific libraries are a mess; i was able to write script for updating DNS the way I need it very quickly. Sadly the Rackspace Cloud is currently behind -- when I create servers there, I need to create it with "cloud block storage" as root drive rather than "local storage" so I can move the data to another instance quickly (Rackspace Cloud serves tend to die, RS tells us the are working on it and then so 20% of the time the server disappears WITH any local storage).
And is very strange at all. primes(100) returns 25, 35, 55, 65, 77, 85 and 95 between others, which is not prime numbers....
Thanks a lot.
Life changing moment in 3... 2... 1...
There is something weird going on here. statsmodels is on the list, but pandas and patsy aren't. However, statsmodels requires both pandas and patsy.
Its not really a language in the same sense though. Programming is more of a science than a language. 
Yeah, it was weird. It includes stuff like numpy and matplotlib, but also random obscure stuff with less than a hundred downloads. I don't get what criteria they are using for "top".
I use it and C++ in ROS daily for robotics research
I would say programming is more like an art, but different strokes fo' diff'rent folks, yo.
And people thought it was surprising Harry spoke parse.
It's the scripting language for a whole lot of industry tools. Maya, Nuke, Blender, etc.
I'll take a look, cheers!
saperlipopette !
I see you're working on the opening paragraph of your book 2084. You rabble-rouser.
Math in Python but overlooks SageMath?
am I missing something here in your example code? # accum.pyx cdef int i, n, accum accum = 0 n = 10**4 for i in range(n): accum += i print i then runcython accum.pyx prints out 49995000 ? why would this not print 9999
Once I have something working to my satisfaction that does some computation for me as part of an analysis, I save it in a .py file and import it within an ipython notebook. This helps remove some excess code clutter. Before I get to that step I might have an ipython notebook dedicated to tweaking whatever computation I am trying to do. 
Useless comparison. 
The entire premise of the talk is flawed. Stallman explicitly states that you don't need to be able to program to participate. He also explicitly states that all programs should be open source, and that releasing a proprietary program requiring someone who *isn't* a programmer to pay is a social injustice. The upshot of this is that all software devs should work for free at the whims of people who don't understand or value their work, and that somehow by virtue of being a dev charging for your labor becomes a social injustice.
ohlala.omelette.du("fromage")
While this isn't a good comparison, it is a good sign. I think it is amazing how we are starting to teach kids how to program at a young age. 
So it was impossible to tell which one of the two a datetime object refers to before this change? Interesting.
There are a couple of projects that do. http://www.scicos.org/ actually has a code generator. As already mentioned there is xcos from scilab. https://www.polarsys.org/ another one. Scade is another one http://www.irisa.fr/espresso/Polychrony/ another one based on SIGNAL language For code generators there are: http://www.e4coder.com/ scilab and scicoslab. http://forge.scilab.org/index.php/p/geneauto-p/ xcos which should be able to use gene-auto which is a open-source code generator. There is a lot out there: https://en.wikipedia.org/wiki/Model-driven_engineering Also when you are looking for something to compete with Simulink, in what area of Simulink? Simulink can do a lot of things, some good and some total crap. 
I have nothing to add, in terms of the direction you've chosen. So feel free to ignore this comment. If it is a larger codebase or whatnot (doesn't sound like it, but whatever), do be aware that logging's handler system would be a great central place to make changes https://docs.python.org/3.5/library/logging.handlers.html / https://docs.python.org/3.5/library/logging.html#handler-objects. It'd also remove any issues about writing abstraction (as in, just need to link the logging api, and the other chosen api), result in minimal edits to the codebase, and will also be portable (no hard linking to any one messaging backend)
I'm interested - what do others do better? I know you have to switch on type inference, and it suggests all the private members of classes which is annoying. 
Which would be slightly more logical anyways, considering that apples and oranges are very comparable fruits. I always say comparing apples and airplanes. 
If you want to play this game, shouldn't math be the most popular?
You might be interested in the open source [data science masters] (http://datasciencemasters.org/) that indexes a lot of resources to complete an entire program of masters level data science, coding, stats, machine learning, and data visualization courses online.
Well, doing science is also an art, in pretty much the same sense as programming is an art. Science isn't writing down a problem and then solving it step by step using algebra. Research in science involves a LOT of intuition to come up with hypotheses, and then designing experiments to prove them. 
(OP and author) I've been using it for absolutely years to validate that incoming API calls (JSON over HTTP for example) are well-formed. This means you can then safely navigate the incoming JSON, knowing that it has the keys and types you expect, allowing your code to focus on business rules checks and avoid most of the validation clutter! I think the more recent direction Python annotation checking syntax has taken (PEP 484 blessing MyPy basically) is kinda sad and much less readable :|
In functionality terms, to autocomplete accross multiple codebases they both need to be in the same pycharm project or installed into the virtualenv and pycharm configured to know about that virtualenv. That is, pycharm doesn't honor the environment PYTHONPATH, it looks only in places you have whitelisted (in essence). I would rather prefer it looked for anything in pythonpath and tried to autocomplete at least memebers using that. But in terms of interaction * argument completion popus do not stay around when entering and exiting focus of the function, they disappear to easily and you either need to wait for them to appear, or hit ctrl+p * the documentation popup (ctrl+q) isn't very nice * it only understands rst docs, not the style preferred by scikits/numpy that's all I can think of now. It's hard to convey they subtle differences in how completion works by text alone, you really have to look at how other editors do it, how focus handling works in those, and how pycharm differs.
Question -- are most of these science-related/data-related Python usage cases done by people with an appropriate background (ie, science, math, stats, high-level CS) who pick up and use python (ie, programming is a secondary skillset), or are they by people from more traditional software engineering/hacking backgrounds who have dedicated roles to help the guys/gals that have the appropriate domain-specific knowledge? Thanks.
Why not both? I started fiddling with BASIC back in the day, before I learned French. French was my strongest subject in school. I now work in the IT field and program in Python as well as other languages. I can't say that my programming career has really turned out well, and I haven't done anything useful with my knowledge of French other than answer questions from beginner/intermediate French students online for free. So maybe the answer should be, neither.
plus, (when I last checked at least) the python ncurses interface is a little different from the C ncurses interface in a few regards. So while the end result might be the same, the code underneath would be slightly different
Sacrebleu!
I looked at that briefly and it doesn't look like it's been updated/maintained in quite a long time...
Wasn't this or something like this already at the top of the page recently?
What hasn't turned out well in terms of your programming career?
As it should be
And Pixar, and Industrial Light &amp; Magic.
I knew that Maya and Blender have Python APIs, but didn't know about the rest (or how popular it is in the industry). Makes sense. Thanks!
Apples fall and go splat, and airplanes fall and go splat. Seems pretty similar to me.
 if youcanreadthis is True: ____print("Python IS a fucking language.") else: ____print("Whoops! Sorry bud, looks like I was wrong, there!")
Inching closer and closer to the future as shown in Transmetropolitan...
I would say programming is a craft, I find both science and art as presumptous definitions
 import meme meme.why_not_zoidberg()
Most of what you wrote is actually English.
But *all* of what I wrote was Python! 
or cartoon network
What do your import statements look like?
You nested a language inside another language. What you said is like saying all of what you wrote is HTML after embedding JavaScript and CSS in a web page. It's not HTML. It's just able to be placed in HTML. Same applies here. English is not Python. It can just be placed in Python.
Similar to how you nested "annoying asshole" into "English" Oh god. I can't just post that. I'm sorry in advance. It's all a joke. I'm joking everywhere, all the time. Love ya &lt;3
&gt; only with local time You are correct, this can only happen with local time and not UTC. The PEP is all about dealing with ambiguities in local time. &gt; I still don't understand what this solves I think you do, but if you are still unsure, take a look at [PEP 495](https://www.python.org/dev/peps/pep-0495/) itself. It is very readable, I hardly know anything about date and time and was able to grasp the gist of it.
yes
20/20
Exactly! In python I can just type: import croissant PS. I also sampled everything in the medicine cabinet for comparison.
This list is fishy. At least as of me writing this, the number one is NumPy at 494,214 and the number 11 is mplstyler at 77. That means that the smallest to the largest represents a 641,736% difference.
/r/learnpython
Look harder? Failing that tell us exactly what you've done to install Python, how you're trying to find it, what you expected to happen, and what actually happened. There are some very smart people in the Python community, but to my knowledge none of us are mind readers :-)
French doesn't compile to an executable either, so it's not a wholly unfair comparison. 
Im so sorry, It looks that I am probably dumb as a brick, since I looked in some folders and saw idle but I thought it would be another extension .exe or something. So when I saw a .py I didnt open it. Turns out IDLE is like an extension to python and not another program with compatibility. Sorry for the useless post :P Since I am starting to learn python in university I will be visiting this sub often haha
Hi there. You have posted a learning question to /r/python. These types of questions are far more suited to /r/learnpython, where users are actively interested in helping people to learn. Please resubmit it over there! Make sure to read their sidebar rules before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." Show them that you've tried to solve your problem and you can get all the help you need. Cheers &amp; best of luck!
you're on a list now
And damn do I make that list look sexy.
Please don't feel bad about it. The only person who never made a mistake never did anything :-)
FYI, I posted this not because I agree with it (for example, it seems like with not using `asyncio` he's kind of fighting the system), but because I don't know too much about the new async/await and I thought it'd be good to get some constructive commentary here.
asyncio doesn't provide any nio abstractions for files because (a) it's not really needed, and (b) there is no consistent way to implement it (a) -- basically you shouldn't expect your code to block on disk io. But even if it does for a short amount of time it's probably fine -- look at this pic https://pbs.twimg.com/media/COLLg0TUAAA4j79.jpg (b) -- one way to implement nio for files is to use a threadpool. Maybe we'll add this in later versions of asyncio, but it will require to write some pretty low level code in C. Another option is to use modern APIs like aio in linux, but as far as I know almost nobody uses them for real. Bottom line -- you don't need async/await to do file io.
Like the article, but author haphazardly posted without polishing. Instance variables and standalone functions? Come - Come now.
Here's some code to get you started. It'll get the names of all the repositories for the first 10 pages of the sourceforge directory from requests import get from bs4 import BeautifulSoup base = 'http://sourceforge.net/directory/?page={}' results = [] for i in range(1, 10): r = get(base.format(i)) soup = BeautifulSoup(r.text, 'html.parser') results += soup.find_all('span', {'itemprop': 'name'}) for result in results: print(''.join(result.contents))
&gt;you don't need async/await to do file io. I'm confused, didn't you just demonstrate how slow file I/O is (assuming a rotational disk) and why you *would* want to use async? Doesn't its omission from asyncio automatically mean that any asyncio app will get bogged down the second it does file I/O?
Does that mean Python has become the newbie test to filter out the newbie programmers?
Although you *can* use `is` to test for equality against literals/keywords, you shouldn't
You can't exclude borrowed language to distinguish something as a language, all of the major languages of the world are full of borrowed sentences
Comparing cars and carpets. Comparing Java and JavaScript
Why don't you use one of the many integration methods available in scipy?
 if claim == True: print("Sacre bleu!") else: print("Well, maybe someday at least.")
Is it for work, academic or hobby? If it is for work I would go Simulink route with a paid for code generator or mod a open source one. Or if you want to just get something done quickly. But it does have it draw backs the Language of Simulink is not really defined openly, there have been papers that attempted to reverse engineer it to define what it does. If this academic or hobby, I might go an opensource route, one it is cheaper, standards are open so a lot more hacking can happen. It is usually worth at least trying out some of the other modeling tools to see if any can function for what you want. 
 if x is None: ... *is* the proper way test for NoneType
I've matched up all the pieces right up to the integration, yes. Everything is well up to the creation of the integrand (verified by checking the integrand for given om against Mathematica), but once the integral is computed, it comes out with that strange number.
Not curses, but if that's got you cursing, try the [python prompt toolkit](https://github.com/jonathanslenders/python-prompt-toolkit)
When I was in school, French was shown, but rarely taught. I suspect that it will be the same with CS taught in our public schools.
Don't integrate to infinity
I live by the open source stuff. Though GDAL is so so much slower than Boost Geometry. :( I just found esri software to be just such a complete set of tools. I'm exaggerating though. It's not suffering. 
Oh, nevermind. I heard it had died after the iPython notebook came out.
that was funny, good job
but why does it say print i as opposed to print accum 
I kept waiting to read the punchline and then got to the end and realized this was supposed to be a serious article. :-(
Will there ever be something like asyncio that doesn't require an event loop? I want to be able to do this in core Python (CPython): x = some_long_running_method() # no blocking y = some_short_running_method() # maybe this blocks. . . if x.done(): # or wait, etc. print 'hooray' 
There are a couple of places where file io might not be as fast as the link you shared -- e.g. if the block device is shared over the network (like AWS EBS or Google's PersistentDisk). NFS is another example of this. A good use for aio in linux might be to write out incoming network data (at multiple Gbps) to disk. Under linux, there are two AIO apis, one of them uses threads and just provides async semantics, and another does true asyncio.
&gt;If you are about to ask a question, please consider r/learnpython. Homework-style questions will be removed, and you'll be encouraged to post there instead.
 # tellerMachine.py # Jiamin Li # 09-24-15 #userinput amount = abs((eval(input("Please enter amount to withdraw: ")))) print () print("Withdrawal amount: ", amount) #convert amount to 20s, 10s, 5s, 1s, quarters, dimes, nickels and cents. no20s = amount // 20 amount = amount % 20 no10s = amount // 10 amount = amount % 10 no5s = amount // 5 amount = amount % 5 no1s = amount // 1 amount = amount % 1 noquarters = amount // (0.25) amount = amount % (0.25) nodimes = amount // (0.10) amount = amount % (0.10) nonickels = amount // (0.05) amount = amount % (0.05) nocents = amount // (0.01) amount = amount % (0.01) #format and display def main(): print("Please lift your keyboard and find: ") print(no20s, "$20-bill(s)") print(no10s, "$10-bill(s)") print(no5s, "$5-bill(s)") print(no1s, "$1-bill(s)") print(noquarters, "quarter(s)") print(nodimes, "dime(s)") print(nonickels, "nickel(s)") print(nocents, "cent(s)") main()
Look at concurrent.futures
&gt; Doesn't its omission from asyncio automatically mean that any asyncio app will get bogged down the second it does file I/O? Ideally asyncio should have it, but most people don't need it.
Have you checked the integrand function in the portion of the integration range where it has the largest (absolute) values? If this region is very localized it might get under-sampled... You might also plot the integrand in both Python and Mathematica to make sure they look the same everywhere. (You might also look at log-scale plots too to make sure small values are matching up ok.) 
Yup. Good for when data and functions are inseparable. Ironically my node server could scale a lot easier if I had used objects. Right now there are a hand full of variables that needed to be outside of closures. They are a big headache now that I want concurrent sessions. 
You probably should be visiting /r/learnpython then.
Really? we had it in 7th 20 years ago. I thought schools were dropping introduction ages to second languages.
Hi there. You have posted a learning question to /r/python. These types of questions are far more suited to /r/learnpython, where users are actively interested in helping people to learn. Please resubmit it over there! Make sure to read their sidebar rules before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." Show them that you've tried to solve your problem and you can get all the help you need. Cheers &amp; best of luck!
Thanks. The upvotes and downvotes have been wildly fluctuating. I think I've written this subreddits most controversial comment... 
Something something IronPython?
Your coworker's pronunciation is odd. It's not an electronic lif.
Like your coworker because it's based on else-if. It's like people saying numpi instead of num-py which is based on python, not pithon. I guess I say mat-plot-lib instead of mate-plot-libe, which is probably correct (I thought it stood for matrix/matlab plotting library...), but the authors don't do that. I guess Matlab doesn't either (that one I know is Matrix Laboratory). It doesn't really matter though.
7th for me as well for a foreign language, 15 years ago, and it was an advanced placement type thing. No programming languages were offered at all even throughout high school.
There's something you are not parsing here, I think. I briefly mentioned the ability to use a partial *if the function takes parameters to begin with*. That implies that you don't need to use a partial for a function that doesn't take params. &gt; a situation where the function itself may or may not be None, which you can't do in the chaining situation if you want conditional execution, unless you move the execution outside of the function But you can, though: def thing(callback): # callback is not ever called unless it is callable (i.e. not None and a function or other callable object) if hasattr(callback, '__call__'): callback() or to fit your recent example a little more closely, I suppose: def thing(callback): # depending on your needs, this could instead be: # callback = callback if hasattr(callback, '__call__') else default_callback callback = default_callback if callback is None else default_callback ...
Learn numpy and HDF5.
I just discovered the collections package... it's saved me many if statements and list iterations! 
&gt; asyncio doesn't provide any nio abstractions for files because (a) it's not really needed, and (b) there is no consistent way to implement it The fact that the various different platforms have all had to implement this sort of thing, despite there being no simple standard to follow, should tell you that it *is* really needed.
https://www.reddit.com/domain/information-age.com/ It's just a trash "technology themed" churnalism site. This doesn't belong on /r/python.
My thoughts exactly.
Do this in Python: https://www.youtube.com/watch?v=IaU3bE7M2UA
in my company, Python is used in auto test but not in webdev.
really cool stuff! Would be great to have more about tooling (performance, profiling, memory etc.)
This http://kivy.org/ is a very good GUI library.
I thought it was for devices with touch capabilities like tablets and mobile phones. Is it fine for a simple desktop GUI with textboxes, dropdowns and buttons?
Yep it's perfectly fine :) EDIT : If the GUI is really simple (few buttons, entry fields and drop downs) you can use Tkinter. Kivy is prettier and more powerful, but Tkinter is really easy to use.
Bah, there's a couple versions I had kicking on pastebin trying to troubleshoot, sorry. I'll find the correct one for you, hold on.
As others have said it comes from else, if so I think it's ok to say el-if
I'm heading to bed (and my English is terrible), so I'll just give you a couple of links. I hope you find them useful: https://en.wikipedia.org/wiki/Composition_over_inheritance https://www.reddit.com/r/programming/comments/36artd/composition_vs_inheritance_how_to_choose/ http://stackoverflow.com/questions/49002/prefer-composition-over-inheritance 
Thanks for the tip :-), the thing you're talking about is actually dependancy injection which is totally fine here. But instead of mocking or providing own fake it'll be easy to create a stub by simply inheriting and overriding setup_backend. What's better ? - I honestly don't know, I guess it depends on the case
* Embrace asap the readable code dogma * Automated tests are best tests * [Raymond Hettinger](http://pyvideo.org/speaker/138/raymond-hettinger) * Don't be scared of the standard lib, have fun with it * Don't be scared of the magic methods, have fun with it * Stop spilling coffee on your keyboard, now!
Actually you can get a better job in France knowing python without knowing French than by knowing French without knowing python. 
When I had it output integrand(0) before it game me something which matched Mathematica (and was significantly larger than this). However, I will double check this. Edit: when I run it, it returns integrand(0)=-3.20470410254e-11, not -5.007e-67
Tornado not listed under web frameworks. I guess this is an early draft.
with that change and adjusting the tolerances print quad(integrand, 0.0, Inf, epsabs=1e-50, epsrel=1e-20) I get -0.002009205. There's probably a different integration method to get better accuracy, but I don't know much about that.
I thought Python was loosely typed?
These have probably been mentioned: * Embedded software * application development for just about any platform * data analytics * testing and validation It is useful nearly anywhere you do not have a CPU bound piece of software and it can be useful even with CPU bound problems if you can break the problem up well enough to that the pieces can be run in different processes.
No. Strongly typed, but dynamic. Edit: this is a fairly good explanation: http://stackoverflow.com/a/11328980
Both-ish. If I just end up doing it for a personal project I may find a 'fallen off the truck' version of Simulink. However long term I would like to provide a cheaper alternative to tuned ECMs.
[Fork it on github](https://github.com/Parbhat/Python-Pedia) and add it yourself, should take &lt;30 seconds to do so and I'm sure the author would appreciate it.
IronPython can't compile Java beans.
You are confused by the PyQT license. PyQT is GPL. It is not mean that you need to distribute the source if you make money from it. It means that you need to distribute the source along the binaries of your application, in any case. PySide is an alternative Python binding for Qt, mostly a drop-in replacement for PyQT, released under the LGPL. However, it does not (yet?) support Qt5.
I guess I'm the only one who actually says "else if." Of course, back in the day, I would also say "console out" for cout. Maybe I'm just touched. 
There's a bit of a licensing difference between PyQt4 and PyQt5. Also, when you have to open source certain aspects of your code, you usually need to solely open source the specific parts that use PyQt or whatever module that requires open sourcing. It doesn't mean the entire project is to be open sourced. Thus for your incredible proprietary secret logic and such, you can simply import it as a module, pre-compiled or something of that sort.
"Elf" or "else if" if I am being formal.
requests and BeatifulSoup4 takes a lot less to get going on Windows. Also Scrapy doesn't have Python 3 support
You could even say they are both often interpreted.
&gt; dynamic/static refer to variable declaration It's a bit more complicated. There is also *type inference* in many statically typed languages which means you don't have to write type declarations either. A better distinction would be to say that in static typing, the types exist at compile-time, i.e. the compiler's type checker decides before you actually run the program whether you have used types consistently in the source code, whereas in dynamic typing, the types exist at run-time, i.e. the language runtime's type checker decides at run-time whether the operations you try to do are legal.
No. this was some time ago, between 1998-2002.
The address is now [central.scipy.org](http://central.scipy.org/). The old [scipy-central.org](http://scipy-central.org) address will redirect to the new address. &gt; SciPy Central is a collection of code snippets, modules and links for solving scientific problems with SciPy and related Python tools.
Well they're both approximations of a different integral anyway, so if it's mostly the same it's okay
Thanks a ton!
Don't use canopy.. use anaconda. Its the current and future of pydata Also this http://www.kdnuggets.com/2013/11/harvard-cs109-data-science-course-resources-free-online.html 
&gt; There are a couple of places where file io might not be as fast as the link you shared -- e.g. if the block device is shared over the network (like AWS EBS or Google's PersistentDisk). NFS is another example of this. I agree. We need someone to add support for aio. I'd be glad to do that myself, but don't have any time soon.
Maybe try doing "import numpy as np; np.show_config();" This will show you what libraries are linked against numpy. I found that with the default installation on Ubuntu, for example, using sudo apt-get, numpy wasn't linked against any accelerator libraries like ATLAS, and my operations were running about 40x slower. In the SO answer, it looks like they talk about vectorizing. Someone correct me if I'm wrong, but wouldn't un-vectorized code run just as slow on MATLAB? Or do they do some neat pre-compiling now where vectorization isn't needed anymore?
Thanks for reporting the issue will update it soon.
I like how the embedded icon is spinning. When you hover over it, the shadow follows.
This assumes your utility function gives the most value to job quality, though.
This is pretty neat, great job! You'll probably be getting a few pull request from me to add all my projects O:-)
is there a way to use nditer to speed it up?
What kind of computer are you on and how did you install numpy?
With coroutines now being a language feature it seems like that async versions of all I/O bound functions should be made available.
You're not supposed to iterate. You need to vectorize your code.
But if you simply import foo, then you have to preface all your calls to functions within that module with foo.whatever() right? And then I think I heard something about it supposedly clutters up the namespace using from X import * as well... are there any other sub-modules of tkinter? how can you list the sub-modules of any given module? Thanks for the explanation :)
How, exactly, can this code be vectorized?
thanks for your points! ill look into those. so the idea is to precalculate things that can be done/vectorized easily. Then have the iteration for those that can't, like the polygontest (I need to check if my object lies inside a polygon which is impossible to vectorize)
Try out the version of the code out the end. I think you will find it is much faster (it may need to be tweaked a little depending on your exact array layouts).
Don't use apply_along_axis. You need to rewrite your code from scratch. You only should be doing one pass as none of your particles depend on any other particle. Don't use for loops and don't use iterate, which you're using as a for loop. You need to use matrix operations. Matlab is all about vectorization, so literally you do it in the same way you do in Matlab. You'd get a huge speedup from your Matlab version as well. So how exactly? I'm not writing your code for you. You know your code better than I do, especially that `cv2.pointPolygonTest(item["Contour"], (x[0],x[1]), False) &gt; 0` bit, which screams inefficient to me. EDIT: You at least need to show you've made the attempt to vectorize your code. You know Matlab. You should know vectorization.
I reported it. The author says it's intentional, but it's possible that he changes it.
First of all, I am not the OP. Second, I have looked at the code, and I can't see a way to vectorize the whole thing. `cv2.pointPolygonTest` doesn't look like it supports vectorization, and I am not aware of a way to vectorize the dot product across multiple axes. Third, the OP specifically said in the link that the MATLAB implementation also used loops. Fourth, I already gave all of your suggestions in another comment. Please at least read what you are commenting on before telling the OP to do the impossible.
You don't need `nditer`. You can transpose the array (which is extremely fast because it doesn't make a copy), then iterator over the array directly. 
That seems like premature optimization. I think a lot can be done to get the speed improved in Python before needing numba.
Good point. I didn't think about 'matrix'. I've heard a sizeable number of people pronounce lib as in library (shared library -&gt; shared 'lib') but I pronounce it like liberty anyway.
In your command line terminal, are you in the same directory that the python script is located in? For example, if the script is in the "Downloads" folder, does it say "Downloads" in the actual command line window? I ask because Python is saying that it cannot find the file in the directory that your command line window is in.
Are you running `python (filename).py` in the folder where `(filename).py` is located? `(filename).py` has to be in the folder where you try to execute it, or you need to provide the path to `(filename).py` 
I don't know either, since I don't use a Mac myself, but I think there are pre-built versions for Mac from various sources that are probably pretty optimally compiled.
I'm not sure if there are better, pre built distributions for Mac. But I've always gotten the best result when installing packages using Anaconda and their "conda install xxxx" instead of pip for complex things like numpy.
Tabulate kicks quite a bit more ass than both I would say: https://pypi.python.org/pypi/tabulate I'm not sure why wget is in there over requests as well, but the rest of the list is pretty cool. Another one I would add is q: https://pypi.python.org/pypi/q - Awesome debugging tool. Go check it out right now if you haven't heard of it.
1. Python exists.
it looks great but it's a bit distracting
It sounds like that guy wrote that sentence. 
yeah, conda is the easiest option. but now try installing pyqt5 and see how far you get.
&gt; You need to learn how to use axis properly, but it's doable. If you have a good method, I am sure it would help the OP. I didn't explain how to do it because I don't know. &gt; it doesn't, but if the goal is speed (and it's important), then rewriting a point in polygon test method is certainly doable. Getting If the OP has tried getting the code optimized through more conventional means first and it still isn't enough, then that may be an option. I already gave the OP a lot of simpler suggestions for optimizing the code that should definitely be tried first. &gt; Getting rid of the dicts would be a very good thing as well. I don't think that is a dict, I think it a structured array. I already covered that in my earlier reply to the OP. &gt; You don't need to 100% vectorize your code to make it fast enough, but you start by getting rid of the inner loops. I think that re-writing pre-existing functions, especially optimized functions already written in C, would be the *last* optimization to make, rather than first.
Nah, I just used R. Couldn't find anything in Python.
Python race master race
Why Anaconda? 
Of course it is. I was trying to say that saying "EE-LIF" is weird.
My issue with extra libraries, in my work environment we can't just install them from the Web, and then if something depends on a library, I have to ensure all developers install it. I'd love to get colorama working for our build output, testing output and logging, but handling the install is the issue 
IT being over protective. Rather annoying, I can get some Lee way on my personal development machine, but rolling tools out to our team becomes frustrating if they use custom libraries. 
A "stereotypical" inhabitant of Russia / CIS, who you would typiaclly associate with speaking / typing in broken English.
I apologize. I assumed an issue with why Python wasn't running after I decided to switch to the command line would be separate from learning how to use or write in the Python language. The current version that runs, when it does run, it 3.4. There are no left over parts of 2.7 anywhere on my computer as far as I can tell. The question is, why does cmd still look for 2.7 when I've set the PATHs in the environment variable to point to 3.4? 
`random.choice()` does not work on any iterable, only on those which support indexing, otherwise you need to use `random.sample()`.
pex might be an option, depending on the specifics of your situation.
check urllib and urllib2 on the python docs. Optionally BeautifulSoup. Then get used to reading HTML. Once you get those two, the rest is simply finding sites to buy on, and figuring out how to make a purchase through requests to specific urls, typically some kind of "buy.php?prodId=134234&amp;param2=2....." and then logging this.
HEY this isn't about buildings with books! 
I don't know if /r/Python is appropriate for this discussion, but I really feel we could all do ourself a favor if we went in the way of better GUI integration in Python. I'm not a GUI developer, I code 3D reconstruction stuff (feature matching, etc) and I never liked having to design GUIs for my code. This time, I had to find a working UI toolkit, with the following requirements : - OpenGL render &amp; high DPI displays - Python 3 compatibility - Video capture support - Touchscreen support Also, this toolkit had to be integrated to a long-running AsyncIO event loop, that is I/O *and* CPU bound. The only two toolkits that I saw available were [Kivy](https://kivy.org) and PyQt5 with [pyOtherSide](http://pyotherside.readthedocs.org/). As I had to settle on a framework because of strict time requirements, I chose Kivy. Many weeks later, I was already trying to refactor Kivy's camera handling support (it did not handle camera errors properly, made the app hang, and it was not compatible with Python 3). I got OpenCV3 working in Kivy with Python3 (I still have to backport this to Python 2 and add support for the other camera providers, [if anyone is interested (branch is `eden`)](https://git.eden-3d.org/external/kivy/tree/eden)). Now, Kivy is not that easy to use. There is no working graphical UI designer (I found kivy-designer, but it just crashes way too much, was unusable each time I tried), doing the imports in the wrong order can lead to a... segfault, the documentations are still lacking a lot, and the parts of the code that I had to work on were a bit messy) I am not criticizing Kivy in any way here, it's a really good project with solid motivations, and I'd nowhere in my project without this UI toolkit. I think they critically lack developer time, and some parts of the code are still the draft copy of a developer's ideas. *BUT*, what is really cool with Kivy, is that, in the end, the code is not *that* hard to improve, and, if things are done properly, Kivy could be really nice. For example, it would be nice to have fully working AsyncIO integration (meaning that you don't have to run them both in separate threads (as they have their own event loops)), this can lead to very very interesting things and can help to manage resources more easily. Such UI toolkits are not lightweight, and forking/threading can get nasty really quickly, in your code as well as in your resource usage. I'm personally trying to implement such integration (it shouldn't be too hard really, Kivy already supports Twisted's event loop).
And that fails on generator expressions too, apparently. Which makes sense. &gt;&gt;&gt; import random &gt;&gt;&gt; &gt;&gt;&gt; c = (chr(x) for x in range(65, 105)) &gt;&gt;&gt; random.sample(c, 1) Traceback (most recent call last): File "&lt;pyshell#3&gt;", line 1, in &lt;module&gt; random.sample(c, 1) File "C:\Python27\lib\random.py", line 321, in sample n = len(population) TypeError: object of type 'generator' has no len() &gt;&gt;&gt; 
prettytable remains a good option for CLI tools that don't need any of the data processing stuff that pandas brings to the table.
I actually considered writing my gui in html/css and rendering it on a browser with a local server. I was [advised to do so on quora](http://qr.ae/Rob3KA). I gave up when I realized I'd have to use django (which im not comfortable with) or learn a lighterweight framework like flash. For now I'm using Kivy but your project looks really interesting. I think I'll consider using it in the future.
That was an interesting read. I already decided to go with Kivy for my project and I really like it so far. Thankfully my project is nowhere near as complex as yours! Good luck with that computer vision stuff.
Should have been more specific in my post - obviously a dictionary is the best option. It is converting it cleanly from the current text format to a dictionary generically for any possible data structure of this type that is the problem at hand.
 Python 3.4.3 (v3.4.3:9b73f1c3e601, Feb 24 2015, 22:44:40) [MSC v.1600 64 bit (AM D64)] on win32
Does it look native?
stack overflow legend ??
Although, "perfectly fine" comes with the caveat of being non-native. If you're fine with a custom skin, Kivy it up. However, if you want it to look native across the various operating systems, Qt would be a much better choice. 
I'd recommend the [PyParsing](https://pypi.python.org/pypi/pyparsing/2.0.3) package. It can certainly handle the heavy lifting, has reasonable docs (both official, unofficial &amp; 3rd party), and is easy to use (although not so easy to debug). It hasn't seen a new release in a few years, but I don't think its author has abandoned it, it's just "stable". PyParsing lets you attach "parse actions" to the rules that make up a grammar. You'd use these to convert "value" lines to (key, value) pairs, and both "list"s and "struct"s to... probably `OrderedDict`s containing those item pairs (ODs rather than `dict`s because no doubt you want to preserve item order). It looks like *everything* has a key, so even so-called "lists" should become mappings and not Python `list`s.
I really don't know all libs of this article. Orz..
Glad to hear it!
Build the wheels and share them via network drive? Honestly no good solution to this, part of Python's convenience is modules via web
I haven't colorama in a while but I think it's pure python so when I used it last I just included it as a directory in one of my projects. I do the same with pyserial.
He's in the [top 0.01%](http://stackoverflow.com/users/100297/martijn-pieters) for SO
Take a look on aiofiles. It has async api and executes file operation in thread pools. 
is anyone else also getting error with the fuzzywuzzy code ?, to me its saying install some "levithien" stuff, no idea why.
Levenshtein is supposed to be optional, for speedups. However, if you're installing fuzzywuzzy, I don't see why you wouldn't also install Levenshtein -- it's not hard.
&gt; But if you simply import foo, then you have to preface all your calls to functions within that module with foo.whatever() right? And then I think I heard something about it supposedly clutters up the namespace using from X import * as well.. Correct. You can also use from spam import eggs, ham This only imports parts you need. Some enforce *one import per line* rule/style. With GUI libraries it can become cluttered very quickly. &gt; are there any other sub-modules of tkinter? I have not used tkinter so I do not know. &gt; how can you list the sub-modules of any given module? Read documentation and/or source. You're welcome!
Ohh.. Windows. I doubt we've ever tested on a non *nix system. I'll explore a little and see what I can find. 
/r/slavs_squatting
what is a SO legend?
What sort of information are you thinking of scraping? I'd be interested. 
I guess it's good on Android 4 then.
[This 3d landscape](http://ekisto.sq.ro/ ) draws a tower for each person on SO, with the height of the tower being their influence on the site and the XY position of the tower representing their connections. Basically, the people with huge towers in the huge cities.
Yes, very strongly typed than you think.
In Python, even a type is a type.
 type of type is type but type of type of something is still just a type
Here is a good explanation if you're [wondering](https://wiki.python.org/moin/Why%20is%20Python%20a%20dynamic%20language%20and%20also%20a%20strongly%20typed%20language)
Woah... this thread isn't closed. It's like seeing a unicorn in the wild. 
Someone who answers a lot of questions and has a high rep on Stack Overflow. I don't think it is a formal designation but I remember at one point he had the highest rep on SO or maybe just highest rep on SO for Python questions.
Do you even read article?
"Strongly typed" is not a term with a consistent, accepted definition. Thus, many people -- including me -- recommend against using the term. ([My favorite example](http://stackoverflow.com/users/41661/norman-ramsey).) That said, if you are asking whether Python has static type checking, then: **No**. If you are asking whether Python forbids applying an operation to a type for which it is not defined, then: **Yes**. \[EDIT. See the reply by /u/kylotan.\] If you are asking whether Python does not allow for arbitrarily type conversions of the kind that C and C++ have sprinkled all over, then: **Yes**. (I.e., yes, it does *not* allow for them.) And if those answers aren't what is wanted, then the question needs to be clarified.
&gt;style guide, not the law The most important part of PEP8 that everyone seems to skip: "A Foolish Consistency is the Hobgoblin of Little Minds" It seems there's always _one_ person on a team that treats the guide as a religious document. 
So, what does it cost?
The point of a confusion comes from the fact that many people think that foo = bar is an operation on foo. When in reality it is an operation on a namespace.
Yeah, once you get python's naming system then the type system (and everything else) is so much easier to understand.
Exactly. I don't need a fire truck to go across the street for a paper
Are you on OSX? Try `cat $TMPDIR/q` instead.
That's really not a very good explanation at all. For instance: &gt; in some languages (like JavaScript) you can add strings to numbers 'x' + 3 becomes 'x3'. ... In a strongly typed language (like Python) you can't perform operations inappropriate to the type of the object Except what about: &gt;&gt;&gt; x = 2 &gt;&gt;&gt; y = 1.3 &gt;&gt;&gt; isinstance(y, type(x)) False &gt;&gt;&gt; isinstance(x, type(y)) False &gt;&gt;&gt; x + y 4.3 As /u/ggchappell explained, "Strongly Typed" isn't a well defined concept. Python may make fewer exceptions than javascript, but it's not fundamentally different, and I have a hard time coming up with a reasonable concrete definition that puts python on one side of the line and javascript on the other.
 &gt;That is the standard method of integer division in most languages. Also `1//2` still works in Python 2 and you can use the division import (since Python 2.5). Also, you can always do `1/2.` or better yet `0.5` and you probably should. Explicit is better than implicit. This is an interesting area of discussion, however I believe the right choice was made for Python 3. It is a question of what a normal user might expect out of a simple division statement. This isn't a language for low level programming. &gt;And until Python 3.5 (not released yet) didn't have an actual purpose. Python 3.5's purpose: help out IDEs to do type checking, but Python will not use it. Python 3.5 has been out of a little while now, I'm already trying to put it to use. Unfortunately got tripped up there with Legacy Windows XP hardware. 
The original question is a bad question (IMHO) because it suggests that * strongly typed * weakly typed is a useful way to look at python. The python student's time is better spent simply learning the semantics of python's types than trying to fit it into a programming language taxonomy. EDIT: it *is useful* to notice how python's handling of types is different from other languages the student knows but enumerating differences is not the same exercise as trying to fit python into the binary category of **{strongly|weakly} typed**.
I definitely agree it was the right thing to do. It gears Python more as a scientific language (e.g. Matlab) that follows sane mathematical rules. It's one less thing to learn if you're just learning programming. For the people coming from languages like C, there is a lot less to learn. That said, once you know, it's not hard. It's just a thing for me nowadays, kinda like dealing with multiplatform file path issues with `os.path` and using numpy where I can for speed. Apparently 3.5 was released 2 weeks ago...didn't see that on /r/python I think the right decision was made Python 3 and unicode (again, nothing else matters). I do think the PSF hasn't done enough to teach people how to do unicode properly for people that don't care about unicode (you probably should use latin1). You shouldn't have to google in order to figure out how to use unicode in an example. It should be on the PSF page and they should teach you how to avoid the whack-a-mole `encode/decode` problem.
&gt; So, what does it cost? The answer is about [3 clicks from this page](https://store.continuum.io/cshop/accelerate/) (first click is the OP link) &gt; **Numba, our open source compiler**, allows scientists and engineers to easily compile NumPy expressions to efficient parallel machine code, without needing explicit code-generation and recompilation steps. NumbaPro, the premium Numba extension in Accelerate, adds high-level API for user to build CUDA functions quickly, and has bindings to CUDA libraries: cuBLAS, cuSPARSE, cuRAND, cuFFT. Write your code with arrays, and execute it on GPUs and multi-core by adding just a single decorator. Numba is open source (free beer and freedom) while NumbaPro is unfree
You might also consider CFFI - (in this case you'd document the binary format as C struct): https://cffi.readthedocs.org/en/latest/overview.html#struct-array-example-minimal-in-line
ALWAYS DESCRIBE YOUR PROJECT
Can we get this into a PEP? import sys if sys.version_info[0] &lt; 3: import time time.sleep(1) 
Maybe something like this: def func(*args): if len(args) == 1 and hasattr(args[0], '__iter__'): args = args[0] It might break in some corner cases, but for simple applications, it'll probably work. 
This question is better suited for a site like StackOverflow.
https://xkcd.com/1053/
It's all opinion, but I feel like the *args is useful when you expect the functions normal use case will just be 2 or 3 items, but would like to support more. 
Sorry, i've never used ut
&gt;If a type system in a language can be subverted at any length, then it is by nature &gt;weak-typed. That's a Haskell zealot's answer. ;-) No, being able to cast a value doesn't make a language weakly typed. &gt;If Python was truly strong-typed, why would there be a need for this: http://mypy- &gt;lang.org/ ? Because that deals with static typing vs. dynamic typing, not strong vs. weak typing.
We'll talk again once there is a C++ update that is incompatible to previous versions and breaks most existing code. We'll see how quickly that is adapted. And yes, being intolerant towards other people is always a good idea to reach your goals :).
That's not an exception. "can't perform operations inappropriate to the type of the object". adding an integer and a floating point value is not an inappropriate operation. We have the definition: implicit conversion of incompatible types. The language guesses what it thinks you meant rather than what you actually wrote. In some weakly typed languages, whether you get 6 or "33" depends on whether you wrote "3" + 3 or 3 + "3"! 
This isn't really about learning Python, though. I know the mechanics of Python. I know how both ways you could do this work. My question is how people decide on which to use. PEP 8 doesn't seem to cover this. I've never seen a discussion of this before.
/r/learnpython or /r/learnprogramming since this isn't python specific
Thanks
look at the author and skip if your username is in it.
Great feedback sir. will do :) 
I tried, but it still commented, i'll try a different syntax
I find these discussions amusing, because from 2009-2013 I did mostly perl. And in that time, I discovered Moose. It made me think a lot about how I'd come full circle, from assembly, C, a brief excursion into java, ruby, perl, and with Moose I am absolutely convinced that declarative programming styles create more robust and maintainable code. It's almost as if I'd found a way to get some of the strengths of my (still to this day) naive views on java, without the suffocating bureaucracy and boilerplate. Plus a whole pile of benefits that fall out naturally. Now that I've been full-time (mostly) python for 2 years, explaining to pythonistas how I"d miss anything perl, let alone its post-modern object system, has usually been an exercise in futility. elk and traits are the closest things to this in python. "Oh, you declare what object members should be and how they validate up-front? That's not very pythonic". And yet here we are, discussing how strongly-typed python primitives are. "strongly typed" has many dimensions to it indeed.
I may have misread the question. Are you just trying to convert the text to something you can manipulate in python, then back to text? Do you need to work with the binary format at all?
&gt; If Python was truly strong-typed, why would there be a need for this: http://mypy-lang.org/ ? We need mypy to check the types because Python is real dynamic language. In latest Python version we have type hint or type annotation feature, Its like static typing. Don't confuse in dynamic and strongly type. Your favorite programming language didn't teach you the type system. Dammit! You need to switch to Python to understand type system.
Well, if you have the text version of that binary file, I can help write a converter. But if you already have a binary&lt;&gt;text converter, it would be easier to work with the text version.
This is the text version of the same file -&gt; https://www.dropbox.com/s/xdd6ocf2dpqwmic/e.cfg0.txt?dl=0 The command line tool will convert it back to binary as well from the text form.
You have lots of logic errors in your code. There was no flag for mixed types, you couldn't get the max in a mixed types. Something like this will work. if not isinstance(vals, tuple): return -1, 'None', 'None' max_val = None is_int = False is_str = False for val in vals: if isinstance(val, int): is_int = True max_value = max(max_value, val) if max_val is not None else val elif isinstance(val, str): is_str = True else: raise TypeError(type(val)) if is_int and is_str: out_type = 'Mixed' elif is_int: out_type = 'int' elif is_str: out_type = 'str' max_val = 'None' return len(vals), max_val, out_type Also, check out /r/learnpython
Is it because the if on line 8 is contingent on the if on line 5 being true?
Thanks for the quick response! I posted in learnpython as well but I haven't had any response there yet. When I tried to run this code it seemed to run into an error where val was referenced before assignment. I wasn't too worried about getting the max in mixed tuples since it should just skip ahead through the test and assign the 'None' as the third element in the output, that's what I was trying to do with that first else statement. I'm just learning so I appreciate the patience!
The purpose of character properties is so that people who need to summarise over broad swathes of Unicode in a structured way can do so efficiently. UAX #31 is very convenient for extending legacy restrictions on identifiers in programming languages into the Unicode space, and relies heavily on character properties (including defining some of its own). &gt; Until someone in Python-land decides that the traditional abbreviation for [0-9] should now mean *Unicode decimal digit*. Why don't you conclude you were the one at fault for treating *decimal digit* as synonymous with `[0-9]` in the first place? To my knowledge `\d` was always defined as the formerâ€”that it was synonymous with `[0-9]` in ASCII-land is coincidence.
This is definitely the most pythonic way to solve this problem.
I actually find programming in Python 3 much easier after having switched from 2.7. The two main reasons are 1. The standard library for Python 3 is much larger and growing and includes a lot of libraries I use all the time now such as pathlib. 2. The best practices are now also the defaults such as Unicode strings, range instead of xrange, input instead of raw_input, etc.
It's an instance of object... which is type type.
Oh...oops...I didn't run it. val should have been max_val. &gt; wasn't too worried about getting the max in mixed tuples Mixed wasn't supposed to return the max value?
No, mixed was supposed to return 'None' for that 3rd value which makes it easier.
https://github.com/pexpect/pexpect is your friend
I just ran "1 is True" in 2.7 and 3.4 and both versions returned False. What do you mean? 
The usual one-liner is that in a dynamically-typed language only values have types; in a statically-typed language, both names and values have types.
In Python, the `bool` type is a subclass of `int`. The constants `True` and `False` have numeric values 1 and 0 respectively, and you can do arithmetic with them. It is this way because originally Python didn't have a boolean type, and the convention was (as in many other languages) to use 1 and 0 as pseudo-booleans. So `bool`, when it was implemented, was done as a subclass of `int`, with those values, to help maintain compatibility for code written in that style.
There is a difference between "forcing," and applying pressure. 
Kill Java inventors
That's I mean :)
&gt; in a statically-typed language, both names and values have types. Or only names have types. IIRC OCaml doesn't have runtime types, not sure about Haskell implementations.
Thank you, I'll surely consider this for future posts. 
You are right, those are the most complex parts of testing. I'll think about it, it's a wide topic. Thank you for the advice!
Thatâ€™s true in most OO languages. Even in Java `Class` is a class.
Great post! From the diagram in the article, does this mean that pandas users will automatically benefit from hdf5 features? 
I remember listening to python podcasts and getting a complex that I'd been saying the name of the snake wrong all my life.
I've got to admit, I say library like a normal person but have always pronounced /lib as in lib-erty. I think I'd need another e before I started saying libe.
&gt; By shut them out I mean stop using their code bases cold turkey. Great in theory. But I have deadlines. I don't have time to rewrite massive third-party projects single-handedly. I use Python 3 wherever I can, but I don't only have a choice. There aren't always python 3-compatible alternatives.
&gt; It's been about time. I am happy to announce that "Python Machine Learning" was finally released today! Sure, I could just send an email around to all the people who were interested in this book. On the other hand, I could put down those 140 characters on Twitter (minus what it takes to insert a hyperlink) and be done with it. Even so, writing "Python Machine Learning" really was quite a journey for a few months, and I would like to sit down in my favorite coffeehouse once more to say a few words about this experience. &gt;Python Machine Learning Book Cover &gt;ISBN-10: 1783555130 &gt;ISBN-13: 978-1783555130 &gt;Paperback: 454 pages, ebook &gt;Packt Publishing Ltd. (September 24th, 2015) &gt;Over time, several people asked me what this book was all about and how I found the time to ... (1) write it, (2) read all these interesting articles that I post on twitter, (3) do research, (4) relax and enjoy my life, ... Technically, I could summarize point no. 1 in one sentence: I believe that all tech books a written more or less in leisure time. I figured that I could "just" cut down on hobby coding projects and blogging for a few months to make this work. &gt;Write what you know. That should leave you with a lot of free time. &gt;â€” Howard Nemerov &gt;You don't agree? Maybe my little bag of productivity tricks can convince youâ€”if you are interested, more on that later. First, let me tell you a bit more about the book. Should I be reading anything into taking a while to get to the book itself?
I think that sounds like a reasonable amount of pressure. I'm not quite ready to start dropping support for *legacy Python* in code that already supports it, but I'm using Python 3 myself, and that's what I target for new code. So I like the idea of shifting how we talk about it to hint that it's time to move on.
Any links to good ELI5 explanations?
+1 on any tool help inspect code visually
`True` is `1` _in Python_. `"1"` is `1` in weakly typed languages. That's what I mean when I say Python is weakly typed with respect to bool/int. It's not that there aren't rules about conversions, just that it's not something the programmer needs to do explicitly.
Did you even bother to google how to do this?
&gt; in javascript everything is an object Not quite - primitives like strings, numbers and booleans are not objects, but using dot or bracket accessors converts the primitive to a wrapper object on the fly. `"klaatu".charAt(0)` gets turned into `new String("klaatu").charAt(0)`. And special primitives like `null` and `undefined` are also not objects, and they have no wrapper class.
Ahem, they support 3.3 and 3.4... obviously not 3.
I recently won an interview on python,webapps,djano/flask,rest-apis: What's the difference between tuple/list ? Why not default mutable arguments in functions ? When wouldn't you recommend a rdbms ? When would you recommend a nosql? How would you scale a rest api ? How would you make faster a rest api ? How would you find a pattern inside a text ? What are flask blueprints and when/why use them ? Flask vs django. When would you use flask, whend jango. Sqlalchemy + db migrations. Why not use an orm ?Pros/cons of orm. Search for python interview questions, rdbms interview questions, what are flask blueprint? How would you design a rest-api ? 
I think this is just a tutorial and not a package. What is the best option you've seen for executing actual SQL on DataFrames?
Ibis has the goal of being a semantically complete SQL replacement...and better: http://docs.ibis-project.org/sql.html 
Do you even know how python versioning and compatibility work?
[removed]
For the sake of others that may come across this at a later date, you're saying to consider and research the following questions? * What is the difference between a tuple and a list? * Why not have default mutable arguments in functions? * When wouldn't you recommend an RDBMS? When would you recommend noSQL? * How would you scale a REST API? * How would you make a REST API faster? * How would you find a pattern inside of a string? * What are flask blueprints? When would you use them? Why? * What is the difference between Flask and Django? When would you use one over the other? * Why not use an ORM? What are the pros and cons of an ORM? * How would you design a REST API?
Are you having a stroke? Should we call 911?
In languages like C types are associated with names and not values.
Not sure what you are saying. Would like to point out that 3.1 was terrible and most projects that support both versions do not actually support 3.1. They typically start from 3.3 which is far saner and more compatible with 2.x code. 
So, x is a (pointer *), next minute it's (unsigned long). Try that in Python. How do you cast? You can't, it has to be explicit.
I appreciate the enthusiasm of your post title, but I'm not quite sure what's happening here...
That's already established convention. There are hardly any projects supporting under 3.3. Only 3.2 was even considered production-ready by the Python devs themselves. *Nobody* runs 3.1 today (or 3.0 for that matter), so supporting it is a complete non-issue. There are *maybe* a very, very, very few users of an older Ubuntu who have 3.2 as system `python3`. Therefore when people say "Python 3" in the community, they are invariably referring to a minor version 3 or greater (&gt;=3.3).
Well, C is also weakly typed :)
They aren't really equivalent because pandas is doing a full sort and picking the first 3 elements, while good SQL implementations could perform partial sorting
Just inject a BytesIO instance into your code and asset on the state of getvalue() after your calls
Also, Python implicitly converts from ints to floats, which is not a strictly kosher operation -- while mathematically every integer is a real number, in practical implementations there's a loss of precision so they should not be in a subtype relationship, strictly speaking. &gt;&gt;&gt; x = 10**20 &gt;&gt;&gt; x + 1 == x False &gt;&gt;&gt; x + 1.0 == x True
I agree, I find tech book a tad to expensive in general, but it's probably all based on market research. I don't want to advertise anything here, but I saw that the publisher offers the book for $8 less than Amazon -- the e-book at the publisher comes as epub and PDF and also has an export function to send it to the Kindle reader. &gt; Quick question: I noticed the book states early on that you need Python 3.x, but I was under the impression that Scikit/Pandas/etc only run on 2.7. Pandas and scikit-learn support both 2.7.x and 3.x (the even support Python 2.6). Both project use continuous integration systems (Travis CI) to automatically check that "all" python versions are supported, you can check the status here https://travis-ci.org/scikit-learn/scikit-learn and here https://travis-ci.org/pydata/pandas &gt; Additionally, will the Theano chapter require use of a GPU set-up? Please forgive my ignorance here! Oh, no worries, that's a legit question. I wrote the chapter in a way that it runs on CPU only, but I explain which "flag" you have to change in order to run in GPU, because not everyone has e.g. CUDA supported GPUs. Typically, you prototype on your laptops or desktop using the CPU, and once you have everything running smoothly, you'd just change a flag and run it on a computer(gpu) cluster 
This sounds like homework help. Have you learned about the `if` statement? Do you think it might help you solve your problem?
&gt; Should I be reading anything into taking a while to get to the book itself? I am not sure if I understand correctly, do you mean the blog post or other literature "as preparation?" The blog post is just to give a brief overview of what it's all about, or what you can expect from the book -- maybe it helps to decide whether you are interested in this topic at all :) As for other literature, it's hard for me to tell, and I think there is nothing really required to follow through. A very basic calculus knowledge, and knowing NumPy and matplotlib would be helpful though. For example, two of the reviewers didn't have any ML background and they got along just fine :)
Look into saving and loading models as well, so a process can be partially run, saved, then picked up again later. Start with /u/Mishkan's answer about online learning though.
This is a really interesting project. Do you have any early benchmarks? I believe there's been some JVM work to improve the performance of Jython so I wonder if this will take similar advantage of them? I tried the instructions on git and readthedocs.org with limited success. The issues I'm having may be trivial, but others having similar issues doesn't help the project. On git: * pip install voc doesn't work * ~~trying to build example.py complains about non-ASCII characters in the code~~ - my bad, incompatible with Python 2 but Python 3 works fine At this point I tried the dev environment instructions: * git clone didn't work (asked me for ssh key) - I just used https://github.com/pybee/voc * mkvirtualenv command didn't exist * requirements_dev.txt didn't exist Thanks to /u/IronManMark20 I got it building, however with Java 1.8 I had some bad times: $ java -XX:-UseSplitVerifier -classpath python.jar:. org.pyee.example Java HotSpot(TM) 64-Bit Server VM warning: ignoring option UseSplitVerifier; support was removed in 8.0 I don't know if by "Java 1.7+ VM" you mean it should support 1.8 or not. Either way, it looks like there's a blocker for 1.8 support: http://stackoverflow.com/a/31569447/94503 Environment: Python ~~1.7.10~~ 2.7.10 on OS X Yosemite.
That version is out-of-date, here is the more up-to-date fork: https://github.com/tqdm/tqdm
Well, if your using 1.7.10, you have bigger problems. :) Also, for the non-ascii characters, just add a utf heading to the file
Haha, fair enough, the blog article is more of a "reflection" on the writing experience; a lot of people that followed me on social media during the writing process were asking for this, plus it was quite fun and satisfying to wrap this project up this way. It's probably more of an announcement; I thought it was nicer than just sharing an amazon link or so. Also, I wanted to thank the people who are involved in this project since the mentioning of the reviewers in the book itself is rather short. Except for the section http://sebastianraschka.com/blog/2015/writing-pymle.html#where-we-are-going-with-this-book it is probably not very informative to you. 
....why?
Here is an example of how you can change a variable depending on what value it has. if cucumbervariable == 9: cucumbervariable = 0
They will automatically benefit from some features. Others will have to be manually supported in pytables or pandas. Others will probably have to be manually accessed. Currently, pandas allowed to to access the lower-level pytables details if you need to. I would think that pytables, in turn, would allow you to access the even lower-level h5py details, but I haven't seen that explicitly confirmed.
It turns out Python 2* was my mistake. With Python 3 it runs fine.
Yes I know programming. I believe a while loop or recursion would be best way to code this but I'm stuck on how to make it work.
Pretty sure everyone is going to stop using passwords fairly soon. They are a bit retro really.
If you have no idea where to begin with freelancing you should probably start by getting a job as a developer first. 
Pandas is designed as a data analysis and wrangling tool; it excels in things like EDA and quick and easy data wrangling for medium sized data. Why use it? If you have data that fits in RAM then sucking it up from myriad formats (or pulling a subselected/summarised dataset from a database) is trivial and fast; once in pandas then you can do standard querying, but you also have easy access to all manner of plotting, machine learning, scientific computing etc. libraries as well as arbitrary python, which all integrates in easily enough, so complex visualizations, data manipulations and machine learning algorithms are all immediately at your fingertips. Where does it suck? It doesn't have query plans or query optimization, it executes what you tell it in the order you tell it, so if you mess up it can be very slow. It also doesn't handle distributed/huge data very well (it was never designed for that) so trying to use it for data that doesn't comfortably fit in RAM is a bad idea. In either of those cases you want a database. In summary, Pandas is complementary to databases. Once you've got a small enough dataset that you want to do non-trivial things with it then pandas really shines. Often that involves pulling summarised, subselected, or otherwise condensed data from a database to experiment with the data and see what can be done with it. Once you're done playing and know what you really want to do you can try implementing your random forest of top of custom ensemble Louvain algorithm (or whatever you came up with) as a stored procedure in SQL.
If you can't do it the way you said at the end, then you basically have to do what you do on paper when you add large numbers (so, carrying-over, and etc). This is a pretty cool problem. When you add numbers, you start from the end, so iterate backwards. If it's less than 9, you know what to do. You can stop iterating. If it's greater than 9, what do you have to do? (hint: it involves more than just the current number). You'll also need to specialcase the end, in which you may need to create a spot using the `insert` operation. Hope this helps, let me know if you need clarification.
&gt; Why wouldn't you recommend an RDBMS? I would always recommend a relational database for core data storage. Unless the data itself is non-relational. However, PostGres has many options to address this if a full on nosql data store isn't needed. &gt; When would you recommend a nosql [datastore]? Only for things like special purpose data storage: cache, message queue, full text search. Maybe they provide the consistency and durability that mainstream RDBMS do, maybe they don't, but there's no silver bullet here as many of these data stores are oriented at different specialties. For example, for message passing or simple caches (users online, etc), redis is a good choice. If a full cache is needed, rendered HTML, memcache is good. For full text search there's Solr and ElasticSearch.
This question is better suited for /r/learnpython or /r/learnprogramming
Hi there. You have posted a learning question to /r/python. These types of questions are far more suited to /r/learnpython, where users are actively interested in helping people to learn. Please resubmit it over there! Make sure to read their sidebar rules before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." Show them that you've tried to solve your problem and you can get all the help you need. Cheers &amp; best of luck!
ok, this has given me a good start thanks
Because having that mindset makes one write inefficient pandas code, or use pandas when another tool would be more suitable. 
I will volunteer my pet python library/project: https://github.com/EntilZha/ScalaFunctional I am happy with the design/implementation. Would be interesting to run your tool on it. EDIT: Created an issue on the github with details, but I get an IO Error because there is a missing file. By the look of it, the json data file from the package I input (tried a few different ones) isn't written to the right place
You evidently like big runtimes too. 
I think people are getting the wrong idea. I wouldn't suggest anyone compose a string this way, unless their use case is something like the following: key = 'base/%s/%%s' % name data[key % 'thing'] = {} data[key % 'stuff'] = {} for item in items: data[key % 'thing/item-%s' % item.id] = item
Thanks! I am just learning about Natural Language Processing so this will be a good primer!
That's a popular technique also used by NCIS: https://www.youtube.com/watch?v=u8qgehH3kEQ
"If you don't have the same views as I do then you suck"
Remember to post the improved version as seeing it should help people in future.
If only there was some python implementation for the jvm we could call it something smart like jython. 
we already have Jython though. Does voc do things differently/better or is it only a hobby project?
Hi there. You have posted a learning question to /r/python. These types of questions are far more suited to /r/learnpython, where users are actively interested in helping people to learn. Please resubmit it over there! Make sure to read their sidebar rules before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." Show them that you've tried to solve your problem and you can get all the help you need. Cheers &amp; best of luck!
Hey, I'm a python+C++ guy 80% of the time, but I'm not a language fundamentalist. I have seem some fantastic Java infrastructure and deployment. It some cases it is the right tool for the job. &gt; "If you don't have the same views as I do then you suck" Piss off.
If the size of the runtime is a primary consideration then you have small problems to solve. You must be new at this. Talk to me when you work on something harder than a facetweeting webshit.
Each Reddit post and comment has a unique id. So you need to store the id of each comment you reply to (in a database or even a csv file), and later check for it before replying. if unique_id not found: reply_to_comment() else: skip If you want an example, there is one here: http://pythonforengineers.com/build-a-reddit-bot-part-2-reply-to-posts/
You "won an interview?" What does that even mean?
Given your comment and the downvoting I got, I can conclude one thing: No one here knows what a joke is.
&gt; Therefore when people say "Python 3" in the community, they are invariably referring to a minor version 3 or greater (&gt;=3.3). It's funny that you say this, yet you completely missed my joke...
Windows keyboard hooks via pyHook: http://sourceforge.net/p/pyhook/wiki/PyHook_Tutorial/
Probably because a "Version 3", as opposed to "Version 3.0" or "Version 3.4" isn't a thing which actually exists concretely. But that's what you were comparing them to. Hence my confusion at whether you knew the semantics of how python versions itself. In this situation an /s would've gone a long way.
So... it's another Jython? I was curious so I looked up Jython. [Jython](https://wiki.python.org/jython/JythonFaq/GeneralInfo#How_fast_is_Jython.3F) &gt;Jython is approximately as fast as CPython--sometimes faster, sometimes slower. Because most JVMs--certainly the fastest ones--do long running, hot code will run faster over time. So there's really no benefit to using Jython over Python... I really don't understand why people are making this stuff. 
With SQL it all depends on how the table is indexed. Looking up the first three elements sorted is very quick in a b+tree. As far as I'm aware there is no such indexing in Pandas. If there was it would be a massive overkill. So it's safe to assume that Pandas queries will perform fairly poorly on massive datasets when compared with SQL
It is. The readme says they're not implemented but with some work they will be.
That's incorrect. Implicit type conversions happen all over the place. 
Well what's the benefits of using Java over using C? That will tell you the benefits of using Jython over the reference implementation
Believe me, I'll be ecstatic if Jython (or this, or anything) becomes a first-class citizen Python implementation on the JVM). However, no one's quite there yet. 
Is this python 2 only?
Really. Examples please.
A lot of things implementing `__eq__` and `__ne__` as an example: &gt;&gt;&gt; 1.0 == True True This gets obviously more extreme with some classes that people write which will try to imitate some other types. On Python there are loads of things that pretend to be strings but really are not.
The point is that such comparisons would error in strictly typed languages or at least are supposed to. In py2 ut was worse as everything was also comparable. If you want examples of actual type conversion just stick some of such things into the dict as key either directly or through a leaky implementation. Great fun. 
Did you install Qt first? PyQt5 simply provides Python bindings to the underlying C++ classes. http://doc.qt.io/qt-5/windows-support.html
[Here's the code](https://gist.github.com/maurisvh/df919538bcef391bc89f). It requires numpy, pyaudio, and a shell that supports ANSI escape codes (try something UNIX-y, or Cygwin if you're on Windows.).
Ah, okay, I'll try that.
pip install wheel Download pyqt5 for python3.4 here http://www.lfd.uci.edu/~gohlke/pythonlibs/ pip install the downloaded file
Thanks for the github issue! Just fixed up my setup.py file, things should be good to go. Updating via pip should do the trick: pip install blackwidow --upgrade Here's a quick visual of your library if you don't want to update: http://i.imgur.com/2F7Ch9y.png Awesome project, by the way!
https://youtu.be/FONN-0uoTHI
&gt; Also, AFAIK using jython doesn't take much effort It takes basically 0 effort...interop between Jython and CPython is non-existent, but straight Jython is very straight forward and familiar.
That's great! I was considering using spaCy at work but had hesitated in building a code base with tangly licenses that would make me have to explain to higher ups why I had used spaCy over NLTK or other free libs. Now I can finally use it without worry. Thanks!
cool library
/r/learnpython
&gt; Why wouldn't you recommend an RDBMS? Distributed temp storage, ala key/value: caching, user sessions, pub/sub, etc.
Figuring out `random.shuffle` works on any `collections.MutableSequence` was pretty mind blowing, honestly.
Or just use jython.
Just last night I got a little exposure to os.path.join for a script at work. Mighty nice the path handling routines, once i figured them out. The documentation however leaves a lot to be desired, I need to find out how to highlight the short comings to the maintainer.
Your joke was terrible
This I understand to an extent but sooner or later you yourself will get left behind. What is interesting here is the similarity to recent events in the Apple world where it is pretty obvious that the days of Objective C are numbered. Obviously Swift is a bigger change than going from Python 2 to 3, however I suspect that is 2-3 years many developers in the Apple world will be left behind if they don't try to migrate. for library developers and the like they will either have to migrate or end up in these position many Python projects are now. That being the fall from favored status due to being replaced by Python 3 complaint software. I probably wouldn't care if we where sitting here discussing Python 3 adoption one year after its release. It is the long delay and apparently open hostility to change that i find objectionable.
Certainly not dormant. A ton of work recently went into getting Jython 2.7, and work on Jython 3.x is in the works. If you want this released sooner, there's a long list of things you could help out with on their issue tracker. See Jim Baker's talk at 2015 PyCon on getting to Jython 2.7. https://youtu.be/hLm3garVQFo
&gt; If you need a full blown IDE with all the bells and whistles, you should be using Java instead. This statement is asinine. A full blown IDE is just as useful with Python as it is with any other language. IDE's might not be advisable for new students just learning programming but they are an enabler even for somebody with significant background in programming. That and the fact that the standard library gets larger with each release highlights the need for better tools. &gt; DO NOT EVER write Python in any other language but English (It is impossible for others to understand your code otherwise). So what do you expect a person educated in French, German, or even Mandarin to write in? At least you grouped your asinine comments together. By the way I would love a world where everybody spoke great english and could write just as well but that won't happen anytime soon.
Traceback (most recent call last): File "pylisten.py", line 78, in &lt;module&gt; with Spectrogram() as s: File "pylisten.py", line 31, in __enter__ device_info = self.audio.get_device_info_by_index(device_index) File "/Users/adam/anaconda/lib/python2.7/site-packages/pyaudio.py", line 977, in get_device_info_by_index pa.get_device_info(device_index) TypeError: an integer is required
Oh, no! I'm on mobile, so I can't look into this, but try replacing that line with `device_info = self.audio.get_default_input_device_info()`.
I put something together that should allow you to do to basic edits on existing configs. It's not 100% of what you may want to do with a parser, but it will allow you to manipulate settings and save the new config file out. https://github.com/jcampbelly/ecfg
/r/pygame
Not gonna lie when opening the picture i thought it was a tool to convert porn to ascii. My mind is broken.
It's very nice to hear that you use pgcli. :) How did you generate the images for the README? Your images don't have the project name on the top and it seems to capture the entire image. I tried Ctrl-minus but that didn't quite give me the result. 
Cool, keep it up! As a way to extend what you have and maybe learn about something you'll be approaching in the near future (lists) try this: positive_responses = ['yes', 'yeah', 'okay', 'yup'] if answer.lower() in positive_responses: print('Of course, TreeVille is 2 miles West of here') You could try modifying this code to save yourself some elifs for the negative responses :) Another thing, it's cool you have the != negation down, but usually in this case you'd just use: else: print('I don't understand.')
This problem was solved in Cookiecutter a while ago for `Unittest` in Python thanks to /u/audreyrg/, Michael Joseph, Paul Moore, and others. Since then we moved to a py.test system by Raphael Perzina. * current py.test system: https://github.com/audreyr/cookiecutter/blob/master/tests/test_prompt.py * Old unittest system: https://github.com/audreyr/cookiecutter/blob/5c4dfe7f8820303886c0d7822afa9f1b84411b5a/tests/test_prompt.py
First project I've seen to actually drop support for Python 2 completely, and move to Python 3 only. Yes, it's 'only' a static blog generator, but it's a good one. Have we finally reached the tipping point?
Wow, that's cool! Now export it to OSM and import it into [Cities: Skylines](https://steamcommunity.com/sharedfiles/filedetails/?id=416064574).
How many of those were doing so unwittingly, using it because they know no better and just called their script with the default python on their system? EDIT: Also, the author of the post states that it is not just about survey results but also about ease of development.
Everyone I introduce someone to programming I do it with Python 3... starting them off on Python 2 just sets them up for unnecessary problems down the line. I use 3 in preference whenever I can and am gradually converting all the code I've written over to it. But I've had first hand experience of the problems with multi-package setups where inevitably at least one thing doesn't work. But it's getting better... and it's only going to get better. 
I expect (hope) to see more of this, maintaining backwards compatibility is incredibly boring. I guess a static blog generator is in a lucky position where it's not depended on by ~~or depending on~~ other packages. OT: How does Nikola compare to Pelican? I use the latter on a lot of sites, and it causes me so few problems I'd even forgotten the name. What does Nikola do better?
The AGPL *is* 100% free.
What sort of vert and face counts are you ending up with in Blender? And what engine did you set the materials up for? Cycles by default would be awesome.
Traceback (most recent call last): File "spectrogram.py", line 21, in &lt;module&gt; gradient.append('\x1b[{};{}m{}'.format(fg, bg + 10, char)) ValueError: zero length field name in format
I think thats the only explanation though, when I run it on my windows laptop i see all 4 cores utilized evenly and it takes roughly 10 minutes to process 600mb. When I move to my enterprise grade linux server, 12 cores 200gb ram etc the exact same code takes well over an hour.. switching to cElementTree didnt make a difference to execution time.
&gt; You are bad comedian :D You are bad spelling.
A lot of what you've asked is easily found via Google. Usually posts like this are downvoted into oblivion in /r/Python as there are better outlets on Reddit for this content, though in the interests of inclusion and learning, I'll help out here. You'd best float around /r/learnpython and /r/learnprogramming too. &gt; How do you include a file inline in python, like if I wanted to break a script into segments? **main.py** from specific_script import specific_function # References specific_script.py in the same folder. specific_function("Bond. James Bond.") **specific_script.py** def specific_function(foo): print(foo) &gt; How do you import files for use in a script? That depends on what you mean. Python code (from snippets to large applications) are made up of flat files (.py). If you want to process files that aren't Python code, see: https://docs.python.org/2/tutorial/inputoutput.html#reading-and-writing-files &gt; The same way as modules? Is everything meant to be a module? I always seem to have issues with directories. What do you mean by 'modules'? Modules can mean many things depending on the language, even the programmer. Can you provide an example in PHP/JS? &gt; Class files, what do you do if you want to use a class file located elsewhere in a file hierarchy? What do you mean by 'class files'? Classes (object definitions) can be stored in any python file (note: this doesn't mean they should be...). Generally, accessing python code from different folders isn't possible by default, though there are [hacks around this](http://stackoverflow.com/questions/4383571/importing-files-from-different-folder-in-python) (but probably isn't a good idea...). 
Are you trying to be ironic? You didn't even use punctuation in your retort.
/r/learnpython please
It's not anything that you'll ever see, but for all the stuff I'm developing internally for my company I refuse to touch 2.x. I can't wait to jump straight to 3.5. For the same reasons I don't target Windows XP.
Describing things concisely is hard. When I wrote that initially, what I was trying to communicate is that there's a serious attention to performance and practically. Or said another way: spaCy is suitable for production systems --- it's not demonstration/education code, which is fairly common for libraries like this, particularly in Python. In terms of concrete results, spaCy is both faster and more accurate than Stanford's CoreNLP, which is usually seen as the leading "production quality" option among similar libraries. Actually spaCy is the fastest NLP library available, anywhere. I gather from talking to Google's engineers that they have faster stuff internally, which isn't surprising. But, it's not public knowledge. Of the systems that have ever been released, spaCy's the fastest.
Previously I was working with a business model where users who wanted an unencumbered model could pay for a commercial license, that offered equivalent rights to the MIT license. Now everyone gets the MIT license, and nobody has to pay money to do so. 
So basically, industrial strength = scalable.
Hi there, nice to see this change. Do you plan to add more functionality in the future or integrate spacy with other libraries (Gensim, Scikit-Learn...)? Btw., you might want to improve the examples section on your website: In [62]: assert sentence.text == 'Hello, world.' Traceback (most recent call last): File "&lt;ipython-input-62-3ff60dd4b8eb&gt;", line 1, in &lt;module&gt; assert sentence.text == 'Hello, world.' AttributeError: 'spacy.tokens.spans.Span' object has no attribute 'text'
That is AWESOME - thank you! When you use some open-source software you inevitable encounter bugs or things to improve; the beauty of open source is that you can help fix them. But if you contribute to AGPL software you're investing time into something you can't use in all situations; that was my personal reason for not even trying SpaCy.
We don't really care all that much whether you are running it on python2. We do care if you have python3 installed and/or available.
&gt; a difference to execution time. Maybe performance is limited by the speed of your storage?
Can someone provide a link?
I missed learn python in the sidebar. I'll try there.
This doesn't seem too surprising. I still use Python 2 almost completely, because just too many dependencies in my projects haven't converted, but obviously Python 3 is the future.
O_o Is that a new install, latest version etc? This works for me &gt;&gt;&gt; import spacy.en &gt;&gt;&gt; nlp = spacy.en.English() &gt;&gt;&gt; doc = nlp(u'Hello, world. This is a sentence.') &gt;&gt;&gt; sent = list(doc.sents)[0] &gt;&gt;&gt; sent.text u'Hello , world .'
Could use pyroute2 to scramble the MAC, then issue a down/up to re-DHCP. What OS?
I get the same error using your example. This is with version 0.89, which seems to be the latest available version on conda (2.7, Linux, 64bit). Just installed it using: $ conda update conda $ conda update anaconda $ conda install spacy $ python -m spacy.en.download all
A static site generator is essentially a standalone application that you use Python to configure it with. The amount of Python "code" this change impacts will thus be very small. If it was a popular library that many people include in their projects, now that'd be a different story.
&gt; And death (or being the next COBOL) is a really unlikely scenario, considering how many people and communities use Python around the world. But they are not using Python 3.
&gt; yet all new code was written in Python 2 Given the ease of single code-base development, there's very little reason not to support both versions in a single code base unless you have to support Python &lt;= 2.5. The additional work required to do this is in general quite small - at least, it has been in my experience.
On a tangent, you have one of the cleanest project graphs I've seen so far. Nice work!
&gt;500 Lines or ~~Less~~ Fewer FTFY. (Sorry! I even downvoted myself)
&gt; pyroute2 Mind fielding some questions over PM?
Honestly, I can't find the exact answer in Google, that's why I asked here(didn't see r/learnpython, I looked). I can load modules relatively. That's easy. How do I do anywhere else. This is what I can't find. Say I have a directory structure like - Application - app - classes - app.py #app.py can get to classes, no problem - db - etc - other_classes #app.py can't get to the things here. - tests I can't find how to get to classes and files that are in a grandparent directory, or a sibling directory to a parent directory. In everything else I use(PHP, TS, CSS, SASS) I can just put in a relative or absolute path like I'm in a terminal. I just can't figure out how to do the same in Python.
Calling `format()` with `*args` explodes the `args` list into a set of arguments. The `format()` function expects arguments in the style `format(a,b,c,d)`, and collects them back into a list with `*args` in the function. So calling with `format(*args)` is a shorthand for `format(args[0], args[1], args[2]...)`, allowing for situations where the number of arguments being passed is unknown. If `format()` required you to specify the arguments as a list (with a single `args` parameter) you would then need to pass in individual arguments as `format([a,b,c,d])`, which is counterintuitive. So, the answer of *when* to do one or the other really comes down to how the function is to be used, and how related the elements in the list are. Use `*args` to collect discrete parameters to the function, that are not (directly) related. Parameters that are iterables should contain related data, e.g. values on which you want to perform some kind of operation. Use calling functions with `fn(*args)` as a convenience shorthand to functions that can accept multiple arguments, and where you don't know how many you will have. I would also avoid calling your variables `args` as that may be the source of at least some of your confusion. If it's an iterable, `iter` might be better. It might be easier to see the point with the similar `format(**kwargs)` which allows you to explode a `dict` into a set of keyword arguments (by key).
Pyaudio has python2 only dependencies I think.
just in time for my class milestone, thanks!
just got my self on board so what next!
Is it just me, but isn't Python an interpreted language (meaning you don't compile it) ? anyways [this link](http://stackoverflow.com/questions/23257984/python3-4-on-sublime-text-3) should help you
I was thinking it might be interesting to import into Minecraft. With the simple villages you usually see, it'd be cool to have a full-sized more-organic city
There is not demand for remote Python developers. If you want to work remote learn Ruby and Ruby on Rails.
I somehow sense you're not really interested in having a real conversation about this!
Sorry, been around the API block too many times.
Here ya go! http://careers.stackoverflow.com/jobs?searchTerm=python&amp;allowsremote=true
Cython has quite good documentation. Wrapping external C code is described here http://docs.cython.org/src/userguide/external_C_code.html while here http://docs.cython.org/src/userguide/wrapping_CPlusPlus.html you can read about using C++ with Cython.
&gt; spaCy is suitable for production systems haven't tested it, but this is one of the big downsides of NLTK. every time i see NLTK in production, i just cringe.
I think this would be much more appreciated in /r/learnpython
I like using sqlalchemy for its compostability. if can start as query = session.query() if foo: query = query.filter(foo=="foo") if bar: query.group_by("bar") if limit: query = query.limit(limit) etc Sqlalchemy is very close to sql, so they have a negiligible performance overhead. 
Why so many upvotes to the various responses for something that appears completely useless to me?
This page here also mentions crosbar.io (ut says it builds on Autobahn). Have you tried that? Any idea how they compare? http://www.fullstackpython.com/websockets.html
excellent
I'm not sure how "provides an solution to support patterns that REST doesn't optimise much for" is different from "fix issues with REST", where those patterns are actually the ones that, the GraphQL people argue, we want in real world applications. But perhaps my introduction was too short to be useful and I should've just pointed elsewhere. GraphQL is, I think, not only useful as proxy for heterogeneous backends you don't control. It's also potentially useful to do *instead* of a REST backend -- it gives UI developers more freedom and can potentially be more efficient too. Yes, SPARQL could be used as a database frontend, and I can see there being some advantages to it. But it would also lead to some new issues if you want to do the backend to a UI: you'd need not only to update the underlying database but also update the SPARQL triple store so your queries are refreshed. GraphQL is much simper (as not generic), so the caching story may be a lot easier to reason about. 
Port the dependencies then and stop whinging. I've pointed out above that the "Python Wall Of Superpowers" is getting greener and greener, so anything remaining can't be that big a show stopper. If the Python community can't get together and sort the remaining issues, then Python deserves to die. I simply do not believe that this will happen.
Fair enough. Still, I don't agree with saying REST has issues as much as the fact people wanted something out of it it wasn't meant for in the first place. Sure, in that case, you will find it has issues. Still, REST is about resources, state and representation. GraphQL shows a much richer set of representation's states, but it's not a REST issue per-se. It's a bit disingeneous to say otherwise.
Oh mmm... I know some of these words. I better study more theory :( but all these things are not necessarily Python related, right?
I'd like this as well, but there would have to be a minimum distance maintained, otherwise the packages might form a black hole
Do you really need the notebook interface? If not, you could convert that to a script, and run it automaticallyâ€¦ unless I misunderstood your question.
On Upwork.com python is needed only for site scraping and Django sites. There are more than enough Django experts, even those that are not very proficient in python, but they know Django. So your chances are low. In regard to site scraping, clients usually need to scrape several huge sites with products and save all data about products to DB, those sites often use dynamic ajax requests. Not only that's almost impossible task, but their budget is $50.
My understanding is that lots of things regarding core devs are all ready happening, or at least starting to happen. So businesses are never going to update anything? Stuck forever and a day with an old set of server software, an old set of client software, well if they can afford paid support for that and the installed version of Python lucky them.
I agree with eusebe. I develop in the notebook then copy my script to a file and run it in the IDE or at the command line. I am not sure how you are connecting to mySQL but I use pyodbc and also retrieve the output to a dataframe. Since I am on MS Windows I use the Task Scheduler to run my scripts via batch file.
I was referring to the amount of Python code that users of Nikola write to configure their blogs. The number of lines in Nikola itself is irrelevant because it's application code, not library code, and thus won't "force" any other libraries or application to be ported to/written in Python 3.
Does this do anything that simply discarding empty list elements wouldn't do? Such as: &gt;&gt;&gt; [s for s in 'a1aa2aa3'.split('a') if s] ['1', '2', '3']
It's an attempt to recreate the split function without using the split function.
I've heard of cffi. Does anyone know from experience how it compares to these alternatives in terms of ease of use and performance?
Sure, no problem.
Pretty much the first ones you see in red. Supervisor, mysql-python, carbon, Fabric, etc. I manage some semi-large Django apps, and they tend to have a ton of dependencies.
Looking over the docs you wrote now - this is very awesome and is going to make my job super easy. Just to confirm I understand the docs - this takes the text version of a file I sent you as the input correct?
Do you do any chunking and chunk stitching?
Cool. Edit: and I just discovered fanstatic - an interesting set of packages given I work in OpenStack which I believe created xstatic to solve basically the same problem.
I think http://camdavidsonpilon.github.io/Probabilistic-Programming-and-Bayesian-Methods-for-Hackers/ is exactly what you are looking for :)
transpiler is not compiler... 
I feel like this book was written for me. Thanks for the link.
You import subprocess but don't ever use it? You could try using lxml as well
Yep. But it's probably not a complete implementation. If this is the same human-readable format described for `eet` [[1]](https://docs.enlightenment.org/auto/efl/Eet_8h.html#details)[[2]](http://wiki.openmoko.org/wiki/Enlightenment_.cfg)[[3]](http://blog.fraggod.net/2013/01/16/migrating-configuration-settings-to-e17-enlightenment-0170-from-older-e-versions.html), it looks like there are some additional data types that I haven't implemented yet. It should be easy enough to extend. Given what I /don't/ know about the whole format, a binary reader/writer is a bit over my head. Feel free to add issues on that repo to add new features. It could be easier to query for a value. Currently you have to iterate the Struct.lists and Struct.values, then List.items and List.values to find things. But once you find the right object, you can just edit the property, and dump the top-level Struct to a file with Struct.text().
How useful is SQLAlchemy for little one off projects? Every time I look at it I end up just using vanilla SQL commands and it seems like it takes far more effort to do so using SQLAlchemy. I know that if you end up changing database engines, it makes it convenient to just change one line, but how often does that happen?
you can get a free pdf of Think Bayes. http://www.greenteapress.com/thinkbayes/ check github for the associated code 
Two challenges... I need dataframe tabular output. And, I need to connect to msql through ssh. 
These are EET data files yes. Reading / writing to the human readable format is more than good enough. I'm going to incorporate your work into my neet library that will handle decompiling / recompiling the data files as you write changes. https://github.com/JeffHoogland/neet
Inspiring people to do great and beatiful things (and learn Python meanwhile) is not useless, it's priceless :)
Cool! Let me know if you have any questions.
My thoughts on NLTK here: http://spacy.io/blog/dead-code-should-be-buried/ To their credit, they've taken the criticism on board and are working to improve. They've just accepted a patch that replaces their part-of-speech tagger with my pure Python implementation. This will halve their number of tagger errors, and speed up tagging by about 20x. A ticket is also open to prune unused code from the library.
Though I have not used it, it is my understanding that Groovy can be statically typed or not and since it runs in the Java VM I'd assume it has the same execution profile as Java.
&gt; multithreaded programs can use multiple CPU cores. Do you have an actual use case for this? What specific platform are you targeting? NUMA?
If you're interested in concepts and algorithms there is a Coursera course on Probabilistic Graphical Models; it's great but not based on Python: https://www.coursera.org/course/pgm It sort-of follows on from the Machine Learning course at https://www.coursera.org/learn/machine-learning
didn't went through code but did you used some framework for mobile apps in python or its raw python. If only python how did you compiled and run python interpreter on iOS.
Or a much lesser known `None` parameter with `filter`: filter(None, 'a1aa2aa3'.split('a'))
I'm so happy you liked it! 350k nodes and 900k edges seem totally feasible ([instructions](https://github.com/anvaka/pm#your-own-graphs)). If you need any help feel free to ping me here or on gmail (same user name) - I love this stuff :).
I wish this too! Imagine every website as a node and each hyperlink as a link - what would the Internet look like? Sometimes though I think graphs are hard to understand, and maybe there is a way to render them as maps? Each cluster is a country, each node is a city...
Ah I see you have just learned how to use a full stop!
The app was written in Swift using Xcode. The app uses an API built in Python/Flask.
Definitely an annoying convenience in python2. I tried something like this in python3.4 and... /usr/local/lib/python3.4/dist-packages/mock/mock.py in __getattr__(self, name) 719 if not self._mock_unsafe: 720 if name.startswith(('assert', 'assret')): --&gt; 721 raise AttributeError(name) which is kind of an interesting way of solving this issue.
Sounds like you should look into https://golang.org/ 
I'll take a look at both! Thanks for the suggestions. :)
Crossbar.io works great now that they support Python 3 out of the box. I'm not saying it didn't work with Python 2, but I personally struggled with it.
Uhm, no. Could you elaborate or send a link to reading what you mean? 
There is [Julia](http://julialang.org/). You might try reading about other [languages supported by Jupyter](https://github.com/ipython/ipython/wiki/IPython-kernels-for-other-languages).
What is the science behind the hard numbers you are speaking of? If its the number of downloads of something, are you sure that there is direct correlation between downloads and developers actively using whatever was downloaded? Is it possible you're reluctant to believe the 75% number and are explaining it away? The key question is not "what version does all Python software run?", but "what version are developers using today for their active development?" very different questions. There's a vast store of already built with Python 2 stuff, but it's what people are writing code with today that counts.
&gt; but it's what people are writing code with today that counts. And people write Python 2 code. Some happens to also run on 3, but very little demands it. You can disagree with me as much as you want but that will not make Python 3 any more popular. Ignoring the problem does not help. And yes. It is the number of pypi downloads.
I'm a fan of rust. 
The word for what it does is transpiler.
I don't believe there is an inherent advantage to using object oriented programming. It's just another tool and a way to organize your code. Being that you are new to OOP, you should try it out. It will probably make your code worse initially, but you will learn more about it. Use it on some one-off scripts that don't need much future maintenance. All of python is built on objects. If you become comfortable with OOP, you will be a better python programmer even if you are not authoring your own classes. Now that I've side stepped your question, I will try to offer a direct answer. Writing your own class will force you to think more abstractly about your problem. That may help you develop code that can be re-used easily which could speed up development on future tasks. ... but then again, thinking abstractly can have its disadvantages: https://xkcd.com/974/
Give your introduction in #intros channel, just for a head start.
Have you seen pyjs? I think this is the closet you are going to find (a cross compiler). Also, it's not exactly clear what you are asking for but it sounds like you're asking for web browsers to be python aware and you aren't joking. In light of this, you might want to study up on web standards and how exactly browsers work, as the request is a bit too much to roll up into any kind of browser standard (with any expectation of main stream browsers implementing it).
Don't Jinja2, Mako et al. already provide embedding Python into HTML for templating? One-to-one mapping from URL to filesystem is an antipattern. Flask, Pyramid etc. do it rightâ€”they have a single object representing the app which delegates to user-defined methods based on the request. Once you have that the only reason you'd want to give your templates a special file extension is to distinguish them from plain HTML.
 &gt;Well we clearly have a different opinion on this, which is fine. You are completely right that using the new C++ standards effectively requires you to do some serious refactoring. But it does not force you to do it in order to start using the new standards. It will still happily compile all the old code and lets you decide when to make the change. Or, if you decide to do so, integrate the old code by other means. There is (from the language point of view) never this big step where all code has to be ported in order to use the new C++ standard. A feat which can be especially funny when you inherit an old legacy project with the original programmers long gone. What I was trying to get across was the idea of moving forward with new technology. Even so there are breaking changes in C++11/14, these may be more obscure and frankly harder to track down because you can end up compiling code that doesn't work as it has in the past. That doesn't mean however it is as extensive as some of Pythons changes. In either case you have to rework your code. &gt;If you think excommunicating all Python 2.7 users from the community is a good idea, that is certainly a valid opinion. I just hope the price won't be many abondoned projects because people are alienated from their community due to the constant influx of hostile actions that the original posting encourages. I like to think of it as leaving them behind. Abandoned project though happen all the time, here are so many in the Linux or open source world I'd hate to even count. Eventually projects get supplanted with new technology. If people have an affinity for old tech, they can pick up a project but the masses move on. Seriously look at the number of X11 Windows managers that have appeared and disappeared over the years. Even X11 is on the way out. My big concern with the Python community is that many projects have taken years to convert and without a good excuse other than I don't want too. Rationally there are good reasons to go with Python 3, I see it as a big improvement over the 2 series. &gt;I mean, if you want to stop supporting Python2, that is fine by me. But why step on people who don't? Because I don't see it as stepping on people. I see it as leaving people that can't adapt behind. It isn't like this is something new in the world of software. I just see the Pythons community as being a bit slow to push old tech aside and get on board with the new. If Python 3 wasn't a big improvement over the old versions people might have a good reason to stay on the 2 series. I just don't see a good reason. To stay and in fact see good reasons to move forward. 
Classes are useful when you have a group of similar objects, that you're are likely to inherit and use more then once within an application. There is no imperative to use them on smaller scripts. I tend to just stick to functions myself. 
The lower() method to convert all string value to lowercase. The upper() method is used to convert all string to uppercase. Example of lower() method: answer = "YES" x = answer.lower() print(x) Output: yes Example of upper() method: answer = "yes" x = answer.upper() print(x) Output: YES Go to the official site of Python to learn the basic of syntax here -&gt; www.python.org
Javing in Python for begginers.
[Kivy](http://kivy.org/#home) is a python framework which lets you deploy to iOS (and android and windows and linux).
ok, so every time i run cursor.execute(mySqlString) data = cursor.fetchall() the cursor fetches from the live and up to date database?
Hmm. So there is a good reason to write in Class Structure. Thank you.
I do write functions, but feel kinda of guilty for not writing Class based code in a Object Oriented Language
Utility is not the only measure of worth.
With SQLAlchemy ORM you do not need to write lengthy SQL Queries, you can do "User.query.get(id)" which is equivalent to " Select * from users where id = user_id" An ORM maps tables to python classess and columns to class objects so its easy to write more pythonic code. I have been able using ORM in my projects and it has not only made my code easier to read but faster to write. You can scaffold a CRUD app with Flask and SQLAlchemy with https://github.com/Leo-G/Flask-Scaffold. This will give you a better idea of it works and whether you should write your current code in it 
What's up with SWIG? I know wxpython's wrapped in it, and I fuckin' bum that library so much. Seemed pretty good to me.
With SQLAlchemy ORM you do not need to write lengthy SQL Queries, you can do "User.query.get(id)" which is equivalent to " Select * from users where id = user_id" An ORM maps tables to python classess and columns to class objects so its easy to write more pythonic code. I have been able using ORM in my projects and it has not only made my code easier to read but faster to write. You can scaffold a CRUD app with Flask and SQLAlchemy with https://github.com/Leo-G/Flask-Scaffold. This will give you a better idea of how it works and whether you should write your current code in it 
[Cython](http://cython.org) is a super-set of Python that can [overcome the GIL](http://lbolla.info/blog/2013/12/23/python-threads-cython-gil). You can stick with (most of) a language you like, but make types explicit and sidestep the GIL when it's useful.
Yea... he maybe and that's the part I am calling silly because to expect that to ever happen is just the biggest wish every when it comes to web standards. I am happy as a web dev when my html looks the same in multiple browsers, god forbid trying to get all these monkeys to do a group dance and add a bunch of bloat to their browsers such that they can interpret python in any seemingly consistent manner. Am I the only one here who thinks this is absolute asinine?
This is why the question seems silly to me. Jinja2 already has this functionality and the redditor mentions jinja, so it seems like they are asking for this functionality in a effectively a plain text file that can be rendered by a browser without a python webserver. Seems like there may be a lacking understanding between the difference of a web app and a web page.
Exactly. I never understood all this GPL hate. The people who shout most against GPL are big corporations, ones who *could* afford to buy a license. This is a great answer on this here: http://opensource.stackexchange.com/a/210/1053
You would probably like http://nim-lang.org/ Its syntax is inspired by python (though not very pythonic in the elegance sense, since it has a syntactic form for every feature of the language... and there are a lot of language features), but it compiles down to C.
Cool.
If you're interested in rust, DEFINITELY dive in. Don't think it'll be as straight forward as Python though.
If you haven't tried a functional language I'd recommend learning one in depth. The mindset and understanding will make you a better programmer even if you don't use them often.
&gt; PHP is interpreted server side I have had my fun in PHP. To me, the question is asking for client side python. If they wanted a server side solution, jinja is already there as they mention in the question. The template is then rendered to html server-side like PHP (this is the traditional web server approach). The question here seems to suggest they are looking for some kind of standard web extension such that the python can be used to create any old web page. pyjs might be what you are looking. I personally don't mind cross compiling and if the readability you gain from a pythonic syntax persists in pyjs (I have not tried it), then I think the gains there maybe worthwhile. However, my point persists, if you expect python to one day run in browser and to have any kind of consistency/support among major browsers, then you are drinking some serious koolaid. I won't say browsers will never embrace such a readable language as part of the standard but it seems unlikely that it will happen before another language displaces python in the ecosystem (simply because the web "evolves" at a rather slow rate given the complexity of the standards behind it).
A souped up IDLE and a teaching tool. Yeah I think I'll stick with pycharm and atom/sublime. 
I recently built (and am still building) a new JSON library based on the fast RapidJSON C++ library ([github](https://github.com/kenrobbins/python-rapidjson), [pypi](https://pypi.python.org/pypi/python-rapidjson)). It only works with Python 3, but it would be interesting to see how it compares in your tests.
I think that you are a nice guy, but most likely you're breaking the Terms of service of their website by logging in with credentials that are not yours. From here: https://www.citibikenyc.com/terms-of-use This: You must not attempt to use another person's Account, service, or system. While what you do with the username/password is "mostly harmless" I think it's a bad practice to request users to trust you with un-encrypted passwords for another website. Usually sites allow you to identify users using OpenID/OAuth (eg. steam api/ facebook login, etc). This doesn't seem to provide any kind of service like that, but it doesn't mean that it's ok to ask for a user's name/password for it. More than this any vulnerability on your servers will cause their servers to be exposed since users sent their plaintext passwords to your server. If they have payment info there, then it's even more dangerous / and maybe illegal. Regardless, while you probably had the best intentions, I must say you are doing something quite unsafe for your users.
They're for completely different purposes. IPython is primarily for scientists and isn't super useful outside of that. You wouldn't write a script in IPython just as you wouldn't do statistical analysis in Sublime. 
I use PyCharm for all my larger python projects creating a new project and starting to type the first python file takes maybe 10 seconds at most and on top of that it interfaces seemlessly with a lot of VCS like GitHub so I can create a new project, write a readme.md and push to my github account in just a couple minutes That said I still use IPython for a lot of things like prototyping new algorithms, creating short scripts to generate plots that I'll need to look at repeatedly for references, etc... but its by no means a replacement to an IDE
I use both pycharm and ipython. For most exploratory projects I'll open pycharm and ipython simultaneously. Generate the project in pycharm but do the module development/experimentation in ipython. When it seems to be working I roll the cell(s) back into a new or refined module in pycharm and continue refining them. Pycharm gets messy really quickly if I try to experiment in it; the ability to cut and paste new cells in ipython is ridiculously handy. I can leave the test string/list/dict in the top cell, along with the boilerplate elements, and try four or five different logic sequences in different cells. No more commenting out chunks of my code or having test1.py, test2.py, test3.py just to see if one way is actually superior to another. And then, when it's done, I leave the experimentation notebook in with the project because 9 times out of 10 I'll end up wanting to revisit that analysis three months down the road when I'm facing a similar problem. 
&gt;I used IDLE for a long time, but its shortcomings start to catch up with you: Eh... &gt;Pressing up moves the cursor up, and doesnâ€™t run the last instruction (which is the default behaviour on most command lines) Because Alt+P is hard right? Plus, having the arrow keys free to move around the for loop you're writing or whatever is real nice. &gt;Working with files/directories on your disk is a nightmare (you have to use horrible ways like os.get_cwd or os.chdir). What? If you want to use a file, you need to go where it is? ... You mean like with anything? [Also](http://i.imgur.com/2feVlg0.png). &gt;The GUI is ugly. Real ugly Nice subjectivity. You just wanted to go for the rule of threes 'cause Dickens reckoned it was the shit? &gt;While there are other IDEs Aha, time for some good points. &gt;many require you to spend six hours creating a project what &gt;when all you want to do is run 5 lines of code. Why are you not using the command line then? Also wtf, no, PTVS, the best IDE there is for Python, opens up to an interpreter. [Observe](http://i.imgur.com/huSrvqZ.png). &gt;there arenâ€™t people shouting OMG! IPython is the best ARE YOU SURE BRO. &gt;If you import a library, say Pandas, and forget which function reads a csv file, pressing tab will give you all possible choices: [Revolutionary](http://i.imgur.com/6PY1GlO.png). [Oh hey I don't even need to press TAB here; intellisense deals with it for me](http://i.imgur.com/XUdnq5J.png). &gt;This works with local variables as well: [Impressive](http://i.imgur.com/c4G0OlQ.png). &gt;Try doing that with IDLE. [Diabolical. It's so horribly pythonic, you're right, WHO WOULD WANT THIS?](http://i.imgur.com/oVUpGK6.png) &gt;We can also run any Python script from within IPython using %run: `import` &gt;What if you want to run other system commands? `os.system()` &gt;What if you want to see which variables you have defined? `locals()` &gt;Or embed your graphs directly within IPython: An actual good point, finally. mpl.show() leaves a lot to be desired, but that's actually pretty niche. Anyone who uses mpl already uses IPy. &gt;IPython Notebook Are we on to all the good point now? Finally? ... Oh, no, that's the end of the article. ----------- I'd say you made a solid effort. There are minimal typos, and the subject isn't blatantly wrong, but it reads like someone who doesn't know much about a subject was forced to write about it, or someone who just picked up something cool and wants to tell everyone about it.
I don't use an IDE (but have mostly stuck with Sublime/Atom which essentially become IDEs with enough packages). This pretty much hits the nail on the head. IPython notebooks are meant for two things. One, prototyping scripts/any sort of scipy stuff. Two, creating and sharing tutorials.
start to finish, 37 days. Prob about 8 days of actual development.
How do you do that? The notebook makes .ipynb files and the Qtconsole doesn't have a multi-line editor. Do you use magic commands to save the .py file?
You used swift to write this app but you never knew it before. In this situation ,only taking 37 days. 
Downloading a .py file from a notebook is two clicks, or you can run nbconvert to strip the json and keep the code. 
It fetches the latest consistent revision from the DB. It may very well be that there is an uncommitted update or insert just about to resolve within a few milliseconds but your query finished before that new revision was considered valid. You can use triggers to call an external user defined function that sends a notice to a queue or Redis box whenever a key changes.
TIL, thanks!
That's all I need Python for in my job (neuroscience) so IPython is perfect for me :)
I heard vs2015 is even better for python. I've hesitated moving to it until I finish the project I'm working on now though. But intellisense is dreamy. Anytime I switch back to an ipython notebook for visualization prototyping I'm hit in the face with the ugly reality that I have to actually type code myself again.
That "funny" _io module is the way that CPython implements modules in C. There are several more of them, e.g. _csv. Typically the Python module attempts to import the faster C code, but if it can't it reverts to a pure Python implementation. To answer your question, from [class io.RawIOBase](https://docs.python.org/3/library/io.html#io.RawIOBase), second paragraph, *"Raw binary I/O typically provides low-level access to an underlying OS device or API, and does not try to encapsulate it in high-level primitives (this is left to Buffered I/O and Text I/O, described later in this page)."*. This is the super class for io.BytesIO. I could not find similar wording for io.StringIO.
Nice work, although a little bar chart here and there would make the results easier to understand
My main focus these days is applied machine learning, and pycharm does just fine. What would be the benefit of IPython?
Number of consumers
&gt;&gt; The GUI is ugly. Real ugly &gt; Nice subjectivity. You just wanted to go for the rule of threes 'cause Dickens reckoned it was the shit? Honestly, I don't want to take advice on how "ugly" something is from someone who has a website design that over-rides the default scroll functionality of my browser such that it handles differently to every other website I've ever visited. Leave my scroll speed/length alone, people! But really, I wish people would stop brining out "it's ugly" as if it's some actual argument for/against something. If you really want to make this sort of argument, at least do it with regards to something like GUI ergonomics, colour design theory, etc, such that you can actually offer a valued reason for why we should consider one particular GUI over another.
IPython is awesome, but arguing that it replaces IDEs is definitely the wrong way to go about convincing people. Also, the part everyone uses isn't actually called IPython anymore. It's called Jupyter, and it is language agnostic. You can run an R notebook or a Julia notebook or a Go notebook just as easily as you can IPython. What makes Jupyter awesome is the things it does that traditional IDEs do not do at all, or don't do well. Iterative, experimental algorithm design, tutorials, reproducible scientific research, documented data analysis - those are where the Jupyter Notebook shines. Replacing IDLE is not the point at all. What makes regular IPython awesome is that it's a REPL with some nice syntactical sugar and syntax highlighting. But it's still just a REPL, and mostly does the things you would use a REPL for.
You may already be aware, but Fabric has spawned [Invoke](http://www.pyinvoke.org/) which is Python 3 compatible. It's basically Fabric without SSH, so depending on your use case, it may or may not be useful.
I just started using PyCharm last week and am already in love with it. I went back to IDLE yesterday to see if PyCharm had really done anything for my coding and I was fumbling around not being able to autocomplete things and having to guess which function had which arguments and in which order
 I'd add that because of all the reasons you just listed it is also a great teaching/presentation tool
Ah yes, another civilized thread on the un-biased topic of IDE preferences. [Should be an enlightening read](http://media.giphy.com/media/vjwACwDxB0hZ6/giphy.gif)
Exactly. IPython is great for iterative things or exploration where you make small changes to the code and continue to build on it.
I did give rust a try, its good, excellent tools, but I found the learning curve steep compared to the likes of nim or golang. 
Haven't played around with it at all since the big split, but in the past I've used custom css to modify the look of the ipython interface. I really don't see any reason why this isn't something that could be extended and easily modified. 
cool, thanks for the confirmation
LOL ! Good analogy. Pointed duly noted Sire.
Thanks for writing this up, Martijn ! Remember the conversation we had last year on a similar subject ? https://www.reddit.com/r/Python/comments/2nho4v/morepath_09_released_the_web_framework_with/cmeel8h 
Does anyone use a different logging format for different log levels? I know it's possible with a custom Formatter class... Curious how people are using 'logging' to get the most out of it. It is so powerful!
Original author here. Yes, you are right, it's not an IDE. The blog was written slightly tongue in cheek, and after being frustrated with IDLE and an IDE that shall remain unnamed. When I then used IPython, it was like wow, why did I struggle so much? That said, the *Ipython Notebook* is more than an interactive shell or text editor. I think the Notebook is a great way for teaching, much better than the methods we have currently, where half the students fail to install all the dependencies of Python (some of which require a full fledged C / Fortran compiler), and half the class time is wasted bringing everyone up to speed. Something which really blew my mind is the temporary notebook project: tmpnb.org
I always like to think of IPython as a kind of living document. It's really good for showing things and teaching and I imagine there will be several published papers using it as you could feasibly have your source code embedded in your paper that demonstrates your point. Alternatively you can use it as a teaching resource for homework, this is a list, this is a for loop, now play with your for loop to do x, y, z and have tests that run after you alter the code block for interactivity. Some of that stuff already exists online but it's not quite the same as running a python interpreter like this. and I agree the cool features are not the shell features the cool part is you can do shell stuff inside the notebook with more potential ways to work with it. 
Let me clarify - I'm not trying to win you over to use PyCharm or suggest you shouldn't be using Sublime. Apologies if my responses came off that way. For me the at most 30 second delay in opening PyCharm is no big issue as I rarely have to open it more than once per day. I have yet to have an issue with something freezing up requiring a full reboot of PyCharm. To be fair, I develop solely in python so I've yet to have a need for using multiple languages save for some CSS/QSS here and there in my GUI's 
https://en.wiktionary.org/wiki/condescension
Consumers?
People who get this excited about IPython and are using Windows should try Linux. It will blow your mind.
A full DL of IPython includes Spyder which is an IDE.
Hmm.. that's what I was thinking. So basically I have the main script which calls the others in the directory. Can I put a wrapper or something around the first script to achieve this? My first thought was to just make a bash script or whatever that did something like: #!/bin/bash cd &lt;location-of-virtualenv-installation&gt; ./first-script.py
One point that might be worth noting (although the benchmark looks perfectly valid) is that pypy does take a while to warm up. If you're running it as a command-line tool, those are the times it's gonna take, that's the deal. If you run it as a service, you'll see faster times as you run it multiple times, try for yourself running the same benchmark couple times in one process.
Sorry, on mobile. I know there's (was) a soon to be deprecated flag that would allow for relative virtualenvs. I've definitely either used it before or made a workaround. Keep trying, if you can't find a solution I'll post back. 
IPython is great with ein. 
iPython refers to the Python Interactive kernel. iPython has switch to a kernel agnostic project called Juypter to show partnership with Julia, R and Python.
&gt; You can even mix and match That's how one creates a giant fucking mess. Mix and match messages == mix and match parsers. A terrible idea. Seems you're missing the whole point of JSON encoding: separating message content from message format. One can marry all sorts of message producers to any sort of message consumer, without having to worry about parsing, using JSON. &gt; format could be affected by audience I don't even know what that means. You might be thinking of an MVC pattern, which keeps the data, its native format, and the presentation of that data all separate. Seems you're not familiar with separation of concerns... &gt; different audiences might use different transports Transport is how data gets from A to B. What does the format of a log have to do with that? You're very confusing.
Gotcha, thanks! 
Same boat here, only thing I use an IDE for is Java.
I suppose repeated concatenation would be similar to `''.join(list)` And should have similar runtime as `write`, since in-memory buffer doesn't have caching behavior? Correct me if I'm wrong, so, seems like the only reason we have `io.BytesIO/StringIO` is to have the file interface without writing data to disk.
&gt;marshmallow is an ORM/ODM/framework-agnostic library for converting complex datatypes, such as objects, to and from native Python datatypes. Yet another changelog post that doesn't actually say what the fuck the thing is.
Fair enough. Added a brief intro section.
Is it possible you've never written a project spanning more than a couple of hundred lines?
Exactly what /u/kurashu89 said. While it's fairly powerful and will do most things out of the box, it still requires that it be given some attention in that you need to assure your upgrade/rollback scripts are as bulletproof as possible. It dramatically simplifies performing blue-green deployments *[and rolling back if necessary]* to the extent that it's ***almost*** like just rolling code back.
&gt; I want to be able to just tar the directory and have the person I send it to run the scripts without having to change anything on their machine. Don't do this. Ferchrissakes, this is only one level above printing out the source code and fucking mailing it to your peers. This is the 21st century, we aren't Neanderthals handing stone tablets to each other, use something a little more sophisticated than a sneakernet. Seriously, if you do this you've no guarantee that the code will even run on someone else's machine. Even if it does, there's no way to track what they're running, how they're running it, etc. Many headaches will ensue when something goes wrong. Time will be sucked into a black hole, and you'll have learned nothing from all the effort. https://docs.python.org/2/distutils/setupscript.html If you're going to distribute Python code, package it up and hand over an eggfile. Even better, put the eggfile on pypi or artifactory or your own private pypi server and have others download it with "pip install". Easy peasy. Yes, the docs are a lot to read, what is all this confusing bullshit, it's so much easier just to hand off a tarball, etc. etc. Stop bitching and start reading the docs... it's really not that much work. All you have to do is write a small setup.py script, run the script "python setup.py install" inside a virtualenv to test it, then when it works, package it up "python setup.py sdist (or bdist)" and hand over the package. Bump the version number before you make another package. Done. Need help? PM me. Or use Google. There's only 1,000,001 tutorials on this very process... 
Text editor no, but I do this a *lot*: 1) IPython.embed() 2) Write some code in the shell, taking advantage of autocomplete. 3) See it run. 4) Copy and paste back to text editor if it did what I wanted. 
I was in the market for similar, but ruled out Go after using it a bit for myself. It's an awkward middle ground that IMO doesn't make sense to use, not much of a job market on the whole, but plenty of hype. A big reason for this is my belief that multi-Pthreading has no reason to be used outside of systems software and game engines (neither of which Python is the best choice for). Given what you've said, I would look at C#. Like Python it's just used in so many places. Or if willing to use another dynamically typed language, Erlang, depending on your goals.
Yeah, I got a sense that Go was a case of [XKCD standards](https://xkcd.com/927/). I have played with C# a little, ages back, and remember it being very high-productivity. Slapped together a nice little desktop CRUD application for a database in a day. Also as you say, people are hiring for it. I'll probably finish screwing around with Rust and Haskell in a week or two, and decide C# is really what I was looking for all along.
[Image](http://imgs.xkcd.com/comics/standards.png) **Title:** Standards **Title-text:** Fortunately, the charging one has been solved now that we've all standardized on mini-USB. Or is it micro-USB? Shit. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php/927#Explanation) **Stats:** This comic has been referenced 2032 times, representing 2.4249% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_cvix7yn)
Should also include ijson, super cool tool for super large JSON.
those who depend on a package (i.e. consume a package)
Will it get open source like sharelatex?
If your projects are written intelligently with proper organization a text editor is fine. If you find your project has gotten so large and complex that you rely on an IDE to help you it may be a sign that you need to factor some stuff out. 
From the Bayesian modeling side, Andrew Gelman and others have a ton of modeling software. Gelman wrote one of the [de facto Bayesian modeling text books](http://www.amazon.com/Bayesian-Analysis-Edition-Chapman-Statistical/dp/1439840954). Krushke has the [other mainstream book](http://www.amazon.com/gp/aw/d/0124058884/ref=pd_aw_fbt_14_img_2?ie=UTF8&amp;refRID=152AZJMKXMD921GHFZYG). Bayesian modeling has grown around a couple tools: [the original, winbugs](http://www.mrc-bsu.cam.ac.uk/software/bugs/the-bugs-project-winbugs/) and one of its descendants, [stan](https://pystan.readthedocs.org/en/latest/). There are a bunch of modeling resources surrounding them. But you'll find people prefer to convert their models into a graphical modeling language that bugs and stan read. The think bayes book is fantastic for beginners, though. If you want to proceed into the level of a graduate course, see Stan. Gelman's group really has fantastic resources. If you want to find some good Bayesian papers, start off with learning about distributions (Bernoulli, binomial, beta, categorical, multinomial, Dirichlet, Gaussian). Maybe try and write a sampler (data from parameters) or estimator (taking data and inferring parameters) in python. From there, try a Gaussian mixture model. Those are a really good application of Bayesian methods. Especially if you use expectation maximization to learn the model.
Geany already does that anyway, but the really annoying part is that it opens another window. That means changing focus away from the terminal, and switching back is a nontrivial set of keystrokes. It's much easier, especially if I'm only editing a few lines (and I'm always *just editing a few lines*) to simply open up nano. It has syntax highlighting and a decent copy-paste. Only problem is the auto-wrapping.
Wow. I didn't know people still used TextMate.
Probably Microsoft Windows, poor things. 
I have a long interview tomorrow, but if no one post by 6 PM PST , I can give it a shot
`%history` will print out your past inputs, even from sessions prior. ipython also stores input and output from the current session in the lists `In`and `Out`.
Ah, ok. I knew about In and Out, but there didn't seem to be a fast way to get that to the clipboard (without writing a loop every time). %history sounds useful.
Indeed. While I have both a Linux and Windows machine, I can't dictate what the learners will have. Since Windows is still has the market share, we are stuck with it.
Sends a POST request to https://accounts.zoho.com/login?servicename=VirtualOffice&amp;hidesignup=true&amp;serviceurl=http%3A%2F%2Fmail.zoho.com&amp;hide_secure=true&amp;css=https://www.zoho.com//css/prd-sign.css with the following post data LOGIN_ID:xxxxxxxxxxxxxxxxx%40zoho.com PASSWORD:xxxxxxxxxxxxxxxxxxxxx IS_AJAX:true remember:2592000 iamcsrcoo:aaaaac02-3a94-40fb-a5e9-0e25099a3c87 you can get the xss tokens from the cookie like below: http://stackoverflow.com/questions/26364376/login-to-zoho-reports-via-a-post 
Is there there any good(faster) alternative to standart json in pypy?
I've gotten tired about using the term "REST" in the purist way while everybody else talks about REST they mean HTTP API with resources and no hyperlinks. I see REST best practices documents over and over again that don't even *mention* hyperlinks... I started to use "Hypermedia API" for true (HTTP) REST.
Yes, I remember. At that point I looked at JSON-LD as a way to solve some of the issues with REST, as it has some support for embedding sub-resources directly in a response. I did some work with it, but I think ultimately it's not a great fit for UI frontends either. I'm more interested in GraphQL and Relay from a development productivity/simplicity standpoint than a performance standpoint (though it can help with that). I learned a lot about the Flux pattern this year, and how a single page app can isolate accesses to the server in a special layer, and that goes into a similar direction. The React community is pretty good at introducing mere mortal software developers such as myself to functional programming concepts. If one cannot use GraphQL, it may be worthwhile to look at a more fine-grained way to use REST that supports subresource embedding, as I described in a previous blog entry: http://blog.startifact.com/posts/graphql-and-rest.html 
lol
I thought he was a programmer with a new compiler until I looked.
How often is Go Lang seen outside of Google?
sphinx
The Community version is.
Here's a starter [Python Success Stories](https://www.python.org/about/success/).
You are in an echo chamber, lots of people are fine with Java and C++. The time you spend actually typing keystrokes is a very small percentage of time spent coding. Python doesn't have a monopoly on libraries - Java and C++ have been around so long their existing code bases eclipse what Python has available. You can argue that the additional structure imposed by Java/C++ make coding more challenging, but constraints can be useful on large projects (even more so when you are working with coders of varying skill).
&gt;it really pisses me off that it doesn't have an enforced PEP8 syntax I really wish I knew what you were on about :P Thanks for the help!
Which application is used to create those kinds of graphs?
Which application is used too create those kind of graphs?
Look up Sphinx - it's the tool designed to build documentation for the python language! It's support for python and ease of use is thus as good as you could hope for. 
[PEP8](https://www.python.org/dev/peps/pep-0008/) is a document that describes the style you should write Python in. It's a must read for any Python developer. In some editors, there's a way to force compliance to PEP8, or at least notify the user when they fail to do so themselves. Usually this comes in the form of a 3rd party plugin for editors such as Sublime Text, Atom, Vim, etc.
I think it depends almost 100% on where you're coming from. I've been a developer for about 15 years now, and the assertion that Python is not being used enough goes against my experience. Many colleges don't use Python as a teaching language because they already have perfectly good course material for Java and they don't want to rework it. Most big businesses (e.g. IBM, Ford, etc) do indeed use Python, a little, at least for something; maybe a few web services, or maybe some scientific number crunching. Those companies might say they are a "Java shop" or a "Microsoft shop" but there's Python in there somewhere. Many big businesses and well-known startups (ala Google, Dropbox) use Python *a lot*. If Python disappeared tomorrow, those companies might too. Hundreds, possibly thousands of developers program in Python full-time at these kinds of companies. So if you're only talking to people who are not really in the industry, like maybe your college professor who hasn't done any nonacademic work in a while, you might believe Python isn't being used, but it is, pretty much everywhere.
Ah, that sounds good. I have Sublime Text on my Mac and use that for a lot of Lua coding over FTP or svn. I want to edit files locally and be able to run scripts with a keystroke, is there like a name for this feature?
Yeah a lot of the benefits of Java come from working in a team, which the OP wouldn't have much experience with if they're just starting out. It's a whole new beast going from the only dev to a team environment.
People tend to complain about the languages they are told to use. ;-)
The JVM has been nice and quick since 1.3. It's gotten much faster since then, but it wasn't a slouch in 2000. I agree on the NPAPI noise, though. That was always a bad idea.
Could you explain why PyPy is not a real solution?
I believe you can do that per default with Ctrl+B in Sublime. Maybe Cmd+C on Mac, I don't really know.
&gt;Also, I write games. As a hobby. Python REEKS at this right now. It's the worst. I don't see any efforts on the horizon that might help solve this, either. For me, [pyglet](https://bitbucket.org/pyglet/pyglet/wiki/Home) is a silver lining. It's far from being comparable to frameworks in other languages, but it's so much fun to write with. I find it to be the best tool yet for writing (simple) games in python, although that's only because it's less horrible than its 'competitors' PyGame, Cocos2d, Panda3D and python-ogre (++). I can't think of a single real reason to use PyGame over pyglet except for the fact that the former has more tutorials and documentation written for it. Bear in mind, I'm not saying game development on python is viable because of pyglet, it's just the pile of dung that smells the least to me.
A lack of motivation to support Python 3.3 syntax (and now there's 3.5 syntax they don't support, either!) is my main concern. Even with Python2 applications things get... strange. I worked on a large project that was having performance issues, and one of the developers was having a lot of trouble getting our test suite passing in PyPy. If you start your project in PyPy, I suppose that it would not be so bad. I was not impressed, though.
Sure, you can. I'm a huge fan of type inference, myself. I think that there's even a JEP for adding global type inference (but I can't find it). Java already supports generalized type inference in Lambdas.
Yeah, I toyed with pyglet, but It wasn't really all there. A lot of simple stuff is missing. It was not an enjoyable experience. I really wish that someone would do something like LÃ¶ve for Python (but more 'pythonic', obviously). I'd considered doing it myself, but I have trouble finding the time for such things.
Honestly, from my first look at C# I couldn't imagine ever going back to Java for anything ever again. Maybe that isn't everyone, but.
Sphinx isn't quite the same - it's aimed at more manually curated docs, although it does have [extensions](http://sphinx-doc.org/extensions.html) that let you include more automatically generated API doc pieces (see autodoc and autosummary in particular). I think the Python community is generally less keen on fully autogenerated API docs, so tools like epydoc aren't so well supported. Of course, that cuts both ways - if there were better tools for generating API docs, we'd probably like them more.
Regarding all the extra code, you should definitely look into using `live templates` or `snippets` or whatever IDE/editor you're using provides. It saves you from most of the annoying boilerplate code. Secondarily, sure there is more word on the screen, but regarding the "silly little syntax mistakes" if your editor isn't catching them before you compile you should look into your settings configuration. Don't get me wrong, I love Python - but Java still is usually a better choice for large scale, large team applications that need to be performant. If you're doing simple content/crud ops or something with a lower load - you'd probably see almost no perceptible difference from a well configured flask or django server with uwsgi and nginx ahead of it. C++ too he a nitch, I wouldn't write a web server directly in it and would rather rely on the abstractions other languages provide, but if you're doing low latency network sockets for high bandwidth throughput - c++ is probably s better choice. Especially if you need fast start times. That's one common comparison: Java and c++ can hit similar speeds on a running application, but Java boot time is typically much slower than c++.
Suppose I'd have to ask what you mean by the "Enterprise" I work on a site that has a few million registered users and we use python extensively. Does that count as an "Enterprise?" I think the tool chains have just evolved differently. Java in particular lends itself nicely to middelware endeavors. It has great XML support. Lots of tooling tailored towards safely exchanging data. Lots and lots of pre-packaged vended products that come with oodles of support. Python lends itself more nicely to scrappier environments. Times when you have to walk a bit outside the box. Where duct tape solutions are a real thing. I find the lead times on features and fixes to be lower. If the team has that "scrappy" mentality and aren't particularly dependent on commercial products then python is a good choice. It has lots of open source libraries to lean on and the out-of-the-box solutions anecdotally tend to be a lot smaller. This means they lend themselves better to composition(as opposed to the comprehensive solutions you tend to encounter in java/c#). The downside is developers have to roll their sleeves up more often and have to know a little more about how everything is wired together. This is something that Java/C# communities have traditionally gone way out of their way to avoid. Additionally there are certain specifications(SOAP as of the last time I checked) for which python has very scant support. I don't think its a matter of "Being ready for the enterprise" but instead a question of "What sort of enterprise are you trying to build and what are your constraints?" that dictate your language selections. Additionally I think the days of being a "Java shop" are waning. The future seems a little brighter for "Right tool for the job shops" 
I have been using TextWrangler to do all of my editing (Matlab, Python, LaTeX, Markdown, plain txt) for a while. It is the free version of BBedit but does just about everything I need (though I am probably not a super advanced user). The best feature for me is the SFTP support. Not only can it open from SFTP (which a few editors including Atom with the right package can do), but the key is I can open from SFTP with a url. From the terminal, I can write edit sftp://user@server/path/to/file (`edit` is TextWrangler's command). This allows me to have a script on my remote server that sends (via SSH with a key) to my mac to open the remote file. Therefore, if I am SSHed into a remote server, I can still type `edit file` and it will launch the file. Is it the best? I can't say. All I can say is that it meets my needs. I am keeping a keen eye on Atom though. If an extension allows me to do this kind of remote edit commands, I may try switching
If you already have sublime, look at downloading the Anaconda package for Sublime. That has insight completion, PEP8, goto definition, and too many goodies to list here. It's as close to a fully functioning IDE that you will find in a text editor.
Do you have a link? Searching for "love" is going to bring up some unrelated results. :)
Also, you might consider giving iPython notebook a go (install using [pip]( http://ipython.org/install.html)). There was decent post [here](http://pythonforengineers.com/why-ipython-is-the-best-thing-since-sliced-bread/) that lists some of the perks. It's a great demonstrative sandbox for python, and I bet you'll never use IDLE again after using it.
If that's the case I would recommend you show your students chocolatey and have them use that to install python. Learning what paths do is super important so teach that but just have them use that for installation. It goes from a 3hr process your first time to about 5 min
I've had to wrestle two large codebases in Python. It was orders of magnitude harder than with Java like languages.
People like it because its easy to write but its slow and cant scale to large applications. its that simple
&gt; not strongly typed I think you meant "not *statically* typed" (Python IS strongly typed.)
Regarding the editor, yes it does catch them (Eclipse) but my point was that there is more to begin with. It's just something I need to adapt to coming from python where semicolons, curly braces etc aren't a thing. Although our prof does have us writing in Notepad++, compiling with javac and running with java.
I love C++ and have done it for years. But to be honest, I don't write templates, and would use D instead if it had all the libraries C++ has. To me using Python seems to be more a thing for 'hireability'.
&gt; You are in an echo chamber, lots of people are fine with Java and C++. Right. I love python but [Unreal Engine](https://en.wikipedia.org/wiki/Unreal_Engine) is C++ rather than python (or Java) for a reason. Given the power of C++'s STL and BOOST libraries C++ is pretty darn good. 
IMO, lack of static typing _by default_ is holding python back. Static typing makes code clearer, makes performance easier to improve and IMO is the more powerful way of programming. But, of course, C++ lacks things like simple one-action iterators, and a lot of the beautiful smoothness that Python gives you. For a large task, I'd come down to something like Python VS C++. For games I've chosen C++, but for anything internet or data related, Python is an easy decision for me. But the fact Python isn't easily compiled and performance is a little lacking makes it normally impossible to create a single binary blob that works without getting too large, and without dependencies. Header-only C++ libraries for things like games and data structures means you can make a very small and sleek executable. The same can not be achieved with Python.
Why not use PyQt? Other than the fact that finding good examples of using the view/scene/graphic item system, once you learn the basics of it, it's actually fairly intuitive. I've been using it to make simple graphic games.
The time you saved from typing less is more than taken up by writing unit tests to ensure it work correctly, unless you don't care about quality, then Python really help you to cut corner. Python is dog slow. Hard to make change and refactor in large project. Hard to maintain. Have to constantly writing unit tests to test simple stuff that should have been caught by the compiler. The lack of backward compatibility between 2 and 3 sucks. GIL sucks. Threading sucks. Parallel support sucks. No real lambda support sucks. Yeah, for toy projects, for simple scripts, for learning it is fine. It's just not up to the task for serious projects.
Funny how you mention boost and Unreal together like gamedevs actually use Boost? It doesn't even build on most console compilers. Also, the C++ Standard Library is not the STL (that's an older product), but I am sure you know that so I'll leave this here for the benefit of others. Edit: Do I ****ing seriously have to tell people that not all STL code builds under standard library?
And people in their 30s+ making content... I think.
&gt; Note that if you don't get a license, you'll get pop-ups about buying Sublime sometimes. You wouldn't have to stop using it, but it's annoying nevertheless. It's about once per day, not even close to irritating. Getting a license is totally worth it, too.
Every 10 saves. If you're only see it once a day, you need to be saving more often.
Cmd-B on Mac. Most of the shortcuts transfer with simple modifier key change.
The project I'm on is written in Python and is literally called scrappy.
if your using requests then r = requests.get('url') then the cookies will be in r.cookies in a dict. The remember and iamcsroo should be stored in there
https://docs.python.org/2/library/time.html#time.strptime
If you don't know the format, I suggest `dateutil` : http://dateutil.readthedocs.org/en/latest/parser.html
Bless you. I'm really struggling here.
YouTube uses Python. That's enterprise, right?
I think all of these sites have two or three people making all the (original) content. It's a conspiracy to keep us from paying attention to the REAL issues! /s
GPL/commercial license only might be an impediment.
Ah, but here you are talking about programming help such as API questions. But this is a separate subject from the original issue which was programming language popularity. This is related to general programming news, trendy languages, interesting projects, new development methodologies, famous projects in language X. That is the bread and butter of r/programming and you don't get that so much from your co-workers, as they are more likely to be similar to you, and not different. Similarly, it's hard to find books on it.
That's what I landed on, though I do keep an eye on all this other, more esoteric stuff like Rust, Haskell and mostly Erlang. I'm more interested in multi-node processing than multi-core myself. There's just not many domains where multinode won't be dramatically superior to local multicore once you leave the OS layer and game engines. And those only for latency reasons. So I kind of appreciate that Python isn't great for multiple pthreads. Python is kind of a must-have addition to anyone's toolbelt, but C# is pretty close to that with Windows having 90% desktop marketshare and having Unity and Xamarin. I gave up on trying to rid my life of anything-MS a while back after dissatisfactory Linux desktops, and just accept each for what they're good at. Namely Linux for servers and the Windows desktop. Trying to fight the power gets old and I just want to get stuff done. Part of the reason I picked Python years ago was due to the decent Windows support. My checklist to really sink time into a language includes good crossplatform support which includes Windows. But I use Python for all my projects just because it's more liberating from a cost/tooling/crossplatform perspective. Mono is pretty bad, but .Net Core is something to keep an eye on and the C# scene while I find most people there rather unenthusiastic and not my type, is still a worthwhile area. I'm going to continue to use both as most of my needs are fulfilled. I'm never going to write better C/C++ systems software than what already exists (and certainly not alone). The extraction layer I'm working on fits in the Python/C# domain. Best of luck!
Pyside just announced Qt5 support is underway. That's LGPL, which is usually good enough.
It's not that bad but you can't deny that it's annoying anyway. It shouldn't be on saves because it disturbs one's workflow. If it were on startup or closing, it'd be okay but it's bothersome as it is. Edit: oh would you look at that, I think I intended to reply to /u/ksion.
**Matplotlib** https://github.com/eliben/code-for-blog/blob/master/2015/benchmark-row-col-major/plot2.py https://github.com/eliben/code-for-blog/tree/master/2015/benchmark-row-col-major 
If you are interested in learning vim I have 2 tutorials on how to use vim. The second one goes into details about how to configure vim's plugin system for python development. Best part is everything is free. https://www.youtube.com/watch?v=kz356ddxV1Q https://www.youtube.com/watch?v=hNYPtTm21pQ
FYI - /r/learnpython is the correct subreddit for any type of Python question. You'll get much better support over there.
&gt; You can argue that the additional structure imposed by Java/C++ make coding more challenging, but constraints can be useful on large projects This is it. Python's interpreted and dynamic nature means that dealing with large codebases can be a nightmare. People will no doubt retort with "just have tons of unit and integration tests" and yes they're needed but a statically typed, compiled language like Java and C++ will find many of those errors for free and a good IDE will find them even before compilation.
You didn't even read my post fully, did you? &gt;People will no doubt retort with "just have tons of unit and integration tests" and ***yes they're needed*** 
Ah, I have a Student ID and a College Email ending in .ac.uk :/
I think SO's gamification optimizes for the wrong qualities, and I have no idea if they could fix it any more.
Cheers! Thanks so much.
Will do, thanks!
Having static type checking cut down on unnecessary unit tests. You are basically writing unit tests to cover what the compiler cannot test for you.
I've found that making a UI that isn't absolutely awful is best done without python. TKinter barely works to make a decent UI. Swing seems better... But not a lot. 
Update four months ago only had to do with coverage. Hmm...but there are no open issues, so maybe it's stable. Maybe try pinging the devs?
What do you mean when you say STL is an old product? STL ist just a part of the Standard Library. 
&gt;So use a good IDE... Even the best python IDEs won't complain about common errors that a statically typed language would. PTVS doesn't raise an error if you do something like `1 + "2"`. You'd have to wait until runtime if you'd happened to miss that. &gt;My open source Python code is ~200k lines (it used to be 2x that). It's fine. When I was looking at the reddit codebase there are parts that they won't accept commits to because there are no tests at all for the section. I'm going to go out on a limb here and say that this isn't a unique situation. With a more strict language you could move forward with a bit more confidence when changing old sections of code. Also I said *can* to make it known that it wasn't impossible to have a large codebase in python, just that there are more pitfalls.
Wow, great points. And yeah, I'm right with you: Linux for servers, Windows for desktops, exactly the same reasoning. 
&gt;Many colleges don't use Python as a teaching language because they already have perfectly good course material for Java and they don't want to rework it. An interesting case of Python being used in a class setting is a summer programming course I took while in college. On the first day of class, the professor explained his choice of Python as, "If this were a CS course I'd use Java, but this is a one-off programming course, so I chose Python since it makes it a lot easier to skip the CS ideas and go straight to the programming part." (The part about Java before the first comma may be an embellishment of my memory, but the rest of is pretty much verbatim.)
/r/learnpython is the right Subreddit for any python questions.
Na, not really. As far as I know Java has basically equivalent resource control to Python (I had to Google, but it seems that Python has weakrefs et al.). Probably the JVM's garbage collector is better performant and more tunable than CPython's, but that's an implementation detail. Performance-wise, the big difference is static typing- the "fast" statically-typed languages are a league above the "fast" dynamically-typed ones. But that doesn't matter much often (unless, say, you write graphics intensive stuff or similar). 
&gt; Python doesn't have a monopoly on libraries This to me is the weirdest remark. I might be a little bit ignorant since my experience with Python is limited, but I naming the two most known libraries and something like Kivy to demonstrate the huge number of libraries for Python. I'm pretty sure the amount of Java/JVM libraries used in production absolutely dwarfs the Python stack..
Yeah, Python was basically Guido's pet project and shared it to the world, people could use it if/how they wanted. It gradually was improved over time. Java started in the business world form the get go in 1995, with the backing of Sun Microsystems so of course there was a lot of man-power to get it in browsers, help companies integrate their products with it. 
Luckily there is Zato now so it all can be done in Python as well :-) https://zato.io/docs/index.html
I have never met an experienced developer who does not use white space, as syntax, for communication with other developers.
Similar questions are asked constantly. I don't think I've answered it here yet, so here it goes. Look, Java is not designed for writing small-scale software nor for teaching (still, I think that dynamically-typed languages are not appropriate for teaching some specific things, either. However, there is an awesome lack of statically-typed languages suitable for teaching). But language design (as most things in life) is full of trade-offs- Java just didn't choose the ones that you need right now. When you need to write large-scale software, on a big team (where not everyone is awesomely skilled), you will appreciate the benefits of Java (or C#). When you need to write high-performance code and can't afford GC you will appreciate C++ (and maybe, Rust). Software engineering is hard to teach "in school". You cannot write large software in six months on your own, thus you won't encounter the kinds of problems you will find when you work (also, many teachers have little experience coding for a living), so it's hard to understand how it all works out in practice, or realize why some practices are good/bad- you're never in a situation where you feel that in your bones. 
The comment history makes me think this person is a content bot for laughspark. No comment karma and it's either a laughspark link or a typical picture taken off imgur and posted to a relevant sub, hence the python on r/python. 
Fair point
I work for a large Fortune 500 company. We are beginning to use Python in the analytic space (as well as R). The company has predominantly been a SAS shop as it relates to analysis and statistics. So, the code that will be written will not be for Enterprise class applications. Besides the flexibility of Python, I think the change of having these as options is at least partially as a result of younger folks being hired that have academic experience with Python and R. For analysis, Python's code is very readable which is important from an audit perspective. 
&gt; PTVS doesn't raise an error if you do something like 1 + "2". You'd have to wait until runtime if you'd happened to miss that. Programming is so much about thinking, care, using different perspectives, attention to detail etc. The Java compiler in my head won't complain about that code either. The answer is the string "12".
check in [r/forhire](https://reddit.com/r/forhire)
very true. Even better, the dictionary mappings are already set up in the "messages" variable, most of the game can be pulled from there
It's supposed to be, they want you to buy a license. It's only $70 for a license, which isn't bad if you think you need it. Personally I find Atom to be perfect for my needs. It's true the startup time isn't instant, but it's still only about 5s, which affects me about once every two weeks. I don't know what people are saying about stability, I've never seen it crash.
Dealing with large code basis is challenging with any tools. Python certainly creates issues. But so do other tools. For example, Carelessly coded c++ has massive build time issues.
Pycharm extremely overrated, Eclipse/Pydev perfectly adequate, the former not always free, the latter always is. Pay your money, take your choice :-) 
C++ is a master's language, IMHO. It also presumes that you already know C. "Learning languages" are BASIC, Pascal, Perl, and Python (amongst others.) Java and C# are also good languages for learning as well. I think what I like most about Python (and BASIC) is that you can just try stuff out at the Python command line (or in IDLE or iPython Notebook.) Still, I think C++ could be taught to a beginner. The best book being "On to C++" by Patrick Henry Winston. Arguably the best beginning C++ book there is. 
I aspire to a better world, with better languages. I don't buy that 20 year old tech is the end of history. I don't buy that you need to only use one language, so c#, swift, go, dart, JavaScript, Python, closure, f#, ocaml, Haskell, Java, Julia, c (yes), c++, are all live for me. They don't trap me one one Eco system. 
over at /r/networking we get people asking about where to meet new people sometimes. Good times.
People don't want to do your homework for you. /r/learnpython is a better place to post. And even then you should explain what you have tried and what you are having issues with, don't just ask people to do it all for you. 
**Matplotlib** https://github.com/eliben/code-for-blog/blob/master/2015/benchmark-row-col-major/plot2.py https://github.com/eliben/code-for-blog/tree/master/2015/benchmark-row-col-major 
I wish python was used more often. In the highschool robitics team im in the robot can only use java. Its super frustrating because i learned python over the summer. When i look at java none of it makes any sense to me but regardless i have still have to learn java.
&gt; C# being the best alternative but leaving you tied to a MS platform This is becoming less and less true. Mono has been a decent solution, and now Microsoft are open sourcing large parts of the .NET framework and the CLR - C# &amp; .NET will be a first class citizen on Linux before long.
At least when you change the argument type in an api, the "poorly designed type system" in Java would flag all the wrong uses of it while the type lacking system in Python just silently fails in runtime.
JS eew
A job interview is a 2 way process. You need to decide if you really want to work with these guys. What part of it is debatable btw? What are you gonna do when you ask for STL code, and you get STL code, and it doesn't build because - surprise! They are not fully compatible.
I said it's not bad if you think you need it. Even for a college student, if you're cs you'd be using it a ton, and it comes out to cheaper than a book. 
I think a lot of programmers get an ego boost from writing long complicated programs.
Agreed, but I think the Internet Hype Machine and the echo chamber that is /r/programming and SO miss the overwhelming majority of what goes on with languages and projects written in them. Also, many of the projects written any any specific language may well be highly proprietary and not discussed outside of the people writing them. Or they're just not written by people that tend to go on about their accomplishments on the Internet. I think again this is a generational thing. Newer languages get lots of press because accomplishing anything in them is more noteworthy. Writing something in C isn't what we'd call surprising since there are _so many examples_. But, writing something in Go or Rust, or Ruby or Python gets slightly more play. TL;DR Internet echo chamber is a terrible way to judge popularity
&gt; The answer is the string "12". Are you a PHP dev?
Pycharm, hands down
1 + "2" is picked up as a Type error in PyCharm IDE. The IntelliJ IDE's have great code inspection &amp; refactoring tools across all the languages they support. Obviously because of the dynamic nature of Python it can't do everything. This is evident in the differences between PyCharm and AndroidStudio. A good IDE makes a big difference when coding in Python. I work in a team of python developers and it's clearly visible who uses PyCharm and who uses Sublime, just by looking at the .py file hehe.
I suspected Pycharm might find some errors like that. I don't have it installed though so I couldn't check. Good to see it does a bit more code inspection than Visual Studio. I do think IDEs will pick up a lot more errors if type hints from 3.5 become widely used. 
If you want something closer to an IDE, I recommend PyCharm CE. It's free and it has more features than a basic text editor. If you just need a basic text editor, Caret is a free Chrome app that you could download to your Mac - it's based on Sublime and it's simple and quick to use.
IntelliJ/PyCharm certainly complain about 1 + "2". Here's what i get from the type checker: Expected type 'Number', got 'str' instead Of course it's just a suggestion, but i found PyCharm to be surprisingly correct and with type annotations from 3.5/mypy this should only get better. Can't comment about PTVS but i assume it can be improved.
What actually is an IDE tho?
An IDE (Integrated Development Environment) usually has additional features that can run your code, help you debug it, and compile or interpret it depending on your language - along with other useful tools. An editor basically just lets you write your code down, edit it, save it, or open other files. If you want to run or debug your code, you'll need another program to do so. If you're just starting out in programming, an IDE might be overkill right now. They can be more complex to navigate and have more features than you need. Since you're learning Python, I'd suggest going with Caret or with Sublime's trial version. You can write your code and save it with Sublime, and test run it using IDLE. Once you get more comfortable and further along in Python, you can start looking into IDEs like PyCharm.
 &gt;I use a Macbook Pro, and need a decent Python Editor for my studies at home. I really like PyDev, an extension to Eclipse, but I hate Eclipse. That may sound strange but I really like the way PyDev works or functions but hate the bugs and strange behaviors one sees in Eclipse. PyDev is a great IDE sitting on top of a not so great base editor. &gt;After a bit of 'Googling' I've found a list of Mac OSX Editors, but I want to know which are the best? Nothing is the "best", find something that fits your work style. It is well worth it to experiment a bit. &gt;I've tried IDLE, but it's too simple for what I need it for. Yes in some ways it is. However it works fairly well as a tool dedicated to Python. &gt;Any help would be great, thanks. What is your major or intentions? If it is computer science I would recommend a multi track approach where you learn a number of editors including Vim/MacVim. The reality is you may find yourself needing a variety of skills once out in real world. Do install XCode! Do install HomeBrew Install iPython! This especially if your studies Lean towards engineering. 
You want to learn Vim to some extent no matter what. It is an editor that is almost everywhere. It isn't a great Python IDE though. 
This subreddit is for things related to the programming language Python, not for the snake. This has been removed.
and its open source alternative (created at the same time or earlier) is Zed ! http://zedapp.org/ 
In regards to using Java in your college paper I have a few things to say (as someone who recently got a CS degree largely done in Java). Firstly in my experience while mostly using Java I also touched Python, C++, C#(+LINQ), some learning assembly language, prolog... The great thing with my course being in Java is that the code is reasonably readable (if done good anyway), and that the knowledge from it is easily adaptable. I found it a breeze going from Java to the C languages, the same structures could be done, static typing was familiar all was swell. On the other hand going to python was easy, just had to familiarize myself with ins and outs of lists and various syntaxs. Going from static typing to dynamic isn't any challenge either. I am not sure if the same experience can be said going from python to the statically typed languages. The best feature of Java for me though was [this](http://docs.oracle.com/javase/7/docs/api/). A comprehensive API that covers the methods and use of every class I ever had to use. Hell I used probably less than 1% of the total documentation there. Python on the other hand I often find myself trawling the documentation, finding different parts of what I need in relation to one tool scattered all over the place, sometimes never actually finding what I want to know. I love python for it's simplicity and readability. I don't have to bother parsing strings and converting things into what I need, just one line of code to read in or write out - that shit happens for me. It allows me to quickly whip something up without having to deal with a bunch of code just to read a file. But I am grateful that I had a hand at doing lower level "simple" tasks, it gives me a better understanding of how things work under the hood. It allows me to write better code, and to better understand why something may have gone wrong, regardless of what tools I am currently using. 
There are a lot of propositions for PyCharm and other IDEs. While they're good, I don't recommend to start with them. I really recommend to start with a text editor (and a terminal). An IDE hides complexity, prevents you from learning, from understanding how your language actually works, from understanding what tools are needed and how they work. For example, something I saw when I was at university (not so long ago): students pressed the "compile" green button of the IDE and they couldn't run the program on the command line. While simple, this example extands to more complex needs. Moreover, the best feature of IDEs is complex refactorings. We really don't need that on a daily basis. So simpler text editors can have all the features we want to edit python code. So, I recommend the followign editors: - Geany - Kate - why not Gedit - and to try vim (gvim) and emacs (with or without the vim layer), even if they're weird.
and I didn't test Scribes http://scribes.sourceforge.net/smart.html
I love coding Python probably more than any other language That being said, I can not imagine working on a large Python code base. I'm sure there are big Python code bases out there. But I can't imagine it.
Contact them and they will hook you up. When I was in college, we were working on a content management system written in PHP. We all used PHPStorm--which was awesome. We just went through https://www.jetbrains.com/student/ 
Every console compiler I have used has supported some parts of boost. Nobody uses all of boost, you pick what you want and use it. Also, you sound very pedantic about the stl vs standard library, most people don't care and call it stl. If you corrected me in an interview about it, you would not be considered for the position.
... so what is it? I skimmed that doc page and don't understand what it does. It looks like it allows you create APIs and stuff... but you can do that already?
Well yes, TK is annoying. Not sure why you would bother using it when there are things like PyGTK and Pyside. The UI for Python plugins in GIMP, for example, is written using PyGTK and is indistinguishable from the rest of GIMP.
Absolutely, I do most of my work in Python but need to go back to Java when working with Microsoft Office documents. Python support is rudimentary to non-existent if you are hoping to do more than read cells from a spreadsheet. Look up Apache POI and you will see Java has a near complete open source implementation, supported by paid developers. There is just so much Java in the world almost everything already exists (although Python has the edge in some areas). I think the biggest advantage of Java is that due to the restrictions on coding style every library will have the same naming conventions, programming methodology (OOP) and integrate seamlessly with the IDE. Most of the time I can figure out a Java library simply using code completion hints, whereas in Python I'll always need a web browser and maybe a peek at the source.
I love static typing. It's frustrating to to read python documentation where they describe a function in this way: doSomething(foo,bar) Ugh! I know I want to doSomething but what does foo have to be? What does a bar look like? How to I make them? Does it return anything? In C++ or Java it would be void doSomething(plotz foo, ploop bar) Ahh! I need a plotz and a ploop and I won't get anything back! What is a plotz and a ploop? I don't know but I'll read the class definition and I WILL know. 
&gt; All of the Linux distros use completely out of date packages https://www.archlinux.org/ and other rolling-release distros. Python 3.5, for example, was released on python.org on the 22nd of September. I updated my packages on the 30th of September, and 3.5 is now my system python (previously, it was 3.4.3) But given results like [this](https://packages.debian.org/search?keywords=python3) (Debian, which is famously conservative) and [this](http://packages.ubuntu.com/search?keywords=python3) (Ubuntu), I have to question the accuracy of your claim of 'completely out of date' packages.
Debatable is the wrong word. If you write for STL not standard library during an interview without clarifying, you might find you have wasted time and need to rewrite. Even though that *shouldn't* make a difference. I have been part of many interviews which say STL and mean standard library, if you say slist during this and the interviewer wanted you to say forward_list they might not remark on it till after the interview so you have no chance to say there is a difference, the same could go the other way. So probably more clarrify before assuming STL means STL, often it can mean standard library. 
Python is awesome! I really love it. However, I love it more for functional programming. Simply algorithms, simple programs, and even complex programs. I can basically keep it bug free and somewhat efficient. However, it isn't all that fast. Really, it is good and such but there's basically a cap. It is a ridiculously forgiving language with a lot of help. There's nothing that you can do on it that you can't on ANY OTHER LANGUAGE. To me, it is the perfect language, somewhat. My other language of choice is Cpp, which is fast! I can make it so fast! A lot faster and efficient than Python can be. The ability to dynamically manipulate the memory is a huge bonus. However, it isn't very forgivable. Get a bug on it and it can be hell. Now, Java is essentially the same but is a bit more forgiving and can assist with the handling of memory. You don't have to do everything yourself, I just don't like it. However, it is a good middle point. Personally, it isn't necessary to me so I don't use it. Python is more widely used than you might think. It usually hides in the background as a helper rather than the main. I'll use the comparison of MJ and Scottie. MJ (Cpp) is the main guy that can do everything awesomely then we have Scottie (Python) that can do just as much but not as good. However, as a standalone, it can be awesome by itself in the first chair. I love me some Python. Really, I love it. Again, you'd really be surprised by how widely used and highly rated it is. Want to set up a server? Django. Want to do statistics, machine learning, computations, and way more? NumPy. It goes on and on. Also, have to say, creating files and directories is extremely easy on Python, probably the easiest language to do so. 
Because what you are doing violates the [reddit rules](https://www.reddit.com/help/contentpolicy), specifically the ones about [vote manipulation](https://reddit.zendesk.com/hc/en-us/articles/205192985). You even acknowledge that this is what you are doing: &gt; I originally developed it to test whether artificial upvote manipulation was possible GitHub README: &gt; I created this script to test if I could mass create accounts from different IP addresses and use them to artifically manipulate upvotes.
Java was the language of choice in the vast majority of classes in school. First job was working mostly on a .NET stack with C#. Mind: blown. Now I loathe Java almost as much as Coldfusion. 
I had a similar problem before and I noticed that text extraction module had some problems with tricky characters, such as Greek ones. I ended up using a different approach. First, I used PDFBox [command line utilities](https://pdfbox.apache.org/1.8/commandline.html) (the tool is in Java, but you can access the command line interface from Python with `subprocess`) to convert PDF to HTML. Then I used lxml to parse that HTML file. After you extract text from HTML you can save it to CSV. 
While I like Python I use whatever I need to use based on the job I have to do. Very rarely is it Python. Not sure why considering I do web development. Almost always .net(c#), php, or JavaScript. 
&gt; Good documentation will have those annotations. Good documentation? You must be talking about non-python docs! ;) Just kidding and of course the documentation should give those details but in my experience they usually don't.
In that case your original comment was completely misleading. Webdev is webdev. People use Python for many other things than webdev.
PyCharm is very nice. 
When I went looking for a Python NEAT library, it bummed me out a little that there wasn't one on PyPI. I found one, but the original author wasn't supporting it anymore, so I updated it to work with current libraries and added it to the Python package index. I've tested it out with Python 2.7 on Ubuntu and Windows 7. Right now the XOR and single pole-balancing examples are the most usable. Some of the other examples may require you to build some C++ extensions manually before they'll run.
Python is a fine scripting language and it's pretty decent for prototyping things. But it lacks a lot of features to make it great for deploying serious applications without a lot of extra work. For a good example of why, try to send a Python program you've written to a non-Python programmer for them to use. You'll find it's non-trivial. Python is essentially the new BASIC. There's nothing wrong with that.
Thank you! That's a good idea!
It's one of the things I hate most about Python.
What I like about it is it enforces clean formatting.
Decompiling pyc files is pretty trivial for anyone who deems it worthwhile to put 5 minutes of research into it. There are similar tools out there for java and c sharp as well. If you're that concerned, I would just turn it into a webapp and deploy it on the company intranet.
I suppose that's true... But shitty devs are gonna write shitty code regardless of language. Just look at Linus' various rants about how people misuse C when writing kernel code. I work on a large, multilayered codebase that's got years of history and plenty of shit code... but I don't see how changing language would solve stupidity.
haha - this is awesome - nice work! to possibly save time if you want to try this out, not only did I need the fix already mentioned, line 31 device_info = self.audio.get_default_input_device_info() the dependencies: sudo apt-get install python-dev libportaudio-dev python-pyaudio Neither easyinstall or pip would install pyaudio
Even better to learn assembly first so that you can appreaciate abstractions that go into c++! ^^^^
It does have paid devs, it's a Microsoft project.
Python is fantastic. If I were looking to develop a commercial product though? Not so much. Yeah, there's Cython/Nuitka etc. but I'm not convinced that, for a large-scale application, either is the answer. Maybe I'm wrong.
Whats wrong with using `git pull`for deployment? I use git pull to deploy my python web app. Almost every day I make a release (probably over 200 in the past year), and have never had a problem. Why exactly am I doing it wrong?
Typically, for Python projects you'd create an OS package for that, containing a virtualenv that has all the Python dependencies you need. For some (C) dependencies, you'll need to make your OS package dependent on these packages. When you do that, you're actually quite aligned with how your OS works (and probably also with how your operations teams work). In fact, configuration management tools will treat your application just like any other application installed on the OS. As for Java - scp'ing a jar to a machine and it just working would only work for "fat jars", i.e. self contained jars that don't need a container or anything like that. Even then, you'll probably need to prepare some properties files, set JVM options such as initial/maximum heap size, stack size, and so on. You'll also need to make sure your process will start when your machine reboots, so you probably want to use something like supervisor or systemd for that. That stuff needs to be configured. And when you have container based Java deployments, your deployment challenges will become much greater.
thank you ;)
Hi there, we have a page on debugging import errors here: https://help.pythonanywhere.com/pages/DebuggingImportError In general, as you can tell from the promptness of this response (or lack thereof), it's always best to drop us an email if you need urgent help. support@pythonanywhere.com!
What's the problem with numpy in virtualenv?
Yes.. Because youtube is owned by google. Many top rank site are using Python.
It tries to compile all the c libraries numpy is based on. The problem are the c extensions, not python itself. 
[Zato](https://zato.io/docs/) is an enterprise integration platform and backend server used for integrating distributed and otherwise disconnected applications or data sources with the end goal of offering unified, clean and well-defined APIs supporting business processes on top of [interesting, reusable and atomic services](https://zato.io/docs/intro/esb-soa.html). In particular: * Designed for Python programmers who highly value productivity * [Clustering built in](https://zato.io/docs/architecture/overview.html) * [Hot-deployment](https://zato.io/docs/web-admin/intro.html) of code and configuration without server restarts * [Web-admin](https://zato.io/docs/web-admin/intro.html), [load-balancer](https://zato.io/docs/architecture/load-balancer.html), [servers](https://zato.io/docs/architecture/servers.html) and [command line interface](https://zato.io/docs/admin/cli/index.html) * Lots of [connection](https://zato.io/docs/progguide/channels.html) [adapters](https://zato.io/docs/progguide/outconn/overview.html): [SOAP](https://zato.io/docs/web-admin/outgoing/soap.html), [REST](https://zato.io/docs/web-admin/channels/plain-http.html), [AMQP](https://zato.io/docs/web-admin/channels/amqp.html), [FTP](https://zato.io/docs/web-admin/outgoing/ftp.html), [JMS WebSphere MQ](https://zato.io/docs/web-admin/channels/jms-wmq.html), [Redis](https://zato.io/docs/web-admin/kvdb/remote-commands.html), [SQL](https://zato.io/docs/web-admin/outgoing/sql.html), [ZeroMQ](https://zato.io/docs/web-admin/channels/zmq.html), [Cassandra](https://zato.io/docs/web-admin/conn-def/cassandra.html), [SMTP](https://zato.io/docs/web-admin/email/smtp.html), [IMAP](https://zato.io/docs/web-admin/email/imap.html), [Amazon S3](https://zato.io/docs/web-admin/cloud/aws/s3.html), [OpenStack Swift](https://zato.io/docs/web-admin/cloud/openstack/swift.html), [ElasticSearch](https://zato.io/docs/web-admin/search/es.html), [Solr](https://zato.io/docs/web-admin/search/solr.html), [Odoo](https://zato.io/docs/web-admin/outgoing/odoo.html) * Notifications from [OpenStack Swift](https://zato.io/docs/web-admin/notif/cloud/openstack/swift.html) and [SQL](https://zato.io/docs/web-admin/notif/sql.html) * Security protocols: [API keys](https://zato.io/docs/web-admin/security/apikey.html), [AWS](https://zato.io/docs/web-admin/security/aws.html), [HTTP Basic Auth](https://zato.io/docs/web-admin/security/basic-auth.html), [NTLM](https://zato.io/docs/web-admin/security/ntlm.html), [OAuth](https://zato.io/docs/web-admin/security/oauth.html), [SSL/TLS](https://zato.io/docs/web-admin/security/tls/overview.html), [WS-Security](https://zato.io/docs/web-admin/security/ws-security.html), [XPath-based](https://zato.io/docs/web-admin/security/xpath.html) * [Role-based access control to endpoints](https://zato.io/docs/web-admin/security/rbac/overview.html) * [Scheduling](https://zato.io/docs/web-admin/scheduler/main.html) * [Dictionary mappings](https://zato.io/docs/web-admin/kvdb/data-dict.html) * [Redis-backed REST publish/subscribe](https://zato.io/docs/pubsub/index.html) * Integration patterns: [fan-out/fan-in](https://zato.io/docs/progguide/patterns/fan-out-fan-in.html), [parallel execution](https://zato.io/docs/progguide/patterns/parallel-exec.html), [invoke/retry](https://zato.io/docs/progguide/patterns/invoke-retry.html), [async callbacks](https://zato.io/docs/progguide/patterns/async-invoke.html) * [Statistics](https://zato.io/docs/stats/guide.html) * [Easy integration for Django and Flask client applications](https://zato.io/docs/progguide/clients/django-flask.html) * An [assortment](https://zato.io/docs/progguide/rest/services.html) of [various](https://zato.io/docs/progguide/rest/channels.html) [REST](https://zato.io/docs/progguide/rest/outconns.html) [utilities](https://zato.io/docs/progguide/rest/json-adapter.html) * Convenience [Python clients](https://zato.io/docs/progguide/clients/python.html) * API [testing](https://zato.io/docs/test/apitest/index.html) [tools](https://zato.io/docs/test/apimox/index.html) * If needed at times, [HTML output with Django templates](https://zato.io/docs/progguide/html.html) * Means to [automate deployments](https://zato.io/docs/admin/guide/enmasse.html) * [Configuration patterns](https://zato.io/docs/admin/guide/config-patterns.html) to deploy or curtail the execution of code to selected servers only * Dockerfiles to support [deployments](https://zato.io/docs/admin/guide/install-docker.html) [with Docker](https://zato.io/docs/admin/guide/install-docker-dist.html) * [Public admin API](https://zato.io/docs/public-api/intro.html) to automate anything * Running on top of [gunicorn](http://gunicorn.org/) and [gevent](http://www.gevent.org/) = easily utilizes multiple CPUs + you've got clustering so you can scale without limits And dozens of smaller integration or backend related features to ease with the development of both smaller and advanced applications and systems supporting business processes in enterprises where you typically deal with dozens or hundreds of backend applications both on-premises and in cloud, some of them face the Internet (like online banking), some get exposed as APIs to business partners but most of them are never available publically to anyone yet they constitute the backbone of many organizations. I suggest checking out both the [web-admin](https://zato.io/docs/web-admin/intro.html) and [programming examples](https://zato.io/docs/progguide/examples/index.html) to understand how high level it is. Then a quick glimpse at the [architecture](https://zato.io/docs/architecture/overview.html) and you're ready to start the [tutorial](https://zato.io/docs/tutorial/01.html) now :-) 
Would be nice to see some examples, not immediately clear what it does. The readme suggests that it automatically generates Q&amp;A pairs from news articles. Would be pretty easy for the Daily Mail: "Does &lt;x&gt; cause cancer?" "Yes." 
I would use [pyserial](https://github.com/pyserial/pyserial) to communicate with an [arduino](http://www.ebay.com/itm/Mini-USB-Nano-V3-0-ATmega328P-CH340G-5V-16M-Micro-controller-board-For-Arduino-/111654763655?hash=item19ff247c87) over the universal serial bus [USB] with an rfid module such as [this one.](http://www.ebay.com/itm/NXP-PN532-NFC-RFID-Module-V3-Kits-Reader-Writer-For-Arduino-Android-Phone-/311005959514?hash=item486966555a) [example code](https://gist.github.com/cooncesean/5961086) or you may be able to find a usb only [RFID device](https://www.youtube.com/watch?v=L0PGQsvWlq8)
Have you used [nuitka](http://nuitka.net/pages/overview.html) at all? It basically translates you python code into C++, then compiles and executes with libCPython. Depending on how much of the standard library you import the executable is a couple of MB, which isn't great, but it's also entirely native. Compiling a single module to a .so also works. I have no idea whether this would be helpful for you, but I'd be interested in hearing your thoughts.
&gt; Right. But with Java, you don't have to do it. You really don't have to do that with Python either, but depending on the OS you're using, that might still be the "technically correct" way to install anything. If you're just scping over some files from a project written in any language, I'd argue that either your deployment procedure could probably be improved dramatically in many ways, or that the application you are deploying is so trivially simple that it's not really worth using as an example of how simple it is to deploy the average enterprise Java application.
A lot of people are Christian. A lot of people are not Christian. Both statements are correct.
No you do not. I am just not familiar with using a RFID USB device and I personally would use an arduino myself because that's what I am comfortable with. The USB reader would just MAYBE need a driver if your running windows otherwise on a UNIX system it would work plug and play.
I don't know Wing. But I can tell you something that I find really convenient with PyCharm: remote developpment. PyCharm is running on my laptop. I have a virtualenv on a remote machine where the code is actually executed. When you setup the remote thing, Pycharm explores the remote virtualenv so that code autocompletion is available on my laptop. The remote developpment feature is only available in the professionnal edition though. 
Well you are not wrong. Hopefully this will get better with time, personally I found I use very little of the specialized Widgets, I just use the base widget and build anything I want from that.
I ended up using tools such as Pandoc (pandoc.org) or AsciiDoc (www.methods.co.nz/asciidoc/) to convert Markdown text to my desired output format. On most cases you can simple create a script to parse data from any format to Markdown (for each in python and output data to a text file) and then use those tools to convert it to the format you need. 
woe is the burden of informing the uninformed
Version thing is getting better. And windows support is better than a lot of its more direct competition (eg ruby). But not saying you're wrong.
The DocX XML file is tricky. You can have a valid XML file but the output would not look exactly as you wanted. the main issue I see are w:p runs... some items could be childs of them and some don't. you can surely use a DTD to validate but it's a PITA, at least for me. It would definitely work for a complete table for example, if you replace the exact same type of object... I mean, open up word, create an empty table, unzip the docx, open the document.xml and find the table element and then replace the whole table element. That would work just fine :)
If you're that serious about it you can always build the latest from source.
Mandatory white-space doesn't magically make code easy to understand.
to me the issue with using git pull is that it doesn't address dependency management and can be somewhat futzy - i.e. relying on manual actions (like remembering, oh yeah, I added a new pip or system dependency). for simple cases it's fine, but not robust enough for complex deployments of large systems. using a pip-based process with build automation is more robust, but also more work to set up. but, otoh, if it works for you then use it.
unfortunately, this thread has drawn all the uninformed java fanbois in talking about how java is some magic platform that solves all of your problems with magic... so it appears some people bitch about python for utterly stupid reasons, such as whitespace or oh no c extensions don't magically work!
https://github.com/reddit/reddit
Thanks. Any elaboration here would be appreciated - I'm very much the novice. I'm working in Windows 8 with Python 3.4, if that's relevant.
Yep. It's great for one liners. But I'm looking into alternatives for big projects. I think python problem here is as soon as you split the project into several files it becomes a clusterfuck of debugging due to mostly typing errors. I've noticed half of my problems are because of this. And writing tests is still writing. 
What's being obscured by the pyc files?
&gt; Dealing with large code basis is challenging with any tools. This is a meaningless relativization. "Programming is hard" Yeah, so is life. But that's irrelevant. We're comparing languages. And some are simply better equipped for statically checking errors.
&gt; That only works when you do in fact provide everything This is exactly how it works with maven/gradle. You define (in a file) everything your app needs. Other deliverables (jars) define everything they need (in their file). It's simple to collect all the classes your app will ever need by iterating over these files. &gt; makes an uber jar that has all the jars that you're using in it You're thinking about war/ear which is basically a zip that contains other zips in it. `jar-with-dependencies` "unzips" all of the jars into a folder and then "zips" that folder into a single jar which now contains your classes together with other people classes. In case of Tomcat, you're certainly right: it needs to be installed. Just like Django. &gt; you will want proper configuration management I agree that I may have oversimplified for the sake of this thread, some Java deployments are more complex than just scp; it is true however that any corresponding Python deployment will not be simpler than Java deployment, by a virtue of having to have and to invoke a C/C++/Fortran compiler on the target system.
Haven't seen it mentioned yet: I use TextMate 2. It's FOSS. It's OS X only. It blends nicely with the system. 
Enterprise fundamentally does not care about productivity or quality. They do care about doing what other people are doing.
&gt; This is exactly how it works with maven/gradle. You define (in a file) everything your app needs. Other deliverables (jars) define everything they need (in their file). It's simple to collect all the classes your app will ever need by iterating over these files. Yeah. But that doesn't mean it is also magically turned into middleware (e.g. when you build the jar-with-dependencies, then what?) &gt; In case of Tomcat, you're certainly right: it needs to be installed. Just like Django. Not at all like Django. Django isn't a container, Tomcat is. Django provides a development server, but that's not anything to be used in production. Django is just a dependency of your application. In this scenario, Django could be compared to e.g. Spring MVC/Play/whatever the latest Java web framework is, and the "container" to something like uWSGI vs. Jetty for Java. Both can easily be embedded, and with Python you usually do. So conceptually, a Django/uWSGI application is similar to a Java web application with an embedded Jetty server. I haven't heard of anyone doing the same thing with Tomcat, that would seem rather painful. &gt; I agree that I may have oversimplified for the sake of this thread, some Java deployments are more complex than just scp; it is true however that any corresponding Python deployment will not be simpler than Java deployment, by a virtue of having to have and to invoke a C/C++/Fortran compiler on the target system. Some? I have done more Java deployments than I wish I did, and I never, ever encountered a situation where a deployment was as simple as doing an scp. Anyone who is serious about any kind of significant deployment uses configuration management tools. There are also a bunch of Java specific ones, which exist for a reason. Deployment is hard, but easily taken too lightly. Mind you, not all Python deployments require a compiler on the target system. In fact, that is typically a side effect of using pip at deployment time (which I highly disrecommend). Compilers should be build time dependencies, not runtime dependencies. Even when using pip however, you do not necessarily need a compiler on your system when your dependencies are pure Python.
For django stuff I tend to look here: https://github.com/rosarior/awesome-django
So your only problem about Django is the default ORM is not SqlAlchemy or there is other things as well? I know SqlAlchemy is powerful but I never had the need to wonder far out of the Django ORM features. And you can always resort to raw queries if you really need to (almost never happened to me). Sure Django is tightly coupled with its ORM (although some would disagree http://lethain.com/replacing-django-s-orm-with-sqlalchemy/) but that brings some cool features like the admin or REST api that "just work" out of the box across a wide range of readily pluggable applications. Not like it is impossible to use SqlAlchemy with Django mind you but it might be hard to not use the provided ORM at all if you think that for some reasons it is an abomination. Using Rails here at work and although there great things to say about Ruby and RoR there is also a plethora of stuff that just plain bad like the lack of namespace in the language, the monolithic nature of a Rails applications, the various syntaxes and weirdness of the language, and the rather terrible documentation all around. You say that python as "too many" frameworks... But how many is too many? Realistically you have to pick from 5 choices maximum with Django as the obvious "favorite". Doesn't Ruby has many web frameworks as well? Known and unknown? https://blog.engineyard.com/2015/life-beyond-rails-brief-look-alternate-web-frameworks-ruby 
Welcome to Reddit
False. Anyone who used multiple languages has some criticism for Python. Its dynamic typing and its lack of access control is widely recognized as a potential source of problems, especially in the business world, where having to deal with Python's weaker encapsulation can cause a lot of unsuspected issues. I love Python, but it's most definitely not a mean to all ends and isn't without weaknesses or downsides.
That is still irrelevant. The discussion is about Python and C++/static languages.
I'm not a fan of Ruby either. I don't like the lack of namespaces. Or the Rails philosophy of "convention over configuration" and so on. The syntax is weird and there are too many ways to do the same thing (why are there so many different looping keywords?.. and so on) The problem isn't with Django or some specific framework, but that most of the frameworks (aside Django) are incomplete, works in progress or just lacking basic stuff. But they are still spoken about as if they are mature frameworks with new development going on. The most popular framework here on reddit (after django) is Flask, which had it's last release years ago.
Have a look at [pod](http://www.appyframework.org/pod.html), which uses openoffice; you can then saveas .docx from there.
Young whipper snappers. In my day, we only had vi from the command line. As a matter of fact, I nominate vi as the one true code editor for Python. Anyone second the motion? That ought to put a stop to all the people who can't use a search function asking "which IDE should I use?" Is that snarky enough to get me down voted all the way to purgatory?
Very interesting post about this topic [Why do dynamic languages make it difficult to maintain large codebases?](http://arstechnica.com/information-technology/2014/06/why-do-dynamic-languages-make-it-difficult-to-maintain-large-codebases/) 
On /r/cpp when people say "STL", they either mean the standard library or STL-derived parts of standard library. I know this is technically not correct, but it seems like the "modern C++" community completely forgot about the STL you refer to. Heck, the current proposals of slight backwards-incompatible modifications to standard library are referred to as ["STL2"](https://github.com/ericniebler/stl2).
First of all, Python is used in the industry. I've worked at big tech companies and it's all over the place - just not a lot of production systems because of its performance. There are many reasons why you'd use Java/C++ over it though. The main reasons would be performance and maintainability. Python is interpreted and the other two are compiled and significantly faster. C++ and Java, on the other hand, are verbose and cumbersome for some simple tasks, and hard to maintain with large teams/projects. By the way, I personally dislike Python and its syntax. Do people really think so highly of it? It's okay for implementing algorithms or making mathematical models. But for anything else, I find it hard to deal with and slow.
https://www.google.com/search?q=python+3+vs+2
On a related topic, can we get a sticky "Can we get a sticky &lt;x&gt; thread?" thread?
/u/greenthumb79 for president. Write it in folks!
&gt;They have hundreds of guys but they break the app into separate browser frames (search, playlist, friends etc) each run by a small team (typically 12 or fewer) and each team has full ownership of its frame being responsible for design, implementation, testing, deployment and maintenance. This is actually how many massive enterprises work as well. This is more or less a project management and HR decision rather than company size or age decision. An example would be Facebook's monolithic codebase. The reason age seems to be such a determining factor (from what little data there is on this topic) is probably down to familiarity. People born before the 1980s, for example, probably don't use social media or forums as much for coding help and discussion. Those tools didn't exist for a large portion of their life and they're comfortable with their alternatives and social norms. But again, there's very little data about all of this.
 &gt;Python's interpreted and dynamic nature means that dealing with large codebases can be a nightmare. I've worked on insanely large python code bases with near 100% unit test coverage. Stupid unit tests can be just as much hell as no unit tests. In all fairness, you can make garbage in any language. But, python is particularly powerful and so it's particularly dangerous. I quit OpenStack because it made me hate python, after a few more projects in a few more languages I have stopped hating python and now I just hate other people. It's people that deserve the hate. /sarcasm
If you start making a sticky for every very commonly asked question, the entire front page will be stickies. The real problem is this is /r/python, not /r/learnpython. Just need proper notification and moderator moderation of /r/learnpython topics. Before posing a text post here, for example, there should be a hover button warning below it asking people if they are SURE this question doesn't belong in learnpython. 
Holy shit, well I actually went and tested it and you're right, it's valid and returns "12". That's just another reason in my book to stay the hell away from Java. It's a problem because it's impossible for the compiler to know whether the int should be cast to a string and concatenated or the string cast to an int and added. Both are valid interpretations and thus the danger of implicit type conversions. PHP is notorious for pulling shit like that doing everything it can to keep from failing.
A proprietary stock-trading tool. 
I just wanted to say that early eBay from at least 1999 to 2005 did use C/C++ (150mb binary) in some portions of their cgi executables/scripts.. now in 2015 I'm sure all that stuff is retired and I'd agree with you about tears and failures.
Great list. I'd add: 6\. vi / vim / MacVim 7\. emacs 8\. Atom.io from GitHub And I'd add a notes that: * PyCharm has a free community edition and a paid professional edition. * Sublime Text 2 / Sublime Text 3 are proprietary, closed source (license costs about 30USD, I think), but have extended, limit-free trial periods, and a rich eco system of plugins (many free, some with additional fees). 
I'm not exactly new..... I'm just trying to make /r/python valuable.
Just downvote and suggest they post on /r/learnpython.
Please post learning questions on /r/learnpython.
I don't believe 'which IDE should I use' is a learnpython question. It is however, a very very often repeated question.
Why do they swear by it? Is it simply the fact they can debug python?
https://docs.python.org/2/library/sched.html
I prefer the current way because people's opinions (especially on IDEs) change often. For example, a person might praise one IDE initially, and then change their mind a few weeks later. Keeps things "fresh" without having to scroll through a bunch of old opinions, IMO.
Hi there. You have posted a learning question to /r/python. These types of questions are far more suited to /r/learnpython, where users are actively interested in helping people to learn. Please resubmit it over there! Make sure to read their sidebar rules before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." Show them that you've tried to solve your problem and you can get all the help you need. Cheers &amp; best of luck!
Hi there. You have posted a learning question to /r/python. These types of questions are far more suited to /r/learnpython, where users are actively interested in helping people to learn. Please resubmit it over there! Make sure to read their sidebar rules before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." Show them that you've tried to solve your problem and you can get all the help you need. Cheers &amp; best of luck!
I just installed Python Tools for Visual Studio and IronPython on Visual Studio last night and it's a dream. (Although, I have to add that PyCharm is pretty good, too.) Visual Studio with Python Tools is much better than anything out there, IMHO. (Especially for a newbie.) I'm not coding to .NET, just using the standard Python libraries and using Visual Studio as the IDE. Auto code completion is just so much easier/better on VS. I've yet to find an IDE that does it as well as VS.
VIM is your friend
That video was actually what got me to look at NEAT in the first place. :) I'll be doing some more API cleanup as time goes on, because I was planning on using this library for a project or two. As I do that I'll try to get some documentation built up, or at least make sure the examples are commented well. NEAT and its variants seem pretty capable when doing maze navigation, so maybe they'd do well for search and rescue. You may want to look at some of [Stanley's publications](http://www.cs.ucf.edu/~kstanley/#publications), especially the ones related to novelty-based search with NEAT.
I would recommend Flask for something like this.
Not even vim? As someone who uses vim daily, I still get lost using vi.
Thanks for the tip. This is what I've done in the past (successfully) but this time, the various calls were way more complex than I'd seen before. I saw dozens of GETs and a handful of POSTs. Searching through all of the POSTs, I didn't see any that looked right.
I also started with vi...on a Sun 3 with a TAAC for graphics.
This is great, but be warned that some of this code isn't going to work because Pandas renamed functions. pd.Factor is pd.Categorical. There's also some deprecated stuff in there.
So is "What is python being actually used for???", but you're only allowed two stickies. And there is no amount of sticky-sticking and sidebar-ing and FAQ-ing and CSS-ing that will prevent *every* newbie from asking repeated questions, unfortunately :(
At least go for vim (I know people who routinely develop C in vim). But if you're really hardcore, you program in [ed](http://www.gnu.org/fun/jokes/ed-msg.html).
To go in reverse order, you're wrong. I'm definitely older than 25 by a signficant margin, I've been writing code professionally for over 10 years. I started off doing high performance computing, optimizing CFD in an MPI environment using both Fortran and C/C++. My frustration is that people often conflate their inability to understand the power of a tool or paradigm with it being ineffective or inferior. Static typing has a very valid set of use cases and in those cases I would choose a language such as C, which I am perfectly comfortable with. I so fully disagree with your point that static typing is powerful in every field... but your narrow-minded belief that it is certainly does tell me something - you have a hard time understanding the advantages and disadvantages of different paradigms. Only a small-minded fool would argue that either dynamic or static typing is straight-up better. They both have use cases, they can both be powerful and they can both cause huge headaches. One of the most basic jobs of an engineer is choosing the right tool for the job, sometimes it's statically typed and close to the metal, sometimes it's (gasp) Javascript, which isn't even strongly typed! I've been able to write some really elegant and simple code in Python that takes advantage of the runtime flexibility inherent in dynamic typing. I've been able to write some really well-optimized algorithms in C because of the low-level capabilities that hinge upon the static type system. So, I reiterate my point, just because you haven't taken the time to understand the paradigm represented by duck typing doesn't make it inferior. I don't barge into Haskell threads and tell them that OOP is the only right way to do things because, a) that'd be fucking stupid, and b) I don't understand Haskell well enough to appreciate its beauty. And yeah, maybe I'm a bit over the top because I've lost patience with people who conflate their own stupidity with tool ineffectiveness and go on spouting ill-informed nonsense like "Static typing, on the other hand, is powerful in every field."
I love it!
+1 for 'Gun kills Batman's mom' hahahaha I loled
Why pastebin.com? It's so filled with ads and cruft. Try http://gist.github.com
I've been using http://docxtpl.readthedocs.org/en/latest (for customer-facing reports in infosec, nonetheless)
And we need a sticky that tells people to read the stickies.
 def Sticky(n): return Sticky(n+1)
How about you use whatever you want. There is no "best", whatever you're most comfortable and productive with is what you should be using. There have been arguments for decades over this, it's getting old.
Yeah, sorry! Will try it out!
I've tried both PyCharm and Wing, and left PyCharm for the exact reasons that you mentioned: it's slow and heavy/sluggish resource-wise. It got in my way more than it helped. What PyCharm has over Wing is in its sheer number of features and its **marketing**. A lot of Python developers have never even heard of Wing IDE. But many people have heard of PyCharm mostly because of JetBrain's line of IDEs. Personally, I prefer Wing because it's faster, more stable, and has all of the features that I need from an IDE. Additionally, Wing's license agreement is much more sane than JetBrain's/Pycharm's new subscription model license. 
I don't know what that function does. If you don't find an answer here, you might want to try asking on the scipy-user list, where people are more likely to know about such things.
The function computes Ax = b for x and all computations are done in a finite field Fp. Thanks for the suggestion!
&gt; Also keep in mind, lots of people hate python. Other than the whitespace-as-block-delimiting and Python's lack of speed (Which might not matter depending on what you're doing), why would anyone hate Python? It is the easiest language to read and write. Being hard to read and write is a *Very Bad Thing*(tm), despite what Perl programmers will try to tell you.
THing I hate about PyCharm is different key bindings for copy/paste at home vs work (mac vs windows) versions.
And with ed, you can transcribe the vim source code from memory. 
meh nothing wrong with def obtener_redis_valor_e_identificacion(llave): ....... if I were Mexican
Why do you have such set up ? I mean why can you not have a local sandbox ? why would someone not develop and run code locally ? 
Here we go again. Some people prefer using a domestic cleaner called "vim", others prefer an electronic version of waterproof rainwear called "emacs". Personally I like eclipse/pydev as I don't have to upload the routine bug fixes to the highly overrated pycharm. Worst case you can always get IDLE of course. Boris the Spyder I found to be bug ridden and hence less than useless, although that was some years ago. pywin32 is perfectly adequate on Window, although Python Tools for Wndows Studio is very good. To put it another way, who really cares? Find something that you are comfortable with and stay with it. 
Why not just have a monthly discussion topic of commonly asked questions and link it in the sidebar?
I would expect it would more likely be used to develop and support the infrastructure (micro services etc), that serve IoT. 
&gt; It is simply a "file" with no extensions or anything as far as I can tell. How can I get the files back or access them. They must go somewhere, right? Just rename it to what it was and move it back to its original location. Then print out the results of your filename creation code and try again. You should be using **os.path.join** to create your filenames which will help with getting the right separators put in the right places.
Seriously! I want to see _that_ code.
It depends on what you are trying to make. I for myself can only recommend Flask. Its very easy for beginners and very easy to extend its functionality beyond what the core provides. Flask is more than enough for small to medium sized projects. It definetly is easier to learn. You can take a look here: http://flask.pocoo.org/ - some more information with more tutorials is also availabe at /r/flask 
There's nothing novel about an online key-value store. Your implementation is a mess. There's no clear class structure in place. If ever you wanted to change backends, or frontends, or your hashing library, or whatever else, you're going to have to touch multiple classes, change interfaces, data models. This makes maintenance and debugging much more difficult. What's even worse is a complete lack of security. Your outputs aren't hashed. I can crawl your DB just by iterating through URLs. There's probably some more gaping holes but, again, your code's a mess. Much more difficult to inspect. Unintentional security through obscurity there, I guess... 
Assembler and Cobol are old technology and far from ideal. But C++ is just closer to the machine, and gives you more control. It is not old and should not be considered obsolete by any means. It has an active community and it is constantly receiving upgrades (in the form of new standards) as well. It is possible that D or Rust could make C++ obsolete in a decade. But for several applications being developed right now (AAA video games for example), C++ is a perfectly fine choice, in fact it is the best possible choice. It is very telling that MS created .NET for everyone else to use, yet they keep using C++ to develop their Windows operating system.
hey everyone, this guys a phony!
Happy coding!
That's because the python runtime hardcodes utf8 on Darwin. Python is a bit absurd on proper *nix, and isn't happy with the encoding set by the system, but requires to be able to change the encoding as well, and will otherwise default to ANSI_X3.4-1968. I've had this fight with python for a _long_ time, and it's not a new problem, it's also a behaviour that differs between py2 and py3 (and that became worse in py3). On basically all other platforms it will enforce something sane, While on *nix it'll do something half arsed and default to ANSI_X3.4-1968 if the half-arsed fails. Which means that the default fallback isn't even a coherently useful thing like utf-8. ( Long story short, always force your python programs to set a file IO encoding to utf8 because one day or the other you'll get a broken [Mojibake](https://en.wikipedia.org/wiki/Mojibake) error from python.
I'm using Flask. It's pretty awesome. It uses Jinja2 for templating, which is also cool. Flask makes it really easy to test it on a localhost server, it will restart the server for you every time you re-save the main app.py file, which saves a little time. If you get into using JavaScript on the webpages too, you have a combination of JS files, CSS, HTML, and Python. As far as I know, there is no IDE that will combine all those things for you. You have to edit the various files and then check out the actual webpage (locally hosted) to see your changes working. A full-featured text editor is the way to go. Sublime Text is popular, I use Vim (MacVim) with a whole bunch of plug-ins to make it more like an IDE. Syntax highlighting, linting, stuff like that. I took the Udacity class called Full Stack Foundations, it teaches you to make a database-backed web app in Python. Probably worth checking out the videos and stuff, the courseware is free. If you do the whole class, they make you do some early development by hand (very painfully) before you get to use Flask and templates... I guess to help you appreciate how awesome these tools are.
 seq = range(1, 10) zip(*[iter(seq)]*3) [(1, 2, 3), (4, 5, 6), (7, 8, 9)] That's actually pretty cool. I remember running into this situation a few times and the stackoverflow page on it suggested something like: zip(seq[::2],seq[1::2]) which seems horribly inefficient compared to using iter.
I don't want to compare Python 2 with Python 3 and PyPy because you can't judge the speed of the interpreter by only one JSON benchmark.