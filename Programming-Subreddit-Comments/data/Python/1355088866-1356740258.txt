I'm not trying to push anything... Fwiw, figure it out yourself.
I use Komodo Edit, but pretty much any decent IDE will give you autocomplete and "go to definition..." functionality, along with file trees and other features to make jumping around easier.
i wasn't referring to you i was referring to the python community. stop being so precious.
classy
^^^^^^^^ this * 10000000
Such as?...
&gt; the community is causing a slow transition. As of a few months ago, at least, the transition was happening more or less according to schedule. It was *scheduled* to be a gradual transition, (unlike - for example - the systemd vs. sysvinit migration).
I'd enjoy the blatant plug more if I lived in London. ;)
I'm very interested in helping pyglet fix its issues on Ubuntu. It's been a huge source of misery for me during PyWeek.... Unfortunately I'm not terribly familiar with pyglet, so it would be hard for me to produce a minimal example. I identified several pyglet games [in this thread](http://www.pyweek.org/d/3400/) that randomly segfault on me, but it's not very reproducible. Do you think you could give me some pointers on how to put together something that would be useful for the pyglet community, given that I have little familiarity with it myself?
Not everyone uses bash.
Why 3.2?
[PyX](http://pyx.sourceforge.net) is an alternative to matplotlib. It focuses on output quality and it uses a rather different approach to express your content and settings.
Is it really? Or are you just saying that?
Whoa, using python to create graphics I can use with Latex? AWESOME! Thanks for showing me this.
What? matplotlib is pretty easy to make look good, it's just a pain to get started with.
Python 3 is one of those things you really want to use until you realize the APIs and Libraries you want aren't supported yet :(
Ninja-ide does that I believe. :D
It was a bad joke, but thanks you for the links. Looks like a really interesting organization.
Sadly, I am one of the unlucky few who knows my reasons. The implementation of `/` for float division and `//` for integer division would be enough to push me into using 3.3 if it weren't for the packages I use. 
Try a different distribution and see if the problem persists. If it doesn't, report a bug in Ubuntu.
Then use python 3. Django is one one of the only reasons to stick with python 2.
I used ChartDirector. It makes very nice graphs and there are bindings for lots of languages.
They are at least two ways to do it: 1. Simple but less control way phantomjs https://github.com/ariya/phantomjs/wiki/Screen-Capture 2. Complex but precise control way Reportlab http://www.blog.pythonlibrary.org/2010/03/08/a-simple-step-by-step-reportlab-tutorial/
Everyone has given you an answer as to how to chase definitions in their favorite text-editing software. I am hoping someone will answer your last question: "how do you approach reading large codebases.."
You can use a template system (like mako or jinja2) to template your latex file, and just fill in the template with python.
Answering your second question; reading large code bases: * Check it out using git (if possible). * Branch it, pick a particular subsystem that I am interested in and make comments everywhere! * Create a test case and walk through the code with a debugger. * Read the developer docs, dev blog, plugin docs etc.
eclipse with pydev has a object navigation pain that works the way you describe. Spyder2 for linux also has this feature. 
Upvote for PyCharm. Unlike Eclipse + PyDev, which I used for a couple years, it doesn't force you to put source in its "Workspace." Plus, it has great support for virtualenvs, allowing you to jump to the version of a library you're actually using instead of what happens to be global on your system. It supports remote interpreters, like on VMs, as well. (Eclipse may have this support, too; just adding it as a feature I quite like and never found/made use of with PyDev.)
Yea, #python. There are some people in there who seem to only want to feel superior to other people. If you can only give advice in a condecending way, then maybe teaching isn't for you. Maybe it's an IRC thing that brings out the worst in people, I don't know. Anyway don't listen to bad advice from the most outspoken people on #python, they are not there to help you.
my brain needs a memory upgrade. python has so many awesome features but i forget to use half of them..
Use wkhtmltopdf.
What part of that is bad advice? I happen to think its better advice than here: the second most up-voted answer is just "3" without any sort of explanation!!
Did you read the [OPs post](https://plus.google.com/114471118004229223857/posts/4Yo2XXPqy45)? It's good advice. The advice you got on IRC was to stay on 2 or switch to another language, seriously? That is bad advice coming from a bad place.
Now that's a sensationalist title
I laughed at it though, so it at least did that right
You just have to look at the imports at the top of the file. (Imports are almost always at the top). Then just press 't' on github and type the filename. Hardly 2 steps. If you're on Sublime Text press 'Ctrl' + 'P'. 
You can just use `from __future__ import division`, or specify -Qnew when you run the program.
When it comes to "this guy is either seriously confused or just trolling", I'm trying to typically treat people seriously, just in case.
Haha the day I'd see a well used Romance of the Three Kingdoms reference on Reddit...then I saw that it was a video game reference -_-
Fat stock offers at an exciting startup sound like a good deal to anyone.
Matplotlib has a PGF backend since 1.2.0, which can output either a (LaTeX-compiled) PDF file, or a PGF file you can `\include` in your document.
ReportLab is what I've used in the past. Extremely useful API.
I would recommend generating DocBook or possibly XSL-FO directly, but I'm a big fan of DocBook, and many people aren't. I also know (and kind of like) XSLT. LaTex would probably be easier to setup. You could also use something like reStructuredText or docutils-xml which have a pure-python code path. (rst2pdf) That said [wkhtmltopdf](https://code.google.com/p/wkhtmltopdf/) exists, and it's by far the best tool for fully-automated converting of HTML to PDF. There are a handful of Python libraries that generate PDFs. PyQts/PySide have bindings to the Qt PDF Generator/Qt Printing System: never used this, but It looks convoluted. PyPDF looks pretty limited, and is more for manipulating existing PDFs than generating them from scratch. ReportLab seems to always get mentioned, and I know some people swear by it, but I don't like proprietary stuff like that.
At work we use Python 3 in our products and Python 2 only where we need to for legacy reasons - compatibility with the SCons build system to be precise. For personal projects - including those published to PyPI - I'm now supporting Python 3 only where feasible unless somebody makes a specific request for Python 2 support. Python 2 is now firmly legacy.
I may get some flak for this, but *sometimes* I find it useful to use a debugger to get a sense of program flow.
I also think matplotlib has severe usability/learnability issues with it's API design - made worse by the fact that there are in fact several APIs such as pylab and examples are not consistent in which API they're using.
in order to get comparable quality, one had to rebuild at least the TeX core in python: all the typesetting algorithms at work there aren’t trivial. executing a binary is surely not overkill if there exists 1. nothing comparable in your programming language of choice 2. no bindings. what one could do is somehow using LuaTeX to write bindings, but that’s not the scope of what OP wanted.
Good god! Thanks for showing me that blog post. My plots will be the prettiest on the block.
The way they build an iterator in the YouTube example seems weird to me. If I was just making a function that would return a generator, I would use the `yield` keyword, but I think when using a class it's more common do have `__iter__` prepare the class for iteration by setting initial state etc and then return `self`, and implement what actually happens on each iteration in the `__next__` method.
You can do plenty of 'serious stuff' with Python 3. Some legacy projects can't run on it, that is precisely what 2.x is for. If you have a good reason for using 2.x, you will know precisely what it is - a specific incompatible dependency which won't be updated and which you can't do without. By now, most of those are not actively maintained anyway. You won't 'be lost without library support' if you build a new project on Python 3.
You might be interested to know about python texlib (it's just TeX line-breaking, but that's the only algorithm anyone cares about) and on top of that [bookbinding](https://github.com/brandon-rhodes/python-bookbinding) which combines texlib and reportlab (bookbinding was released at pycon.ca, and is still a little "early".)
I would generate reStructuredText files, and then use rst2{html|pdf}. In fact, that's how I generate tests-results reports on my current job.
thanks! seems a nice idea if by line-breaking you mean linebreaking+kerning with ligature support. one could build upon this, and add vertical stuff to support pagebreaking with widow/orphan config and page layout (KOMA’s typearea, [this](http://wiki.contextgarden.net/KOMA-scrartcl_Type_Area) would be a start)
What data? I use Tex to write math and the journals seem to happily accept tex files.
Here's the documentation on all the [python special methods](http://docs.python.org/2/reference/datamodel.html#special-method-names) for classes.
I always go from two directions: first, I generally look at any example code they have. That will tell me the primary modules being used at the core of the project. Then I look at those modules. Finally, I look at the supporting code -- utility functions, etc.
This!
They're not cherry picked. I use them every day.
The problem with using the instance itself as the iterator is that you can have only one iteration over that instance in progress at a time. Sometimes this doesn't matter, sometimes it's a critical flaw. Since it is easy enough to support multiple iterators, however, why not always do it that way?
I use [xhtml2pdf](http://pypi.python.org/pypi/xhtml2pdf) which was formerly known as Pisa. I use it within Django, so I have "pdf" html templates that I use to generate the PDFs. Works pretty well for me.
I suggest having your script generate [pandoc markdown](http://johnmacfarlane.net/pandoc/) (it supports tables, graphics, math, etc.), then have it shell out to `pandoc` to create the pdf. 
Yes, my needs are simple, and Latex seems like it might be overkill. Each 'report' will be 1 page with a few plots and some text/headers with some autofilled numbers...
I'm doing a similar thing on a Django application. I render HTML and then pass it to a phantomjs script that uses webkit to "print" it to a PDF. Works reasonably well and better than any other alternative I explored.
I've often found this helpful. `pudb` (available on pypi) is actually pretty nice for this.
I tried this method and it was great except for one thing, I would describe the image support as primitive at best. I wish I could have gotten past that though because it was awesome being able to easily make a django template spit out a pdf. Edit: because I can't seem to complete my thoughts today.
Ah, I haven't done any images other than a simple logo at the top, in my usage.
At self.previous_employer I had a similar text formatting + PDF export requirement. We were developing a web application, and it was very important to our product team that the web version and the PDF version looked "the same" which meant identical except for all the web navigation removed. We originally used [Pisa](http://pypi.python.org/pypi/pisa) but found it very challenging to write CSS that would be properly interpreted -- we effectively delivered two distinct versions of the report. On a second pass through similar requirements we opted to use [PhantomJS](http://phantomjs.org/) instead, and that solution was much simpler, though a little trickier to install. Like I said, we're doing a web application in the first place, and we're exporting an existing report to PDF. That might make my preferred solution less awesome for you, but it's still my preferred solution.
yeah. latex is probably overkill. If you decide to go that way at some point though have a look at LaTeX - beamer. You can auto generate quite nice looking presentations. I have actually used this to give a progress report every 3-4 days in the hot phase of my phd thesis :) 
&gt; One thing is that I don't think the notation is very clear or concise. The original goal of this blog post was to show that you can create a task loader with whatever interface you wish... using decorators, classes, JSON or anything that you can convert to a dict. No interface will make everyone happy and a dict is the most simple and flexible. Anyway I will start working now on my next post showing how to use decorators :D &gt; perhaps the front page could focus more concisely on what benefit can I expect to get by learning this slightly complex tool, and how the use case differs from that for make. Thanks for the feedback. Are you talking about [doit](http://pydoit.org/) page? I sincerely dont know how to improve more in this aspect... IMO it's all there :D. More specific feedback is welcome.
WeasyPrint dev here. Please ask if you have any question about it. Of course you can use it on HTML genareted from jinja, Markdown, docutils or anything.
I use a similar setup, with some Mako added to the mix to customize the output.
Jinja2
Hmmm. I would have to disagree on that. I used Jinja2 with a recent very small project. I found it got me 90% of the way there, but then was too restrictive in the fact I couldn't embed code blocks. I know it's generally considered bad practice, but this was a rushed project that had to go out the door yesterday, it was easier to code the display logic in the template rather than breaking everything out into twice as many variables in the controller.
Yeah.. code does not belong in templates!
I'd say anything that can't be written by a *designer* (who has never written a single line of python code before) shouldn't be in a template.
This is just one user's feedback, if you don't find it useful that's entirely OK. In summary, I think new users considering doit are going to weigh a high apparent interface complexity (doit expects users to write functions which return dicts which return certain magic keys mapping to lists of functions declared inline, etc.) against a lot of uncertainty that this will really be that much better than waf, scons, make, etc. For the first - while I don't think you need to advocate decorators here, or abandon the old API, I do think it will be useful to also provide a simplified interface: dependencies here, actions here. That was the important thing about your decorator example. The use of @ might not help at all. For the second, on the doit page - my main nitpick is that it takes too much effort to determine what precisely this does and why it's better than related tools and for what family of use cases. There is just a lot of text and I have to work hard to get out the relevant stuff. It might be all there, but it's not all that clear and up-front, since there is much more going on. You have to be pretty strongly interested not to give up here. I would get to these issues very concisely, at the very beginning, one section of no more than half a page or so. (I'm not saying this is easy!) Only after that would I go into more background, etc. But, that's just what I would try to do, it's not my project :) For a project I'm building I considered this as a watchdog replacement (`doit auto`) - also since I am considering using pytest-incremental which depends on doit - except that I think I would want task definitions to read cleaner and would miss the ability to watch files on systems without inotify. 
I know this has relatively little to do with Python itself, but it's open source (I'd love people to contribute!) and it can be incredibly handy in web development and design. We use it daily at work, so perhaps some of you guys might have a use for it too.
You cheated by putting cats in it :P
Scripts. Currently setting up a script to manage repositories and access to a Subversion server based on user roles in a database.
Well, you said it - it's pretty rich in features and works. I mostly use it when I'm exploring data, prototype code etc. from an interactive IPython shell anyway, so the pylab interface works ok. Whenever I have to write a paper that is supposed to be published, I use ggplot2 for the plots anyway. Meh. Show me something better, and I'll consider that. But let's talk about the shortcomings: what do you guys hate about the interface? Specific examples would be great.
Legacy, baby! (I help look after a Zope site that's 12 years old - yes, from before it was even called "Zope")
Oh my... This is exactly what I wanted for Christmas (and the rest of the years). I was so jealous of PyCharm's autocompletion... but I never gave in, never!
They aren't representative, you have chosen them to advance the view that Python 3 is unusable. Years have passed, things have changed, that really isn't the case now
I know they're not representative. They're still major libraries that are stopping many developers from upgrading. To say "Python 3 doesn't lack support" is ignoring a *huge* amount of devs who rely on those projects every day. It sucks, but you can't just ignore it.
[doit-task-decorator](http://blog.schettino72.net/posts/doit-task-decorator.html) I value your feedback. I always had trouble to explain what is *doit* in a simple way. For me it is just a more generic (modern) build-tool. But when I say build-tool people just think about compiling C or java, and about deployment! &gt; It might be all there, but it's not all that clear and up-front, since there is much more going on. Another point is that maybe some people use *doit* for a different purpose than you, so what might be cruft information for you might be important for them. Anyway I would be happy to get a patch from you improving the front page :) 
&gt;waiting for the sublime text plugin. Incomplete and hasn't been worked on for a while, but: https://github.com/svaiter/SublimeJEDI Would kill for that to be functional :(
It depends on whether you not you plan on developing small pet projects, are actually into production that will have users depending on and a business to support. Missing out on libraries and tools like Django, Flask, Twisted, PIL, boto, mysql-python, fabric, paramiko, python-openid, python-ldap, python-oauth2, mechanize, and a lot more that I have yet to run into during my professional work experience, Python 2 is a save bet or else you will regret it later after you rolled your own code or used some buggy/alpha/poorly ported libraries to replace the listed above. Python 3 is a much nicer language, but has the same problem with most other immature modern language coming out these days. They may be *beautify*, but they aren't *useful*. A language is only as useful as the libraries available for it. 
I might see if I can write one, depending on how difficult it is
Haha because it's not free. :)
So get forking.
If you need help, please contact me. Writing a plugin just for autocompletion is really easy (~20 lines Python code).
I'd love to try out kivy, but I've been having a hell of a time getting it to run on my macbook. (OSX 10.6.8).
Owh...no collision. :(
I also use vim, and jedi-vim. I don't see why you oppose them??? Autocompletion is a great feature of vim…
I don't get the problem with paying that people seem to be having. If it substantially increases your productivity, shouldn't it be something that you want to pay for?
Here's a few libraries I use for machine learning work (besides the one you already have listed): * [scikit-learn](http://scikit-learn.org/) A library filled with many of the most basic machine learning algorithms (Naive Bayes, SVMs, decision trees, clustering, etc), with both supervised and unsupervised learning. * [pandas](http://pandas.pydata.org/) A R-like data analysis and modeling library with lots of great statistical tools for working with messy data (especially missing values). * [pymc](https://github.com/pymc-devs/pymc) Probably more specific to my line of work, but it's a library implementing several more complicated Bayesian models and algorithms, notably variations on the Markov chain Monte Carlo algorithm.
Really nice. Using it with emacs, so far so good!
Disclaimer: I'm not really a licence expert. The reason I used LGPL 3 was that changes to Jedi are being pushed back. The way I understand LGPL is that it allows products with Non-GPL licenses to use Jedi. At least that's what I intended when I chose LGPL 3. I would also invite commercial products like PyCharm to use Jedi (because imho it's better).
For me, it's not free-as-in-beer that I'm looking for, but free-as-in-speech. For basically the same reasons as you'll hear everywhere. That said, I use vim, so I wouldn't use PyCharm anyway.
I'm currently using python-mode for vim, which (loosely) integrates with rope. This is working fine for me, so is Jedi better enough to transition to?
Stab it with fork until it bleeds out. 
Great progress!
I think I may have to look into writing an autocomplete plugin for Kate. That would be really awesome.
still missing mercurial :(
R.
An ignorant question: is it the case that most of the libraries that don't yet support python 3 have just been abandoned and will never support it?
and Matplotlib. And PyAudio.
Seems like there's some fairly serious issues in Python 3 making a port sub-optimal: http://mercurial.selenic.com/wiki/SupportedPythonVersions
In business context, it will be easier to find a java guy (than a python guy) to replace you, when you'll quit or when you'll be fired ;-) "easier" to maintain.
I've still never seen `__iter__` use the yield statement. I guess it's fine, though if you want the iteration state to be picklable you will need to write an iterator class explicitly.
In general it takes a lot more lines of code to do the same thing in java than python. This is only partly down to syntax, but also the design of the standard library plays a part. (A simple example is getting an item from a list, with a default if it's not present). As you'll write less code, there's less to keep in your head + dev is quicker. Also: http://blog.vivekhaldar.com/post/10669678292/size-is-the-best-predictor-of-code-quality The compile/run cycle is fairly handycapping timewise if you go from python to java. It's very frustrating going from python to java, everything you do results in a feeling that it should be a few lines of code, not 5 or 6 classes. You can probably use jython to interface to their existing code. With python there's a lot less syntax - that means more of the code on the screen is expressing what your trying to do, as opposed to boilerplate - since what you can keep in your head is probably measured in screens, that speeds up debugging too. I haven't used java since JSPs, but just hitting refresh to view a django page, rather than building a war file, restarting tomcat is the difference between night and day. Urg, what else. .. the overabundance of xml config in java - xml is for computers not human consumption. At the end though, the java devs will be happy with all of the above, so I don't know if any of those can be distilled into convincing arguments for them. What's good about java... ? For me it was the speed, so when it came to graphical apps + also on android it was all I could use. [edit: typo conventional/convincing] 
Cheers, that's very helpful.
They have no plans to fire me in the near future but thanks for the input :P
Good luck - if you'll look around you'll read similar things. The harder job, is to frame the argument in ways that they'll understand, otherwise it's easy to come across as just attacking the language. (I have the same problem with a friend who sticks to old style java to even persuade him to use java 5 stuff (generics etc). Sorry for the run on text, currently @ work :)
well if you care about one, why not find out and adopt it if necessary?
That's why I'm about to post something similar in /r/java and see it from the other side. I'm not looking to fight with them, if there's something I can be doing better I want to know it. Even if it means not using Python.
Heh, somebody has been looking at the android API. Can't wait to get round to trying kivi, looks great :)
Correct. But it is not included in that list.
Spyder is also included in [WinPython](http://code.google.com/p/winpython/) (something like a portable version of Python(x,y) -- the same author) and [Anaconda](https://store.continuum.io/cshop/anaconda) (Community Edition is free). Travis Oliphant -- CEO of Continuum Analytics -- is known as creator of SciPy.
Paste is dead. We need to ask Chris to release its partial replacement in a standalone project :)
True. I hadn't considered it as much as maybe I should have.
Besides the language features, there are also some cultural or other kinds of reasons for Python I've encountered: * Python (and Ruby, Lua, Haskell, etc) developers are more likely enthusiasts than programmers of COBOL, Java, C#, Perl, etc. So, your use of Python can attract the kind people that work &amp; study on their own time - because they actually really love to program and they know a lot more innovation is happening in these languages than in Java. * Java is a platform rather than a language. And so, there's a truly vast amount of stuff to learn and know in order to master it. This doesn't leave much time to also learn much about the business or how the local systems work. * Java has its own way of doing quite a few things and can be inflexible. Python, on the other hand, tends to be more adaptable (functions or classes for example). I've run into issues with Java developers who have derailed so many data warehousing projects - by insisting on treating every single row as an object (when they have to handle tens of millions at a time), or by resisting proven dimensional modeling in relational databases because they didn't work well with Hibernate or they wanted an object database, or in refusing to including reporting with their app because they simply don't like reporting (this is less true now that there are some high-profile Java reporting apps like JasperReports and Birt). The cumulative affect of these three can be very dramatic for certain types of projects.
In Arch Linux, `python` is `python3`. Shebang lines in scripts are fixed in the PKGBUILD of their packages.
How come greenspan hasn’t responded yet?
that sounds more reasonable. That is, you use the tools because they are good tools, and they are good tools because they are created by other developers, who in turn want to use good tools, etc... I like open-source free software in that it works. it's a good ecosystem where developers can build on the work of other developers, without worrying about patents, opaque interfaces, etc. In other words, it's practical. It works. If it didn't work, I'd gladly pay for an equivalent commercial software that *did* work. I do this all the time. In a fitness landscape, those products which generally tend to work the best fit a particular niche. Free-as-in-beer software has done that extremely well, as has commercial software. Both have their place. But when someone suggests that the main choice for their platform stems not from practicality or appropriateness to the task, but rather because it's (choose your dogma), it's like saying you're vegetarian for the principle of it. I applaud the principle, but don't be surprised if you're not invited to many dinners. In other words, it's not a choice to be taken lightly, and like rms, you pay a heavy price. most people are not that committed to any ideology, and I think that's a good thing. it allows for compromise, and for hybrid ecosystems, which lead to greater variety. and fewer flame wars.
I plan to but at the same time I'm trying to go in as prepared as possible. Thank you.
By any chance is this a development team internal to your company? It may just be that they've ~~mis~~labelled themselves as a "Java shop". But as /u/linuxwhisperer said: Java makes you pretty damn near replaceable. Python isn't (yet) an entrenched corporate language whereas Java is more of a lingua franca of Corporate programming.
That looks great. My previous attempts at getting completion modules to work in emacs were a mess. Can you comment on how it identifies the type of a parameter to a function? Does it scan for calls to the function? Can it infer that if I call p.foo() somewhere, the type must be one that defines foo()? Is there any way to give it hints for things like pandas DataFrames or named tuples that dynamically define their members? Is it smart enough to allow completion of member names that were used elsewhere when it can't infer a type? 
Komodo please!
I might if I were in that situation.
Dirdy
Imho, yes. It's better for autocompletion/goto. But python-mode provides many different things like highlighting of bugs, etc (I'm using syntastic for that). Jedi is more powerful, because it displays things like function calls directly above the functions. In short jedi-vim tries to be good at only one area: Understanding your code. It leaves highlighting and VIM specific stuff to you and your other plugins.
I don't know much about IT software development but I've seen they like to document each part of the implementation in great detail specifically data types of variables and return values of methods/functions, and they like to see that explicitly reflected in the code. Python is dynamically typed so you don't have to specify data types on the code unlike C or Java. Maybe that's one of the reasons IT hasn't adopted Python yet, I'm not sure, what are your thoughts?. 
Sure! 1. It scans for calls to the function. 2. I don't understand what you mean. 3. I haven't used pandas, but I'm pretty sure that this is something where Jedi sucks. Hinting is possible, just use Sphinx style docstrings (Hinting in multi-dimensions might be hard though). Also Jedi understands isinstance checks. If you have any idea how Jedi could understand something like that please share it with me. Because normally I'm having a hard time to infer the types just by reading code in such examples.
I don't do particle physics at the moment, but that's what I intend to get into during graduate school. What in particular makes this package nice for particle physics if you don't mind me asking?
**Edit: I stand corrected by people who know more about programming languages than I do. Better listen to them ;)** One major difference is that Python is a Scripting Language (a very potent one but non the less) and Java is a full blown object oriented language. This is nothing to worry about when just programming smaller stuff. But if you need to handle bigger sets of data it becomes very important. For example Map Reduce. On Hadoop you can perform native map reduce with Java or do a streaming map reduce with paython or another scripting language.
In pandas, you create an object that's like a 2d numpy array with named columns. Then you can access the columns by name, such as *dataframe.column5*. I imagine that would be extremely hard to handle without a special case that noticed the *columns=[...]* constructor argument. However, in general you could autocomplete members that you saw used elsewhere in the code when you can infer that two objects have the same unknown or incomplete type. Do if I call x.foo() somewhere, and y is the same type as x, y probably has a foo() method too. Also, if I have a function with parameter x and I call x.foo(), you could search the code for other objects where z.foo() is called. Then x could autocomplete methods defined on z's type, or invoked on z if z's type is unknown. It would be a usability question whether to err on the side of more or fewer potential completions. If the method name is unique across known classes, that's a pretty strong type hint, while calling *\_\_repr\_\_* is not.
Have a look at the paper here - http://www.biographixmedia.com/stew/cv/index.html#publications - the link to "A gentle introduction to Programming"; Stew wrote this as an argument to teach Actionscript instead of Java in CS undergrad courses, but a similar argument holds here: The message is that Java requires a lot of setup, compared to the amount of code that addresses the solution (in his paper, in teaching algorithms). The conclusion of his paper - that CS students would have more knowledge than those from competing schools - applies to your experience, in that your work was productive and successful. BTW - I don't believe the (historically correct) argument that you would be easier to replace with a Java programmer holds anymore. Python runs some pretty major stuff - from new sites, to dropbox, disqus, and reddit (among many, many others; and, of course, Google started as a Python app, and still uses a lot of Python in its core). Java and Python are (once again) both in the top 10 languages, re: http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html Trust your gut, and collect data to support your instinct - don't get "spooked" by those who didn't share your experience. Best of luck! 
Alternatively, numpy + scipy + matplotlib.
I use pycogent for bioinformatics work.
Hmm good idea! I didn't think about that. If you don't want me to forget it, please add a github issue :-) I really think this might be an option. It shouldn't be too difficult.
&gt; One major difference is that Python is a Scripting Language (a very potent one but non the less) and Java is a full blown object oriented language. Could you clarify what you mean by this? Python supports object-oriented programming, and compiles down to bytecode, like Java. If you're using Jython, it actually compiles down to Java bytecode. &gt; On Hadoop you can perform native map reduce with Java or do a streaming map reduce with paython or another scripting language. I believe that this is because Hadoop is primarily written and designed to work with Java, not because Python is a "scripting language". You'd need to use Hadoop Streaming, Hadoop Pipes, etc. to run a .NET or C mapreduce job as well.
No one mentioned ipython notebook's has this built in. Rabble, Rabble, Rabble!
You can just ignore it. It doesn't matter.
I'll give it some more inspection. The existing codebase to worry about for me is all Python and written by myself so far.
It's mostly reading in CSV data, some CRUD stuff from the database, a bit of HTML formatting and more recently some basic statistics stuff. PHP would be an acceptable choice for most of it.
the suits have a thing for JAVA and PHP (the last one, specially combined with Satan's little helper: Zend Framework).
One thing Python has going for it: it's a hell of a lot easier to teach python to a java programmer than teaching java to a python programmer (although, I haven't met too many python programmers whose only exposure to programming is python; python is a perfect language for beginners, but beginners are almost never taught it.)
I think reddit is using a hacked up version of a very old Pylons. How do you like Pyramid though? I've been looking forward to starting some project with it, but unavailability of python jobs in my area have switched my focus to other frameworks/languages.
Do we have one of these for pypy anywhere?
If you use the shell terminal, you can use git.
Cool, thanks! I've written a plugin for gedit before, so I think I'm okay, but I might take you up on that offer. My biggest unknown is the source file path for new and unsaved documents, but I suppose I can save them to a temp file if I have to, before calling your library. 
I have heard that too.
It's one of the things on my mental list of "why I want to stay with Python".
&gt;does very little for you well it's kind of what I'm looking for.. I have had some experience with webapp2, so this isn't a big concern. I've heard from other developers (probably with as little pyramid experience as me) complaint about certain design decisions in pyramid, so I was wondering how easy it is to shoot yourself on the foot with this. I guess I'll eventually have to take a look at it.
That will probably be easier to do in python and just as fast 
The most common web framework used in Java is JSF. The latest version (with annotations and convention over configuration) is pretty decent but it's much more rigid than say Bottle+Python. It defines its own set of components you can use in your webpages and automatically populates fields on a class automatically for you. It really abstracts out most of the web's aspects such as HTTP statelessness, benefiting you with an easy to use interface but making it very rigid if you want to do something the framework developers didn't predict. Now Java and Python aren't so different. Sure, the syntax is different but both of them are imperative, object-oriented languages. They mainly differ in one being statically typed and the other dynamically typed. APIs however are VERY different, as Python prides itself in being an expressive language where simple expressions achieve a lot whereas Java is a very verbose language where even simple stuff requires quite a bit of code and configuration. Also, most configuration of Java frameworks use XML, which is simply horrible. And yes, Java is much faster than Python. Sun (now Oracle) has poured millions of dollars on making Java fast.
This is an interesting angle I'd not considered, thank you :)
The program is currently running (very comfortably) on a server with 1GB of Memory. We're a long way away from that issue but useful to know :)
disclaimer: i like the WOS, but /u/ubershmekel should at least fix the superseeded packages. ok, updated buglist of the WOS: 1. superseeded packages: * ssh → paramiko * pylons → pyramid 2. plugins are weighted as much as standalone packages. for the following main packages, dozens of plugins populate the list. my opinion is that they shouldn’t be weighted as much as standalone packages. * zope * plone * django
That part about doing non-standard things, that's where I'll hit issues. Loads of the things being asked of me are things nobody would have predicted.
I find the autocomplete so useful in ipython I do wish I had python aware completion in vim as well. You bring up a good point that autocomplete without the ? or help() features from ipython available you might get into the java-esque bad habit of programming-by-tab-complete.
Useful to know. As someone that uses both, how long would it take *you* to rewrite a 10kloc Python app into a Java one?
A young and trendy language.
Well, that's encouraging :)
It's hard to say. Depends where is this code. How complicated model is. What frameworks did you use? Are they similar one available in Java? How difficult the domain is? Trying to look at my python project at home and guess. Hmm 3-4 months at least I would say. 
YouTube also runs primarily on Python.
Just as fast? Don't you mean several times faster? Or with PyPy several **more** times faster.
&gt; I will be looking over your code while realizing I am not a special snowflake and trying to learn some good habbits! Ha ha, just keep in mind that I had a very limited scope when I wrote this: I just wanted something where Link walks around and you can view the full overworld map. Hence the use of global variables everywhere. I'd be interested in checking out your game as you make it though. Do you have a link (no pun intended) to it?
I'm gonna take a moment to pimp my Flask/Sinatra-ish web framework, which I've been developing with the explicit goal of supporting Python 2.6 - 3.3. Check out [hoboken](https://github.com/andrew-d/Hoboken) on GitHub. Test coverage for all stable versions is 100%!
Like many on here I secretly use python to cheat. There's a lot of busywork stuff we need to do and every now and then I'll automate it using python for fun and to spend an hour or so to save 5 minutes or so. :-) (I could argue that it scales over time so that I come out ahead, but it's honestly at best a wash. But I built something so it doesn't matter. Whether it's Legos or Python sometimes you just have to build something. It can't all be work work work.) 
&gt; Would you please make your code to read the map data from the ROM available? No way. :) The actual rom uses a ton of tricks to squeeze out the most memory efficiency for the maps. The point of my project was basically to get a bloated (but easy to parse) form of the overworld map, because these days 67k isn't all that much. I did find this tool for editing a rom's overworld map directly (it's kind of hard to use though): http://www.romhacking.net/utilities/187/ In fact, the romhacking.net site seems pretty good for this kind of thing: http://www.romhacking.net/games/712/
I would easily assume Java twice as much time as Python. 
Neat tool. I found one line in one of my sources that wasn't indented properly. I'm curious, my editor strips spaces from lines that are 'empty'. This has never affected any of my scripts, but I noticed that reindent.py adds them back. Is there a standard for this that I should be aware of?
Acceptable as in it would get the job done, it'd not be pretty but you'd have a working product. That said, another team were doing something similar and used PHP. There were 3 of them (though I had more programming experience than any of them), their team is apparently being disbanded.
So did you use the linked tool to export the data in a usable format, or did you still end up writing your own? I know this is not the point of your project, but that's where my interests lie :) BTW, great work all the same, on this and on your free books.
I know these aren't comparisons but it highlight quite a lot of differences between python and Java: &gt; The Zen of Python &gt; Beautiful is better than ugly. &gt; Explicit is better than implicit. &gt; Simple is better than complex. &gt; Complex is better than complicated. &gt; Flat is better than nested. &gt; Sparse is better than dense. &gt; Readability counts. &gt; Special cases aren't special enough to break the rules. &gt; Although practicality beats purity. &gt; Errors should never pass silently. &gt; Unless explicitly silenced. &gt; In the face of ambiguity, refuse the temptation to guess. &gt; There should be one-- and preferably only one --obvious way to do it. &gt; Although that way may not be obvious at first unless you're Dutch. &gt; Now is better than never. &gt; Although never is often better than *right* now. &gt; If the implementation is hard to explain, it's a bad idea. &gt; If the implementation is easy to explain, it may be a good idea. &gt; Namespaces are one honking great idea -- let's do more of those!
 import this 
But that's what the enthought distro includes, and more. 
you missed the indentation
Function calls are slow. The built-in data structures are implemented in C and highly optimized. You can write blazingly fast Python code if you are careful and know what to do. The GIL may be a problem performance wise if you think you would need threading, but then just use multiprocessing, it even has got the same API.
Depends on what you mean by pretty. Svgwrite generates svg which is vector graphics viewable, zoomable in a browser. http://packages.python.org/svgwrite/index.html 
&gt;You can write blazingly fast Python code if you are careful and know what to do. Is there a good reference for that? I would be happy to dig that topic more. 
I'm interested in that as well. I always had automated code cleanup tools remove trailing spaces in a line (and therefore empty lines have no spaces in them). In python it is also ambigous how many spaces an empty line should have (as many as the first non-empty line above or below?).
I'm going to contact the PyDev guys. But I still have to do one speed optimization first. Hopefully they are willing to use it :-)
right. was just being a little more explicit about the packages, or specifically the packages i use.
Any that stand out as good examples?
That list is based on downloads from PyPI. That probably underestimates matplotlib installs, because installing it with `pip` requires various development headers to compile it. More people probably get matplotlib through binary package managers or all-in-one Python distributions. And indeed Ubuntu 13.04 will have [python3-matplotlib](http://packages.ubuntu.com/raring/python3-matplotlib) available.
A slightly better view on the progress is at http://py3ksupport.appspot.com/ which is curated and handles issues about abandoned packages and those like Plone which have a large number of packages listed and are never, ever going to be ported.
I believe the point of http://py3ksupport.appspot.com/ is that it takes these issues into account.
ah, awesome! that page is definitely better than the WOS (sorry shmekel), yet i didn’t know about it. too bad the design is that… basic.
I'd recommend my Pyganim module to you to handle the sprite animation. Here's the download and tutorial for it: http://inventwithpython.com/pyganim/
I never had a gotten a answer for this. Beyond the JVM and the number of libraries tied to Java, I actually like the static checks at compile time for Java. You tend to catch many obvious errors especially with a large code base. Add in generics and you have even a little bit more type safe checks. If you have large code bases, hundreds of thousand of lines of code, you can do a compile and avoid those major compile errors up front. Also, Java hasn't had too many major releases. You Java 1.4, 1.5, 1.6 and now 1.7 and Java is good about backwards compatibility. So pretty much if your code compiles, it will mostly run or at least compile. With Python and the no static compile checks, you lose a little bit upfront error checking. How do you deal with a large code base? What if some adds in a small typo, would that cause issues for the entire code base and you won't know until runtime? For me, I won't mess with Python minus the tiny 100 line script. I am sticking with Java, Haskell, Scala. Also, can't you still compile with Python? Do people normally compile?
TL;DR if you want to a build a pretty profitable software development career without much effort. Keyword on "not much effort". I would go Java. Python is great at smarter startups, great for smaller projects, but the larger business industry tends to favor Java followed by C#.
Ah yes, the manual developer unit testing. What could go wrong there. &gt; static compile time checks do not mitigate the need for rigorous build testing. True. But you can avoid the most obvious errors at compile time. And it sometimes helps taking code from an external source (say the web) that doesn't have unit tests.
If you're a single coder working on a project which needs to be developed rapidly, Python is absolutely defensible. It can be an order of magnitude faster to get a project off the ground using python, especially a web app. Upsides: 1. Rapid Development 2. Mature (at this point) web frameworks 3. Easier to hold the entire project in your head However it does have some downsides. 1. Speed, in my experience, you can expect pure python code to run more than 10x slower than equivalent java code. 2. Static typing makes it easier to enforce contracts between sections of the code, which makes it easier to break up and distribute to a team. I suspect this is the sort of thing that the Java guys are interested in. 3. Less mature tooling (IDE's, document generators). 4. Harder to find experienced programmers. Speed is not much of a problem for a web app (since network latency tends to make cpu time somewhat irrelevant) but the other points might be a factor.
ironic :)
Yes, a dynamic language like Python can have issues from type errors and typos, but so can Java. I have fixed more bugs due to autoboxing and null pointers in Java than type errors like you describe in Python. Generics also don't always work, especially with autoboxing. The solution is testing and lint like programs (or from the Java world, FindBugs, PMD, etc) on the Python code base. Several exist, all with the pros and cons. As for major releases and backwards compatibility, yes, Python 3 is backwards incompatible. The reason for the major change was that Python 2.x was getting long in the tooth and the right was to fix some issues, unicode handling being a very large one, that could only be done with backwards incompatible changes. Don't just assume that if it works on Java 5 it will work on 6 or 7. Also, 5 did introduce one major issue, that while easy to fix, did break a lot of codebases by adding the enum keyword. Also, I recently found an issue with Java 7 on Macs that I have to put a lot more work into to fix at work. Java isn't perfect. Compiling? Yes, Python compiles on the file. Why does it matter when that happens? Why do you want to compile Python? From the dynamic side, I ask you why you like having to recompile and restart your servers to test small changes? That is a lot of wasted time. 
Clojure is another alternative for a JVM shop especially if your a FP fan.
What does IPython Notebook lack that you need out of an interactive console?
&gt; #TODO: don’t change multiline strings that aren’t docstrings See http://bugs.python.org/issue12930 
I use IdleX as an editor since it has something similar to Matlab's cell mode and IPython's cells. Being able to run subsets of your code is useful when doing algorithm development and data analysis. You can tweak and test very quickly.
Thanks for the link. I do modeling in Python. I primarily have been using Eclipse. Is there anything I can expect to be missing by switching to python(x,y)?
&gt; It's very frustrating going from python to java, everything you do results in a feeling that it should be a few lines of code, not 5 or 6 classes. I forced myself to implement my latest project in c++ to review for some job interviews I am expecting to do in the near future, and I could not get this feeling out of my head. Development is a lot nicer than I remember (from 4-5 years ago, I really like the auto keyword), but it's still so darn sluggish to have to stop and write code to handle common edge cases...
PEP8 says that a line should have no trailing whitespace. A lot of style guidelines have this, which is why a lot of editors have this as a feature. For Python, any line that contains only whitespace is ignored completely, so it doesn't particularly matter.
FWIW, packages which are not abandoned but for which there is an intent to never port to Python 3 should probably add the 'Programming Language :: Python :: 2 :: Only' Trove classifier in their next PyPI release. For the wall of shame, this adds the little lock icon, and other automated tools can take it into account variously.
When i first started writing python after 15 years of largely matlab work, (im a scientist who uses programming as a tool), spent a ton of time trying to find the best IDE. I tried Spyder and gave up on it rather quickly. I settled on PyDev/Eclipse, but there are surely better IDEs out there.
It's about halfway there.. I got all the boilerplate crap done, and now I'm ready to start messing with the objects that jedi returns. If you want to track my progress, it's here: https://github.com/killarny/gedit-python-jedi (everything is in the develop branch at the moment)
I work in a department that's full of old (and new) fortran code. When I need to get a routine into python, I use [f2py](http://www.scipy.org/F2py) and it works very well. I also prefer to do my plotting with gnuplot because the docs for matplotlib are **terrible**.
Technically, so would Brainfuck and Scheme.
Yeah, this. We're a Perl shop, and the new Ownership just opened 7 Java positions to replace 2 lost Perl Developers. Even if your language is better for the domain, a big company will usually prefer to spend more money on more (sometimes cheaper) individuals to obtain extra redundancy and safety.
Takes more time and more code to do something in Java rather than Python. I usually do sci/AI/ML type applications and I work on very tight timelines, solo or with a small group, so I appreciate that about Python. If I have a bottleneck in performance, then do the app, or more likely a component, in C/C++/Java/Fortran/whatever. Don't forget Jython. Writing in Java feels like needless work to me. I also don't think it's as much fun as Python. Really, people use it because it's a platform, and not so much because of "Java" the language. Also, Oracle is a pain in the ass. This is my humble opinion.
Now if they add support for [Python Jedi](https://github.com/davidhalter/jedi), they are pretty close to being on par. Additionally, using ipdb to set breakpoints would rock. Makes me want to start contributing... 
You realize the acronym for Wall Of Shame is exactly the same as Wall Of Superpowers, right? Right?
I explored porting the web.py project to Python 3, one of the major issues I ran into was the 2to3 translation of the project's safestr method: https://github.com/webpy/webpy/blob/master/web/utils.py#L356 If you pass that through 2to3, the cases (unicode vs. str vs. etc.) get all muddled, and the intended behavior becomes very unclear. Resolvable, I'm sure, but non-trivial, especially for a method used throughout the project.
&gt; It's very frustrating going from python to java It was the other way around for me. Sounds strange I know. Maybe it's just me whose brain is hard-wired to just writing code and not bothering around with lots and lots of test and making sure my refactors don't break everything. But then again, I don't *love* Java but its type checking capabilities. This is reason I have started moving to Scala. Comparable lines of code wrt Python and the type check capabilities of Java (or better I would say).
xlrd and xlwt are shown as red but have actually been ported to Python 3, under new package names: http://pypi.python.org/pypi/xlrd3/ http://pypi.python.org/pypi/xlwt3/ Note I've been unable to build successfully xlwt3 on Python 3.3, but xlrd3 works.
I work in a pretty large java shop as a sysadmin. When a team wanted a python application deployed there was some negativity around it from the SA team as they didn't understand the deployment process as well as they did java. My advice is to write clear documentation for the sysadmin / whoever; covering how you deploy it and how to debug failed deployments of new versions of that application. When things are documented and you show you're willing to help the sysadmin team on-board said application, you will probably find the business case for a java rewrite somewhat evaporate.
thanks
If someone wants to experiment, I'm waking *them* up at 3am. And I won't be happy.
This is good news. [IPython Notebook](http://ipython.org/ipython-doc/rel-0.13.1/interactive/htmlnotebook.html?highlight=notebook) is one of the more interesting developments in computing. Being able to use a high level programming language with access to almost any data format you care to name, married with several top-notch graph libraries and the ability to write text/markdown and LaTex (for maths) in the browser in an integrated environment, is very powerful. Here's an [example](http://nbviewer.ipython.org/url/epi.whoi.edu/esr/GIS_GRASS-R_Example.ipynb) showing the use of geodata with the code and data used to generate it. IPython notebook may be the ultimate scientific publication system.
You can try IPython (shell) and IPython Notebook (web interface) online with Wakari at https://www.wakari.io - platform (with all popular Python scientific libraries installed) that lets you run multiple Python sessions and access them online anywhere. It also allows IPython Notebook sharing - you can share your workflow.
To clarify: Frozen-Flask is great. I think it really is the right way to do static web sites. It’s only Flask-Flatpages that I dislike. You’d be better off with Markdown and a couple of `os.listdir()` calls.
+1 for LaTeX. I used it to type ALL my physics homework back in college.
Haha I don't think the response usually turns out to be that simple or rational. :) Some people (lots really) don't like to pay for software at all. I'm sure there's lots of others variables too. But give 'em time...
Really? Maybe it's a Boston thing. Our old ownership considered swapping to java because their consultancy (...ahem, our NEW ownership, go figure) felt java developers were "a dime a dozen." Most people who leave here for other Perl positions are surprisingly close to the notorious "lisp-level" salaries. Are there any statistics you can show me? I'd spend the time to pick up Java if that's really the case. 
This is great news. I've switched almost my entire workflow to IPython notebook (apart from launching batches of simulations) and I'm loving it. There's still some polishing to do, particularly in regard to how JS interacts with the IPython Kernel and vice versa but with some further development it's going to become ridiculously useful.
How so?
You can already use it in place of Matlab. I've done so for at least five years. Of course if you want complete eradication of Matlab, that will take a while :)
In the best traditions of the internet, let's use a car analogy. The normal Python `&gt;&gt;&gt;` shell is like a Ford - reliable and ubiquitous, but it doesn't have many special features. bpython is like a Ferrari - you can go that much faster, and make people using the plain shell jealous. IPython is like a Rolls Royce. It has an HTML interface, a parallel computing framework, an extension system, strong integration with the scientific computing world, and so on. But, if you don't want any of that, you can still do `pip install ipython` and just use it as a great interactive shell. (Disclaimer: I'm an IPython developer, and I might get to work on this grant)
Ipython has both features you mention. 
That's awesome. I've been building myself a django app that mixes markdown, matplotlib, and latex, and a wiki ... I wish I'd seen this a couple of weeks ago!
I whole-heartedly agree
I'm talking local deployment for development, not deployment for production. Also, your IDE should do incremental deployment, massively reducing the transfer time. 
For me: HTML interface with possibility to add markdown between statements for workflow narrative. Makes explorative data analytics and interactive data processing more understandable. It is like shell with comments and with ability to reconstruct your whole development process from the beginning.
 computing similarities between user 'takluyver' and name 'Thomas Kluyver'... ok probability of being the same person: 99.9% Yes, I think so!
Works now!
What would this mean? There's no security model that would allow untrusted users access to run arbitrary commands. You can already point multiple browsers to different notebooks within the same server. And sharing the same notebook to multiple people would be a problem since the python process blocks when anyone runs a command.
Can some of the grant money go toward getting pdb to work in the notebook?
That's very different from seeing the doc string as you type (so that you know function arguments, etc). [Here](http://bpython-interpreter.org/static/screenshots/2.png) is a screenshot from bpython. It can be quite useful. 
I use the IPython interface to download my data from servers, parse it into useable formats, do fancy operations with the built-in numpy integration, and then make pretty plots using the matplotlib integration that show up right alongside the code. Then, with the notebook interface, when I want to use a different file, I change the name in one place, edit as I go down, and it all pops out really neatly. bpython may be cool, but half those things are impossible, and the other half would be much less useful.
I probably wasn't explaining it very well, but there is a document on github [here](https://github.com/ipython/ipython/wiki/IPEP-3:-Multiuser-support-in-the-notebook) that describes what this might look like. 
One comment I'll make is that I found bpython to be unstable the last time I tried it. I saw it demonstrated at PyCon this year and got super excited about it but when I tried it I had multiple crashes or strange behavior, so I gave up on it. For me the power of IPython is in the IPython Notebook
I can't give you links to some job posting as they were deleted or expired. The positions I have seen were on the West coast (San Francisco, Los Angeles, etc). I worked a company that went from Perl/PHP to Java (I came in as part of the Java team). The number of Java positions nearly tripled at peak compared to the number of Perl/PHP coders. I talked to a couple of the Perl guys and found out they were making a lot less than most of the Java developers. In any case, the company eventually decided to out-source the entire engineering team to save money. Here are a couple graphs of Java developers salary versus Perl developer salaries: Java: http://www.indeed.com/salary/Java-Developer.html Perl: http://www.indeed.com/salary/Perl-Developer.html I didn't enter an area, but I know that for Java these numbers are very low for my location. A friend recently got a new job as a Senior level developer and is making somewhere between $120K and $150K. However, if you are very talented, then your skills can trump the local salary for the right company.
Could say that about reddit, couldn't you? I don't really know what's wrong with trying something new.
That all goes out the window when you have things that you want to have aligned across line breaks. Consider the following example, where we want the dict items to line up as well as the comments: def foo(query): params = { 'lang': 'en' # eventually this should be configurable ,'type': 'documents' ,'section': '27b/6' ,'query': query # TODO: validate query string for sanity } do_something_with(params) If you wrote that code in an editor with hard tabs enabled and set to a width of 4, the result is the following, where » represents a tab and · represents a space: def foo(query): » params = { 'lang': 'en'»» » » » # eventually this should be configurable » » » ··,'type': 'documents' » » » ··,'section': '27b/6' » » » ··,'query': query» » » » # TODO: validate query string for sanity » » » ·} » do_something_with(params) If I then open this file in an editor that has the tab width set to 8, everything will be messed up, resulting in this: def foo(query): » params = { 'lang': 'en'»» » » » # eventually this should be configurable » » » ··,'type': 'documents' » » » ··,'section': '27b/6' » » » ··,'query': query» » » » # TODO: validate query string for sanity » » » ·} » do_something_with(params) Or without the symbols: def foo(query): params = { 'lang': 'en' # eventually this should be configurable ,'type': 'documents' ,'section': '27b/6' ,'query': query # TODO: validate query string for sanity } do_something_with(params) All that careful work that went into aligning things is completely mangled. The notion that "everyone can choose their own tab width" is a myth. If you are *extremely* careful in your formatting, you can pull it off, by using tabs only for indentation and not alignment. The result would look something like this: def foo(query): » params = { 'lang': 'en'·················# eventually this should be configurable » ··········,'type': 'documents' » ··········,'section': '27b/6' » ··········,'query': query···············# TODO: validate query string for sanity » ·········} » do_something_with(params) How tedious is that? You could only use a tab for the leading indent, but not anywhere else. Most editors are not setup for this, which means you'd be indenting and aligning manually with the spacebar instead of just using tab. And it's incredibly brittle -- if a change creeps into the source where somebody wasn't aware of the convention and hit tab instead of using spaces, then the mistake will be invisible and will probably never be noticed, until someone else downloads the code and tries to read it with a different tab setting and notices that the alignment is broken. Another issue is that you don't have control over the tab width of sites like Github, which means your code will display as if it had an indent width of 8, which is not Pythonic. If you just use spaces then all of these issues magically vanish. The document looks the same to everyone no matter where they are viewing it or how their editor was setup. You still have to make sure that some knucklehead doesn't later introduce hard tabs, but that can be added as a code review step or handled by an automated check-in script.
You can use pypy or write small portions in C/C++ if performance is an issue. Numpy even has tools to make that easier for you. Plus, even though the Mathworks marketing spin works really well, Matlab's performance isn't that great either. In the end it's also an interpreted language and you have to pay special attention if you don't want it to be slow. I've seen quite a few people rewriting their algorithms in C/C++ after developing them in Matlab because of performance issues. On a side note, if you want to do numerical work in C++, I highly recommend a library called Eigen. It has decent performance and is extremely easy to use.
Please do! We are seriously understaffed! About Jedi: We have rope, which does almost the same and it's deeply integrated on several places. About ipdb: It's almost broken on qtconsole, we'll have to wait until IPython guys fix it. But 2.2 will have a breakpoints toolbar and a widget to show a list of breakpoints on all files.
You can search and find that stuff on wiki. I would now but I'm in my phone. It's basically making a ui that looks and operates the same way as the physical world equivalent. The stereotypical example is a lot of apples apps. Think if notes on an iPhone etc. When done right it can bring a users already learned intuition withit so that you don't have to teach them a new interface. When done wrong it either limits what a user can do because you're treating the computer exactly like the real world equivalent or you end up with an inconsistent and confusing ui. In my question I was really asking if there is a library that doesn't just use the OS native objects when I ask for a button etc. though a little aggressive, other posters in the thread aren't in the wrong in cautioning me not to use such a ui. They're FAR easier to screw up than get right.
I see your argument. Allow me to play devil's advocate (read: allow me to explain why I can't justify the arguments for using spaces). I'm not trying to start a holy war, rather I am explaining my thought process (read: I'm not trying to prove you wrong (or right)). [PEP 8: Code Layout](http://www.python.org/dev/peps/pep-0008/#code-lay-out) says that you can also do def foo(query): params = { 'lang': 'en' # eventually this should be configurable ,'type': 'documents' ,'section': '27b/6' ,'query': query # TODO: validate query string for sanity } do_something_with(params) like this with a hanging indent: def foo(query): params = { 'lang': 'en', # eventually this should be configurable 'type': 'documents', 'section': '27b/6', 'query': query} # TODO: validate query string for sanity do_something_with(params) The latter would look like this with the white space marks: def·foo(query): » params·=·{ » » » 'lang':·'en',»» » » » # eventually this should be configurable » » » 'type':·'documents', » » » 'section':·'27b/6', » » » 'query':·query}» » » » # TODO: validate query string for sanity » do_something_with(params) &gt;If you are extremely careful in your formatting, you can pull it off, by using tabs only for indentation and not alignment. Personally, I prefer that. And who codes with a tab size of eight? I don't mind holding down the spacebar for a second. Tabs should be used for indentation and spaces should be used for alignment that is unrelated to the level of code. def·foo(query): » params·=·{ » » » 'lang':·'en',·················# eventually this should be configurable » » » 'type':·'documents', » » » 'section':·'27b/6', » » » 'query':·query}···············# TODO: validate query string for sanity » do_something_with(params) With that said, though, I *try* to avoid inline comments (also suggested by PEP 8). I often shoot for one-line block comments. So I would do it something like the following (if I'm not in a hurry on an individual project): def·foo(query): » # TODO: » # The language should eventually be configurable. » # Validate the query string for sanity. » params·=·{ » » » 'lang':·'en', » » » 'type':·'documents', » » » 'section':·'27b/6', » » » 'query':·query} » do_something_with(params) Without the punctuation it looks like this: def foo(query): # TODO: # The language should eventually be configurable. # Validate the query string for sanity. params = { 'lang': 'en', 'type': 'documents', 'section': '27b/6', 'query': query} do_something_with(params) Another personal preference of mine is to put the the closing parenthesis, bracket, or brace on its own line (which is implied not to be done by PEP 8) def foo(query): # TODO: # The language should eventually be configurable. # Validate the query string for sanity. params = { 'lang': 'en', 'type': 'documents', 'section': '27b/6', 'query': query } do_something_with(params) &gt;Another issue is that you don't have control over the tab width of sites like Github, which means your code will display as if it had an indent width of 8, which is not Pythonic. In their defense, you can change this in the editor on Github IIRC. Anyway, it's not their fault that most browsers don't implement the CSS 3 `tab-size` property. &gt;You still have to make sure that some knucklehead doesn't later introduce hard tabs, but that can be added as a code review step or handled by an automated check-in script. The same applies for any indentation issues, though. &gt;you'd be indenting and aligning manually with the spacebar instead of just using tab. In my experience some editors make you delete the spaces that are used as tabs one by one. Also not fun. And some dumb "editors" (i.e. Notepad, TextEdit aren't even configurable, so you either use tabs with the tab key or spaces with the space bar.
Enhorabuena chicos! Ipython y mas recientemente su notebook no han hecho sino acrecentar el gran placer que me proporciona experimentar ideas en python. ¡Un gran trabajo el vuestro! Gracias
http://vimeo.com/20743963 demo. Jump to 7min30s to see how file editing works.
It's like you're famous
And [vim-ipython](https://github.com/ivanov/vim-ipython) is like...? An unholy love child? ;-)
The plain terminal IPython can't show docstrings as you type - it's a limitation of a terminal program (unless you use curses/urwid, which is what bpython does). The Qt console or the notebook have tooltips that appear as you type for function arguments etc.
iPython does both highlighting and shows docs with the [qtconsole](http://ipython.org/ipython-doc/dev/interactive/qtconsole.html). [http://imgur.com/5pQ3a](http://imgur.com/5pQ3a)
No promises, but we'd love to have some kind of interactive debugging integrated with the notebook.
thanks for the info, ill definitely check those out! I was wondering earlier about an IRC channel for python, what are some good ones?
**server** irc.freenode.net **channel** #python Nick registration is required for that channel.
If you have some time to hack around with it, you should try PyPy. It is a JIT compiled version of Python that does many operations ~10x as fast as CPython.
Some people think less is more.
It's like PowerPoint for Python. Very cool!
1a) yes, exactly. also ssh (as a dead project) will likely never be ported to python3 while paramiko most likely will some day. 1b) hmm, but pyramid is very much the direct successor – it has pylons compatibility modules and all. i don’t feel very strongly about such stuff, but i guess any project being deprecated in favor of another should not be counted if the superseeding one is. about the limitations of the automatic approach: there is also http://py3ksupport.appspot.com, which is manually curated. maybe you could add a link to it from your WOS? (its FAQ also links to the WOS)
All that, and then I run it on [picloud](http://www.picloud.com).
I enjoyed the wording in the FAQ &gt; I care about seeing Python 3 succeed and pushing against the FUD that some spread about the lack of Python 3 uptake Anyhow, I'll add the link once I get home tomorrow.
So do IPython developers - and numpy, scipy, matplotlib, and all the rest. ;-) There's different ways to the same end, and we think open source ways are best for science.
Heh, just contact the author and tell him that it was not your intention to spread FUD (if that's what he was implying) I'm not thinking he meant you. 
Cheers, it's a useful opinion.
My current favorite feature of iPython 0.13 has been the kernel, and being able to attach multiple instances to it. I don't use it heavily, but being able to interact and adjust variables from the shell and the notebook UI is delightful. I'm really looking forward to getting the clusters working, at some point. 
If you're writing array-oriented code in Matlab and not getting high performance, it's very likely that you're not writing your Matlab code well.
PyPy is simply not an option if you have to interface to anything in the ecosystem that uses the NumPy C API. Interfacing to C libraries is also a pain with PyPy (tl;dr ctypes sucks). &gt; Plus, even though the Mathworks marketing spin works really well, Matlab's performance isn't that great either. In the end it's also an interpreted language and you have to pay special attention if you don't want it to be slow. I've seen quite a few people rewriting their algorithms in C/C++ after developing them in Matlab because of performance issues. Certainly, it's not great for everything, but for a large variety of tasks you can get really, really good performance out of it in a fraction of the development time. I say this as a passionate hater of all things MathWorks.
&gt; You can already point multiple browsers to different notebooks within the same server. I think the goal would be real-time synchronization of the actual notebook interface. I agree that authentication is a silly goal. &gt; And sharing the same notebook to multiple people would be a problem since the python process blocks when anyone runs a command. Well, yes, the engine would block. The web server wouldn't.
&gt;PyPy is simply not an option if you have to interface to anything in the ecosystem that uses the NumPy C API. I agree, but I think it will get better very soon. Pypy's performance is simply too good to give up, so people want to use it and will improve the tools around it. I know I certainly will.
I'm aware of that. It's very useful in its own way, but I then find myself clearing the line I was typing, executing the command to get the doc, and then rewriting what I intended now that I know the argument signature. 
it's not exactly java based, but it runs on the JVM since about version 6, and can be deployed as an EAR. Also since 6 or 8 it has been able to interoperate with java. wikipedia has a rundown of the versions.
ColdFusion looks like the opposite of MVC. Put all your logic into the presentation layer! Fuck yeah! Now seriously, is that correct?
that's cool, why not introducing exciting bpython features into ipython? bpython and ipython are not exactly mutually exclusive.
I agree with you based on my anecdotal evidence that the single craziest guy I know is a huge Perl evangelist.
No, it's not correct, but given the time frame of when cold-fusion came out, it was the prevailing architectural style (or lack thereof). Similar to ASP (classic), PHP, and (straight) JSP. You have to remember that it was with the advent of these technologies that we had just started crawling out of the pits of [CGI](https://en.wikipedia.org/wiki/Common_Gateway_Interface)-hell *^([now with PERL!])*, [SSI](https://en.wikipedia.org/wiki/Server_Side_Includes)-dispair, and, for Java, Servlet-madness, as the defacto standards for generating dynamic content on the web. So it was a necessary step. And since you can use servlets as a front controller to coldfusion views, you can fairly easily craft a decent MVC architecture with it. Or you could enforce the programmer discipline to manually keep your "controller" CFMs separate from your "view" CFMs, like a lot of things did with PHP. I can't speak to the technical strengths of coldfusion as a pure view template technology because this is my first real jump into it.
&gt; Really? yup, almost always
yup yup, dude put this to blog for posterity
Thanks for the kind words, we're indeed very excited. We've put up a [few more details](http://ipython.org/sloan-grant.html) in case you're interested. We'll have more details coming soon on concrete work to get going, but I'm [traveling right now at a conference](http://icerm.brown.edu/tw12-5-rcem), so managing this remotely has been madness.
Please stop with the yields and stop copying Twisted. The only sane way to handle python IO concurrency is with green threads (eventlet or gevent). Anything else is foolishness. Futures, Tasks (are just renamed Deferreds from what I can see). Twisted has been around for years and years and there are still few people who understand it. "yields" -- Nope, forget about those. Those are good for generators, and toy examples about "co-routines" I have not seen any large library use them successfully. The biggest problem (surprisingly perhaps for some) is not really the mental model or the syntax. Programmers can figure those out if they try hard enough. The biggest problem is the splitting of libraries. Once you start using Futures, Tasks, Deferreds, Promises, and so on. Forget about re-using any existing library that is not written using that particular type of Async IO. Look at Twisted it has created a parallel universe of IO libraries. There is "&lt;library to handle X&gt;" and if you are lucky "&lt;library to handle X with Twisted". Now with the new "yield/send/yield from" business there will be a need for a 3rd type of the same library "&lt;library to handle X with yields&gt;". Outside of a few corner cases (such as dealing with binary C drivers) you're even better of replacing regular Python threads with greenlet threads (gevent and eventlet are based on greenlet). You get at least 2 things better: 1) less unpredictable context switching (only during IO operations). 2) ability to handle a huge number of connections as the thread context is just a small memory block in the Python process not a whole OS thread. 
&gt; Twisted has been around for years and years and there are still few people who understand it. Maybe so, but threads and coroutines have been around nearly as long as the event loop model, and even fewer people understand those. (And even fewer people understand programs written by those people!) So it's hardly a detraction from Twisted.
&gt; coroutines have been around nearly as long as the event loop model, Twisted was released in early 2000's (2002 maybe). greenlet module was around 2006 and then eventlet came, then gevent. &gt; and even fewer people understand those. Yes few people understand co-routines that's why the yield stuff doesn't make sense. However most people understand threads because that is the most common concurrency idiom (whether we think it is perfect or right, doesn't matter, just saying it is most familiar). &gt; And even fewer people understand programs written by those people! Really? Spawning a thread for each connection is harder to understand that defer.waitForDeferred, Deferreds, addCallback and reactors? from twisted.internet.protocol import Factory from twisted.internet.endpoints import TCP4ServerEndpoint from twisted.internet import reactor class QOTDFactory(Factory): def buildProtocol(self, addr): return QOTD() # 8007 is the port you want to run under. Choose something &gt;1024 endpoint = TCP4ServerEndpoint(reactor, 8007) endpoint.listen(QOTDFactory()) reactor.run() 
it's a shame that Jeff Ortel abandoned suds. Python seriously needs a new soap client library.
Please, talk with /u/gargantuan and the mailing list and do the PEP. I'd do it myself if I had the slightest knowledge on that topic (which I haven't), simply because I think that in a case where several styles coexist and have their fans, every one of them should be considered. Also I'm no fan of the architecture consisting of a dozen of methods, none of which leveraging any concept of python. I just see Java code in the PEP. 
The problem I have with the twisted model is that you end up breaking your code up where things block, which doesn't necessarily make sense. Then your state machine ends up splayed across a bunch of callables, and it leads to shit that's as unreadable as old code that poorly used goto. "yield from" and inline deferreds are just ugly implementations of what greenlets provide beautifully.
I use IPython/numpy/scipy/matplotlib from the [Enthought](http://www.enthought.com/products/epd_free.php) distribution. I edit my code mostly with [Komodo edit](http://www.activestate.com/komodo-edit) or sometimes [Aquamacs](http://aquamacs.org/). Specifically to my field (Astronomy), I also use the excellent [pyfits](http://www.stsci.edu/institute/software_hardware/pyfits) to read and write FITS files and [pyephem](http://rhodesmill.org/pyephem/) to make basic astronomical calculations.
That was the closest anchor to the list of Pillow releases that specifies which Python version it works with. Python 3 is absent.
Well... sounds like I wasted a lot of time trying to wrap my head around Twisted. It's encouraging to hear that there's a simpler solution, though.
Hmm... I usually look at the example page for matplotlib - it is often quite good. For me it is just great, but perhaps this is from experience with much worse solution (i am looking at you ROOT [here http://packages.python.org/rootplot/root2matplotlib.html is a suggestion actually], and also you jFreeChart). There are a few stupidities in it that I hate though, like it is hard to switch between many open figures and subplots. As a gnuplotter, did you ever try : http://gnuplot-py.sourceforge.net ?
very cool
I agree on that, but a lot of things can't be easily reduced to operations on matrices and arrays. Iterative methods, for instance, force you to have that extra for loop. 
Twisted is horrible. You need to keep in mind, threading is so horribly screwed on Python specifically because Guido is completely clueless about all things good in threading. In fact, he hates threading. He doesn't understand threading. He is scared of threading. As such, that should explain everything you need to know about Python, threading, Guido, and Guido's interests in Twisted. Bluntly, anything Guido likes for threading should be everything you need to know to avoid his preferred solution. I love python, but python threading, and the lack of a fixed solution in 3.x, should be grounds for a good lashing. 
The event loop model has been around much longer than Python has. Twisted isn't the first library to provide it. Coroutines have a pedigree of similar length. Coroutines are just a different flavor of threads, and have the same kinds of disadvantages to readability/debuggability as threads, just in a different degree. &gt; Spawning a thread for each connection is harder to understand that defer.waitForDeferred, Deferreds, addCallback and reactors? As soon as code servicing those connections need to interact with each other at all, yes. (And if they don't need to interact with each other at all, you're just using threads/coroutines to emulate processes.)
The only reason the green thread libraries don't have their own parallel universe of stuff is that they've taken to monkey patching under the sun, not exactly a best practice I want to encourage, Second, you're not going to get far dismissing C-extensions as corner cases, believe me I've spent the last few years trying.
I found it makes it easier. If nothing else, I found it reduced my code size by a huge margin, that alone means less code to maintain and debug. It can do this by doing one scary thing in the begging -- monkey patching IO function calls so they don't block the process but instead so they switch to other green threads. 
Not really. Twisted is still the best and most mature library for a big swath of network-related development. gevent has gained popularity because of its seeming compatibility with existing code that uses blocking IO -- in effect, it's just a different flavor of threads, with much of the complexity that entails.
I used spyder for the first six months of programming in python, and I still recommend it to folks who are switching from Matlab. I use Wing IDE now because its autocomplete is better, the go to defintion works across files, and the interactive debugger is amazing. I do miss rich text formatting and the ipython shell, and Jedi would alleviate the first two concerns, so I will indeed take a stab at integration. 
&gt; As soon as code servicing those connections need to interact with each other at all, yes. (And if they don't need to interact with each other at all, you're just using threads/coroutines to emulate processes.) There is the exact same problem with Twisted and other callback based mechanisms. There are semaphores and locks in that wold as well. At any point where IO waiting happens control is potentially lost and other code could run. With real threads it is a bit worse in Python's case because control can be lost at any time (threads could switch during any bytecode operation pretty much), but without the benefit of CPU based parallelism because of the GIL. With gevent if you are just updating 2 dictionaries between 2 green thread and you want that to be protected, you don't necessarily have to lock.
You don't need to clear the line you're typing in recent versions - you can stick a `?` on the last name in the line, like `a = b + foo?` (to get docs on foo).
This reads like an article written for the sake of writing an article.
What's wrong with just a random number? It'll have even distribution, thus small and large numbers.
Why not use [logspace](http://docs.scipy.org/doc/numpy/reference/generated/numpy.logspace.html) from the numpy project?
I think it's worth noting that monkey patching is not mandatory to be able to use gevent, just to be able to use gevent with existing libraries that do normal synchronous IO. If Twisted could provide monkey patching to give async support to async unaware libraries it probably would and people would probably use it.
&gt; There aren't. This is the advantage of the event loop model. I've used Twisted for 3 years and personally used. He it is in the source tree as well: http://twistedmatrix.com/documents/10.1.0/api/twisted.internet.defer.DeferredSemaphore.html
too bad cassandra's not relational. that "R" has to go....
Oh boy. The current GIL is still crappy threading. The current GIL simply provides what the original GIL was suppose to provide all along. Basically the GIL (Global Interpretor Lock) means only one thread can ever run at one time, unless its inside of a non-python module which explicitly releases the GIL. Which means, regardless of the number of threads you use, so long as you write native Python, your application is single threaded (w/some I/O exceptions). So yes, absolutely Guido deserves that much flame...and more. Edit: down votes mean people prefer ignorance and delusion to reality. Its all in the archives folks. Everything stated is well documented. But hey, lets shield guido out of extreme ignorance and completely misplaced reverence...that's sure to improve things. 
I thought about making a version that adds a bit of noise, but I especially want to be able to see how the output changes as the number gets larger; it's easier to see that with a more regular logarithmic distribution.
Not a semaphore in the same sense as used in threads. This object is a convenience for code that wants to limit the number of concurrent operations it's running at once.
&gt; The biggest problem is the splitting of libraries. Once you start using Futures, Tasks, Deferreds, Promises, and so on. Can’t agree anymore.
&gt; Interoperability with systems like Stackless Python or greenlets/gevent is not a goal of this PEP In other words, those have already solved the problem we are trying to solve, better, so we are just going to ignore them.
If function call overhead is what's limiting your code's performance, then you're way ahead of most code that uses databases. :) The "breaking up of functions" you describe can be a problem in poorly architected code, possibly. But anything sophisticated is going to want to batch operations together to some degree. &gt; Python's performance drops almost linearly with function call overhead. This certainly isn't true on PyPy. Personally I would *love* to have something like SQLAlchemy Core that built the query for me and let me feed it to the database myself, or otherwise separated the communication parts from the sql-wrangling parts.
Monkey patching because greenthread libraries are dealing with things at a lower abstraction, so monkey actually patching works really well in most cases.
using only integer arithmetic: def log_gen(n): m = 1 while True: for i in range(1, 10): r = i*m if r &gt;= n: return yield r m *= 10 
http://meyerweb.com/eric/comment/chech.html
&gt; You do realize that gevent is a "coroutine-based networking library" and eventlet is even implemented using coroutines. Yes I know how they are both implemented and even contributed code to one of them. &gt; yield is basically equivalent to gevent.sleep(0)) Aha except the "minor detail" of a having "yield". Then any call that calls that call also have to unwind the generator and pass a yield up the chain. Just because they are both co-routine like libraries, gevent and eventlet have the advantage that they don't bubble that up vertically through the API. Your green thread could be switched when you do IO but you don't have to handle a yield, you just wait for the operation to complete while other green threads can run. 
&gt; The "breaking up of functions" you describe can be a problem in poorly architected code, possibly. not really, unless you consider a function like this to be poorly architected: def execute(connection, statement, parameters): cursor = connection.cursor() cursor.execute(statement, parameters) cursor.close() Using psycopg2 with the async extension, that above is three separate messages sent to the database.
Sure. Writing for writing sake. Like Art [for Art's sake](http://www.allmusic.com/song/for-arts-sake-mt0003822614).
I find your argument interesting, and possibly correct, but it brings up two questions. (1) I'm not as familiar with Twisted, Tornado, et al. -- do they avoid monkey patching on purpose because of ideological reasons, or do they not monkey patch because they are fundamentally incompatible? (2) If something like gevent is found to be useful/easier by the community (my feeling is that it is, and others have argued to that effect), and it does that by monkey patching, does that not indicate that it is a good candidate for being included in the standard library in some way? As in, if the only way to get the best blend of usability and functionality was to put it in the standard library and/or the language, then is putting it in the standard library and/or language not a natural extension of the idea?
&gt; I not only understand threading, I frequently teach people how to effectively use them in Python - which is difficult. It doesn't change the fact, they are really screwed up. Even Guido admits this. Its why threading is such a stinky subject about Python. &gt; BTW, I'm also a contributor to Python. Not to mention I've ported python to other platforms. I know what I'm talking about. Guido and most everyone who knows anything about threading and python, completely agree with me. Threading on Python is horrible. There. Remove the ad hominem and your post has the same impact, but you look *more* professional and less like a troll. It's quite possible to be persuasive without being rude. And persuasive it is, but once you analyze what remains.... ---- &gt; I not only understand threading, I frequently teach people how to effectively use them in Python - which is difficult. *"I'm an expert on this, because I say so."* &gt; It doesn't change the fact, they are really screwed up. Even Guido admits this. Its why threading is such a stinky subject about Python. [Argument from authority](http://en.wikipedia.org/wiki/Argument_from_authority): your own, which you've just "established", and Guidos. No source link for the latter. &gt; BTW, I'm also a contributor to Python. Not to mention I've ported python to other platforms. I know what I'm talking about. *"Did I mention I'm really really an expert?"* &gt; Guido and most everyone who knows anything about threading and python, completely agree with me. More argument from authority, and [the bandwagon fallacy](http://en.wikipedia.org/wiki/Bandwagon_fallacy) &gt; Threading on Python is horrible. At this point it's [proof by assertation](http://en.wikipedia.org/wiki/Proof_by_assertion). ----- Now hold your horses! I don't doubt what you say. But so far you've been all bark and no bite. How about some *actual* arguments, or examples? Or links to such? And links to the relevant discussions in the archives? 
I'm just saying that low-level details like that don't have to be exposed to application code.
not understanding your point. My attempt was to see how SQLAlchemy, a database abstraction library whose job it is is to handle low level DBAPI details, could be made fully async. My analysis concluded that it would require an explosion of function calls which would dramatically slow down and bloat the entire library when concurrent IO wasn't a primary bottleneck (which it usually isn't).
You've missed something important here. The above code is *always* three separate messages sent to the database. When you make I/O asynchronous, you can just *see* that it's three separate messages sent to the database. Being able to recognize everywhere that I/O – and therefore concurrency – (might) be happening is hugely valuable. This isn't a purely theoretical advantage, either. In a properly event-driven system, it's possible, for example, to notice that the 'cursor' or 'execute' message is taking a long time, give up on it, and clean up or shut down the underlying transport, without having to make the connection or cursor objects threadsafe, and without having to add a 'timeout' argument to every function. This is invaluable when writing applications against multiple databases, especially when the application needs to be tolerant to network partitions between some of the database (think "multi-site synchronization"). So, yes, a function like that is, in a sense, poorly architected. I'm not saying that it's necessarily the wrong solution for a particular problem; clearly it is the most popular option in the world of databases, and possibly the most practical in today's environment, but it is definitely not ideal.
No, it is exactly in the same sense. There are also locks. You can use these for throttling but they are primarily to protect data structures. You are doing things concurrently and if you have shared data structures that you need to update across a context switch (a callback, thread rescheduling, yield) you need to protect that data with a concurrency primitive. Say you have dict d and you read an item, increment it and write it back. But between reading and writing back you need to get some data from the network so you add a callback and finish incrementing and writing back to d when it fires callback. Guess what, you cannot guarantee that while you wait for your callback to be called some other callback hasn't written to that dictionary. 
Sure. But the difference is that in an event loop system *you can discover this by looking at the code*. That is what you lose in a coroutine- or thread-based system.
&gt; Look at JS - seems evented model is actually much more popular than green threads/coroutines. Do JS people actually have an option not to use it? :-) &gt; Green threads present the same problem as you're describing (blocking IO is a problem) Do not understand how getting explicit with this can help you. 
Why isn't there a single popular dynamically typed^\* language that doesn't have a GIL (or no threading whatsoever)? Is that Guido's fault as well? [\*] dynamically typed, more or less class based, "scripting", I guess... Python, Perl, Ruby, PHP, Lua, Javascript, Racket, to name a few examples.
Does Lua have a GIL actually? Does Javascript have threads?
I'm not suggesting that this is always a good idea or that you should jump to this by default, but it is a useful tool. I had this: for user in Users.get_all(): Everywhere! It was much cleaner and intuitive to implement as: for user in Users: But Users could not simply be a container because it handles interaction with a database. The example I provide in the post is over-simplified and obviously not a situation in which such complex methods would be necessary, however, there are use cases for this. Again look a Django. Th e Django ORM provides a very clean and intuitive API, that is entirely dependent on the use of metaclasses in order to function.
Yeah, it's a terrifyingly bad example. What are some good reasons to use metaclasses?
you shouldn't post examples so over-simplified to the point of being wrong. what I mean with this is that a list as a class attribute will act as a cache *only* for the objects created within that interpreter, in a parallel world (as in, everywhere besides Django's development server) you'll have several threads and/or instances of the interpreter, those will hold independent lists thus breaking your idea of singleton.
The example was meant to be a simplification, the list represents a database connection, which is far more complicated and handled by the class, but showing all of that would have made the example very unwieldy. As for other good use cases? I am going to point to Django again, partly because it is the best known example and partly because I am building an ORM. When you define a field on a django model you do it like this: from django.db import models class Person(models.Model): first_name = models.CharField(max_length=30) last_name = models.CharField(max_length=30) first_name and last_name are *class attributes* but somehow each `Person` has a last_name and first_name attributes of type `str`, this is done via a metaclass which transforms the django field into instance attributes.
cqlengine was mainly built to expose CQL, not be a replacement for the thrift interface, or as an alternative to something like mongo. It is expected that someone using this would understand the underlying data model of cassandra/CQL. Check out the section on partition keys and clustering keys here: http://cassandra.apache.org/doc/cql3/CQL.html You have the ability to define clustering keys alongside your primary key in cqlengine.
Sure but as I said the list is merely meant to represent a database, thus the example is not wrong. In the real world that list would not simply be a list but some function call that returns all of the users from the database. Thus regardless of the number of running interpreters or thread s it would still function. The example I gave is *never* meant to be implemented for real, rather is meant to serve as demonstration without requiring complex supporting code that is irrelevant to the topic being discussed. 
If you use a primary key &amp; a clustering key, cassandra will lay your data out sequentially on disk how you want it to be. For instance, if you have a message + comments, you'd probably use messageid (primary key) and commentid (clustering key) to get your comments on the message laid out sequentially. It's the CQL3 version of using WITH COMPACT STORAGE. See my [blog post](http://www.rustyrazorblade.com/2012/10/cassandra-cql3-and-time-series-data-with-timeuuid/) (shameless plug) to learn more on that. 
&gt; But Users could not simply be a container because it handles interaction with a database. Why? I mean, of course it can't be a list, it should represent some sort of context, where those users are, a db connection object, stuff like that. As it is you're using global variables for that basically, it's almost always better to bind stuff to context instances instead: you can have several contexts at the same time (like, for migration, comparing stuff etc), you will never _accidentally_ make what should be another context (just create a temp User instance real quick to calculate its hash... Ooops), it will be much easier to write tests against, and so on. &gt; The example I provide in the post is over-simplified ... __ESPECIALLY__ when you have a complex program. For a hundred lines long script, OK, make everything global, that doesn't matter. &gt; Th e Django ORM provides a very clean and intuitive API, that is entirely dependent on the use of metaclasses in order to function. I'm not saying that metaclasses are bad, I'm saying that you had a bad design and by trying to make it easier to use you made it even worse. Actually, I should not be trying to convince you, it's better that you come back to use that code in six months time and learn that it sucks on your own hide than trust my arguments. I just want the future you to know that there's nothing wrong with him, that his WTFs are not because he's stupid or a bad programmer, on the contrary, saying "fuck this shit" and replacing it with a much simpler, straightforward solution would be you growing in the right direction.
They probably tend to prefer Java/.net because they are backed up by corporations (Oracle and Microsoft respectively) unlike Python which is mostly community driven. This is somewhat the case for PHP as well with Zend.
Last I checked, you can't add new columns to a CF with compact storage, and it was stated that it was unlikely that column removal would ever get implemented. Not to mention that from all the tests we've run, the CQL-parts of Cassandra are still pretty buggy and immature. (We haven't tested these features in 1.1, though, but I doubt a single minor release is enough to stabilize things) In the end, CQL and all its features are just a (somewhat buggy and poorly implemented) sugar on top of a relatively simple and robust storage engine. It's not really a very well designed sugar, or one that is well adapted to Cassandra's strengths and weaknesses. Instead it seems designed to tick of as many check boxes as possible for business types that are used to the SQL world. Seriously, every sane person in the world hates the SQL syntax with a vengeance, but here the DataStax people are, hard at work trying to recreate every single wart, bad design choice and misfeature of that abortion of a language, 40 years after it somehow escaped from the science lab that rightly should have been its grave.
Fine examples of premature optimization and hyper-generalization... well done, gents. The OP just wanted a fucking basic number range for testing purposes. A few log10 calls in a test case aren't the end of the world. simple clarity &gt;&gt;&gt;&gt; cleverness and other forms of turd-polishing
OK. I guess I would say that all of CQL is a huge mistake and everybody should use something closer to pycassa. :-/
That's completely understandable. I've been embedded in scientific python for too long.
I recommend adding an update to your article, either revising the example or clarifying the "simplification".
Dat star in brackets! Yes, immutability and related stuff helps a lot, in particular you can't quite tell if Erlang uses threads or processes. Can you?
this is wonderfully wtf, i like it.
Look into sessions in SQLAlchemy/Storm. Django ORM implies one monolithic session for it, and it’s not very good. Basically it’s not so different from using `mysql_*()` functions without explicitly passing database connection in PHP.
You could use cloud9 (http://c9.io) as your online IDE saving directly to github. Then use travis-ci to run your tests, and use a AWS/Rackspace micro instance to pull from github to run whatever you need ? 
It's called "recreational programming" and your poor opinion of it doesn't make it any less valid. 
This is very interesting! Unfortunately google-code doesn't have PR's, you'll have to clone our repo and then open an issue so we can start the discussion about your changes in your clone. We also use rope to get docstrings and calltips, can Jedi do that too? How configurable is it?
I agree i never use Zope or plone , so this list is a lot more useful for the rest of us who use django for example
If you really need an immutable object, you are probably going to end up using a metaclass. 
The best thing about proper green threads in core is that they can, given enough time and effort, completely replace regular threads, making Python like node.js, only better ( I do realize that this is very very hard to do, but at least it's feasible ). Add some zero-copy immutable data structures and suddenly Python competes better with the likes of erlang. You can write regular Python code and have it "magically" scale onto multiple processes in production while running a single one in development. Welcome to the world of actors and message passing without any special syntax. All completely testable, debuggable and very powerful and easy to use. Moreover, most of existing libraries will have async IO benefits for free. And, even more importantly, they can still continue to write the code as they did before, their public API dont have to change at all. Callback/yield style of concurrency however is entirely different matter. It will never ever be able to center the whole environment around itself, so there will always be duplication of efforts between regular Python libraries and "async Python libraries", and this duplication problem will become worse and worse as callbacks popularity increases. In other words - green threads are *evolution*, while callbacks are *revolution*. Do we really need another one?
\*shrug\* I have no problem with metaclasses, I just took issue with your point that if one wants an immutable object then one will likely end up using a metaclass. It makes sense now that you have clarified that there were also other (perfectly sensible) implied features.
&gt; The fact you believe Guido doesn't have control over his own language but does on those others validates your stupidity. I believe that? You can't into reading comprehension, bro. You should learn that before attempting to discuss advanced topics; baby steps bro.
You can get both from the script object quite easily i think. I will try to make Fileinfo subclass and send the code to spyder-mailing. Than you can see what you'll make of it.
Yeah. It's just like that. Except for, you know, being an ORM. And not opening you up to SQL injection attacks. Flamebait is flamebait. (and I bit. Sigh.)
Really awesome project, hate the name.
It's not complex - or is this like sarcasm?
this is awesome i was always sad that there where no python talks. there could be also some sprints :)
That'll be great! I think it'll be good enough to get us started.
At a certain scale, obviously, nobody would recommend it -- because, at scale, frameworks work better. But if you want to make something small, if you don't want to learn a framework, or figure out how the fuck CGI scripts work... PHP lets you do very simple things. I remember... I suppose these things are not *that* simple, but they don't require frameworks: * Autocomplete. I just needed a function that would take what's currently in the text box as input, and... I can't quite remember, but I suppose a list of words to show as output. * Curl requests. Certainly not easy, but I don't know of any way I could have done it any easier with python.
I was genuinely curious how this was handled, particularly when the context switch can happen in external code not originally designed for async. 
I guess why it's not being done is because there is no DOM access in python, and it's not standardised by the w3c, that would be a little disadvantage to javascript. Python has a strong flavor of open source too which is not really attractive to the industry unfortunately. You also have to think about security, you would need to come up with another python dialect that can't open files. I'd love to hear Guido van Rossum about this idea or any other python guru or developer. Also it would still require a lot of skill and time to have a python equivalent to v8 or monkey, although there already are some. I guess it's both a problems of politics (training programmers to python, which is not a really big problem), standards (ecma script and js have different history I guess), and companies who would like to see that done. Python vs js can be somehow debatable, it's hard to convince people python is better in general, it can become a flame war which is not really attractive to investors. I guess the indented syntax makes python somehow uncommon as a programming language and scare away a lot of programmers, although to be honest I'd love to see more language with that kind of syntax. To answer your question, I think it's a big challenge, because browsers are not really simple pieces of software, but I guess if a project appear many people would join...
Don't you think that 74 [source lines of code](http://www.dwheeler.com/sloccount/) (without the STATIONS list) is a bit too much for a bunch of buttons that launch an external player?
For someone with JS-phobia (like me), this is all kind of awesome! After reading the code for the [demos](http://www.brython.info/test/gallery.html), I can picture myself being able to produce "apps" with bottle.py + boostrap + Brython.
Guido addressed Python in the browser in his [keynote at PyCon 2012](http://youtu.be/EBRMq2Ioxsc?t=41m33s). I don't know at exactly what time. edit: updated link to the time where he talks about it.
It's interesting though that JS is still the only option for client-side web development. On the backend, I can name at least 5-6 popular languages and probably a couple of dozen more obscure ones. Why hasn't this variety proliferated to the client? This "language lock-in" has spawned an entire industry of hacks around the limitations (or design choices) of Javascript: jQuery, CoffeeSript, etc. It's even prompted projects like Node.js, which is popular not because JS is perfectly suited for server-side environment, but because it allows frontend devs to more easily move up and down the stack. Baring in mind the challenges that you mention, it seems like introducing an alternative, like Python, could spur additional innovation. 
&gt; can't open files &gt;&gt;&gt; open("myfile.txt", "r") Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; NotImplementedError: Cannot open files in the browser I think everything else that has file access works through the `open` interface, so disabling that would solve much of the issue.
Not at all. Considering what it does it looks really simple to me. The bulk of it is setting up the gui and the error handling. I'd love to see the same thing done with say swing or some other multi platform gui.
http://docs.python-requests.org/en/latest/ It's a *lot* easier; after finding this, I'm never going back! :)
 print safe_access(path='a.b["abc"][1]', base_obj=a, default_value=7) You know what would be nice? An alternate API that uses a tuple so you can pass in objects that don't have literals (and so you don't have to invoke ast at runtime). You'd have to distinguish attributes from string dictionary keys in that case, though. Why is base_obj second? It seems like it'd be more natural to put first. A tuple-based one could even just have it as the first member of the tuple. Why do you use exceptions for index access, but hasattr for attribute access?
Wouldn't an api like this be better ? x = SafeWrapper(someobject, default=None) x.bla["foo"][123] 
Do you mean political or technical? From a technical point there is nothing todo, besides just implement it in the browser. Mozilla had such projekts and there were addons that added python-scripting to firefox toolbox. There were also some for ruby and perl. I don't know what state those projects now have, last thing i heard were'nt really good. Problem here is the politic. Javascript is established and all tools are capable to work with it. And now even the engines are gaining great optimizations. So, for what reason should browsers add a new language, even if it's some established like python? It the typical chicken/egg-problem. Nobody is using python on client-side, so nobody cares to work on it, so nobody is using it...
Ick. I take it you're not familiar with `dict.get()` then? Because it solves the same problem without requiring a whole wrapper class: &gt;&gt;&gt; foo = {'bar': 42} &gt;&gt;&gt; foo.get('baz', 12) 12 (Substitute `None` for 12 if you want `None` returned if the key doesn't exist. I used a number because the Python REPL doesn't show anything for `None`.) If you want a dict that auto-vivifies such that you can just write to arbitrary keys at arbitrary depths without ever worrying about whether they exist yet or not, then turn to `defaultdict`: &gt;&gt;&gt; from collections import defaultdict &gt;&gt;&gt; def autodict(): return defaultdict(autodict) ... &gt;&gt;&gt; foo = autodict() &gt;&gt;&gt; foo['foo']['bar']['baz']['quuz'] = 42 &gt;&gt;&gt; foo['bar']['baz'] = 123 Reading a key that does not exist does not raise an exception, but returns an empty `defaultdict` which if used in a boolean context is `False`: &gt;&gt;&gt; bool(foo['nonexist']) False 
Most (all?) blocking operations in gevent accept a `timeout=` parameter. Additionally, there is also [gevent.Timeout](http://www.gevent.org/gevent.html#gevent.Timeout), which is roughly: class Timeout(BaseException): def __init__(self, timeout=None): self.timeout = timeout self.thread_to_kill = gevent.getcurrent() def start(self): gevent.spawn(self._kill_thread_after_timeout) def _kill_thread_after_timeout(self): gevent.sleep(self.timeout) if not self.thread_to_kill.ready(): self.thread_to_kill.kill(exception=self) And this pattern should be applicable to any greenlet-based system.
dict.get &amp; defaultdict only works for dictionaries. This allows you to drill down multiple levels into attributes, dictionaries, and lists.
I think those are great suggestions. I'll definitely incorporate them. Differentiating strings from dictionary keys should be easy because strings will have to start with a quote character and variables will have to start with an alpha character. I used hasattr instead of try/except, just because I figured if there was already a python builtin, I might as well use it. 
Well, yes, in the current interface where the path is a string, but the tuple interface I was proposing would ideally simply pass the string itself for a string. Maybe have a magic value (maybe getattr) you can pass in to make the next string treated as an attribute instead of an index. Like, `safe_access((a,getattr,'b','abc',1),7)` is the interface I have in mind.
And here's the link for the [best scripting language](http://www.linuxjournal.com/slideshow/readers-choice-2012?page=28).
it seems that you just target dictionaries though, in which case a closer read of Python's documentation of dictionary might have saved you some time. 
It's a good idea, but the lack of functionality is disappointing.
Does the w3c standardize javascript? I think I read the w3c DOM definitions and it was written in a language-neutral manner.
Neither Iron Python nor Jython have a GIL, so you're asking about popular implementations of language, and not about all implementations of popular languages. If you do the whole stack yourself then GIL implementations are easier. The Iron Python and Jython versions get to build off someone else's hard work of doing fine-grained locking. .Net and the JVM have had a *lot* more development effort than Python.
A bunch of buttons you did using a GUI library. And GUI libraries are always messy and complex. Because they want to solve everyone’s problems at the same time. *You* want a simple list of buttons. I want the next KDE. Please don’t forget that those are mostly C/C++ bindings — the original C{,++} libs are even a bigger mess in the original. And I am the guy who wrote an About window in 45 lines of PyQt4 (≈ PySide with a different license and name — for your project, I just swapped the imports from PySide to PyQt4 and it worked like a charm; I do not have PySide installed, but I am doing it now. Currently going through a dependency hell, because Arch Linux has no official packages.)
Hmm. I hadn't thought of that as a way to get the same functionality within your API, good catch. Have you considered a=a instead of baseobj=a? i.e. `safe_access('a.b["abc"]',a=a)` - with the variable substitution, that almost seems like a more natural way than my previous suggestion of putting baseobj first.
Why not do try: x = foo.bar["baz"][:qux] except: x = 7 You're seriously going to eval a string to avoid writing a try block?
Python is competing with _Bash_?
That would be a better name
Brothon.
PiCloud dev here. Thanks for mentioning us :) I thought I would also mention that for those doing scientific computation we're currently hosting our [2nd Academic Research Grant Program](http://blog.picloud.com/2012/12/11/announcing-piclouds-second-annual-academic-research-grant-program/), where you can apply to get 10,000 core hours for free.
So it's PHP then?
Does anyone else find this ugly and misleading?: doc['result'] &lt;= str(x) + BR() IMO it would look nicer if it used the `+=` or `&lt;&lt;` operator.
Yeah, it definitely shouldn't be used with careless abandon. I wrote it mainly for processing data coming back from third party APIs where you want to drill into a response object, but would have to check the attribute/key/index access at every layer.
I think the rule of thumb is to include a subset of "Python" in the name of the project. I think I'll come up with a project that will generate names for other projects. I'll call it pynamathon. What do you think?
Sounds absolutely horrible. It'll fit right in.
Yeah but then you would have to prevent the use of subprocess, os.system, file, and all the obscure way of opening files. Because the issue here is not opening the files by mistake, it's trying to access a file maliciously in any tricky way, not just overriding the built-ins. So I guess that would be a lot of changing in the parser implementation and in the compiled packages that can be installed...
It's worth considering [pyramid](http://www.pylonsproject.org/projects/pyramid/about) and [sqlalchemy](http://www.sqlalchemy.org/organizations.html). Reddit itself was developed using pylons, of which pyramid is the successor.
I imagine `os` would be similarly stripped to prevent unauthorized access to the OS. You make a good point that there are [other](http://docs.python.org/release/2.5.2/lib/bltin-file-objects.html) points of entry for creating [file](http://docs.python.org/2/library/socket.html#socket.socket.makefile) descriptors.
Thanks! I'll check those out
Because that code is impossible to debug
The Linux kernel, [by recent estimates](http://royal.pingdom.com/2012/04/16/linux-kernel-development-numbers/), has over 15 million lines of C code. I challenge you to find a single kernel developer who uses an IDE. **Edit**: Actually, this wasn't as rare as I originally thought. [IDEs can sometimes be useful in kernel development too.](http://stackoverflow.com/questions/149321/what-ide-would-be-good-for-linux-kernel-driver-development)
Because I'm sure some other people will also be wondering: [here is the javascript that implements the python interpreter](http://www.brython.info/brython.js) to allow this to happen. It's over 100 KB.
Anyone else thinks that the name "brython" is really horrible? 
It used to be "brothon". We should consider ourselves lucky!
Call me cynical but Dart and Coffeescript have much better chances of replacing javascript. 
The author needs to namespace the code.
What the hell does "map!" mean? It goes against all previous conventions that ! == bang == invert I've programmed Perl for a long time, got tired of special symbols, tried Ruby, see the same thing, and finally settled on Python. Never looked back.
Have you thought of overriding `Database.__new__`? 
Somebody will rewrite it in emacs lisp, and we'll have brothel. 
Can I take this moment to point out how frustrating it is for a python novice to make any sense of this sub? Every other post: "Pygruytidocdbasidhd: a frisks handled lib." The fuck?!
Pure ignorance right here. python2.7 script.py python3 script.py If you have trouble with this I fear for your cognitive health. Also, http://pypi.python.org/pypi/virtualenv 
+100, even though I love python, I totally agree on that one
What's wrong with code in a sans-serif font?
I don't know where you end and scientific python begins.
From the documentation page: "The class keyword is not implemented, you can not define classes other than the built-in types (lists, dictionaries, sets)." That's going to feel pretty limiting for me...
you can start by googling frisks and see what you get... so... its a library handled by "a leap, skip, or caper." and it's HD! Wow! How can you not understand that? :)
Correct. W3C should have standardized JavaScript. However, when Netscape asked them to standardize it, they refused. Apparently (However, i cannot confirm) due to the standards war they were waiting for an opportunity to say to 'go to hell' to Netscape. So Netspace went to Ecma International and standardized with them as ECMAScript.
Brogrammers, yo. 
Yeah, that's no bad idea. The only reason why that didn't work for xml is that xslt is a horrible verbose clusterfuck. 
The bang is used in Ruby, but also in other programming languages (I think in Scheme and maybe Common Lisp) to express the mutating nature of the operation. I guess the bang is explained quite early in any Ruby book. What's the point of "learning" a new programming language if you want it to stick to everything you previously known? If you have to say "what the hell" for little syntactic conventions (Did you came across some underscore-prefixed method name in Python ? Did you notice its use of indentation?), I wonder what you'll do when you come across more important subjects.
Coffeescript *is* javascript. And nothing will ever replace Javascript because that requires Microsoft, Apple, and Google to all get on board with the idea.
I've always loved the idea of a unified document serialization syntax based around JSON. Instead of: &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Crappy html page&lt;/title&gt; &lt;script type="text/javascript" src="blahblah.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;What is &lt;strong&gt; going on in here!&lt;/strong&gt;&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; I so want to just write: jsondoc : { head : { title : "Neato json page", script : { type : "text/python", src : "urlishness" } } body : { p : ["This seems", strong("so much nicer"), "."] } } I imagine in the same way in javascript (and json) you can omit the parens around a key, you could have tags as reserved keys. I dunno about the paragraph syntax, just seems the most obvious to segment an element that has different modifications applied to it into an array. Though, looking at this, it seems like if everything is a map, you could omit a lot of the colons and have them implied. Maybe even have a whitespace significant version so you can omit curly braces. Try to minimize the grammar overhead and all that. Maybe instead of having script : { which acts like a content declarator, for the modifying properties of a "tag" you might write it in function syntax like script(type="text/python", src="urlzilla"). But that makes me want to write the paragraph element like the others, where you omit the key:value syntax and have raw strings represent raw text on the page like p : { "Words,", strong : "bold words", "and some more words"} but then how would you do nested tags like &lt;strong&gt;&lt;emphasis&gt;stuff &lt;/emphasis&gt;&lt;/strong&gt; would it be {"Words", strong : { emphasis : "stuff"}, "ending words"} which kind of starts to get ugly, even if it is syntactically compliant? I actually like that more, to revise the original example (in writing it, I think just using colons for all value statements instead of the equals signs in the function definitions just looks cleaner if you eliminate the redundant glyph, and that if you treat tags like functions you can ommit parenthesis if there are no arguments) jsondoc : { head : { title:"Round 2", script(type:"text/python", src:"urlishness") }, body : { p(id:"oneandonly") : { "Some textual context", strong : { emphasis:"fancy text" } } } I'd consider eliminating the colons descriptors and letting quotes qualify as the syntactic breaker glyph, but then you couldn't use raw numerics like timeout:5000 so that you don't have to do numeric -&gt; character -&gt; numeric conversions. Alternatively, you could force everything into characters (they would really end up there anyway if you are sending these around as text documents, you are converting back into raw numerics at some point) and mandate all "values" be text - but then you can also assume that other breaking characters like closing braces or commas can act as the textual escape. Though having a single end character for a sequence is usually the better way to implement it, it is glyphic overhead vs syntactic pitfalls where writers might forget a } , ] ) are string delimiters. I *really* think you could go pretty nuts with this idea though and get some serialization format that is *also* a fully valid and sufficiently powerful markup language. Data serialization and document writing are such similar problem domains, after all. Even better if you can get a binary serialization format for one, you can just compile the other and save network bandwidth.
/r/brogramming has so much wasted potential...
I like Dart. Simple and powerful. What I would love is if Google replaced Java with Dart because of Oracle, but it won't happen.
In the same line of thought, nothing will ever replace x86 due to backwards compatibility. You can try to emulate it, but the trillions of lines of x86 binaries are the most powerful anchor in the software world ever. Similarly, trillions of pages of html with javascript are a web anchor. More likely they would keep doing what they do now - static compilation to javascript for distribution. Unlike the pitfalls of C / C++ style preemptive conversion to the target language, you don't need JIT compilers on the web because the grammars are so similar. And I never said it was unreasonable - I would *love* to see browsers drop javascript as the king of all DOM scripting languages and let script mimes like text/python text/ruby text/perl work. They could background download interpreters if they can't find a local one, and just dynamically plug and play interpreters for whatever a web page wants. It is a lot more UNIX that way at least, you keep the scripting language much more discrete than the current html parser + css render + javascript interpreter mess that every modern browser is. I just said you will never get Apple / Google / M$ to agree to do something this drastic. And good luck trying to get that kind of behavior standardized in html6 (htmlX for that matter... or htmlXX.... or htmlXXX).
I personally dislike Dart. It feels like google is trying to bully it's way with a new standard. Google shouldn't tell people what to do, they should nudge them in the right direction e.g. coffeescript.
[I talked about this in another fork of this comment thread a bit.](http://www.reddit.com/r/Python/comments/14vaj2/brython_is_designed_to_replace_javascript_as_the/c7gynta) You absolutely need to have the capabilities of the language you try to supplant with something new from day one. Honestly, it is why I think JSONesque syntax makes more sense than trying to use markdown or yaml - it is a naturally tree structured syntax which lines up with how html works nicely with curly brace syntax. Also, strong is a tag. Your grammars are mixed up if "title" (also a tag) behaves with a colon but strong text behaves with a classic html tag. And on that, fact (and ninja_weapons) definitely aren't standard "types" (tags, typing, same concept) so they would more easily be definied (going back to my cooky json frankeinstein) like this: jsondoc { title : "Ninjas Are Awesome", p(id:"fact") : {"A ninja's natural enemy is a", strong : "PIRATE", "!" } ul(id:"ninja_weapons") : { li : "sword", li : "kung fu", li : "throwing star" } } Though I'd guarantee such a syntax would have [] be a shorthand for a collection of list indexes. This kind of breaks json compliance by using parenthesized arguements. Another option would be to have the "first" index of the map be the arguments array, or just have a special type of args : that is the modifiers in the map. But I think that looks ugly.
an implicit reply? http://www.amazon.com/Spring-Python-1-1-Greg-Turnquist/dp/1849510660 ?
I got the impressions Coffeescript to Javascript is more like C++ to C.
ARM is replacing x86 in a lot of places, though, right? It seems to me that even though so much software is x86, as we transition further to new platforms most people will discover that they don't need those old x86 programs after all. It would probably end up something like the transition from python 2 to python 3. I expect the same would happen for the web- years from now, people will probably be using a different programming language for new projects, and eventually as people develop entirely new, faster web browsers, those browsers will just completely drop support for Javascript, and eventually you would end up needing a specialized web browser to view websites we consider current.
I'm all for Python in the browser, but please come up with a better name!
The documentation system already works completely offline, just go checkout the CPython repository, `cd Doc/`, `make html`. Done!
This is true. I use coffeescript for personal projects, but at work I go with JavaScript. I'm actually in a position to make decisions about what technologies we use, but for the sake of finding devs who can maintain it I feel it's best to stick with JavaScript.
To be fair, you still don't have to. But some tasks are increasingly time-consuming when your project becomes more and more complex. Actually, I try not to use full-blown IDEs, but I did pimp my vim to be pretty much equivalent.
So, code not in a monospaced font then. Monospaced and sans-serif are two totally different things. You can have a font that is monospaced and serif, like Courier New, or something that is monospaced and sans-serif, like Monaco. Sorry to be a font nazi, but you *were* calling him an idiot.
Try something that ends up triggering a dozen imports, connections to two databases, building a few ten thousands of objects, etc... My point is, all of that happens in what looks like a totally normal property access, and even if you do what Megatron_McLargeHuge suggested in the right way by specifying AttributeError and KeyError, one could still bubble up from way deep down and you end up with a semantics bug.
Not always. It's not like you can't read the code and see what's really going on. If it's all your own code, just make sure not to do stupid things with @property. Or if you do, just make sure you have good exception handling code. Doing just except: without specifying an exception type is horrible.
I take issue with the statement "Of course, most experienced Python programmers use objects only when necessary. They prefer Python's built in data structures, especially when creating APIs.". This is bollocks. As soon as you start thinking of linking an API with a purpose-designed data structure, you are really talking about objects and you'd be stupid not to use python's excellent facilities for object construction (i.e. classes).
Show me 10 people calling a font “monospace sans-serif”. Good luck.
I played around with pyjamas, and amongst other problems, you get totally meaningless errors, so debugging is a nightmare. Good stack traces are one of the reasons Python is good, and I think this is fundamentally quite a difficult problem to solve. So I'm not optimistic about "compile to js" solutions.
have you looked at cherrypy or web2py either one can serve standalone or hosted in the cloud on EC2 or GAE you might also check out webapp2 
That is Guido's response because that's the corner into which he had backed cpython. It also shows a fundamental lacking of threading comprehension on his part. Thread per I/O its generally considered a bad idea. It has significant scalability issues (see development history of Apache as example and why hybrid model is defacto for Apache). Furthermore, thread context switching for per thread-i/o frequently harms latency, especially at scale. All of these issues are further compounded by Guido's many poor choices, at his insistence, made for cpython. Beyond all that, once you complete i/o, you traditionally need to do some form of processing. In python, even a modest amount in-python processing frequently destroys any and all parallelism advantages in python. Add to this Guido's insistence to keep threads a second class feature while enforcing thread limitations as a first class problem. The combination is why threading is so hard to fix. Furthermore, Guido is on record condemning threads in general. Basically cpython's limitations are because threads are evil and everyone is too dumb to ever safely use them. As such, Guido has saved us all from our own ineptitude. Computer science proves him wrong - daily. Which is a nice way of saying, Guido saved us from his own ineptitude in threading. And given today's hardware, he is completely out of touch with reality - in this regard. 
Sufficiently advanced funding would also do it.
I agree with everything you said here but there's one thing I don't get. Python is older than Java and well established as a near de facto standard on most Linux distros. How can any language pull that off and yet still be perceived as a "toy" or a "fad" language?
Doesn't setup tools have support for rpm/deb? I am wondering if you could us that instead of the ruby dep. This is really cool though! 
setuptools only supports rpm, so perhaps I can get some functionality from there. fpm has concepts for preinstall/postinstall scripts that could be useful, though.
Same with building websites in dreamweaver, its a crutch, forms bad habits.
Hey Ogi! Hope things are well for you? If you want to have some more fun hacking on Python with us, KA Lite always has room for more contributors! :D
It actually starts at 1:14, sort of... It then really starts at 2:14, sort of... Finally, we get going at 2:50...
I am sorry, its an hour and 35 minutes long.
I see that, I'll try to watch it tomorrow.
It may well be possible with a combination of system site packages and the vanilla make relocatable. I will give it a shot when I get ten minutes.
That looks good, but I couldn't actually see that it packages environments, or did I miss it?
Python without classes is really perl with better syntax. Python grew out of Perl due to the fact that perl was not OO. While the syntax is nicer that wasn't much of a selling point back in the day -- especially with the way white space works. Python provided OO. Brython doesn't support classes - that's a deal breaker and reasonably brython cannot claim to be python without that. Also it appears that functionality may be replaced in brython. I think the liberty taken here is going to kill this particular instance before it gets very far.
That one is much harder to explain. Short answer, Java was created by big business for big business. Python was created with much smaller goals that grew over time. 
Yeah, I should add a license, but feel free. 
The "optional" option was added in Python 2.6+ http://hg.python.org/cpython/file/a50b409ee89f/Lib/distutils/extension.py#l80 If used, Distutils silently ignores a compilation error
I'm not sure what you mean by a military-centric company? DARPA is the arm of the military that's responsibly for advancing the state of technology to meet defense needs (yes, aka military needs). It is e.g. the reason that the internet exists, though, so it's worth looking at it with a slightly different point of view than as a "military-centric company" since I don't think that accurately describes it at all.
It not actually a player written in python ... though I do like what it does and have added it to my scripts folder. Thanks for sharing
i know that will be downvoted due to the american’s indoctrinated love for the military and guns, but: --- an arm of the military apprears pretty military-centric to me. and while i know about the military’s role in the creation of the internet, that doesn’t mean that i have a reason to develop any warm feelings towards the military. &gt; [A military is an organization authorized by its greater society to use lethal force, usually including use of weapons, in defending its country by combating actual or perceived threats.](https://en.wikipedia.org/wiki/Military) so the whole purpose of any military has always been (and will likely be for a long time) to apply lethal force, aka kill. as a pacifist, that’s incompatible with my whole moral foundation.
Nice! Really like that the connector adapter has been factored out. Room for SPDY or anything better that comes along.
The transport adapters portion of the idea has been implemented in Requests as of v1.0.0. The intention is to make it easier to move into the HTTPCore framework as and when that happens.
gladly i’m not american, but i also wouldn’t move to another country: that’s a far too big incision in anyone’s life to be a valid solution to that problem. and i don’t see you quoting any statement above, so what do you mean? and finally: what wretched logic makes you think that just because the americans base their sub-par health system on the military i’d think better of it? the [prison industry](http://www.cnbc.com/id/44762286/Billions_Behind_Bars_Inside_America039s_Prison_Industry) is also a big part of america’s system to deal with certain social classes and [mentally ill people](http://anarchistsoccermom.blogspot.de/2012/12/thinking-unthinkable.html). all that makes me go “wtf is wrong with america, other countries don’t have that kind of insane structure”, nothing more.
Really-existing US government is all about socialism, but will only fund if it can be linked back to killing in the name of imperialism, with plausible deniability if it ends up being a net benefit to humanity.
Sorry it was reverted in 2.6+ - it's only present in 3.2+
&gt; i know that will be downvoted due to the american’s indoctrinated love for the military and guns, but: I have no problem with you being against the military but this kind of opening line practically guarantees a downvote from me.
Any examples you guys care to share?
i simply faced that reaction often enough. putting the phrase in didn’t change the outcome (nearly equally many up- and downvotes).
his name sounds like an actors
Useful tutorial. As cool as they are, I personally haven't really found a need for websockets in any of my applications.
I don't know why you have char as output but in the else you have an error. else: while len(fib) &lt;= n: fib.append(fib[-1] + fib[-2]) //here Your list don't have elements and you are using the last elements of the list.. that's an error. How to fix it: import random, math def fibnum(n): fib = [] if not isinstance(n, int) or n &lt; 0: return 'cannot compute' for i in range(2): #the change is here fib.append(1) if n &lt;= 2: return fib else: while len(fib) &lt;= n: fib.append(fib[-1] + fib[-2]) return fib print random.choice(fibnum(math.floor(random.random()*15 + 1)))
Also math.floor is giving you a float with no decimal part so math.floor(2.3) returns 2.0 Use int() instead. fibnum() is expecting an int but receives a float so as expected return 'cannot compute' Then random.choice() receives that string and chooses randomly a letter from it.
True, but as I said: I only tried it to see if it would yield different borings this time
Like stevenjd, I don't want to be too negative because the idea is cool, but the code is... kinda messy. * No clearly defined API. What am I supposed to call? (Sure, I can figure it out from reading the code, but I shouldn't have to, don't you agree?) * It leaks internal code (remove_html_tags, soup parameters) * It uses regexps to operate on HTML. This is generally frowned upon * Generic try/except without specific exception to catch * No documentation * Commented out code / debugging code Maybe this seems a bit harsh, but I've always believed that publicly posting code entails certain responsibilities. Lots of people will see your code, and start to think it's alright to program like that (ever seen PHP programmers copy/paste from the PHP Manual User Contributed Notes? \*brrr*) *edit*: The most vulnerable part of the code, namely the fetch of the external resource, has no error checking. If there's any place where a generic Try/Except without specific exceptions is allowed, it's there.
Thanks a lot. I had the same issue (except I had no idea why my code didn't work anymore).
The point of stdeb is to build a single .deb file for a single .deb package. If you need a whole environment, you need a .deb package for each component. Of course, the dependencies specified in the packages are full apt-get level dependencies and when you install python-foo, it will automatically tell apt it depends on python-bar. (So if you need multiple custom python packages, you probably want to start your own deb repository, using a PPA or mini-dinstall for example.) The philosophy is reusable components, not to package an application as one large download that depends on nothing else. So the purposes of stdeb and pypackage are pretty divergent.
http://semver.org/
Just really a matter of preference, I'm not expressing an opinion on the framework itself but: config.add_view_predicate('abc', my.package.ABCPredicate) I would have found this more readable and intuitive: config.views.predicates.add(...) Or something of that effect.
Clearly not my taste indeed. I've never considered exposing objects was poor practice in Python, *au contraire* I'd say :)
The facade pattern is pretty broken in Python to be honest, though.
Is [this](https://store.continuum.io/cshop/numbapro) what you're looking for then?
I may be wrong but Python developers have a rather clear convention (if not pretty) to notify something is for internal usage only: the _ prefix. I usually consider everything not prefixed by an underscore to be public-ish.
of course pypy is the future of python. without reading the article: JIT compiling is simply faster than interpreting.
http://wiki.python.org/moin/PythonEditors At least one co-worker of mine uses Komodo. http://www.activestate.com/komodo-ide I use VIM.
"Always release on a Friday" is my mantra for libraries, the opposite as the one for application deployments. This means that the early adopters are the ones developing, deploying to staging or at worst, who go against common sense and deploy on a Friday, in which case it's not my fault anyway. This gives me time to relax and fix bugs during the weekend and usually a x.x.1 is already out on Monday.
If you are used to visual studio then [Eclipse with PyDev](http://pydev.org/download.html) will probably be your favorite, although there is also a [python plugin for vs](http://pytools.codeplex.com/).
which OS are you on? if on linux, which desktop environment?
[Komodo Edit](http://www.activestate.com/komodo-edit/downloads). Projects. Code Completion. Intellisense. Syntax Highlighting. Similar keyboard shortcuts that are easily customizable. You'll feel right at home.
If you've got Visual Studio, why not try Python Tools for Visual Studio? I've found it to be pretty excellent (although I'm a Sublime Text 2 user myself). http://pytools.codeplex.com/
I've been the one upvoting your comments &amp; even thanked you for your in-depth answers. At no point of time did I do a single downvote to someone edifying my understanding on Python's GIL and how it works with regard to concurrent operation(often seen in Java being done by Threads) or, lack there of, vs just performing a fork, rather, subprocessing of the parent process. My understanding of issue thus far has been: Python can fork the process, this allows the GIL to be bypassed. It would seem to be suggested on Mulicore systems that the main process that forked the child is not continuing in Python to do the work that it could be doing, rather, it has to stop or wait for the child process at some point along the way. Further, it would seem to suggest that the two processes are not working independently of one another, ie, the parent process will not finish before the child? Perhaps you mean to suggest that the forked process creates it's own identical memory space as the parent, but, independent of the parent, thus, parallel. Python's only ability to share memory resources can only be done if the code is not being done in Python. 
I like this idea.
You're being downvoted because you're on a very high horse regarding your apparently weak pacifism.
Yah it's a god sent for apis.
For the uninitiated: [Ed Is The Standard Text Editor](http://c2.com/cgi/wiki?EdIsTheStandardTextEditor)
VIM and Sublime Text 2? Explain yourself. Does SLT even g;?
+1 for Sublime.
+1 for PyCharm. I've done all my Python in it -- it comes with all the niceties of an IDE, and is quite functional. Useful for someone who has come from the Java or .NET world who is used to using an IDE. 
I love PyCharm myself although that takes it out of his "has to be free" criteria.
Isn't it better now? I thought they were making improvements in that area.
PyPy sure is a future of Python, but so is CPython. Why do things always have to exclude other things here? Let people use what they feel is good for them and you'll have a wide variety of fields where Python can be used.
It seems that you make active use of PyPy. If you are not in the core PyPy team, this means that PyPy is actually used in the wild. Sorry, just stating. Did not know that.
I am using it right now for a combinatorial optimization problem I am working on. (Just another data point for you)
I think this will become less true over time. The numpypy library is a huge improvement over numpy, and for new research projects that require scipy I find myself in the situation of asking, "how much of scipy do I need? If it's less than 5 functions, I'll just rewrite them myself". In my latest research project, week long simulations were reduced to under an hour. Businesses have a much less fickle dependency on CPython, where they have invested heavily into the C api and designed large code bases around it. Re-architecting around something like cffi would be incredibly expensive and not worth the benefits. These are the kinds of companies that will probably never update to python3 just because of its backwards-incompatible C api changes. At least in these communities, CPython and Python 2 are here to stay.
I think you should use multiprocessing instead of threading. specifically the Pool object might work well for you from multiprocessing import Pool import requests urls = ['/somestuff', '/somethingelse', 'somethingmore', 'etc', 'etc', 'yougettheidea'] def func(url): print requests.get(url) pool = Pool(processes=4) #how many cores do you have? pool.map(func, urls) 
https://github.com/kennethreitz/grequests All you need, and will ever need, packaged by the awesome Kenneth Reitz…
Haha na it doesn't. Not even with Vintage Mode turned on and the VIM community package. :/ But it's still a solid GUI text-editor and I thoroughly enjoy using it.
;) The main intent for us to build a "better" lib instead of using existing ones was extensibility (and then speed). For instance, we use new PostgreSQL JSON support to get data encoded in JSON right from the database, we then wrap this data in a buffer with \_\_mm\_json\_\_ method defined, and then we enclose those buffers in an envelope, then we dump this envelope straight to bytes (so we don't even decode data from database) and send to the socket. There is no way of doing this elegantly with stdlib's json module. mm_serialize hook is also very handy, when you need to add JSON serialization support to your custom objects.
It's running my Django site.
Yes, but for some reason there is no Pool in the threading module.
https://gist.github.com/4333067 Interesting results. First, it looks like ujson has a bug, as it crashed with "Maximum recursion level reached" on a fairly simple list, and it also has unusually cool results on serializing lists of doubles and short ints -- i'll investigate tomorrow why (maybe it caches or simply serializes them wrong?)
Care to fork it so we can just download the 2.x compatible version?
&gt; there is just one hook in stdlib json Encoder class - "default" method. the dumps() method in "json" has these hooks and options: dumps(): skipkeys, ensure_ascii, check_circular, allow_nan, cls, indent, separators, encoding, default, sort_keys also why no decode ? We should still use stdlib/simplejson for that part of it ? or is it more like, we should be using your Encoder as the argument to standard lib dumps(cls=&lt;your encoder&gt;) ? 
So in other words, you don't actually rewrite the functions, you manually wrap the LAPACK routines yourself.
OP wants to save time. His current code has each request waiting for the previous one to finish before starting, so the total time of all the network requests in linear succession is what's making the program take so long. Since the computer is capable of making more than one network request at a time, using threads means that new requests can be started before the previous one is complete. Thereby lowering the total time for the script to complete.
No, I would if they needed to be written. For instance, specific statistical distribution functions. My point was that both of these things are clearly in numpypy already and there is no need to write anything to use them in pypy.
&gt; Have you ever used those parameters? cls, indent, sort_keys, all the time. &gt; Besides, since we introduced our own API, don't you think being able to drop in your encoder without any changes to an existing application would be of use ? 
I would use urllib3 Supports multiplexing requests without manually managing threads
My biggest challenge as a proponent of Python in general and Django in particular is that most of our clients and uninformed client-side people (I work at a digital agency) think there are only two tiers in web development: lite (PHP/Wordpress) and heavy (.NET). They have never even heard of Python, let alone considered it a candidate for creating our newest endeavor. Is there some kind of site that essentially makes the uninformed yell "Holy shit I didn't realize you could do that with Python"...like a showcase of some sort? Aimed at 'business' folks?
I really like the way this guy codes.
None with Django because it's pure python.
Good stuff, ill try it out. Have you checked out fabric? http://docs.fabfile.org/en/1.5/
Whats up with it being able to serialize datetime objects? There is no standard datetime encoding as part of json... 
That is pretty cool. If only my school network didn't suck so much, and I could actually SSH into my local boxes. 
Reddit and YouTube are Python heavy.
Try to make a game, in general game development include a lot of knowledge from different fields.
I would suggest making something that people will use. Solve a problem for your campus (what food trucks are nearby me right now?). Build a site for people you've never met, but with whom you share an interest. For me, getting people to use my stuff, and seeing them use it, was the most motivating factor.
How about [Project Euler](www.projecteuler.net)?
reminds me of flask-script
Leaking internal code is when code that is not relevant to the person calling the code (hereafter known as "the programmer") is still exposed to that person. In this case, the "opener", "remove\_html\_tags" and "load\_ul" methods are classes/methods that are used by the library itself, and shouldn't be called directly by the programmer. Instead, the programmer should call "load\_events", "load\_births" or "load\_deaths". *But* not before calling "load\_history", saving the result it returns and feeding that to the other "load\_" methods! See why this is a bad API? It's not clear at all, without reading the code, that you're supposed to call "load\_history" first, then call any of the other load\_ methods. (The OP has since cleaned up the code by prefixing the methods with underscores, which in Python is a hint to the caller that they're internal methods. For the rest of this post, I will pretend I'm reviewing the code without the underscores). The reason why you shouldn't expose (leak) code that the caller won't need is to keep the interface clean, simple and understandable. Consider the following rewrite I made (I didn't test it though): class ThisDayInHistory: def __init__(self, date): opener = urllib2.build_opener() opener.addheaders = [('User-agent', 'Mozilla/5.0')] formatted_date = date.strftime("%B_%d") html = opener.open('http://en.wikipedia.org/wiki/'+formatted_date).read() self.history = BSoup(html) def events(self): return self._parse_url(1) def births(self): return self._parse_url(2) def deaths(self): return self._parse_url(3) def _parse_ul(self, idx): p = re.compile(r'&lt;[^&lt;]*?/?&gt;') item_dict = {} for li in self.history.html.body.findAll('ul')[idx]: s = p.sub('', str(li)) # Remove HTML tags try: if int(s[0]) &gt; 0: line = s.split('\xe2\x80\x93') year = line[0].strip() event = line[1].strip() item_dict[year] = event except: # FIXME: Catch specific exceptions pass return item_dict There's only one way to initialize this code, and that's by calling the constructor of the class with a date. That will give you an instance of the class, on which you can only call three methods: "events", "births" and "deaths". (Technically you could call "\_parse\_ul", but the underscore says you shouldn't). See how I've reduced the number of methods exposed to the programming? And perhaps more important, the programmer can't call them in the wrong order anymore! In the original code, the programmer could accidentally first try to call "load\_events", which would fail because he has to call "load\_history" first (which due to the naming of the functions isn't clear at all). Neither does the programmer have to pass around the "soup" argument manually. I've placed it in a "private" class property instead. I also don't expose the "opener", but only use it in the local scope of the constructor. There's no reason for the programming who's gonna use this code to see it. This is called [Encapsulation, or Information Hiding](http://en.wikipedia.org/wiki/Encapsulation_\(object-oriented_programming\)) and it's one of the most important methods of creating better code. Hope that clarifies a bit what I meant with "leaking code". A while ago a wrote a bit more abstractly the same concept [here](http://www.electricmonk.nl/log/2012/11/14/input-state-and-their-relationship-to-bugs/), but it wasn't well received. Perhaps it was too abstract or inane :)
I wrote a small module for this a few years ago. [taskqueue](https://github.com/medecau/taskqueue) I just added an examples folder, take a look. 
If your bottleneck is I/O then threading may be an advantage as in you can parallel multiple requests.
I'd say businesses have a much *more* fickle dependency on cpython: while they often go through the C API, it's indirectly through packages which do so. If the packages (eg lxml, pil, …) support pypy they're done. As far as I know, businesses directly use the C api (or ffis) much less than the scientific communities. 
Oh, wow. That's awesome. Reading its README I kept thinking: "yeah, that's great and all, but I would really want it to be able to do--" and then in the next section it turns out that clize already does that and more.
Sometimes factoring this way is nice, agreed, but the charge is not really true in the context of Pyramid's configuration given that you can use existing directives like "add_view_predicate" to build other directives ala http://docs.pylonsproject.org/projects/pyramid_cookbook/en/latest/configuration/whirlwind_tour.html#custom-configuration-directives .
What happens if "name" is desired as an option?
Damn. See, I believe these regular expressions are correct. I tried yours, in raw string form: `r'"([^\\"\n]+|\\.)*"'`. The same thing happened that happens whenever I try getting "s in the regex. The quit command no longer functions, the log command no longer functions, and if I sneak debug-prints into the type parsing functions they are never run. But the lexer and parser build without complaint. But if I use, for instance, `r'[a-zA-Z_0-9]'` I can match single words_01 or with `r'[a-zA-Z0-9_"]'` can match "quoted_words". But as soon as I move the " out either by itself, or as ["], it fails. I tried other delimiters, such as `r'[z][a-y][z]'` and no luck either.
Did you see the local command? You don't have to ash to use them. 
Another implementation https://github.com/muromec/consoleargs
Keep using the system interpreter and add support for Gentoo ebuilds.
Since you have Java experience you might want to give Jython a try. It is Java implementation for Python and your Python code can use JDK.
Well, my father recently retired from the NIH. He still receives military healthcare benefits, and upon retiring he was promoted a rank (to Captain). I don't know what to point to online, but I assure you: certain NIH physicians receive a Navy rank.
Perhaps start with http://python.org/about/success/ ?
Your regex is matching for me, though it won't catch a backslash quoted double quote inside the string -- though my test was outside of PLY. I do wonder if curses is doing something... have you logged the strings to a file before lexing? The section "4.18 Conditional lexing and start conditions" in the PLY documentation describes how to use "states" to manage different lexing strategies. The example uses { and } as the start and end markers, but the idea is similar. Basically, you can go into a string-parsing state when you see a double quote, then leave the string-parsing state when you see another double quote. In this case, you could also add logic to stay in the string mode when you come across a \", or throw an error if you reach a new line or EOF while inside of a string. Here is a quick and ugly example, modified from the PLY docs: import ply.lex as lex states = ( ('string', 'exclusive'), ) tokens = ["STRING", "LOG"] t_ignore = ' \t' def t_error(t): print "illegal character '%s'" % t.value[0] t.lexer.skip(1) def t_log(t): r'log' t.type = "LOG" return t def t_string(t): r'"' t.lexer.code_start = t.lexer.lexpos t.lexer.begin('string') def t_string_slashequote(t): r'\\"' # do nothing def t_string_quote(t): r'"' t.value = t.lexer.lexdata[t.lexer.code_start:t.lexer.lexpos] t.type = "STRING" t.lexer.lineno += t.value.count('\n') t.lexer.begin('INITIAL') return t def t_string_any(t): r'[^\n]' pass def t_string_error(t): print "illegal character '%s'" % t.value[0] t.lexer.skip(1) t_string_ignore=' \t' lexer = lex.lex() def run_lexer(data): lexer.input(data) for tok in lexer: print tok if __name__ == "__main__": def f(s): print "\nlexing &lt;%s&gt;" % s try: run_lexer(s) except: print "failed!" # ok f('log "this is a test"') f('log "this is a test" ') f('log "this is a \\"test" ') # should fail f('log "this is a \n test"') # only parses log, doesn't fail on eof like it should :/ f('log "this is a testz ') 
This. To my mind there is nothing more motivating to write code than knowing that it will be used by others! Also: Get a buddy and work together. It will not only prepare you for almost every other project you do, but also will make you wirte good, readable code. At least knowing someone else will read my code has this effect on me...
Now let's say in theory I would be on the other side of things and decide I am only going to support Python 2. Great, we just split the community.
I know it's crazy but here I am wondering that I'm not alone in miswriting pythong.
Sounds like some basic unit-tests might be in order, like just a sample set of commands and maybe just the initial phase "Does this string match this expected command" and etc. It will cut down on the whack-a-mole stage of development
Excellent post! thank you.
It's a very exciting set of modules.
For lexing specifically I usually start with tests, lots of opportunities for one piece of grammar to decide it matches everything ( or nothing ).
Depending on the size of your company, these are actually few and far between.
If it's just a handful of functions, perhaps. But numpy is just the base of a huge ecosystem of packages, many of which are built using the C API, often via an abstraction layer like Cython. From general things like matplotlib and pandas, to more specialist things like scikits-image and PyMC. Many people are using far more than they're interested in rewriting. Neither is this community standing still - there are new tools like Numba and Blaze appearing that will make it faster and more powerful. PyPy's best chance of making headway here, IMHO, is to work closely with Cython, which a substantial fraction of these projects already use. Some work was done on this, but the last I heard was that it was not very promising.
Why not just run a proxy like polipo?
Where are cookies stored?
I've got a crazy idea: how about you take a hint and just do the work they're paying you for.
I've got a crazy idea - why not judge people on their productivity and happiness instead of putting them in cages?
proxies are blocked.
thanks for the suggestion. I will definitely do that!
This is very true, for companies which primarily write in python. I agree that these companies would not be very dependent on the C APIs, because they would have more use for the benefits of newer versions of python or pypy, and the python engineering expertise to make a clean transition. However, many companies are coming from completely the opposite direction. In two different industry projects, I have added python as a scripting language for advanced application configuration, in one case for a monolithic C++ application using the boost python bindings for python 3, and in another case for a large Java application through Jython. Many companies, especially large companies building software that is sold to businesses, do not use python as their primary application language but do interface with python in some ways. These companies have much more complex dependencies on various aspects of the python ecosystem. Another example is CCP, the creators of EVE Online. Much of the game engine is written in python, with the core rendering and physics engine written in C or C++ (the source was leaked a few years ago, I forget which they were using). I think you are right that most businesses that program primarily in python would be less likely to create explicit dependencies on cpython (with some specific counterexamples like CCP that have specialized needs), but that ignores an entire class of industry applications which are coming from the other direction, and adding python to applications written primarily in other languages.
"pythong"? Probably from the habit of typing the suffix "-ing"?
There's always SOCKS-5 ssh over port 80, only downside is that you need access to a server you control. 
I think this is a very good point. Specific parts of the scientific community are very dependent on a wide variety of CPython-dependent packages. However, there are two factors that mitigate these dependencies: - The python community is extremely willing to write new libraries, often to a fault. Once numpypy is complete, there will be plenty of fertile ground for writing libraries that accomplish all of these tasks with no dependency on cpython. - The effective lifetime of academics is 6-8 years, in which they would actively be writing significant code (after this, you're probably either in industry or have your own grad students writing code for you). New students tend to be very willing to reinvent wheels or try out shiny new technologies. It is likely that numerical computing specifically will be the slowest to change if change does happen. From my own experience in academia, which included some need for relatively high-performance computation, people are willing to use or build whatever tools they need to get the job done, and pypy is a very attractive option even with relatively few options for scientific packages.
True enough. :-)
I will have fun dueling with him :D
I meant all the well known proxies are. Usually websites seem to have some kind of "tags"...the proxy at my workplace blocks according to those.
Unless your app, a SSH tunnel won't break pretty much any website. Also, look at something like cgiproxy or Glype and you'll see that there's a LOT of effort behind a functional online proxy.
Apparently not at all.
Rent a virtual server ($5 per month) and use ssh tunneling to it. Setup a dynamic port forward (aka SOCKS 5 proxy) and you can run anything you want through it. 
Violation of company property use agreement? 
"Been browsing reddit and what not ALL DAY at my work today!" seems to be putting an upper bound 0 to productivity :(
Ok seems like SSH is definitely a better option. I guess I will give it a shot after all! Can't stop loving python though!
Awesome!! Thank you for the link :)
No, because if I want to use your Python 2 only package with Python 3 I'll evaluate how much effort it is to do the port to Python 3 and then do it, if that's cheaper than building a new Python 3 only solution from scratch (which is usually is). To show that I put my money where my mouth is, I recently I submitted a [pull request](https://github.com/tkrajina/gpxpy/pull/4) to the GPXPY project for Python 3 support. It was duly accepted and I'm [credited for my work](https://github.com/tkrajina/gpxpy/blob/master/NOTICE.txt). So theory is one thing, but practice, and contributing, quite another.
This is exactly my setup, and it works wonders. I even tunnel Pidgin through it for FBchat/GoogleTalk
[`distlib`](https://bitbucket.org/vinay.sajip/distlib/src/dedee37736624076ab1f31cfbfdfddae94951293/distlib/version.py) also contains a semantic version implementation, along with support for PEP 386 and legacy (`setuptools`/`distribute`-compatible) version numbering.
cookies and urls need to be re-written. you could do that in middleware, but I think you'll find it's not worth the effort and you should just get back to work. 
That's nice if the port to Python 3 does not require API changes. I am in the boat where I have to break my user's code on Python 3 when I want to do a Python 2 port. On top of that can't I use Python 3 for work and I probably will never be able to so when I will do a Python 3 port for a library I end up in the situation where I will probably not be able to use it any time soon. The world is not that simple where you can just say "hey, let's all do Python 3".
OpenVPN is your friend. Run it on 443 on your server, done and done. 
This is called a proxy, and a more robust implementation can be found here in python too http://code.google.com/p/mirrorrr :)
I've always wondered about how to set up SSH on a home computer. My IP isn't fixed because, you know, it's cheap. Is there a way to set up SSH on a system like that?
All it takes is one ssh command
I'd like to emphasize the second point above. Working with others is crucial. So many things you're taught seem useless until you realize it's keeping your code neat for other people.
Pfft. I was Bayesian when those frequentists [were still bragging with their approach](http://yann.lecun.com/ex/images/allyourbayes.jpg).
&gt;and look like a regular ssh session. Not to be used at places where you don't use SSH on a daily basis. Also, encrypted but still bandwidth heavy. You WILL show a lot more bandwidth than a normal SSH session and they will certainly know something is up.
I guess I'm fortunate to be able to use almost exclusively Python 3 for personal stuff and work.
Do you work at my company? Security risk blocked for your protection Reason: This Websense category is filtered: Proxy Avoidance. Sites in this category may pose a security threat to network resources or private information, and are blocked by your organization. URL: http://cheatwithportals.herokuapp.com/
Who works for himself.
Look at dyndns.org. They offer free and pay static host names for dynamic IPs. You'll also *likely* be configuring port forwarding on your modem/router to get port 22 -- or whatever port you choose for SSH traffic -- to the SSH server. It's actually quite easy to set up; probably 20 minutes for everything if you're familiar with your modem/router. 
What is it? 
FYI Chrome on osx has a habit of leaking dns requests, even when socks proxying :/ Firefox does not (on my machine at any rate). I'd recommend wiresharking to check
I just think you cannot be as efficient as an autocompletion. Because a completion of 10 characters is just faster than you typing it by your own hands. For me autocompletion is much more about comfort. Also jedi-vim adds some pydoc features. Hitting `K` is just much more comfortable than always switching to the terminal and retyping your stuff. Believe me, I did it.
The author also did a tutorial at PyCon this year: https://sites.google.com/site/simplebayes/ 
Learned a bunch of bayesian statistics this past semester. We mostly worked with a math heavy, painful textbook that everyone agreed was for statistics PhD students (or bust). However, we read through Think Bayes instead of a few chapters, and the math is really approachable (if not as extendable) and the concepts are well presented. If you're interested in picking up a little bit of statistics, this is great. If you understand statistics a bit, this is really easy to get through. If you've *never* done statistics before, this is a surprisingly approachable option. If you know stats really well already, this might give you an idea of how to use bayesian stats, but it might leave you wanting. And it's python! 
Man, I'm close thanks to your help. Here is my implementation and test output: import os, sys lib_path = os.path.abspath('..') sys.path.append(lib_path) import ply.lex as lex class kadvLexer: def __init__(self): self.lexer = lex.lex(module=self) states = ( ('string', 'exclusive'), ) tokens = [ 'LOG', 'STRING', 'QUIT', ] # Tokens def t_quit(self, t): r'quit' t.type = 'QUIT' return t def t_log(self, t): r'log' t.type = 'LOG' return t def t_string(self, t): r'"' t.lexer.code_start = t.lexer.lexpos t.lexer.begin('string') def t_string_slashquote(self, t): r'\"' pass def t_string_quote(self, t): r'"' t.value = t.lexer.lexerdata[t.lexer.code_start:t.lexer.lexpos] t.type = "STRING" t.lexer.lineno += t.value.count('\n') t.lexer.begin('INITIAL') print("string") return t def t_string_any(self, t): r'[^\n]' pass def t_string_error(self, t): print("(string) Illegal character " + t.value[0]) t.lexer.skip(1) t_string_ignore = " \t" t_ignore = " \t" def t_error(self,t): print("(initial) Illegal character " + t.value[0]) t.lexer.skip(1) def run_lexer(self, data): lexer = self.lexer try: lexer.input(data) for tok in lexer: print(tok) except: print("failed!") if __name__ == "__main__": fal = kadvLexer() while True: fal.run_lexer( input("kadv: ") ) # ok f('log "this is a test"') f('log "this is a test" ') f('log "this is a \\"test" ') # should fail f('log "this is a \n test"') # only parses log, doesn't fail on eof like it should :/ f('log "this is a testz ') Thanks for the hints. A coworker mentioned something about state switching but I haven't looked at his language's yacc files. I was close to abandoning this after three days of no progress! Edit: Even closer, update my code. Here is a sample session: kadv: log quit LexToken(LOG,'log',1,0) LexToken(QUIT,'quit',1,4) kadv: "You tore the bodice from the elven maiden!" No end of the string input :( 
&gt; Been browsing reddit and what not ALL DAY at my work today! revenge eh ?
Though your solution is clever, I think it's more practical to just use the functionality built into sshd Edit the /etc/ssh/sshd_config file and add the following: Port 443 Port 555 #That's right, open-ssh supports listening on multiple ports write, quit then, sudo service sshd restart Good to go!
haha "!work"
Project Euler is a series of mathematical problems, not programming problems. Problems that actually emphasize programming skills are much more useful. I would personally suggest looking at the ACM programming competitions and similar if you really want a directory of programming based challenges. They're a little bit data-structures heavy usually but are much more useful to a programmer than project euler.
I'm not sure it is finished; at least the PDF I downloaded. Ch 11 ends with a sub-heading for the "Unknown Species Problem" with no following content, and that's followed by "Future Chapters". But what's there seems pretty good and informative... some nice "light reading" for the holiday break!
Could be anyone who saw this thread.
how is it not advertised as stable actually?
There's still time to let the author know. He credits people in the book that have helped.
To be fair, the Hoeffding Inequality and its variations are fairly important :)
Arhh now I know, yeah I would like to join your google group
Oooh, that is a nice dandy script! Thanks. :) i should have googled more!
you shouldn’t. but you should use the existing solution if there is one.
Seconded, especially since amazon give you like, 12 months free iirc. 
if the link had been to here: http://www.greenteapress.com/thinkbayes/ instead of directly to the download, you would have seen the following: Think Bayes is an introduction to Bayesian statistics using computational methods. This version of the book is a rough draft. I am making this draft available for comments, but it comes with the warning that it is probably full of errors. If you find some of those errors, please let me know. But it is probably too early to bother with typos. 
Seems interesting, can you share with us the details?
That's encouraging to hear.
The sale is only for today (21 hours 29mins as of now). I was hoping one or more of you would comment on whether PyCharm is worth $25 (USD) for a Personal license. Am searching Google for reviews at the moment.
Depends what you plan to use it for. If you are going to write 4-line scripts, then no. Otherwise yes. Take the trial!
Hmm... you could use the regex negative lookahead to only match characters in the string state that are not followed by the EOF. ( I modified t_string_any and t_string ... other rules might need to be changed too) def t_string(t): r'"(?!\Z)' # more stuff... def t_string_any(t): r'"[^\n](?!\Z)' # rest of code... Also, I am not sure what the proper way to keep using the same lexer is. In my test cases, the previous lexing state sometimes breaks the next test. The docs probably have it, but I didn't look.
Awesome. I already have a commercial licence of PyCharm, but I'm curious about WebStorm; worth a shot for $12. That being said, good luck to everyone. Their servers are hosed; I'm getting a 404 trying to add something to my cart. Ouch.
Looks like your book is teaching you Python 3, but you're running Python 2.7. if you change the line to print "Hi, ", name it should work fine. In Python before version 3, `print` was a "statement" and in later versions it's a function. Functions need the parens to wrap their parameters. In Python 2.7, which you're using, the parens (and the comma separator) are actually creating a tuple and its that tuple that's being printed out.
You're doing print("Hey", name) , and Python recognises it as a tuple, not a function call, i.e.: print ("Hey", name) Or, using Python 3's print() function, print(("Hey", name)) This adds the parentheses to the output, because it's outputting a tuple, not a string. However, you can just concatenate the two strings to get what you want, like this. print "Hey " + name No parentheses required. However, I'd rewrite it to be forwards compatible, like this: from __future__ import print_function # ...snip... print ("Hey " + name) This will import the new print behavior from Python 3 into Python 2, and that makes print() a function not unlike any other. This way, your code will stay compatible when you switch it to Python 3. Edit: also, the book you're using is not too good. It'll get you started on the basic concepts, but there are some books that manage to explain things in a cleaner way, with way less forward references (IMHO). I'd suggest Learning Python by M.Lutz, it's great. Also, [Learn Python The Hard Way](http://learnpythonthehardway.org/book/) is one of the best books you can get for free.
:-) See you [there](https://groups.google.com/forum/?fromgroups=#!forum/web2py)
There are two things going on here: * In Python, print is not called the same way as a function call * You create a tuple by using the "," operator and are are printed with the parentheses around them name = "Richard" print("Hello", name) prints a tuple with element 0 = "Hello" and element 1 = "Richard" To see if this is true, type: name = "Richard" mytup = ("Hello", name) print type(mytup) What you really want is string concatenation. Simple do: name = "Richard" print "Hello " + name
It definitely is. I have been debating buying it for the past week and finally decided to buy it last night. If I'd waited twelve more hours I could have save $75. Still worth it.
LiveEdit (the preview stuff) is a plugin that you need to install. Sorry about the problems with the e-shop - our team is hard at work fixing it right now.
Well, PyCharm costs half as much.
I love to use Komodo edit for Python, between Komodo edit and Pycharm, which one it's the best for you guys? Thanks!
still more expensive than emacs. :) and slower too
If you're not using java, then get pycharm. Its cheaper.
The only problem with your solution is that you're then using emacs. ;) I kid, I kid. I've been meaning to purchase PyCharm for a while as I've heard good things about it, it looks like today ~~will be~~ is the day! EDIT: Thanks for getting the checkout process working, just purchased PyCharm! :)
Definitely. The only real downside is the price. $100 is kind of steep if you're just using it for your own projects. There's a free 30-day trial if you want to test it out for a few hours, but I don't think you'd regret it if you went ahead and dropped the $25 for it. Their ordering page is currently over loaded, though. I was going to buy a license, too. :(
There is no downside at all to learning Python 3 instead of 2. Your goal is to learn Python, and in the end the differences between the two major versions will be easy enough for you to switch back and forth between without much effort.
Can anyone comment on how well it integrates with IPython? For example, can you drop into an IPython shell while debugging and explore variables and the stack? How well does it handle the scientific packages such as Numpy and Matplotlib?
Anyone got any thoughts on PyCharm vs Sublime Text 2?
The main scientific/math/machine learning libraries require 2.7. If you're not going to be doing that kind of work then 3 should be fine.
Probably PyCharm. I think a fairer question would be between regular Komodo and PyCharm which is better. I've used both a little bit and I'm not really sure. Probably PyCharm but it would be quite close. Why don't you download the PyCharm trial and give it a go? Best way to know is just trying it out.
I use Sublime Text 2 (own a license) for general stuff in various languages including Python. Earlier this year JetBrains had a 50% off or so on PyCharm so I picked it up and it's quite good for larger projects but for smaller stuff I stick to ST2. With this JetBrains sale, though, I'll probably pick up RubyMine and WebStorm just because of how cheap they are--$29 combined! I've been getting a start with JavaScript and I've just started with Ruby, so hopefully a small investment will help ensure I keep it going.
I use butterflies. 
You caught me spreading nonsense on the internet. In my defense, I was not the first.
Why not renew now? Sure, you will lose 2 months, but you'll only pay $15. 
I use PyCharm. When I tried IntelliJ before with the Python plugin, the biggest difference I saw was that starting a new product, or "importing" an existing (non IntelliJ) project was much more complicated (more dialogs). In PyCharm, you just open a directory. The other (and I could be wrong/outdated on this) is I don't remember seeing a Django option. But at $50, I went ahead and ordered IntelliJ and PHPStorm. At $12, PHPStorm is a no-brainer (I will be starting a job soon that uses PHP/Drupal a good bit). So why did I order IntelliJ if I have PyCharm and PHPStorm? It's one app that supports Python, PHP, and Ruby. Once in a while, I find myself debugging Ruby apps. If I can work through the create a new project hurdles, then I can just worry about keeping one product installed. 
I've used ReportLab and Matplotlib (though no Numpy, yet) with PyCharm. Works like a charm. Haven't had any headaches yet (documentation is pretty good for both). Beware I've only been using these libraries on PyCharm for a good 2-3 weeks so there is still plenty of exploring to do.
This is incorrect. You will not lose any subscription time if you upgrade early. &gt;You can renew your upgrade subscription at the discounted upgrade subscription price during your upgrade subscription term or within 1 year upon its expiration. Regardless of the actual upgrade subscription renewal date, your new upgrade subscription term will always start on the date following your previous upgrade subscription expiration date. 
Just some thoughts: PyCharm: best for larger applications that are going to exceed more than 50-75 lines (this is what I've found the cut off for me to be, will be different for others). Plenty of development tools available. Sublime Text 2: I only use it for small quick scripting/ workarounds for other projects.
Well I went ahead and got it. for 24.75$ it is too hard to pass up. Well supposedly I did. Still haven't received an email about it. Anyone know how long that normally takes?
To add, I have used several different frameworks in a handful of languages. Although new to web2py I do find that I'm not thrasing about trying to jam code where ever. The layout makes sense, the web based IDE/Debugger work wonders, and the whole thing runs on pypy quite nicely. I am in the process of convicing coworkers we need to ditch Groovy/Grails for Python/web2py since it seems to fit our enviornment the best considering how many DBs it can connect to. Also it is by far one of the easiest python frameworks to deploy making it not a PITA for the SysAdmins to update my applications. 
PyCharm at $25 is a steal, and for that matter Intellij IDEA for $50 is as well. I was a Komodo user before I tried PyCharm for a bit. It's well worth the money even at full price.
From what I've heard, you'd do better just grabbing IDEA and downloading the plugin for Ruby and JS development.
How does the subscription part of this work? Is it for upgrades or does it expire and prevent me from using the IDE unless I renew?
And.... they're down.
"PyCharm license is permanent and includes one year of free product upgrades since the purchase date, including even major version upgrades." Sounds like you have a permanent usuable version and updates for a year if you buy a license. If you have a license but ran out of the year of updates, you need a subscription to get an updated version for another year.
And.. they're up. Sort of. But they were up long enough for me to order PyCharm, IntelliJ, WebStorm, and RubyMine for $112, after taxes. Woot! I suppose I'm a sucker in the end because they'll have the last laughs on the upgrade cycles, but I'm OK with that. :)
Thanks for the info. Purchased a copy. 
there are two main reasons for this change - to allow us to finish first (so we can say "ok, we have all of it, now let's make it fast") and another one is invalidation, which turned out to be a nightmare. Notably: a = (b + c) * 2 when you modify b (say assign an item), **both** b + c and (b + c) * 2 have to be computed if you don't have refcounting. We either need an explicit API for that or we need to think (I even have an idea, but let's see)
Hmm, that's interesting. I hadn't thought of that. Not having done a lot of networked python I'm not 100% sure how to achieve that.
Is Paypal not working? I ordered pycharm a few hours ago and got confirmation from element5 but no confirmation from paypal and no key. 
element5 processed my order, but i see no charge in my card and didnt got any emails. Did my order push thru? do i need to purchase again? i dont want to risk a double charge
Because PyDev and Eclipse are very resource intensive and the Eclipse editor is mediocre at best.
I use pycharm every single day, wouldn't trade it for another tool out there atm
It's definitely worth the $25 or for that matter, a lot more, if you prefer an IDE-style environment. It's one of those IDEs that does *everything* -- vcs integration, copying files to your server, remote interpreters over ssh, UML diagrams, etc. If you're more of the type to just get a text editor and a grep function, PyCharm is probably not what you want. My attitude is, I program Python for a living and I use PyCharm for 6 or 7 hours every day, so it's worth a lot more than $100 to be honest.
It's hung up...I think the website might be coming down.
Same here. I'll give it a few more hours before being worried.
No idea, but their sales people are assholes. Otherwise I am pretty familiar with ActiveState's core developers and while they are extremely competent, the reality is that they're probably tackling Python 3.0 alongside the stackato side project which has probably thinned out their available manning. edit: http://bugs.activestate.com/show_bug.cgi?id=91836#c12 Yeah looks like Stackato is the culprit.
You're going to love it. PyCharm is the only way I write Python anymore.
Still can't buy http://genophoria.files.wordpress.com/2012/11/shut-up-and-take-my-money.jpg
I've been looking into this as well, as I'm deciding whether I just want to buy PyCharm and RubyMine separately or just get IntelliJ IDEA. The plugin appears to contain all or most of the features that PyCharm has. Some things have a few more steps to get them done in IntelliJ, but that seems to be just because of the organization of the UI as it's not a python IDE first. That's where the benefit of just PyCharm comes in. Since you already have IntelliJ it probably isn't worth it.
Well you kind of did. I've read in some of the other threads around reddit (webdev, programming) that WebStorm is actually included in the other packages (PyCharm included). And for the price of PhpStorm and PyCharm, you could have just gotten IntelliJ IDEA and used the plugins which contain all of the features of the individual applications.
I'm having the same problem, also happening with IntelliJ. 
The python intellij plugin gives the same stuff that comes with pycharm, so its not worth if you already have intellij.
Checkout is back up now. Just bought mine. 
OS X only.
Pretty sure this has been done before.
No, please don't purchase again. Your credit card will be charged and your license will be sent in a few hours.
RubyMine includes all the functionality of WebStorm - you don't need to buy both.
Sorry for the delay. You'll receive your license in a few hours, as soon as the order is processed.
Don't miss the IdeaVIM plugin for PyCharm. It's not exactly vim but it's the next best thing. :)
PyCharm's handling of virtualenv and pip is no different from what you would do in the command line: we simply run the regular pip tool for you. I don't think there's any other IDE that does anything better than that.
so pycharm is something you eat? 
Well, their website should have made that more clear.. Oh well. If that's the case, then after their sale shitstorm clears up, I'll contact them. 
Yeah, it will be sad if they stop creating AP. I suspect you are right though.
Thanks for the tip!
Er what? You only needed IDEA for $50. All the others are plugins to that.
Didn't have to deal with any plugins or issues when it came to connecting the two. Walks you right through, and you can set it to commit on a set interval I believe. Nothing too substantial though.
I haven't received mine yet either and I bought it at least 6 hours ago. I'm getting a little worried...
FYI - My order appears to have been trashed. My credit card isn't showing a charge, temporary or otherwise, the element5 site won't acknowledge the order # I was given hours ago is valid, and there isn't a receipt anywhere in my email. Should I go ahead and reorder and hope I'm right? I will be on for a bit if you're open to looking into it.
&gt; Works like a charm. icwutudidthar
Disclosure: I work for No Starch Press.
I think in an hour or so if I haven't heard back from these guys and still haven't seen the charge go through, then I'll just make the order again. There is no way I'm missing out on this deal because of a system gaffe and I suspect they'll work with me to reverse a charge if I should actually get charged twice. 
Thank you! The real trick is caching as much as possible. Apart for that I suggest keep sessions small so if needed you ask web2py to store them in cookies. Accessing the filesystem is a major bottleneck. 
Ordered PyCharm. Ooh, I hope the world does not end now! 
Does IDEA with Python plugin support Django? Django templates?
Awesome deal.
I think a reorder was the way to go. Not only is the order experience smoothed out now, but I got my emails right away, so I should be set. Hopefully I won't get a dupe charge, but the first order # still isn't being acknowledged by element5, so it would appear to be void. 
Same here :(
Thank you 
As a student who hangs around here to learn about python, I have to ask: what kind of companies employ full time python devs?
FYI, the name conflicts with windows' built-in CLIP.EXE
I didn't see this until I ordered again and DID get a confirmation. Didn't want to miss out on the deal... I guess I'll be talking to cust service soon :)
Just about any company that deploys Python. It's very widespread in web work. I've never had trouble finding work in my ~14 years of experience using it professionally.
Just dropped over $100 on the site after I saw this. Bought Pycharm, resharper, intellJ (I code C# and java occasionally at work). This is a good deal. 
A lot of companies use python. Not just for webapps, but as a glue language for all kinds of server side processes. My company uses python for a lot of batch/nightly/admin tools. Also, big companies like Google have a lot of python influence in their products. Mostly as a glue between development and administrative tools. Also, Google App Engine uses python. 
I did the same thing. So just sent them a note via their online contact form. Hopefully they can cancel my webstorm order. 
I did the order and got a confirmation number roughly 11 hours ago - I still haven't gotten an email - you have any advice. I know others are talking about reordering and worrying about fixing it if it double charges later but I'd rather not do that if I can help it.
I saw this on boing boing a few days ago, it looks great.
numpy people (including continuum guys) are very much against what are we doing with PyPy. I seriously doubt (although I don't know) if there are any plans to integrate that with the PyPy ecosystem.
Me neither, I sent them an email to make sure my order went through. I'll see what they say.
I ordered yesterday (Europe) and still haven't received anything.. Are they still processing all the orders they got ? Should I be worried ?
Use vim or emacs, already.
Make account at dyndns, add host. Then sudo apt-get install ddclient It updates the host for you.
After reading this I downloaded the demo and tried it out. It absolutely blows away anything I've used up to this point (mostly Komodo Edit and Pyscripter). Huge bonus points for cross platform too. Has anybody gotten the license key yet? I'm going on about 20 hours and I've seen a lot of people posting that they haven't gotten it yet, but nobody saying they have. EDIT: I did notice that it performs absolutely zero syntax highlighting on PHP files. Is there a way to enable basic highlighting? I don't use PHP much, but it would be nice to not have to load a separate program just to make a quick edit.
You are being silly right now. Obviously loaded questions and obviously false dichotomies are silly.
Did you hear anything from them by now? I ordered like 14 hours ago an didn't even get a confirmation email. I got a Ref# after the transaction though.
Still nothing. And as I was in a rush I did not note my Ref#. Surely, some proof of it exists somewhere (at least at Element5).
Several reasons, mainly because it comes with several tools for windows like pywin32. I have been using it for many years and I have it installed in several PCs and never had installation or working problems. In any case it seems the time for changing arrived.
Got an email from Element5 to confirm the order !
Feel free to, you know, give us a hint about what the job entails or some details on what this company does.
Yes.
I'm interested. I've been trying to get a job in the Boston area for a few months now. I don't have 5 years experience, but I have tons of personal project experience. Whats the name of your company?
[Globex Corporation](http://globexcorp.files.wordpress.com/2007/04/scorpio_with_bont.jpg)
added
Full time, permanent. I am the team lead, working *with* HR on this.
It's certainly not the fastest IDE I've used in my years of programming. But for Python work it's certainly the best I've found. Can't compare it to Eclipse however - only used Eclipse for other languages, and at the time I found Eclipse too slow!
Gee, thanks for telling me there's something interesting at the end of a 45 minute video, but not spending 38 seconds to tell me what it is. 
PyCharm and PhpStorm are both absolutely awesome! We use them both at work with a commercial license. The only issue we have with PyCharm is this: http://youtrack.jetbrains.com/issueMobile/PY-5131 And it is annoying as hell :-/ Apparently it is not fixable or at least not important, but it completely destroys its usability with PyQt. Still awesome for our console and Django applications though. 
I finished this book yesterday. Although I am no kid, I enjoyed it a lot:) I recommend it to all beginners like me. 
6 years old? Isn't that too young? If not, congrats for having such daughter
Pretty interesting concept.
well, nobody gives a shit about your stand on ide's.
Huh...I see what you did there.
Thanks
And now the long wait of the arduous installation process. I hope it is really worth it! (Doesn't support Open JDK! Grr!)
That's really neat. I've really been wanting to get into stuff like this, and till now, have never heard of this pyMCU. I'm going to have to check it out! 
It's a little Python script that connects to skype via Skype4Py api, and then pumps any messages in the chat window over to cleverbot.com; then pipes cleverbot's responses back to the chat window. It's kind of funny if the first time you spring it on friends, so I thought I'd share. **EDIT** ----------------------------- I've added an executable version for any windows users that want to play around with it without downloading all the needed packages. Pyinstaller outputs a *TON* of files... but just double click on the 'ol `Clever Skype.exe` to launch the program. 
First of all, I'd like to say that this is very cool. I wish I had this back when I used Skype. ;) While I was browsing through the technologies you used (thank you for listing them), I noticed that Skype4Py has moved their project from Sourceforge to Github[[1](https://github.com/awahlig/skype4py)], so you might want to reflect that in your README. The UI is simple but looks really good. I've heard the name "wxwidgets" passed around so many times; I've never actually looked at the project. I think I'll be using the python binding soon! [1] - https://github.com/awahlig/skype4py
Hmm.. Are all the downvotes on this because of the initial lack of details... or are people trying to hide it from 'the competition?' Hmm... 
You should call it "AFK"
There's nothing to install.. ~~per say~~ per se -- not as you would a traditional program, anyway. You run this one from a command prompt. The things you *would* need to install are the additional python packages if you don't have them. I have links to them in the readme. Once you've done that, all you need to do is run the python script from a command prompt via `python clever_skype_gui.py` However, I realize that this is kind of a lot of work just for a silly toy, so I'll upload an executable version in a second. That ways there's no dependencies to worry about ;) **EDIT** I've added an executable version if you wanted to play with it. 
Anyone running something like web sense is probably running MITM for DLP so all these ssh tunnel recommendations are stupid.
Microsoft backend to visual studio, almost everything windows and python related have a vsc call in their build scripts. I could be wrong but unlikely as compiling with Mingw is a lot more difficult ( run into a few parts of distribute that call non-existent mingw gcc flags that were deprecated and throw up errors if called ).
A reddit post can either be a self post or a link post, but not both. 
Of course. Someone says "If you care about coding in Python even a little bit, it is worth every cent of the $25 cost" and that's ok. Someone else says that it isn't worth the cost, but that's nonsense. \*shrug\*
Agreed. But I remember pasting the link while submitting this entry. That's what I find weird. It maybe a bug though. I'll try submitting something and see if it happens again.
well til that in python: `x` == x.__repr__()
Try [no-ip](http://www.no-ip.com/personal/). They have a little app that runs on your home PC to detect IP changes and update your URL. It's a pretty nifty service.
Looks like a python module to me
Right. I did exactly this. I'll remember this next time. Thanks.
&gt; per say Ze correct spelling of ze phrase is ["per se"](http://en.wiktionary.org/wiki/per_se). Ich wünsche Ihnen einen schönen Tag!
My guess is that the surprise at the end is that he debugged the debugger with itself.
Still not a git module
if you want, add me and your cleverbot can talk to my cleverbot.
arg. I give up. 
I actually tried that very thing. I set one instance up on my laptop and another on my desktop. After a brief discussion of Unicorns, [they transitioned into speaking in different languages](http://i.imgur.com/bF5hP.png?1). It also got a bit existential at one point. One cleverbot was telling the other that it was God. It was kind of interesting. 
I just made a simple script that chats with a pandorabot a few days ago. You can find it [here](https://gist.github.com/4330179). If you want to replace cleverbot or if you want to mix in new answers, you can check it out.
In your github README, you have some code in the background in one the figures that says: info.SetWebSite('http://www.gitnub.com')
That's cool toy. Would love to see a large scale, such as solar systems being affected by galatic cores, or other complicated things like binary star systems.
This is pretty cool, but you could be more realistic about how the planets form. There is a reason why all of the planets in our solar system move in the same direction, their orbits don't cross, and they all lie in the same plane: https://en.wikipedia.org/wiki/Protoplanetary_disk
What's a good reference for the differential equations that govern the planets' motions?
If you want to be more accurate, check out [PyEphem](http://rhodesmill.org/pyephem/) for all your basic astronomical calculation needs.
Picture of it working: http://i.imgur.com/VPaiH.png
Well the cool thing is their upgrades aren't that expensive and they do sales pretty frequently so if you keep an eye out you may not need to pay full price for your next upgrade. I only had to pay 15 this time around :) 
Site was unreachable when I clicked. Here is a [Google cache](http://webcache.googleusercontent.com/search?q=cache:Qs24Mlla7w0J:users.softlab.ntua.gr/~ttsiod/gravityRK4.html), a [github mirror](http://ttsiodras.github.com/gravity.html) and here is a [video of it in action](http://youtu.be/a6oAkSVHg7Y).
Hey, it's free, that's kinda cool I guess. There's also the-cloak.com, basically does the same thing. You could step it up a notch though by doing the VPS + proxy software over an SSH tunnel, that's definitely a kick-ass combo. Useful for traveling also, that way you've got some defense against bad guys sniffing your wifi traffic in airports or whatever. FWIW, I'm running a Linode/Ubuntu server with OpenVPN &amp; Squid. Very awesome.
This was completely removed in Python 3 and up, by the way, so it's recommended not to use it. `print repr(var)` still works.
Sublime Text? Nice choice!
I modified it slightly to give flakes different speeds, then checked the other forks and found someone had done something similar already! And I also forgot to account for Windows. Never mind. https://gist.github.com/4369275/67f5fe48a19450139b947131dd21aa5f2b4f6896
Mmmm....that is a hard one. If by "small" you mean small scripts that aren't organized into formal projects probably not. 
Apache + mod_wsgi? I don't know, I'm just getting started with web development using python but this setup has worked well for me.
I was looking into that one. But I'm hoping someone has experience with an Nginx build while using Python. My current desire is something like: Nginx Mod_FastCGI or Mod_fcgid. I'm familiar with fcgid but I cant find any updates to it after 2009. I don't like old software. I'm also curious as the best distro to build it on.
apache + mod_wsgi or nginx + uwsgi... both are working great for me.
For development i recommend gunicorn and nginx to serve static files. I actually use the development server of Django and Flask to serve both static and dynamic content. In production i recommend uwsgi + nginx. Have a look [here](http://bartek.im/blog/2012/07/08/simplicity-nginx-uwsgi-deployment.html)
UWSGI is a fantastic alternative already built into Nginx.
I use Linux, Nginx, uwsgi, virtualenv, and supervisord. Some frameworks have their own server so I skip uwsgi and have nginx proxy to the frameworks server. Supervisor starts and monitors nginx and the python applications (uwsgi or the applications server). You need to turn off NginX daemon mode so that it runs in the foreground to use it with supervisor. I have a separate Python virtualenv for each application. The paths in the supervisor config are specific to the virtualenv when running the application. I don't have much experience with uwsgi, so i just used whatever parameters i found online. Also I use the Paste server with the Pyramid framework and I use a composite handler so that multiple Pyramid applications can run in the same Python process. This allows them to share database connections and use less resources (as opposed to running a new Python process for each application). This is one of the cases where NginX proxies directly to Paste instead of using uwsgi).
I use nginx with uwsgi and web.py. It's a decent amount of effort to set up but worth it.
An interesting functionality to add would be the ability to display movie showtimes near the current location, but I can't seem to find a decent API and I'd rather not screen-scrape from Google. Any suggestions? 
Pretty sure tornado doesn't need root privs unless you need access to special files or services. Could be wrong. It's been a while since I've done a clean install. What I like about tornado is how easy it makes a few otherwise onerous tasks, like handling user authentication or simple template processing and passing parameters to it. But if your needs are modest, pretty much any wsgi-based framework will do. It depends on how much you like using built-in services vs bolting together, say werkzeug, jinja2, and sqlalchemy.
Awesome. I'll take a closer look to tornado. I'm currently reading Core Python Programming. It's a pretty great book so far. The only thing right now is that I'm not sure if I want to use a built framework at this time. I may just take the road of writing everything myself to start with. I like learning and understanding through trial and error. I feel like if I went straight into a well built framework, it would become a crutch.
Package that :P
I'm running a similar stack in production (gunicorn instead of uwsgi, apparently I'm behind the times). I also don't run nginx in supevisord, I find that nginx is more reliable than supervisord itself so that seems like a strange one. I'd be interested to know what prompted that. It's not overkill though, you need supervisord or something similar to keep your app servers running and you need virtualenv to make deployment and installing an easy process. If it would be bad in any way for your site to go down and become unavailable this is the bare minimum. It is overkill for a toy project, but not for anything that matters.
Well it definitely needs root if you want to serve anything over port 80 or 443 (http and https)
I think rotten tomatoes has an API that will allow this: http://developer.rottentomatoes.com/ Edit: Maybe not after further review.. no showtimes and basically no localization. Seen several sources reference http://www.tmsdatadirect.com/ as being where everybody else gets their data from; but I'll presume that's a paid service.
1. #!/usr/bin/env python 2. You're using argparse incorrectly. Correct use will save you all the 'sys.argv[n]' stuff. 3. Read PEP8. 4. Great idea :-)
I agree with having NginX under supervisor is probably less reliable. I like it because I have an event handler that will email me if NginX (or any supervised process) goes down and it will email me if supervisor stops for any reason. 
It looks more like a command line interface to retrieve info from [omdbapi](http://www.omdbapi.com/) I wish I could search for actors.
[Here's my kinda noobish piece on Nginx + Gunicorn + Django](http://yellowsharkmt.com/2012/02/01/adventures-with-gunicorn-django-nginx-apache-and-upstart/). I'm no expert though, just have been playing around with it for a couple years. 
tbh $995 is a lot. 
Fedora 17 + GNOME 3
Ah, I see. Thanks.
Sounds insane. More expensive than a lot of colleges who provide the software for free.
A typical setup would be a web server serving, passing along requests to a wsgi-capable application. (which are somewhat analogous to application servers) mod_wsgi, uwsgi, gunicorn and flask can serve as a backend, while apache, nginx and tornado are the front-facing web servers. (And supervisord is just nice to throw on the server aswell to give CPR to the web servers incase of a failure.) The first answer [here](http://stackoverflow.com/questions/936197/what-is-the-difference-between-application-server-and-web-server) is a decent explanation of the exact differences between the two.
Wow, just wow. If you want an intro of games in python try one of the best e-courses (Free) I've seen so far: [An Introduction to Interactive Programming in Python](https://www.coursera.org/course/interactivepython) reviews (overwhelmingly positive): http://www.knollop.com/courses/301/An-Introduction-to-Interactive-Programming-in-Python/ http://www.topfreeclasses.com/course/6880/An-Introduction-to-Interactive-Programming-in-Python Before you pay anything. Make sure it's what you want. That page barely tells you anything about the competence of the instructors, the way and range in which materials are covered, etc. &gt; As game developers, we often see students attending overpriced and under-performing schools, learning outdated, inferior, or incorrect information about video game development. We think you deserve better. Electronic Gaming Education was founded by industry professionals in the hopes of training people who really want to be in the industry by people already in the industry, at a price that is reasonable. Our training is more focused, concise, and applicable to working today! Well, you guys need to show proof that you're worth it. Specially in the dawn of free e-learning from Coursera, Udacity, Edx, etc.
I would like to hear more detail on this setup if you have the time. I am reviewing my stack at current and these set of tools is what I have been mostly looking at using for production.
If you've just getting into python, make sure you're using virtualenv and virtualenvwrapper. It make development and deployment a breeze.
I managed to get `pip` to compile extensions (only tested with `ujson` so not exactly comprehensive) by installing mingw, adding it to distutils' config, and then editing distutils' cygwin script to remove the no-longer-existent flags from the lines that use them. If you just do the first two then you can use `easy_install` to get those modules rather than `pip`. Side note: If it's not clear, I'm using CPython (2.7.3, 32-bit) on Win7 x64.
I parse data from omdbapi.com, which cites Freebase as its source :)
 Traceback (most recent call last): File "snowjob.py", line 106, in &lt;module&gt; snowflakes[col][1])) UnicodeEncodeError: 'ascii' codec can't encode character u'\u2740' in position 7: ordinal not in range(128) Edit: This can be fixed to work with python 2.7 by adding .encode('utf8') to the print statements 
Yeah I did that. Made sure my paths were in the correct spot as well so I could run stuff from the command line. I guess I should specify this is for windows.
One question: how does `print('\n' * rows)` work in clear_screen if rows is neither passed nor a global variable? EDIT: TIL, see Asdayasman.
Hehehe, yeah. I felt bad so I went ahead and changed it to softly exit after three failures. There's probably a lot of room for sophistication in determining if it's an issue with the link not being an actual image vs. being a corrupted image etc. etc., but that might be overengineering the script a little bit.
Thank you! You rock.
For completeness sake, on a Debian based OS you can apt-get python3-setuptools, easy_install3 pip, and use the pip-3.2 command. 
The camelcase, it burns!
PyQt has Phonon bindings, and I think there is something for GStreamer, too. Not sure what you want, but those should do it if you just need to read frames from a video.
That link doesn't seem to be working.
http://stackoverflow.com/questions/439857/is-there-a-movie-showtime-api
Honestly that seems majorly over-engineered to me. def attempt(transaction, throw, rollback = lambda: None): try: transaction() except Exception as e: rollback() raise throw from e
Usually video processing code will take advantage of Numpy. I don't think it's supported on python 3 yet.
you mean `print(repr(var))` ;) useful related knowledge: `{!r}`. is the equivalent of `%r` for the new formatting syntax. (e.g. `'The repr of {var} is {var!r}.'.format(var=var)`). i wonder why it wasn’t mentioned in the article.
You could use pyffmpeg but personally I'd use [VapourSynth](http://www.vapoursynth.com/) which is a new and kinda awesome alternative/port of Avisynth in python 3.
BTW: There's good autocompletion for emacs: https://github.com/tkf/emacs-jedi
Simplest way is to extract the frames of the video using `avconv` to images and then work on the images instead of the video.
No good reason really, I think the main focus was on gunicorn + python + upstart. As I said in the post: &gt; If I was even a tiny bit more ambitious at this moment, I’d install Nginx on this server too, and instead use it to dish up my static content, rather than Apache. However, I’ve already got Apache serving up this app under mod_wsgi, so changing it up to just serve the static content is cake. You're absolutely right though, it's pretty stupid to have Apache serving up static assets when I've already got Nginx in place, and basically just need to write a location directive to handle static requests. Got me thinking I need to do an update :)
[Pip for windows](https://sites.google.com/site/pydatalog/python/pip-for-windows) installs it for you. It's a gui for pip on windows, and it allows you to switch between different python versions.
I am trying to plot the intensity values of a single pixel of all the green frames. The final project would involve live stream from a camera as well.
Thanks, fixed now.
Absolutely -- made the fix. Thanks!
A university has to pay for university facilities. 
I just completed this course myself. For no money, it is an amazing learning experience. I went from no programming knowledge to building a customized version of Asteroids in 8 weeks. You should definitely sign up for the next round of this course in 2013.
Could not connect :/ looks like pastebin is down.
what's winsound ? dont have it edit: crap, Windows only
Thanks, that one works. Sadly I'm not on Windows so no winsound :(
Dude it's free
How fun! That's a really intuitive way to teach the basics of programming. I've seen the musical score as source code analogy before, but seeing it laid out like that is great. You can easily see a function call, a function definition, variables and parameters, repititon. Maybe super basic, but so intuitive it would be very helpful for an absolute beginner.
I think the arguments for that function (the notes and durations) should be pre-defined as data (list of tuples). Then at each main loop, simply call the function over an iteration of said list. Good one, though! Props! 🎅🎄🎁 [4] 
you can't just say that and not post the code :)
This package listing has helped me out dozens of times. Definitely needs more publicity.
That's true, but largely unrelated. People charge whatever the market can bear. And, online classes also have expenses and have different economies of scale.
The problem with taking another persons work and copy and pasting it into a finished product is; you cannot reproduce it from scratch. You should learn from the example and learn how to accomplish it yourself, just 'in case' your client asks you to make it again. Personally I don't learn from copying and pasting so I frown upon it.
I think the down votes was for the requirements. I think they are good for weeding out people but they need to be optional if you know what your doing. With that said most comp sci college graduates that I know of can't program but there are always a few that may not know the languages but give them a chance and they will kick ass at your company.
Would've been my approach too. I'll get on it in the morning. ;D 
Ok, well basically what I did was install beep. In ubuntu/debian its. sudo apt-get install beep Then I had to remove the modprobe blacklist of snd_pcsp and ~~pcspkr~~. nano /etc/modprob.d/blacklist.conf There you find the line blacklist snd_pcsp and uncomment it like this: #blacklist snd_pcsp Finally I modified the original script by doing import os and modified the playnote function to do this instead: def playnote(note, dur): os.system("beep -f {0} -l {1}".format(n[note], dur)) And thats it :) EDIT: I think removing the blacklist on pcspkr isnt necessary.
What, no ``__getattr__``? ;-) (Funny, I was just wondering today if there was anything like this out there for JavaScript, to help shorten function definitions for D3 and jQuery and such. I know there are similar libraries for Python already, though I don't recall the names of them right off.) [Edit to add: found something like this for JavaScript: http://osteele.com/sources/javascript/functional/ - it does it by giving strings a .lambda() method so you can do e.g. ``'x**2 + Math.abs(y)'.lambda()`` instead of ``function(x,y){return x**2+Math.abs(y);}``.)] 
Haha, yeah. I was kind of busy with family and stuff. I replied to iamstrange14 what I did.
Pastebin.com is horrible... I don't need to see Facebook like buttons and other extraneous crap when viewing some plaintext. Here it is hosted on a sane paste bin, http://sprunge.us/ajOG
you pay for the sheepskin that says to hr units around the world 'hi i am employable now'. you certainly don't get that with this program. 1k is a lot unless your company is paying for it. 
i am aware of that. haven't tried it yet. I've been pretty happy with ropemacs. I've found that if it can't figure out things, the lib you are trying to access is doing crazy stuff anyway. 
It worked in 2.7. Well done, and a Python Christmas to all.
Try PyGame. As long as you are using *nix you should be able to get the camera stuff working too. 
WE WISH YOU A NON CROSS PLATFORM CHRISTMAS!
That doesn't make it any cheaper...
I know that Python people are supposed to hate golfing, but I couldn't help myself: import operator class Fill(object): def __init__(self, f=lambda x: x, arity=1): self.f, self.arity = f, arity def __call__(self, *args): return self.f(*args) _binary_ops = ('add', 'sub', 'mul', 'div', 'mod', 'pow', 'and', 'or', 'xor', 'lshift', 'rshift', 'floordiv', 'truediv', 'getitem', 'lt', 'le', 'gt', 'ge', 'eq', 'ne') _unary_ops = ('neg', 'inv', 'not', 'abs') for wrapper, namelist, dest in (( lambda op: lambda self, other: Fill(lambda *x: op(self.f(*x[:self.arity]), other.f(*x[self.arity:])), self.arity + other.arity) if isinstance(other, Fill) else Fill(lambda *x: op(self.f(*x), other), self.arity), _binary_ops, '__%s__'), ( lambda op: lambda self, other: Fill(lambda *x: op(other, self.f(*x)), self.arity), _binary_ops, '__r%s__'), ( lambda op: lambda self: Fill(lambda *x: op(self.f(*x)), self.arity), _unary_ops, '__%s__')): for name in namelist: setattr(Fill, dest % name, wrapper(getattr(operator, '__%s__' % name))) _ = Fill() I am not going to claim that this is easier to read or better in any shape or form. 
Great clarification, thanks.
Well, I suppose Python is supposed to embrace readability and simplicity, which is sacrificed sometimes when trying to write succinctly. However, not always -- [this talk](http://www.youtube.com/watch?v=o9pEzgHorH0) gives examples of how removing code can make things better. So there's good and bad refactoring, but I think the term "code golf" specifically has this connotation of being the bad kind, where you use syntactic tricks and such to reduce size without regard for readability. You could make the case that that's what I did above, at least to a minor extent. But as I said, I just couldn't resist. Bad habits die hard. 
And then one might consider using openCV for image processing. 
Noob here. Why is that combo rare? 
Yeah no lie... That is probably the most helpful tip someone has given me.
Just a heads up: I added some documentation. I'll definitely be adding some more, but I think it should be usable as-is. There are pretty complete doc-strings, in any case. Let me know what you think. I'd like to add support for renaming movies, and eventually add support for alternate databases. I'll probably be adding a wxpython GUI as well, sometime down the road. I thought you might want to contribute to the movie scraping support. Anyway, [here it be](https://github.com/louist87/Scrappy).
[nqe](http://reddit.com/u/nqe) explained it briefly, but, from my perspective: * most people I know who write scripts are more inclined to use Unix rather than Windows because it’s (in my experience, at least) a friendlier OS for running scripts * The Python 2 branch is being developed concurrently with the Python 3 branch, and Python 3 isn’t backwards-compatible: a lot of code that uses other libraries (or aims to be used in other projects) will therefore be written for Python 2 for compatibility reasons.
"Code golf" is rewriting with one and only one goal: minimize the number of bytes in the program source. Every other consideration is actively disregarded in golfing. So it's not awesome high-level elegant code that's Web Scale(TM) and as fast as assembly; it's just code that uses the minimum number of source bytes, and performance and everything else be damned. Perl people tend to enjoy it as a game. Python people tend to dislike it as it can be habit-forming.
I think you missed the point. The cost is trivial for what you could potentially get out of the class, especially if someone puts a lot of effort into it and does networking. Sure, all of that info is located *somewhere* for free, but you're paying for the instructors to highlight what's most important plus whatever certificate you get, plus the ability to honestly say you took the course, plus grading, etc. As I've already said, university would probably be better, but a mere 1k could easily be worth it for someone who finds this stuff interesting. What's asinine is you saying other courses are free, therefore this course isn't worth paying for... Do the other courses even teach the exact same material?
Nothing wrong with cameCase.
&gt; i'm merely pointing out why universitiy can charge a very high price relative to whatever education it is giving you Thanks, I'm sure lots of people didn't already know that universities give out degrees. &gt; and why your quote "it's not that bad compared to a university class" is meaningless. University classes and non-univeristy classes offer some things that are similar and some things that are different, which is why you'd be an idiot not to compare these online things to what you could get from a university. Companies typically paying for things does not change whether it's worth it for individuals or not, especially if someone is not currently working. &gt; you have to weigh that against all the many free resources out there. Yes, you weigh classes against self-teaching, both of which have advantages and drawbacks, and which are not mutually-exclusive as you seem to think. &gt; but don't pretend it isn't a lot when you compare it to the other options for self-motivated self-funded education. I'm not pretending anything. It's not a lot when compared to some other classes. Their are more expensive classes and there are cheaper classes, but you don't just say, "Hey, you could take shop class for free, so these 1k programming classes are way too expensive!" You compare it to other classes and you value the 1k class based on what it actually teaches and how long it take to teach that specific material. Needing to take 3 free classes instead of 1 1k class, based on the syllabuses, would not make sense for some people, nor would taking 1 free class that doesn't teach a lot of the material in the 1k class that you want to learn about. If the free classes do it for you, fine. Maybe the Cousera courses actually teach the exact same stuff in the same time frame. But, it's hardly the cut and dry situation you are making it out to be. For a class that could be instrumental in you eventually doubling your yearly salary, and do it in 1/3 or 1/4 the time that you'd otherwise get that information in, 1k is hardly an unreasonable price to pay.
Even tho I do not like the idea of using python as a functional language. This is a really interesting and fun idea. 
I've wanted to try it long time ago, but now pretty satisfied with django CMS. Can anyone tell how are they compared each other? Which pros and cons? Does Mezzazine ready for "serious" use?
Yeah, that still becomes the latter; it's impossible to use the same variable twice :(
Merry Christmas to Python too.
I use Skype mostly for text, actually.
I'm a fan of [bpaste.net](http://bpaste.net/show/YSkooPM5E6r9v8R5EAms/). I think I came across it in #python on freenode
I have tried Django CMS too, but was not happy enough. Like adding News plugin - It was not working as expected, missing file upload in text editor and so on.
It's been shown in scientific research that people who take frequent breaks (every 20-40 minutes), in a relaxing way, such as browsing news etc., are more efficient in the long run and will more likely solve stressful problems. Attention span of most humans are not meant to have such high levels of concentration for too long.
Have you looked at sympy or theano? It's neat to do this concisely, but there are packages that give a lot more functionality if anyone really wants to do symbolic math. Theano will compute derivatives and compile your code to run on a GPU for example.
Thanks for this reply, interesting stuff.
Usually a good rule of thumb to just pass the variable in as an argument if it's not a constant.
This is really great stuff! I starred it on GitHub.
Thanks! This is exactly what I was looking for. If I can find some non-family time, I'll start refactoring. The library I'm writing is for a bigger django based project so I didn't focus too much on the CLI. Just threw something together to test the library quickly. Again, thanks for the feedback. 
The things you're disallowing by not subclassing `list` include (in addition to iteration and slicing) `extend`, `index`, `reverse`, `pop`, and easy copying. You're deciding to leave these out, but implement `len`, `remove`, and `__contains__`. It seems really arbitrary to me. How are you deciding which ones "fit the purpose of the class" and which ones don't? Since order matters, why would you want to be able to know whether a function is in the list, but not be able to know its position?
I think we're agreed that if you want the vast majority of the functionality of a list you should subclass list, whereas if you only want a little you shouldn't. I'm making a case that you actually want more functionality than you think. Why do say that those methods don't fit? I think they do. For instance, why do you feel the need to prevent this usage, which I consider intuitive? c = Compose([lambda (a,b): a+b, lambda x:x*3]) d = Compose([lambda x:x/3, lambda x:x+1]) f = c + d f(1,2) Or this? g = 2 * d g(10) You actually implemented `__iadd__` in your code, so I definitely don't understand why you say it doesn't fit.
I'll be here whenever I can for the next 24 hours to answer any questions (or respond to suggestions)! Feedback is more than welcome, I'm just learning too!
I find mezzanine more djangoesque and pythonic. The mixin system is really nice. The source is really easy to read and makes it so simple to get stuck into more advanced cms features not covered by the core Page model.
My solution: def compose(*fs): """ chains functions together """ def executeFunctions(x): for f in fs[::-1]: x = f(x) return x return executeFunctions Which is a bit shorter. Usage example: h = compose(lambda x: "::%s::" %(x,), lambda x: x+1, lambda x: x*2) print "h(5)=", h(5), " should be ::11::" A perhaps-more-elegant syntax might be to overload the | operator so it looks like a Unix pipe; doing this would require a class however, not just a function, e.g.: h = Pipe() | a | b | c | d then executing ``h(x)`` would be the same as executing ``d(c(b(a(x))))``
I thought it was good. The inverted dictionary trick is pretty hand, I may use that pattern in my code. I couldn't think of any examples you should add!
Thanks! I'm really glad someone liked it!
I can't visualize that. How would the target function be written? abc = lambda x: x ** 2 + abs(x)
&gt; is a good example Perhaps I wasn't being clear so I will expand: "That was one example that was easy to type that I find representative of my many issues and interactions with a fairly new project that I like and trust enough to run in production" And yes, it's "not professionally managed", like many open source projects. Release engineering is hard and often boring and rightly skipped by smaller fast moving projects. Are you really arguing that it's in the same league as nginx in terms of reliability? The team sizes and resources available as well as the expectations of reliability are completely different. Now I will extrapolate: You chose supervisord at some point and now feel the same http://en.wikipedia.org/wiki/Choice-supportive_bias that everyone does. Don't let your ego get tied up with tool choices. That way, fanboyism lies.
One possible convention is that subscripted fills refer to the n-th indexed unsubscripted fill. Like so: abc = _ ** 2 + abs(_[0]) 
Thanks! Some of that is silly mistakes on my part, and some of it is new to me too! Would you be alright if I spent some time and updated the post with some revisions based on your feedback (with credit, of course)? I can entirely understand if you'd prefer me not to.
And how would you implement that?
No please feel free to update away, that's the point of (what I hoped is received as) constructive criticism -- to make your post as good as possible. You don't need to worry about crediting me. 
They are a marketing company, not a review site. Don't ever take their reviews seriously.
You inspired me to write a FizzBuzz solution as a list comprehension.. for y in ["FizzBuzz" if x%15 == 0 else "Buzz" if x % 5 == 0 else "Fizz" if x % 3 == 0 else x for x in range(1, 101)]: print y 
It's funny that you should mention wisdom and necromancy, that's totally my thing. I hate to tell you this, but there is a popular web scraping tool caled ["Scrapy"](http://scrapy.org/), you might actually want to use it for your project. API design is all about finding the correct abstractions and paying attention to scope. I would suggest creating a TheTVDB api first, and then build a command line / gui program to go along with that. The renaming files bit might fall outside of the scope of a pure TheTVDB api. I could imagine TheTVDB api might have functions like **thetvdb.get_series()**, and **series.get_episode()**. Also remember in python we generally use function names_with_underscores() as opposed to lowerCamelCase(). Finally, consider this function to use with the levenshtein function, so that the user can compare based on percentage likeness of two strings, rather than the number of changes, insertions, deletions which is hard to conceptualize: def compare_strings(a, b): """ Makes the levenshtein into simple little coefficient, so that it can be rated as a 0 to 1 value. """ coef = 1 - levenshtein(a, b) / float( (len(a) + len(b)) / 2 ) if (coef &lt; 0): return 0 return coef
I think we aren't thinking of the same thing when I say "not professionally managed". I mean that literally. As in, not managed in the way that software products with paid positions dedicated to release management are managed. That's over the top for a small open source project and it's not even popular anymore, people want to move fast and break things and don't want to evaluate every change. They don't want boring old cranky sysadmins doing ops, they want devops. Worse is better. Bugs are things that happen, not the result of an engineering failure. That's fine, I love the choices and flexibility I have doing devops tasks these days. There are excellent reasons to make this choice. I choose this path *constantly* when I think it's the right choice. But it's silly to pretend you aren't making a tradeoff. All that being said, I chose that example because even in devops I would expected a bug report of "make a tiny docs change so your users stop losing data because the docs are lying" to be closed in days rather than months. I get worried by that level of "meh, whatever" in an ops related context. Also, the docs bug is a patch on the actual problem of not being able to keep unlimited log files. That's the actual bug, the docs patch is just to tell people that the bug exists. 
"Make it possible to store an unlimited number of log files" is actionable, thanks.
Pretty good. I would also add that putting a for loop in brackets is also a good way to make a copy of a list you want to manipulate later. Also, digging deeper in to nested lists is very crucial to data management.
Please, find my bugs. I'm working on a project for fun. If you find this type of thing fun too, send me a message. I want to collaborate.
If you love stories like [these](http://espn.go.com/mlb/story/_/id/8772294/strange-true-feats-2012-mlb-season), you're going to love the future of this game.
I love list comprehensions but FizzBuzz is rightly not the best context to use one. This is rather unreadable.
You might consider adding functionality to existing programs rather than starting from scratch. I suggest checking out [episode renamer](https://github.com/skorokithakis/episode-renamer). 
Man, this kind of things are what remind of how fun python can be.
I had an implementation like this at one point. I found the exception names long enough that I had to break the line. That and saving the functions off saved alot of writing those same arguments over and over again. Off course you could partial the exceptions onto attempt and save those off. You also lose the stacktrace of the original exception if you raise without the 3 argument form.
I generalized the playing code (and made a mini parser so that there aren't a bunch of repeated calls and the music is all in one string), added comments for lyrics, fixed a couple of notes (all those whole notes should be half notes; 4-beat whole notes wouldn't make any sense anyway, because the piece is in 3/4) and sped it up (you had it at 120 quarter notes to a minute and I think it sounds better around 160): http://pastebin.com/zLCX1Y50 Interestingly, `winsound` seems to play through both my computer's internal speaker and the ones I have plugged in; if I turn off the externals, it still plays, but gets quieter. Edit: crap, I was making changes to it locally before pasting, and I forgot to switch the arguments to `play_melody` around in the submitted paste. That should be `def play_melody(bpm, notes):`. Sorry!
&gt;You also lose the stacktrace of the original exception if you raise without the 3 argument form. In 2.x, you need to jump through these hoops to hack the `sys.traceback` global, yes. In 3.x, that `raise throw from e` thing chains the exceptions for you, and the chained exception keeps its traceback. Changes to the exception syntax are one of the fairly big motivators for migrating, IMHO (although "sane handling of Unicode" pretty much dwarfs everything else).
That's bad SQL use. Parameterize your queries. 
Maybe. It's certainly what I use, though. I'm not exactly your typical Windows user, mind; in fact, I grew up using Macs. But I've developed a very strong mindset of using the computer I'm given; the "right tool for the job" is realistically only ever a software question, in my extensive experience, and anybody who tells me I have to replace the OS that came with my computer to be taken seriously as a programmer is frankly not worth my time. (And it's pretty hard to avoid getting a machine with Windows pre-installed, that you're effectively paying for as part of the bundle anyway, if you're not a hardware geek - which is different from being a programmer - or springing for a Mac.)
&gt; Moreover, this is a place where a list comprehension should not be used, but a generator expression: &gt; `sorted_owners = sorted(getOwner(dog) for dog in dogs)` Why is that? Is it just to save 2 chars?
I'd say it needs more examples at the start to show how they work. The animals thing really didn't help me, for example.
my favorite way to refactor code is to make it dumb. Give meaning as late as possible using code that is as meaningless as possible. Think about an ideal world in which most of your code is borrowed from a project that has no idea about what you want to do. Then go implement the code that is missing. Push as much of the method code your God Object uses outside the class in various methods and treat each method like it's a psychopat that, when given too much data or too much access to the data, will go insane and mess things up. State is one of the worst blindspots I have identified in my experience as a programmer. All my God Objects are a slugfest of methods messing in a muddy state that only God ends up understanding past a certain point. 
A list comprehension builds an entire list before returning. A generator expression yields each item of an iterable on demand as needed. That has several potential upsides: - There is no temporary list created. In many situations the necessary work can be done an item at a time and that list is extraneous garbage, for example calculating a sum. - In cases where the answer can be found before all the elements of the iterable have been inspected, it's possible to stop early without even calculating all of them. For example, suppose you wanted to know if any of the members of a long sequence were odd. If the third number checked is odd, there's no reason to bother looking at the rest. Passing a generator expression to `any()` would be a way to achieve that. In the example of `sorted()`, maybe the sort algorithm is able to do a better job if it's handed the items one at a time, for example perhaps it can build the result list in-place in sorted order. I don't know if such an optimization exists or not, but even if it doesn't it will just fall back to what the list comprehension would have done anyway, so there's no reason to tie its hands by forcing it to create a list where there might be a better option. 
So yeah.
&gt;winsound THE GRINCH STRIKES AGAIN!
Actually, I'm not sure the example works at all - he's passing the values in a tuple in a second argument [rather than applying `%` which is how I assume you read the example as] like with parameterized queries, but using %s instead of ?.
Heh, that's the reason I want to change it really. It isn't the friendliest of code to understand at the moment.
Your further simplification worked a treat. I didn't know about .update() before, but now I do I think I may need to refactor some of this project. getattr looks to be useful too. Thank you for showing me how to write this better.
There's also [pastebinit](https://launchpad.net/pastebinit/). It's at least available in Ubuntu and Debian repositories. It supports many many different pastebins.
Maybe this will help: http://gafferongames.com/game-physics/integration-basics/
How is this better than Selenium+Xvfb?
This requires PyQT. If I use this in a server setup I need to install huge dependencies.
With AJAX you can't tell whether a page is fully loaded or not. Example: [http://www.ncbi.nlm.nih.gov/nuccore/CP002059.1](http://www.ncbi.nlm.nih.gov/nuccore/CP002059.1). But if you have an "onload" solution, paste the code.
Unfortunately, ghost.py requires Xvfb. A true headless solution is [PhantomJS](http://phantomjs.org/).
&gt;I have no idea what a levenshtein is For your general culture: [Levenshtein edit distance](http://en.wikipedia.org/wiki/Levenshtein_distance) is a metric for comparing string similarity. It's basically the number of "modifications" necessary to turn string 1 into string 2. Modifications can be: - remove a character - add a character - change one character to another - switch the place of two characters Thus, the Levenshtein distance of `"Herp Derp"` and `"Derp Derp"` is `1`. It's an extraordinarily useful tool for simple text searches, as it allows you to return inexact matches.
How to download the source of a page and wait X seconds with PhantomJS? A code snippet would be highly appreciated.
Which is interesting because it looks like omdb scapes the IDs and ratings and such from IMDB. 
Really glad it helped! I'll try to keep posting every couple weeks or so if you're looking for new tips and tricks, but to be honest you'd probably find way better resources over in the later chapters of [learn python the hard way](http://learnpythonthehardway.org/book/) or [code like a pythonista](http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html). They're much more qualified to educate than I am.
Thanks for the advice. I've put the Ply lexer/parser aside for simple parser class that I wrote, just to keep development moving forward. I definitely plan on returning to the idea in the future, though. With my own code, I've already got a fake vi command/"insert-command" mode.
Specialized code is certainly easier for your code. In your case, ply will only provide a learning experience and cleaner code (hopefully :) 
Why do you use PyQT ? I don't see what it offers other than adding on the dependency list.
Fijal, this is simply not true. We are against wholesale abandonment of the CPython runtime. We are also against not having a binary-level runtime which C, Fortran, and other runtimes can interface with. This point has been made over and over in several blog posts from me and Travis. We are actually very interested in what's going on in PyPy land. We just wished that more of it was (a) available as Python compiler tools that could be leveraged by other projects, and (b) resting on a reified runtime or intermediate layer that other technologies can interoperate with. By contrast, Numba is built on LLVM. We are able to leverage optimizations from a very wide developer ecosystem there, including contributions from hardware manufacturers like Nvidia and Apple. For example, the most recent LLVM release includes loop vectorization optimizations which we will get for free. We can talk about interop with other languages like Julia and LLVM-based implementations of R and Java.
I use the webkit module of Qt. This is a complete browser thus it can interpret JavaScript. It can also be used in a headless way, i.e. no window is opened (perfect for scripting). And I could make it to wait X seconds, which was not trivial to figure out. What do you suggest instead?
Instead of writing multi-line comments above functions, why not just use doc strings?
I've never used Ghost but I'll try it. Thanks for the tip.
It's not really a monad without &gt;&lt;|^{[*]````{( Seriously though: 1 &gt;&gt; get_user &gt;&gt; send_message &gt;&gt; log would be nice.
But once you *know* what the NoneMonad is and what it does, all that special cased handling of None becomes nothing but noise and the example using the NoneMonad looks perfectly readable and sane. And you only need to learn about the NoneMonad once.
&gt; It's essentially the same as "we're compatible because we use x86". What exactly LLVM gives you extra on top of that? It's a pluggable compiler architecture, you know that. It gives us access to backend hardware-optimized codegen, as well as access to optimization work from a much broader development community (which is commercially backed by folks like NVidia, AMD, Apple, etc.). &gt; How would you leverage LLVM when talking with Julia? There are many potential ways forward there. Simple examples include using Julia-defined functions which are compiled to LLVM IR, or using Numba to JIT compile Python user functions into IR, which then Julia could dispatch to. None of these things are impossible with a rich, well-defined C ABI, except that so much of what's baked into machine code is irrelevant from a language interop standpoint, whereas the IR is actually a pretty useful representation. Of course LLVM is a compiler system, and not an actual runtime like the JVM. Input source is responsible for memory and lifecycle issues. These have to be defined as an external interface, and LLVM does not give that to you for "free". But the same thing that gets Beazley excited about Bitey and LLVMPY is what gets us excited about language interop without resorting to emitting C headers and shared objects. &gt; LLVM is a nice project when you do static compilation. It's completely not working when you do any serious JITting. Maybe you don't need a real JIT, we do. JIT != Hotspot JIT. Maybe you've been working on PyPy for so long that you don't care to make the distinction. But when we can accept userland code at runtime and dynamically create optimized binaries from it, that's a JIT. Numba is a "real JIT", since it can dynamically compile and dispatch based on known types. PyPy is much more ambitious and tackling a more general case, but so much of the work of hotspot optimizations are unnecessary when types are already known. Overall, the divergence in philosophy between the various technical efforts at Continuum, and the approaches of projects like PyPy (and to some extent, Julia), is that we are very focused on improving the state-of-the-art of *data description*. Once that is improved, efficient computation can follow in a very nice way. This has been well known in the supercomputing and technical computing communities for decades. Dynamic hotspot JITs come from a perspective that is very fixated on *efficient computation* as the core concern, and fails to realize that 90% of the problems facing real world data analysts is about just moving and structuring data. Scientific computing languages like Chapel, Fortress, X10, SISAL, NESL, etc. all start with data description. Language geeks and LtU subscribers all start with building niftier compilers with cooler optimization approaches. I think these different perspectives can complement each other in domains where they can overlap, and do not have to be exclusive. But we definitely do not need to be spreading FUD about each other - especially stuff like "Continuum folks are very down on PyPy". Ilan Schnell wrote fast_vectorize many years ago, based on tools from PyPy. Jon Riehl, one of the Numba developers, was hacking on PyPy almost 10 years ago. Earlier this year we even funded you to package PyPy in a more accessible C library form! We are very interested in the project and hope for its success. I just don't think it's appropriate to oversell what it can do in the scientific space at present, because it may introduce more confusion to commercial users of Python, who are largely silent in social media and blogs and mailing lists, but who pay very close attention to the conversations around these tools we are all building.
Readability is subjective. To me it's much easier to read the monadic version over the over the copy paste oatmeal code that looks almost exactly the same. In fact, to me this could make it harder to find a subtle bug in the non-monadic version since the real code is in the background surrounded by boiler plate. Sure, clever one liners are not necessarily readable, but they are an improvement over nested conditionals. EDIT: I think the generator notation makes it a lot more readable (at the cost of being even more clever): @do(Maybe) def with_maybe(first_divisor): val1 = yield mdiv(2.0, 2.0) val2 = yield mdiv(3.0, 0.0) val3 = yield mdiv(val1, val2) mreturn(val3) 
More clever is right. I have absolutely no idea what this does, even conceptually. The amount of code required to truly understand what's going on would be staggering. What are the implications of the wrapper? What's the definition of Maybe? How does that change the flow of code in do? What does mdiv do? How can mdiv fail? What would the stacktrace look like? How is the status of the global state modified in mdiv or mreturn? How do I recover from an exception that occurs (assuming a non-trivial example)? What is mreturn even doing? What does the loop look like that surrounds this generator? How What is it passing forward and backwards? What happens if the loop is interrupted by a system call elsewhere in the code? I'll take boilerplate over mysteries. But as you said, it's subjective.
First of all, dont do CSV, its messy with the quotes. Use tab-text. Here is a function i wrote some time ago. #=============================================================================== def fPrint( outputDirFile, headerStr, *args ): outputFile = os.path.basename(outputDirFile) ouputFileBase, outputFileExt = os.path.splitext(outputFile) outputDir = os.path.dirname(os.path.normpath(outputDirFile)) + os.sep if not os.path.exists(outputDir): os.makedirs(outputDir) fileID = open(outputDirFile, 'wb') for i in xrange(0, len(headerStr)): if (i &lt; len(headerStr)-1): fileID.write(headerStr[i]+'\t') else: fileID.write(headerStr[i]+'\n') for i in xrange(0, len(args[0])): for j in xrange(0, len(args)): if (j &lt; len(args)-1): fileID.write('%s' % args[j][i] + "\t") else: fileID.write('%s' % args[j][i] + "\n") #=============================================================================== EDIT: The spacing above is a bit fukt. EDIT2: So, this was my first post in /r/python and here are my conclusions: 1) You guys are either helpful or fucking assholes. 2) Posting code examples that only someone with years of python experience find understandable is not supporting your "cause." "You should write code this way, here is an example that will look neat to other pythonistas that know the language inside and out, but forget about understanding it if youre new to the language. If you are new, we will ridicule you for not understanding this snippet." 3) Mods, this is my first and last post here. Such a great community you have here. I have over 15 years of matlab/C/C++ experience and have spent a few months with python, i was hoping to find a helpful community here, instead i found, with one exception, assholes. Congrats. 
Linode VPS running Arch Linux, nginx, and using systemd socket activation for starting Django on FastCGI via a Unix socket file. Very happy with the simple setup now that I have the unit files written.
 import csv with open(filename) as csvfile: writer = csv.writer(csvfile) writer.writerow(["id", "username", "password", "token", "url"]) writer.writerows(zip(ids, usernames, passwords, tokens, urls)) You forgot to close the file.
&gt; alias celerity='python &lt;(curl -s https://raw.github.com/dukerson/celerity/master/main.py)' Is it not a little excessive to download the script each time you want to run the program? You should make a setup.py file, something along the lines of: from setuptools import setup, find_packages setup( name=u'celerity', version=u'0.0.1', author=u'Justin Duke', license=u'...', description=u'A self-contained Hastebin CLI.', packages=find_packages(), entry_points={ 'console_scripts':['celerity = celerity:main'] }, )
&gt; raise TypeError("the objects {} are not callable".format(", ".join(str(x) for x in non_functions))) I think you may have forgotten the index here... raise TypeError("the objects {0} are not callable".format(", ".join(str(x) for x in non_functions))) edit: the former appears to work with python 2.7 actually (TIL). 
zip() will create a huge list of tuples, prefer itertools unless you actually want a sequence to manipulate, rather than just for iteration as done here
This should also do the trick :) for x in range(101):print"fizz"[x%3* 4::]+"buzz"[x%5* 4::]or x (Had to add a space after each * to prevent italics)
Again, speaking as a non-Haskell programmer, your Haskell example means absolutely nothing to me. I'm sure it's conceptually beautiful (and the python code does have a nice symmetry to it), but as an in-the-dirt programmer who has been responsible for maintaining code written 7-10 years ago, I'd prefer you to keep your Haskell-isms in Haskell, C idioms in C, and stick to writing Python when in Python. I've seen that link before, and while there are some damned clever tricks there, I still would not want to try and maintain code written using it. Overridden "&gt;&gt;" and "+"? Decorators driving generators? Decorators catching and swallowing exceptions? Exceptions as flow control driven by decorators? Not a single one of those statements sounds easy to maintain or understand. It's so easy to just get something a little bit wrong (and that's not even mentioning the performance hits). I guess in the end I have a distinct distaste for things that take control away from me. Python does enough of that on its own, but I've learned to work within those boundaries. Having to fight to discover the new boundaries in code *that doesn't need to be this complicated* doesn't make a lot of sense to me.
You could use reduce here as well, applying the result of the prev function to the next function in the list, or returning none. Would mean you don't need the loop or the scope leaking ugliness of the arg variable. Edit: Something like: def none_chain(vars): """ Returns the result of composing the functions in vars from left to right. EG, none_chain([1,foo,bar]) = bar(foo(1)) If any of the functions return None, this will return None. """ return reduce(lambda a,f: None if a is None else f(a), vars[1:], vars[0]) 
No way! I just found this sub and I was having a look around. It seems that you've made something very similar to this: http://sourceforge.net/projects/pyshowrename/ Which is something I put together over the last year. Mine scrapes epguides instead of plugging into thetvdb API. Your code looks massively more professional than my child's attempt at learning Python. It would be great if you'd take a look and see what you would improve. I'm interested at smoothing out the edges and making it more easy to install on a windows installation so I can just release an EXE. 
Honestly, this code snippet is one of the more confusing ones I've seen. CSV is a perfectly reasonable format for many purposes. It's not "messy with the quotes" if you do it consistently, and even if you mix it up it's generally pretty easy to unmess. I mean really all your function does is use "\t" instead of "," as a separator. Secondly... how much Python have you actually written? I'm genuinely curious. I honestly had to do a double take because that code, to me, looks like C code. Or, to rephrase, that code looks like what an experienced C programmer would write if you gave him a basic Python function reference and a short time limit. Your "for i in xrange" construct. You're using xrange, so I'm guessing you've read enough to see something like "xrange is a more efficient implementation of range". But then you use it in these just terribly non-pythonic ways. fileID.write("\t".join(headerStr) + "\n") fileID.writelines(map(lambda x: "\t".join(x) + "\n", args) I think that correctly takes care of pretty much everything below your open statement. Stop trying so hard. Python is a big, strong, grown-up language. You don't have to hold its hand to get the 1's and 0's in the right order.
Take a look at csv.DictReader, from here: http://stackoverflow.com/questions/13324916/a-pythonic-way-to-read-csv-with-row-and-column-headers/13325712#13325712
I have been writing python for about 3 or 4 months. I am scientific programmer and have spent the better part of the last 15 years in Matlab and C++. I dont deny that i suck at python and being a scientific programmer it is more useful for me know what is happening than depending on functions i have no clue how they work. Your two lines above make no sense to me at all. I would rather read the code and know that it is doing what is expected. I dont even know what map does, or what "lambda x:" is. In addition, i tried to use the writelines function in the past and it just produced garbage (obviously i was not using it "pythonically" or whatever). And yes, CSV is messy. I hate having to strip quotes or include them when doing a match, and forget about how much of pain it is adding them if you do a write. Tab-text has none of these problems. I should mention i did cheminformatics research for years, have you ever seen a chemical name? Tons of commas. Then there are problems with free form input, people always use commas when just typing a simple "shit did not work" phrase. EDIT: Also some asshat said this was ugly code. Probably because i use the full library (import os v. whatever that alternative is so that you can call "basename" without the os.path) so i know what im using.
I've also taken a jab at this. Though I approached it differently. https://github.com/amccloud/apy/blob/master/tests/test_apy.py 
&gt; well, I am sure, it's because you're raising good points but they're not in favor of monads Python the language and its community are relatively hostile to functional programming so I'm not sure your statement follows. Personally, I did not down vote that comment but I can tell you why I disagree with it: you can make the same argument against any abstraction. The argument is especially weak against a formal abstraction such as a monad since you can use any proper monad correctly as long as you follow the monad laws.
I should mention that snippet is not terribly reflective of what i write in python. When starting down this road, i was disturbed by the lack of an fprintf(). Its simple, easy to use, easy to understand. In its place were all kinds of wrappers that did not work, were difficult to understand, and complicated. 90% of my output is tab text, with headers, and that function does a perfectly fine job of printing variable column tab text. So, i started watching that video, and right off the bat they start talking about dictionaries. Which brings me to my other python gripe, why are there no structs? Dictionaries work fine if you have a 1-to-1 mapping, but what if i have a 1-to-many mapping? I hate that many of my methods have to return many lists rather than just one struct. I have looked into dictonaries of lists, but like most pythonically oriented things, it takes hours to figure out how to do something that should really take minutes. 
I think a lot of developers, myself included, use "CSV" as a synonym for "a flat file with tabular data separated by some set of delimiters.", which your "tab-text" is. I've seen "||" used as a field delimiter before. They're all basically the same thing, and we just call that set of things CSV files because commas are one of the more popular delimiters. "join" is a method that "joins" a sequence together using some delimiter, or not. L = ["x", "y", "z"] "aaa".join(L) gives "xaaayaaaz" This is very readable to me, it says "join the list L together with "aaa" as a delimiter. "map" is just that - it maps a function over a sequence. "map(f, L)" will call function "f" with each element of sequence L, and then return a list of the results. So if I had def f(x): return x * 2 L = [1,2,3,4] print map(f, L) I'd get [2,4,6,8] as a result "lambda" is how you define an anonymous function in Python. The above example is excessively verbose. For simple operations, it's nice to be able to define the functionality for a simple operation without actually having to define a function. "lambda x: x * 2" encapsulates the logic of "f" above, and so you could write that whole thing as print map(lambda x: x*2, [1,2,3,4]) You could also use it when you have a list of objects that have a "balance" attribute, and you want a certain percentage of that. sum(map(lambda x: x.balance*0.10, accounts)) Gives us the sum of 10% of the balance for each account. Lambdas can also have multiple arguments, which is really nice when you're using zip. Because it's Python, you can use a lambda expression anywhere (at least to my knowledge) you could use a function call. This means you can do weird but still valid stuff like (lambda x: "Hello, %s" % x)("homercles337") And it returns Hello, homercles337 Your concerns about readability are 100% valid. But just because you or I or whoever doesn't know *how* to read something doesn't mean it's unreadable. You just didn't have the "lambda" and "map" constructs in your vocabulary yet. Once you do, reading and writing programs that use them becomes easy, and you'll actually have an easier time reading programs that use them well because they communicate the idea clearly. It took me a moment to figure out what your original code did, because you broke what I think of a a single cohesive "join" statement down into tiny pieces and implemented them yourself - whereas if I see a "join" statement then I know immediately what it does. I'm not trying to come down on you, it's just that maybe if you're a real beginner at using a programming language maybe you shouldn't be giving bad advice to other beginners.
Thanks for the feedback. Point totally taken on the CSV thing, however in practice i have never seen someone talk about CSV and use any other delimiter. Its always a comma, always. I have looked at .join and find it confusing because its backwards. "aaa".join(L), should produce aaaxaaayaaaz. Also map() is a horribly misleading term. Its too short, it should be called funmap() or something if its mapping a function because every other language i know deals with map as a memory map (in matlab this is memmap). On anonymous functions im cool with that, but try searching for lambda there are about a million unrelated things. In matlab this prepended with an '@' to denote an anonymous function. Finally who cares if my function looks like C? Do you say the same thing about C bindings called via cython (or whatever, i have not actually done this in python yet)? Here is how it is called: projectTools.fPrint( outputDirFile, ['Sessions', 'Quality'], Sessions, Quality ) Far easier to read than file.write(map(lamba x: Sessions, (foo(bar(outputDirFile, ['Sessions', 'Quality'], Sessions, Quality)))), or whatever (i admit that is a horrible example meant to point out the absurdity of your join/write/map/lambda/writelines example). Sometimes its easier to read 10 lines of code than dig through 20 lines buried in 10 library files. 
&gt; EDIT: Also some asshat said this was ugly code. Probably because i use the full library (import os v. whatever that alternative is so that you can call "basename" without the os.path) so i know what im using. No, that's about the only thing that's NOT ugly here. Here are the reasons why it is ugly code: &gt; def fPrint( outputDirFile, headerStr, *args ): what is fPrint? the function is for writing tabular data, it should be called something like write_tabular_data_with_headings. I'm sure it's great having a nice short function name to use, but it makes no sense. What is outputDirFile? Is it a directory? is it a file? Most people would call this variable "output_file" or something. What is headerStr? Your variable naming seems to indicate that it is a string, but it is really a list of strings. it should be called `headings` or something. You're using `*args` to allow passing an arbitrary number of columns, it should be `*columns` &gt; ouputFileBase, outputFileExt = os.path.splitext(outputFile) You never do anything with either of these variables &gt; outputDir = os.path.dirname(os.path.normpath(outputDirFile)) + os.sep appending os.sep here doesn't accomplish anything. a path to a directory does not need to end in a slash. &gt; fileID = open(outputDirFile, 'wb') this is not a fileID, it is a file object. &gt; for i in xrange(0, len(headerStr)): &gt; if (i &lt; len(headerStr)-1): &gt; fileID.write(headerStr[i]+'\t') &gt; else: &gt; fileID.write(headerStr[i]+'\n') This is the most complicated, roundabout, slow way I've ever seen to write header_line = "\t".join(headerStr) fileID.write(header_line + "\n") Or even for col in headerStr[:-1]: fileID.write(col + "\t") fileID.write(headerStr[-1] + "\n") There aren't any programming languages where looping over every element and checking to see if you are at the last one yet makes sense. Just loop over all the elements -1! The fact that you are trying to write c++ in python isn't even the issue here, this code would make no sense if it was c++. the fact that you even have lines like for i in xrange(0, len(.. means you haven't even read the most basic of python tutorials. Additionally, what probably annoyed the most people is your &gt; dont do CSV, its messy with the quotes. Use tab-text Which indicates that you haven't even skimmed the python csv module documentation. &gt;&gt;&gt; w=csv.writer(sys.stdout, dialect='excel-tab') &gt;&gt;&gt; w.writerow(("Surprise, motherfucker", "commas work just fine")) Surprise, motherfucker commas work just fine 
 def seriously(): return {"thingone": ["this","couldn't"], "thingtwo": ["be","simpler"] } &gt;&gt;&gt; seriously()["thingtwo"][1] 'simpler' 
I've finally gotten around to updating the code based on your feedback. If you get another chance, can you take a quick look? 
Do you have a copy of the materials? I'd love to sign up for this but I'd like to take a look at the last set of coursework and exercises so I know what I'm getting into.