To highlight the fact that the editor is not overly bloated, the demo was run on a Windows XP machine that was over 10 years old. But unfortunately this also meant no microphone was available on that machine :( But there was an attempt to add a readable narration to the video. 
I tend to consider ``__all__`` also as a documentation's utility. It serves me to *declare* what I consider public access from a module.
Doesn't change anything about the fact that I'd *never* recommend a beginner to start off with PHP. Web development isn't trivial anymore these days, so why recommending an amateurish and broken language for that?
Honestly, can you extract some of the data and plot it manually with Cairo to an SVG canvas? Some things are best done by hand. Matplotlib is not the most beautiful thing you'll find.
You can edit the matplotlibrc file to customize almost everything in your plots. http://www.huyng.com/posts/sane-color-scheme-for-matplotlib/
Ugh. There is basically no information on that page, no introduction to the project, no justification, no example code, nothing. There's a one sentence blurb that tells me very little. The downloads tab is empty. The wiki tab is empty. The issues tab lists one defect, "what is the status of the project?", which I can very much empathise with. All the "source" tab lists is the command to use to clone the source tree with mercurial. Great. If you go through all that trouble to make something cool and amazing, spend a little bit of time talking about it so people know what it is you've done, why you've done it, and why that's awesome! And you put that information FIRST so people can't help but read it when they visit your website. Websites that have a "news" section before an "about" section are one of my pet peeves. This has neither!
The one thing I miss is to fit arbitrary functions easily (probably the one thing I like about ROOT).
* Desktop: i5 2500k, Radeon HD 6950, 240GB Corsair SSD, 1TB WD HD * Dual 24-inch monitors * Das Keyboard (Cherry MX switches) * Arch Linux (Xmonad ontop of XFCE4) * Vim (configured and with plugins for Python coding)
&gt; lots of important sites are build it it Doesn't mean anything. Lots of people smoke, so does that mean it's a good thing to do?
I am just switching from php to python and i already love it! PHP: a fractal of bad design http://me.veekun.com/blog/2012/04/09/php-a-fractal-of-bad-design/
It's not matplotlib but check out scipy.optimize.curve_fit
STM will be significantly slower, so no free lunch.
Probably performance. Performance is probably the only deal-breaking problem with Python.
python fan here and i completely agree way too many technologies that you have to deal with...
I like RooFit it is very powerful... but you can use it from pyROOT i'm sure.
wtf?
Unfortunately (py)ROOT maintainers have never heard of packaging :P The scipy solution looks good though, now I have to see how I can plot the function over the other data.
And it's annoying, when you actually want to find something without an IDE [to jump to the real declaration]
Generic intel quad core box with 2 by 24" 1920x1200 monitors running gnome-shell on ubuntu 12.04. Cheap but good setup. Current gen Macbook air 13" when on the road running gnome-shell on ubuntu 12.04 in VirtualBox.
You clearly afford all of this by cutting costs and buying Euro Shopper energy drinks. ^___^
holy sheet
Faster startup, maybe, but the overhead of ctypes at each function call is significant. I doubt that it's faster than pyobjc.
You discredit the brilliance of ES with your PHP.
it doesn't prove that it is good, but it proves that it's not useless.
I know that feel - Java here.
If it works great - but it seems rather limited in choice of minimization procedure and multidimensional fits.
I think the idea is to improve their STM implementation until it's fast enough to be the default. But that could be some way off yet.
Desktop@Home: - AMD K7@900 MHz. 256 MB of RAM. HD 60 GB. - 17" @ 800x600 (because the monitor is diying). Desktop@Work: - Intel Core2Duo E8200@2.66 GHz. 4 GB of RAM. HD 250 GB. - 17" @ 1024x768. In both machines, I only need to get a better monitor (1280x1024 would be fine).
Look at playing with line width and alpha, if you want a cuter graph. 
I am definitely interested!
I will be posting it soon as an edit of my OP.
This is just getting up and running not really porting a django app to pyramid. I could do that in the future but I just started and figured I would post this.
I completely agree that the project page is useless in its lack of information. As a side note, on PyPy the ctypes overhead is not as significant, so if the goal is to support PyObjC on PyPy (or IronPython or Jython) then your objection is not as strong.
pyPDF doesn't seem to be capable of _generating_ PDFs, which is what I asked about. To summarize: - 1) I said Python seems to be lacking tools for generating PDFs and mentioned ReportLab as being the only serious one out there. - 2) You said that's not true, and that there are excellent tools for _working with_ PDFs. - 3) I asked you to mention some of those excellent tools for _generating PDFs_, which is what I was talking about in the first place. - 4) Now you point back to _fucking ReportLab_, and to some haphazard tool that's _not_ capable of _generating PDFs_ at all. So, in conclusion, I guess it's pretty safe to say that Python lacks tools for generating PDFs, and that it's kind of pointless to argue against that statement especially with no other "useable" tools in mind. 
yeah I was just guessing since I haven't read what you are posting yet :), just suggesting 2 possible areas where it might fit if you are interested. 
Well ... not cheap compared to the wordpress template editor no, but cheap compared to most general purpose languages. That's based on actual data by the way. Another benefit to being a non-php shop (and non-node/ruby shop these days) is that those self taught beginners who don't know how to evaluate their own talent because they have no reference (the Dunning-Kruger effect) aren't really an issue. DEFINITELY not anything like 400 out of 410 candidates. I've done a lot of PHP developer hiring and a decent bit of hiring for other languages. No CTO has ever chosen PHP for a green field project for a reason other than how easy and cheap (comparatively) it is to find PHP devs.
Also False.
No need to get huffy. I just didn't follow your drift... While we're on the subject of avoiding redundant statements, allow me to present the conversation as I experienced it: - I reply to OP by saying (paraphrase alert) "I don't know much about *generating* PDFs. My work has dealt more with mining them." and **most importantly** "my point is that PDFs in general are a pain, independently of the language" - You respond with: "So basically what you're saying is that Python is lacking in tools for generating PDFs :p" - I mistakenly think we're still talking about working with PDFs (i.e. mining) because I thought it had been made abundantly clear that this was all I *could* talk about. - You respond with a request for libs that are not ReportLab - I suggest some other tools I've worked with, again, thinking we were past this silly idea that I knew a damn thing about generating PDFs. - You become angry and insulting Your lack of manners is exceeded only by your lack of manners. Please understand that my life does not revolve around you.
Hi all, I'm really new to all of this, can someone explain to me what the difference is between Pyramid and Django? How can it help me with back end server side programming?
what does this even mean?
"Pure seo spam ftw"? Is that what I'm supposed to be reading? That doesn't make too much sense now, does it? Edit: I even wrote a Python script to confirm. Result: PURESEOSPAMFTWW. That does *not* look like anything I can make sense of, unless you mean 'pure sea of spam ftw', which is still somewhat weird.
oursql also supports streaming data in/out of the database, something MySQLdb doesn't do.
search engine optimization aka SEO
How does someone notice this? Rain man all up in this shit.
It's not inherently insecure. SQL injection happens when data is *improperly* interpolated into an SQL string. It's generally recommended against because in a typical application you'll have countless queries, and it comes down to a numbers game: you're likely to screw up at least one of them. But a library will only really do it in one or maybe a few places in its code, and as long as it's consistently and correctly interpolating the parameters (with quotes, escape characters, etc.) then it's not inherently insecure -- although there may be other undesirable side effects, like poorer query caching.
Standard library, or third party? Of the third party modules, I've recently been quite impressed by [keyring](http://pypi.python.org/pypi/keyring), which provides a simple API for the encrypted storage services on the main desktop platforms - Windows, Mac &amp; a couple of Linux services. A small niche, but one that it fills nicely.
Desktop. Win7 dual monitors 2560x1600 with a portrait monitor next to it running 1200x1600. Virtualbox running Ubuntu fullscreen most of the day. Write code in VIM always in a virtualenv. Dropbox moves files between VM and host and keeps them web available.
Uhuh, "the Munroe algorithm"... there goes his humility...
If you are doing GIS, i'd suggest you ditch mysql altogether and do postgres/postgis
import this
Keep up the good work. I'm impressed with the ideas behind PythonAnywhere and Dirigible, even though I don't currently have a need for them personally.
GIS support in MySQL is actually pretty ok. Many times one has to work with one is given.
Aiming for Science, so definitely professional quality graphs and data, not so much cartoony. Some code examples for those already published in top journals would be great.
I really like Pyramid. - Flask is cool, and I get it's a micro framework but having an option to get some scaffolding out of the box would be really nice. - Django is great, it really is. But I like SQLAlchemy and loose cupled frameworks. - Pylons rocks, documentation was a bit weak, but all in all great framework. So yes, we need more Pyramid exposure, it's a great framework.
I think #2 does have some importance, particularly in the context of the "small bespoke website". There's often no long-term hosting or maintenance contract, or the client eventually realizes "I should control the site in case I fall out with the firm."
I've been putting BeautifulSoup through its paces lately and finding it very useful
QR Codes suck! Thanks for the effort though.
Hey, put up a NSFW when you post something dirty! I mean in general. In this case, you don't need one, obviously.
I'm going to leave you with [a list of some python libs](https://gist.github.com/797129) I've been gathering over the years. Star/fork/comment.
Wow, that's a pretty cool feature! Now I don't have to do docstring formatting :D
And you've helpfully provided a link for us to see this guide? ;-)
Did you look at the source code in the link? It is inherently insecure here because it just uses the default string representation inline in the SQL.
Thanks for the tutorial, it was well written and informative!
I would be very much interested, but could you please specify a use case for the pyramid framework (perhaps in your introduction?). I see phrases like "x is a webapp framework" and I'm still not 100% sure I understand exactly what that means. I *think* pyramid is something I might want to use in the very near future, but I'm not a professional developer and sometimes the jargon is lost on me. tl;dr: Please don't have us building abstract services without any context. It would be nice if you formatted your tutorial as "Today, we're building X", where *X* is a functional, real-world application. Thanks!
I'm still trying to understand the basic idea behind all these frameworks... I tend to get confused by the jargon =) If I understand correctly, Flask/Pyramid/Django are all web frameworks, meaning that they're a replacement for the traditional server-side number crunching (which usually relies on PHP, correct?). Furthermore, I understand this to mean that these frameworks *can* serve webpages, but their usefulness doesn't stop there. They can be the backend for any data processing with remote clients. Am I missing anything? Also, I'm rather experienced with python, but I don't know the first thing about web development. I don't think I've ever even used a socket. Which framework should I start with? If I'm reading your previous comment correctly, I'm guessing Django?
Yep Django for beginners. Later you can try the others and see which is best for each project.
Frameworks provide you with ready made functions, classes, convections, tutorials to speed up the website building process. In the end a framework is just python code. Traditional server-side number crunching can happen in any language (php is just the most used/deployed). Yes they are backends for any data processing with remote clients, for example you can build a rest api with django/flask/python/php and connect it with a mobile application transfering data with xml/json/whatever. If you don't know you should learn first a little html and css before diving in the framework. 1 tutorial is this: http://learncss.tutsplus.com/
Your institution might well have some material about this. It's in their interest that Science takes your paper. It's definitely worth asking them to point you.
Why do they suck ?
I was more thinking they should be able to give you design tips about what the final graphs should look like (eg. how many pixels wide should a line chart be) and that gives you a target to work towards in either photoshop or matplotlib. 
Well technically this wasn't a tutorial on building a specific application but instead just getting the pyramid framework installed and setup for deployment of whatever kind of web application you would like. This tutorial allows a developer to run one script and be ready to develop right away.
All these are entirely objective reasons and completely technically orientated. *Oh wait*...
ok, when I compare `gunicorn` config and `mod_Wsgi` config, I feel `gunicorn` more pythonic. `mod_Wsgi` complexity is due to apache. 
Thanks for pointing this module out. Pretty neat.
This is really well written. Easily the best intro to creating python packaging that I've read. Thank you!
Yet another nebulously defined term.
Wow... thanks! :]
&gt; The problem is: the delay didn’t indicate that Python isn’t interested in my help. It proved it needs my help very much. This is entirely true. It can take a while for someone who has commit rights to consider your patch, verify that is actually fixes the problem, and then commit it to the 2.7 and 3.3 series. This is especially true for languishing parts of the standard library, like IDLE. Despite these delays, it is satisfying to know that the next version of Python will work a little bit better.
Can't vouch for this at all, but the first thing which springs to mind is FUSE, e.g. http://sourceforge.net/apps/mediawiki/fuse/index.php?title=FUSE_Python_tutorial
Seconded. I'm one of the principal developers of PyFilesystem, so feel free to AMA.
how does it currently handle unicode path names, and why still svn?
Understandably this probably won't work for your needs because of the rather large dependency. I think [Django-Storages](http://django-storages.readthedocs.org/en/latest/index.html) does exactly this. Perhaps you could at least use it as a reference.
Do you find it really saves time over just building the Objective-C version in the first place? I remember (boy am I dating myself) using Ratfor to build a system - it was great when it worked, and a royal pain to work backwards into the original source when it didn't. Thus the question.
Yes, Python is much more expressive and productive than Objective-C, even for desktop apps.
 $ python -m this &gt; zen
You've convinced me - I'll try it!
Nice, just like to say thanks for pyfs, very nice software. We use it mostly for abstracting S3 and DAV access. 
Is this really what's needed? The question seems to be asking for a common interface to storage, whereas FUSE would allow you to create your own file system and mount it as a directory.
Is `this` a python module? What does it do?
The advantage of your way is that it works for Python 2.
If there are FUSE filesystems for SFTP, S3, cloudfiles, etc. then you wouldn't need a library to abstract any of them, you would just use normal file operations.
Use FUSE. Then you don't need an abstraction in your own software but instead you just use the file system.
At home: iMac 27" 2560x1440 single monitor (laptop open as well) At work: said 17" Dell Precision Laptop 1920x1080, but usually hooked to 27" Dell 1920x1200, and 19" dual 1280x1024 I have a 23" Samsung 1920x1080 that can either hook to the iMac, the Dell, or be used as a TV.
Interesting, I didn't know about the `Ellipsis` singleton before.
In the linked "zen of python by example" file, it looks like it's recommending against use of both sqlalchemy and twisted (two of my three favorite libraries; the third is pypy). in twisted's case, it's recommending use of gevent (greenlets), which are highly non-zen-of-python (explicit? what's that?). I'm not sure I buy this guy's explanations. Has Tim Peters ever published examples of what he meant? *that* would be an interesting read.
I upgraded my viewsonic 19" (1440x900) with new Samsung 23" HD, and the difference is huge :)
 a, b = b, a *Jaw drop.* That's awesome. But it would create two tuples first right? Essentially making it slower than a temp variable I'd assume.
Is it, let me clear it. `mod_wsgi` config is pain in the ass. `gunicorn` is straight forward. 
Linux, text editor, Firefox, and a few terminal windows, and the nicest keyboard and largest monitor I can afford. Enough RAM to compile PyPy without swapping. I stick to desktops, otherwise I find the line between work and home starts to blur, and work starts to happen on the laptop in front of the TV. I use a bunch of virtual desktops, and prefer a single large monitor rather than a dual screen setup. I'm spoilt at work with a 30" 2560x1600 monster, but the 24" I have at home is more than adequate. I use the lovely DasKeyboard, with a Dvorak layout.
Seconded. Having your graphs in a format that can be easily edited in Inkscape when you realise you spelt the axis label wrong or when an elderly supervisor insists there is no difference between cyan and blue is a lifesaver.
Only cloud 9
Ugly, hard to work with from user's perspective (you need a smartphone with qr scanner app), take a lot of space, nobody fucking uses them, most people don't even uderstand them and again - they're ugly.
I don't get it, care to explain?
Horned or unhorned goats?
Prepared statements are, apart from other benefits, supposed to solve the issue of having to quote your input. Prepared statements send the values separately from the SQL so no injection is possible. So, yeah, what MySQLdb does is quite dumb and that's why OurSQL has been preferred for a long time.
That looks very promising, and may be more useful than I had imagined Fuse could be. I'll have to take a look.
Hacker news has a monthly job posting that typically has 50-100 python positions.
The expressions `....__str__()` and `str(...)` are synonyms, they call the stringification method on the `Ellipsis` instance, which returns the string `'Ellipsis'`. From there on it's just some string joining and slicing: &gt;&gt;&gt; 'Ellipsis'.join('Ellipsis') 'EEllipsislEllipsislEllipsisiEllipsispEllipsissEllipsisiEllipsiss' &gt;&gt;&gt; 'Ellipsis'.join('Ellipsis')[::8] 'Esispill' &gt;&gt;&gt; 'Ellipsis'.join('Ellipsis')[::8][3:] 'spill'
http://careers.stackoverflow.com/jobs?searchTerm=python&amp;location= https://jobs.github.com/positions?description=python&amp;location=
Startups need rockstars like bands need Python developers.
Pretty much anything that isn't monster or monster affiliate. Monster is pretty much just head hunter spam. 
no, but if its one of the uncommon ones i reserve the right to mumble about having to install weird things i never had a good experience when giving stuff back to a svn using project (its not even sanely possible to manage authorship in svn when committing patches by others)
I don't get the impression that the author recommends against the use of sqlalchemy. In one example it's obviously way more complex to use sqlalchemy than just dumping the dict to json, however, compared to using MySQLdb sqlalchemy is a clear winner in terms of reduced complexity. I think this makes a lot of sense.
I got mine from an ars technica listing
I am new to Pyramid and its dependencies but if you pip install Pyramid it installs Zope because it is one of its dependencies. Unfortunately I don't quite know what it does.
If you're in Canada, try [Workopolis](http://workopolis.com). The advanced search lets you search for Python as a keyword.
Hi there! Interesting article, but maybe you should get someone to proofread your entries for you: * "As you know the reasons for that. " ==&gt; "And you know the reasons for that." * "So I chose it without any doubt" ==&gt; "Without thinking twice" * "it is an over killing for blogs " ==&gt; "It is an overkill for blogs" * "Main issue is with speed of page rendering" ==&gt; "The main issue is the speed of page rendering" * ... There are **a lot** more of these small examples where your English sounds a bit "off", as if it was machine translated. Many of the idiomatic expressions are slightly off. I hope this does not come off as condescending, but maybe you should think about working on your English :)
Who cares. Properly formatted text is low on my list of things to do. Get a life.
And I'm very happy I don't have to debug your code. Practicality beats purity for whomever's writing the code. For everybody else, it's a fucking nightmare.
The key is randomly generated client-side -- it's the hash part of the URL (everything past the #.) If you try to load a page with the hash removed, you see the encrypted version as the server sees it. Since the hash part of the URL is not sent to the server as part of the HTTP request, the server admin can never know what's in a paste even if they wanted to, nor could anyone that managed to steal the site's data. But the site still operates as a regular pastebin-type site in that you can give anyone the URL and they'll be able to see it. I suppose the reasoning here is - The site owner is prevented from being liable for the contents of pastes, since they could have no way of reading their contents. (Although they'd probably have to accept takedown notices for bad content where the reporting party provides the full URL with key.) - The site users don't have to worry about the site owner (or a third party attacker that gained access to the site) being able to remove their content or spy on it. However, I wouldn't want to test the legal waters by hosting such a site. Apparently, based on a recent string of closures by paste sites, these things are attractive to people who upload all sorts of bad things. While in theory this would shield the operator, it would also make them a target for people wanting to post bad things. My only complaint is that the site just hung indefinitely when I tried posting a ~400KB text file. It wasn't even using a bunch of CPU, the progress bar just stopped moving and never recovered. 
&gt; If the API expects you to escape the data and convert it to an SQL-safe string yourself It doesn't. It escapes the data for you. It just uses its own implementation of this, rather than MySQL's bind parameters.
The server could potentially fetch the fragment identifier with a tiny bit of JavaScript (`location.hash`). 
Just hit http://localhost/index.html#blargh with curl and chrome, and in both cases, never saw blargh in my apache access logs. I suppose to be really sure I could fire up tcpdump or wireshark, but I'm willing to believe it. Neat!
Hello, I think this comment is a good summary of the pros and cons of our tool. Thanks for reporting the size issue. This is a very young project so we will discover more of them. If you ever have the time, please report this (https://github.com/sametmax/0bin/issues/new). It will prevent us from forgeting about it. Attaching the text file you used and some information about your webbrowser would prove useful. 
http://pyvideo.org/video/880/stop-writing-classes A colleague of mine once said something similar but put it "stop writing Python like you're writing Java". 
I've never coded in Java. Hopefully I'm safe... EDIT: ... but I do love to use classes =/
Don't be so sure: $ echo yay &gt; foo.txt $ cat foo.txt &gt;&gt; foo.txt $ # watch your disk fill up
Again, the purpose of the tool is to protect the host, not the user. So that's not a flaw.
PytyhonAnywhere dev here, just wanted to say thanks for posting this! Much appreciated :-) 
a single use message: http://tinyurl.com/cfs8des
very cool utility by the way
My pleasure. Thanks for a great service.
Yep. Javascript encryption is in no way secure. It's a [SEP field](https://en.wikipedia.org/wiki/Somebody_Else%27s_Problem) for the guy hosting 0bin.
&gt;Learning the culture that surrounds a language brings you one step closer to being a better programmer. One thing to note about the culture surrounding Python is that they're a bunch of know-it-alls who hate play, and hate playful exploration. Python is a language in which you must do everything completely right and by the book, or you will have your ass handed to you by 50 different people for daring to stray outside the lines. I like Python, but I do not like the culture around it at all. Every question you ever ask, be prepared to have at least one, but usually more people say "That's a terrible idea. Don't ever do that," or "Why would you ever want to do that?" If you ask a generic question, you'll always be asked for sample code, even if the question is very simple, because it makes it much easier for everyone to tell you why everything you're doing is wrong.
Awesome, I really dig it and its appearance. If I had to comment on anything at all, and I'm really being picky here so it's not even important, you should align the quote with the paste-form div. http://i.imgur.com/CUXKW.png Again, not important at all. Only thing I noticed that seemed out of place.
They feel familiar if you write OO code all day long in other languages (not Java in my case, objc). I have a python side project at the moment that did have a class-without-purpose, most of the stuff in __init__ could just as easily have been global and the only actual method was a callback from pycurl, but it felt familiar and the code worked. Refactoring it the other day to use Tweepy instead of pycurl resulted in that class becoming a subclass of something else that requires one anyway though.
;-)
Writing new code instead of using the stdlib. There's a lot of stuff in there, much of it very useful in solving everyday problems.
We (IPython developers) are also grateful to the PA team for providing the [Try IPython](https://www.pythonanywhere.com/try-ipython/) page.
I could not agree more. For me the biggest thing (that I still fail to remember so often) is to know itertools and functools (to a lesser degree as sometimes they are not the best tools) like the back of my hand. 
I'll have to start taking that approach. I usually write a function and then immediately say "Hey, this would be nifty in a class". Apparently I shouldn't do this. In fact, [here](http://code.google.com/p/pypamplemousse/) is a google code page for a poject I'm starting work on. I would *really* appreciate architectural or style critiques if you or anybody has time. The code is mostly borrowed from a tutorial. THe main work I did was to refactor it into OO design.
Are you perhaps talking about the #python irc channel? Because yeah, the culture there is as you describe. Perhaps you should try your luck elsewhere if you don't like this attitude (I myself don't like it either but the advice given there *is* sound). Mabe usenet's comp.lang.python newsgroup will suit you better?
Granted. But I'd consider that a far worse offence than not fully grasping booleans!
Very cool stuff. I just did the try ipython page sample. Can you explain a bit more about how this would be used by someone like me? How does an interpreter be used by a dev like myself? Thanks!
I went through some code I had written a couple years ago, to find that my coworkers had begun modifying it after I left the team. They couldn't figure out the concept of variable scope (apparently) and wrote a method to search for variables defined with a certain name "in any scope" I'm still at a loss for the words to describe how brain-achingly stupid this was. (Oh, they later decided to rewrite this code in java because for some reason the python was "too slow")
Very helpful thanks!
Or they could just not actually encrypt it..
Note: While a nice idea, this isn't actually secure in any way and you should not trust it for your secret plans or whatever.
A bit of a subquestion: Is it reasonable to possibly return one of two types given the same input? An example: I'm doing a lookup in a classes table and if a value is not found, None is returned by the method. If a value is found, it is returned. Normally, I would approach this by asking `if value in this_dict:` prior to preceeding, but in this case, it isn't feasible. The other option is raising an exception, but I don't see that this is an "exceptional" situation. Opinions?
 dict.get() That's what it's there for.
Error Paste could not be saved. Please try again later. Concept is sound, I guess.
You should inherit your objects from object so you get new-style classes.
I was talking about various forums. /r/python is the friendliest of the lot. I've been presuming it's just the loud ones who come in for a fight, and that perhaps there are many other more temperate people who don't tend to reply, but it's given a sheen of a-hole to the whole land of Python users for me for the past 3 or 4 years. It's not as bad as the old Perl users, though :)
Generally, I'm impressed by code that is easy for a rookie to understand. A lot of people reach some degree of fluency with python, and then go mad with power when they discover all the crazy shit you can do. That's no good. Python is all about writing code that will make the maintainer's job easy. Anyhow, these are some of my favorite python habits: * use enumerate rather than x = x+1 inside loops * yield elements one-by-one rather than building a big giant list in memory * The abc module makes it fun and easy to test for interface support * context managers and decorators each are good ways to wrap code (for different reasons and with different results). * Use dictionaries that map tuples to callables rather than gnarly nested conditional clauses. * pdb.set_trace and pdb.post_mortem. learn them, live them, love them.
I swear I've read the big SO post on decorators 100 times and I *still* have trouble understanding it. Maybe it's because I don't have a use case in mind? &gt;Use dictionaries that map tuples to callables rather than gnarly nested conditional clauses. I implemented callbacks in a dictionary once and I was very proud. The best part was that I used dict.get() and returned lambda: None to emulate a default action if the case didn't match anything known. I'm still *really* proud of that one, even though there's nothing particularly fancy about it.
Oh yeah, the most important thing -- how easy is it to load and run your code within an interactive python session? In other words, can it be done without spinning up half a dozen framework instances? Is your code littered with references to globals that get defined during some other poorly-defined step? Will your imports work right if I'm not in the same folder as your code? I'm convinced that if you don't spend at least some time in the interactive interpreter every time you work on python, you really aren't getting the power of the language.
Thought of a real-world example. Imagine a decorator that wraps the inner function in try:...except: pass, so that no matter what goes wrong, the function won't crash the system. Use it like this: @diaper def f(): 1/0 That should just return None, not raise a ZeroDivisionError.
generator expressions too
Mostly, new-style classes make it easier to call super(YourClass, self). And there's some other weird gotchas here and there. 
Ok, cool. I also just saw that old-style classes will be dropped soon enough. That seems like a good enough reason to go all new-style on everybody's ass...
Actually, I think I write very readable code, but to each his own. Also, I disagree that adding `from [subpackage] import *` in an `__init__.py` makes debugging difficult. If you're using the python prompt (or even better, ipython), the interactive help function lists the path where the function is *defined*---not the namespace it's called from. 
Years later, I'm still finding out there's stuff in the stdlib I didn't know about. (It's not always named quite what I'd expect.)
I've been programming since I was 7 and I never did anything like that and never understood why other beginners were doing it. I mean, they would never do the equivalent in natural language (tossing saying "if it is true that" where "if" would suffice").
 return bool(something())
They're long gone in Python 3.x. 
&amp;#3232;\_&amp;#3232; Dammit.
just use whatever is simplest/most understandable.... If None is non exceptional and the callers are aware that None is possible, then return None... 
One thing that bothers me about this module is that, if you look at the code, it uses hand-coded ROT-13 rather than the .encode('rot13') method of strings. A patch was committed a few years ago but it was rolled back.
if you mean only pyramid and TG: both pyramid and turbogears are built upon pylon. They both are full stack frameworks. I am not sure but there are talks that the next version of TG will be merged with pyramid and it might be named orion. There are many similarities, the only difference is from a learner's POV is that TG has a steeper learning curve than Pyramid. if you mean TG and other full stack python frameworks: i have been doing a comparison of all the python frameworks, i am coming up with a post very soon. for now django undoubtedly is the best. More in my post. 
Behind story: I used to want to add polymorphic methods to existing types including built-in types, classes defined by others and classes that are not natural to contain these methods. Initially I had written methods like: def typequerying_method(value): if isinstance(value, basestring): return something elif isinstance(value, thirdparty.Something): return something elif isinstance(value, Something): return something raise TypeError() Of course that was horrible and especially hard to add types. I had begun to maintain a `dict` of types to functions, and such methods showed me a *pattern*. It was written to avoid copy-and-paste a single file named `visitor.py` from my old projects to my new projects every time. Thanks!
Yes, that's one of the possibilities that I mentioned, but the processing of the request would have to occur twice unless I cached it. That would require additional complexity whereas returning `None` is quite straightforward in this case: class ProcessLookups(): def lookup(self, value): # Do some processing and try to find value, else return None if __name__ == '__main__': process_looker_upper = ProcessLookups() looked_up = process_looker_upper.lookup("find this, or don't") if looked_up is not None: # Do stuff else: # Don't do stuff. Pretty straightforward. If I understand Exceptions properly, there is some overhead. `StopIteration` is built into iterables and so we don't have to use `try` / `except` blocks (for-loops catch it, for instance), which I would require in this case. Recovering from an error takes extra processing, and this is one of those times where I expect a large number of failed lookups. In error handling, I've always been told that you use error handling if you expect that things will proceed without error most of the time. If you expect there to be lots of situations where errors would occur, you check. Look before you leap vs. asking for permission if things go poorly.
&gt; A lot of people reach some degree of fluency with python, and then go mad with power when they discover all the crazy shit you can do. I went through that exactly. What's worse, it's still fun, so I made a deal with myself: I get to use magic in my testing and straightforward and easy to read code in the rest. It keeps me doing test driven development. Who *doesn't* want the dessert first?
Here's a use case for decorators that I'm all about since it saves Python users from having to use getters/setters and still maintain a steady API. Let's pretend that we have designed a class, `Foo`. Now, `Foo` has a variable, `bar`: class Foo(): def __init__(self, value): self.bar = value That's well and good, and everything works as expected, but what if we suddenly need to do some extra processing on `bar`? We don't want to change our API or the users of our class might get angry at having to change their code. This results in the use of getters and setters as a preventative means, but we're Python users and we don't want to have useless methods: class Foo(): def __init__(self, value): self._bar = value @property def bar(self): return some_processing(self._bar) The `Foo` class will continue to serve the `bar` variable with the processing and our API stays the same. The `property` decorator will cause the method to pretend to be an attribute: test = Foo("Baz") test.bar # =&gt; "Baz" Of course, the example doesn't handle setting, but the `property` decorator will handle it if implemented slightly differently. It's builtin, so `help(property)` will tell you more. For me, decorators clicked when I realized that all they were doing is calling a function on a function: class Foo(): def __init__(self, value): self._bar = value def _process_bar(self): return some_processing(self._bar) bar = property(self._process_bar) Oh yea, I don't like getters/setters in Python. They're [almost] never necessary.
I've been following this methodology to a while, however it's gotten to the point where I sometimes avoid classes so much that I end up nesting functions within functions in one file when it should really all be in a class.
Until you run into trouble.
Would you mind elaborating on this (or pointing me to a link that does)? I'm a vim user who's just starting to learn Python and I've been looking for better ways to integrate them, and I haven't learned anything about IPython yet. What does it allow you to do in terms of interacting with a running program?
Well, so far as the plugin goes, I select the code that I would like to run, and use the keypresses that I've defined to send that code to IPython. If you've not used IPython before, I suggest you pull it in now. It's the most fantastic environment for Python experimentation and exploration that I've ever found. The plugin for vim to interact with it can be found here: https://github.com/ivanov/vim-ipython Also, the `%run` magic in IPython will run your script and IPython will hold any resultant objects in the `__main__` namespace, meaning you can interact with them: #Testfile.py class Foo(): def __init__(self): self.attribute = "an attribute" if __name__ == '__main__': x = Foo() Now we go to IPython... In [1]: %run Testfile.py In [2]: print(x.attribute) Out[2]: "an attribute" In [3]: new_foo = Foo() In [4]: new_foo.attrib = 23 And so on. Also note that you can use unix shell-like commands like `ls` or `cd`. Edit: Formatting
You can't do Yoda style without a comparison: if True == something() But don't kid yourself. While it is a waste of code it is simple to understand and not really a big deal.
Which is not correct: `bool(2000) == True` but `2000 != True` edited to remove the bool(1), since `1 == True`. An interesting detail I'd never seen before.
If your `something` function can potentially return both strings and booleans then there's a good chance that it's not a well thought out function.
Hey towelliee, i have a quick question for you, for a long time you were in support of a guy named Brotatoe. Then i took a break from watching streams and focused on school and things like that can you please give a quick explanation on what happened to that guy?
True, but I've seen some fairly scary list comprehensions where it would have been more readable to break it out into a few more lines of code.
If your class is going to be a singleton, what's the advantage over a module level global?
It's not a big deal. In Python 2 some little things like properties go wonky if you don't inherit from object. It's just a glitch in Python 2 more than a deep philosophical difference unless you're a deep Python internals ninja. 
You haven't actually tried that, have you? 
^_^ I messed up the cache check for the paste directory creation. I couldn't see the bug without having a lot of people using it. You know what they say, release early... It should be fixed now. Thanks for reporting this.
Same as above. Sorry about that, lazy as we are, we didn't write unittests, so you are our guinea pig I guess :-)
I'm repeating myself but it's important: 0bin is not built to protect the user, it's built to protect the host. You should not store secret on it. It's encrypted to avoid people to force the host to moderate his site content.
You can't trust JS encryption for this. This is why we do not advertise 0bin as a place to keep your secrets. Please read above.
The appearance is free for all to use: http://twitter.github.com/bootstrap/
More than free, bootstrap comes with a whole bunch of tools that make designing a prototype a breeze. it's a must use !
Cool thanks! That will help.
well it's not much to go on: http://www.tiobe.com/index.php/paperinfo/tpci/Python.html there was a big write up when it took a 3.5% dive a few months ago. of course it's not much to go on and not very accurate anyway, but i believe it has to do with a strong push for python3.
I'm not saying you are wrong, or that I am right - I understand the idea. I just don't see the use in a system that wouldn't fit the end user's need. What's the point of hosting the service if it isn't going to be used in the first place (due to security implications).
Ok we added a FAQ t address the security concerns: http://0bin.net/faq/ I think this is very good so many people raise these issues, it proves that more and more uses are becomming self aware of the all security thing.
Oh right, I didn't get that. I should mention that the project began with zerobin, the PHP implementation, which was a reaction to this: https://www.zdnet.com/blog/security/pastebin-to-hunt-for-hacker-pastes-anonymous-cries-censorship/11336 Pastebin as been forced to moderate the contents because of so many illegal stuffed poste to it. Pastebin is not encrypted, and it doesn't prevent people form using it massively. But legal threats now make them play the game of censorship. 0bin should be used the same way pastebin is for users. The only difference is that if you host it, we hope the encryption feature can be used as a defense. This is not proven though :-)
I don't worry about stuff like the overhead associated with exceptions, but that is because I mostly work on web programming, where stuff like that is dwarfed by the time my stuff burns waiting on IO. Rather than returning None, you could (maybe not should, but could) just return some kind of sentinel value, like the string "DO NOTHING". So the code might be more obvious: if looked_up is not "DO NOTHING": # do stuff Or you could return a lambda that does absolutely nothing when called, and then you just always run the returned callable. Alternatively, if you keep returning None, you might be able to just say: if looked_up: #do stuff and drop the "is not None" and the else clause. Generally though, this stuff is a matter of taste, and I think that reasonable people often have different preferences.
To be fair, the docs on installing python code rather than just running it are not beginner-friendly. We need to make that better.
There's a [twitter feed](https://twitter.com/#!/Py3K_update), but it's not updated very often. I don't know of any better source.
Yeah, I went on a metaclass bender for a few months. Sure, the code worked for its initial purpose, but it was hell for me to debug or extend, and absolutely impenetrable by colleagues. I like your idea to get wacky in the testing layer, but keep it simple in the core. That's good advice. So much of testing involves boilerplate setups and teardowns, some code-generation tomfoolery is well-deserved.
It depends on your use case, but if you need to confirm that something returns True you should use `if something() is True`. If something returns 1, `something() == True` will evaluate to True, but `something() is True` will evaluate to False.
this is very true.... I'm recovering from a phase of writing five to six levels of nested list comprehension. Needless to say some of the results were quite unreadable, abet most concise.
If you are a dev that has to get their hands dirty in production, ipython is a life saver. See, typically the support staff will want you making all these admin tools to support the application in production. These tools are always ill defined and never feature complete and can pose a security risk and in general, largely a waste of time. BUT, if you have ipython, you can pretty much do everything you need to do in production. Scenario: Someone reports someone is having some issue, but they have no idea what's wrong(typical vague bug report scenario) and it needs to be fixed asap. ssh to the environment and open up ipython turn on logging(%log) and start loading data and poking around to figure out what the problem is. When you quit ipython you will have a log file sitting there of every statement you ran, often I use this as the basis for a script to keep around just in case a similar problem comes up. As time goes on, you will begin to notice that you are doing the same thing over and over again and the tool you need to build will be obvious. But build the script for you, don't try to build a webpage to do it, generally the problems are so adhoc that you can't begin to put that into a webpage, and it is a PITA to try to keep that in sync with all the features that are going into the app you are supporting. Just build up a bunch of scripts to help you fix things, eventually they can get to a point where you can give them to the production support staff to run. I personally use ipython as a front end to our appengine apps via their remote api, and it's been really handy on several occasions. Like last week, someone in sales left the company under less than friendly terms and the demo version of the application was vulnerable as everyone in sales had the same password for the demo users. So all those needed to be changed immediately. Do I spend weeks writing a tool to do it? Or connect to the app and type 10 statements to get it done in 25 minutes while sipping a margarita. I opted for the margarita, and had it done in 10 minutes. Today I'm cleaning up GBs of junk in the database that was left by a mis-configuration in one of the environments. Next week I will be using it along with some prepared scripts to change the schema from old to new as we roll out a new version of the product to customers. Sure you can do the same thing with the plain old python interpreter, but completion, logging and command history and the ability to drop into the debugger on error help you diagnose/fix those unexpected problems efficiently and fast. 
Curses, foiled again. The only thing that still holds about what I said is that reassigning to bool types is no longer possible in 3.
Properties and getattr/setattr are meant to solve different problems. I suppose you could use getattr/setattr to implement properties, but there are a lot of things getattr/setattr can do that properties can't. 
There's a website partially maintained by Kenneth Reitz I believe which keeps track of the larger projects that add support.
Sometimes there can be an interesting balance where the crazy shit python enables you to do makes some things easier for the rookie to wrap their head around. Take django's use of metaclasses in models, for example. Django does some crazy magic behind the scenes, and God save the rookie who had to debug that. But the result is that a rookie can create and use code more intuitively, so long as they don't have to care about the magic behind the scenes. 
How does this compare to the [simplegeneric](http://pypi.python.org/pypi/simplegeneric) library?
And ninjas. "Ninja rockstars" are probably OK though because it means that the company has a sense of humor.
depending on the situation, using collections.defaultdict instead of dict.get() might be more appropriate.
Yeah, I agree 100%. But in practice, I've seen a lot of code that uses __ getattr __ that could be rewritten to use properties. And I prefer properties because I use dir() all the time to inspect objects. 
Frankly I had not known `simplegeneric`. It seems to share equivalent features and the same limitations as well except I will fix one of the limitations: &gt; - The first argument is always used for dispatching, and it must always be passed *positionally* when the function is called. TypeQuery 2.0 will provide multiple dispatch as well. You would be able to easily make generic multimethods as CLOS or Clojure can do. One of trivial differences is Python compatibility: `simplegeneric` supports Python 2.4+ while TypeQuery supports Python 2.5+. Instead `simplegeneric` does not mention about Jython or PyPy but TypeQuery makes the guarantee these alternative implementations as well.
"Magical" isn't a positive attribute for a software library. A good reason to avoid web2py :)
&gt; both pyramid and turbogears are built upon pylon. pyramid is not built on pylons, it replaces what was going to be the next version of pylons so it is in effect replacing pylons and pylons is pretty much deprecated. Last I read, I believe the next version of TG they are using something home grown for routing and such(as in not moving to pyramid for whatever reason), but I have not kept on that conversation as much. 
That wouldn't match the requirement "Also notice that the order of 'a' and 'b' are preserved in the resulting array, 'c'. " Ie. [1,2,3,4] combined with [5,6,7,8] should never produce a result where 1 comes after 2.
Slightly more generalized variation of the accepted answer which uses a sequence of iterators rather than the source lists themselves, so would work with anything iterable. &gt;&gt;&gt; import random &gt;&gt;&gt; a, b = 'abcdef', range(6) &gt;&gt;&gt; iterators = ([iter(a)] * len(a)) + ([iter(b)] * len(b)) &gt;&gt;&gt; [next(i) for i in random.sample(iterators, len(iterators))] [0, 1, 'a', 'b', 2, 'c', 3, 'd', 'e', 4, 5, 'f'] 
As omginternets suggests above, native code already acts that way by default in the dict.get method. It may not be common, but it isn't unheard of. Edit: get, not git. Version control on the mind.
And what's the site url?
Very cool. Until now I've just been sticking with Python Anywhere and the "try me" version of ipython they have set up. I am excited to get it installed for myself. 
Is that so? On the contrary, that's how Python got popular. Try this: &gt; import antigravity 
all(iterable) returns False if and only if at least one item in the iterable validates as False.
Randomly interleave these two lists using any of the algorithms on that page: [1, 2, 3] [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15] You'll find that 8-15 are pretty much the same every time. Not so random! If you really wanted to do it right, you'd have to split the larger_list into len(shorter_list) randomly-sized pieces (keeping in mind that a "piece" could be 0 elements), then insert the elements from shorter_list in between them. Or something.
The one I always forget to use is: &gt;&gt;&gt; divisor, remainder = divmod(7, 3) &gt;&gt;&gt; divisor, remainder (2,1)
I always trust the advice of developers who, when they do not understand how something works, turn the other side. I really find odd how some people have the ability of turning something stated as a compliment into an offense. web2py is magical (which I take to be synonymous of enchanting) and it is 100% predictable and documented, backward compatible since 2007. It is not for everybody and that is ok. Edit: Here is another place where the word magic is used in a good sense: http://djangopony.com/
&gt; Randomly interleave these two lists using any of the algorithms on that page There's a fair bit of discussion about the very problem you noticed in the answers to the question. *The top answer avoids that problem*. It works by making an iterator for each sequence and then having each iterator repeated a number of times according to the length of each sequence. Finally the new list of iterators is randomly shuffled and used to create the list where items are randomly interleaved but honour their source order.
My bad! I assumed that the edit to that post was a refinement to his original solution - I didn't look at it closely enough. Good stuff!
&gt;so would work with anything iterable You still require `len`though, so you're really only supporting sequences rather than any iterable. Eg this will fail if `a` is a generator. 
Website is not loading correctly in Chrome.
This is one of the few parts of the code base where you just can't touch it. Who wrote it and when it was written ate just as important as what it does. Ironically, thus goes against the meaning of the text.
http://docs.python.org/library/functions.html **RTFD**
Good point. But how would one get a random distribution without knowing the length of the sequences involved?
Ah! Well, it's definitely a good idea, it's just that if the site were forced to moderate or MitM users' traffic, it would be a very simple matter for a government/court to order the seizure of the site and do very little modification to read the unencrypted contents. There's really no way around the issue.
*arg parameter ;) &gt;&gt;&gt; help(dict) &gt; dict() -&gt; new empty dictionary &gt; dict(mapping) -&gt; new dictionary initialized from a mapping object's (key, value) pairs &gt;&gt;&gt; dict({'one': 1, 'two': 2}) {'one': 1, 'two':2} &gt; dict(iterable) -&gt; new dictionary initialized as if via: d = {} for k, v in iterable: d[k] = v &gt;dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs in the keyword argument list &gt;&gt;&gt; dict(one=1, two=2) {'one': 1, 'two':2} 
Surely most people are familiar with these things... it's the standard library *modules* that I'm constantly discovering. For example today I happened across [atexit](http://docs.python.org/library/atexit.html) and [imp](http://docs.python.org/library/imp.html).
That has a problem when the sequences are different lengths. On average the shorter sequence will be exhausted first, leaving the remaining items in the longer sequence. So not a random distribution. 
Or for the operational semantics folks, because `all(s) == not any(not x for x in s)`
No example code, no real preview and no browsable source. Do you really expect people to try this? I bpasted the source for you (it's only 30 lines of code anyway): http://bpaste.net/show/29697/ ~~ ~~ Example usage: &gt;&gt;&gt; L = Loading(100) loading... &gt;&gt;&gt; L.complete(20) ##########&gt;&gt;&gt; L.complete(40) ##########&gt;&gt;&gt; L.complete(60) so: L = Loading(max_value) and then call L.complete(value) every now and then. It will then update the progress bar up to a maximum of 50 characters (although I'm missing the logic of /first/ normalizing to 100 and /then/ back to 50, but whatever) ~~ ~~ Last, but not least: how is this better than, say, http://code.google.com/p/python-progressbar/ or http://code.google.com/p/corey-projects/source/browse/trunk/python2/progress_bar.py ?
 chosen = args[randint(0, len(args) -1)] Would be better written as chosen = random.choice(args) (But this still doesn't give a random distribution for different length sequences.)
was that required? missed that.
it is random but not uniformily distributed (which I think wasn't a requirement maybe I missed that).
I like [fish](http://pypi.python.org/pypi/fish). Despite its name, it can also show an animated duck if you so desire.
someone has a card game as a homework assignment...
Second order logic, that's what.
If you were to simply look under the info there is a link to the github repository with an example.py. So please, read before you start bashing others. Its something I wrote, I shared it. I am not saying its the end all be all of anything. Edit for the lazy: https://github.com/myusuf3/loading 
Wow that second example is straight out of nightmares. Never use a mutable as a default argument. This is a giant troll post right? My troll detector has been on the fritz.
+1 for informing me about pow's z argument.
Here's a blog I wrote about what to do: http://blog.tplus1.com/index.php/2007/06/24/using-dictionaries-rather-than-complex-if-elif-else-clauses/ For simple cases, keep using if-clauses. But when you have some elaborate dispatching, use a dictionary.
I have some functions that look like this def foobar(var1 = '', var2 = '', var3 = ''): dictionary = {'var1' : var1, 'var2' : var2, 'var3' : var3} It looks stupid, but as the code is intended to be read by people with varying python skills, I would prefer not to hide my function arguments with *args and **kwargs. Is there any way I could use this to make creating the dictionary simpler and easier to read? 
Good point. You're probably right about it being more private here, where it will disappear into history, whereas on his blog it would be more permanent. Clearly you've thought about it enough that you're not intending to be condescending. Voted up.
Like this? Simpler and easier to read is personal preference here... I would be inclined to use what you have over what follows as it is far less common to instantiate a dict in the following way particularly when you are guaranteed a certain number of args. Anyway, def foobar(var1='', var2='', var3=''): return dict(var1=var1, var2=var2, var3=var3) &gt;&gt;&gt; foobar(1, 2, 3) {'var1': 1, 'var3': 3, 'var2': 2} &gt;&gt;&gt; foobar('a', 'b', 'c') {'var1': 'a', 'var3': 'c', 'var2': 'b'} 
100% this, when coding you must remember who your target audience is. Personally when I pull code from a tutorial or obscure python module I like to stick the url in as a comment. 
Thanks for the input. I think I'll stay with my original code, on a second look it is the most easily understood. But it does annoy me somewhat, as it looks like I'm pretty much saying the same thing twice. 
This is one of those things everyone makes and it's interesting to see the different paths people take. [Here](http://www.danomagnum.com/files/progress.py)'s the one I did.
Trypython.org does work from windows. I agree with all this stuff. 
&gt;I got greedy and figured random.sample() would eliminate a line. I agree random.shuffle() is better. I kinda wish there were a non-destructive `random.shuffled()` analogous to `sorted()`. Your solution is pretty much exactly what I was going to post before I started reading the comments here, though.
I don't know what you mean by "use references" exactly, but there's nothing special about how list comprehensions treat variables in Python. You probably should study Python's variable semantics more closely first.
No, I'm pretty sure "someone" wants to model the riffle shuffle in order to test its effectiveness in randomization. There's no way that this sort of thing would be required for a homework assignment; just calling `random.shuffle` on the entire deck would suffice, and probably be considered superior in every way that actually matters.
Agreed that readability is somewhat subjective, though I would argue that enumerate is quite idiomatic in python and is used more widely than range for including the index in a for-loop. For me, enumerate is more readable for the same reason you think range is more readable. It would take me a second to look ahead to see why the person used range when they plan on using the object in the iterable as well. And I would also argue that the standard for readability should be to benefit fluent python programmer, not those unfamiliar with the language. I think it's to the benefit of everyone that the novice do the extra research and the fluent pythonista save the extra time trying to interpret something otherwise idiomatic.
I think that `zip` takes some getting used to. It's pretty useful if you remember to use it, but examples like this don't do it justice. A better example off the top of my head is taking a dot product: dotprod = sum(a*b for a,b in zip(v1, v2)) If you have a list of keys and a list of values that you want to match up: d = dict(zip(keys, values)) There's probably a lot more good ones.
Don't read them?
Also there is a neat function that creates iterables of numbers: range(). Very useful!
 for i,item in enumerate(['I','wish','I','knew','this',before']): print(i,item);
I have to admit, I really fucking hate that website solely based on its name. I'm not a prude, but it basically means I cannot forward the information to some people I know.
I hate to rain on your parade, but contextdecorator already exists, with that very name. It's [in the standard library](http://docs.python.org/py3k/library/contextlib.html#contextlib.ContextDecorator) from Python 3.2, and there's a [backport](http://pypi.python.org/pypi/contextdecorator) for older versions. On the plus side, it looks like there's one obvious way to do it. ;-) I'm not sure about the for/with syntax - it seems ambiguous whether the context is entered once, or exited and entered for each loop iteration. A couple of things I would be interested to see, though: - `with` statements (or something similar) that had a new scope, so you could create variables which would vanish when the context ends. - Something like macros, so the context has access to the code body, perhaps as an AST. There are already some crazy hacks to do this, but I'd like a properly supported way.
haha, wow, i reinvented the wheel. this does exactly what my implementation does, except that it has more features. well, i could still refactor this one in a blog post about the basics on how it works ;) i even looked for it in contextlib, but didn’t bother to check the newest one.
&gt; saying "if it is true that" where "if" would suffice" if that then this sentence would make sense.
Also, it's better to use the construct you want to wrap directly: def ret(*args, **kwargs): with self: func(*args, **kwargs) This way it is automatically correct regarding exceptions and stuff (and I'm not sure why the backported version goes through all the trouble of doing it manually; the 3.x version [works as I say](http://hg.python.org/cpython/file/06f21c6e0f2b/Lib/contextlib.py#l10)).
true, didn’t think of `with self`.
Thank you for those - I think I may have come across those before. They are all very useful, but focus on the most download/most dependencies. What I am after is a listing of all new or updated packages that have python 3 support (ie with the classifier noted in PyPI). PyPM was pretty well spot for this. This is mainly so that I can discover new packages that support python 3 that I didn't even know I wanted to program with :D Sorry - I should have clarified that in my original post.
This is closer to what I am after (the activity log especially) - however I wish they had a Python 3 filter on the log (couldn't find anything like it after a quick scan through the docs). Cheers for that :D 
That's counterintuitive to me.
This also looks similar to some of the multimethod libraries available through [pypi](http://pypi.python.org/pypi?%3Aaction=search&amp;term=multimethod&amp;submit=search)
Any Python developers primarily develop on Windows? Now that there is GitHub for Windows, I'm thinking about going back.
&gt; Using seperate operators is actually more concise.. and not really any less clear d, r = 7/3, 7%3 is more concise and clear? Doesn't seem that way to me. &gt; more performant At least for integers, the / and % operators [are defined in terms of divmod](http://hg.python.org/cpython/file/dff6c506c2f1/Objects/longobject.c#l3225), so you'll be doing the same division and allocating all the same variables twice instead of once. edit: [float is too](http://hg.python.org/cpython/file/dff6c506c2f1/Objects/floatobject.c#l618)
I only have the Microsoft Windows SDK 7.1 (includes compilers and linkers, which are identical to Visual Studio's) installed. Isn't there a way to build Python without heavy and large Visual Studio on Windows? Of course, I don't want to install cygwin or MinGW, either.
Well, it's 3 fewer characters, so, yes, it's more concise in that example. And I think it's even arguably clearer in that it's using operators that are well known and heavily used over a function. The only downside is the DRY issue, and that doesn't really seem worth introducing a builtin function for such a specific case (especially since you'll generally need to use them in a form other than the returned tuple anyway). &gt;At least for integers, the / and % operators [1] are defined in terms of divmod, No - they're defined in terms of the l_divmod (C) function. The problem with (python) divmod function is that you also add the cost of function overhead, which is fairly expensive compared to the simplicity of the operation. Ie: &gt;&gt;&gt; timeit.timeit('a,b = 7/3, 7%3', number=100000000) 7.530382532696256 &gt;&gt;&gt; timeit.timeit('a,b = divmod(7,3)', number=100000000) 22.418699237301155 
from something import *
Lots of things can be done with *defaultdict* and a suitable callable.
I've realised that it wasn't just the fact that I pretty much repeated myself when creating the dict, but also that I had about 10 nearly identical functions due to the high modularity of the rest of my program. So with a brainwave coming from you mentioning locals(), i coded def _helper(dic): # do some stuff return dic def foobar0(a = 15, b = 22): return _helper(locals()) def foobar1(): return _helper(locals()) def foobar2(q = "hello", w = " world", e = ".jpeg"): return _helper(locals()) This allows me to clearly expose the variables, but still cuts down on a lot of lines and make the whole program a lot more modular. Helper will get a variable or two extra in some cases, but that doesn't really matter in the programs context. Thanks for the help :) 
Fair points, but I think it's still somewhat of a stretch to claim it's *unreadable*... but oh well.
Perfect. Thanks. Yes I am having problems getting GDAL installed. I am already finding that I am stuck on Python 2.6 on my SL6 Linux server since it is bundled in with the OS and yum seems to rely on it heavily. I want to get to 2.7 but am scared to mess up this box.
Many thanks! I'll try it later. (I don't have access to my PC now)
But Mixins.
Please bear in mind that [a message queue is not a task queue.] (http://www.rockstarprogrammer.org/post/2008/oct/04/what-matters-asynchronous-job-queue/) (Although to be fair, your use case is so simple/non mission critical the distinction will probably not matter.) I would recommend [beanstalkd](http://kr.github.com/beanstalkd/) for your task queue. It is ridiculously simple -- one executable, with a ridiculously simple python interface. It is also a true-blue task queue.
You do that when you aren't sure about the results of an implicit test that is the result of "if something()". This is especially true when you have languages that don't always provide a true/false test to the existence of a value like python does. For example: in VB, some string functions (like, say, Instr) can return a positive integer value, a false condition of 0 and a undefined condition of -1. So you simply can't just test if Instr() in VB, because the function can return a value of "true" even if the actual result is undefined. The same is true for Java and C++ in certain respects. It's this shit that someone learning python that has used other languages has to unlearn. 
Both Radiohead and Bjork would be better with Rockstars. Especially Radiohead. (cue 90's reminiscing... )
It depends. For instr, if instr(value) = False will pass I believe (it's been a while), although this means that it will return True when value is a zero length string, since -1 is the value it will return in that case... 
I used Phenny and it was nice, it can do 2 and 3 for sure, and can activate different modules in different channels for the point 4. I don't remember time functionalities, but I guess you can write a module to send messages periodically. As for the optional points 1 and 2 I don't remember well, I think there was a way to rank importance of threads triggers.
Seeing this [wikipedia comparison](http://en.wikipedia.org/wiki/Comparison_of_Internet_Relay_Chat_bots) it seems Supybot is better than the one I suggested. Phenny doesn't support SSL and multiple networks as far as I remember, as for "command syntax" feature I don't know what does it mean.
[scikit-learn](http://scikit-learn.org/stable/)
You might like ZeroMQ: http://www.zeromq.org/.
[Flask](http://flask.pocoo.org/)
now since you've repeated this answer to half of the comments in this page, we know people are looking for something safe for the users as well, right ?
THIRD language? Someone needs to reassess their priorities.
Okay, this conversation is over. See you around.
It's been over for a while. We both just wanted to "win" it. 
Not sure I understand. I do stuff like this: except ParticularError as ex: handle() except Exception as ex: log.exception(ex) That uses the type of exception to dispatch. Of course you need to raise unique types in this scenario.
Yes, this is why I added a list of safe open source solutions in the FAQ in case people come to 0bin with this in mind.
Well, we all need Clojure sometimes, like after a bad breakup...
On Linux, you shouldn't have to manually install it. Ubuntu/Debian at least have a `python-box2d` package. Run `sudo apt-get install python-box2d` to install it. Other distributions should have something similar. And you certainly shouldn't have to manually install an old version of Python! A simple way for the developer is just to zip up all the Python files you need, and give users an instruction to install `python-box2d` before they run it. If it's popular, you might later want to think about packaging it properly and adding a dependency on `python-box2d`. Proper packaging isn't (yet) very easy, though. I've recently got into it, starting with [this walkthrough](https://wiki.ubuntu.com/PackagingGuide/Python#The_debhelper_way) and going through quite a bit of trial and error. I'm happy to share my experiences if you're interested. There's a project called pkgme which aims to simplify things, but I don't think it's quite complete yet.
Two things, off the top of my head. 1) How exactly did you test this? More exactly, how many times did you test it? Did you use ipython's %timeit magic? 2) The two operations are not analogous. dict.get() looks for a value in your dictionary, returns it if it exists, and returns a default if it does not. if x in dict only checks to see if the key is in the dictionary.
[bravo](http://bobcesca.com/wp-content/uploads/2012/04/Slow-Clap.gif)
Mercurial. Dive into the guts of it. They will learn a great deal about good code, while learning a very necessary tool.
I'd use python 2.7.3 if you can. Are you really sure you can't? I'd be more inclined to help on your dinosaur thing if it was at least using the almost latest and greatest tools.
gods save you god sir, yes
Well I've been working with Python for less than 6 months and haven't use dicts much at all so you probably are more knowledgeable on the subject.
if you do, try this: https://github.com/odeoncg/django-ztask-odeon
I'm really confused by the pricing: * $15 - Contributor + License * $15 - Contributor * $50 - License + "Early Beta Access" * $100 - License + "Early Beta Access" + Chance to give feedback * $100 - License + "Early Access to the Betas" * $1000 - 10 licenses * $5000 - 25 Licenses So I could get a license for $15, or I could shell out $5,000 for 25 licenses at $200 a pop? What happened to buying in bulk?
I may use this line in the future.
I think this will happen regardless. Things have changed a bit since they joined YC, and a video was posted a couple of days ago showing a python and flask project.
This is because they changed their rewards in response to a lot of grousing from the community, but you can't remove old rewards. 
I'm still amazed that some of the ideas they're showcasing have taken so long for someone to actually implement. I don't think IDE's have added truly substantial and useful functionality since... code completion? The [VS 11 changelog](http://msdn.microsoft.com/en-us/library/bb386063\(v=vs.110\).aspx) is almost laughable by comparison (though it's not a completely *fair* comparison).
&gt; TypeQuery 2.0 will provide multiple dispatch as well. You would be able to easily make generic multimethods as CLOS or Clojure can do. You might want to take a look at [PEAK-Rules](http://pypi.python.org/pypi/PEAK-Rules), then... ;-) 
Adaptation and generic functions are equivalent in the degenerate case of an interface with one method, and of course you can implement an adapter registry as a generic function. If your adapter is stateless, then each method of the interface can be implemented as a generic function. So yeah, it does the same job. ;-)
Pyramid is a very well written piece of code, but it's a development tool. How about an end product, like the code that powers reddit? https://github.com/reddit/reddit/tree/master/r2
Survey Monkey?
People are talking about how crazy this is, but how much better than wing pro? It seems like it doesn't have as much 
It is unreadable in the sense that you first read the loop header and it does not tell you what *really* is looped over. The intention is to loop some iterable, not some integers. Of course you and everyone understands it, but it takes a second look down into the loop body. enumerate is also superior for other reasons than readability. For example, if you loop using a generator, you would need xrange(len(list(gen))) which defeats the purpose of the generator.
Thinkpad w500
Of course, I am. If the mentioned article is helpful to some people (and apparently it is) I think they should ~~RTFM~~ reevaluate their learning process. Because most if not all of this stuff is covered in the tutorial and it is or should be covered in the manuals. At least a quick glance through the standard functions couldn't hurt either.
[Clone Digger](http://clonedigger.sourceforge.net/) The source code is far from being ideal and even "pythonic", but the tool is very useful since it helps improving the quality of Python programs. [Leo](http://webpages.charter.net/edreamleo/front.html) General purpose outliner written in Python.
The answer is just one click away. "Will it be open source? I'm a firm believer in open source software and open source technologies. I can guarantee you that Light Table will be built on top of the technologies that are freely available to us today. As such, I believe it only fair that the core of Light Table be open sourced once it is launched. At some level, this is an experiment in how open source and business can mix - it will be educational for us all. What's a license then? In order to download packaged distributions, you'll need a license. Preliminarily, we're thinking licenses will be based on a "pay what you can/what you believe it is worth" model for individuals. This gives everyone access to the tools to help shape our future, but also helps us stick around to continue making the platform awesome. We think what we build will be worth at least $50, and so that's what we've used for our rewards."
Found this https://github.com/wiredfool/Python-Imaging-Library-G4-Tiff-Support.git to be working. It build ok on webfaction but does not build with the g4 support on ubuntu 12.04 :-/ The patched PIL 1.1.6 build and reports full support but making a thumbnail will rise an IOError Decoder zip is not available. Will keep trying tho. 
Everytime I see a cool new editor I want to use it, but my fingers are trained for VIM. Someone needs to start a kickstarter to write a modern vim :(.
Also see In [1]: %run -i foo.py this runs foo.py in the context of the current interpreter session so you can define variables interactively and access them in the script. This is really helpful in gradually migrating more and more code from interactive session to module...
You can remove old rewards if there are 0 backers on that old reward iirc.
Wing pro still treats code as text, and the repl as a separate entity.
What's the point of teaching Python by means of a different language? There are too many of these useless small educational languages in the world. Python is great for beginners, and it's a useful language too.
I don't think the question is unreasonable. It does mean "hard to monetise" for a product like this. If you give coders source, chances are they won't have much of a hard time to compile it and make it work. It's not like you gave your little sister the sources to the latest SIMS game. Some open-source-but-not-gratis products I've seen in the past could without the shadow of a doubt be assumed to had been obscured/made harder to use intentionally in order to be able to monetise them. Or artificially tied to some subscription service. I'm trying my best to come up with a self-contained software package using an open-source-but-not-gratis formula that I'd actually use, and I can't think of any. I guess they will make the core Open Source and they'll add non-open source stuff to it, like Eclipse with proprietary plug-ins. That analogy makes sense. Something definitely usable but with possible extra stuff on top that isn't necessarily Open Source nor gratis, or maybe a SaaS scheme (hope they don't go too far this way, I like my software local). But we will simply have to trust their judgement. But to be completely honest, the editors I like are all either OSS and gratis, or none. This just happens to be the case. Maybe this is the first exception to this rule.
You can probably create a mac application easily enough using py2app. There are similar tools you can use for Linux ([cx_Freeze](http://cx-freeze.sourceforge.net/), [PyInstaller](http://www.pyinstaller.org/)), to bundle up all the files you need to run it. That approach isn't considered ideal for Linux distribution, but it's better than ignoring it. Those tools will hide the code a bit, but bear in mind that there's no way to really stop people getting at Python code if they're determined.
Just because someone wants to write an IRC bot doesn't mean they're making a botnet. If OP is capable of writing a botnet he can probably write an IRC bot too.
It's also the case for other platforms unless the creator is either incompetent or actively sabotages the product so it's not easy to install or use. It's a legitimate problem with Open Source self-contained software. You truly do your job well, you don't introduce lock-ins and you are competent at packaging it: no money (except maybe donations... which may work for some extremely popular projects but definitely cannot be extrapolated to any project, let alone niche projects like a Clojure editor would be, at least initially). I'll be following this project to see how do they approach it.
Sublime 2 can accept vim commands - and blew my mind until I saw Light Table.
The article does not talk about range (except in examples to show when enumerate/zip is to be preferred). Other than that, I agree with you.
A lot of editors and IDEs do, but they never support everything as well as actual vim.
And there will be some form of HTM in near-future Intel chips.
yep
Am I the only one who thinks that project is a waste of time? We don't need yet another gimmicky IDE, regardless of language support... I'm also a little irritated that this project is essentially being funded by the community, yet is being created as a closed source proprietary app.
As one of the people behind this, and a PSF director I am here to answer any questions people might have.
maybe the point is that flask is flexible and un-opinionated, thus if you want to do mvc, you can do it. That's my takeaway.
But how can I rage at the truth? 
If my article wasn't indication enough, I use Windows for most of my work too, although I keep dabbling with Linux
Give [TwistedBot](https://bitbucket.org/Sylnai/twistedbot) a try.
Thanks! I need to pay attention to my commenters on reddit more. Sorry guys!
this is cool. are there any plans to port to osx and/or windows? and if so, could you use the help of a novice-intermediate level python programmer? i'd like to contribute to an open source project
Although quilt was originally written to run on an OLPC the core should run just fine on OSX, not entirely sure about windows though. The only sugar/olpc specific part of quilt is the gui, which is in an unfinished state. Feel free to fork the code and hack away!
This is the same model as transmeta(?) uses for that wine-package that does direct3d, or atleast that was the case ten years ago when i used it =) You could download sources from their ftp or pay for the rpm
Man, the maximum you can get on Lenovo W520's now is 1920x1080. Why did everyone start selling laptops with really shitty resolutions all of a sudden anyway?
Yeah, the whole thing about "evaluating code as you type" I don't see working outside of Lisp, and even then I see it only working for trivial code snippets. I rarely just run the code after I write it. I construct a test case and environment to both verify it's operation and protect against side effects from bugs. I'd never want to blindly run a function immediately after I typed the last character. The focus on ease of access to documentation, and making the interdependency between function calls more transparent is novel and would be useful, but it seems overkill to create an entirely new IDE just for that.
&gt; That doesn't make too much sense now, does it? Sure it does! "SEO" means search engine optimization - many of these people create spam farms and do other spammy things to get higher ranking. FTW means "for the win". I read this off and immediately laughed, and I think a lot of other people did too.
Hahahaha. Love it.
Hahah :D lold
I would avoid IDE's. Though they seem convenient, they are not great for helping you understand what is going on. Better to choose a good text editor, and run scripts either from the editor (e.g. TextMate can send Python scripts to a terminal) or from the Python shell itself. Come to think of it, the [iPython notebook](http://ipython.org/ipython-doc/dev/interactive/htmlnotebook.html) would probably be a nice way to learn Python without having to worry much about editors and IDEs. It takes some effort to install, but then you are just working with Python in a browser window. I find it excellent for teaching.
I think the documentation for some modules already includes links to PyMOTW, adding a few more could be a welcome contribution. Absorbing chunks of PyMOTW and keeping them up to date could be good as well, but it's an effort that might require more long-term participation.
The proposal is a bit of a buzzkill on this point: &gt; The primary implementation language must be Python, though components in other languages can be used. For example, a proposal can use Chef, which is written in Ruby; a proposal cannot use Drupal, which is written in PHP, for everything.
Ten years later vanilla Wine comes with perfectly good DirectX support.
There is no mention of overall cost or being a factor in the selection criteria, which seems kinda odd. What kind of budget are you looking at? Is this something that will keep a small team in the Bay area fed for a few months, or are you expecting someone to have to outsource the bulk of the work to India to offer a competitive bid? Edit: It looks like you spent $3,642.20 for the redesign of python.org in 2006. Is that to be used as a guideline?
Obligatory Emacs mention
Yeah, and who needs gimmicky features like syntax highlighting and auto-completion? I do all my coding in hex, using debug.exe.
I expect they will accept whatever works best for them regardless of framework. 
We're using Debian, which has the same Python 2.6 dependency; we wound up compiling and installing our own Python 2.7, as that gave us the most control over where it went. To get GDAL working, we install the underlying library like this: wget http://download.osgeo.org/gdal/gdal190.zip unzip gdal*.zip cd gdal* &amp;&amp; ./configure &amp;&amp; make --jobs=2 &amp;&amp; make install ...then we just pip install gdal. Simple, but I think it took a few days to work out exactly how to get all of the right versions of everything together...
The proposal seems to be geared towards corporate entities. Are you only looking for commercial interest, or would you be willing to take a free rewrite in the understanding that it comes with no long-term support (but clear and well-documented Python). **Edit:** Found the answer, &gt; Post-launch, we envision that PSF volunteers will perform most future improvements and maintenance tasks; the winner(s) of the bid may provide assistance, but does not carry the primary burden of supporting the system.
We did not want to assign a cost/budget to this as that borders into "spec work" and the designers/firms we spoke to balked at that. Currently we are leaving it open-ended to see what the community will provide.
Ah, right. I ment their model of selling open source software is the same, you could download the sources to Cedega and built it yourself or pay for a package.
Obligatory VIM response
I'm not entirely sure but I think the thing about Cedega was the specific settings for different games to make them work and that you couldn't download these. Could be wrong, though.
I run a small web dev shop that primarily works in Python (we're one of the very few in the Midwest). My concern is that responding to your RFP is going to require a quite a bit of our time and resources. Whereas one of your corporate sponsors (or even just a larger company) can afford to throw a small team on the bid, on the off changes of picking up the project for the prestige. Should us smaller guys even bother bidding? If so, what advantage do we have against the bigger companies?
For Python only, try SublimeRope instead (add SublimeLinter and SublimeREPL for extra points).
Thanks! That's very helpful. I did some searching and people had mixed opinions on compiling and installing a second version of python. I'd like to do it. Will have to look for a guide. Thanks for the GDAL information! Also, I see you're using pip. I have been using easy_install. Does it make a difference which I use?
I run a small dev shop, and I won't respond to RFPs unless specifically invited by an existing client. In all other situations it's a gamble with a low likelihood of any payoff - you could easily go broke winning RFP work.
I'm asking him if it's doable. Do you have children? Do you buy coffee every day? What about eating out? There are a lot of ways to save money.
Sublime has vim keyboard command plugin that's pretty dope. It's replaced vim as my editor of choice for the most part.
The idea is to hold everyone - big firms and smaller firms to the same stick, and not treat anyone unequally. You have just as much a chance as the larger firms, especially if you have strong ties to the community, your proposal is good, and you are responsive, attentive and clued into the community and its feel. Many larger firms will miss that last part - the point is, yes, we're paying for this, but we are still a community driven by the community. We want to support community *members* (meaning, companies using and developing websites in Python) through this, which means faceless big corps who don't have ties into the community will miss the touch we're looking for.
Howdy, neighbor - I'm also an owner of a small Python dev shop in the Midwest (Lawrence, KS). We plan to put in a bid, and yes: it's going to be difficult balancing our need to pay the bills against the desire to give the PSF a good deal. However, I think us small guys are in a good spot for a few reasons: * Being small and living somewhere with non-crazy real estate means our overhead's smaller. * Those big forms you mention? Most don't bother with small-time stuff like this. They don't need the prestige -- they're already successful, remember -- and even at an artificially inflated Big Shot Design Firm price this project still comes out to small potatoes. * Price is obviously a factor for the PSF, but I know quality is as well. I'm fairly confidant that "cheapest" won't be the deciding factor. Oh also: we small guys can team up. Hit me up on email (jacob at jacobian dot org) if you want to help put together Team Midwest Represent.
Go broke? I've seen some crazy RFPs that wanted tons of documentation, designs up front, fly out to give a presentation, etc but you learn to pass on the ones that you have little shot at winning or are so cumbersome that it simply isn't worth it. I would say the average RFP takes 5 hours of work to respond.
How is it mesh as opposed to P2P?
Note: This isn't mine
Please tell me we're not going to see another generic design for programming languages again. Git-scm recently had a redesign, and it really lost its character.
Being a programmer that uses SCM daily, I totally fail to understand how the workflow can apply to the contents of a website. In any case, I suggest that you detail more what you mean by "offline editing", since what I *think* you mean is something that is totally alien to the current web industry; you might want to better specify what you expect to be able to do offline; for instance, some might think that giving you a way of having a local copy of the website, including the backend web interface where you can edit contents, with a separate push+merge step, might be enough, while your comment here seems to imply otherwise.
I guess I'm one of the stakeholders for this given that I update parts of the site, and including an offline workflow just makes sense to me. A great majority of the people working on the site are developers who use source control, so allowing them to use similar workflows to what they already do 8 hours a day seems like a no-brainer to me. Oh, you want me to update all references of foo to bar? Let me work my magic, check it in, then we're done. If I had to do that online and update every page I'd just let someone else figure it out, which would never happen, and we'd just have a shitty site. The current site *only* works via source control -- SVN checkins trigger a rebuild -- so we exclude some people who don't care to use source control or hate SVN. With the new site, we don't want to alienate the developers who like and use offline editing for whatever reason, and want to make the site usable for non-techies, e.g., our administrative staff. A recent change I made on the site was to update the PSF board records. It was a few updates made very simple with a few familiar keystrokes in Vim, and on a page that makes sense to have nice version tracking. Updating the page in an online editor would be a whole lot more manual. On the other hand, adding a news item to the front page such as a note for new version releases seems like a change that would be nice to make in an online editor. Hit some button called "add news item", then type in a paragraph and add a link. Done. Writing something in a text file and later c&amp;p'ing it to complete the task seems cheap to me. We have the technology to support an easier method that most of us already use daily.
Okay. Mesh makes it sound a bit more novel than it is, but I get your point.
You should document your workflow in a blog or somewhere so the next person doesn't have to stumble over the same things. A simple: "here's how to get your dev environment setup for project foo" will result in exponentially more people contributing to project foo.
I don't think the ircops run #python, do they? dash and friends do. I used to disagree with dash on a lot of things, but the more I try his advice, the more I find that he's a fucking genius. I now find #python *the* most useful channel I've ever been to.
So the article doesn't talk about range except when it does? Ok.
Stop reporting this and other LightTable posts as spam, people.
Thanks! That's a great idea. 
I imagine that means that the Light Table team (and others) would be able to charge for closed-source plugins. Fine by me.
The way that a lot of projects are structures is that all the python code is within a subdirectory of the project directory. You can put the tests in a subdirectory of that. / . /myproject . /test . __init__.py . test_awesome.py . test_derpy.py . __init__.py . awesome.py . derp.py . /bin . ... . /doc . ... . README . WHATEVERELSE Now, when you want to run anything, you run it from the root directory of the project, and refer to all imports relative to the root directory (e.g. `myproject.awesome`, `myproject.test.test_derpy`). This makes your code more portable, as you can have myproject anywhere within your PYTHONPATH and the imports will still work.
It's still 50k away from supporting Python with only 8 days to go, we'll see how close it is near the end of the kickstarter.
Set up wordpress on dinsdale, choose a sexy theme, boom, new website. On the plus side, it's PHP. So you won't be tempted to tinker with it. Trust me.
In my current project I just have the source and tests in the same folder. I guess it doesn't bother me enough to change it. There doesn't seem to be any standard practice in the python community, which is disappointing, because: &gt;There should be one-- and preferably only one --obvious way to do it. &gt;Although that way may not be obvious at first unless you're Dutch. Also, I name tests as: foo.py foo_test.py So the tests usually sort next to their source.
this looks excellent. Matplotlib has always been inadequate for real time or interactive stuff. I am constantly doing stupid crap like using SDL or drawing directly on widget pixbufs just because I want some real time plotting. Surely this is better. 
Yes, you can use absolute imports from anywhere within myproject. [PEP 8](http://www.python.org/dev/peps/pep-0008/#imports) recommends you do it this way (absolute instead of relative imports). If you want to refer to a module without the "`myproject`" prefix, you can always just do `from myproject import awesome` instead. Now, in the latest versions of Python you *can* do [relative imports](http://docs.python.org/tutorial/modules.html#intra-package-references). It's just discouraged, and outside of rarer use cases not needed. EDIT: Just to make this clear, when I say "run from the root directory," I mean go to the root of your project directory (where README is) and do something like `python -m unittest myproject.tests.test_awesome`. 
You're right about that. I won't comment on anyone specific though.
I drooled a little. Obviously very excited for python support, hopeful someone will write a module for bash at some point too. 
I'm probably retarded, but every time I try to make this work, I fail miserably. It seems like there are 100 stack overflow questions surrounding this issue, all with slightly different answers, none of which work for me. This has to be the most frustrating aspect of the python world for me. More frustrating than the GIL, which has never caused me a single problem.
The official documentation kind of falls short in certain aspects of this, but the [modules](http://docs.python.org/tutorial/modules.html) document covers most of the workings of the package system. Other useful things to read: [*Importing Python Modules*](http://effbot.org/zone/import-confusion.htm), which is a brief article on how imports work, and [Jean-Paul Calderone's recommendations for project structure](http://as.ynchrono.us/2007/12/filesystem-structure-of-python-project_21.html) which is often referenced when such things are discussed. 
Or at least it did [in 1913](http://en.wiktionary.org/w/index.php?title=pythonic&amp;action=historysubmit&amp;diff=13954313&amp;oldid=11511884).
I think I saw it at $234k yesterday. It might still reach 300k before it's over!
botnet-zombies are never ever written in python, trust me, ive written a fair share of them in my youth days.
Just going to python.org to download python for my mobile device, then I will get to work... oh.
Even better pledge $100 for early access and opportunity for feedback, then you can steer the Python angle more.
The Request for Proposal is heavy on the development side, so it's rather off-putting to anyone considering just the design aspect.
Very cool, tried it out after reading this and it rocks! 
It's only an early prototype to market the concept.
Not in my experience. I don't know how big your datasets are but mine were at most ten thousand points and it wasn't snappy at all. I still used it because it wasn't exactly terrible and it was enough for my hobby project but it kept me from wanting to release my stuff.
[idleX](http://idlex.sourceforge.net/features.html)
See Brian's response: http://www.reddit.com/r/Python/comments/u0wz0/pythonorg_redesign_request_for_proposals/c4rm33r - a good example of an excellent implementation is actually on Github - github allows you to edit files/commit via the web interface while also allowing a traditional SCM style workflow. In my mind this pretty close to perfect
I think status, value = foo() del status should alleviate IDE warnings. You could also returnedValues = foo() value = returnedValues[1]
Portable Python - you can install it on a USB stick: http://www.portablepython.com/ Alternatively, if you have a decent web browser available, you can get a free account with Pythonanywhere: http://www.pythonanywhere.com/
&gt; It's not like you gave your little sister the sources to the latest SIMS game. What makes you think my [little sister can't hack](http://pyladies.com/) the latest SIMS game? 
If you're going to ugly up your code you might as well: value = foo()[1] 
Woooo, I got PortablePython to install from the exe. It seems to be working, thanks!
A word of warning, using isinstance with anything other than built-ins can be misleading and cause unexpected results. Consider the following: you have three modules (a,b,c) under a parent module p. Module b has the following import: from p.a import foo and a function that returns an instance of foo. Module c has the import from a import foo and does isinstance(b.get_foo(), foo). This will return false because the import paths are different which is very misleading as both imports work and are in theory the same object. Which is incidentally one of my main arguments for following duck-typing whenever possible and avoiding isinstance all together. This is python 2.7, not sure if this is in 3.x.
You can copy like you did, but you also need to copy the DLL that is installed at the system folder, e.g., `C:\windows\SysWOW64\python27.dll`. I think the Windows registry entries are not essential.
This question is most often asked by programmers who understand neither. In such a case, your only answer should be "nu" or "I'm not sure, what does wikipedia say?" and let the Internet deal with it. 
How many subplots were you plotting in a figure. Did you share any axis between subplots. I believe the issue is with updating ticks on all the subplots when interaction happens in one axes. 
Depends if it eventually breaks or not :). If the return of the function changed then whatever you do then the call is going to need changing anyway.
Ha, I've been irritated for ages by unused params in event callbacks showing as warnings, so this might be the answer.
Any languages with pointer or object reference have names.
I knew the Monty Python stuff is a ruse. The ancient connections make more sense. :-) 
I just like to think that the routes are the controllers - in the end, they do a controller's job. Making a function/class to load a route like a controller is pretty cool =)
It is much much faster, and still very good looking. I like the api of matplotlib more, but is too slow for interactive use in my case. Another alternatives are guiqwt and pyqtgraph, which also very fast.
I disagree with the article. If the VM provides a new name for the same object, it is copying the reference. It has assignment semantics. Passing an argument in python "foo(a)" has similar semantics to assignment "foosa = a". That's entirely different from referencing a variable or creating an alias to the variable itself. This is a strange concept that doesn't really exist in Python or C, but does exist in C++. I agree that the concept is confusing for users. But the distinction is important to programmers in general. Most modern languages, pass by reference is an explicit option. Even with perl the [value assignment tends to come as the first part of a function](http://www.perlmonks.org/?node_id=149478). *edit: better link formatting
One question about the good looking part of Chaco. Is there anything similar to matplotlib configuration file (matplotlibrc) to customize plots in Chaco.
Somewhat, but they only make about one significant release [every 12 months](http://sourceforge.net/projects/matplotlib/files/matplotlib/). Pretty annoying because bugs can hang around a long time, for one thing. I don't know if Chaco has more frequent updates, but that alone would be incentive for me to switch.
The OP was saying something about a compiler (?) warning, and I wouldn't think using that would stop it.
I guess it's a bit like hearing most of the people who work for the bakery don't eat bread or cookies or what have you.
I can't wait for PyPy to start taking off with full support for NumPy, SciPy, Matplotlib, etc. I use Python exclusively, but MATLAB has a JIT and many optimized, multi-core libraries, which I can't deny make it faster in many cases (e.g. unvectorized code).
Should there be a link?
I don't think they allow for full unloads yet in the Capi using Py_Finalize. Currently we get a segfault on reimport of array.
Nice work :)
At least it's one less bug to (potentially) bite me in the ass one day!
I used TextWrangler on my Mac for a long time. I now use Sublime Text 2. I realize these aren't IDEs, but I wouldn't recommend an IDE for a beginner.
I'm curious why the tests are using relative imports like this. If you've got the source package directory in your python path you can import things in the test code just like you would anywhere else. e.g., ATest.py could have from &lt;project name&gt; import A and then test A
The ability alone to re-position simple stuff like legends would be a *huge* improvement for Matplotlib.
At least for certain operations, it gets a lot of that for free, and so can NumPy by [using MKL](http://enthought.com/epd/mkl/). Furthermore, [sometimes NumPy is faster than MATLAB](http://dpinte.wordpress.com/2010/03/16/numpymkl-vs-matlab-performance/). There are certainly cases where MATLAB will outperform NumPy, but there are a [decent number of things NumPy or Python will do faster than MATLAB](http://julialang.org/) (admittedly that last one is promoting use of Julia which is a MATLAB-ish LLVM-based clone).
Good article, I really enjoyed it. I'd like to see a mention of having a mutable type as a default value in a function. You briefly mentioned that mutable types can be operated on because they are modified in place. An example of, say def foo(bar=[]): bar.append("baz") and explaining what would happen would be good to introduce scrubs to this quirky behavior.
Can someone summarize what this means?
Believe it or not, to a lot of people it's just a number. Probably most people, even.
Cool, another ugly __ thing __ removed.
I'm partial of PEP 418.
You should email the author. I'm sure he'd like the feedback at this early stage of his publication.
You want them hidden? What if they contain important code?
Chaco is part of the Enthought Tool Suite and so it shares its release schedule with that. You can look at the release tags in github to see the relative frequency of release: https://github.com/enthought/chaco Generally I recall a minor release every 4-5 months or so. Enthought has hired more developers recently and there is more development activity happening with it.
Same thing happened to me using Django once. When django works in debug mode, it keeps tracks of querys and stuff in ram. Turn debug mode off if any! Hope this helps.
Eearly prototype or not, the concept is still the same. And, at least for the latter part of the demo, i don't if the idea of showing all files relating to one web request is going to scale when each function involved has more than couple hundred lines. 
okay, call it ugly you like, but where do I put my `__all__` ?
you may find [Dozer](http://pypi.python.org/pypi/Dozer) to be helpful. Get it up and running and throw a bunch of requests at your app and watch which sparklines keep going up and up. This should give you a hint of where the leak is. 
Just a few: - Unnecessary animations - Higher temperature threshold to trigger fans - you can't keep the laptop display off when using an external display - Finder is plagued with bugs - Integer mode doesn't work (audiophiles will know what it means) In my opinion SL feels way more snappy and refined, but hey!, Lion does have some cool stuff.
This is the standard practice for any code that's not using gettext (with gettext, `_` is the standard name for the function that marks a string for translation). If you're not using gettext, feel free to use whatever name you like to indicate "I'm not using this".
The portable python FAQ was pretty lacking, or apparently I have a couple infrequently asked questions. Can you install third party modules? Is it fully compatible with CPython?
Yeah, I think I've explained it to my wife on at least two separate occasions (this year's 4/20 and some year in the past). I think most people aren't really aware of it.
It means that instead of\ from this_folder_has_to_have__init__py.so_does_this_one.and_this_one import fuck_this You can do from any.effin.folder import awesome
I remember starting from an official example that had the kind of interactivity that I needed so I'm pretty sure that I didn't do manual plot()-s. Responsivity issues arose even when I was just zooming or panning my plot with the builtin pan and zoom functionality. Are you a developer? Can you confirm/reject my theory in an other comment below, whether the fact that my plot contained about 1000-2000 graphs (polygons - rectangles defined by 5 points) could have played a part? I guess it's not the same as having a single graph with 10000 points if there are some expensive calls that need to be done on a per-graph basis.
nice :)
I'd quite like to take libClang, some kind of local html search engine and clutter to see how far I could get with it. Not so much I want to be in hock to the tune of tens or hundreds of thousands of dollars from complete strangers, though. There would be no chance of a REPL.
Dream come true =)
&gt; Are you a developer I am the original author of Chaco, although it's now maintained by developers at Enthought. &gt; Can you confirm/reject my theory in an other comment below, whether the fact that my plot contained about 1000-2000 graphs (polygons - rectangles defined by 5 points) could have played a part? Depending how you did it, it's very possible that is your problem. Did you use PolygonPlot, or did you create a few thousand different LinePlot renderers (perhaps via calls to .plot()), or what? &gt; I guess it's not the same as having a single graph with 10000 points if there are some expensive calls that need to be done on a per-graph basis. No, those are very different. Chaco gets its speed from having a graphics pipeline that does most of the data transformation, clipping, and rendering via fast C/C++ backends, whether Numpy or the Kiva rendering library (Kiva is sort of like Cairo). So, putting 10k points through a single graphics pipeline should not even break a sweat. However, having 2-3k individual pipelines that we have to manage at the Python level can easily push rendering speed below interactive rates. If you want to post your code in a gist on github, I can take a look and let you know.
If you want to install packaged Python code from PyPI using an installer like easy\_install or pip (or the new pysetup installer that will be built in to future Pythons), and have multiple projects using different configurations of these dependencies, PYTHONPATH doesn't help you very much. It's _possible_ to install stuff to arbitrary locations using setup.py options like --install-base and then add that location to PYTHONPATH (though even that breaks if you install anything as an egg, or any namespace packages, because .pth files aren't processed in PYTHONPATH directories); but it's a lot more convenient and robust to just create a virtualenv and then run "pip install" without any verbose options. Also, virtualenvs can be used simply by running any script (or the python executable) in the virtualenv's bin directory, which is more convenient and less verbose than remembering to set PYTHONPATH correctly before running anything.
No. As before, you'd need an ``__all__`` for that... which means you'd need an ``__init__.py``... which means that wouldn't work. Relax, your super-secret modules are safe. ;-)
&gt; .pth files aren't processed in PYTHONPATH directories They are if you use easy_install, actually. &gt; Also, virtualenvs can be used simply by running any script (or the python executable) in the virtualenv's bin directory, which is more convenient and less verbose than remembering to set PYTHONPATH correctly before running anything. Another misconception. A script that's installed in a directory alongside its libraries doesn't need PYTHONPATH set to work. There are only two things you get from a virtualenv that you can't do easily with stock Python, and that's: 1. Make site-installed stuff *not* importable, and 2. Run an interactive interpreter without having to either set PYTHONPATH or be in that directory. As far as I know, that's *all*. The rest was doable with other tools. The only reason I even promoted the idea of a virtual Python install in the first place was because I hadn't yet figured out how to make .pth work in PYTHONPATH directories. If I'd done that first instead of second, I'm not sure virtualenvs would actually be a thing. 
For me, this is a damn good reason to switch over to 3.x. . .
In other words the problem is with the installers. I've been watching and waiting for some killer feature to emerge virtualenv, for years now, and it still hasn't appeared. Python has always implicitly searched a script's base directory for modules when executing a script, regardless of where it's called from, so for example: cd /etc /home/me/foop/bar.py (containing "import zag") Will cause Python to look in: /home/me/foop/bar/zagmodule.so /home/me/foop/bar/zag.py /home/me/foop/bar/zag/__init__.py As for installation, well, the UI of those tools for the most part is total junk (and engineering choices highly suspect - but that's another story). For easy_install, if it weren't for the presumptive message about PYTHONPATH that it emits, and its broken egg concept, this would actually be quite a simple task. Instead something like the following works: mkdir foo PYTHONPATH=foo easy_install -d foo -Z cdblib rm -rf foo/*/EGG-INFO mv foo/*/* ~/my-project No magic involved, no import hooks, no 1000 line libraries, etc, and redistribution can be accomplished using.. shock.. built in OS tools (cp, mv, you get the idea). The only problem with this approach is arch-specific binaries, however virtualenv doesn't solve that problem either. Scripts in ~/my-project will execute without any PYTHONPATH configuration. If you want the directory's scripts to appear on your path, add it to PATH, or symlink individual scripts to, say, ~/bin, which is on your path, just the way of the rest of UNIX has worked for the past 40 or 50 years.
Shoulda been the submitted link. Also, who is Nick Coghlan and why is he accepting PEPs instead of GvR?
Love that pattern. I'd be really tempted to call the dictionary "case"...
The real benefit here is virtualenv-like tools can be built without being total bash hacks. I think this is a good thing but there are several superficial reasons why I'm actually not thrilled about it. First of all, "virtual environments" is a terrible name. It was OK, when it was the name of Ian Bicking's project but for a standard Python piece, it's a very misleading name. Every non-Python person you talk to when saying "virtualenv" automatically assumes it's some kind of chroot or lightweight virtual machine. They should be called **silos** or **sandboxes** or something. Those names come with their own baggage, but certainly someone could come up with something better. Next, I feel like if we tried to come up with something from scratch it would have turned out better than just taking paradigm from the good-but-not-great virtualenv as-is. For example, when I have commands installed that happen to be written in python, and they use something like `/usr/bin/env python`, and I happen to have "activated" a virtualenv, it causes problems if that particular Python can't run the program. I will admit that this is really just a much bigger problem with packaging in Python and maybe venv shouldn't try to fix it. If I want to send someone a command line program that just happens to be in Python, it would be great if I could package it up with all of its dependencies easily, something like an egg or py2exe, but built-in, cross-platform, and not terrible. It would have been cool if this new venv was something that when you install a tool from your OS's package manager that happens to be written in Python, that tool is automatically isolated in its own Python silo by default. Maybe this can be used for that if the package managers do it, idk. I'm going to stop ranting now.
Agreed if it's complex, but sys.argv is absolutely fine for short scripts... what's easier to understand? This: import sys try: n = sys.argv[1] except IndexError: raise SystemExit, 'Usage: factorise.py &lt;n&gt;' or this: import argparse parser = argparse.ArgumentParser() parser.add_argument('number', dest='n', type=str, nargs=1, help='the number to factorise') args = parser.parse_args() Use the best tool for the job. Not everything needs massively verbose documentation. Agree with your 2nd point though - that goes hand-in-hand with generally trying to avoid instantiating things in the global namespace (not a hard and fast rule, but...)
Amen to that. Decorators are gnarly -- functions that return decorators are ridiculous.
Just a few days ago I was looking for something like this :D
Agree, probably my biggest issue. Since there are so many commands and different ways people use them, its hard to get the support. All of the vim mimics lack some command that I commonly use, trips me up.
There is a raffle (http://web2py.com/cookbook) and three more days.
&gt;As far as I know, that's all. You also get a convenient way to test your code against multiple Python binaries and multiple third party packages.
Very nice!
Very nice. I like the use of flask to provide a lightweight web-based service. Keeps it light weight and as portable as python.
This is beautiful! And sexy.
In addition, [PEP405](http://www.python.org/dev/peps/pep-0405/) and its sample implementation add built-in support for virtual environments. Support for this would be dandy.
I reopened it myself, I really want to change this and I'll work on this for the next release. Thanks for the feedback.
After you've finished the survey, it would be interesting to hear about what you were testing, what you found, and what sort of code you wrote for it.
Awesome. Good work by the way, you've done a really great job. II'm really surprised that this has been missing for so long 
Should the instructions say "sounds best out loud when you attempt to read it as if were an English word"? I don't think nonsense strings of letters can be just read aloud abstractly but they can be read *as words in a particular language*. I'm fluent in both English and Spanish and in all cases which piece of gibberish sounded best differed depending on whether I regarded the gibberish as using English sounds or Spanish ones. I thought to just pick whichever sounded best of the best English one and the best Spanish one but decided that that might not be what you're after and didn't answer the survey so as to not pollute the results.
Have you tried stack overflow? http://stackoverflow.com/questions/110259/python-memory-profiler
whats wrong with pip?
Stallion is just an interface. "Stallion is a Python Package Manager interface created to provide an "easy-to-use" visual interface for Python newcomers. Today we have many nice distribution utilities like pip, distribute, etc, but we don't have a nice visual approach with these same goals." 
God, I fucking hate CATPCHA anyway. Half the time I get the letters incorrect myself.
Have you considered that you might in fact be half a robot?
Who said half, user halike?
don't you mean? print('おはようございます', 'O HI', 'αβγ')
Yeah, just like you can when using PYTHONPATH. ;-)
If you're using easy_install, then they don't really add anything except the ability to prevent system-wide packages from being importable. But you can do that with a sitecustomize.py if you really want to anyway.
It sounds more like it might be the multiprocessing module based on the comments below. I know Jesse was looking for someone to help him out at least last year or the year before. And the module may be in the core library, but my understanding is that there's still quite a few issues with it. http://stackoverflow.com/questions/9094469/dynamic-worker-pool-management-in-python-multiprocessing http://stackoverflow.com/questions/4214775/reducing-memory-footprint-with-multiprocessing http://www.velocityreviews.com/forums/t685646-multiprocessing-forking-memory-usage.html 
 mkdir foo; PYTHONPATH=foo easy_install -d foo Django==1.4 mkdir bar; PYTHONPATH=bar easy_install -d bar Django==1.3 cd myproj PYTHONPATH=../foo python setup.py test # test my project against 1.4 PYTHONPATH=../bar python setup.py test # test my project against 1.3 rm -rf ../foo ../bar Any questions?
thanks a lot, looks like I'll have some reading to do tomorrow
Possibly, but Textmate's dev really dropped the ball on updating the application, and that plays a huge role in people moving over. 
Most likely I won't use stallion either since I am a CLI guy. But this does not change the fact that this thing is impressive :)
Virtualenvwrapper implements a structured way to manage multiple virtualenvs. Ideally it'd be straightforward to just feed that existing information to Stallion.
 virtualenv env14 &amp;&amp; source env14/bin/activate pip install Django==1.4 python setup.py develop // test deactivate &amp;&amp; rm -rf env14 It just seems a bit easier to `source env/bin/activate` than to muck around with your PYTHONPATH. I'm not sure what the aversion to convenience here is.
Fine, I'll do it in one line. virtualenv env14 &amp;&amp; source env14/bin/activate &amp;&amp; pip install Django==1.4 &amp;&amp; python setup.py develop &amp;&amp; // test // &amp;&amp; deactivate &amp;&amp; rm -rf env14 Yours amounted to 8 commands and required manually keeping track of your PYTHONPATH while mine was 7 and allowed you to test multiple environments at the same with a simple `source env/bin/activate` when needed. It also let you treat the environment like it was global. virtualenvs make it easier to set up and manage custom environments where you have specific versions and combinations of specific software installed. Django 1.4 with SQLAlchemy 0.6, Django 1.3 with SQLAlchemy 0.7, Django 1.4 with PIL, etc. Creating a directory and setting it on your PYTHONPATH is taking a step backwards in terms of convenience, because you end up keeping track of everything yourself instead of letting the environment do it for you. If you don't see the benefit of using a virtualenv by now, there's not much I can do to convince you. I just hope I never have to work with you.
This is an example of heavily obfuscated Python that's designed to superficially look like Lisp, which is one of the most famous functional programming languages. EDIT: Sorry, I guess I didn't directly address the question. Like mijaba says, it's a terrible example of FP.
&gt; Yours amounted to 8 commands Yeah, to create *two* "virtualenvs" and run tests against them, then clean them up afterwards. Yours is 6 commands to do it *once*. If you don't want to "keep track of PYTHONPATH", then just write: export PYTHONPATH=whatever As that's the equivalent to "source whatever/activate". &gt; Creating a directory and setting it on your PYTHONPATH is taking a step backwards in terms of convenience, because you end up keeping track of everything yourself instead of letting the environment do it for you. Er, what? Let me rewrite your example using PYTHONPATH, *exactly*, line for line: mkdir env14 &amp;&amp; export PYTHONPATH=/path/to/env14 easy_install -d env14 Django==1.4 python setup.py develop -d env14 // test unset PYTHONPATH &amp;&amp; rm -rf env14 The *only* difference here is that you explicitly say where you're installing stuff to, instead of it being implicit... which strikes me as a virtue, since I won't go, "oops, installed that to the wrong environment." (Also, I used "easy_install -d" because I don't use pip and don't know what its "install to this directory" command is.) &gt; If you don't see the benefit of using a virtualenv by now, there's not much I can do to convince you. I just hope I never have to work with you. I'm using "virtual envs" too... I just don't need the virtualenv **tool** and a bunch of "activates" to do it. Also, if I really needed to statefully install stuff in different places, I'd just tweak my distutils.cfg to use an environment variable as part of the standard install paths. Or who knows, I might actually make some sort of "activate" script... but I *still* wouldn't need an actual virtual Python installation, just something to tweak PATH and PYTHONPATH and the default installation locations. I've asked virtualenv fans to explain what it gets me *besides* those functions, and never got any answer besides either 1) it's cool and awesome and you should use it, or 2) you get isolation from the system Python. And for #2, h I'm not sure why I should care; how about just NOT installing things in the system Python, or install them with easy_install -m so they're not on sys.path by default? The irony here is that I'm actually the person who *invented* virtualenv, in the sense that several years ago I wrote up how to use PYTHONHOME and some symlinks to create a virtual Python. The reason I did that was because at the time, easy_install didn't "just work" with PYTHONPATH. Ian Bicking then turned my instructions into a Python script, that then later morphed into the current virtualenv tool. But while he was doing that, I fixed easy_install so it *would* work with PYTHONPATH, thereby removing the *only reason* I created the virtual Python idea in the first place. (For that matter, Ian also created pip, which doesn't need .pth files, so *it doesn't need virtualenvs either*!) Basically, AFAICT the popularity of virtualenv -- the tool, not the idea of having various installation environments -- has become popular solely because PYTHONPATH and the distutils options are obscure, and not well-marketed. virtualenv has become associated with the idea of having installation environments, so its proponents assume that when other people say, "wtf do we need that (tool) for?", that we're saying we don't need to install things in different places, and that we're some sort of luddites who install everything in the system Python. Not so. We just never saw the point of adding a tool to (implicitly) do what we could already do explicitly with stock Python. Virtualenv just has better marketing, because it's a thing you can point to and say "use that", whereas the other stuff, well, you have to know what you're doing, and there's no one HOWTO (AFAIK) about creating virtual envs without the "virtualenv" tool.
&gt;Yeah, to create two "virtualenvs" and run tests against them No, to create one. To create two, it was sixteen. &gt;Er, what? Let me rewrite your example using PYTHONPATH, exactly, line for line: Actually it would be `PYTHONPATH=/path/to/env/lib/python2.7/site-packages`. And then you would need to copy a Python binary and `PATH=/path/to/env/bin:$PATH; export PATH`, because I would like my CLI to default to a specific version when I'm working on that project. Oh, and can you have it automatically install distribute? But only for X projects? And maybe have it so Y projects require local distributions of packages to install instead of downloading them? By the way, I would need a script to make it compatible with Apache/gunicorn/uWSGI. So you can see where someone thought creating a script to handle all this was a good idea. &gt;I just don't need the virtualenv tool and a bunch of "activates" to do it. Just one activate per project. You end up typing less than if you wanted the same amount of functionality without the virtualenv script, and it's compartmentalized for you. &gt;Also, if I really needed to statefully install stuff in different places, I'd just tweak my distutils.cfg to use an environment variable as part of the standard install paths. Or who knows, I might actually make some sort of "activate" script... but I still wouldn't need an actual virtual Python installation, just something to tweak PATH and PYTHONPATH and the default installation locations. That's great! It works for you. But it doesn't work for others, so that doesn't mean they're wrong or you're right. If you want to do everything manually and have your own personal structure for projects, that's fine. Just don't think everyone else wants to. &gt;Basically, AFAICT the popularity of virtualenv -- the tool, not the idea of having various installation environments -- has become popular solely because PYTHONPATH and the distutils options are obscure, and not well-marketed. Don't assume a tool you do not use is popular just because the tools you *do* use are unpopular. I know about both `PYTHONPATH` and distutils, and I don't think either fills the role virtualenv does. &gt;its proponents assume that when other people say, "wtf do we need that (tool) for?", that we're saying we don't need to install things in different places, and that we're some sort of luddites who install everything in the system Python. No. I assumed you were someone averse to change. &gt;Virtualenv just has better marketing, because it's a thing you can point to and say "use that" Which is a good thing. I'm not sure why you would prefer to ignore a tool that makes your workflow easier, gives you more tools, and has no downsides.
According to [this comment](http://spamtech.co.uk/software/cracking-the-areyouhuman-captcha/#comment-33) which was supposedly made by a founder of this CAPTCHA system &gt; You’d have to submit to our webservice and request a score and most of these would have failed. Perhaps in future versions, it will take into account amount of errors and time taken to complete a challenge?
Floating points? Nope. Functional Programming, of course. **Stop using ac~~c~~ronyms, it doesn't help anyone.**
 &gt; Actually it would be PYTHONPATH=/path/to/env/lib/python2.7/site-packages. And then you would need to copy a Python binary and PATH=/path/to/env/bin:$PATH; export PATH, because I would like my CLI to default to a specific version when I'm working on that project. Stateful implicit versions of Python? Ugh! If I want a specific version of Python, I make an alias like py27 or whatever. Explicit is better than implicit. &gt; That's great! It works for you. But it doesn't work for others, so that doesn't mean they're wrong or you're right. If you want to do everything manually and have your own personal structure for projects, that's fine. Just don't think everyone else wants to. Once again, you're arguing *tool* when I'm talking about *mechanism*. You could make a tool (or several) that would handle all these use cases *without* creating a "virtual python" -- the kludge which, as you may recall from my earlier post, I **invented**. (Okay, I just *popularized* it -- the mechanism for making one was already mostly there in Python.) What I'm saying is, the underlying *mechanism* of having virtual Pythons is actually pretty bogus, and unnecessary in order to fulfill virtually (no pun intended) all of the use cases of the virtualenv tool. As I said, nobody has yet shown me a use case that *requires* the virtual-Python kludge to implement: even 100% isolation from the systemwide site-packages can be accomplished with a sufficiently-clever site.py, although personally I'd prefer not to write said site.py -- the one that easy_install uses (and which the virtualenv tool, IIUC, builds on top of) was difficult enough. ;-) Again, I'm not saying virtualenv the *tool* is bad; I'm just saying it's built on top of a kludge. PEP 405 just promotes that kludge to official status and a less-kludgey implementation. Way, way, back at the top of this comment thread was a question: &gt; Can someone explain to me what virtual environments add to Python above setting PYTHONPATH? Presumably, that's because the person who asked that question is happy with PYTHONPATH... and that means the answer to their question is "not much". If you're happy with PYTHONPATH -- and therefore, already accustomed to using it -- then virtualenvs don't really offer you any new killer features. That is, you are unlikely to just one day decide to take the time work through their learning curve, when you've already done so for PYTHONPATH... because there's nothing they do that you can't already do. &gt; Which is a good thing. I'm not sure why you would prefer to ignore a tool that makes your workflow easier, gives you more tools, and has no downsides. I could say the *exact same thing* about PYTHONPATH. See, any tool you've already been using, long enough to learn its ins and outs and get past traps, will *appear* to be "easier, more flexbile and have no downsides", because it's a tool ready-to-hand in your brain. So, the answer to the original question here is still, "Not much". *After* you go through the adaptation to a new tool, you get some maybe a little-shinier versions of what you already had or could do without it. But if you've already learned the ins and outs of whatever tool you're using, there's really no reason to *switch* from PYTHONPATH to virtualenv... At least, nothing that any of its advocates have so far been able to communicate to any old hands at PYTHONPATH. It all sounds like, "ooh, shiny" to us. Now, if you find somebody who was doing all this stuff with PYTHONPATH and then switched to virtualenv, who can explain why it was worth switching, then great.... I'd love to hear that explanation. But everybody who I've heard try to explain the advantages of virtualenv sounds like they're always describing stuff I either don't need, don't want, already have, or could trivially make on the fly if I ever did need it. 
There is also the pretty cool [cmdln](http://code.google.com/p/cmdln/), which 'fixes some design flaws of cmd.py and takes advantage of new Python stdlib modules like optparse so that it is more useful and convenient'.
Any library that involves executing documentation strings at runtime is squarely in the realm of "terrible idea" as far as i'm concerned.
After reviewing the code, the take away for me here is finding out how I can use a fixed number of spaces for a string substitution. For example: %(foo)-8s. 
Executing? Or do you mean parsing? I don't find it so bad.
Your comments should never affect how your code operates. You should be able to put *anything* in *any* comments, well formatted or not, and feel comfortable that your code will work the same. Docstrings parsed out into html pages for viewing don't bother me. They don't affect your code at runtime. 
I love the completions it offers but absolutely hate that it auto-inserts the first result. I can't continue typing to narrow down my choices. If that could be fixed this would be by-and-far the best option for python auto-complete.
That's cool, I guess. It still doesn't convince me that it's any good. What if new maintainer sees the help output at the top of the file and goes "huh... don't need this..." And then it doesn't work anymore. And he can't figure out why. All he did was remove documentation. This should *never* affect runtime operations. You may be saving lines of code by doing this, but you are violating universally accepted rules in doing so. DRY be damned, this is a bad idea. 
&gt; Special cases aren't special enough to break the rules. &gt; Although practicality beats purity. I think this is a very practical solution.
Point taken. Instead of using \_\_doc\_\_ it should have probably been a string variable.
Then put the string in config-file, that sais "This is the config-file for argument parsing. For syntax see http://docopt.org." and strip first line before passing to `docopt` function.
This is only practical if you are going to be the only human ever to look at the code. And you have a perfect memory. And you don't make mistakes. And you never comment your code anyway. This is not a matter of purity over practicality. Changing comments should never change how your code behaves. 
I was really hoping for fixed point.
well defined does not equal not guessing, if I as a programmer don't know what the rules are. You're introducing a DSL, and in an unusual place where it doesn't need to be. You could achieve similar, if not better, clarity and succinctness by using more normal declarative systems such as sqlalchemy-style metaclasses.
Ya, it's lame by default. Checkout my [vimrc](https://github.com/samiconductor/dotfiles/blob/master/vimrc.after). Near the bottom there's a mapping for rope code assist that avoids selecting the first completion. It's based on [this page](http://vim.wikia.com/wiki/Make_Vim_completion_popup_menu_work_just_like_in_an_IDE) of the vim wiki.
What I was trying to say is that it is easier to read at a glance than the regular argparse version, not that the number of lines is the issue. That isn't all that big of an issue because usually when you need to know all of a program's running arguments it would be when you're running it. So it doesnt seem to be worth it, especially if you have to go against one of the important guidelines of the language. 
Well, in this case, for the lulz.
A fascinating approach. I'm excited to try and see how this holds up in practice. I've wasted huge amounts of time trying to make argparse format a help as I wanted it to.
agreed, argparse is great and i don't know why everyone hates it so much. Once you learn how it works its really simple to use, I even have a snippit program fill it in for me so its even LESS typing. import argparse, sys def __themethod__(args): ''' __methoddesc__ @param args - the namespace object we get from argparse.parse_args() ''' if __name__ == "__main__": # if we are being run as a real program parser = argparse.ArgumentParser(description="__description__", epilog="Copyright @date Mark Grandi") # optional arguments, if specified these are the input and output files, if not specified, it uses stdin and stdout parser.add_argument('infile', nargs='?', type=argparse.FileType('r'), default=sys.stdin) parser.add_argument('outfile', nargs='?', type=argparse.FileType('w'),default=sys.stdout) args = parser.parse_args() __themethod__(args) 
http://www.youtube.com/watch?v=ywWBy6J5gz8
He's question was actually "can you sort the cards in a deck of cards"?
 nums = [1,4,2,4,0,-22,6] lim = len(nums) for i in range(lim): for j in range(lim): if nums[j]&gt; nums[i]: nums[j],nums[i] = nums[i],nums[j] print nums Output: [-22, 0, 1, 2, 4, 4, 6] I am noob myself, and this is probably a very inefficient way of doing this. Edit: Just thought of another way of doing this. sortednums = [] lim = len(nums) for i in range(lim): sortednums.append(min(nums)) nums.pop(nums.index(min(nums))) # I am not happy with this line. print sortednums 
You just invented Bubble Sort! :) `[].pop()` returns the value you popped, so you can compress those two lines into one. sortednums.append(nums.pop(nums.index(min(nums))))
Yep, parentheses offer an "implied" line continuation that spans all sorts of whitespace. http://docs.python.org/reference/lexical_analysis.html#implicit-line-joining
Do you have some examples?
http://pypi.python.org/pypi/Baker/1.1 Is my preference for command line UIs, I mostly like it's subcommand handling.
I've updated the front page with an image, sample output looks like http://six9s.com/depchart.png Basically it's a directed flow diagram to show how things, in this case systems in my home network, are linked together. Wish I could show the one at work, it's got several hundred nodes and a few thousand dependencies.
Oh my gosh distutils2 / packaging can't come soon enough.
I just took issue with using docstrings to affect the runtime. The library itself is okay, I guess. I see no reason to use this over, say, argparse, though.
1. Why should I not just use `dot`? 2. dependancy -&gt; dependency 3. printing superfluous stuff to stdout in a command line tool is a no-no 4. Some config options should really be command line options (sourcefile, outfile, and config filename itself). Use `argparse` 5. No way to read from stdin. 6. Main entry point should live under `if __name__ == '__main__':`, in case you want to turn a script into a lib or put unit tests in the same file. 7. Some constructs are a bit verbose. E.g. def GetEdgeOptions(parser): Opts={} EdgeOpts={} #Get Node Types EdgeTypes=parser.get('types', 'DepTypes').split(',') for et in EdgeTypes: #Only pull options for ones that have sections if parser.has_section(et): for name,value in parser.items(et): EdgeOpts[name]=value Opts[et]=EdgeOpts EdgeOpts={} return Opts can become more "Pythonic": def GetEdgeOptions(parser): edge_types = set(parser.get('types', 'DepTypes').split(',')) sections = set(parser.sections()) # Only pull options for ones that have sections return {et: dict(parser.items(et)) for et in edge_types &amp; sections} or this, def getedges(deps): edgelist=[] for dep in deps: if dep['dependancy'] != '': edge=[dep['resource'],dep['dependancy'],dep['dependancy_type']] edgelist.append(edge) return edgelist can become this: def getedges(deps): for dep in deps: if dep['dependency']: yield [d[k] for k in ['resource', 'dependency', 'dependency_type']] or even slightly more obtuse, but passable for an experienced Python coder: def getedges(deps): return [[d[k] for k in ['resource', 'dependency', 'dependency_type']] for d in deps if d['dependency']] Read [Python functional programming HOWTO](http://docs.python.org/howto/functional.html): it's practical and contains useful info on how to effectively mould data structures into desired shape. 8. It's better to use a `dict` in `getnodes`, since you always lookup by the first item ("resource") in the list/tuple. You can convert it to a list of lists if you really want to after you've built it. This will simplify `getnodes` and get rid of `NodeExistsInList `. 9. Don't forget to close your files and use safe handling for resources that require release using "with" block: with open(sourcefile,'rt') as f: for row in csv.DictReader(f): ... 10. Can refactor setting node and edge options in `makeedge` and `makenode` to eliminate code duplication. 11. "2012-2018": I don't think copyright works that way :)
It accepts no selections, you should fix it. `You chose:` `, , , ,`
its pretty useful for industrial robotics, pretty cool contribution...
Have you looked at mango automation? mango.serotoninsoftware.com/ I use it for data collection and systems monitoring at my plant. Its the easiest way to get common industrial data streams into a standard DB 
Now that I think about it, if you're the kind of weirdo that uses the -O0 flag, it'll strip out the docstring, and break your code. Neat.
agreed!
Please don't tell people to delete the directory. Delete just the one file and you'll be fine. For that matter, if you delete the file that you removed from MANIFEST.in, then you'll be fine also.
Yeah, you can definitely do everything with dot, however it's a little easier to get people to update a spreadsheet than handle the dot sourcefile. I hope to integrate it with a network discovery tool, however I'm not sure which one, or how yet. I haven't played with those tools in quite a while and have been forced to do this last one pretty much manually. I really want to add a couple of web based features though, namely the ability to go to a page for a node and see the upwards and downwards graphs for it, plus any additional info on the node. Also I'd like the ability to add new dependencies to the node from that page, to make it easier to keep up to date.
Yeah, I've been looking at NetworkX for doing analysis of the graph, pydot was just easier to get setup for this since I didn't need to have any real analysis.
what's so bad about deleting the folder? It's all auto-generated. Is it not?
In which case the OP should have engaged with the "old programmer" who was asking the question to find out more. For fuck's sake, what happened to personal communication? When a teacher asks a question you legitimately don't know the answer to *fucking ask them for help, don't go running to the internet*. Reddit is the *last* place your hypothetical OP should be asking for support. I appreciate giving support and all, but if /r/python is the first place the OP turns for "how do I sort a list" then giving them a practical answer isn't going to help. They need to be turned on to a good book, or perhaps ask someone I don't know, *directly in front of them*? Myself, I don't know *any* experienced programmers who would ask such a question of someone completely unversed in the art without being prepared to teach them something.
Fuck you and your GFY. If you want to learn, show some initiative and use google, or at least give the impression you tried. Acting like a petulant fucktard isn't a good start, even if you qualify it with a smiley face :-D.
Thats not quite as bad as the docs made it out to be, looking through the pydot docs it doesn't look to be that bad either. 
Is it Open Source?
Never mind...lol actually checked out the web site, looks very interesting, thanks!
Not sure what you mean by recursion, but it can handle dependencies that refer to themselves, and and referential loops. 
Regardless of whether this is good or bad for PyPI, it's still a cool proof of concept. I'd upload to both PyPI and Github though.
I've always found that learning a language is easy in the abstract but it's when you start programming that the rubber meets the road and that's infinitely more productive with a debugger.
Obligatory recommendation for Vim (and Vim-IPython). Probably not actually a good idea, though. Not exactly an IDE, either, but close enough. Edit: Not a good idea because if you're a beginner in general, you'd probably spend more time fighting with Vim than writing code. Vim was intentionally designed to be non-beginner friendly. Through a variety of plugins you can achieve the full functionality of an IDE if you so desire. &gt;Vim only has two modes: beep violently and break everything.
Goddamn I hate fightin on the internet, but yo. You give attitude, you get attitude back. I came here to ask a question, got sent in the right direction, and Im moving on, so thanks for nothing buddy. I hope you get everything you want in life.
http://geany.org/
Komodo edit. 
It's [a thing](https://github.com/ivanov/vim-ipython).
I was using idlex until I found [Spyder](http://code.google.com/p/spyderlib/). 
Sounds like you want a debugger, not an ide; [pdb](http://docs.python.org/library/pdb)
but any modern IDE is expected to have a debugger...and a pleasant one too.
I'm quite fond of emacs. Even with the out-of-the-box python mode, you can have a split screen where you're editing in one pane and running an interpreter in the other. A key combination sends the buffer to the python interpreter and switches you to that pane, where you can then play with your changed code. I find it a terribly efficient way to develop code. Of course, emacs is its own religion and commitment.
I spent some time looking at all the options available a few months back, and I initially skipped WingIDE because on OSX it runs under X windows. After finally giving it a try, I found, to my delight, that it works about as well as a native app.. command keys etc all work as expected. Great debugger builtin, code completion, emacs/vi bindings, ton of code intelligence (http://wingware.com/wingide/code-intelligence), all the bells and whistles. It's extension language is python itself, so you can easily modify it. It also runs on windows, osx, and linux. Glad I went back and gave it a chance, as that's all I use now.
Sublime Text is the editor I have been waiting for for ages. I'm a vi nut too. It's everything wrapped in fast!
Yeah, I actually work mainly in Vim, and use IPython a lot (though not for scientific computing). I have been doing a lot of Django development lately, and IPython works great for loading up django models and testing things, etc. Anyway, I'll give it a shot, but the readme on that github link is a bit intimidating. Will let you know how it goes :P
Install the plugin. Run "ipython console." In vim, ":IPython". That's it, you can run the whole code or just lines with the shortcuts it mentions on the web site. All the concerns about the Ruby being installed weren't an issue for me. (I was using MacVim, though, which links against the default version of Ruby on OS X, it may be a problem if you're using Linux.) I think it also works with the notebook interface instead of the console, too.
Yes Yes Yes.. Just switched to this recently.. and its SO much easier and better.. 
Be careful with c -- if you modify it in one invocation of `do_stuff`, those modifications will persist in future invocations. (Google "python mutable default arguments" for a zillion or so detailed explanations)
You really need to give more info.
So you want the list to live in argument scope, and mutate it? It can be done, but as for whether or not it should? Dunno. [here's an article](http://effbot.org/zone/default-values.htm)
Not in all cases, no. Projects that use EggTranslations, for example, put their i18n resources there, and there are other use cases for putting files in there. Granted, I suppose if you have one of those use cases, you'd *know* you'd put files there you didn't want to erase... so perhaps I'm being overly pedantic about it. Of course, the real solution is to just forget about MANIFEST.in in the first place and use a revision control system. ;-) 
Of course not... You're not the first person to ask this question (in the last two weeks). Look around.
I love Emacs, but I would not recommend it to a self-proclaimed noob.
WingIDE is great. I'm a vim person but if you want an actual IDE, WingIDE is the way to go. I've tried every single IDE that has been recommended here, besides the windows one, and none of them compares. Not to mention that their license is pretty liberal and they are really cool to work with if you have issues or questions. Their debugger is awesome.
Is it too much to ask for a FAQ, sidebar entry, or sticky thread for IDE, sir? I don't mind the question, I just think with other news they scroll off the front page so we end up with a 20-comment thread every couple of days with people repeating themselves, rather than a single decent discussion on editors &amp; IDEs. I find the links to new editors or plugins for existing ones valuable and on-topic; but the frequency of this question being re-asked anew is over the top even for my patience. 
OP is a Python noob, not a programming noob. Says: &gt; I've programmed for years. 
I much prefer: d = d or [] to: if d is None: d = []
"Yoda style" is completly unneeded in python. It only makes sense to use Yoda style in C where you might accidentally assign to a variable.
Totally. Comments are there to say what the programmer thinks should happen. The code will tell you what actually happens. A bug is when those 2 things aren't the same.
I agree that ST2 is the best text editor, but OP asked : &gt;I'd like to just be able to easily set conditional breakpoints, look at variables, pop up and own the stack etc. " I don't think those are possible in ST2 (but I hope I'm wrong)
&gt; the real solution is to just forget about MANIFEST.in in the first place and use a revision control system. What do you mean with that? Write the Manifest manually? Or how else would you include the package data? I am really curious about this, as - at least for now - the `MANIFEST.in` is the only option I know of (and which I got working).
No. No I have not.
The only thing I can think of that may be better than Sublime is Light Table (and I'm holding judgement until I can play with it)
Everything that makes PyPI faster is greatly appreciated ;D
As another newbie, so far I've got to give two thumbs up for Eclipse with the PyDev module. It's very good, free, and with the pydev features creates a good workflow for working through the early tutorial and test projects I've been doing. At this point, I really only use Sublime Text for the recursive typing feature (multiple cursors are quite handy for ascii art), .pt and .html files. But looking below at ST2 comments, I may check it out
Yup. I use Wing on a daily basis at work. I do own a professional license, though, but Wing offers a limited, personal edition as well. I can only recommended it.
I tried Aptana but found it didn't play nice with other plugins I was using within eclipse. Birt for one example. Had to remove it and return to Eclipse with Pydev. 
There's room for bugs when you're vague. What if 'd' is any object that evaluates to True but is not a list? What if 'd' is an object the user want's to use but it's empty (e.g., deque), or what if the reference belongs to a bigger structure {'parameter': []}? 'None' isn't the best sentinel to determine this but it's the most common idiom.
This is unfortunately true. I tried PyCharm as soon as it came out, and have since then been willing to give it a try every other version. I guess I have been through 8 cycles of installing/uninstalling it as of now - I really *wanted* it to be usable, but the performance was killing me. Mind you, I was thinking about using PyCharm in a professional environment at work, where sluggishness and non-responsiveness are traits that are not exactly tolerable - your mileage may vary. I do know some people that can cope with it quite well and found PyCharm a great product, I however think Wing is the superior of the two. 
Python 3.3 randomises dictionary hashes as a security measure, which means that the order is not consistent. Having recently had to clean up doctests which assumed that dictionaries had a stable ordering, I don't like doctests. They make it far too easy to assume things which were never guaranteed.
I am absolutely aware of the pitfall or side-effect of 'c'. I just presented a few 'list as parameter' suggestions as the op was very obscure about the exact need of a **global** list in a function. I'm still not sure what the op wants. 
They are with PDB and the console.
It's a plugin for VS.
PyCharm (and other similar IDEs) work just fine if you have SSD. On HDD they're totally unusable, true
Komodo
Komodo only.
Probably this is the quickest way to get a setup for Python with emacs https://github.com/gabrielelanaro/emacs-for-python Python with emacs has a high fiddle factor (even higher than usual for emacs).
Vim can be intimidating for beginners. My guess is that OP is a beginner in general, thus he might spend more time fighting with Vim than actually coding. Personally, I use Vim for pretty much everything. Another interesting advantage is that Vim is extensible in Python. There is a syntax and indent plugin for LOLCode, however. Can't say I've used it though &gt;.&gt;
Now with Vintage (vi keybindings).
Try pudb instead of pdb :D It's so good I actually prefer it to the full-blown visual debuggers like PyCharm or PyDev.
I'm not writing it but I would gladly link to an FAQ put together by someone else. If anyone wants to get started on it, you can probably follow [this lead](http://www.reddit.com/help/faqs/Python) (which just links to other FAQs) and then I'll update the sidebar.
In Python functions and methods are essentially the same. You can call them with some arguments and get some value returned. In Python methods are functions that are part of a class/object. Usually their first argument is called "self". A procedure is similar to a function/method but the name is not used in the python community. The exact meanings of these words vary between different programming languages.
YMMV, I have it on a fairly old quadcore machine with a 7200 rpm disk. No problems at all. "Search in files" isn't an instant operation of course, but everything else I can think of is just fine.
The differentiation between them depends a little on the programming language and the individual programmer, but the definitions I usually see are: * **Subroutine:** The most general term. A subroutine is a point in the program that you can jump to from almost anywhere, optionally passing arguments and receiving return values. * **Function:** A subroutine that returns a value, usually dependent on the arguments. * **Procedure:** A subroutine that returns no value. * **Method:** A subroutine that is defined within a class and usually operates on an instance of this class or the class itself. Sometimes, especially for languages which are not natively object oriented, "method" and "procedure" are interchangeable. 
Check out /r/learnpython if you haven't already.
Sometimes people use the word procedure to describe a Python function or mehod that always returns None, like list.sort. If I remember right, the official documentation even notes this use, or used to.
This is the correct answer. Note that classmethods get the class of the instance passed as their first argument, so they're not exactly the same as a regular function. Also, it's quite possible to write functions in python that act like procedures. Just omit a return statement. This will cause python to return None from the function (since function calls are always expressions and therefore must have a value) but otherwise the idea is much the same. 
Ditto, but mostly because I alrady use Eclipse for other things. I use vim for quick edits. 
These are pretty good and definitely fine for a learning programmer, but I think that you'd find that in more advanced discussions those definitions don't really hold up. At the very least, the definition of 'Function' is inadequate to capture Python's functions. So again, your definition is fine for here, but personally I would define a 'Function' as: -------- A map from the domain (defined as the possible values assigned to the arguments of the function and the state captured by the function [ie. closure]) to the range (the possible return values AND the possible changed program state [ie. side effects]), coupled with the subroutine that defines the transformation that brings about that mapping.
Procedure is just a name for a function that doesn't return anything. Some languages (and many databases) make a distinction and treat procedures differently, enforcing their lack of return value, but Python does not. A function that always returns None (or never returns anything at all, implicitly returning None) can be called a procedure in documentation or conversation to assure someone else that they can ignore the return value safely. Python itself makes no distinction, and all functions and "procedures" will always return a value, even if it's just None.
What? You must be confused. When I said "classmethods" I meant actual class methods, created with the decorator of the same name. As I said, they are passed the *class* of the calling instance, whereas regular methods are passed the instance itself. They should definitely be called classmethods since that's what they are. 
Emacs. I also have a script allowing you to run python embedded in the editor. It's simple.
Looks nice, but I think it isn't very optimized for speed (besides the use of C++): https://github.com/raphaelcruzeiro/webimage/blob/master/snapshot.cpp#L55
I think it's more pertaining to compiling C extensions which python can access. edit - Also, I remember Guido mentioning, oh wait, here's the quote and link &gt;[Guido van Rossum: What made the lack of file support in the ABC language worse was that it wasn't easy to extend ABC. You couldn't say, "This language is implemented in C, so let's just add another function to the standard library that does open a file." ABC had no concept of a standard library. It had built-in commands, but the parser knew about them. It had built-in functions that were very much integrated in the runtime. Adding to the language's standard functionality was very difficult. For Python, I felt extensibility was obviously a great thing to have. I already knew we would want to use Python on different platforms. I knew we wanted to use Python on Amoeba, the operating system we were developing, and on UNIX, the operating system we were using on our desktops. I knew we would also want to support Windows and Macintosh. I realized that each of those systems had certain functionality that was consistent everywhere, like the standard IO library in C—but there was also different functionality. If you wanted to draw bits on the screen on a Windows system, you had to use different code and a different programming model than you would on a Macintosh or on Unix.](http://www.artima.com/intv/pythonP.html) So basically we're talking about .py files and C extensions.
Indeed, nor is it true of idiomatic python programming. I think discussion of lambda calculus and functional programming is very healthy for computer science and programming in general, but thought perhaps it was too much for this post. But, cheers to you, I do like your extension quite a lot!
If you use a revision control system and have an appropriate plugin for setuptools, it will automatically include in the sdist anything that's under revision control, without needing it to also be in MANIFEST.in. You can then use MANIFEST.in only to list things that are not in revision control, or to ask that things not be included even if they are in revision control. If you use a revision control tool such as hg, bzr, git, cvs, svn, etc., you can find an appropriate plugin via PyPI. And if you aren't using revision control, you probably should be. ;-)
Yeah I don't really see the point of that line... Cool tool but what has it really got to do with Python? C++ Qt is doing the heavy lifting here. &gt; Generating website previews using in C++ (using a little tool written in Python) would be a more accurate title.
Well, I *do* use revision control. But this solutions is something I personally would *not* like. I like to manually specify what gets packaged and what not. And I *do* have stuff in version control that I do not want to package. It might be interesting to mention that there are plugins for this behaviour. Then everybody can decide for him/herself.
I guess we'll have to get in to defining 'idiomatic' which is 'idiotic' ;) I *wish* I worked in an environment where idempotency and side-effect-less-ness was the idiomatic style, but alas, I do not. I absolutely agree that it is a good goal and one that Python supports better than many (most?) other imperative languages.
Actually, the tool was written so I could call it via Python to generate previews for a web content crawler.
You can find different definitions for them, but it is hairsplitting. The terms are used interchangeably outside of textbooks.
I believe you can use MANIFEST.in to specify what you do not want packaged. Personally, though, I wonder what you'd have in your source tree that doesn't belong in an sdist. Or are you talking about binary distributions? (MANIFEST.in and revision control don't directly affect what gets put in .egg, .rpm, .msi, etc., or what gets installed to an end user's system.)
I maybe wrong but i am sure you can download the Visual Studio Integrated Shell + pytools all for free. (doing this now just to check it out!)
Your definition of function is mathematical and not correct for Python at all. Python functions are not maps because they incorporate state and potentially randomness.
There doesn't seem to be any syntactic difference (other than the trivial aspect of physically putting a method inside a class) according to this: http://docs.python.org/tutorial/classes.html - what do you mean?
I use PHP storm which os based off the same platform and that works great...
I'm using it on a 3.4ghz Intel I7 quad-core iMac with 16G of RAM and 1TB HDD. Speed is perfectly fine.
Python only has functions (every subroutine will return None if you don't explicitly return a value) and methods (bound to either classes or objects).
There is nothing trivial about the fact that a definition in one place defines an function and in another it defines a method. And then it generates a method object rather than a raw function object.
 &gt;&gt;&gt; a = [0] &gt;&gt;&gt; a[0] = a &gt;&gt;&gt; print_elements(a) lol! I see pprint handles it properly though :)
Alright, that won't break it anymore. :D def print_elements(ulist): for i in ulist: if i == ulist: print "Try again!" elif isinstance(i,list): print_elements(i) else: print i 
It depends on the language. The basic concept is that of a function: a "rule" that links a value to another value. f(a) = b. When programming was on it's childhood, they needed a way to avoid code ctrl+v and, for this, created "**procedures**", that is, a defined set of statements that would be executed whenever you wanted. Only later they realized that this was very related to functions. You won't see that name on modern programming languages anymore. 
That's a (trivial) semantic difference, not a syntactic one. Regardless, a method in python is just a function with one curried argument. I don't see the significant difference?
I think I came across "is" at some point. IIRC, "a is b" is equivalent to "id(a) == id(b)".
Pretty much. Here's my recursion-proof version of your code: import sets def print_elements(ulist, ptrs=None): if ptrs is None: ptrs = sets.Set([id(ulist)]) for i in ulist: if isinstance(i, list): if id(i) not in ptrs: ptrs.add(id(i)) print_elements(i, ptrs) else: print i Edit: use sets
I recently did a blog post on a similar service using python and phantomjs, a headless browser without qt deps. Phantom is programmable in js. http://charlesleifer.com/blog/building-bookmarking-service-python-and-phantomjs/ 
I've had too many teachers give answers much like yours. They loved to (try to) impress with nuance but they were blind to subtlety. If you are like them, I did have to be rude. The best teachers are not the smartest students, yet higher education institutions in America select the students most eager to prove how smart they are as the next generation of professors. Only bluntness and repetition can have any hope of disillusioning the acolytes and I don't have repetition at my disposal. If I've assumed too much by assigning you to the acolytes, feel free to write me off as an Internet blow-hard :) 
I'm glad that we have you to stand forth as the bastion of decency and aptitude in learning, then.
If you're allowed to call that function with a generator instead of a list, it might incorrectly skip elements, because an ID can be reused once an object has been garbage collected. That's why `id([]) == id([])` can be true. You could use a set instead of a list to store the IDs, because membership tests in a set are O(1), versus O(N) in a list, but the difference would be negligible compared to the speed limit from printing output. Also, I wouldn't call the cache `ptrs`, because while `id(i)` might be a memory address, you can't use it as a pointer in Python.
This is correct but has terrible performance (O(n^2 )) for large lists, since the "in" operator is O(n) worst case for lists. You get much better performance using a set.
You're right, writing the nested list printer would be easy in c if you can assume something like Python's list type. In c, you would have to define a struct that has a pointer and a char which is a flag that tells you what type is at the end of the pointer (either whatever it is you're printing, or an array). `ulist` would just be an array of those structs, and the `print_elements` function would be defined pretty much the same way it is in the OP.
 &gt;&gt;&gt; def f(): ... pass ... &gt;&gt;&gt; type(f) &lt;type 'function'&gt; &gt;&gt;&gt; class Foo: ... def g(): ... pass ... &gt;&gt;&gt; &gt;&gt;&gt; type(Foo.g) &lt;type 'instancemethod'&gt; &gt;&gt;&gt; type(Foo.g).__bases__ (&lt;type 'object'&gt;,) Methods are not functions.
If you're using apache2, you should use mod_wsgi. But most people used nginx instead. (mod_wsgi for nginx is different stuff and not maintained)
seriously, this - it's very well polished.
It's simpler and more beautiful in many ways, but more complicated and contrived in others. Once you've used both for a while, you'll figure out when which tool is appropriate to use, and when it's inappropriate. Knowing to apply the right tool for the job is the biggest advantage of a language polyglot, along with learning new, useful modes of thought.
Fixed! def print_elements(ulist): if not hasattr(print_elements, "ids"): # Store "static" function info inside the function itself print_elements.ids = set() print_elements.ids.add(id(ulist)) for i in ulist: if id(i) in print_elements.ids: print "Circular reference to " + str(i) elif isinstance(i, list): print_elements(i) else: print i
ready for enterprise
Are there any hobby mcu's you can suggest?
When is it more complicated?
The most popular recently are the Arduino boards using the ATMega microcontrollers. They're very easy to learn on for beginner microcontroller programming.
Regarding set-vs-list, I believe that it is always best practice to use a set when you are using it for containment tests to better elucidate the purpose of the structure. This also allows scaling without changing the code, always nice. Most importantly, especially with novices involved it is always important to use the right tools for the job, so they learn what the right tools for the job *are*. As a side note, even including premature optimization there is no good reason to use a list even in small cases, because time spent searching a set is roughly equivalent to searching for the second element of a list, says my timeit. And that is giving the benefit of the doubt that we are using integers, which have extremely simple equality testing (which list searches do more of).
udacity... bookmarked. Thank you
not wrong. you can use PTVS with full VS, or stick into the Integrated Shell, which effectively gives you a "Visual Studio Python Express". This combo is completely free &amp; the plug-in itself is OSS. the most recent version has support for Django as well.
I suggest you taking a look at Golang, if you are coming from C.
I really enjoyed this read - it is both motivating and informative. Thanks for the share!
The ex falso tagger from the quod libet people is excellent, does what you ask and is written in python: http://code.google.com/p/quodlibet/ - it's the simplest and best tagger I'm aware of, much better than anything that comes built into a player, except quodlibet itself, I guess (although I'm not currently using this as a player)
lots of ram is another option. with 8+GB of RAM, OS can easily cache all files of your project, which will give you access-speed similar to SSD. with SSD, though, 4GB of RAM (sometimes even 2GB) is enough
Doing `isinstance(i, list)` limits you to lists (or things that inherit from it), missing things like iterators for example. A better way of doing it is `isinstance(i, Sequence)` (from the collections module), though this also catches strings. So the best way is probably `isinstance(i, Sequence) and not isinstance(i, basestring)`. **EDIT**: `Iterable` is better than `Sequence` in this case.
Bit-banging of the top of my head. Things where the specific bytes matters, for example network protocols. Typically the kind of things you wouldn't consider writing in Python. Sort of Threading, although that's changing in P3.3 or so we are told. tl;dr - whenever performance is more important than getting shit done.
&gt; Is it possible to run php and python on the same apache server With Apache, friggin anything is possible. *Should* you do it? No. My best advice is to avoid mixing languages at all costs. Anything you can do in PHP you can do in Python (and vise-versa). Don't tack a Python piece onto a PHP site just because you want to use Python. If you can build the service best in PHP, do that. If you can do it best in Python, then do that. In the words of Ron Swanson, "Don't half-ass two things. Whole-ass one thing."
The "best" way is probably doing away with `isinstance` altogether and instead determining if the object supports iteration, for example by calling `iter(x)`. Custom objects that support iteration do not necessarily have to be of a given subtype, which is partially responsible for the flexibility that Python offers.
&gt; It’s been said before, but if you don’t care enough to do some research and thinking about us and the position before you come in for an interview, why should we think you’ll care once you’re hired? Good lord, such hypocrisy. On many jobs boards (craigslist.org, /r/jobs), less than 25% of the programming listings will even tell you the *name of the company* let alone give you an accurate description of the position. And the corporate job listings, well fat chance you are going to learn much from a corporate designed recruiting page. I understand this is largely because if you give away any information at all, you will find yourself with an army of headhunters eager to send you some choice candidates for every critical position you are trying to fill. But this dope doesn't even give us the name of the company he is pimping for, and he is looking for programmers! Otherwise, TL;DR
&gt; Bit-banging of the top of my head. I would like to disagree here. `struct` module makes it a breeze to deal with file formats and protocol parsing. Though I agree on the performance part.
Crude, but effective :)
The ATMega Controllers are nice because you have (compared to many others) much space and ram at a low price. You can programm them in C, Assembly or some BASIC dialect, IIRC.
No it doesn't, not in Python. In Python "readability counts" (read the Zen of Python). This just "looks wrong".
Understood. So, I'll use mod_python
depending on the size of your project you should look into django or one of the smaller python web frameworks (flask, etc.)
On the contrary, trying to learn C coming from Python makes me want to bash my head into the wall at how complex even simple things are in C. That said, it is really interesting to learn how all the data is structured and stored in memory, especially because many things can be found in Python in a similar, but simpler way. It makes me appreciate how much simpler Python is as well :)
That is odd, I can't type ^ followed by enter like that. Did you try pressing the caret key followed by space?
Not all jobs are discovered through jobs boards, and not all job descriptions are corporate job listings. Like cocoon56 says, by the time you're going in for an interview, you know where you're going and can do some research. OP is talking about the experience of sitting across from someone who is sleepwalking through their own career. I can empathize; I've interviewed many people who had absolutely no idea what they had in terms of skills, what we did, or what they were looking for. It is a huge waste of time for everyone involved.
Yeah I mean, that's the thing, it's a modifier key so you will have to press space afterwards if you just want the caret itself.
Came here to suggest this. For someone with no programming experience TW would be the best option, as it's super simple - if it were windows, I'd be suggesting notepad.
Should probably use "is", not ==...
Kind of reminds of the science fair projects I did in middle school.....not!
As i just wrote in comment below, i get the stdin from a barcode reader, and it uses that modifier key to signal "end of transmission". Is there any way to capture that the caret key has been pressed, even though it doesn't return a character? 
If all else fails, you could capture different key presses and then emit 'Å' and '^ ' to the machine.
try http://beets.readthedocs.org/en/latest/
I came back here to quote the same thing. I don't mind doing a little research about where I'm going, reading up on the corporate propaganda from your website, but I'll care a hell of a lot more when you're paying me. This is business, not a clubhouse.
I made a github repository instead. I don't have an alternative hosting provider and its got programmer and reddit relevance. People can send pull requests and we can have multiple FAQs if necessary. I think at this stage my plan is to pull out a selective set of upvoted answers, kinda like /r/BestOf, but us. I would have preferred this stayed in reddit (saves re-typing comments) but whatever. https://github.com/darthmdh/rPython 
&gt; On many jobs boards (craigslist.org, [1] /r/jobs), less than 25% of the programming listings will even tell you the name of the company let alone give you an accurate description of the position. &gt; &lt;snip&gt; &gt; I understand this is largely because if you give away any information at all, you will find yourself with an army of headhunters eager to send you some choice candidates for every critical position you are trying to fill. The postings are more than likely put up by the headhunters themselves. Why would a recruiter just give you the name of the company they're getting a cut from so you can just go directly to the source and they get nothing? As much as I completely despise third-party recruiters, this makes perfect sense. It seems like you didn't get it so you spent time going off on your own inaccuracies. If you get a callback from submission to any of these job postings, you'll get the name of the company and you're in the door with them. It's not like these nameless postings remain nameless all the way up through the interview and you just show up at an unmarked building and talk to unnamed people who expect you to suddenly know about their company. Plus you called him a dope, so downvoted.
Once they respond to you and say "hey you submitted your resume on $JobSite, I liked your resume, I'm from XYZ Corp" you have their name.
keypad mode has nothing to do with the numlock key on your keyboard. If you read the curses documentation I linked to, you'll see it is a setting for the curses library that will tell curses to return individual keystrokes rather than waiting for chaining. The caret key is clearly bound on your keyboard to something that enables diacriticals, its common on the central european keyboard layouts to do this so I've heard. With keypad mode on your getch() should return when you hit the caret key. For a list of the "special values" inferred in the documentation, try running: &gt;&gt;&gt; import curses &gt;&gt;&gt; dir(curses) 
iter(x) will still include strings.
Sublime is great but it's still for python 2.
True, but there are dev shops that work predominately with Python technology.
I have gotten my last 3 jobs from Craigslist. I honestly can't remember if the earlier two had the company name in the posting. I'd send an intro email, and get one back with who the company was, website, what they did, etc. First two were direct, 3rd one a recruiting firm did it. Each time I was told the company name, website, contact info (both for the company and who I was contacting) very early in the process. And honestly, so many positions nowadays almost don't fit in a job description that I can't blame anyone for that other criticism. Currently, my title says "software developer." Yes, I write some code, but a whole heck of a lot of my week is spent not developing software. It's spent doing lots of little things that are necessary to the business, and which I am the optimal person to do, but they are not developing software. I don't know how I would summarize my job for a posting. I'd probably just say "get me a good software developer who's flexible and can learn quickly, and he or she will be able to figure it out." The other slightly relevant thing about my most recent job-finding experience - I was hired on my ability to write C++. I like C++, a lot. But I have written roughly 0 lines of C++ in my 7 months here. I *have* written tons of Python though. As in - every time I need to write something that is anything more than a one-off bash script, it's Python. And that's a LOT of the time. Only other coding I do is maintaining legacy Perl (bleh). I honestly sort of don't like the phrase "Python developer." Not because I don't like Python, but because a good developer isn't defined or limited by what languages he or she is good at. I think my Python skills are pretty solid, but I'd never call myself a "Python developer" or a "C++ dev" or a "Ruby dev." And as a person with input to the hiring process, I'll take a capable developer with little knowledge of the tools we use over a bad developer who knows a bunch of Python (or whatever language) tricks any day.
A bound method simply receives a reference to the object or class automatically as its first parameter. This is how the function closes over the state of the object. They're syntactically different for convenience, but they're both the same thing in the end. You could force this behavior manually through clever definitions of functions, so that you have a fully functioning object-method system relying only on unbound methods/functions). The point is that Python doesn't use the standard definitions of 'method' and 'function', nor does it really distinguish between the two properly. A static method (not class method, but static method) and a function represent the same object, just in different namespaces. 
I used to use C/C++ when constructing tools for embedded uPs and FPGAs. Now, I am sold on Python because I get something together in 50-75% of the time it would have taken me to do in C. ------ **tools I've created recently** -custom format extractor -binary image alteration -post build tools for inserting device addresses and boot loaders into Intel Hex Records -frontend CLIs and GUIs to test, control, and record data from embedded hardware -in system programming scripts ----- I wish I had a C/C++ parser that would generate proper Python structs. http://docs.python.org/library/struct.html 
I completely agree that sets would be more useful for this, I just didn't use them seeing as I didn't think it would be a big issue for an example snip of code. In Python is trivial to switch data structures. I mean, literally just adding a single import and switching from "list.append()" to "set.add()". Anybody with even the most basic knowledge of computer science could look at that code and say, "For my needs, it would make more sense to use a hash set, because is has O(1) average search time, or a red-black tree because it has guaranteed O(log n) search time and I need something with a worst case that isn't O(n)". I'm updating my code since it's been brought up by multiple people, I just wanted to make a point that there is no one-size-fits-all solution. Good programmers look at what the requirements and time constraints are, and make judgements regarding underlying architecture. If you're copy/pasting code off the internet into a production system, you're doing something horribly wrong.
&gt; What exactly constitutes a "Python" job? This: &gt; My current job is heavily into Python
&gt; why? Under the assumption that OP is building a single application that uses two languages: 1. Code duplication. Functionality is duplicated for both platforms. Libraries may be incompatible or have different, unexpected side effects. 2. Decreased supportability. If you're building an app that relies on two back-end languages, the person that needs to maintain the application down the road will need to know both languages. 3. Risk of misconfiguration. By having two sets of configuration, two sets of best practices to follow, etc., you're automatically doubling the attack surface of the application. There's twice as much of a chance that you might have misconfigured something. 4. Organization. By having two platforms, you automatically make it more difficult to manage which part of the application includes which functionality. Moving components or adding components requires extra documentation to figure out where the appropriate place is to do so. 5. Increased stress during setup. Any time the application needs to be installed on a new server, there are double the software requirements, which means you need to have the right version of Python, the right version of PHP, the right version of Suhosin, etc. Having additional software requirements like this also decreases your ability, in some cases, to install other applications on the same server due to requirements conflicts. Those are probably the most important reasons. There are more, but if it can be avoided, applications should stick to a single language.
On the contrary, he made it very simple. Ruby arrays, for instance, have a built-in flatten method. Performing the original task becomes so simple I wouldn't even think of writing a method to do it, `puts a.flatten.join("\n")` Maybe the `flatten` implementation isn't completely simple, but it adds a very useful layer of abstraction and makes other things much much simpler.
I see your points and you are right in general. OP should definitely think about these things.
It's not hard to run a couple of commands to start a new project. Stop using and promoting Fabric as it is crap. You now have more code to maintain and have introduced new dependencies for very little benefit.
You ought try one of the freelance websites.
Thanks for the read. I think this might do well x-posted in /r/cscareerquestions, just a thought.
Any suggestions on a good reputable one? I tried a few and didn't get any worthwhile responses.
I wrote one too: https://github.com/grahamking/tip
what are the size of the images? the landscape ones and the portrait ones
The sizes vary, but the aspect ratio is the same. On the large size probably 1875 Pixels wide
I've had two development jobs, and despite hordes of recruiters pestering me all the time, both times I got the job without going through recruiters. If I want a new job in the future I won't bother with sites like Monster and Reed. I think the way job boards seem to work just isn't a good fit for developers. In most cases I think we're better at sorting out this kind of data than the recruiters are, and they're therefore a superfluous annoyance. I'd put together my own custom job feeds using Yahoo Pipes in order to aggregate likely-looking jobs from numerous job boards into one feed, and there were loads of jobs I'd already dismissed when some clown would phone me up and try to persuade me to apply for them. IMHO job boards should have cut out the middlemen - instead the middlemen have taken them over. There are a few job boards that get it right. I'm quite impressed by [Hacker Jobs UK](http://hackerjobs.co.uk/) and [Stack Overflow Careers](http://careers.stackoverflow.com/) in particular.
 def print_elements_internal(ulist): print_elements_internal.ids.add(id(ulist)) for i in ulist: if id(i) in print_elements_internal.ids: print "Circular reference to " + str(i) elif isinstance(i, list): print_elements(i) else: print i def print_elements(ulist): print_elements_internal.ids = set() print_elements_internal(ulist) Solved and made more efficient by the lack of hasattr check. :)
How many lines do you think it should be?
This brute force solver gets the answer in about 12 seconds on my machine: http://pastebin.com/5cDC39Wf A nice job for itertools.permutations, &lt; 30 lines of code. If you want to be faster you'll have to get more clever; but do you want to be faster?
This is exactly why I brought this to reddit. Thank you so much for your feedback. I made this over the weekend without a good project scope in mind so I am probably going to work on rewriting it over the week. * I really like what you said about Extensibility, that is probably #1 on my todo list for this project. * I was going to use SQLite but I really wanted to be able to tinker with the logs in a spreadsheet. I agree that I should make it more human readable. * I have since fixed the bug you found. Running sourglass without arguments should toggle tracking on/off on the last project you altered. * I wanted to be able to track more than one project at once but now that I have used it I think that I should auto-suspend the old project unless the -m flag is set. * I am planning on including the current status with the -t flag. Once again, thank you for the feedback! I will definitely share my next project here. EDIT: added bullets for readability.
Is there? Anyone else care to weigh in? I'd be interested in seeing it if there was..
&gt;try calling that from 2 threads, see the world burn True. &gt;you just created a function that wraps around, ids was supposed to be a parameter, not an attribute of a global function Supposed to be? Since when? Just because you mashed "it does not cleanup use a additional optional argument instead" onto the keyboard doesn't mean I was going to do it that way.
What do you mean by control-v? Is is paste or is there something else?
This is a subreddit dedicated to: &gt;news about the dynamic, interpreted, interactive, object-oriented, extensible programming language Python Please submit such posts to other sites intended for coding in exchange for compensation. Unfortunately, I don't know of any other subreddits intended for this on this site (although they may exist!) 
He just wants to iterate all grades possible and what he'll need to get on the test. The title is badly worded, but obviously he's learning.
http://www.iaza.com/work/120530C/iaza12276688025000.png
Okay, I had to change the last line to "print(x, gradetest / seconddec)" Thanks so much!
Take a look at running your python app out of gunicorn (WSGI): http://gunicorn.org 
Like this: http://codepad.org/PHnHw452 That what you're looking for?
Would you mind posting a link to the source code?
I think you're using python 3.x. So you can try this in python 3 flavor: print ("{0} = {1}".format(x, gradetest / seconddec))
I would recommend using sqlite for your database and writing an export function for CSV. It'll give you more options in the long run and you could even write exporters for other formats like JSON, XML, or YAML.
Maybe a little?
What does it do?
I assume it would use less memory than a browser running reddit, but this remains to be seen.
http://www.bbc.co.uk/news/education-16493929
Bingo. Also, some things that I'm planning to add should enhance the utility of it, for example a save for offline viewing feature.
It'll be up in a little bit. I'll post the link once it's up.
I'tried. But for me it's a bit messy. I develop some application using php and it was quite easy and well documented to understand how to write code. But in fact, more I try to use python with gunicorn more I have trouble to understand. So I need to learn a whole part of python WSGI and it will take time. Do you know a good place to learn WSGI ? 
Then you should be using a microframework like Flask.
You don't need to learn WSGI. I would avoid it unless you get into larger apps. You can set it up FastCGI style, then it is easy to understand and works fine.
For someone first getting into it, easiest thing to do is just run your python application on some port, and reverse proxy to it.
tl;dw * Keep in mind that 'self' can be not only an object of the class you're writing, but also its child, so that people have easier time subclassing later. Similarly, when you're writing 'super', it may mean a class totally unrelated to the class you're writing, because it may be its child calling this method, and 'super' will be from this child's ancestors tree, not from your class' ancestors tree. * In "bondage and discipline" languages, parent classes define interfaces, parent classes are 'in charge' (they call the extended interfaces of subclasses), and subclasses mean specialization. In python, subclasses are 'in charge' (they delegate work to their parents), subclasses reuse parents' code by pointing to the dictionaries of parents' functions. Consequently, when you're deciding which class should be a parent, and which should be a child, the answer is not lying in 'which is a specialization of which', it's in 'which class has more code to reuse'. * Liskov substitutability principle is 'subclass should work in all the places where class works'. If you violate it (which is OK), you better separate this violation and put it in one method, so people have easier time subclassing later. * use `__method_name = method_name` idiom when you want to make sure that by overriding `method_name` a subclass will not break your other methods that use `method_name` (in your other methods, call `__method_name`). This is open-closed principle: your classes should be open for extension, but closed for modification. And that's what dunder is for.
Agreed. The article is misleading at best.
My rule is that I should be able to replace every `tuple` with a `namedtuple`.
What would a music-generated L-Tree forest look like ?
In the python world, you define functions. If they are defined outside a class they're just functions. If they are declared inside a class, they're called methods of that class. The name "procedure" is not used in python, but is used in other programming languages. Procedures are functions that don't return a value. In python, even if a function doesn't return a value, it's still called a function, not a procedure. Some programming languages may call functions with other names, like routine or subroutine. For example, in Visual Basic, functions are called subroutines. HTH.
&gt; Things I learnt from reading your code except Exception as e: &gt; &gt;I've always used &gt; &gt;except Exception, e: `except Exception as e` syntax works only for Python &gt;= 2.6.
I think he's right, but I also wish we had immutable lists. (And immutable dicts, while I'm wishing.)
[inotify](http://en.wikipedia.org/wiki/Inotify) ([Python module](https://github.com/seb-m/pyinotify)) **EDIT** Don't take that as offense or something that makes your tool useless. Take it as a suggestion. Maybe you could use that as an alternative method to do things.
You make a good, albeit brief, point. And, sure, OP's solution isn't the most efficient way to monitor file system changes, but I doubt it was meant to be. Multi-platform file system monitoring is actually quite complicated, and then this solution wouldn't be "minimalist" any longer.
I don't think there is any such rule. There's plenty of underscores in various built-in methods, for example `set.symmetric_difference()`, `int.bit_length()`, `float.is_integer()`, `dict.has_key()` (deprecated, gone in 3.x), `str.format_map()` (new in 3.2). And obviously if you venture out into the standard library there are countless examples. In any case, `raw_input()` is long gone in 3.x so it hardly will be an issue for long. 
Looks interesting, I've been eyeing for a nanoc replacement. Question: does it handle routing of files (images, assets)? And does it rewrite internal links depending on the different locations of an asset relative to the destination of a page/post? Couldn't find it in the jekyll page. Edit: just tried to generate your example in the doc dir (is looking very fast btw). A small problem, leading slashes everywhere which makes the links not work.
Still, he was talking about builtins like max(),min() etc and your examples are of a completely different class.
You're doing it wrong (;-)). Consider not mixing pure (calculation) code and IO things too much, see e.g. https://gist.github.com/2838535/eac0068536e0960bcd7384c220d4e524128190a9
Not at all. :-) I am in fact I am aware of inotify (linux), fsevents (mac), and [windows file monitoring](http://msdn.microsoft.com/en-us/library/aa365261\(VS.85\).aspx). In a future version I am planning to integrate them with this system. Yet for now this is good enough for my needs. If you want to help by submitting a patch, you are welcome. The only requirement is that it must fall back to the current portable solution when those APIs are not available.
Does it really matter whether they are methods or functions? They're still built-in to the language, and my point is that names with underscores in them are rampant both in the Python core and the standard library. It is only by pure chance that there happens to be one built-in function with an underscore in its name (in 2.x at least.)
I see, merci. With routing I mean describing which files move where and how are they processed. Lets say I add a folder with images, and I want to copy that verbatim, is that possible? Or if I want process files in &lt;somedir&gt; as posts too, or apply a certain template by folder.
In your Quickstart manual you say I should install Obraz using pip. For me that means using a virtualenv because I don't want anything in my system that does not come from my package manager. For me that totally knocks out the advantage of being single-file because it adds the step of dealing with a virtualenv to my workflow which is definitely one step too much. You should think about that. You could say that users only have to download your file to get started and - as another possibility - there is pip. **EDIT** Jinja as a dependency? What's the point in being single-file then at all? **EDIT EDIT** Consider something like [Bottle's SimpleTemplate Engine](http://bottlepy.org/docs/dev/_modules/bottle.html#SimpleTemplate).
two unnecessarily jinja2-hardcoded gens in one day, see [my other comment](http://www.reddit.com/r/Python/comments/uci1x/obraz_static_site_generator_in_a_single_python/c4uajzh).
Any advantage of this over [watchdog](http://pypi.python.org/pypi/watchdog)?
Maybe you're right. Please file a feature request in the [issue tracker](https://bitbucket.org/vlasovskikh/obraz/issues) if you're interested in getting it implemented in the future versions. 
Not completely sure because I do not know watchdog very well. Some of the differences I see is that workflow allows to associate actions to events with a delay. Such as delete a file 1w after is was last modified. It also allows to have multiple rules involving the same file type easily. It allows me to check the state of the system by looking at the filesystem only and allows me to serialize the execution of actions if I want to. Perhaps I can do all of this and more with watchdog which is a much more complex and sophisticated package but, at a first look, seemed to me that it involved more programming than just making workflow. If you have many files to monitor and only need to respond to create/modify/delete events, watchdog is probably better because it is event based and uses os callbacks. Workflow loops so it gets slower when you start having too many files.
 You can send the whole file to be evaluated, I think the default mapping is F4. At least, it is on mine. The value of it for me is that it makes the definition of objects available in a tooltip inside your vim session. And I also had a bit of trouble. Mismatched architecture in some extraneous library, ended up having to link against the 64 bit version. But I will agree, it's not life changing. But handy. Even without, I still would use vim and ipython. 
Ok, I see. It seems to me though that you could probably use watchdog as a cross-platform backend for monitoring the filesystem and you can keep the cool extra logic supplied by workflow. Also, why use a custom config file as opposed to YAML? I like your plugin btw. It fills a gap with the whole time delay/multiple rules thing.
Thanks. I did not use YAML because I wanted to avoid dependencies and therefore I want for something easy to parse. I like your idea to replace the outer loop with watchdog, it will make it more efficient.
I will make a setup.py eventually. Here are some of my personal use cases: - My web applications tend to create lots of files (session files, error files) and they need to be cleanup periodically. I also may want to receive emails when error logs are created. - I download many large files that need to process. For each file downloaded the processing involves running a sequence of programs each reading output of the previous program. - I have multiple machines sharing a dropbox folder. I want to have a workflow running on one of the machines and i want to trigger the workflow by creating instructions files on another machine. Think of creating a file on my laptop with a list of URLs containing data I want to process, and my office machine syncing the dropbox folder, and initiating the desired processing of those data. 
I don't always drink WSGI, but when I do it's with Gunicorn. To be honest I haven't dealt with it much, but was dealing with issues and found Gunicorn a while back that seemed to help work as a gateway to funnel my python programs through.
PEP 8 says separate words in function identifiers with spaces. The other built-in functions either predate that rule or represent types, which I guess by convention don't get underscores. (Like their CapitalCased counterparts.)
I'm watching this in 3d, totally not worth the $18.
I assume names like execfile break the rule. Should be exec_file according to PEP 8.
It is not hardcoded because I'm lazy, it is hardcoded because it is (currently) required for core functionality like incremental compilation and filters, not only for basic template rendering.
I did, but if there is no Python support on the initial release I will be sad.
If there's no python support I just lost $15
2k in four hours, 13k and 38 hours to go. This might *just* work.
Threw in my $50. I'm very much looking forward to playing with an IDE that takes such a unique approach. I think diversity like this can really up the quality of the programming tool gene pool.
It will support Clojure, Javascript and Python... That sounds like an odd combo for anyone other than web guys..
People will describe their problems to python-based bots in order to produce more python-based bots that will describe the problem using python to other python-based bots who'll use python to solve the problem. Finally, a python bot will offer the solution back to the puny human. The IDE will be named Overhead. :)
There's no raw_input() in Python 3 anyway, so it doesn't matter.
Obraz has a slightly different syntax for permalinks in order to re-use Python's built-in string formatting. See [Obraz compatibility with Jekyll](http://obraz.pirx.ru/jekyll.html). You have to put your page into pagename/index.{html|md} in order to generate _site/pagename/index.html. 
Honestly, we're so close to 300k they'd be huge assholes to not do it anyway.
The latest commit in SQLAlchemy-migrate was on [23.01.2012](http://code.google.com/p/sqlalchemy-migrate/source/detail?r=e62fdba4dbcea7e0a3e9b2b6e5c54270a7616f2e), so it's still alive and being developed, though not very actively. We've been using it in production for a while (almost a year) and haven't yet stumbled into lack of features. From our experience, it's absolutely safe to use this library in the project. Of course, there's also [Alembic](http://alembic.readthedocs.org/en/latest/), which is being developed by SQLAlchemy's author, but I haven't tried it in a while (though I see that there has been some extremely active development in the past few months). Judging from documentation, it has evolved into a pretty solid library, so I recommend you give it a try.
Just pledged my $50. Even if Python doesn't make it, I'd love me a decent Clojure IDE (VimClojure just ticks me off, even though I'm a diehard vim fan).
Nothing (except they serve the same purpose). He asked for an alternative. Perhaps I misread the question.
For migration tool alternative, not for an SA alternative.
Ah, many thanks again. When I read the compatibility page I completely missed that that was actual syntax, I thought it was just an example of the result ;) I have not found a way to apply layouts based on filesystem location yet, and how exactly do you handle multiple posts on the same day? I saw some tag related stuff in obraz.py, but is not used yet. Is that what you mean by you have yet to implement the category system?
Other engines support these concepts, and an abstract API can be provided. See the example of the [sphinx template bridge](http://sphinx.pocoo.org/ext/appapi.html#sphinx.application.TemplateBridge). 
It's now over $290k, with 30 hours to go.
Perhaps you are right. It is a matter of interpretation. Do you want me to apologize? I apologize. :-) To everybody else: "There are always alternatives", Spock, "The Galileo Seven", stardate 2822.3
composite keys = bad practice, huh? Yet another indication that web2py is *not* for me
How the the pledges per day go negative?
I assume you mean like this: class Config(dict): def __init__(self, **kwargs): super().__init__() self.update(kwargs) Well, because I prefer defining the config like this: class Config(defn): optionA = 1 optionB = 2 optionC = 3 ...rather than this: config = Config(optionA=1, optionB=2, optionC=3) Also (if the above dict subclass is what you meant), then it's really no different than: config = dict(optionA=1, optionB=2, optionC=3) Is it? 
It's already more or less working (he showed it in his demo).
 Config = dict( OptionA = Foo, ... ) Has (most of) the visual appeal of a class without using a cannon to kill a fly. For subclassing emulation you could just add a dict.update-like method which copies the original, updates the dict, and returns. ~3 lines of code
This is blackmailing.
I think I'll stick to good old Vim.
Ahh the article wasn't clear. It sounded like he didn't like typing in quotes when writing a dict for configs.
Try using [wx.Timer](http://www.blog.pythonlibrary.org/2009/08/25/wxpython-using-wx-timers/)
Could you elaborate on why you feel that way?
Emacs?
Threw in $15, but since I don't use Clojure or JS it'll suck if I don't get my py support. 
I think that conditioning a feature on such a restricted and money-stocking (i'm sure that term doesn't exist) way &gt;("help us get N quantity of mone in M time") is **directly** invoking on people's fear of not getting such feature. Of course I am exaggerating a little, but I cannot stop thinking in blackmailing :/ EDIT:formating
$8k and 24 hours to go. Ugh.
This is one of the reasons we made web2py 4 years ago. This is the web2py code for your second (longest) example: def contact(): high_priority_user = auth.user and auth.user.high_priority form = HighPriorityContactForm if high_priority_user else ContactForm form.table.email.default = request.user.email if auth.user else None if form.process().accepted: #check post automatically send_contact_message(form.vars.email, form.vars.message) if high_priority_user and form.vars.urgent: send_text_message(form.vars.email, form.vars.message) redirect(URL('contact_thanks')) # response.view = 'contact.html' ## is automatic return dict(form=form,high_priority_user=high_priority_user) 
mariuz, Thanks so much for responding. I've used Firebird for years, but not with Python. I'm getting (back up to) speed on Python (used it a few years ago for 1 project). Where is the documentation/example code for FDB? I don't see it in FDB's PyPi web page. Also, does SQLAlchemy work with FDB? I've just barely scratched the surface with SQLAlchemy, hence my ignorance.
if you supply an interface, others will supply the template-engine specific knowledge. Also keep in mind the concept of graceful degradation. So what if some engines don't report accurately regarding changes in parents? Those users disable the feature.
Depends where you are - in Finland for example, outside mobile stuff (the dying Nokia/Symbian market and the usual iOs/Android crap) it seems to be the usual enterprise work (SAP, Java, .NET) and maybe some PHP. I've not seen a single Python position here, not even a few Ruby jobs. There's a lukewarm startup industry (other than Angry Birds :-)) but it seems to be mostly one-man ex-Nokia bands at this point. Would love if some Finnish Pythonistas could prove me wrong :-)
Moo hoo ha ha ha! From OP: "When I pondered metaclasses as a solution, I was a tad hesitant because they can obfuscate code. Someone else taking a look at your metaclassy configuration code won't intuitively suspect what is going on. But, being a mad genius ('mad' may be the only accurate term there) I decided I'd go for it anyhow."
I was wrong: [it's ready today](http://www.python.org/download/releases/3.3.0/).
I really prefer config files just be regular python files with CONSTANTS in them. Our projects are all laid out with a in-source-code "default" set of settings in `default_settings.py`. For instance, `default_settings.py` might define EMAIL_HOST = "localhost" EMAIL_PORT = 22 The actual app though looks for `settings.py` (just `import settings`) which is NOT stored in the tree; it contains any locally overridden settings, such as DB passwords. `settings.py` is: from default_settings import * EMAIL_PORT = 8022 # port 22 is blocked on this machine via firewall This has the advantage that `settings` is just a module -- you can pass it around, modify it, run `dir(settings)` to see all of the settings, etc.
Ouch!
You know that this is not what the word blackmail means? They do not have some dirty secret which anyone would like to remain secret, nor are they threatening to release such information if they are not paid to keep it secret. This is called Funding. "We can afford to implement two languages for our kickstarted required minimum investment total. We will do JavaScript and Clojure. If we raise the additional money required to do the additional work to implement Python, then we will implement that as well." "People's fears" can do whatever they'd like, but the fact is that time is money, and development of support for an additional language takes time.
Ok, you need to take a little more time reading what you copy-paste: &gt;any payment extorted by intimidation, as by threats of injurious revelations or accusations. &gt;__as__ by threats of injurious revelations or accusations. See, accusations and revelation are just examples of chantage (which, btw is also an english word. Again, read better)... the main point in chantage is the payment by means of fear/intimidation. Wich applies here as well. I don't know if you're north american but U.S.A. is the best example of culture of fear. Maybe you're just too deep in it to realize it.
Because a final comment means succesfully migrating conversations. Stop being so defensive, don't take it seriously this is just reddit, have fun!
I'd consider a requirement to only ever have integers for primary keys a serious limitation. There are definitely times with new databases when a surrogate key is definitely not the best solution.
i should be bumping that soon.... been lazy on putting out 0.3.3
Here's a few more data warehousing-related use cases for those that prefer to avoid ETL frameworks in lieu of ETL libraries &amp; toolboxes: * file movement - ideally, data flows through an ETL process as a sequence of files (usually easier recovery, eliminates database complexity from ETL, is a commodity interface, etc). Rsync isn't the best - ideally you've got a file movement tool that support pre &amp; post actions for both source &amp; destination. This allows you to prevent a downstream autonomous process from picking up a file in the middle of being transferred, etc. * file archiving &amp; roll-off - this can be handled by a separate process looking at data retention periods. * etl program execution against a specific file - rather than have transform &amp; load programs polling for new data this process could centralize that and execute as necessary. Might need a some throttling features though.
Yeah... and once you're into compiled languages, there's nothing stopping you from making it a nice visual IDE for, say, C (a la Tenacious C, with cool pointer visualization maybe?) except for the fact that you've got a pretty large and purpose-diffuse program there. 
Python's [data model documentation](http://docs.python.org/reference/datamodel.html) makes it clear that reference counting is an implementation detail that should not be relied upon. Any functionality that depends on the timing of the `__del__` call should be considered broken. However, there certainly does appear to be a bug in CPython, which thankfully has been fixed. 
$298,656 So close.
Down to less than a thousand. I'd say we can expect some python love, not that we weren't in the first place.
Yes, tried Emacs with SLIME. Was still disappointed.
as of now, the goal is met
In my experience, "mad genius" -&gt; mad idiot.
Massimo this looks like something I can use. Can this tool allow what I'm scheming here (Windows): if I code Excel VBA to output at runtime a file (signal.txt) into folder X and signal.txt be (almost) immediately detected and a someprogram.py be kicked off.
Oh thank goodness. I was worried that it would be close.
of I didn't mean that as a burn or anything, just that if you want that sort of thing, Python's probably not going to yield a lot of fruit for you. Python == Legos Ruby == Oil Paint You can be creative with both, but two artists on one painting is a mess, but large groups can build amazing things with legos.
What's wrong with it? It's just for payment.
In what world? To develop a fully-featured completely new IDE... that should take a lot *more* money.
I will be sad, but only for a moment--they said they'd keep releasing plugins, and make it so others can easily make them. It'll get in there.
Nah, you just went full-on crazy-pants there. You ever pay more for an upgrade to a hotel room or new car? Think of it like that.
&gt;Beautiful is better than ugly. &gt; Explicit is better than implicit. &gt; Simple is better than complex. &gt; Complex is better than complicated. &gt; Flat is better than nested. &gt; Readability counts. &gt; Special cases aren't special enough to break the rules. 
So, I assume that the web2py DAL doesn't have support for CASCADE updates? I guess that would make sense - have such a wide support for different dbs (some of which are not fully "relational") you have to implement the lowest common subset of features.
Redditor spookylukey leaves this sage comment below the article: &gt; It also has the disadvantage that doSomething has to come after every other top-level function/class/constant that it might use, since it gets executed as soon as it is defined. And so I feel that these @main decorators really don't save enough to be worth it.
Also, python for web development sucks due to deployment hell. EDIT: Downvote all you want pythonistas, you know its true and it hurts doesnt it
Well you dont have to use CBV, if you feel that a function handels it better write a function. Easy as that. 
Thanks, Larry. Entertaining and informative, as always!
Sir-jeep (but you don't sound the r)
&gt; I think the moral is - don't do OOP. That's a bit too prescriptive (and proscriptive) for many situations. OOP has its place, otherwise why would web2py use objects? The difficulty in OO design is not specific to the idea of a framework - it applies to libraries, too. Unless a library or framework author can predict the future, they have no way of knowing how things will evolve. For example, just in the area of authentication, things have evolved from "keep the user credentials in your database" to "use OpenID" to "use OAuth" and some sites might use all of these options. To design the original authentication system to allow for this evolution would have been possible at the outset, but not easy. Out of curiosity, how does web2py allow one to have an authentication system which offers any mix of those three options?
I'm not developing the thing(and I'm happy with emacs), but from what I gathered from the second screencast it will be an extendable platform with a goal of making it trivially easy to extend to do things like listing db calls, http requests, api calls. Someone would need to build those extensions. And the hope is that it will be easy. Will it? who knows. You can do the same thing in eclipse but it's painful java bullshit. I'm assuming this will be initially clojure until someone builds the various bridges between languages. But really it's too soon to tell. I'm adopting a "wait and see" policy. 
In before vim. I used to use eclipse + pydev before I hated the bloat. Pydev is a pretty cool tool. You might like ipython notebook if you like matlab.
Yes. Web2py support these authentication methods and combinations there of: https://github.com/web2py/web2py/tree/master/gluon/contrib/login_methods Web2py is object oriented. Everything exposed to the developer is OOP and in some sense more than in Django. We do not do: Poll.objects.filter(pub_date__year=2012) but we do instead db(Poll.pub_date.year()==2012).select() Just the workflow logic is procedural. We think it makes the code more readable. The functionality is not that different from Django. The syntax is a little different. 
I've been having a great time with KDevelop (with the Python plugin). Check out [these](http://scummos.blogspot.co.uk/2011/06/basic-list-content-type-support-in.html) [few](http://scummos.blogspot.co.uk/2011/09/kdev-python-argument-type-guessing.html) [posts](http://scummos.blogspot.co.uk/2012/04/improved-code-completion-in-kdev-python.html) to see some of the things it supports for Python. Otherwise, simply using Kate will give you all the syntax highlighting you need.
You are right. We support ONDELETE CASCADE but not ONUPDATE CASCADE. We have plan to add it but none of our users as ever requested it. Oracle does not support ONUPDATE CASCADE.
have you seen [this](http://www.chris-granger.com/2012/05/21/the-future-is-specific/) or not. Because I shared some of the same "concerns" as you, but that gives me hope. Still, it's going to take a LOT to tear me away from emacs. Because if those visualizations can be whipped up quickly in my language of choice, I could totally see myself coding up what I need. After all, I can already standup an http proxy in my setup/teardown that logs all the http traffic. I can pass a custom configuration during setup/teardown to echo all the sql traffic from sqlalchemy. i could do the same for taskqueues if I wanted. All the information is there in my log buffer and I have to grep/search to make any sense of it. It's not too hard for me to imagine redirecting that log output somewhere else where it can be represented better than linear. I dont use pycharm , but the other dudes at work tell me that at least for django templates that simple case you describe is indeed solved. Thanks for the enlightenment on what a "typical" web application entails. LOL In all my years of doing them, I had no idea, and thus I should probably quit and buy a farm or some shit. /sarcasm 
i swear by [wingide](http://wingware.com/). all the features you could ever need, and their support is always responsive and helpful when i need them.
I absolutely love wingide. I wish there was an equivalent for all languages.
PyDev is my favorite followed closely by PyCharm. PyDev is free, PyCharm is not, so I suggest you try PyDev!
Vim.
vim or emacs. why do you need anything else for python?
Oh I agree. I just found the exercise really interesting.
[http://www.reddit.com/r/Python/search?q=IDE&amp;sort=new&amp;restrict_sr=on](http://www.reddit.com/r/Python/search?q=IDE&amp;sort=new&amp;restrict_sr=on)
I was looking at a broken link [here](http://docs.pylonsproject.org/projects/pyramid/1.3/tutorials/modwsgi/index.html) but I found the other docs for mod_wsgi [here](http://docs.pylonsproject.org/projects/pyramid/en/1.3-branch/tutorials/modwsgi/index.html) and they look like what I need. Thanks
hmmm weird, I wonder if the pyramid folks know about the broken link. anyway glad you found what you needed. 
cool thanks. 
[Its: possessive form of it; It's: contraction of 'it' and 'is'.](http://learnyourdamnhomophones.com/)
I'm not intelligent enough to critique the code specifically, but I wonder if using the title as the unique poll key is the right approach? Would the reddit unique id be better? Available? 
Oh look at you being all correct 'n' shit. Daww!
Lovely!
[Release info from python.org (stuff not listed on the blog)](http://python.org/download/releases/3.3.0/) Python 3.3 includes a range of improvements of the 3.x series, as well as easier porting between 2.x and 3.x. Major new features in the 3.3 release series are: * PEP 380, syntax for delegating to a subgenerator (yield from) * PEP 393, flexible string representation (doing away with the distinction between "wide" and "narrow" Unicode builds) * A C implementation of the "decimal" module, with up to 80x speedup for decimal-heavy applications * The import system (__import__) is based on importlib by default * The new "packaging" module (also known as distutils2, and released standalone under this name), implementing the new packaging formats and deprecating "distutils" * The new "lzma" module with LZMA/XZ support * PEP 405, virtual environment support in core * PEP 420 , namespace package support * PEP 3151, reworking the OS and IO exception hierarchy * PEP 3155, qualified name for classes and functions * PEP 409, suppressing exception context * PEP 414, explicit Unicode literals to help with porting * PEP 418, extended platform-independent clocks in the "time" module * PEP 412, a new key-sharing dictionary implementation that significantly saves memory for object-oriented code * The new "faulthandler" module that helps diagnosing crashes * The new "unittest.mock" module * The new "ipaddress" module * A "collections.ChainMap" class for linking mappings to a single unit * Wrappers for many more POSIX functions in the "os" and "signal" modules, as well as other useful functions such as "sendfile()" * Hash randomization, introduced in earlier bugfix releases, is now switched on by default [What's new in 3.3?](http://docs.python.org/3.3/whatsnew/3.3.html)
I'm surprised that Python 3 support wasn't one of the criteria measured.
Thanks for the reminder, I was waiting to see how close they were before I made sure to contribute. I'm still new to programming and am really interested in messing around with Light Table.
There are both advantages and disadvantages to each approach. When searching for a submission, only the bot's submissions are considered so this places the potential issue of multiple submission hits in the user's hands. In the use cases that I thought of, I expecting the create_poll class to be executed first and then after some time the bot would be logged in again to tally votes. Using the poll title as the key makes it much easier for the user to find their poll without having to save some nonsensical string for future reference. Both ways seemed reasonable to me, but I had my reasons for choosing to use the title.
That's pretty much useless unless you restyle the template using the Bootstrap classes.
Awesome. Always interesting to hear the process that went into some of the decisions. Thanks!
On line 174, you call a function 'trim'. Unless I'm missing something, that doesn't actually exist. Could you perhaps mean to be calling strip? Also, on that line, you can just call [1:-1] for the string subscription if you want to cut off the first and last characters, no need to deal with the string's length.
Heard about this right after I got Pycharm :(
There wasn't any criteria as far as I can tell. Author just wrote things that came to his mind. I'm not even mentioning the lack of bottle, web.py, Tornado and brubeck. I'd like to see technical reasons.
I only put it here because in the past I've found things really helpful even when they're not new. If you'd not posted the link I'd never have even known about 3.3 Alpha 4.
&gt; PEP 380, syntax for delegating to a subgenerator (yield from) YES! YES YES YES YES YES YESYESYESYSEYESYESYESYESYSEYESYESYES!!!!!
Is it just me, or is the RSS feed for this broken? I have tried iTunes, Instacast on iOS, and BeyondPod on Android -- iTunes and BeyondPod get a 404 when trying to download audio for an episode, and Instacast doesn't even try...
You downvoted me because you didn't like what I was explaining? Pardon the swearing, it was only to concisely illustrate the frustration that some devs feel about __init__.py (not me actually, it's whatever), so the reader can understand not only what the change is but why it's newsworthy and may make some devs happy.
I will prepare the documentation for FDB , i didn't had the time to clean it For the SQLAlchemy questions , Philippe Makowski one of the FDB maintainers use it but for details please ask on firebird python list http://tech.groups.yahoo.com/group/firebird-python/
Just joined the group, thanks.
He's not wrong, unless you revel in language minutae. Or enjoy doing your taxes.
It's not just you, the RSS feeds are kinda tweaked. It's been on my todo list to fix 'em for a while. Maybe I can find the time once 3.3 hits feature-freeze later this month...
Cool, I'll try again in a few weeks and listen to some past episodes in the browser in the meantime. Thanks!
I've been looking to play with this for some time! Thank you!
I don't understand why this is really all that useful. It doesn't address the issues of the 64 bit version on windows, which can be fairly frustrating. Also in my opinion they should have added a section on setting up a compiler for use with pip, as that can be somewhat complicated. 
Here ya go champ: http://docs.python.org/library/dis.html It's part of Python already.
Pure class. Pun intended but it really was an excellent talk.
The story is mostly that friend gave me a problem I found interesting. He sent me a .pyc he created and I want to figure out what exactly it is doing. So far I have done packet capture and have found out that it sends out/recieves encrypted strings as some sorth of authentication measure that I invariably fail (if I didn't I assume the program would continue doing...something). I figured if I decompiled it I could look at it and figure out what it wants/what it is intended to do. Perhaps even trick it to authenticating me. Honestly I am not stupid enough to do this sort of thing for nefarious purposes, I rather like my current life. This is just for a puzzle that I got sent.
You can import `.pyc` files just fine from the python interactive prompt. Then you can inspect them using `dir(module_name)` to figure out what names are defined, and check what they do by calling them or using the `dis` module for disassembling.
Thanks so much for this. I've been wrestling with this exact topic for the last two days. Very timely posting!
LOL ... and the web2py example is exactly the same as the Flask example. This blew my mind.
There are some modules that either do not release 64bit binaries or will not work with a 64 bit of python at all. Most of the time unless youre going to use a lot of ram it would be worth while to just install the 32bit version of python. As for the part about the compiler all I know is that it seems to be easiest to install visual c++ 2008 express edition to get the compiler that is needed for pip to build c extensions on windows. I think if you try pip install numpy then this problem will occur if you dont have it setup, at least it does on the computer that I'm currently on. 
In the Flask example, what is "response"? I think you need something like: return Response(Canvas(…).binary(), mimetype='image/png') (I could be wrong, there might be a simpler way of doing this)
Don't need to get so defensive buddy.
wtf
Wow, I love you, thanks! I always hate matplotlib api that is supposed to be matlab-like, this always make me procrastinate using it. On a side note: your OO approach is very smalltalk/ruby like (returning self everywhere), that's not really the python way of doing things. Now, let's see how far I can go with this one :p Also: you aren't on pypi, that sucks, I'm sending you a dummy setup.py once I've tested it. 
For starters, you need to run it inside MainLoop or your widgets are never going to receive the UpdateUIEvent in order to know to redraw. 
I once used unpyc quite successfully - but looking at the project page it seems to be dead since 2 years :(
Thanks. You're right, and I've updated the post to point people to 32-bit Python. By the way, I've found many useful Windows binaries for Python packages at [http://www.lfd.uci.edu/~gohlke/pythonlibs/](http://www.lfd.uci.edu/~gohlke/pythonlibs/)
I think you are right. I fixed it. Thanks.
Yes please. I will be happy to post it on pypi.
Because the creator posts about it. Mdpierro, I think.
I added all your suggested improvements to trunk. Thank you. I did not use git merge, I just did it manually. Sorry about that. Will try do it properly next time.
Fucking font with l and 1 being so similar.
OP here, Would love to hear about any features that could be useful to you. Clearly this is early on in the project so lots of possible paths.
Nested functions. Also, there are cases where it may make sense to have another variable or argument named 'kwargs'. But most importantly because it is more explicit.
As you seem to have guessed already, subprocess is a better choice than pexpect for this task.
I completed the course myself. I agree. Udacity is superb.
It's the same thing with `self`. I can do this if I want to: def func(dogbone, *dogbiscuits, **dogfriends):
Am I missing something? What does this offer over Argparse?
Disassembling the byte code isn't the same as decompiling it - you would still have to make sense of instructions to CPython's stack based VM, which is very different from reading Python code. There seem to be a few projects, mostly unmaintained, for this use case - I think [uncompyle](https://github.com/wibiti/uncompyle2) is the most recently updated (it supports Python 2.7).
Doing sub-commands in argparse is kind of hairy. Argon adds some shortcuts. Using "with" statements is not required, but I find the nested code natural to read and it also does some validation in `__exit__` methods. **Argparse:** # create the top-level parser parser = argparse.ArgumentParser(prog="PROG") parser.add_argument("--foo", action="store_true", help="foo help") subparsers = parser.add_subparsers() # create the parser for the "a" command parser_a = subparsers.add_parser("a", help="a help") parser_a.add_argument("bar", type=int, help="bar help") parser_a.set_defaults(func=handle_a) # create the parser for the "b" command parser_b = subparsers.add_parser("b", help="b help") parser_b.add_argument("--baz", choices="XYZ", help="baz help") parser_b.set_defaults(func=handle_b) # parse arguments and run handler parsed = parser.parse_args(args) parsed.func(parsed) **Argon with validation:** # create the top-level parser app = argon.App(prog="PROG") app.arg("--foo", action="store_true", help="foo help") # create the parser for the "a" command with app.command("a", help="a help") as a: a.arg("bar", type=int, help="bar help").handler(handle_a) # create the parser for the "b" command with app.command("b", help="b help") as b: b.arg("--baz", choices="XYZ", help="baz_help").handler(handle_b) # parse arguments and run handler app.run(args) **Argon without validation:** # create the top-level parser app = argon.App(prog="PROG") app.arg("--foo", action="store_true", help="foo help") # create the parser for the "a" command app.command("a", help="a help").arg("bar", type=int, help="bar help").handler(handle_a) # create the parser for the "b" command app.command("b", help="b help").arg("--baz", choices="XYZ", help="baz_help").handler(handle_b) # parse arguments and run handler app.run(args) 
Please can you explain to a noobie what this is &amp; why it is wrong?
This is interesting. I hope the matplotlib people take notice. Whenever I need to plot something, my first tool is Excel. And only when Excel can't do it, will I reluctantly try matplotlib. The problem with matplotlib is that you have to write a program to draw a plot. And it's just impossible to remember what you have to do, unless you use it days in days out. So for most people, who only need to plot data occasionally, they can use matplotlib for years, and still have to look it up every time they use. And often, it's very frustrating to look things up. It's exactly like Perl in this aspect. You can be using it for years and still have no idea what needs to be done to something that ought to be simple to do. Plotting shouldn't be this hard. 
We used it mostly for help managing files and the render farm. Also quickly re parsing email request information into a usable format for our scripts. So for example, say we had runaway render logs that we needed to keep the start and end of, but the middle was all junk. We could write a macro in pyp to take the output from a find command and run a head then tail to a temp file that met the search criteria, then copy the temp file over the original log. Not really exciting visual effect stuff, but still cool :) 
This question is essentially unanswerable, in the same way that it's unanswerable for nearly any kind of program. Modern hardware is so fantastically complex that predicting performance is very hard, borderline impossible. You can't compare clock speeds or anything like that, you simply have to measure. And you have to measure the specific task you're doing. 64 bit calling conventions are faster, and there are more registers available, but pointers are larger. So it can be a win if you're doing a lot of function calls or a task that requires a lot of registers, but it's a loss if you're memory-bound. 
http://docs.python.org/library/ctypes.html As far as I can tell this is a newer version of the same thing, I have no idea why you'd post the old version.
Thanks! What do you mean by react, exactly?
self is pep8 though, args and kwargs are not
See, but if you do, and I have to maintain your code, I hunt you down and kill you.
&gt; Are more clock cycles the biggest factor in python speed? The biggest factor in the speed of any program, regardless of the language, is the skill of the programmer. You can write programs in C that run slower than the equivalent program in Python if you choose the wrong algorithm. A classic example of this is in the book Programming Pearls by Jon Bentley. He explores several algorithms for finding the highest summing sub-array in an array of signed integers of size N. The slowest ran in O(N^3 ) and the fastest in O(N). He implemented the first one in optimised Fortran running on a [Cray-1](http://en.wikipedia.org/wiki/Cray_1), and the other in Tandy BASIC on a [TRS80](http://en.wikipedia.org/wiki/TRS80). The Tandy version ran as fast as the Cray version for N=2,500, and for N=10,000 the Tandy took 3.2 minutes and the Cray-1 49 minutes. For N=1,000,000 the times were 5.4 hours and 95 years (estimated).
One question, I enrolled, so how do I take the class?
Dat karma
This is like matplotlib for humans. Thanks =)
To elaborate on this: Python is best for applications which are not CPU bound. For things like web applications you will typically be limited by network (and perhaps disk) access. For many desktop applications you will be limited by user input. Say for example you have a task that takes 100 seconds to run. 90 of those seconds are spent in calls to network resources and the hard disk, and the other 10 seconds are spent processing data. If you make your code 10 times faster, it will now run in 91 seconds. If you make your code 100 times faster, it will run in 90.1 seconds. Your code can never overcome the limitations of your network resources and disk access. If you have a task that can be optimized significantly in C, you can write Python extensions so that you can call that C code in your Python and get the performance enhancements while keeping most of your code in Python. An example of this is simplejson's C extensions which can make processing JSON much faster than the pure Python implementation.
Select the course from the "My Classes" menu and click on "Unit 1" on the right of the video.
Sorta ridiculous, I think.
I agree completely. The problem with matplotlib is that its API is very difficult to learn. This is compounded by the fact that it has multiple APIs, violating the "there should be one, and preferably only one, right way to do it" philosophy. In this sense at least, matplotlib cannot be considered Pythonic.
Your mom dereferences so many pointers people mistook her for a Python interpreter.
In Python 3.3, that could be simplified to def flatten(ulist): for item in ulist: if isinstance(item, list): yield from flatten(item) else: yield item
We did a Python based connect 4 AI. While debugging, the AI printed every few lines. IDLE takes forever to print(), so I ran it from a linux terminal emulator while my roommates ran it in Windows cmd. I generally finished execution (deterministic) in about 90% the time it took them. 
It's also going to depend on which Python implementation -- CPython, PyPy, Jython, IronPython -- and which version of that implementation. It's also going to depend on what you're doing which determines the point of contention -- CPU-bound, lots of filesystem IO, network-bound, etc. In my general (non-Python) experience, Linux is going to have an tiny edge over Windows for CPU-bound activities since its scheduler is much better, Linux will be noticeably faster under filesystem stress, and if you configure Windows properly (i.e. not the defaults) network-bound jobs will be the same. I have no idea how AMD vs. Intel compares. 
I'm pretty sure byte 0 will get compared twice, so the more efficient version isn't more efficient (in terms of number of compares), but like lurkertoolong said, strcmp should be inlined, so that should be the only thing that matters, (and not say function call overhead).
Don't worry, it has an unmaintainable warning in production: def func(dogbone : "warning! unmaintainable", *dogbiscuits, **dogfriends):
CPython and 2.7 for now, as far as project goes it's a little bit of everything...we're in a unique situation where we get to customize our web servers for a python based web project, so I thought I'd capitalize on the best hardware for the job. Turns out I may just go with something "fast."
I like this answer, because it's true. As far as my library reliant web project goes, I may just opt for more cycles though. Thanks for the response :)
&gt; Not really exciting visual effect stuff, but still cool :) Definitely cool. Thanks for the eventual reply (I had actually forgotten about this :-)
What is "visual"? It seems most of this short code uses stuff from "visual", but it's not part of the standar lib. The answer to your problem lies in the impl. of "visual".
It's VPython. To the original poster, a flipped image usually means that your idea of the y axis is flipped with respect to what the library thinks. It looks like VPython puts the origin in the bottom-left. Some people expect it to be in the upper left. Where do you think it should be?
I've seen also this optimization in Blender code and wondered the same thing. Probably there are (or there was) awful implementations of strcmp or compilers, out there, that doesn't inline that.
Ooo, nerdy yo mamma jokes, I love these Yo mamma's so big, she needs her own page table to manage her page table Yo mamma's so big, the computer page faults every time she gets accessed in row-major order Yo mamma's so big, there's a 1-2.7105e-20 (that's 99 dot eighteen 9s %) chance that any random index to her overflows a long long Yo mamma's so big, when scientists devised a log-log searching algorithm, they still concluded that the Yo-Mamma-Search problem was intractable Yo mamma's so big and negative, when you try to take the absolute value of her, she still end up being negative Yo mamma's so slutty, even an extremely conservative escape analysis of her code will conclude that she doesn't need any stack space. http://en.wikipedia.org/wiki/Escape_analysis Yo mamma's so slutty, gcc automatically links everything against her Yo mamma's so easy, she can be solved by the iterate x[k+1] = x[k] in one step for any x in reals. (Incidentally, yo mamma's the function f(x) = x - x) Yo mamma's so slutty, Cook used reductions from the problem of counting the men who have slept with her to show that 3-SAT is NP-Hard. (Alternatively, Yo mamma's so slutty, Turing originally used the problem of counting the men who *have* slept with her instead of the Halting problem as the default reduction instance to show undecidability, but found that the complement problem Co-YoMamma to be too trivial and weak as the workhorse reduction to show that a problem is also not enumerable)
Check the VCS history to see when it was introduced, it may have made a difference then, or perhaps it was the result of a gradual series of changes and not intentional at all.
&gt; You have to put your page into pagename/index.{html|md} in order to generate _site/pagename/index.html. This doesn't seem to work by the way, the files are copied unprocessed. What is wrong?
I'm a blogofile user. I like it and never had any problems. It just works.
This is fairly speculative, but some of the more 'optimized' versions of strcmp will compare using words* (or a N sized memory block read as a vector) which will often require an alignment fixup. This is substantially faster for strings larger than the size of a word, but could be slightly slower if the general case is a first character failure. * Note that this is a compsci word, not an English word. Would be pretty awesome if we could teach processors to understand English, though.
Things like str(), enumerate(), and most of the str methods just plain don't work, making it super useless for doing anything. Also, the time limit is cute, but not allowing you to go back and do an exercise multiple times is pretty dumb! Overall, I give it a -1.
I just figured out the problem: obraz doesn't render files with non-Unix end-of-line encodings at all. Setting it to UNIX solved my problem, but I'm not sure how to fix it otherwise (I work on both Linux and Windows, so it would be nice if I wouldn't have to set EOL to Unix manually).
Yes.
Cool. When can we expect a production plone instance running? ;)
Done. Hope you can fix it!
I use my own because it's perfect for my own needs. It's more of a static site library instead of a generator: out of the box it just routes items to different output paths and you need to hook in filters (Markdown or whatever) and templates (Jinja2, etc.) yourself.
I have seen mynt and don't be ashamed to self promote. I do have a question though. Does mynt have a way to generate/link atom feeds? I would like to have one and that is one of the main reasons I am heading towards blogofile.
Pelican seems to be a nice alternative to blogofile and the documentation seems thorough as well! Thanks
Yep. If you use the default theme all you have to do is configure a few settings in the config file. If not you can pretty much just copy / paste the [feed template](https://github.com/Anomareh/mynt/blob/master/mynt/themes/default/feed.xml) from the default theme with a few changes.
I don't want to use my GitHub domain though.
I've started to get some traction with [StrangeCase](https://github.com/colinta/StrangeCase), and it's gotten good feedback. I try to keep the README up-to-date and thorough, but I'm also hanging out at #strangecase (irc.freenode.net) to answer questions and such. It does two things: builds a tree of nodes, and configures those nodes. Simple in concept, but the practicalities of web sites (index files, iterable folders, static assets) actually throw a lot of curve balls. The goal of StrangeCase is that everything "just works". It was inspired by hyde, but with more emphasis on the file/folder structure as a way of organizing and generating content. The README lays it all out. #colinta
I moved from Jekyll to Pelican last week as described in a [blog post](http://williamting.com/posts/2012/05/30/migrating-from-jekyll-to-pelican/). Paraphrasing: I only really considered Hyde and Pelican, but Pelican won out. - better documentation - category / tag specific RSS feeds - Jinja2 &gt; Liquid templating - simple layout, IMO much better than Jekyll The site's code is [here](https://github.com/wting/williamting.com), theme code [here](https://github.com/wting/pelican-svbtle). On a side note, when I used Jekyll I rebuilt the site for every push using a post-receive hook. However I got tired of maintaining two separate environments so now I just use rsync. Hyde's also going through a [major rewrite](https://github.com/hyde/hyde) now to get rid of the Django dependency (among other things). Also, I know this is wrong but I really don't like Hyde's low contrast theme. I should be more objective about choosing my tools, but good documentation makes it easier to start working with a new tools (e.g. LESS vs SASS).
I use one called [blatter](https://bitbucket.org/jek/blatter/) because I know the guy who wrote it, and I didn't really find any competitors when I started using it 3 years ago (maybe I didn't look hard enough). My needs are very simple and it works, so I haven't had any reason to look at newer options.
This is proof of concept for running Zope2 (http://pythonpackages.com/package/zope2) on Heroku. In https://github.com/aclark4life/zope2-heroku we list all the requirements in requirements.txt so that the packages are installed on push, then we tell buildout to use them (rather than re-fetching them all). Thus the buildout runs quick enough (must be &lt;60s) because it only has to handle the Zope instance setup. Zope2 is fortunately small enough to deploy on a single push. Plone, for example, which is built on top Zope2 needs multiple pushes (still working on it).
Ah cool. Thanks I will look into this.
I'm starting to use [growl](https://github.com/xfire/growl). I like that posts are just text files with a yaml header to describe categories, dates, etc. Extensible, lightweight and seems to do what I want. That said, I can't write html/css to save my life, so I'm mostly stuck making something that looks nice rather than working on content like I should be. But I'll check out blogofile and other recommendations here. 
I'm philosophically against one-liners. At first I found them undecipherable. As I got better at programming I began to understand them better and implemented them myself. After about a decade of programming 6-14 hours a day, 5-7 days a week, I now find them indecipherable. 
I just used max(sum(map(int, str(i**j))) for i in range(100) for j in range(100)) Seems a whole lot cleaner to me than max(map(lambda x: sum(map(int,str(x[0]**x[1]))), product(range(1,100),range(1,100))))
I typically prefer list comprehensions but I think map(int, str(i**j)) Is much more elegant than (int(x) for x in str(i**j)) Although your solution was the first one that came to mind for me.
 &gt;&gt;&gt; max(((sum(map(int, str(i**j))), i, j) for i in range(100) for j in range(100))) (972, 99, 95)
lol. You're so literal about it. Right now I'm seeing you how my friends see me. :) I am in the camp that documents their code but also believes that the code is the documentation. (I bear the cognitive dissonance as best I can.) So, yeah, [movie.get('title') for movie in movies] is fine, but I shouldn't have to think too hard about the intricacies of any one snippet of code as a discrete unit. We've got a larger application to build and can't get held up on a few lines showing off how clever the programmer is. 
Python is about readibility, if you want to write succinct code, use APL or Perl.
I &lt;3 PEP 380. :)
I've been using pelican with success. The theming was easy and the conversion process from my ReST based Django site was fairly straightforward. 
Don't judge on the socketmodule.c. It's grown all sorts of nastiness to deal with different platforms.
I couldn't agree with you any more. Sometimes I think this subreddit values the complex too much for zen of python's sake. I especially hate to see ridiculous lambda functions that look like an abortion...but I digress!
Less load on the server, because the pages are already generated, and you can use any type of host, because no specific serverside extension or language support is required.
There was at least one [longish thread in the mailing list](http://thread.gmane.org/gmane.comp.python.devel/81541) discussing it. Just from quickly scanning the PEP it's clear that there's a million different issues/corner cases/ways of implementing it. Some people want it to save some typing but act like an if/elif tree, others want performance improvements that are possible by forcing the tests to be static/const/evaluated only once. It looks like no matter what you choose, there will be people that hate the decision, and no likely consensus. That doesn't really speak well of a new feature. 
One programmer's elegance is another's ugliness. 
You end up with a lot of repitition.
I like to put an if 0: pass on top so I can move all the cases around with impunity.
Current Python if case in [0]: print "You typed in zero" elif case in [1, 9]: print "a perfect square" elif case in [2]: print "an even number" elif case in [3, 5, 7]: print "a prime number" elif case in [4]: print "a perfect square" elif case in [6, 8]: print "an even number" else: print "Only single-digit numbers are allowed" vs c-style switch switch(n) { case 0: printf("You typed zero.\n"); break; case 1: case 9: printf("n is a perfect square\n"); break; case 2: printf("n is an even number\n"); case 3: case 5: case 7: printf("n is a prime number\n"); break; case 4: printf("n is a perfect square\n"); case 6: case 8: printf("n is an even number\n"); break; default: printf("Only single-digit numbers are allowed\n"); break; } What are you gaining here from a syntax perspective? In C-code, switches are a translation to an if-else chain and a convenience of syntax. Python doesn't benefit at all from this approach and it definitely is only worth adding new syntax if there's something special about it that isn't available already within the language. The advantages of the switch statement were going to fall under what the interpreter did behind the scenes (if it did anything at all). [PEP 3103](http://www.python.org/dev/peps/pep-3103) has most of the discussion in it. If you read through it, you'll gain a better insight. 
are you using PyGtk or have you made the transition to PyGObject?
as opposed to repeating "case" a bunch of times?
Did it seem unreadable when I expanded it out?