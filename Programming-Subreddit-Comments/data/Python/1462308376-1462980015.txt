Yes indeed no Python 3 because of GAE... as for removing GAE from the stack it will be quite a challenge because the whole Config/User model (and some other stuff) are depending on the [Datastore](https://cloud.google.com/appengine/docs/python/datastore/).
I don't think so. You can find other cheat sheets for 3.5 though.
Yeah, my idea is that names are better the less arbitrary they are (only letters, only words/names) so I know what kind of rule set I want for it. The problem is detecting it, I could take a list of every word in the english dictionary and run the name though it to check for matches but that is a lot of overhead per name. I thought there may be some spell check library out there that would be possible to use to detect complete words in a random string.
Man, have people seriously still not heard about this crap? I know the Python community trends pretty far-left for god knows what reason, so maybe you'll look at this and say "sounds good to me," but basically they've got a radical political agenda to push and they're willing to do things like nuke people's accounts with no warning in order to push it. Here we go, found an older post of mine with sources: https://www.reddit.com/r/programming/comments/4dhrtt/gitlab_pages/d1t50e1 There's also the fact that GitLab offers most of the features GitHub wants money for for free, and is basically equal or better in every possible way except their GUI.
Bravo! This is reallly great stuff.
Fun post, but if I want to be a bit annoying, I would mention that the histograms are almost impossible to read… There is probably tons of cool data analysis to do (e.g. are the two histograms drawn from the same distribution, or can you fit them with an exponentially decreasing law, and see if the constant is the same, etc.), but first thing I would do would to prove your theory is a scatter plot (or a 2D histogram, they would convey similar infos) : * for each Noodles, put on the x axis the distance to the closest Qdoba, and on the y axis the distance to the closest Chipotle. * draw a line indicating x = y * if most points are below the line, then indeed Qdobas are statistically closers to Noodles than Chipotles. With a bit of style, could be pretty nice :)
Bookmarked, upvoted, saved. This is awesome, will give it a try!
shelve is backed by an efficient on-disk btree storage for keys/values and then objects are stored as pickle. So it's basically a key value storage (where the key is a string and the value is any pickleable python object) stored on disk in a single file and built into the standard library. Problems: decoding pickle can execute arbitrary code. So you have to make sure you can "trust" the documents. There are some issues with pickling user defined classes, but you can always not do that and just store POD dict/list/int/str objects (and other standard library objects like datetime and decimal). OTOH it's built into the standard library.
Honestly, this sounds like machine learning would probably be best at this. creating "rules" and having something follow them. It might be better to throw examples of good and bad usernames and then have it figure it out. Perhaps there's a simple spam filtering/bayesian analysis library? EDIT/Update: I'm finding ones that are word-oriented, but since you can't reliably tokenize a username you probably want something at the character-level and you'd need a pretty big corpus of "good" &amp; "bad" usernames.
Hey, there's a bit of pattern matching in dg but not quite: https://github.com/pyos/dg/issues/15 zip' = x' y' -&gt; if ([x, *xs], [y, *ys] = x', y') =&gt; yield (x, y) yield from $ zip' xs ys otherwise =&gt; yield from () 
Typically these async things aren't multithreaded, so no, it wouldn't. They're designed for scenarios where you're "I/O bound" i.e. the CPU spends a lot of time waiting for I/O (from the network).
Yep. My reply was mainly to show that an iterative method is not obviously worse (to read) than recursive, even for typical examples used to demonstrate recursion.
Can you explain more about exactly how your application works and why you want a serverless database? You'll get better advice if you give more detail.
FBO.gov has api access so you should be able get this information. https://www.fbo.gov/downloads/fbo_web_services_technical_documentation.pdf However as you say, the sites aren't user friendly and neither is the documentation
[edit: after the latest fix, it works!] hrm, no luck. I'm getting an error. Here is a screenie http://imgur.com/mbs8UAJ Does uvloop play nice with multiprocessing and shared sockets?
This looks like it might have come from nodebox or something similar? Derivatives of the Processing (Java) program have a setup step and a draw step. 
No.
Was always having to do str(path) when passing to other functions. Hadn't realized that many of those functions exist as methods on path objects. Still have to wrap in str() when passing to a lot of functions and methods though.
Aaaand it's fixed in uvloop v0.4.10. This was a really dumb thing (as usual) https://goo.gl/45ytPn
Regex may not be the best approach for this. Why not just iterate over the string and check for sequential character values explicitly? Perhaps something like: def check_seq(s): '''Returns True if s has no sequential characters''' prev = s[0] for char in s[1:]: if ord(char) == ord(prev) + 1: return False prev = char return True edit: bugfix per codemonkey14
I've gotta agree here - regex is an amazingly powerful tool, but it's dense code that's hard to unwind and support long term. Use it if you need to, but it shouldn't be your first tool out of the chest. Now, if you are trying to learn and get better, that's a different story.
I loved this! I'm learning python right now and these kinds of simple, easy to understand case studies really advance my learning and creativity. Thank you! 
Yeah, but what does it *do*? I assume it's above socketio in terms of abstraction? Where is it in relation to, say, Twisted? I guess I could just look it up, actually. EDIT: Apparently it's all of the above. Huh.
Responding with my phone, so haven't tested it, but have you tried (or similar): //span[text()="Export"]
I haven't. I'll look into it!
k bye
Personally I prefer iterative approaches since they seem more suited to the language and are easily adapted to generators.
Yup all good points. Definitely didn't do enough visualization and I know how much people love pics. Might have to do a follow up post with that, maybe adding in some database action that can do geoqueries, and maybe adding more restaurants to see which ones go well together. Tons more to thing about for sure.
Would StringIO do the trick? I've used it with boto to write to S3 but haven't looked at tinys3. https://docs.python.org/2/library/stringio.html
Yeah, think of it more like the primitive/s that something like socketio and twisted would be built upon. Really awesome stuff /u/1st1! :)
oh wait I think it would indeed work. I am pretty sure I fucked something else up because it's hanging even if I upload from a written file instead of StringIO. I'll look into this, and try boto3 if tinys3 fails. Thanks!
Hey it worked! Thanks for the help. I didn't know that I also needed to do something like an output.seek(0) before putting it through the boto upload. Somehow that makes it work. 
bear with me as I'm new to python but have been a dev for awhile. 1.) theoretically you could append it all to a massive string but there's no reason to not store your output in an iterable of some kind. Is there a reason you want to avoid an array? 2.) you might want to check out csv.DictWriter(). your for loop could look something like thead=('Date','Bulletin Number','KB Number', 'Title','Bulletin Rating') rows = [] for row in table.findAll('tr')[1:]: col = [c.text for c in row.findAll('td')] row = {'Date':col[0], 'Bulletin Number':col[1], 'KB Number':col[2], 'Title':col[3], 'Bulletin Rating':col[4]} rows.append(row) with open('output.csv', 'w') as f: #might be better way to do this for header f.write("||".join(thead)) csvwriter = csv.DictWriter(f, fieldnames=thead, delimiter="|") csvwriter.writerows(rows) 3.) are you trying to loop through the pages in the table? easiest way to do that would likely be to, in your loop parsing tables, do something like the pseudocode below #parse table from first page nextPages = True while nextPages: #extract link for next page from the next page button on the table #extract data from table on page #if next page link is not disabled or if exists, set nextPage=True and navigate to the next page. Otherwise, set nextPage=False to break out of loop 4.) You could use the date and timedelta classes to do date math to figure out what the earliest date you want to include updates for is date_lim = timedelta(days=30) earliest_date = date.today - timedelta and then use that value to compare against the date in the table to see if you want to include it. EDIT: formatting 
Why do you pass paths around? Usually I have a configuration object with all config data which I'm passing around. 
Agreed, this is much easier to read than a regex. just don't forget to increment the 'prev' variable with each iteration to avoid something like 'ACDC' from returning True. 
I do a lot of batch data analysis (of data files) and automating analysis codes which themselves have input files, output files, executables, etc. So I often write code that takes a filename, does stuff with files, generates files, combines data from multiple files, ... so somehow in all of that workflow the need to pass filenames around seems somewhat natural. I'm actively working on 3 or 4 related libraries and having a central config object doesn't make sense for dozens of different types of tasks that don't share state. Maybe there's some neat way of doing stuff I don't understand yet, but for all the classes and functions that take filenames, if they took Path objects instead, that just means I still have to str() when passing to pandas, numpy, PyQt, external tools, or other functions that don't exist as methods on Path. I use pathlib extensively (instead of os.path) since all my stuff has been on python 3.4 for quite a while. This post helped me realize that I can make better use of it by remembering to use the methods instead of doing stuff like open(str(path)). I just find I still need the universal str version of the paths quite often and use strings in my api's for easy compatibility.
I will definitely try this in my asyncio projects in the future. Thanks.
You merged a few too many beers buddy
What I don't like about these "benchmarks" is that the end product is ALWAYS a lot SLOWER when you add more functionality. It's unfair to do this kind of comparison at this stage and should not be taken serious just yet!
&gt; In most apps, you still want yeah, most, but not all do you think all situations should be as slow as a parser burdened http server, just because you want to be grumpy?
Personally, I would go with `math.factorial`, which has been available since Python 2.6 :-) 
ImageMagick is used by some popular python libraries like Wand. I thought it would be nice to let people know about this.
Not actually an answer. You may also want to sanitize for sequential letters on a keyboard (or on differents keyboards) : QWE, QWER, QWERTY (or AZERTY in my case), ASD, etc. In this case, it may be (but I didn't make any tests) faster and/or cleaner to write all sequences you want to forbid, and search for them in the original string. 
It lets you say "I always avoid recursion in Python" and feel smug.
Dropped to 20 already. You shouldn't say "top 15" until after the competition....
Hey, I would like to see a little code snippet of how you did it. Is it possible?
Ah, programming by superstition. The most popular programming style!
&gt; It's useful for dealing with trees that you know will be shorter than 1,000 items tall. In all other cases, use iteration. In a balanced tree, that implies you have fewer than `2**1000` items, which is comfortably bigger than the total number of subatomic particles in the entire universe (about `10**89`, give or take a few zeroes). So I have to ask, what sort of data do you have that gives you a balanced tree larger than 1000 levels deep? P.S. you can always increase the recursion limit beyond the default limit: py&gt; sys.getrecursionlimit() 1000 py&gt; sys.setrecursionlimit(2000) (I know not all trees are balanced. But if you have significant amounts of data, in a non-toy application, you should be using a proper balanced tree. Use the right tool for the job.)
It defines two functions. `setup` defines a whole lot of global variables, then calls a mystery function `size` (which is not shown), and another mystery function `background` (which is also not shown). My guess is that they are functions from some unknown graphics library. The second function `draw` looks like it is trying to draw a small circle. 
Okay, but you should have said. Not everyone knows what connection ImageMagick has to Python. I didn't.
 s3 = boto3.resource('s3') stuff = StringIO.StringIO() stuff.write('meow meow meow this is text in a pretend file') stuff.write("more stuff") stuff.seek(0) #not sure what this does but it makes it work s3.Bucket("my-bucket-name").put_object(Key="filename-for-s3.txt",Body=stuff)
You might get better feedback over at /r/learnpython
I'm mostly against saying things are faster when only looking at synthetic benchmarks with the very simplest of tests, loads. There wasn't even any sort of application looked at here whatsoever, just echo servers. If I wanted one of those, I could write one in C.
I also think this is much nicer. And since we can obviously never help ourselves, here is slight alteration using zip() :) def check_seq(s): for cur, prev in zip(s[1:], s): if ord(cur) == ord(prev) + 1: return False return True Edit: Or a numpy version, just because we can. It is probably slower than the pure python one. def check_seq_np(s): sarray = np.array([ord(x) for x in s]) return not np.any(np.diff(sarray) == 1)
What's faster, paws or nginx?
How does asyncio compare to gevent? Are they different implementations of the same thing, or do they provide different levels of abstraction, or what?
The title reads: **How I got into the top in 2 days.** No future predictions is given :) You should distinct past and future and be less picky. It is nice article though, thanks to author.
No, because otherwise I can post an article at the start of a competition "How I got top 1 without doing anything". When you add something like "top X" that suggests it's an actual accomplishment; e.g. reaching top 15 at the end of a competition with many competitors. I find "you should distinct past and future" a quite insulting remark actually. 
You don't have to open links you find.. You could just find a url a user would hide, it can be dangerous for privacy..
my resources shelf next to my workstation has all the classics - python cookbook, thinking in tkinter, chicken bones, incense burner, think python, python pocket reference, etc. you know, the essentials. 
dont need to define the variables as global, they are in module scope
That's actually a very interesting point to make :)
`stuff.seek(0)` puts the pointer of the StringIO instance to the beginning of the file/buffer. That way when something reads that buffer it gets the entire data instead of what goes after your earlier write operations, which would be nothing since write puts the pointer to the end.
Awesome! I'm glad you got it working
For anyone that has used this. How good is it at packaging python programs? For example if I create a PyQt5 Graphical Application in Windows7, OSX and Linux will it work in another machine that has Windows10, newer OSX or other Linux distros?
Right, but for/else hasn't yet been renamed, so it should not be used in production because you can't trust other developers to understand it. 
Why can't you port it to PySide? It should be fairly straightforward since they are on the surface fairly api compatible unless you have some custom sip code.
I have used this to package python programs into executable applications on OS X (X.8, X.9, and X.10), Windows (XP), and Linux (Ubuntu 14 and 15) The application in question made heavy usage of Qt/PyQt4, Numpy, Scipy, Matplotlib, and Pandas. It will take some time to get to know how the process works; generally when first trying the build you'll run into some errors about missing libraries - 90% of the time this is solved by just using one of the built in hooks - ie. you'll need to tell pyinstaller where to find scipy or numpy - or you may even just need to move one of the libraries into the build destination manually. I remember having some trouble with pandas specifically. There was a shared library (.so file) for pandas somewhere in my python site-packages that wasn't getting properly copied to the build destination. All that needed to be done was to copy the file from my python site-packages folder, drop it in with my code and other libraries in the build destination, and rename it pandas.so. Every error I encountered generally had some stack-overflow discussion regarding how to fix the issue. So overall the process was fairly simple.
On top of what has already been mentioned don't forget that most libraries use "duck typing" ( aka if it walks like a duck and quacks like a duck ). Often times as long as you pass an object with a read(size) attribute then the libraries will work. If you can programmatically generate your output when read(n) is called then you can pass that object to the s3 library. StringIO is just one example of a "FLO" ( file like object ) which works. I do this all the time with IO wrappers for things like automatically generating sha1 sums of data streams.
A terminal tool for searching genius.com for lyrics. Search for a song, and the lyrics will automatically be selected and displayed on your terminal of choice. There's also a neat little search results thingy I made, in case you don't immediately get what you wanted. A silly little tool that I take way too seriously, but all in all, it was good practice for interacting with an API and making something of the data that it returned. I did this mostly to get myself a little familiar with `requests` and `bs4`, and then I did a little practice writing out to a tempfile and paging it through less. Thinking about creating an ncurses interface for genius.com, including support for clicking and retrieving annotations for lyrics that have them. If anyone would be willing to help with this, please let me know. This may very well be the first project of mine that's even remotely useful to someone. Doubt this will get much attention, but I thought I'd share because I'm a little proud of it. Enjoy!
wow, stupid me has been using [`websockets`](https://pypi.python.org/pypi/websockets) and `aiohttp`...
What does your code look like so far?
They have an install script so you could literally just run your own instance of reddit. https://github.com/reddit/reddit/wiki/reddit-install-script-for-Ubuntu
No, only asyncio.
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, we are sure you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, we are sure you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
I was personally wondering about this, and had tried to look up if it was normal to remove an access token from repos, but wasn't able to find anything, so thank you for the feedback! I'll see if I can try to work out a solution for this, but I do appreciate the note and the suggestion! Thanks! 
The [7] would unfortunately return a value in either case. I don't it want it to be the wrong value. I'll try the other two things. Thanks. 
I think what u/stuboo is trying to get at is that you can check for the text in the xpath in the situation you describe: '//span[@text="Hide Partial"]/span[7]' with whatever before you need, by using the @ you can search attributes on an element. If that's null you can default to span[6] http://www.w3schools.com/xsl/xpath_syntax.asp
&gt; Could anyone please give any recommendations on what we should look for in the profile of a developer who can help us create this, using Reddit's open source code, and what sort of time frame we could be looking at? Since reddit already exists as a free/open source codebase, you need someone with server admin skills, someone with knowledge of deploying and managing websites on Linux, such as on AWS. If you want to make modifications to functionality, then you need a developer. If you don't want it to look just like reddit, then you need front-end devs / graphic designer. timeframe / compensation etc is something you'd negotiate with the freelancer.
If you aren't using a self-balancing tree algorithm, your tree might become severely lopsided. E.g. a naive binary search tree given pre-sorted data becomes a linked list. I wouldn't use recursion for a naive binary search tree, only a self-balancing search tree. I'm not sure what we're debating. Use recursion for trees.\* \* As long as you know it will be less than 1,000 items tall.
Optimize production code for readability first, and only deviate from that where you need to for reasons of correctness or speed. For/else does not meet that test. It's not readable by many good developers, and it's trivially replaceable with a more readable variant (set a flag before looping and change it before breaking). It's true that "readable" is not objective. It means "readable relative to a developer who knows X." So what? For/else is still a misleadingly named construct, I've worked with many good developers who didn't understand it until I explained it to them, and there's no good reason to use it in production. That doesn't mean that I'm dumbing my code down. Just because a language has a feature does not obligate you to use it. Lots of languages have misfeatures. C has plenty of them, and some of the worst were copied into other languages (`switch` without `break`, ugh). 
asyncio allows the core I/O insides of Python (or any python code for that matter) to take advantage of high concurrency via coroutines instead of plain old subroutines; allowing you to break-out of a piece of code and do something else while that other piece of code is waiting for something. Coroutines are pretty awesome stuff and can be built into any language that supports customizable generators. In a way, it side-steps the GIL by making it irrelevant. If you combine it + multiprocessing library you can do some cool stuff, very quickly
Hence the pointening.
But.... but... wait... twisted is an async framework for Python...
&gt;how would I go about making a script like this that relies on an API without forcing people to register their own access token? You literally cannot - that's the whole point of having to register for an access token - the company can control and limit access.
Figured this might be the case... Would it be advisable to create a dummy account on Genius just for the purposes of getting an access token so it isn't tied to any personal account?
Google is very siloed. Within each silo, they have development standards they adhear to. So, if your team is using Python as a language, they would probably frown on you coding in Haskel. It depends on what area you are working in really. Banks and financial companies generally have a centralized IT group where most technology projects are done within. Google's product is technology so each 'product line' may have some say over the language choice, but there are a few that are favored. DART, Java,C++, Python and GO are most frequently used. . Also, Google has very strict code styles that must be followed for each language. Google "Google language standards". It's not just anarchy over there like you seem to be implying. 
Please post your ideas in ~~the comments on [Medium](https://medium.com/@Lipis/share-your-app-idea-and-i-will-implement-it-within-minutes-in-the-cloud-67f6a152f3ef).. not here :)~~ here..!
Thank you.
Systemd is the devil!
~~But of course we can discuss them wherever later on..~~
You're probably going to need to fix this by running .encode(some encoding) or .decode(some encoding) on your text.
Well, first of all: what python version are you using? Post the full traceback. Post your code. Edit: oh right. this might also be better posted in /r/learnpython
Well yeah, you could. But he clearly didn't do that. It's quite an extensive post and getting to the top 15 is an accomplishment, as is 21 (where he is now).
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, we are sure you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
pyvenv is deprecated in favour of python3 -m venv . Edit: proof!!! https://docs.python.org/3.6/whatsnew/3.6.html &gt; The pyvenv script has been deprecated in favour of python3 -m venv. This prevents confusion as to what Python interpreter pyvenv is connected to and thus what Python interpreter will be used by the virtual environment. (Contributed by Brett Cannon in issue 25154.)
I mean, if you want to really learn stuff I'd use low-level C++ and build some basic 3d engine out of DirectX, OpenGL, or what have you. PyGame is cool if you want to build a basic 2d game like I did, but if you just want to learn coding I think it pays to learn something low-level first and then go to higher level stuff like Python, since you'll not only understand how it works, you'll understand how it's *made*.
Thanks! I will check it out in the morning! 
&gt;Hi all. Not sure if I am posting in the right place You're not. /r/Python is for news and releases, /r/learnpython is for questions.
While correct, he didn't ask for feedback. This is a release, and therefore actually belongs here. Unlike half the other shit.
Yes, it doesn't block modules from being imported from the filesystem, it just prioritizes the frozen ones
Oh that's awesome! any idea how to run a new script created in a new file? so if my pyinstaller program creates a newscript.py file, how could I invoke the interpreter?
i have packaged pandas, scipy, numpy, ipython, pyodbc, even pythonnet with WPF without any problems!
Awesome tutorial! Very enjoyable read, keep it up.
Please link me the docs for that.
Python is a language. If you count yourself among professional Python programmers, but fear Python falling into disfavour so much that you are looking to move to an entirely different field, I would say you're doing actual professionals a disservice.
Yes that is my number one issue in going to tackle going forward. Didn't have time this past weekend. Thank you I'll check that out!
You can use `import` or `exec` to run the new script in the running interpreter. If you need to spawn a new interpreter process, you will need to set up your main script to be able to conditionally launch a different script on startup instead of your usual main script code, and then call `sys.executable` using the `subprocess` module to launch a new interpreter process using the frozen executable.
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, we are sure you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
yes. /r/learnpython is the subreddit for stuff like this.
Thanks, I shall delete my shit-post.
Yes, although afaik it still teaches python 2. So, even for 2013 it would be legit, for 2016 much less so. 
Yeah, I'd love something like this to cache SQLAlchemy responses, for example.
I know two people who are now in the industry beside me that started out on their own with CodeCademy. They each took less than a week to learn and within a month applied python to repetitive tasks in their work. One is now working as a software dev and the other as a test lead, both in less than a year after started to learn code at all. They had totally different backgrounds, consulting and music major. So I have major respect for CodeCademy. 
How is the service? Is this really the best deal in town, so to speak?
Oh, that's unfortunate. codewarrior0's approach will probably work, but will likely be more work than just reimplementing in pyside from scratch.
So for instance, I could do something conceptually to the tune of: if not //span[@text="Hide Partial"]/span[7]: ? When you say "search attributes on an element", do you mean within its tag or any attribute of even child elements?
Yeah, I opted to implement my own version in PySide at the end of the day. The other class had a little too much baggage to make it worth the effort of trying to implement some kind of low-level PyQt4-&gt;PySide conversion thing. I needed to add some features to it anyway, and there were some features I didn't need. Ultimately implementing just what I needed in PySide worked out best. 
As far as I understand it is a drop in replacement for asyncio event loop using libuv. You continue to use asyncio the same way you normally did, except it is faster.
We're not here to do your homework
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, we are sure you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Can someone please touch on why os.system should never be used? A quick search doesn't show me anything security related. If it is "bad" to use it, why is it included? Is there a good time to use it over other options?
I'd mainly be interested in the proxy rotator service. Is there a way to just run my own python script and either drop or pull the results to my server? 
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, we are sure you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, we are sure you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Op linked to the release page, I linked to the page that explains what PyInstaller is. 
Not anymore but yes :)
Thanks for your post. Please add some exclamation marks to the shebangs. 
Also, leading slash is missing. Replace the space with that. Also, OP is using Python 3 but usually `python` is Python 2 on most systems, so you should use `python3` command. IOW, each file should start with #!/usr/bin/env python3 I guess OP usually invoke their scripts via the Python interpreter $ python3 somescript.py rather than directly $ ./somescript.py Also, OP, if you are reading this and want to invoke scripts directly, remember to make them executable first. $ chmod 755 somescript.py Just in case you were unaware. Then again, it could also be that OP is using Windows instead of Unix, which would also explain why they had the typo, since the shebang would then not be relevant to their platform. The shebang should still be included ofc for the sake of Unix users reading OP's blog.
Since uvloop is a drop-in replacement for asyncio, the answer is likely to be yes.
oh snap, thanks for that Sir. Updated :)
well, I do use print as a function in p2 for compatibility reasons.
Ah, yes, you are right. I was only looking at the use of `print()` to incorrectly determine that it had to be Python 3.
That will come when they rebase onto openssl 1.0.2 when the defaults changed again.
Let me get back to you on that. Last I checked, the answer was no.
I have yet to run into any memory issues with Redis. When deploying with elastic cache on AWS you can configure the cluster to pretty much scale with your load. I'm using this to cache results of an expensive DB query that changes infrequently which reduces load times down to a fraction. Redis [GET](http://redis.io/commands/GET) runs in constant time and is extremely fast for me.
Great post, when is saw "there are several way to write code, some better than others" I assumed I would be in the worse category but I was pleased to see that I fit more in the third "good" category. I'm just happy about that. Nothing to see here.
I did, a few years back. The API is pretty straightforward, but be warned - they throttle you to something like 1000 requests per day or something like that. 
glad to hear :)
It's usually preferable to do &gt; chmod +x somescript.py To preseve existing permissions
Nice concise example that a new programmer can understand and use immediately.
&gt; Why do I need to keep packages for different projects separate? &gt; First, you may not need the exact same packages or package versions for each project. Second, if you collaborate, a package manager helps all team members use the exact same packages and versions. Also, if you are on Linux or a Mac, some critical system software (such as system package managers) may be written in Python and depend on a specific version of a Python package. If you like to use the latest versions of everything, as I do, it is safest to use a virtual environment unless you are running a rolling release distro such as Arch Linux.
yup, that is the exact reason I wrote it. Simple tip that makes a lot of super cool scripts i see around much more usable.
/r/learnpython
Great. You discovered abstraction.
You can try the service **for free** (forever if you want). Just sign up here and try it out: https://dash.scrapinghub.com/account/signup/
Thanks a lot for posting this, I didn't know about the Pattern Library developed by the CLiPs researchers, it seems very useful.
print as a function certainly is built-in to python 2 without having to import anything from \_\_future__ Last login: Thu May 5 00:51:43 on ttys012 MBP:~ kyleg$ python Python 2.7.10 (default, Jul 14 2015, 19:46:27) [GCC 4.2.1 Compatible Apple LLVM 6.0 (clang-600.0.39)] on darwin Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; print('howdy') howdy
Thanks for the clarification. These problems are the ones that take 48-56 hours to discover sometimes and if they can tackle them out of the box I see PyInstaller becoming the only tool needed to bundle standalone executables for us anyway. Have you tried using PyCrypto with it to encrypt the bytecode and how secure does that make your executables based on your experience? 
&gt;Also, OP is using Python 3 but usually `python` is Python 2 on most systems, so you should use `python3` command. IOW, each file should start with &gt; #!/usr/bin/env python3 For that matter, *never* use `python` without a 2 or 3 in the shebang. Arch Linux, for example, has `python` point to python3... Which breaks the assumption lots of people make that the default will be python2. It gets ugly real fast.
I have not bothered with bytecode encryption. I develop open source scientific software so I haven't had a need for encrypting my codebase rather I hop the make it as accessible as possible. 
Got the answer in r/learnpython Thanks anyways
Well, I used to use tls-o-matic, but it went offline for a while, so now I run https://badtls.io for testing, which is used in addition to badssl.com. This may be part of what you are looking for: https://github.com/wbond/oscrypto/blob/master/tests/test_tls.py Instructions for running the tests can be seen at: https://github.com/wbond/oscrypto#testing You can see the CI environments used to test it on different platforms and versions of Python at: https://github.com/wbond/oscrypto#continuous-integration. Standard validation is done via OpenSSL, CNG or Secure Transport, depending on your OS. Here are the implementations: * https://github.com/wbond/oscrypto/blob/master/oscrypto/_win/tls.py * https://github.com/wbond/oscrypto/blob/master/oscrypto/_osx/tls.py * https://github.com/wbond/oscrypto/blob/master/oscrypto/_openssl/tls.py In terms of advanced key and certificate manipulation and inspection, I wrote an ASN.1 library from the groud up since the existing solutions were not really usable: https://github.com/wbond/asn1crypto And then implemented full certificate path validation that passes the NIST path validation test suite (with the exception of name constraints, which are on the todo list): https://github.com/wbond/certvalidator certvalidator can also do CRL/OCSP checks if desired.
That makes sense, thanks!
&gt; Personally I hate argparse because I have to learn an entirely new way of doing things, I can imagine that being useful to someone that knows all the odd documentation edge cases, needed to write a lot of simple scripts and wanted to learn as little python as they could get away with. Otherwise, not very compelling - since you still need to learn all kinds of new things - including how to validate docopt. And learning schema looks like it'll take longer, and certainly be less readable than argparse most of the time. 
https://www.reddit.com/r/learnpython/comments/4i0dg8/close_windows_console_automatically/ For anyone curious. 
&gt; Personally I'd not use Redis as a cache. The authors of Redis advertise such usage but I have experienced Redis to be extremely unreliable as a caching service, mainly due to it's memory management. This is all very hand wavy, what problems have you had with Redis as an LRU cache?
Here's an answer I wrote to a Stack Overflow question on a similar topic. http://stackoverflow.com/a/13507034/416467 (Looking at that code, I don't feel smart enough to have written it)
Given the popularity of virtualenvs, I think this is bad advice unless your code is strictly for one version or the other.
virtualenv or conda environments would certainly work. Depending on what kinds of applications you are developing, another option worth considering is making web apps. If, for example, you just need to show some data to the user or perform a couple of simple calculations, then you only need to worry about keeping it running on one computer since all user interaction would be via a browser.
It gives executable permission to everyone. In this case it's a good idea to be selfish and give this permission to yourself only: chmod u+x file.py where `u` means "user".
This seems really interesting. But... it's only for Windows?
It's a programming thing, not a Tkinter thing.
No. I've run it on Mac, Windows, and Linux. 
It depends. How fuckin KEWL is this Kyle Gruenberg?
Ok this is good! I think portability is a keypoint of success.
Just follow the accepted answer, that's how you use PhantomJS with Python :P Compatibility will be similar to Chrome, but will be executed headless; which has it's own pros and cons. My recommendation is using the Firefox driver while you're developing your tests, then switch the driver to Phantom and verify everything is working on both.
Really exciting to see partial type checking appear in Python so quickly after the PEP was accepted! Definitely have to give this a go.
You should ask learning questions like this at /r/learnpython
Maybe it's pedantic of me, but... $ pyflakes test.py; pep8 test.py test.py:3:4: W291 trailing whitespace test.py:4:21: W291 trailing whitespace test.py:5:28: W291 trailing whitespace test.py:16:1: E303 too many blank lines (3) test.py:16:25: W291 trailing whitespace 
It just depends what you're trying to do. There's nothing wrong with using Firefox/Chrome/Safari drivers, but you have to deal with the active windows. You can run Firefox and Chrome in Docker containers and connect via RemoteWebDriver...that's what we do here. For a side project I have 4 tiers of service calls: - **fast** is API access - **normal** uses `requests` on non-api acess with html5lib parsing - **slow** uses Selenium with PhantomJS - **very-slow** uses Selenium with Firefox Basically, given system resources and API credits, and the demand on the data we need to grab...the system will pick an access tier and scrape the page. The amount of times a PhantomJS fails over to Firefox/Chrome via Docker is less than 1% -- it does pretty good at interacting with most things.
I haven't used docopt before but is it really "stringly typed"? That's like half the reason you use an argument parsing library.
My point is that if your code expects a certain Python version and won't run on both, the shebang should specify which version instead of assuming the OS default is what you expect. 
Yup, you're correct, of course. I'm so used to working on single user machines at this point that good practices are slipping.
Looks great! How would you compare it with LÖVE?
part of the work for my doctoral thesis - has to do with data analysis for a specific type of electron microscope experiment. github.com/mgrady3/pLEASE
Great to see more progress on this! The 0.2 -&gt; 0.3 upgrade made Mypy usable in one of pet projects at work. The test case was to support variable-length namedtuples (constructor generated at runtime!) instead of a known tuple; with Mypy and Hypothesis it took an afternoon to finish ~2kloc. It was actually fun, and pointed out a few areas with too-tight coupling. 10/10, would recommend for anyone working with large or complex code. You can just annotate the tricky bits too, so starting with no type checking and adding it as needed works well. And adding annotations before a big refactor was a huge net timesaver for me :)
Isn't uWSGI "micro-wiz-gee"? 
IIRC (based on a video of a pycon talk about this), Guido wrote the PEP somewhat in cooperation with this guy. Originally he was going to make a fork of python for this, but Guido convinced him to make it an add-on on top of Python. Which works out so well for me since it lets me use my type-checked code with hundreds of Python libraries.
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, we are sure you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, we are sure you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Just realised I've likely been subconsciously removing the second p every time I've thought about pronouncing that, as "psi-cog-2". Oh well....
The scope is different, and to be pedantic, there's no `main` object.
[Low End Box](https://lowendbox.com), a website dedicated to find you inexpensive hosting. For what you're doing, you won't need much. That's if you want a full server, if you just want to run python, [Python Anwhere](https://www.pythonanywhere.com/) has a free option that is worth looking at.
Why do you want the main meat of the program to live in the global namespace so badly? It's just ugly and awful and a huge PITA to debug. The more lines you have in a given scope, the harder it is to find where (if) each individual variable was defined (and where if it was defined local/global/default (or in some other inaccessible scope)). Since you want each scope to have as few lines as possible, that means you want to have as few variables as possible visible to any given scope. This concept is called "modularity" and it's a really good idea, and makes debugging 8000x easier. Making your code anti-modular just so you can use the interpreter as a gimped debugger is kinda insane. Why not write modular code and then use a debugger as a debugger? &gt;the main program can still happily live inmain. You mean, "in the global namespace", which is what you're doing. The point of allowing the user to use the global namespace is so that the programmer can write code directly into the interpreter without having to define and complete a `main` function--not so that programmers can put everything in the global namespace.
Awesome! I was looking for something just like this recently. I ended up using tkinter which was far less than optimal. But wanted something lighter than Pygame and QT.
I'm glad function argument types can be specified and that we're requiring Python 3.5 as the minimum for work so we can use it. At the minimum all well-written Python code should have type annotations for all function definitions. I don't know if this belongs in PEP8, but it'd be smart to add it. When I see an image argument, is it a numpy array, a PIL/GDAL image object, or a filepath? Docs help with t his but having things supported by the compiler is great. Rust has really blown my mind with their typing approach as it feels like dynamic typing but it's strict static typing and it's great. I hope all languages converge on this in the future (looking at you JavaScript).
I did some research into the history of this project and yes, it's part of the "python" github organisation and the homepage's history talks about how it used to be a fork of Python before turning into its current form of an uber-linter.
You're placing an *awful* lot of words and ideas in my mouth. Step away from the keyboard and come back in a minute... ... okay, back? Great. Read OP's post again. We're talking about **scripts**. Not complex pieces of software - scripts for accomplishing simple, easy-to-define tasks. Your example from above is absurdly verbose and over-engineered. It reads much better and is far easier to understand if you just write it straight out: #!/usr/bin/env python3 """ Super awesome script Take user input as a command-line argument for a number: - If the number is less than or equal to 100, return number to power of itself - Else, return the number squared Finally, print the result. """ import argparse __version__ = '0.4 (fork)' parser = argparse.ArgumentParser(description=__doc__) parser.add_argument('--number', required=True, type=int, help='number to perform calculation') if __name__ == "__main__": args = parser.parse_args() number = args.number if number &lt;= 100: print(number**number) else: print(number**2) Code like this doesn't benefit from over-engineering; it becomes obfuscated. It's *trivially* clear what's going on here. You *could* factor out the calculation, but you have to ask yourself, "why?" before you bother to do it. You're not re-using the calculation anywhere else, so why bother? Just so you can pedantically document it? Overkill. Total overkill. And overkill which makes your code less readable and unnecessarily complex. Modularity is not useful in this context. The global namespace *is* the appropriate place to build the architecture of your script.
You're making mountains out of molehills, and over-engineering code for no apparent purpose. You created a *less readable* code. The vast majority of basic scripts that someone would write will never grow large enough or complex enough that the global namespace will become unmanageable. They're not big; they're not redundant; they don't need modularity just for the sake of modularity. In fact, your example would be a *far* worse nightmare to debug in practice and maintain. 
See [my other comment](https://www.reddit.com/r/Python/comments/4hzam0/how_to_make_your_script_better/d2urie5).
Hey nice project! I noticed you're using some pyglet code under the hood which is awesome. I also noticed, however, that your Sprite class is based off of the pyglet 1.2 branch. That's OK, but the Sprite.set_position method will be deprecated in pyglet 1.3. I rewrote the Sprite module a few months ago with @property decorators. The position can be set directly by the Sprite.position attribute now, so the Sprite.set_position method will likely dissapear in the future. Also, there is a new Sprite.update method added by another contributor that allows updating the x, y, scale, and rotation simultaneously (which is a bit faster than updating them separately). I'd recommend just grabbing the whole sprite module, since it should be backwards compatible with the pyglet 1.2 codebase. 
&gt; 10-line long programs have the strong tendency to become 100 line programs. And furthermore, when people make 100 line programs, they do it by following the things they learned when they started out making 10-line programs. There's no benefit to using poor coding practices just because you can when you can get away with it, but there's so many benefits to using good coding practices always. And a 100-line script, let alone a 1000-line script, won't suffer the problems you're trying to prematurely solve if a halfway-competent programmer is constructing it. "Good coding practices" is not equal to "unnecessarily abstract everything away." Text editors of even twenty years ago have more than enough capability to help a programmer find his/her way through any such script as long as they stick to semantic variable names a decent, consistent coding style. &gt; That above is far more readable than anything either of us have written because the problem is so simple. Again, you've constructed a *less* readable script. It's not documented at all - which is the main point of using `__doc__` and `argparse`, to make the documentation about what the script does available both internally and externally. Leaning on `argparse` also safeguards the script and allows it to fail gracefully on unexpected user input. &gt; But the blog post isn't about 5-line long programs! It's about good coding practices that are necessary for things longer than 5 lines long, it just breaks it down into a 5-line program to make the concepts easy to understand. And my point has been - and still is - that you're taking a caricature of "good coding practices" to extremes. Over-engineering code in the manner you're suggesting makes things just as bad as not employing any thought in its design. 
Consolidate your comments in the future.
Are your examples the correct or incorrect way?? Edit: the only one i was confused about was PyPi. I did some Google'ing and it appears the community is pretty torn. 
There's a subreddit just for that; r/learnpython. 
Simplecv is abandoned
Wot
As a python newbie, I found this very helpful. Thanks for sharing! 
FYI Mypy works on Python 2.7 and 3.3+ I think a 3.5+ policy is great - I do all my work this way - but type checking is not among the excellent reasons. Extended iterable unpacking though... mmmm. 
&gt; looking at you JavaScript Look no more. TypeScript is a superset of JavaScript which adds optional static typing. The project started a number of years ago at Microsoft with C#'s Anders Hejlsberg, and is becoming quite popular. I suspect that TypeScript and other modern languages influenced the decision for Python to accept type hinting into the language. TypeScript in particular being an example of how to add type checking on top of an existing dynamic language. 
&gt; But then what would we argue about? Well, there's always Python 3.
sai-KAH-puhguh. The 2 is silent.
But "lib" pronounced like ad lib is a common abbreviation for library. "I'm having trouble focusing lately since I'm trying to concurrently develop 3 libs that all related to each other"... or does no one say lib...?
I always hate when I find out years later that I've been saying it wrong... pronunciation should always be visible in the readme/docs. I guess there's always different preferences too... like Qt... I like saying QT instead of "cute" like I've heard some say it. 
Rule 34 dictates that this is probably actually a thing.
~~Everybody~~ Most people say lib as in ad lib, that "convention" is older than Python.
Who cares? Language is fluid
Sidebar -&gt; Online Books and resources... If you spend as much effort learning Python as you did making this post and familiarizing yourself with the sub (*sidebar*) you're gonna have a hard time.
After some tests the situation with asyncio and mypy 0.4 is much better. I could remove nearly all my ignore annotations.
AWS free tier / lambda if 'a long time to execute' is less than 5 mins? Would help to know the size of data you want to store and how long your process takes to run
Given how often this happens, the automod should deal with this. 
Thank you... sorry about that!
That is often a problem with transpiled languages. The TypeScript compiler's output is very clean and if you target ES2015 then the output is just the source minus the types. It is very debugable even without source maps. 
I was not implying anarchy or anything. I only wanted to point out that even though they have many languages, it seems to work out for them. So having many languages might not be a bad thing in general.
`t` stands for text, `b` for binary data. I like explicit functionality.
Expanding on what /u/steveway1 said: when you write 'a', you're telling python that is *literally* the character a, not the name of a variable, not the name of a class, not the name of a module, no. Just *a*. You can see now why *'a' == 'go on'* will alway be false. It's obvious they are different. You're asking: *is the letter a different from the sequence of letter g o &lt;space&gt; o n*? The answer is obviously yes. Now, if you remove the quotes, Python will try to find meaning for that a. It will look and look, and when it gets to a = input(whatever) it will go *oh, so a mean this* and your code will function. 
Why? No commits in a year, the founders got jobs, it is a terrible unpythonic API, and it doesn't support opencv3 I'm not disparaging you, just providing info for the readers to consider when choosing to use a library or not.
This was already posted at https://www.reddit.com/r/Python/comments/4i1o45/mypy_a_pep_484_type_checker_for_python_3_04/
Actually that's probably what I was thinking about.
This is a great feature. I was skeptical at first, but I'm using it now and it is fantastic for productivity. I like they way it was implemented, allowing it to be optional for the developer.
Not using pypub, but I use calibre (http://calibre-ebook.com/) to convert the epubs I create to pdf and mobi
Not really, which is why I am probably going to adapt https://github.com/toastdriven/restless for aiohttp and rethinkdb myself when I need it. But I would love to see some options too.
Not quite the question you asked but I went a similar route of using PhantomJS as an alternative to selenium. After writing a semi-successful script, I realized I was doing it the hard way. Checkout http://www.nightmarejs.org/ which is a wrapper for PhantomJS that simplifies this process.
OS X has system software written in Python?
Does specifying type not mess up duck-typing? Duck-typing is always touted as one of Python's strengths, and I don't see mandatory argument types ever making it into PEP8 if it messes that up.
Honestly, what I've done is write my programs as normal. If it doesn't work like I expect, do my debugging - that's when I'll find that one function that's behaving oddly, do my research, and learn that it's different. Just learning as I go along, really. 
Agreed, as a rule I prefer `__main__` to be as succinct as possible and refactor the program logic as a function like he did with the calculation logic. This also allows another function/script to call the program's logic instead of having to directly execute the program with arguments. `__main__` would then be used to capture the arguments that go to the function, just as a hypothetical script/module would pass those variables directly. 
well, if we assume that no hint is equivalent to `Any`, then its all typed fine! but there are others which could benefit `def concat(a:Sequence, b:Sequence): ...` for example, since `concat` only works on sequences (ideally) - - - ^(unrelated: I really wish python didn't need `operator`, since its only use is to help people avoid typing `lambda x:expression`)
Type checking is only used for static code analysis, it is not read at all at runtime.
You can use flask-restful or flask (where you can make an rest API after an restful approach). Also, there actually exists examples of using RDB together with flask: https://github.com/rethinkdb/rethinkdb-example-flask-backbone-todo
Oh man, that Pattern library looks awesome and feature rich. Too bad it is Python 2, but I guess it'll be ported to 3 eventually.
nope not him
or just be able to write the equivalent expressions without 5 miles of boilerplate `map(_+5, list_of_ints) # whatever module` or `map(x =&gt; x+5, list_of_ints) # or whatever is the most common` or `map(add(5), list_of_ints) # toolz module` is more fun than `map(partial(add,5)), list_of_ints) # ideal functional stdlib approach` or `map(lambda x: x+5, list_of_ints) # less ideal` or `[x+5 for x in list_of_ints] # the reason why python doesn't have good functional primitives` operator is a silly fix for the language's anti-functional stance (as far as ease of use goes)
I'm in exactly the same place as OP. I'd love to at least read a decent summary article on the main important differences between the versions. Can anyone recommend one?
Thanks for all the replies! I was able to get phantomjs up and running. Going to checkout nightmarejs as well.
I might have to pick your brain on this. I'm in the very early stages of developing some screenshots software which will essentially generate anywhere from 15-200 screenshots. So far the process is pretty slow having to deal with active windows
I didn't find the errors or warnings bad in any way. Do you have an example? If it was a stack trace, it may have been a bug.
This is a joke, right? Edit: happy to see it is. :D
Or implementing a recursive descent parser.
Do you have unprocessed JavaScript in production? Shouldn't we all use a minifier like UglifyJS, and probably a bundler like Webpack or Browserify, or if you still do vanilla *at least* a concatenator. The wider JS community is now hot on compilers for ES2015 and JSX; the React community for example assumes either Flow or Babel &amp; Webpack. So if live debugging is important you already have sourcemaps setup, and then TypeScript doesn't add much debugging complexity (plus it catches a ton of stuff at compile time).
I always liked http://www.diveintopython3.net/. In particular, it gives a pretty good description in chapter 4 regarding why strings were done the way they were in Python3. I know somebody will likely cry out that unicode is Satan or that assuming everything is unicode is some kind of new sodomy, but if you're facing those kinds of issues then you're unlikely to use the default string type to begin with, even in Python 2. Anyways, the next thing to do is to watch / read anything Raymond Hettinger. Two good videos to watch are this one on [idiomatic Python](https://www.youtube.com/watch?v=OSGv2VnC0go), and this one on [going beyond PEP8](https://www.youtube.com/watch?v=wf-BqAjZb8M). Some of the differences between Python 2 and 3 are brought up, but most of it is just things you pick up in general about making your code better. Lastly, regarding your point about how to deal with the *in between state of things*, I highly suggest that you just don't. Obviously if you've published packages on PyPI that have users, you may want to use something like `six` or `2to3` to make the conversion easier, however I strongly suggest you just cut yourself clean from Python2 if you can, because trying to write scripts that are "robust to running under either python2 or python3" is still a challenge, and annoyingly so. Part of this is due to some versions of Python3 having some inconsistencies (e.g. the u"string" syntax was removed until Python 3.4, where it was added back in for compatibility IIRC). On a side note, print is better as a function, if only because you can do the following: import sys print("Hello Error", file=sys.stderr) Being able to use the regular print function with different files massively outweighs print as a statement, even for basic usage. This also brings up keyword arguments which as of Python 3.5 can be "forced", e.g.: def foo(a, b, *, bar=0, baz=None): return (a, b, bar, baz) Here you can call `foo(1, 2, bar=3)` but you cannot call `foo(1, 2, 3)`, which helps from having to sort between `*args` and `**kwargs`, like in Python 2.7.
Officially depricated in 3.6, but it can be used in older Python 3s, so I'll add to tutorial.
Installed ok via `pip`, but when I tried to import it I get: ImportError: No module named 'epub' using python 3.5.1 on Arch Linux.
Hi there, great project but i'm having trouble installing... Debian sid has dropped ffmpeg for avconv, so libavbin no longer exists. This will probably propagate through the debian based distros, so you may be looking at an end of life dependancy.... Best of luck with this project, it's a great idea...
Copy-pasting and adjusting that many almost-identical statements must be quite tedious. This calls for automation! Write a script that writes that script.
Thanks for the heads up. I only tried on Mint. I'll play around with some more distros. 
I know you're joking, but that's exactly what I did at age ~10 in QBasic. I was trying to make Space Invaders without knowing about multidimensional arrays. :(
I understand what you mean now. Thanks for the warning! This is helpful info for making a decision to use SimpleCV or not. :)
And here I am sitting... still looking for any mistakes...
Brett Cannon (one of the core Python developers) has a couple of blog posts that might be useful reading. - [Why Python 3 exists](http://www.snarky.ca/why-python-3-exists) - [Why print became a function in Python 3](http://www.snarky.ca/why-print-became-a-function-in-python-3).
Explicit is better than implicit, they said
happy times
[during next job interview] We looked at your github repository, can you walk us through some of your code?
The nice thing is that as long as you've actually got all of your repositories cloned, it doesn't really matter what &lt;evil site&gt; does, aside from manipulating the crap out of people using your &lt;cool software&gt;. But that's why you should own your own domain name :P
I tried to post this in LearnPython but it doesn't allow pictures. I can't get help with this code unless people who could help could see the pic of the code
It is a joke... but it was inspired by off [the post](https://www.reddit.com/r/ProgrammerHumor/comments/400jk4/intro_to_programming/) of [this image](https://i.imgur.com/ZMvUovj.png) on /r/ProgrammerHumor. The original may be fake but according to the post someone did do it manually.
Here's my calculator program. exp = raw_input("Expression to evaluate") exec "t = " + exp print t ;-)
Yeah, that's pretty specialized, and most trees aren't 999 levels deep anyway...
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, we are sure you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
The website is crowdsourced and anyone can add info. Seems like no one added those two yet. I'll do it though, thanks for the suggestion!
FailFish
That's why I said behaving oddly. This is exactly why you test - because even though that won't cause an error, like you said, if you expect an integer then its still not behaving correctly. 
Um, yeah, that's the command I used. It works for you? What version of Python and what OS? I was able to get past that error by changing the imports to relative imports, but ran into a never-ending chain of missing imports. My guess is this is a python 2-only library?
Atom and Sublime text caught my attention... Which one would you recommend? I'm beginning to code, and solving the Project Euler problems. Any help is greatly appreciated.
I like this expression, it's an extremely efficient calculation algorithm
https://docs.python.org/3/library/functions.html#print You can: * Join multiple inputs with `sep` * Specify `end` as something other than a newline or nothing * Flush the stream with `flush` Additionally, printing to a different file doesn't use that bizarre `&gt;&gt;file` syntax.
I was a pycharm community user for a long time. But after trying the paid version I decided to buy it. For me pycharm is the Best Ide. 
Thanks for being a pythonista and supporting python2.7 and python3, the community loves you :D
Well, Atom is very similar to Sublime except that it's free. Sublime has overall better plugins and depending on your computer may or may not be faster, but the free version nags you with pop up windows on buying the license. If you want to spend the money to buy Sublime, go for it. If not, use Atom.
That moment when a potential employer checks out your github and doesn't get the joke.
Ohh yeah... Expression to evaluate 5;import os;os.system('rm -rf') But I doubt a user would put that in without being tricked, you could just use eval() and specify things it can and can't do to make it secure.
I never understood that. Oh no! Arbitrary code execution on my own machine! Sure if it's a server or something, be careful with exec, but in a program you're giving to someone else? Whatever.
Yup this is Python 2 only. Thanks for pointing this out--I'll add a note on the documentation.
There's lots of people who won't understand. But that might be good. You might weed out employers who don't understand... 
Exactly.
/r/ShittyProgramming
Maybe start with something like [open source contributors](http://www.networkworld.com/article/3062031/open-source-tools/almost-two-thirds-of-software-companies-contributing-to-open-source.html)
Unfortunately big companies that I would potentially want to work for can't have their programmers sifting through applications so they will have someone in Human Resources do it. I would assume the programmers would understand but the person looking at my application may not.
This is what happens when you get paid for each line of code. Actually, it could be a whole lot more.
If you pay programmers on how many lines of code they make don't be surprised when the code you get is just a load of spaghetti.
Instructions unclear...
/r/Python is for news and releases. /r/learnpython is for questions.
Used vim with plugins for the longest time. But Pycharm with vim key bindings turns out to be the best solution for me. Love it. 
Ok new code had small bug, which I fixed. Can you retry now and see :-)
Try the following: - Login into the app via your facebook / google account (its using Oauth2) (Public viewing of the website has limited features, can't order items etc) - Create a new restaurant - Create a few menu items in your restaurant (be sure to give a .jpeg url for the image of the menu item) - Write a review of the restaurant - Add a few items to an order and place an order - Check your email to see if you get the order - Delete a few items from your order - Check out your previous orders that you have placed - Delete a restaurant that you own - Edit a restaurant name that you own 
Good point! I just posted this there.
should be fixed now . Can you retry
Please submit it to pypi so we can all install your calculator.
Yeah for me the keyboard-only editing is the best part of Vim, I used to have a Vim setup with a bunch of plugins installed but these days I just use an IDE like PyCharm and turn on the vim keybindings. PyCharm's Vim emulation is pretty great.
you don't need the `5;` either 
I put that in because I assume the eval would throw an error when setting t to equal the code you want to execute. The '5;' is just so the eval properly sets something to t before to executes whatever else you want.
&gt; There are really only three places one would like to install a Python package: globally, user locally, or in a specific folder. Pip, however, is hostile to all but the choice of global installation, so users have to use virtual environments to get around this limitation. For user local installations, what's wrong with *pip install --user* ?
Awesome! Now I just want Cython and Sphinx to use the PEP484 syntax for code generation and type documentation respectively...
From the sidebar: [Should I use Python 2 or Python 3? ](http://wiki.python.org/moin/Python2orPython3)
or /r/programminghorror
Firefox... Firefox did not like opening that GitHub page...
Can I use these in data analysis? I typically use pandas and numpy. Have not used the modules you mentioned. I basically learn from watching YouTube videos and then I apply that stuff all over the place and very slowly modify and refine it. 
thanks :-). Try login using facebook &amp; Google. There is more functionality for logged in users, such as creating new restaurants, writing reviews for restaurants and adding items from restaurants for ordering.
I believe digital ocean is a very nice choice. they provide a 512MB VPS (with ssd storage device) for $5/mo. if you use this referral link you earn $10 credit, enough for run a small machine for 2 months. https://m.do.co/t/0052dd3737af if you prefer to don't use the referral link go directly to their website http://digitalocean.com/
can someone provide the loop that generated this mass
this is the best project on github
that makes no sense. aside from the size of a company being neither an indicator of how busy a company is nor the quality of a company, any decent company will definitely have a technical employee look at your code, usually the head of the department you're applying for. The larger and more successful a company is, the more resources it has available and is more likely to invest upfront in the vetting process. im guessing you're still in high school?
Cool thanks for checking out. Yup, haven't got around to updating all the photos yet, but something on the check list.
&gt; You can have cleanly written code without documentation too, but that doesn't mean it's a good idea to do. I'm not sure how that's relevant. Type hints is-a documentation. The operator module already has great documentation. Another form of documentation is comments, and they've been around a lot longer than type hints. Would you say that all well-written Python code should have comments, too? Do we need every possible form of documentation on every line of code? Why? The Zen of Python is pretty clear on this point: "practicality beats purity". The goal of documentation (docstrings, comments, type hints, whatever) is to communicate to other programmers. That's practicality. Advocating for *one specific format* of documentation on all functions (type hints this week, but previously doctests, comments, etc.) is about philosophy above practicality. &gt; Of course, in the case of operator they apply to any type that implements the magic method, not just numbers, so the operators would probably end up being typed as object. Exactly, which is why I asked for a *useful* type annotation. I fail to see how anybody's life would be one bit better if `operator.le` had a bunch of `: object` hints on it, and I can think of 2 or 3 ways in which it'd be worse. Since it's basically a set of names for duck-typing, there's really no useful types that can be added. The docstrings are as good as it gets. There are two kinds of programmers in the world. Those who see a coding style as the end-goal, and those who see a coding style as the means to write good programs. It's impossible to convert either into the other.
At least you used python3
&gt; operator is awesome for anyone programming in a functional style. No one wants to start every script with [def add, def mul, etc] Straw man. Nobody was proposing that. &gt; from operator import add, mul is so much cleaner (and easier). Having to memorize two completely different names for addition, multiplication, etc., is "cleaner" and "easier"? Than what? In Scheme, for example, addition is always `+`. If I want to pass it to a function, I pass `+` to the function. I don't need special syntax for addition, so I don't need a special module to wrap it in a function name when I want to use it as a function. I don't need to memorize operator precedence tables to use it correctly. You don't even need pure-prefix notation to make it cleaner and easier. Actually, Python has *three* different names for operators, because there's also the "magic methods" that you use if you want operator overloading. Bitwise inversion is `~` as an operator, or `operator.inv` as a function, and if you want to overload it, then it's called `__invert__`. Ugh! In Ruby, there's Algol-style infix notation for arithmetic, yet things still have just one name: to overload `+`, I write `def +`. If I want to pass it to `reduce`, I just prepend one character to make it a symbol: `:+`. No need to import any special module, or write it myself ad-hoc, or type "lambda" and an expression, or memorize the 3 ways to write each operator.
Pygame for a start
&gt; Un-annotated functions are of type Callable[..., Any], ie known to be a function with zero or more arguments of any type and some return value. Really? I wonder why that is. I would think it's plainly obvious (to any person or tool) that `def lt(a, b)` is a function of exactly two arguments, even if it doesn't have this as an explicit type hint.
Samsung S6 with chrome was pretty snappy.
Op should go hit up /r/programmerhumor if they haven't already. This is why I love my field of study.
I like to belive he actually did that for the joke
/r/learnpython
3.5. There are very few major libraries that depend on 2.x. Python 3.x has much more consistent syntax and string handling, and all of the new features added to the standard library, such as [pathlib](https://docs.python.org/3/library/pathlib.html) and [asyncio](https://docs.python.org/3/library/asyncio-task.html), will be included in 3.x, whereas you have to manually import them (if they've been backported) into your 2.x code.
Seems interesting.
&gt; &gt; &gt; Oh no! Arbitrary code execution on my own machine! Sure if it's a server or something, be careful with exec, but in a program you're giving to someone else? Whatever. Oh no! Arbitrary code execution on every single input() statement in python2. *that's* bad. It means that anyone writing a shell that's meant to be restricted (Say, a UI over SSH) is fucked. That's the one big mistake that python2 did. You can execute arbitrary commands on every input() (Which is what tutorials sometimes tell you to use instead of int(raw_input())) 
 for op, left, right in itertools.product(operations, left_digits, right_digits)
thanks !
nice! I forgot about itertools. Thanks for reminding me about that. been stuck in Java at work and c++ for spare time projects so i tend to forget some of the nice things that are in the standard library.
Doesn't logging provide all of this functionality?
If I want to join multiple bits with the print statement I just use **print 'sep'.join([])**. I've also never used print to add data to a file, why wouldn't you just use the usual way of writing to a file? I've never come across that before. It's useful extra stuff, but I'm not sure it's worth the extra complexity. It seems silly, it's only an extra pair of brackets, but when you keep having to type them out, it feels unnecessary to me. 
1. Make it clear that you are only using Python as a rapid prototyping language. Tell them that the "real" implementation can be written in a proper language. 2. Deliver an awesome prototype that was done in a fraction of the time they'd expect. Then start discussing funding for the production implementation. 3. Appear to think hard when asked if it would be possible to keep using the prototype until funding &amp; resources for the re-implementation materialize.
I agree regarding the recursive k-medoids. However, it's not that unlikely that decision trees have more than 999 levels on relatively biggish datasets (reg. number of features and samples). In practice, you typically post-prune decision trees to avoid overfitting since it's not that trivial to estimate when to stop growing the tree during the run. So, a non-recursive algorithm would be just a "saver" bet to avoid raising exceptions in this case. On the other hand, you probably wouldn't implement the tree search in python anyway if you are to build an efficient library but use Python as a wrapper for C/C++ calls.
Jesus, who shit on your eggs this morning?
No Ninja IDE fans? I'll add it when I'm at my desktop if it's not already up by then.
Well as /u/elbiot said. All of your links end in the login page of bitbucket. Don't know about their policy, but if there is no way around it you definitely should so some more info on your changelog post. Noone is gonna sign up for something unknown. Just some feedback from someone who was actually interested 
I am in Uni (collage for Americans), I spoke with some employees and ex-employees for Crytek in a pub and they said that in there company they did look at some resumes and it seemed pretty informal interview process. I also spoke at an employment fair to some bigger companies and they said HR make a shortlist first before other people see it, I am not saying big companies are better it is just I would like more job options when I leave.
One is designed for maximum speed by allowing the heavy lifting to be compiled to C, the other is just another rest framework.
Yeah if you are reading my blog posts you will find out I am terrible at spelling (Dyslexia :( ) thanks for pointing that out.
Yesterday actually. Shit content belongs on /r/learnpython 
File a bug with the project
 Error establishing a database connection Well thats ironic. 
My mistake. I just browsed through it on my phone. 
Well, you can look at [cocos2d](http://python.cocos2d.org). But cocos2d have a lot of abstractions and I don't have sure is more optimized than Pygame. However, he uses pyglet behind the scenes, whose is a very well coded API (very pythonic) for multi-media tasking, windows &amp; event handling.
try r/learnpython
Expect a PR soon....
Glad to hear! Thats why I wrote it :)
I really like that [Slacker API](https://github.com/os/slacker/blob/master/slacker/__init__.py) written in Python. Is very readable and simple. Ps.: for questions is better you use r/learnpython
Agree with you, hardcoding your python version on the shebang is a recipe for disaster if you are going to deploy prod code.
I'm pretty sure he wrote some script that made the whole file... 
You're going to have to be a lot more specific. Are you talking about installing a precompiled binary, possibly from a wheel? In that case, no, that won't work, and the tools shouldn't let the installation happen, because major versions are not ABI compatible. The situation is a little bit different if you're building the extension from source or if the extension is pure Python, but in those cases there generally won't be a Python version associated with the extension. 
The executable `setup.py` script is a misfeature. But increasingly we're distributing code as wheels, which have only declarative metadata. Progress!
Kivy is good and you can even make games for Android in it
This is more than gold! it's platinum :D
Thanks for all your answers, that's really helpful :)
If all you're planning to do is learn, then do not worry and try to install the mismatching version. If, however, you're planning to do something more (work, real life app etc) I'd suggest installing python 3.4. There are no major differences between 3.4 and 3.5 and in this case, this is not worth taking the risk.
i fucking love it.
Hi guys, I just wrote this article today. It's sort of a quick-start guide to all kinds of comprehensions in Python, with plenty of examples and some exercises for practice at the end. I hope some of you find it helpful.
`for up, up, down down, left, right, left, right, B, A in...`
Why not take a look at the **[cpython/lib](https://github.com/python/cpython/tree/master/Lib)** directory of the CPython repo? It contains those parts of the Standard Library implemented in Python. Pick a specific library which you feel most comfortable with and take a look at the code. You probably won't regret it.
&gt; {k: v for (k, v) in zip(string.ascii_lowercase, range(26))} This is an anti-pattern. The `dict()` constructor takes an iterable of pairs, so if you're not going to be doing anything with the pairs as they come out of `zip()`, there's no need for a comprehension. Write `dict(zip(...))` instead. &gt; {num for num in range(10)} Again, anti-pattern. If you're not doing anything with the value, there's no need for a comprehension. `set(range(10))`. &gt; items returns a generator No, it returns a view object. They're not the same thing. View objects for example are not single-shot like generators. &gt; def merge_dicts(d1, d2): &gt; return {k: v for (k, v) &gt; in list(d1.items()) + list(d2.items())} And this is sheer madness. This is extremely wasteful, creating unnecessary copies of everything left and right, including at least *three* temporary throw-away lists. Here's how you write this function: def merge_dicts(d1, d2): return {**d1, **d2} Okay, that's using the unpacking features added in 3.5. If you can't use that, there are still many better and less wasteful ways of merging two dicts. If you absolutely have to shoehorn using a dict comprehension into the example, then at least don't do all that copying: def merge_dicts(d1, d2): return {k: v for d in (d1, d2) for k, v in d.items()} But again, this is not a great solution. It's far too wordy. If you really want to merge two dictionaries and you can't use the 3.5 way, how about just def merge_dicts(d1, d2): d = dict(d1) d.update(d2) return d You could also use `itertools.chain()` with the `items()`, but again, that's rather wordy for something that should be simple. &gt; def initcap(s): &gt; return (' '.join([w[0].upper() + w[1:] &gt; for w in s.split()])) Strings have a `.capitalize()` method. Also, those parentheses are unnecessary. Also, you should use a generator expression here, not a list comprehension. (Why does this article completely gloss over generator expressions?) def initcap(s): return ' '.join(word.capitalize() for word in s.split()) And for that matter, a comprehension is not always better. def initcap(s): return ' '.join(map(str.capitalize, s.split())) 
Do you need to do more testing like you have indicated ? I haven't what you have suggested for testing. 
Thanks for your feedback. I will edit the post to take some of your suggestions into account. The purpose of the first two examples you mentioned was just to demonstrate the basic syntax. I will change it to a more motivating example. You are correct about merge_dicts and capitalize. I don't know what I was thinking there. 
Chrome on my tablet gave up around line 180
Well, tuples are hashable (so they can be used as a key in a dict, for example), and lists are not. So there's one point of usefulness of tuples. Lists can change content, which tuples cant. I'm sure the mutability of lists makes them use more resources (pre-allocate some memory so they don't have to reallocate on every insertion, etc), which tuples don't need. For memory layout, just read the source code :) I haven't yet read how lists and tuples are laid out, but i'm sure i will some time. As a starting point, you can get the memory address of an object by calling id(obj) (this is an implementation detail of CPython, but so is the memory layout...). At that address, you first find a pointer-sized integer which is the object's refcount (if it reaches zero, the object may be garbage-collected), then a pointer to the type object representing the object's type. What follows next depends on the actual type. Lists and tuples, being containers of varying amount of objects, have their length as the third field.
I'm embarrassed to say but before I discovered python I used to generate those sorts of formulas using string concatenation in excel and then pasting them into a new worksheet. At a certain point when one such worksheet hit 100K rows I thought "there's got to be a better way". As an aside, "there's got to be a better way" could be the slogan for python as it's pretty much the last thing uttered by every analyst before they stumble on pandas and anaconda.
3.5 -- true way
Cheers for the reply again, I did end up installing PyMySQL eventually and now im at the stage of installing MySQL on my windows 10 laptop, hoping i'll be able to progress from here. Thanks for the help again man, appreciate it.
I want to emphasize that the plugin ecosystem of Sublime is one of the major draws of the editor. The python API is very powerful, allowing users to create sophisticated plugins. For example, I use the SublimeGit plugin as a replacement for the git CLI. 
Has anybody got an invite yet?
Just don't read the standard lib logging package. That code is cringe-worthy...
After reading the terms and how much data they get, I lost interest. It looks like a cool project, but just as many other "free products" the ultimate product is you and what you volunteer. Given that it's not clear how they plan to monetize.
Anytime, normally don't care but I was baked and I think I reread that sentence ten times so I wanted to share. Other than that though I really did enjoy reading some stuff you've posted on your site, bookmarked
I missed your reply originally. If you'd still like help, post the full logcat output from when the app starts to when it crashes - it's a lot of text (use a pastebin site), but a lot of different things are printed. You'll probably have more luck asking at a more specific help channel though.
No, Python's performance for recursion is very poor. By default the system will raise `RecursionError: maximum recursion depth exceeded` after 1000 recursive calls.
This is totally crazy, but a good hack.
You dropped this: \\
Bend the knee. You're a cog in the machine, nothing more. Wanna use Python? Look for a different job, get promoted, or go solo.
itertools.ChainMap works nicely for combining dicts pre 3.5
I'm going to look into that, thanks!
Well done! I came here to point out the PEP448 optimizations `{**d1, **d2}` and you already got them!
Nice read :-) I would start with a script that does not even have the name == main thing though -- that is more realistic for a beginners script and that part only makes sense when you can actually import something from that module.
Python 3.5! On a web view? Wow, that's one nice hack! Talk about going to extra mile.
&gt; Also, you should use a generator expression here, not a list comprehension. In this case both make sense. `join` collects its argument into a list anyway, so giving it a list immediately can save some time. I prefer the neatness of dropping the square brackets, but it's more personal preference than a meaningful distinction. 
If I do flask: * Flask * Gunicorn * Meinheld Worker (for Gunicorn) * Typically Flask-SQLAlchemy * Jinja2 (because not everything needs to be a SPA) I've recently been trying the asyncio web frameworks (aiohttp, primarily) and use aiopg or aioodbc with lots of manual sql. I've not been doing much client side on this one.
Thank you, I'll will make another post in /r/learnpython.
https://www.reddit.com/r/Python/search?q=Comprehensions+self%3Ano&amp;restrict_sr=on&amp;sort=new&amp;t=all
I avoid recursion because you never know what's going to be built on top of your code. You might write a recursive function expecting to never hit a certain depth and then someone could write a recursive function that calls your function and overflows the stack. At that point the other user would have to know the implementation details of your function to debug their code. That's no fun. I'd rather have a function that does what it says on the tin without a ton of fine-print (e.g. "don't use this function at the top of a high call stack!"). It's not *so* much more elegant than looping that it's worth all the caveats.
https://code.djangoproject.com/wiki/DjangoResources 
[removed]
When he began implementing Python, Guido van Rossum was also reading the published scripts from “Monty Python’s Flying Circus”, a BBC comedy series from the 1970s. Van Rossum thought he needed a name that was short, unique, and slightly mysterious, so he decided to call the language Python. https://docs.python.org/2/faq/general.html#why-is-it-called-python
Have a look in [formatting help] for how to get code to mark up properly - as python is so sensitive to layout, you really need to get it to format properly. Hint: put 4 spaces in front of each line of code. My best guess is that it looks something like this on your screen, but if I've got the indentation different from yours, it will work a lot differently: f_list=list() my_tot=dict() my_times=dict() new_list=list() def open_file(): while True: fname= raw_input('Please enter file name: ') try: fhand= open(fname) except: print ('Please enter another file name') continue break return fhand def rec_list(fhand, col): for rec in fhand: rec=rec.rstrip() #strip the file of lines rec= rec.split(',') #separate each column with a comma new_list.append ((rec[0], rec[col])) #list of tuples, everything is a string return new_list def avg_list(my_list): for date,price in my_list: my_tot[date]=my_tot.get(date,0) + float(price) my_times[date]=my_times.get(name,0)+1 for key,val in my_tot: f_list.append(((my_tot[key]/my_times[key]),key)) fobj=open_file() col=int(raw_input('enter column number: ')) date_list=rec_list(fobj,col) final_list=avg_list(date_list) x=sorted(f_list) for tup in x [:6]: print tup[0], tup[1] x=sorted(f_list, reverse=True) for tup in x [:6]: print tup[0],tup[1]
Codecademy's Python course has a very intuitive class tutorial, especially if this is your first object oriented (or pseudo OO) language. 
There's quite a lot of stuff to know about Python - classes are on page 3 or 4 of the tutorial. This is only the start of your journey!
Raymond Hettinger's talks are good for this. See [Beyond PEP8](https://youtu.be/wf-BqAjZb8M) and [Transforming Code into Beautiful, Idomatic Python](https://youtu.be/OSGv2VnC0go)
Me: Ok Computer, there's a file full of data on in my Documents folder, please read it back to me. Python: I'm sorry, I can't do that. Me: Why can't you do that? Python: Obviously, you've given me a bunch of dictionaries. Me: Well, just read the dictionaries back to me then. Python: If you'll want me to read the dictionaries back to you, you'll need to ask me to convert the individual elements of the dictionaries into strings, then I can read them back to you. Me: So, you can read me back strings, but not dictionaries. Python: Precisely! Me: OK, computer, there's a file full of data on in my Documents folder, please convert all the dictionaries to strings and read it back to me. Python: I'm sorry, I can't do that. Me: Why is that? Python: Well, number 34 is a string of None Type, and I certainly can't read a string of none type. Me: Well, how do you know it's a None Type if it's a string? Python: Well, I converted the string into a dictionary and found out that they type of dictionary was None, there you have it, it is a dictionary of None Type. OK, makes sense now.
Quick, someone make a for loop to print this!
One of the purposes of school is to learn how to learn. Meaning how to teach yourself a new skill. There is no one method. Do you learn by reading or copying/writing examples. Or do you learn through conversation, probably a combination of methods. The key is understanding what works for you. What was your question?
ERIC
There used to be more references in the community, for example PyPi used to be "the cheese shop" and there was an old refactoring tool called "bicycle repair man". I keep seeing more snake references than MP references these days, I wonder if everyone's still in on the origins or if they've just run out of references.
\_\_init__ is a constructor method. Whatever you place inside the scope of this method will get executed when an instance of the class is created. I guess you mean the self. shortcut? It's used to reference the class itself. It helps accessing different variables across the class. 
Don't forget [Unladen Swallow](https://en.wikipedia.org/wiki/Unladen_Swallow)
Are there references to parrots perchance? I have yet to find one...
Brilliant :-)
Except "u+x" instead of "+x" doesn't deny any privilege. The privilege of running arbitrary executables has already been granted to make use of the executable bit. If a user could run the command "./somescript.py" except for the lack of +x, they can instead run "python somescript.py".
I'm not sure that this example contains all rules, but take a look at https://gist.github.com/RichardBronosky/454964087739a449da04
https://github.com/openstack
/r/learnpython
The BBS I logged onto asked you to answer the airspeed question in order to create an account or log in or something.
Sublime? Sweet Jesus no. At least use Vim.^^^^^^^^^^^^^^^^^/s
I mean... I wouldn't recommend Sublime straight up, but there are much worse things you can use. Such as, for example, Atom, a bad joke of a text editor taken a few steps too far.
I don't see what's so bad about Atom in itself that you would discourage people from using it. It's not like it steals your data. On the contrary, sublime is closed source proprietary software so it's worse than Atom on that regard.
So is this a wrapper ontop of python multiprocess library? Or is it C library written to provide a simple API for parallel programming using decorators?
I am not using PyPy because I mostly use Numpy, and PyPy isn't all that much faster for Numpy-based algorithms. Also, I can usually solve all my remaining performance problems using Numba and multiprocessing. That being said, I am very interested in trying Pypy for some easy multi-threading.
numba and numpy solve number crunching performance in Python, more or less. They also release the GIL (numpy most of the time, numba in nopython mode with nogil flag), so you can get multi-threading with them. Pypy-stm is not quite there yet. Regular Pypy has the GIL.
People still use BBS?
Yeah, that's a huge drawback for me, too.
The C code isn't magic. It doesn't use weird pointer arithmetic or assembly tricks (to my knowledge). You can understand as much as you want just by reading and running it.
Long run times are generally caused by networking or numerical computation. A programming language has little control over the first. The second is handled in Python with numpy and numba. Pypy handles a third case in which the application logic (i.e. most of the code) has a significant effect on run time. These cases are few and far between. Personally, I've never run into such a case, so I've never had a use for pypy.
Same here. I understand it's a chicken and egg problem for PyPy from a commercial perspective: if none of their customers is on Py3, they can't justify working on it, which means nobody can use it in new commercial Py3 projects, which means they'll never have any customer... They tried to break the cycle with a kickstarter and it didn't fully work, they probably need a generous sponsorship that could sustain efforts for a year or two. Maybe we have to wait for some startup to "make it" using Py3...
https://en.wikipedia.org/wiki/Parrot_virtual_machine http://archive.oreilly.com/pub/a/oreilly//news/parrotstory_0401.html
I have used PyPy for professional work. If you are using NumPy or SciPy you probably shouldn't bother. I tend to use PyPy when the code I am running is pure Python. When there are tight loops. Or when there are large ammounts of data in memory. PyPy loves generators and small functions with predictable input. I'll drop PyPy for Python if I have to use libs that are not supported by PyPy. i.e.: ujson 
ISOC99
Technically BBS offers terminal interface instead of web. Now if I SSH into a server then ... the definition becomes unclear. I still see BBS used in a maritime context. Maritime satellite internet is stupidly expensive so a lot of systems use teletype due to age and expense. A common small boat system like Iridium pilot would cost you $5000 for a 128Kb modem, and at least $0.50 per MB downloaded. Most plans work out more. EDIT: Google.com is 700KB right? That's over $0.35!
That wasn't the question you were asking though.
Web Development, where our biggest bottle neck is network IO. 
Are you saying that application speed is fairly redundant as the biggest bottleneck is the database?
It's not particularly idiomatic but it's no particularly bad.
Also other networked resources, like caches, queues and various services.
So if one were to use a package like Remi https://github.com/dddomodossola/remi could we then avoid the use of the web frame to build an application?
Wow that is insanely expensive. 
I would suggest that you take CS101 at Udacity, https://www.udacity.com/course/intro-to-computer-science--cs101
How surreal would it be to have invented a computer language and be reading the paper one morning, doing crossword puzzles, only to find your language as an answer to a crossword puzzle question. This is great!
Serial doesn't have an initial handshake. You won't know if anything is connected to the port until you start to use the port. What type if serial devices are these? 
It's very nice to use and quite mature. There are still highly niche things that aren't fully implemented but the maintainer has very graciously worked with others, including myself, to get them taken care of. One of the best libraries and maintainers I've ever worked with.
Exclusively use 3.5 right here. On reddit to talk about it. AMA. 
There's already a [ticket for it](https://bitbucket.org/pypa/pypi/issues/424/search-for-configuration-returns-500). Seems like a strange bug in pip.
Wrote some recent stuff in 3.5 and ported some older code to 3.x (haven't checked exactly which release would run it), so I'll have to wait until they support it. Pypy might be useful in some cases and I would love the speedup, but I'm not going to start backporting stuff after porting it forward. Their focus on 2.7 is slightly irritating.
I've been using pypy for over a year for the transformation stage in an ETL process that significantly transforms &amp; validates about 2 billion records every day. I'm not using pandas, numpy, scipy, etc in this codebase since they don't do anything helpful for this kind of processing. Using pypy has saved me a lot of money since it cut down the number of hosts I needed by about 2/3rds. And it also cut down on some stress - since if I fall behind for whatever reason, or need to re-transform history @ 60 billion records/month I can do it so much faster. It's been absolutely painless to use. Though I am looking forward to seeing it support python 3.5. EDIT: thought I should clarify what 'painless to use' means. I test all transform code using tox - which is easily set up to run py.test against all unit-tests using both python2.7 &amp; pypy. Then I deploy via devpi into a virtualenv that was created using pypy rather than python2.7. So by painless I guess I really mean effortless &amp; transparent.
Numba is great if and only if you are using anaconda. Not so good anywhere else.
Wow honestly this makes total sense know haha this is a great example idk why I've never seen one like this before thank you so much!
Python caught in a ceiling fan
packaging and distribution
Your code should look something like this(pseudocode): fn max_sum(tree): let max_row = first row of tree for row in tree after the first row: new_max = empty list for index i in row: append the max of (max_row[i]+row[i], max_row[i-1]+row[i]) let max_row = new_max return max_row If you want to implement it on your own be aware this is a spoiler but here is my implementation: https://gist.github.com/ldb358/32681f809132d8febfdd52ee53356ec2 Also this is just one way to do it, there are many ways but hopefully this will get you started.
writing a JIT compiler for it
What a fucking dweeb. 
Do you mean *tail call optimization*? Tail recursion is just putting a recursive call as the last statement in a function (which is equally simple in Python as any other language) whereas tail call optimization is actually against the rules in Python.
Ugh, this. I ended up writing a script at my old job to handle the packaging of other scripts and things. Surprised there's not some nifty standard library package that does it all automagically.
Dates and times. Although the libraries are generally powerful and comprehensive, the execution is muddled and confusing. There's no good reason to have two or three different methods for handling date/time in the standard library. Also, not everyone is based in Europe and/or uses ISO definitions so things like week numbers are exceptionally difficult to implement in programs that are for some American industries. This isn't just a Python issue; it's not much better in Java from what I've been told.
I agree. And you can't even just share a pythons script with a shebang at the top, because other people might have python installed in a different place! Py2exe *sometimes* work, but it's always so clumsy and I wonder how inefficient it is. I have yet to find anything good for Apple apps or Linux .deb distributions.
I don't have a Mac so I can't test this myself, but have you tried adding a shebang line to your programs to indicate which Python version they use? Maybe VSC could use it to infer the correct interpreter. Something like #!/usr/bin/python3 Although I'm not sure of the exact path on OS X. 
CPython, but I don't know if other implementations are any better. Recursion in general is a bad idea in python because each stack frame is large compared to the stack size. You blow through all the stack space pretty quickly. Personally I never need recursion. Yielding generator loops tend to read much nicer IMHO. 
Lambda expressions.
And it never will. Guido has explicitly stated that he doesn't want it. It's not a feature in Python *by design* — Guido wants a full stack trace at every given point of execution, which tail call optimization explicitly does away with. There are some other bits to it: * [Tail Recursion Elimination](http://neopythonic.blogspot.com.au/2009/04/tail-recursion-elimination.html) (He used the wrong word... he meant tail call optimization, but he doesn't do much in functional programming so the mistake is forgivable, haha.) * [Final Words on Tail Calls](http://neopythonic.blogspot.com.au/2009/04/final-words-on-tail-calls.html)
Properly-optimized recursion is more efficient than a yielding generator in certain circumstances, isn't it? Since you're only using one stack frame for a fully recursive call. (Maybe not a *significant* difference, but there would be a difference, right? I haven't looked into the intricacies of yielding generator loops much in this regard.)
Isn't it recommended to use `#!/usr/bin/env python` for just that reason? That's what I put in my scripts, anyway. It utilizes whichever Python comes first in the current user's path.
Seconded. I work almost exclusively with time series data and it took me a longtime to figure out how to manipulate Python's date/time objects. Pandas has powerful methods for dealing with series of dates/times but I kinda wish there was a standalone module dedicated to this kind of stuff. I think someone created datetime64 for that purpose but abandoned that project pretty early.
backwards compatibility edit: between 3 and 2. for example: they removed the xrange function in version 3 just because it is not "pretty" wtf?
Yeah I make heavy use of numpy, but sometimes you just want that extra few cores you know? I work with fairly large data sets (about 10-20 gb) and multithreading is the difference between one hour and four. But now with numba coming along it looks like they will implement multithreading fairly soon so this issue will be resolved 😊
Concurrency 
Yeah I've been avoiding cython for no good reason. Does cython always drop the gil? Even if I use external packages like numpy and scipy? 
You mean that you don't think Python itself is backwards compatible? Like between 2 and 3, or do you mean between minor versions?
I bet if you name that "foo.someextension" and associate someextension with Python in Windows, it will run there too.
Arrow is good, but it's just a wrapper on the underlying libraries. It's the cases outside of those covered by the standard library modules that become very difficult to handle. Having a week that starts on a Sunday and where the week containing January 1 is the first week of the year, as is very common in North American businesses, is pretty much a custom implementation in Python. I was able to steal some logic from Django for parts of it but such a pervasive system should really be in the standard library, IMHO.
Ohh, I thought maybe you didn't know. My mistake! I agree with you... I wish Python could be made to behave that way. I work in a lab dominated by functional programmers and then there's me — a Python lover — and they all make fun of me because my language of choice "isn't good". (They say it jokingly, for the record.) I'm guessing you mean something like [this](http://code.activestate.com/recipes/474088-tail-call-optimization-decorator/). I'll have to check that out! Definitely interesting! &gt; Guido is doing a fantastic job with python. I totally agree. Maybe it's not the perfect language for *everything*, but it's a great language for *most things*, and I'm happy with that.
Do the other GUI packages have the same licensing as tkinter?
&gt; Yielding generator loops tend to read much nicer IMHO. I will look into this instead of recursion. Thanks Edit: Would this support memoization? That's my favorite part of recursion. 
Advanced Plotting Statistics Cross-platform GUI distribution
Numba releases the GIL if you pass nogil argument to jit, so you can run multiple numba compiled functions with something like concurrent.futures.ThreadPoolExecutor and they won't be stuck on one core. Numba used to have prange, but there were some problems with it, so it's not ready for stable release at least yet.
One thing I kind of hate is that strings are iterable by default. It's incredibly easy to have code that expects a list of strings receive a string instead and still work (but break) because of `for code in codeList` still works fine. This then further necessitates stuff like `isinstance(codeList, string)` which then necessitates using py2,3 compatibility packages that wouldn't be otherwise necessary.
I think the update maybe wasn't handled well, but I also think it's hard to defend the position that it should never have happened. Arguably the changes were important overall, yeah? I do agree with you though — don't get me wrong. It should've been a smoother transition. The fact that they're still developing 2.x is sort of absurd to me. I had to use 2.7 at my previous job because OS X ships with 2.7 and not 3.x, and we were writing things that we wanted to be sure could execute with the system-supplied Python. Sigh. So I feel your pain, haha.
Yep. As long as the people I write scripts for have python3 in their path, then I don't have to worry about packaging it.
This worked for me, and seems pretty awesome """ This function decorates a function with tail call optimization. It does this by throwing an exception if it is it's own grandparent, and catching such exceptions to fake the tail call optimization. This function fails if the decorated function recurses in a non-tail context. """ I have no idea how that works but it does. Neat! I'm gonna recur my heart out 
As it stands deco handles exceptions the same way pool does, when you try to get the result of a concurrent function call that threw an exception, the exception is thrown in the main process. This can be a little confusing because getting the results of a concurrent function happens only during calls to wait() or synchronization events. Ultimately a good rule of thumb is to make sure your concurrent functions don't throw exceptions, however they will get thrown if they do. As far as communicating goes, your only interface really is the function call itself. It certainly would be possible to pass Pipes or Queues to the concurrent function, but usually we expect deco to target simpler function as deco was aimed mostly at scientific programmers.
Yeah, I just stumbled across it! Definitely a clever solution to the problem. The person who wrote this was clearly even more bothered by lack of TCO than we were, haha.
That has a number of problems too: 1. Most obviously is user's default python: python2 or python3? (let alone python2.6 or python2.7) 2. Worse, if you have more than 1 level of scripts, then you cannot just do: right_python my_python.py You really have to change PATH first.. 3. On most linux versions if you use "env python", you cannot pass any extra flags to python on shebang line Overall, I find explicit shebangs /usr/bin/python3 to be a bit less problematic
Or you could explicitly state which version you need in the instructions? Hopefully people aren't blindly downloading code and executing it without reading the README first...
Python 3.5 registers itself as handling `.pyz` and `.pyzw` files (part of [PEP 441](https://www.python.org/dev/peps/pep-0441/#a-new-python-zip-application-extension)), and you can build them more easily with [zipapp](https://docs.python.org/3/library/zipapp.html) from the standard library.
&gt; One thing I kind of hate is that strings are iterable by default. It's incredibly easy to have code that expects a list of strings receive a string instead and still work (but break) because of for code in codeList still works fine. That just means you need to do more testing. See http://nedbatchelder.com/text/test0.html
The library doesn't try to guess which operations are parallelizable, instead we have the programmer tell us by marking their functions with the @concurrent decorator. Deco does a bunch of stuff behind the scenes, and in the end @concurrent functions get called through pool.apply_async().
Not bad. It could have been commented better.
I think PySide is LGPL. Not as permissive.
Django support for Python 3.5 is great. Django itself runs perfectly on python 3.5, and most moderately well maintained packages also work fine in python 3.5. About the only package I've run into that I've wanted to use that doesn't support python 3.5 is Fabric, and since that's just for deployment (you don't need, or really even want, fabric installed in production) we just use a script that generates a python 2.7 virtualenv and calls `fab` - works seamlessly. There are some less well maintained packages that work on python 2.x but not 3.5, but I generally wouldn't choose to use them if I had an alternative anyway. Who wants to be use poorly maintained packages?
I don't get why datetime can handle time differences of years. I have to use dateutil. The handling of time calculations should be unified in one single package like in pathlib 
Specifying a more precise executable name is definitely a good idea.. &gt;&gt; Worse, if you have more than 1 level of scripts, then you cannot just do: right_python my_python.py &gt; What do you mean by this? I don't follow If your script x.py calls script y.py and both scripts use "env python" as shebang, and your default python is wrong one, then you cannot just do right_python x.py (y.py will still try to use the default python). You pretty much have to change the PATH. &gt;&gt; On most linux versions if you use "env python", you cannot pass any extra flags to python on shebang line &gt; This is... wrong. Well, you just have not run into this problem yet. Try this: #!/usr/bin/python -O assert 0, "assert fires by default, NOOP if -O" This is noop. and then this: #!/usr/bin/env python -O assert 0, "assert fires by default, NOOP if -O" I get "No such file or directory" on Ubuntu. That's not python's problem (more of linux's limitation) but it's a real issue with "env python" Overall, "env python" shebangs solve about as many problems as they create ;-(.
Sure but then if you want python2 and the default on my system is python3 I have to go into your script and manually change the #! (or execute with an explicit python2 scriptname or whatever). Asking for the correct version is the least annoying option from my point of view since I have python2 and 3 installed on my systems so a script which explicitly asks for the one it actually wants will just work^tm whereas one which claims it can cope with any random python but actually can't run under one of them is more annoying. Basically in my opinion the shabang should match the semantics of what you actually want. If your script will run correctly under two *or* three then any random "python" will do (until a hypothetical python4 comes along with breaking changes). If you need a specific one then ask for it.
IPv6. If you create an `http.server` or `SimpleHTTPServer`, it's IPv4-only by default. There is no built-in library for splitting/joining host:port strings, and dual-stack sockets require you to manipulate `::ffff:0.0.0.0/96` addresses manually. `gethostbyname` is IPv4-only, and `getaddrinfo` requires 5 arguments with post-processing just to resolve a simple hostname. `socket.create_connection` is pretty decent, though.
Cython adds a special construct for specifying when you want to drop the GIL, and IIRC it'll error out if it can't drop it. It's basically a specialized context manager, which makes it really explicit where in the code the GIL is dropped.
I'm almost entirely convinced that PEX is a hoax application. I have not once successfully gotten it to work.
exactly so. "with gil:" and "with nogil:" (as well as ways to drop it for an entire function body).
No. PyPy is written in [RPython](https://en.wikipedia.org/wiki/PyPy#RPython), a restricted subset of Python which is compiled to C and then compiled to machine code. This is what makes interoperability with some python libraries difficult--they use the CPython C API, which is not fully supported by PyPy. PyPy instead uses a a library called CFFI to interface with C libraries.
Try Qt
Yeah, even PHP has [array_chunk](http://php.net/manual/en/function.array-chunk.php). Why something like this didn't even make it into itertools is beyond me.
Ahh okay. Thabks for the clarification. But if PyPy is written in Python, wouldn't it still at least run if run with a different runtime? Or is it strongly binded to RPython?
We use whatever tool suits the job. If we feel we can support a newer technology and gain a competitive advantage then we'll pursue it.
Today I realized how stupid bash script is, so I rewrote a script I was trying to fix up in Python. In order to iterate through a list of files and call a command on it, you have to import os, shutil, and subprocess. Getting a list of files is an os function, moving files is a shutil function, and calling a specific command is a subprocess function since the equivalent in shutil is now deprecated. This kind of pissed me off, it should all be shutil. I've also always found myself baffled by decorators. They never seem to actually work the way you expect them to. And double-nested list comprehensions have a strange syntax that isn't particularly readable or elegant. Also, lambda expressions are meant to be for quick anonymous functions, but actually doing so is too verbose and you can't partially apply functions. Basically, Python's functional capabilities are really poorly implemented because of Guido's distaste for functional programming.
Correct. It will run under CPython. 
That's the way it should be. Had to fix a Mendeley installation only last week by altering a broken `#!/usr/bin/python` line to `#!/usr/bin/env python`.
Ah okay. But I imagine you lose quite a bit of the performance gains. Thanks. 
I've used PyQt4 and it was great but you have to be aware of [the license restrictions](https://www.reddit.com/r/Python/comments/34qau7/why_is_pyqt_even_a_thing_anymore_when_pyside_is/). PySide might be a suitable option commercially unless you're going to open source it.
Coming from Ruby and Rspec, testing is not necessarily harder than it needs to be, just more verbose and less elegant. Though, the Sure library helps. 
Seriously. I'm using Python to write a gtk+ program and its great, but trying to package it is a huge pain
Fair point. What about GTK?
I never tried it myself but isn't it relatively painless to add a simple GUI using one of the Qt libraries?
Yeah, I've done that several times (started writing my own logging package). It's amazing how inflexible it is and how much boilerplate it requires.
I think slowly we're going to get there, ala https://github.com/dropbox/pyston
Python 3.5 is 8 months old. I'll grant 8 months isn't ancient, but python is one of the most scrupulously maintained and widely used programs on the planet. After 8 months you can count on any bugs you run into being in truly obscure edge cases. It hardly qualifies as a 'mostly untested' technology. It's just anecdotal, but personally I've run into a couple cases where 3.4 was doing something problematic that was fixed in 3.5, and exactly zero cases where something was broken in 3.5 that worked in 3.4. I still mostly use python 3.4, because my production machines are running Debian Jessie, but if a new Debian stable releases came out now I think it would have 3.5, and I'd use it without hesitation.
What's wrong with matplotlib, seaborn and pandas? We definitely need better stats functions though. Scipy doesn't even do two-way ANOVA.
Seriously wondering, is there any reason you would want multiline lambdas over semi-anonymous functions, or functions that take all of their parameters explicitly? Semi-anonymous: &gt;&gt;&gt; def factory(power): ... def fn(number): ... return number ** power ... return fn ... &gt;&gt;&gt; x = factory(3) &gt;&gt;&gt; y = factory(4) &gt;&gt;&gt; x &lt;function fn at 0x105332140&gt; &gt;&gt;&gt; y &lt;function fn at 0x105332758&gt; &gt;&gt;&gt; x(2) 8 &gt;&gt;&gt; y(2) 16 Explicit: &gt;&gt;&gt; def power(number, power): ... return number ** power ... &gt;&gt;&gt; power(number=2, power=3) 8 &gt;&gt;&gt; power(number=2, power=4) 16 This is a simple example where a normal lambda is probably better, but if you had something more complicated, I actually think semi-anonymous functions are more readable. Though, I also try and avoid having one-liners just to have them (aka things like triply-nested list comprehensions). Might just be a C background thing.
Arch does and probably some other linux distros and some bsds. Unless you want to target those platforms you could probably get away with relying on python being python2 but being explicit only requires you to type one extra character so it just seems like a no brainer to me.
Can you use `basestring` instead of `string` and have it work on Python 2 and 3? (Not tried this myself.)
&gt; Arguably the changes were important overall, yeah? The only changes I've noticed are shuffling and renaming shit, which is useless IMO.
The fact that new variables become instances of the old one. It's non-configurable, non-intuitive and I hate working around that.
I haven't, but it works perfectly on Linux.
Itering over strings is not common, but of course it might happen. I alaso think that iterating over strings creates many more problems than it solves and should be disallowed, but some special operation could make it allowable in special circumstances, e.g. by using 'iter(mystring)'.
http://www.reddit.com/r/python/comments/4if7wj/what_do_you_think_is_more_difficult_in_python_than_it_should_be/d2xp97n
https://github.com/search?l=python&amp;q=%22for+ch+in+%22&amp;ref=searchresults&amp;type=Code&amp;utf8=%E2%9C%93 And that's only the ones that use `ch` as the variable name.
Thank you for your reply. Here's what I just did: 1. Run the script. "Fails" at 300 requests, as usual. I stop the code from running. 2. Rerun the script right away with the first 300 requests: runs just like before, with no problem. 3. Test only the last 400 requests (as you said, they might be misformed): no problem either. I noticed that for every set of 20-30 urls, I get theses responses (for all urls in the set) in this cycle: 200 200 200 (working...) 404 404 (problems...) 200 (working again!) 404 (nope...) 404 404 200 200 404 404 None 404 None 404 None 200 404 None Also, this time instead of sleeping for 90 seconds I slept for 10 secs. It looks like it helped me get more responses (instead of a maximum of 8 sets of urls with response codes 200 before, I got 14 sets of urls with response codes 200). I'm not sure if that means anything. One last thing: this guy seemed to have the same problem I have, but I don't understand the answer: http://stackoverflow.com/questions/29009839/python-requests-requests-get-returns-404-on-valid-url
&gt;Edit: Would this support memoization? That's my favorite part of recursion. Well it's not an apples for apples translation, just i often find i solve the same issue with them. Memoisation probably is not something you'll get for free, but check out the lru_cache decorator in functools(?). 
Pypy seems decent enough....
I'm not sure what you mean by keeping consistency with dictionaries, but it wouldn't make sense if the + operator took either a list or an object, because sometimes you want nested lists, so in the general case of appending an arbitrary object to a list, it would be useless. Also, why are you using append? I don't actually use it all that often. If you are using it to build a list, why not just use a generator function?
Writing decorators. The protocol is just awkward.
The former. Define it as that and be done.
&gt; why not just use a generator function? I find building from within loops to be more intuitive and readable. I know it isn't Pythonic though. Also I don't even know what one is.
Its owned by the Qt Company a subsidiary of Digia for the last 2 years, for the 2 years before that it was owned directly by Digia. Before that Nokia. 
Fedora defaults to 3 now. 
I've become a big fan of Fabric3
You *could* use os.rename and os.system, if you're allergic to imports - but the safer and more powerful functions are usually worth it. 
Its like a type system is helpful...
The syntax for list comprehensions is backwards. names = ['alice', 'bob', 'charlie', 'david'] To get each name out, that's fair enough (although I never particularly cared for the syntax). names_ = [n for n in names] We get an n for every n that is in names. But what happens when we want letters? [letter for word in name for letter in word] So we get a letter for every word in names for every letter in word... what? We're getting a letter for every letter in the word for every word in our list of names. It's also not particularly readable in my opinion. Syntax highlighting helps, but I like Haskell's approach better: [ letter | letter in word, word in name ] And the actual order doesn't matter because Haskell is lazy. The other thing I like about Haskell is something that might look like this in Python (keep in mind it's a toy example): list(map(lambda x: x + 1, mylist))) I'd really like to do instead: list . map(+1, mylist) But, you know, I still really like Python. No programming language is ever going to do everything I want it to in the way I want it to.
You can do the first with lambdas, no? &gt;&gt;&gt; (lambda num, power : lambda : num ** power)(2,3)() 8
Hey, for once we can take comfort in the fact that no one uses Python 3.
&gt; Iterating over strings is not something I do often. FTFY
No; `[1] + [2] == [1, 2]` while `[1] + [[2]] == [1, [2]]`.
Doesn't the python implementation of GTK use gnome's GIR?
No simple inbuilt library for maths with vectors/matrices. 
Numpy ufuncs release the gil, and then cython or numba.vectorize allow you to write what are essentially ufuncs that are much more powerful.
They are easy to use, but when do you use threading and when do you use multiprocessing? Other languages usually have a go-to standard way to approach concurrency - goroutines in Go, threads in Java, actors in Erlang, etc. But thanks to the GIL, Python users need to constantly decide between using threads or processes. And now with 3.5 and language-level async, it confuses things slightly more. 
I'm the same, coming from PHP I love me some curly braces. They just feel right. That said, I have gotten used to Python's indentation and feel at home reading Python code now just like I do in other languages. It takes a little while, but you will get used to it and even come to love it maybe since it does start to feel natural. 
 for ch in iter(string) Would be fine IMO. Really though, optional static typing would be the best. *sigh*
How long did you look? I've seen multiple.
So many people have asked for it, they've added this: from __future__ import braces
&gt;The main libraries are either deprecated/abandoned, thin wrappers around C libraries (themselves often outdated), or both. Pyglet is neither, and what's wrong with c code? It's like 100x faster than python. Pymunk is awesome.
No. I experience memory leaks when I run my perf tests, and it's not worth the extra work to support a sixth (and very different) version of python. 
Newbie here. Could someone be so kind as to tell me what is going on?
Pyglet is more performant and actively maintained. You'd want some c lib for your heavy stuff like physics. 
The intent of the programmer still wouldn't be clear.
Anaconda is a distribution of scientific computing packages. Conda, can be used to install numba in a lighter weight environment (cleanest to start from miniconda). `conda create -n numba-env python=3 numba` would give you an environment with only numba and it's dependencies with Python 3. It's probably possible to install it without conda, but then you need all the build requirements. So, there is no inherent dependency on Anaconda proper. 
But... you can though, unless I'm misunderstanding something? Let's say you have `#!/usr/bin/env python` at the top of your script `my_script.py`, and let's say the first Python in your path is some 2.x. If you want, you can always call `python3 my_script.py` and it will be executed as Python 3 — not the first Python in your path. So if you want your Python script to call another Python script, you can specify the version there if you want. Or, possibly better, simply require a path to a Python executable as a positional argument and use that throughout. (It seems odd to me that you would execute a Python script from within another instead of just importing it and accessing its methods that way, but I assume you have your reasons.) As for the second point, I did misunderstand you. I thought you meant to call the script with command-line arguments from the shell — not in the shebang. I've never had a need for that and so am unfamiliar with it.
http://python-future.org/compatible_idioms.html#basestring
jobs using pyhon that aren't using django.
This way these libraries so aggressively try to do everything in local time drives me crazy. That you have to go through some non-intuitive hoops to get code to function the same way with regard to time in environments that have different timezones is frustrating.
&gt;Coming from those languages, you would look for the multithreading module, but that doesn't do what you want it to do. The multiprocessing works, but I need to split my code into chunks that I can feed into map(), which isn't always the case. Plus each process has its own address space, so things can end up taking a lot of memory. I'm hoping Julia or some other language with real concurrency can eventually replace Python. For now though, Python is the gold standard in scientific computing. 
First block creates a script. Second blocks zips it into a zip file. Third block is essentially adding a python 3 shebang to the zip file and renaming it to foo. Fourth block chmods to make it executable. Essentially if you run a zip file with python code through the interpreter it'll automatically unzip and run the code (has to be named: __main__.py if I'm not mistaken but I never use this) 
&gt; I wonder how inefficient it is. The EXE it produces is just a specially compiled CPython binary, so I can't imagine there's any performance differences.
&gt;They are easy to use, but when do you use threading and when do you use multiprocessing? Seems like a pretty noob problem. If you can't tell the difference between I/O and CPU, then I think it's fine that you'll have to learn that first. Someone who doesn't even know that is going to be multithreading non thread safe code in some other language. Multiprocessing requires an understanding of what's happening no matter what language. Python and the GIL make this easier for noobs, not harder. 
I agree with you on the letter in words example. I find it is more clear to use "chain" from the itertools package. Rather than `[letter for word in names for letter in word]` I would use `chain.from_iterable(names)` For your second point, I think using comprehensions rather than `map` usually makes more sense.
&gt; If you can't tell the difference between I/O and CPU, ... Nah, it's not that simple at all actually, unless you're talking about a trivial application. In normal scenarios, your program a mix of CPU- and I/O-bound activity, and that activity will likely vary based on user input or types of server requests for example. &gt; Python and the GIL make this easier for noobs, not harder. Again, no. The GIL is the main reason behind the whole threading/multiprocessing split, and it adds unnecessary overhead and makes it more complicated for newcomers to concurrency in Python. As far as I know, Java for example doesn't even have a concept of "multiprocessing", making threading a clear choice for all scenarios. This probably has to do with JVM warmup and overhead, but it's still a relevant point I think. Some bits from The Zen of Python: * Simple is better than complex. * If the implementation is hard to explain, it's a bad idea. * There should be one-- and preferably only one --obvious way to do it.
Huh? You shouldn't ever need to modify `sys.path` unless you've got some *very* odd setup (in which case I would suggest changing things to just use the existing configuration). What you're probably missing (I guess) is that you should be putting your modules into specific directories that are automatically searched and put into `sys.path` when Python runs.
I deliberately wrote it in past tense. Are you joking or did you just not understand? This was the early or mid 1990s.
Naive datetimes are the worst, too. Here I am chugging along doing everything in UTC like a good developer and suddenly an API hands me back 2016-05-08T19:28:00. What the hell am i suppose to do with that? Assume it's local time (hopefully it's not right before/after/during a timezone change), assume its UTC, just throw an error? And then there's the issue of server timezones. Just fuuuuuuuuuck. Everyone just use UTC if you need to communicate datetimes. Or if you can't be arsed, translate your datetime to a Unix timestamp (which is UTC). AND don't give me back more than 6 digits of millisecond precision, unless it's absolutely important. Hell, don't even give me seconds unless it's important. 
Look at pytest. The built in unittest library is a decent start, but looks more and more like a dumpster fire the more you use other testing libraries.
`itertools.chain` is generally my go to. If you need to flatten arbitrarily deep nested lists, then you'll want to invest in some code yourself. 
For 1), I'd say that's one of the major problems with Python. There's this obsession of doing everything "The Python Way", when in many cases, this just makes a given task harder to do compared to a more straightforward approach.
Parsing command line arguments. . . Christ, I hate how optparse and argparse work. . . It's funny, reading through this post, what strikes me is how much about Python really annoys the shit out of me, yet it's my favorite language. Boy. . . I could really rant like a maniac if this post were about Perl or C++. :) 
God dammit. I actually got all excited and typed it into the interpreter.
Oh jeez, another thing I hate: that docstrings are *inside* methods/functions. I want my documentation outside! It drives me nuts when the docstring is so long that the function def statement isn't even on the same page as the actual implementation.
&gt; [letter for word in name for letter in word] The reason for this is that it follows the normal nested for loop conventional order: for word in name: for letter in word: letter I do agree that this makes list comprehensions less intuitive than they could be. 
People down vote if they disagree. It's stupid but I've learned to stop taking it personally. 
Rust offers zero-overhead abstractions with increasingly better support for automatic parallelism. (Arguably the same is true for Scala, also due to strong/static typing, so the compiler/VM knows which parts can be run in paralell without threads stepping on each other's toes.)
* To view the disassembly of the code that will eventually be run. * To find the type of function arguments without digging deep in the source tree (given an old/large code base). * To create an executable without creating any extra files like setup.py. One terminal command should be enough.
I regularly use both php and Python and every time I have to take a few minutes to readjust to the nuances. Honestly it reminds me of BASIC in a lot of ways, the lack of braces and line terminators. 10 Print "Hello World!"
This looks pretty incredible!
Agreed, I'm constantly baffled by matplotlib/MATLAB's plotting code. Though then again, I'm am enthusiastic member of R's ggplot2 cult, so I could be a little biased here. 
Okay, yes, if you want to be pedantic about it you need to use the anaconda python stack, but not the entire anaconda python distribution. In principle it is possible to build it outside of that stack, but it's dependencies are tied to the versions in anaconda. In particular it only works with one version of LLVM at a time, and that version pretty much always lags behind upstream by a version or two. So it is usually either to old or too new for most other stacks with LLVM. And enthought has explicitly stated that they are not really concerned with making numba easy for anyone but them to distribute. 
Rust is not garbage collected though. This is a big one for me, I don't want to deal with memory management. It seems to me that Rust wants to replace C++, not Python.
Regex, exposing variables implicitly is very nice, I want it Dank metaprogramming shit, being able to mutate or extend the syntax properly requires writing a whole new parser, that is a bit silly And the non proper ways involve fucking around in python's memory or fucking around with encodings All a bit daft IMO 
To me it's certainly a convenience in the obvious higher-order functions (e.g., fold). If you feel like it's less intelligible, that's totally fair. I wouldn't consider it appropriate to litter code with anonymous functions for the sake of doing it, but when I'm really not going to care about the function ever again, why bother naming it? Language syntax also might weigh in here. If creating an anonymous function is as simple and clean as `\`, It reads more like logic than a bunch of tokens to be remembered. **ed**: this was substantially modified because I definitely misunderstood what you were asking the first time around.
.NETs DateTime class has spoiled me
At least PyPy has some support for Python 3. Pyston, AFAIK, has none.
Have you seen statsomodels: http://statsmodels.sourceforge.net/0.6.0/examples/notebooks/generated/interactions_anova.html 
Pyjion is pretty cool. They're trying to make it so you can plug any JIT you want into CPython.
Everything. Either that, or I'm too dumb for this :(
&gt; new variables become instances of the old one I'm not sure I understand - do you have an example?
The main issue is that there are so many ways to do it and many of them overlap so when you're trying to figure out you see some documentation that uses distutils, setuptools, distutils2 etc. IMO just stick with http://pythonhosted.org/setuptools/, it can automatically download dependencies from PyPI, you can generate egg, rpm, tarball, wheel (you need to install wheel first). It also has ./setup.py develop mode when it installs a package in such way that you can continue working on it. Edit: also recommended is to use virtualenv, that way you don't need to use root, and you only install what you need for your application.
There is http://pythonhosted.org/setuptools/.
Many of the changes were "shuffling and renaming", yes. Even Unicode, the main driver behind Python 3, is merely done differently between the two versions - it is arguable whether Python 3 does it any better. Python 3 is "let's break every program that uses `print`" without, as seen in this thread, fixing any of the real issues.
typings
Numba seems amazing with nopython=True and predefined signatures, but it needs at least mypy to make sure you don't mess up. (Or just too many tests in my opinion.)
You can put things into a Rc [reference coutner] (or Arc [atomic refcount]), though it's not as friendly as the JVM-based languages. So it forces the developer to think about memory management a bit. Since it's much simpler than C++, doing memory management with Rust feels okay, whereas in C++ it's a hit and miss emotional roller-coaster. Sure, it seems much closer to C/C++, than to Python, but the things people miss from python (besides sane DateTime), such as no-GIL, better numerical computation stuff all need the strictness of Rust (or the black magic of C++, or the bare-metalness of C). Or we're stuck with use-case based concurrency as in [PyParalell](http://pyparallel.org/).
Glad to hear it, in southern ohio any python demand has been django that i've found. webob based frameworks would have been right up my alley. Unfortunately the last few years my focus has been on ruby and javascript. 
Py 3.5 here as well (breadwallet)
Pandas has really good datetime support.
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, we are sure you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, we are sure you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, we are sure you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
What libraries do you use for analyzing time series data? I haven't found much that's good.
&gt;But in the shebang you can specify which major version, e.g. `#!/usr/bin/env python2` Yeah, that was all I was suggesting you do.
No need to get testy about it, just trying to help as the way you talk about it, you seem to get the wrong impression about what anaconda vs what conda is and what it does. For example, using "anaconda python stack" and Enthought. You do not need the "anaconda python stack", you just need the software dependencies for numba, just like with any python package. Your complaint is like being annoyed that pandas version A requires at least numpy version B. There are three main components in Anaconda. First is python, second is conda (a cross platform apt-get and environment manager), third is a bunch of packages. You don't need part 1 or 3, where all 3 parts equates to anaconda. You just need part 2, which can be installed via pip. Then doing `conda install numba` will install numba and both the binary and python dependencies. But you'd really want to start by creating an environment first. This isn't a "stack", it is a package and it's pre-built dependencies (if not already available). If llvm is behind what you expect, it shouldn't matter as it will be in an environment, separate from any other llvm being used. https://pypi.python.org/pypi/conda
That's fine if you want a Windows executable. I've used cx_Freeze and it works for me. But I'd like to make a wheel, and I have found the documentation to be sparse and opaque. It seems to have been written for someone who already knows all the details and just wants a brief refresher on the basics. 
yep!
Authenticating with kerberos with python 3 on Windows. I had to install visual c++ to pip install the package and when that was finished there were compiler errors.
Case statements
Not sure, but this should be posted on /r/learnpython, and you should paste the actual error, rather than a screenshot.
if the server you're hitting requires authentication credentials or keeps track of your session with cookies, it may appear to the server that you're making too many requests at one time. A 404 means the web page doesn't exist. If you are getting kicked out for authentication reasons(whether you need to be logged in or if they just blocked you for scraping too quickly) you would see a http response code of 401 unauthorized. You might want to try just looping through your requests with the request library on its own without gevent and log the urls that come back as non 200 response codes first. I'm not too familiar with gevent, but if you can get it working for each request in a single thread/process you can look in to parallelization or asynchronous calls afterwards. Though I havent used gevent before, some of those objects might be coming back as None because the asynchronous event hasn't finished so nothing has been returned. 
In the future, you should post learning questions like this to /r/learnpython
In the example, process_data_set is the @synchronized function, it's entire body happens in serial in the main thread except any calls to @concurrent functions like process_lat_lon. Those are the operations that get executed in parallel.
Can you run randint from the python prompt? That seems to be what it is complaining about. 
I love the slicing of strings too, but I wish that there was a __slice__ magic method or something. 
Don't do this. PEX is better.
And how, precisely, is a PEX file supposed to run on a machine that doesn't have Python installed?
Oh I agree the changes were important, and I think python 3 is definitely the better language. It was a pretty terrible transition and the fact that it's non trivial to work in both versions, combined with python 2's continuing popularity requiring development for both is a bit of a pain. 
The GIL is actually an *optimization* for the, at the time, most common use case for python: single-threaded programs. There have been attempts at removing it, but none of them have succeeded without imposing a massive performance penalty on single-threaded code. Comparing Java threading and Python threading is a very strange place to go. Java has a concept of a "constant pool", a segment of constant data that can be freely accessed across threads. Class definitions are the most common pieces of data loaded into this space. Unlike Python, classes are immutable in Java. You cannot redefine methods (not without great effort, anyway), so it's not necessary to place locks on this data. It's safe to assume that all threads can safely read from this space at any time. In python, I can change the behavior of a type any time I want. I can mutate objects in strange and unpredictable ways. In Python, a type *is* an object, and so it must be subject to the same access locking that all other mutable data must be subject to. As far as the "warmup" issues on the JVM are concerned, they have nothing to do with threading. The long startup time is largely due to loading the entire class library at startup (hopefully fixed in Java 9), and the warmup period is due to the HotSpot compiler prioritizing what methods to JIT compile first. I personally think that the threading module should be removed from Python entirely, and that *only* multiprocessing and asyncio be available. However, that would break a lot more code than the 2-to-3 process broke. Maybe the juice isn't worth the squeeze in that case...
The best quote I've read about matplotlib is that it "plots by side effect". Makes me so annoyed. And yet apparently it's powerful and we should all learn it. I've recently started playing around with [plotly](https://plot.ly/). It's interesting.
Looks like you need to upgrade your python install.
This has been in Python since 2.6, and I've never heard of Pez before. Is it new?
Don't forget that visual c++ redistributables and DirectX runtimes are commonplace. Why would you think that python is different?
Because Windows comes with those preinstalled?
String encoding. back and forth, unicode, utf8, latin1, ascii... it's all garbage and it's impossible to deal with them all.
I just tried it and you don't have to do every single escape. `\_\_main__` works fine.
Then it starts to depend on the absence of matching delimiters elsewhere in the text, and different parsers (eg mobile apps) can mess up in amusing ways.
 np.arange(20).reshape((4,5)) [list(range(i, i+5)) for i in range(0,20,5)]
Check out joblib. from math import sqrt from joblib import Parallel, delayed results = Parallel(n_jobs=2)(delayed(sqrt)(i ** 2) for i in range(10)) Also, this was posted yesterday: http://alex.vector57.net/deco/
Try [Click](http://click.pocoo.org/) or [DocOpt](https://pypi.python.org/pypi/docopt/). I personally prefer Click, but I don't think you can make it simpler than with DocOpt.
Man I'm gonna need a "what is Python good for?" thread after this.. 
"Double click them."
I don't know how openMP does that, for loops aren't necessarily multi-threadable. Maybe some magic to check to see if they access data in a way that would break multithreading? Regardless, you should look into map-reduce. You can use multiprocessing in map-reduce calls by calling "pool.map()".
No, because numpy and py3. 
1.5x speedup? That seems... not worth the developers' effort. 
I am firmly of the opinion that everyone should always be using the conda stack. 
&gt; To view the disassembly of the code that will eventually be run. Does `dis.dis()` help at all, or do you mean something else?
In general, I'd say the key is to stay flexible and be adaptive. So, it depends on what your needs are and what tools are available. I've used rpy2. I dig the idea. There are uses for it. I think the last time I used it was for a desktop app. That was a proper GUI app to help people with a very narrow set of tasks. Most of the time, if I'm going a straight up analysis project or prototyping, I keep everything in separate scripts. This is because the transition between languages usually is with a transition between tasks, steps, or something else. So for example, if you're quickly mining text data from Twitter for a basic analysis. We might pull the data with Python, parse and clean it. Then put the data into an sqlite3 db. Then R reads the cleaned data from that db, fits statistical models, and then finally plots everything. We could break this into three scripts: read-n-parse.py, fit-models.R, plot-models.R . This would be easy to debug. If you wanted to fit models with MATLAB or Python, you could easily slide in a new script to replace the fit-models.R script.
going into a Python sub and mentioning that you prefer tabs over spaces
My company just decided we're switching to Node to do JS development instead of Python because of this. I'm said because of the superior string manipulation of Python, but ^^^I ^^^still ^^^agree ^^^with ^^^them ^^^for ^^^this ^^^reason
&gt;amusing so you're saying i should do it then
Yes, and that is a bitch to configure. I just gave up and manually did everything with bash scripts. If you've never worked with Node you don't know what you're missing by having to do it this way. Install a third party library: `npm install $package --save` and it's automatically added to your program's dependencies, and the next person who gets your software just runs `npm init` and it downloads everything. No futzing around with some weird setuptools config thing.
Fewer packages, less frequent updates (for packages built together), poorer package manager, and a ton of duplicates of files I already have on my hard drive. For computers I can't control, or for operating systems without package managers, it is great. But on my own machine the only advantages it has are numba and mkl, and it has so many disadvantages it would be easier for me to maintain those two myself.
Came here to say this. 
Just learned about [Arrow](http://crsmithdev.com/arrow/) for more sane date/time handling.
I'm still learning Python and want to get into GUI.. is it even worth learning Tkinter or should I start somewhere else?
This has caused me so much grief.
Also when you are in a python3 virtualenv.
Dask is still really buggy right now. Would be ideal down the line since I use data frames so much and wojld be nice to spin off parallel workers.
I'm not understanding you. Will using "env python2" or "env python3" solve this problem?
Python should copy date parsing in Go. Just input a standard date in the format of input and it readily parses it out 
Another interesting one is Pexpect for certain use cases.
I like native widgets tho
Yeah, I'm in that awkward gap of having large datasets, but they aren't *large enough* to justify blowing money on some GPUs. Dask looks pretty promising! I haven't been able to get it to work faster than Numpy as yet but I guess that's just me.
But without any checking of it. You need a separate library or lint to check them.
Made by the pocoo guys! I've been having a huge argument with the standard logging module which doesn't seem to do what I want it to do, I should definitely look at logging!
Maybe if they'd organized it to go upward rather than downward [letter for letter in word for word in name] would be a *lot* more readable.
You know, I never realized this bothered me until right now. Maybe starting this thread wasn't such a great idea after all! Thinking about it - We could define a docfunc which lives outside the function definition, but contains the function definition within the triple quoted string. Like so - """ def myfunc(a, b): myfunc does my stuff. a is an argument, so is b. """ def myfunc(a, b): return (a-b)/(a+b)
Ah - depending on your workload, you may already be near optimal single-node parallelism on your single machine. That's when you can bust out the distributed scheduler, but with dask, you don't have to rewrite any of your core logic. https://matthewrocklin.com/blog/work/2016/02/26/dask-distributed-part-3
Gtk is only nice on Linux, but looks and feels really ugly on Windows and OS X.
Does Click work well with python3? Last time I tried it failed quite badly :(
I like [celery](http://www.celeryproject.org/).
To me, it removes clutter and let me focus on the code. If you have hard time following the flow, brackets won't help, it could likely be the code is poor. I've been using Python for a long time and the lack of brackets has forced me into making my code readable to humans, not to the machine (compiler, IDE...).
asyncio is quite great to use (actually, async/awat now makes it fun to use). But Guido is so bad at writing good documentation. It's just a massive blob that you keep scrolling up and down. 
Java's standard library for dates and times has been completely redone for the most recent release. Try to keep up, Python ;-)
Okay, maybe `append` was a bad example. How about b = a.insert(4, 1) # b == (1, 4, 2, 3) And while constant time optimizations may indeed be better left for core devs, I believe that asymptotical complexity optimizations are everyone's responsibility. Currently `a + (4,)` will recreate the whole tuple, thus resulting in O(N), while some advanced implementation may be able to bring it down to O(1).
Is it Async? I would prefer something based on current async built-in module.
No, I'm thinking the lists of CPU instructions that will be executed when that bytecode is being interpreted.
FreeBSD has it disabled by default for security reasons. OpenBSD too IIRC. See this handy Stackoverflow: http://security.stackexchange.com/questions/92081/is-receiving-ipv4-connections-on-af-inet6-sockets-insecure
Although your example is very helpful, this is the exact problem for newcomers. There are hundreds of "ah, but that's just how it is".
Is GIR still as bad as it was? I remember using it a few years ago and it was so badly documented, you'd have to figure out how certain C or Vala API's were exposed through the GIR. That wasn't a pleasant experience at all.
You're on terra incognita here :) I have the same problem and I'm testing a few solutions: * redis - I hate redis, but for very simple work single central node running redis as a storage for confirming whether the task completed or not is ok - you can also store lists, dicts or anything there really, including data structure ops like pop from list of remove from dict (hash), having pubsub can also be helpful for live monitoring of progress * rabbitmq - you can store put JSON into rabbitmq - it doesn't support typical datastructure ops like popping from list or smth like that - but if you use persisted messages there's very little data loss possible Those are the systems I use for storing data and metadata about the work to be done. For actually doing it I recommend running a pure Python script under the auspices of supervisord.
The defacto standard for game development is to avoid Python. For faster games the GIL makes it a non-starter. For simpler games Pyglet or PyGame might be sufficient, though they're both antiquated in my opinion. Also, distributing Python apps is too awkward, especially now that people typically want to target web and mobile platforms.
I don't know any other language that is bad at all of the above things and yet still so popular. I think it says a lot about the productivity level of the language that we put up with these problems.
Yeah, it's kinda bullshit. There should be some kind of standalone executable support in the standard library, or at least some kind of one-step solution (Nuitka is getting there...) Of course I also think there should be a graphics library included too so maybe I'm just full of crap.
Well.. They renamed it to "range" and removed the range function. 
I second this. It's now Python 2/3 dual compatible as well.
In-house groupware, tweaked mercurial server and django-based IS. Also successfully put an e-commerce application through comprehensive testing but still eager to put in production, due to possible breakage after security updates of related dependency packages.
Your boss is odd. File extensions are meant to make things easily identifiable. Don't see why he correlates this with a Windows thing.
Yeah, I tried it but there was a bug that broke it in jupyter so I wasn't able to get any results from it. Have you had success with it? 
PAR files are great
kivy
I was in a similar boat about a month ago. The problem was finding something that very clearly explains how to construct and utilise a decorator. After a lot of searching I came across the below link which helped me understand. http://thecodeship.com/patterns/guide-to-python-function-decorators/
Do you mean PyPI? I wrote [a quick example](https://github.com/msikma/pytpl) of a `setup.py` driven CLI script with instructions on how to send it to PyPI, in case anyone is interested. (If you're talking about executable files then that's never come up for me, so I don't know.)
Logging. 
I see, thanks. I struggled with this too when I first started using Python, but it all becomes clear when you realize that names *always* represent references to values, not values themselves. `a` and `b` in your example are two names for the same list. Related to this, however, is the following. I consider this to be a real design flaw in the language: a = [1, 2] b = a a = a + [3] print(a + b) # [1, 2, 3, 1, 2] vs a = [1, 2] b = a a += [3] print(a + b) # [1, 2, 3, 1, 2, 3] It is completely unintuitive for `x = x + y` and `x += y` to have different behaviour.
Well, I know no language that actually get half of those right except JS, which is hence quite popular despite the fact is so ugly
I really wish python had switch case. Endless `if-elif-elif-elif`s are sort of ugly IMO.
Looks versatile, but the documentation is pretty esoteric where it exists, and it doesn't always exist. https://kivy.org/docs/guide/advancedgraphics.html Not particularly compelling for game developers.
Raymond Hettinger (core Python developer) has [said](https://mail.python.org/pipermail/python-dev/2006-February/060793.html) that "freezing dicts is a can of worms and not especially useful". I'm not sure I agree - I would be interested to know what use you have for a `frozendict`? In the same message, Hettinger also says the idea that "tuples can serve as frozenlists" "has to be shot down".
No (see other answers). However, there are other Python JIT/optimisation efforts which DO use CPython such as Pyjion and FATPython and Pyston https://github.com/Microsoft/Pyjion http://faster-cpython.readthedocs.io/fat_python.html#fat-python https://github.com/dropbox/pyston We seem to be moving in a direction where JIT optimizer hooks will be added to CPython. However this is unlikely to work with PyPy since they take a completely different approach.
Not at all. Why would you reinvent a GUI framework just so that it is written in your target language? Tk comes with python, but is itself not written in python. Tkinter is a python wrapper for Tk, just like PySide/PyQt are python wrappers for Qt. The former just happens to come with a default CPython installation, while the latter ones don't. You'll need some REALLY good reasons to roll your own GUI framework. The need for a GUI framework alone doesn't qualify. I'm not sure why there is the kivy project, which IS written in Python / Cython, but i'm sure they had a damn good reason to spend their time on kivy instead of using Qt (might be target platforms, multi-touch support, licensing, ...). And kivy is probably too young to be the most popular python GUI framework, and, judging from the gallery, doesn't support native(-looking) widgets. So while it is an interesting project, i'll stick with PyQt.
You can generate it locally via `plotly.offline`.
it has some issues though, in that it's not so nice to work with, not all of the widgets even work all the way, and its crossplatform-ness can actually be somewhat limiting in some cases (it doesn't let you have more than one window per process, at least as of the last time I used it)
This is one area where static AOT type checking really shines. Though we do have mypy for that. 
I think Go gets half of them right - "packaging and distribution", "concurrency" and, AFAIK, "async web dev". Getting those right means that, just as with JavaScript, people are leaving Python for Go even though Python is a nicer language.
I believe that's only for a few different types of graphs
It tried to copy Matlab, which was a really bad move. Unfortunately though all the other libraries seem to be focused on stats, so physical science is kind of stuck with it. 
Not really. Ubuntu 16.04: $ python --version Python 2.7.11+ 
I use (Celery + Flower) &amp; Rabbit MQ, processing 100 Gb / day with heavy computations (GPU mainly). A good solution is also Kafka, but I don't know how it can operate with Celery yet. 
it's one thing to not require having file extensions in general otherwise stuff will be badly broken. It's another thing to eschew file extensions entirely on the basis that you "hate windows". I strongly dislike whenever I have to use windows, but...... is your boss on LSD?
Nope - I do mostly scientific work and PyPy is basically useless for scientific work because of the limited C-extension support, which basically nukes all the scientific software stack from numpy upwards (i.e. scipy, pandas, hdf5, scikit-learn, cython...) PyPy also doesn't offer any speed advantages for numeric code anyway because numpy-based arrays are much faster. Oh yeah, and crappy Python3 support. There's just too many things I depend on in Python3 now to forgo that (my latest love is unpacking generalizations in 3.5 https://www.python.org/dev/peps/pep-0448/)
It's not weird at all, one of the main strengths of python is binding well to other languages suited better to other tasks. Python's concurrency problems (GIL on most implementations) and general slowness mean that implementing GUI toolkits at a low level would be pretty bad. It's a similar question to "isn't it funny that web browsers aren't written in JS" ..... https://github.com/breach/breach_core ... oh jesus, spoke too soon
Well, Tk is in the standard library, and it was written in Tcl, so I guess it's not that weird?
I find it's much better at handling underlying /installed libraries (matplotlib just doesn't work in a virtualenv). Pip still works in a conda env so that's not an issue. Installation is much quicker for the big packages. 
On the flipside writing GPU code is surprisingly simple. Pycuda is an amazing library. 
Great work! That highlights the new possibility of this toolchain, this is just awesome :)
Wrong comment?
There needn't be any effort as PyPy may work as a straight replacement. [Compatibility list](https://bitbucket.org/pypy/compatibility/wiki/Home)
People are moving to JS because it's the only language on the brower. Remove that, and JS dies in a month. Nobody would code in JS otherwise. As for Go, yes and no. There is a hype factor, and I've seen people leaving and going back. Plus, Go certainly hasn't async web dev right, because it doesn't even have web dev right. And the reason is it's not handy for the task of manipulating data. It's nice to manipulate streams, but if you have to manipulate strings, arrays or number, it's not handy at all. Hence, go is great for writting web __server__ but not web __sites__. 
That's because it's a direct port of a ... java library.
Geoalchemy seems to be based on SQLAlchemy, which is just another ORM for python. You can use SQLAlchemy with python as well, of course its easier with Flask. That being said, the biggest difference you'll probably have is the URL routing. Django has a very powerful and complex URL routing system, where Flask has a very simple "This URL for this function" system. Personally, if I'm making a REST API with a few URLs, Flask is my go to. If I'm making a much more complicated site than I tend to look to Django first.
Whatever wingdb.py is doesn't look like it supports Python 2.7.11. 
Compared to manual install, but not compared to Linux distribution-supplied packages. It takes me much longer to install packages from anaconda than through my distribution. Heck, just the dependency check using conda typically takes longer than the entire install for my distro. If you need to manually install low-level packages in a virtualenv then I can imagine it being extremely useful, but I only use virtualenvs for niche packages that conda doesn't have, for my own personal packages, and for development on upstream which requires me to manually install git. It sounds like it fits your use-case extremely well. Then use it. I use it to when it helps. But please understand that just because it fits your use-case doesn't mean it always fits everyone's use-case.
Thank you!
I'm actually a fan of using syntax to denote things :( Oh well.
You can use a decorator to do this... def docit(docstring): def decorator(func): func.__doc__ = docstring return func return decorator @docit("""\ Returns a foo """) def foo(): return 'foo' 
I like that better. It's funny, I also commented here that your post got me ranting a bit, I love Python but reading through the other comments here, I realized how much about the language really annoys the crap out of me. :)
I'm a Flask user but have a bit of knowledge on Django. cdrf.co seems to be a great resources, thank you. I'm pretty sure I'll be happy with either Django or Flask overall. My concern is really about the PostGIS/Geospatial data. Have you had experience specifically with this on Django?
&gt; Jinja2 I've been working using a micro service architecture for my web projects so that i could easily scale and maintain, also makes code cleaner. I've always used expressjs to url handle transactions and rabbitmq to handle message passing I see that flask natively handles urls transactions is there a perferred message passer. 
Apache would be a hell of a lot nicer for the standard lib
I love that this has more upvotes than the OP's post. It really needs to become a focus point for future development if the core team want Python to grow as a language. Doing wonderful things for yourself is great, but I feel like most code is written for others to use. Python severely gimps itself in that regard.
You forgot the part where it's full of bugs
Type hint in python 2. Anyone can shed some light on how to do this?
We should probably just delete that page, we've been intending to populate it for ages! But you don't need the 'advanced graphics' stuff that it would contain to make games with Kivy, it's intended to contain instead some extra details of Kivy's OpenGL abstraction. [Kivent](http://kivent.org/) is becoming a serious option for game development using Kivy, if anyone is interested.
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, we are sure you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, we are sure you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, we are sure you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, we are sure you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
If you're not using any part of Fabric's SSH capabilities, you can switch over to [Invoke](https://pypi.python.org/pypi/invoke/0.12.2), which is its Python 3 successor.
I couldn't find anything in your documentation that _looked_ practical for game development - perhaps because it's worded in terms of Widgets and UI instead of sprites and images. That alone is going to turn most game developers off (though that's not necessarily your problem). Kivent looks capable, but again, quite esoteric. And it's not going to get traction if the developer needs to understand Kivent and Kivy on top of Python. Game developers really need one solid and well-documented library with few dependencies, and they need it to work in terms of the concepts they're already familiar with.
IMO Python should integrate Pandas into its core distributions. Off the shelf, Python just can't challenge R for data manipulation and visualisation, but incorporating Pandas would change that.
I was not aware of it, but the code that controls click generally is short, do fixing incompatibilities would probably take at most 15 minutes. I wonder what was the reason he said it was broken. It seem to work fine, my only concern was that Unicode was in my opinion not handled correctly in python 2 (IMO it is hard to get it right in 2), but last time I talked to him, I don't think he agreed.
Because you should install Python with a package manager.
I must have. Can you refresh my memory on what bugs you are talking about?
They install python3 by default, but it still uses the `python3` executable recommended by upstream.
Python doesn't use semantic versioning. Python 4 will not be backwards-incompatible.
&gt; No, it's a different language. The changes are all pretty minor. Yes, there are changes, but is far, far, far from "a different language". It wouldn't be so easy to write code that works in both if it was really "a different language".
Conda is brilliant. The best part being that it bundles non-Python things too, like external C libraries.
Seaborn and holoviews are both great for this.
The animated gif in the README transitions between commands wayyy too fast: https://camo.githubusercontent.com/0a06f9f3172a0b4472d4ef8600716c815acd8255/687474703a2f2f692e696d6775722e636f6d2f504d51506678762e676966 Slow it down to people can read and get an idea of what's going on. But this looks super cool!
Not mature? By what measure? It is 8 years old. It also provides some nice features R lacks, such as multi-indexes.
This is the real error: PermissionError: [WinError 5] Access is denied: 'c:\program files (x86)\python35-32\Lib\site-packages\werkzeug' Run your pip command with Administrator privileges and you should be fine.
I wholly disagree, at least in Python 3. In Python 3 I only have to ever deal with text (Unicode, `str`), or bytes (UTF-8, `bytes`).
Exactly. That is pretty complicated compared to more array-oriented or matrix-oriented languages.
&gt; No simple **inbuilt** library (emphasis added) The problem for me isn't so much whether it is inbuilt or not, but rather that it is verbose to make an array. `np.array([[1, 2, 3], [4, 5, 6]])`, for example. Of course, creating dedicated syntax for something without it being built-in is not trivial in Python.
The post being responded to was about documentation, not checking.
on version 2, range returns a list and xrange returns an iterator. on version 3, range returns an iterator and xrange was deleted. they did the change for aesthetic reasons, breaking peoples code,.this is not cool.
Using apt for python packages is also pretty bad practice - makes it much more difficult to replicate, control versions, tear down if necessary, and can conflict with pip installs. I concede the use-case point, though. I am in academia (and obviously am surrounded by academics) and so my use case is that I have a dozen or so different environments, each one with slightly different requirements, almost all of which use numpy/scipy/ipython/matplotlib, and some of which need to be torn down and rebuilt pretty regularly if I install an iffy research package which messes with too much other stuff. My main point was that I haven't found any compelling reason to use virtualenvs over conda environments. Conda environments at absolute worst perform the same as venvs (you can still use pip, and the `environment.yml` conda produces defines where it got each package in the environment), and also have a load of nice stuff available on top. And I would absolutely recommend using some sort of virtual environment on any machine where development is taking place, and on any machine using python to do more than one thing.
`np.newaxis` is just an alias for `None`. So anywhere you use `np.newaxis`, you can use `None` and it will work identically.
What is hard about `zip(sorted(zip(list1, list2)))`
&gt; so easy to write code that works in both http://ondrejcertik.blogspot.it/2013/08/how-to-support-both-python-2-and-3.html https://wiki.python.org/moin/PortingToPy3k/BilingualQuickRef - so yeah, different languages with ridiculous third-party efforts to unfuck the core developers' mess. Oh, and the weird subset that works with both Python 2 and Python 3? Might as well consider it a third language. And all that wasted effort and time for what? Might as well bite the bullet and transition to a compiled language, while you're at it. At least you'll have some performance gains to show in the end. 
I think making numerical arrays (i.e. numpy arrays) is harder than I would like. I understand that numpy will never be part of the standard library, and I understand why, but I still can't help but wish there was some built-in syntax for making numerical arrays. Similarly, I wish there was a built-in way to make float ranges, and a simpler syntax for creating normal ranges. I have seen so me good proposals, but Guido is against the idea. I wish there was a simpler syntax for anonymous functions. I doing like having to spell out "lambda" each time I make an anonymous function. It makes it hard to integrate lambdas into function calls while still keeping the line from getting too long. The `itertools` recipes are not part of `itertools`, and as far as I can tell the have the PSF license which makes them kind of hard to integrate into other projects. I also wish there was a simpler way to quickly consume iterables, throwing away the results. Many of the standard libraries are not as good as third-party versions (logging, unit testing, date and time, etc). I think dealing with tranposing in numpy is more complicated than it needs to be. I don't want `.T` to automatically coerce to 2D, but some other method to quickly and simply coerce to 2D or do a 2D tranpose would make a lot of tasks much easier. Also, I wish numpy used orthogonal indexing instead of "fancy" indexing. I would say matplotlib, but it is getting a style and API overhaul in the coming months so I will wait to see what that brings about.
No, `xrange` in version 2 returns a range object. `range` in version 3 returns a `range` object. They can do a lot of the things lists can do (slicing, indexing, re-use). They are read-only and you can't combine them with `+`, but otherwise you can use them for a lot of the same things you use lists for (and they will be considerably faster for many of those tasks). And it wasn't for aesthetic reasons, it is because using such an object is almost always what people want, and having two functions that serve similar purposes in completely different ways, with the default being the less useful one, is confusing. Much easier to have one function that does one thing, and let you call `list(range())` when you need to.
that maybe true, but being backwards compatible is more important. I dont mind to remember that range returns a list and xrange returns a a range object. it is much more difficult to convert old code bases. for this reasons, companies as big as bank of america and bloomberg, where I used to work, wont use python 3 no matter what. and its a shame because python 3 can make life easier, I guess, I never bothered to check because the backwards compatibility is a just to much of a big deal for me (and others)
So "a little extreme in his views at times" == "nazi"? 
Yes, except for `decimal` all of python's numerical types are finite. And all IEEE-conforming float implementations are also finite, yes.
How the heck is your version of the site missing this nice blue bar with a Downloads link on it? https://i.imgur.com/zy00R6s.png If you think there is some glitch going on with the website code, you can file an issue reporting it [here](https://github.com/python/pythondotorg/issues)
Sorry, I was on mobile and couldn't determine how to express my major gripes with that approach. Consider the case where not all of the keys are unique - then this approach attempts to sort the tuples by their second element. But what if we desire either a stable sort (meaning we should preserve the order of the second elements in the case of a tie with the first), or we have types where an ordering and equality are not well defined. For example, this code: class StringHolder: def __init__(self, s): self.s = s def __repr__(self): return self.s a = [5, 4, 3, 2, 1, 1] b = [StringHolder("A"), StringHolder("B"), \ StringHolder("C"), StringHolder("D"), \ StringHolder("E"), StringHolder("F")] # Replace with correct parallel sort print(zip(sorted(zip(a,b)))) would ideally return something akin to [(1, E), (1, F), (2, D), (3, C), (4, B), (5, A)] but it does not, and in fact crashes when using the code you gave. I think something like sorted(a, along_with=b) would be significantly more readable, and could be made to have the behavior I specified above (which is, IMHO, correct).
like his SAWS project for AWS, it's command line auto-complete tool for git with integration with GitHub. It's an alternative to a GUI like sourcetree. If you use git CLI now, this will augment that experience with handy auto-complete/suggestion pop up. 
Well, the SSH libraries are so inconvenient that most people just use subprocess.call, as far as I've seen.
I use MPI with mpi4py.
TBH writing 5 lines or so is not really that hard. And that info is mostly program name, description and requirements. I indeed never worked with node, but if it is similar to golang, then it might be easy for developer to bootstrap working environment, but it is a nightmare if you for example want build packages out of it that builds the application it is a nightmare when there ate dependencies, especially tracking which versions you should compile with.
Google Chrome. Windows.
Okay, fair enough. 
Is there a way to have `sorted()` output the permutation required to sort the list? I think you could `zip()` the original input with `range(n)` and then use your approach, and then extract second element. I'm not sure if there is a better way. That would allow you to "replay" the permutation on as many lists as you want.
I suppose if you had a privacy gate to get in to your house you could use this to auto open the gate when pre determined plates show up. Like yours, friends, SO etc...
Your garage could automatically recognize your car's license plate and open the garage door for you. **DISCLAIMER:** This is very unsafe and only works as long as the bad guys don't notice that you use such a system. Your mileage may vary.
A link to a reddit post that contains two links to two further reddit posts? That's some inception shit right there 
So what? Game installers still bundle vc++ and directx. What's different about including a python installer? Or even just including the binary if you don't want to confuse users.
I would file an issue at the link I gave, with that image and exact description of your OS / browser
The downside is that you'll have to manually include all your dependencies (including shared libraries for all supported platforms) or it'll have zero portability.
Great. Might be an already reported issue from what I saw too. Thanks for your guidance.
Also since you're already using image recognition you could just as well check the color of the car, or even shape of the front.
Actually, Battlefield 2 and later use Python as their scripting language. More performance critical parts are C++ or C, naturally. And Eve Online's server software is largely written in Stackless Python.
I personally like wxPython for my desktop GUI applications
You can show the instructions as if it was run right now, up until the instruction that can not be determined. Python can often be compiled, ref Nuitka and Shedskin.
The main problem with using Kivy as a desktop GUI toolkit is that users expect their applications to look native to the OS in most cases. Using it for mobile is quite fine though
Even in python 3 it's far too easy to create circular imports, only solved by importing modules three times inside three different functions, which is all sorts of wrong and ugly.
I've had issues with pkg_resources and things of that nature when mixing easy_install and pip. These days one of the first things we tell users of Pyramid (open source project I am a member of) is to use one or the other but to never mix the two.
Using something as your scripting language is not really the same as writing your application in it. The games industry mostly shuns Python because it's a poor choice for embedding. The Python community has always stuck to their "extend, don't embed" mantra and that, combined with the GIL, a heavy standard library, and general neglect for subinterpreters, means Python is rarely used. Eve is one of the very rare Python-first games, but the hoops they've had to jump through to get reasonable performance have been considerable.
Hey, try posting learning questions like this on /r/learnpython instead of /r/python. It'll get a better response there because that's where devs go to help beginners. This subreddit is more for news and some discussion.
Then bake in just the core functionality of pandas and leave the rest as an extension.. As it is Python rolls out with no native support for tabular data with different data types (i.e. most datasets), which is nuts.
Same here, I wasn't going to keep a duplicate requirements-to-freeze.txt file around [1] so created this tool. [1] http://www.kennethreitz.org/essays/a-better-pip-workflow
Looks a lot better, but I think half as fast as it is now would be about right.
Oh crap, thanks for that. That was a typo on my part! I'll post there, too, thanks.
Elaborate?
incrementing variable, var += 1 is most retarded way to do it
Added to tutorial, thanks.
Yep, definitely fair. It all went wrong with how the transition was handled.
&gt; I do want to ensure they don't accidentally get run under the wrong Python, and I want to ease the transition by converting things slowly to work under Python 3. For your first point, you should just be able to set the following at the top of your files: #!/usr/bin/env python3 instead of #!/usr/bin/env python This won't prevent people from taking a Python 3 script and running it under 2 (you can still call `python myscript.py` with the wrong version), but this should hopefully alleviate people who execute scripts on *nix based platforms. As for transitions, the biggest two are `print` and unicode. If you're really worried about strings, just prefix all your Python 2.7 strings with 'u' (e.g. `u"Hello World!"`). If you're running Python 3.5, you shouldn't notice a difference as Python 3 strings are more or less the same as Python 2 unicode strings (prefixed with 'u'). For your last remark whether or not the two print statements are functionally different, the answer is yes. They both print a string to the file that is pointed to by `stderr`, however the primary difference is that one is a statement and one is an expression. `print()` is a function that can be evaluated as a sub-expression within another expression. `print` is a statement which must be evaluated independently on its own line in it's own context. In another thread that replied to this I tried to expand on it a little more, however in short the consistency provided by making `print()` an expression makes it much nicer to work with, as opposed to `print`, which stands out as a sore thumb in the language since unlike literally every other language feature it cannot be combined or modified. To further my example, consider that you had a set of properties that you wished to use to print multiple entries of some kind. Some of the keyword parameters you might want to pass to print are `file`, `sep`, and `end`. You might construct several items or lists of strings to print, and you always want to print with the same properties. You might do the following: delimiter = ', ' print_options = { 'sep': delimiter, 'end': delimiter + '\n', 'file': sys.stdout } entries = ["Column 1", "Column 2", "Column 3" ] print(*entries, **print_options) and now you've very easily printed a CSV file using print without too much struggle. Want to change from comma-delimited to tab-delimited? Just change delimiter to equal `'\t'` and run the exact same code and you're on your way. On Windows and want to end your lines with `\r\n` instead? Easy to fix. Now try replicating this using print as a statement and see not only how many more lines it takes, but how much harder it is to get the separator and end character right. This is the power you get for free by switching `print` to a function, and making it consistent with the rest of Python's standard features. So in conclusion, yes, those two lines of code do the same thing; however, they are functionally different in ways you've probably never given much thought to until now.
Other tools you could use for this task: Peewee ORM (for easily getting the data you collect into a db, probably sqlite) https://github.com/coleifer/peewee cron (for scheduling the task to run once per day or whatever) http://www.unixgeeks.org/security/newbie/unix/cron-1.html matplotlib (for graphing the data) https://pythonprogramming.net/matplotlib-intro-tutorial/
Is there any support for leaving a particular package alone? For instance, I have to support an app that needs MySQL-python==1.2.3 There are some slight incompatibilities between that and the current 1.2.5 version and updating the application code is not a priority at the moment. Edit: removed use of term "pinning" that was causing confusion.
That is true. On the other hand, it has Twisted and Tornado. So I think it's fair to say that PyPy is still well served.
Oh ok thank you :)
Some people use dicts. def numbers_to_strings(argument): switcher = { 0: "zero", 1: "one", 2: "two", } return switcher.get(argument, "nothing")
I meant the full error message... ;) If you're getting *just* a note, then that's probably a bug.
I find PyCharm handles this well.
I don't think that's possible, if you're writing exact version numbers (for reproducibility) and also [insist on keeping everything in the actual requirements.txt file](https://www.reddit.com/r/Python/comments/4ijqvo/update_your_requirementstxt_file_with_pur/d2ys52d) that pip uses. You can't have it both ways. There's no way for it to distinguish between "1.2.3 because I mean exactly 1.2.3" and "1.2.3 because that happens to be the latest version today". OTOH, if you are OK with putting your intent in a separate `requirements.in` file that says "foo" or "bar&gt;=1.0,&lt;2.0" or "baz==1.5.2", then [pip-tools](https://github.com/nvie/pip-tools) is what you want.
Sure, it's not possible with just a requirements.txt. I was imagining something exactly like pip-tools, actually. For some reason, I did not see /u/dpres reply above. I think I had this page loaded for a while without refreshing it.
Welp, I know what I'll be doing tonight. PS, I looked at the github repo of that Urban Planning course the other day. Seems interesting and useful.
I've only recently gotten a Mac, but I haven't tried it yet. However, I know several people who have used it successfully and it's an actively maintained project, so I'd give it another shot.
Train it with different data and bam you've got a Raspberry Pi that can read off a dash cam and recognize when the speed limit changes while you're driving and warn you if you're going to fast/slow. I'm actually adding this to my to-do list because I've been waiting to do this as a personal project for a while but lack the training in neural nets and image processing and lack the time to teach myself from scratch all that I'd need to know.
Better to set up a wireless repeater and have a system set up so when your phone logs onto your wifi, it messages your home automation system to open the garage door. Or when it's within some small radius of your house. Either one. The wifi one is more guaranteed to work. I'd use plate recognition for tracking but not for security.
So a forged license plate + you being asleep at your house = thieves can open your garage door.
Sorry for beating this dead horse again. But why use python 2 for teaching new python programmers? I think it will lead to unnecessary confusion and the need for them to deal with porting their stuff later.
I was only responding to &gt;Let's set up . . . speed cameras and ass-fuck our citizens with extorting fees I'm sorry for not being clear on that. You'll not see me defending red light cameras: studies show they increase accidents.
Are you familiar with Kivy? I wonder how it compares.
6\. You only have to learn how to do it once, because they never change (unlike string formatting, for example).
MATLAB doesn't have 1D matrices at all, so it isn't a good example. I am not sure how R handles it.
If relative imports are that complicated, you should probably be using absolute imports. (Personally I've never been in favor of relative imports.)
Thanks! That urban planning course is coming around again in August... so if you know any interested folks around the bay area you should let 'em know. We'll be refreshing and updating all those ipython notebook lessons then too.
Hey, it's never too late to sync it up and start scrobbling!
nice, I've been meaning to dig more into wasapi more, but havn't gotten around to it (due to the fact that it always seems unreasonably daunting sometimes) I'd personally recommend not having build artifacts in the repo at all, and instead have those only in the release section
Please re-submitt this question into r/learnpython subreddit. https://www.reddit.com/r/Python/comments/3kestk/post_learning_questions_to_rlearnpython/
My tendency for a long time has been to assume that programmers exceed a certain level of intelligence. What I am learning as I get more exposure is that this often not the case.
That comment... isn't *really* a switcheroo. And by *really* I mean *at all*.
That is one possible approach.
I'll throw it out there whenever I have the chance. I'm hoping to pull from it a bit when I need it. I've applied to the insight data science program, and would expect it to come in handy there.
Once again, BSD performs security by stupidity.
HPC is too vague in this context, do you have a single high powered machine, lots of little machines, a mix? What are you trying to do, cpu or io bound tasks?
I have had some issues with unit testing decorated functions. My solution has been to avoid the @ syntax, and test the decorator separately from an undecorated version of my function. Is there a standard recipe for unit testing which also makes use of the @ syntax?
It's not actually extra complexity, it's *less* complexity because print as a statement adds *more* special cases to the language; the print function follows all the existing rules of regular functions. I suspect the only reason `sep` and `end` were added is because they needed a way to do *at least* as much as the print statement did, and that was the simplest. I can understand that the print statement is better for your use cases, and there are many people who agree with you. The problem is that print as a statement is bad for the language as a whole, and the developers decided that saving typing was not a good enough reason to keep it.
as in the build/\*.dll's, *personally* I'd go with, new release of pyaudio / portaudio --&gt; make sure tests work with the fork --&gt; create a new release --&gt; upload built .dll files (or any other built files) to the release that way your repo only has code, and then there is no confusing questions like, if I wanted to fix a bug in your fork, do I also build a new release and include that in the pull request? do I expect you to do that yourself? what if I accidentally commit the build regardless, then I need to go back to the remote head, copypaste the dll, etc etc etc 
There are no difference ! http://pyos.github.io/dg/tutorial/ dogelang is a (little) Haskell that compiles to python3 bytecode. Love it.
But it's not like Windows makes it hard to change file association.
No performance problem, I haven't even actually used this in what might be considered a "production" setting yet. Making it run faster at this point is just for fun and to learn more about the language. I know what they say about premature optimization...but it's a personal project so I'm not wasting anyone's time but my own. I originally planned to use this on a Raspberry Pi so I began it with performance in mind since it would be running on very low end hardware. 
* You don't really need setters for those global variables * Most of `xAngle` looks like it's just trying to do `dtheta %= 2 * pi` * Looping with `range(len(something))` is usually bad - if you need the indexes, use `enumerate(something)` * Things in Python are typically named `like_this` and not `likeThis` I don't really know enough about multiprocessing to comment, but global variables are generally a bad idea.
* How would Rails deal with two different models, each connected to a different database? `declarative_base` means your model doesn't share its `MetaData` instance with other models. * You also need your own `Session` class so that your session events only apply to your own session. * For the table name, you can create a `declared_attr` for `__tablename__` if you want to infer it from the class name, but any built in way to do this would be opinionated, and I think too implicit. * I like the unit of work pattern, and don't see a problem with add/commit/close. I think a problem with a built in context manager is the implicit commit, but I agree it should be part of the library in some form. * I agree somewhat re: imports, I think declarative should be rolled into sqlalchemy.orm, but that orm should stay separate from core. It's important that people know the ORM is just an optional part of SQLAlchemy.
&gt; Boosting your career WTFF?
It's an actual HPC with over 300 nodes. I need to find a solution for threading thousands of mathematical calculations, transferring output, and reading in and interpreting input.
just a quick reality check: you do realize that basically anyone with some skill could defeat your analog lock right? Why is this no problem? because its illegal to do so and you have to be physically present to actually get something out of it. This is not the internet noone will forge a license plate to illegally use your parking space and if they do you just get the vehicle towed.
GS allowed scrobbling, FYI . . .
You have to implement the database layer with most of the frameworks you mentioned (not sure about django's, as it has an ORM). Some might have extensions that provide syntactic sugar but you might not even need that. The [RethinkDB Python API](https://www.rethinkdb.com/api/python/) is really all you need to communicate with the database. Taking a [rethinkdb example written for web.py](https://github.com/rethinkdb/rethinkdb-example-webpy-blog/blob/master/blog.py), we can rewite it for use with Falcon as a REST API (untested code example): import falcon import json import model import argparse class IndexResource: def on_get(self, req, resp): """Handles GET requests""" posts = model.get_posts() resp.body = json.dumps(posts) class ViewResource: def on_get(self, req, resp): """Handles GET requests""" post = model.get_post(post_id) resp.body = json.dumps(post) class NewResource: def on_post(self, req, resp): """Handles POST requests""" # validate and stuff status = model.new_post(req.params['title'], req.params['content']) resp.body = json.dumps(status) class DeleteResource: def on_post(self, req, resp): """Handles POST requests""" pass class EditResource: def on_put(self, req, resp): """Handles PUT requests""" pass if __name__ == "__main__": parser = argparse.ArgumentParser(description='Run the web.py blog app') parser.add_argument('--setup', dest='run_setup', action='store_true') args = parser.parse_args() if args.run_setup: model.dbSetup() else: api = falcon.API() api.add_route('/', IndexResource()) api.add_route('/view/(.+)', ViewResource()) api.add_route('/new', NewResource()) api.add_route('/delete/(.+)', DeleteResource()) api.add_route('/edit/(.+)', EditResource()) You also need this [model.py file](https://github.com/rethinkdb/rethinkdb-example-webpy-blog/blob/master/model.py) To setup the database, use: python blog.py --setup To run: python blog.py 
I'm working on the same issue but havn't found much concrete help yet. It's my understanding that to communicate across nodes (as opposed to across cores on a single node) you need to use some sort of communication protocol. A common one that is implemented in HPCs is MPI. Look into [mpi4py](http://pythonhosted.org/mpi4py/). [https://rcc.fsu.edu/docs/high-performance-computing-python](https://rcc.fsu.edu/docs/high-performance-computing-python) [http://stackoverflow.com/questions/26854967/python-on-hpc-cluster-computer](http://stackoverflow.com/questions/26854967/python-on-hpc-cluster-computer) [http://stackoverflow.com/questions/13617019/parallel-python-or-mpi](http://stackoverflow.com/questions/13617019/parallel-python-or-mpi) 
http://i.imgur.com/qrpz7BC.png ? 
There are ways to turn attribute access into a function call, but it's much easier to do for classes than modules. In that sense it's probably fine to leave the setters. I don't understand what you mean by "wanted to avoid the division in modulo". You're doing exactly that yourself, just less efficiently. This is one of the reasons people say what they do about premature optimization - if you don't know what you're comparing against, you don't know if your code is actually faster at all. &gt; Not to mention that the modulo doesn't take care of negative numbers anyway. &gt;&gt;&gt; -7 % 3 2 The element will be accessed whether you use it or not, but in `getMaxNumPoints` you're then doing the element access yourself anyway, which takes longer than using enumerate. In Python, functions, methods and variables are typically all named the same way. Also note that you only have functions - methods are functions attached to classes. To my knowledge, Java won't let you define functions outside of classes, hence Java only has methods.
 &gt;&gt;&gt; f = fdict({1: [1, 2, 3]}) &gt;&gt;&gt; def a_func(arg): return arg.pop() # a_func(f[1]) modifies f You have to either do some serious contortions with recursive freezing - which Hettinger explains some objections to above - or you're basically implementing a new datatype yourself. That's sometimes the right thing to do, but in general I prefer to use builtins unless there's a good reason not to.
I'd second the Anaconda suggestion, built in 'binary environment' support alone is worth it... But just for troubleshooting are you maybe running some sort of extension that could be blocking their navbar? Adblock, uBlock, noscript type stuff?
yeah the un-needed intentional breaking was a bit daft imo `xrange=range` would of been so nice to have, but alas at least it wasn't as bad as `future_builtins`, completely removed in python 3 (when it was supposed to a parallel concept to `__future__`, additionally it wasn't even compatible with python 3's builtins just like, ugh
Once you are familiar with the paradigm, you would just start with multiprocessing or dask from the begining. I'm sure it's similar in any other language. You don't just go from not thinking about multi threading in java to implementing it with little refactoring. You need to worry about thread safety. Julia and Haskell however do handle it much better. Being able to move from single core to multi core to thousands of nodes so easily with dask in python is pretty awesome. It's new but will be a bigger deal than pandas in less than five years.
Oh, I missed the bit about preserving sign. If you want to read more about Python conventions, you should check out [PEP8](https://www.python.org/dev/peps/pep-0008/). This is what it says about function names: &gt; Function names should be lowercase, with words separated by underscores as necessary to improve readability. &gt; &gt; mixedCase is allowed only in contexts where that's already the prevailing style (e.g. threading.py), to retain backwards compatibility. 
second this, after having used Anaconda for the past week, I strongly prefer anaconda over python.org distribution 
You just need to know if your code is IO bound (waiting on sockets, web requests, system calls) or cpu bound (doing lots of math in python). For the former, you use threads. For the latter you profile, improve your algorithim and use numpy/pandas/cython/numba/dask if you can and maybe start to think about multiprocessing latter. Numpy and the others are a 30x speed up or much more if you can use them. Much more than multiprocessing. Dask scales out to thousands of nodes if you need it to. Multiprocessing is cool, but I never use it because it's easier to use some other paradigm and get better results.
Fair. I use multiprocessing very rarely. I wonder if concurrent futures is more stable, being part of the python 3 standard lib. Anyways, numpy with numba is a awesome and dask is going to be really fricking cool. I'm glad multiprocessing exists but its pretty niche and rarely the best solution. 
&gt;In normal scenarios, your program a mix of CPU- and I/O-bound activity, and that activity will likely vary based on user input or types of server requests for example. Then you're usually using some multithreaded front end like apache or nginx, no?
Yes. Unfortunately I cannot disagree with you about documentation... T_T
Let's look at what that would entail. Even with minimal dependencies, at the very least it would require including, in addition to pandas, numpy and Cython into the Python standard library. Numpy and pandas together, for a basic `DataFrame`, would easily need an at least additional dozen, highly complex classes added to the standard library. Most of these classes are not general-purpose, they are highly tailored to the specific needs of pandas. On top of that, this would also require adding lapack as an additional dependency of Python itself. That alone is almost half the size of the entire python package. Overall we are talking about probably doubling the size of Python and its dependencies, *before* we even start looking at including any pandas classes. And what would the benefit to you be? You would still need to install things like matplotlib (with all its dependencies), the stuff left out of the standard library version of pandas (like most or all IO), and so on for it actually be useful in the real world. So you still need some sort of integrated Python distribution. So what do you gain from having Pandas in the standard library? 
numba definitely does some useful things. It's mostly low-hanging fruit I think, but there's a *lot* of that these days so the impact is pretty large. Dask is a bit strange to me. I understand wanting a decent API for datascientists to query logs of ad impressions, but I don't know enough about it to know why it was necessary to write a new pipeline-oriented computational graph engine. It's not the first out there. I should probably take a harder look at it, mrocklin has put out some pretty neat blog posts. Granted, that's what I would hope. If the main developer can't even do anything interesting with it a tool then it probably isn't worth touching. Have you used it?
Ehh, I know three ways to write the same decorator and if there being used for caching (like memoization) there's at least one additional way to write it.
in fact,just api.Flask or Django is so heavy, try this one: https://github.com/salamer/jolla
Only true if the snout provides 110V.
Python 3.4only. . . . . Grrrrr. . :) 
Your have not answered the question, as I [said](https://www.reddit.com/r/Python/comments/4hzam0/how_to_make_your_script_better/d2x5cx4). What malicious action is prevented by denying o+x on somescript.py? What undesired-if-not-malicious actions may be prevented? I have seen this same dubious claim made before, specifically that on a file, not using the executable bit for either group or others while using it for owner somehow improves security. Here you have said "of course" it is a good idea, but you cannot answer why that is.
I've seen this as well, and have no reliable way to duplicate it.
&gt; I prefer to put them in a single directory and reorganize when it gets too big. Just curious, I find it quicker to search a tree structure than a linear array. In what sense do you 'reorganize' a single directory without making it nested? Incidently, I never have agreed with this particular element of Python Zen: Flat and Nested each has its place, depending on circumstances. Flat is not always better than nested.
So you're saying that pansexuality is just duck typing?
Is it possible that you meant to respond to someone else? I don't see its relevance to the post you're quoting.
As an aside: Python itself violates the Zen all the time, and IMO its strength is not the "strong foundation of design philosophies", but the fact that it puts pragmatism above everything else (though again, not religiously so, because that wouldn't be pragmatic...), and especially emphasizing the bottom end of the learning curve. In fact, I think that several languages out there follow the valid parts of the Zen better than Python itself. The Zen itself also has its fair share of issues. Because of this, I have come to use the word "pythonic" to mean "idiomatic in Python" - that is, pythonic code is code that is written according to the habits of the Python community, and making good use of Python's strengths and weaknesses. Which is hardly a concept that applies to anything other than programming in Python.
You should post the errors you get. Looks like you spell the variable c with lower case in one place and upper case in another, that's a crash. Then "c++" isn't valid Python. "c += 1" is what you want. But look up enumerate. 
My interpretation of 'flat is better than nested' was that nested structure require more cognitive load than flat one, so if it doesn't matter we should prefer flat structure over nested one. It's hard to imagine them claiming that it is always better than nested since python itself uses nests a lot. Also you claim that it is quicker to search a tree structure than a linear array, but HCI researches proves quite the alternative. Now I'm not an expert in the subject but I did take an HCI course in school, and here's the part of HCI textbook that talks about menu design and breadth vs depth. http://www.hcibook.com/e3/online/menu-breadth/ It even go as far as to claim that by Fitt's law adding a depth does not benefit selection time until there's 60(!) choices.
use a Unicode escape code, look it up in the character table 
In python, in general, you implicitly trust whoever is calling the function or setting a variable, so getters and setters tend not to be used. &gt;&gt;&gt; foo.bar = 5 &gt;&gt;&gt; foo.bar 5 However, if you need control, or if the value of a variable changes dynamically and you need to update it whenever it is called, then you use properties. Because properties exist, your interface does not change at all, so you never see getters and setters in python. So, `getBar()` becomes `bar` (with a property if you're doing something other than returning it directly), and `setBar()` becomes `bar =` (`@bar.setter` if you're doing something other than setting it directly). So get rid of as many as you can, allow direct access where possible, and use properties where you need them. edit: This question is better suited to /r/learnpython.
+/u/CompileBot python import subprocess import socket import sys import os # it's a raspberry pi :D .. socket.gethostbyname(socket.gethostname()) print sys.version_info p = subprocess.Popen(['ls -ltr'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True) output, errors = p.communicate() print output 
So besides the obvius advantage in terms of "reading" the code, the properties are also "faster" ? 
Likely most time is spent in tensor flow, where computationally expensive code is already written in c++.
i have different type of set/get methods. I'm working on a machine learning algorithm and my main class is called "agent". Some methods just need to set/get values from the genetic code, but there are other, that have to do some work to return the value i need. For instance i have the get_card methods which computes the cardinality of a cluster that i've found inside my dataset, and of course i have also a methods to set the cardinality. 
Output: Thepathof therighteousmanis besetonallsidesbytheiniq uitiesoftheself ishandth etyrannyofevi lmen.Bl essedishewho,in thenam eofcharityandgoo dwill ,shepherdst heweak throughthev alley ofdarkness,forheist rulyhisbrother' skee perandthefinderof lostchildren.AndIwill strik edownuponth eewithgreatvengeancea ndfuriousangerthosew howouldatte mpttopois onanddestroyMybroth ers.AndyouwillknowMyn ameistheLordwhenIlayMyvengeanceupont hee.T hepat hoftherighteousman isbese tonal lsidesb ythein iquiti esofth eselfi shandt hetyra nnyofe vilme n.Bl essedi shew ho,in the nameof char ityandgood will, shepherds thewe akthrough theva lleyofdarkne ss,fo rheistruly hisbr other' skee peran dthefinde roflo stchild ren.A ndIwi llstriked ownupo ntheewi thgre atven geancean dfuriousangerthosewh owoulda ttemp ttop oisonand destroyMybrothers.Andyouwill knowM ynam eistheL ordwh enIla yMyvengean ceupon thee .Thepath oft herighteousmanisb eseton allsi desby thein iquitiesoftheselfi shandth etyr annyo fevilme n.Blessedishewho,in thenameo fchar ityandgoodwill ,shepher dstheweak throu ghthevalleyo fdar kness, forh eistr ulyhis brot her' skeepe randthef indero flo stchi ldre n.AndIwi llst riked ownu ponthee with greatvengeance and furiousang erth osewhowouldatte mpttopo isonanddestroyMyb rot hers.An d youwillknowMyn ameistheLordwhenIlayM yven geanceu pont hee.Thepathoft herighteousmani sbesetonallsidesbythe iniq uitiesofth eselfishand thetyrannyofevilmen .Ble ssedis hewho,inthen ameof charityandg oodwill,sh epherdsthew eakt hrought hevalley ofda rkn ess,fo rhei struly hisb rother'ske eperand ... [^source](http://ideone.com/7i1tfG) ^| [^info](http://www.reddit.com/r/CompileBot/wiki) ^| [^git](https://github.com/renfredxh/compilebot) ^| [^report](http://www.reddit.com/message/compose?to=compilebot&amp;subject=Report%20Abuse&amp;message=--report%20https%3A//www.reddit.com/r/Python/comments/4ikox4/came_across_an_interesting_reddit_bot_written_in/d2zpg6b%20Include%20your%20reason%20for%20reporting%20here.) 
It's not a Schuko plug, that'd have ground connectors at the top and bottom. It's a [CEE 7/17](https://en.wikipedia.org/wiki/AC_power_plugs_and_sockets#CEE_7.2F17_unearthed_plug) which is an unearthed 16A plug compatible with both CEE 7/3 "Schuko" and CEE 7/5 "French" sockets. In essence it's a high-current (but still unearthed) variant of the CEE 7/17 "Europlug" (which only allows up to 2.5A).
PyPy was the great hope of everyone for a long time, then they decided that sticking to python 2 was the right thing to do for an experimental implementation. Also never fixed using c-modules (they thought rewriting numpy was a good idea ....) So yeah, that's dead in the water for both the scientific python communities, and anyone who uses modern python. Such a shame really
Matplotlib is phenomenal once you are used to it (which may take years). Unfortunately the samples/tutorials all use a random mix of the procedural and object API's. Really they should update to just show the OO api. But yeah, its an API modelled on how matlab does things as the project seems to have started as a python replacement for matlab plotting (which was reasonable considering the target audience). There are libraries that wrap matplotlib in a more pythonic api (and generally have better defaults), however for anything other than basic plots you always need to go down to the matplotlib api anyway. I spend most of my day doing data visualisations of various sorts though, so its invaluable to me, and I've overcome the hurdle of learning the api. I can see for python guys who aren't from science background generally finding it hard to work with though.
This, numba is great when it works, but outside of anaconda setups you are going to have trouble. Unfortunately it seems to be deliberately hard to use out side of anaconda, which I get as they are the guys developing it. I even use anaconda as a default python environment, but generally would not recommend, or add as a dependency to a project, any library that can not be reasonably easily installed on vanilla python.
Advanced plotting? There is nothing in any language as powerful as numpy/scipy/matplotlib
I use Tkinter, which is fine for my basic needs, and is standard in all Python distros.
OpenMP is dumb, you as the user have to think about it. There are constructs which effectively place Mutex's on data structures so threads don't overwrite data that is being read or written to by another thread though. e.g """ \#pragma omp parallel for schedule(dynamic) int data[100]; for(int i = 0; i &lt; 100; i ++) { data[i] = i**2; } """ would be fine """ \#pragma omp parallel for schedule(dynamic) int data; for(int i = 0; i &lt; 100; i ++) { data += i**2; } """ would not be fine, gives race conditions. The solution to this could be """ \#pragma omp parallel for schedule(dynamic) int data; for(int i = 0; i &lt; 100; i ++) { \#pragma omp critical { data += i**2; } } """ You can have a look of the source of libgomp in the GNU project to see how it works.
What do you want to use it for? License restrictions are something you need to take into account.
It's ±10% FWIW, interestingly the UK have legacy area which still get 250V mains… which still falls within 230V±10% so it's all good.
Pretty sure it's an electrical outlet.
That is pretty imposing. I sure wouldn't do it with PHP.
This guy knows his plugs right here.
And again: one extra function call wouldn't be much of a hassle anyway.
Also, it would have to wait for another major version, since its an incompatible change. I don't think we want to go through another Python 2 to python 3.
I don't get it... :(
Do you have a go-to method for parallel processing? While we all wait for Numba to give us the magic bullet, it would be nice to have an interim solution!
Sounds like he wrote messy, bad code and blamed Ruby for it instead of saying "I wrote bad code". Also, post that to /r/programmingcirclejerk
Just a tip: if save == "y".lower() Think about your comparisons like this. What does " y".lower() do? It returns the string in lowercase letters. Since you are calling the lower function on "y", nothing happens. Instead it should be: if save.lower() == " y" Since this will allow the user to type either "Y" or "y" as save.lower() will return "y".
Yes: pur --skip PACKAGENAME
Whoever told you that would work, don't trust them. It pure quackery.
Ah, very good. You just added it.
I installed the install package by downloading the full version Anaconda for Python version 2.7 (I'm running v2.7.11 from OS X Yosemite v10.10.5) and then updated via terminal. However, when I try to run your script 'import pandas... after saving it as mortgage_rate.py, I get the following error: ================================ RESTART ================================ &gt;&gt;&gt; Traceback (most recent call last): File "/Users/stevexxx/Documents/mortgage_rate.py", line 1, in &lt;module&gt; import pandas ImportError: No module named pandas I checked via command line to verify Anaconda is properly installed and it is. I then proceeded looking into web scraping. I proceeded to try to install via terminal, 'pip install lxml' and 'pip install requests'. Looks like they were already installed with Anaconda. However, when I try to run a sample script, "from lxml import html import requests" after saving it as web_scraping.py, I get basically the same error: &gt;&gt;&gt; ================================ RESTART ================================ &gt;&gt;&gt; Traceback (most recent call last): File "/Users/stevexxx/Documents/web_scraping.py", line 1, in &lt;module&gt; from lxml import html ImportError: No module named lxml Am I missing a step somewhere to be able to import these modules that I just installed?
Duck typing (aka dynamic typing) is the idea that you figure out the data type at runtime based on context. If it looks like an int, and acts like an int, treat it like an int. This is something python does. This is making fun of that concept. You have an object that is an instance of a pig nose implemented to look enough like a power plug that it is being treated as such.
Some elaboration for the benefit of OP: The single underscore is (mostly) just a convention. As you said, you can still access the attribute with object._attributename. But there is one case where the single underscore actually affects things. From PEP8: &gt; _single_leading_underscore: weak “internal use” indicator. E.g. from M import * does not import objects whose name starts with an underscore. That doesn't apply to class or instance attributes, of course, but only to top-level constructs. The double underscore is a stronger way of indicating that attributes are intended for internal use. Check this out: &gt;&gt;&gt; class Foo(object): __bar = 1 &gt;&gt;&gt; Foo.__bar Traceback (most recent call last): File "&lt;pyshell#12&gt;", line 1, in &lt;module&gt; Foo.__bar AttributeError: type object 'Foo' has no attribute '__bar' You can't access \_\_bar with its normal name. However, if you look at \_\_dict\_\_, you will see that it is in there under the name \_Foo\_\_bar: &gt;&gt;&gt; Foo.__dict__ mappingproxy({... '_Foo__bar': 1, ...}) &gt;&gt;&gt; Foo._Foo__bar 1 This is called name mangling. When you use the double underscore, the name is transformed into the format \_Classname\_\_attributename. It is still accessible from outside the class. It's just more trouble.
When get/set methods ARE used in Python, it is often a hint that they do not merely set or retrieve some value. A set() could have other side effects. A get() might be a relatively slow operation that should not be called indiscriminately, etc. Otherwise, access the members directly or use a property that makes it look as if you do.
Maybe I'm in the minority, but I've written very few tests that stand in for a type system. Usually those exist for utility functions to ensure I'm iterating a list and not a string or the like. I hear this complaint all the time, yet I never actually seen it in action. At this point, I just chalk it up to FUD about dynamically typed languages. 
Calls to plug_in() didn't fail, but did not receive expected output.
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, we are sure you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
perfect thanks!
Thank you! Haven't thought of this yet. I moved these now to the release.
Definitely this is not a panacea, the paper linked in the readme goes into a little more detail. This approach was aimed at programmers who are not familiar with parallel programming, specifically it was inspired by use cases in scientific programming. In that way I do think this is solving a pretty large problem, the requirement that you need to be familiar with parallel program in order to write parallel programs is seriously restricting scientific programs from performing well on highly parallel hardware. Overall no, you do not need to familiarize yourself with any paradigms or ideas before you should be able to write code that uses an entire CPU rather than a fraction of it.
Not trying to bash anything here, just giving some perspective. If that offends you, I apologize.
Have you worked on products (not libraries) with a large number of developers? 
There was a report to this effect (actually there's been many reports): &gt; you have a fork in the road here. are you going to turn /r/Python into memes or see the light? I'm going to turn that back on the community. If this isn't what you want to see, then use your votes to express that.
or [airflow](https://github.com/apache/incubator-airflow)
Keep the memes away
I appreciate that stance, but democracy is historically terrible at maintaining standards--particularly via anonymous vote. There's something to be said for being opinionated. If Python had been built democratically, it'd probably be Perl. 
Oops. I was basically trying to say something line "yeah, I agree, and an even shorter way of saying the same thing is 'don't be a jerk' " I ended up being one myself...
Lol first think i thought of
Please no memes. There are enough subreddits for memes, even programming specific ones. 
I had this same problem with my app and I chose Django + DRF in the end despite being proficient with Flask/SQLAlchemy. Main reason being dealing with user authentication and permissions. I just did not want to manage that myself.
Please no memes.
As you well know, there are around 120K people subscribed to /r/Python. What percentage of those people do you really believe actively think about what constitutes quality content for the subreddit when clicking the "upvote" button? I'm all for a pointedly relevant joke post every now and again in an otherwise serious subreddit, but unfortunately, at this scale, that can quickly become a very slippery slope. At some point, moderation does have to step in for a subreddit like this, to avoid having it turn into a bog of shitposting and funny stuff. I at least hope the team is keeping an eye on the ratio of joke posts to real content and is prepared to step in if it starts getting out of hand.
Let's review. This has come up one time, ever. We have very little context to base rules on in this situation.
Haha, double misunderstanding then :D No offense taken!
I did not say that this is a long-running concern, I did not anywhere speak of how frequently this is an issue. Your attitude seemed to suggest that the community should police itself on stuff like this, so in response to that, I'm expressing my desire/hope for the moderating team to be prepared to step in *should it become an ongoing issue that the community can't stop.*
Instead of leaving, could you submit better content that people will upvote more?
IMO coming from a PHP background and trying Python out (As a jump). I have to say getting started with Python is not as easy as they say. First of all when starting a new project you have to decide between Python 2 or 3 which at this point in time projects are still being started in Python 2 because of compatibility. I think it's just ridiculous how a version that was released 8 years ago is not fully supported by the community and most of the Python packages out there. This brings a headache down the road when trying to use other people's libraries. Second, compared to PHP's Composer Python's pip (now default package manager) is really easy to get started with, but when you find out that you are not supposed to install packages globally but inside a virtualenv things start to get complicated. For a language that advertises itself as being easy to use all this virtualenv and virtualenvwrapper crap shouldn't exist. And yes I understand the OS packages != your app packages but there should already by a way to install packages locally without so much hassle.
https://github.com/michiya/django-pyodbc-azure
I want to try this but I don't know which ESP8266 to buy. Can anyone recommend via an amazon link? I just want a reliable one that works. 
&gt;Oh, and I don't really care whether or not we should remove memes, as long as there are not too many of them. As I said before: &gt; I'm all for a pointedly relevant joke post every now and again in an otherwise serious subreddit, but unfortunately, at this scale, that can quickly become a very slippery slope. A joke post every now and again is fine. This joke post is fine. However, the moderators and the community should be careful not to let joke posts become the norm.
Visual Studio with Python Tools has been awesome for me. I need to give PyCharm a try one of these days though.
brew install unixodbc --universal brew install freetds --with-unixodbc pip install django-pyodbc-azure [.freetds.conf](http://imgur.com/gfM1yPt) [.odbc.conf](http://imgur.com/BeiYqxl) [django settings](http://imgur.com/X2BLuob) 
My point was that the majority of people will probably not consider what's good for the community when voting on low-effort content that is easy to process and amusing. Enough people doing this, over enough low-effort posts, and it eventually can become an issue rather quickly. In internet communities, an unchecked majority rule on content and/or focus almost always leads to the core members of the community abandoning it, removing the quality and type of content that drew the community together in the first place.
I understand the fluff principle of reddit in great detail. Implementing rigorous moderation is not something that we've had to do in /r/python before, and I would certainly prefer it if the community would decide to figure this out instead of *me* (or other moderators) deciding to figure this out.
&gt; If this isn't what you want to see, then use your votes to express that. Yes, votes should be used for a thing like this, but they're not. Votes are used for every reason, sensible and nonsense. To assume otherwise is fallacious.
I would recommend ones that are ankle to be connected directly to a device through USB such as the nodemcu. I tried 2 brands of the sort where you solder directly to pins (or have them presoldered), and for bitten. At the same time I've heard other people have success with them. I feel like it's very hit or miss
&gt; democracy is historically terrible at maintaining standards--particularly via anonymous vote. This subreddit has historically been very good at it. I hope that continues.
Tried at my 2.7.x. . Gave me facepalm. .
By... upvoting this to the top of the subreddit?
Before I asked people to vote according to what they want to see here, it was at 82% approval. I think that just asking people to recognize the issue has been quite effective, and for as long as possible, it would be good for this community to police itself in terms of this type of content. It has handled things admirably up until now, and I'd like for it to continue.
My concern was also not the one joke post but the reply that implied you'd only rely on the up/down system to moderate. It didn't read like you were holding back to make a decision but rather that your decision was to delegate responsibility for moderation to the community. That's also happened one time ever, but was disturbing enough to me to invite a response. You're a mod--your "one time evers" carry significant weight as they indicate direction. 
Buy the Huzzah from Adafruit! 
I've got a NodeMCU dev board based on the ESP-12. No problems at all (so far!)
What is this amazing Urban Planning course I keep hearing about? I also live in the Bay Area. 
Out of stock in USA...
Python is famously terse in its avoidance of excessive punctuation and tendency to favor simple expressive idioms. I find this is good advice in writing prose as well as programming. 
Hahaha, I fear our course is coming in with way too high of expectations with all this talk... but, here's [an overview](http://geoffboeing.com/2015/08/urban-informatics-visualization-berkeley/) of it. Coming again this fall in the city planning dept at UC Berkeley.
All but the 'h'.
I just tried installing feather-format with pip and got an error. Something about visual Studio.bat not installed. The feather format was made by Wes who create d pandas so I wanted to try it. It's not on conda yet so I'll wait for that. 
Okay
I should definitely do that
I also chose falcon and I am happy with my decision.
I'm new to python but I'm sure I've read everywhere that you should use .join() instead of + when forming strings. Just a fyi
A few comments. * When installing from source repository you should use `python setup.py install`. `pip install -e PolyPoint` doesn't install the package. * PolyPoint depends on an external dependencie `numpy`. It should be mentioned in `install_requires` attribute of [setup.py:setup](https://github.com/josephacall/PolyPoint/blob/master/setup.py#L67) * `coverage` [is required](https://github.com/josephacall/PolyPoint/blob/28dbe7eba6a5a97fe1d015c7e91126812cf8aeb0/setup.py#L75) for testing. But I've haven't found tests. So why requiring it? * The following code can be rewritten: ``` from multiprocessing import Pool as ThreadPool ``` ``` from multiprocessing import Manager ``` as ``` from multiprocessing import Manager, Pool as ThreadPool ``` * [setup.py:setup](https://github.com/josephacall/PolyPoint/blob/master/setup.py#L30) is called with `license=None`, but you've licensed it under GPL2.
&gt; Unfortunately the samples/tutorials all use a random mix of the procedural and object API's. Really they should update to just show the OO api. This is my biggest pet peeve with matplotlib. You end up googling around and get tutorials using pyplot. Personally, I only ever use pyplot for two things: 1. `fig,ax = plt.subplots(...)` 2. When I need to very, very quickly throw a plot up to see something. And even then, I will often still make a OO call 
So, you also don't like `def __div__(self, other):` for division? Because I think it looks much better than `def /(self, other):` and also fits great together with things like `__init__`.
Many other (cheap) boards have an *LED* on GPIO16 which controls deepsleep. Guess how much battery life you'll get with such design. 
**EDIT:** I'm sure you have your solution worked out by now, but in case someone happens by on google: in __init__.py: change: from gmplot import GoogleMapPlotter to: from .gmplot import GoogleMapPlotter in gmplot.py: change: from color_dicts import mpl_color_map, html_color_codes to: from .color_dicts import mpl_color_map, html_color_codes change: for key, color in settings.iteritems(): to: for key, color in settings.items():
+/u/CompileBot python while True: print("True")
That may do the trick! 
Thank you so much. Running this on esp's has been so mind blowing I see such potential ;] But I've been using the arduino ide for a while now and patiently waiting for that Neopixel library haha!
What's difficult about decorators? This @decorator def func(): ... is just syntactic sugar for this: def func(): ... func = decorator(func) 
Agreed. Anything that's not as ridiculously SIMD-friendly as training large ML algorithms is usually hard to adapt to GPUs, and would benefit from a simple OpenMP pragma more (in terms of cost-benefit), and the next step for those problems is a proper supercomputer (uber large NUMA systems, InfiniBand, and so on).
If you want to format floats a specific way, then do that. That's why string formatting exists.
How does this compare to `pip-compile` from pip-tools? https://github.com/nvie/pip-tools#example-usage-for-pip-compile
If you already installed anaconda, just run python from that directory /anaconda3/python for example. I dont use OSX, so cant supply the correct path to use. OS X stock version of python will be in /usr/local/bin or someplace like that
Really? A political post in /r/Python? But Bernie seems to be the one saying that "Special cases aren't special enough to break the rules" though... And he keeps talking about the metaclass (or something like that)...
/u/CompileBot python3 import sys print(sys.version)
This is partially true. However, I would add that knowing about them may change the way you tend to write functions, allowing you to be more succinct. For example, I don't like the pattern result = [] for i in range(10): result.append(i) preferring to use generator expressions instead. However I sometimes need the result to be a list (or a string, or some aggregation like a sum). In order to preserve my general code structure, I stick with generator expressions, and use a decorator to get the type I want. def compose(f): """Decorator that turns g into f ∘ g.""" from functools import wraps def decorator(g): @wraps(g) def wrapped(*args, **kwargs): return f(g(*args, **kwargs)) return wrapped return decorator @compose(list) def squares(top): for i in range(top): yield i ** 2 assert squares(5) == [0, 1, 4, 9, 16]
He actually unsoldered that. It still didn't help. It wouldn't wake from deep sleep.
It seems like cPython will not shed the GIL any time soon, and alternative implementations don't have nearly the same level of support. It seems like our best chance of getting concurrency is looking elsewhere.
You wouldn't even need to use selenium for this site. Just the requests module. 
&lt;joking&gt;Unless it's emacs versus vi&lt;/joking&gt;
What would the above look like in matlab/octave?
Someone correct me if I'm wrong but I think that because there is a process for each tab you may try to find information about each of them(using winapi or something ). They may be a better way so don't take me to my word.
That's a cool example - and a common question I run into - return a list, or convert (or tee?) when the func's called. Might steal it. You could also consider the toolz library: squares = toolz.compose(list, squares)
Same, i generally use the pyplot api (via %pylab magic) for interactive stuff, which to be fair it is very nice for, but when writing large programs with perhaps a few dozen complex and interacting plots, its just to much of a black box
* You're right, I made a mistake. Why are you keeping your tests in a different branch? Seems hard to manage. It is very common to put your tests alongside your code. [Here][1] [a][2] [few][3] examples of large projects. [1]: https://github.com/pallets/flask [2]: https://github.com/numpy/numpy/tree/master/numpy [3]: https://github.com/django/django
Why? I assume they have measures against it...
Personally I think a extension would be easier and cross platform, and no config issues etc. Doing a dump via pstree on a mac does not show the URL/Tabs etc, though it does show inidividual process for chrome. Also process monitor for Windows seems to do the same. 
&gt; Overall no, you do not need to familiarize yourself with any paradigms or ideas before you should be able to write code that uses an entire CPU rather than a fraction of it. I disagree. There's a basic level of familiarity you need to have for everything. You can't use a car without basic knowledge about rules and interface, though you don't need to understand how a carburettor works. But if your aim is just to help scientists, that's cool. 
Although applying string formatting to a float makes it a str, which will also make it a String in the final json document. So you either have: { "key": "2.65" } if you %-format the value, or { "key": 2.65000000001 } if you don't. I just wanted to vent my thoughts to the creator before diving into the implementation of ujson myself to try to remedy it. 
Isn't that a pretty big reason not to use f-strings? Everything you may want to translate or make configurable cannot use f-strings. You can't even define a constant for magic strings which you should do if you want clean code.
jup, one of my points of criticism. they’re only usable for simple cases. a design like javascript’s [tagged template literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals) would be much more useful
Let me just clarify: The above post was me sharing thoughts to hopefully trigger a discussion, and not a list of feature requests I was asking for (Although I see I might have portrayed it as such). I know how free software dev works and that nobody wants to spend time developing niche features for other people for free, so please don't think I was expecting you do do anything about it. :) With that said; there might come a time when we would /need/ a feature implemented. In such a case, would you be open to some paid consulting/dev? Any features we pay for would ofcourse go straight back into the master branch.
You sir are a gentleman and a scholar. Wonderful work.
Output: 3.4.3+ (default, Jun 2 2015, 14:09:35) [GCC 4.9.2] [^source](http://ideone.com/9lfuJd) ^| [^info](http://www.reddit.com/r/CompileBot/wiki) ^| [^git](https://github.com/renfredxh/compilebot) ^| [^report](http://www.reddit.com/message/compose?to=compilebot&amp;subject=Report%20Abuse&amp;message=--report%20https%3A//www.reddit.com/r/Python/comments/4ikox4/came_across_an_interesting_reddit_bot_written_in/d315euc%20Include%20your%20reason%20for%20reporting%20here.) 
When wil it officially support windows
Yeah, I just picked up Ryan Mitchell's *Web Scraping With Python* and chapter 9 is all about scraping web sites with forms, logins, and cookies.
Take a look at https://docs.python.org/3/library/threading.html#timer-objects Have the task you want to run schedule another timer when it begins.
Looking for feedback and criticism. Do you think it's too small for a module? ;) Note: not published on PyPI yet (mainly because I am a student and I don't use it apart from some private projects), but if I get enough requests then I would do so.
I don't know anything about skimage, but scipy is split into several largely-self-contained sub-packages (scipy.sparse, scipy.special, etc.), and you probably aren't using many of them. You can just delete the ones you don't need. Numpy isn't so modular (or large), but you can delete any testing stuff, for a start.
It depends
I said this on HN as well, but it's just too slow for me, even with the nice features.
I would second /u/OneEyedChicken's link to the documentation on timer objects, but i would also strongly encourage you to learn about python threading in general at [PyMotw](https://pymotw.com/3/threading/index.html) NOTE: There is also a version of it available for Python Version 2.7 - Just search for it within the site.
Just modify example.py with your informations, after open python idle and run example.py I just tried and it works well.
when i try to open it in command prompt it says IndentationError: Unident does not match any outer indentational level
try google searching that error
so I opened python Idle, it opens python shell and then what do I type in to run it? When I type "C:/Users//Downloads/instabot.py-master/instabot.py-master/example.py" it just returns the same thing 
I'm sorry. We'll keep you in our prayers.
/r/learnpython
I always thought `SyntaxError: not a chance` was cute in its own way.
&gt;error: Unable to find vcvarsall.bat J/k, fuck that error.