Because I can't make a case for porting our codebase to Python 3 that the ~~cokeheads~~ managers will understand and agree with
It's not about being automated or being possible. In large businesses it's about cost and risk versus gain, from a business perspective. And if you look at it purely that way, the gains do not justify the cost and risk, so ir won't be done. We'll be using Python 3 as soon as RHEL ships with it by default.
You were downvoted but this is completely reasonable. Fill a file with "x: y" sort of k/v pairs, and then just pass the fileparh as a single argument. Load and you've got yourself a dict of options. Can even nest and have various data types. 
I didn't, but I think OP is not primarily asking whether to use argparse or other argument parsing library, but which design pattern to use to pass those parsed arguments to individual modules within his app.
*shudder* I recently left a job where I was stuck with Django 1.5, bolted on a Flask/SQLAlchemy app to provide an admin interface. All the logic everywhere, twice, in python 2.7.6, with so many dependencies even upgrading to 2.7.9 was hard.
Yeah, I think you’re right there. Others in this thread have been suggesting loading confit files and I think that’s a better way to do it too.
Other comments in this thread suggesting loading config files are spot on imo. Many arguments is unwieldy. Another option could be to export some of the arguments as environment variables and import them in your script. Click allows for clever management of using env variables in a CLI.
The arguments are stored in the object, which you get by calling the method parse_args() on the parser. (I am talking about the argparse module)
It has been a bumpy ride to get support for that platform across the board. At least the foundry supports part of the platform since nuke 11. But god is it slow to addapt. 
Hi! 
From personal experience, the new approach is vastly better. Rather, the old approach is simply *incorrect*. I would be happy to assist you with moving forward on this if you have any specific questions.
I have refused it since 3.4.
In the UK we introduced Computer Science to all students from 11-14 with a requirement that they must learn a text based language. Python is the most popular choice for this and it's starting to come through into uni etc. (VB being another popular choice) 
&gt;raw_input() was removed and im too lazy to lookup how input() works now. ... It works identically to how raw_input worked in 2.x. The [new documentation](https://docs.python.org/3/library/functions.html#input) *even uses the exact same example* as [before](https://docs.python.org/2/library/functions.html#raw_input).
I recently got a google colaboratory test run, and it supports only python2, this is the only place I am using py2.
i tried some basic ansible (from develop) with python3 just 4 months ago and had plenty of issues still... after 2 days wasted trying to fix mysterious errors i just switched down again.... i always start with py3 when making new stuff at least. about ansible it's far far better than it was a year ago but I'm scared it'll still be awhile for the word stable...
Wat....okay i dont know what the hell i read then. Thanks for letting me know my head has been in my ass. XD
&gt; having the wrapping parens You mean, for calls to `print`? Have you tried out any of the neat things that you can do now because of the fact that it's a function, that you couldn't before? Does it bother you writing the parentheses when you call other functions? Certainly I hope that doesn't discourage you from extracting common code into functions in your own code....
You know there's an `encoding` parameter for `open` now, yeah?
You can add a lint checker for your editor, not have to follow them but you will try to aviod warnings, and one day you will get used to it.
The stdlib. Too many people go around looking for external 3rd party libs before even knowing well how to use Python's. collections, intertools, functools, json, hashlib, heapq, bisect, etree, pathlib, datetime, sys, os, argparse, csv, logging, asyncio, __builtins__... You can do A LOT with those. Granted, requests, pendulum, django, sqlalchemy, jinja2, numpy, pandas and the likes are all awesome. But you need to start with the basics. Then, once you got a hang on that, you should learn tooling. pip, venv, flake8, pytest, mypy, tox... 
It's not even remotely comparable to "a different language". It fixes things that are fundamentally wrong about 2.x's design and gives you access to a lot of neat features that are not getting back-ported.
Not C, Java
I have heard about stuff like that, never had to use it though :-)
Using PEP8 now is just training yourself to have good habits for when you'll finally work with somebody else.
Second this
Like, you literally drop it in and you get Unicode strings out of your text file that behave the way you want and expect them to. I really can't fathom the extent of laziness (not the Larry Wall kind) that people are describing ITT. It seems like it would prevent people from cleaning up their code at all.
Ubuntu 16.04 comes with Python 2.7.
Doesn't even mention Pillow… You don't need numpy for everything.
Because Python 2 had broken behaviour (such as bad Unicode handling) that needed to be completely fixed which was a breaking change.
Kidding? Or do you not have sudo access to your work environment lol? If the latter, look into **anaconda**; it's a distribution of python packages, binaries, command-line tools etc. that installs into your home directory.
Give it a shot. I think you would be impressed. Like i said, it really helps the way i thinj about coding. And especially Python
Im 100% with you... I borrowed (with permission) from Tim Hoppers [blog](https://www.tdhopper.com). I wish I knew pelican a little better, because the theme for articles isnt that great, and Id love to change the font... Here is [mine](https://datavistics.github.io/).
The real gain from it is zero though. The only real reason in this case would be that the support for 2.7 is going to go away in the future but if you have a single script somewhere that runs on a 2.7 it is no huge danger.
If you are into image processing in the scientific sense you are most likely already using numpy, so in that case Pillow is actually not very useful. Source: am image processing/computer vision scientist, and I have never used PIL or Pillow.
I used to answer this with ansible but that bullet point is almost off the list now due to amazing effort from their team. So the only remaining point for me are our in-house systems that stem from over 6 years ago and are stil in heavy use. The funny thing is that it's my responsibility to port them. It's pretty low on my list to be honest. Python 2 will be around a good while longer. I have looked at porting them, because I use Python 3 for anything else I do. Mainly it's print statements and except statements that need modernizing. Most of the rest is backwards compatible, even if it's tempting to convert other things like format strings.
Large fucking codebase and tons of features to work on.
Soon you will be in the reverse situation. All the big scientific libraries decided to drop 2.7 support in 2020
What kind of differences? We have switched to Django 1.11 from 1.6 and the changes to our Jinja related code was minimal.
I dont know Pillow but i mentioned scikit-image as a good alternative. The point of the post is that you dont need numpy.
&gt; I dont know Pillow If you're gonna write a guide, maybe you should. It's literally every result you'll find if you google "python image". It's used in the Hitchhiker's Guide in the chapter about image processing. As the name PIL ("Python Image Library") implies it's basically the default library for image processing in Python.
Maybe. But im not a algorithms programmer, just needed to do some simple image processing and found scikit-image very simple to use
Well of course, if you're already using numpy/scipy or whatever for other purposes then it makes sense to use its image processing abilities. My point is you don't need it and if you're *only* doing image processing it is, as in so many other cases, massive overkill.
Geo people unite !!
Not really related but anyone noticed this beautiful annual pattern in some of the curves ? I would guess that the peaks correspond to university exams !
Did you try http://www.paramiko.org/ ?
If you don't need to, don't worry. If you find a need to later on, it'll be there. 
Heh
It's cool once you finally dump python2. It can take a while but it feels good once there. 
If all you need to do is split the data, casting the data will make it slower. Just do less.
The question is what code you had been using before. We have lots of custom filters spread across apps and namespaced.
Short answer is no, there is currently no backend to matplotlib that supports gpu rendering. HOWEVER there are other plotting packages that do and may suit your needs. Vispy is one example.
Okay thanks for the reply! I'm thinking of trying to use Cuda and numpy to "prepare" the data before making a histogram e.g. Maybe that will work? Yeah, I got recommended Vispy but it feels like the threshold to start using it is quite high? And I find it hard to find examples and documentation.
The fastest and most reliable way to manipulate primary files is in shell: split yourfile -n 2 
Are you time traveling? 
Is this a joke? Package management is widely considered to be one of he weakest parts of Python.
This is not going to happen, sadly. Most enterprises don't want to change something that is working even for something better, especially when the people deciding don't understand the technology used... Took me two year to convince my boss to move to an enterprise gdb and use topology instead of the glorified excel table they had been using for ten years... Also, schools are teaching GIS with ArcGIS because of the money ESRI is throwing at them.
I'd check out http://longbets.org , and suggest the Python Software Foundation would be an appropriate beneficiary :-)
I have a question a lot of the issues are syntax changes on minor things. Couldn’t something be written to auto update the majority of the code.
I support Macs, and 2 is still standard in macOS. For my personal projects I use 3 now, but I can't justify pushing and maintaining 3 on an entire fleet of Macs just because I want to use it for system scripts. I can't understand why Apple hasn't even started a transition. They should've started shipping 3 (not as default, just alongside 2) years ago.
I'm too much of a lazy cunt to change. 
I guess so! Thanks for the reply.
Vispy is quite new and the development has been slowing down these time. You can try pyqtgraph which is less ambitious but more mature, they have plenty examples. What is taking so long in your data? Pre-processing or display? Can you "coarse" your data to accelerate the rendering? An other possibility is to format your data and output a format that is comprehensible by Paraview. This software is designed for scientific visualization, has python scripting possibilities and has good performance. 
It'd be new to me anyway. Rewriting it all in COBOL would porting it to a new platform as well, though not "the."
A lot of the inertia is due to the following vicious circle: - If you are a library developer, you can support both 2 and 3 with and test everything twice for every release, or support only python 2.7 and reach most of the market. - This in turn, makes people choose python 2 (and continue to choose) in the first place, as it allows them to profit from more available libraries 
But you don't need to change the OS default python version to use a different one in your programs. They are just 2 different languages that you can have installed and use at the same time, letting the OS use the one it needs. Like using ruby, you wouldn't need to change your OS to stop using python2 and start using ruby just because you want to deploy apps in ruby.
Ah okay! The reason why it's slow is because I've got multidimensional time series with millions of observations, and usually I want to plot all the observations. Or I might want to search through the data according to some np.where()-statement or smth and plot that data. Would you recommend learning Vispy or pyqtgraph? And if I go for Vispy should I just go all in instead and learn some OpenGL?
The basic use of git is only a few specific commands git init sets up the project git add adds files to the git tree, git commit says what you changed, git push pushes it to a place (usually github). The rest you can look up as you go along, retaining history is a big deal and being able to row back on things is a really important super power.
Why even vim? Sed that shit
You could just use a formatter. I am not a python developer(yet) but I have been researching tools like this to use for python web development. [https://github.com/google/yapf](https://github.com/google/yapf) - is one that I am considering now and I think there are others. I will be working on a team of devs though so this may be a little extreme for your needs. I find that this is something that lets me not think about stuff like this too much. 
Are you able to distingue all your observation? It may be pertinent to reduce the dimension of your data which can lead to more pertinent visualization and faster rendering? I would recommend to dive in openGL then use higher level tools as vispy : you will be able to "hack" stuff if the provided tool is not enough. But openGL is not trivial and far far away the python logic, it will certainly be time consuming (but interesting...). Being honest, I plan to do that, but never achieve the openGL part, so...
No, Matplotlib focuses on high-quality plots for publication, and sacrifices performance for visual quality. That said, you should be able to subsample your data to make it work. Some Matplotlib functions (e.g. scatter) have recently grown options for automatic subsampling. Also, there are often several variants of similar kinds of plots with different performance characteristics.
I'll be impressed when people start building useful software in it. After 27 years just being known for a spam filter at facebook and an obscure window manager isn't overly impressive.
We have a lot of small scripts in the company I work, we started with Python 2 but by the time we pushed them to production we converted all to Python 3, this script do backups between MySQL and Elasticsearch, we also use this libraries, [fastText](https://github.com/facebookresearch/fastText) [nltk](http://www.nltk.org/) and [gensim](https://radimrehurek.com/gensim/) to classify words 
If there has to be a bandwagon to jump on for you to try it, just wait. I like it, so I'll keep using it for my own purposes.
Try opening the file "r+" and use seek, read and write.
Depends on the application. Most socket programming is easier in C on operating systems that have decent man pages than it is in Java. No multiple layers of indirection. `man 7 socket`, then `3p socket`, etc. That and compiling C code is marginally less obfuscated by we'll do everything for you IDEs.
Exactly. If most people would just properly style their code in the first place, we wouldn't have this problem. I just don't get why they can't.
Most basic CS or software engineering courses don't go into sockets at all. Or would start at Java and then move to C afterwards. 
It can't be emphasized enough just how powerful the [itertools](https://docs.python.org/3/library/itertools.html) and [operator](https://docs.python.org/3/library/operator.html) modules are in combination. If at some point you're not using them then I suggest that you're missing out big time.
&gt; Python is not a programming language for writing algorithms. &gt; If we want to write a complex algorithm we need pointers for efficiency and we will probably use C/C++. Two falsehoods in the first paragraph. 
The new approach is overall much better, but has a couple issues. For example, listdir returns str filenames when given a str parameter, and bytes filenames when given a bytes parameter. However, your filesystem actually keeps names as bytes, so the bytes-to-str operation can fail. This means listdir can raise an exception just because somebody created an oddly named file that your software was never going to be interested in.
I’m aware of this, but when I bring it up that’s the response and they won’t talk about it again. 
&gt; My biggest concern is that I'm a 16 year old trying to learn coding for a career opportunity and to be honest, I have no idea how I'd ever make money doing Python. It makes no sense. People make money with using Python a few ways. One is that they work for a company that makes software. Such a person is a "software developer" there, also called a programmer. Her or his job is to write Python code that results in usable applications. That software is then either sold directly to people, or it is given away (in which case the "company" may actually be some kind of non-profit foundation), or it is used for a website that makes money through advertising or other ways. For example, you are using Reddit right now. Reddit is written in Python! Some people sat down and had to figure out how to write code that would provide all these words, in this layout, with this formatting, and your user login, and all sorts of other stuff. They had to figure out how to store all these words in a database on computers somewhere in the world, and retrieve and deliver the information to you as you request it by clicking links. This is all done with Python and related tools. Other websites done with Python include Pinterest, Instagram, and many others. There are also programs that just work on your computer directly, called desktop software, and that, too, can be written in Python. Every time these companies want to add a new feature, the Python programmers have to sit down and figure out how to do that. They might use any of the basics you have already learned (loops, lists, etc.), plus more advanced Python. Or if people discover a mistake--a bug--in the application, the Python programmers have to figure out what is wrong and correct it. There's tons to do. Now, you are probably thinking, "OK, but how the heck can anyone go from a simple loop to something as crazy impressive as Reddit?". Well, it's like saying how do you go from a simple brick to an entire giant building. It's brick after brick after brick, and the architectural plan that allows you to do it in such a way that it doesn't fall down. It's not easy! But it's do-able. In the case of a web site, there are "frameworks" out there that make life easier by handling common needs for making web applications. 
The same reason we have rules about grammar and punctuation in spoken English, even when it can be possible to get the gist of the meaning without them. It makes it easier to read, for you and for others, and once you're comfortable with the rules, makes it easier to write too. Anything is possible in python, which also means that for any given task, there are myriad ways to accomplish it, and indeed many ways a single solution can look. Following Zen and the style guide means that more people converge on the same look. You do share code - with your colleagues, and even with yourself (the biggest critic of my janky code is me when I read it again in 2 weeks' time). Your and your colleagues would be doing each other a huge favour if you used standard style guidelines and code sharing protocols.
You could also call ImageMagick from the shell, and avoid Pillow that way. Not everyone is web dev.
Yes, it matches my angular 1.6 project :(
I react in the blog post, but short summarize : if your stack is not too much hardware dependent, it is possible to freeze all your scientific stack by providing a Dockerfile. Ideally, a git repo with your publication + code source + a Dockerfile (or equivalent), with care taken about the version of the libs you are using should ensure reproducibility. Of course, these tech are new, and you have to observe how stable will be docker (or equivalent tech) in the future.
If you read 'complex' as algorithmic complexity (big O notation), it's a reasonable statement.
All software engineering students study sockets at some point
3 years in software engineering, we studied how to program Cisco routers but not actual socketing
There are plenty of counter-examples of algorithms written in Python, including complex algorithms... You don't *need* C/C++ if your code is fast enough in Python. And you certainly do not *need* pointers for efficiency.
brython, like skulpt is a python interpreter implemented in javascript, while transcrypt is similar, but tries to convert some more python apis at the expense of final js readability, imho
There are 3 year software engineering degrees? I had to write a TFTP client and server. Thankfully we never touched a cisco. I mean WTF it's "software engineering" not "network engineering"
I don't have experience with it, but isn't that like the primary function of py2to3? I mean if you are literally just hanging on that one point, just try to run your codebase blindly through and see if still works on the other side, then you're home safe. 
Yeah there was a 3 year option and a 4 year option, they pretty much added an extra module to each year and made it shorter, the idea was more for people transferring from the other course to not have to do a full 4 years. I did the 3 years because I'm a masochist. 
&gt; And you certainly do not need pointers for efficiency. This is true. 
This blog post is acting like people won't be able to set up and install Python 2.7 with NumPy after 2020. The downloads for Python 2.7 will be available forever, and `pip install numpy` will work for Python 2.7 in perpetuity. It just won't be updated with any bug fixes or security fixes. The same likely goes for your other dependencies. And lets be honest, you should be pinning your dependency versions, so this really shouldn't be a problem. Versions just aren't going to go away for these large projects. And if you're really worried, download the versions you want to keep and archive them yourself. It shouldn't be the responsibility of NumPy's and other packages' maintainers to make sure your code will still work in 10 years.
Yup, constraint satisfaction program. Languages like Prolog are much better suited to this, or algebraic programming systems like AIMMS. In open source, JBoss OptaPlanner is a great tool for exactly this kind of problem. Python may have optimization libraries that could do this, but for this, I'd go with a specialist tool.
Stability, especially for academic code that is expected to last 5-10 years, is important, but not at the cost of non-academic progress in science/CS. Imo, the academic community needs to come up with better tools in python to preserve their code and make it usable. There are two situations here: First, paper-specific code should be reproducible given only the same inputs. I believe we need a tighter integration between services like docker and published code for papers -- if published code was released in the form of a docker container, it will always be reproducible. This is effectively a "freeze" of paper-specific code. The assumption here is that this code won't need to be used in other projects, and is only there to be reproduced. The second situation is that of libraries for the scientific community, and is the real one worth discussing: Right now libraries have to choose between keeping up with the fast-paced improvement of the language, or deal with backwards compatibility issues. I think library maintainers of domain-specific scientific packages should be expected to keep their libraries up to date with the most recent version of other packages _and be provided funding to do so_. I also think that every release of a package should specify exactly what versions of its dependencies it uses when the package is released. This is a spot where the python community could make more/better tools to help library maintainers (especially with consideration for version dependencies and backwards compatibility). The real problem in my opinion is academic funding (which has some things in common with open-source funding). Right now, funding for the hard sciences rarely supports code maintainability in an era where good science simply cannot be done without good software. One solution is to provide funding for code maintainability. However, that simply requires more money, which often isn't feasible. Another partial solution is to hire scientists (including grad students) with serious CS qualifications for coding-related work. Right now, graduate students are expected to learn to code on their own. This is okay because they are very capable of doing that, but they lack the necessary "soft CS skills" to make good, maintainable code (I know, because I underwent the transition from writing crappy scientific code to writing maintainable code over the course of my grad work, but learning how to do that was done entirely outside of my research time). Placing more emphasis on being able to write good code will result in better, more maintainable code across the spectrum.
It would not be difficult for a group of companies using Python 2 to set up a fund to ensure continued maintenance. Even the PSF may not object to taking their money to do this. Alternatively, some vendor (e.g. ActiveState) to pick up the glove and offer ongoing paid support. Big py2 users would do this even if the total is higher than porting - as long as it reduces the risks involved. And I don't expect it to be more expensive.
What's the real downside of the overkill though?
Thanks wasn't expecting a post like this. I tried with the den files and then I almost tried just using the run files but someone on SO said den files would be easier to handle. I tried to read the installation guide but I kept having to search for something else like the link for the .deb for Cuda 8 or the new LD path for Cuda 8, or where I needed to put Cudnn files. I completely gave up after yesterday and resumed with sickit learn but I might go back and see if I can follow your steps. I'm sure the first time is the hardest but this just seems like such a mess to me and I was way too frustrated to think straight 
Yeah I specifically wanted to try tensor flow since it's one of the only ones I know of that has gpu support. I'll look into anaconda though, it seems it could be interesting. 
Yes Vispy is very new and a little opaque. There are other libraries that may do what you need that are more well developed. I see some in the comments here. The trouble with “preparing” the data as you suggest is that that may take time and won’t shorten the rendering process unless you reduce the size of what you are plotting. Short of coarsening your data I doubt it would have much positive effect. I would encourage taking the time to learn one of the actual gpu plotting tools. Ultimately it will take the same kind of time and leave you with a fuller solution and a more valuable toolkit.
This is what the OP needs to do.
Really? With Sage 8.0 I can run: sage -python3
oh, sad to hear that :/ Hope it changes someday.
I'll quote two parts that I think are relevant here: &gt;But frozen code is not a good basis for further work. Using it requires much work for re-creating an outdated environment. Worse, using two or more of such packages together is in general impossible because each one has different dependency version requirements. and &gt;Layer 3 code gets more or less well maintained, depending on the size of the communities supporting it, and on the development resources available. Quite often, maintenance is sub-optimal for lack of resources, with the maintainers aware of the problem but unable to do a better job. That’s my situation with MMTK. The first explains why the author doesn't want to just version their code -- they want it to be compatible with other software packages that might use other versions. The second quote explains why they aren't able to update their library -- lack of time/funding. I agree with you that library maintainers (myself being one) should be required to keep their libraries up to date. This isn't always possible, and I don't blame the scientific library maintainers themselves. This is a culmination of code maintainability not being given as much importance as it needed over the last 10 years in the academic science community.
Well.. and now Im curious :-) Please post a link to the SO question.
Now updated so it sends an update when an event happens but still does not bombard the receiver of the e-mails.https://github.com/vfxGer/docker_eventer/blob/master/README.md
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [vfxGer/docker_eventer/.../**README.md** (master → ce333be)](https://github.com/vfxGer/docker_eventer/blob/ce333be700da9b4f424de05c21bd31b3611a1e0e/README.md) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dpyms2x.)^.
Edited the comment for clarity.
https://stackoverflow.com/questions/47321797/pandas-replace-records-based-on-conditional-test-in-column there you go!
Those blogs are nice. I'm hoping to use Pelican or another static site generator in the future. I hope to achieve the following: Jinja2 templates for header, footer, nav, and widgets (aka sidebar) Write html files for the post bodies. Will probably run the site off of gitlab, they have a nice CI engine that will automatically publish static sites.
I think a couple reasons. 1. The rise of data science in popularity and the rise of Python as one of if not the best tools for data science. See [here](https://www.youtube.com/watch?v=fk8ATuMUltU). 2. The general move away from OOP as the standard for building enterprise tools, and thus the slight reduction in popularity of Java, which I think led to it being considered "OK" to learn Python as a first language as opposed to Java (which makes sense to me anyways). 3. It took Python a LONG, LONG time to come up with a consistent and mature packaging and dependency management strategy. It is mostly in a good place now with venv being "official" and the general maturation of setuptools. The "container revolution" has also helped. Rambling but those are my thoughts.
using tox + flake8 and pylint will help you catch things like: using undefined variables in your code, unused variables, unused imports, syntax problems, indentation problems. IE, things that will break your code. This is especially useful if you code needs to be uploaded somewhere to run, or if your code is using a lot of modules and it's hard to test each and every module before attempting to run it. This alone will save you tons of hours of work, and a nice side effect is that your code will be nice and easy to read.
Yes.
Could you explain why ?
I think so. I use Miniconda on Linux for several reasons. * It installs in user-land without any need for sudo privilege. * Since it's user-land it isn't mixed in with the OS-land and won't interfere with system packages/updates/upgrades. * It easily allows multiple Python versions to be installed for different projects with different needs. Since I also build projects with both Python and node, I use Miniconda with virtualenv and nodeenv to create project based virtual environments from my Miniconda "global environments" for further separation. In this way I can easily reproduce my compartmentalized project setups across different machines without relying on Linux system package management. All the relevant directories are in my user home directory which can then be tar'd up and copied to any compatible Linux system. Also handy for backups since it captures the full project state - both binaries/libraries and my code.
I have. It's cool. But as someone who writes software for a living, I tend to use tech other people know, too. Python is like that. Haskell, not so much, and its performance characteristics at scale aren't as well known as Python, Perl, PHP, .NET, C, C++, Ruby, and a host of others.
How so? All I need to do is 'pip install [package]' or even run 'pip install -r requirements.txt' and I'm all set. 
&gt; VB *shudders*
btw for your information: https://www.ecommwar.com/ 
Thank you for you answer! So portability seems to be a great thing about this solution. But I have trouble understanding where virtualenv comes in play. Is not also usable with vanilla python (that is without conda)? Also, do you have some good introductory ressources on virtualenv or similar solution? 
As a c++ programmer, totally, pointers kill efficiency fast. As soon as you start chasing pointers, you lose a lot of performance waiting on main memory as the data you need isn't in cache. 
I used this example in my original talk at PyCon Canada - at least in Python 3.6, taking a slice from a string won't duplicate the items in memory: https://github.com/python/cpython/blob/master/Objects/unicodeobject.c#L13922 The purpose of this code was also to show "idiomatic" Python, i.e. a straightforward and simple description of the algorithm, and that a similarly simple approach in Rust can offer a large speed up. If you were going for pure speed, there's probably a lot more you could do (e.g. SIMD, fast-path ASCII-only strings) :)
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [python/cpython/.../**unicodeobject.c#L13922** (master → f02f5e5)](https://github.com/python/cpython/blob/f02f5e5c3eb815fff9578dc58de60374c6baaa3d/Objects/unicodeobject.c#L13922) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dpyq5sd.)^.
I understand that. I'm just a hobbyist right now. Learning and applying on my own machines.
Yet you didn't even mark it as resolved.
Make a github repo with your description above as the README. Stop saying you arent good at coding. You made a game!
Thanks for the reply. I understand it now!
Thanks a lot! Lots of help for me!
I don't know what modules are. I only know the basic things, print, loops, starting a program, and importing things like turtle or random.
&gt; &gt; But frozen code is not a good basis for further work. Using it requires much work for re-creating an outdated environment. Worse, using two or more of such packages together is in general impossible because each one has different dependency version requirements. This is exactly why virtualenv and conda exist. Just dump an environment.yml into your repo and it should be trivial to rebuild your environment. It's really not that hard.
Thanks, I'm proud :p 
Wait what? I'm.... supposed to do that!?
I did so that I dont have to wait for a package to compile since the miniconda/Anaconda repos have precompiled installers. But with .whl format being more prevelant, that is less of a reason IMO.
Do everything with Python. Front end with Python. Sleep with a Python in your bed, worship python as a new god, become a python.
Weak article, nothing new or even well explained with overly basic examples. 
&gt; This doesn't help at all. An empty iterator is still truthy. In fact, this makes things worse: Of course it helps. If your dealing with iterators, you don't test for truthiness at all: don't Look Before You Leap, instead it is Easier to Ask Forgiveness than Permission. When you are dealing with iterators, including generators, you shouldn't write: if spam: # len(spam) != 0 won't work either # handle non-empty case else: # handle empty case because it doesn't work, regardless of whether you test for truthiness or directly compare the length to 0. Instead: spam = iter(spam) # make sure we have an iterator try: # handle non-empty case except StopIteration: # handle empty case works for any iterable, including iterators, generators, sequences and collections of all sorts. &gt; But the behavior of the if myCollection check, when applied to things that aren't actually lists, tuples, or dictionaries, requires you to be thinking about these things and to know the behavior backwards and forwards. Apart from iterators, can you think of any other built-in type or standard library type that doesn't obey the rule that "nothing/empty" values are falsey, and "something/non-empty" values are truthy? I can't, and I've been using python since before iterators even existed. So there's really only *one* common exception to the rule, and if you're accepting generators and other iterators as well as collections, you can't use the `if len(x) == 0` test because iterators don't have a well-defined length. So in practical terms, there's no need to think about this "backwards and forwards" -- there's just two cases to deal with. If you are dealing with iterators, use the EAFP idiom and catch StopIteration; if you're using sequences or mappings or other collections, you can LBYL by checking the truthiness of the collection. In neither case is there any point in first calculating the length of the collection if all you want to know is whether it is empty. Even if len is cheap for the builtins, that's an implementation detail, not a language promise, and you never know when somebody will pass you a linked list with a billion items. &gt; If python collections had an is_empty() method - that would be the thing to check. They **do** have an is_empty method. It is spelled `bool(collection)`, and you can leave out the call to bool in many contexts. &gt; a collection (like an iterator) with no length is always going to be truthy because there's no relevant specific idea of truthiness In practice, you're right, but that's only because the iterator protocol is deliberately minimalist. There's no reason why iterators cannot support a more useful __bool__ even if they don't support len. Here's a quick sketch that shows one possible way to make it work: class MyIterator: def __iter__(self): return self def __next__(self): sentinel = object() x = getattr(self, "_saved", sentinel) # look for a saved value, if it exists if x is sentinel: # calculate the next value the usual way... return "something" else: del self._saved return x def __bool__(self): sentinel = object() x = next(self, sentinel) if x is sentinel: return False else: self._saved = x return True You can see why Guido doesn't want to *require* that for all iterators. Its a pain. But you can certainly make your own iterators support a more useful concept of truthiness, if you can be bothered. But if you think that's hard, well, that's *nothing* compared to having arbitrary iterators support len. It is not just the the length might be infinite -- it can also be indeterminate. def generator(): while random.random() &lt; 0.5: yield 1 Short of caching the entire sequence of values, which defeats the purpose of using a generator, there's no way of knowing what the length will even be until you reach the end. The bottom line is, the idea of emptiness (i.e. truthiness) is more fundamental than the idea of having a well-defined length that can be compared to zero. I don't know exactly how many grains of sand there are on the beach, nor do I care, and I certainly don't want to have to enumerate each and every one of them, just to decide whether the beach is empty or not. I don't care about the difference between a beach with 67 trillion grains of sand and one with only 57 trillion grains. All I care about it whether or not there are any grains of sand, and the canonical way to write that using LBYL is `if myCollection`. 
100% agree -- this is the way to do it. I'd make the file easy to edit/access too, like: configs.txt
You should be very proud! One piece of feedback Would be to refactor your code to use functions. Currently your code has 1 function which does everything. The general idea is that a function should do one thing and do it well. Having many smaller functions and then composing them together to make he program work will make your code more readable!
Thanks! Thanks for the advice too, I'll certainly look into doing that. It's all a bit of a mess right now!
That’s quite alright! The main thing at this point is just understing the concepts. As you gain more experience you’ll start to focus more on making it pretty.
There are a few things that have been written in it. Eg. pandoc is a fairly popular document converter, and is written in haskell.
I worked in CV for a while. I’d use PIL, but yeah nearly all the heavy lifting was skimage, numpy, and others.
Thanks! So basically as a dict?
Yep. And with generator expressions, comprehensions, etc along with C extensions, most of the time I can do the heavy lifting with functions that have a C implementation. If I have an embarrassingly parallel task, GNU parallel usually does the trick. I don't know the last time I touched multiprocessing/multithreading in python. Write smart code, don't reinvent the wheel (especially if it's already got a mature C implementation), and use other tools to augment python. I don't have any issues with performance anymore that switching to another language would help me with. That said, I do mostly machine learning, on the stochastic side of things. But there are so many tools out there for taking advantage of JIT or a graphics card for computation, I don't really think there's a better choice than python for the majority of problems in the field. 
lets check back in around 2030.
I'm trying to learn python while building the backend for a chatbot with flask. So many things I don't know yet.
I think there were a bunch of things that created a feedback loop. The maturity of CPython itself, along with the progress in hardware making cpu cycles much less scarce and multiple cores more common in the 200x's led to scientific computing becoming more of an option. That led to adoption in academia, and the ecosystem broadening. Machine learning and statistics in general became more accessible and the cross-disciplinary benefits more widely known contributed too. Nearing 2010, more and more universities started teaching python first or earlier because faculty had more experience with it. Add a four year lag to that, and it corresponds with the elbow in that graph. More users-&gt; more libraries, more users-&gt;-more teaching python, etc. I don't have any numbers on this, but I would bet that rise in popularity can be directly tied to the number of significant projects in python, the number of cs and applied math students going through programs that teach python, and the amount of coverage that programming gained in mainstream media. Another thought- smartphones. No, phone apps are not generally written in python. But I think it's fair to say that smartphones becoming ubiquitous changed the way people thought about programming. Instead of an esoteric, abstract practice, dozens of applications that were useful in everyday life were now in most people's pockets. I think that inspired more people to want to learn, and python is an obvious choice to start with because of its accessibility as a language and the rich ecosystem. It's a lot easier to get started with and learn python than any other language, imo, including JavaScript.
Also, conda can install non-python dependencies. For example - the `numba` library requires libllvm and it'll just bundle that with it if you install via `conda`.
I write an scientific open source package. It's 200k lines of code and it's me and sometimes a few others. Python 3 was a struggle, but like other people, once unicode clicked (it took a month), it was easy. I though I'd never need unicode until I did. Nunpy 1.10 broke arrays because my code had been wrong and I didn't know it. Scipy 0.17 broke ckdtree because they introduced a bug, so we fixed it. Numpy 1.13 broke pandas in my code...still don't get it, but it's minor to me. The reality is that if you're using a scientific package without tests, the package is bad. On my 200k line package, it's 6 years in and I regularly break things. The funny thing is my scripts from years ago can be updated in a few minutes with a couple minor changes. The stuff is primarily on the backend, so it doesn't break anything. I compare the output and then breathe a sigh of relief because I fixed a lot of bugs in the code and I know exactly where it runs through. Seriously, what's worse? I'd prefer not to hurt people. At one point, there was a proposal to identify these important lagging packages and put some resources behind it. What happened to that?
&gt;Also, do you have some good introductory ressources on virtualenv or similar solution? You just make a virtual env by typing `venv myvenv` and then you type `source myvenv\bin\activate` to start it, and then you use use python and pip normally. On som systems you might need `python -m venv` instead of `venv`. However the real answer is to use a non-dogshit IDE, which will automate this for you.
Awesome game! threw it up on Pythonista and gave it a shot, may want to take a look at how you calculating the percentage chance of winning, but really good job with this. 
Depends on you actually. It's not useful for my personal day to day use, because as you've said, we have virtualenv and even virtualenvwrapper. I have a 'go-to' virtual environment called p35 with my generic up to date python packages of everything I need. And then I have a virtual env for each specific project, which makes everything tidy. I don't usually need the huge cluster of libraries, 80% of which I will never touch. Also Anaconda adds its bin directory to your path. One time I was trying to compile a C package, one of the library names clashed. Rare but can happen. There's a lot in that directory I guess. There are two occasional useful scenarios for me though: 1. Attending ML workshops in which they expect a load of anaconda packages I know nothing about. Saves me from installing them. 2. Hosting ML workshops in which you instruct all participants to dl anaconda because they can't all be relied on to use pip. Also some packages like scipy on windows fail to be compiled by pip (in the regular scenario). But actually in this case, you don't need anaconda yourself, you just need to confirm that anaconda contains your workshop packages.
It is for many of the scientific devs. They use mixed indentation and install packages by copying them into site packages. They duplicate files constantly vs writing a function. They use import * in their code.
The answer from /u/itsmoppy is definitely spot on! The "preferred way" to set up a virtual env has changed a lot in the last few years so if you go googling you will end up going down a rabbit hole (source: am survivor of said rabbit hole). This is the resource you want in my opinion: https://docs.python.org/3/library/venv.html
is your blog based on pelican?
i finally gave up and tried jekyll. it is super cool. just need a powerful markdown editor and you are good to go!
27 years isn't long enough? I'm not looking for a bandwagon. I'm looking for evidence that it's either extremely safe (e.g. airplane/rocket/self driving car software being built with it) or it's very productive (e.g. like python, a panoply of software that lots people use every day with it). Rust has a similar sort of approach, but the memory/thread safety it gives you for zero performance cost is massively valuable for certain applications. It's 2 years since it hit version 1.0 and it already has a better CV than haskell (firefox, bits of openDNS, tor, dropbox's storage engine).
Thanks. Can you think of a better idea for winning percentages? I know mine isn't the best. :)
Awesome!
nice! Small suggestion: rename your CODECODE file to game.py (or anything else ending in ".py") on github. That way, we'll get syntax highlighting.
Alright, I'll do that when I get home. :)
I’ll try to sit down later tonight and take a crack at it
It seems like some preallocation is happening. There is some pre-allocated space in the free list that can be used to store tuples up to size 20. Since this space is pre-allocated, all the program need do is initialize the points in memory and return pointers to them. Since this allocation is done at the start, it is much more efficient. So you have a free list of length 20, each index corresponds to a tuple of the size specified by its index. Index 0 has one empty tuple pre-allocated but the rest have 2000 pre-allocated tuples per index that can be used and re-used. 
And don't forget that in alphabetical order P precedes R.
`venv` was _removed_. You should use `python -m venv` for forward compatibility.
Thanks, that would be great. I'll also think about it. :)
Since this wasn't explicitly answered already, `virtualenv` is out of core, and predates the in-stdlib `venv`.
Yes? What about it? Does this really belong in r/Python?
One of my clients is running 2.500.000 lines of Python 2 code, written in the last 15 years. The ERP department's director told me she absolutely don't want even think to do the switch to Python 3, mostly because she hasn't the resources to do that, and also because it would be really hard to justify thousands man-hours of work for what is just a technical reason to the company's heads, in a non-tech company. Just to bring a real world example.
Yeah
I use it at work because we don't have sudo privileges and I want to use pip to install random libraries. Having my own anaconda install and 'python' aliased to my install fixes that. Other than that, can't really see the use for most people.
Why is java easier than c ? My peers(sophmores) hate java for its syntax. 
Same but a step better: print("Add a space between each token (number/operator)") expression = input("Math expression: ").strip() tokens = expression.split() if not len(tokens) % 2: raise ValueError("Invalid number of tokens") for num in tokens[::2]: if not num.isalnum(): raise ValueError("Input contains something besides numbers and operators") for operator in tokens [1::2]: if operator not in ('+', '-', '*', '/', '%'): raise ValueError("Invalid operator") print(f"Answer: {eval(expression)}") Haven't actually tested the code, just wrote it out of boredom.
Good work! Be proud of making something. There's always room for improvement, so keep improving on this (git is great for that) and working on new projects. Have fun!
Um... what? Part of the difficulty in programming is explaining what exactly you are trying to do. The same applies in asking people questions about programming. What would you like it to look like? What *exactly* are you trying to do? Have you started coding yet? If so, can you show us what code you've written?
I dislike it too. I think the main idea is it removes the complexity of compiling and linking mostly, also strings are much easier to explain than C even if they aren't as easy as Python in that regard. Our lecturer would give us a helper library to do the string stuff. 
I think the best way to go is with virtual environments. Miniconda can be really useful in systems where you have no root nor gcc access, or when you have troubles compiling C stuff. Just my opinion 
Thanks, the support has been overwhelming!
And?
lol, no, at no point in undergrad or grad school did we ever even touch on sockets. 
A crappy game? You've gotta start somewhere! I look back on old code of mine and shudder, but writing that code helped me get to where I am today!
Thanks, maybe I am a little too self-deprecating.
As much as you can, avoid installing python packages via your system package managers. Packages on apt and the like are usually out of date. Your OS may depend on the system python, so loading a bunch of arbitrary packages into it with clashing dependencies and so on is a bad idea. It's common (and recommended) to use a separate virtual environment (either a virtualenv or a conda environment) for each project you're working on. That way, it's easy to silo the dependencies of each, you don't poison the system environment and you can work with multiple versions of python on the same computer.
I think so too. At first I thought it showed what languages are more often used for work stuff vs hobby stuff, but then I reread the label on the y-axis and realized the apparent increases in JS/PHP/C# during Christmas and summer probably don't correspond to any actual increases. 
By that logic we should be doing everything in C...
Exactly.
Yup they don't go into opencv at all.
I guess I lucked out more than I realized in my program. My sockets experience has been useful on the job on many occasions. Thanks, Vermont Tech. 
But the downside to this is going to be that students won't be getting to know the core old school basics.Which imo everyone should know. 
Me too. It's a constant battle that I'm willing to fight
Yeah a lot of my team right now have a lot of issues with fundamentals of programming, performance, security, scope of variables...etc. I pretty much have been holding up the team since I actually know C and apply most of the lessons learned even to Python. 
you could do "pip install xxxx --user"
you forgot to post a helpfull link in case your instructions are unclear. http://lmgtfy.com/?q=adding+a+python+script+to+startup+on+linux
You can use [flake8](http://flake8.pycqa.org/en/latest/) and [flake8-future-import](https://pypi.python.org/pypi/flake8-future-import) to enforce consistency w.r.t. future imports.
Massive Python 2 codebase our entire business runs on. No business value in moving to Python 3 right now but it might happen at one point.
This is cool. I had school a project that we did something just like this in Matlab, I wanted to replicate the same thing using Python but wasn't sure how to go about it. One problem on our final exam was to take an image of a boat which had a green background, and remove the green background and place the image into a second image of a beach.
I'm working on [PortableWinPy](https://github.com/yn-coder/PortableWinPy) study project - portable web server for python web development. I've start this work to go deep to web server configuration. Now it's based on Apache and mod_wsgi, several new options is in a process.
It's hardly numpy's fault that there's a large swath of scientists that aren't aware of what tools are available to them to make their research properly reproducible. The solution to the author's problem is to train scientists to use just better engineering practices. It's not like these tools take much time or effort to learn, and the author seems to be complaining about scientists who are already savvy enough that they're using git and publishing their code. Most scientists don't even do that, and we should pressure them to.
Without a doubt. Don't just go installing random pip packages or you will likely end up breaking something. 
It is a mess. Nvidia is shit fir linux support. You just gotta sit down and read and learn. I find a lot of mixed opinions on how to do it on stackoverflow or the nvidia forums, but this way has always worked for me. I do the .deb driver installation because installing the driver from the cuda installer run file tends to cause a login loop. I use the runfile for cuda installer though because I don’t want updates messing with my cuda installation. cuDNN has terrible instructions for installing, but tensorflows website used to have instructions for that back in version 0.10 or so. I’ve just always followed those. But as far as I know wherever you put your cuDNN lib files, so long as it is included in your ld library path should work.
You should put a license before your code otherwise no one will copy paste/improve your code since it's technically illegal. Choose a license (like GPL, MIT) and copy paste it to your github account into a folder called LICENSE.
Really creative game, you did an amazing job! I wonder, how old are you? And if you're just starting to code, know that you're off to a great start! As the others said, it's a good idea for you to divide your code into different and specific functions. Later on, it would also be nice if you explored Python's object orientation by creating different classes e.g., a class for soldiers and another class for civilians. Keep up the good work and keep updating your code on GitHub so we can follow the evolution of the game.
I'm 16 years old right now. Yeah, I'll try make it better in the future so thanks for the advice! :D
Use [struct](https://docs.python.org/3/library/struct.html). Something like this: import struct bytes4 = struct.Struct('I') with open('filename.ext', 'rb') as file: data = file.read() print(byte4.unpack(data[156:160])) You may need to also specify the endianness.
I was just working on creating a Python based website blocker to help block whatever websites you stray into (one for Windows, and one for Mac- taken from a Udemy class I am currently taking)
Splitting the code into smaller chunks makes it easier to add more code.
Yeah. I ran into some issues earlier whilst trying to loop the code, so I went from having war(), commands(), etc... to just one giant blob. Not the best and I'll likely split it up in the future.
That sounds interesting, I assume you'd have had relevant schooling in how to undertake such a thing first? Did you nail it? 
We should and I'm one of them. They're not programmers at heart. They were never formally trained in how to code. You pick it up though. My scientific open source package is on github and it's 200k lines. I could complain about numpy 1.10s breaking of arrays, but I found bugs because of it. There is an emphaais by most devs to not break code, while striving for consistency. You have to move forward with packages. Practices like semantic versioning helps, but so does deprecation. If you're 5 years out of date, by all means, go for broke. When it fails and yes it does, try the version from 2 years ago and see if there are deprecation errors. If your code doesn't support a range of python/numpy/scipy versions, you have a bug.
Um well, it was a class I took last semester. Probably the hardest class I've taken so far. One of the classes they put in place to fail students and weed you out. Funny you mention the relvant schooling bit, because one of the things it felt like they were doing to us is giving us half the information we needed to know, and then asked us to do something with our code that we hadn't been taught yet. It required some heavy heavy googling and reading on your own to get through the course. However, I learned so much in that class, that I was able to go into the summer and start my own project where I learned python, javascript, ajax, and all kinds of other shenanigans in just a couple months. 
Which is ok, there’s so much you can do without it, but there’s so much more to image processing than manually calculating grayscale. Also tons of grammatical errors. 
I'm a beginner myself but I don't think that would be too difficult. It's pretty much exactly the kind of thing that Automate the Boring Stuff covers. I'd definitely recommend that. Depending how much time you have to dedicate to it you could get through the book in a month or so. 
That makes me feel like I started late lol. I started coding when I was 18, but as they say: better late than never! Now I'm a computer science undergrad, transferring to computer engineering next year. What do you plan on studying at college?
The most difficult part will be getting the information out of the emails, and coping with the scenarios where people don't send exactly what you are expecting.
Please don't say that you aren't good at coding. That was really good.
This is fun, I went to war against the United Kindom (playing as England) and lost 4000 men, I went to war with them again and they had lost nobody! Somehow I survived, and went on to attack Germany (with a healthy 106% chance of victory) then all out war with Rusia which I scraped a win at 1%. Good fun, I demand to be able to conscript more than 10'000 troops.
I'd avoid using the system package manager and the system version of Python. I view the system version of Python as installed to handle system processes and upgrades are subject to system administration patching. It's better to own and manage your own version of Python and its modules
Another piece of advice: try not to use "magic numbers" (arbitrary constants in the middle of your code). Instead, create another file with those settings. e.g. instead of if tension &gt; 50: try if tension &gt; settings.tension_threshold: It will be easier to adjust the gameplay.
Thanks, I see what you mean. I'm new to Python &amp; coding in general, so I'm trying to make it as simple for me as possible. :P
I think I've done that now. Thanks for the advice!
Not sure, taking up coding as more of a hobby. I'm more interested in humanities like history. But you never know, if times get tough. :P
Thanks :D Seeing what a lot of people talk about on this subreddit it really does feel that way though. Thanks anyway, it's nice to hear :)
Yeah, I didn't really want it to be too big though, since then you can just conscript loads of people and invade everywhere. As of a few minutes ago, I've added "money" into the game. You can now buy soldiers, it's an alternative to conscription. 
I have to redo our windows build toolchain for the CD at work (pyinstaller, lots of binary dependencies to build+install, all in a VM for less fragility), small team, not much time for this until it's urgent. And of course, porting the existing projects, or having to still maintan the old toolchain, that's what keeps me on python2 for now. But the time will come…
you might want to look into the [hidden_imports](https://pythonhosted.org/PyInstaller/spec-files.html?highlight=hiddenimports#spec-file-operation) parameter to specify modules that are not correctly automatically added to your package, it's often needed in my experience.
My boss refuses to update because why the hell should I have to put parentheses in my prints? My answer is unfortunately because you do. I agree, but of things to really complain about, that's not one of them. The only thing worth discussing is unicode. It's hard as hell until you learn the 3 rules, which are not ever clearly stated. 1. Bytes to strings = decode. Strings to bytes = encode. 2. Don't guess at encodings. Punt the problem to the user unless you have a good reason not to. 3. There are 91 encodings in Python 2.7 and roughly 3 you should consider using because you speak English and don't care about unicode. Latin1, UTF-8, and UTF-8-DOM. Your western data is more than likely in latin1. Your excel data is in UTF-8-DOM, which you call using UTF-8-sig because Python and reasons. 4. You can't fix unicode errors using Python 2. Once you do, you don't need to upgrade.
When I read this code it makes me think two things: 1) I wrote exactly this kind of code in the 1980s. The same kind of naive if statements and too-many-variables that a seasoned programmer would refactor into objects and so on. 2) My reasoning about the game mechanics of the games I made then were nothing like as sophisticated as yours. (Seriously.) Today I'm a software engineer. I work on a data processing pipeline that chews through some 700-900 million events a day. I invented a transformation language that my co-workers use to process these events, and many of them say they like it. My point is that you're showing more promise than I did early in my career. I was 7-17 years in the 1980s, but that doesn't really affect the point. If you can reason this clearly about your game mechanics now then the only thing that stands between you and better code is more practice.
These questions are better suited for /r/learnpython You need relative imports for this. Modules called `foo.foo` are confusing to explain, so I'm going to give you a slightly modified example: main_project/ __init__.py thingy/ hoodlum.py ferry.py martyr/ breakdance.py If you are outside of the package `main_project`, you would import them like so: import main_project # for main_project/__init__.py import main_project.thingy.hoodlum from main_project.thingy import ferry # also possible import main_project.martyr.breakdance Inside `main_project/__init__.py`, you would import the other modules as: from .thingy.hoodlum import BaseHoodlum from .thingy import ferry from .martyr.breakdance import * Inside `main_project/thingy/hoodlum.py`, you would import the other modules as: from . import ferry from .ferry import FERRY_COUNT from ..martyr import breakdance from ..martyr.breakdance import * I hope that helps.
Thanks for the insight! Thanks also for telling me your story - it's quite inspiring I'm glad to hear things are working out for you. :)
Kewl. A math suggestion, if I may... your war win probabilities won't be subject to edge cases if you instead use this formula for win probability: x/(x + y)
Why not just use the --user switch?
I don't know what age 3rd to 5th grade corresponds to, but I'm assuming something Primary. CodeClub have Python resources aimed at the upper end of Primary.
I'm compl unaware of it. What is it?
It installs packages to your $HOME/.local folder.
You have no idea how many people in my department have this issue. I'll check it out :)
Thanks, I'll look at implementing that in the next update!
Thanks! Yes upper primary. 8-11 years old.
I wrote a complete install script for opencv: https://github.com/whizzzkid/opencv-complete-build-cuda Installation: `$ curl -fsSL http://bit.ly/OpenCV-Latest | [optirun] bash -s /path/to/download/folder` Updates: just run the above command again, make sure to have the download path as same. 
Exactly the age group they're aimed at.
Ah, I had no idea that pytest just runs unittest out of the box. I'll definitely give it a go I'm not an actual developer, I'm on the operations side of things. You could say I'm in a devops type of role. I learnt the importance of tests after I had about 3 years of experience with Python. For some reason prior to that it was just never something that occurred to me, and not something that I heard about or noticed from other people, articles, or tutorials.
No pointers. No memory management. Try writing C for something real and you'll quickly see why Java is at least an order of magnitude easier.
So, I am not fully aware of the role operations play, I admit. I guess if you are in DevOps/ops, then I might give you a pass too :P Depends how much coding you actually did, I guess.
Nice! Congrats on your first game!
That's cool, and learning this stuff is just an extension of what you're doing now. Try this: * make a file, next to (in same folder as) your main file. Call it settings.py * add anything to settings.py that you want to be able to change easily later like maybe STARTING_TENSION = 0.1 * in your main file, at the top, add: from .settings import * * you can now set tension equal to STARTING_TENSION in your main file. * you can see how doing this for several different constant values would make your code lack what looks like random integers everywhere. Also when you wanna change a value, you go to settings.py an it's obvious, instead of having to edit random lines in your main app. * this might not seem necessary with a small project, but a bigger project will have many many things in the settings file, and maybe even different settings files (eg for development and production modes etc... Or maybe your game has a easy, medium, hard settings file with diff values and now your main file doesn't change, just settings files) None of what you did so far is wrong, all the comments in the thread are: "nice goin! Now try this, which makes your life easier on future/bigger projects" 
 &gt;&gt;&gt; for i in range(10): ... print("user-{}@server".format(i)) ... user-0@server user-1@server user-2@server user-3@server user-4@server user-5@server user-6@server user-7@server user-8@server user-9@server That should do the trick
As a pet project of mine, I have been updating an overlay library for Twisted from 2 to 3. The transition from string to unicode/bytestring has been a bit trying at times. Fortunately my pet project is an overlay and there are plenty of opportunities to patch in pre/post filters to consume a bytestring, decode it, let the application do whatever, and then encode str back to bytestr. From my professional past experience, a common incident comes to mind. There was a client that had this absolutely MASSIVE code base written in PHP4 that had so many semi-dormant modules of business logic that cost estimates suggested twice the company's average revenue would be needed to upgrade/refactor. Last one and I apologize in advance that this sounds malicious. There is a saying that if people stay in a company long enough, they will rise far beyond their level of incompetence. My biggest failure as a consultant/corporate trainer was to help a client's in house staff with transitioning from CGI to WSGI using a MVC framework. I thought they got it, it looked like they got it, but the implementation pilot project ended up being this nightmarish CGI like application shoehorned into a WSGI framework. Most cases it makes business sense to upgrade to new technologies and paradigms but getting the people who will make that happen to buy into the idea isn't straightforward.
You take coding advice really well, rock on
Well I'd start by learning some easy to use modules such as datetime. If you search up the docs for it you should be able to understand it.
Hi TurtleSpy4, It's always helpful to include your complete code and any error messages. You will get more help that way. In your example there doesn't look like any error messages...so a link to the entire code would have helped so others could see what the code actually should do...and see where some problems may be so they could help you better. I'm also just a newbie python coder...so the following suggestions may or may not help you. Given the code you gave...it looks like your code is asking for an input..."How many....". When the input question comes up...it should be waiting for your input. Try and input some number to test that... It should then provide the answer based on your input. Let us know how you solve it. Hope this helps you. Robert
This thread makes me glad to be part of r/python. Good job OP, and good encouragement and advice everyone.
So when you put total_secs = int(input("How many seconds, in total?")) this is a completed thought to the Python interpreter. You are telling the computer that the next thing you want is input. Because you're doing this in Idle, it is expecting this input immediately. If this were a python file, or you were writing it in a text editor (or whatever as long as it's not IDLE), it would reach that part and then ask for input but keep going. Here, it's doing the same thing, however you see EACH step of the program and it is expecting you to enter a complete and final thought each time. I recommend opening a text editor of some sort and entering the code in there. Then, once the code is constructed, you can save it as a .py file (e.g. "second-calc.py", or whatever you want). Once you have saved the file, you can then run the python file from that directory and it should ask you to input something because you have that line of code for input. Then the rest of the file, which is the part you are trying to write immediately after, will get read and will operate as expected. TL;DR IDLE is an interactive shell. So you are putting in multiple lines expecting it to accept it all, and it's expecting 1 line to be a complete sentence/thought/process/task.
The full code is 1 total_secs = int(input("How many seconds, in total?")) 2 hours = total_secs // 3600 3 secs_still_remaining = total_secs % 3600 4 minutes = secs_still_remaining // 60 5 secs_finally_remaining = secs_still_remaining % 60 6 7 print("Hrs=", hours, " mins=", minutes, 8 "secs=", secs_finally_remaining)" I cant even get to the second line. Im gonna follow Mitchell486's advice.
I'm gonna try a text editor. Would "Atom" be a good one? Again, sorry for the dumb questions. I just find it difficult to learn if i'm not getting my hands dirty. Also, it's strange that I cant test my code then and there to see if there's any errors. Like a missing = sign or if I misspelled something.
&gt; Too many people go around looking for external 3rd party libs before even knowing well how to use Python's. Guido's time machine strikes again.
You're kidding, no? Did you not notice how many questions on SO have a big green check next to them? That's the accepted answer. The question asker is supposed to choose one if there is a good answer. 
&gt; If this were a python file, or you were writing it in a text editor (or whatever as long as it's not IDLE), it would reach that part and then ask for input but keep going. Here, it's doing the same thing, however you see EACH step of the program and it is expecting you to enter a complete and final thought each time. Huh? IDLE has a text editor window. OP could write it in IDLE.
That works for user installs, but then it's going to the user's global environment.
You can just stay with IDLE for tonight. Just go File &gt; New File (or just hit ctrl-N) and it will open a text editor window for you. Write your whole program in there, save it, and run it with Run &gt; Run Module (or just hit F5). 
&gt; But I have trouble understanding where virtualenv comes in play. The usual advice when using conda environments is: don't mix them with virtualenvs. In reality, you rarely need to mix the two. What /u/vpz described was their own particular use case where it might make sense, but it doesn't sound like the kind of thing a typical conda user would be doing.
When do we get nukes Sid?
That's true! Good luck on your journey 
It WORKS. Holy cow.
Thanks for the full code. I see Mitchell's post suggesting you use a different editor...and I agree. IDLE and Spyder seem to be limited to one line commands and are much more difficult for beginners to learn to code and test with. But I don't know really since I don't use them. As for me as a beginner coder I found Jupyter Notebooks to be the best for learning to write and test code. It's notebook style lets you break your code into separate boxes to test each box...or run the entire code at once. And there are hundreds of great example Jupyter Notebooks available to download on almost any subject...science, finance, etc. Take a look at some examples to see how Jupyter Notebooks are set up and used. Using Jupyter Notebooks have been an excellent way for me to learn by running the examples and see what happens. Also search Reddit for other suggestions on the different Python platforms for coding and testing. There are lots of great suggestions here. FWIW: I ran your full code and it works fine # Full code is: total_secs = int(input("How many seconds, in total?")) hours = total_secs // 3600 secs_still_remaining = total_secs % 3600 minutes = secs_still_remaining // 60 secs_finally_remaining = secs_still_remaining % 60 print("Hrs=", hours, " mins=", minutes, "secs=", secs_finally_remaining) ----------------------------------------- How many seconds, in total? 86 Hrs= 0 mins= 1 secs= 26 Good luck in your coding adventures...and I may suggest that combining fun learning and patience is the key! Robert 
Hurray! You can actually stay with IDLE for much longer. Once you're out of beginner mode, then you might choose a more advanced code editor. But for now IDLE is fine. It will even color the code for you, automatically indent and dedent, comment in and out whole blocks, etc. Look at the menu in the text editor window, particularly under Edit and Format. Have fun.
Is Jamuary a country? 
I am learning python as well and half the time is taken up by "why the hell isn't this working?" followed by "I am not a moron, I have Googled this problem and lots of people asked the same thing."
One comment after quickly looking at the code: If you try to buy soldiers, but do not have sufficient money, you fail, and your money is set to 0. Is that intended? Logically, your money should probably be set back to what it was before the purchase.
That will be unlocked at a later stage, but you can also buy this with a microtranscation of $19.99.
Beginner questions are usually more welcome at /r/learnpython ;)
Yeah man, its good to be humble, but part of the joy of being a programmer is being able to be proud of the little things. Everyone is allowed to have those moments where you call a friend over and you say: “Hey check this out! Click this!” “*Okay.... what now*” “See that?! When you clicked it, it fucking **worked**, can’t you see the thing? I MADE THIS THING” Solving challenges and watching small parts become something cohesive is just beautiful. Be proud of it. That being said, cool game! Don’t be afraid to take an idea like this, keep the skeleton, and completely re-write it with tricks you learned along the way when writing it the first time.
I use pyenv instead of miniconda to manage my userland python installations. I find that pyenv is more flexible, much simpler, and most of all, doesn't periodically break pip. Nowadays all the packages I need install painlessly as wheels, and I don't need the conda package manager any more. 
It's true that non-python deps can be installed, but numba actually doesn't require llvm itself to be installed, because llvmlite (numba's dependency which contains the code interacting with llvm) already bundles the necessary parts of llvm in the offial wheels on PyPI.
I'm interested in your point. Could you please elaborate? 
This is very true, in my experience, but also not a good reason. People who have terrible coding practices that hurt everyone else in the community should have to face the consequences of bad design. 
Wow - so you can pip-install a package that uses `numba` and not require any additional dependencies? That's amazing given how performant `numba` is!
I've been programming for almost 30 years now and my code is still just a huge turd at times. Give yourself some credit. You've got to start somewhere. I'm just glad you're willing to make the effort and try it.Hopefully you can stick around and get great at it. 
 Type a command: !tension Your country's tension is 0 percent 
PIL and Pillow introduced some annoying features into the image processing toolbase for both SciPy and Scikit-Image, both of which used Pillow as a backend for a variety of operations for quite some time. A couple of examples off the top of my head: 1. Floating point images had to be within the range [0.0,1.0] which for scientific computing makes zero sense whatsoever. 1. The 'Anti-aliasing' interpolation feature in PIL was actually bilinear. Probably it would have been better if PIL died when it did and the Pillow fork was never made. 
You could move `num.append(...)` to before the loop and then just copy and paste `num.append(...)` above the continue inside the `elif numAsk is 'N'` indent. This should give you the same behavior if I understand what you are trying to do
I think people who are users of `pip` and `conda` have very different opinions from people who have to implement modules and deal with the `distutils`, `setuptools`, and `numpy.distutils` mess. I mean, even `conda forge` is pretty painful to use. And uploading wheels to PyPI is also a ton of pain.
Correct, was going to also note that. The if money &lt; 0 should probably add the same amount back that was subtracted 3 lines above 
&gt; Russia has an army of 50000 men. Your chance of winning is 22 percent. &gt; Would you like to go to war with Russia? &gt; 1=yes/2=no &gt; 1 &gt; Your troops are travelling to Russia... &gt; Your troops are fighting... &gt; Failure! Your troops were defeated, 14966 men were killed. &gt; As a result of your failure, your country's tension has increased by 5% &gt; The defeat cost you $500
Russia has an army of 50000 men. Your chance of winning is 22 percent. Would you like to go to war with Russia? 1=yes/2=no 1 Your troops are travelling to Russia... Your troops are fighting... Failure! Your troops were defeated, 14966 men were killed. As a result of your failure, your country's tension has increased by 5% The defeat cost you $500
You sir, are incorrect: https://en.wikipedia.org/wiki/B_(programming_language) 
**B (programming language)** B is a programming language developed at Bell Labs circa 1969. It is the work of Ken Thompson with Dennis Ritchie. B was derived from BCPL, and its name may be a contraction of BCPL. Thompson's coworker Dennis Ritchie speculated that the name might be based on Bon, an earlier, but unrelated, programming language that Thompson designed for use on Multics. B was designed for recursive, non-numeric, machine independent applications, such as system and language software. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/Python/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Check out the Young Coders program here, https://pyohio.org/young-coders/ They put on a great class for 5th grade and up and have done so over a number of years at quite a few conferences. I'm sure they'd have some good advice, contacts and possibly course material.
This is a free python lesson built on top of a minecraft style 3D game: https://craft.buzzcoder.com. We've used it in a local kids coding club and kids liked it much better than a few other lessons that we have tried.
First of all, this code is cleaner than most of my code. Everyone said it, so I'll just repeat: use functions, especially for buying units. Also, seeing this code made me inspired to make my own text-only game. I'm thinking cyberpunk detective thing. Thanks for showing your game, it's actually fun.
But first you have to unlock access to the World Market. This can easily be done through roughly 700 hours of in-game play time, or for instant access you can purchase the Trader Pass for only $14.99!
Why would you want to return to numAsk? You would just get stuck in a 'N' loop at that point. It seems alright to me as is!
Welcome to the wonderful world of Java applications.
That was really neat. I appreciate the visualization.
Thanks for the answer. Any insight on why use conda and not virtual environments ? 
Conda packages a python distribution, environments, a better environment specification system, and a python package manager in one - getting the same with virtualenvs involves chaining a bunch of different tools together. Conda also allows you to more easily install compiled components in the environment (rather than relying on system-wide binary libraries). I've found both virtualenvs and conda to be hit-or-miss: usually there's something that works in one but not the other, which then switches over within a few months. Virtualenvs are the python standard way of doing it, so I'd recommend going that way until you find something that conda makes easier. You may also be helped by virtualenvwrapper, pyenv, pipenv, and pyenv-virtualenv, which all contribute to making virtualenvs more convenient.
I would feel such a sense of pride and accomplishment if I could unlock it!
Stupid question: after installing miniconda, which python is used by default in the commandline ? What about other interpreters such as ipython and jupyter notebooks ?
You could use virtual environments
If you build a template email which is well structured, and put specific words and magic numbers in specific places, you can do several important things: 1) Verify that the email is a filled in copy of the template email 2) Pull the data out of the email in a structured way and 3) Flag the non-compliant emails for human handling (or bounce them and make the user resubmit) This is far from a perfect solution, but it gets the job automated quickly without requiring a lot of skill or programmer time. A better but far more demanding solution is an internal webapp which allows authorized users to input the hot-jobs information themselves bypassing the middleman. You will still need a human to monitor queue submissions for (potential) abuse of this process, but it's a lot faster than doing this manually and they need to do the data entry anyway.
Thank you for the thorough response. Could you possibly explain the concept of dropping one dummy column?
Wait, isn't that what .ini files are in most games?
This is one of the reasons I prefer super lightweight editors instead of fully fledged IDEs. vim and sublime work everywhere and startup nearly instantly.
If an army of 10000 and and army of 20000 fight, then the chances of player one are 25% (50*10000/20000) and the chances of player 2 are 100%. But that cannot be if the first player wins with a chance of 25%. Did I misunderstand something? If not, may I suggest to normalize your probabilities? E.g. by 100 * x / (x+y) and 100 * y / (x+y).
heres a link to make it easier https://repl.it/repls/EvergreenPlainAmericanlobster
 When ever I run the code it and enter my first and second number and add them together it gives me a huge string of numbers as my answer when all i do is try to add 1 + 1 together
These "problems" could be easily solved installed specific version of the needed libraries, they are not going anywhere. If you really want (or need) to use Python 2.7 with SciPy 0.98 after 2020, nothing stops you.
Yes,java is easier but college students those who are new to comp sci need to know about pointers and stuff. 
Without pandas, those projects wouldn't be getting used nearly as much. 
bump for help this is really hard for me lol
What you are missing is how much easier it gets to migrate when more people are doing it, at the same time it gets more expensive to maintain legacy. As firms adopt 3, fewer and fewer are covering the costs of maintenance. While newer better libraries become more and more unavailable to those who stay behind. No one is starting a new library in 2. Numpy is abandoning 2. Other maintainers will see less and less adoption if they only support 2. The writing is on the wall. 
Atom is a great code editor (I use it myself) but it is not an IDE* *atom-ide did recently release (finally thank odin) but it does not yet support python. You can still edit python code in Atom, you just cant run it from Atom (thats where the IDE comes in)
I guess my issue is if you're going to have a credible piece of software that you're going to use to produce scientific results, you need to validate that it gets the right result. You also need sufficient tests such that you don't have many regressions. It doesn't need to be unit tests, but it helps.
I'm going to have to look into this. TYVM for sharing.
This raises questions of why is this a desktop program..., but yeah, [S3](https://aws.amazon.com/s3/pricing/) or similar would be your best bet. [B2 is quite cheap](https://help.backblaze.com/hc/en-us/articles/217667478-Understanding-B2-Pricing-Structure), though note that it might be slower than the competition since it's intended for backups. It might be better to store the photos in fewer zip files and then download them. I suppose I'd be remiss, If I didn't mention [my employer](https://cloud.oracle.com/en_US/infrastructure/storage/pricing) offered this product, but it's not very accessible to small developers.
A few suggestions: * Go to "File &gt; Invalidate the Cache". If something was broken in the indexed data, that may "fix" it. * Do as PyCharm suggests and try to get the VCS integrations (i.e. Git or whatever) to not raise errors. Even if you don't use that feature, it might help loading time. * Try to mark directories that don't have your source code in them (virtualenv, build, etc.) as excluded (right click on them in the tree view &gt; Mark As &gt; Excluded). It helps reducing the amount of indexing to do. * Indexing will go through all the Python libraries installed with the selected interpreter, so working in a virtualenv with only the bare minimum dependencies will be way more efficient than using the OS-installed distribution (if applicable) From experience, the Community edition of PyCharm is waaay faster than the Pro version when it comes to loading time. And it will still do the cursed indexing every so often... A big pain, but 100% worth the IDE features IMO. 
Wow, I feel like this sort of info should be incorporated into the beginners lessons. I've been tinkering with python for five months or so and I never knew this. I wrote a SlackAPI program that checks for a file on a server. But in order to use Slack you have to have a token. I just put the token as the only entry in the file. I will not go back and change it to use the method you describe here. Thanks!
Started late??!! Dude, I'm 36 and I'm just now getting 'ok' with Python. Never too old to start.
Actually, shouldn't there be a check to determine if the player has enough money first? Doesn't seem logical to take money and then put it back if you didn't have enough. if total_cost &lt; player_money: spendmoney(item, cost) else: print('No can has cheeseburger')
I'm a software engineer developing on OS X &amp; Linux, primarily tasked with managing large data (~millions of records) &amp; data pipelines, and here's what I do for everything that's more than a one-off script (and sometimes even then): - I *always* Create a `virtualenv`. Using a `virtualenv` makes it much easier to manage dependencies, and know for sure what project requires which packages. Self-plug here: I wrote a small and (I think) intuitive wrapper for `virtualenv` that helps you manage all of your different environments. You can check that out [here](https://github.com/tomplex/virtualb). As a fun story, where I work, we have all of our ETL (extract, transform, load) code in one giant repository with no defined requirements, and we just had to migrate it to AWS. It was a GIANT f*cking pain because we had to go through each individual job and figure out what dependencies it has, and found that some of them required python 2.7 for two libraries (`arcpy` and another I can't remember) and also that several had conflicting dependencies, and since we didn't know which version of any package was installed, we ended up breaking some jobs where the package's API changed. I can't stress enough how useful it would have been and how much time we would have saved if we had tracked dependencies from the start. It's so easy too; just run `pip freeze &gt; requirements.txt` and you can easily install those requirements with `pip install -r requirements.txt`. - I create a `Dockerfile` and assume that my application / script will run in a containerized &amp; consistent environment, every damn time. This took some getting used to, but when combined with the above, it makes environment management MUCH easier. I don't know if you're familiar with `docker`, but it's a [really powerful tool](https://www.docker.com/what-docker) for deploying your software and ensuring that it will run in a consistent environment, always, and will run exactly the same on any machine with `docker` installed. This means that we have fewer production hosts which are "pets" - cared for and maintained - vs "cattle" - which can be stood up and torn down at will as required. - As for version control, I am fully on board git. I haven't used much of SVN/ mercurial, but git seems to be the industry standard, and knowing how to use it is, in my eyes, only a plus. At work we use the [github flow](https://guides.github.com/introduction/flow/) approach for adding features, but there's also [git flow](https://datasift.github.io/gitflow/IntroducingGitFlow.html), along with others, I'm sure. - I like to think that these days, writing tests is mostly standard in the development community. It's helpful to know that your code is going to do what you expect it do. I really like `pytest` for that, but the built-in library `unittest` is definitely OK. Using `unittest` feels like writing Java for Python to me, so I tend to avoid it. - It's worth looking into continuous integration / continuous delivery (CI/CD); basically the concept is that you're building your application as often as possible, as well as running all of your tests and detecting merge conflicts or errors as early as possible in process. This means you're rehearsing your release constantly, so when you have to release, it's not a big deal. At work we use gitlab as our code repository, so lately I've been using gitlab's pipelines for automated builds of my application's `docker` images, as well as running my tests. It's useful for much more than that, though. I LOVE that when I submit a pull request, anyone reviewing it can immediately see my tests and if they all passed, as well as pylint scores. I've used Jenkins for this before as well with mixed success; it works fine but the integration isn't as streamlined. - As far as alternative interpreters go, there are a lot of options. To be honest, I don't really use iPython or Jupyter too much; though I've used them before I tend to prefer using [ptpython](https://github.com/jonathanslenders/ptpython) or [bpython](https://bpython-interpreter.org/), but that's just me. Since all of our data lives in postgres, I tend to visualize data in that environment and not in python. Your milage may vary, though. Jupyter and iPython are generally preferred in the data science / analysis sectors. - I haven't used much of conda for managing environments. That's also sort of a personal choice. Hopefully someone else can speak more to that here. Anyway, I hope that helps. Also bear in mind my use case for python is probably going to be different than someone who uses Django all day for web development, or someone who uses Python for data analysis exclusively. This is just my general approach. TL;DR 1. Create virtualenv 2. Create `Dockerfile` 3. Write code 4. Write tests 5. Profit 
Ha! Jokes on you! The only have 1 Dalek, not 50,000 men. Chance of failure - 100%
Thanks spaztiq :) Check out the other videos on my channel as well when you get a chance - https://www.youtube.com/channel/UCd2Boc12Ora42VIJBULz0kA
Your very welcome. If you're interested, the code used to generate these is at - https://github.com/ryu577/base/blob/master/numerical/python/visualization/Animation/CubeObjects.py
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [ryu577/base/.../**CubeObjects.py** (master → 2c1a9aa)](https://github.com/ryu577/base/blob/2c1a9aa00a8b7715099cf142f5b68b1cc55ae027/numerical/python/visualization/Animation/CubeObjects.py) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
I've used airflow and luigi, and I personally found luigi easier to wrap my head around &amp; implement quickly. Another alternative is to look into messaging. I use [rabbitmq](https://www.rabbitmq.com/) and [Amazon SQS](https://aws.amazon.com/sqs/) for data pipeline orchestration; to basically break down all steps into microservices waiting for work to come in, performing it, and then notifying the next service in line that it's got work it can do. This has the advantage of being easier to parallelize &amp; scale (in my opinion) than Luigi (can't speak to Airflow).
That may be true for data science, but not for physics, biology, chemistry, signal processing... I could do my work without pandas, but not without numpy.
Let's see: - You've not only written some random code, you've made a game! That is, whether you consciously did it or not, you did some **game design** (you thought about the rules for your game, tried to balance things so it's not too easy nor too hard, etc.) - You've **learned how to use Git** to do versioning, and to push your code online so that people could provide feedback - You've already **listened to that feedback** and made some modifications Programming is not only about writing code. Your game is a great project to learn a bunch of new stuff and to learn from others. Congratulations! There are several next steps that you can take: - refactor your code. Right now there is only one huge fonction that does everything. As you've probably already witnessed, it's a pain in the ass to debug something in this. Try to create smaller functions instead. It's easier to debug later - write some tests ([official doc](https://docs.python.org/3/library/unittest.html), [Python Testing website](http://pythontesting.net/)). This allows you to always check that your game works even when you add new features or modify existing ones. This will also force you to think about some corner cases. For instance, I mistakenly answered `n` to the question `Would you like to go to war with the USA?`, and the game crashed! (`ValueError: invalid literal for int() with base 10: 'n'`). If you had written some tests, you would have thought that maybe someone could enter not only a number, but a character or even an emoji! ;) - once your game will be working smoothly, make it graphical! This is not an easy task, but it's a very rewarding one! Keep up the good work!
I highly recommend going with pipenv. It takes the ideas from other successful package managers like npm or cargo and applies them to pip and virtualenvs. https://docs.pipenv.org/index.html
I coudln't Defeat Russia :/
I'm still fairly new to virtualenvs and docker so forgive me if it is a stupid question, but why do you create both a virtual env and then a docker container? Isn't it easier to just create a docker container and use/develop the feature on that?
Here are some of the scripts I talk about when introducing people to Python and scripting: - Sorting a music collection based on artist. - Creating a spreadsheet (CSV) of stock prices using some api. - Email reminders when disc space is running out. Also, depending on your audience, especially if it's in a professional setting, there will be a lot of domain specific use cases. For instance, - Getting lat, long of a folder of images and generating a file to view on Google earth. 
Awesome! The only thing I suggest is adding Unix type of clear screen
Not a stupid question at all. The truth is while I pretty much always deploy in Docker, unless what I'm writing requires a ton of dependencies, I'll usually develop locally and only use Docker for deployment. It also depends on whether I'm adding a feature or starting fresh. If I'm adding a feature then usually my Docker tooling is set to run the application in production and it can be easier to run locally to test stuff out. Finally, I'm still pretty new to Docker myself - I've only been using it in production for a little over a year, so I'm still trying to decide on the right work flow. And when it's only two commands to create a new virtualenv with all the packages, meh. Might as well. 
I always update my main packages (not osx software tho) because i like the new features and bug fixes. sometimes the API changes break my code so i need to go in and fix it which sucks but I think is useful for code that you plan on using again and again. i don't like having code that only works with deprecated versions. that being said, it sucks going in to fix code that was working perfectly . networkx 1.0 to 2.0 perfect example
&gt; NOTE: I AM NOT GOOD AT CODING. So don't expect this to be good. At all. I think I'm quite good at programming, but - games made by /u/Brumafriend: 1 - games made by /u/misterlight: 0 Remember this. 
Thanks, the support has been amazing!
Thank you! I'll fix that asap.
Yeah, I'm trying to make it hard but possible. The problem is that the game can just snowball if Russia was too easy to defeat. I.e you win one war and then another and another, etc...
You missed what is probably the most important point in my comment: they would be doing this even if the total cost is higher - and it would be a sound business decision. The risk and disruption are more significant than expected total cost. 
If you just want working solutions, they can be easily found in the docs. Something like this, as an example: int('011', 2) # == 3 '{:b}'.format(int('5')) # == '101' If you want to do it by hand for the learning of it, I would suggest r/learnpython, but make sure to format your post correctly before posting.
I'm a new to python, but something i noticed was : &gt; army = army + 100 which is the same as: &gt;army += 100 cool concept!
Foyles, Tottenham Court Road and Waterstones, Piccadily Circus both have a decent range of Python books. That being said despite them having the best range of books I have seen in person, the range is much smaller than on Amazon.
Since this is the most extensive answer, I'll hijack the thread and ask a small question here. Do you use any tool like CloneDigger for big projects?
And any specific technical suggestions or opinions would be appreciated!
Also, if that's at all close to your real directory structure: please remember Python isn't Java. You're allowed to have more than one class per file, and more than one file of code per directory. Creating the kind of directory structure you've shown here will just cause you to repetitively type things (like `app01.app01.App01`) when there's no need to lay things out that way.
Made it about 5 seconds in, had to stop watching due to lack of pop filter.
Glad to hear you fixed your immediate problem. I get my students to use Pycharm it gives a lot more help with spell check etc. 
I hear digital oceans spaces is similar to s3 but cheaper. 
The university bookshops in Cambridge had a good range too... But probably no better than any other uni town. 
Is that all in one file? 
Not bad dude, let me show you a thing I wrote for an RPG a friend was running sometime last year, it may give you ideas on how to frame menus etc. Download all into one folder, and run SWoN.py https://github.com/Jeanhaley32/SWoN
also, I have no idea what i'm doing, and this is the first thing I made after reading like 1/2 of the Python Crash Course, so there are probably other ways to do everything here way more efficiently. 
&gt; IDLE and Spyder seem to be limited to one line commands... I know IDLE works with backslashes, and also indenting is supported.
Going to check this later
It's pretty neat. Unfortunately I'm not savvy enough to comment on the code, but you should post it to r/gis as well to get a different point of view. 
Reported 
Will do - thanks for the suggestion!
My previous workflow was based on python, virtualenv-wrapper, vim with vim-bootstrap, and git. I'm transitioning towards VS Code, which also integrates things like pylint. You can also make it play nicely with jupyter, including running the matlab-like blocks.
post links homie
I agree this is amazing! The dependency to one exact llvm version was always a concern for me. By the way, those stand-alone llvmlite wheel packages have only been out for a few months now, it's a recent achievement of the numba maintainers.
New line
How does it compare to conda environments?
This is what I have done on MacOSX. Remove *export PATH="/Users/user/anaconda3/bin:$PATH"* from the *".bash_profile"* file or comment it out. Your system *Python* is now your default Python again. Now create a new profile in your terminal which will execute the bash command *export PATH="/Users/andre/anaconda3/bin:$PATH" &amp;&amp; clear* at activation. As soon as you want to work within the conda environment activate the alternative profile. Good luck. I hope you get a solution that suits you. 
That's pretty cool. I've used blender for a while and am just learning python, so that will be a good playground to learn in. Good post.
Around 0:18
Nice. Glad to help.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/gis] [Open-sourced a library that converts a Shapefile, GeoJSON, or CSV to an equal-area hexgrid cartogram. Suggestions and criticism appreciated.](https://www.reddit.com/r/gis/comments/7dss7h/opensourced_a_library_that_converts_a_shapefile/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Only if the required python version is available globally 
nice :)
A bit off topic, but choosing a real editor (PyCharm, Win, EclipsePython) makes a difference (although the lack of static typings doesn't help). I've used emacs for years and then switched to one of theses editors and when it comes to refactoring, it really helps.
Not to complicate things more but running Docker on your host machine and having a special DockerFile that uses a volume to your hosts project directory is awesome too. It’s allows everyone else on the network the ability to do UAT and makes sure you don’t forget to update the requirements (since the build would crash and burn if you did forget).
Fragrance commercials are still weird in trying to be artistic, at least some things never change.
URI *obscurer* 
There are no private methods in python. The only "convention" is to mark methods you don't want people to call by starting with an underscore. I've never seen any standard method ordering, so I think it boils down to personal preference. 
&gt;There was a client that had this absolutely MASSIVE code base written in PHP4 that had so many semi-dormant modules of business logic that cost estimates suggested twice the company's average revenue would be needed to upgrade/refactor. But you don't just "refactor" as one large end-goal project. You make sure everything in is in source control. That's not a big deal, just git init, commit, and you're done. From there, any function/module you work on, you write a test case for. That's the first thing you do. Whether it's new code or old code. Make sure that module is outputting exactly what you're expecting. Up to this point. There is nothing that shouldn't be happening on a large codebase anyway. The next step works with that. Now, while still in that function/module, refactor it for the upgrade. Obviously make simple optimizations here too. If you see some copy/pasted code rip it out and write a proper function. Your test case keeps you safe. When you are done you should be able to run it and have successful tests for both py2 and py3. With test coverage you'll have exact numbers that let you know how much code is yet to be converted. Just through regular day-to-day maintenance you will get to the point where the majority of your code is converted, and will eventually hit a point where you just push forward and get the rest done. I'm not sure why so many people in this thread are so proud of their house of cards. You should never be afraid to change your code. With all the version control, testing, and refactoring tools we have today, no code should off limits to a little optimization.
It's the standard recommended by PyPA, the pipfile is much more replicable than a conda env yaml, and it handles switching to and from environments.
Given that you said that you will be using Python for scripting and machine learning I'm going to give you a different perspective to many presented here. I use Python for data analysis, but also maintain a couple of larger packages. I seldom start off thinking "I am going to write a large piece of code, let's fire up a virtual environment, get a package going, etc". Mostly I am sent/come across some data which I want to answer some questions on. I will create a folder and start off in a Jupyter notebok just loading up the data and playing with it a bit. The notebook environment makes it very easy to iterate on simple visualisations and simple exploratory analysis. At this point, I'll be working in my root Anaconda environment where I've got all the packages I've ever needed installed and kept at the latest version. Only when I have a good feel for what I'm going to need to do, I spin out some of the cells which haven't changed in a while to a module which I can import into the notebook. Sometimes I have already answered the questions I had and I just call it a day. If it is clear this is going to go longer than "just" a single analysis notebook, I'll also initialize a git repo and start committing to it. As the project starts maturing (now keep in mind this could be just in the space of a couple of days) I'll start thinking about how different files fit together, and figure out which dependencies I want to keep. This is when I create a new conda environment with just the stuff I'm using at the time. I also think it's when there are more than two files when I'll start using PyCharm instead of just a simple editor like Atom to wrangle the project. I'll also start introducing tests when the functions have matured a bit. I have converged on this workflow because I have found going through all the motions described in the other posts just to get the first look at the data makes me not even want to start. I think there are plenty of failed experiments, where you think something is going to work but it doesn't, and I want to make the investment into the initial experiments really low so that I don't have a lot of inertia keeping me from trying different things. I agree that for larger projects having a virtual environment and testing and a "proper" IDE set up is vital, but all projects are small before they are big, and many of them never go beyond what can be very easily handled in a single notebook. I've also got many small Python scripts which I use quite similarly to small bash scripts. These work with whatever my system Python is and usually depend only on the standard library. They do small things like moving files around or small bits of data cleanup (for instance I have one which converts CSVs to be semicolon separated so that Excel on my Mac can work with them). On the very bottom end I also use IPython from the commandline (as I always have a terminal open) to try out small code snippets and perhaps do some small things that are hard to do in zsh by itself. I make quite a lot of use of blending shell commands with Python from IPython by using its ability to store results from the shell commands in Python variables (`file_list = !ls` will store the results in a list). This allows me to go smoothly from just `head`ing a text file to see what it looks like to building a notebook around the initial results to finally packaging it up and allowing others to reproduce the workflow.
I don't know this full answer, but I did write a [blog post](https://medium.com/@mgarod/a-workaround-for-private-scope-in-python-classes-bf8100927ab1) that might be of interest to you regarding private members for classes 
dunder will mangle the names, so make it very hard to call those methods but not impossible
A single leading underscore is meant more as “protected”, and are often intended for extending classes to be able to call or override, but as you mention not called from the outside (except in some cases like `namedtuple._asdict`) A double leading underscore is more of the “private” construct where any extending class shouldn’t call/override and the method/property gets “name mangled”. That basically pretends `_ParentClassName&lt;original_name`. So `__foo` in a class called bar would be `_Bar__foo` iirc.
I don't use ipython or jupyter notebooks so can't comment there. But I use the same shebang line and my scripts work with my miniconda envs. I have 4 envs and about a dozen of my "double wrapped" virtualenvs and no issues with that shebang.
I've been using vscode for some dotnetcore stuff (omnisharp-vim was a huge pita), and I actually like it. If the vim key binding plugin was better, I might actually switch. I could learn all the keybinds they define, but it's hard to teach an old dog new tricks. Though, I will say neovim's terminal feature might be enough to keep me firmly in the vim camp since I can yank and paste between buffers and terminals easily. The only sticking point there is forgetting I'm in the neovim terminal, shelling to a server and starting vim there and now I have nested vims. Whoops. 
A good sendaway for them may be to link them to [Automate the Boring Stuff](https://automatetheboringstuff.com/). The entire purpose of the book is really useful things for non-programmers to get the creative juices flowing.
Trying to get started learning python this week :). Any good resources for this? I've started with the code academy course on it. 
the dunder serves a very specific purpose, and should be used sparingly, just as metaclasses. It's not meant as a "private method" construction.
IMO static methods are a code smell. Ideally avoid them. I usually follow the principle of https://en.wikipedia.org/wiki/Cohesion_(computer_science) when it comes to the question of where to put the method - i.e. put it as close to other related things as possible.
**Cohesion (computer science)** In computer programming, cohesion refers to the degree to which the elements inside a module belong together. In one sense, it is a measure of the strength of relationship between the methods and data of a class and some unifying purpose or concept served by that class. In another sense, it is a measure of the strength of relationship between the class’s methods and data themselves. Cohesion is an ordinal type of measurement and is usually described as “high cohesion” or “low cohesion”. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/Python/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
it's because of this https://www.theverge.com/tldr/2017/8/31/16234342/ai-so-hot-right-now-ysl-alexandre-robicquet 
You’re confusing two leading underscores (a convention for signifying a private) with dunders, the “magic methods” in python with is two leading and two trailing underscores. The former is what this discussion is about. You can read about the convention of leading underscores for protected/private usages [here](https://docs.python.org/3/tutorial/classes.html#tut-private). Regarding protected (single leading underscore): &gt; However, there is a convention that is followed by most Python code: *a name prefixed with an underscore (e.g. _spam) should be treated as a non-public part of the API* (whether it is a function, a method or a data member). It should be considered an implementation detail and subject to change without notice. And “private”: &gt; *Since there is a valid use-case for class-private members (namely to avoid name clashes of names with names defined by subclasses), there is limited support for such a mechanism, called name mangling.* Any identifier of the form __spam (at least two leading underscores, at most one trailing underscore) is textually replaced with _classname__spam, where classname is the current class name with leading underscore(s) stripped. 
Thank you for your detailed answer ! *Concerning the scripting part* For scripting I find it convenient to use the system provided python and installing different modules that allow me to interact with the system (dbus, alsa ...). I don't think that using virtual environments or conda will make things easier for me, though it may avoid breaking the system python distribution. However, using the system package manager (not pip) to update my python distribution and modules allows me to have packages that are deemed stable and secure by the the linux distribution maintainer. I might stick with this for the moment, even though I will probably try to play with conda/virtual environments to test them out at some point. *For the machine-learning part* I do agree that trying things out first on a jupyter/ipython notebook is a great way to test an idea, even launch a small project. Your workflow seems perfectly viable to me. In fact, the most important thing IMHO is that you are using anaconda, which is kind of a virtual environment since it is independent from the system provided python. As another suggestion, it is true that setting up an environment for every small project/script might be overkill. But it might also be relevant to not use the root conda environment. For instance, I could create an environment for testing/playing with data, and then create an environment for each particular project which seems to get bigger.
I would argue that it's best practice to always use virtual environments, even when inside of a Docker container. [This post](https://hynek.me/articles/virtualenv-lives/) changed my mind.
Nice idea. I would * Deploy it to pip. * Fix the English in this sentence "ObjectModeler is an open source library for define object models in applications." * Add clear explanations in docstrings on all of the modules, classes and methods. * I'm not so sure about PrettySlotsObjectModel as a name. A simple "ObjectModel" might be better. * It's not so clear what happens when you feed an invalid dict in, also. Does it try its best to serialize it and throw away data it doesn't like? Does it throw an exception? Does it run it through a schema of some kind? * Find some other libraries that do the same or very similar things and compare them (ideally favorably) to yours.
Well, the base problem is not the code, but the logic of the program you came up with. For current set up: You do not need 'else' at all to just state that the program does not understand user input... You should check if the user typed in the answer you expect (number,y,n) via exception handling and not an else statement. And you should ask the user about inputting another number only after you check the 'thing' he already input is a number. That would eliminate the need for the else in the way you have it.
Look up Sentdex on YouTube. 
Thank you for your answer. For the moment I remove conda from my `PATH` and use the complete path to launch it : `~/miniconda3/bin/` I am considering adding aliases in my .zshrc (and/or .bashrc) for the commands that I am using most that is `conda`, `activate`, `deactivate`. Not sure this is the best way, but it might be the easiest for today
No. Some things you're going to keep in mind that will determine the difficulty: Is the email in a standard format, or do people just type the job number and description? Is the job number a standard format? Is it an integer or a string (as in, does it have letters in it)? Is there any other information in the email? Again, is this standard, or do people just type whatever they want? Is the customer info tied to the job number in the server? Or tied to the email address that sent it? Or tied to the name? Or some other unique identifier? What type of data structure stores the information on the server? Does the output spreadsheet need to be new every day, or are you updating an existing one? Is this report sent out in emails, or stored on a shared drive? If its on a drive and you need to make a new one every day, what is the directory structure or naming convention? Is the spreadsheet excel or CSV? Depending on the answers to these questions, this could be 10-15 lines of code or a couple hundred. Maybe more if I didn't foresee something Also, I'm assuming there is security with regard to the server you get the data from, so you're going to have to automate retrieval of the data in a secure fashion. All in all its pretty easy, not trying to intimidate you.
Nifty! If you can figure out how to make make a game like this, you can learn anything in programming. One thing you might consider is using a [class to represent countries](http://anandology.com/python-practice-book/object_oriented_programming.html).
if you read what you have posted you'll see that you're saying the same thing. I just used the _dunder_ term to refer to the double underscore, which is very clear, I think. class-private is different from the concept of "private methods" from other languages, which is what the post is about. Its purpose is ONLY to ensure that you're calling a method from the same class instead of an overriden method, and not to represent visibility on the public interface. The method is still public, only mangled with the name of the class. 
I can't make it through his videos. I'm sure he is knowledgeable, but the pace is way too slow. I'm probably beyond most of the starter videos available but not far enough to fly on my own. I need concepts and ways to approach problems in a pythonic fashion instead of "type this and then this happens". I know enough of that to look up what I need on stack exchange. Is there anyone who explains more python theory than the mechanics of coding it? Someone who can explain *why* to code a certain way and the tradeoffs involved? I've learned a lot from Raymond Hettinger lectures. Who else should I watch in that vein?
Your audio is overdriven and distorted. Don't kiss the microphone. Move it away from your mouth.
glad you enjoyed it! good luck with learning Blender! it's amazing that a completely free and open source tool has so many features.
I have some feedback for you. * First off, I'm 18 and I've been coding for about a year and you just shattered my self esteem, so give yourself a pat on the back. * I've noticed that in the code, you're doing the money transactions before checking if the player has enough money and then adding it back if there isn't enough money. For example you have the parade command. Instead of doing it like this: if parade == "1": money = money - 10000 if money &lt; 0: money = money + 10000 print("You don't have enough money") You could do it like this: if parade == "1": if money &lt; 10000: print("You don't have enough money.") else: money -= 10000 It's also the same for buying soldiers. You're checking for money after the transaction. * I'm sure you've already started doing this because almost everyone mentioned it but you have a lot of the same code with slight variations that you could compress into one function. Overall great job and very enjoyable game...looking forward to your next project.
Nope. Android doesn't use OSS, it uses ALSA, and you won't be allowed to access that, because you're supposed to use the custom AudioFlinger API instead. You can use some of those APIs through [androidhelper](http://kylelk.github.io/html-examples/androidhelper.html).
Thanks for the insight and advice, I'll look into it!
I don’t usually copy and paste anything. I have the cells set up with what I’m working on, and set the breakpoint in my regular text editor. When jupyter runs the cells and hits the breakpoint all the usual debug commands are available. e.g n, s, l, c etc There might be a better way though!
Scientific/Research Software development. Here is what I use for a simple package: GitHub Conda Vim/Sublime/Pycharm on Ubuntu LTS Testing with py.test and Travis CI Documentation on ReadTheDocs Packages to custom anaconda channel and pip
Thanks for the insight and advice. I'll look into it.
Which is why it’s “conventionally” _private_, and not reserved for only metaclasses (but any base, or mixin).
Don't do `pip freeze &gt; requirements.txt`. That hard codes the versions of all dependencies. You should only list packages that you specifically brought in and let them handle their own dependencies.
Thanks for the feedback, will keep that in mind for the next onr.
Sorry to hear that. Will try to add it.
Thanks for your reply. Regarding scripting using the system Python, I've never been able to live with that as I use a Mac day to day and that has Python 2 as its system Python. Yuck. Having to use BSD tools is bad enough. I've thought about the root environment thing a lot and even interacted a bit with the Anaconda devs on the mailing list about it. The way I see it I usually want the latest versions of packages so that I can and I delegate responsibility to the Anaconda maintainers to make sure they don't introduce breaking packages frequently. I feel like I am just as likely to introduce a breaking change (like the networkx 1.0 to 2.0 someone else mentioned) by upgrading packages in my conda environments as I would be when upgrading in my root environment. The fix is similarly simple in both cases as well, if I find I have two projects that require different versions of a package, I can create a new environment _at that time_ and by specifying an older version of of Anaconda I can get the packages as they were at that time. I guess which workflow works the best for you depends greatly on how many projects you have, how big they are and what their lifetime is. For large long-lived projects the benefits of virtuals is very clear. For small ephemeral scripts I don't see the use. Another way of putting it is are you more annoyed by import errors when you try to import the cool new package you've been using in another project, forcing you to drop back to a shell, install the new package into this environment (and also running the same risk of having upgrades breaking your code) or by silently breaking an older project by upgrading your root environment. In a way there is a symmetry with "look before you leap" vs "its better to ask for forgiveness than permission". If you have environments for every project, you're guaranteed not to break them retrospectively, but you build in a lot of difficulty if you want to update all the packages in all the environments. If you just update your root environment you have to fix breakages from time to time.
You might be able to fix it in audacity, bring the level down and try a low pass filter, maybe a pop filter. TBH it's probably faster to just rerecord. It's only a few minutes long. Pay attention to your level meters and listen to the result carefully. I used to record the news every morning for my college radio station. Fun stuff, audio engineering.
That's the thing with url shorteners.
This is just for a small project that'll be running on a raspberry pi and small screen and just display scores, stats, etc. Is Qt/ PyQt what i want to be using or should i be using something else?
Read the title - simple image processing
Where did I say it's reserved for metaclasses? I said it's a niche feature, like metaclasses. You should seriously learn to read... 
The typical layout (although this is just from seeing other people's code) seems to be Default var list (optional) __new__ override (pretty rare) __init__ (common) __magic_methods__ override (__add__, etc) __private_methods (not really private, just mangled) _semi_private_methods 
[ponder]
[How far do you want to take this](https://en.wikipedia.org/wiki/List_of_programming_languages)
Cool! Well crafted Readme. I took a quick glance at your code and, while I am no expert at all in cartography, I can give you some advice on Python itself. - Package your code and make it pip-installable. - Use docstrings. - Trick: dictionaries for keyword arguments can be written cleanly with dict(key=v(alue') instead of {'key': 'value' }, saving you the hassle of quoting keys. I am on mobile, so sorry for not providing any links, but you get the idea. Hope you find it useful! 
https://github.com/mitsuhiko/pipsi looks very cool for the desktop script-tools domain. I had been doing something similar by hand, but this is better. Thanks for the link. 
Ah ok it's recent - so I haven't just been living under a rock! Using the `@jit`decorator in numba is the closest I've seen to 'magically get C-performance out of a python function'. I remember trying to optimize a function with cython for over an hour (slowly adding checks and types) and just writing it plainly and using `@jit` *still* beat this version by a significant factor.
That's really cool.
In case anyone reading this doesn't know about it, I suggest using [PythonTutor](http://www.pythontutor.com/visualize.html#mode=edit) for visualizing code step by step. It helps see what went wrong and exactly where. 
Very useful! Thanks for the suggestions - will fix soon.
If you're going to have multiple projects, including machine learning, then the example you posted is a good place to start. I would take a look at [this video](https://www.youtube.com/watch?v=cY2NXB_Tqq0), which is a more in-depth and updated example of that workflow, including how to handle multiple projects. I started using it a few months ago, and it's worked well. I believe the same channel has videos on how you can throw jupyter in the mix, but, if not, it's very easy to do, since you're still in Conda.
&gt;That hard codes the versions of all dependencies Well, yes, that's the point. Otherwise it might be hard to reproduce the built later on.
On top of everything else I've seen here (some really solid advise), I must say that one of the things that boost my producitvity by quite a bit is using vim and tmux (terminal vim inside of tmux). Vim makes editing a much faster process, which is good because it not only gives you more time to think about issues, but once you're fluent you won't have to lose your mind of thought over a tiny edit (that takes 10 seconds and little thought in vim, but 40+ without it). Tmux means that it's easy to very quickly toggle between your editor and the command line.
If they’re convinced /u/wiz21b to engage in volunteer guerilla niche marketing on reddit, and we’ve been convinced to watch the advertisement, and this has a marginal increase in purchases of French perfume, then it’s a success. 
Siren may suffer from unfortunate naming: https://en.wikipedia.org/wiki/Siren_(codec)
_private_methods are not mangled. That is __private_methods.
Will surely have a look at that, !Remind Me 3 days
Added subtitles.
Nothing of that conflicts with what he said. Read it again. 
Added subtitles if that helps.
The English word is “interesting”. 
I also went from C/Cython-Extension for math-heavy code to numba and it was both much easier to write/manage and faster while running.
This is pretty basic. Export the spreadsheet as a csv or tsv text file, parse it in python, and use the os or shutil modules to move the files. If you need additional help, try Google and r/learnpython
Instead of adding miniconda to the front of your PATH, add it to the end. The system Python will remain the default, but you can still use all the features of conda environments/etc. the way they were designed. export PATH=$PATH:~/miniconda3/bin
&gt; Does it try its best to serialize it and throw away data it doesn't like? No, iterates only defined fields. &gt; Does it throw an exception? No, just silently ignores. &gt; Does it run it through a schema of some kind? No, just it checking for data type and try cast to defined type Defined types may be several. I updated readme, added pypi, refactored code and added more docstrings, thank you very much!
Thanks, being a common name, I don't find it so surprising. Still, I didn't know about the codec. I added a reference to the hypermedia format, so it should be clearer that is about that and not the audio codec
Re-recording is not an option at this point since the video already has my highest view count ever. But definitely need to pay some attention to audio. Thanks for the pointers to the tools, will check them out.
That's why I put it on 1.5x speed
The other problem is when you install from a wheel it some other local source, but requirements.txt isn't smart enough to know that, so trying to reinstall from that later will look for a pip module that isn't in the registry and then fail to install. Happens a lot for cross platform development, some modules exist on Linux but not Windows and vice versa. requirements.txt should just be a time saver so you don't have to type it each requirement. It shouldn't be used to guarantee matching environments. There are more comprehensive tools for that.
Anymore for anymore? I will open this up a bit more, So what I need is someone to implement request payment by e-mail from the Coinbase API. It needs to handle everything from Authentication so I can just import my own API keys, Bit of error handling as much as you feel is needed. Email from command line or text file, I don't mind either way now. https://developers.coinbase.com/api/v2# If anyone is interested please feel free to get in touch. For a python programmer it should be fairly straight forward I imagine. 
&gt;No, just silently ignores. Ok, that's bad. It should fail loudly if anything about the data you've initialized with is invalid.
Gotta ask the classic startup question: what problem are you solving? What advantage does this give me beyond having PyCharm, Terminal, and HipChat open next to each other? I remotely collaborate with my coworkers on occasion, but not enough to justify getting me to ditch those three. It seems like this is a *very* ambitious project. Have you considered writing it as a plug-in for Atom or PyCharm? If the feature you want to build is remote collaboration, try to avoid re-inventing the wheel by writing an entire IDE around it, find a way to focus on the problem you really want to solve using as much industry standard that's already available as you can.
Note that using the dict(key="value") is a function call and not a direct assignment. This is significantly slower and I would consider it bad practice.
Fail.
In this sidebar of this subreddit you will find [Automate the boring stuff with python](https://automatetheboringstuff.com/)
Appreciate your insight. I'm going to give Luigi a shot - I had some issues myself getting started with Airflow. Big downside for me is that Luigi doesn't have scheduling built in but I might be able to do that using cron jobs anyway. Any resources you'd recommend for learning Luigi outside of the official docs? Thanks again
also jupyterlab
Looks like this is the source code: https://github.com/llbricks/224nproject/blob/875bb9de395c6d26d03ec339e83cbbd205c7f332/code/qa_model.py
This is another good point. There's actually an issue in the pip codebase discussing solutions to these unintended uses of requirements.txt: https://github.com/pypa/pip/issues/1479 This article makes some good points too: https://medium.com/@alonisser/things-i-wish-pip-learned-from-npm-f712fa26f5bc
There are very few tutorials that I *don't* watch at 1.5-2x speed. Usually the information density is so low that it is almost a waste of time not to. 
&gt;* I heard [bcrypt is a good hashing library, but too slow for Python. Is that true?](https://stackoverflow.com/questions/11393564/bcrypt-in-python) Computation intensive algorithms like hash functions should not be implemented in python but in native code. In fact the library linked in the stackoverflow is just a python wrapper for a library written in C. sha512 is just a faster hash function than bcrypt. &gt;* For the website itself, is that flow fine speed-wise? When it needs to login a user, its going to have to fire off a request to the server which fires a request to the DB and whatnot, then do it backwards. I'm not suggesting having the hashes stored on the server itself (bad), but is that general procedure for how logging into a site works? * Get the hash and the salt from the database. * Hash the password + salt * Compare the generated hash with the stored hash Login and signup don't have to instantaneous. It's ok if it takes a second or two. &gt;* Will look into sql injection; I think you use primarily stored procedures to mitigate right? If you always use stored procedure for variables, you should be safe. 
&gt; Get the hash and the salt from the database. &gt; Hash the password + salt &gt; Compare the generated hash with the stored hash Is this done in this order? For the python alg being done natively in C, is there a preferred library/alg to do the actual hashing? What's the standard tooling for this that you'd suggest? Also, thank you. Seriously; super helpful. 
Is it free?
If you're able to use python 3.5+ (even 3.4 supports some of it), the type annotations features are a godsend for the lack of static typing. Most IDEs that are python aware have some level of support for them, and adding them makes the IDE's intellisense features much more robust. Definitely worth using if you're able to.
No. Its value is $200 but now just only $10 due to discount coupon. 
Conscripting was a little confusing at first, because didn't read the instructions to see that it's your *army* that can't be over 10,000. I was like "I haven't conscripted 10,000 people!" :) [My Russia strategy](https://pastebin.com/3PkpBByq) (spoilers).
Yeah, sorry. I'll make that more clear :) Yeah, if you do that then you'll win 1/3 games lol. Gonna make it a bit harder, i.e more countries and mechanics.
Automate the Boring Stuff! Maybe Learn Python the Hard Way but don't take it too seriously...
Mind sharing your girhub? Sounds interesting.
Hey do you have a favorite examples / tutorials for setting up Docker + Python + Gitlab CI/CD? The few I found from google weren't great!
Related project: http://www.grantjenks.com/docs/diskcache/index.html In particular: diskcache.Deque and diskcache.Index which have the same API as collections.deque and collections.OrderedDict in the standard library.
Yes, errors should never pass silently, but it isn't error. I'll try to explain in details. If during initialization of the object not received all the required fields, then will thow exception. If some field failed to cast to appropriate type, then will throw exception. If received some undefined field, then just will ignores, because it undefined for object. Maybe it's another object and developer wanna get only part of it, I don't think it's error. I throw exceptions only when get error, like incorrect type which failed cast, or not received required field, or invalid a data type on serializing or someone try add new field in model, which can't modify structure (slots-based). But when receive some undefined field - I just ignore it :) 
Sorry if this is already an option, but it looks like it's placing the hexagons at a central point for each country. Could you use a closest packing algorithm to maintain the general geography but account for larger countries?
Use shutil.move if you are on python 3!
This is unfortunately a bit too ideal for reality and using the word "should" is usually where things breakdown. Assume there are no unit-tests, factor in that there have been at least three "generations" worth of developers who worked on this big ball of mud over ~8 years with none of them leaving notes beyond incomprehensible inline comments, and last assumption is that not only is the codebase at the threshold of being unmaintainable but further features need to be implemented in the next quarter for the company to continue making a profit. This story is unfortunately not unique. &gt;I'm not sure why so many people in this thread are so proud of their house of cards. Some sort of stockholm syndrome/battered spouse dissociative disorder? 
Hm, I don't, but I sort of just felt it out and did a lot of experimentation. I should write up a blog post about it, I was looking for something new to work on. 
This was released this week for [Atom](https://blog.atom.io/2017/11/15/code-together-in-real-time-with-teletype-for-atom.html) and announced for [VS Code](https://code.visualstudio.com/blogs/2017/11/15/live-share).
Yeah I'm understanding what you're saying. That makes complete sense. What I was thinking was to have a platform where you don't have to switch between screens to do all those things and it was especially inspired by situations such as a competitive coding challenge where you have to solve a set of problems as a team. And when I was looking for such an existing solution during my last competitive coding event I didn't any with all these features. But I realize that making an Atom plugin for it would be a much more efficient way to go about it and I'll try doing that. In fact I deliberately didn't go that way in the beginning because I wanted to exercise my Django and web development skills and later had myself believe it was good enough for short-lived fast-paced coding scenarios such as competitive coding where you don't need much of an IDE, and I still believe it does have some audience there. But thanks a lot for your time and feedback!
I've actually never heard of that before; it looks pretty cool though. I will look into it. Thanks for sharing! 
Nice! I might have to pull this in to some of my tools. 
Whatever you do, **no one** post anything about forking or dongles!!!
For the use case where you're writing a web app, absolutely this is a good idea. At work the major web app that we use for internal data creation and validation (written in node, though), we have three environments: test, staging, production. We deploy all new features to the test environment before merge into master to so that reviewers and users can perform UAT and we can give feedback to the implementer. Once it's merged, we deploy to staging to allow a select few users to check it out and make sure that everything goes smoothly in more in-depth use. Finally, once a feature is stable in staging for a couple days or a week, we deploy it to production so it's accessible to all users. 
This is precisely why I hate video tutorials for this sort of thing. Just give me some text I can skim through, a couple screenshots, and the code. Video is a waste of bits--I'm not on a metered connection, but my DSL is slow, only 12 Mbps.
Yes that would be the general algorithm. You don't actually want a super fast hasing algorithm. If you're database gets stolen, you would want to make it hard for the attackers to crack the password by making it expensive to run a brute force attack. Argon2 was the winner of the password hashing competition, have a look at it: https://password-hashing.net/. One of the python implementations is here: https://argon2-cffi.readthedocs.io/en/stable/. I'll say it just in case: don't allow user credentials to be passed over http, only https.
No problem, innovation is always fun to see. Keep it up!
[removed]
At the moment it's mostly a horrible mess of testing and not really coherent or functional enough to be sharing, but I'll let you know if that ever stops being the case. 
And you missed my most important point, the distribution of disruption is relatively well known (getting more well known as time goes by) while the distribution of stagnating on 3 is fat tailed and skewed. 
Check out pygame. You can put together the skeleton of a simple side-scroller, and walk them through changing things like speed, gravity, etc. I've done workshops for beginners, and it always seems to go better when I can abstract away the details by having objects for managing each part. For example, you may have an environment class that manages gravity, bounds, and general movement. Another class might represent objects or player characters and their position, Sprites, etc. In each class, clearly mark areas to be changed and use an IDE that highlights docstrings. Also, it's often easier to give them completed, excruciatingly well documented code, and let them play with it than to have them write their own. Even something as simple as a variable might be unfamiliar to them if they haven't seen algebra yet. You will need to guide them through almost everything, and you will get blank stares if you can't immediately show the link between some code snippet and the result. Stick to simple things that let them count, adjust numbers, or add personal touches like names, text, or images.
I would love to see even a bare-bones write-up, do you have a link and I'll bookmark it to check in another time!
Great answer! Seems to be working the way I want for the moment
It sounds like you are still pretty far from being employed as a programmer. You need to learn more algorithms. There are web sites that have coding interview questions for you to practice. Build a real product to demonstrate your skills. I think a small web site would be great since you can send the url to others.
That is really helpful! Thank you. 
"NOT GOOD AT CODING", "NOT GOOD AT CODING"… really. This isn't production code, so if you are neither the kind of person expected to do so, nor is that its purpose, why are you worried? Of course if I review your code like I do at work I'll be a bit disappointed… but why don't you just ask on /r/learnpython what's the proper way? - Refactor it into understandable chunks - Test it - Package it (Google "python packaging tutorial" or "alice in Python project land") - Use a proper command line argument parser (argparse, click, I don't care) - Put a shebang in it Come back in a month or two.
Kind of a shame atom has just come out with a plugin for this and VScode's is on the way...
You on Python 2? 'cause if not, non-rhetorically, why are people still on `virtualenv` and not `venv`? Now if you use a wrapper, I do hope it knows better.
So now you've hidden the system Python from every other script that depends on Python. Congratulations on breaking everything else. Not all scripts hardcode the path to the Python interpreter, which they shouldn't. `#! /usr/bin/env python3` anyone? Instead of installing anaconda or miniconda against packaging convention, why don't you put it somewhere other than `$HOME`? It's not a dumping ground? - `/opt` - `/usr/local` (ugh) - `~/.local/something` - Use `pyenv`+`pyenv-virtualenv` (really venv or conda env) to both abstract that away, and not put it in `$HOME`
That's absolutely true, I had that problem when I added some forks from github. Had to manually update requirements.txt by doing `pip freeze` and diffing it with the current requirements.txt.
Docker can be used for all sorts of things, it'd be a bit weird to have a "how to use Docker and Python together" type of blogpost. Though I guess a showcase would be nice. I'd suggest just playing around with docker on the command line, and you should be able to figure out usecases once you know the basics.
Consider checking out tmux. I have it configured using different colored bottom bars depending on where I am, so it's easy to avoid nesting too deep :)
&gt;too slow Wrap your hashing layer in a thin abstraction layer so you can swap it out, either in a IoC pattern or with some other mechanism for changing it. After that, crunch the numbers. How many times will your users go through the full authentication procedure before being handed back a session identifier? In a lot of cases using a SQL input sanitizing script with the salt stored outside of the database in code/config files, most SQL servers have hashing functions that will trounce what you could accomplish in your application. Last point, with MSSQL, it is possible to incorporate mcrypt as an serverside function. The procedure I've been recommended is something like: #creation Receive a username and double copy of the password. verify username is unique verify password matches itself In a MSSQL stored procedure salt = hash the username OR use a builtin unique id function insert new user record using the declared salt to hash the password as well as storing the salt in an adjacent column. #verify/login using something like `select * from account_tbl WHERE `account.username=="input_username" AND account.password=hash("input_password" + account.salt)` and of course use a trust SQL library to sanitize inputs either on application to avoid injections #opinion The idea behind salts is to neutralize the time savings of a rainbow table attack after the database has been compromised, forcing an attacker to take their rainbow table, hash each value using the stored salt, and maybe find a match. To really fuck with a theoretical attacker, a second, code side salt could be used as well, but that gets a bit crazy/complicated. #Thoughts on SQL/schema and codebase synchronize tools. ~10 years ago I used a tool like this http://www.liquibase.org/ for keeping database side stored procedure and schema synchronized with the rest of the application. Most DBA's love and hate this because the good ones are extremely territorial and will follow the developers down a dark alley and gank them if they try to make production database changes BUT for smaller shops without devops/dba's it makes life easier. 
So, I didn’t take a look at your code, but one organizational thing that would be good as you work on the library is to tag any releases to PyPi using semantic versioning, and to keep a change log as you make improvements or changes to your library. It helps users and yourself stay organized! 
That is a great answer! Thank you!
You might have to go in a specific direction. Maybe web programming, network programming or data analysis. Go with django for web programming. It fits your current level, judging by the form of your question. You can find tutorials on youtube. Search "the net ninja" or "brad traversy" channels.
I use tmux as well. I'll probably look at configuring it that way. My usual work flow on projects is to use tmuxinator to create a one command start for the projects (e.g. start all containers, tail logs, run tests, etc) and also spawn an empty split at the bottom that I use for any editing or commands I might need to run. However, since neovim has its own terminal and splitting, I end with inception levels of terminals (more if I end up running/execing into a docker container). Terminal -&gt; Tmux -&gt; Neovim -&gt; Terminal -&gt; Docker. It's possible something is incredibly wrong with me.
Thanks for sharing your general workflow. I'm glad that someone with such a different perspective took the time to provide a detailed answer regarding how they work, because it's honestly fascinating to see how different the use case can be. While I work with data a LOT myself, I don't ever really do exploratory analysis - I'm mostly just generally managing it. This is part of why I love Python so much - the language is flexible enough to allow such a difference in tooling and workflow. 
You can use simple http server, and a single directory where all html is saved. It's just `http.server` in python3. 
I am actually looking into data analysis for a start. But, I will take a look at the others to see where I may reside. Also, into it I really want to set my sights into Machine Learning. I hope that helps out more.
Sure, this is my website: http://tcaruso.com/ I've only got one blog post right now, but I'll get working on this one ASAP. Thanks for the idea!
Thank you for the suggestion! Will add versioning and a changelog soon.
I did not quite get how a closest packing algorithm would help account for larger countries :-) If at all possible, could you provide a description or screenshot of what an ideal output would be like?
Maybe I'm describing it wrong, and maybe it would change the scaling of the map too much. But I'm envisioning the left side of the map with the countries packed edge to edge like they are on the right side. So there wouldn't be hexagons spread out in white space on the left side where the countries are larger. 
Sweeet great info 
Got what you meant. Will try to add an option to cluster together countries that border each other other, such that whitespace between them is minimized. Thanks very much for the feedback!
Cool! Looks like a great tool. Very nice work!
I understand your statement. I had indeed asked myself : should I propagate advertisement or not. Retrospectively, it wasn't that bad for I doubt the target of this commercial covers a lot of the reddit/python audience. My proposal was a bit more like : "see, Python is so ubiquitous that it ends up in very unexpected places". Definitely not some guerilla marketing, I have much more interesting things to do.
You can if you aren't socially inept and understand how to deal with the consequences :-/
Have you installed it with `pip` in Terminal? `pip` is like `brew` for a Mac, but only for Python libraries. On a standard config, `pip install numpy` should make it available globally. Or checkout [pipenv](https://docs.pipenv.org/), which works more like NPM in a JavaScript project, and makes libraries available only to individual projects, rather than installing everything globally.
I assume you've tried openCV?
Thanks! This is exactly what I was looking for. Do I have to run pip every time I close terminal or will running it once be enough?
For plain ol' `pip`, you just install a thing once and it's there forever. For `pipenv` you install things to an environment, and then you fire up that environment only when you want to work inside it.
Hello, OpenCV is a library for image processing and I'm not using images here. I already got the information of the moving objects as a vector (height, length, width, direction and speed). What I need is a physics engine to run a collision simulation :).
Thanks!
The web server part is just this: create your files in a folder with the first page named index.html and run `python -m http.server 8000 `. What you need now is a simple tutorial on creating html pages.
Pybullet is a good contender 
Please elaborate. You don't need any programming language for a very simple website. But if you still want to use Python then use a framework, otherwise it's not going to be simple or easy for that matter. If you just want to learn then read about [WSGI](https://www.python.org/dev/peps/pep-3333/).
Write fucking English 
Hmm, is `bpy.ops.rigidbody.object_add()` acting on the last added mesh? Isn't side-effects like that pretty poor api design?
For the mobile users, please provide proper clickable links.
it's mentioned here https://wiki.python.org/moin/PythonTestingToolsTaxonomy
1. Avoid using Classes if you're writing performance-critical code. Instead use dicts for data structures, functions, and modules for name-spacing. 2. Use `multiprocessing` and don't share state between threads unless you have to. Sharing state is a pain in the butt. 3. Don't use decorators. They might seem cool, but they're a pain to debug when you inherit other people's code. 4. Learn how to use unicode properly in Python 3.x. 5. Learn how to distribute python projects with setuptools, pip, virtualenv, and FPM (Effing Package Manager). 6. Learn Django, Jinja, Requests, SqlAlchemy, Lxml2, and IPython. Any Python software dev gig is going to expect you to have at least a passing understanding of how to use those libs. 7. Learn how to interact with database drivers. 8. Version your code at your projects' top-level `__init__.py`. 9. Install your project to a virtualenv and vend your dependencies so that its easy to install and manage your dependencies. 10. When you're gauging your app or project's performance, don't obsess over it. You should also not ignore it. Get an expectation in writing from your customer or product owner and then write tests that check for it. Lots of systems or kernel folks tend to think that only compiled code can be "fast" -- for some definition of fast. ___ For later: * Fix a bug in Python. * Write a C-Extension for a Python project. * Become a part-time contributor on your favorite Python project.
I have to create a new app for work, one with a Django backend and a React.js frontend. I've never worked with React and have very little experience with javascript. So I am trying to learn both this weekend. This also involves learning how to use django-rest-framework and I'm currently converting one of my projects to these new technologies. 
Save them how? To a file? https://www.guru99.com/reading-and-writing-files-in-python.html
Intership? 
the issue is I'm not sure how to access the javascript element result set after the page loads this data. 
Maybe I can help? You can just do driver.page_source after it loads and that’ll be the source HTML for the whole page, which you can parse later. As for getting specifically only in the table from the beginning, I’m not sure.
Use the [bcrypt class from the passlib library](https://passlib.readthedocs.io/en/stable/lib/passlib.hash.bcrypt.html?highlight=salt). 1. Send the password as-is, to the server. **In production, this means your site must use HTTPS by default**. You can use [HTTPS Everywhere](https://www.eff.org/https-everywhere) to install HTTPS freely and easily on a production site. There is no excuse. 2. Upon user registration, use `bcrypt.hash` to hash the password and store the result in the database 3. Upon login, fetch the stored hash for the given username from the database, and check the given password with `bcrypt.verify` Don't worry about the salt, it's auto generated by passlib and part of the string it returns, so that when you call verify on the same string it knows what is the salt. The bcrypt library in Python is implemented in C (but has a pure Python implementation, which passlib won't use by default). Carefully read the entirety of [passlib.hash.bcrypt documentation](https://passlib.readthedocs.io/en/stable/lib/passlib.hash.bcrypt.html?highlight=salt) before proceeding.
A lot of good answers so to try and summarize. The goal is reproducibility from the ground up to make it trivial to push the application to a service like AWS's virtual machines. Having all of the recipes outside of Docker makes it easier to figuratively press a button and voila the project is online.
Now we got Numba, Cython and Numpy results for comparison https://github.com/rochacbruno/rust-python-example#new-results
Reminds me of the anime 'Kobayashi-san No Dragon Maido'. One of the MC's is a full-time Python programmer \^\^
driver.page_source is not valid. is there another option for that ?
https://stackoverflow.com/questions/27411915/python-webdriver-how-to-print-whole-page-source-html It’s the .page_source of your instance of webdriver
okay got that to work, but it doesn't catch the javascript result set
How does the HTTPS Everywhere browser extension install HTTPS on a server? I think you are confused about a user who uses a https:// domain vs a server admin actually setting up https.
Are you sure? Did you print it to terminal and check if it was there? If it wasn’t I’m not sure because I’ve never encountered this. If you send a link to the webpage maybe that would help.
If it can help. 
Another user mentioned that doing this without something like Django or Flask is a bad idea. That I shouldn't just yank a Hashing library and handle the rest myself. I'm absolutely unfamiliar with this entire domain (Python and web servers, but not new to programming). Would you say it's a bad idea to do it this way as well?
My statement is made in amusement, not with derision. I originally was going to say _accidental_ guerilla marketing, and wish I had. :)
That's cool man! I really liked the heatmap of which wines were crossed the most.
In general that’s what prepended underscore means, but IIRC `namedtuple` methods are prepended with an underscore so they don’t conflict with attributes, not because they’re supposed to be protected. I remember reading that in some mailing list thread about them but I could be remembering incorrectly.
Yeah, I found the same thing, regarding _asdict, when I looked (I think Brian Okken pointed it out on Twitter). It breaks the “Special cases aren't special enough to break the rules”, but maybe convention isn’t really a “rule”. 
Home brew is another good one if you're looking for a tool to curate a whole python environment and keep it up to date. I generally use homebrew and pip3. Gets me by with IDLE and Jupyter environments :). Unless you need them, I'd just find what works for you and stick with one until you see a need for something else. 
I think a lot of people still just don't know how versatile python really is/can be. There are so many tools to optimize plus the rate that new ones become available. I've met so many people that don't even know about numpy, let alone things like iPython, or other specified optimization libraries/modules. I can't wait to land an internship and learn more about python. It's such a large world with so many tools available to optimize things and write good, solid code. 
Most of my pandas work has been really simple so far, but I was pretty proud of my first deque usage today to quell my curiosity. Had to remove rows from a dataframe with non CA addresses and already had row indexes. Easy as: while d: df.drop(df.index[d.pop()], inplace =True) 
What have you tried? https://github.com/tweepy/tweepy /r/learnpython
regex is what I'd suggest for dealing with any text. There may be a better library by regex is what I know. Other great ones like numpy and pandas have been pointed out. The Jupyter ipython environment is great too. I'd also suggest collections. Things like deques can be super helpful. Learn the other data structure like dictionaries, and sets as well. Each data structure offers benefits and drawbacks. Finally don't forget to learn about interning and equality vs identify in that pointers get used a lot and it can help or hinder you. Knowing when something is or will be a pointer is important ! 
Very nice! Pls consider uploading to https://notebooks.azure.com so others can run/clone it? thanks!
Well done, and nice writeup! You did a great job with the visualizations. I also really enjoy web scraping. I have a couple of unsolicited comments about the code. First, I would hate to maintain it. It would be impossible to test or troubleshoot. `HouseOfWineScraper.extract_wine_data()` really needs to be broken up. You nest a lot of functionality, such as the return value for `HouseOfWineScraper.number_of_wines()` and other things. There aren't enough comments either. I hope you take some time to clean this up now, while it is fresh in your mind, because future you will loathe current you for writing this. Great job for sure though. I don't mean for my comments to be mean. I purely intend to help.
A word on working on jupyter notebooks: Always start with `%load_ext autoreload` `%autoreload 2` to automatically re-import every import when its source code changes. This makes it possible to interactively develop a module in tandem with the notebook, and have the notebook pick up code changes without needing to restart the jupyter kernel all the time. 
Now analyze python with 1000+ Greek wines.
IPython. End of Line. https://www.quora.com/What-is-the-difference-between-IPython-and-Python-Why-would-I-use-IPython-instead-of-just-writing-and-running-scripts 
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/dotnet] [IronPython and the DLR will be joining the .NET Foundation!](https://www.reddit.com/r/dotnet/comments/7dy2vi/ironpython_and_the_dlr_will_be_joining_the_net/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
More specifically, ipython notebooks. Easily the fastest way to play around with code, and it's a tool that will grow with you from beginner to expert. I've been using ipython since before there were notebooks, and I currently use it every day in the terminal for trying things out or running quick tasks, and in the browser for data processing, presentations, exploration, and all sorts of stuff. IPython is the best programming tool in my arsenal, no exaggeration. 
Thanks, I'll give it a try.
From my Udemy classes this is what I am building Build an interactive dictionary Webmap creation with Python and Folium Website Blocker Website with Python and Flask Building a Desktop Database Application Webcam Motion Detector Scraping Real Estate Property Data from the Web Building a web based financial graph Building and data collector web app with PostGreSQL and Flask Student Project on Building a Geocoder Web Service
Do you mean stop the shutdown command from working from the terminal or just stop the terminal itself from being killed? Be very specific.
I want to stop the terminal from being killed. Just make my friend suffer of a five-hour long spam without there being any way that he escapes it (except opening something else) 
IronPython has been slow to get to 3.x. Do you know if they are working on that?
Pycharm
Okay. Are you referring to the Python terminal specifically or the computer's standard shell? 
The computers shell... 
Okay. First of all, that probably isn't Python so I suggest you find out exactly what OS he is running and then ask a subreddit devoted to that OS.
MacOs... So if I run a python script with a section that is not Python; it runs? 
I'm not really sure what you mean but you are definitely going to want to find an OS X subreddit.
Oh well... not even a way to open an annoying number of finder windows?
I'd stick with IDLE, it's perfect for beginners. It keeps things simple so you just have to worry about writing the best code you can. BUT, if you're feeling a little fancy PyCharm is your go to. It makes life a lot easier. You can get the community edition free, you can get the full version if you pay an arm or a leg or if you're a student you get it for free :) 
Thanks for sharing! Those are some really beautiful plots, I love the style.
Do you really need a 3D engine for path planning? Why not just use a 2D approximation? There's plenty of examples out there for that. https://github.com/llSourcell/path_planning_demo_live https://www.youtube.com/watch?v=XflBhg6tq5c
I honestly have no idea. You would need to ask someone who is more familiar with OS X. I suggest you try a different subreddit.
Careful putting arcpy on aws. That might get expensive ;)
Ha, that hasn't moved yet. We're looking at ways of replacing some of the functionality with other tools / libraries. We're 99% a postgis shop anyway, so other than time required for refactoring theres pretty much no reason to have it as a dependency. Biggest issue is figuring out how to create a geodatabase with domains using other tools. 
Not by drinking them either. You have to type with the wine bottles. 
Mmmm. That's not how PATH works. The solution I provided does not hide the system python or break anything. Try it out and see for yourself. 
I wouldn't say significantly slower, but yes, nonstandard and probably bad practice.
Would you be interested in a pull requests? There were a couple things I saw I would like to help with. * Restructuring in this common format: https://github.com/audreyr/cookiecutter-pypackage * Some minor readability items. I didnt want to do anything before I found out if you are interested or not though. Thanks!
Check out pyqgis (and qgis in general)
Pycharm is good but busy. I prefer a combination of vscode and ipython
the first time i read through the csv docs, i gave up. then parsed it by hand. it worked, so i saved it for future use. came back to it eventually, and condensed 3 functions into one for loop. it worked but the thought of using the csv module didn't cross my mind until I read this. just read the csv doc again but this time its a lot easier to understand :D however, i am proud to say i never tried to parse json by hand.
Would absolutely be interested in (and grateful for) pull requests! Please feel free to create one. 
I renamed and tweaked the recipe posted [here](https://programmingideaswithjake.wordpress.com/2015/05/23/python-decorator-for-simplifying-delegate-pattern/) (with credit in my opening comments)
[removed]
yes, IronPython 3 targets .NET 4.5 and .NET Core 2.0
REGular EXpressions RegEx 
Thanks, but this doesn’t address my question. 
You should give pyquery a try. It provides a jQuery-like interface for navigating the DOM. I find ut much easier to work with than BeautifulSoup.
I’m gonna give this a look, thanks for the suggestion! 
You shouldn't really advice people to import *, this person is just starting out, so ideally don't teach them bad habits straight away. I know this is just a small game so it doesn't matter *that* much, but it doesn't mean we should be teaching bad habits if we can avoid it. The issue with import * is that if you lint your code with something like pyflakes, it can no longer track unused imports and unused variables, so you lose a lot of the value from linting. It's best to be explicit when importing. Also, I didn't check the code in detail, but another thing I would like to point out is to try to avoid using os.system() as it can lead to shell injection vulnerabilities, you should always use os.Popen().
I've been experimenting with Numpy and OpenCV lately, so I've been coming up with a new challenge for myself each week. This week I wanted to create a program that would encrypt a message and embed it into an image, then upload the image to an image hosting website like imgur, and finally re-download the image and extract the hidden message. The hardest part was designing the algorithm that was capable of generating a matrix of points in any size image, to insert the hidden message into, and then be able to re-generate the same matrix of points to extract the message. [Here's an image with the preamble to the US constitution hidden in it.](https://imgur.com/a/Atlb1)
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/eR6VMp6.jpg** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) 
I hate to be the asshole... but someone's got to say it. This sounds like "help me do my homework".
I really like Microsoft Visual Studio Code. It has most of the features that are included with most "full-featured" IDEs like pycharm, but seems to run much more smoothly.
I’m creating an animation exporter to games. 
https://realpython.com/blog/python/vim-and-python-a-match-made-in-heaven
I know that it's pretty limited at the moment, but I just started it today and have never done anything in micopython before. If you are interested in helping out, just shoot over a pull request!
Alright! I sent one in for pep8. Im going to make one for the project structure next :D
* the lxml parser is pretty fast but kinda shit * the BS *API* is slow You may want to give a try to using the lxml API with [html5-parser](https://html5-parser.readthedocs.io/en/latest/) instead. 
Great! Just merged your pull request. 
This typically the kind of project where I think to myself "This looks simple. I could have done it too." But I didn't :( Great job! It's really interesting.
I want to see it in Unity3D
I really want to use micropython but threshold to start using it is so much higher than arduino. Arduino has good documentation and an easy to use GUI while micropython requires an investment of many hours to get up running to do simple stuff. Why on earth do projects that has this high potential not focus on making it more beginner friendly?
What are your needs?
https://www.reddit.com/r/Python/comments/7dqvwj/domino_effect_in_10_lines_of_blender_python
IDLE.
&lt;html&gt;&lt;body&gt;Hello simple website&lt;/body&gt;&lt;/html&gt;
The way I manage it is as follows... note this requires you to deactivate the environment before executing `conda_off` ``` function remove_from_path { directory_to_remove=$1 PATH=:$PATH: PATH=${PATH//:$directory_to_remove:/:} PATH=${PATH#:}; PATH=${PATH%:} } alias conda_off='remove_from_path ~/anaconda3/bin' alias conda_on='export PATH=$HOME/anaconda3/bin:$PATH' ```
It's definitely a good (and recommended) idea to use frameworks that will do the job of user authentication themselves, especially if you don't know much about the subject. But I don't know about your requirements and the tools you can use. If you can use Django I would suggest to go with it. It has a whole user system which will make you life easier (and your system secure).
Yep I mixed up the two things. Edited.
While drinking them
You can find the source .ipynb notebook here (too bad Jupyter &amp; Pelican mess each others CSS and formatting is a bit off). https://github.com/Florents-Tselai/greek-wines-analysis/blob/master/greek-wines-analysis.ipynb
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [Florents-Tselai/greek-wines-analysis/.../**greek-wines-analysis.ipynb** (master → 5054d01)](https://github.com/Florents-Tselai/greek-wines-analysis/blob/5054d01956d5d0f5ff068f2becd3cb8659c8c7f1/greek-wines-analysis.ipynb) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
You can find the source .ipynb notebook here https://github.com/Florents-Tselai/greek-wines-analysis/blob/master/greek-wines-analysis.ipynb Just posted it on Azure as well https://notebooks.azure.com/Florents/libraries/greek-wines-analysis
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [Florents-Tselai/greek-wines-analysis/.../**greek-wines-analysis.ipynb** (master → 5054d01)](https://github.com/Florents-Tselai/greek-wines-analysis/blob/5054d01956d5d0f5ff068f2becd3cb8659c8c7f1/greek-wines-analysis.ipynb) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
use lxml finditer so you don't have to parse the whole thing.
Seems like a good idea! Check out [kazi1's response](https://www.reddit.com/r/Python/comments/7dsjl6/miniconda_how_to_add_conda_to_path_without/dq0d13t/) above. Might be interesting to combine the two approaches 
Yes, heatmaps are really cool in general, once you get a few interesting dimensions. Used to be hard to get nice with Matplotlib, but now with Seaborn they are a breeze.
It's become my default Matplotlib &amp; Seaborn configuration for all projects. 
Motion detection, dictionary, and a web scraper? While learning data analysis and web programming? These will only make you more lost. 
I didn't want to judge your current level. Since you haven't mentioned where have you reached; I suppose you should focus on the simple things for now. Focus on what will get you paid in the mean time. Machine learning will take some effort from you. As I said before, web programming might be useful for your case. Start with a linked-in account, and see the technologies your local companies use. 
https://launchpad.net/~jonathonf/+archive/ubuntu/python-3.6
There is a note on that PPA that says &gt; System extensions/Python libraries may or may not work. What does that mean? 
It means that the libraries you install with `apt-get` will be for Python 3.5, and thus won't work on your 3.6 install, which is separate.
Great. That is fine.
I'm really like the [Python Weekly](https://www.pythonweekly.com/) newsletter
The IRC channel #python at freenode.net is a great place for quietly sitting in a corner and learning
https://www.anaconda.com/download/#linux Anaconda enables you to install isolated Python environments.
Just signed up for it now, thanks 
A bit sad that I’ve never even heard about freenode before considering I’m a developer. Thanks 
https://github.com/pyenv/pyenv It's a simple version management.
These are through Udemy, not Youtube vids- and I know how those can get old quickly. 
No problem. If desired for more info, here is my Github. https://github.com/wjplaud83
Definetly do the anwsers your way....but always try to consider the efficiency of your programs.Dont just do the first thing to come to mind.
Use anaconda.
Cool. But still don't know which one to buy...
No but knowing how to properly write a term is the difference between getting a job and not. I'd trash your resume just for seeing ReGex spelled this way. 
IL2CPP should do the trick, no?
I don't know... never dealt with it. Should it?
That's one drunk snake.
The best way to get 3.6 without any worries. 
https://docs.unity3d.com/Manual/IL2CPP.html
pythonnet supports Python 3.3-3.7
I think settings.py is a fairly common exception. 
Figured out how to spam text messages t people phones :)
Depends on the place. Do long sleeves not cover them?
Well more specifically, the neck. So a collar would cover it slightly
Just laugh at them privately. Helping people to better their language skills is rude.
So this wine site already had an API in place? That's pretty convenient for a wine store! Nice writeup, especially for matplotlib. I've been wanting to use it for something so this will be a nice starting point.
Not really a python or software guy, but I’m using it to interface with a serial device and writing a tkinter gui :) Really liking python so far, and hoping to get more into it. 
Poli orea 
Stackexchange chat has a very friendly python group that helped me out quite a bit!
What is the tattoo? Something offensive would make things harder
It's the same William. You have to start reading. The teachers on Udemy, they read first, and then make tutorials.
All of them could emulate either Epson's or Star's command language or both. Every thermal printer with an usb connection you can get a year warranty for imo fits your need. Just check are there drivers for your OS and you're good to go.
Huh, took me a while to realize that DLR refers to the *Dynamic Language Runtime* instead of the German Aerospace Agency [DLR](http://www.dlr.de/dlr//en/).
Can you please link the group here?
Are all of your projects, based on tutorials? I agree with lht1999's point; try making a good solid project - or two- to show to your potential employers. I'm sure there are plenty of companies around you. Have you thought about converting the command-line dictionary to a gui one? Here's a similar project on my github: https://www.github.com/omar-hydrah/russian-dictionary But that one was made using both Pyton and Java. Python for the networking stuff, and Java for the gui.
Usually, no. Depends on the workplace and if the tattoo is offensive. It is really subjective. If your clothing covers it, it is not a problem. 
Awesome work! r/wine would certainly appreciate this (and possibly more) Thanks for the great work and sharing it!
The location is important here. The social stigmatism surrounding tattoos considers location very heavily. It's one thing to have a sleeve or a tramp stamp, it's an entirely different thing to have facial tats. That said, most big CS companies are very liberal, so they'd probably be very lenient in your appearance. If you do have neck or face tattoos, their will be a bit of discrimination against you for it, regardless of the field. That said, dev work is the least discriminating work I know of, and if you can demonstrate talent and competence, you shouldn't have an issue.
Kind of like this, except I’m a male and I don’t have piercings https://i.pinimg.com/736x/36/84/57/3684574e93687af5d67cde0241afaa71--neck-piercing-piercings.jpg
What is your experience so far? Mind to share?
https://www.instagram.com/loganmartintran/?hl=en This is a software dev I follow on instagram. Covered in tattoos in all visible places, is a Dev based out in chicago. so, depends on the place
It is largely based on your employer. I'm a Systems Admin and I have many visible tattoos as well as a mohawk and they don't mind. If you are debating on getting one because you are worried how it will affect your career then I would get one in a place that you can easily hide it. If you already have one then I wouldn't worry about it, not much you can do about it.
IMO the two worst traits a programmer can have are perfectionism, and indifference. That doesn't mean that you should settle on "good enough", but don't torture yourself stressing over getting it perfect (unless you have a really good reason to). Never be unPythonic, try to be Pythonic, and if you can achieve your goals somewhere in the grey area, then you have nothing to stress over. 
Yeah that might be an issue some places. Don't expect anything client facing. Startups probably not an issue.
Why dont u use something web ? 
Check out github
I think you know the answer, had-made RegExp are going to be finicky if you can't be sure of your inputs. Parsers can definitely by slow, because they analyse and build the whole document in memory. There's a middle road, where a parser returns/callbacks when it finds open or close tag and you keep a minimal state to know where you are, which was a lot faster for me way back (not on Python). I can't, for the life of me, remember the name for the type of parser, so I can't be too helpful.
I haven’t applied for a developer job yet (or any job really lol). Mainly just been building my own websites so don’t have any experience yet! 
But "[Builds of IronPython 3 are not yet provided](https://github.com/IronLanguages/ironpython3)", right? What is the current plan / roadmap / best guess for e.g. when a first release is going to happen? (It seems last year they hoped "[to have something usable by the end of the year](https://github.com/IronLanguages/ironpython3/issues/112)", but I guess that didn't happen?)
I just started this a few weeks ago, I am in my thirties and trying to conduct a career change. I have been through a lot since my job termination and am in need of help.
Use Anaconda.
I will be learning how to create a GUI later on with my Udemy teachings.
Learn git, write documentation and put it on github.
I completely agree! The only way to get a similar level of ease right now is to buy 1 of a limited set of boards (pyboard or openmv cam) which have it pre-loaded. Those also have all their components already wrapped in nice functions for easy use. What I feel it would take to get micropython to Arduino levels is first, a better ide. Just take the one openmv made, it's amazing and Arduino like. Then start the long process of building component libraries like Adafruit has started but really kickstart that sucker for non-adafruit parts. I am a tools engineer full time and the difficulty I had in getting this set up vs the Arduino plug and play was astounding to me. I hope that I can continue to grow this lib with more generalized component packages and installation instructions so that others won't have the same problems I had.
Write python code as pythonic as you know. When you pick up a new pythonic trick, add it to your toolbox and use it next time.
The official numpy repository is available at https://github.com/numpy/numpy You can create a GitHub account for free, and either open your idea as an [issue](https://github.com/numpy/numpy/issues/new) on their repository page (suggesting a new genfromtxt that also supports utf-8) or you can fork their repository, make the necessary code changes to add the function yourself, and submit a pull request to them to consider incorporating your changes. The latter is more advanced if this is your first time contributing to an open source project. I would suggest first searching issues to see if anyone has suggested this idea or may be currently working on it. Best of luck!
Any recommendations on any good courses with real good content? 
It's worth considering building it from source, this way you can configure it with optimizations for your own cpu.
r/learnpython should be helpful for when you're stuck 
Use a `while` loop. Also, post questions like these in /r/learnpython please.
You should go to /r/learnpython 
http://docs.python-guide.org/en/latest/
The [Python GitHub repository](https://github.com/python/cpython) can help keep you in the loop as well.
&gt;most big CS companies are very liberal I think you mean "are free-speech-quashing whiny snowflake globalist cucks" /s
Coolest label
Pyenv + Pyenv-Virtualenv is a great combo
That's it, I'm making a video today. Yes you should write the pythonic way. Most of the code in the python universe is that way and it'll improve your comprehension if you follow the standards. 
http://planetpython.org/
Why would you use functions for simple maths? You can just write the expression itself instead of defining a function for it ,-,
Striving for "80% of perfect," then moving on, works for me. 
No, the website doesn't have an API. I build a scraper for it which looks like an API. Here's the source code. https://github.com/Florents-Tselai/greek-wines-analysis/tree/master/houseofwine_gr
I don't think the functions are that bad, honestly. The bigger issue to me is that `if...elif...elif` block which could be refactored, and the functions actually can help with that: mapping = { '+': add, '-': sub, '*': mul, '/': div, } value = mapping[operation](num1, num2) print(value)
Thanks
Testing man.
Awesome! This is what I was looking for. Thanks!
Your back off function is doing an xor by the way, not exponentiating. 
Came to write this. It looks like a lot of extra work, but it can benefit you greatly. Git can be a bit hard to learn, but it is a game changer when it comes to dealing with version control. Plus, writing good documentation is an invaluable skill.
ATOM
Depends on the place, just like with most other professions. Software dev is less of a public-facing role though, so many places that would reject you as a receptionist, lawyer, account manager, etc., might still consider you as a developer. And there are plenty of places that are about your skills rather than your appearance, and software dev as a creative profession tends to have more leeway here, too.
have a look at [Twython](https://github.com/ryanmcgrath/twython)
wow I wasn't sure if everyone is able to contribute... because open source is so I don't know... I thought I would break something. Yeah I will post the issue with my code to see if someone replies. Thank you!
Thanks dude! Only started a few days ago so i've been just testing stuff out, Cheers for that. I'll definetly give it a go and see how it turns out. :)
Thank you for your suggestions. Python seems like a really powerful programming language and excited to learn 
From what I've seen, no, if anything it might be a plus at most places
For a start you can watch "Loop like a native: while, for, iterators, generators" and "Transforming Code into Beautiful, Idiomatic Python" to learn how to write pythonic code. [Here's a list](https://github.com/s16h/py-must-watch) with other great talks.
Sorry, I meant stack overflow, and I think it was this one - https://chat.stackoverflow.com/rooms/6/python On mobile right now so can’t confirm
https://chat.stackoverflow.com/rooms/6/python
What does this mean? Adhering to conventions?
And the 80 20 rule applies to programming somewhat as well. 80% of the work takes only 20% of the time. But perfecting it takes forever.
Register on irc.freenode.net and join #Python. You can get realtime help when you get stuck, and just generally talk to people using python. It's an amazing resource.
Someone beat me to it. 2nded, amazing tool.
I prefer pyenv to anaconda. 
Nice job!
You cannot merge it into the canonical repository yourself, so there is no way to break anything by yourself. The maintainers of the project will take a look, probably ask you to make changes, and eventually get it to a point where they think it's up to the quality of the project and *then* merge it.
Just checked it out, I have been running just the basic python IDE till now, and I really like it!
I'm a big fan of writing things correctly, but I think there are a million more important considerations than this when you're evaluating a candidate.
I once broke a Wikipedia page, and a few hours later someone reverted my changes. It's a relief it won't happen here.
It… depends. Any "parser" (= DOM traversal frontend) is susceptible to changed HTML structuring or shifted class/id names. A regex can at times be faster and more long-lived, if done right. Both approaches often require post processing. For reference, I got this one app where I alternate between the two: [http://fossil.include-once.org/streamtuner2/wiki/channels](http://fossil.include-once.org/streamtuner2/wiki/channels). Oftentimes I have both methods. Regex could easily become convoluted when you try to match too many items at once. PyQuery (neatest API in my opinion, BS4 always felt cumbersome) is more convenient for modern and well-structured HTML. In my experience the oddest HTML is easier to scrape with throwing regexps at it; given that you have some textual patterns to anchor it too. There's often only a minor performance penalty for DOM traversal - in comparison to HTTP requests. Albeit you'll often use regex still to e.g. merge multiple page results (e.g. condense `&lt;/body&gt;.+&lt;body&gt;` - as otherwise LXML would throw up on conjoined HTML).
I haven’t used either, can you tell me what you like about pyenv over anaconda?
Excellent links, I'm brand new to python and programming in general. Coming from a trade background I'm focusing on building skills in building automation and controls for HVAC systems.
It's gonna depend on the attitudes and prejudices of the person doing the hiring honestly.. The more you can cover it and make it a moot point the less you'll have to worry about it.
I'm not sure how English translates to spoon, but I think he just meant liberal. 
You can also apply for remote jobs. Usually those companies look for people that are able to work in such an environment. Having tattoos usually isn't a problem there. Your colleagues probably won't see you 99% of the year. 
Notice my comment, just because it's a common thing people do doesn't make it right. As soon as you do this, you can't lint properly anymore. There are always other ways, in my projects import * is never acceptable.
Hey everyone ! Just found this really nice and concise conference about good practices when writing Python C-extensions. Many thanks to Paul Ross for his talk :) Ps: More informations can be found on http://pythonextensionpatterns.readthedocs.io/en/latest/
It's been a while, but I believe pyinstaller has issues with newest versions of python.~~I don't have my other computer with me to check the specifics, but~~ I do clearly remember being forced to run pyinstaller through an older version of python to get it to compile. `python36-32` was definitely the version that it *didn't* work with for me. I just checked. I had to downgrade to 3.5.2 to get pyinstaller to compile correctly.
Thanks for the info. Is there a way to have two versions of Python installed at the same time? Create and run with the latest Python, but build executables with an older version of Python.
It looks like someone submitted a pull request for a similar idea just today. https://github.com/numpy/numpy/pull/10054 &gt; This modifies loadtxt and genfromtxt in several ways intended to add unicode support for text files by adding an encoding keyword to np.load, np.genfromtxt, np.savetxt, and np.fromregex. The original treatment of the relevant files was to open them as byte files, whereas they are now opened as text files with an encoding. When read, they are decoded to unicode strings for Python3 compatibility, and when written, they are encoded as specified. For backward compatibility, the default encoding in both cases is latin1. Not sure if this was just good coincidence or what.
Yep. I have two folders `~/python35` and `~/python36`. You simply need to run pyinstaller from the appropriate python install and then point it at your `.py` as normal. I would code/test in the latest version but compile in the older one. It's frustrating and a bit confusing, but it worked for me.
I know CS doctors that have several tattoos. Try to invest in your skills and don't worry about your tattoo. 
Or just use the one functions that are already available in the `operator` module. 
Even though you included a /s here, it reads poorly, as if you're blowing off steam. Maybe stay out of the political subreddits for a bit.
An ORM adds another layer, which makes things a bit slower, but it's not something you would really notice. And you definitely don't want to write simple select or insert statements a hundred times till you get annoyed and essentially write your own ORM. Bypassing the ORM sometimes makes sense with complex and costly queries that can be optimized. ORMs oftentimes aren't very good at that. Take the best of both worlds.
I always recommend the SoloLearn app, a great way to get to know the basics (and even a bit more) of a programming language. However, if you don't know any programming language up to now, then it could be a bit confusing.
you should publish it on https://beta.gryd.us
If you are in Chicago, we organize Python Project Night every third Thursday at Braintree-s Chicago office. We do beginner friendly exercises by grouping the attendees in teams of four to work on predefined problems on Python 101, WebDev, or Data Science. Every team member gets 15 mins at the keyboard and at the end of the hour we pick one team to give a code walk through, finishing off with we a discussion on what we learned. [projects on github](https://github.com/chicagopython/CodingWorkshops) [our Meetup page](https://www.meetup.com/_ChiPy_/) We also run a 3 month free mentorship program twice a year where we pair a senior developer with a junior developer. Check https://chipymentor.org for more details.
What has this got to do with the Python programming language?
Hey thanks for speedy reply. That's what I assumed, but I'm still a noob at python and have no shame asking when google (rarely) fails me. I think I'd learn more if I stuck to psycopg2 as my db interaction is fairly limited at the moment.
I think that will give you more trouble than the tattoo, honestly. Have you contributed to any open source projects? If you can point to some work that you've done that's "in production", so to speak, that can really help offset your lack of formal experience. I've known a few people that got jobs that way. Good luck!
Ah. You're right. Read that the opposite way. My apologies. Regardless, your solution only half-works. It allows access to `conda`, but unless `activate` prepends `conda`'s Python's parent dir to the `$PATH`, you'll actually be using the system Python. Regardless, you'll want to do this other than in your `$HOME`.
Please justify. Just telling people to use `anaconda`'s actually not very helpful, and could be a bad habit.
Working as a developer for the government sector, tattoos might affect your ability to obtain a job there where you have to be “professional”. But if you’re working for the private sector such as a start up company where the CEO is name is Chad and walks around barefoot, I think you’ll be fine with tattoos.
Python is young and hip just like tattoos 
You're right, but you might want to justify that in particular. In the past, if Ubuntu had the Python version I wanted, setuptools/venv was broken, so I used `pyenv` to work around its broken packaging, or lack of latest major version. They're kinda orthogonal. But you are right that `pyenv` is the proper solution here… except for the need to manually update your Python version. Unless you're trying to be consistent with Windblows developers who can't build C extensions worth squat, or there's some preexisting conda environment in whatever company project you're working on (dev-dev parity!), stick to stock. And that's what `pyenv` does.
I made my first twitter bot this weekend! It automatically uploads the daily top post to twitter with title and OP (for credits). Quite awesome actually seeing it work. Still have to buy a harddrive for my old pc so that it can run the script everyday but that probably be next weekends project. https://twitter.com/EarthPornTopBot 
Regex is not a robust solution for parsing the DOM, since it's not a regular language. It might work in your case, but it can be brittle, or you just missed an edge case. HTML is not a regular language. You might want to be specific about exactly what you're extracting. Element attributes? Node text content?
- Do you mean `lxml.parse`, or `lxml.html.parse`? - And please be specific about how it's "shit". It's not exactly useful to other developers to just take something at face value without understanding it. - Scrapy just uses LXML AFAIK, but I could check. - Better selections could be a thing, but since you can't just pass a bunch of selectors and let the library aggregate them into a single pass for you, you might also want to consider doing that manually… but *please profile first*.
Nothing wrong with any of these comments, but I typically run *everything* in docker. I have my own images hosted on ECR for many of my projects and I can test, run, and deploy all of the things without contaminating my system + pyenv environments
Also podcasts, ie. [Talk Python to Me](https://talkpython.fm/). Great on a commute to work.
Please justify.
Please justify. I could just retort "Vim since it actually has composable key bindings and doesn't slow down my whole laptop with its bloated browser-based renderer". Please objectively compare and contrast. If a beginner is asking this question, they probably don't have the background yet to understand all of this on their own.
Thank you. Will definitely watch them. 
PyEnv installs (any version of) python. That's all it does. In contrast, anaconda is a python distribution, a package manager, an environment manager, and a platform for paid packages. In the past, they once did break pip because they wanted to promote conda instead. Some features of conda require a login, some require a paid subscription. When you install packages through conda, you get binaries and source code from anaconda's servers, *not* the official packages from PyPi, which might or might not be up-to-date and feature-complete. For every package you install, you have to make a choice of using pip or conda. With PyEnv, you install a python. This can be CPython, PyPy, IronPython, Jython, even miniconda. Plus, it provides an easy and transparent way of switching between installed versions (including any system-installed versions). After that, you use Python's own venv and pip. I find this process much simpler, and easier to manage, because it relies on small, orthogonal tools (pyenv, venv, pip) instead of one integrated conda that kind of does everything. I also like to use these official tools and packages instead of conda's parallel universe of mostly-open, mostly-free, mostly-standard replacements. Mind you, conda solved real problems back in the day (binary package distributions, python version management, and environment management), and arguably still does (MKL et al, paid packages). But ever since wheels became ubiquitous and painless, and virtualenv was integrated into Python, and the development of PyEnv, these issues now have better solutions, and conda is no longer needed for my applications.
Probably want to implement self.__str__() and not mess around with print(card[i][0], card[i[][1]) every time.
See my response to your brother post: https://www.reddit.com/r/Python/comments/7e08sv/what_is_the_best_way_to_install_python_36_on/dq21er7
I am actually doing the same thing. Mostly. I develop in a local virtualenv but I test, build and run/deploy in Docker containers. Even small cron jobs are temporary containers. But, I don’t like to develop in containers. I’m pretty happy with hacking locally without any abstractions “in the way”. For example I always have an ipython shell open. I’m curious how you develop. 
Or the docklands light railway, the cool driverless train line in London.
I really doubt that kind of tweaking has any meaningful impact. Do you have an example with numbers to compare?
How about you rewrite it *without using any comprehensions* and debug that code until it works? After that, you can convert it back to code that ~~is an unreadable mess~~ uses comprehensions?
Not sure if I want to download / use a 525 MB installer. 
Hi guys! I'm Subhash, and I've just released a new open source Python tool for instantly creating a REST API for any ML model. For now, it's a work in progress and so far supports all Keras models. What do you guys think? Would love your feedback!
Hmmmm, usually developer roles aren't customer-facing so no one cares. But large corporatey places like banks or whatever would probably want you to cover it.
I've installed Python 3.5.2 into a separate folder. Do you do run each version of Python using the Python shell from its corresponding installation? I've done all of my Python stuff via the Command Prompt. So i'm not sure how to use a specific version of Python.
Many thanks! Historical context is good too. Should be good enough for just about anybody who isn't already familiar with every little bit of the ecosystem or has a year or two of experience. Or you could just call me a lazy delegator.
Holy fuck. Why would you do something like that to yourself? Yes, there will be stigma... maybe you’re lucky to find a boss that don’t care.. either way try to get it removed.
If you don't need all the stuff in Anaconda (which I don't), then Miniconda is an alternative and is about 50MB. https://conda.io/miniconda.html 
It's acting on the current selection. I haven't used Blender but if it's like other apps, all those calls (including rotate and resize) are acting on the current selection and adding a new object resets the selection to just that object. It's how a user would do things from the GUI, the api is most likely written to support/mirror this way of working (and I'm also willing to bet you could pass names to those calls to have them act on specific objects.) But yeah, not the best way of doing things. 
It's been months since I had to do this, but I'm pretty sure you'll be able to just open it from `C:/pythondowngrade/python` instead of `C:/python/python` with no issues.
In this case I would have to recommend you to search the subreddit for an answer. It is a general and common question.
We use a conda env for development, and then a docker setup for testing that is closer to production. I've found that with django and the huge difference between dev/prod that this helps shake a lot of bugs out before we deploy to our actual dev hosting env. We could get by with pyenv / virtualenv I'm sure, but we standardize on conda because of how it handles binary dependencies. Our actual dev/test/prod environments do NOT use Anaconda, as they run in docker. We did try Miniconda for those, but found no real benefit there.
Does it require you to install all libraries in each environment again.
Woo! It worked :)
Some inspiration: http://pbpython.com/xlwings-pandas-excel.html 
If any employer cares, they aren't worth working for.
Data mining is hard while ensuring data quality... Why do you have Chianti in the varietal list? 
&gt; Do you mean lxml.parse, or lxml.html.parse? lxml.html &gt; And please be specific about how it's "shit". It's not exactly useful to other developers to just take something at face value without understanding it. It's libxml2's HTML parser which is an outdated hand-rolled HTML4 parser, which means the tree it builds is crap and matches the parse tree of no modern browser, which means its output is confusing and harder to predict.
pyenv allows you to use specific versions of python for a specific project, you can even install anaconda python with pyenv.
sweet, thanks for clarifying! gonna give this a try, for sure 
No visible tattoos allowed in finance 
Very helpful and supportive community. Kind of like *pile exceeded* except without the constant racking anxiety about possibly asking a question that has already been asked some time between the start of recorded history and now. 
https://automatetheboringstuff.com I tried a few apps and found that I struggled with the lack of tangible example projects that translated what I was learning into something real. ATBS really helped me forward in that regard. 
This is something I've always wanted to do. I've taken a stab at the back end once or twice but nothing I've wanted to keep. I've been playing with cyhon recently and was thinking of having another go at it with that. The closest thing I've found is called coral. It's written in C++ with a Python interface and PyQt GUI. It was a little specific to visual effects though. https://code.google.com/archive/p/coral-repo/
Yeah this is ridiculous. ' here's some data structures I won't tell you the content of. Can you debugger this list comprehension dictionary comprehension with n context?'
You wrote a chatbot but are unfamiliar with loops. No wonder companies struggle to find quality these days.
You can just use apt. sudo add-apt-repository ppa:jonathonf/python-3.6 sudo apt-get update sudo apt-get install python3.6 Most developers/serious programers prefer virtual environments such as pyenv, docker, or anaconda. Because they can control their dependencies better. Say for a project you need to use an old version of a library, you wouldn't have to uninstall the current version and break your other projects. Additionally if you want to publish your code it helps track dependencies that others would need. 
So it's like a meta virtualenv?
It's not a course per se, and it's not really written material, but if you're interested in really learning how to, dare I say, *elegantly* do powerfull stuff with Python, I'd highly recommend any of Raymond Hettinger's talks that can be found on Youtube. He's been one of the core Python devs for over a decade and all of his talks have immensely helped me gain a deeper understanding of how the language works and how to exploit the most of it. He also runs a twitter account that only tweets tips &amp; tricks for Python!
Thanks, fixed!
I wouldn't vouch for it. Some of the most active users are kinda dogmatic and sometimes aggressive when you disagree with them. 
Honestly maybe assist GoDOT or Banshee game engine's. They are trying to implement the same systems and are opensource and could definitely use the help.
MITx introduction to programming with Python on edX. The best a programmer can get. 
&gt; &gt; Do you mean lxml.parse, or lxml.html.parse? &gt; lxml.html is pretty obvious considering we're in a thread about parsing HTML and screwing up tree building from an XML document is difficult. It's not an uncommon mistake though. Pardon me for not giving the benefit of the doubt.
Seconded. I liked this the best out of all of the online tutorials. I liked the question interface, they are able to ask you complex questions and force you to solve them. Most of the online tutorials just tell you how to do things and never make you think.
I'd put it the other way around... but maybe this is how I learn stuff: Put it on github, write documentation, learn git (eventually)
It's interesting that you mention this. Because [gists](https://gist.github.com/) are very much like Wikipedia page but with this pull / push philosophy. I think it's interesting looking at the effect it has on things. I get the impression that one of the reasons that Wikipedia is an angry place is that you don't have pull requests / the implicit politeness it creates. On the other hand I think this ability to "trivially hostile fork" is the reason that wikipedia works. 
Suggestions for someone who just knows / programs in python to start on stuff like this? My initial plan was to rewrite core algorithms in cython for speedups, but ultimately c-linked libraries are faster right? 
Using an ORM or not depends on your use case, but I would say that most of the time you are looking for a query builder and not an ORM :) There are plenty of good ORMs for Python but I am not able to advice you any query builder, as most of the time I write one myself. Does anyone know a good and maintained SQL query builder for Python 3 ? :) 
It's one of those words that deliberately has a bit of a vague meaning IMHO. It's a bit "minimising surprise", a bit "not going against the grain of the language and the libraries", a bit "doing things how other people like them to be done", a bit "demonstrating you're one of the in crowd", "post hoc rationalisation of my decision" I'd say it's a bit higher level and less formal than conventions. High level things can be more important than conventions. Some pythonic things (in my opinions): * Use of iterators * enumerate versus indexing * slicing * list comprehensions * decorators * small amounts of functional programming * not too much OO 
I am automating a manual procedure at work, using python. When some websites hosted on the same auto-scaling groups on aws experience latency spike, we have to invoke a dump procedure and collect debug data. Data is saved on local disks. On auto-scaling instances. That come and go. My script's job is to enumerate autoscaling instances using boto3, invoke said procedure on every instance and download logs as soon as possible, ideally in a parallel manner. Invoking the procedure is easy, just one urrllib shot away. Then I parallelized with threads (GIL isn't a problem here as this is a io-bound problem with a low number of paralle jobs). Next steps are to automate logs retrieval using paramiko and then detect latency spike using boto3's interface to AWS cloudwatch.
&gt; My initial plan was to rewrite core algorithms in cython for speedups You should do this. It’d be a great way to learn.
Man, this is cool! I looked at some of the sources (mainly output_voice.py) and I think it would be a great improvement if you could write some comments, docstrings in particular (to document the data types you expect as parameters). Good job!
Agree in regard to specific use cases. The problem is, in most tutorials (as with everything web development) there are 100 different ways to do something and the tutorials never specify why they choose library X over libraries A,B,C... and the Python ecosystem is quite large and arcane for someone (me) who is still fairly new to the language. 
 bin(number)
Also **more-itertools** ! One can never have enough :)
All depends on what the "General purpose application server" does. I would suggest you to use django over flask if your application server has backend db and complex logic. Otherwise flask will serve your need
I wouldn't worry too much about what is considered "pythonic". The definition of that is hotly debated and rarely fully agreed on anyhow. Striving to make things as simple as possible and eliminating duplication wherever possible will get you pretty far. It's also worth bearing in mind that you should always try to get it working *first* and only then worry about cleaning up your code.
Nope. I work in it security and it's pretty common. 
Did you try meetup.com?
...Wait, what?
Don't if you don't have to. You write some code and preferably less of it. https://www.youtube.com/watch?v=o9pEzgHorH0
?? You're looking up values by their key; it's how dictionaries work. I'm probably missing something obvious here, though.
This is for python 2
yeah now do d['zero']=1 
you can use it to get the keywords also in Python 3.x here's an addition, to check if a word is a keyword in Python import keyword keyword.iskeyword("raise") keyword.iskeyword("printstr") When you run the code snippet above, you will get a True value for "raise" and a false value for "printstr" This indicates that "raise" is a keyword in Python while "printstr" is not. 
There are established python user groups: https://wiki.python.org/moin/LocalUserGroups If you don't find one close to you, you might try the local linux user group: http://lugslist.com/ctry/usa.php?lg=en 
Sorry, this is straight copy/paste: ########### Python 3.6.x ############### sudo apt-get install build-essential libsqlite3-dev sqlite3 bzip2 libbz2-dev sudo apt-get install python3-dev libblas-dev libatlas-base-dev libopenblas-base liblapack-dev gcc g++ gfortran cython sudo apt-get install libreadline-dev libncursesw5-dev libncurses5-dev zlib1g-dev libssl-dev tk-dev sudo apt-get install libfreetype6-dev libpng-dev sudo apt-get install libjpeg-dev zlib1g-dev libtiff5-dev libfreetype6-dev liblcms2-dev libwebp-dev libopenjpeg-dev wget https://www.python.org/ftp/python/3.6.2/Python-3.6.2.tar.xz tar xf Python-3.6.2.tar.xz cd Python-3.6.2 ./configure --prefix=/opt/python3.6.2 --enable-optimizations make &amp;&amp; sudo make install whereis python # run this to find locations of python installations mkdir ~/envs cd ~/envs # move to envs directory /opt/python3.6.2/bin/python3.6 -m venv bottle # create bottle virtual environment using Python 3.6's pyvenv or python -m venv bottle cd bottle source bin/activate # activate the environment pip --version # double-check the pip version ###### Installing Same Packages as Prior Python Version ###### pip freeze &gt; installed.txt (on older Python version) pip install -r installed.txt (current Python version) # If using miniconda3, add conda-forge channel: conda config --add channels conda-forge 
where's the trick? 
Your dictionaries double in size and are now slightly inaccurate
I wouldve thought OOP would be pythonic just because python is OO though?
Once you’ve got the basics of the language down, I recommend watching almost anything you can find by Raymond Hettinger. In a happy coincidence, he is a Python expert, a gifted presenter, and someone whose various talks often get recorded and put online. [This talk](https://www.youtube.com/watch?v=OSGv2VnC0go&amp;list=PLRVdut2KPAguz3xcd22i_o_onnmDKj3MA&amp;index=3) might be a good starting point.
Unless you need a specific feature from 3.6 I'd say just stick with the default Python3 in Ubuntu and use virtualenv anyway. They bring security features and "verified" libraries in the repo. 
Maybe. It's definitely more fond of using functions than other languages.
Ubuntu first, now Manjaro-i3. The basic differences between linux version comes down to the package manager first, followed by the init system.
Cython transpiles down to C (or C++), so not really. In both cases it depends how far you'll take it. You can write cython in a way that you release the GIL the moment you step into a function, but obviously the idea is to use python and only offload the tight spaces. The nice thing about cython is you don't have to worry about python calls (preparing tuples, lists, etc...) at all.
Python has OO rather than is OO though, you aren't forced to use it, and there are often better ways to model your problem.
Doesn't really matter 
Depends how you look at it, even basic types (and I think functions even?) are python objects, so whatever you do, you work with them.
Start a projet you'll be passionate about. When you get block, ask around in the different references given here.
First, I call a vote on calling coding in python "spanking the python" from now on. Second, both Lynda.com and YouTube have great howtos, especially on data processing and plotting. There is also a great series of videos on natural language processing on YouTube. 
Yes, it's not possible to avoid doing so.
&gt; Manjaro Wow never heard of Manjaro before. Reading up on it now. 
[pipenv](https://github.com/kennethreitz/pipenv) has pyenv support now as well
This. Python has a lot of great tools for functional programming, but the objects really complicate matters when you are trying to avoid/minimize side effects.
I highly recommend [Falcon](https://falconframework.org/) if you are looking for a very simple REST server to drive actions on a server. If you have a full-fledged web app with requiring DB access or a frontend, Flask is probably better suited to your needs.
So I always try to have "functions do stuff that use objects" where possible (unless you are going all event driven). I mean, it's all trivially equivalent really, but somehow this feels like it makes it easier to understanding what's going on. 
I've been using Pop_OS (ubuntu) since it was released and I'm pretty into it at this point. 
Recently abandoned windows at home and now using Debian stretch, KDE desktop. I am happy wit the 3.5 python it provides so far. I have used other distributions in the past such as mint and Ubuntu but I didn’t like these as much.
Good to know, thanks!
printstr is undefined even
Whatever. I use windows 10, ubuntu WSL, ubuntu native, and centos because those are the systems available at my disposal. Nothing about debian makes it better for python dev than any other environment.
I understand where you're coming from. It's not the objects as data structures that are usually an issue for me; it's usually when a framework uses objects that have methods that change state. In the end, I'd still rather have a language that supports both paradigms like Python does.
I was playing with the code to make the dominoes run into each other. But, all but the two end pieces just fly up into the air. I don't think any of the pieces are overlapping. What could be causing that. import bpy bpy.ops.mesh.primitive_plane_add(radius=145, location=(0, 0, 0)) bpy.ops.rigidbody.object_add() bpy.context.object.rigid_body.type = 'PASSIVE' x=-75 for i in range(0, 25): bpy.ops.mesh.primitive_cube_add(radius=1, location=(x, 0, 1)) x+=6 bpy.ops.rigidbody.object_add() bpy.ops.transform.resize(value=(1, 6, 10), constraint_axis=(False, True, True)) if i==0: bpy.ops.transform.rotate(value=0.4, axis=(0, 1, 0)) if i==24: bpy.ops.transform.rotate(value=-0.4, axis=(0, 1, 0))
https://www.maketecheasier.com/apt-vs-apt-get-ubuntu/
Python is 26 years old.
thanks .. I'll try both Flask and falcon .. I want to write a python program that runs in a loop and selectively calls functions based on events. .(probably, that's called event loop, I havn't written anything in event loops.. ) without having to schedule python program using cron jobs .. 
Kubuntu 16.04. Also a Win 10 in Virtualbox for those times only Windows will do and these are getting rarer. Minor gripe is lack of official Google Drive support. 3rd party support works OK but official would be better. 
reddit , dev.to , stackexchange, also listen to talk python to me podcasts and several other podcast subscriptions.. I've seen quick responses here in reddit by far .. 
Maybe is just because I'm newbie on Python (and programming in general) but I always wanted a way to map, for example, month names to their number correspondents and vice versa. With that kind of thing it is easier than ever. I thought it would be interesting to share my excitement but I see I was wrong. Nevermind, guys.
Well most of the programming committee is like that but sometimes you still find useful stuff if you ignore things like that
He wants a job as a Python developer, and wants other devs to give him some feedback. Is that so hard to understand?
Yeah I have a user registration system which I extended off of the AbstractBaseUser in Django. Yeah you can have payments without user registration, you would just have to get their email at least and then use that to match up the payment with PayPal. But you don’t need a user system to take the payment. PayPal will send the payment details to a webhook and then you can just confirm that Email@foobar.com has paid and give them access. Sorry about the late reply btw. 
Absolutely. No negative judgement intended.
/r/computervision https://www.pyimagesearch.com/tag/edge-detection/
I like what you have done, been reading through your code. I feel like when you win and get troops the amount you get should be something based on random and the percentage that you beat them by. What i mean is if they had 1000 troops and you had 30% chance of beating them, when you win you should get 70% of them because you killed the rest, or something like that. Bit more dymanic in nature. Solid effort though, i like it. Its like a text version of Civilization :)
PyData talks on YouTube and all of the related viseoa
If you wanted to update this, you would have to do it in 2 places. I think there are more pythonic ways to look up a key by value depending on your structure. But keep up the excitement :) 
I rarely ever see compiled python binaries. That's actually common? Also, lets say I wanted to build a web server (http) as a learning exercise. If I later needed it to scale would you recommend Python or Go for this task? Am I right to assume that Go would scale better?
I dont have enough reputation... I have 16 :(
Google Dan Bader. He's got a lot of resources available.
That's a feature, not a bug.
You should strive to re-use existing solutions whenever possible. In this case, you could use the calendar module. https://docs.python.org/3/library/calendar.html#calendar.month_name But as an academic exercise, this is how I might implement it: `months = [‘’, ‘January’, ‘February’, ‘March’] february = months[2] month_map = {m: i for i, m in enumerate(months)} second = month_map[‘February’]`
Lots about Linux makes it better than windows, though.
Ubuntu 16.04. I've never used a Linux OS which hasn't had any requirement to get your hands dirty, so it's best to stick with the one used by the most people, with plenty of beginner-oriented documentation.
I love using docker. Everything is contained. Messed up build or install? Just try again. Saves the pain of messing up anything on your system. 
Check out my vim config file geared towards python dev, maybe someone here will find it useful: https://github.com/jarolrod/vim-python-ide
It's totally possible, easy even. The problem is you would be violating that site's Terms of Service and they would blacklist your IP address. https://www.sports-reference.com/data_use.html &gt;Please do not attempt to aggressively spider data from our web sites, as spidering violates the terms and conditions that govern your use of our web sites: Site Terms of Use &gt;If we notice excessive activity from a particular IP address we will be forced to take appropriate measures, which will include, but not be limited to, blocking that IP address. We thank you in advance for respecting our terms of use.
This is awseome.
Did you try googling something like "python genius.com tutorial"?
yes and its not really that helpful
Java as in java applets or javascript? Two very different things... 
I see. What would make it so aggressive, is there a way I could only do it once
I think he should try each of them and see what fits his needs. This is what I use and I use it because it fits my needs and I can't be objective about it. OP - please worry less about where you code and just continue practicing. Good luck.
Definitely, jenkins + docker = bread + butter 
Doesn't look like it for that particular site. On that page I linked they link to other sites from which you can get big DB dumps of scores, maybe one of those would suit instead? The only way to do the scraping you want from that site without triggering their defences would be to scales it right back so you're only doing a handful of page views a minute.
Terraria go home, you're drunk. Just kidding, this looks pretty cool
Thank you. I am using mostly *spacemacs*, but I think that the python layer is not optimal, I'm will give a try with your config . Bonne journée !
Arch Linux I've tried a lot of distros, but Arch is the most stable and efficient one so far
The icons in nerdtree are so fucking beautiful. What font are you using ?
+1 for Arch Linux. Also, it's nice to install packages with pacman instead of pip so that the python packages are updated with the system
I don't see how your Linux distribution would greatly affect your python development. I mean, vim is the same no matter what distro you're using.
awesome! thank you for this. 
Cython can achieve C-level speed, but it requires using a bunch of decorators, and documentation is not always great, so it can feel like black magic sometimes. I think it's nicer to write the core algorithms in C++ than Cython. Cython makes a great wrapper for calling the C++ code -- it's super flexible and makes it easy to gradually move functionality into the C++ layer.
Mononoki Nerd Font
That is super cool. Maybe now I'll take the time to learn/practise Vim
Looks cool, must have took a lot of effort, but, for anyone dealing with the codebase larger the 3-4 files I'd strongly recommend trying pycharm. It takes some time to get used to (well, vim as well), but, oh boy, I never thought that ide can be that quick and ergonomic at the same time. Few bugs here and there leading to false positive alerts, but generally their static type inference engine and refactoring tools are just awesome. Even built in git is good for simple add-commit-pull-merge routine,not for complicated things, though (or I am just not aware of how to do that in ide without breaking things) 
I also find quite useful reading sources of stuff I work with, especially if I am confused about how it might work. 
It still has fuck all to do with the Python programming language. Crap like this belongs somewhere else, try alt.bollocks.
What is this?
What have you done to NERDTree? It looks magnificent!
This looks very cool! Do you have any idea how much latency and bandwidth is possible with a REST API for ML? I have been thinking about using a similar setup, but I am concerned that http just won't scale for my problem (e.g. fluid dynamics solver which requires very tight/fast coupling between the machine learning model and the rest of the model). Thanks.
"Stop writing classes" Um... I agree with Uncle Bob here - large functions are where classes hide. I'm dabbling in a roguelike made with libtcod and some of the functions I'd have to make would be huge. Classes make my code really clean and easy to read.
The serious answer would be /r/cscareerquestions
Oh ye of little vim.
“Spanking the Python” I can second that. Secondly the only problem I have wi h most online courses esp Lynda is that there are quite rigid. 
I saw that the most popular projects are building web scrapers, then search engines, login systems etc...... I like that approach a lot. 
Hi felinecatastrophe! Thank you very much for your awesone feedback! After considering your use case, I would probably go with an in-process setup with the ML model accessed directly from your code (without any network calls), as this would reduce your latency the most. In fact, in one of Google's Tensorflow talks, the Tensorflow team suggested that for very strict latency requirements, this would be the recommended approach. So, if latency is a very big concern, then you should probably just access your model directly from your code. However, in a use case where some minimal latency is OK, (such as in recommendations, churn prediction, and many, many other situations), you should go with deploying your ML model as a separate system, since this will allow you to easily update your ML model with new data and deploy the updated models without re-updating your entire codebase. Hope that helps!
Isn't there a slight upper hand with the more popular distros, in that certain libraries (*cough* OpenCV *cough*) that can be a pain to compile from source are quickly available in the distro repository?
What is going on in your right split? It looks really interesting. Anyway, thank's for sharing!
How do you get the right column to display that?
Its a plugin called DevIcon which displays file type icons in NerdTree 
ctags, they're automatically generated as i type
Looks like Tagbar.
I have a autocmd in my vimrc that automatically opens the tags buffer when i open a python file
Yes. It think i need to figure out what precisely my latency needs are. For intermediate latency, I think using something like redis as an intermediary might be faster than http, but easier than performing in-process calls. Although, I guess it isn’t that hard to link the code against the appropriate libpython, and call tensorflow that way. Any chance you could link that google talk you referred to? Thanks!
Yeah, I checked it out and Plugged already. Commented mostly to point out how amazing it looks :D
Id be _very_ interested in your thoughts. I was a spacemacs user a few years ago and loved it. Now Im using pycharm with ideavim and its pretty good... But its not very 'smooth' per se.
I strongly agree. Tried to make Vim + Python work for the longest time, but Jedi/YCM/Python Mode are really poor substitutes to the deep language comprehension offered by PyCharm.
I like the combination of flake8 and pylint.
No worries felinecatastrophe! Here's the link to the talk: https://youtu.be/yALzr4A2AzY?t=11m55s I guess Redis might work then. You should also checkout gRPC, which is Google's version of RPC, which they claim to be highly performant...
I admit that it is a bit scary at first, but be sure that there is no perfect path when learning programming, so my advice would be: just do it :P Go learn ORMs with a tutorial on Peewee or SQLAlchemy and when you will be more comfortable with DBs, Python and ORMs you will have a much more accurate knowledge to decide whether to use or a DB driver directly :)
I can't find the reddit topic when I asked the same question but someone answered me that he uses Cython to prototype stuff, and if the result is good and tested, he implements it as a C-extension. It's been two weeks that I write C-extension, so I am fairly new to this topic, but I find it much more easy that expected. It's actually quite funny :)
For anyone else interested, check out the udacity intro to computer science program. Don’t know how much it costs but seems like it’s quite in-depth 
This
I personally find conda amazing. It is like wheels but older and more mature, afaik. 
I always thought that pycharm creates a virtual environments under the hood, if you want more then a single set of packages, no? 
For reference: semver.org keepachangelog.com
Is it only the font or do you need to configure nerdtree somehow for the symbols?
What features does the tagbar on the right side have? Does it allow any type of jumping of sorts? 
I personally changed my terminal font to the patched mononki nerd font, but I know you can set guifont: in vim
`pylint` if nothing else as it gives the most useful feedback. I also use `pycodestyle` and `pydocstyle` because I'm picky about coding standards.
Have you considered uploading it on Github? That would be awesome
Python programmer here, and long time Vim user for all things (including Python dev with MUCH more than 3-4 files). Vim is great for all size code bases. I don't doubt your experience maybe didn't lend you feeling this way, but that was simply your experience, not the product itself.
VSCode is very nice. I also like this addon for it: https://marketplace.visualstudio.com/items?itemName=donjayamanne.jupyter
One of the most popular distros, shame on you. :D It's really nice distro, I've been using it for 2 years and never had any problems.
!remindMe 7 days
I will be messaging you on [**2017-11-27 10:56:00 UTC**](http://www.wolframalpha.com/input/?i=2017-11-27 10:56:00 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/Python/comments/7e0646/i_am_brand_spanking_new_to_python_would_like_to/) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/Python/comments/7e0646/i_am_brand_spanking_new_to_python_would_like_to/]%0A%0ARemindMe! 7 days) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! ____id____) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
the one with the Python Tools for Visual Studio Win64 ✧ʕ̢̣̣̣̣̩̩̩̩·͡˔·ོɁ̡̣̣̣̣̩̩̩̩✧
&gt; Cython makes a great wrapper for calling the C++ code I previously used Cythin for wrapping C and C++ code, but I recently switched to [pybind11](https://github.com/pybind/pybind11) because Cython didn't quite cut it for my use case. I prefer pybund11 for wrapping now simply because it does not introduce a third language (Cython) into the mix. Cython is however awesome when you want to lift existing Python algorithms directly into C for speed with minimum amount of modifications!
!RedditSilver
!redditsilver
Out of curiosity: Any reason you chose to use manjaro over base arch? I tried to run manjaro but had some issues, and the installer not offering i3 (at the time, might have changed since) made me go for a full manual arch install. This was a while back though so it may not be the case anymore.
&gt;vim is the same no matter what distro you're using. sure, but python isn't. Which is kinda the important thing. Ubuntu, for example, still has 2.7 as default while others like Arch already run 3.6
Cool, maybe I should finally learn Vim. Is it worth it?
Haskell is older than Python. 
Dude; Elixir if you're looking for something a bit more mainstream, even ruby has some pretty nice elements of FP.
If you want to build something that's going to be used in the real world, you should use a distro that is used in the real world either directly as your desktop or as part of your testing. FWIW, I run Debian, because we run Debian, and everything I do will run on Debian. If we were a SLES shop I'd be running Suse. If you want to release something, use Suse/Centos/Debian for testing and whatever distro that adheres to PEP 394 on your desktop. (i.e. Most distros except Arch and Gentoo and derivatives)
This definitely looks good.
vim is like the universal text editor for - programming laguages - config filles - anything with formal sytax - anything with balanced braces It can handle everything pretty good. However, it is not an expert in any single file type. vim really shines when you edit whatever.py and then stuff.go and then reddit_bot.cpp and then video.ini and then fix_flicker.patch before tweaking your systemd.conf and comparing your nginx.conf to animal_list.json. It is very different from what is a regular text editor nowadays and you will learn a lot basic editing up front before it becomes useful. There is a lot of stuff in vim for historical reasons and a lot of plugins that can add language specific features. I recommend visiting https://neovim.io/ if you want to start using vim.
If you want to enjoy sitting in front of a screen and keyboard, I believe... ABSOLUTELY YES.
There's also the IdeaVim plugin which will give you vim keybindings plus emulation of some vim plugins
[removed]
Looks good. I was trying to install this on my mint machine and get these errors: Error detected while processing /home/z/.vimrc: line 396: E117: Unknown function: pathogen#infect E15: Invalid expression: pathogen#infect() line 437: Traceback (most recent call last): File "&lt;string&gt;", line 2, in &lt;module&gt; ImportError: No module named 'git' Press ENTER or type command to continue Any ideas ? 
Yes, but it's only grown into the niche it is today.
I second pybind11 for C++. I've found that Cython makes assumptions about the C++ memory model that be unworkable in practice - say if you have a class that cannot be constructed normally. I think Cython's C++ implementation is more of a toy with limited and narrow uses. By contrast you can return templated STL containers with pybind11 and get equivalent Python containers back. 
it seems like you don't have git installed on your machine 
https://tecadmin.net/install-git-on-ubuntu/ 
Yes, I find the slightly more assumptions-free approach of pybind11 better in many cases. My *actual* reason for trying it in the first place was that Cython simply did not support wrapping my template-of-a-template-heavy C++ code at all. But that should not be a problem for most code :) On the other hand, I simply love the fact that pybind11 handles conversion between STL containers and Python containers, as well as Eigen matrices and numpy arrays, seamlessly. Big time saver!
Please put some spaces between those lines of code. My eyes are bleeding. 
git --version git version 2.7.4 I have git installed...
whoops you found an error in my vimrc, pathogen is a package manager, i forgot to delete that line Good catch
Is it possible to get Jupiter's doc string functionality with shift+tab in vim? Even as I've gotten used to most of the functions/methods I typically use, I still find my self needing quick access to it, which has delayed me switching to another editor/ide.
Still getting some errors on launching vim: not found in 'runtimepath': "ftdetect/*.vim" not found in 'runtimepath': "ftdetect/*.vim" could not source ".exrc" No matching autocommands not found in 'runtimepath': "autoload/magit.vim" not found in 'runtimepath': "autoload/webdevicons.vim" not found in 'packpath': "pack/*/start/*" Reading viminfo file "/home/z/.viminfo" info oldfiles "development/test01.py" "development/test01.py" 15L, 383C Reading viminfo file "/home/z/.viminfo" marks Error detected while processing function pymode#init: line 2: E319: Sorry, the command is not available in this version: python import sys, vim line 3: E319: Sorry, the command is not available in this version: python sys.path.insert(0, vim.eval('a:plugin_root')) line 4: E319: Sorry, the command is not available in this version: python sys.path = vim.eval('a:paths') + sys.path Error detected while processing /home/z/.vim/bundle/python-mode/autoload/pymode/virtualenv.vim: line 3: E319: Sorry, the command is not available in this version: python from pymode.virtualenv import enable_virtualenv Error detected while processing function pymode#breakpoint#init: line 9: E319: Sorry, the command is not available in this version: python &lt;&lt; EOF line 11: E492: Not an editor command: from imp import find_module line 13: E110: Missing ')' E15: Invalid expression: ('wdb', 'pudb', 'ipdb'): line 14: E488: Trailing characters: try: line 22: E580: :endif without :if: endif line 23: E170: Missing :endfor not found in 'runtimepath': "autoload/vimtex.vim" No matching autocommands No matching autocommands Error detected while processing function &lt;SNR&gt;64_SetIndentGuideHighlights: line 3: E28: No such highlight group name: IndentGuideSpaces Error detected while processing function &lt;SNR&gt;64_SetIndentGuideHighlights: line 4: E28: No such highlight group name: IndentGuideDraw filetype detection:ON plugin:ON indent:ON Tagbar: Ctags doesn't seem to be Exuberant Ctags! BSD ctags will NOT WORK. Please download Exuberant Ctags from ctags.sourceforge.net and install it in a directory in your $PATH or set g:tagbar_ctags_bin. Executed command: "'ctags' --version" Command output: ctags (GNU Emacs 24.5) Copyright (C) 2015 Free Software Foundation, Inc. This program is distributed under the terms in ETAGS.README Exit code: 0 Error detected while processing function tagbar#autoopen[9]..&lt;SNR&gt;160_IsValidFile: line 29: E121: Undefined variable: s:known_types E116: Invalid arguments for function has_key(s:known_types, a:ftype) E15: Invalid expression: !has_key(s:known_types, a:ftype) Error detected while processing function youcompleteme#Enable[12]..&lt;SNR&gt;165_SetUpKeyMappings: line 51: E227: mapping already exists for \d error list 1 of 1; 1 errors Writing viminfo file "/home/z/.viminfo"
Exactly what I was thinking. So far Jupyter and Spyder are the best for working with tests, but I might look into this if I can do it with vim.
You want /r/domyhomeworkformebecauseimacheater not /r/python. 
make sure you have python, ycm is compiled, and you have the ycm_extra_conf.py in the right directory 
I'm pretty sure "mycall" was asking if IronPython targets Python 3.0 NOT are the IronPython team working on getting an IronPython 3.0 release out. To answer "mycall"'s question, the answer is no. IronPython only targets the Python 2.x series.
I love vim, but the effort to turn it into a workable ide compared to firing up pycharm isn't worth it for me. 
Have you ever looked at [coconut](http://coconut-lang.org/)?
I... I forgot... I labeled it as accepted.
This mostly what I do. But I have been adding mypy to the mix lately.
ycm is compiled and ycm_extra_conf.py is in ./.vim/ Still getting these errors on launch. not found in 'runtimepath': "ftdetect/*.vim" not found in 'runtimepath': "ftdetect/*.vim" could not source ".exrc" No matching autocommands not found in 'runtimepath': "autoload/magit.vim" not found in 'runtimepath': "autoload/webdevicons.vim" not found in 'packpath': "pack/*/start/*" Reading viminfo file "/home/z/.viminfo" info oldfiles "development/test01.py" "development/test01.py" 15L, 383C Reading viminfo file "/home/z/.viminfo" marks Error detected while processing function pymode#init: line 2: E319: Sorry, the command is not available in this version: python import sys, vim line 3: E319: Sorry, the command is not available in this version: python sys.path.insert(0, vim.eval('a:plugin_root')) line 4: E319: Sorry, the command is not available in this version: python sys.path = vim.eval('a:paths') + sys.path Error detected while processing /home/z/.vim/bundle/python-mode/autoload/pymode/virtualenv.vim: line 3: E319: Sorry, the command is not available in this version: python from pymode.virtualenv import enable_virtualenv Error detected while processing function pymode#breakpoint#init: line 9: E319: Sorry, the command is not available in this version: python &lt;&lt; EOF line 11: E492: Not an editor command: from imp import find_module line 13: E110: Missing ')' E15: Invalid expression: ('wdb', 'pudb', 'ipdb'): line 14: E488: Trailing characters: try: line 22: E580: :endif without :if: endif line 23: E170: Missing :endfor not found in 'runtimepath': "autoload/vimtex.vim" No matching autocommands No matching autocommands Error detected while processing function &lt;SNR&gt;64_SetIndentGuideHighlights: line 3: E28: No such highlight group name: IndentGuideSpaces Error detected while processing function &lt;SNR&gt;64_SetIndentGuideHighlights: line 4: E28: No such highlight group name: IndentGuideDraw filetype detection:ON plugin:ON indent:ON Reading viminfo file "/home/z/.viminfo" marks not found in 'runtimepath': "ftplugin/tagbar.vim ftplugin/tagbar_*.vim ftplugin/tagbar/*.vim" not found in 'runtimepath': "indent/tagbar.vim" 8 more lines Error detected while processing function youcompleteme#Enable[12]..&lt;SNR&gt;176_SetUpKeyMappings: line 51: E227: mapping already exists for \d error list 1 of 1; 1 errors not found in 'runtimepath': "autoload/UltiSnips.vim" Writing viminfo file "/home/z/.viminfo" 
ORMs use database drivers behind the scenes. It’s like asking if you should use a car or use gasoline.
I run Debian or sometimes Void Linux
I'm not sure what you mean by "general purpose application server" but yes, you can use flask to serve content generated by another process. A few months ago I wrote a service like this. Basically it get the data available on StatusCake from time to time, then serve this data on a format that our monitoring tool (prometheus) understand. If you want to have a look the code is https://github.com/psychopenguin/prometheus-statuscake-exporter (sorry, i hadn't enough time to document it yet)
For a while I thought I was in /r/unixporn. Looks so nice.
Mostly laziness. Manjaro *is* Arch, with an installer. Manjaro-i3 was the only distro that offered i3-gaps with zero effort.
https://www.amazon.com/gp/product/B011KF6GW4/ref=oh_aui_search_detailpage?ie=UTF8&amp;psc=1 I've used this one with Python and a Raspberry Pi to do make my a Donald Trump Twitter printer. I don't specifically remember what library I used, but it seems to work well.
Agreed, I just wish that Ideavim felt more natural. If someone more capable than me would be able to implement Neovim in IntelliJ I would be so happy.
As a python guy who went to UB, I salute you. But you can still pry PyCharm from my cold dead hands. xD
I have to keep reminding myself that people actually ask questions over there. I just use it as a static "wiki", of sorts. 
I think it's worth it, but it is a significant time investment. It took me about two weeks of using it exclusively at my job before I wasn't actually slower than I was with a regular editor. Learning all the ins and outs is still happening, now 10 years later. There is a lot to learn, but I think it can make you faster in the end.
I dunno about aggressive, but if I were a 20-year python vet, and someone asked a question, and then said "I think you're wrong", I might get a little prickly. 
Does python-escpos ring a bell? Thanks btw!
Yes, but it lacks most significant FP features. And it requires compilation. It is a viable option right now, however.
I think this is what I need..Basically a headless service like app . I'll take a look thank you! 
No. Performance is not a simple game. How the h*ll would adding more RAM just magically make things faster? Are you running on a loaded system already? - Understand all the operations you're doing. * Is that operation pure Python, or is it partially in C (because it links to say, libarchive)? * Is that operation parallel under the hood? * Are you actually running out of RAM? * Have you run the code under `cProfile`? * You do know that tar is an unseekable streaming format, so it could affect the performance of the underlying code, right? * How big is the file? * Are you sure it's just not Jupyter notebook not reporting that the code is done when it already is. Mind you, you *are* using Windows. I hope you're running Python natively rather than under something that kills performance like Cygwin. And your system would probably not be so memory hungry in the first place if you didn't run Windows. The only thing that takes any RAM on mine is Chrome, and it doesn't swap like a greedy…
Yeah, and setuptools just works, and isn't messed up like Amazon Linux, Ubuntu used to be, Fed-up-ora, etc.
Yes. That was the one, now that you mention it. I use the twitter API to get Trump's tweets. There are some occasional character encoding issues that causes certain special characters and punctuation to print incorrectly, but it was just a fun project for the break room. Since I had it up and running pre-election it worked well enough for it's intended purpose that I haven't went back to try to clean up the character encoding bugs. I'm sure it would be easy to work around if I tried.
Agreed. I haven't used vim for any major python projects, but the way that buffers, windows, and tabs are implemented is just incredibly powerful, and far more useful than in any IDE I've used to date. What's your experience with the various python plugins, how good is the autocomplete, linting, etc... The one thing I know you might of that you might miss moving from pycharm to vim is the debug tools.
Thanks for the response! I really appreciate it! I updated the OP to include a version of the code that people can use to run this text case, without having to install numpy, scripy, etc. here it is &gt; url = 'https://commondatastorage.googleapis.com/books1000/' &gt; last_percent_reported = None &gt; data_root = '.' # Change me to store data elsewhere &gt; &gt; &gt; def download_progress_hook(count, blockSize, totalSize): &gt; """A hook to report the progress of a download. This is mostly intended for users with &gt; slow internet connections. Reports every 5% change in download progress. &gt; """ &gt; global last_percent_reported &gt; percent = int(count * blockSize * 100 / totalSize) &gt; &gt; if last_percent_reported != percent: &gt; if percent % 5 == 0: &gt; sys.stdout.write("%s%%" % percent) &gt; sys.stdout.flush() &gt; else: &gt; sys.stdout.write(".") &gt; sys.stdout.flush() &gt; &gt; last_percent_reported = percent &gt; &gt; &gt; def maybe_download(filename, expected_bytes, force=False): &gt; """Download a file if not present, and make sure it's the right size.""" &gt; dest_filename = os.path.join(data_root, filename) &gt; if force or not os.path.exists(dest_filename): &gt; print('Attempting to download:', filename) &gt; filename, _ = urlretrieve(url + filename, dest_filename, reporthook=download_progress_hook) &gt; print('\nDownload Complete!') &gt; statinfo = os.stat(dest_filename) &gt; if statinfo.st_size == expected_bytes: &gt; print('Found and verified', dest_filename) &gt; else: &gt; raise Exception( &gt; 'Failed to verify ' + dest_filename + '. Can you get to it with a browser?') &gt; return dest_filename &gt; &gt; &gt; train_filename = maybe_download('notMNIST_large.tar.gz', 247336696) &gt; test_filename = maybe_download('notMNIST_small.tar.gz', 8458043) &gt; &gt; num_classes = 10 &gt; &gt; def maybe_extract(filename, force=False): &gt; root = os.path.splitext(os.path.splitext(filename)[0])[0] # remove .tar.gz &gt; if os.path.isdir(root) and not force: &gt; # You may override by setting force=True. &gt; print('%s already present - Skipping extraction of %s.' % (root, filename)) &gt; else: &gt; print('Extracting data for %s. This may take a while. Please wait.' % root) &gt; tar = tarfile.open(filename) &gt; sys.stdout.flush() &gt; tar.extractall(data_root) &gt; tar.close() &gt; data_folders = [ &gt; os.path.join(root, d) for d in sorted(os.listdir(root)) &gt; if os.path.isdir(os.path.join(root, d))] &gt; if len(data_folders) != num_classes: &gt; raise Exception( &gt; 'Expected %d folders, one per class. Found %d instead.' % ( &gt; num_classes, len(data_folders))) &gt; print(data_folders) &gt; return data_folders &gt; &gt; train_folders = maybe_extract(train_filename) &gt; test_folders = maybe_extract(test_filename) As for your questions. &gt;Is that operation pure Python, or is it partially in C (because it links to say, libarchive)? I **think** it's in pure python. As far as I can tell from the code. &gt;Is that operation parallel under the hood? I am not sure how to figure that out. I'll look into it. &gt;Are you actually running out of RAM? No, not on my computer. From my limited knowledge , I was guessing python didn't have a lot allocated to it? &gt;Have you run the code under cProfile? No, I will look into it soon. &gt;You do know that tar is an unseekable streaming format, so it could affect the performance of the underlying code, right? I don't know what this means, but I'll look into this as well. &gt;How big is the file? the bigger file is 241 mb when zipped. &gt;Are you sure it's just not Jupyter notebook not reporting that the code is done when it already is. yes. I can look at the folders and know when it's done unzipping all the files. &gt;I hope you're running Python natively rather than under something that kills performance like Cygwin I am not using Cygwin. I am not sure if I am running Python natively . I am using pycharm. 
you have the wrong version of python
Same here. I use an IDE for development on my workstation, VIM on remote systems running Linux/Ubix, and Atom for text editing on my workstation. 
&gt; No, not on my computer. From my limited knowledge , I was guessing python didn't have a lot allocated to it? That's not how a "modern" operating system allocates memory. Do you understand operating systems? Do you know about virtual memory? Process scheduling? &gt; the bigger file is 241 mb when zipped. 1. That's tiny. Should not even take 5 minutes unless you're I/O bound (like if it had an extraordinary compression ratio). 2. Zipped, zipped, zipped, zipped. Is it a tar file or is it a zip file. "Zipped" is not a genericised trademark. Say archived, compressed, or both. &gt; I am not using Cygwin. I am not sure if I am running Python natively . I am using pycharm. You're probably native at least then.
Ohh wow this is almost identical to mine. Airplane bar, nerdtree, Tagbar, are you running YCM and syntastic?
Cool! Could you walk through the logic on that?
You like my username? 
I found much the same issues with atom as vim. I had to hunt and peck for a working combination of plugins that ultimately wasn't as good as intellij/pycharm. I hear visual studio code is slick and has some great tooling but idk if it would be a better python ide. Since it runs on *nix I may kick it around the block in the future
great minds think alike
&gt;Do you understand operating systems? Do you know about virtual memory? Process scheduling? I do not, but I'll look into those. &gt; unless you're I/O bound (like if it had an extraordinary compression ratio).] Hmm I do not know if this is the case. &gt;Is it a tar file or is it a zip file? "Zipped" is not a genericised trademark. Say archived, compressed, or both. it is a tar / tar.gz file 
A recent convert to vim for python and I have been using quite a few of these plugins. NerdTree and Vundle are excellent. Thanks for putting this .vimrc together :)