It's running OSCommerce seems like.
Because the OP mentioned Ubuntu which is a gtk based system. Honestly, there's really not much difference between the two for the python programmer. They both do pretty much the same thing in pretty much the same way. The best way to choose is to look at external factors such as other dependencies that your app may need, or what platforms you want to target, since they will have far more bearing on your decision.
yeah ... I've learned that lesson (*textmate*). That's why I'm learning emacs right now.
no no you did not understand. 1. find a product idea 2. write a rant about someone else who has created it before you 3. release yours 4. profit?... or not?
Some of us have evolved beyond debugging with print statements :)
cmon python, be indulgent.
So obviously I evolved back to print statements and test coverage...
ONE WAY TO DO IT
The batteries-included Python debugger integrates really nicely with Emacs. You don't have to rely on print statements.
I don't see why Ubuntu is a gtk system has anything to do with it. It's not as if it's incompatible or themes don't migrate to Qt.
You might find Python Module of the Week interesting also: [http://www.doughellmann.com/PyMOTW/contents.html](http://www.doughellmann.com/PyMOTW/contents.html)
I use Ubuntu, tu. [Quickly with ubuntu-project:](http://blog.didrocks.fr/index.php/post/Build-your-application-quickly-with-Quickly%3A-Inside-Quickly-part-7) &gt; * Python for the language &gt; * pygtk for the UI framework &gt; * Glade for the UI editor &gt; * Gedit for the code editor (though this is easy for you to change if you choose another one) &gt; * bzr for version control &gt; * Launchpad for code hosting &gt; * desktopcouch for storage/database (!) [Quickly](https://wiki.ubuntu.com/Quickly) install [Getting Started with Quickly](http://www.youtube.com/watch?v=dx93U10Kkro&amp;feature=PlayList&amp;p=BB56751A5D55ED53&amp;playnext_from=PL&amp;index=0&amp;playnext=1) 3 youtube videos, I think it is Quickly 0.3 [Quickly, some commands](http://blog.didrocks.fr/index.php/post/Build-your-application-quickly-with-Quickly%3A-Inside-Quickly-part-7) [Quickly, more commands](http://blog.didrocks.fr/index.php/post/Build-your-application-quickly-with-Quickly%3A-Inside-Quickly-part-8) [QuicklyFun](https://wiki.ubuntu.com/MeetingLogs/devweek0909/QuicklyFun) when Quickly was 0.2 [Acire](http://aciresnippets.wordpress.com/install/) python snippets, viewer + "hack n' run" [Quickly-0.4 available in Ubuntu 10.04](http://blog.didrocks.fr/index.php/post/Quickly-0.4-available-in-lucid!) [Logs from UbuntuOpportunisticDeveloperWeek 1st - 6th March 2010](https://wiki.ubuntu.com/UbuntuOpportunisticDeveloperWeek), including Pre-week [Intro to Python for total beginners](https://wiki.ubuntu.com/MeetingLogs/OpWeek1002/Python4Beginners) and [Intro to Python for programmers](https://wiki.ubuntu.com/MeetingLogs/OpWeek1002/Python4Programmers) [More about Quickly](http://blog.didrocks.fr/index.php/?q=quickly) [Ubuntu Forums : Development &amp; Programming](http://ubuntuforums.org/forumdisplay.php?s=3b2f84225be880b016d9eb412c1cf64e&amp;f=310) [Planet Ubuntu](http://planet.ubuntu.com/) [Opportunistic programming](http://www.jonobacon.org/?s=opportunistic) and [Connecting The Opportunistic Dots](http://www.jonobacon.org/2010/01/30/connecting-the-opportunistic-dots/) Edit1: When "quickly edit" opens the files in Gedit, you probably want to edit the main file - the one that has the "#!/usr/bin/python" in line 1. Edit2: [videos and blog posts](http://theravingrick.blogspot.com/search/label/quickly) (theravingrick.blogspot.com) via [moephan](http://www.reddit.com/r/linux/comments/cgwtt/quickly_rapid_project_development_on_ubuntu/c0sick1)
Yes. Also try the following for getting help on general topics: $ pydoc topics [...] $ pydoc OPERATORS 
&gt; I have open aliased to emacs on non-Mac unixes If you use GNOME, try [gnome-open](http://embraceubuntu.com/2006/12/16/gnome-open-open-anything-from-the-command-line/).
1. Look at [my comment in sister thread made 3 days ago](http://www.reddit.com/r/Python/comments/bvtbn/zed_shaw_started_writing_his_own_python_book_for/c0otbhm). 2. Think how big of douche this guy is. 3. ... 4. High five. 
Wow. ... Thanks!
i disagree with your disagreement. pydev/eclipse's project based file system abstraction is useless and gets in the way and visual debuggers are for kids. ipython4lyfe
fork it, put it in mercurial and upload it to bitbucket... problem solved.
writing CSS seems to be easier.
No problem. When "quickly edit" opens the files in Gedit, you probably want to edit the main file - the one that has the "#!/usr/bin/python" in line 1.
Funny, because: &gt; if you list [your dependancies], make sure you set the minimum required version to the one released yesterday, even if module works fine with version released 2 years ago is what moved us off of Debian. Every time we wanted to install or upgrade one little package (say, `pv`), Debian would insist on upgrading libc, which would want to upgrade postgres (right, we'll just upgrade postgres 8.2-&gt;8.4 on a running production server), which would want to install X11 (wtf?)... when there's no way that the package we wanted needed a newer version of libc to begin with.
Perhaps, although if you have your python dynamically generating HTML and accompanying CSS, this might be handy to use logic to specify how styles are designed rather than, say, through client-side javascript. There are other methods, sure, but sometimes it may be useful.
Was that with Debian stable?
I don't remember, but it seems unlikely that we'd be running `testing` in production, so I'm going to guess yes
1. notice a trend 2. mimic the trend 3. ... 4. get downvoted!
Check out some nice [videotutorials](http://us.pycon.org/2010/tutorials/) from PyCon US. Most of them are 2+ hours long with downloadable handouts. Not all of them include links to videos for some reason, but you can find them at [blip.tv](http://pycon.blip.tv/rss).
The truly impressive thing about this library is that it is implemented in 81 lines of Python. Seriously! http://github.com/fitzgen/zoolander/blob/master/zoolander/__init__.py
I'd be more interested to learn why developers want to stop their modules being distributed in Debian.
it was a joke
I use emacs myself, but I thought VIM had the [retab](http://www.gwhiteman.com/python/intro_to_python.html) cmd which seemed to work at fixing broken python files for the most part. "As a side note, if you are a vim/gvim user this will sequence will fix any indentation issues with Python:" set ts=4 (sets tabstops to 4) set et (expands tabs to spaces) :%retab! (enter command mode, retabify) :w (enter command mode, write file) 
Delphi was my first few jobs out of college. Those were good productive times, then there was VB6, then C#/ASP.net and now JAVA and I'm old. I miss Delphi. RIP good 'ol Borland
this is neat for sure but I'm pondering it's applicability. There have been occasions where I have wanted to reference variables in CSS, but not sure the overhead would be justified. You'll find me over there on the fence for now.
&gt; but it seems unlikely that we'd be running testing in production It's more likely than you think. Some people run Ubuntu servers after all, and that's pretty much equivalent to running a slightly stabilized debian unstable.
Well, now we're on Ubuntu at EC2, which doesn't appear to have that problem. So far, anyway
[The first section of the chapter](http://diveintopython.org/getting_to_know_python/index.html) gives the complete source code and the expected output. It's just a one-line function that takes some input, transforms it, and returns it to a caller who prints it. That's it.
So what? The **point** is that it isn't a meaningful name or a meaningful transformation for the beginner. There are a million more relevant examples you could use. Whoever downvoted me, nice job playing popularity instead of actually thinking.
I asked a question similar to this some time ago in the newsgroups, have a look at: [link](http://groups.google.com/group/comp.lang.python/browse_thread/thread/e9c305645b4d3046/eb26024e362d4d72?q=#eb26024e362d4d72)
It is more an issue that until recently vim didn't understand python syntax at all, and even now it remains a bit buggy. Thus if you try to retab a file, or simply hit return while editing, it will not always get the correct indentation level. There are a couple scripts on the vim site which specifically add improved support for python syntax, and indentation. With those it will work as expected. 
Generating CSS programmatically seems kind of expensive.
I want to use your book but I have a concern - My workplace does not have Python 3 installed (there's no upgrade in the near future). I am a beginner - do you think I can still use this book to learn Python if I'm going to need to use it in Python 2.6?
Shell one-liner: python -c 'print "/n/n".join("%s:\n%s" % (k,v.__doc__) for (k,v) in __builtins__.__dict__.iteritems() if hasattr(v,"__doc__") )' &gt; builtins (replace / with \\ because of stupid markdown processor)
well, the tabify seemed to work the few times I had to use it and it was a life saver. FWIW, emacs doesn't seem to have those problems as far as I can tell, maybe I should expect my editor to do more for me maybe? /shrug
yeah me too. the book is all right, but I wouldn't recommend it for a python newb. seems to me the person who chooses to read that book already has something in mind they need to do, like process a bunch of data and get some graphs, and they know python. It's not for everyone.
&gt; if you list [your dependancies], make sure you set the minimum required version to the one released yesterday, even if module works fine with version released 2 years ago It's surprisingly difficult to test libraries against 2-year old dependencies. Unless everything is very self-contained (unlikely), it's usually easier to hunt down an old Debian/Ubuntu/RH/etc install disk and use that in a VM than to try to mix-and-match temporally-distant library releases. Sure, my `libspam` specifies `libham` 1.8 as a dependency, but actually only needs 1.4. How would I know? `libham` 1.4 hasn't been available in my repositories for years, it uses `yield` and `with` in dozens of places as variable names, and its C extensions don't compile with more modern GCC releases. There's no way I could test against it on a modern system, and installing an antique is *way* more effort than I'm willing to go through on the off chance that somebody, somewhere, wants to use my week-old library on a years-old installation. If the Debian team wants to have outdated dependencies in their repositories, it's their responsibility to test and see if it works. Does it work with an older version? Great! Patch the version check, send me an email, and I'll merge it in.
Nice bit of python programming, but I cannot think of an application for this.
Correct -- thanks for the note. Twitter [posted an update](http://groups.google.com/group/twitter-api-announce/browse_thread/thread/f71eb68600996af8) recently clarifying the situation (after posting a note de-clarifying things :-) ). 
The Python subreddit is not really that web2py unfriendly (people aren't going to be mean to you or anything). However, I think there is a little bit of a disappointment (is that the right word?) in regards to web2py. For whatever reason (licensing, style of coding, etc....) people may not prefer web2py or they may just like some other framework better. However, there have been many posts on this reddit trying to promote web2py that I think has worn people a little bit the wrong way. So... not really anything meant to be mean, but maybe it is a little of a reaction to that. Oh, to answer your question, yeah ease in any development environment is great. Some of the other frameworks (like Pylons) really have a problem in terms of being easy to get started (except maybe for Django).
Did apt-get fail?
Your CDN might be serving content too quickly and you want to serve css from your app server, your app server might be serving too many requests/sec and you want to slow it down...
Not to mention some people run Windows servers after all, that's pretty much equivalent to running a slightly destabilized unbuntu desktop.
My sentiments exactly. In my opinion, it's enough to test on whatever versions are available on the distributions you intend your software to run on. I fat some point you get users on some older distros that are interested in your modules, you can test them there too.
well nothing wrong with expecting a package to grow in the future.
what's the problem?
This seems a little convoluted and exactly what [Sass](http://sass-lang.com/) was created for. Python is to C++ what [Sass](http://sass-lang.com/) is to CSS.
awesome. thank you.
SASS seems to be much easier.
i wonder if the author knew about [clevercss](http://github.com/dziegler/clevercss/)?
CSS I don't need python for, this doesn't look like it *saves* time... For [XML](http://slip.sourceforge.net/) though...
I am a big fan of ReSharper, so I will have to check this out.
and that really hurt.
What a horrible problem, yes, I can see how this would be the perfect solution.
My only gripe with people using debs of my python packages is that they end up filing bugs on the debian tracker rather than the project bug tracker. I've had that happen a few times, and people didn't even bother mailing me to tell me that someone had a problem with my stuff.
the Debian maintainers/developers really need to get off their high horse imo.
Yeah. Expecting people to follow any kind of decent standards if they want their stuff packaged.
Thanks for the warning. I would have probably assumed the same thing.
Isn't that exactly the reason that the OP is pointing this out? If pv was packaged with a requirement for a needlessly recent version of libc, when it would have worked with an older version, then this could lead to a cascade of unnecessary updates. The points made by jmillikin and kisielk are pretty valid, though.
I just happen to have a strong opinion about what constitutes 'real' software, just as many people seem to think that 'real' scientific knowledge is knowledge you don't have to buy from some company, and that you can only use in a way that is acceptable to this company. if thinking about fundamental freedoms and spreading it, in a polite way, is immature, I'm glad to be in good company: http://www.youtube.com/watch?v=E6LsfnBmdnk
Hi. `import` statements need not be at the top of the code, you can place them anywhere. In general, if only one function requires a module, place the import inside that function, this may help avoid circular imports.
Reading your situation, I think you've got to suck it up and merge. If there's no hierarchy and neither functions without the other, then don't they belong together?
As inelegant as this sounds, I think you may be on to something.
You need to avoid using from foo import bar statement. in your model you can do something like this: import app.model.user_producer as mo_up now you will be able to use it like mo_up.UserProducer inside other class without any issues. I have a model that depends on 30 other models at same time, so i can assure you that this works. Also as someone mentioned you can import inside a function but i think my solution is better.
It can be done without any big issues. As i replied in other comment ;-)
 \ is a backslash in code fucks up the \\ n normally, one can escape backslashes using a backslash \\\\ --&gt; \\ \\n
Why do they live in separate files when they're so obviously related? Why do you have a method called `User.create` when it seems so useless (reminder: you're not coding in java here)? What the fuck does `UserProducer` do, why isn't it done by `User` or by `User`'s metaclass? If `UserProducer` is supposed to interact with the database and `User` is just a dataholder, why the hell do you not create `User` instances via `UserProducer`? &gt; I don't want to put them in the same file either, as that would get bloaty quite quickly. If two classes in a Python file get bloaty pretty quickly, I say you have issues in your python.
This has nothing to do with the problem. Circular imports are only problematic when you use the *from x import y* format. As long as you use only *import z*, you'll be fine with anything circular. Imports should only be at the top so it's easier to see what are the dependancies.
Meh. You should have written it in CPython bytecode, then it'll be cool!
It might be neater if you could implement inside a Django app - for example a template tag that automatically converts the given Python module into CSS in DEBUG mode.
I think this is a problem related to the way packages work, not the circular import issue itself. The problem occurs when you mix 'from import bar' with 'import foo.bar' in your package. Using 'from' imports is just fine, just as the absolute imports you suggest, it's mixing these patterns that is the actual problem. The problem starts because there might be code in the __init__.py in the package foo that imports from somewhere within the package. If you then import from the package in other modules in that package, you can run into circular import problems as in some cases the __init__.py needs to be loaded to finish the import of 'bar', but __init__.py imports from bar, argh. The problem occurs when you mix 'import foo.bar' with 'from foo import bar', however, not if you just use either one of them. This is due to some subtle details of module initialization I can't recall of the top of my head. I looked into it once as some developers have converged on the 'import foo.bar' pattern as a solution to this issue and think it is the *only* solution, but they're wrong. I like my 'from' imports. 
I design my things so I don't get circular dependencies. Typically the things that require circularity can be spun off to a third module.
The problem is a bit more subtle than you are suggesting. I use 'from x import y' all the time, and I don't get bitten by circular imports very often. I think that's in part because I design my modules not to be mutually dependent anyway (that's good design practice). The only case where it's really hard to avoid is when you got a package that does imports from modules in the package in __init__.py, and you do imports in the package's modules too. You can easily get circular dependencies that way, but you only get the import errors when you mix from imports with absolute imports. Consistently sticking to either pattern gets you out of the issue. 
 class User: def create(): import UserProducer as P P.verb() Subsequent runs hit the import cache.
How is the source for the last line? When I typed a pair of backslashes followed by an n, then it renders a space in between..
This is bad practise.
&gt; I expected logging.critical() to write the email to a local buffer, and for sendmail (or whatever) to pick it up and deliver it later. What does this means exactly? SMTPHandler pushes the email to an SMTP server, how could it "write the email to a local buffer and wait for sendmail to pick it up"? (and while it waits, wouldn't it be... waiting?) &gt; It turns out that logging.debug() blocks, waiting for the logging.critical() call to complete. I wouldn't expect this when using *different* loggers for each of those calls, but the same logger? Yeah definitely, it's not unlikely the logger has internal state it needs to manage during logging, and it's not like you guarantee all handlers are going to be different, so at the *logger* level it's sensible to serialize logging calls. And the `logging` utility functions are all backed by the same logger. &gt; Is my MTA running too slowly, even though it is on the localhost? Could it be making me wait while it sends the email, rather than buffering and sending it later? Could it be protecting itself from elephant-interferers err.. spammers by deliberately running slowly? Or is it inappropriate for me (and SMTPHandler) to have every thought it should be fast enough? At that point, I'd consider using either a SocketHandler or a custom handler and sending the various logging tasks to a task queue who'd be free to take as long as it wants to do whatever it wants done. edit: oh, I see Vinay (the `logging` maintainer) has commented in the thread.
+1 I avoid circular dependencies too. Most of the time they occur because your API is not well organized. If they can't be avoided, I use an import statement local to my function or method. In your case, it sounds like you miss another module (util?) that would have a function that return users instances, or whatever the Producer stuff needs. Unlike some other folks here, I think it's a good practice to split the code in several modules, and avoid having tons of classes in the same module. When it grows, it helps. Ending up with a several-thousand lines module quickly become a nightmare whereas small modules are easier to read, tests etc. Java "one class per module" is a bit too much, but avoiding big modules is better. 
Okay then I will choose to define a 'real' maintainer as one who doesn't leave its users in a lurch for idealogical reasons and insult them about it.
How do **you** deal with it?
This. From what the op describes, the API sounds weird and unpythonic. Fix that and the problems will likely go away. 
Tears and half a bottle of whiskey.
This will fail to discover missing modules until well into runtime. It's ok, but only with a note in the module doc-string to indicate that the import is possible. Unless the import is delayed because of speed, it's better to import at the top of the module and then bind the variables later. E.g., instead of def foo(): from OtherMod import bar prefer import OtherMod def foo(): bar = OtherMod.bar
I was expecting something along the lines of (In python shell): import urllib2 urllib2.__file__ 
You need to handle missing modules where/whenever they're identified. What's the difference between: try: import foo except ImportError: blah def bar(): foo.baz() and def bar(): try: import foo except ImportError: blah foo.baz()
You could store the index values in a list: zeroes=[] for i in range(0,1000): if numbers[i] == 0: zeroes.append(i) print(zeroes) If you can bear an improvement suggestion, try to rewrite those for loops in one single double for loop. Something like for factor in [2,3,5,7,11,13,17,19,23]: for i in range(numbers[factor], 1000, factor): numbers[i]=1
Right, now after taking a second look, you first should create a function that takes an integer and returns True or False depending if it's a prime number or not. Try that first, and then continue with the sieve. EDIT: ignore this please, I was thinking of something else. Of course you don't need a prime() function in an algorithm which tells you which numbers are prime :)
Thank you very much. I appreciate your help and your suggestion :) I have no experience with this factor function. I'll play around with it a bit and see what I can learn. Does this mean then that there is no way to print the index values of the 0 items? Just trying to learn as much as I can.
Move User.create() to UserProducer.createUser(). Code creating user will depend on the UserProducer module. UserProducer depends on User module. 
Initializing the list is more easily done like this: numbers = [False] * 1000 And it would probably be better to use the `bool` type instead of `int`, though I could understand a bunch of `int` values are more readable when you do `print(numbers)`. Instead of all the for loops maybe you could do something like: for i in range(0, 1000): if not numbers[i]: for j in range(i, 1000, i): numbers[j] = True (I haven't tested this!) The part that you can't get to work is done like so: for (index, value) in enumerate(numbers): if not value: # this works for both int and bool values print(index) 
I use http://namecheap.com because well, it's cheap I know a lot of people in this community use http://www.gandi.net/ because of its TLD availability and the "no bullshit" theme.
 for (index, value) in enumerate(numbers): if not value: # this works for both int and bool values print(index) Or a listcomp: print [index for (index, flag) in enumerate(numbers) if not flag]
Why is this in /r/python? Surely a registrar has nothing to do with your language of choice. 
The first fails on import whether bar is called or not, while in the second case you only discover the failed import when bar is called. Where this really becomes a problem is cases like... try: # Something that succeeds 99.9% of the time for the module developer. except: import loging # Note the misspelling. ... Unit tests *should* catch simple cases, but that's a big "should." The deeper the imports are buried the lower the odds that they're covered.
Not sure about the specifics of your problem but in general if you want to print the index of iteration you can use the enumerate function. For example: for idx, value in enumerate(collection): print "Index: %s, Value: %s" % (idx, value)
As far as I can tell, the code you've written should run fine, despite room for improvement that everyone else has pointed out. The line you're missing is, in python 2.x at least: `print i,` (note the comma at the end, this tells print NOT to add a newline, so all your values will be on the same line making it easier to read... you can remove the comma to get them on separate lines if you like) The brackets on print are optional in 2.x. I would recommend not including them, as print is NOT a function and doesn't act like one. If you're using 3.x, print has been substantially changed, and in that version it IS in fact a function. The equivalent command in Python 3.x should be something like: `print(i, end=" ")` although I could be wrong as I don't have much experience with 3.x yet. edit: well, it does run but there's a bug in your for loops. Try replacing all your for loops with something like this (using 23 as an example): for i in range(23 * 2, 1000, 23): numbers[i]=1 What's happening is, first of all, you're starting your loop at the *value* at numbers[23] in the array which is always going to be 0. So you're doing `range(0, 1000, 23)`, essentially. Take the array part out of it, and you'll have `range(23, 1000, 23)` which is closer, but that is still not quite what you want, because python will start at 23 (your prime number!) and set it to 1, as if it wasn't prime. *Then* it will finally move on to 46 and correctly set it as not-prime. By starting the loop at 23 * 2 (46) you start the loop at the right place and avoid setting your starting prime as non-prime. 
This. enumerate() is the Right Way to do that kind of iteration.
Here's how I would write a Sieve of Eratosthenes: size = 1000 numbers = [0] * size # start at 2, which is our first actual prime number for j in range(2, size): if not numbers[j]: # number is prime! start looping at prime times 2, and set all multiples as non-prime for i in range(j*2, size, j): numbers[i] = 1 for i in range(2, size): if not numbers[i]: print i, I've tested this and it does seem to work. Hope that helps! Ask me if you have any questions. Good luck! 
there are performance implications also, trying to import foo every time you call bar()
you can also throw the import in __init__() and set self.P = P
I used to think it was necessary but I think I follow hylje's ideas more often now.
"Doctor, it hurts when I do this." "So don't do that." 
Put them in the same file. Edit: come to think of it, why would you have a UserProducer _class_? When I need a factory, I just put a create\_user _function_ in the same file as the User class. A class with no data and just one "class method" has no business being a class.
Namecheap is a Enom reseller, and they are pretty good. I would also look at Moniker, what they lack in functionality they gain in never have having a domain stolen in their system. Registrar's I would stay away from are GoDaddy and Network Solutions.
I prefer GoDaddy - their control panel, although not the most usable in the world, is still pretty good (especially when you start managing multiple domains). Plus, you can always find a coupon code for a couple bucks off the price, usually bringing a 1-year .com down to around $8.
What is the subreddit you suggest it should be posted in?
I love pyqt my applications run great on OS X windows and linux. I use vim and eric4 for my IDE 
/r/webdev maybe. even /r/php would be a better choice since PHP is at least a web-only language. I would wager that the majority of people reading /r/python dont even use python for web development, its not a strictly web language. 
And if I like python web developers more than php web developers? And I specifically wanted their input? Anyway, don't want to bitch around, you are right.
I use [123-reg](http://www.123-reg.co.uk/), it's good if you are in the UK.
Hey guys -- sorry I missed this post, I read reddit every day, so I'm not sure how that happened. Anyway, instantdjango is my project. I agree with the comments here that are telling you to use linux, but please understand that this project's goal is very limited. It is intended for people stuck on Windows - me at work - with no ability to install software. It's pretty good for learning Django, but not intended for deployment or serious development efforts. Also, I think the tutorial I wrote is pretty good for people trying to learn Django who are totally new to programming. I'll admit that I haven't been the best maintainer, but I am insanely busy at work, so that's how it goes. If you do try out instant django and you experience any problems, please let me know. 
Use "from module import object" statements at the exact position you need them inside functions and methods. Never at the top of modules. You want to use the "from module import object" form instead of "import module" to avoid polluting the namespace. Remember "from module import object" inside functions and methods only. You'll never have to worry about circular imports again. Not to mention, you'll only import what needs to be imported when it's needed and nothing more. This is one trick used to improve the startup speed of applications.
Thanks for the heads up.
i dont mean just with packaging. devs they do not like they completely shit on, such as php. sure its not the best language but no reason to piss on someones parade, just saying no is jusst as effective.
Although PyCharm is a real memory hog. (At least for me on linux)
 &gt; * reflection (getattr, hasattr), eval, or other really dynamic stuff Damnit. &gt; * variable numbers of arguments and keyword arguments Fuck. &gt; * multiple inheritance Rawr. &gt; * nested functions and classes Sigh. &gt; * unicode Fuck sake. &gt; * overloading \_\_iter\_\_ and \_\_call\_\_ Goddamn. &gt; * closures Fuuuu~ I don't think Shedskin is for me... :( 
Mitigated by the import cache. 
What does it do, can you give more info. Does it help you generate a jar or something ?
Yes. There aren't that many changes between Python 2 and 3 that the book uses, and they're documented in Appendix A: http://inventwithpython.com/appendixa.html
A few solutions work, none are pretty. All this jumble about poorly designed code isn't always true. * Put the import into the function that needs it. * Move the import to the bottom of the module. * Use dependency injection. ie: pass the class you need into it. * Move common functions to a third module (best one IMO).
Thanks! I'll start working on it then.
One of my co-workers, a guy new to python but certainly not to programming in general, brought this up today. I'm not much of a programmer (I'm a QAE) so I told him "don't do that". It appears that most documentation says the same thing about it.
I've used NS, NameCheap, GoDaddy, gandi, and a couple others. I've been using dynadot.com for the past year or so, and I quite like them. NS is (maybe 'was' by now) a huge maze of an interface that put selling you more services way, way ahead of helping you get things done. Simple DNS changes were an absolute chore. GoDaddy pulled some funny business with domains in use by a client, so although I've worked with their interface (nothing great), I was lucky to learn not to use their service before I gave them any of my own money. NameCheap was ok until their site became completely unstable. Errors and timeouts became a regular thing, and so whatever domains are there now will probably be moved to dynadot at some point unless dynadot does something stupid. I tried gandi so long ago that I can't recall what it was I didn't like about them. 
Tears, not so good. Half a bottle of whiskey, FUCK YEAH!
what does Java have to do with this?
&gt; You want to use the "from module import object" form instead of "import module" to avoid polluting the namespace. A little correction, `import module` does not pollute namespace, `from module import *` does.
I also think that this is a bad practice (I upvoted you). Most of the time you'd better refactor the code so that there's no circular dependency. But this is a useful trick in case you need to get thing done now, or when a part of third party framework/library is involved in the issue.
that's odd.. but for whatever reason I would not have architected it in this fashion, preferring instead to queue the log messages into a buffer or separate thread or if it's a unix machine a syslog. I'm not entirely sure why I didn't think of the wrong way of doing it first. 
You rarely need such explicit factories in Python
You might try PyPy which speeds up that example by ~12x (still not 47x, but well, we're on it :) and supports all of the above features.
&gt; what does Java have to do with this? The instance creation and initialization processes are performed by "regular" methods in Python (as in Ruby or Smalltalk), so you generally don't need explicit factory methods (you just override those which already exist). And when you do, you usually use factory *functions* as not everything needs to be a method. Likewise, the idea that things get bloaty when you have two classes in the same file is a caracteristic of java-thinking, and so's the multiplication of weirdly related classes. All in all, OP's comment/query feels a lot like someone's coding in Java, it just happens that the serialization language is Python.
When you hear one person ask about how to order a pizza to fight the muchies at 4:20am and a second person tells them to quit smoking pot, do you ask, "What does pot have to do with this?" The code above exhibits a pathology of the sort endemic to brains damaged by too much Java use. 
What are you talking about? Python still won't let you have a circular import no matter how you spell it. 
They're sufficiently different that it wouldn't make sense. UserProducer is basically a database query class. I think I'm gonna have to rename it to UserProducerByEmail or something like that. The base class of UserProducer used to be called QueryRunner at some point.
To Avoid the bitter experience of this condition, I always "import", and never use from eg # from foo.bar import widget &lt;&lt; will give problems import foo.bar widget = foo.bar.widget()
Circular dependencies are Evil. Here's how to fix'em: Say you have modules A and B that are circularly dependent. You identify the part that is causing the circular dependency. You can either *demote* that part such that A and B depend on this module C, or you can *escalate* it such that C depends on A and B.
Some of the lists are actually instances of the SAME list. &gt;&gt;&gt; l = [[0]*2]*2 [[0, 0], [0, 0]] &gt;&gt;&gt; id(l[0]) 140623077493792 &gt;&gt;&gt; id(l[1]) 140623077493792 Edit: Clarification: this is due to the usage of the \* operator. Think of it like this. Suppose you do a*2. You'll get a string with two a's. Now you can't change the value of a character, but if you could (like with a list), and you'd change a to b, you'd now have a string bb. Edit 200000: I hate reddit's markup.
There is no spoon.
You could use list comprehensions to create independent lists: &gt;&gt;&gt; max_months = 2 &gt;&gt;&gt; att_list = [1,2,3] &gt;&gt;&gt; matrix = [[[[0 for i in xrange(max_months)] for i in xrange(max_months)] for i in xrange(3)] for i in xrange(len(att_list))] &gt;&gt;&gt; matrix [[[[0, 0], [0, 0]], [[0, 0], [0, 0]], [[0, 0], [0, 0]]], [[[0, 0], [0, 0]], [[0, 0], [0, 0]], [[0, 0], [0, 0]]], [[[0, 0], [0, 0]], [[0, 0], [0, 0]], [[0, 0], [0, 0]]]] &gt;&gt;&gt; matrix[0][0][0][0] = 1 &gt;&gt;&gt; matrix [[[[1, 0], [0, 0]], [[0, 0], [0, 0]], [[0, 0], [0, 0]]], [[[0, 0], [0, 0]], [[0, 0], [0, 0]], [[0, 0], [0, 0]]], [[[0, 0], [0, 0]], [[0, 0], [0, 0]], [[0, 0], [0, 0]]]] 
Why not use numpy? import numpy as np matrix = np.matrix(np.zeros((w,x,y,z))) or you could use list comprehension l = [[0 for i in range(2)] for i in range(2)] l[1][1] = 1 print l [[0, 0], [0, 1]] 
Sure it will. You'll only run into problems if you have code that runs *during the import* that *uses* the objects. So long as each is merely *defining* classes and functions that call it when invoked / instantiated, rather than actually *using* them *during* the import (inheriting from a class would be the most likely possibility), then you'll be fine if they just import each other. (And don't make assumptions about the name already being there as in the "from X import Y" form). What will happen is: your_program.py: import user # Trigger the import of user. &lt;Checks module cache - not there, so:&gt; &lt;Create a new empty module object&gt; &lt;Add this to the cache of modules&gt; &lt;Start executing user.py in this module's namespace&gt; user.py: import userproducer &lt;Exactly the same process as above: start executing userproducer.py&gt; userproducer.py: import user &lt;Checks for 'user' in list of imported modules&gt; &lt;This time, FINDS IT, and returns it (in its current, empty state)&gt; #from user import User # &lt;- This would fail with a NameError however. class UserProducer(object): def getUser(): return user.User() # No problem. user.User doesn't exist yet, but we don't # care so long as its there by the time we are CALLED. #some_user = UserProducer().getUser() # &lt;- eg. this would be a problem if uncommented. #class SubclassedUser(user.User): pass # &lt;- as would this &lt;finish executing module1, resume in module1.py&gt; module1.py: &lt;Continue executing, module2 being fully imported now&gt; class User(object): ... (And of course, it happens the other way round if you imported userproducer first) 
Nested list creation gotchas in python http://www.reddit.com/r/Python/comments/bvyt4/did_you_know_about_all_and_any_in_python/c0owc7g?context=3
If you're going to use a lot of matrices, you should definitely use numpy. I understand that if you only do a few matrix operations you may not want to depend on it though.
I didn't make myself clear. For example, he should use from gtk import Window **not** from gtk import * 
At the last level, where you're storing a list of integers, you may want to use the built-in *array* module. Storing a sequence of homogeneous primitive types can be more memory-efficient than a list of references to could-be-any-type values. You get closer to the metal, with all the good and bad things that implies.
You can use the multiply operator for the inner one, just not the outer ones: [[0] * 10 for _ in range(10)] works. Don't use numpy unless you have many matrix operations (i.e. don't use numpy just for accesses), it's slow.
If you know nothing about Python, but you are a programmer, that book will make you quite proficient in Python faster than any other book, because it is focused on getting things (really common, useful things) done. Do not be put off by its title, it is not all about data visualization, but more about data manipulation (which constitutes most of programming tasks). Also, the book is quite easy to read (even for non English speakers as myself), doesn't treats its readers as dumb, it assumes you can think, it goes directly to the point of solving the task at hand, and has a KISS style in its code that makes it really appealing (at least to me). Really. You can't go wrong with this book. And no... I have nothing to do with the author nor with APress, really :-).
all very good points. thanks man
Here's a multidimensional matrix generator: def make_matrix(x, *dim): if dim: return [make_matrix(*dim) for _ in xrange(x)] else: return [0] * x Example: make\_matrix(max\_months, max\_months, 3, len(att\_list)) Edit: As a one-liner: def make_matrix(x, *dim): return [make_matrix(*dim) for _ in xrange(x)] if dim else [0] * x
Nice, but still 100x less beautiful than SASS
You must remove the dependency of the user class on the database layer - it does not make sense.
This stuff is *inside* the database layer. The User class is a proxy for a database object.
I don't see any criticism.
Glad to know I'm not the only one who thinks this
"Python 2.6 even recommends doing that." - if that actually meant anything it would be wrong... :-) The print statement is unchanged in 2.6. There is an optional future import if you want print as a function. That is neither recommended nor not recommended. Adding parentheses to print statements (as opposed to using print as a function) can change the semantics - you can end up unintentionally printing a tuple for example - and is definitely not recommended, particularly for beginners.
Ok, your database layer has a class that search users, and a user class. Remove the dependency from user producer/finder on user. It will return user data from the database, e.g. (name, email, etc.), and the user class will use this data to initialize a user object. Client code depends on user class, user class depends on user finder to locate/fetch user data, user finder does not depend on user. The real question is how to avoid circular dependencies, not how to deal with them in Python. 
very neat!
As a noob Python programmer, where can I go to learn how to make these badass statements?
It's kind of recursive trickery I learned from writing ML and Scheme code. "ML for the working programmer" is a great book that will blow your mind (if you're new the content). Also "Structure and Interpretation of Computer Programs".
But using UserProducer from the controller layer is actually very convenient. For example, when a user is on the "forgot my password, please send me a new one via email" page, he/she will enter her email address and it's convenient to use UserProducer right from the controller to search according to the email address and get a User instance back. Plus I'm using CouchDB here and I've got strong coupling between the User class and the database. Usage is something like: user = User() user.checkout(db_key) # I should rename this to user.pull() datasnap = user.snapshot() if len(datasnap.name.value) == 0: user.write({"name" : "John Doe"}) What I've basically done is designed a DB layer based on CouchDB that looks and feels a lot like using a modern source code version control system like git. It actually feels very nice to use. There's an early alpha (I'm successfully using it in a private production system) with zero examples up on github: http://github.com/elver/siil
I was wondering the same thing. I like the idea of clevercss and sass, but zoolander doesn't look nearly as nice. For that matter, [haml](http://haml-lang.com/) and [shpaml](http://shpaml.webfactional.com/tutorial/1) are pretty neat looking as well.
I use this: class Tensor(): """ Examples: &gt;&gt;&gt; t=Tensor(10,3,5) &gt;&gt;&gt; t[8,2,2]=5 &gt;&gt;&gt; print t[8,2,2] 5 &gt;&gt;&gt; print t.dims (10,3,5) &gt;&gt;&gt; print t.size 150 &gt;&gt;&gt; s=t+t*3-t &gt;&gt;&gt; print s[8,2,2] 15 """ def __init__(self,*dims): self.n=len(dims) self.dims=dims self.b=[reduce(lambda x,y:x*y,dims[i+1:],1) for i in range(self.n)] self.size=reduce(lambda x,y:x*y,dims) self.m=[0.0]*self.size def __getitem__(self,key): return self.m[reduce(lambda x,y: x+self.b[y[0]]*y[1],enumerate(key),0)] def __setitem__(self,key,value): self.m[reduce(lambda x,y: x+self.b[y[0]]*y[1],enumerate(key),0)]=value def __add__(self,other): if self.dims!=other.dims: raise "cannot add" t=Tensor(*self.dims) for i in range(self.size): t.m[i]=self.m[i]+other.m[i] return t def __sub__(self,other): if self.dims!=other.dims: raise "cannot sub" t=Tensor(*self.dims) for i in range(self.size): t.m[i]=self.m[i]-other.m[i] return t def __mul__(self,other): t=Tensor(*self.dims) for i in range(self.size): t.m[i]=self.m[i]*other return t P.S. If you have 2 indexes it is a matrix. If you have an arbitrary number of indexes it is called a Tensor.
It may be more convenient to use dict, or even default dict. d = defaultdict(int) d[20,2,51,51] += 1 print d[20,2,51,51]
&gt; Don't use numpy unless you have many matrix operations (i.e. don't use numpy just for accesses), it's slow. Can you clarify? You mean don't use it for looping element-by-element in Python?
Yes, if you use it to just iterate over elements instead of doing matrix-wise operations such as matrix multiplication, numpy is many times slower than Python lists...
Thanks everyone! This is why I love reddit. I don't have many friends who are learning to program, so bringing my questions and ideas to you guys is a blessing. Thanks again!
You could use nested list comprehensions. A bit verbose, but they'll get the job done. [[0 for i in range(10)] for j in range(10)]
If you're actually doing matrix math, and not just storing stuff in n-dimensional arrays, I would suggest numpy. It is mostly wrappers to fortran functions and data structures and is incredibly fast.
... What exactly is the purpose of this matrix?
[Been there, done that; I suck at Python.](http://1.618034.com/lessons-in-python/)
Bullshit article much?
Ah. I now vaguely recall reading about this in the docs years ago, but it was never relevant, so I forgot about it. I just assumed that Python didn't put anything into sys.modules until it was done loading the module. Guess I was wrong. Thanks for the correction. 
Not really. Just cache it and it's a one time expense. The bigger issue that this syntax sucks. 
Put those entangled classes in same file or glue them together in third file. Need for circular imports means bad design.
http://ironruby.net/ Similar project, also sponsored by MSFT. If Oracle doesn't keep funding the alternative JVM languages, lots of people will eventually end up on the .NET CLR.
RELEASE? -&gt; :D RECOMPILE? -&gt; D: I know I'm gonna' break something...I just know it...damn you nginx and your sexy load handling...damn you...
Is there a way I can use the VS 2010 IDE with "normal" Python?
I don't think it's built in. Pure python projects should work pretty seamlessly switching between IronPython and Python as necessary, but I know some major projects like Django still can't run fully on IronPython. This would be a nice request.
Do you happen to have more info on how Django doesn't work on IronPython. I've been hauling ass to make it work on PyPy perfectly lately, and if there are issues in Django that make it not work on IronPython I'd like to take a crack at those too.
Wow, Microsoft is really good at building IDEs. Haven't tried it before but it looks nice.
Django usually works alongside SQL databases. I would guess that's the main issue, and I don't see why they can't get around it. I don't know.
Does IronPython not have any database bindings? Not even SQLite (part of the standard library since 2.5).
Jeff Hardy is the guy to talk to. See this discussion: http://www.mail-archive.com/users@lists.ironpython.com/msg11012.html
Some native modules are still being ported. Sqlite module port is here: http://bitbucket.org/jdhardy/ironpython.sqlite/wiki/Home
Cool looks like most of the bugs are upstream (aka someone else's problem ;)). I do wish they'd file bugs for the relevant issues in Django though.
They've been at it a long time :) Also, one of the main selling point of Widows is the breadth and depth of software available. That's only possible with excellent developer tools. 
Currently you can use the editor and set the project to launch using Python.exe. But you won't get any debugging and the intellisense will be based off of IronPython's type information. And the REPL window will still be IronPython based. We are eventually going to do some form of lightweight debugging instead of the .NET based debugging we do today. When we do that (who knows when, and it's a lot of work) then we will probably also support CPython debugging as well.
&gt; If Oracle doesn't keep funding the alternative JVM languages The jRuby guys left Sun during Oracle's acquisition. They now work for Engine Yard.
I don't think this is Python backing, but rather an attempt to divide the Python community and create multiple incompatible versions and confusion. Writing programs with IronPython and Visual Studio will only make you stuck with the Microsoft platform. Microsoft tried similar tactics with Java in the past with their JView and a big lawsuit from Sun put an end to that. Then they started the .Net nonsense. 
One of the main things I love about python is that I can use it effectively without Visual Studio. Props to the Iron Python team, but this isn't my bag (anymore).
&gt;rather an attempt to divide the Python community and create multiple incompatible versions and confusion. I don't think it's as much an attempt to divide and create confusion as it is an attempt to take over the whole thing -- *solving* the incompatibility and confusion problems (not only with python, but with all popular languages) -- with the tiny caveat that it all runs on top of the platform that Microsoft controls.
Can pretty much create a large app with just a good text editor
In the [reddit comments](http://www.reddit.com/r/programming/comments/byb1c/charles_stross_the_real_reason_why_steve_jobs/) for [an article](http://www.antipope.org/charlie/blog-static/2010/04/why-steve-jobs-hates-flash.html) about Apple's strategy for the future everyone was foretelling Microsoft's downfall because Apple and Google would dominate the next era of cloud based computing and portable personal hardware. They were suggesting Microsoft was asleep at the wheel. I think they really underestimating what Microsoft is doing in solidifying their hold of development tools. If 9 out of every 10 programmers are targeting for Microsoft's environment using Microsoft's development tools, they're not going anywhere. 
Sun's decision to pull Microsoft's Java credentials was the biggest mistake they ever made.
i don't like the comparison and many people pointed out that this is not how you use list comp. but the author went a justified the comparison.
I don't think Apple has anything which competes with the JVM and the CLR. 
LLVM.
Yes, it's obviously some big conspiracy. I can only imagine that Ballmer is cackling back at Redmond. Funny however, how the entire OSS world is fragmented into diverse communities, and multiple incompatible versions, and much nerd rage.
Oh god no. oh god no, no no no. It's only a matter of time before they release their own interpreter. One that doesn't support all the features. One that crashes on random calls. One they'll force users to download so coders have to write two versions of each program. 
Azure is looking pretty incredible. And I say this as a non-MS guy....
IronPython has always run under their own compiler - that's the whole point.
Funnier still is the endless supply of pro-MSers who vehemently argue "Oh the *100th* time will be *totally* different from the 99 times before!" And this same group seems to want to throw every freedom out the window to lock themselves onto one IP amassing platform. They seem to want to rush to support one company's "standards" forever (take your pick between Microsoft or Apple here). I mean, WTF!?! Are our public schools really *that* fucked up these days?
...orrrrrrr, they've been successfully releasing their own quality interpreter for several years now.
really? link?
[1.0 release blog post - September 05, 2006](http://blogs.msdn.com/hugunin/archive/2006/09/05/741605.aspx), which I believe targeted Python 2.4. The whole project started in 2003. As for not supporting all of the features: as with any alternative implementation, there are always things that slip by, especially when you are trying to hit a moving target. Now that the language moratorium is in place, alternative implementations should be able to get on (or close to) the same playing field. The IronPython team is pretty quick to fix differences between CPython and IronPython, and bugs in general. For example, C extensions don't directly work, but there are ways to make it work -- PyPy has the same issue and is working on it right now. Overall, it's really just Python + .NET. It's not some half-assed product, and there's no crazy strings attached to ruin your Python life.
Has anybody here ever tried developing Python on Windows? It's a fucking nightmare and VS2010 is a bloated pig that cannot run on a machine with less than 2gb of memory.
Honestly if you're worried about the efficiency of a few bytecode ops, Python is probably the wrong tool for your job
"Ian"'s test in the blog comments is broken: the imperative form does not collect the results, whereas the list comprehension is required to. Also, nobody would ever write the list comprehension example as shown in the blog. The entire point of using the list comprehension is that it **often lets you avoid** having to declare an accumulation variable, accumulate into it and return it - you can just create and return the value in place.
But come on, who would want to run development tools on a mobile phone anyway? ;)
This is why fabric is so useful: def build_webserver(): '''Builds a webserver using specified versions of Nginx and uWSGI. Overwrites without replacing nginx.conf ''' TEMP_REPO = local_clone() # get dependencies sudo('aptitude -y install build-essential python-dev libxml2-dev libpcre3-dev libssl-dev') # build uWSGI server PY_VER = run("python -c 'import sys; print \"%s.%s\" % (sys.version_info[0], sys.version_info[1])'") with cd('~'): run('wget http://projects.unbit.it/downloads/%s.tar.gz' % env.uwsgi_ver) # get uWSGI run('tar zxf %s.tar.gz &amp;&amp; rm -R %s.tar.gz*' % (env.uwsgi_ver, env.uwsgi_ver)) # extract and delete archive with cd('~/%s' % env.uwsgi_ver): # compile uWSGI if PY_VER == '2.5': run('make') elif PY_VER == '2.6': run('make -f Makefile.Py26') else: print "Python 2.5 or 2.6 required for all features." # build Nginx with cd('~'): run('wget http://sysoev.ru/nginx/%s.tar.gz' % env.nginx_ver) # get Nginx run('tar zxf %s.tar.gz &amp;&amp; rm -R %s.tar.gz*' % (env.nginx_ver, env.nginx_ver)) # extract and delete with cd('~/%s' % env.nginx_ver): run('./configure %s' % ' '.join(env.nginx_conf)) run('make') sudo('make install') put('%s/bin/restart-nginx' % TEMP_REPO, '~/') sudo('mv ~/restart-nginx /etc/init.d/nginx &amp;&amp; chmod +x /etc/init.d/nginx') sudo('/usr/sbin/update-rc.d -f nginx defaults') activate_config(env.conf)
In this case the list comprehension is also inefficient in memory (it'll allocate a new list of Nones), which might be an issue.
OK that's what I thought you meant. Technically it's incorrect to call the "matrix-wise" operations, because that implies matrix arithmetic and such. It's more accurate to call them "vectorized operations". Most of the features in numpy are actually vectorized for element-by-element array operations, and the matrix-related functionality is only a small portion. In general, if you're iterating over numpy arrays one element at a time, you're using numpy wrong. :)
the only problem is that most sane python coders don't write list comprehensions like that the author acknowledges this in the comments. 
What would be useful here: a few words summarising what uWSGI is so I don't have to click through to the mail, follow a link into the wiki then find the appropriate page.
I just wrote the analysis portion of my thesis in Python and loved the language and the ton of available libraries. IDLE on the other hand, wasn't my best friend. Is this an alternative to IDLE? 
That's good I was worried about EEE similar to what they did to java in the 90's. Seeing that it's python and .NET, it's really apples and pears. 
&gt; What? Fail. I'll readily admit to not being a member of the Python dev project, so this is pure speculation, but here's the guess: the * operator works on values for fundamental types, including strings. For all other types, it operates on references. Actually, Python does everything by reference. It's just that for some fundamental types like strings, ints, floats, and tuples, there are no mutating methods available. They are "immutable". So, in that case you don't have to worry that the "a" in "aaa" will somehow get changed into a "b". It just is an "a", and there's no method to let you mutate the object into anything else. Same thing with 0. A 0 object will never become any other number. It will die the same number it was born as. 
I just did double backslashes followed by an n. Maybe it only works in an empty line? Lets \\n see... \\n
Not really: its an implementation of a subset of Python which compiles to the CLS. Eclipse is pretty heavy compared to IDLE, but with PyDev, it makes a good python IDE.
Ditto to that. I had to use VS2008 on the computers in my school's lab last quarter and it was so unbearably slow that I gave up completely and installed Mono Develop on my workstation in the lab because a 20 minute walk and the installation and learning of MonoDevelop seemed faster than continuing to use Visual Studio.
It can be. Though it would currently require you to use IronPython from within the IDE.
Thanks for the comments guys! @ketrainis: In my view, just because it's high level language doesn't mean you should ignore everything that's going on under the hood. Knowing that a list comprehension always creates a list in the size of the transformed set is important for memory efficiency reasons as well, as @kingkilr points out. I'd say it falls into the same category of efficiency knowledge as using a dequeue instead of a list if you're going to inserting into the head of the sequence frequently. *shrug* @mordaunt0: I realized that I hadn't put an efficiency comparison for the typical use of list comprehensions and added it as an update if you're interested. I was mostly using that entry to reply to a comment somebody made in the entry I referenced in the first paragraph.
@zahlman: Very true! I was purposefully comparing the use of "list comprehensions for side effects" to a for loop, but I've updated with a section on the efficiency comparison for the more common usage.
Those developers MS is holding on to need users, though. To get users, they have to be able to create modern, spectacularly useful applications. There are a lot of Windows software, but most of it seems.. underwhelming to me. I'd like to see that change.
Like posting a blog entry and people comment on it on reddit instead of on your blog. Annoying.
and, by the way, Microsoft is a long time supporter of Python: they are sponsor member of the Python Software Foundation: http://www.python.org/psf/members/ Jim Hugunin, the initial creator of IronPython who was hired by Microsoft is a nominated member of the PSF also. Microsoft has signed a contribution agreement http://www.mail-archive.com/python-dev@python.org/msg44965.html so they are legally able to submit code to the Python project. I know that many AUG love to call Microsoft the "evil empire", but Microsoft is big enough a system so that there are good moves and bad moves. Confronting Microsoft for their bad moves may be a strategie. BUT I strongly suggest that communicating and working together is the better move. I saw the IronPython guys having discussions with Jython, PyPy, UnladenSwallow, CPython about improving the language; solutions to implementation challenges with the underlying platforms. There is united effort for a common benchmark repository, example: http://mail.python.org/pipermail/python-dev/2010-February/097936.html with contributions from UnladenSwallow, PyPy, IronPython, Jython to have real world measurements of the implementations (rather then "my fibonacci are better then your fibonacci") As far as I am concernced, Microsoft should be granted relieve of the EvilEmpire tag, please compare their recent activities to another high tech company which often gets good rep for their shiny gadgets. 
Bah, we've confused the terminology. By element-by-element arrays do you mean vectors?
I'm sorry, I meant "for element-by-element array operations". I'll fix that in my original comment now. So, for example, element-wise multiply is not matrix multiplication, nor is element-by-element comparison a matrix inequality, etc. Numpy (I *think*) is used more heavily for its fast, vectorized array operations than for its matrix routines, although the latter are used in the scientific community quite a bit.
I agree, the difference is that if you use vectorized operations a lot, you have already gotten the speedup, so you might as well use its matrix routines as well. If all you want an array for is to access the elements one by one yourself, numpy arrays will be more convenient (you can reshape them, etc) but much slower too.
What are the specific issues you have with Python on Windows?
I can say for sure that Microsoft *does* directly back the CPython project. They provide MSDN subscriptions free of charge for core developers, in order to make sure the necessary tools and OS licenses are available to help in providing quality support for the platform.
That's not a embrace but bear-hug..escape before its late.
That guy should delete that blog post completely, it's utter nonsense to use a list comprehension that way. He's building two lists the way he's got it.
IDLE is a joke. I don't think it was ever meant to be used for production.
Once in a while a sysadmin comes along and cries "I'm forced to work with Windows, there is only notepad installed on the server and with notepad I can't edit Python scripts" - so there is certainly a use of IDLE. Otherwise [this](http://wiki.python.org/moin/IntegratedDevelopmentEnvironments) is my first Google hit for Python + IDE. 
wo kan bu dong lolol
wat?
Ah.. it just doesn't work in code sections: \\n
AFAIK they're migrating their store from OSCommerce to Satchmo, so that's probably why the intermittent issue isn't getting much love.
That's incredibly insightful, thanks. I probably could have done a little more research before I went through that post, but I was so eager to share my, "WTF, why is this happening?" with the world that I didn't stop to think. Still, the notion of "reference, but immutable" is a little mind-boggling.
It's pretty obvious. I'm a web developer.
As a rule of thumb, you will get better results with a non-recursive solution (that means nearly always).
but recursion is so cool. it's worth it. :P
For the most part I wouldn't really be worried about memory usage these days anyway. I've got 4 gigs and while I know not everyone has as much as me I don't recall hardly ever using more than 2g. If you're python code is using too much memory that's a sign that it's either very poorly written or that you should probably move to a more low level language, at least for the memory intensive operations.
You can simplify the first one: def addr(n): if n &lt;= 0: return 0 else: return n % 10 + addr(n / 10) And you can write the second just like the first: def add(n): r = 0 while n &gt; 0: r += n % 10 n = n / 10 return r You can also write the first version using a temporary string: def add2r(n): def rest(s, i): if i &lt; len(s): return int(s[i]) + rest(s, i+1) else: return 0 return rest(str(s), 0) The second is probably faster, because Python function calls are expensive. It also uses less memory because each function call needs a new stack space. You can time both functions using the timeit module. You can estimate the memory usage by repeating each one and watching memory usage in top or ps. 
Thanks :) Oh, and for the first one, the original example called for treating negative numbers the same as positive numbers. I neglected to mention that.
the fact that we are not too much constrained by memory shows that we should NOT care about going to lower level languages (gains of a few times maybe) but for better algorithms (gains of a few orders of magnitude). Then, the fact that we have speedy CPUs show that memory access is the slow element, so it makes more sense (without generalizing) to optimize for memory. 
@dgrant: "That guy," here, bidding you good day, kind sir! I've restructured the entry to put the analysis of the more common use case up front -- it was originally intended to be a response to a comment on a previous entry, as mentioned in the first paragraph of the previous version, but your comment inspired me to enhance it for those who happen to miss that bit. Thanks!
You can do lots of fun things in Python, like recursion, and returning functions from functions that compose functions. But Python's not very fast with that stuff. If you love recursion, you might like [a language](http://reddit.com/r/haskell) where recursion is the way you're supposed to do things.
experimented with haskell a few weeks ago. still trying to get into the functional mindset. hahah. mainly, i hit a lot of dead-ends because I don't want to pose stupid questions on that board.
Generally, iterative methods are always going to be more efficient*, while recursive cases to tend have a bit more clarity. To understand this, you'll need to understand the overhead that goes into a function call and the time required to allocate that space in each recursive iteration, versus the time required to prepare the function call once and maintain the loop variable. Let's dissassemble the first implementation: &gt;&gt;&gt; def add(n): ... if n &lt; 0: ... n *= -1 ... if n &lt; 10: ... return n ... else: ... return add(n / 10) + n % 10 ... &gt;&gt;&gt; import dis &gt;&gt;&gt; dis.dis(add) 2 0 LOAD_FAST 0 (n) 3 LOAD_CONST 1 (0) 6 COMPARE_OP 0 (&lt;) 9 JUMP_IF_FALSE 14 (to 26) 12 POP_TOP 3 13 LOAD_FAST 0 (n) 16 LOAD_CONST 2 (-1) 19 INPLACE_MULTIPLY 20 STORE_FAST 0 (n) 23 JUMP_FORWARD 1 (to 27) &gt;&gt; 26 POP_TOP 4 &gt;&gt; 27 LOAD_FAST 0 (n) 30 LOAD_CONST 3 (10) 33 COMPARE_OP 0 (&lt;) 36 JUMP_IF_FALSE 5 (to 44) 39 POP_TOP 5 40 LOAD_FAST 0 (n) 43 RETURN_VALUE &gt;&gt; 44 POP_TOP 7 45 LOAD_GLOBAL 0 (add) 48 LOAD_FAST 0 (n) 51 LOAD_CONST 3 (10) 54 BINARY_DIVIDE 55 CALL_FUNCTION 1 58 LOAD_FAST 0 (n) 61 LOAD_CONST 3 (10) 64 BINARY_MODULO 65 BINARY_ADD 66 RETURN_VALUE 67 LOAD_CONST 0 (None) 70 RETURN_VALUE So, without going into too much detail about what the above actually means, just know that this number of operations has to be executed for each digit of N. Now, if we look at the dissassembly for the second implementation, we can see there are far fewer operations involved: &gt;&gt;&gt; def add2(n): ... s = str(n) ... t = 0 ... for c in s: ... t += int(c) ... return t ... &gt;&gt;&gt; dis.dis(add2) 2 0 LOAD_GLOBAL 0 (str) 3 LOAD_FAST 0 (n) 6 CALL_FUNCTION 1 9 STORE_FAST 1 (s) 3 12 LOAD_CONST 1 (0) 15 STORE_FAST 2 (t) 4 18 SETUP_LOOP 30 (to 51) 21 LOAD_FAST 1 (s) 24 GET_ITER &gt;&gt; 25 FOR_ITER 22 (to 50) 28 STORE_FAST 3 (c) 5 31 LOAD_FAST 2 (t) 34 LOAD_GLOBAL 1 (int) 37 LOAD_FAST 3 (c) 40 CALL_FUNCTION 1 43 INPLACE_ADD 44 STORE_FAST 2 (t) 47 JUMP_ABSOLUTE 25 &gt;&gt; 50 POP_BLOCK 6 &gt;&gt; 51 LOAD_FAST 2 (t) 54 RETURN_VALUE In addition, the repeated section is only the chunk of instructions from 25 to 47 for N digits. The point to take away, is that far less instructions have been executed per digit of N. For shits and giggles, lets look at rdamer's implementation: &gt;&gt;&gt; def add(n): ... return sum(int(i) for i in str(n)) ... &gt;&gt;&gt; dis.dis(add) 2 0 LOAD_GLOBAL 0 (sum) 3 LOAD_CONST 1 (&lt;code object &lt;genexpr&gt; at 0x8cd6e78, file "&lt;stdin&gt;", line 2&gt;) 6 MAKE_FUNCTION 0 9 LOAD_GLOBAL 1 (str) 12 LOAD_FAST 0 (n) 15 CALL_FUNCTION 1 18 GET_ITER 19 CALL_FUNCTION 1 22 CALL_FUNCTION 1 25 RETURN_VALUE This is even faster, because with a generator expression, we have delegated the inner loop to an external C routine. There is still a section of code that has to be run N times, but it is no longer executed in the context of the virtual machine. This is all a bit of an oversimplification, but this should give you a headstart on why one version is more efficient than another. *Now, regarding recursion being less efficient than iteration, this is not true if the compiler implements tail call optimization. What this does, is take your recursive implentation at the high level and turn it into a loop in the assembly. CPython's assembler does not do this, if i remember correctly. In addition, the way you have your recursive implementation written, would not allow for tail call optimization because it requires a stack accumulator. It would have to be rewritten as this: def add(n, acc=0): if n &lt; 0: n *= -1 if n &lt; 10: return n + acc else: return add(n / 10, acc=(acc + (n % 10))) Now, if python had tail-call optimization, it could optimize out the stack of each function call, and reduce it to a loop. 
Try reading this story: http://www.reddit.com/r/Python/comments/bsec2/how_to_think_like_a_pythonista/
Sorry but I know very few python programmers who would ever move to a proprietary platform.
2gb? I thought Eclipse was bad. I gotta pretty beefy computer at home, but my work computer could never run VS2010. 
I finally gave up on Eclipse a couple months ago, back to vim like the day I started. Seriously, 15 years and editors still haven't gotten more efficient to work in?
I also write Java and java is painful in vim. Otherwise I would probably just use it.
Scrolling down would be nice.
dunno why some stupid votes down this without any useful comment.
Terrible, terrible graph.
Yea, I don't know what on earth that graph is supposed to show.
Check this out [udp broadcast server](http://www.java2s.com/Code/Python/Network/UDPBroadcastServer.htm) 
can &amp; do
I have a little more time now. I think the udp broadcast would be the way to go - its basically what it's good for. Your brute-force method of scanning the IP range is....interesting. If you were going to use a method other than broadcasts, you would probably want to do a ping-sweep of the local network before attempting to connect only to the responding systems. Keep in mind you have firewalls to deal with, too - I'd suggest turning your hosts firewalls off while you're trying to get this to work. Also, you should only have to scan the systems which would fall within your subnet, based on mask - that being your LAN. It's probably not 65k addresses, more likely 256, especially if its behind a soho router.
Pass a generator/iterator to dict(): \&gt;\&gt;\&gt; dict( ( (x, x**2) for x in xrange(10) ) ) {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81} 
The dict keyword will initialize a dictionary from a list of (key, value) pairs. dict(((1, 'a'), (2, 'b'), (3, 'c'))) gives {1: 'a', 2: 'b', 3: 'c'} So, you can build a list of (key, value) pairs using a list comprehension, and pass that to dict().
Here's Wikipedia's example in Python 2.4 and up: &gt;&gt;&gt; d = dict((k,v) for k,v in enumerate('ABCD') if v not in 'CB') &gt;&gt;&gt; print d {0: 'A', 3: 'D'} &gt;&gt;&gt; type(d) &lt;class 'dict'&gt; &gt;&gt;&gt; 
good luck with that.
For me, shedskin highlighted the unfortunate state Python is in now. Very dynamic programs are slow, but so are very static programs, whereas you could get more than 50x the performance by just performing some optimizations. Hopefully Unladen Swallow will change that and we will soon be able to write code that rivals C in speed. Until then, I'll put all my performance-critical code in a module and compile it with shedskin.
I'm checking out the UDP broadcast server you linked to below. As I said, I'm not really sure what the difference between UDP and TCP is, so I'll need to look that up and figure out how that will affect my program. I noticed that UDP broadcast server used socketoptions, which I haven't even touched yet. I'm going to need to do more research there, too. I don't think I'll need to turn the firewalls off. I made a simple chat program where you had to manually type in the IP addresses, and that worked just fine. I think I only had to give that application permission to use the LAN, and it connected without any problems. Also, it appears I'm going to need to find out what the heck a subnet is. I've had no formal education in any of this, so I'm banging into a pretty steep learning curve.
Just curious, but is it better to pass a generator than tuples, or is the result essentially the same time-wise?
Seems to be very similar, generators maybe a hair faster. &gt;&gt;&gt; import timeit &gt;&gt;&gt; timeit.Timer("dict( ( (x, x**2) for x in xrange(10) ) )").timeit(100000) 0.39112305641174316 &gt;&gt;&gt; timeit.Timer("dict( [ (x, x**2) for x in xrange(10) ] )").timeit(100000) 0.40731406211853027 &gt;&gt;&gt; timeit.Timer("dict( ( (x, x**2) for x in xrange(10000) ) )").timeit(1000) 1.9186849594116211 &gt;&gt;&gt; timeit.Timer("dict( [ (x, x**2) for x in xrange(10000) ] )").timeit(1000) 2.1006810665130615 
The innermost tuple (x, x**2) is used as (key, value), while the middle set of ( ) is a generator: list( ( x for x in xrange(10) ) ) == [ x for x in xrange(10) ]
Mind there are lots more [goodies](http://static.thadeusb.com/web2py_utils/index.html#lots-of-goodies) in there.
Mechanize hasn't been updated for Python v3.1 and I'm looking for other options. Does anybody have suggestions?
Any idea how to contact upstream developers?
This was briefly posted before, but we no longer require a registration. Download away! :)
To be honest, I'm surprised you got as far as you have. Obviously you have the persistence and the mindset to bang away at it, learning as you go. I think you're exactly right: you need to read about tcp vs udp, subnets, etc. You'll get it. Understanding what a subnet is will be key to the whole shebang.
[Invent Your Own Computer Games with Python](http://inventwithpython.com) is free, aimed at beginners but also useful for people who know programming in other languages. Each chapter has the source code for a small game (Hangman, Tic Tac Toe, Othello, etc.) and teaches programming from the source code. The later chapters cover Pygame.
That feature was backported to the forthcoming Python 2.7: http://docs.python.org/dev/whatsnew/2.7.html 
I couldn't find any options so I went back to 2.6.5. The documentation for 3.1 is still incomplete, there are very few modules that have been ported over, and all in all it just doesn't seem like the right time to switch.
I enjoyed the challenge and how simple he made the solution appear, however I can't help but think there are easier, more concise ways to write this application that would be more accessible to a beginner. I wouldn't expect an introductory student to understand the final code produced here, especially since he glosses over datatypes and uses some methods that require a good bit of understanding (e.g. \_\_repr\_\_ and recursion).
i really like what the programmer is doing here. what module is that win32gui?
Love the website! Is this video by you? It was very well done.
This would have been great when I needed to deploy a special-purpose SSHD recently. As it was I ran screaming from the Twisted documentation and ended up modifying [dropbear](http://matt.ucc.asn.au/dropbear/dropbear.html), which, after a few segfaults, seems to have turned out simpler (more efficient and robust are incidental).
Thanks Crath. The video is by my co-founder Marco Beri. I'll pass on the compliments.
On the same website you linked to, I found a [broadcast sender](http://www.java2s.com/Code/Python/Network/BroadcastSender.htm), and I was able to snip and modify some lines from that sender and the server to make my own sender and server. I also found a nice [explanation of what all the socket options mean](http://linux.die.net/man/7/socket), so I have a good idea of how to use them now. It looks like I'm going to have to use UDP to share local IP addresses, and then use the local IP addresses to switch to TCP to handle data, since TCP can passively receive while the application does other things. I'm not sure if any of these links are helpful to you, but, if not, it's good to have them available for future reference, if only for my own reference. Anyway, thanks for your help, it looks like I've got this mostly figured out now.
Suggest he put up more free python videos :)
Good man, makes more sense now.
Does PyQt work?
you can try http://twitter.com/unbit or send a mail to uwsgi maillist 
woah, cool, thanks.
both PyQt and PySide use custom code generators instead of SWIG, so it is unlikely that support will be the same, mostly it depends on what libpython functions they use.
Pretty cool, but changing recursion limit only helped to solve the problem at hand. It would still be failing in bigger case, wouldn't it? Iterative solver would be both faster and free from that limitation.
pywin32
I personally find [PyScripter](http://code.google.com/p/pyscripter/) the best Python IDE for Windows, hands-down. For coding Django, the ctrl-click feature (go to the definition of a certain method, class or object) leads you directly into the innards of the Django framework. Which, IMO, often gives a much better idea of what's going on than the documentation. Especially if you're into customizing stuff. While PyScripter's webpage says it is possible to run the development server from PyScripter itself, I personally prefer still running it from the DOS-Box. However, I do have a script named "prepare_shell_setup_environ.py" [ok stupid name] that's partly copied from the main manage.py, plus loading a couple of objects from the database, which I run to initialize the PyScripter interpreter. That way I can try out and test and inspect bits of Django code. When I'm done with this project, I'm probably switching the OS to Linux [for unrelated reasons], does anyone know if there are any tools as wonderful as PyScripter available for Linux? Cause currently I'm leaning on running it in wine, as it has some functionality I'm not sure I can live without :)
ancient, factually outdated article. SQLAlchemy is standardized on the choice of [declarative](http://www.sqlalchemy.org/docs/reference/ext/declarative.html) or elixir for most configuration. plus I never understood the fetish with configuration, when 95% of development time is spent writing new queries and features.
Not a rule of thumb though. numpy types require constant boxing if I'm not mistaken, so that would result in slower access but better memory use.
Whoops, I didn't notice it was 3 years old. But which bits are factually outdated? I've been working with Django 1.0 and 1.1 the past year, dug real deep into the code (the book "Pro Django" proved to be a real good introduction for anything that is not covered in the docs). And my experience is, it's a helluva ride, quite fun, shows the power of Python, but next time I need to write something that goes beyond "Generic Blog Engine" I'm going to take a littlebit more low-level approach. Cause after the initial rush of "weeeooooow this is easy!", you end up with these last bits of functionality where Django starts working against you instead of with you. First was the templating engine, which I only had seen at my previous job, not really touched, but I had seen enough to know to skip right ahead to Jinja2 instead of using Django's builtin templating. I think that saved me a lot of headaches. Ok that's not much to do with the ORM. Mostly it was the ImageField (thumbnails? sensible filenames with the pk in them?) and trying to get a multilingual TextField to work.
I don't understand your post. Could you explain a bit more or point me to a link that explains this "constant boxing"?
In a numpy array the integers/floats are sitting next to each other like in a C array. Whenever such an integer/float is send back to the Python layer, the Python API has to create a Python object from this value. Integers from 0-255 are singletons and can be looked up in a table, but everything else requires an malloc() + filling in the refcount + setting the object type (Integer, Float) + copying the 4/8 bytes of data into that object. Actually, it might not require a malloc because there are free lists* for such small objects in Python, but the general problem persists. * for 10 integers or so Python will keep a list of allocated objects even if their refcount dropped below zero. That way you save mallocs and frees for often used temporary types such as integers and tuples.
Thanks a lot! That was very interesting. Of course since you normally do the heavy weight processing, this should not matter too much, but it's a good thing to keep this in mind.
I had to modify gui.py from... from tkinter import * to... from Tkinter import * I'm running Python2.6 on XP.
He talks about SQLAlchemy .2. That library is now at .6
Thanks for the report.
"Per say"
That's fantastic, I was waiting for something like this. Github is also a plus!
The inner brackets can actually be left off. Python lets you skip them unless it causes an ambiguity, so this works: dict( (x, x**2) for x in xrange(10) ) You still need them if there's more than one argument, but otherwise, the enclosing brackets of the function serve to delimit the genexp.
&gt; But which bits are factually outdated? the final conclusion: &gt; But, TurboEntity is deprecated, and Elixir has adopted the Rails-style syntax. This means that, as of now, there is no object-oriented-interface declarative mapper for SQLAlchemy. 
You're right, I'm just in the habit of bracketing my generators anyway.
Looking thru `traceback.py` shows that `sys` isn't being redefined. That means that it's either (a) not in `sys.modules` or (b) somehow removed from `sys.modules`. Quick and dirty, I'd create a cycle so sys couldn't be GC'd., e.g.: import sys sys.foo = sys Not pretty, but not harmful either. You'd have to stick that somewhere in your startup script. Also, looking thru threading.py, specifically the big comment block above `__bootstrap()`, says that the world might be torn down when it's called. Sooo.... you might want to set `thread.daemon = True` on the threads. 
Looks like you've found a Python bug. Has it been submitted yet?
Follow up: I don't think this has anything at all to do with Paste. I'd guess that your system has been changed somehow (put under more load) and the change has triggered a different timing on the GC during interpreter tear down. That your thread has already been stopped tells me it's completed it's work, and since you didn't provide the context that this is all running in (except to say `r2/whatever.py`) I would probably just wrap the thread call and/or set its `daemon` flag and be done with it. 
Weird that `sys` would disappear from `sys.modules`, isn't it typically built in to the interpreter to begin with?
Yes, it's built-in, but it's also part of `sys.modules`: In [21]: 'sys' in sys.modules.keys() Out[21]: True But like I wrote in the follow up, it's probably disappearing during interpreter tear down (which it should). 
You need to join all of your threads from your main thread and ensure no other threads are running when you exit your main thread (and application). During shutdown of the main thread, I believe python sets all vars (like 'sys') to None; if you still have other threads executing, they will see this bogus state. 
Looking at `threading.py`, it looks like this is not the actual error. This is triggered by by `traceback.py` not being able to report the actual error. Not quite sure what to do in this case... wrap the code of `command` in a try/catch and write the actual error to syslog?
I've seen that error in two separate scenarios: 1. A thread has completed work, died off, and then something tried to talk to it. 2. A thread has died and something tried to access/kill it. In any case, any time I've seen this error it's been identified through generous use of try/except. Typically (in my case) this error means my code got something unexpected, puked, and I failed to deal with it properly. EDIT: Meant to mention that I've only seen this happen randomly, because incoming stuff that needs processing doesn't all look the same, and the stuff that breaks my code is more the exception than the rule, so... it only breaks sometimes. 
Neat, I like it. Death to verbose HTML. The 'new tags on a newline' stuff is a bit of a problem though... It would be nice if there was some way of writing largeish blocks of static content with some markup without messing up the layout.
(@both) I see. I haven't worked with those libraries myself, I mostly posted the link cause I thought his observations on Django were interesting.
Cool post! I've always thought generating text through markov chains was pretty neat. The offical NLTK book is pretty good too: [Natural Language Processing with Python](http://www.amazon.com/Natural-Language-Processing-Python-Steven/dp/0596516495) edit: Nice! I just realized the book is available for free online. http://www.nltk.org/book
HAML and SASS are really awesome tools in Ruby-land. I'm glad we're seeing Pythonic alternatives - Rails -&gt; Django, Sinatra -&gt; Bottle (or Flask IIRC, and more). Any more? Is there anything as good as RSpec for Python?
Usually if that's the problem, the error message says `(most likely raised during interpreter shutdown)`
People that code Python on Windows (or wine) can use PyScripter, which has this functionality built-in by ctrl-clicking on a module, class or method. (Not saying this shellscript isn't useful, btw)
Does this exception happen also with regular requests? If not, I would try to use the regular code path for sending request from cron, by making local HTTP request to the web server.
Check out this [MOTW](http://www.doughellmann.com/PyMOTW/cgitb/index.html). Basically, dumping more of the stack variables may help to id the problem. I would add this somewhere in the `paster run` command object: import cgitb cgitb.enable(format='text') This may not work, if what serpent says is true, so no guarantees. &lt;insert lecture on the evils of threading&gt; You may want to post this to stackoverflow as well. 
Awesome. I'm pretty excited about flask and looking to port my pylons app over simply because I feel the "lightweight" pylons is still too overkill for my app that has no model and only needs one or two controllers. Thanks for your efforts in this.
Yep; interpreter teardown + daemon threads = weird errors on shutdown. I've seen them in Zope 3 quite often.
Cycles don't prevent garbage collection. They stop reference counting from freeing the object as soon as it goes out of scope, but they'll get collected as soon as the garbage collector is triggered. But this is beside the issue; the traceback in question looks like something that happens to daemon threads that are still running when the Python interpreter is shutting down. Nothing to do with GC. 
I find that, often, generic functions operating on lists actually tend to be able to operate on sequences of any type (strings, tuples, etc). Which leads me to the variable name `seq` or `sequence`, which are not keywords. I don't like to abbreviate names just because otherwise they'd clash with a keyword. Neither do I really like the underscore suffix to prevent clashes. So that sort of thing often gives me a dilemma. And then, yeah. When it really has to be a list sometimes I end up using uppercase `L`, other times `xs` (with `x` being a reasonable arbitrary variable name, `xs` is a list of them). Both dont feel really right either. When I revisit code like that often enough, this usually results in me changing the code to accept arbitrary sequences, just to be able to use `seq` as a name. It's twisted, I know.
Jeez, I look at titles like this and feel so behind the times. HAML? I have no clue (I'll wikipedia it). 
I'm guessing sys is None because the process is already exiting; during the process teardown modules get unloaded in this fashion. It's possible that you have something using `atexit.register()` or `__del__` that is running at a late stage (though I think atexit stuff should be okay). Or as people have suggested a thread (probably marked with `isDaemon`) that is hanging around in a weird way. In this case, it might be `.push_thread_config()`? Not clear on that, but there's a process-wide equivalent method you could use there. As an aside `paster request` is intended for the same purpose as `paster run` (might have the same problem though).
Well, it's more popular on the Ruby side of things, so it's not so weird that a Python programmer wouldn't hear of it. It has been around for a number of years though. 
Thanks! Yes, the book looks really good -- I've only got through the first chapter (which is where it introduces the generate method) and I'm looking forward to reading the rest.
Hey I'm the author of this bit, noticed my blog traffic blow up a little today. As for the new lines for tag bit, yeah that totally effin blows but no different then haml as I understand it (dont use haml or ruby). For more details on creating the meat of a document in mark-up like this, check out: http://chriseppstein.github.com/blog/2010/02/08/haml-sucks-for-content/ One thing that will be added soon is inserting straight html on blank lines. As-is, you can already do that anyways so dont line-break and %em b/c thats just stupid anyways (much like what most of my blog post was). As for the largeish blocks of content, I'm working on a bit right now so you can basically :func content and it turns into :func('\ncontent....') so point being that back on the development end you can extend functionality stupid easy. def func(s): s = s.splitlines() .... return s This is coming to fruition as I create a django code-blocks mechanism. And frankly, I wouldn't give my own code the time of day if it couldn't do what its doing quickly. By projects end, I anticipate it being faster then other python templating languages with the exception of mako. If I'm going to migrate away from libxslt, i want it to be fast.
Easy. The module is being unloaded while the thread is still running, so all module variables (in this case, sys) have been set to None. Not sure of the solution without examining the code, but make sure the thread is fully shut down before the main thread exits.
Here's another python implementation of HAML that has been around for a couple of months: http://shpaml.webfactional.com/ 
The thread from the traceback looks like daemon thread - you don't need to join these.
A wile guess: [paste threadpool](http://pythonpaste.org/paste-httpserver-threadpool.html) is injecting SystemExit exception into unresponsive threads using undocumented APIs and ctypes. This may explain how a stopped thread get an exception from nowhere.
yes but this lacks a number of features that make it useless for production. I noticed of course on the site that those gaps are filled in by layering it into django templates. This is just increasing processing time for generating a template. Take for example the utmost basic template.html as seen in the "bench" folder Genshi's repository. Django takes 2.28ms to process the template, and its not even that big! Now layer in shpaml on top of that, now increase the document size in turn increasing processing time so that it's now taking 5-7ms to generate a template on the fly. Now 1000./7 ~= 140 hits a second, and this is the first limit your placing on yourself just for the template. This doesn't even include the full web stack. Now consider that template engines such as Mako can process that same document i mentioned earlier that django rang in at 2.28ms, in only 0.38ms. Consider that DAML can do the same thing in 0.47ms. Cheetah at 66ms. Hell I haven't even tested it again libxslt, but im sure its alot faster. Point being, this implementation of HAML for python is intended to be useful without the need for an additional template engine, framework agnostic, and freaggin fast for on-the-fly compiling.
yes but this lacks a number of features that make it useless for production. I noticed of course on the site that those gaps are filled in by layering it into django templates. This is just increasing processing time for generating a template. Take for example the utmost basic template.html as seen in the "bench" folder Genshi's repository. Django takes 2.28ms to process the template, and its not even that big! Now layer in shpaml on top of that, now increase the document size in turn increasing processing time so that it's now taking 5-7ms to generate a template on the fly. Now 1000./7 ~= 140 hits a second, and this is the first limit your placing on yourself just for the template. This doesn't even include the full web stack. Now consider that template engines such as Mako can process that same document i mentioned earlier that django rang in at 2.28ms, in only 0.38ms. Consider that DAML can do the same thing in 0.47ms. Cheetah at 66ms. Hell I haven't even tested it again libxslt, but im sure its alot faster. Point being, this implementation of HAML for python is intended to be useful without the need for an additional template engine, framework agnostic, and freaggin fast for on-the-fly compiling.
According to the downvotes you've got, it seems likely that it's not wise to insinuate that Python might have bugs :D
You have to provide your own cycle detector or use a built-in type. Does the module namespace use a real dict under the covers or a custom thing? If it's custom, it's possible there's no cycle detection. 
Any version upgrades lately?
I've seen this error on several occasions lately. It's not your code. It's the threading module. Try to upgrade/downgrade python, or at least run this with different version of python and see.
Markov chains are great, I use them to generate star/planet names for a game I'm writing. I fed it 800 or so names from sci-fi fiction, the result is pretty great.
reddit :)
In the case of HAML/SASS, do we really *need* our own alternative when they work just fine as they are? There's no reason to not integrate them into your Django work flow today.
Cool! Any examples?
Do you have heartbeat functions for always running processes (daemons, while 1, etc)? If not, see about implementing some for the most likely culprits. A heartbeat function could also trigger a status dump for global variables (in debug mode), or report back with an array of.targeted variables. In transaction oriented environments with multiple programs always running, I found this technique to be invaluable for finding those impossible-to-reproduce-on-development-environment, but-wait-long-enough-and-it will-surely-happen-in-production errors. 
How about speed. They are slow. Period. How about ruby ?hashes? i guess their called, used in HAML is confusing and painful to look at for a python user who's never used ruby. How about the fact theres no real way to declare a template, import/include those templates, and call them into place where needed. The most I've seen you can do with HAML is a "render-partial" and an include in only one direction, down from the overlay. Thats not useful stand-alone. I assume this is because ERB handles the features missing. So theres another reason, HAML is tightly couped with ERB and thus missing functionality that is sorely needed without having to layer in another template engine like django. And seriously? HAML processes slower in django in my limited tests (id love a better resource on this), so with those two combined? I'd jump off a freakin cliff and have to wait all day to hit the ground And to note, this is not an alternative to SASS. I've actually been reviewing using SASS in my projects and we'll see how that goes Oh geez, and how could I have forgotten the most important. How many python users want to embed ruby in their templates to process their controller responses? Is that even possible? I dont even know if HAML is even a viable alternative beyond basic tag layout
How about speed. HAML is slow. Period. How about ruby ?hashes? i guess their called, used in HAML is confusing and painful to look at for a python user who's never used ruby. How about the fact theres no real way to declare a template, import/include those templates, and call them into place where needed. The most I've seen you can do with HAML is a "render-partial" and an include in only one-direction. I assume this is because ERB handles these features missing. So theres another reason, HAML is tightly couped with ERB and thus missing functionality that is sorely needed without having to layer in another template engine like django. And seriously? HAML processes slower then django in my limited tests (id love a better resource on this), so with those two combined? I'd jump off a freakin cliff and have to wait all day to hit the ground And to note, this is not an alternative to SASS. I've actually been reviewing using SASS in my projects and we'll see how that goes Oh geez and how could I have forgotten, writing ruby code to handle your controller returns? Is this even possible? Seriously? Another reason its use would be sorely limited and would need yet another layer to fill in the gap
Solution is this btw: import sys as _sys Things with leading underscores are cleaned up late.
Are there any Linux Python editors with the feature to jump to the definition of a class/object/module/attribute, etc even if it's in a different file? I'm going to switch from Windows back to Linux soon, but I'm not sure if I can live without PyScripter :)
How about speed. HAML is slow. Period. How about ruby ?hashes? as I think they're called being used in haml. Confusing and painful to look at for a python user whose never used ruby. How about the fact theres no real way to declare a template, import/include those templates, and call them into place where needed. The most I've seen you can do with HAML is a "render partial" and an include in only one-direction. I assume this is b/c ERB handles these missing features. So theres another reason, HAML is tightly couped with ERB and thus missing functionality that is sorely needed without having to layer in another template engine like django. And seriously? HAML processes slower then django in my limited tests (id love a better resource on this), so with those two combined? I'd jump off a freakin cliff and have to wait all day to hit the ground Oh geez and how could I have forgotten, writing ruby code to handle your controller returns? Is this even possible? Seriously? Another reason its use would be sorely limited and would need yet another layer to fill in the gap
I would strongly recommend to choose PyQt. Qt is a very powerful framework and an absolute joy to develop with. It offers loads of functionality, which in the case of GTK has to be found in separate libraries. Qt is very strong in cross-platform support and adapts to the native toolkit looks of the platform it is run on (it even has GTK theme support built in). It is also the official toolkit of MeeGo (the successor/merger of Moblin + Maemo) which is bound to make an impact on the smartphone and mobile-pc market. Also, eric is a very nice IDE built with PyQt.
I prefer NetBeans with the vim plugin (jvi): best of both worlds!
Instead of PyGTK I would recommend PyQt. The eric IDE is nice too. And use git or mercurial instead of bzr, with github or gitorious hosting (or bitbucket in case of mercurial).
Yes, yes it might not be!
Snazzy! Simple and effective.
yeah man ! very very good, the Perl snobs have a thing or two to learn from you. the language is very clean, I like it(I liked it before but now even more so). the algorithm is a classic, but the presentation is slick.
 while response not in ("shut up", "shush"):
Thank you so much. Could you possibly explain what the "not in" part is?
IIRC, the plot function has parameters to set the location and size of the plot. I'm guessing the legent will follow the right-hand side of the plot.
Sure, the "in" operator checks that an iterable contains another element, e.g.: "a" in "my string" False or: 1 in [1, 2, 3] True The "not" inverts that, so it checks if something is not in that tuple.
"in" and "not in" are operators which test membership to a sequence. Take a look at [this](http://docs.python.org/library/stdtypes.html#sequence-types-str-unicode-list-tuple-buffer-xrange) for an overview of sequence types and their operators.
Explained [here](http://docs.python.org/reference/expressions.html#in)
The expression "not in" combines two different operators: The 'in' operator works like this: 2 in [1,2,3] which evaluates to True. The 'not' operator simply reverses True to False and vice versa. Got it? (That 'not' operator is a biiatch. Studies show that a huge percentage of people cannot deal with it rationally. If you are one of those, then programming is not for you.) 
Use subplots_adjust(right=0.8) or whatever value suits your needs to make some room for the legend. 
if you are not however, programming is not not not not for you. 
FYI, it seems like you've gotten an answer here, but stackoverflow.com would probably be better for questions like this in the future.
OK, I get it =D thanks for the help.
It makes sense to me, so hopefully programming is for me! 
So therefore it is for me, because programming and the whole "not" business is not not not not not not not not not not for me. ;D
Or give http://ask.scipy.org/en/ a try.
if you... import time and define something like... upshutting = { 'shut up' : 5, 'shush' : 10, 'quiet' : 7, 'sssh' : 13 } then you could... if response in upshutting: time.sleep( upshutting[response] ) ...and have her shut up for different amounts of time depending on the response. Ok, I'll shut up now.
You see, the trick with Samantha is not to yell at her, but to give her something to do. The reason she annoys is because she is bored. Perhaps, you could encourage a culinary hobby, such as sandwich making?
Isn't md5 a little slow for consistent hashing? This code even only uses the first four digits. Has there been anything released with an fnv hash? I have some toy code that I'd be willing to share if there was interest.
Oh I see: I was imagining a workflow where you translate HAML to HTML before you release it to a live site.
Please do :)
Have I ever!
Yeah, I realized yesterday I was misrepresenting the project by simply saying its a python implementation of HAML. Thats really only the start of it. SHPAML as linked in here is precisely that. This project is actually intended to replace a portion of someone's current workflow. Though I would prefer it to remain flexible as well, no need to shove something down someone's throat to make them use it. I'll be investigating both workflows in django in the coming weeks, but I do not use django so that will be an ordeal in itself.
You'd have to be out of your mind not to go to PyOhio if you live anywhere near. A free 2 day conference that attracts way better speakers then you'd expect for a small regional conference.
really like it. powershell 2.0 (win xp sp3) does not: http://i.imgur.com/L3Jsi.png
Works awesome: http://kgfamily.com/files/fish.m4v Source: http://codepad.org/SwrcDR5x
Protip: Make sure you use response.lower() in your test so your program doesn't get confused by case.
Nice, but I had to add a way to remove the fish when done (basically setting fish = " " * self.own_length)
This looks interesting. What are some examples of things you could use it for? Would it work for SQL?
Hmm... I wonder if there is anything like this under a non-copyleft license (I haven't bothered looking); does anyone know of any offhand? I might need to make a hardware simulator at some point myself.
Did some searching and here's the author's blog about the project: http://eli.thegreenplace.net/2010/05/05/introducing-luz/
More precisely, module objects set all their globals to None when all references to the module go away. This can happen even before interpreter shutdown, if for example you delete a module from sys.modules. (But of course, at interpreter shutdown, this will also happen when sys.modules is cleared and GC is done.) 
If there's an objective reason for their switch to Java it isn't in this press release.
I opened an interpreter and watched this fish all through my lunch today. It was oddly relaxing/comforting.
No Kindle edition?
Oh yeah, the other "Invent Your Own Computer Games with Python" with the blue cover is produced by some guy who takes CC-licensed works and sells them on Amazon. Kind of scummy, but legal (early versions of the first edition didn't have the No-Commercial clause). I'm more annoyed that people are buying an old, typo-ridden version instead of just reading the book online, rather than losing customers.
Orangered'd. I've been trying to learn Python to write games, but the conceptual jump between "Okay I can use the console to do basic math stuffs" and "moving sprites!" seems to be a vast yawning chasm. Will read, implement, and let you know how it works out. Thanks so much for this.
Good luck to you. I liked your book!
You need to let people search inside the book.
I'm using CreateSpace.com (owned by Amazon) to publish the book. It will be a few days before the "search inside" is working. But thanks!
Not yet, but I'm making plans for one in the indeterminate future.
doesn't look much like a progress bar. More like an activity/is alive bar.
You should choose a license that doesn't allow others to sell your work..
You have to install ply so in a terminal just type: easy_install ply
This is great. I just started learning Python and I also wanted to learn how to approach programming games with the language. Win all around.
His version of my book is actually priced at $32.95, but the smaller price is from wholesalers (hence the discount). It is not "more valuable", as it is an older version (1st edition) and doesn't have the Pygame chapters. My book has zero reviewers because it just got listed on Amazon today. The older version has been on Amazone for a year or so. I'll be adding LOOK INSIDE! in a few days, but for now you can read the entire book online at http://inventwithpython.com
I have. It was only for an older version of the book (one of the 1st edition versions) that lacked the No-Commercial clause. It has since been added. (Though this doesn't stop him from selling the old version.)
use the show function and adjust the subplot parameters (left, bottom, right, ...) and use that parameters for your savefig. if you can try pgf-plots from latex tikz. best quality i have seen so far in plotting. 
Dude, this is EXACTLY what I've been looking for. I've been coding in Python for about 2 years now, but only recently have I wanted to make small games (for the linux repositories and such). I think I might buy the hard copy for support purposes :) Great job, and thank you.
For those that just want to know what it looks like: &gt;))'&gt; also there's only one fish, and it goes back and forth. Also, 3 minutes of my life back please.
go on ...
You might as well right a review to your own book, incognito or not, to mention that the many errors of edition one have been corrected in edition two and you don't recommend people buying the older edition, etc...
That's my problem with the Kindle. Here you have the exact same book, legally, from the author. But you can't put it in the Kindle because you can't. You must buy it from Amazon, and if they don't have it, tough luck. And as demonstrated in the past, if they decided that they don't want you to have it anymore, tough luck.
You don't necessarily have to buy from Amazon. .mobi books can be manually transferred to the Kindle via USB cable. 
I wrote one instead! [Vote this up](http://www.amazon.com/review/R1RC8KE6JLM0E0/ref=cm_cr_rdp_perm) so it shows up.
Hey, how did you write this book? Did you use LaTeX or what? I'd be interested in learning what the process is...
 (Scene changes to Freakazoid and Cosgrove commenting on the cute ASCII fishies they've made)
I remember someone posted your book on the [/r/csbooks subreddit](http://www.reddit.com/r/csbooks/comments/9y971/invent_with_python/) a while back. I'll check it out sometime, thanks for writing it!
[Python Essential Reference](http://www.amazon.com/Python-Essential-Reference-David-Beazley/dp/0672329786/ref=sr_1_1?ie=UTF8&amp;s=books&amp;qid=1273204342&amp;sr=8-1), by any mean, after Learning Python.
You may not be able to write code off the bat, but http://www.sqlalchemy.org/ may be a place to look. Their dev page is at http://www.sqlalchemy.org/development.html . Even if it's just testing/QA, you'll gain familiarity with the project quicker, then move to patching. Have fun. :)
Look up [Calibre](http://calibre-ebook.com/), friend. It will change your life.
we do not do refund sir.
Write a simple web app with [Flask](http://flask.pocoo.org) or [Bottle](http://bottle.paws.de) and open source the code. Flask and Bottle are great little frameworks that let you dive into making something useful right away, and writing webapps will expose you to a lot of Python concepts. If you want something intense you could try writing some kind of database backend for [Mercurial](http://hg-scm.org/). Google did it with bigtable so it's *possible*. It would probably be a lot to bite off if you're not already very comfortable with Python though.
Do you have a pdf version I can manually convert for now for the kindle? *edit: never mind I just saw the pdf on the chapters list
Very, very nice. Not only the main ebook formats are supported, it also includes the CBR/CBZ comic/manga format, which is an unexpected plus. Downloading news from the web is a good addition too. In general i'm very impressed so far. I'll have to try it out to see if it fits my general style of doing things, but for that i'll have to stop procrastinating on upgrading my linux, still on Ubuntu 8.10 :)
dito I just bought the book as a thanks and well because I want to read it... I will let you know 
13 votes so far.
If you look at the source, there are two types of fish that you can choose from. &gt;))'&gt; is the bass look &lt;*}}}&gt;&lt; is the salmon look 
Hmm Flask and Bottle seem to be quite similar. When choose which? Also, my favorite micro framework until now was web.py, which is a single file, and works great for prototyping stuff. If I want to go bigger, why should I go for Bottle/Flask instead of one of the big guys (Django, Pylons,etc)? Or would you rather use Bottle/Flask for prototyping? 
hahaha xD
Thank you for the tip. I'll be sure to use it! Also where would I put this line of code?
=O wow, this is pretty awesome, thanks for this, now I know a new module xD. (sorry if my terminology is incorrect, I'm still getting used to the whole thing)
Comment so i can find again. Good job.
Hey, at least it has a target.
Contributing is a great way to learn and meet interesting people. Find an interesting project and dive into the code.
The OP wrote [a post about his experience writing the book](http://coffeeghost.net/2009/11/02/lessons-learned-from-writing-a-technical-book-to-teach-programming/) and lists some advice for writing technical books on his own blog. &gt; This is largely a decision to be made by you. But I wrote Invent with Python using HTML and CSS. Other options include LaTeX or some specific word processors format. Use a format that you are familiar and comfortable with. I chose HTML because I didnt want to spend the effort to learn LaTeX or Docbook before starting on the actual books content itself.
If you want to go bigger , go django + pinax. pinax is a set of compnents on top of django , that save you huge amount of work when building a real site. http://pinaxproject.com/
That's interesting, thanks!
I thought the *real* indicator was recursion and pointers..
Thanks! I didn't get that far because there was a video ITT and bandwidth is cheaper than time, despite that reading the source might have been infinitely more useful. FWIW, I prefer salmon.
Duh. This is a CPU Emulator -- **not** a OS Emulator. The real question would be: Is GCC ported? ;) 
I downloaded PyGame and had stuff moving around the screen in an evening. Try it it's really simple.
Please don't take offense to this, but I already own, and just completed, Andy Harris' Game Programming by Wiley Press. Have you read it? How does yours compare? Side note, Andy is also Computer Science faculty at my university, but don't let that influence your opinion. 
&gt; He finally put his University of Texas at Austin computer science degree in a frame. Hook 'Em! \m/
 pcomp=0 while loop==1: comp=random.randrange(20)+1 if comp!=pcomp:#pcomp has previuous comp value, check if they are same pcomp=comp#put current comp value to pcomp print comp user=raw_input("\ \ Is this your number? Press 1 for yes or 2 for no: ") user=int(user) if user==2: attempt = attempt+1 print "\ \ Oh no, I'll try again, press enter\ " raw_input() elif user==1: loop=0 else:#comp was same as pcomp so start loop again continue
Ok then, thank you. Looking at this code, it looks to me as if, even though it wont print (for example) the number 10 twice in a row, it could potentially print 10, then attempt 10 again, but fail and print, 12, but on the next go it could potentially print a 10 again. Am I correct?
Yes. If you want to stop that from happening you could make pcomp set. Like this: pcomp=set([]) while loop==1: comp=random.randrange(20)+1 if comp not in pcomp: pcomp.add(comp) print comp user=raw_input("\ \ Is this your number? Press 1 for yes or 2 for no: ") user=int(user) if user==2: attempt = attempt+1 print "\ \ Oh no, I'll try again, press enter\ " raw_input() elif user==1: loop=0 else: continue This code goes to infinite loop if it has guessed all possible values, so you need to also check if all possible values have been guessed.
=D This makes sense to me, thank you for your help. and, being the noob I am, could you possibly tell me how I would check if all possible values have been guessed? and how I would code that.
[Beginning Python Visualization](http://apress.com/book/view/9781430218432). Do not be put off by its title.
Since you used createspace I'd also add a link to the createspace eStore page. You make more money per book sold that way. And I for one would rather see the author of a book make more money than amazon if I had the choice.
I would shuffle an array. import random guesses = random.shuffle(range(1,20)) guess = guesses.pop()
When all the possible values have been guessed length of pcomp is 20, because it has 20 values. So just check if len(pcomp)==20. In previous code replace: else: continue With this: else: if len(pcomp)==20: print 'All possible values have been guessed' break else: continue This code thinks that it has guessed the right value when it is out of choices. So you need to still solve that.
len(pcomp) == 20
Right ok, I'm going to give it a go and see how I do. Thank you for all your help Ttl.
what is the random.shuffle function? and what does guesses.pop() do? Sorry for the questions. I'm a noob, but I like to understand the code I'm using.
Ok I've fixed my code using your suggestions and have got it to work the way I wanted it too =D. So thank you once again.
http://docs.python.org/library/random.html http://docs.python.org/library/array.html This was way too easy to find. Please be willing to do *some* research.
You could use the online help... &gt;&gt;&gt; import random &gt;&gt;&gt; help(random.shuffle) &gt;&gt;&gt; &gt;&gt;&gt; guesses = [] &gt;&gt;&gt; help(guesses.pop) Note that OcdSmurf proposal is incorrect, rescind has a correction.
This book looks awesome. I've been looking for something like this to give as gifts to younger cousins for a while now.
Imagine that this is a "pick a card" trick used by magicians. Your original solution: 1. User picks a card. 2. You pull card from deck at random. 3. If user says, "No," you put it back, shuffle, and repeat [2] without remembering. If user says, "Yes," then you're done. OcdSmurf's solution: 1. User picks a card. 2. You pull the top card from the pre-shuffled deck. 3. If user says, "No," you discard the card, and repeat [2]. If user says, "Yes," then you're done. The other alternative (as suggested in using `set()` by Ttl): 1. User picks a card. 2. You pull card from deck at random. 3. If the card is marked, then shuffle, and repeat [2]. If user says, "No," then you mark the card, shuffle, and repeat [2]. If user says, "Yes," then you're done. Ttl's original: 1. User picks a card. 2. You pull card from deck at random. 3. If the card is the one you just tried, remember it, shuffle, and repeat [2]. If user says, "No," then remember it, shuffle, and repeat [2]. If user says, "Yes," then you're done. 
He may be so new that he doesn't know how to look yet. 
Others have answered your question, I would like to suggest the Python Tutor mailing list, this is a very good place to get beginer help, I used it myself some 7 years ago now and it was extremely helpful. So go there, sign up and read it every day. http://mail.python.org/mailman/listinfo/tutor
How does this work? I would really like to know!
&gt; I chose HTML because I didnt want to spend the effort to learn LaTeX or Docbook before starting on the actual books content itself. In many cases, this is probably a really good tradeoff. LaTeX and docbook are powerful and offer lots of output formats from a single source, but they definitely have more complexity than HTML + CSS. I've derailed my own writing efforts into investigation in just how to author with LaTeX or docbook and regretted the time sunk into the investigation.
I downvoted you, then upvoted for the humour of C-level micro-optimisations written in a **Python** program :-) (Note to original poster - please don't take the above code seriously)
Good luck with your homework, I'm sure you'll figure it out. Which textbook are you using?
Thanks for pointing out where we should look with those mouse movements. Otherwise I would have had a really hard time finding the moving fish on an otherwise *completely still* screen.
Yes, setting up the eStore is something I have planned for this weekend. Thanks.
No offense taken. I haven't read the book, but poking through the Table of Contents and first few pages on Amazon, I see it's the same type of programming book I've always seen: it reads like a textbook. It covers Pygame early on, uses something called the IDEA/ALTER framework for drawing (yet another library for the reader to learn), doesn't seem to have a complete game until around page 180, but does have practice questions (I didn't think that was important enough to have in my book). My book takes a different approach: I try to show real, actual source code for games as soon as possible. I remember when I was programming as a kid, for the first several years all my programs were sort of variations of BASIC programs I had already seen (which is why I try to have a variety of games in the book: guessing games, board games, encryption, AI simulation, pygame, etc.) I start with text only because that means fewer concepts to cover before you can actually write programs. I have to delay the Pygame game with three chapters of Pygame introduction because Pygame is rather complicated to make something simple. (Though I do have demo programs in those three chapters). His book seems to cover physics, which is kind of nice. I basically cover collision detection between rectangles, and that is all. All in all, I try to make my book as simple as possible to get from nothing to making small programs, without relying too much on external libraries or IDEs. And, of course, my book is freely available online and also a website with an online tracing and diff tool as well.
http://inventwithpython.com/IYOCGwP_book1.pdf Don't download the torrents for the book, they usually have an older version of the book. (You can find "Version N" on the copyright page at the bottom.) The PDF should match the book on Amazon, but I need to update the HTML version on the web.
Yeah. I want to write a second, perhaps a third, programming book. I think at this point I should learn LaTeX or Docbook. But in many cases, you have to have a version 1 before you have a version 2. Heh, while I'm plugging my blog, I once wrote a Shel Silverstein-esque poem about the flaw of "preparing to prepare": [Starting Out](http://coffeeghost.net/2008/04/09/starting-out/)
I used HTML &amp; CSS. At first I didn't want to learn LaTeX or DocBook. My advice: Don't use HTML &amp; CSS to write a book. :) The web version is easy enough. But making the PDF is a horrible pain. I basically use software to print from the browser to a PDF. I had to try several browser/pdfmaker combinations to get one that didn't look crappy. Even Acrobat's "create from a web page" didn't render it very well. I also tried to jot down some things that I learned about the process, so that I wouldn't make those same mistakes again: [Lessons Learned From Writing a Technical Book to Teach Programming](http://coffeeghost.net/2009/11/02/lessons-learned-from-writing-a-technical-book-to-teach-programming/)
You are very welcome! :P
I don't know how well it works, but you could look at [Scrapy](http://scrapy.org/), which purports to be &gt;a fast high-level screen scraping and web crawling framework, used to crawl websites and extract structured data from their pages. It can be used for a wide range of purposes, from data mining to monitoring and automated testing.
Oh, thanks for that. I would use LaTeX but then I figured that, since you used HTML, it must be better, so now I'm back to LaTeX! I guess you can't beat a typesetting language...
I recently switched to PyDev from Vim at the suggestion of a coworker and am loving it. It's definitely made me more productive as it catches a lot of obvious mistakes before you even try to run your code. The advanced autocomplete and autoimport features are a great time saver as well. The only major pain has been not having my Vim editor to edit the files. Yes, I do know about Eclim, but thus far I've been unable to get it to work :/
Linear Feedback Shift Registers were originally developed directly on hardware. You essentially have a circular shift register with some cleverly placed XOR gates; as you shift the data circularly through the shift register, the XOR's modify the data being held. You can also prime the shift register with a key, and use the resulting pseudo-random patterns to encrypt data, again with the XOR operation. Edit: http://en.wikipedia.org/wiki/Linear_feedback_shift_register
Ah, excellent. I think I've encountered skipping breakpoints a few times. The only way I've found to get around it involves spraying breakpoints up the call stack until one of those hits, and then trying to walk the call down to where I actually want it. It is rare, but when it does happen, I always think I've lost it.
for scrapping ... look at pyquery. for automation ... use python ;-) no ? from pyquery import PyQuery as S q = S(url='http://reddit.com/r/python') for i in q('a'): print S(i).attr("href")
rescind's (note: I'm not entirely sure if this is correct, so apologies if I'm wrong): 1. User picks a card. 2. rescind pulls a card from the deck at random. rescind then feeds the card to a rabid pitbull with a short memory. The pitbull chews on the card, spits it out, looks at it. If it has a guess, it barks the guess. Otherwise, it continues chewing on it and spitting it out until it gets a guess. 3. If user says, "No," then repeat [2], except feed the pitbull the card that was just guessed. If user says, "Yes," then you're done. 4. The pitbull eats the user. 
Wow, very good response. I'll check out your book, I like the way you're thinking about the pedagogy here. Also, congrats on the book as well. Id love to write one; that's one of my goals I keep putting off, so kudos for setting out and just doing it. 
&gt; But I was looking for something more "integrated" and "complete". Mechanize/BeautifulSoup combo is about the most complete and integrated solution you could possibly use. I really couldn't even *imagine* anything easier. You create a browser object, point it at a url, feed the stuff into beautifulsoup, then parse the data you need...and act upon it. Be prepared to use a LOT more try/except clauses though. The web is quite the unstable place, pages can change from session to session, not display at all, or maybe even display only 1/2 the page, etc etc...you'll be doing more exception catching than you will parsing to begin with.
I had, but Amazon didn't display it. Most likely because they (wisely) don't let authors review their own books.
Thanks! If you have time, could you write a review on Amazon?
Go incognito and make a dummy.
Here's my try on Clojure. It is not salted and cannot be used for real, but it helped me understand the algorithm. (defn next-num [bits] (let [ln (-&gt; bits count dec) nn (conj (rest (take ln bits )) (bit-xor (first bits) (last bits)) (last bits))] (lazy-seq (cons nn (next-num nn))))) (take 8 (next-num [0 0 1])) EDIT: I XOR first and last bits, but I guess any combination is valid...
Why does a URL shortener need to be pseudo-random? Why not sequential?
A URL shortener doesn't, but a password generator might. 
Agreed, mechanize and beautiful soup is the easiest and best solution.
umm, pyquery. did not know about it.
This should be the top answer. Short and easy to understand. Found one little bug though. Should be range(1,21).
My vote goes here
Task tags aren't working. Don't know if it's a bug, or if I am doing something wrong. Also don't know if this release introduced the bug, it's been a while since I last used pydev. By the way, I like pydev :)
&gt;clobbered together I love this malapropism.
Oh, sorry, I honestly thought this was a joke (though micro-optimisation was probably the wrong word). Given the OP's self-professed credentials: &gt; Ok this is going to be my biggest program so far in terms of complexity. and his **actual** requirements: &gt; the user thinks of a number between 1 and 20 (note 'user' is singular)...I would have thought readability would be a priority, and this approach definitely qualified as premature optimization. The thing is, you have no idea how the OP wants to extend this. Maybe (s)he would like to have access to all the guessed items (or non guessed items) at the end. In that context, you have optimised for RAM usage when you have no idea that there is a need for that, to the massive detriment of readability and future work. And since the OP only needed 20 numbers, it does seem ridiculous to optimise for RAM usage when writing in Python. I'm well aware of the need for good algorithms, but there is of course the need to take actual requirements into consideration. For example, insert sort has very poor characteristics for large data sets, but what if you only have very small data sets? If the requirements say you will only ever have 5 items, it is plain wrong to optimise for huge data sets. In this case, I'm willing to bet that your solution uses more memory (though not much) than many of the others given the *actual* requirements. 
I think you can do it bignum style too. Select a large, pseudo-random number r that is *relatively prime* with respect to the size of the range or array you're enumerating. Now, for i=1..length(a) print a[mod(r*i,length(a))] You may need to adjust for 0-based arrays or whatever. I came up with this as a way to improve stateless TCP port-scanners like scanrand - you can do random ip/port scans without repetition, and without having to keep track of what ports you've already sent packets to. The real trick is to implement this algorithm *and* only store ranges of addresses and ports, so if somebody asks to scan 0.0.0.0-255.255.255.255:0-65535, you don't go actually building some insanely large array first, then enumerating over it. All you need to do is calculate the size of the total range (2^48 in the example right?), then use the pseudo-random non-repeating number as an offset. Then, for some set of ranges, you store the size of each range, along with the start and end points. Then for each offset, you step through the ranges in the range-set, subtracting the size of each range from the offset and stepping to the next one until you get to where your size is less than the size of the current range. Then you're left with the offset into the current range, which you can use to calculate your current point. So now you've got a very compact, stateless, non-repeating, pseudo-random enumeration of a set of ranges. Perfect for scanning all the ports on that class A your client gave you to test... So the only thing is, I've forgotten too much math to be able to prove it anymore. But I've played around with it and it seems to work. I have some intuition from my old abstract algebra class waaaaay back when. The question is, does this definitely cover the whole space of a within length(a) enumerations, without repetition? And the other question is, what is the relationship between the ration of r to a, versus the apparent pseudo-randomness of the ordering. Like for example if you have a 10 element array, and you use an r of 11, the ordering is 1 (11\*1 mod 10), 2 (11\*2 mod 10), 3 (11\*3 mod 10)... So anything less than square(length(a)) is probably a mistake. But just as obviously, if it's got 128 more bits than length(a), and it's a pseudo-random number that's relatively prime with respect to length(a), the ordering of the enumeration should be pretty un-predictable. See, now I wonder what the strength of function of that unpredictability is. If I can guess that prime number, I can tell what you're going to scan next. How many packets do I have to collect before I can guess your original seed r? Anyway, It's neat to see it done in a shift register, though some of them are much more susceptible to reversing the state given a few samples (I'm thinking Mersenne Twister here). Or something like that.
I like pydev, but it always marks import logging as an error (undefined).
This is also a real good example of premature optimization. If you showed up with this at a code review, I would send you right back to your cube. A program with this functionality should not use more than five lines especially in Python.
Wherever you're doing a comparison; while response.lower() not in shutup_phrases: ... The point is that if you convert your response to lower case before you do the comparison then you won't have to have weird case combinations in your list of acceptable responses (e.g. 'shut up' will catch 'shut up', 'Shut Up', and 'shUt UP').
Your choices in high performance computing are C89 and Fortran03 using the Intel compiler. Somehow I don't think Python is going to get wide spread adoption in that area.
Here is another: http://en.wikipedia.org/wiki/Forth_Railway_Bridge Phillip.
what are the alternatives ?
The trend has been to write key aspects of the code in C or Fortran and then (easily) wrap those pieces in python.
I've always found Eclipse too big, bloated and slow I really wish there were more options for good Python IDE's, I inevitably end up going back to a simple text edit (Editra).
I think you also need to call setgid and get rid of supplemental groups.
Two thoughts: * how does a presentation title slide with a typo as bad as "Chicao Python Users Group" ever end up in front of an audience? * seems like too much detail for a single presentation - where struggling to get your audience to remember anything is the classic problem. Would be better as 4 to 8 presentations.
have you thought about using a real OS? :)
Apparently, you don't say that in the Python sub-reddit! Fortran77 on the Cray YMP was amazing. Python wouldn't do much good there. But one thing I do appreciate about python: the ability to wrapper some decent C libraries and then 'script' them together. The ability to rapidly prototype using some powerful fundamentals is pretty cool for exploratory scientific computing. Probably wouldn't use it for big jobs or big data later on ... but in terms of development ... it kinda rocks...
The problem is you're never going to get a non-computer scientist to re-write working code and all the scientific high performance computing code is in c and/or fortran (over MPI). Java tried to do this and it didn't work for just that reason. Sure they could make Java almost as fast. Sure it's way better to program in that C/Fortran. OMG garbage collection and no seg faults? Did it matter? Nope, they already had working code and weren't going to change it.
This was basically a practice run of the presentation before it was given at a scientific computing conference (I was in the audience for part of this)
This was a rehearsal for a 3 hours tutorial that was later given at Supercomputing 2009 in Portland.
If anyone can figure out why Google Chrome refuses to transparently load the [OpenSearch description](http://www.opensearch.org/) file for that search engine, I'd be much obliged. I spent an hour banging at it without success.
:)
Or...use a decent IDE?
Unless i'm misreading the code (which is entirely likely) won't #3 also pull all files into memory, akin to #2? Also, I'm a little fuzzy on what will happen in `merge` when the files do not contain the exact same number of rows.
I presume the slide was titled "Supercomputing 2009 in Portand"
&gt; Chicao Python Users Group one letter, pretty easy to miss &gt; seems like too much detail for a single presentation I'm pretty sure it was more like 4 presentations under a single title.
Put this into .[g]vimrc: " F7 opens documentation word under cursor, considering syntax function! BrowseDoc() if b:current_syntax == "php" ! firefox http://ch2.php.net/manual-lookup.php?pattern=&lt;cword&gt; elseif b:current_syntax == "perl" ! firefox http://perldoc.perl.org/search.html?q=&lt;cword&gt; elseif b:current_syntax == "cpp" let cname = tolower(cword); ! firefox file:///opt/qt-4.3.4/doc/html/&lt;cname&gt; elseif b:current_syntax == "python" ! firefox http://docs.python.org/library/&lt;cword&gt;.html else return endif endfunction map &lt;F7&gt; :call BrowseDoc() I've just started with python the other day, so I havent tested it much. &lt;cword&gt; does not involve periods, so placing the cursor on any letter of "sys" in e.g. sys.argv will open the sys module doc at http://docs.python.org/library/sys.html. However, F7 on "abs" will probably not work, so doing exactly the same as the posted link would need some more work. OP could maybe add an official URL parameter interface to his tool, so we could use ! firefox http://code.naeseth.com/python/libjump/?q=&lt;cword&gt; from editors and such. 
Thanks for this, it's fantastic. I don't know anything about opensearch, but I did notice the syntax on the example page is a bit different &lt;Url type="text/html" template="http://example.com/search?q={searchTerms}&amp;amp;pw={startPage?}" /&gt; vs &lt;Url type="text/html" method="get" template="http://code.naeseth.com/python/libjump/search"&gt; &lt;Param name="q" value="{searchTerms}"/&gt; &lt;/Url&gt; Hope this helps. /clueless
One of the things I love about PHP and wish other language websites had. Being able to go to php.net/function and go right to the documentation is great because like most programmers I am lazy and impatient and don't want to go to Google to search for it.
It looks like it, yes. Look at StopIteration handling in merge -- it will exit the loop and there is a two-branch if to handle that.
Horses for courses. From the link: &gt; The focus of PythonQt is on embedding Python into an existing C++ application, not on writing the whole application completely in Python. If you want to write your whole application in Python, you should use PyQt or PySide instead.
Nice, but there appears to be a slight hitch with case-sensitivity. If I query using *logging.basicConfig*, the fragment generated is *#logging.basicconfig*, which doesn't navigate to the right part of the page, at least in Firefox 3. If it were *#logging.basicConfig*, that would work.
Cool stuff! I've added it to Launchy, via: http://code.naeseth.com/python/libjump/search?q=$$ (Also remember to hit F5 to refresh Launch before using it) I'd love to have this for decompiled .chm files in html, for when my internetz is slow.
Try clearing all the error markers for the workspace by right clicking on the workspace and looking under the Pydev menu. But, yeah, occasionally it will decide one of my source files is just very wrong, import-wise, even though I know it works perfectly.
Oops. You're right. My bad.
I see his point, but I think he (and his coworker) think the stdlib is this bastion of perfect code. It isn't, and there are some modules which weren't (or aren't) ready to be in there, but they make it anyway (ahem, subprocess). Additionally, parts of the stdlib also have a slightly questionable or clunky design. Perhaps one should just make the code available regardless of whether it is slated to be in the stdlib or not.
Here's what works for me. I code python/django and I deploy on Windows. I tried coding on windows and deploying on *nix, but it got to be too big of a pain having multiple settings files. I find it much easier to have the dev/deploy boxes as similar as possible. For getting up and running quickly look in to InstantDjango. Flat out, best in class. If you want to create a full on dev environment on Windows, it's not that big of a deal, although getting your PYTHON_PATH, and your DJANGO_SETTINGS_MODULE configured correctly can be a bit of a pain. I have a base python 2.6 / django 1.1 install. Feel free to use the binary installers for those, they work fine. I also use PostgreSQL for my database. Use the installers from EnterpriseDB: http://www.enterprisedb.com/products/postgres_plus/getinstaller.do You then have to be sure that you're using the correcct Postgres driver for both your Python version and your Postgres version: http://www.stickpeople.com/projects/python/win-psycopg/#Version2 If you can get those up and running you should be set. As far as my development environment, use a good text editor. I love e. It's a textmate port to Windows, and it's worth every penny of the $35 I paid for it. I keep on trying other text editors like Notepad++, emacs, vim, and I keep on coming back to e. I've also tried full on IDE's, but for the vast majority of Python work, I find them way to heavy handed. That being said, the best that I've found so far is PyScripter. As far as my command line. I use PowerShell. Aside from that, I use iPython as my python interface. It really is amazing. If you're serious about using Python, I highly recommend it. Set up your configuration with this snippet to automatically load all of your models:http://www.djangosnippets.org/snippets/549/ . This of iPython as intellisense for your command line. As far as deployment, I use Windows 2k3, Apache and Postgres. Use the WSGI modules instead of Mod_Python. It's much less persnickety. I'm going to switch to Server 2008 pretty soon, so I can use PowerShell's remote method invocation to completely automate deployment. As of right now, I end up having to remote in and run a script, and I really should automate that process as well, but I've been a bit too lazy. And, have a blast. It's a great language and a great framework. 
It is disapointing that on the bottom of the third page it says "more to come", but the page is 5 years old. Also, why learn nltk lite when nltk is pretty straight forward?
Absolutely brilliant. Probably the best Python development tool to come out in years! :-) 
Ah, good call! It's now generating the fragment using the original (not case-normalized) query, so `logging.basicConfig` should get you where you want to go.
Sorry that the page doesn't make this clear, but you can indeed visit `http://code.naeseth.com/python/libjump/search?q=abs` to get the desired redirect.
Hey, thanks for your help. I actually tried both syntaxes, but the problem I'm having with Chrome is that it won't request the XML file in the first place. Chrome is ignoring the `&lt;link rel="search"&gt;` tag, and I can't figure out what its problem is.
Related: http://www.reddit.com/r/Python/comments/c00qn/a_bit_of_fun_markov_chain_generation_of_uk/ NLTK is pretty darn fun! Right now I'm using it to build an IRC bot that idles in a channel, collects statistics, and mocks people :P
Kinda weird how much more productive this project is than Jambi
pyQt runs on Windows, pySide dont
I code all my desktop apps in pyqt. Work at a geotechnical lab, so I update the application/s, and then everyone does an "svn up" with tortoise on workstations for latest version. Works well.
This is an awesome link. Incredibly useful. Thanks!
Give them a year. This project literally didn't exist at the start of last year (Don't forget the main attraction: the license is fundamentally different :)
There's a whole book and a module (or framework, i'm not sure how to call it) for natural lang processing. Check: http://www.nltk.org/book
Neat. Is there any way that I can point it to local copies of the documents rather than access the web every time?
&gt; if file_name.endswith("pybnf"): self.python_mode = True else: self.python_mode = False self.python_mode = file_name.endswith("pybnf") Or is it there for some reasons I don't understand (very likely)?
If you're on windows try [PyScripter](http://code.google.com/p/pyscripter/)
I just visit the docs often enough that http://docs.python.org/library autocompletes after "d". On second thought, maybe I shouldn't be proud of that ...
I'm sure this is an obvious question, but why do they maintain both 2.6 (now becoming 2.7 apparently) and 3.1?
Because the 2.x line is still very widely used. However, 2.7 includes numerous 3.x features in order to make it easier for people to transition to 3.x. 2.7 is basically the end of the 2.x line anyways, so maintaining what is in essence two trunks will soon be over.
I'm curious as to why you replied to my message.
The auto-complete blows (just uses terms i've searched for, including everything that has nothing to do with python). Why not set it up like [this](http://bozosort.com/hacku), so that it only shows relevant/exact things? 
is pyQt the best/easiest option for python GUIs? i run ubuntu. also: is pyside for qt GUI development? or should I use pyqt? Sorry, a little confused
Thanks for answering, that cleared things up for me. I'm in an awkward stage right now where I'm developing new stuff with 3.1, but a lot of libraries I like (E.G. BeautifulSoup) are still 2.X only, so I have to work with 2.X as well.
I do not program without the complete documentation for the language readily available, no matter how well I know the language. There's always something I've forgotten or confused with how another language does it--or just didn't know!
We'll finally only being doing one 2.x series after 2.7's release.
yes
You and everyone else, sadly
That is one awesome hidden advertisement. Thanks for sharing!
What's the problem with subprocess? I agree that it's inconvenient (I even made my own convenience module for it), but is it technically flawed as well?
Qt C++ was GPL, so to use it you would have to release your product opensource. You could purchase a commercial license though and release commercially. Nokia, came along and released Qt with a nicer license so you can make proprietary C++ products cheaply. PyQt is not owned by Nokia so was left as GPL. PySide is an effort to remake python bindings with a more liberal license. The other main contender for Ubuntu python is PyGTK. PyQt has a good book to learn from and is probably a little nicer. GTK=gnome, QT=KDE but they both run fine on gnome. Canonical released a project called [quickly for ubuntu](http://arstechnica.com/open-source/news/2009/08/quickly-new-rails-like-rapid-development-tools-for-ubuntu.ars) based on PyGTK, but nothing much has been mentioned about it since. 
Both are good for prototyping. The main difference is that Bottle is distributed as a single file module with no dependencies while Flask is a layer on top of Werkzeug/Jinja2 and requires these libraries to run. The APIs of these two projects are exactly the same (Flask adopted Bottles API while Bottle is inspired by Sinatra) so they are easily exchangeable. Both are unstable and relatively new (Bottle about a year now and Flask started one or two months ago) but usable. Bottle has a few applications in the wild and is heavily tested. Flask is based on tested and proven libraries. So, this is really a matter of taste.
"The IP6 format is not supported, only IP4." Fail.
also wxpython
Have you tried [pydoc.vim](http://www.vim.org/scripts/script.php?script_id=910)?
Thank you I will do.
If someone is looking for something fairly simple to hack on, then I'm gonna point out that the 2.6 standard library's csv module does not support reading of unicode csv files. That's the single most frustrating module I've come across in the standard library.
could you maybe upload your code to a snippet site like [pastie](http://pastie.org/)? that way it will be easier to read.
ok then. done. http://pastie.org/953570 Thank you for showing me that. Instant bookmark, what a useful website!
You seem to only printing a specific hint for each try at guessing. Not a hint that is actually related to the jumbled word. Try setting the hint from the jumble section. Look here http://docs.python.org/tutorial/datastructures.html at the list.index(x) as that may help in setting your hint index to use instead of 0-3 like you are doing now. 
While I'm not a linguist I'm doing some computational linguistics stuff with NLTK right now. It's an application of data-oriented parsing to parsing both morphology and syntax (of Esperanto). http://github.com/andreasvc/eodop Concerning NLTK I would like to add that it unfortunately does not focus on performance, eg. it's PCFG parsers are slow and memory hungry (you could blame Python, of course, but it shouldn't be hard to provide bindings to C implementations). I've sidestepped this limitation by providing a shell interface to an efficient C++ based parser (bitpar), but it's messy. To be fair I think Python is more to blame than NLTK. While researching possibly more efficient data-structures for python I came across a flat out rejection to include something as basic as a red-black tree in the python standard library, with the stated reason that they saw no use case for it (they must be idiots because the rest of the world does see it). Meanwhile python dictionaries have horrible memory overhead, while of course being suitable fast, but who cares about that if your application is swapping like there's no tomorrow? My script requires 15 gigabyte with a python dictionary for a two thousand sentence corpus. I have since decided that the optimal data-structure would be a Trie, but of course there exists no C-based implementation of it for Python, let alone one that is included in the standard library (there is one but targeted to routing specifically). /rant... 
I think that would be module, because a framework is something to build on (eg. websites) whereas nltk consists mostly of implemented algorithms and data structures.
And women
If I was going to do something like this the first thing I'd do is try to make it easier to associate the data by making it a dictionary where the key is the question and the values are a list of hints, that way if you wanted to add more than one hint per question you could. Here's an example of what I mean. I think it will help make your code cleaner http://www.pastie.org/953722 
For me, at least, just finding a project that you're interested in is a good place to start. I've learned a lot just by making CD databases (before I had everything in mp3s') and Movie databases. These are generally just things that I find interesting and I find useful. Over the weekend, I worked on writing a PyQt GUI to streamline searches for TMDB (sort of like IMDB, but open). My app is still pretty terrible, and things I need to fix up, but overall, it's okay. I've rarely learned programming via 'follow x guide to do x'. I started following the django 'introduction', but found it kind of boring. I ended up modifying it to read my MythTV database and create lists of movies in there (At which point, I lost interest, because web dev makes me itch uncontrollably.) I used to try to learn how to program like this, but I found that finding something I actually want to accomplish is a lot easier for me to learn from than random examples. A lot of open source development is just getting into the software itself. If that's your intention, find something that you're interested in now, join the mailing lists &amp; irc channels if they exist. I'm guessing most all Open Source projects need documentation - which is a good place to start. Some projects are better about new people joining in and submitting patches than others, which may skew your choice, as well. Obviously, you can 'join' multiple projects to see which one suits you best.
thanks for clearing that up :) I think I'll finish learning GTK then.
You can always put your function into a dll and wrap it with something like [boost.python](http://www.boost.org/doc/libs/1_43_0/libs/python/doc/index.html) and call the code directly instead of launching a separate executable.
Correct me if I'm wrong, but I think this isn't really a python issue. You'll need to modify your .exe to not show a command window. [You will have to recompile it as a windows application instead of a console application](http://social.msdn.microsoft.com/Forums/en/Vsexpressvc/thread/b6f05945-50ef-46bf-936c-308cd9d934ce) (see the last post) Failing that, you can probably do some brutal hacks with the win32api module to find the window and hide it before it even appears, but that's not recommended and beyond the scope of this post, I'm afraid.
Never heard of IP4 or IP6 formats... Maybe they come after IPv6...
I'd much rather use http://bpython-interpreter.org/
I wonder if you could use this: [hstart](http://www.ntwind.com/software/utilities/hstart.html)
I don't know if this is the best way to do it, but this is what I would do: p = sub.Popen['Poker.Equity.Test.exe',str(n),r], stdout=sub.PIPE, stderr=sub.STDOUT, shell=TRUE) Once that is done you can get to the output by running the following, but I'm not a programmer by trade so you'll have to figure out what you want to do with what is returned. p = [line for line in p.stdout] let us know what you do... I'm interested to know.
you may need to quote TRUE in ..., shell='TRUE') I don't know why but my old code worked without it quoted, but when I just tried a quick run it needed it to be quoted.
why was this downmodded? This is the correct answer
The subprocess module supports such hackery directly: http://stackoverflow.com/questions/1016384/cross-platform-subprocess-with-hidden-window
A question that I know I have asked many times. ;-)
This worked perfectly, I'm curious why does setting shell=TRUE turn off the command line, intuitively I would think it is the other way around. (I'm not a programmer either) Thanks for the help
Thanks for the tip, this is really cool. I am going to go with bneises method, it works great for a python specific console. 
Thanks, I'll give this a look
Thanks, I had never seen boost.python, it looks really cool
This will work, but bneises solution(shell=True) does not require changing the executable. 
I think it's telling python that you are opening a program meant to be used in shell.
http://www.github.com/andreasvc/pdfbrowse
Interesting.
Looks like it's just calling ImageMagick `convert` 
these days mod_python should be avoided mod_wsgi is there since ages
Yep, but I added jquery lazy load so that the images load on demand. I could use a python module for doing the PDF stuff but I don't think it would be faster, or would it? As it is, the code is so small that I doubt it would have any benefit at all. Something which I would like to add is tracker search. I wouldn't know how to highlight the search results, but I could at least provide anchor links to the right pages. Similarly to the highlighting issue, links should be clickable.
Why? does it have PSP?
no, but wsgi is the standard for deploying python webapps and mod_python is a messy apache-only hack
I disagree that mod\_python is messy, yes it's apache only, but that's because it's low-level. Furthermore, PSP is awesome. I bet there's no faster python templating engine because PSP is written in C.
The PSP *parser* is written in C so the *parsing* may be fast. The *rendering* however is done in python ([PSP generates python code](http://www.modpython.org/live/current/doc-html/pyapi-psp.html)) and is not faster than in any other python based template engine. In a WSGI environment you usually parse a template only once and the speed of the parser is irrelevant for the performance of the WSGI application. Rendering speed and readable syntax are much more important and PSP does a poor job here.
ET is great and F.Lundh is a great coder and teacher (through his site). However, if you are consider this module, give lxml a try. It's extremely fast and has full support for xpaths and many nifty things =)
Hint: Not validating user input is a bad idea.
What user input? Do you mean the filename? Yes it allows reading of all pdf files readable by the webserver, but that's what a public webserver is for, right? And the filename is quoted so I think it doesn't allow arbitrary command execution, but do correct me if I'm wrong.
I find its syntax very readable; I mean, what syntax, actually? It's just two pairs of tags introducing python code or expressions, respectively. What's not to like?! You may disagree with templating in the first place, that's fine of course. What's a better solution in your opinion, and would it be as concise?
Argh! How can I prevent mod\_python from adding a "Vary: ..." header? It kills my mod_cache solution! UPDATE: SetEnv force-no-vary -- but it still doesn't seem to mod_cache the frigging thing, plus force-no-vary downgrades connections to HTTP/1.0 :(
You are wrong. Try a filename with a single-quote.
Well lo and behold, "file not found". EDIT: I added an os.path.exists() check just to be sure. I'm still curious how this would be exploited. It's probably also better to run the command directly instead of in a shell?
This is better than Scribd's viewer. +1
If anyone is using Scite, you will want to add these to Options-&gt;Python Properties: pythondocs=C:/Python26/Doc command.help.*.py=$(CurrentWord)!$(pythondocs)/python265.chm command.help.subsystem.*.py=4 Replace the *pythondocs* value with the path to the Python .chm docs (Usually C:\Python26\Doc). Now when you highlight a word and press F1, you get straight to the definition (if found). I think this only works on Windows, unless you can get the subsystem to work on Linux (see the section **Command subsystem** [here](http://www.scintilla.org/SciTEDoc.html)).
Wishlisted it to get it when I have some time later this year.
You can also read it in full for free on the website: http://inventwithpython.com
&gt; I bet there's no faster python templating engine because PSP is written in C. But when I write a webapp, I still need more than just templates. Like... a way to display data from some kind of data store. You surely won't argue that I should do it PHP-style, will you?
You can plug-in Karrigell which allows you to embed Python code inside of HTML (and supports WSGI). Not that it is a good idea, anyway...
[pdfbrowse on GitHub](http://github.com/andreasvc/pdfbrowse). You're welcome, lazy redditors.
I'm fairly drunk and way over worked (funny how those things go hand-in hand), so would someone explain what Spring is and/or what aspect oriented programming is? * = grammar
Spring is used to inject values and objects into your programs. Completely useless in Python as you can do that trivially by writing python config files, so it's a lot of bollocks and complexity bringing nothing of any worth in. AOP is used to add behavior in or around existing calls at runtime, it's often interesting if you want to add non-business behaviors (logging, transaction handling, authorization/access rights, ...) without altering business logic or without making it more complex/less readable. You give the AOP engine "paths" to the callables (join points, the points where your AOP engine can add shit) you want to wrap (a pointcut) and a behavior you want to add (an advice), and the AOP engine will handle all the instrumentation. If you know dtrace, it's basically a basic, read-only AOP engine for the whole OS. The system probes (static or dynamic) are join points, the probe conditions are pointcuts and the actions are advices.
No I wouldn't argue for PHP-style, except for quick hacks like this.
Thanks for the explanation &amp; for making the dtrace analogy, that makes it really easy to understand.
What's the difference between this and decorators in Python, if any? Also, is there a similarity between this and monads in Haskel?
What you want is 'super' - it always refers to the superclass. e.g. super.create_boogie There is an argument that it's "considered harmful": http://fuhm.net/super-harmful/ I would recommend reading a quick guide to OO in python to grasp all the basics: http://www.voidspace.org.uk/python/articles/OOP.shtml
&gt; What's the difference between this and decorators in Python, if any? With decorators, you have to alter the original source code. A closer (if messier) analogy to this would be reopening classes &amp; wrapping methods in Ruby. &gt; Also, is there a similarity between this and monads in Haskel? I have absolutely no idea. I don't think so, but my "mastery" of monads is nowhere near good enough for that kind of comparisons. You should ask in /r/haskell and report back.
First, you should be using new style classes (subclass object). Second, are you sure you want Boogie calling methods of World? When something seems kludgy it usually indicates something wrong with your design. However, if you are sure that's what you want to do, then that's the way you do it. I might implement World as a singleton class, that way you can instantiate it whenever you need it and get back the same instance. 
Thanks for the info! I think there is a very good chance that the problem is with my design as you indicate...
Definitely looks like some good reading for me to do...this is my first foray beyond simple scripting-to-make-less-work-at-work, so I expected a few hangups along the way. Thanks!
1. It's super(). 2. Boogie doesn't subclass World.
This is not a Python issue; the clunkiness of circular references of this sort is a general design issue. It feels clunky because it **is**. You need to examine why it is that a World needs to keep track of a list of Boogies, and why it is that a Boogie needs to know what World it's in. Chances are high that these are not actually both the case simultaneously.
Your solution is perfectly pythonic. I don't find it clunky at all, assuming it's necessary for all Boogies to know about the World and the World to know about all Boogies.
Yeah, it largely depends on what you are trying to do. However, you may also find this demo code instructive: http://www-inst.eecs.berkeley.edu/~selfpace/cs9honline/P4/
It's not clear to me what you're trying to accomplish here. Keeping a reference to the parent world in Boogie isn't necessarily bad but most tower defense games I've seen have only one world so you can infer what world you're using by the fact there is only one. Are you trying to give each Boogie instance enough information to know what to do? E.g., if a unit walks by the Boogie do you want to tell the Boogie to fire at it or something? class Boogie(object): # inheriting object makes this a newstyle class (good) "Assumed to be a tower of type 'Boogie'" # skipping __init__ declaration def explore_world(self, world): "In this function the Boogie can access the whole world." pass # put real code here class World(object): def __init__(self): self.boogies = [] def create_boogie(self): self.boogies.append(Boogie()) # note: no parent reference def tell_boogie_about_world(self, some_boogie): "Passes a reference of this World to some_boogie." for boogie in self.boogies: boogie.explore_world(self) Code like this might be what you're after. If it is, I strongly urge you to consider where logic should reside. Do towers decide who they shoot at from a list of everything nearby, or does the world only tell the tower about certain things and the tower always acts the same? edit: damn indentation!
Why does a Boogie need to know about an instance of World? Operate on Boogies from the outside. Don't turn them inside out. You're passing an reference to a instance of a class correctly, but it feels clunky because it's probably dumb. 
When considering this approach you may want to look at [ctypes](http://docs.python.org/library/ctypes.html), this is a builtin library that will let you interface dynamically loaded code with pure, vanilla install Python.
Out of vague curiosity, what are the advantages of bpython over ipython? As near as I can tell, ipython does everything bpython does and a lot more... Am I just missing something?
&gt; singleton Hiss!
If you really feel that both the World and the Boogie must reference one another, I'd suggest that one side of this equation do so using a [Weak Reference](http://docs.python.org/library/weakref.html) 
Good points. I think I'll be re-evaluating the overall structure rather than tweaking something that is appearing more and more to be poorly designed from the get-go.
Thanks for this. It's becoming clear that I'm making my objects far more 'knowledgeable' about the world than they need to be. I think I've been placing too much logic in the boogies and towers... 
Thanks, very instructive :)
Yeah, I see what you mean. 
I think a quick hack like this would be just as short in any microframework like bottle or flask.
last time I tried spring python it was mainly for the AOP which was completely broken while going through the tutorial. I did the due diligence and filed a bug report. http://jira.springframework.org/browse/SESPRINGPYTHONPY-134 It's un-resolved. But unless I am completely missing something in that code, the error is just stupid nonsense that should never have made it into a release of a framework that claims to have many benefits like loose coupling and aiding in the testability of your code Other than that, as others have said, it brings complexity with not much pay off at all, very un-pythonic.
You are doing very good work with this.
Personally, I've never learned from a book. I always buy one, try to learn from it, get pissed at the confusion, stop trying to learn the language. Then I find a project that is widely used and I think is implemented in the wrong way, I become furious at that, channel that dislike into convincing myself that I could do better in a programming language that I don't even know. Finally I begin to blindly program, hitting every bump along the way and learning a new programming language. This has been my story with C, C++ (kinda), and Python. I have no fucking clue how I'm going to get through college this way.
cryptlib charges [$75.00](http://www.cryptlib.com/security-development-toolkit-pricing.htm) *per* end-user in royalties??? D:
As with many things I guess it's mostly personal preference. What I really like about bpython: * Very clean curses interface * Automatic completion * method paramter hints / docstring display * rewind (ctrl-r) There is a short screencast showing some of the features: http://bpython-interpreter.org/static/bpython-screencast01.ogg 
Jaegermeister was a good choice :)
You should ask the Plone mailing-list, or on IRC / Freenode / #plone. 
[http://plone.org/products/plone/releases/2.1.2](http://plone.org/products/plone/releases/2.1.2) I couldn't find an explicit link, but clicking the download release and simply changing the URL seems to work. I still maintain a 2.1.x site myself, although I've always built Zope/Plone from source. They are certainly making it more difficult to find the older releases. EDIT: My bad, apparently the download links lead to *nothing at all*...
Awesome! Thank you for this framework. I've written 1 productive app with Flask, and 2 apps in development. I absolutely love it! Edit: You couldn't have done better job with the codename :)
This is very nice. I'd actually started on something like this, built around Werkzeug and Jinja2, but I like this a hell of a lot better than what I was working with. Combined with SQLAlchemy (as I see you've [included](http://flask.pocoo.org/docs/patterns/sqlalchemy/) in the patterns section), this could really rock. 
&gt; Which leaves us with ob_type, a pointer to an objects type, a central piece of Pythons object model (bear this deep in mind: in Python 3, type and class effectively mean the same thing; historic reasons lead to the usage of one name over the other depending on context). Every object has exactly one type, which never changes during the lifetime of the object (under extremely unusual conditions it can be changed, no API exists for that and if you handle type-changing objects youre not likely to be reading this). &gt;&gt;&gt; class C(object): pass ... &gt;&gt;&gt; class C1(object): ... def f(self): return 'hi!' ... &gt;&gt;&gt; o = C() &gt;&gt;&gt; o.f() Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; AttributeError: 'C' object has no attribute 'f' &gt;&gt;&gt; o.__class__ = C1 &gt;&gt;&gt; o.f() 'hi!' So no, there's nothing "extremely unusual" about changing object's type and there is this obvious API =). Though of course if you would try to change the type to `int`, you're in for a rather cryptic error. All in all, these series are relevant to my interests, please continue!
This isn't a windows installer but archived Plone packages are here: http://dist.plone.org/archive/ &gt;Requires Zope 2.7.8 or 2.8.6 on Python 2.3.5 already installed Both have windows installers here: http://www.zope.org/Products/Zope/swpackage_releases http://www.python.org/download/releases/2.3.5/ I suggest figuring out the exact versions of Python and Zope the site is using before installing these to minimize headaches.
@masklinn: You say Spring Python is worthless, because you can code things in python config files. Have you looked at http://springpython.webfactional.com/1.1.0/reference/html/objects.html#objects-config-object? If that's not a Python configuration file, I don't know what is. That is pure Python, giving you complete power and flexibility. Maybe you are assuming that Spring Python requires you to use XML. We have an XML format, but its not required. It serves more as a bridge for ex-Java developers familiar with Spring to migrate over to Python. @twillis1973 I'm not sure what tutorial you were following but nowhere in the official documentation are you directed to assign factory.target.__class__.__name__ = "instance". I say WTF too...considering that's not how we do things! Go visit http://pastebin.com/nBZ011dX for a sample based on http://springpython.webfactional.com/1.1.0/reference/html/aop.html. Looking at the ticket you opened, I'm not sure how Python would react when you have both a method and class with the same name. Must be really confusing. To answer your question about why it is checking that the target is instance? Because I designed it that way. When I coded the AOP solution, I opted to give the developer flexibility in only applying advice to selected instances of classes, not to the whole class itself. If this seems like a critically needed feature for your, why don't you join us on the mailing list, the forum, or on the #springpython irc channel and discuss it openly the way open source developers do, not just snipe about it on reddit. Many other features have been enhanced and developed through 2-way communication. Just opening a ticket in jira, and expecting others to pick it up as a priority doesn't really cut it in the open source community. But then again, maybe that's just me. I don't just hop over to stackoverflow (http://stackoverflow.com/questions/2461702/why-is-ioc-di-not-common-in-python) and continue to repeat the same invalid complaints against AOP that are also posted on reddit. I prefer a more constructive approach. But again, that's just me. Anyway, if you are willing to set aside any knee jerk, not-invented-with-a-dynamic-language assumptions, and look at a more detailed set of arguments for IoC/DI, then checkout https://www.packtpub.com/create-powerful-versatile-spring-python-1-1-applications/book.
That's not a bug.
To make sense of Python Unicode, just remember that it's magic. Seriously. Unicode characters are magic. To print/save/whatever them, you need to convert them to a more mundane format, which you do by encoding them to ASCII/whatever else. This way they lose their magic and can be treated as mundane bitstrings. To convert a bitstring into Unicode again, you need to decode it so that it regains all its magic. And that is how Unicode works.
If you just want one unique identifier for the machine, try uuid.getnode: http://docs.python.org/library/uuid.html#uuid.getnode
I knew someone would find something wrong in the article :) That said, the cryptic error actually says this can only be done with 'heap types', i.e., types that were dynamically allocated on the heap (using the 'class' statement or the 'type' constructor or the '__build_class__' 3.1 builtin), and not anything that comes with the interpreter or a C extension. Also, in writing the article I only found mentioning of this in the documentation in two places, it was never specified exactly how to do it (I thought it was to deter the uninitiated / because it might change in the future) and in both times it appeared with a warning discouraging you from doing it. So I'd be careful of calling this an "API", though the old saying goes any sufficiently elaborate bug is indistinguishable from a feature... Thanks for your support, and indeed I shall continue!
I teach Unicode at Hogwarts and I can confirm this.
Yay! Finally you can select which interpreter (virtualenv) libraries to refresh and it only takes a few seconds not 10 minutes like before! Thanks very much for that!
You wrote the learn python in 10 minutes tutorial! You definitely know what you are talking about.
&gt;Though of course if you would try to change the type to int, you're in for a rather cryptic error. Just FWIW: Python 2.6.1 (r261:67517, Dec 4 2008, 16:51:00) [MSC v.1500 32 bit (Intel)] on win32 Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; x = object() &gt;&gt;&gt; x.__class__ = (3).__class__ Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; TypeError: __class__ assignment: only for heap types Couldn't tell you what Python 3 reports, though.
Thanks timeaway - I got it from dist.plone.org as you suggested...
It's early days yet, but I'd say Flask could well be a replacement for Pylons for projects where you don't want to use Django. The documentation is better (clearer, more organized and up to date), it's just as easy to use with SQLAlchemy or some other backend, and it's a LOT easier to understand. Pylons/Paste create a lot of modules you have to wade through to get started, configure middleware, etc (maybe I'm stupid, but I still don't quite get the idea of "entry points"), Flask just provides you with a simple API you can learn in 20 minutes. 
By that measure everything involving programming computers is magic. The kind of magic that is not really good for parties.
Regular magic is also not really good for parties. 
A nice short intro to Unicode its self: http://wiki.secondlife.com/wiki/Unicode_In_5_Minutes
It shows, doesn't it!
I dunno, I like the water-2-wine trick. With a lot of water.
:-) Yeah. As far as I'm concerned, a singleton is just a thinly veiled global variable.
+1 http://en.wikipedia.org/wiki/Law_of_Demeter
*Every* time I've encountered a situation where I'm tempted to make use of a Singleton, there has been some glaring deficiency in my program's design. Usually, I've failed to define clear boundaries on how data flows through the various processes. Once those places are smoothed out, I find that I suddenly don't need a Singleton. I'm sure someone can suggest situations where one is the "right" answer, but I tend to view Singletons as an indication of a design flaw further up the chain.
Also there are more than 200 packages with "Framework :: Buildout" trove classification: http://pypi.python.org/pypi?:action=browse&amp;c=512 
hum... so you suggest we use flask instead of web2py? ;)
wow zope.
useless stats. Doesn't take into account the time that a package has been up, nor does it take into account previous versions of packages. A package that hasn't had a new release in a long time is rated more highly (even if totally dead) than very active packages that release monthly. 
Of course not. There are enormous differences and this is not the place to list them. Except for one philosophical issue: Web2py is committed to its users before its developers. That is why we promised backward compatibility to users and we never broke it since 2007, despite adding lots of new features. Other frameworks have yet to prove that kind of commitment. It is difficult because every developer has his/her own agenda and beliefs and eventually someone thinks that it is a good idea to break everybody else's code by renaming unicode as str, for example. Anyway remember, Flask started as an April's Fool joke that the author himself took seriously. Considering that was one month ago, Flask is making good progress.
But zope/plone packages are released quite often... and Django just at 32th position...
Maybe because it's a dependency for a lot of other packages, and gets downloaded as a result of that?
What if the package is listed in PyPI but the actual download is hosted somewhere else? How do you get the download stats?
Ugh, when looking at those stats one must believe that Python consists of nothing but infrastructure webcrap. 
Just in case some people haven't read this: [The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)](http://www.joelonsoftware.com/articles/Unicode.html) Not really specific to any (programming) language, but probably the best introduction on the subject I've ever read.
The simplest way to create singletons in Python *is* a module-level global variable. :) There is no need for all the java-y getInstance() mess.
Upvoted for truth. TBH, it's pretty easy to get that impression of Python whatever you do.
No way should Myghty #47 be and Mako #136 (I wrote both). Myghty is entirely defunct and that one ancient release has just slowly amassed downloads for years. Mako has a more active release schedule so the downloads are spread out. This tool should aggregate across releases.
I asked the guy who made this to do rankings that aren't per-version, and he said he'd give it a go this weekend. So... will be fixed?
Because web developers are LIVING THE OPEN SOURCE DREAM!
http://docs.python.org/tutorial/modules.html
yeah, I've read this already. It says to put the module into a directory that the sys.path lists. I get it. Now explain why when I put the module into one of the directories listed it still doesn't work. I get: Traceback (most recent call last): File "&lt;pyshell#10&gt;", line 1, in &lt;module&gt; import odbchelper ImportError: No module named odbchelper
Do they? When I think about PHP then Wordpress, Wikipedia ( Mediawiki ), Yoomla, Mantis, Magento, phpMyAdmin, ... come to my mind i.e. *web based applications* and OSS on application level, not 5 package administration and built tools in the top 5. 
You can just keep it in the same directory as your example program and import it. The current directory is on sys.path. Also, to see what other locations are on sys.path, fire up ipython or the python interpreter in interactive mode and type: import sys sys.path And it'll return something like: ['.', '/usr/bin', '/usr/lib/python2.6/site-packages/PyMOTW-1.100-py2.6.egg', '/usr/lib/python26.zip', '/usr/lib/python2.6', '/usr/lib/python2.6/plat-linux2', '/usr/lib/python2.6/lib-tk', '/usr/lib/python2.6/lib-old', '/usr/lib/python2.6/lib-dynload', '/usr/lib/python2.6/site-packages', '/usr/lib/python2.6/site-packages/PIL', '/usr/lib/python2.6/site-packages/gst-0.10', '/usr/lib/python2.6/site-packages/gtk-2.0', '/usr/lib/python2.6/site-packages/wx-2.8-gtk2-unicode'] (depending what python modules you have installed on your system.) 
Python will be able to find any modules in the current working directory, so the easiest way is to run python from the directory with the odbchelper.py file in it.
It's quite likely you just don't have a file named called "odbchelper.py" anywhere. There's been a bit of discussion recently of whether Dive Into Python is any good as a tutorial, not least because it starts you off with crazy things like ODBC. [Learn Python The Hard Way](http://learnpythonthehardway.com/index) is one attempt at a replacement, and the website links to others.
I understand this, I have created odbchelper.py and put it in the directories listed. 
Is there an [`__init__.py`](http://effbot.org/pyfaq/what-is-init-py-used-for.htm) in the directory containing odbchelper.py?
Buildout is created Jim Fulton, the creator of Zope. Other than that, Buildout has nothing to do with Zope.
&gt; I dont even use free software that requires X11. Lemme know when you figure out that coders like Macs and Ill try Wingware. I like Linux, so I guess i'm not a real coder. My life is a lie..
there you go. author does not know what they need an IDE for. they look around and point out the obvious.
I'm currently using vim, and I'm wondering if there's a python IDE can do code completion to left hand side object. For example: a = "foo bar" then if I type 'a' it can list all methods of 'a' object as a string.
That's not what he said at all.
Linux is basically just a stripped down mac.... (I'm joking please don't kill me)
in vim it's called [omni-completion](http://www.vim.org/scripts/script.php?script_id=850). netbeans [can do it too](http://netbeans.org/kb/docs/python/temperature-converter.html).
I use Komodo Edit and I feel most productive with it. 
Same directory or somewhere in sys.path or insert something into sys.path, since it's just a list (don't do that, btw). Please remember that modules consisting of more than one file (directories) will require \_\_init\_\_.py. Oh, and remember to not name your local files like stdlib modules. For example having sys.py in path somewhere leads to trouble.
Try [pida](http://pida.co.uk/). Edit. Ok, so this time I read enough of TFA to realise he doesn't 'use free software that requires X11'.
PyDev can do that. Regardless of the article it's actually quite good.
I think many arguments stated in the article are nonsensical. &gt;So why not just use Vim? I could do it. Ive been using Vim for many years and am pretty good with it, but I just feel like separating my coding from my terminal whenever I can is a good thing. I dont want my code to look like my terminal, nor do I want my terminal to look like my IDE theme. . Im SUPER picky about fonts and colors in my IDE, WTF? 16 colors (that you can configure however you want) are enough for most, if not all programming language syntaxes. There are very decent fonts for terminals. Also, you can use vim without a terminal. &gt; I really prefer a specialized tool to a generic one with plugins layered on to provide the necessary functionality. Eclipse with PyDev really feels to me like a Java IDE Certainly didn't feel that way to me. Eclipse is not a Java IDE, it is a generic platform. PyDev gets the job done very well.
Have you tried other IDE's, like PyDev, for example?
Yep, it is the best so far of all I've tried. 
Komodo is especially good for web apps, the Javascript/Html editors are also very good.
I want to say it first: Emacs! * Vi-mode:  * Python console:  * Project management:  * Debugger integration:  * Intergration of version control systems:  * Class browser:  * Auto completion:  * Refactoring:  I too searched for a python-IDE and i found emacs. 
pyCharm is OK
I've tried every other IDE. What's so good about PyDev? Komodo runs fast, no project space clutter (only 1 file for project), easy import of working directories, and most important, when using virtualenvs Komodo Edit configures to read from them with 3 clicks. PyDev is slow at startup, pain in the butt to configure, and the Project Workspace is just dead wrong. I don't want 2000 chars of path and one directory for all my projects. Also, I don't use graphical helpers for svn/hg/git. Work them through command line.
then i will be KING (except for virtualenv and paste of course )
make sure \___init\___.py is in the very same directory as your module. Import sys and print out 'sys.path'. Do you see the directory where your module is in? Worse comes to worse, just to troubleshoot you can also try appending the system path to 'sys.path' e.g., "sys.path.append('/your_full_path/')". Be aware, strings containing backslashes '\' that you mean to be taken literally need to either be escaped '\\' OR you can prepend 'r' onto the string e.g., "r'C:\Windows\etc'". Also, when you import a module, Python naming conventions still apply. Never add an extension to your import. Hope something helps. 
No, the problem's that the blog author is an idiot who, for someone who "knows" Vim, seems remarkably ignorant of its capabilities. For one, Vim doesn't have to look like a console; you can set your fonts to whatever you want or use the Mac equivalent to GVim, although I wonder why you'd ever want to do that since the greatest Vim IDE is obtained by using screen to manage vim and shells simultaneously. Second, Vim DOES support the mouse, even in a command line environment. It also supports modern terminals with support for 256 colors. 16 colors is plain bullshit, I don't know where he got that from. Finally, it supports the little things different editors have but none have in combination: snippets, tags, source control integration, etc. You pair that up with your screen (especially using Byobu, the best screen theme there is) and nothing can match it. Look, everyone knows Vim requires a bit of learning to get it right. But we've got Google; you have dozens of blog posts and wikis on how to pimp it up. There's no excuse if you're willing to waste away weeks of your time experimenting with IDEs.
Provided your GPS device comes up as a serial port you should open it with pyserial and parse the NMEA sentences. You need only the $GPRMC sentences. Instead of writing a full on parser you can just create a regular expression and discard anything that doesn't match. If your GPS does not enumerate as a serial port then you are screwed, use one of these instead http://bit.ly/cwvxrm . If your GPS device is not NMEA, e.g. SIRF binary, you will need to find a way to switch it into NMEA mode.
Your post strongly reminds me of [http://bash.org/?152037](http://bash.org/?152037) ;)
In fact, I can't imagine ever using a Mac as a coder. The vibe I get from MacOS is "form over function", whether Apple practically invented modern UI design or not. I like my KDE launcher and yakuake shortcuts and being able to tweak key bindings and GUI styles and colour schemes to extremes. Maybe it's because MacOS 9 (pure GUI, who needs a shell anyway?) and the iPhone OS (closed ecosystem) always come to my mind first thing when I think about Macs, but programmers using anything but Linux just feels unnatural for me. Well, at least it's not Windows.
Anyone else notice that the text in the title tag is 'Pyhton for Linguists'?
Can you kindly tell me what kind of extension are you using for each item like refactoring and auto completion?
I'm using emacs too. Could you elaborate on what you are using for project management, class browser, and refactoring in emacs (for python development). So far I'm using python-mode with ipython for autocompletion and anything-python.
If all you worry about is "form over function" with macs, I'd say you could safely reconsider. I think a lot of what makes their 'form' work is attention to function. The two are really unified when it comes to computers. Of course, there are other reasons not to support Apple...
[here](https://unstable.nl/books/view.psp?pdf=report.pdf%3B--%3E%3Ch1%3Ethis%20is%20awesome%2C%20I%20don%27t%20validate%20my%20user%20input%20at%20all.%20If%20I%20were%20evil%2C%20I%27d%20put%20tubgirl%20here.%3C/h1%3E) is an "exploit". EDIT: I like the idea of the app, it's quite interesting. I just wanted to point out why input validation was important. 
Some bits: pymacs, rope, built-in vcs, built-in debugger (gud).
&gt; "form over function" Form and function are orthogonal ideas, even though it's common to suggest they exist on a continuum. Something can have both form and function, or neither form nor function, or a bit of both. I've written code on both Macs and Linux machines, and greatly prefer the Mac. Sure, it has some glitzy UI stuff and whatnot, but at the bottom it's a pretty standard BSD Unix system, meaning it has all the power of BSD and Linux along *with* the glitzy UI stuff. I think it's a testament to programmers' machismo and insecurity that they claim that "real" programmers have to use a particular platform. "Real programming" is a function of an individual's talent and intelligence, not what platform they choose to use.
Well, I used to argue that Apple is evil because they sell closed systems and you can't simply replace individual components as with an IBM-compatible PC. I never liked consoles either  I'm a PC gamer. But I guess that argument would seem hypocritical these days as I'm happy to use a notebook or netbook and increasingly lose interest in building PCs by myself. It's really mostly the gloss and "prettiness" that puts me off today, I suppose. I like rough edges and matte textures. I want a truck, not a roadster. Green pixelated console fonts on black screens, not clear type on a carefully arranged starfield. I want a machine, not a sex toy.
I'm really not sure why the [Eric Python IDE](http://eric-ide.python-projects.org/) isn't more well known. It's natively written in python + pyqt, has a wonderful debugger, vcs integration (and modularly implemented too), additional qt-related development features, etc. All based on pyqscintilla. It's also cross-platform (whenever pyqt can go). It's also got great syntax highlighting for things like Mako+HTML, somewhat of a rarity in IDEs. (for debian/ubuntu users, just apt-get install eric, and you're off)
I'm not a big fan of using XRC (for example subclassing is a pain). I use wxFormBuilder and I wrote a program to convert the FBP files into Python code, bypassing the runtime XML parsing and multi-stage initialization pain. I guess it could be easily adapted to read XRC files since they're very similar. I would release it but I wrote it for my employer in a closed-source project.
Real programmers manipulate butterflies in Africa in order to shift bits around anyway.
I've used Komodo Pro for ~4 years now. I like it a lot except for the fact that certain debugging keystrokes I'm used to from Visual Studio can't be set in Komodo because they are reserved by Mozilla (which Komodo is built on top of).
Eric has a very impressive features list, but it's got two things that always annoy me every time I try it: 1. The UI is busy beyond belief. It's busier than most IDEs. It's like Visual Studio barfed into my Microsoft Office and splashed it on my screen. The default layout is to have every conceivable option in a toolbar button, and if that's not enough there's like 20 menus. 2. That damn [Gnome](http://eric-ide.python-projects.org/images/eric_header.png) gives me the heebie jeebies every time I open their website. Are these petty reasons? Sure, but it's not like Python is incredibly complex. What do you need an IDE for anyway? Why does it all need to be integrated? Get a good editor, get a good visual debugger for the rare times you need one, get a good VCS, and learn how to use a command line. The skills you learn with these will also serve you well outside of your coding tasks.
&gt; 16 colors is plain bullshit, I don't know where he got that from. I use gnome-terminal and it only supports 16 colors. I am fine with that. however. It is enough for coloring my syntax.
Help them port it.
1. Yeah, it's CRAZY with toolbars. First thing I usually do when I install eric on a system is go to "Windows &gt; Toolbars &gt; Hide All". That feature only appeared recently I think, people must have been asking for it :) 2. You don't like him? He just wants to devour your soul. Or give hugs. Not sure which. I don't really use many of the IDE-ish features per se. Main reason I use it is as an editor with syntax highlighting and vcs integration. Most of my company's apps are too complex (or too pylons/paste based) to be run from the debugger properly anyways. So I do like how the rest of it stays out of my way since I'm not using it. edit: My love of syntax highlighting isn't really for python per-se, but for other things like Mako HTML files, where I may have mako + html + python + javascript all rolled into one poor file. Syntax highlighting keeps my brain from short-circuiting in the wee hours (and Eric's one of the few with pygments-based highlighting integrated into the scintilla widget).
Is there a good IDE for that?
Apparently there's an emacs keybinding for that.
&gt; No, the problem's that the blog author is an idiot who, for someone who "knows" Vim, seems remarkably ignorant of its capabilities. Not just ignorant. He also has a completely different idea about software, it's some sort of a paradigm mismatch. I got a friend whom I recently introduced to my tools of trade (vim/gVim, ipython, zsh, bzr/Olive, etc), and after an hour of my "presentation" (which included changing themes, using the mouse and whatnot) he said: "It's cool, but I just don't like the idea of using a terminal-based editor." I felt like we were speaking different languages.
Thanks! I will fix this. EDIT: fixed (AFAIK) and committed.
Also pyCharm.
Um, standard Python REPL can do that: Python 2.6.2 (r262:71600, Apr 16 2009, 09:17:39) [GCC 4.0.1 (Apple Computer, Inc. build 5250)] on darwin Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; a = "foo bar" &gt;&gt;&gt; a. a.__add__( a.decode( a.__class__( a.encode( a.__contains__( a.endswith( a.__delattr__( a.expandtabs( a.__doc__ a.find( a.__eq__( a.format( a.__format__( a.index( a.__ge__( a.isalnum( a.__getattribute__( a.isalpha( a.__getitem__( a.isdigit( a.__getnewargs__( a.islower( a.__getslice__( a.isspace( a.__gt__( a.istitle( a.__hash__( a.isupper( a.__init__( a.join( a.__le__( a.ljust( a.__len__( a.lower( --More-- Put this in your .pythonrc: def spiff_up_repl(): """Add tab completion and persistent command-line history to the top-level.""" try: import readline except ImportError: pass else: import rlcompleter import os.path import atexit class irlcompleter(rlcompleter.Completer): def complete(self, text, state): if text == "": readline.insert_text('\t') return None else: return rlcompleter.Completer.complete(self,text,state) readline.parse_and_bind("tab: complete") readline.set_completer(irlcompleter().complete) # Restore our command-line history, and save it when Python exits. history_file = os.path.expanduser("~/.pyhistory") if os.path.exists(history_file): readline.read_history_file(history_file) def save_hist(): import readline readline.write_history_file(history_file) atexit.register(save_hist) spiff_up_repl() del spiff_up_repl 
More looking at Windows and thinking, "Gah! Why would they design this so poorly?!" 
You need this in your .bashrc: export TERM=xterm-256color And this in your .vimrc: set t_Co=256
&gt; with **pygments-based highlighting** integrated into the scintilla widget This, I was not aware of. I... I think I'll take another look at it.
Just another [leaky abstraction.](http://www.joelonsoftware.com/articles/LeakyAbstractions.html)
Differently != poorly. fork() isn't the end-all, be-all. It is awesome for servers and the like. But it isn't simple. General applications who want to kick off another process that is totally unrelated should not have to clean up everything right before the exec(). They just want the program to do its thing and leave it alone. CreateProcess(), in its 50 parameter glory, at least lets you get away with that. Windows opts to having the programmer opt-in to inheriting file handles, rather than assuming that is what you want. Linux allows you to opt-out via O_CLOEXEC and the like, but how do you control whether libraries you use use that call? And how can you be sure the Python runtime is providing it? [This page](http://www.linuxprogrammingblog.com/threads-and-fork-think-twice-before-using-them) goes into some of the intricacies involved if there are threads in your process and you want to fork(). I'm not sure I agree with the author when he says not to mix threads and fork(), but what is any GUI app supposed to do?
Honestly, there are issues with fork(). While it makes many things easy, it also promotes coding practices that make accurate estimation of memory load very hard -- there is a reason malloc never fails in Linux. Sure, you can turn off overcommit, but when you do that, you usually run out of memory during bootup. Clean ubuntu 10.4 has some 6 gigs of address space allocated after boot -- while the vast majority of it is shared and will in fact fit in about a hundred megs, in theory every process could use it all, and thus the kernel just doesn't know when it runs out of memory.
&gt;CreateProcess(), in its 50 parameter glory That's one aspect of what I was talking about with poor design. 
&gt;Honestly, there are issues with fork() Yeah, it's not perfect but it beats the snot out of `CreateProcess()`. 
Apple produces some rather expensive bricks.
[emacs](http://xkcd.com/378/).
Try Tk. It looks like crap but the docs are good and it makes sense (at least to me). Once you are done with that, try wxWidgets.
http://www.zetcode.com/wxpython/
Your options are: pyQt (or pySide on gnu/linux until it is able to run on other platforms) pyGTK wxpython All of the above mentioned modules is bindings to c/c++ libraries. In my experience Qt have the best documentation if you are willing to read c++. But seeing your question is: &gt; What is a good way to ease into GUI programming? I would recommend you download [Qt Creator](http://qt.nokia.com/products/developer-tools) and read [Introduction to Design Patterns in C++ with Qt4](http://cartan.cas.suffolk.edu/oopdocbook/opensource/) to get a solid background on how Qt and GUI programming works and after that it will be a lot easier for you to use the pyQt or pySide bindings with python. I don't have a lot to say about pyGTK or wxpython only that I know they exist and last time I looked(2008) I found the GTK documentation lacking compared to Qt.
It's time to let windows go. Let it go...
&gt; This book is so well written for absolute beginners I believe my grandmother could learn to program with it. too bad she's going to die soon and Python is of little use to dead people. do you believe your grandmother will write Python in hell or in heaven ? or if there is no such thing as hell/heaven isn't it completely futile for her to learn anything at all much less Python, as she will be rotting 4 feet under the ground with maggots and bacteria ? reality is so crude that it makes me think politeness is the ability to hide the hard parts of reality. please excuse me if I'm a bit rude, I hope your grandmother has a great life(what is left of it)
Hey thanks for the info, this helps a lot. It seems that C++ is generally a more intuitive route to programming GUI. Is that right? Moreover, to use this sort of C++ code in a python program, it seems that I need to employ "bindings". I've googled it up a little, and it seems that bindings are something you call in Python and they help you access code that is written in C++. Is that right?
thanks I am going to look into it. What's the difference between wxpython library and wxWidgets?
wxWidgets is a C++ GUI library. wxpython is a python wrapper for this library.
excellent.
wxPython has a pretty active list with help from a solid core of experts. Start dabbling and post sample applications demonstrating your sore spots when you run into trouble. I think it's a great piece of kit.
The binary package for Pyqt is [here](http://www.riverbankcomputing.co.uk/static/Downloads/PyQt4/PyQt-Py2.6-gpl-4.7.3-2.exe). I'm in the middle of reading Mark Summerfield's PyQt [book](http://www.qtrac.eu/pyqtbook.html). I only have a few months of experience with Python, but I'm on page 284 (of 643), and so far I've learnt how to make: Main windows, dialogs (modal dialogs, non-modal dialogs, "smart" dialogs), toolbars, menus and sub-menus (including active menus that, for example, track recently opened files), dock windows (with customizations), making actions/key sequences, loading/saving various settings (window positions, opened files etc), making layouts that hold widgets, making signals/slots/actions both in code and Designer, saving/loading custom data in binary/text/ini/xml format (using python and/or Qt methods), dealing with user input (checking for validity of input, with various techniques), using PyQt Designer to make dialogs and implement custom behavior in code (or implement everything in Designer if I want to), etc.. The author also throws in a nice Python class chapter at the beginning, and you can download the source code for all the examples in the book (so you might even try running the examples before reading the book, if you want to). I haven't finished reading the book yet, but I would highly recommend it. Oh and, don't worry about the date of publishing, all the examples in the book work fine (although there was a little bug in a recent version of PyQt which made an app crash after a successful run, but I think this is fixed now). 
Komodo IDE is $250, that's not expensive for something you use as much as an IDE. I also like that it runs on Linux, Mac OS X and Windows and supports most languages quite nicely, giving you a consistent IDE experience across platforms and languages.
Next to libpthreads, a lot of stuff falls by the wayside. Their API is pretty much perfect.
Why would anybody do GUI programming any more when it is easier to build a web interface instead and make the program accessible concurrently and remotely?
&gt; First, lets get Wingware out of the way. Im on a Mac, and if youre not going to develop for the Mac, what a fucking moron of a mac fanboy
that guy is a fucking moron of a mac fanboy.....the world has to revolve around the fucking mac sheesh
&gt; That damn Gnome gives me the heebie jeebies yeah that head looks like some diseased cock
So two different platforms have *different implementations?* Who ever would have thought! (Disclaimer: I'm really not that cynical, I promise. :)
There are plenty of other ways of launching processes like WinExec (deprecated) and ShellExecute. You don't have to use CreateProcess (or any of its siblings) if you don't need to.
The open source dream is apparently to build tools for other open source developers to use to build tools for each other.
I wont say C++ is the more intuitive route to GUI programming. There is a lot of options like Mono, Lazarus, Glade, etc. I just recommended a tool like Qt Creator because it has a WYSIWYG editor that generates all the boiler plate code for you and the Qt library is well documented. But remember if you want to use Qt Creator(the tool) you will have to program in C++. Also you won't be creating the binding because there is already a good binding for Qt called [PyQt](http://en.wikipedia.org/wiki/PyQt)(and hopefully in the future PySide). Have a look at the Hello World example in the wikipedia link. So my recommendation was use Qt Creator to learn the Qt Framework and create some small applications. After you understand the Qt Framework you can use bindings like PyQt or PySide to use the Qt Framework in python itself. 
Because: * it is faster, can run on the bare metal. * its stateless * You don't have to struggle with different client browsers to make sure it renders correctly * and it is still the best way to do graphics application on a PC. just to name a few. Edit: The web is stateless.
* Vi: viper + vimpulse * Console: uhm...python-mode I think * Project-Stuff: ECB * Debugging: honestly...I usually just drop a "import pdb; pdb.set_trace()" in the code. But I think there is a visual debugger for emacs+python. It's just that I don't need it. * VCS: http://www.emacswiki.org/emacs/MercurialMode * Class/Function browser: ECB somehow does this * I think rope. Most times i just use the dumb-completion * rope can do that. hope this helps :) 
http://www.reddit.com/r/Python/comments/c3x3i/python_ide_frustration/c0q2fy5 and thanks for anything-python, that module seems to be pretty neat.
Not obvious that is is faster than when you access the web app locally on localhost. Web apps are not stateless. I agree with the last two points but the world is changing fast and it is better to prepare for the future. Did you see [this from Google](http://code.google.com/apis/o3d/).
Well then you will need a local httpd for each application or configure the httpd on the local system to run php, py, etc(with iis oad apache support for cross platform compatibility) and then it will still run slower compared to a executable. But maybe on todays machines its not a problem, but I see that kind of mentality as a problem because it adds a lot of extra bloat. My main point is my grandma can't get a httpd server up to run her applications but she can run setup.exe or use the nice add/remove applications thingy in the Ubuntu menu. Also I'm sorry I meant to say it is stateless. But I agree with your last point about the shift that is happening, but the web as we know it was around since 1997 and html5 is still getting drafted. The only contenders to desktop applications is binary interpreted languages like Flash, JavaFX and Silverlight that gets streamed to your browser. And what is to stop Nokia to use their current Qt Architecture and develop a web based Qt for example [Wt](http://www.webtoolkit.eu/wt#/)?
I don't think there's anything necessarily wrong with this. Circular references should be avoided whenever possible. But sometimes it isn't possible. Cases where parents need to know about children and vice-versa are classic examples where you need circular references. [looking at this again - if there is really only one central world then this is not a good idea... the Law of Demeter is "never wrong".]
Can someone explain what this is in a nutshell?
I don't see any real advantage to that in this case? The garbage collector handles circular references just fine... under what circumstances in his design would a Weak Reference be handy? (Basically, weak references are almost always used for caching - in almost any other case, you want to know that you either have something, or you don't...]
Python, I love you more and more every day.
There is no such thing as call-by-sharing. Python uses call-by-value, but what gets passed around are references to objects. And if these objects are mutable and you modify them, then, well, you do modify them. Making copies of immutable objects (int, string, tuple) is just plain idiocy. If you ever need to modify an int/string/tuple in a function, you can also use a mutable counterpart -- list instead of tuple, or a numpy array. Like this: def f(x): x+=1 a=1; f(a) =&gt; a=1 a=numpy.array(1); f(a) =&gt; a=array(2) You also have call-by-reference in Scheme or Java: if you modify some object you get passed as a parameter (with Scheme, you'd need to use set-car! and the likes), you're poking around with the caller's data.
Yes, you are right about making copies of immutables. It is a typo. I have just fixed it. I actually meant dict, list, set, etc.
This article has practically zero information. The introduction talks about how Python beginner's typically don't know what call-by-sharing is and then *does not explain it*.
check this online interactive tutorial to start http://ironpython.net/tutorial/
Python is a cinch. Just go to python.org, there are links to lots of intros.
* http://docs.python.org/tutorial/ * http://diveintopython.org/ and make sure you're using python 2.xx not 3.x edit: well maybe in your case you can also use 3.x assuming everything you need has already been ported edit2: you may want to check this as well http://scipy.org/
How much time do you have to invest in really learning python. Is this a one and done, I need to learn it as fast as I can to get a result, or will this be something you plan on knowing for the future?
What's the nature of the problem? I coded an app using [Biopython](http://biopython.org/wiki/Main_Page) for some of the work I am doing, but without knowing closer to what you are trying to do its hard to make an exact reccomendation.
I'm working on a Master's project heavily involving python (I'm a professional Software Engineer in my day job). I'd like to hear more about what you're working on, feel free to PM if you don't want to make it public, I would be glad to collaborate (My focus is Computational Ecology). 
You might also just want to post a notice in your local CS department, asking for help from another student. Chances are somebody could write a solution for you quickly, then walk you through it. 
Diveintopython is for programmers. Not for newbies.
that's what the book says but I've read it and it's no different than the tutorial with respect of the level it has.
thanks Alex. heard about it before, but finally downloaded it. can't access the performance pages though. and i like this: &gt; we implemented other languages too: Prolog (almost complete), as well as Smalltalk, JavaScript, Io, Scheme and Gameboy.
This is interesting post. Only you haven't proved that conceptually writing a language in itself is faster that writing the language in C. Your example shows that the code is smaller, but that doesn't mean faster. And the optimizer is a non issue because you can run JIT in the C implementation too (unladen swallow).
I *think* that a well-performing map implementation in Cython would look friendlier than either the C or the PyPy version. You could start out with a pure Python implementation and then modify it to take advantage of the knowledge you have about types (i.e., use List_append instead of .append). The thing that would help any made-to-be-faster Python implementation, be it Cython, PyPy, unladen swallow, Jython or IronPython, would be a standardized way to add type information to a plain python program. At least for micro-optimizations, this would be really great. The way that PyPy and unladen swallow solve this problem is that they do trace-based optimization, which is great, because it also helps for code that has heavy OO-style polymorphism, but it's slightly overkill to *have* to depend on the JIT. In PyPy, you *need* the JIT if you want a performance that even remotely resembles CPython's.
Still, there's no point in reading DiP2. It's better to read DiP3 and then go back to Python 2 than to read DiP2 and pick up a lot of bad habits that made sense in Python 2.3 but not 2.6 or 2.7. 
I still advise to learn 2.xx and migrate forward (as everyone will be doing) instead of going backwards but you may be right in that the 2.xx version covered in DiP2 is too old.
Hopefully, after Mark Pilgrim finishes Dive Into HTML5 he'll do a DiP2.6. 
Since you are using Python for science, I suppose you'd better check [Python(x, y)](http://www.pythonxy.com/). It's a collection of all libs and tools you'll ever need for scientific calculation in Windows and Linux. 
I was flooded with javascript alerts...I guess that's what happens when you don't escape your forms. Oh the irony. Looks like he's fixed it now though.
I think the authors have relied on Markdown parser. Also, this site written with Play Framework (Java).
If they used Django, this wouldn't have been the case. You have to explicitly mark a content safe so you can output html/javascript
They used to implement voting with GET requests. Professionalism my ass.
Oh, no, with Django would have the same problem ;)
Don't know which of the comments are worse: the inaccurate newbie crap or the fanboy "I hate Django because it's too perfect" fawning.
Hurt that no constructive. I feel that the fans started to shit bricks.
What's the point in this? At this point there is only one or two actual complaints about Django on the site - the rest is written by fanboys or people trying to be funny. If you have a legitimate complaint about Django and a story you'd like to tell, do it in a blog post, so we can learn exactly what you think is wrong with Django, if anything.
When i think about it, you're probably right.
On the contrary, we are interested in other people's opinion, their real experience of walking on a rake.
I considered asking if we should pronounce it pee-pee or pie-pie, so for a change I checked "python" in Wiktionary instead of Merriam-Webster, only to discover that they use the much more readable SAMPA instead of IPA. Example: * Wiktionary: (UK) IPA: /pan/, SAMPA: /paIT@n/ * MW: \p-thn, -thn\ So it's pie-thon and pie-pie. And MW doesn't use standard IPA.
As williamofbaskerville said in another comment, if you have a complaint about a framework - be it a single feature or the design philosophy as a whole - the place to do it is a blog post. You can detail a project that went wrong because Django was chosen, for example, or workarounds for certain issues. That helps other developers when choosing a framework, or if they go with Django, avoiding the pitfalls you have encountered. Pithy one-liners by fanboys and the ignorant help nobody. One-liners by people who know what they are talking about is just whingeing. 
Yeah, but since your domain is ihatedjango.com, I'm assuming **you** must have a story to tell? And looking at the submitted stuff there, I'd say people won't get any real information by looking at the site, only tweet-like opinions. If you have a domain that says "I hate Django," I think it's fair to ask exactly why you hate Django.
As for useful information. Later will need to do moderated posts. In general, we have answered, why we hate django - see posts from **Sevenov** and **barbuza**.
&gt; Only you haven't proved that conceptually writing a language in itself is faster that writing the language in C. It is also not claimed that this is the reason it is faster. But it obviously has a lot of other advantages. Read the intro to PyPy. The architecture of PyPy aims to be even more than just a Python interpreter.
You mean this ? &gt; 1) django.contrib.admin awful inconvenient, nailed to the authorization from contrib(!!!). 2) Single auth in the site and in the admin interface. 3) Failure to use multiple instances of the application. 4) ??? n) FAIL! That reads like a weird, incomprehensible haiku. And for the mind-blowingly stupid (or one would hope, just a bad joke/troll): &gt; it uses whitespace for logic. Doubt any guru can fast recover code after simple preg_replace(/\s+/,''). And snippets cannot be normally published via html. OF course, i tried Django, and i FAILED, because i am dumb. PoHaPe foreva, anything other sucks. Chuck Norris 
Unfortunately, appeared too many trolls.
With a domain name like that, what on earth did you expect ?
Let you remember Cal Henderson and his report entitled "Why I Hate Django" (DjangoCon '08).
I always just click the little icon that lets you listen to someone saying it. Pronunciation guides confuse the hell out of me. All those silly characters.
That was a detailed, informative talk with proper examples, not a honeypot for trolls and fanboys.
Yes, this I would agree with you. We gave this site is not correct.
What is your native language? Not to be insulting -- I can understand your English in this thread, but it is unusual, and that makes me curious.
My English is terrible and I know it :) My native language - Russian.
What's the problem with relying on the jit?
It is memory intensive, so not suitable for every current use of Python. Also, if your program is one-shot, you probably won't get as big a boost as a long-running program. Still a big win for many (most?) though.
Wait, who pronounces it pee-thon?
As a biologist you might be interested in this: Python course in Bioinformatics (http://www.pasteur.fr/recherche/unites/sis/formation/python/index.html)
Ugh, I hate the Merriam-Webster style of pronunciation (which isn't SAMPASAMPA is just IPA mapped to ASCII). Whenever I'm looking up the pronunciation of a word in a dictionary that uses this non-standardized style, I then have to look up several other words I know the pronunciation of so that I can cross-check that their bizarre symbols for vowels do indeed sound they way I'd guess. It is not intuitive to me that ** should be the sound in 'father' and that *a* should be the sound in 'cat'. Of course, I don't suppose it's intuitive that the IPA's [a] should be the sound in 'father' and its [] should be the sound in 'cat', but at least knowledge of the IPA is transferable to languages other than English. Absolutely the only way I could have figured out how to pronounce [Uyghur](http://en.wikipedia.org/wiki/Uyghur_people).
I hate to bog down the commentary here with a newbie question, but what exactly is the difference between all of these Python interpreters (CPython, Jython, PyPy...)? Is the difference with how you write the code and the packages that can be utilized? The most important question I have is, can all of these implementations work with NumPy and SciPy?
I strongly disapprove of this post and the linked web site. In my country we have a saying "you don't look a gift horse in the mouth". If a software is free and you don't like it, do not use it. The authors of Django have done a great service to us all and whether we use it or not, we should be thankful. One thing is to compare systems, propose new ones, emphasize the strength of one system over another (competition is good, even if always biased); another thing is to complain about something for the sake of complaining (use bug reports if you find a bug).
Can Cython support closure? As far as I know it is not officially supported.
My 4yr old nephew, I think.
Closures have been on the Todo list of the Cython people for quite some time. In principle, there's no problem - you just have to figure out what variables are used in the local function and move them to a closure object instead of allocating them on the stack. There's even [an experimental Cython branch](http://hg.cython.org/cython-closures/) with closure support, so I guess it's more or less a matter of time.
I am going to answer you with what I understand We currently have * CPython * Jython * IronPython * stackless Python * PyPy * Unladen Swallow * Cython (Only large subset of python, but I put it here because it can compile a pretty complete subset) CPython is written in C and generates its own bytecode. Since it is written in C, many C/C++ libraries (like numpy, scipy) can be easily glued into this implementation. It has a threading problem (GIL). Jython and IronPython generates jvm and .net bytecode respectively. Because their internal architecture are not C, therefore the FFI with C is a more convoluted problem. There are [attempts](http://code.google.com/p/ironclad/) for these non-C implementation to call C-style library. They dont have GIL problem because it uses the jvm and .net threading system. Unladen is a google's attempt to add JIT and solve some of the deep problems (GIL) in current CPython. Some shows promises and some has been failed. It is to be merged to Python3k releases. It is in C/C++ and based on the popular [LLVM](http://llvm.org/). Stackless is a fork of CPython that tried to solve the threading problem in CPython. The history of not having it merged into CPython is predated my programming life. PyPy was a research based project that tries to bootstrap python itself. It was based on the technique and result from a CPython library called [Psyco](http://psyco.sourceforge.net/). It attempts to solves some of the fundamental issue that CPython has because of its C-implementation, and adding JIT to it. They are working on C-extension integration now and it is implemented upto python2.5. Because it is bootstrapped, the backend is implementation independent and can generate different target (given someone implemented the particular backend). Cython (and Shed Skin) are attempts to compile Python's dynamic code into static typed language by type inference and type annotation. Compiled Code is faster than dynamic code because compiler can do opimisation based on type information. Most speedup are from operation of basic type like *int, double, char* and therefore they are popular in scientific community which python excels. One thing to note that they do not support full set of python and Cython even accepts type annotation that is not python compatible. However it is Cython goal to support python3k's function annotation. 
their release manager says it should be included in next release. 
* CPython - The original, slow, written in C, relatively hard to maintain because of that. * Unladen Swallow - (Really just an experimental branch of CPython, the two will be one in the same at some future point) Makes CPython faster using Just In Time Compilation * Jython - Python for the JVM, no GIL, mostly slower than CPython. Much better at CPU bound threads than CPython because of the lack of GIL though. * IronPyton - Python for the .NET framework (and mono), again I believe no GIL, and slower than CPython. Similarly better threading performance as Jython. * Pynie - Python on top of the Parrot VM. Very new, not very mature. * PyPy - Python written in Python. With the same code base it can be translated to C, Java, and the .NET framework. It can optionally be translated with things like stackless support, or its own Just In Time compiler which makes it generally faster than CPython. IronPython is the only interpreter other than CPython that I know of, that I've heard of NumPy running with (using their compatibility layer, IronClad) As far as I can tell this is to a pretty limited extent. My Google Summer of Code project is, among other things, to get NumPy working on PyPy (As you can probably tell by the relative size of my blurbs, it's my favorite of them) Just two days ago I got NumPy to compile against PyPy successfully (With a combination of viable fixes and dirty hacks that will need to be replaced before the month is over), but it fails immediately when you import it. There's plenty of work left to do there, but thought I'd let you know :-).
Among the natives probably no one, but in French the pronunciation is something like peeton, and the English rules of pronunciation are quite hard to guess.
Hrm, you clearly beat me to the punch, but I didn't see your post until now :-/
From the UK, I loved hearing my Canadian boss, or Americans pronouncing python: "PhythOhn" as opposed to "peyethn"
There is also [Dreampie](http://dreampie.sourceforge.net/) I've been using it recently and its pretty good. Sometimes I also use iPython and am still unsure as to which one I prefer yet.
I thought you were supposed to pronounce it /'pan/ (i.e. the "-on" being pronounced properly, not turned into a schwa as in the animal's name) because it's a proper name (from _Monty_ Python, which the language is named after).
&gt; CPython - The original, slow Why is it slow?
&gt; It has a threading problem (GIL). Nah that's a threading solution.
0.1 alpha, going to use anyway just for the name.
I use pdftk on linux for this sort of task. # pdftk pdf_1.pdf pdf_2.pdf cat output combined.pdf Or, pick and choose pages # pdftk a=pdf_1.pdf b=pdf2.pdf cat a1-3 b2 b4 a5 output combined.pdf Or, rotate pages # pdftk a=pdf_1.pdf cat a2E output rotated.pdf (the 'E' means east, theres also N,S,W)
I do not understand. How is this different from django.views.decorators.cache.cache_page? 
Lots of new features including experimental {{block}} in templates, automatic reconnect for closed connections when pooling, better PyPy and Jython compatibility, new Rocket web server, better Oracle and Firebird support, multicolumn checkbox widget, curd.search widget, bulk_insert on GAE... [read more](http://web2py.com/examples/default/changelog) EDIT: Our policy: ALWAYS BE BACKWARD COMPATIBLE EDIT: Thanks to all those who have contributed. We have more than 50 developers now.
Now reading in battlecruiser commander's voice.
Dude, if you want your own trimmed-down version, you write a function that substitutes the values that you want. Does your language allow for creating custom functions? OK then, what was your problem?
It's a very simple as an interpreter. Clarity of code has been preferred over speed for the most part, although with the Unladen Swallow project this will change somewhat. 
I may be mistaken, but the performance of the exact piece of code presented in TFA (builtin map implementation) does not depend on JIT, because it is actually RPython, which is ahead-of-time translated to C/x86 asm/whatever. Just a note.
This is very cool! Why are people downvoting this?
I suspect it's due to mdipierro's constant and annoying web2py evangelism. The framework is quite good, albeit quirky in a few places.
Is there documentation on writing a language/syntax for Pypy?
Nice name.
From what I can tell, it is tied to database writes. So any time a write occurs, all the pages are invalidated and regenerated.
I bet it would suck to get bitten by a peethon; doubt it would hurt anything other than your pride though.
I hear so much about PyPy, but is anyone actually using it? Can I get SciPy/NumPy working?
I didn't say launching a new process is impossible, but I think it's needlessly complicated. It's bad design if I have to work around it all the time with my own abstraction layer. Something so fundamental should have a reasonable interface. `fork()` is such a nice solution. And yes, I do use a library in Windows to give me something reasonable to work with: Cygwin. 
This might be clearer: people from North America say "py-THON" and people from the UK say "PYTH-en". Also see "ta-MAY-toe" / "ta-MAH-toe", "WA-ter" / "wo-TAH", umbrella / brolly, pants / trousers, underwear / pants, rent / let, tv / tele, and so on... Oh and one of my favourites: fanny means something completely different in the UK. The term "fanny pack" actually makes sense once you learn that (tip to men: don't wear fanny packs, lest people think you have a fanny).
Actually I made a mistake in posting. Please press the [upgrade now] button in admin to upgrade to 1.78.2 automatically (posted few minutes ago).
When you say "any time a write occurs, all the pages are invalidated and regenerated." you refer to django.views.decorators.cache.cache_page?
Past year google for "rails site:reddit.com" #670; "django site:reddit.com" #350; "pylons site:reddit.com" #163; "web2py site:reddit.com" #37. I prefer the word promotion to evangelism, ;-)
I like your attitude, I really do. More developers should be as excited about their work. I just use the word "evangelism" because it seems that in any Reddit conversation remotely related to Python web frameworks, I see a post about web2py, always with your username. It really is annoying when people are talking about, say, debugging a Pylons app when a post about how web2py does it better pops up. Not that that is a legitimate example, but I see this type of "promotion" all the time and it strikes me as advertising. But do keep up the good work.
I also like advertising better than evangelism. :-)
Based on the title, I expected this to be about quarks capable of executing Python bytecode.
That is an excellent resource. Helps in understanding programing using examples that are easy to understand for biologist. I learned a lot from this course. 
"slow" means that, for microbenchmarks, the JIT variants are *lots* faster. Even when you're basically only handling integers or doubles, you're still creating objects, calling virtual functions, etc. in CPython. The way to solve that is to do type inference either at compile time (where it's difficult because you don't know much) or at run time (where it's difficult because you have to do it on the fly). If you're not doing type inference, you *still* have all the overhead of object creation when it's not needed, which is why just compiling Python to equivalent but non-specialized C code only gives you a rather limited speedup. (This is also why IronPython and Jython are slower than CPython - they have to support all the dynamism features on top of the other VM). ShedSkin, which is missing in the above list because it doesn't come with all the useful runtime libraries, does static type inference and is (a) fast and (b) memory efficient. PyPy is generally faster than CPython but gobbles up twice as much memory (which is a bit counterintuitive since it should be doing *less* superfluous object allocation): see the [Alioth programming languages shootout](http://shootout.alioth.debian.org/u32/compare.php?lang=pypy&amp;lang2=python). There's still ample room for improvement: [SBCL lisp](http://shootout.alioth.debian.org/u32/benchmark.php?test=all&amp;lang=pypy&amp;lang2=sbcl) does quite a bit better when you give it helpful typing hints, and uses about half of the memory. (SBCL does static compilation, but the type hints make it efficient; admittably they do sacrifice some clarity to speed). 
Short answer: No. Long answer: not yet, but soon.
someone likes sphinx
&gt; PyPy is generally faster than CPython but gobbles up twice as much memory (which is a bit counterintuitive since it should be doing less superfluous object allocation) Guess that's just memoization overhead for compiled variants. The reader might think about the overhead C++ generates when it instantiates templates. &gt; (SBCL does static compilation, but the type hints make it efficient; admittably they do sacrifice some clarity to speed) How do type hints remove clarity? They remove some flexibility / duck typing.
evangelist = [this](http://www.saintlucas.gr/O_EYAGGELISTHS_LOUKAS/IMAGES/saint_lucas.jpg) , however he looks like he is redditing on an ipad...
In honour of mdpierro's great techniques of self-promotion, here are a bunch of irrelevant links to other Python web frameworks: * http://djangoproject.com * http://pylonshq.com * http://werkzeug.pocoo.org These are all, of course, much better than web2py. Django allows you to edit your web application through psychic thought waves and Pylons supports databases that don't even exist yet using the `hot_tub_time_machine` plugin.
I follow web2py since a few month, never seen anything of this type beyond the "don't forget to also check out web2py" in a thread about web framework choice.
Buildout gets downloaded a lot because running a buildout normally checks whether a newer version of buildout is available, and if so, downloads it. So lots of people have multiple buildouts that they update, causing the new version to be downloaded a lot. Not sure whether that explains all of the figure; it still looks very high, but it does explain some of this phenomenon. 
Buildout technically is something very different than Zope. In that sense it has nothing to do with Zope. But it's true Zope-based projects such as Grok, BlueBream, Zope 2, Plone, Silva, etc, do use buildout a lot, and lots of the people who contribute to buildout come from the Zope community. But you can use buildout with Django just fine: http://jacobian.org/writing/django-apps-with-buildout/ 
The reason Zope packages are so high up not only because Zope-derived systems are popular - some of them are very popular and have sizable communities. It also has much to do with the fact that the Zope community was an enthusiastic early adopter of Python automated packaging tools and application assembly tools. Because of this it's easier to assemble an application or framework from a whole range of smaller libraries, and do upgrades of such, and we do a lot of it from PyPI. The last year or so the Python community as a whole is starting to catch up, so this will change. 
Thank you for the detailed answer, it was very informative.
no, Jimmy Page is being referred to. It automates cache invalidation in a rather transparent way that's optimal for a few types of website but rather useless for others.
I don't know, the documentation doesn't seem to say anything about page caches being invalidated when db writes occur: http://docs.djangoproject.com/en/dev/topics/cache/#the-per-view-cache Am I missing something?
Still draft. 1.2 final's not out yet.
The benchmarks used to run on a VM, however recently they started displaying totally inconsistant performance (because they're on a VM). As a result they were moved to a full machine, and so there's not much data ATM.
No problem! I don't know if you consider this to be an exploit, but it looks like clients can also traverse your filesystem using the pdf input variable. Example is [here](https://unstable.nl/books/view.psp?pdf=../../../../usr/share/doc/shared-mime-info/shared-mime-info-spec.pdf) I admit that this one is pretty much hit or miss, but if you have any other (possibly sensitive) pdfs on that machine that the apache user (which defaults to 'www-data' on Ubuntu, which is what your server is running if the headers aren't lying) has permission to read, well, they're available as well.
This is why I'm hesitant to even learn Django: &gt;There are a number of changes in Django 1.2 which will be backwards-incompatible I don't need to be dealing with incompatibilities every time I upgrade. I wish they would stabilize their API and get it over with.
It's still a very good read so in case you wrote it, thanks. Know what, thanks anyway.
The ranking is now by package name instead of version, and the winner is... 4Suite-XML, and after that aafigure, an ascii art to image converter. :) Okay, I suspect the index is in the process of being rebuilt as only 10 items seem to be in the database right now. 
Django is really good at being backwards-compatible. The biggest changes were from 0.96 to 1.00 and then now from 1.1 to 1.2. Even then, the new database schema is backwards compatible until I think 1.3. In summary, the API became pretty stable in 1.0 so you don't need to be too hesitant.
Thanks very much for this marvelous web framework. I tested django and used zope in production but i must admit I'll now stick to web2py. it has all the features I want and there are 3 very big selling points: small code base, no external dependencies and very fast application development.
I do not mind this post at all and I welcome it. I am confident web2py can withstand the competition and, in any case, if people find something that suits them better, good for them.
There's a number of pretty large changes going on, and the very nature of those changes mean, that you'd need to start deprecating api's to keep a sane api at length. You should really read the following: http://docs.djangoproject.com/en/dev/internals/deprecation/ http://docs.djangoproject.com/en/dev/internals/release-process/#internal-release-deprecation-policy The policies surrounding django and deprecation are excellent.
&gt; This is why I'm hesitant to even learn Django Apparently you're also hesitant to read the notes themselves. New/changed APIs in 1.2 don't become mandatory until 1.4; until then they'll raise steadily-increasing deprecation warnings. Everything that's not under that umbrella was undocumented internal (and hence un-guaranteed) API or one of a couple of extreme edge cases (you can't use `and` and `or` as variable names in the template `if` construct anymore -- want to guess how many actual deployments that'll affect?).
"For most of the changes listed below, code written for Django 1.1 or older will simply raise a PendingDeprecationWarning in Django 1.2, followed by a DeprecationWarning in Django 1.3 before such code finally stops working entirely in Django 1.4." I think that's an excellent way of handling backwards compatibility in an API.
@gregturn: the tutorial I was following was from the documentation. I feel I did the due diligence in filing the issue when I came across it. I'm not even convinced you understand the bug I ran into. But whatevs, I feel I gave it a good go, and reached my conclusions on the merits of the code and the documentation that was provided. but that's just me. edit: I have no idea why I insisted on getting to the bottom of this but I did. So greg answer me this, why does your example work only if the class being wrapped is an old style class? http://docs.python.org/release/2.5.2/ref/node33.html Also, I hope you consider my few hours of chasing this down for you + pastebins and bug reports and constructive criticism worthy of your appreciation. I happen to have on occasion longed for "spring like" functionality to leverage and dealing with this implementation and now the responsiveness to bug reports and reaction to constructive criticism has proved to be very frustrating. But alas I'm going to go update the bug report I filed If I can remember my login.
Good, because it references `DATABASE_ENGINE` which was said to be deprecated *in the same document*. Apart from that, good read. Thanks.
&gt; Django 1.2 will be released on Monday, May 17, 2010. or today
I downvote you cause you flunked me back in '03
C++ class?
Excellent? It would be perfect but for Python 2.7's unfortunate (in my opinion) default silencing of DeprecationWarning,
no, i didnt go to your university, im just trying to troll again (unsuccessfully :-/)
And today isn't over yet. In fact, for me it just started.
That is rather mean-spirited.
HAH
ON UPDATE/DELETE didn't make it right? :(
Flask did not start as an April's Fool joke. Denied and Flask have nothing really in common.
I was referring to [this post](http://www.reddit.com/r/Python/comments/bplmb/flask_a_microframework_based_on_werkzeug_jinja2/c0nybbk) and did not mean any disrespect. As I said: I like flask.
I don't think Cython really represents a bootstrap like RPython -- Cython works *with* CPython, it's not a complete alternative to it. It might be amusing, maybe even performant, to write a Python interpreter in Cython, but it wouldn't be a true bootstrapping (the result couldn't run Cython, for instance).
The point of Cython (at least as I understand the guys) is not to be a replacement for CPython at all. The benefit of the more conservative solutions (like Unladen, and Cython) is that they actually work (without crashing). That's a huge advantage if you want to get things done. You don't need another Python interpreter if you already have the C-based one. In other words, Cython is *not* an alternative to turning Python into something different (although the idea of adding optional type information is something that could also benefit Unladen Swallow or PyPy), but it's a good alternative to writing your own C++ code when you need better performance.
Mighty physics inside! x=r*cos(theta) y=r*sin(theta)
I saw this guys post, and realised I had something similar.. http://www.swharden.com/blog/2010-03-05-realtime-fft-graph-of-audio-wav-file-or-microphone-input-with-python-scipy-and-wckgraph/ More importantly, there was some great feedback on the code, if anybody has any feedback I'd love it (especially around the audio/fft code, which I'm sure could be better).
Just ending here :(
That was done because end users typically do not care about nor do they know how to deal with deprecation output coming from the interpreter. With the increase of these warnings with 2.7 leading into 3.x, it made sense to do it then. If you are Joe Schmo end-user running some Python app, you don't want to see DeprecationWarning output anywhere -- you'll think it's something you have to report to the program's developers as an issue. Ideally the tests of a project should be run with the warnings enabled so that the project is better prepared, not only for the future but for what their end-users may end up seeing.
&gt; That was done because end users typically do not care about nor do they know how to deal with deprecation output coming from the interpreter. I understand why it was done, but I still disagree with it.
lil django 1.2 finaly can do multiple db's which sqlalchemy could do for ages. oh it also supports a proper IF statement in templates ;-) Im sticking to pylons and sqlalchemy :]
Maybe there should have been DeprecationWarnings about DeprecationWarning in Python 2.6.
Not exactly sure what changes were actually backwards incompatible with 1.1.1 that we didn't already know about, in all honesty...
Many years ago most university had intro programming courses in C/C++, they they introduced intro programming courses in Java, today many universities have intro programming courses in Python. I personally have taught some of these courses at DePaul and students find Python to be much easier to pick up than C/C++/C#/java.
It's as good a place as any and better than most.
Python has a nice, clean syntax. Python has a great selection of bulitin libraries for doing many tasks (database access, shell commands, numeric processing, simple 2D games, and much, much more.) There are a few really great web frameworks written on top of Python, and you'll likely end up using one of those after you get your feet wet. That said, my first response to any "what language should I learn" question is always: It depends. What do you want to get from programming? Are you interested in making web sites? Games? Commandline programs? Windows/GUI programs? Your answers to this question will be the most important determining factor to which is the best language to spend your time learning. 
I started with BASIC about 6 years ago :P (when I was 11). Really wish I would've tried Python instead. Basically - it's easy, it's powerful, and it looks great.
What used to be known as "[How to Think Like a Computer Scientist](http://www.greenteapress.com/thinkpython/thinkpython.html)" is a pretty good start to Python *and* computer science. I found it a short read and interesting. Personally, I find a lot of the administrative details of other languages disappear in Python. I also hate typing braces.
I truly feel for all the students in those non-computer oriented sciences that require at least one programming course and then they end up in a C or C++ course. (or even java for that matter) The vast majority of them should have been in some kind of scripting class.
If you plan on becoming a programmer by trade, the just start with something that captures your interest. Since python (and other interpreted languages) have an edge as far as immediate gratification and no need to understand lower level concepts to get basic things done, they're not a bad place to start. But, just pick something that looks *fun*. If you think Ruby on Rails sounds interesting, give it a whirl. Maybe you're a gamer and your favorite game supports lua gui scripting. Maybe you have an iPhone or an Android and have an idea for a really neat app. If you don't plan on being mainly a programmer, but want to learn programming because you see it as a good skill set to have in your preferred profession, then the answer is different. Mainly because different areas of focus / communities tend to aggregate around different technologies depending on their needs. As far as why you're hearing python recommended a lot, * It has a lot of libraries suitable for a wide variety of tasks, from web to hard science * It has an active community * Low barrier to entry * Very portable; multiple platforms (if written with portability in mind) * A Very clean syntax for easy readability I'm not aware of any other interpreted type language that can honestly check all those boxes. *edit* changed "scripting" to "interpreted" to try and mitigate a tangent into the deeper meaning of "compiled" vs "scripting" languages. 
I am studying biochemistry and chemical engineering, and I had to take a C course for engineering. Though I think a scripting course in Python (or Ruby or Perl or whatever) would have suited the purpose of the problems more, I'm glad it was a C course. Taught me a lot about low-level programming that I didn't know before. I suppose C might be the most useful language for an electrical engineer, since they sometimes collaborate in designing embedded systems, but as a student of chemical engineering I generally program for small simulation purposes, so scripting is the way to go (as long as the number-crunching isn't too heavy for Python).
But how much do you use it? I worked with a lot of researchers with background in either neuroscience, biomedical engineering, or non-computer engineering. Except for a few, most of them never performed a task where any C-like programming was required. Within two years into Grad school (if not before) they'd pretty much forgotten everything and all the class accomplished was instilling some deep sense of fear of "doing programming stuff". After I introduced them to Python (or even simple Bash for loops) so they could automate/batch their analysis tools, it was like a new awakening. &gt; Ohhhhhhhh, so THIS Is why programming is useful. &gt; so scripting is the way to go (as long as the number-crunching isn't too heavy for Python). May I introduce you to [Cython](http://www.cython.org/) For most of the cases where Python underperforms, Cython will get you very near native C speeds. In the fringe cases where you need every last bit, it makes wrapping your C/C++ libraries trivial.
Python is a great place to start. It's * simple enough to be easy for beginners; * powerful enough to do more advanced programming; * uses the same fundamental ideas of constructs as many other languages.
Have to agree with this post. I don't program for a living, but occasionally just need to "do some shit"...what python enables me to do, and do quickly, absolutely astounds me some times. The available libraries, clean and mostly intuitive syntax, user community support etc. have really let me belt out some really useful things in short order. I'm not claiming this is better or faster or more scalable or whatever than any other language, but for me at least, it is has been giggle-raisingly fun and arse-bitingly useful. Still astounded no-one on this thread has yet referenced http://xkcd.com/353/ btw.
Yes.
&gt; But how much do you use it? Not to be snarky but, how often does a person use 90% of the degree they earned?
Ive been writing code sice the late eighties and have probably tried more languages on more platforms then most, i would say that python is by far the best language to start coding with, its easy to read, simple to look under the hood and supports alot of nifty tricks and modern concepts while still being elegant. edit: writing this made me realize ive programmed for more then 2/3s of my life, wonder if i still got the tapes (yes tapes, as in music casettes if you remember those, we actually used them for storage a while back) with my first software.
This is true. College is mostly about proving you are capable of learning than learning what you practically will use (imho). And I don't take it as snarky. But, I guess all I'm saying is that all other things being equal the odds of using a scripting oriented language in the sciences is much greater than needing a low level language. And when non-CS students land in a C or C++ course it usually just serves as a deterrent. :P
Python as a language is not compiled nor interpreted, there exist diffrent implementations of the language that are treated diffrently, the most one beeing CPython which indeed are interpreted. if you want to compile your python there is PyPy and other implementations that are going that way. And for those that are new to the world of python, we also have Jython, which is Python on the JavaVM and IronPyton, which runs on the .NET VM whatever its called. Google are doing their own implementation called Unladen Swallow. 
Yeah, I think scripting is a better way to go. Personally, I like the idea of using Javascript as an introduction, because the students won't have to download or configure anything to learn. But Python is a totally legit language to use, too. Also: &gt; After I introduced them to Python (or even simple Bash for loops) so they could automate/batch their analysis tools, it was like a new awakening. I think this is the key to introducing someone to computer science. Start out having them figure out how they would solve the problem by hand, with a big ol' sheet of paper and a bunch of numbers, calculating sums and averages and all that. Then show them how to wrap that up in a simple script. It's important that people know how to do the work by hand before they try to do the work in code.
&gt; It's important that people know how to do the work by hand before they try to do the work in code. This is definitely true. But man, when the only non-script way to run an analysis after it is set up is by clicking "go", "go", "go" over and over. Now that's where you thank the gods for something like scripting. At least solving problems (even by hand) is pretty interesting. 
You're bang-on, except maybe &gt;Maybe you have **an iPhone** or an Android and have an idea for a really neat app. was a bit off. I'm not sure I'd want to learn to program on a platform that requires $99 a year...
Yes, Python is the best first language to learn. I've written a book (completely free under Creative Commons) called "Invent Your Own Computer Games with Python" at http://inventwithpython.com Each chapter has the source code for a small, complete game (like Tic Tac Toe, Hangman, Othello, etc.) and explains the code line by line. So the book teaches programming concepts from real examples, instead of teaching it like a textbook. The later chapters go into the Pygame library for making games with graphics and sound. Java and C++ do object-oriented programming, which you don't need to know to just learn the basics. JavaScript and PHP are really just for the web. Perl is a mess. Ruby is alright from what I hear, but there is more documentation out there for Python. I'm strongly in favor of learning programming with Python.
And Unladen Swallow is about to become Python 3.
That xkcd comic is just a day in the life of a Pythonista.