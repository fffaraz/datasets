 ((len(a)-1-i, x) for i, x in enumerate(reversed(a)))
what?, no svn download?
It sounds like you were not an experienced programmer at the time. I believe Dive Into Python is targeted at those that already know Python.
From what I had been told beforehand, Dive Into Python was for people who were experienced in programming in general, so it skipped past explaining concepts. I know how to program in C#, so I figured I was in that group. When I was reading it, it didn't really go into how things worked, it just said "If you do this, this will happen" and then continued on. I think the main issue I had was that none of the examples the book provided would ever run properly for me, so without the additional explanation, I was just lost.
In /etc/apache2/sites-enabled/your-site add the line: AddHandler cgi-script cgi py in the top of your script add a #!/usr/bin/env python and make the script executable. You should now be able to run it like any CGI. Or like the other guys say, use mod_python - I don't because I like to have different versions of Python installed concurrently. *EDIT cos I forgot Reddit uses markdown for formatting
I recommend writing a .CGI from scratch using as little of the built in libraries as possible (go with me here)... Start with a script which takes a URL and serves up a page. To do this you will have to learn about how Python handles the environment, URL splitting, querystring parsing, HTTP headers etc. Some of this you may already know. Now move on to making a templating engine, with dynamic content maybe pulled back from a file. This should cover character/string encoding, Unicode, file access etc. After this, hook it up to some 3rd party online web APIs (Flickr/Facebook) so you learn how the http libraries work. Once you understand these bits, delete it, import the standard libraries and enjoy. You'll have the benefit of not only knowing how they all work under the hood (since you can read the code) but _why_ they are written like that. Have fun. (oh and the traceback module is your friend for debugging!)
I'm sorry about this - but can someone please explain why this is so awesome? I have heard so much about PyPy and understand that it is a boot strapping pure python implementation of python (I think). This sounds awesome. I just would like some more info - is it faster? more portable? makes django run on my toaster?
haha I got the sofa
what?, no chm download?
It's more about completeness than anything else. Django's a rather large, actively maintained Python code base originally written without much concern about portability beyond CPython. Thanks to hard work from both Django and Jython developers, it has turned into an important test for Python implementations; if you can run Django, you have really good support for modern real-life Python applications. 
&gt; if you can run Django, you have really good support for modern real-life Python applications Only that Django is a Python 2.3 application. 
From the wiki: "Reloading doesn't seem to be working properly at the moment, so you need to disable it. " What is the definition of "runs"?
oh awesome. that makes a lot of sense. thanks :) What are some interesting potential uses for PyPy?
I suspect they mean code reloading (when running the built-in development server), not page reloading.
Playing around with GAE might be a nice little introduction, too.
this is an honest question: Why use elexir when SQLAlchemy has its own declarative layer that's kinda easy to use?
Some relevant reading: http://codespeak.net/pypy/dist/pypy/doc/architecture.html http://codespeak.net/pypy/dist/pypy/doc/getting-started.html
see also: http://mayavi.sourceforge.net/docs/guide/ch04.html Using MayaVi from Python
damn I don't understand...
Translating to the C backend looks pretty. ASCII fractals, anyone?
Also see: * &lt;[http://www.voidspace.org.uk/python/weblog/arch\_d7\_2008\_03\_22.shtml#e954](http://www.voidspace.org.uk/python/weblog/arch_d7_2008_03_22.shtml#e954)&gt; * &lt;[http://egofile.com/blog/python/pipes.html](http://egofile.com/blog/python/pipes.html)&gt; * &lt;[http://code.activestate.com/recipes/276960/](http://code.activestate.com/recipes/276960/)&gt; * &lt;[http://wordaligned.org/articles/takewhile-drops-one](http://wordaligned.org/articles/takewhile-drops-one)&gt; I’m not convinced that this is actually in general quicker/more useful/more readable than just using standard python syntax for generator expressions, combined with various itertools/functools type functions, and whatever custom generators/classes are needed for the task at hand. But maybe for real shell experts it’s more familiar.
Not convinced either. But one thing Python generally is missing is "free form" DSL creation (for languages where certain syntax is optional). I don't consider this a real disadvantage, but it is nice to see a few attempts at it. 
via: http://kandle.wordpress.com/2008/08/20/configuring-cracklib-python-crack-and-a-better-system-cracklib_dict-in-red-hat-fedora-core-9/
http://kandle.wordpress.com/2008/08/20/configuring-cracklib-python-crack-and-a-better-system-cracklib_dict-in-red-hat-fedora-core-9/
this is out of date, the article refers to oldforms functionality which is no longer part of Django
Errrrr... it's static HTML and it's almost an exact copy of the content at http://code.google.com/appengine/ i.e. it's not all that exciting.
Wow, this is disappointing to learn. I had no idea that (C)Python didn't support true concurrency. Guido's complaints make sense, but it's hard to imagine that in 2008, a modern language environment doesn't offer support for multi-core programs. The talk of a single lock in the Python interpreter (the "GIL") is reminiscent of the Big Kernel Lock in the Linux kernel, that resulted in people spending lots of time working to remove it. It seems like CPU cores aren't going to get much faster, we're just going to keep getting more of them now. Nehalem promises 8 cores, right? If performance is at all a concern for your software, this is the age of concurrency. If I had any free time at all, I'd be thinking about stepping up to Guido's challenge to get rid of the GIL. Of course, the prospect of dealing with a bunch of non-thread-safe modules with global data is intimidating. Still, this seems like something that *must* change soon.
+1 for generator expressions
I got bored and improved the code a bit: #!/usr/bin/env python import sys # used for sys.exit() import urllib # This reads in a list of urls &amp; emails, comma separated. # It checks each url for a specific phrase in its HTML # and writes the url and email to a log file. # The status print lines are for fun, to watch it scroll. def write_status(filename, blog, email): msg = "%s,%s\n" % (blog, email) # string formatting \o/ outfile = open(filename, 'a') outfile.write(msg) outfile.close() def grab_page(blog, email): try: # Try to put as little code in try: blocks # (so you don't accidently catch the wrong error) web_sock = urllib.urlopen(blog) except (urllib2.HTTPError, urllib2.URLError): # check for 404 or other not found error print "Site Down:", blog # print "bla", "aah" outputs "bla aah\n" write_status("gotsitedown.txt", blog, email) else: # called if no exception is raised src = web_sock.read() # readline() returns a list (one index per line), and ''.join() # combines that list into a string. .read() returns a string return src def main(): try: lines = open("biglist.txt").readlines() # 'r' mode is default except IOError: print "Error: Couldn't find file!" sys.exit(1) for cur_line in lines: line = cur_line.strip() try: blog, email = line.split(",") except ValueError: continue src = grab_page(blog, email) if 'NEW BIT OF CODE' in src: print "New!:", blog write_status("gotnewcode.txt", blog, email) elif 'OLD BIT OF CODE' in src: print "Mixed up codes:", blog write_status("gotbothcodes.txt", blog, email) elif 'OLD BIT OF CODE' in src: print "Old code:", blog write_status("gotoldcode.txt", blog, email) else: print "No code here:", blog write_status("gotnocode.txt", blog, email) if __name__ == '__main__': main() # runs main() function if the script is called
&gt; However, before doing so, I caution you that a Python thread is not the same thing as an OS thread. ... &gt; Even though this doesn’t create a true OS thread, it keeps the GUI from freezing... These statements are wrong -- each Python thread _is_ backed by an OS thread. Properly designed C extensions will release the GIL when they don't need it, allowing for concurrent execution. I believe SciPy/NumPy have been designed with this in mind.
WHAT? before 2.8.8.0 wxpy do not even support ActiveX?
For me the attraction of wxpython is that it gives great results and *is* multiplatform.
I had no idea Python used backticks until now. Cool, but I can see why that's not pythonic too.
that would be a silly question. 
A frontend to LaTeX? For shame.
Next generation? IBM is bit slow. 
I just finished listening to FLOSS Weekly where they discussed CouchDB (http://www.twit.tv/floss36) I sounds really interesting and similar to Google's BigTable.
...with possibly the greatest name ever chosen for such a package. Mingus Amungus FTW! 
The website is incredibly slow at the moment too. When it loads, you get a nice article, though.
wow, amazinga mount of typos andm istakes. i will subscrib eimmediately!
&gt; Exceptions exist for exceptional situations: unanticipated events that are not a part of normal execution. I disagree. Python uses exception to signal the end of an iterator. Exceptions are just for different situations, not unanticipated ones. 
He quotes the "Python in a Nutshell" book in the article, and in the introduction sentence for the "Exceptions" chapter it reads: &gt; Python also uses exceptions to indicate some special situations that are not errors, and are not even abnormal. For example, as covered in "Iterators" on page 65, an iterator's next method raises the exception StopIteration when the iterator has no more items. This is not an error, and it is not even an anomaly since most iterators run out of items eventually.
But iterators are usually intended to be used in 'for' loops, that hide this detail. You're not supposed to explicitly pull more items from an iterator than it can provide. Besides, I'm not sure this was a good design decision on Python's side. This is using exceptions as flow-control, or kinda-'goto's, which isn't recommended.
The iterator protocol is suitable for a wide range of applications, not simply in for loops. For example, co-routines. PEP 342 (http://www.python.org/dev/peps/pep-0342/) shows many examples of exceptions used for code clarity. It's not so much flow control, but more 'signalling' within a EAPF context. 
&gt; Besides, I'm not sure this was a good design decision on Python's side. What could they have done instead that would have made more sense? If anything, I feel like they didn't go far enough. `continue` and `break` should be `raise continue` and `raise break` in my opinion.
Good job Jython guys. Jython 3.0 next pls :-)
Couldn't a special value be returned ? continue and break control loop flow. Do you suggest wrapping each loop with try/except ?
IMHO such usage of exceptions is sub-optimal. But sometimes, if that's the only choice for maintainable code, then it's the way to go. I'm against absolutes, like saying **never** use some construct. Never is a relative term in such aspects, and should be interpreted as "try not to, but very rarely you have to". Same as with gotos, for which some people are able to find truly good examples.
Sure; knowing when to break the rules and how, comes with experience I guess.
The problem with returning a special value is that then you can't do something sensible like this: it = iter(my_favorite_exceptions) try: x = it.next() #Python 2.6+ version is x = next(it) do_something(x) except StopIteration: do_something_else() Instead, you would have to do this: it = iter(my_favorite_exceptions) x = it.next() if x is not StopIteration: do_something(x) else: do_something_else() As a side effect, it is no longer possible for `StopIteration` to be a member of `my_favorite_exceptions`. Anyway, there's nothing magical about the words "try" and "except". The `for` operator in Python automatically catches `StopIterator` exceptions encountered during the set up phase for the loop. There's no reason that it and `while` couldn't also catch other special exceptions that were the equivalents of `break` and `continue`. The only reason that people think that "exceptions are exceptional" is that in other languages they're slower than doing a test first. In Python, however, the speed difference is much less significant.
&gt; I’ve been writing Python professionally for about a month ... and then &gt; I am making some “mistakes” as I am in the learning process. Maybe you should learn Python before you started taking peoples money to write it for them?
Maybe you should learn that making money is not about being honest.
I have no problem making money and being honest.
I didn't know Python when I was hired to do Python work. I didn't know PHP when I was hired as to do PHP work. I didn't lie about my ignorance. I made mistakes and my co workers were understanding of those mistakes.
If people for who you worked for knowed that, then that would be another situation.
You seem to be assuming the blogger is misrepresenting himself.
Yes.
Thanks for this link! I'm so frustrated with the idiots on this sub-reddit that continue to mod down useful stuff. I've almost given up.
The post makes a good point. I think that Python is a good transistional language from C++ to a functional language like Haskell. C++ coders think a certain way, and switching to functional programming all at once is hard. Python encourages coders to try limited fp (list comprehensions) and lazy evaluation (yield). Eventually, they'll look into partial function evaluation and closures. But they're not forced to forget objects or their generally imperative style. Python is a very educational language, and still very useful for small projects.
This is not wikipedia. If they know that he never used Python before they would give him time to learn at least the basics. This guy has problems with for loops and is working on production code.
Currently the templates folder is missing, which contains some required tpl files. Seems like the creator lacks the testing of his own install scripts.
He is writing perfectly valid for loops. Python just gives you some nice syntactic sugar do things differently if you want to. His big "mistake" was not coming to terms with the having a huge standard library at hand to do what he needed. You aren't going to learn unless you have a real goal writing a real application. If you have a new untrustworthy programmer you do code reviews until he gets the hang of things. Someone pointed out that he was reinventing urlparse, so there is probably someone looking over his shoulder.
&gt; He is writing perfectly valid for loops. We don't see the code. &gt; You aren't going to learn unless you have a real goal writing a real application. Sure, but how to use syntax and basic construct in any languge is best learned from tutorial/manual on toy examples, not on code you will ship to your clients. &gt; If you have a new untrustworthy programmer you do code reviews until he gets the hang of things. This is about a for loop, I don't think it gets more basic than that. Are you just contradicting me or something?
&gt; We don't see the code. We didn't need to see the code. If you were a python programmer you would know what he was talking about immediately. He said the problem was his code was more verbose than it needed to be. I think his real mistake in this case is thinking that he was doing something wrong and *needed* to use list comprehensions. It's mostly a question of style. List comprehensions can become hideous and unwieldy at times. I've been using python for years and I still waver a little when choosing how to implement a simple set of loops. &gt; This is about a for loop, I don't think it gets more basic than that. It's not that basic, and he's not trying to master the for loop. He used to be a C++ programmer. &gt; Are you just contradicting me or something? I'm just trying to present the facts and defend a complete stranger's honor here. 
Certainly, cross-platform support is one of the great features of WxPython. What makes it truly great IMO is that it also allows you to take advantage of OS-specific features if you choose to use them. That said, it would be fantastic to have a cross-platform Mozilla browser component for WxPython. There is [wxMozilla](http://wxmozilla.sourceforge.net/), but it appears to be a dead project. Until that happens, IEHtmlWindow is a good choice if you're doing Windows-only development anyway. For cross-platform development there's the HtmlWindow control, which sadly lacks many cool features like JavaScript and access to the DOM.
&gt; We didn't need to see the code. Now your assuming. I did't know for loops are not *that* basic, ok.
AFAIK everything in Python is a first-class object. The article seems to imply otherwise; I wonder why.
&gt; In Python pretty much everything is first-class. —The article
via: http://www.johnstowers.co.nz/blog/index.php/2008/08/23/blog-as-noticeboard/
see also: http://blog.cerris.com/2008/08/21/fixtures-with-nose/
Wow, this is very clever. I had to read through it a couple times before I realized how it was working. He should have included an example though. For example: @memoize def fib(n): if n == 0: return 0 if n == 1: return 1 return fib(n-1) + fib(n-2) Normally calculating fibonacci numbers this way is horrendous because of the explosive number of function calls for even modest values of n. Using this memoization decorator, the exponential growth in number of function calls will not happen. Kudos to this guy on his decorator.
http://code.reddit.com/browser/r2/r2/lib/workqueue.py
There is a bug on the 4th line: &gt;&gt;&gt; print list.sort.__doc__ L.sort(cmp=None, key=None, reverse=False) -- stable sort *IN PLACE*; cmp(x, y) -&gt; -1, 0, 1 list.sort sorts in place, so the second item in your haxh tuple will always be None. Fix it by changing that line to: haxh = tuple([args,sorted(kwargs.iteritems())]) sorted will return an iterator (which when put in to the tuple() is changed in to a list) &gt;&gt;&gt; args = (1,2,3,) &gt;&gt;&gt; kwargs={'a':5,'b':6,'aa':9} &gt;&gt;&gt; tuple([args,sorted(kwargs.iteritems())]) ((1, 2, 3), [('a', 5), ('aa', 9), ('b', 6)]) *edited for code markup
I'd also offer this: on line 6, instead of: if fctn.__name__ not in memory: memory[fctn.__name__] = {} this_memory = memory[fctn.__name__] do this: this_memory = memory.setdefault(fctn.__name__, {}) or use the newer `defaultdict` class to instantiate `memory` on line 2: from collections import defaultdict memory = defaultdict(dict) 
Isn't the use of nested dicts superfluous? There will be an instance of the dict called memory each time the decorator is called, so there's no need to store a second using the function name as a key. Or am I missing something?
[http://news.ycombinator.com/item?id=283877](http://news.ycombinator.com/item?id=283877) &lt;-- What he said. Ruby has good solutions for a lot of Python's problems (e.g. things aren't just symbol table hacks). And Python has good solutions for Ruby's problems (e.g modules/namespaces). If only there were some language which was a mixture of both. Oh wait, [there is](http://groovy.codehaus.org/). (If you can resist the downvote button just have a look at the examples, you'll see what I mean.)
I think you're right. The only substantial improvement on this that comes to mind is if the structure were some kind of priority queue that would trim rarely used keys off the back if the cache got too big.
Nope, You're not missing anything. The nested dictionaries are unnecessary.
pwnd by James Bennett 
As another improvement, I would change return memo to memo.__name__ = fctn.__name__ memo.__doc__ = fctn.__doc__ return memo
a quick google search gives a recipe which does exactly that: http://code.activestate.com/recipes/496879/
See also the `update_wrapper` method from the `functools` module.
&gt; Initial code. Nothing is functional at this point. Nothing worth an announcement at this point.
I looked at Ruby a bit, but ended up selecting Python for our corporate development. Mostly because of the libraries and applications available for it (notably DrProject, OpenERP, Mercurial). Also for how the language evolution is handled. You may not agree with Guido in all cases, but he's proven to be a very steady hand at the wheel. They decided that they needed a backwards-incompatible language evolution (with v3.0), and they've been working to make it as painless as possible. Much better than the disruptive changes seen with several other HLLs.
very, very nice. I did not know about that module. I will definately be using the functools.wraps decorator in my own code.
Multiline lambdas would be nice in python (which are not possible.) But that ends up being only irksome by just declaring a named function in your current scope. It blows, but it's no killer. just takes a bit more work moving what was a one line lambda into a named function. I love looking at other people's code in python. Ruby on the other hand is less pleasant. (not nearly as unpleasant as php or java.)
Rabid fans that attack PHP constantly without provocation?
I don't myself get the craving for multiline lambdas. The code difference between a `lambda x, y, z: foo` is very small, here's the equivalent: def bar(x, y, z): return foo that somewhat destroys the **OMG I MUST WRITE NEEDLESSLY MANY FUNCTION DEFINITIONS**, which in fact are trivially longer than doing the same inline. In a way that is actually feasible.
Interesting solution
&gt; Multiline lambdas would be nice in python I disagree. The whole point of a lambda is to use the function as an argument to something. So you would end up writing: x = do_something(1, True, lambda x, y: z = 0 for item in y: if cond(item): z += foo(x, item) z = z/3 return z) There's just no way to make that play nice with Python's indenting syntax. And anyway, it's not like it's hard to think up names for functions. Just call it "inner" or something.
One of the replies there says: &gt; As a very simplistic example, C and Python have two different ways to iterate. You could write a loop in Python in a C-like way, but there are much better ways to do it (list comprehensions). Are list comprehensions really the correct way to implement iterators? I would say if your goal is to create a new list based on another list, then a list comprehension is the way to go. But suppose you had a visitor pattern and your list was all the classes to visit. You want to call a method on each class in the list. You could certainly accomplish this with a list comprehension, but it doesn't seem like the "right" way.
Having tried both languages, I feel that it's simply a matter of personal preference. I ended up picking Ruby, but that doesn't mean I don't long for some aspects of Python. The languages are very similar, so people immediately look for differences to find which one is "better." I'm not convinced it really matters anymore (providing your task doesn't *need* something that one language has that the other doesn't). Just try them both and see what you like! They're both splendid languages.
Great news, but a PDF warning would have been nice.
Generic methods feel much more like the right way to replace the visitor pattern. RuleDispatch etc.
The advantage is, that you can define just about functions everywhere so you do not need to pollute namespaces with 2-line functions that you need once somewhere in the code.
&gt; I won't be digging into language reference to find whether or not it is formally true, but in practice it is just like that. —The article
Meh, I wonder why people often explain how Python's INDENT/DEDENT-based syntax is equivalent (and nicer to) braces-based syntax, yet they don't see how it's also equivalent in this case. Given a function f of a, b, c, where b can be a function: f(1, lambda x: statement... #INDENT token before this line statement... statement... #DEDENT token after this line , 3) Adding support for that to Python would be simple and so much better than the typical def _() a dozen lines above the actual call. If Python's focus is readability, then I wonder why Guido hasn't realized this is much better, nicer and simpler than def _ in a separate statement. In fact, my main gripe with Python is that it has statements - expressions' poor cousin, that are more limited than expressions *just for the hell of it*, and the Python devs seem obsessed to give you as much functional programming power and expressivity as a game demo, that goes "REGISTER NOW" whenever you get near the good stuff. Examples: You have lambdas, but they are limited to an expression, and statements are crappier: you cannot use them in lambda. Functions are first-class values, but thus cannot define all of them anonymously because sometimes you require obnoxious statements in them. You have multiple assignment, but assignment is one of these obnoxious statements, unlike in C-like languages. You have lexical scoping, but you cannot rebind outer scope variables without defining them as nonlocal (in Py3K, currently not even that). You have if...else, but it works in a way it can't be sanely nested (Guido's cunning response to a functional if, I guess). Crap, I need a statement-less Python. Everything else in Python is great, including what I consider my favourite object model.
Besides the fact that they make the code unreadable (wasn't Python trying to focus on readability?), because they are defined before they are used, somewhere else (and before you can see why they make sense!), with a bogus name.
My jQuery code is often using anonymous functions which have their own anonymous functions and these have their anynymous functions. But at some point it sucks to have functions that ressemble matryoshka dolls. The Python zen also tells that "flat is better than nested", and this certainly holds some truth (see python-openid on how to make a library API suck).
http://code.reddit.com/browser/r2/r2/lib/memoize.py
Surely numpy has had changes in the past three years that would render parts of the book obsolete?
I always hate the one I'm using. :(
why a PDF warning? not trying to be a dick, just wondering
&gt; Results 1 - 10 of about 2,640 for "php sucks" python -ruby. (0.14 seconds) &gt; Results 1 - 10 of about 1,430 for "php sucks" ruby -python. (0.31 seconds)
Some people still use dialup. Some of those still use Adobe Acrobat. Some of *those* have slow computers. Acrobat will usually not ask before loading up in the browser window. Once it starts loading, it's hard to stop. The computer comes to a halt for a few seconds, and the impatient user behind the keyboard realized he's no longer the master of the machine. It's the pain of that sad realization that we all want to prevent.
This is the single thing from the Zen of Python I disagree with. Flat is ugly and unexpressive, it cannot be combined or reused or, well, nested, and it doesn't exhibit a recursive nature. It's not that nestable elements are better than non-nestable elements; it's that non-nestable elements are just not serious to me. I'm surprised a set of guidelines that got as bright as to realize that simple &gt; complex &gt; complicated or that explicit is better than implicit included such a big mistake as to think that purposefully, artificially limited features are better than freely combinable features. Like break in loops or any other programming tool, nestable doesn't mean "nest 500 levels deep this expression". It means you *can* do that. And like every tool, it has its uses and it can be misused. But artificially restricting the language with non-nestable elements because nestable elements can be overused is asinine; if we follow this policy we'll end up writing COBOL. Statements are the single thing preventing me to feel Python as beautiful and expressive as Lisp.
https://addons.mozilla.org/de/firefox/addon/3199
It's what I want to know too, any body has some advices?
i stopped using adobe simply because it would kill firefox for like 10 seconds just to load a damn PDF. and then sometimes it would just stop loading the PDF and freeze everything so i would have to restart firefox. now i use foxit...soooo much better ;)
maybe the first Frequently-asked questions of http://www.tramy.us/FAQ.html : "Why are you charging for something that used to be free?" //edit: thanks for the correction of broken-url 
Why do you have to define them somewhere else? You /can/ define them just before the expression that uses it, usually in the function namespace too – having zero effect on the surroundings. Bogus names are just bad coding, worse than no name at all. I'd rather have a descriptive name, though.
Expressiveness leads to many ways to do it. Many ways to do it leads to Perl. I'm under the impression your gripe with Python is that it is not Perl. Besides, most things can be nested if you really want that. Give some examples of where that doesn't apply. 
[un-broken link](http://www.tramy.us/FAQ.html)
Agreed. They are both very similar, the only thing I like about Ruby over Python is the cleanliness. And maybe I'm a bit ignorant of the depths of the languages, and haven't used Python as much as Ruby, but I don't see much difference. If you disagree, feel free to educate me, but don't be a dick about it.
That kung fu is too deep for me.
Wow, thanks - this is a nice addon :-)
You can nest stuff, you just can't define normal anonymous functions, but nothing prevents you to make a hell of nested functions, containing nested functions, containing classes, which contain other classes and their metaclasses.
Much better organized then the previous docs. The "And More" section though looks kind of odd, very jumbled, but it seems even the actual doc pages have had a well done touchup
Yet you have statements, which are, as I said, expressions' poor cousin, because they behave like any special construct (such as if..else), but they were arbitrarily decided not to be expressions, just for the hell of it. Think of the expressivity you're missing because of this. In fact, the whole if..else thing from Python 2.5 would have been unnecessary if we had a real if expression. I'm still wondering why aren't we allowed to do simply: a = if e1: e2; else: e3 or a = if e1: expressions... else: expressions... giving a the value of the last evaluated expression. 
&gt; Expressiveness leads to many ways to do it. Many ways to do it leads to Perl. I'm under the impression your gripe with Python is that it is not Perl. Expressiveness leads to solving every problem in the most elegant way. Elegance and Perl are two very different realms. No, I don't miss Perl. I miss Lisp.
&gt; Why do you have to define them somewhere else? You /can/ define them just before the expression that uses it That's "somewhere else". On top of that, it's *before* it can be understood why I need that. I don't want to do: def StuffIWantToPassTheNextFunction(): magic spells here ... 10 lines below... f(1, 2, StuffIWantToPassTheNextFunction)
That enlightens me a little bit. Apart from GvR plain not liking lambdas and syntax not considering multiline lambdas at all, another argument for no multiline lambdas was readability: defining blocks amidst a function call was considered worse than detaching the block to that dreaded somewhere else. I believe it is indeed better that way, as the function calls themselves give away their intention better when it's tersely put. I don't – in most cases – even need to read the actual code doing the magic in the function; it's name should be enough.
Not sure if this is some problem on my side, but I cannot open this link.
I think the 'And more' section seems good, but I agree it seems less related. Maybe a 'most read' block would be better?
I like named functions, but I hate how I have to define them before their use. When reading code I prefer to look at higher levels of abstraction first and then dig down to lower levels of abstraction if necessary. Something like haskell's where clause would be perfect.
via: http://mercurycomplex.com/blog/2008/8/17/django-tinymce/
Recently, I've been experimenting with a similar setup. You can do do your application logic in Python and your UI in Flex, all hosted by Google Apps. If you use Flex Builder on Linux, you can even work in a Microsoft free environment (I guess some developers will appreciate this). The communication between my Flex binary and the Google App backend works very nice using simple XML over HTTP. The way Google Apps works, makes it very easy to process requests. I see the author of the article uses AMF. I haven't looked into this yet, and I'm not sure yet what advantages it offers, but I'm planning to look into that later. Thanks to the author for sharing his app, I'm sure I can learn from it!
I guess this is cool but for Admin you can use the Media class to include JS and therefore, TinyMCE and apply it to textareas. A similar thing can be done for non-Admin stuff. Can someone explain what is the benefit of this app? Not trying to be rude, just curious :)
Thanks for your support. AMF is faster than XML in this scenario. Your service interface can support both protocols if you need.
Defining blocks in the middle of a function call doesn't look any worse than defining loops in the middle of other loops. It's just a matter of being accustomed to it or not. As for giving names: sometimes giving a name is counter-effective. Not all values need to have a name; they don't when they are useful only once, and giving them a name would otherwise pollute the namespace and make it harder to read I'm sure you don't give a name to every value. Do you see anything wrong with: i = a * b + c ? Would you rather have to do: product = a * b i = product + c ? I hope you'll agree that the second version is only sillier and harder to read. And if you do, then I wonder why you wouldn't think the same of other kind of values, such as applicable values (in other words, values that support __call__ or (); in other words, functions).
AMF is a binary and compressed protocol, so you can expect a lower latency. 
&gt; Adding support for that to Python would be simple and so much better than the typical def _() a dozen lines above the actual call Why does it have to be a dozen lines above? Why not immediately above. Also, anyone who creates a function with a name "_" should be sent to python reeducation camp ;-). Seriosly, give your function a name and your readers will thank you. Btw, multiline lambdas essentially save you a single line of code (compared to defining a name function) so I don't think it's that much of a deal. Also, limiting lambdas to a single expression allows you to avoid return stmt.
looks cool. 
I thought python had some sort of map function?
The one about developing games with python isn't working. At least for me.
There is a map function, but the "pythonic" way to do things is to use list comprehensions (or so i was told).
I'd be more impressed if it ran on Python and App Engine figuratively.
Why is living in a democracy more fun than living in a dictatorship?
[stop posting dupes dammit](http://www.reddit.com/r/programming/comments/6tvde/why_is_python_more_fun_than_java/)
Have you lived under dictatorship?
Python a democracy? Then why does this Guido guy call himself a benevolent dictator?
For the first 18 years of my life, yes.
Who claimed python was a democracy? Certainly not me.
So you spent the first 18 years of your life unable to vote? Join the club.
&gt;For me, Java was a productivity enhancer, over C and C++ I'm more productive in C++ or Perl than Java or Python.
stop posting dupes dammit
wasn't the Python community itself that came up with the term BDFL (Benevolent Dictator For Life) for Guido?
That was 26 days ago, and I didn't see it then. So I'm happy with the new post.
Are tar, gzip, and bzip2 the only tools implemented?
I don't think he realized it. It's a different url, so reddit wouldn't have caught it, and the other article is 26 days old so he probably never saw it.
That's right, I mean it's not like TFA mentions having been posted on reddit does it? &gt; Also, someone also posted the article to reddit.com's Programming page, where it generated a small amount of commentary. Feel free to jump in. Ah well, it does, what's the next excuse?
Not the community as a whole, it was in a meeting in the early days of Python.
PJE's (dated but still good) [Python is not Java](http://dirtsimple.org/2004/12/python-is-not-java.html) is also a good read on the subject.
see also: http://www.gossamer-threads.com/lists/python/dev/673833
No you're not. They're downvoting you, so you can't be. They know better than you which languages you are more productive in. They know all...
I love object oriented languages with garbage collection, but while java is slow within reason, python seems inexcusably slow. I'm sticking with Java for laptop/desktop programs. When speed is a consideration, a cluster is the only way to go. But fuck the fast languages. As soon as the code passes 20,000 lines, memory leaks suddenly rear their ugly head. 
 &gt;&gt;&gt; a = 1 if False else 2 &gt;&gt;&gt; a 2
Because that's the only difference? Please.
Because Java is for masochists. Python is for sadists. We all like to switch now and again. Why so serious?
We know him better than he knows himself.
See http://www.artima.com/weblogs/viewpost.jsp?thread=235725
Precisely. In any BDSM relationship, I enjoy being the one with the power. Python: the computer IS MY BITCH.
I had to do java at work, did python for fun then I found groovy. Has all of the dynamic, meta programming goodness and and works smoother on the jvm. Edit: I know it sounds like a sales pitch, I'm just a python fan that found a way to incorporate some of this fun into my everyday work.
I don't understand why I'm being downvoted. I simply stated what's true for me--I'm not trying to impose my languages of choice on anyone else.
the real treasure is the last.fm Fingerprint (command line) client... the python script is quite trivial...
via: http://groups.google.com/group/django-users/browse_thread/thread/f32fdb228538fbaf
I don't understand this: &gt;"With Python, it's easier: Simply create a factory method right in your module. To make things even simpler, you can use a hash table to look up the implementing classes. (You can do that with Java, too, but you end up having to use the Reflection API, which is clumsier than in Python." What is the problem of doing like this in Java? Map&lt;String,Class&lt;? extends RPC&gt;&gt; RPC_CLASSES = new HashMap&lt;String,Class&lt;? extends RPC&gt;&gt;(); RPC_CLASSES.put("xmlrpc", XMLRPC.class); RPC_CLASSES.put("jsonrpc", JSONRPC.class); // ... public static RPC getRPC(String identifier) throws InstantiationException, IllegalAccessException { return RPC_CLASSES.get(identifier).newInstance(); } Or perhaps even this: public static RPC getRPC(String identifier) throws InstantiationException, IllegalAccessException, ClassNotFoundException { return (RPC)(Class.forName("mypackage" + identifier.toUpperCase()).newInstance(); } Is it the exceptions?
&gt; "Python doesn't have true closures, in the Ruby or LISP sense of the term" Why is nested functions and lambdas in Python not real closures? 
Internet isn't easily available in our place. Does anyone know where I can obtain an easily downloadable version of the Django book?
&gt; Further, while Java allows strings to be concatenated via the "+" operator, that usage is discouraged for building up strings, since it can be inefficient. &gt; message = "I don't recognize the command \"" + s + "\". Sorry." There is no problem of using + for string concatenation if you only concatenate a few pieces. But you should avoid using + or += on strings in a loop. I think this is the same in both Java and Python. 
Yeah, line-noise ftw. Let's expand @ into the current class and % into the current function.
I don't see what is so wrong with "self.blah".. Yes, it's slightly more verbose than $blah, but I thought the whole idea behind python is to be a bit more verbose than `$#!=&gt;$#(1..2)`-like languages.. My biggest problem with self is having to do `def __init__(self, actual, args):` on every single function, every single time, which does seem slightly redundant - I can't think of a time I've had a class's function not start with `def(self,`.. And even that's pretty trivial.
Yes, it is true in Python also. Instead of s = "" for x in sequence: s += x one should do s = "".join(sequence) and not just because it is shorter, `str.join` is very efficient.
&gt; "With Python, it's easier: Simply create a factory method right in your module. He means you don't have to create a seperate `RPCFactory` *class* just for the static factory method. As for the other bit, I guess he considers `x.class.newInstance()` more "clumsy" than `x()`. 
The **real** thing I hate about 'self' is that it's required as the first parameter of every class method. For example, the following code that forgets to use self as the first parameter of printInfo: class MyClass(object): def printInfo(s): print s def main(): m = MyClass() m.printInfo('Hello') When running main, you get the following traceback from Python: Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "hello.py", line 7, in main m.printString('Hello') TypeError: printString() takes exactly 1 argument (2 given) Except I **am** giving one argument! What second one is it talking about? Oh yes, the interpreter is expecting 'self'. Totally confusing and brain-dead requirement. Why does this need to be the first parameter of every class method? 
About time this was properly addressed!
Voted up for "mysqlgame is probably not displaying properly in IE. We suggest Firefox or another standards-compliant browser. We're not trying to be jerks about it, it's just there's only so much time in the day to spend trying to defeat Microsoft, and we gave up. "
This isn't really so clever. The main reason behind keeping explicit self is that it's regular. Pointing out ways you can add special casing to get rid of it is exactly the opposite of what is wanted. 
First attempt at a Python wrapper. Still needs a lot of work, but would appreciate any help and advice. Cheers, JingleMan
what I really want to know, is how to make this calls from gwt, and make gae take them
Usually when you're iterating over something, you want to get the results back. If not, go ahead and just use a for loop. The problem is when somebody writes unpythonic code like this: results = [] for item in (1, 2, 3): results.append (str (item) * 2) Or, even worse, with indexing and `enumerate()`
Neat, except, I can't help but wonder why not generate a QR code locally? Isn't there a library for that?
got http://blog.haydon.id.au/2008/08/notes-on-practical-django-projects.html this morning. It looks useful to Practical Django Projects readrs
will this work with django 1.0 ?
So, uhm, where's the failure? This is normal floating point number behaviour.
&gt; In fact, the whole if..else thing from Python 2.5 would have been unnecessary if we had a real if expression.
It's not worth risking my account details for the sake of playing a game.
[Floating Point Arithmetic: Issues and Limitations](http://docs.python.org/tut/node16.html) If this is causing you problems, perhaps you want the [decimal](http://docs.python.org/lib/module-decimal.html) module.
Does anybody here actually _use_ cheatsheets? It seems to me they're all just blogspam.
That is cool. I recently ported a PHP Website over to Django and had pretty much the same results. Now my initial number of lines was much less, but the idea is there. My new django-version of the site is faster, leaner, and just so much easier to add stuff onto Of course, if I had followed a similar Django method of building my PHP web app then I'm sure it'd be close, but the framework helps you get by a lot of annoying things that most seasoned developers know how to do, but just don't want to deal with it.
These cheatsheats are a waste of time. Chris Hoffmann / Richard Gruet's Quick Reference Guide is far better: http://rgruet.free.fr/PQR25/PQR2.5.html 
thanks :)
Is this good or bad? I've never used Aptana.
Good.
step 1: import psyco step 2: psyco.full() step 3: is faster?!??
The *L* suffix is long gone.
I miss reduce()
does anybody know how the jslint validator of aptana can be customized?
# A set can be declared with {1,2,3} instead of set([1,2,3]) That is just cool in terms of math notation, but also makes sense as a parallel to dict declarations.
It's a pity that {} will still mean an empty dictionary.
hey, cool! just as i got a multitouch surface to play with :D
[Easy](http://docs.python.org/dev/3.0/library/functools.html#functools.reduce): from functools import reduce
Excellent!
holy shit, a knol.
pydev is fantastic, particularly with the Extensions loaded, but even without is still the best Python IDE in existence. With nbPython under development too its going to be a good year for Python tooling. 
via: http://apiblog.youtube.com/2008/08/using-youtube-data-api-with-app-engine.html
via: http://blog.alternating.net/?p=117
He left out [a whole bunch of stuff](http://docs.python.org/dev/3.0/whatsnew/3.0.html). I will particularly miss `execfile()` and the `print` *statement* (saves keystrokes, doesn't move fingers away from home row.)
via: http://pypi.python.org/pypi/restview/1.1.0
This is really cool. Ruby people, you officially have no excuse for complaining about this again! :-P
I like the explicit self...
Yeah me too, but now there's a way to shut down complainers with a different opinion, as can be done with tail call optimization decorators.
Depends on which you use more. Since `{}` always means instantiate a standard library `dict` whereas the name `dict` can be used to point to anything, you can optimize the byte code for `{}` more than you can optimize `dict()` or `set()`. Since people use dicts more than sets, I guess it makes sense to leave things alone for now as far as the empty `{}` are concerned.
I don't know. For one, I'd like the ability to easily redefine `print` with my own custom wrapper (for e.g., logging to a database, or teeing output to another file). Moreover, redirecting the output stream becomes more intuitive, witness the new syntax print("hello world", file=fp) versus the old one print &gt;&gt; fp, "hello world" IMHO, this change alone is probably worth the extra parentheses.
You'd still be able to use your bytecode optimization by introducing an empty dict literal as well. While following the discussion on the python-ideas mailing list, people seemed to like the {:} literal for empty dictionaries, but the consensus was that it would be better to leave things alone for backwards compatibility. I understand your point, but it's still a pity :-)
&gt; now there's a way to shut down complainers with a different opinion, as can be done with tail call optimization decorators. Please, no. These are cute hacks, but not suitable for non-demonstration use. The selfless hack breaks lexical closure, for example, so any normal code like: list(self.foo(x) for x in ...) or any other `self` in a nested function will no longer work, and instead raise `NameError: global name 'self' is not defined`. A number of other legal uses of `self` will also break the hack, by slightly altering the bytecode that gets generated. (If you really want to do something like this, the simple and correct way to go about it would be to alter the AST, before compilation. But you do not really want to do something like this.)
The proper way to shut down that kind of complainers is to instruct them to use something else than Python. Remember, Python is all about the one true way ;-)
There is no way i would ever want to do this, its really stupid to mess with the standard semantics of a langauge. 
How do I get rid of the mandatory indentation? Just a pre-processor, or is there a better way?
&gt; one true way ...one *obvious* way.
If only I could find a way to add goto... *edit* oh wait you [can](http://entrian.com/goto/)
Really depends on your code. I have not felt much speed improvement in the code I tried it with, but others report large improvements.
I guess you're being snarky, but I'm being serious. I know some people like it, but it just gets in my way. I understand the rationale for it, but in *my* case (a non-professional programmer), it's just irritating. I can't just pop open a vi window and whip something non-trivial together, I have to keep fighting with indentation all the time. Even in emacs it's a pain in the butt to try and move large blocks of text at a different indention level. Anyway, I like python, just not that one thing. 
fun f() -&gt; woo is quite interesting. Finally a way to overload functions.
&gt; This is retarded .. I seriously can't imagine why you'd actually do this. Because it's fun to do, fun to look at and fun to play with? Have you never played with language features to see what they're capable of?
Fuck me, getting down modded for not liking one feature of python on the same site people get 100 karma for joking about niggers stealing bicycles.
http://www.d.umn.edu/~gshute/vi/vi.html#indenting
Without the indentation, your blocks would be ambiguous. There's no curly braces in python, so how would the interpreter understand how to apply lexical scope?
No, don't actually do this. If the explicit self bothers you that much, go commit ritual suicide, because you are leading a life so meaningless that trivial conventions in a computer language are getting you down.
I don't suffer from self hatred.
I was digging around the django site and googling to see when this would make it into the trunk but couldn't find anything out. Glad to see it added, time to go pull the latest from svn.
Most of the code I have written has been C and PHP, so I'm looking resources to change my methods to use python properly. Currently my scripts are just php written in python syntax. (These are data importing scripts. cvs importing to mysql) When do I use list comprehensions, map and lambda? 
No, I released it for three reasons. 1. To experiment with bytecode manipulation. 2. To experiment with metaclasses. 3. I thought it was funny. It's *obviously* a ridiculous thing to do...
That is the closest representation of 3.3 with double precision floating point numbers on your platform. Worth learning about the accuracy of floating point numbers - reading about it now could save you a lot of heartache in the future.
How would you representing the follow code without indentation? And what about it gets in your way compared to any other method of denoting blocks of code? def example(): for x in range(1,10): if x % 2 == 0: print "%d is even!" % x else: print "%d is odd!" % x print "Finished processing silly example."
&gt;How would you representing the follow code without indentation? With a code block delimiter like the traditional { }. &gt;And what about it gets in your way compared to any other method of denoting blocks of code? The most irritating thing is taking a large block of code, like the if/else statement, and copying it or moving it to another level, such as immediately before the for statement. Now I have to go through and manually set the indent per line. Of course, vi doesn't parse the code at all, so you just have to tab/untab until the line gets where it needs to be. Emacs is a little better. My understanding is that the intention of this is to force more readable code. My opinion is that it does do this-- but it makes writing code more difficult in general. Perl is easier to write shitty code in, sure, but with explicit code block delimiters, it makes it *easier* for a program to parse and prettify my code for me, because there isn't any ambiguity about how where my blocks start and stop. I really wasn't coming here to piss in anybody's Cheerios. If I am being completely stupid, python zealots feel free to correct me. I like perl, but I like python, too. My only complaint is that I don't like the indentation. I didn't realize it was a sacred cow.
Open vim and read :help &lt;&lt; and :help &gt;&gt;
python hacks make baby Guido cry
I just use 'me' instead. My problem with 'self' is not that it's listed explicitly as an argument, but that I have to type it repeatedly. def __init__(self, x, y, z): self.x = x self.y = y self.z = z I much prefer the `@` notation of Ruby, but `"me."` is just 3 characters. I can live with that. def __init__(me, x, y, z): me.x = x me.y = y me.z = z 
A Python-free course? So, they kept Scheme after all?
Just went through whats available, this is useless, just a bunch of notes that are useless without context, the homework assignments, and some random related reading (with broken links). They obviously dont do much work to check that Opencourseware material is up to standard. Give me SICP any day.
Try the link for the Big O notation material (the only one I was interested in), broken. I hope they do update it, it looks like it has the potential to be great, but with whats there right now, I don't know why they bothered.
not python-free.
It was somewhat disappointing yes. The Lecture notes without video lectures are meaningless (they are not made to make sense without the lecture). What is most interesting these days seems to be the the Assignments, I always have a problem to figure out what I should code after I've passed that initial hump with hello world et al.
via: http://jessenoller.com/2008/08/28/entertaining-documentation/
See also [_why's poignant guide to ruby](http://poignantguide.net/ruby/). Unreadable, but entertaining. (Yes, I know, Python subreddit and all that.)
the same in php function base64_url_encode($input) { return strtr(base64_encode($input), '+/=', '-_,'); } function base64_url_decode($input) { return base64_decode(strtr($input, '-_,', '+/=')); }
No nonsense docs are better than some guy trying desperately to be funny (camel book) imho.
&gt; Unreadable, but entertaining. This is **exactly** what it is. Nail on the head, bravo. I thought I was the only one tired of its style (I want to learn the language, damnit, not read cartoons about bacon). That guide urged me to write the [Learn Python in 10 minutes](http://www.poromenos.org/tutorials/python) thing (now with 10% fewer cartoons).
*shrug* I pointed my boss to it to learn ruby (and thus understand slightly what I'm doing), and he loved it. I think it depends on your goal. It doesn't make a good reference source -- what I assume you really mean by unreadable -- but if you just want to sit down and read a chapter and glean some information (and you find _why's humor at least slightly entertaining), it's pretty great.
That's probably true, I wanted to learn the basics without any distractions and in the least possible time. I found the meanderings rather distracting.
it only works with US operators at the moment..
You really need to profile with psyco. It can make Python code run a lot faster, but it can also have no effect or even slow it down. And of course, psyco is no longer updated and won't be extended to support other platforms.
Unreadable? I disagree. But it does read like a novel rather than a programming manual. If you want unreadable, try Nobody Knows Shoes (also by _why), I never managed to get any information worth using out of it :(
Why don't sites make that clearer? I guess America seems a lot larger percentage of the world when you live in it...
Still my favorite example ever: &gt;&gt;&gt; horsemen = ['war', 'pestilence', 'famine'] &gt;&gt;&gt; horsemen.append('Powerbuilder') That's not just entertainment; that's therapy. (Source: http://diveintopython.org/power_of_introspection/built_in_functions.html )
That brings me to thinking about a "View Source" button for Python desktop apps, giving a possibly hot-editable file of the code under whatever in the active context. Heuristics for doing that should be defined well, though.
who in the python subreddit would downvote this? this is cool
There's no built-in support for connecting to a database, or integration with something like SQLAlchemy
Please link to the original article on CIO.com http://www.cio.com/article/446829 
Not only the formatting on CIO's version is better, it also has a nice printer-friendly format for those who don't like artificial paging on websites. Thanks for the link.
While I'm having fun with appengine, google always feels like it's a step behind in some way. This is a mediocre solution to the problem of educating developers. Kinda like knol is a weird solution to some problem I'm not aware of.
via: http://feeds.feedburner.com/~r/LateralOpinion/~3/378709968/30.html
1. Use `back ticks` or preface lines by four spaces to make things look like code. 2. This can be done in Python as well: def uri_b64encode(s): return unicode(s.encode("base64")).translate({10: None, 43: 45, 61: 44, 47: 95}) def uri_b64decode(s): return s.translate({45: 43, 44: 61, 95: 47}).decode("base64") Unfortunately, Python's `translate` method has an ugly interface (of course, it can always be replaced with a series of `replace` methods), but it's otherwise the same. 
I just skinned python subreddit as python.org... I hope the community likes it... any feedback is welcome... Also, if somebody knows how/who, it would be sweet if we can CNAME news.python.org to python subreddit...
My feedback: * A bit sad that the Python logo isn't flushed left * No link to the root of either reddit or the subreddit, which is quite annoying
I didn't flushed the python logo left intentionally, because, it's not flushed at python.org... but fixed... also, I fixed the link so it point to python subreddit... :D
Not working well in IE 6. Yeah yeah
can you post a screenshoot? I think I solved the issue, but I'm not sure.
http://i202.photobucket.com/albums/aa225/sp111_photos/screen.jpg there you go, its much better now, could maybe used a bit of padding or margin between the logo and the Whats hot link
Nice hack with the link, that's exactly how I've always wanted the subreddit logos to behave. It looks much nicer now.
Looks ugly if you have subreddit styles turned off, with the logo looking a bit forlorn up there.
Looks good, but there should probably be some reddit branding.
But I like distractions ...
Especially with a *.python.org alias.
There should be a link to reddit root as well, since there's no link there otherwise. We may, after all, have our customized main pages.
Although I don't like the python.org-style very much (I used to like it, but it looks far too corporate and impersonal compared with the new Ruby site) this is quite nice. I didn't know that subreddits are styleable. As for the subdomain, consider [writing to the PSF](http://python.org/psf/about/), although I doubt that they are going to add a CNAME, but go ahead and ask.
Great! Thanks.
Or you could just turn off the sound, fullscreen emacs/your editor of choice... is there something I'm missing here?
This is a good case for the logo being a PNG with proper alpha transparency.
actually I uploaded the logo with alpha transparency, but reddit dumps the transparency, leaving a #CCC backbground... So I had to upload the logo with the gradient...
Now, you can not only get the source via [Bazaar](http://www.python.org/dev/bazaar/) but also via Mercurial, which is [faster](http://pyside.blogspot.com/2008/08/quick-hgbzr-timings.html) for most tasks. (And no, this is not going to be a flamebait, while I value bzr for many things, yet it seems to me still too slow for big repositories)
I like it. :-)
Exactly, vim + fullscreen terminal. I might not want distractions but I still want search &amp; regex ...besides if you don't want distractions there's this thing known as 'pen and paper' :)
too much wasted space, needs reddit branding somewhere; something like [environment subreddit](http://www.reddit.com/r/environment/) 
Good effort and cool idea but I don't see how making your editor full screen doesn't work. I do it all the time and it works well enough
But ALL THOSE BUTTONS! Don't they DISTRACT you amd make you want to PRESS them?
But it's not flushed at a different position. There's a `margin-left` of `3%` on python.org's logo. It looks weird.
Maybe the 'turn off custom CSS' option should also turn off custom logos, then
How did you get that header background image to work? I kept getting errors with any off-site pictures.
Looks cool. Some small issues: 1. There is a gap between the comments/related tabs and the line that lies below it. 2. The comments/related tabs sit too close to the python logo. Consider adding a bit of space between the two to make the python logo sit nearer the horizontal middle of the space allocated for it. 3. The space below the python logo is larger than the space above. Consider adding some space above the logo to make it sit in the vertical middle. I know these are nitpicky, but I did design magazines for a while...
Oh, also, can you do it so clicking the logo takes you to the python subreddit if you are viewing a comments page within the subreddit, but takes you to /r/ if you are on the index page of the subreddit? That's how I think the header link should work, but I doubt the reddit admins would ever change anything like that. I don't know if you have the editing power to do that, but it would be super cool.
Pretty much the only difference is that PyRoom and the likes have wide margins, so your document is only, say, 80 characters wide (which is far easier to read) That said, dull background wallpaper, quit other applications. If you get distracted by a menu bar, I think you have problems beyond the reach of a simple text editor..
via: http://www.livingubuntu.com/?p=89 Python for SysAdmins Virtual Server
They removed the **u** from the abbrev. Otherwise it would have been **py4usa**. Neat shit! I am high BTW.
MacVim has a full screen mode, if you want a real editor.
Nice job. Its the best subreddit on the site and deserving of the logo. The DNS registrar of python.org is the Python Software Foundation; whois reports: Admin Name:Kurt Kaiser Admin Organization:Python Software Foundation Admin Street1:P. O. Box 653 Admin Street2: Admin Street3: Admin City:Ipswich Admin State/Province:MA Admin Postal Code:01938 Admin Country:US Admin Phone:+1.9783565220 Admin Phone Ext.: Admin FAX: Admin FAX Ext.: Admin Email:psf@python.org 
Nice job. Its the best subreddit on the site and deserving of the logo. The DNS registrar of python.org is the Python Software Foundation; whois reports: Admin Name:Kurt Kaiser Admin Organization:Python Software Foundation Admin Street1:P. O. Box 653 Admin Street2: Admin Street3: Admin City:Ipswich Admin State/Province:MA Admin Postal Code:01938 Admin Country:US Admin Phone:+1.9783565220 Admin Phone Ext.: Admin FAX: Admin FAX Ext.: Admin Email:psf@python.org 
Forget `hg`, `git` all the way :-)
I've always suspected some of reddit are high. The question becomes 'what percentage'?
via: http://www.amk.ca/diary/2008/08/turning_over_python_cryptograp.html
&gt; which is faster for most tasks. Are there tasks for which bazaar is already faster than hg? aside: isn't it a bit sad that no hg mirror uses hg branches? The django mirrors I've used didn't either.
Mercurial's in Python, the interface is more enjoyable than git's (+1) and it's a little slower but not much (-1). What'd the point of using Git be?
The speed of development in Bazaar is faster. Switching branches in place might be faster. While there is much stuff being done in the Mercurial `crew` repositories, there is not much user-visible changes. They don't have such nice release notes where changes are described. Hg branches are currently a bit crappy since the original idea was repo == branch which is not as comfortable as git branches. Bazaar has the same problem, but they included a special type of repository, the so-called shared repository which contain all changesets, so branching these is very cheap. Consider cloning two hg branches via HTTP: you have to clone every shared revision twice, whereas in bzr you can dump all revisions into the shared repository and only need the specific revisions. There is also `bzr switch` which makes a git-like workflow at possible. Not the nicest solution, but not bad either. Hg on the other hand has named branches which are just commits that are annotated with a branch name. Therefore you can create branches but cannot get rid of them (revlog is append-only for performance reasons) and I'm not sure whether you can branch from named branches (since the branch-nicks are just annotations) etc. This is probably the one thing that annoys me most about Hg.
The Bazaar API (bzrlib) is IMHO more enjoyable than Mercurials which 1) has lowercase class names; doesn't use underscores etc. 2) is geared towards performance. I doubt that Python is going to switch to Git since two of the three most popular DVCS are actually written in Python and they are not particularly bad.
When I talked about hg branches, I was talking about named branches, not clones. &gt; Therefore you can create branches but cannot get rid of them I don't see that as too much of a problem though, the issue of hg log being branch-unaware and quite stupid is more of an issue to me. &gt; I'm not sure whether you can branch from named branches Why couldn't you? It just creates two different revisions with the same parent (the revision you branched from), one for the new branch and one for the old branch, doesn't it?
I understand but I was talking only of git vs hg, not of git vs hg vs bzr here (and python's already available under bzr so...)
&gt; Why couldn't you? Yeah, I thing that would work. I was just thinking that the branch unawareness might be problematic.
&gt; I was just thinking that the branch unawareness might be problematic. Last time I tried to play with branches it was... annoying, to say the least. I don't know if it's changed since though, I'd have to check (and maybe see if I could improve it) Which makes me think, wouldn't it be possible to "delete" hg branches simply by dropping their entry in whatever file they're stored in, therefore making them invisible.
ctypes can call C++ now?
There was somebody working on named branches support and he committed some patches to the crew-repository. Maybe they just need some more people who fix stuff that annoys them. Many things are probably fixable without any bigger performance impact or repository structure overhaul. It just isn't done yet. I'm already trying to get my changes in since some time, I'm currently struggling with the hg unittests.
yes, with extern "C" You can use ctypes to call any c++ code that can also be called from C code. Full-fledged C++, with its classes and virtual functions is far more complicated.
So I can't even use STL containers, std::string or.. well any C++ specific feature? Maybe it should say "calling C code from Python".
Do we [need](http://they.misled.us/dark-room) another [one](http://hogbaysoftware.com/products/writeroom) of [these](http://www.codealchemists.com/jdarkroom/)?
See http://www.boost.org/doc/libs/1_36_0/libs/python/doc/index.html Maybe it's what you need Or perhaps http://www.swig.org/Doc1.3/Python.html
It's medicore in that it seems to just be a scattered collection of whatever gets submitted. I'd prefer a collection that has some code review / editor to keep it "on course"
*zing*
Ok, so I have two variables, label1 and label2. label1 could be None and so can label2. I want to concatenate them together into a third variable label such that label is None if label1 is None and label2 is None The code I have so far is like this: if label2: label = (label1 or '') + label2 else: label = label1 is this an abusive way to use 'or' or is it Pythonic?
 label = (label2 and ((label1 or '') + label2))
It's Pythonic, but the code won't work the way you specified: if label1 is None and label2 is '', the result will be None.
I'm using that, but it would be cool to write wrappers in Python, boost.python wrappers take a long time to compile and consume a lot of memory.
I think you meant that the other way around, namely if label2 is None and label1 is not None. 
That, too; it's an even bigger bug. The right way to write it would be if label1 != None or label2 != None: label = ((label1 or '') + (label2 or '')) else: label = None or, if you're allowed to treat empty strings as None, label = (label1 or label2) and ((label1 or '') + (label2 or '')) or None Or here's another one: def _(x): return x or '' label = _(label1) + _(label2) or None Also, he really shouldn't worry about "pythonicity" if he can write it in under three lines anyway.
You could do it using the new syntax in Python 2.5: def concatenateLabels(a,b): """If both a and b are None then return None. Otherwise return a + b, where if either a or b is None then is treated as an empty string.""" return None if (a,b) == (None, None) else (a or '') + (b or '') assert(concatenateLabels("a", "b") == "ab") assert(concatenateLabels("a", None) == "a") assert(concatenateLabels("a", "") == "a") assert(concatenateLabels(None, "b") == "b") assert(concatenateLabels("", "b") == "b") assert(concatenateLabels(None, None) == None) assert(concatenateLabels("", None) == "") assert(concatenateLabels(None, "") == "") assert(concatenateLabels("", "") == "") The documentation and testing is more important than the code, IMHO.
Not sure if it's more pythonic, but I'd rather use a couple of lines rather than a criptic one-liner: label = '' if label1 != None: label += label1 if label2 != None: label += label2
You can see `(value or other_value)` sometimes in the Mercurial source, because it is short and compatible to Python 2.3 (and even beyond).
label would not be None if both label1 and label2 are None. Plus, you should never write if label2 != None: if label2: is much more Pythonic
You shouldn't use != None, since None is a singleton. If you really want comparison to None, use: if foo is not None: bar() If you want to test for truth value, just use a truth value test: if not foo: bar()
I'm the author of Qtile, and I thought I'd mention that "full-featured" is where Qtile is headed, rather than where it _is_... ;) While the project is usable right now, the current release is aimed mostly at developers who might be interested in joining the project.
Whoa, I was just thinking of starting to write a tiling wm in python. I don't have much free development time right now, but I'll check out the code, and maybe in the future I can contribute meaningfully.
I love Python more than my wife, but how is its performance? Python isn't exactly known for that...
Actually, for this kind of application Python's performance is more than adequate. I might add that the same answer goes for a surprising number of situations where you might think Python wouldn't cope. 
You are a wonderful, wonderful person. I'm currently using awesome and I keep thinking "God I wish I could script this with Python." *hugs*
Yes, I used to be an Awesome developer, and I always wished the same thing... ;)
That's what I was thinking as I was writing the previous post, actually... "If Python's performance is good enough for web development, what else is it good enough for?". I'll be sure to try your window manager, thanks.
I have a pressing need.
you should have named it "reptile"
And here I was thinking - "Sounds good, but I'm just about to get into Awesome". Python scriptability is a big win in my book. Might lend a hand once I finish writing up my thesis...
Does qtile keep the same concept of tagging? Because I find that very useful.
Nice work, can't wait to see how this project goes.
That multiprocess module looks quite great, but isn't the cost of spawning a process rather large? Although I guess you'd have a long-running process and use IPC to perform your calculations instead of launching it every time.
How about bringing it to 2.5 (or 2.6)?
That's nice. I've been looking for a nice scriptable tiling WM and so far only xmonad and stumpwm/ratpoison (I do like Lisp, but I know Python way better) were of interest. Sounds definitely like something to try/contribute. Do you work for Nullcube? Because you're using their design and their testing framework (usually people use nose which is more popular).
Maybe it uses a pool of processes?
It's lower on Unices. 
Does it have a "porn" mode?
Great that numbers starting with 0 are not going to be interpreted as octal anymore (in 3.0) that's a legacy from c we didn't need.
Yes, but you shouldn't spawn a process all the time. Only do it when you need to.
Yes, that's what I thought later on... You'd obviously spawn a pool of long-running processes and use queues to dispatch problems to them, like you do with threads. In all, I am very excited over this multiprocessing module, I just need something to test it on, now.
Yes, this is a very important question that should be answered.
a) Its low on systems with a proper fork() call (most anything but windows). b) It has built-in support for Pools, which is generally the suggested way to multiprocess with threads anyway :-)
No, but it has other features that make up for it. Qtile has "groups" rather than tags, with each window belonging to one and only one group. Groups are shared between all screens, so you can pull a group to any screen in a multi-monitor setup. This nice feature breaks classical tagging - what happens if a window belongs to two tags and both tags are displayed simultaneously? 
Yeah, but that's in 3.0 only, unless I'm missing some `__future__` import…
Holy crap, [sphinx-generated documents](http://docs.python.org/dev/) look awesome. 
I'm not really into the tiling window managers but the scriptability is a must in a modern UI. Best WM ever was sawfish. I always wanted a sawfish but with Python as the language. With the amount of module support Python has you could script a conky replacement, wallpaper changes from flickr, custom Gmail / GCalendar alerts fully themeable from within the WM. I like making root shells a light transparent red background opposed to the normal dark black because visual clues are important in the interface - I just do this in XResources but IMO the WM should handle this type of thing in a customisable way.
I think this is all stolen from the `multitask` module. Anyway, it's a neat concept, but it is not so useful as it seems at first. The problem is that Python generators are not full co-routines, so they cannot 'yield' from nested sub-routines.
Will try it out. Currently a StumpWM user, but clisp it not my primary language. Oddly, I wanted to mess around with Xlib in Python as well, but didn't get that project started (have to limit myself after all).
I think you need to elaborate a bit on why it is not Python. Sure it has a huge initialization section with GUI widgets and whatnot but so has any similar wxPython program.
Still, there has to be a better way. Perhaps a more "pythonic" or "pythonesque" one, or whatever the "pythonistas" would call it.
A link to reddit.com would be nice too
I still don't get what your problem is. Is it the size of it in the LoC sense? GUI programming tends to be quite verbose in any language. Also don't confuse "pythonic" with "clever-but-hard-to-read-onliners" (some people seem to do that)
A while ago I hacked [this](http://code.google.com/p/termroom/), which is basically a full-screen gnome-terminal padded a la pyroom/writeroom, so you can run vim, emacs or any other text editor in it.
OK, I had not spotted the '*'-imports. That is definitely bad style and not pythonic (although it is valid Python :-)) I don't get your beef with the interfaces thing. .NET is quite hung up on types so I guess that some typechecking is necessary. I have also seen alternative approaches like pyanno that (attempts to) do the same thing. The GUI init part is a matter of taste I guess. It is IMO not more pythonic to have stuff in a dict instead of individual attributes. If you are using a Python-aware editor tool, then using the single-attribute model may assist the tool in stuff like code-completion. FYI, Python GUI tools like wxGlade and Boa Constructor will generate code in much the same way as this. 
&gt; Sure it has a huge initialization section with GUI widgets and whatnot but so has any similar wxPython program. And I would argue wxPython isn't Pythonic at all either - it's basically a wrapper to the equivalent C library..
Hm. Aren't you confusing the implementation with the usage? But apart from that, would you argue that a native Python GUI widget library would look much different? (a theoretical question, since AFAIK no such thing really exists)
[Shoes](http://code.whytheluckystiff.net/shoes/) is one the only GUI toolkit I've actually liked using.. I wonder how difficult it would be to write something similar in Python..
[Posted to the programming subreddit first.](http://www.reddit.com/r/programming/comments/6ze70/how_super_should_be_used_when_calling_a_parents/) In Python 3, you can just call `super()` without any arguments and it will do the right thing.
Thanks, this is informative. I did find one minor error, though: on Unix-style systems such as Linux and OS X the character to join multiple paths is a colon, not a semicolon, the latter being the appropriate character for Windows.
Dammit, I hate having to vote up a gst story.
This one is notable in that one of the authors is Simon Willison, a major Django contributor. Not sure it's any better than the (more established) django-evolution; in fact since it only supports MySQL at this point I would consider it unsuitable for general use.
It's definitely suitable for general use if you're using MySQL ;) We've been using it in production for a couple of months now, both on our deployment servers and in our dev environments with quite a large team of developers (14 people). If django-evolution is working for you there's no reason at all to switch to dmigrations, but my experience with evolution was that it wasn't quite right for the way we were developing things.
Why doesn't it support other databases? Doesn't it just store the SQL with the revert statements?
I know those words, but that title makes no sense.
Because we only needed it for MySQL, so we didn't bother supporting anything else. The SQL it generates is currently MySQL specific, but porting it to other databases should be extremely easy. If someone else doesn't do it within a week or two I'll probably give it a go myself :)
Some shameless self-promotion here; there's also South - http://south.aeracode.org - which has the advantage of being database independent (and there's nothing like competition to spur development, we've just finished off a major feature overhaul).
I think a babby is involved.
I'll drink to that.
Ah, I see... It sounds quite interesting.
Cheers! I hate doing mySQL stuff. It isn't that it is hard, it is just that 99% of the time they are just busy-work SQL calls. Django removes some of the pain with their database API. I drink to Django 1.0 as well!
I'll stop drinking... FINALLY!
And here's how you do it using the interface provided by gnome-screensaver exactly for this purpose: #!/usr/bin/env python import subprocess import dbus bus = dbus.SessionBus() obj = bus.get_object('org.gnome.ScreenSaver', '/org/gnome/ScreenSaver') screensaver = dbus.Interface(obj, 'org.gnome.ScreenSaver') handle = screensaver.Inhibit('gmplayer', 'playing a movie') subprocess.call(["gmplayer"]) screensaver.UnInhibit(handle) This is the same method totem uses to suspend gnome-screensaver.
Basically the guy got initially worse results for mod_wsgi than php because he misused the API (in effect Apache was sending response one character at a time, flushing the output stream after each one). After making neccessary fixes he "got results similar to or better than PHP".
Well written article. I actually didn't know you could return tuples like that in a function, and a few other things you mentioned Thanks!
this is a nicer solution
via: http://www.procoders.net/?p=225 numpy docs are free now !
Direct link: http://www.youtube.com/watch?v=bDgD9whDfEY
The link in the comments to http://users.rcn.com/python/download/Descriptor.htm is interesting.
Thankyou ! I wondered if mr mecurty tide would bring out one for 1.0.
Why not sponsor support for libvirt (http://libvirt.org/)?
I tried to submit that content to test the language filtering preferences of reddit but apparently it does not work and I could not choose to set the content language at submission time. Please non-french speakers do not down-vote this and try to help me make the multi language work correctly on the Python sub reddit instead maybe by adjusting the subreddit preferences?
Is free!
How does this book compare to Dive into Python (better/worse/for different audience)?
Byte of Python is for beginners with little or no programming experience. Dive into Python is for people who already have python programming experience. 
thanks. I'm currently reading Dive into python, and i was just wondering if i should try this next (especially since it covers Py3K).
Naked and smoking a cigar?
From a novice point of view, Py3K means use the `print` function and `as` exceptions. That's about all that's different if you ignore the APIs and other fine details.
Looks like the performance differences between these benchmarks are pretty minor. Note that the statistics in this study are flawed -- the author took the "best" time, not the average, not the median, but the fastest. I would have liked to see averages and confidence intervals. As is, the study is perhaps a weak indicator, but we cannot even say that there is a significant difference between the different versions. Sorry, those are the facts. 
New version released: http://pypi.python.org/pypi/pprocess/0.4
The print thing should be solved in Py3K, since print will become a regular function.
so, there is an active community using appengine on windows, when a new version is released, they renew their version and keep working... By the way, I download appengine through svn...
Scoping ======= What the author proposes would be more confusing in my opinion. He wants a to be global and then switch to local all of a sudden? Sure easy to see in that 3 line function, but you are asking for trouble with something slightly more complex. Did I misunderstand? Rounding errors =============== &gt;&gt;&gt; a = 0.1 &gt;&gt;&gt; a 0.10000000000000001 &gt;&gt;&gt; a - 1/10 0.10000000000000001 That's because 1/10 is 0 (like when you divide two integers in C) before python 3000. Try the same with 'from __future__ import division': &gt;&gt;&gt; from __future__ import division &gt;&gt;&gt; a = 0.1 &gt;&gt;&gt; a 0.10000000000000001 &gt;&gt;&gt; a - 1/10 0.0 There are also libraries like sympy and gmpy if you want a true rational type, but I can understand it as a criticism of the language that these aren't available by default. It could be a performance issue. Can anyone shed some light on that? lambdas ======= joelthelion said it ugh, sorry for the formatting (and no I'm not fixing it, though I'd appreciate someone telling me if there is a way to force a newline or use [code] tags somehow) :)
I'm not a newbie, you insensitive clod.
I'd like to see performance measurements when using [psyco](http://psyco.sourceforge.net/), for comparison.
&gt; There are also libraries like sympy and gmpy if you want a true rational type, but I can understand it as a criticism of the language that these aren't available by default. A [fractions module](http://docs.python.org/dev/library/fractions.html) is being added to the standard library for Python 2.6/3.0.
I've been looking high and low for a good vim and python integration. I know a lot of people use vim and IPython. For me it's a bit backwards to start in IPython and call %edit on all the files I want to edit in vim. For one thing, it makes any file opening and project plugins you might have in vim useless. I would like to go the other way - start in vim, and execute selected files/code in IPython, kind of the way it works in IDLE. I tried to launch IPython as a subprocess from vim but so far I haven't managed to get anything working. Any help appreciated.
You can get into Python editing mode by typing :wq&lt;enter&gt;emacs&lt;enter&gt; It's a secret; don't tell!
I am envious of Emacs' extensibility. Vim just can't touch it in that department. However, since I touch type, I find that using Emacs is just too uncomfortable. Viper mode doesn't do the trick for me. If Emacs were modal in the sense that vim is modal I'd probably be using Emacs instead. Each to his own.
You meant "To each his own".
How does this compare to multiprocessing? EDIT: Oh wait, it doesn't. He's just launching new ones.
I am looking for the same kind of IDLE workflow with vim / ipython, especially while writing doctests with the ipython doctest mode. I did not had time to try and start a prototype though.
awesome
What's your platform? I'm on a mac and use all three of Emacs (Aquamacs variant), Vim and TextMate - depending on the task. For Python I usually end up in TextMate. I'm an old time vim-er, but started using Emacs after I learned Haskell and Textmate since I got a mac.
http://henry.precheur.org/2008/4/18/Indenting%20Python%20with%20VIM.html
hey, that's my setup :)
Seriously, try out Emacs with Viper-mode, even if that sounds like heresy. I use Vim for 95% of things, but Emacs is tops when it comes to interactively editing Python code (or other languages with a REPL, notably CL and Scheme). "`M-x run-python`"...
http://technotales.wordpress.com/2007/10/03/like-slime-for-vim/
Best is the best metric. There are *many* things that can affect an individual benchmark run - the best shows the fastest that the machine is capable of.
PyBench runs compared across versions would be more useful.
If you're looking for an integrated experience, there are a lot of scripts and tips on VIM's site that will point you in the right direction. However, if you want a more IDE like experience using the tools you love, you should check out http://pida.co.uk Probably the best IDE i've ever used because it embeds the things I love to use most.
&gt; I am envious of Emacs' extensibility. Vim just can't touch it in that department. Have you considered the possibility that this might be a bit misinformed opinion? I would really like to know what exactly did you find impossible to do with vim but feasible under emacs. 
Here's the [direct link](http://code.google.com/edu/languages/#_python_understanding) to where this blogger found the lectures.
Among other things, Emacs has the comint package which allows you to interact with an external process (usually a REPL) from an Emacs buffer.
Actually, despite it not being very constructive criticism, I'm tending to agree with you now. The lack of purpose-driven naming makes it a bit difficult to decipher the intention at a glance, which I imagine is doing the project more harm than good. ie, I'm going through some restructuring in order to simplify the layout of the projects.
One sentence on some chapters. That's just terrible. This could be on one page.
Preferably something kind of slick and ajaxy (you know, when ajax actually contributes to the user experience and isn't just used flagrantly) I've seen [Skeletonz](http://www.orangoo.com/skeletonz/) but it isn't really being updated or supported at all -- and that seems to be the only newer Python CMS around..
See also: http://www.davidcramer.net/code/276/high-performance-django.html
&gt; Note that the statistics in this study are flawed -- the author took the "best" time, not the average, not the median, but the fastest. Please engage brain before posting. (no need to downvote: anyone arguing that avg(A+B) is better than min(A+B) when you can measure A+B but want to know A isn't using their own brain; they're just repeating some crap they memorized in school in an attempt to make themselves feel smarter than someone who's actually a lot smarter than themselves.)
I don't know what level of interaction does this package offer, but you can [script something similar in vim as well.](http://briancarper.net/2008/09/06/vim-screen-repl-win/) (This was actually [linked on proggit rather recently.](http://www.reddit.com/r/programming/comments/6zzc1/vim_screen_repl_win/))
&gt; Now, in order, I can't help but read except IOError as 'catch everything apart from IOError'. That's an interesting take on them &gt; Secondly, print adding newlines. While this might seem trivial every other language I use on a daily basis has a print function that doesn't print a newline so this feels weird. Simply make a habit of adding a comma at the end of your prints: print "foo" will add a newline, but print "foo", won't. &gt; Can we have ++ and remove nested ternary ( ? : ) instead please? Well considering that form of ternary doesn't exist in Python (we have `value if test else other`), no.
I found it quite handy that `print/print()` write newlines by default (although I dislike the `,`-syntax) but agreed - there are some cases where it is problematic. `println` proves, that this is common enough in other languages, that the default setting is useful to many people. The problem with `++` is that it modifies the object and uhm, integers are immutable. This is why `+=` is a plus and at the same time a assignment, thus replacing the old immutable object with a new one. On mutable objects it might work, but honestly, these few characters that one saves do not justify a special and very limited syntax construct (`+=` is way more flexible).
&gt; The problem with ++ is... I was just about to post asking why ++ isn't present. Thanks for your explanation.
&gt; I found it quite handy that print/print() write newlines by default So do I, I much prefer defaulting to adding a newline, but I can understand the criticism from people coming from languages where this isn't the default. &gt; although I dislike the ,-syntax Well with Python 3.0, the `,` postfix disappears, replaced by the `end` kwarg: def print(*args, sep=' ', end='\n', file=None) So to remove the newline, simply write `print(foo, bar, baz, end='')`, which is much clearer than the current version (even if more verbose) edit: ugh sorry about the spam, reddit crapped on me non-stop (every comment request came back with a 500) and refused to show the comment on page refresh (incl. C-F5) so I thought it wasn't being posted
Also the main program's bytecode will be saved in a .pyc file reducing startup time.
and the perl equivalent: main() unless caller; sub main { # do stuff }
I always used \_\_name\_\_ in my Python scripts because this is how I learned, but until now I never really understood the inner-working.. great article.
this was posted a while ago, hope it helps: http://www.reddit.com/r/programming/comments/6j02b/setting_vim_up_for_python_coding_properly/
`type` is not a keyword; it's a built-in. There's a difference.
Even better to use the main() template that GvR describes (prescribes?) on his artima blog.
Part 1: http://www.youtube.com/watch?v=bDgD9whDfEY Part 2: http://www.youtube.com/watch?v=y7vwZ20SDzc 
While "to each his own" is more common and arguably more correct, "each to his own" or "each to their own" is not uncommon, esp. in American English. But thanks for the heads-up.
I believe this is the article you are talking about: [Python main() functions](http://www.artima.com/weblogs/viewpost.jsp?thread=4829).
Also, remember `python -m compileall` which byte-compiles all files. This is useful when the user doesn't have write permission to the application directory. For example if you are running mod\_python or mod\_wsgi in embedded mode, Apache has to recompile all your application code on every request unless you do this. 
Someone can't draw a proper graph, it seems. EDIT: You don't put the dependent variable on the x axis, downmodders...
If you actually take a second to read the code, you'll notice that it's awful, and a bad idea. It's essentially using a spinlock to wait for new network traffic to come in, which arguably defeats the whole purpose of asynchronous IO. 
&gt; Lastly we have the lack of ++ and --. counter += 1 counter -= 1 ..or.. var2 = 123 counter += var2 It's an extra character (`a+=1` vs `a++`), and is more flexible &gt; What does irk me is the lack of block delimiters - whitespace just doesn't cut it for me. The only problems I've had with indented code is 1) long blocks of code can be hard to follow (although that's generally an indication that you need to restructure things), 2) if the indentation gets messed up (say, by a weblog script that strips leading whitespaces, or tabs getting messed up in copy/pasting), it's very difficult to correct.
&gt;unlike Python, a serious programming language would not have a cheese shop where you get eggs. win
I'm happy with vim and IPython in separate windows too. I'd just like to be able to press F5 while in vim to execute the current buffer in IPython and switch to the IPython window. Seems simple, but on Windows, it is not.
What a waste of time, downmodded.
webmonkey is owned by reddits parent company. do not want.
Discussed here: http://bcurtu.com/?p=491
I'm thinking that "category label" can't possibly be a dependent variable, even if it is sorted. 
I don't understand what you mean. I'm talking about the "value vs hatred" graph. Apparently his lots for smug rails developers is much hatred, and his a little for most things is a little hatred. EDIT: Okay, **now** I know what you mean, and you are correct. It should have been a bar chart. For some reason the fact that "lots" was on the x axis made me ignore the fact that "hatred" is not a variable. It was as wrong as [this](http://www.youtube.com/watch?v=qhmahD_EbHY&amp;feature=related), but nowhere as funny.
Aren't the first six somewhat equivalent? But fine, they're tests, they should be subtly different. Don't sbv1 and sbv2 contain the **exact** same code? Or am I missing something? 
Yeah, that's what I figured as well. The results below are different, which leads me to believe that he only mistyped the code, not the actual test.
lulz you link to other sites owned by your parent co. make me laff. har har har.
Yes, definitely a bar chart. And yes.
I've only seen the slides but they were quite entertaining. You don't have to take it too serious, it is just fun.
This article is absolutely hilarious and was posted by gst, a bot, which afaik has no connection with reddit or Conde Nast.
Discussed here: http://agthorr.livejournal.com/47888.html Building a faster-like type for Python, part 2 I needed a break from my deep mental immersion in poker software, so over the past few days I spent some time working on my faster list-like type for Python, the "blist". Some of you with good memories may remember it from my last post about it... over a year ago. Previously, it featured O(log n) inserts and deletes without giving up any performance for small lists when compared to Python's current array-based lists. However, random access reads and writes with no change in length were also O(log n), compared to an array's O(1). 
very nice.. I was wondering idly about how to do this just this morning. I've always thought that this is a nice feature in MATLAB -- setting breakpoints that just dump you into a full shell so you can view variables, plot things, even enter code. I wish it was simpler in Python.. but that can come.
http://www.iamcal.com/talks/ pps =&gt; 162M pdf =&gt; 100M WTF ?
I'm not quite sure, but this sounds all kinds of wrong.
what is the "Additional language implementations:...He also indicated that you could probably guess what the next languages would be by looking at the popular web languages in use today." Java or Ruby or Php?
Woah, never knew that class attributes take precedence over instance slots. Is it a language quirk or is there a rationale?
How about JavaScript as a dark-horse contender? I wonder whether a generic JVM is a possibility? (and hence JRuby, Rhino, Jython, etc)
It would be nice if some equivalent of Rhino were available in Python. Rhino is a pure java implementation of JavaScript.
what would be cooler is some kind of low-cost common object model that lets languages swap data and call functions in-memory the implementation is lacking in places and overdone all to hell, but theoretically this is something microsoft got right. call vb objects from jscript, link in c# code, etc. oh i know about parrot. it looks like it will be fun to play with. i dont think it'll ever ship a 1.0 release however
This only happens if you use `__slots__`. That's why all the guides say, don't use slots unless you're really desperate to save memory.
i was following along and having a grand time (i'm a django amateur, building my first web app) until I realized that only videos 1 and 3 are available.. Is this some kind of cruel trick!?
Sorry, Django guys, Python Paste added [pony power](http://pythonpaste.org/modules/pony.html) in version 0.9, and it was extended to include unicorn power in version 1.1. *[Not yours.](http://i24.photobucket.com/albums/c42/troys1911/myspace/pony.jpg)* This is just going to require another magic-removal branch. 
This has got to be one of the most inane postings to /r/Python in the last week. Using the built-in symmetric_difference set function is faster than a non-builtin list comprehension that you coded in straight Python which does the same thing? No kidding!
Looking at the source code, they are reusing their javascript variables, so in actuality, videos 2 and 4 are the only ones available. They're using a variable called 'sx' to handle the flash player. sx is set to video 1, and then immediately overwritten with video 2. Link to video 1: http://www.linux-magazine.com/var/linux_magazin/storage/original/video/4315ee216a17132b3d0eb9e079ab27bb.flv Video 3: http://www.linux-magazine.com/var/linux_magazin/storage/original/video/e6e3c440788bafa1dcdcb7eff851b117.flv
thank you. jw.. how complicated was that to figure out? heh heh.. you went into the source code just to investigate? that is nice of you.
You mean it is not consistent with what is done in absence of slots? I.e. in your example attribute is correctly (at least from common sense perspective) set on instance.
I looked it up in docs: &gt; `__slots__` are implemented at the class level by creating descriptors (3.3.2) for each variable name. As a result, class attributes cannot be used to set default values for instance variables defined by `__slots__`; otherwise, the class attribute would overwrite the descriptor assignment. So, not really a quirk, but still feels like this behavior is implementation-driven rather than though out.
That has got to be the least readable font I've seen in body text. That's almost as bad as [this.](http://www.angelfire.com/super/badwebs/)
Don't use slots unless you **have** to. **NO.. BAD** Slots make lots of things really goofy, and you save a few bytes of memory per instance. They aren't faster, they aren't better in any way other than using slightly less memory. If you need to instantiate a trillion objects for some reason, fine, otherwise steer clear.
Wow, thank you for making the magic-removal branch connection for me, that was gold.
Django is popular enough to steal it and have everyone think they always had the pony.
OMG!! PONIES!!
I don't know why, but this reminds me Twin Peaks...
Try opening the site in Firefox instead of Chrome.
Django is so magical that they can do an I-Dream-of-Genie nod and Python Paste never had it to begin.
I expected it to be a video of a dude cutting up a snake. If that's what you were fearing and you came to this comments page before clicking the link, relax, it's a Google Tech Talk, not some dude trying to troll you. I haven't seen it yet (not ready to commit to an hour) so I'm not sure if the image of a cut-up snake is there or not but at the very least you will learn about Python the language or CPython the implementation, and not much about animals, for which there are [other sources](http://www.knowaboutanimals.com).
Alex Martelli apparently does a ton of these talks, but he's quite good, so check it out.
Defaulting to ascii is one of the more stupid things in python 2.x, luckily 3k will default to utf-8.
Mojibake - FEAR!
reddit pony too! .,,. ,;;*;;;;, .-'``;-');;. /' .-. /*;; .' \d \;; .;;;, / o ` \; ,__. ,;*;;;*;, \__, _.__,' \_.-') __)--.;;;;;*;;;;, `""`;;;\ /-')_) __) `\' ';;;;;; ;*;;; -') `)_) |\ | ;;;;*; ;;;;| `---` O | | ;;*;;; *;*;\| O / ;;;;;* ;;;;;/| .-------\ / ;*;;;;; ;;;*;/ \ | '. (`. ;;;*;;; ;;;;;'. ; | ) \ | ;;;;;; ,;*;;;;\/ |. / /` | ';;;*; ;;;;;;/ |/ / /__/ ';;; '*jgs/ | / | ;*; `""""` `""""` ;' 
In all fairness, \_\_slots\_\_ can also be used to detect typos and prevent them from having your program do unexpected things. For example, on the Python dev mailing list they've recently discussed changing the Thread.setDaemon method to a Thread.daemon property. However, one problem with this is that if you call mythread.setDaeman(True) then it will raise an exception due to the type, whereas if you say mythread.daeman = True then it will just silently do the wrong thing. So one option being discussed is defining a \_\_slots\_\_ for the Thread class so as to make that second example an error. So I think your advice is very solid; don't use slots unless you have to. Just keep in mind that there might be reasons other than performance.
Hmm... he slightly misunderstands the situation and changing his default encoding is a bad idea. What he needs to do is to declare the source encoding at the top of the file (which will then cause Python to decode Unicode literals in source correctly).
&gt; using just HTML I don't think 'HTML' means what he thinks it means...
Good call, wonder why that was. The only way it was readable in chrome was to highlight it.
I use text-shadow en masse on Avalonstar, and Google Chrome doesn't fully support that yet, hence the shittiness that you saw. Hopefully they fix that soon. :/
It's amazing how difficult is to do simple programming on windows... 
That was very very informative. I didn't realize that you could use metaclasses to create new classes without a class statement. class MyA(object): x = 5 def xAndHam(self): return "%i HAM" % self.x MyB = type("MyB", (object,), {"x": 5, "xAndHam": lambda self: "%i HAM" % self.x}) `MyA` and `MyB` will function essentially the same (if I hadn't used a lambda they'd be more similar). I don't know when I'll actually have a practical use for that, but it's cool.
Does this actually use it as a mouse/pointer? I couldn't make that out from the post.
Whoa, whoa, hold on a sec. I-Dream-of-Genie? Ponies are nice, but if we're going to be THAT magical, why not just go with I-Dream-of-Djinni?
No, you can do the above with \_\_stattr__ or \_\_setattribute\_\_. Using slots for the above is relying on a side effect that might well change, and isn't explicit (violating the zen of python). Slots messes up inheritance and does all sorts of other nasty things, don't use it.
thanks aaallleeexxx. I didn't know anyone was even reading these, so thanks! There are even simpler ways of doing, without all the optparse nonsense. It sounds like I use it for the same purposes you do. 
Poromenos, I did screw up on the code, it's corrected now. The big story is how the itemgetter solution smokes the others. The secondary story is that playing around with exact details (lambdas vs. functions, etc.) doesn't make much difference. Mostly I wanted to try every solution and variation I could think of. 
That's what I took out of it, I figured you must have had a typo there, and I learnt about the itemgetter function, so overall you got my upmod!
Yeah, it looks pretty nice in FF, rest of the design comes off just fine in Chrome. I still do a little web dev here and there so this is good to know. Oh, and the article itself was great.
Obligatory *I like penis.*
meh, I like *Bewitched* better. /twitch nose
maybe Alex Martelli NOT a native english speaker? 
You can't download an egg of it for some reason, and if you try to build in Windows it fails unless your machine is set up like the dev team's Windows setup. You can fiddle it to get it going though. See https://bugs.launchpad.net/storm/+bug/268151 
You're welcome. :-)
He's Italian, I guess. All I know is, he's great at Python.
&gt; if you try to build in Windows it fails unless your machine is set up like the dev team's Windows setup. That's a standard Python message -- you cannot build extensions with compilers that are not compatible with the Python runtime you're using.
Conclusion?
My conclusion: use demjson if you really really want to make sure everything is right, and you don't care at all about time. Use simplejson if you're in the 99% of all users who want reasonable performance over a broad range of objects, and use enhanced cjson 1.0.3x if you in the came with reasonable json inputs, and you need much faster (10x) speed.... that is, if the json step is the bottleneck. 
Thank you, that's a very useful summary. I'd rather bookmark your comment than the article...
Perhaps, but I don't think that's the key issue. My use case is this: I'm a developer who wants to use this library. I don't want to build extensions - I just want to use the library (as I can do easily with numerous other libraries - wxpython, twisted, etc). Ultimately the fiddling gets it working without the need to build extensions, which demonstrates that the build with Win2003 is not a necessary step. So - I go to download it. No egg. Annoying. So I go and download the source to build it. Try to build it. It fails. Docs are not particularly clear as to why but people on IRC are helpful. There should be no need for API consumers to have to know about this stuff just in order to use a library. The purpose of a library is to abstract complications away from the target developer. The library for an ORM shouldn't require the target developer to have a particular version of Visual Studio installed, or go changing the code in order to install it. That's why I raised the bug. 
I try to be helpful and explain how things work on the Windows platform, and I get a rant in return? Sorry, wrong target. As for the rest, I can only quote the great Perlis: &gt; When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop. 
why would you post this to reddit... are you an idiot
That comparison is by the demjson developer, not really unbiased. There are some controversal things demjson does and some stupid limitations. Most important, everything except simplejson doesn't follow the serlization module interface. Eg, it's module.encode/module.decode instead of the established module.dumps/module.dump/module.loads/module.load. This makes it hard to use the module as drop-in replacement in some situations (eg: sphinx' serilization builders). Furthermore demjson doesn't support processing on streams. You have to load everything into memory which is very problematic if you have a large input. One page two or so the table shows that '42' and '"foo"' are invalid values in JSON as root object. Could be, but I never read that before and the official JSON spec isn't very clear about that. The rest of the examples are pretty much based on special value conversion. For example demjson and others handle user dicts/lists/strings, decimals, complex numbers and a whole lot more (even sets and generators!) that have no expression in JSON. Implicit conversion there (that looses information) is really something very unpythonic and I really don't think a library should do that. simplejson has a hook system for stuff like that where you can register your own types and how you want them to convert which is a lot more clever. Also I think demjson should follow the "be lenient in what you accept and strict in what you send out" principle a bit more. The library is written to be über strict in strict mode which makes it nearly useless (eg: doesn't accept "wrong" whitespace, wrong root elements) for quite a lot of JSON I've seen out there but is far too magical in the lenient mode where it even supports JavaScript elements like undefined. My personal conclusion: there are far too many JSON libraries out there that just do too much (demjson) and I'm very happy that the python developers chose simplejson for the stdlib which is has a good balance of features/strictness/lenientness and a pythonic API. just my 2ct
Never use slots unless you have to! Slots change semantics of Python classes in many subtile ways you don't even think about. This example shows one of the problems with slots: &gt;&gt;&gt; class Foo(object): ... __slots__ = ("foo",) ... &gt;&gt;&gt; class Bar(Foo): ... __slots__ = () ... &gt;&gt;&gt; Bar.foo is Foo.foo True &gt;&gt;&gt; Foo.__slots__ ('foo',) &gt;&gt;&gt; Bar.__slots__ () So far, so good. Both objects have no dict, both objects have one foo descriptor that points to a single PyObject. However, how do you get the slots of an object? Answer: obj.__reduce_ex__(2)[2][1]. That fixes the problem for copy.copy() but not for pickle and other modules that expect a __dict__. What you should not do is `__slots__ = Parent.__slots__ + ('new_name',)` because that recreates already inherited slots. And not only the slot, also the storage for it: &gt;&gt;&gt; class A(object): ... __slots__ = ("a",) ... &gt;&gt;&gt; class B(A): ... __slots__ = () ... &gt;&gt;&gt; class C(A): ... __slots__ = ("a",) ... &gt;&gt;&gt; A.__basicsize__, B.__basicsize__, C.__basicsize__ (12, 12, 16) &gt;&gt;&gt; A.a is B.a True &gt;&gt;&gt; A.a is C.a False There are all kinds of oddities involved by slots, mainly because their descriptors are added after the class is set up normally. This gives collisions if you have a class attribute with the same name as a slot.
Ok, you want it, you got it :) http://writeonly.wordpress.com/2008/09/11/quick-and-dirty-json-speed-testing-in-python/ 
And now I get [all the karma](http://www.reddit.com/r/Python/comments/70wrd/quick_and_dirty_json_speed_testing_in_python/). Oh yeah! :P EDIT: You misspelt my name!
did i? DID I? Yeah, I did, but it's fixed now. 
I also think simplejson is pretty rad... In the applications I use it for, json conversion is one of the bottlenecks (rather than network timing for example), and I have very well-defined / trusted input / output, so I use cjson-enhanced. 
Wow, I really appreciated the in-depth analysis presented in this article
Discussion here: http://www.reddit.com/r/programming/comments/70wjp/prototype_based_programming_in_python/
Quick, dirty, and quite possibly deeply flawed. The profiler's designed for profiling, not benchmarking, and Python code running under the profiler runs a lot slower than usual -- but C code isn't affected at all. To get proper results, use the **timeit** module instead.
Easygui is good, but...you can't really EDIT your windows, just go with the presets. That being said, the only download-worthy app I've made was made with Easygui.
Yes, It's some difficult for me to follow his voice.
Is this going to replace VB Gui hacking software?
effbot's right, but these results match what I've seen as well. One nice thing about demjson is the non-strict mode. I like to use simplejson in a try-block and fallback on demjson. jsonlint is also useful for testing strict correctness. Probably the fastest thing in Python is to 'eval' the JSON within a 'globals' dictionary in which "true", "false", and "null" are defined as True, False, and None. That's obviously unsafe on the web, but it's fine in-house. There is no similar way to dump JSON. In C++, I use jsoncpp, which I have also SWIG'd. That's useful for many applications.
The pgdb module is the Python module I'm using to connect to a PostgreSQL database. I've come from a PHP history, where we used the '$' syntax to include parameters in our SQL. eg: SELECT a FROM b WHERE c = $1 Now, in Python, I can't get the '$' syntax to work, I have to use this: SELECT a FROM b WHERE c = %s The problem with that is taht when porting SQL from one application (our old PHP one) to the new one (in Python), all our WHERE name LIKE xxx code no longer works, as the '%' character signifies a paramter. Has anyone figured out how to use the dollar sign parameter import? Thanks!
Use double %: &gt;&gt;&gt; "select a from b where c = %s and d like '%%like_clause%%'" % ("foo",) "select a from b where c = foo and d like '%like_clause%'" 
The good thing about Python 3 is not that it defaults to UTF-8; it's that it clearly distinguishes between byte strings and unicode strings. Good practice is to specify your encoding on read-in, process the text as a unicode string, then specify your encoding again on read-out. Do NOT rely on the defaults. If you want to use an encoding that can't encode all of Unicode, manually set the encoding/decoding error handlers to replace things with question marks, and it won't crash when given bad input or output. This advice applies to both kinds of Python. In this case, it looks like there were a couple of problems. He may not have declared the encoding of his Python source file, which would mean the unicode string literal wouldn't work properly, since the source code file would be assumed to be ASCII. He also probably didn't have his environment set to `LC_CTYPE=en_US.utf-8`, so when attempting to print a non-ASCII unicode string, Python will barf since it cannot convert the non-ASCII characters in the string. On top of all that, he should man up and put the `u` in front of `"%s"`. I mean, come one, it's one character. Just do it.
via: http://joelhooks.com/2008/09/12/dynamic-upload-paths-in-django/
You're asking for an SQL injection attack if you don't use either an `escape_string` function or the `cursor.execute("select person from people where name=?", (person, ))` format (only available with some db modules, sadly). 
Hmm, which ones isn't it available with? All the ones I know are DB-API compliant and thus support it...
Because when all you have is a hammer...
No, eg. the point about Python being called executable pseudo-code is specific to Python; significant whitespace plays a role in this regard.
I've tried to use EasyGUI before. The name holds true. It's incredibly easy to make forms, however any customization is absolutely impossible. Everything must adhere to the rules EasyGUI sets up, and you can't make your own.
I was looking online at the documentation for `pgdb`, and they didn't list it as possible and their example showed how to use `% escape_string`, but maybe I missed it…
You might want to try with ("query ?", "parameter"), ("query %s", "parameter") and ("query %", "parameter"). Not ("query %s" % "parameter"), though, that's just injectionerrific.
you can threaten people to use the language you like!
There's no such thing as executable pseudo-code. It's either instructions for the computer, or it's instructions to the programmer.
I agree with the author.
There's at least one use-case I really anti-recommend python... statistics and statistical simulation. For people in the stats/biostats world, I almost always recommend R (R-project.org). 
This has less to do with Python than with coins...
That's good to know. I'll see how the results differ! Thanks for the tip.
One of my other frustrations is that python repr() for basic data types is *almost* json, except for single/double quote things. 
Surely you meant, "I'm gnuvince and I approve this message"
Ok Mr. Literal, what andreasvc is trying to say is that when read python resembles what most peoples pseudocode would look like more so than most languages. No one is trying to say that python *is* pseudocode. However, thank you for clarifying that in case a dumbass happens to stumble upon this post. 
Beginning programmers don't think in pseudocode; They don't think in terms of processes and sequences and algorithms. Getting beginners to start thinking in terms of sequences and algorithms is a good thing, but when you frame teaching in this way, you also introduce a ceiling that seem to make it harder for them to learn to think symbolically. Pseudo-code simply isn't valuable to a non-programmer.
That's stupid... what if the question is from someone who already knows Python, or is trying to solve a problem for which another language is more appropriate?
http://rpy.sourceforge.net/ !
I still want one.
It should help them wrap their minds around it instead.
I've got a pretty firm grip on my python right now.
I reran the analysis using timeit. Thanks for the advice... cf: http://writeonly.wordpress.com/2008/09/12/quick-and-less-dirty-json-speed-testing-in-python/
I'll take "Hey, look at this cool thing I made using Python!" over another "Hey, I bet you've never heard of generators!" story.
Not to belabor, but the point is, eventually most programmers do start to think in terms of pseudocode: loops, iterators, named variables, hashes, and the like -- that's part of learning (procedural) programming. So it's a win that python makes the burden of going from *that conceptualization* to working code pretty small, for basic programs. One doesn't have to create a class just for hello_world().
While I would not recommend Python for everyone that asked, I would recommend it for most. Thanks for the post well stated.
I'm with Lexarius. It's nice to see cool things *done* with python, and not just stuff on generators, or threads, etc. And hurray for Stani. H, also, makes my favorite python editor SPE.
Me too, that's why I upmodded it.
Me too, I was thinking of filing an order for one for a second. It looks very good.
It's related to Python. I would therefore suggest that this post is justified, and that you sir are the fuckwit.
Hmm the coin is cool but the disclaimer sucks. Essentially, they will use your address to send information about "relevant activities, sales discounts, services and products" and will also give your address to "selected third parties". If you want to opt out, you'll have to send them a letter (yes, snailmail). It does explain why they want your sex, date of birth, and telephone number. 
... sometimes you *really* wish it actually was the blessed, rustproof +3 Mjollnir. 
I have to say that's what continually puts me off learning Java/C# - who the heck wants to write 2 pages worth of code for HW? Yeah yeah yeah I could use Visual Code Paint .NET or whatever it is that lets you draw programs like Photoshop and it'll write those 2 pages of code for me, but then am I a programmer or a graphic artist? How do you set about debugging code in your own program that you didn't write and have extremely little control over, and thanks to its automatedness is extremely unreadable and difficult to understand what with all those interdependencies out the wazoo? 
see also discussion here: http://www.nabble.com/Not-releasing-rc1-tonight-td19302819.html "Not releasing rc1 tonight" and here: http://holdenweb.blogspot.com/2008/09/python-26-first-release-candidate-due.html 
Well, I guess at that point you may have to *think* instead of rote-repeating something you read on the internet once. 
I think the second-last point is the best one; that you can jump from Python to other languages pretty easily. In Python you can do procedural, object-oriented and functional styles - very few languages support more than one of those. It may not be the best at any of them, but it doesn't pretend to be and that's certainly out of scope in this kind of question anyway. 
does it make anyone else a little sad to see guido hawking app engine so hard?
c
Not to belabor, but I'm going to belabor you. The author said python was *always* the best choice because of a number of points that [webdtc](http://www.reddit.com/r/Python/comments/711ac/what_language_should_i_learn_my_answer_is_always/c05eeuo) pointed out could apply to other languages. [The point](http://www.reddit.com/r/Python/comments/711ac/what_language_should_i_learn_my_answer_is_always/c05eh5w) was that having a language that looked like pseudo-code was the critical feature. I think that teaching pseudo-code to beginners is a bad idea- it locks them into thinking about things in terms of sequential algorithms, and produces a culture of cut/paste code -- *the exact culture* that many python-programmers reject out-of-hand. Are you actually arguing that you think it is a good thing to teach programmers how to use python the same way people are taught how to use Visual Basic?
That's also why it's such a nightmare for programmers to use. Trying to explain to people that their code was bad because it worked on an old version of the python interpreter is a level of smugness you don't usually see outside of the lisp communities. The difference, of course, is that they are right: A book where every page begins with "roses are red" isn't necessarily a book of poetry.
...you're dead broke? ...you could hammer in the morning and hammer in the evening? ...you can't touch this?
Unfortunately, it's ugly as sin. Pity, that.
It looks like a vicious circle—the fear of the 2-page HelloWorld puts you off learning Java or C# and finding out that the HelloWorld is all of five lines long, or maybe 15 if you want a fancy GUI. Go ahead, try it, *(I would recommend C*#*, if it's all the same to you... properties, LINQ, partial classes, less cruft,)* and you just might like it. 
Pros: useful Cons: the dialogs are butt-ugly: http://easygui.sourceforge.net/screenshot-multenterbox.png
a good project for combining the two, but it can be a little frustrating to use if you don't already know R, since it treats many R returns like strings, without the R intrepeter's knowledge of how to format them to make them make sense... A good case of this is the R.summary() function, which in R knows to sort the quantiles in the right way, rather than lexographically. 
Yep, graphic design chops != programming chops. That said, it won, so someone liked it.
I agree w/ kton, if the inputs/outputs of those simulation results need to be piped to other major (for example: graphical) systems...
Why are you people down-modding him? He may not be completely right, but has a valid point. Now, many issues don't need to be addressed symbolically either, and certainly Python does not bootstrap someone to symbolic awareness. But, if symbolic awareness is your goal. Python is not a good launch point. I've gotta admit that I'm weird. I was building dedicated DSP / hardware ray-tracers in the late 80's. That being said: I do like to code up algorithms (parallel and not) in Python before I actually get to the grunt work. For me, Python is *just* a design specification tool. But it works brilliantly, and any performance issues will be worked when reduced to discrete silicon later... CAVEAT: Now, I'm doing a lot more with reverse-engineering of metabolic pathways. I still find it useful to 'prototype' the algorithms and test them in python before going to 'efficient' code later... 
Eating the [bacon](http://www.reddit.com/r/bacon/) makes your hands very slippery. Mjollnir slips out of your hands.
I'm modded down because I'm suggesting python doesn't infact give you antigravity, nor does it magically turn non-programmers into programmers. Whatever. There are a lot of very good programmers that use python. They're just apparently not here right now. 
Python is a very good language. It does not give you antigravity. It does not magically turn non-programmers into progammers. It does not teach you how to behave symbolically. 
It says djano??
I tried Python but I finally gave up on it. I’m in my 40s and just don’t have time to “play” with it. 2 things - * Job prospect - I think we can all agree on this. it’s just so depressingly low and I still haven’t heard a good answer to my very first question I had when I realize how few Python jobs there are: “If the language has all these nice points - why is it that it is NOT widely used AT ALL by the majority of job providers like financial services and mid-size companies etc ?” * Where-TF is Python ????? - I’m in NYC…..probably the most metropolitan area of developed countries right ? I *really* wanted to learn it - but I rather not go the way of “DIY” - so i searched (and searched ....) for training resources….You probably know what I’m going to say - it’s like trying to find a teacher of some fucking long-lost central-Asian nomadic language LOL. Google search result is literaly one page of disappointing results. I’m now 95% certain there’s no colleges with 300 miles of NYC that offer Python class. 80% certain that’s no private training class within NY metro.
Pseudo-code is never purported to be a teaching tool (AFAIK), rather a language agnostic way of describing an algorithm. The fact that python might resemble pseudo-code is evidence for its concise yet readable form.
Balderdash. *Everyone else* on this thread, including [you in particular](http://www.reddit.com/r/Python/comments/711ac/what_language_should_i_learn_my_answer_is_always/c05eh5w), and [the linked article in question](http://gnuvince.wordpress.com/2008/09/11/what-language-should-i-learn/), argued [with webdtc](http://www.reddit.com/r/Python/comments/711ac/what_language_should_i_learn_my_answer_is_always/c05eeuo) that pseudo-code makes python more valuable than other languages specifically *to beginners*. Whatever. I think it was a legitimate criticism of the linked article that all of it's "points" that make python particularly well-suited to teaching programming to beginners are also found in other languages.
I didn't talk about beginners in particular. The difference with other languages is still that Python doesn't have cluttering curly-braces or begin-end pairs, for example. Besides, I think the point of the original article was about being consistent in recommending a particular language to beginners, not about it being the ultimate.
lethain.com, it hurts my eyes!
Honestly, I've never heard of Python training outside of conferences. I think most Python programmers are self-taught. There are lots of local confs, and I bet you could find some classes that way, or post in #python, and see what people say. I have a python programming job, and it's by far the best programming job I've ever had. It's a hacker shop though, which seems to go hand in hand. If found mine through Dice. Also, there are Django jobs around, if you like that app-domain. Or build something using Google App-Engine and go entrepreneur. I didn't learn python to get a job. I learned it replace the perl I used previously, and discovered that I really liked, and I liked programming in it a lot more than in any other general purpose language I'd tried. As for why it's not used in industry... it's not a "safe" language.... who do you sue if something goes wonky? Where do you get 10k python programmers when you need them?!? 
You'll note that webdtc said: &gt; I agree with the article and I like Python, but the reasons given could be applied to many other languages: The same thing could be said about Ruby &amp; RoR, ASP.net and PHP. From the article: &gt; “What language should I learn?” ... is asked by somebody who wants to learn to program and wants to know where to start. ... I shall explain in this post the reasons why I recommend it [python]. The article doesn't say anything about “cluttering curly-braces” or “begin-end pairs”. The article says nothing about being consistent in recommending a particular language to beginners, and nobody said anything about being “the ultimate”. *Here*, in this thread, we were talking about the article, and it's "points" for recommending python to beginners. I can see now that you weren't talking about the article, and you weren't actually replying to anyone's points. Instead, you were simply creating opportunities to talk about how great python is.
I'm so happy [this will be in Python 2.6](http://docs.python.org/dev/library/collections.html#collections.namedtuple). Named tuples can make code a lot more readable - aside from the wacky incantations needed to subclass tuple.
IT DOESNT HAVE A PONY :-(
You could import it from the Python standard library, but then you'd go over 64k.
What PICs/microcontrollers does it run on? You see... this is the point of making languages and their execution environments really, really small and compact.
When I press Enter without entering something, it increases the counter. I preferred the old way, maybe there is a configuration option.
via: http://projects.scipy.org/scipy/numpy/milestone/1.2.0
see also: http://isolation-nation.blogspot.com/2008/09/packages-in-python-extension-modules.html Packages in Python extension modules 
(It's days like this you realize that you're roughly [30 months](http://www.dehora.net/journal/2006/02/just_use_1.html) ahead of everyone else ;-)
well, most PICS/Microcontroller are harvard architecture... maybe you don't know but C is a language designed to be easy to compile in a von neuman architecture (think about function pointers, thats actually impossible on most harvard architecture)... sure there are a couple ANSI C compileres for pic microcontrollers... but rememer that pics have a very, very, very limited memory space... so surely you can build tinypy for any microcontroller... but doing so, will make larger amounts of code than the one generated for a harvard arch... and at that point, you won't have space left for your program... on the other side, there are some nice dsp from the same company... formerly called "_dsPic_"... those use a modified harvard architecture... and are great candidate por running things like this... just download _Microchip C30 Compiler_ (which is actually a modified version of gcc), download tinypy and compile... because, as you may already know, C, is actaully a cross-platform language... (yes, java didn't invent that)... Have fun! 
Thanks, I didn't know that. Which High(er)-Level Language, if there is any, is more suited for a harvard architecture?
Teaching python to an eight-year-old could be a bit ambitious, but I suppose that depends on the nature of the child. A lot of eight-year-olds wouldn't sit still long enough to learn programming. 45 minutes is probably the limit of their attention-span, and that falls well short of the time that needs to be invested to make any headway in programming. I would advise teaching something like LOGO (which I learnt in year 4, which is for eight year olds). That was about ten years ago. LOGO will have most of what you intend to teach in python (loops, iteration, functions, assignment, etc), but the tools are much better, and the syntax is probably clearer - it's significantly more basic than python. If you want your child to eventually have the realistic* option of going in computer science or related fields, I would spend time making sure they are good at mathematics. There's nothing stopping you from spending time on high-school level maths topics, which, honestly, is a strength I wish I had (ie: being better at maths, not high-school maths, I can do those ;)). I'm going to University in a weeks' time to study Artificial Intelligence and Robotics. * By "realistic", I mean doing it well, rather than passably learning php and getting a "web design" job.
well, you are talking about devices with about 14.3 Kbytes (8192 words) for the program and 368 bytes of RAM... surely there is a compiler designed for this kind of devices... but you are missing the whole point... they are risc, are cheap, and fast exactly because of this... they are designed for being programmed in assembly... of course, you can always download a C compiler, which, by the way implements most of the C subset... or one of those "basic" compilers, and play around, but if you plan to do a great job, use assembly... download some application notes, and do it with plain assembly... If you really, really need to use a compiler... buy a dsPic, those are great devices...
I first blogged about Django back in 2006 as well, but today's post is not meant for "early adopter hackers". I consider it the kind of message that managers should read.
Ah thanks for clearing that up, I never did anything with Microcontrollers, and I was confused by the number of Basic and C compilers for PIC/AVR.
Oh, trust me, the post I linked to was definitely written for and read by "managers" and other influential technologists. You're a bit late to the party. (But I don't mind managers reading your post, of course. Just don't claim that you're the first one realizing that Django's a Python killer app ;-)
&gt; But I don't mind managers reading your post, of course. Just don't claim that you're the first one realizing that Django's a Python killer app. Yes, I don't claim to be the first person who realized that Django is a killer app for Python, even though I'd consider myself a relatively early adopter. Today's post took the 1.0 release as a chance to promote things that we hackers have known for a while, to the right audience.
`import goat as pony`
Send the kid outside to play with friends instead. 
See also: http://zerokspot.com/weblog/2008/09/14/pycon-uk-2008-day-2/ http://www.kryogenix.org/days/2008/09/14/enso-presentation-at-pycon-uk-2008 http://orestis.gr/blog/2008/09/13/pycon-uk-day-1/
&gt; It looks like PyPy is coming up to a 1.0 release later this year. Er, PyPy hit 1.0 [last year](http://codespeak.net/pypy/dist/pypy/doc/release-1.0.0.html).
Yes. Writing tiny programs for [fun](http://golf.shinh.org/) is against the law. Every piece of code ever written must have commercial value or else there is no point doing it.
Forth
see also: http://gordallott.blogsite.org/2008/09/14/i-made-an-open-source-fully-free-as-in-the-software-game-in-a-week/ and: http://www.pyweek.org/7/
hey look, I've been watching make and a few other DIY geek builder sites and I've been particularly frustrated by the lack of python or lisp or some other resonably high level object oriented language for cheap small low-power embeddable microcontrollers. ...so the question has nothing to do with insisting that code be "commercially viable" and everything to do with bringing high-level tools down to extremely focused hardware projects.
They're really confident regarding bugs. Check out the bugs/issues page. &gt; It's rather unlikely that tinypy will have any bugs at all &gt; But if you do find a bug, please report it here.
Teach Logo. It's fun.
so they merged ipython1 into the main trunk i hole those bastards haven't killed the notebook interface in ipython1
I can understand your frustration, but you shouldn't assume that everyone else is writing code to serve your needs. The point of this code is not to make it run on your system, it's to have some fun coding. If it also helps you achieve your aims, that's a bonus, but that's not the point. And if it doesn't achieve your aims, perhaps you should you should start coding instead of complaining about the authors not doing what you want.
I'll be impressed when you get it down to 8K. That's about the standard size of a BASIC interpreter on an 8-bit machine.
If somebody already knows Python, we'll find out quickly enough during the conversation and we can point him to another language. It's more probable however, that this person will already know what language she wants to go to next. As for solving a problem for which another language is more appropriate, even if someone comes over and says that they want to program hardware drivers, I would suggest that they learn Python first. Learn to walk before you can crash my kernel.
I didn't see anything in the conclusion about Python being crappy. Comparing an interpreted language to compiled languages on arithmetic performance and calling it crappy is kind of like sending a chess champion into a cage fight with a bunch of folks from the UFC and calling him a weak competitor. There are many important areas where interpreted languages and the chess master are much better. Python should be bench marked against Perl, PHP, Ruby, etc. Other considerations: * 2.3x is not exactly up to date anymore. * This was on a Windows system. 
What's going on? We were told there was a Palin smearpiece supposed to posted next? Well, when it DOES come up, make sure to vote up the person who exposes Palin's extensive ties to Auschwitz, and the fact that Palin tripped Rosa Parks as she got off the bus.
Don't you know that Python code is self-documenting? Python code is just like a Google Chrome comic!
see also: http://ipython.scipy.org/doc/manual/ipython.pdf
Reposting my comment here because the it does not show up in the blog. &gt; The point is, you compare function signatures of Python with function signatures on Java and say that the latter contain more information. Right, they do. But does it make the code that is contained inside the functions more readable? I don't think so, you did leave it out. This argument is a little bit like "Java" has only four letters compared to six letters of "Python" so it is easier to read. &gt; &gt; Your other argument is that lower abstractions make code more readable, which is.. strange. Therefore C should be easier to read than Java, because it does not provide any object abstractions. &gt; &gt; That you find Java code easier to read has a very simple reason. You know Java more than you know Python. I also find Java easier to understand compared with Scala, Haskell or Erlang, but does it say these are difficult? Or take Scheme. Many people find Scheme hard to read but it is really one of the programming languages with the easiest syntax ever created. &gt; &gt;Easy to understand code is not purely because of the choice of the programming language. Take Perl, which is said to be write-only. Clearly, one can also write readable programs with it, but many don't bother doing so if it's only for throwaway scripts. If you ask me, this blogpost is uninformed and oversimplifies. How much you can learn from the return type anyway? I do see problems that Python has and that one can write unreadable code, but this is a problem of the programmer and not the language. The language just makes it easy or hard to do so, and Python *usually* makes it easy to write readable code.
I'm sick of Ponies.
Straight from the heart. With Sphinx as the new "standard" documentation tool for projects like Python itself (2.6 and 3) and Django, it is not as if you have to go hunting for good documentation tools. And with the right Sphinx extension (see down) you can integrate Python doc strings; including doctests. [Sphinx](http://sphinx.pocoo.org) [Include documentation from docstrings](http://sphinx.pocoo.org/ext/autodoc.html) [Wikipedia on DocTest](http://en.wikipedia.org/wiki/Doctest) 
&gt; posted by Christopher W. Cowell-Shah on Thu 8th Jan 2004 19:33 UTC Hmmm. out of date much?
ALWAYS? That is far to strong a word. I always start with what do you want to program for. Once that is answered we can get into details. If you want to program because programmers make big bucks, python is a good choice to get started. Once you know that you should learn a couple more languages. Make sure you take all the science and engineering classes in high school (but skip the programming classes - they are worthless from what I've seen), then go to college... (If you are beyond high school already be prepared for programming to take a few years to click in your brain) If you want to create a game then forget programming. Pick a game engine, and learn that. If your idea is good you don't even need to program as someone else can be talked into that - in fact you will have to as the high level design of most games alone is a lot of work (your ideas are almost never that good, but you will discover that on your own) There are engines for all different types of games, have fun. If you want to create a website you may need to learn javascript, but odds are someone else has already created a widget library that is good enough for you. A python web framework might or might not be useful.
Maybe he should spur himself on to write better exception handling ;) uncaught exception while running onerant.app Traceback (most recent call last): File "/home/sabren/lib/workshop/weblib.py", line 383, in execute self._exec(script) File "/home/sabren/lib/workshop/weblib.py", line 374, in _exec exec(script, self.globals) File "onerant.app", line 18, in &lt;module&gt; from rantelope import * File "/web/script/sabren/withoutane.com/rantelope/rantelope.py", line 23, in &lt;module&gt; import sqlGuru File "/web/script/sabren/withoutane.com/sqlGuru.py", line 7, in &lt;module&gt; db="sabren_guru") File "/usr/lib/python2.5/site-packages/MySQLdb/__init__.py", line 75, in Connect return Connection(*args, **kwargs) File "/usr/lib/python2.5/site-packages/MySQLdb/connections.py", line 164, in __init__ super(Connection, self).__init__(*args, **kwargs2) OperationalError: (2003, "Can't connect to MySQL server on 'db.sabren.com' (111)") script input: form: {'': ''} querystring: cookie: script output: Content-type: text/html
My IDE (Wing) already has this. Highly recommended.
If I find a known key uploaded here I'll purge it from my systems. The reason is that this is a great source of phishing attack. I could go through the uploaded keys, use the comment field, which is often a good email address, and invite the person to log in to their new awesome account with their SSH keys on mynefariouscoolsite.com. This nice, free account will of course log all keystrokes through the tweaked sshd it's running. If I'm lucky they'll upload private keys and type passphrases or use the account to skip to somewhere else and I'll get login credentials. 
&gt; I would advise teaching something like LOGO (which I learnt in year 4, which is for eight year olds). Python has that too, just type: "from turtle import *" and you'll have logo-like functions (penup, pendown, forward, left, etc.).
Whats the benefit over the built-in python omni completion?
Nice; I'll submit an Emacs patch when I find the time. Eclipse+pydev and WingIDE do this stuff quite nicely. I've heard the vim omni-completion for Python is decent, too.
Hi, I'm the author of PySmell. I could never get the built-in python omni completion to work reliably. It was too slow, and was trying to spider my project when I was trying to invoke it. PySmell is pretty fast and it much more reliable as well. It's very easy to install and try out, why don't you give it a go?
I certainly plan to. From reading the docs though, it looks like this is meant to complete individual projects. Does it have support for the standard library, or can I can I create a pysmelltags file for it manually?
Currently analyzing the standard library fails, but for no reason that couldn't be fixed. I plan to change that in the next release, and add an explicit way to use "static", external libraries.
huh, it's still in there and they've wrapped it inside a proof of concept wx app which is awesome
Wing is great - I think its autocomplete is just about the best of any Python IDE I have ever tried. It doesn't use the 'reverse-duck-typing' type inferencing that Orestis is working towards and is one of those simple-but-brilliant ideas. The nice thing about PySmell is that it is a library that can be used with any IDE / code-editor.
Christ, I wish they'd choose another name. [Grok](http://opensolaris.org/os/project/opengrok/) is taken.
As Nat Torkington said in his OSCON keynote "Spawning the Next Generation of Hackers": "No, fuck off. You can do both. You can do both. You can learn to program and you can run around outside. There are 24 hours in a day." http://blip.tv/file/1137045 (around 7:10 for the quote)
I thought of this exact problem, and came up with a solution. I wrote a book (available for free under a Creative Commons license) called "Invent Your Own Computer Games with Python". http://pythonbook.coffeeghost.net Each chapter gives the complete source code for a simple game (Guess the Number, Hangman, Tic Tac Toe, etc.) and then explains the programming concepts from it. I was tired of books (especially for kids) that were just dead listings of language syntax and functions. People (including young adults) want to learn programming so they can do useful things. The best way is to give them complete examples, and then they can work their own creations off of those examples.
http://wiki.python.org/moin/BeginnersGuide There is a large listing of resources to learn Python, most of which are free. The above link also has "for programmers" and "for non-programmers" subsections.
via: http://www.voidspace.org.uk/python/weblog/arch_d7_2008_09_13.shtml#e1012 PyCon UK and Metaclasses in Five Minutes
via: http://tottinge.blogsome.com/2008/09/16/pyfit-madness-day-3/ see also: http://pypi.python.org/pypi/PyFIT/0.8a2 and: http://agiletesting.blogspot.com/2005/01/pyfit-tutorial-part-3.html and: http://agiletesting.blogspot.com/2004/11/writing-fitnesse-tests-in-python.html
Is it fast enough to run in a server side Python script? Or in say Django?
`easy_install` is great if you don't let it fuck with your whole site-packages directory. Just use the 'multi-module' mode always: easy_install -m Foo Then: from pkg_resources import require require('Foo') # or require('Foo&gt;=1.3') import Foo 
I appreciate Simon highlighting stuff on his blog, but sometimes it feels like linkjacking (since he rarely adds substantial commentary). I'm downvoting this in favour of upvoting the actual article. Oh, and I know this is really gst's fault rather than Simon's.
This is good, objective analysis which is often hard to find. I think that adopting the suggested improvements would be good for a 1.2 release, though there would probably have to be some extra allowance to avoid breaking the tag API (a decorator saying "use the new lexer" would be sufficient I think).
This talk of buildout and virtualenv and so forth concerns me. At work, I'm currently working on writing a new network service in Python, and my deployment plan looks something like this: * Write daemon and supporting libraries as Python packages, using distutils. * When the time comes to go live, run: python setup.py bdist_rpm to create RPMs of all my code. * Put the RPMs into a private yum repository accessible to production machines. * Run "yum update" on production machines to install/upgrade new packages. This seems to be a fairly sensible way to go; this is fundamentally the same thing that's worked for RedHat and Debian for a decade or so. However, it involves practically none of the technologies the author of the linked article can't seem to live without. What am I missing here? Is it just that RPMs only work on a subset of possible Python platforms?
Oh well, let's port Hackety Hack to Python now. Has anyone else experienced that Hackety freezes when trying to run the Ruby code? I mean, the idea is nice and using XULRunner is too, but it just does not work for me.
It's because not everyone runs Linux or there might be some functionality that needs a newer package than the one in the repo. I, for one, would love a good package manager for Python since I have some projects that are unrunnable because I don't have the specific required package :/
I cannot for the life of me decipher what the submission headline is supposed to mean.
There isn't anything wrong with that method. However, if you are only working with a single Python package or depending on maybe one or two python packages, then these tools aren't going to be very interesting to you. If your using 10+ or 100+ packages then it becomes a lot nicer. But it's worth noting that Buildout was still made with the idea of creating development sandboxes - Zope Corp still deploys to their production servers using RPMs with aid of an rpm.cfg config to allow them to use Buildout as a tool to help build what they need in their RPMs. 
Arguably Grok shouldn't have taken Grok in the first place. A bit generic ...
It definitely should, but I think Zope is fubared. It's just way too "enterprise". Personally, I stay away from anything that sounds or smells like component architectures.
Large software systems deserve "contracts", including pre- and post-conditions and class-invariants. In a language which supports them natively (e.g. Eiffel or D) these can typically be turned on or off as needed. They also serve as part of the documentation.
This will lead to [SkyNet](http://en.wikipedia.org/wiki/Skynet). Stop Now!
via: http://devhawk.net/2008/09/17/IronPython+Beta+5.aspx
I'm going to need to see some more version numbers before I click on that article 1.0.
the second example is wrong. None does evaluate as False. try bool(None)..
and this http://www.python.org/download/releases/3.0/ 
I'm guessing that user instance evaluates to False also, thus he always gets to gologin() call. Otherwise he is obviously wrong.
Ugh, `cjson`. I will dance when that library dies. It can't read or write astral Unicode, and it won't unescape forward slashes.
Sigh...I'm sure I'll get tons of down votes! BUT I've tried to watch this video 2 or 3 times and that guy's voice is just too damn annoying to me. I usually can get through some pretty bad things...just not this.
I find it basically listenable. 
via: http://www.voidspace.org.uk/python/weblog/arch_d7_2008_09_13.shtml#e1013 Since 2006 I've been working at Resolver Systems creating a desktop spreadsheet development environment called Resolver One. My talk is based on my experiences of testing Resolver One, and I've put it online in article form.
Quite interesting. His examples seem to be written in Python 2. Does anyone know if all of these still apply in 3?
http://code.google.com/p/django-history/
Why not link directly to the article?
So is there a nice write-up of _why_ all these happen? I guess I try not to shadow variable names, but it would be nice to know what's going on.
same here, He is not a native speaker, I am not a native listener. and I got several down votes for this and my bad English writing ...... 
* [django's official website](http://www.djangoproject.com) * it's a web framework. It helps you build websites quickly... you could say it's the Ruby on Rails equivalent for Python.
Introducing a VCS (or, in here, RCS) seems a bit unnecessary where a database already exists.
Mozilla had a much different reason for use of XPCOM -- namely, it's the only way to interact with local resources or do OS-specific tasks, i.e. get stuff done. Also, using an XPCOM object (say, in C++ or, to a lesser extent, Python) is generally a whole lot faster than running Javascript code. No wonder everyone used it. I don't know much about Zope other than what I've read, but their component system seems to be simply a architecture choice that added complexity without many advantages. 
If you're a perfectionist with a deadline, then you should use Django. This isn't to say that you shouldn't use it if you're imperfect and have no deadlines, however.
Django is a great web framework that makes it easy to build a web app/site. There are other frameworks, like web.py and many more but I personally, along with many others have found Django to be the best. Django is well written in that it almost forces you to write good, clean code. As an example, I recoded a PHP-driven site in under a week with a few hours each day. The site is pretty simple and just has some basic retrieval, search, etc. but I was still impressed at how easy it was to do with Django
Very simple to answer. Consider this situation:: class TextToken(Token): type = intern('text') def __init__(self, value): self.value = value def __repr__(self): return '&lt;%s %r&gt;' % (type(self).__name__, self.value) If the class would open a closure the `__repr__` method would try to call the type class variable, rather than the builtin `type`.
How would one go about eliminating these oddities, if one could change the language and would not need to worry about backwards compatibility. 
Say you want to build a web app, and you really like Python over PHP or Perl. Normally, you'd have to write a lot of boiler plate code: code for logging in users, making sure they are logged in, an administration panel, stuff to handle form input, maybe come up with some quaint template system for rendering HTML pages, etc. etc. If you've written a web app before, you could just reuse that code. Django is a framework that already implements most of this functionality that a Python web app will require. It takes a bit of learning to figure out Django, but in the long run it will save you a lot of time building web apps. Django is to Python as Ruby on Rails is to Ruby. http://en.wikipedia.org/wiki/Django_(web_framework) http://www.djangobook.com/en/1.0/
By just doing it?
Um... by downloading the source code and hacking on it?
Django is for creating content management websites. If this is what you want to do, Django is a very popular choice. Why should you use it? This is a harder question, and in some cases the answer is you should not use it. I choose pylons instead, because it seems somewhat more pythonic, but I'm not sure this was the right choice - I just needed to choose something. I'm assuming you already know you want to use python for some reason. Php is most popular, but a bad choice. Java is popular, but too "enterprizy" and thus complex. Ruby is a great language according to programmers I respect. You however choose python, so we can limit ourselves to python web frameworks. There is zope, which is the oldest web framework of all - older than the whole concept of a web framework, and thus doesn't work much like a web framework. There is Django, which is most popular. There is Pylons, and Turbogears (which is different now, but going to be pylons except for one or two things in the near future - Don't see this as a fork as the two teams work together well for the most part). There are a few others, but they are not as popular, and often dead. (in fact most are dead because the authors have choose one of the above) 
Thanks, that's really what I wanted to know!
Testing it in 3a1, I found 1. 2 1 (Same) 2. [1, 1] [1, 1] (Now consistent, but not with the "expected" value.) 3. (['a', 'a'], 'top') (['a', 'a'], 'top') (Now consistent with the "expected" value.) 4. xlocal ytop (Same) 
Bah. I have 3.0rc1 installed, I don't know why I didn't just test it myself. Thanks.
&gt; No wonder that people are turning to web applications. They can use them from both their home and their office, they look exactly the same First he was speaking about integration with the native UI and then he wants them to look the same on every platform? He should love Java Swing or AWT then.
see also: http://www.linux-magazine.com/online/features/django_reloaded_workshop_part_1
Why are all those stuff named after animals? Python, SquirrelFish, TraceMonkey... In this case Python &gt; SquirrelFish. The battle between monkeys and snakes isn't decided yet. 
It's called Jython.
pypy, but let's say that it's from \_\_future\_\_.
&gt; Why are all those stuff named after animals? They want to prevent to get an awkward animal on an O'Reilly cover. :-) 
Or IronPython... neither have the GIL nor use reference counting and both have a JIT. PyPy is our great hope for the future. Psyco has been 'bandaged up' to provide a JIT for Python 2.5 and possibly 2.6, but it isn't a long term answer.
The 'Monkey' part comes from the Adobe Tamarin engine - a Tamarin is a kind of Monkey. Python comes from Monty Python. As for SquirrelFish... WTF???
&gt; The 'Monkey' part comes from the Adobe Tamarin engine - a Tamarin is a kind of Monkey. Python comes from Monty Python. Not really, it comes from SpiderMonkey, the first JS engine ever (and that used by Mozilla until Tamarin)
See also: https://svn.enthought.com/enthought/wiki/MayaVi
I know Python is slow, but it's still faster than Perl http://shootout.alioth.debian.org/u32q/python.php and PHP http://shootout.alioth.debian.org/u32q/benchmark.php?test=all&amp;lang=php&amp;lang2=python , so not all is lost.
Unfortunately psyco is no longer developed and does not work on 64-bit CPU's. It is great to get that 4-100x speed up on 32-bits.
I'm surprised there's no mention of Pyrex here.
Good stuff. This reminded me that I wanted to write-up how to do the same thing, only using Buildout: http://www.bud.ca/blog/how-to-install-python-shell-scripts-with-buildout
via: http://simonwillison.net/2008/Sep/20/release/
Cython is basically an extension of Pyrex, because the official development of Pyrex is pretty slow.
And the costs? Any numbers? 
well done, bring the java feeling back to python ... and of course its either pay for qt or gpl the gpl on the free qt is "stronger" than the lgpl on pythonqt 
Isn't there a contradiction? &gt; B is the minor version number, which is incremented for large yet backwards compatible changes. Code written for Django 6.4 will continue to work under Django 6.5. and then &gt; So, for example, if we decided to remove a function that existed in Django 1.0: &gt; Django 1.3 will remove the feature outright.
&gt; Personally for now I discard the idea to develop with mono. Instead I prefer Python and/or C++, since I don’t like the idea of contributing to Microsoft development ( not to Windows applications, but to applications for the development) and I prefer Free Software. Not that I'm a Microsoft fan but Mono is licensed under the MIT (X11) license and partly GPL/LGPL, so it is about as free as it can get, both licenses are OSI and FSF approved. The presentation is fine, but the uninformed rant against Mono is plain stupid and silly. &gt; However, I suggest you to avoid frameworks as mono and I heartly reccomend to learn C/C++ so that you can make better performances of your project. How often do you need C++ speed to need learning it specifically for this purpose? How about learning ATS? Or OCaml? Or Assembler?
[Search for arguments yourself](http://www.reddit.com/search?q=mono&amp;x=0&amp;y=0)
Yeah, most of reddit and the FOSS world seems to be too busy declaring Mono as the ultimate bad which will crush Linux than just have a look at it. It's easier to spread FUD, after all.
is there a shellscript file-system?
&gt;&gt;&gt; Not that I'm a Microsoft fan but Mono is licensed under the MIT (X11) license and partly GPL/LGPL, so it is about as free as it can get, both licenses are OSI and FSF approved. I know that Mono is Open Source and MIT licensed, but contributing to Microsoft development - I think - it's a really bad choice. Of course, this is my opinion, but I think (since I prefer open source and FS) that using MS development tools is as "incrementing" proprietary software by MS. Then it's my choice. &gt;&gt;&gt; How often do you need C++ speed to need learning it specifically for this purpose? How about learning ATS? Or OCaml? Or Assembler? I understand what you said, but if you read the part above in the post, I've also said that I've never used a program in Python that was "slow". So you don't need always low-level performances. In the case you need low-level language performances, you can learn C/C++ instead of Mono, because for C/C++ there are APIs ( http://docs.python.org/api/api.html ). Bye!
&gt; I know that Mono is Open Source and MIT licensed, but contributing to Microsoft development - I think - it's a really bad choice. Of course, this is my opinion, but I think (since I prefer open source and FS) that using MS development tools is as "incrementing" proprietary software by MS. Then it's my choice. How is it contributing to Microsoft development? If I can run Windows apps on Linux because they are written to use .NET with Mono, I prefer them any time against Win32API programs. So far, there was no single multi-language VM that was FOSS and has caught on. See Parrot, see Neko. Java is effectively only a JVM which is mostly focused on the needs of one specific language. Now there are more and more languages for it, but Tail Call Optimization is not needed for Java, whereas Mono supports it for a long time. That's useful if you want to implement functional languages on the VM. &gt; I understand what you said, but if you read the part above in the post, I've also said that I've never used a program in Python that was "slow". So you don't need always low-level performances. I know. I'd still prefer using Cython to get better performance than use C++. Especially for speeding up small things C or Cython are definitely a better choice than C++. Besides this, Jython and IronPython exist, which allow you to use any code written for the VM for speeding up your Python programs.
I find it fine. Maybe it is harder for non-native speakers of English.
I don't see how JavaScript could replace Python in the future, as the article quotes. How many among you had to chose between JavaScript and Python when developing some app? They're targetting entirely different platforms. And if speed was the primary concern, we'd still be using C or assembly in the first place. That said, it's a neat comparison. Hopefully the improvements in JS performance can be used to tune Python as well.
What would that do?
I like it too, but I was joking about his pronunciation of "basically."
&gt; Hopefully the improvements in JS performance can be used to tune Python as well. The idea for the Javascript performance was basically taken from Python (psyco) and/or Java (HotSpot). It's not a new idea, it just has a lot more marketing behind it (Google Chrome) than Python does. I'm looking forward to the results when he retests with psyco.
$1
Oh... :-)
I like how the native MD5/SHA functions are some 100 times slower in Python than in C :/ God bless Cython...
Funny how the answers are dominated with major, well documented Python features...
Databases don't automatically version information. While numerical fields can be handled reasonably well with audit tables, large text fields are different. Using a VCS allows you to do more sophisticated merge handling to resolve concurrent edits (which are themselves more likely with large text fields). In addition, sometimes part of your app is already maintained in a VCS (think CSS styles, for example) in which case this is better than trying to co-ordinate import/export routines.
via: http://www.learningpython.com/2008/09/21/textwidget-01/ 
New version: 0.2.1, released 21 September 2008. http://home.gna.org/py-notify/ 
Seems like it could make some stuff much more trivial. 
true, but still useful to have them listed in one page
See also: http://alicebob.cryptoland.net/quivi-10-released/en/ Quivi 1.0 released 
not really, if you don't know these you need to lurk moar. I mean, verbose regular expressions? (that one isn't even python-specific); comparison chains?; generator comprehensions?; decorators?; parallel assignments? These are supposed to be "hidden" features? Holly schmolly edit: the step argument to the range operator as well, or doctests, seriously how are they hidden?
sadly, many frameworks as gtk think they are the center of the world, meaning they will control the main loop and they won't be deffered in another process/thread. This has a really bad impact when you have many subsystems that each needs a *kind of* main loop. in a word : good link althought it is not the end of it. 
Sounds like a job for Continuations!
See functions gobject.MainContext.pending and gobject.MainContext.iteration (glib.MainContext will work too with SVN). That is a way to plug GTK+ main loop into other loops. Also, you can plug different event sources into GTK+ using custom GSource, though support for that in PyGObject is quite rough.
Personally, I'm astounded at the fluency with which Alex M, Thomas Wouters, GvR, etc speak the English language. Granted, some of them have probably been speaking English for longer than I have, but I know plenty of non-natives that have trouble. Alex M: "It's the cat's pyjamas for debugging."
Variables. Python has variables, allowing you to reference values. For example: a = 1000 creates the value 1000 and binds variable a in the current scope to it. 
This is a good example of why I am trying to stay away from stackoverflow Also stuff like this: http://stackoverflow.com/questions/113655/is-there-a-function-in-python-to-split-a-word-into-a-list
Of course, there you would do: import re filter(None, re.compile('(.)\\1').split(re.compile('.').sub(lambda x: x.group() * 2, 'Word to split')))
Shit, I've been doing it wrong this whole time! 
[You too?](http://stackoverflow.com/questions/101268/hidden-features-of-python#113706)
Objects. Python has objects. For example: a = (500).__add__(500) Creates an integer object with the parameter "500" and adds another similar object to it. Python lacks non-objects.
Please post that and enlighten them
I'm the author of Cobra. I've added a lengthy response over at the original article to clear up some things. Since the reddit discussion here is focused on Mono/.NET, I'll include the last portion directly, which is relevant to the thread here on reddit: Sun has taken note of Microsoft’s mantra regarding multi-language support and has also taken note of the popularity of languages such as Python and Ruby. Consequently, they are hosting a “JVM Language Summit” (http://openjdk.java.net/projects/mlvm/jvmlangsummit/) which I will be attending this week. My goal is to get Cobra running on JVM as a peer platform so that developers can choose the VM that’s right for them. Volunteers are welcome! I’m also interested in targeting other back ends such as Objective-C (for native Mac and iPhone applications) and possibly Parrot, which will be presented at the JVM Language Summit. Over the past several weeks I’ve been slowly but surely refactoring the Cobra implementation to pave the way for other backends. -Chuck
Lol, I posted that one earlier today. (Miguel Pérez is my RL name.)
cool - stackless and twisted are fairly dense, but pretty powerful. This is a good post.
Stackless has very little in it: just the `stackless` module with a couple of central things. Twisted, on the other hand *is* indeed fairly dense.
I'm myself put off by the style this fellow uses. Spaces padding parenthesis?!
OMG, I thought the title said "sackless." XD
&gt; but why not just write "__new__" when blogging about it? Simplicity or sloth. But the article misses the opportunity to talk about class methods -- and doesn't even mention that `__new__` is a classmethod. IMHO, it's much more clear to use classmethods to combine init and new, and has the wonderful benefit of conveying intention to the client programmer: class MissileLauncher: @classmethod def fromSpareParts(cls, name, parts): obj = cls(name) obj.assemble(parts) return obj @classmethod def fromContractor(cls, name): obj = cls(name) return obj Edit -- spelling.
Not using mechanize makes scraping harder than it needs to be.
I much prefer httplib2 when using Python. But more importantly, TFA says he extracts data using readlines() and regular expressions.. Why do that when you have BeautifulSoup?
Sometimes it might be easier (well, the only example I've found is epguides.com, which has this huge &lt;pre&gt; block with all the text).
You bastard, I spent 15 minutes pasting all that in a file and prettifying it, and now mechanize does all this and more! Well, thanks for the tip, I guess...
Yeah but usually you do your text munging after getting the relevant element, and I rarely reach for regexps (let alone `readlines()`) as my first tool when screen scraping.
Well, for the epguides.com example getting the element wouldn't really be that beneficial as the format is really specific and found only in that part of the page. You just use readlines() to get the page text. Or is that read()? Come to think of it, it's probably page.read(), so yeah, what the hell does he need lines for?
I use a combo of regular expressions, and BeautifulSoup (the latter mostly for extracting tables more easily). Regular expressions are quickest and easiest for most cases; there's so much utter-utter garbage HTML/encoding issues out there even the lovely BeautifulSoup chokes sometimes. Mechanize &amp; zope testbrowser are pretty cool and I use them for some testing, but for my scraping use cases I have not found them helpful (i'm not spidering, usually); though i guess now that I think of it if you do a lot of that horrific ASP "viewstate" stuff, the Mechanize approach of submitting forms could ease the pain. Some percentage ASP/viewstate pages are partially entirely run by javascript however. Some I have seen even generate have hidden forms with the viewstate which get populated with other data via and posted via javascript in an onclick event. Nasty stuff to manually try to sort out. I started playing around with crowbar, an xulrunner based server that you can send a URL and have it dump you back the gecko serialized DOM. You give it an optional delay parameter to let it (hopefully) complete running any scripts trigged after onload. However I found crowbar not to be reliable (the http server locks up after a while for some reason). Then I discovered [pykhtml](http://paul.giannaros.org/pykhtml/), which wraps the kde3 khtml renderer conveniently in python (via pykde). It's a bit awkward to work with for someone like me not knowing pyqt/pykde, and not wanting to be trapped in the pykde event loop, but I managed to wrap it in an http (and xmlrpc) server so that I could drop it in as a replacement for crowbar. I run it headless in a minimal vnc server (as I did with crowbar). Works great so far, though is a bit heavy... so I only use it for sites I absolutely need to. In conclusion, depending on your needs, there are a vast number of scraping techniques and most of them are still useful in different situations. Use them all! 
A lot of this resembles why I left GAE months ago. It really looked promising, but it's obvious they are trying to appeal to short term developers, rather than people who want to make a stake in using it as a long term platform.
via: http://vnoel.wordpress.com/2008/09/23/enthought-python-distribution-now-with-basemap/ 
So all he did was try code snippets individually? That's not much of a hint...
I have run into an issue where Beautiful Soup sucks up too much memory constructing the tree for the whole page when all I need is a couple pieces of data from it. In that case I found using a regex to pull out out information. I had not heard of Mechanize though, it looks like a nicer package for some things I ended up writing on my own.
I have a VBA script run in excel which scrapes all of the nfl.com team players it then goes to fftoolbox.com to scrape all of the rankings it then goes to sportsline.com to get all of the injury reports. I run the macro once a year and then about 10 minutes later I walk into my fantasy football draft with my killer information...
Nice. Next year try adding ADP info. I offer XML and CSV formats on my fantasy football site: http://fantasyfootballcalculator.com/adp.php
Thanks! This just got on my Delicious page, nivek.
This a pretty useless post. Doesn't offer any insight at all! "So I tried code snippets individually, and I kind of figured out where the problem might be. I'll have to look some more.." Gee, thanks for the hints.
I've come to the conclusion that GAE is essentially Guido's project to keep various concerns at Google "happy" that he is working on something "related to Google." I bet he spends 90% of his cycles on Python and 10% on GAE. You can see why he would have a vested interest in making sure the service does not become popular ;) But IMHO Python will be fine whether Guido spends 10% of his cycles or 90% of his cycles on it. It is too bad that Google has taken such a short-sighted approach to his work - he is clearly one of the most talented leaders in software, and if he had a dozen programmers working for him he could rip up any sector of the software industry at all - finance, CAD, anything on the OLPC. I suspect that the core problem is a lack of leadership at the top---at least Bill Gates had vision. Brin and Page seem to me to be fairly poor leaders who lack a genuine interest in software.
"and doesn't even mention that \_\_new__ is a classmethod" From the article (after explaining that \_\_init__ is an instance method): The method responsible for creating objects is a class method called \_\_new__.
This is awesome
In Perl: `print __LINE__;` 
What's the point of a named lambda? It's unpythonic to save a line just for the sake of saving a line. 
Couldn't you use pdb?
Thanks for pointing this out. I've updated the info, as I was mistaken with the second example. I was using the Google App Engine API, and when the second version didn't work, I thought I was evaluating None incorrectly. I've updated it to show the one wrong way, and three ways which all work.
It's handy for code golf and not much else :D
Then what about such situations: class Foo: def bar (x): pass a = Foo () Foo.bar (a) giving you no less confusing error message that 'bar expects 1 argument, but you specified 0'. (Note that I omitted `self` as suggested in TFA).
That works for me (no error), as I would expect, but you do have a point, you can pass any class instance directly to a class method and have it execute on that. I don't know if this is a bigger benefit than making "self" a keyword, because in any case you would do a = Foo() Foo.bar(a) doing a.bar() is much shorter and sane.
Of course it works for you with current Python. It would give an error if `self` was implicit as TFA proposes.
Ah, right. Well, I'm not very convinced that the use case you showed is that useful, and I don't know of any case explicit "self" is necessary (maybe decorators?).
Sure, this is probably used 100 times less often than 'normal' method invocation. Still, this is explicitly allowed by the language (methods being just like functions and all that). Most commonly it is used in subclassing to invoke super method, though `super()` is probably the preferred way. However, with multi-inheritance I'm not sure if it is possible to do away just with `super()` and without such explicit invocations. What I was trying to say, while explicit `self` would fix exception message, it would also break it in another case, even if much more rare.
&gt;Hadoop + Python = Happy - Happy Well shit, I'm not even going to try it then. Happy - Happy = Teh Suck
Well, you could fix that by allowing the 'implicit self' to be passed explicitly in unbound methods. 
Isn't that what I did? Or is there a misunderstanding here? I mean, currently a method has N + 1 arguments with N being 'real' arguments and 1 is for explicit `self`. When calling it as a bound method, you pass it N arguments and 1 additional (`self`) comes from binding the method. When calling it as unbinded method, you pass all N + 1 args. Now, since you need to pass different (N != N + 1) number of arguments when issuing bound and unbound calls, no error message about argument number could possibly be 'correct' and non-confusing in both cases. Unless, of course, at the point where error message is issued, you can differentiate between calling as unbound or bound method.
"Unless, of course, at the point where error message is issued, you can differentiate between calling as unbound or bound method." Python could differentiate - which is what I was saying... (bound and unbound methods are different types with different implementations of '\_\_call__' - so no reason that they couldn't be differentiated). We could also make 'cls' a keyword for class methods in the same way that 'self' would be for instance methods. We're starting to create a lot of new keywords though.
Yup. And also that point about inner classes. When you are free to name `self` as you wish (using `self` is only a convention, right?) you can refer to outer `self` by naming inner one differently. If `self` were to become a keyword, you'd not get away that easily. E.g. Java uses OuterClassName.this, but in Python this would obviously require a different solution. All in all, this looks like too much hassle (even if for solving corner-case problems) to me. And gains are doubtful. 
That's odd. I searched the article before making the claim. If I missed it, I apologize. 
But that messes up one important aspect of dynamic programming in python - bound methods are not any different from normal functions. Nothing stops you from defining a new function, calling it as a normal function a couple of times, and then making it a bound method of an object. class a(object): pass def hi(self,a,b): print self.__str__() print a+b hi(1,2,3) &gt;1 &gt;5 aa = a() aa.hi(2,3) &gt;traceback... AttributeError a.hi = hi aa.hi(2,3) &gt;&lt;__main__.a object at.... &gt;5
I'm with you. The problem I have with the setuptools ecosystem is that I can't put my finger on the problem I have with the setuptools ecosystem. It *seems* like goop. That's the best I can come up with, but I'm certain I could find real things to dislike if I read the code for comprehension. (BTW, have you ever peeked? It's pretty sloppy looking). Oh, and the names kill me. On the one hand, it's `easy_install` but on the other hand, it's `ez_setup`. Consistency fail. 
Do you have any idea how much work it takes to make something like google app engine? This is probably a dozen man-years of effort, minimally, to get it where it is now.
Maybe I have this problem because I'm a bit of a Python noob (so feel free to enlighten me on anything I get wrong), but what I don't like about this is that the calling object is only available in a method call, and not an attribute call (unless you use `__getattribute__`). For instance, I have a Profile class with a name attribute already defined and used throughout the view (this is using Django btw): class Profile(models.Model): user = models.ForeignKey(User, unique=True, verbose_name=_('user')) name = models.CharField(_('name'), max_length=50, null=True, blank=True) I want to modify this so that it gets the name values from the User object. Ideally, since I don't want to mess with all the calls to profile.name in the view, I wish I could do something like: name = self.user.first_name + " " + self.user.last_name Which seems not only easy but also straightforward. However, the calling object isn't available to me in an attribute as it is in other languages, so instead I'm having to add the following: def __getattribute__(self, attr_name): if attr_name == "name": return "%s %s" % (self.user.first_name, self.user.last_name) else: return models.Model.__getattribute__(self, attr_name) Which works, but it seems obscure and makes it difficult to someone else glancing at the code what the interface profile.name refers to. That's why for me it would make sense to have `self` as a reserved word and have it available in the context of calling attributes in addition to methods. I'm probably not seeing the value in how it is configured in Python now and there could be a better way to accomplish what I'm trying to do, so as I said I'm happy to be enlightened by anyone who knows better.
Well in Python 2.6 you will be able to install to ~/.local/lib/python2.6/site-packages as per PEP 370: http://www.python.org/dev/peps/pep-0370/ But lots of people have needs beyond per-user package sets. pyinstall let's you capture a snapshot of the package set (including version information!), archive that, and reproduce later. 
In your example, user and name are defined as attributes of the Profile class, not of a Profile instance. Instance attributes are normally created in the ____init____ method. In your class definition, name is a models.CharField object but when you access the name attribute of a Profile instance, it's a regular python string. The same bit of code is being used to define a schema and to create attributes/methods of an instantiated object bound to a database. ORMs such as Django are inherently a little tricky if you're new to a language because they have to use a bit of trickery to achieve their purpose. In you case, btw, you want name to be a computed property.. define it like: class Profile(models.Model): @property def name(self): return self.user.first_name + " " + self.user.last_name
I'm glad I brought it up, because I learned a lot from your reply. This makes much more sense to me now, since I was at least dimly aware that foo = bar in a class definition was setting a class rather than instance attribute. Thanks!
Seems like a lot of work for: rm *.sql 
&gt;I am French. My english is far from being perfect. The Packt team did a great work on improving it, but you will probably feel my french touch in the book. I hope you won’t mind. 
Also with [virtualenv](http://pypi.python.org/pypi/virtualenv) you get something similar to per-user installations, except one user can have many installations, which is a much nicer abstraction. I've thought of proposing it as a core Python feature, but I don't have the stamina for the resulting Python-dev discussion.
I **love** itemgetter/attrgetter. [I even blogged about it.](http://www.bockris.com/blog/2008/04/16/operator_itemgetter/)
In my experience most non-native speakers who apologize for their English speak it better than 50% of the people I meet on the bus.
It's not a matter of explicit being better than implicit. It's a matter of not-magic being better than magic. Explicit self enforces a symmetry between functions and methods that would be lost otherwise. Yes, that symmetry is broken by having implicit self when you actually make the call... but a little bit of magic is ok for something as common as that. I mean who actually wants to type "self" every single damn time he calls a method?
Good question--I think that gst is a bot, so it doesn't know better.
I wasn't into Django until I heard there had been a 38th edition of "This Week in Django". Now I'm all about it.
Surely there's a better place to submit this crap. Digg?
&gt; pje is a better programmer than I could ever be. I doubt that... &gt; But code being good doesn't imply that the code is necessary. ...because you've already been able to figure out this! 
yo, brotha' totally agreed.
I don't understand why the author is trying to avoid lambdas so hard - in my opinion the version with lambdas is much more readable.
via: http://www.webadminblog.com/index.php/2008/09/24/w3af-a-framework-to-own-the-web-owasp-appsec-nyc-2008/ see also: http://www.computerdefense.org/2008/04/14/installing-w3af-on-windows-xp/ 
In the function definition a minus sign is missing: zeta(2) = sum(k^(-2), k=1..infinity)
Well - itemgetter / attrgetter are about twice as fast for one thing.
maybe http://blog.haydon.id.au/2008/08/notes-on-practical-django-projects.html helpful.
Couldn't agree more. I recently started work on web app using CherryPy and the Cheetah templating system. I have found this to be an extremely efficient and powerful combination - both components stay as out of your way as possible and in just one hour you can be proficient enough with both to throw together some really nice products. CherryPy FTW!
What's the reason? Serving web pages is about as parallel as you can get, why do we need something based on stackless?
I had some problems with cherrypy and large downloads. Maybe I misused something, or maybe it was a problem but has been fixed. Other than that it has been delightful. I can create a web app far faster in python with cherrypy than I'd have to contemplate with java + servlets + tomcat + etc. The smaller structure means you can back it up far easier than a java development stack. 
I've been running my blog as a custom cherrypy app for about 3 years now, with 1 crash ever (I needed to change one line in my config when I upgraded). I love it.
Yes, more hugs and kisses for CherryPy. All of my tool building is done as shell scripts and mini-web apps done with CherryPy. One file with one page of code gets you a JSON server/consumer. Add jQuery, Mako templates, and sqlite for a slick little app. Swap sqlite for postgresql for an industrial app.
that NamedTuple recipe is crazy. For us mere mortals, I use this one: def named_tuple(names): class NamedTuple(tuple): pass for i, name in enumerate(names): setattr(NamedTuple, name, property(itemgetter(i))) return NamedTuple 
Then you have communicated nothing.
qw(F PD AD D TD ED ABO) and Perl is supposed to be uglier than Python?
see also: http://linil.wordpress.com/2008/06/14/cairoplot-plotting-graphics-using-python-and-cairo/
I don't know, he may have a point. The latter does involve less typing, and fewer flow-breaking single-quotes. 
a FRENCH guy who both admits that his English isn't 100% AND lets NATIVE SPEAKERS edit his writing. Very impressive indeed. I have quibbles with some of the content of chapters 2 and 3 (if I meet anyone whose code depends on MRO I will go out of my way to slap them upside the head with a wet fish) but this book looks like it has lots of useful and thought-provoking content.
Type once, read *forever*. Any decent text editor with syntax highlighting will make the first example much, much more readable.
You need to get a good text editor. What you want is to be able to type the latter, hit type either :MakeVector() or m-x make-python-vector depending on your fancy. Code gen FTW.
Okay, you got me there. Macros for the win.
Cool idea. Totally insane nit-pick: &gt; Delight therefore enforces a single style: one Tab character per indent level. Anything else and the compiler will reject it. No. Tabs lost this battle. At the last two places I've worked there's been an svn pre-commit hook to enforce this. Just stop with the tabs. We hate them. And we are legion. etc. and so forth.
much ado about nothing?
But this is what make perl not as elegant as a language. Besides qw you have qq, qr... tons of keywords. Probably the only feature I miss (i.e. in perl not in python) is the regex syntax. (e.g. $a =~ /[abc]*/)... 
See also `__FILE__, __END__, __LARRY_WALL'S_BIRTHDAY__`
Seriously, this is why the REPL was invented. Go to your terminal window. Type `"blah blah blah".split()`. Highlight the resulting, `["blah", "blah", "blah"]`. Copy. Paste into your source code file. Anyhow, is it even worth reading the blog of someone for whom Python 2.3 is new? I mean, what the hell has he been doing for the last four years?
Being a productive programmer? I can see where he is comming from. I learned python when is was at version 1.5 I never kept up with the additions because I could do everything I needed to "the old way". I've just recently started trying to force myself to actually use more of the newer features.
Well, it's when you have to use `qqrdqbqrqtqqqcdqqqq使它停止qq()` that it gets ugly.
via: http://blog.poundbang.in/post/51806295/getting-stack-trace-from-a-running-python-application 
What if you want to change or extend the once-generated list? That's where just-in-time generation comes into play: instead of the dataset one can change the algorithm.
How large of downloads?
For a real-world example of an event-driven Python program, check out Nick Welch's [whimsy](http://incise.org/whimsy.html), an X11 window manager. I've found the code to be quite eye-opening, being a new Python programmer.
Meh, Graphication looks nicer: http://www.aeracode.org/projects/graphication/
This is not surprising considering all the work Microsoft is doing on the functional F# programming language, a variant of ML/OCaml. Since F# is fully supported for .NET and Visual Studio, it makes sense that functional paradigm features such as lambdas, closures, syntax extensions, sequence expressions, etc are finding their way back into C#.
Awesome, they've almost caught up on *some* of the features Python had years ago. Nevermind it's still cluttered with static typing, interfaces, XBOX-sized class hierarchies, and general enterprise bullshit. On top of that, it's a proprietary, non-standard, non-portable technology from no other than Microsoft (I pity the fools that believe it is open just because Icaza, in his stupidity, is trying to make it seem so, until the day Mono becomes half useful and Microsoft decides Mono is over).
I stopped reading at 'yield return start'.
Too bad, the rest of the stuff was pretty interesting. The extra 'return' was added because yield was not a reserved word in previous versions of the language and they didn't want people's code to stop compiling when they upgraded their compiler. 
If the tool does not fit your use-case, then don't use it. I find it difficult to fathom a genuine reason to log in and leave such a comment. Obvious troll is obvious.
via: http://ironpython-urls.blogspot.com/2008/09/spider-python-some-notes-on-ironpython.html 
What use-cases would you suggest where C# is worth it?
There was a great moment where at PyCon during a section of Guido's keynote on indentation, an aging hacker intoned in a deep voice, "GET RID OF TABS!" And there was much applause and cheering. Guido agreed in principle, but unfortunately there appear to be some hurdles...it wouldn't hurt to keep beating the drum once in a while to convert the few remaining tabbers.
A company that writes business applications where either: * The company already has an investment in the Microsoft platform (i.e. servers and workstations, pre-existing code base, third-party .NET SDKs, etc) * The clients expect to run the applications on Windows specifically (with no cross-platform requirement) * The applications require integration with other Microsoft applications (e.g. Office, SQL Server) In this case, I would find C#/.NET more pleasant than the other Microsoft alternatives (VB/.NET, managed C++, unmanaged MFC/w32). Additionally, while some of the code could indeed be written in a non-MS language (like Python), the .NET framework will handle a lot of the Microsoft-specific integration with less complexity. Going back to the article, what does C# being proprietary and non-portable have to do with the fact that, as a programming language, C# is evolving to include more functional-paradigm inspired language features, which are generally conceded to be useful features for languages like Haskell and Python as well? If someone is using C# because it fits their use-case, wouldn't it be a good thing that they can now use functional and higher-order constructs to improve the quality of their code and their enjoyment in writing it?
&gt; The company already has an investment in the Microsoft platform (i.e. servers and workstations, pre-existing code base, third-party .NET SDKs, etc) And you're going to fix a mistake of being locked-in to a specific platform (let alone a proprietary, ugly one) with more lock-in? &gt; The clients expect to run the applications on Windows specifically (with no cross-platform requirement) And you're going to give them less for the same price just because they didn't ask to get the right thing (as in, portable)? &gt; The applications require integration with other Microsoft applications (e.g. Office, SQL Server) Agreed, a valid use-case. Yet neither of these three use-cases justifies using a lower-level, static-typed language when you can use something much nicer even on Microsoft's proprietary, lock-in .NET platform. If I had to do something like your third use-case, I'd try to use IronPython, IronRuby, IronScheme or anything like that, unless I'm explicitly prohibited from having fun writing the code and maintaining it more easily. And in the case of performance being critical, C# is not the fastest choice either. &gt; what does C# being proprietary and non-portable have to do with the fact that, as a programming language, C# is evolving to include more functional-paradigm inspired language features, which are generally conceded to be useful features for languages like Haskell and Python as well? Not much other than the fact it feels kinda useless to me for the above mentioned reasons. &gt; If someone is using C# because it fits their use-case, wouldn't it be a good thing that they can now use functional and higher-order constructs to improve the quality of their code and their enjoyment in writing it? Of course! Do not misunderstand me: right now I'd rather do C# than Java. (But I'd rather do neither.)
&gt; C# has Lisp-like macros! Wait, what? So does this mean Paul Graham is going to be switching over to C# in the near future? Is there someone out there that is fluent in both C# and Lisp who can comment on this revelation?
$100?! I love python, but I don't $100 love python.
I didn't really stop reading. I just kinda balked at it as being fairly clumsy.
C# is defined by ISO/IEC 23270 (passed before the OOXML debacle) and EMCA-334. It's quite portable thanks both to de Icaza's work on Mono and GNU's work on dotGNU. Static typing isn't always a bad thing, and "general enterprise bullshit" is, well, bullshit. Even Java could not say as much until very recently: it was a very proprietary language without a standard. The fact that its default compiler and runtime are now under the GNU General Public License doesn't change the fact that the language is still not specified by an actual standard (just a reference implementation). You can't write a new Java compiler/runtime without inspecting the behavior of Sun's. You can do that with C#.
As before, C# isn't lock-in. It's a language, one with a specified standard. You can write a compiler for it without looking at Microsoft's work--not that you would, but GNU has (it's called dotGNU, as I mentioned before, and it leaves out the Windows.Forms bit that is in Mono). Typing is typing. It doesn't matter in the long run whether a language is statically typed or dynamically typed. Outside of the zealotry of a few, nobody gives a damn. Now, if it's Microsoft you're worried about, I might remind you that they've got a pretty big stake in a good number of Open Source/Free Software projects, including Python, Haskell, and yes, even Samba. I'm coming to learn that the Evil Empire isn't fractally so: it's just a few old farts at the top that haven't caught on yet (Ballmer, I'm looking at you).
http://www.pythonworks.org/PythonContext An interesting detail is that it uses Python 3.0.
I wrote [something like this](http://bazaar.launchpad.net/~gnome-terminator/terminator/trunk/annotate/566?file_id=debugserver.py-20080807043052-zxxllbhx98ylmn7l-1) for [Terminator](http://www.tenshu.net/terminator/); it can run a minimal telnet server in a thread to allow you to poke at the interpreter while it's running. I can't say I've actually used it for anything, but it was fun making it.
Typical college class costs many times that amount. Not to mention the text book.
&gt;Passing in "spiderTracker.FoundUrl" instead of "lambda url: spiderTracker.FoundUrl(url)" results in an extremely unhelpful runtime error. Sorry, but this is absolutly the same.
&gt; As before, C# isn't lock-in. It's a language, one with a specified standard. With widely available implementations: Windows 2000, Windows XP, Windows Vista... hey, it's multiplatform! Yes, there are some attempts to implement portions of the language, but people are probably going to use all the Windows one has, and the Mono folly won't be able to catch up, or will be kicked away anytime. They did this in the past with other technologies, and will do it again with every single one of them. &gt; Typing is typing. It doesn't matter in the long run whether a language is statically typed or dynamically typed. Outside of the zealotry of a few, nobody gives a damn. What? Even the *design* of a dynamically typed program can be radically different from a statically typed program, and the code is pretty different (immensely simpler and more flexible in the dynamic counterpart), especially if you don't have type inference. &gt; Now, if it's Microsoft you're worried about, I might remind you that they've got a pretty big stake in a good number of Open Source/Free Software projects, including Python, Haskell, and yes, even Samba. Er... again, what? Microsoft doesn't have any power over Python, nor it has contributed at all. They're only spending pocket change on an implementation of Python for .NET. They're investing in Haskell, but AFAIK they don't influence the community either, other than the bucks they can use to put pressure on them. And Samba? This is like Mono: they'll try to screw it up by changing their closed protocols every few years. They're not on Samba's side; they're *opposed to* Samba. Yet Samba's implementation of their crappy protocol is so much better, faster and smarter than their own it's not even funny. A handful of free software developers had their ass handed to them, and it's not the first time this happens. (Not just to Microsoft; that's pretty common with "enterprise" software in general. As a general rule, the more "enterprise", the shittier it is.)
&gt;With widely available implementations: Windows 2000, Windows XP, Windows Vista... hey, it's multiplatform! Yes, there are some attempts to implement portions of the language, but people are probably going to use all the Windows one has, and the Mono folly won't be able to catch up, or will be kicked away anytime. They did this in the past with other technologies, and will do it again with every single one of them. Mono has kept up. That's just it. Most C#/.Net programs run without much trouble on Mono. What's more, if I were to take a Java program, most people will use the Windows version. Or have you forgotten that the Common Language Runtime doesn't ship with WinXP or basic forms of WinVista by default? &gt;What? Even the design of a dynamically typed program can be radically different from a statically typed program, and the code is pretty different (immensely simpler and more flexible in the dynamic counterpart), especially if you don't have type inference. And 90% of developers can deal with different software design patterns. And does the end user really give a damn whether I wrote the program in Python, C#, or COBOL, as long as it works. MS's contributions to Python are in the form of employing two developers on a part-time basis for CPython and one full time guy for IronPython. That's about par for the course: Google only has one employee working on Python itself (GvR), and Sun has two working on Jython. Most of the rest of Python development is done by hobbyists or non-giant companies (Red Hat and Canonical come to mind). In any case, the only company that holds much influence over Python is Google, and that's simply by virtue of signing GvR's paycheck. Microsoft is no more or less evil than any other company in the industry. They're just bigger than everybody else*, and they have a couple of assholes in high positions. *Google's cooperated with the Chinese to imprison dissidents. So has Yahoo! Sun's got a lot of useful stuff under GPL/BSD incompatible licenses. Apple is Apple, and if I have to explain their evil, someone isn't paying attention. Novell's in bed with Microsoft on a few projects. Canonical isn't all Free Software, and neither is Red Hat. IBM is still a bit more heavy handed with their mainframe business than they should be. The only difference between any of those companies and Microsoft is market share. Half of them have committed the same crimes that Microsoft has, and for the other, it's only a matter of time. Man, I can't believe I'm *defending* Microsoft.
I once tried porting an application from Python 3.0rc1 to a beta of Visual Basic. It didn't work. Visual Basic is obviously crap. *headbutts desk* 
And they're just as overpriced.
The classes are certainly over priced, but the ROI on a book of this nature (on the assumption that it is as advertised) well eclipses the sticker price. It's what, an hour or so at a standard contract rate? It depends on what value you place on knowledge I guess.
You mean things that are GC'd get closed! OMG! 