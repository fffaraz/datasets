 import sys _handlers = {} def register_handler(exc_type, func): _handlers[exc_type] = func def handler(exc_type, exc_value, tb): _handlers[exc_type](exc_type, exc_value, tb) sys.excepthook = handler
Nice, didn't know about sys.excepthook. Thanks. Makes my project alot easier than I thought.
Would it not be simpler to just sub-class the Exceptions?
I rather not have the user write my code into their code. I don't like tightly coupled code. Also if a builtin exception is raised, how is it helpful that I created a subclass of it? b inherits from a. Since b is further down the hierarchy, it cant point to a but a can point to b, since a's stuff is also in b. Since a can point to b, if b is thrown you can catch it with a.
I was going to say that their decorator was a bit too complicated and non-pythonic. 
lol, I posted that on Reddit a few hours ago.
I got an error. Should be easy to figure out http://i.imgur.com/GM3Rk.png
I guess you don't like TCP then :)
i feel the same way about 'timeout' and 'sleep'. yeah, practically they can solve your problem. but they still feel pretty damn dirty
Here's a nice [intro to decorators](http://www.artima.com/weblogs/viewpost.jsp?thread=240808) blog post if anyone is needs a bit of context on them.
Yea I got it to work using twisted. I created a factory dictionary to hold the current connections. That allowed me to broadcast. Now Im considering switching to C++ because of the sizable scalability/performance boosts.
The real funny part is that you don't even need the parens. The comma is the operator: bercilak:~ kobold$ python ... &gt;&gt;&gt; 3, (3,)
I prefer decorators implemented as Class. I find it easier to understand, as compared to decorators implemented as wrapped functions. What exactly do you find non-pythonic in it?
You can do it. The object doesn't get passed to the \_\_init\_\_ of the decorator class, but it can be gotten by writing your own \_\_get\_\_, which will end up getting invoked when the method is called as part of the descent through the decorators to get to the actual underlying function/method. See http://wiki.python.org/moin/PythonDecoratorLibrary#Memoize for an example.
I agree. The idea of implementing a class whose instance is a callable is more intuitive than defining functions in functions (often several layers deep). But (as unpythonic as that idea seems), to each his own.
Why manipulating bytecode makes you parse source twice?
maybe not non-pythonic, it's just more idiomatic to do it as a closure.
Out of curiousity, what's your objections with paste? I personally find the .inis annoying but find webob to be extremely handy.
&gt; gleam in Adrian Holovaty's eye FTFY 
I found that Flask become a bit cumbersome when you attempt to create multiple apps and integrate them together. Perhaps I was using wrong but I had a lot of trouble trying using it's [module](http://flask.pocoo.org/docs/api/#module-objects) functionality. I've since determine that microframeworks work well when you separate the mega-app concerns and the micro-app concerns. When I say mega-app concerns, I mean common things like authentication and authorization, sessions, etc. These are things that are managed on a global application scope. Every mega-app concerns are passed to the micro-frameworks by the WSGI environment. H:: # Some hypothetical application wide auth&amp;auth module from auth import authorized, BasicAuthMiddleware from myflaskapp import blog_app from mybottleapp import events_app from from frontcontroller import Front class AuthenticateMiddleware(object): def __init__(self, app): self.app = app def __call__(self, environ, start_response): if authorized(environ['REMOTE_USER'], environ['PATH_INFO']): return self.app(environ, start_response else: start_response("401 Unauthorized", []) return "Permission Denied" # Here's some hypothetical front controller application = Front({"/blog": blog_app, "/events": events_app}) application = BasicAuthMiddleware(AuthenticationMiddleware(application)) This approach is the WSGI way™. It makes it so that you can integrate any WSGI app regardless of what the framework is. Unfortunately many micro/mega frameworks make it hard to do this. 
BTW, I'm using Basic auth not because I'm advocating it over session based auth, it's just the easiest to demonstrate what I mean.
Yeah partly the .ini :). It's been a while, so if I remember correctly, I also found some nuissance regarding forced usage of .egg files. Making version control, and deploying a pain. Sadly, I don't know if this is true anymore. Webob is fine, but so is other request/response models i.e. [the models in werkzeug](http://werkzeug.pocoo.org/documentation/0.6.2/wrappers.html).
http://docs.python.org/library/time.html#module-time * time.daylight -- Nonzero **if a DST timezone is defined.** * time.timezone -- The offset of the local (**non-DST**) timezone If you describe what you're trying to accomplish, perhaps I can suggest a solution. Time in Python can be frustrating.
Keep in mind, time.daylight is non-zero if in DST which is not the offset in hours, it should be treated like a boolean value to say you are in DST or not, its up to you to know the offset (which is usually 1 hour by coincidence).
I have a feeling that Pylons extended the python deployment functionality to far. It's really nice to be able deploy an app using setup.py when you have a dozen sites using the same code. It feels like overkill for my one off blog. The initial stuff also feels dirty. It's nicer to do:: from mypylonblog import make_app from sites.myblog import config application = make_app(config) 
[Python timezone management kind of sucks, but it can be patched up somewhat](http://blog.mfabrik.com/2008/06/30/relativity-of-time-shortcomings-in-python-datetime-and-workaround/)
I need to be able to get a local time tuple down to the minute and the hour offset from UTC at any given instant. If the system time zone changes, time.timezone and time.daylight are not updated on Windows. In Linux, I believe the solution is to just run time.tzset before checking the values, but there appears to be no equivalent on Windows.
FYI, it's interesting to compare Python to how Erlang handles clock changes during runtime. http://www.erlang.org/doc/man/erl.html search on "immediately reflect"
That's a really neat approach, but it doesn't quite address the issue I am having; in my case, I am only worried about adjustments to local time. I will definitely keep that approach in mind for later though. A wrapper to the time module using time.clock as the basis to provide that kind of functionality could come in handy.
You could use time.gmtime() and time.localtime() and just subtract them.
time.localtime is "immune" to Windows time zone changes; when the time zone changes, you have to reload python or it yields in incorrect value.
Thank you for this!
Tried that. I lot of it is about small details in python or small problems ppl have with it.
Thx! That helped me a lot :)
Don't use mod\_python, it's dead and burried. If you want to start with Python take a look at mod\_wsgi and a framework like Django or a microframework like Flask.
that might explain why I can't find any info. 
http://blog.dscpl.com.au/2010/06/modpython-project-is-now-officially.html
Thanks to you for showing me this, and the author. I'm just getting into Python and this is a godsend!
I'm not sure the Module system is meant for wiring together different apps a la Django (if that's what you meant). It's more just for arranging the views in a single app. You could think of Flask Modules as (very roughly) equivalent to controllers in Pylons or Rails; a way of grouping views together with common URL prefixes, before/after handlers, etc. 
To be more exact, Adrian and Simon Willison: http://www.quora.com/What-is-the-history-of-the-Django-web-framework
Python Magic!
I recently started a project on python with web2py. I come from a Java/.NET/ColdFusion background with one US top 50 website under my belt (architect and principle engineer) and picked python because of the productivity/performance ratio and to help move more prototype projects onto GAE. So far I have enjoyed the web2py framework and find the docs in great shape. The magic did cause some confusion for me and I can see it causing some headaches in debugging. But overall it seems to be a fairly productive framework if the model is laid out correctly. The GAE datastore restrictions are a bit tricky - but NOSQL tends to be a bit painful regardless. Interesting discussion up until a point.
My brother is doing some C as part of his civil engineering course and asked me to look over his code, he'd used this: while (valid_menu = true) I'm very much in agreement that it's a "gotcha" for newer programmers but it took all of 60 seconds to explain how that worked and problem solved.
yeah, that's why I think I was using it wrong.
Numpy can be used with PIL to manipulate pixels, and scipy.ndimage has a number of image processing functions.
This is good advice. Specifically, check out couchdb and couchdbkit. As to frameworks, I don't get all the fuss - they are tools for different tasks. Engineer around your data, choose your libraries and datastore based on that. Unless the purpose of this practice is to learn a specific framework, then choose one that doesn't force you to define your data models its way. 
Read again. `time.daylight` is a boolean indicating whether a DST configuration exists at all, not whether you are currently in it.
Whenever you use stupid templates, like those in Django, in the real world, you keep running into obstacles and situations where the toolkit is actively working against you and preventing you from getting stuff done. For example, Django has a something called csrf tokens, which are extra parameters sent with all post requests to make cross site reference attacks slightly harder. However, when trying to create a form inside a template tag, the context object, (the thingie that, among other things, generates csrf tokens) will be unavailable, making it impossible to create valid post forms. I keep running into these stupid artificial limitations whenever I use Django templates, it's easily one of the parts about Django I like the least.
| is bitwise or in C as well. "C" or is ||
uhhh, isn't this just websockets? Why didn't they use the websocket's interface? It looks like they created a whole new namespace for their thing but they basically used the same API. I'm confused.
Most likely this is an issue of documentation. Pylons never forced anyone to use .egg files. You might have thought it did, because setuptools is not documented very well, and the default paster templates emitted by Pylons made use of setuptools. But at the end of the day, Pylons doesn't care. It just needs your code on the PYTHONPATH.
We get pretty close in Pyramid (Pylons' successor): from pyramid.configuration import Configurator from pyramid.response import Response from paste.httpserver import serve def hello_world(request): return Response('Hello world!') if __name__ == '__main__': config = Configurator() config.add_view(hello_world) app = config.make_wsgi_app() serve(app, host='0.0.0.0') This is the simplest possible Pyramid app (no setup.py required, nor any Paste, etc).
I'm not sure that's true. Are you saying that `5+2i==5-2i`?
Depending on exactly what you you are doing you could run a new process with python -c to get the timezone.
Thought of that one [already](http://stackoverflow.com/questions/4360981/make-python-respond-to-windows-timezone-changes) actually. I think ctypes is a bit nicer though.
I assume you meant 5+2i==5-2i. No, that's not true. But if you take any valid system of equations with i in them, and you replace all the i with (-i), the equations will still be valid. You can't do that with positive and negative real numbers, though. (-1)(-1) = 1 But if you interchange -1 and 1, you get (1)(1) = -1 which is not true. Redditor [Mark Dominus](/user/mjd/) wrote about this on [his blog](http://blog.plover.com/math/i.html) a few years ago.
&gt; I assume you meant 5+2i==5-2i. Yeah, fixed &gt; But if you take any valid system of equations with i in them, and you replace all the i with (-i), the equations will still be valid That's what I did, isn't it? I took 5+2i=x and replaced -i as 5+2(-i)=x Which gives `5+(-2i)`, which gives `5-2i`. Assuming that `x` still equals `x`, then `5+2i = 5-2i` &gt; Redditor Mark Dominus wrote about this on his blog a few years ago. That's quite a good article. On reading that, is it correct to say that `5+2i ≠ 5-2i`, but equal or not, they are not mathematically distinguishable? **Edit** on reading it again, it's not quite that simple. Thank you, you've given me a fine list of evening reading :)
U : tension (exprimée en volts, symbole V) ; R : résistance (exprimée en ohms, symbole Ω) ; I : **intensité** du courant électrique (exprimée en ampères, symbole A). 
Every number has a real and an imaginary root, yes. 
Nice idea. But I would NEVER execute a script that looks like this. Why compress a script in the age of broadband connections and infinite disk space for a reason other than obfuscating?
**tl;dr** Some Django guy says stupid template languages are better because they prevent the developer from writing complicated templates. Armin says stupid template languages are stupid and defends Jinja2, which is smart.
I found django confusing so tried web2py and it is much easier to pick up. Best things are: 1) Everything works independently - database, forms, templating, auth, validation. When you are learning you can just pick one thing to focus on. Once that is working you can move on to the next feature. Even better they work together really well so you end up using just web2py. 2) Documentation is excellent with loads of simplified examples with minimal code. Brilliant. Wish other tools did this. Not aware of any that do it so well. 3) If you have a problem then MDIpierro seems to answer every question on the google web2py forum personally! And whilst he is an enthusiast his posts are always factual, informative and helpful. 
Oops. I accidentally b0rked the script over the weekend. As you sent this a day ago, you may have the broken script. It should be fixed now. Sorry :( I also outlined the installation procedure in the README. I still need to update the docs though... :/
it's not *really* self-extracting, it just includes a little python script that knows how to execute the extraction program. If you don't have a bz2/zlib extractor installed you're still out of luck.
bz2/zlib are both part of the python standard library. No need to install anything.
Which however is not possible for filters which is annoying. Instead of this: {{ user.register_time|dateformat }} I have to do this: {% format_datetime user.register_time as register_time %} {{ register_time }} Why? Because this statement is used in an i18n block and format_datetime needs the context to figure out the user's timezone automatically. The only argument to the filter is already used for the time format. Fun.
I really enjoy reading Armin's blog posts. They are always very opinionated, but sometimes I wish he would be a bit clearer. Thanks for bottling that up for us.
Thank you for the comments! I admit to being a bit of a reddit newb, missing your suggestions for almost two weeks, and certainly not understanding why this got 6 down votes. Anyway, I appreciate the good pointers.
very informative. looking forward to the next one. 
Been developing django apps for around 2 years or so, and really haven't ran into this being a huge limitation. Sometimes it's annoying, sure. I've also had to use Genshi for the past 6 months, and I will happily take Django's limitations. The nonsense I've seen in Genshi templates make me beg to deal with a CSRF issue like you mentioned.
Cool, I'll have to look into that
You have to be either crazy or complete idiot to use smart template's capabilities for core/business logic. If you feel tempted to do so with STLs, you are doing it wrong. Smart template engines are smart for a reason and that reason is certainly not using it for core logic. I'd be more tempted to implement core logic in django template tags/filters, (edit cont.) which is pretty much the same, except for the different scope of implementation.
When picking apart someone else's blog post in your own blog, it is generally good form to provide a link to the original article, so that people can easily go read it. Since Armin didn't provide such a link, here is the [original article](http://pydanny.blogspot.com/2010/12/stupid-template-languages.html) and here is [Danny's response](http://pydanny.blogspot.com/2010/12/reactions-to-stupid-template-languages.html) to Armin's post, among others (with links).
&gt; The biggest annoyance I have with smart template languages (Mako, Genshi, Jinja2, PHP, Perl, ColdFusion, etc) is that you have the capability to mix core business logic with your end views, hence violating the rules of Model-View-Controller architecture. This isn't a great argument. If people want to shoot themselves in the foot and write bad, unmaintainable code, an intentionally crippled templating language like that of Django's isn't going to stop them. edit: Spelling/grammar
I like the power that comes with Mako or Jinja2, smart template languages allows me to mock up some ideas very quickly. Yes I do understand with great power comes great responsibility. 
&gt; You have to be either crazy**, a complete idiot, or a php developer** to use smart template's capabilities for core/business logic. If you feel tempted to do so with STLs, you are doing it wrong. FTFY
In the (admittedly limited) experience I've had with Django templates I haven't felt particularly limited, but I'm leaning more and more toward integrating Jinja2 anyway. This post makes it all the more likely that I'll give it a try, if only so I have the details down when I really need it.
What's the advantage of a templating language over just writing stuff in whatever language you're using to generate html? I understand the need for separating concerns but I don't like html in general.
&lt;3 I just took my *Zend Certified Engineer* thingy from 2004 off of my website because someone told me the other day that I used PHP and I laughed at them saying I didn't. Then I okayguy'd the crap out of, "but you're Zend certified, it says on your website."
Do I understand correctly that you are attempting to access a python variable from a PHP script? Hang on...let me go read your link.... Ok, I'm back.... How are you calling the python script from PHP? 
Sure. That's what we did. It's just that in a perfect system, the templating language wouldn't be trying to purposefully work against me and make stuff needlessly harder just because. There are ways around all the limitations in Django. In the extreme cases, you can always just prerender an entire html snippet in the controller, though I've never had to reduce to such idiocy. But I don't run into these kinds of issues in e.g. Rails. On the other hand, I have yet to see anything as extensible and pluggable as the Django ModelForm/autotemplate framwork when it comes to whipping up mostly crud-like data entry. It does it's thing amazingly well. 
When I see it happen is usually later in a development cycle, a request comes in or some UI restructuring and it could be implemented deep in the code or in the template somewhere, and the template is much easier (sometimes only because the person fielding the request handles the templates and not the core code). Sometimes the person making the request isn't even sure it's what they want, so the solution is hacky so they can give the person a preview of the result. Then the code is left like that. Sometimes that's even a good compromise -- the UI person might need to move forward, maybe you want to make some functionality accessible through the templating system, maybe it's unclear what is simply complicated UI logic and what is business logic (and maybe the UI logic drifts towards greater complexity over time). It can be a form of code debt, but taking on code debt is sometimes the better investment.
What I've resorted to on one such occasion is {{ my_time | i_wish_i_were "Y-m-d" | an_oscar_meyer_weiner "gmt+1" }} It is of course a thing of utter perfection. You are welcome to gaze in awe.
How does either option result in less html being generated? Anyway, the advantage of templates is you can have one data source generate very different rendering of the same data and with a simple templating language you have nice mostly-html for the designers to play with or a few template tags for you to throw in their html.
I don't know anything about interacting with PHP but in python a variable you assign to is local unless you declare it global. x = 5 def foo(): x = 10 def bar(): global x x = 20 print x foo() print x bar() print x Prints: 5 5 20 
I can get whatever I print out from python back as a variable in php right now, so I'm fine on that front... what I need to figure out on the python side of things, is how to print out that "filename" variable. $command = "C:\Python26\python.exe \"C:\Abyss Web Server\htdocs\exec2.py\""; exec($command, $output); Then in the php I'm able to use $output as an array and it'll contain whatever I print from the python script. Basically all I want is to print out that variable called filename in python. But so far the script doesn't execute when I try messing with it in that way.
Wrong. you need to install python. All I'm nitpicking about is that "self extracting" usually means that the archive requires no external data/program/library to extract itself, which is clearly not the case here. All this provides is the small convenience of "run archive = extract", which isn't all that different from "right click -&gt; extract"
From what I can tell, rorrim.py isn't a script, it's a module. AFAIK it's not normal to be using Python modules from within PHP. You'd be better off finding something written in PHP that does something similar.
You're `exec2.py` script needs to... import rorrim # create instance of Asset object myasset = rorrim.Asset( blah, blah, blah ) print myasset.get_filename() # this will show up in $output [a1russell (below) makes a good point](http://www.reddit.com/user/a1russell)
This can be handy: `curl script_location | python`
when I said I hate html, I meant I hate writing html. I'd rather have function that generate html in whatever language I'm coding in. this should help me generate different renderings from the same data source without having write code in html. I guess I can see the value if you have a designer who knows only html. But as a developer, I don't want to write in both perl/php/python and html (or whatever templating language I use) if I can avoid it.
how is: print "&lt;html&gt;&lt;head&gt;&lt;title&gt;hiya&lt;/title&gt;&lt;/head&gt;&lt;body&gt;hello " + name + "&lt;/body&gt;" or: &lt;html&gt; &lt;head&gt;&lt;title&gt;hiya&lt;/title&gt;&lt;/head&gt; &lt;body&gt; hello &lt;? echo $name ?&gt; &lt;/body&gt; &lt;/html&gt; less HTML than: return renderTemplate("hello.tmpl", {name: name}) hello.templ: &lt;html&gt; &lt;head&gt;&lt;title&gt;hiya&lt;/title&gt;&lt;/head&gt; &lt;body&gt; hello {{name}} &lt;/body&gt; &lt;/html&gt; It has to go SOMEWHERE
I know this is gonna sound really dumb, but what should go where "blah, blah, blah" is?
exec probably..
Yeah I wasn't too thrilled to be using python either as I have more experience with php, but for what I wanna do (make a cache of whatever url is entered), rorrim's module seems to be the best tool available that I came across.
why not just write the python variable out to stdout (hack) "print filename".. u can capture std out in an array with exec .. something like exec('script.py', $output); print_r($output);exit; and then parse the array in php.. Speaking as a php/python dev.. just drop your whole php app and do it in python/python framework, faster neater and way cooler ;) Hope that helps
&gt; but then the whole script won't execute. Seriously, did you ignore the error message and stack trace, or just decide that it's not important enough to tell us. ...zomg. Is it a *secret?*
I don't mean write out html by hand. I meant have a function that would generate them instead of a templating language. Something like perl CGI: print header(); print start_html("MY TITLE"); print "hello $name"; print end_html(); etc. This is is an oversimplification, but you sort of get the idea. I can also write functions to group together commonly used functions to simplify my life. And I can stick with one language (the only html is in the perl CGI library which I don't have to maintain). 
I'll try to be constructive now. Two things: PHP has eaten your brain. You really need to learn another language. It doesn't have to be Python, but something else. I'm not even suggesting that you use the next one outside of learning it, but if all you know is one language (especially PHP or BASIC), then you're going to be a bad programmer forever. Yes, the problem is probably simple. Python will tell you what the problem is, if you'll listen. Talk to it, not through some thick haze of web-browser + web-server + PHP-module + your-program. Just run it already. What does it say? (This is rhetorical. I'm not asking for the answer.)
Your values for: source, destination, level, link_types, mime_types, user_agent
Yeah I was reading on Globals and tried this: if self.mime_types.has_key(content_type): filename = hashlib.md5(self.source).hexdigest() filename += self.mime_types[content_type] global outputfilenametophp outputfilenametophp = filename return filename else: return False Then towards the bottom of the file, where I was able to print to php earlier, I try: print outputfilenametophp or global outputfilenametophp print outputfilenametophp and the script doesn't execute at all.
Put the global declaration at the top of a function right after the def line. Don't put it at the top level (zero indent) of the file. Other than that I don't know. The purpose of global is to let functions change module level variables. I have no idea how you get at python data from php.
Because you have to create an instance of the Asset object and call the get_filename() function before that global has any value..... Also, you may need to wrap your setup &amp; calls to the rorrim stuff in a if __name__ == '__main__': block in your exec.py file to cause it to actually be run. 
He's doing a reasonable cross-process way of passing data. Having php's `exec` call python and parse the script's output is a typical method. However, it's very *very* slow. 
This debate caught me entirely by surprise. Is there anyone who would disagree that the view needs to pass the absolute minimum data that the template needs, and the template should have enough logic to decide what goes where? I love Django to bits, but seriously, Django, not being able to do 'for item in items.order_by("-date")' in the template itself is a serious buzzkill. Why do I need to calculate it on the view and pass it, when I already have an items queryset there? The ideal, for me, would be Django templates with a bit more allowance for logic. That's the reason why I try to use Jinja2 or something else whenever possible, because this constraint actually couples my view to my template **more**. What's the logic in having me calculate a variable in the view which is only required by that specific template, rather than give the template enough freedom to request whatever it wants from the view? Obviously you need to exercise caution, otherwise some people will try to calculate everything in the template, but some people are idiots.
Better late than never... The functionality is in win32serviceutil and used through the handlecommandline call. 'epycron.exe install' will install the service.
&gt; Is there anyone who would disagree that the view needs to pass the absolute minimum data that the template needs, and the template should have enough logic to decide what goes where? Yes. Me.
 &gt;&gt;&gt; ll = [['aa',100],['bb',50],['cc',25]] &gt;&gt;&gt; sorted(ll, key=lambda x: x[1]) [['cc', 25], ['bb', 50], ['aa', 100]] You can also sort in place, using ll.sort(key=lambda x: x[1])
or... &gt;&gt;&gt; from operator import itemgetter &gt;&gt;&gt; l = [[1,2],[3,4],[5,6],[7,0]] &gt;&gt;&gt; sorted(l, key=itemgetter(1)) [[7, 0], [1, 2], [3, 4], [5, 6]] &gt;&gt;&gt; 
it is easier is you have two lists: x = ['aa', 'bb', 'cc'] y = [100, 50 , 25] #sorts both lists by y x = x[y.argsort()] y = y[y.argsort()] 
I am already dreading this discussion, but go on...
I wrote my own about a year back in C++ with boost.spirit (I know this is /r/Python, but I do both and I guess this is relevant). I feel it's a pretty good mix between the two - it's basically just variable replacement, with a bit of extra support for conditionals and for loops and dictionaries and such. From what I know about Django, it basically does the same sort of stuff, except mine is a real stack based parser (as opposed to using a bunch of regular expressions, which last I read anything about Django is what they did). It supports real operator precedence and stuff like that, which regular expressions can't do easily. Below I'll put some examples of some of the things it does, sorry if it's too long or nobody cares. I thought it might be interesting as it's sort of Pythonic (at least in the way it handles dictionaries and lists), and I'm proud of it :P I might open source it someday if I have the time. }}# This is a comment and won't appear anywhere. {{"te\"\tst"+" end"+-5}} 5--5 is: {{5--5}} 5-"string" is: {{5-"string"}} 5*"hi " is: {{5*"hi "}} "hi "*5 is: {{"hi "*5}} "hi "*0 is: {{"hi "*0}} 5/5 is: {{5/5}} Here's a null value: {{__null__}} Here's an undefined value: {{ __undefined__ }} 100/0: {{100/0}} (5+(2/3)+(3*2)/1): {{(5+(2/3)+(3*2)/1)}} More modulus fun with equality operator, (0 == 10%2): {{(0 == 10%2)}} Testing comparison operators. 1&lt;1: {{1&lt;1}} 1&gt;=1: {{1&gt;=1}} 1==1: {{1==1}} 1!=2: {{1!=2}} 1&gt;__null__: {{1&gt;__null__}} 5*true: {{5*true}} (5+(2/3)+(3*2)/1): {{(5+(2/3)+(3*2)/1)}} Operator precedence, 5/4*3: {{5/4*3}} (should be 3.75) Operator precedence, 5*3/4: {{5*3/4}} (should be 3.75) Operator precedence, -2+5*3: {{-2+5*3}} (should be 13) Testing logical, 1&amp;&amp;1: {{1&amp;&amp;1}} Logical negation. !true: {{!true}} Logical negation, !!true: {{!!true}} Logical negation, !!!true: {{!!!true}} typeof([ "list item a", "list item b"]): {{typeof([ "list item a", "list item b"])}} typeof([ "dict a": 0, "dict b": 1 ]): {{typeof([ "dict a": 0, "dict b": 1 ])}} [] (printing a list): {{[]}} ["a", "b","c" ]: {{["a", "b","c" ]}} }} SET mylist = [ "a", "b", "c" ] # should be no output. Test grouping (5 + 5): {{5+5}} Test grouping -(5+5): {{-(5+5)}} Test unary grouping: !(true) {{!(true)}} Test unary grouping: !(true == true) {{!(true==true)}} Test grouping -(5+5): {{-(5+5)}} }}# Set some really crazy dictionary with a bunch of stuff with newline escaping. }} SET d = [ \ "a": [ \ 0, \ 1 ], \ "b": [ \ "5", \ "6" ] \ ] # This is a comment about the statement. }}# And now print it. {{d}} Length of a string with member "test".length(): {{"test".length()}} consecutive_unique("tteesstt"): {{consecutive_unique("tteesstt")}} unique("tteesstt"): {{unique("tteesstt")}} sort([ "c", "b", "a" ]): {{sort([ "c", "b", "a" ])}} percent(50, 100): {{percent(50,100)}} [ "a", "b" ] + [ "c", "d", "a" ]: {{[ "a", "b" ] + [ "c", "d", "a" ]}} }} IF 1 }} SET STATIC blah = "blah!" }} END blah (static set): {{blah}} 
yeah, nice work with the ctypes calls.
&gt; Is there anyone who would disagree that the view needs to pass the absolute minimum data that the template needs, and the template should have enough logic to decide what goes where? I agree
That's why I wrote "C-esque" and not "as in C". :-) 
You're right. Instead of fighting with php for the benefit of not having to learn something new, I decided to just do away with php altogether and do the whole thing in python. Thanks
Django filters are an awesome idea made half way useless by arbitrary restrictions. Why can you only send a single argument to a filter? Why can't a filter access the context? There types of restrictions make it impossible to e.g. do automatic date formating based on the users locale without jumping through hoops. Sure, everything is possible, but when you spend more time fighting the template system than coding, you know something is seriously wrong.
Since PEP 3003, the Moratorium on Language Changes, is in effect, there are no changes in Python's syntax and only few changes to built-in types in Python 3.2. Development efforts concentrated on the standard library and support for porting code to Python 3. Highlights are: * numerous improvements to the unittest module * PEP 3147, support for .pyc repository directories * PEP 3149, support for version tagged dynamic libraries * PEP 3148, a new futures library for concurrent programming * PEP 384, a stable ABI for extension modules * PEP 391, dictionary-based logging configuration * an overhauled GIL implementation that reduces contention * an extended email package that handles bytes messages * countless fixes regarding bytes/string issues; among them full support for a bytes environment (filenames, environment variables) * many consistency and behavior fixes for numeric operations * a sysconfig module to access configuration information * a pure-Python implementation of the datetime module * additions to the shutil module, among them archive file support * improvements to pdb, the Python debugger 
Exactly. I think Django templates would be much improved if they'd just allow calling, then you could do: {% mystring.upper()¦myfilter(3, somevar) %} Then again, if you're going to allow calling, just make filters functions and call them on things.
&gt; classes, because then they cannot decorate methods (due I don't know what you mean by that. To my knowledge `*args, **kwargs` is going to work the same whether you use a class or a function as the basis of your method.
But why not use _l_ for the speed of light?
I agree, it wasn't confusing to me when I learned BASIC. But that's probably because I learned BASIC before I learned algebra. :-)
It's called idioms. Please do everyone a favor and take the time to download a dictionary of them into your positronic brain, Mr. Data. You wasted half the shift last week scanning the ship for the cat that caught Mr. Worf's tongue. 
Because / is for divided-by.
Sounds like you want HAML.
I'm squarely on the fence in this debate, but willing to play devil's advocate. In particular, Bayer doesn't elaborate on the following: &gt; It's my experience that non-trivial projects using such systems virtually always bring forth situations where HTML needs to be stuffed into concatenated strings inside view logic - areas where some intricate interaction of tags and data are needed, or even not so intricate interactions. His and Ronacher's posts spend a lot of time critiquing Django templates, but not having a strong preference toward one templating language or another I'm left starving for examples. The "you could shoot yourself in the foot with any tool" argument also seems to be equivalence fallacy that may hold weight with Django but not in general. Moreover, allowing code in a template does seem to be advantageous if it cuts down on one proper vector for abuse and you can't conceive of cases where it's truly necessary.
This is one of the best packages evar!
The example is, some component needs to write out an intricate &lt;table&gt; based on some domain-specific structure. If you're using JSP or something, you'd use taglibs. Taglibs mean, hey I'm going to write a Java class that takes my data structure, spits out the requisite &lt;tr&gt;&lt;td&gt; strings to get the job done. svn commit (its java, we don't use DVCS), and its forever. Django's tag system seems to be the same idea in that, hey here's a new tag, let's define a function/class/method, shove all the &lt;tr&gt;&lt;td&gt; into it (their example has a &lt;strong&gt;), instead of defining intricate componentization using template constructs. For more severe examples, I do have some java code I inherited from an old project (and rewrote in Python with Mako) that is basically hundreds of classes with concatenated HTML shoved into them. This because JSP historically didn't have good systems of componentization (not sure if it does now, I've used Tiles which is fairly weak), even though JSP is a fully language embedded system. The developers there made a decision based on JSP just not allowing them to do what they wanted in a straightforward way (and a fair degree of ignorance about what they could have hacked together on top of jsp). With my own restrictive template systems back in those days, we spent the extra time to carefully tailor view-specific datastructures that could really spit themselves out into a &lt;table&gt; via simple iterators and conditionals - but it was seriously tedious having only restricted expressions and imperative constructs. The artificial constraints certainly forced us to develop good habits. But I would have to say I've been there, I am now qualified to be trusted with an open ended system that will let me do what I want, thanks. 
Nice. By the way, web2py can do this too: from gluon.html import TAG html = urllib.urlopen('http://...').read() page = TAG(html) content = page.element('div#content') print content for item in page.elements('input[type=text]'): print item['_name'], item['_value'] here gluon is the core web2py modules. element accepts jquery syntax. TAG does not just parse. It creates a pythonic representation of the DOM and can be used to manipulate the page (kind of like beautifulsoup). 
jquery syntax, [really guys?](http://www.w3.org/TR/CSS2/selector.html)
There are a few s60 phones around and if it replaces s40 like they said it would, a whole bunch.
good point.
The examples there are CSS 3 (at least I'm pretty sure `input[type=text]` is only in CSS 3), but jQuery includes a number of extensions to CSS selectors, which pyquery and I presume web2py implements. Well, [looking at the source](http://code.google.com/p/web2py/source/browse/gluon/html.py) I don't think web2py's code is anywhere as robust as pyquery (or lxml.html which is the basis of pyquery). It uses HTMLParser, which is not a good parser, and the [elements code](http://code.google.com/p/web2py/source/browse/gluon/html.py#737) looks fairly primitive. [lxml.cssselect](http://codespeak.net/svn/lxml/trunk/src/lxml/cssselect.py) uses a proper tokenizer and parser. If you are curious lxml.cssselect implements CSS 3, and so [pyquery.cssselectpatch](http://bitbucket.org/olauzanne/pyquery/src/7cdca9272815/pyquery/cssselectpatch.py) specifies the jQuery-specific selectors.
I read the example from the Django docs (using &lt;strong&gt;) as mostly pedagogical, though I agree that it's horrible practice. Where the table example is concerned, it's a case where, however tedious, I'd still be inclined to stuff it into a template fragment/module/macro/etc given how nuanced table styling can be, independent of output data. I have a pretty hate-hate relationship with JSP myself, but a lot of that relates to deficiencies independent of being able to execute inline code. Java on the other hand opens up a corollary argument: Keeping code out of my templates/views significantly increases the value of Java IDE X, coverage tool Y, and debug tool Z. For better or worse Java devs are often spoiled by these tools and so anything that falls outside of their coverage may as well be invisible until release or a failed web test (another rant entirely). As someone who works on a fairly sizable GWT/Spring/Hibernate app, my hell is other devs hiding logic in the GWT layer. Something similar to Poromenos' sorting by date example is all well and good until our web UI ordering no longer matches our SOAP API. My fear with embedded logic in templates is "hell is other people." I trust myself enough to know that if I make a mistake in my template logic I'll at least know how to fix it quickly. Not so much with other people on my team, whether I'm debugging their code or them mine. (Thanks for the quick reply, btw!)
I am probably missing something basic here but whats the difference between using a multiprocessing Pool vs using futures? The API seems quite similar. 
This is a great package, thanks for the repost, although there's nothing jQuery about the syntax, it's just CSS selectors...
Four years ago I wrote [this](http://www.b-list.org/weblog/2006/jun/05/templating-languages-redux/), and now I'll quote the important bit: &gt; I’ve come to the conclusion that web developers go through certain phases: &gt; &gt; 1. In the first phase they discover a language like PHP or classic ASP which makes it extremely easy to intersperse program logic amongst HTML. &gt; 2. In the second phase they have been bitten by the consequences of over-mingling logic and presentation, and violently react by retreating to the opposite extreme. &gt; 3. In the third phase enlightenment is achieved, and they realize that application logic belongs with the application layer and presentational logic — kept as minimal as possible — belongs with the presentation layer. Though at the time I was arguing with people who went to the other extreme (advocating no logic of *any* sort in templates), I believe that's still the best distillation I can provide of my opinion on the matter.
The way of chaining the queries, like: &gt;&gt;&gt; d = pq('&lt;p id="hello" class="hello"&gt;&lt;a/&gt;&lt;/p&gt;&lt;p id="test"&gt;&lt;a/&gt;&lt;/p&gt;') &gt;&gt;&gt; d('p').eq(1).find('a') [&lt;a&gt;] That's the parallel to jQuery.
Can you paste more info from the error? Try easy_install2.7 packagename and see if that works for installing packages.
Also all I think all the methods like `.html()`, etc.
You can install something like [homebrew](http://mxcl.github.com/homebrew/) to keep your non system python isolated from the shipped one. By default homebrew keeps everything in /usr/local/Cellar. lxml,mechanize,psycopg2 all install fine with the homebrew supplied pip but I havent had any luck with game libraries such as pygame or pyglet. 
I've updated my post with another line from the error. Seems to be the only part that's relevant.
I've had a few projects where this would have been incredibly handy. I will definitely keep this in mind.
the library behind it: lxml is worth a look too it also supports xpath if you're into that sort of thing (and xpath is like a scalpel for xml-esque documentns) 
So you basically exactly agree with me...
I see, thank you.
Do you have gcc installed? (do gcc -v) If not you should install it via xcode (should be on your osx cd or via download to get the latest)
web2py code for parsing implements only a subset of jQuery/CSS3 syntax it is only as robust as the the python HTTPParser and it chokes on some non-utf8 characters. This is in fact not the main purpose of web2py. The only reason to mention and use it is that is parses into web2py helpers. This allows to grab a page, and replace - for example - an existing form with form generated by web2py.
Doesn't look like I have gcc installed. I noticed the xcode download is 3.5gb and I'm on crappy hotel wireless, so I'll have to check my disc when I get home. Thank you. Any idea how to handle the packages for py2.7?
You need to have gcc installed from the Xcode for your release of OS X (there are different ones for 10.6, 10.5, etc.) for packages that include C extension modules, like lxml. You also need to install a separate version of easy_install for your new 2.7 instance; that's true for every separate Python instance. Follow the directions on PyPi to install either setuptools (the traditional easy_install at http://pypi.python.org/pypi/setuptools) or the newer fork, Distribute (http://pypi.python.org/pypi/distribute). The installation will output exactly where the new easy_install command is installed. Then make sure you use that version of easy_install when you want to install packages to 2.7.
Incidentally you can also use CSS with your XML documents, CSS even secretly supports XML namespaces (e.g., match `&lt;foo:bar&gt;` with the `foo|bar` CSS selector).
That's why it is called py*query* and not py*css*
So let's use * for division!
I know it's a bit nitpicky, but don't forget documentation at the top of the file! This is a pretty self-explanatory script, but it's a good habit to get into.
Try it out. From other replies there's some magic to work around it, but test it the basic way.
BeautifulSoup seems like a better choice, but CSS selectors are fun, too.
Then it would be Jinja2.
As noted by deadwisdom the API of the library is similar to jQuery, also the css selector of jQuery and PyQuery has a few pseudo-classes that are not in the css standard (:first, :last, ...).
WillieWampum, the reason you are seeing the installs that complete go to your old (system) version of Python is that you are still using the easy_install that came with the system. Whenever you install a new Python to your system you also need to install new setuptools as well. Follow the installation instructions at http://pypi.python.org/pypi/setuptools to install an easy_install program associated with the new Python install. After that, your installs should work better and show up for the correct Python version. You probably also want to do a fresh install of pip as well.
pyQuery is very broken.
Heh, exactly.
Take a look at [scrapemark](http://arshaw.com/scrapemark/) it's incredibly easy and quite powerful while still being decently fault tolerant.
Calling is allowed: mystring.upper just works. What isn't in Django, but should be, is multi-argument filters: `|foo:bar,baaz` The other issue which comes up a lot: Django has two good ways of writing template tags ([simple tag](http://docs.djangoproject.com/en/dev/howto/custom-template-tags/#shortcut-for-simple-tags) and [inclusion tag](http://docs.djangoproject.com/en/dev/howto/custom-template-tags/#inclusion-tags) decorators) and then the general, all-capable but heavily BDSM Node process which is discussed at considerable length in the documentation before getting to the sane, concise methods you should actually use[1]. The net effect is that 90% of the time when someone asks for logic in templates, what they really want is to write a template tag but are unaware/afraid because they aren't used to thinking of that extension path. [1] There are also a couple of unfortunate limitations (e.g. @simple_tag needs the trivial takes_context addition, both and filters could use richer argument handling) which have taken far too long to fix due to internal politics.
Tell me about it, I've actually never written a template tag because of the convoluted way of doing it (or maybe it's just the docs?). It helps that I've never *needed* one, but it's not something I'm proud of...
It's really not that bad: learn and use the simple_tag / inclusion_tag decorators. When you need more for things like argument parsing or nicer interactions (e.g. "with " or "as" syntactic sugar), look at something like http://justquick.github.com/django-native-tags/ or https://github.com/alex/django-templatetag-sugar for 
 python2: print x python3: print (x)
A comment near the top of the script indicating required version. 
Most people still use 2.x as their system python. If the top of a script starts with "#!/usr/bin/env python" then it's likely a 2.x script. Otherwise it will likely specify python 3.
Allow me to summarize the thread to come: **PyQt** or **wxPython** Thank you. Have a nice day. 
Thanks. Could i ask why and the difference between the two? Why do you use them?
Sounds fair. We'll just use whitespace for multiplication and all our problems are solved!
tkinter is very easy and comes preinstalled with Python. And it is no longer ugly in this day and age. It is also somewhat retarded. See also: http://www.reddit.com/r/Python/comments/e9lrl/gui_question/
thanks
pygtk + glade makes gui dev quick, imo.
My friend just did a project using wxPython. He says the documentation is horribly out of date.
Or use the cmp argument to sorted to write a comparator, taking two elements of the list and returning -1,0, or +1. That's the (arguably) more general way of customizing a sort.
There is no quick way to tell that, you could probably run 2to3 script on code and see if it suggests some changes. The problem is, quite a few features from 3.x have been backported to 2.x to ease the porting. There are some things that will indicate that code has been written for python 2.x other than print statement: * importing from _ _future__ * old-style classes - class Foo: instead of class Foo(object): * using _ _cmp__ method edit: thanks reddit for formatting my code..
I use [the online docs](http://www.wxpython.org/docs/api/) and they are current as of 2.8.9.2 But they are more reference than instructional. Consider getting the wxPython book if you want to learn it from scratch. 
Use [this](http://qooxdoo.org/demo) together with a web framework and your app will be internet ready.
Looks spiffy but isnt this more for web dev :P im looking to make a desktop app
How about this for the documentation?: http://xoomer.virgilio.it/infinity77/wxPython/APIMain.html Here you have some starting points: 1) Download the binary and 'docs and demo' distribution 2) The wxPython demo is really a great intro to all the widgets and controls, there is a tab showing the 'working thing' and other showing the code used (for the 'thing') 3) When you start to struggle with the sizers, go for a RAD / code generation tool, I particularly like [wxGlade](http://wxglade.sourceforge.net/) as is a full code generators, but I think a lot of people like resource editors (an XRC editor is distributed along the wxPython docs &amp; demo package), [wxFormBuilder](http://wxformbuilder.org/) seems a popular choice. 4) Anyway, once the initial framework bump starts to banish, you'll ask your self if certain stuff was already done, as it seems a common pattern. Certainly, you're answer might be already in the [wxPython wiki](http://http://wiki.wxpython.org/) (for instance, multiple language support, distribution using installers, MVC patterns, more sizing stuff, etc). Hope this helps!
WxPython uses native widgets on every supported platform, so the apps always have a native *look&amp;feel*. PyQt uses only native **styles**, but provides more modern features and good Designer.
I've used PyQuery and BeautifulSoup and I like them both, but I really like PyQuery because it matches the way I scrape pages; open them in FireFox, use the Console and jQuery to figure out what selectors I need to access the parts of the page I want to scrape, and then use those same selectors inside my script. 
Tkinter already comes with your Python distro. [Here's a good place to get started](http://infohost.nmt.edu/tcc/help/pubs/tkinter/). New Mexico Tech FTW!
Makes no sense to make a desktop app today. A web app can be restricted to the host machine if you like. It is easier to build. It handles concurrency better. It is more flexible. Runs on every os. It can be made to look the same.
personally for bleeding edge development I do it in a ubuntu virtual machine. I then sometimes use the osx system python for quick scripts or testing.
ha ok ^ ^ thank i will use it. I just got confused by the "new era of web dev" that is on the title
BeautifulSoup is more or less abandoned and deprecated. html5lib or lxml are better choices these days. (Pyquery uses lxml)
How so?
&gt; Makes no sense to make a desktop app today. For some things, maybe.
I'd probably just use the search feature if I needed an answer to this question, since it gets asked weekly.
It's been a while since I used it. I had all sorts of issues with it producing incorrect output in certain situations. Something to do with how it copied nodes around internally I believe.
How should I keep up to date with which libraries are deprecated?
GUIs are just like web apps except that use OS sockets instead of internet sockets (the latter are more powerful) and use OS controls as opposed to browser controls (the latter are extensible and customizable). The only reason I can see a desktop beating a web app is for fast high definition graphics.
If you want to create a proper desktop app, use a proper GUI toolkit. It's all been discussed and said before. PyQt is excellent, wxpython is also very good. If you only need a web app or don't care much about usability and performance you can go with web stuff. But it's *not* easier! There're good reasons why huge professional (also database backed) applications use proper GUI toolkits or Rich Clients like Eclipse and not some html+jscript.
No really. That's why you code your web stuff in a browser and not in an editor like vi, emacs or an ide like wing, eclipse or pycharm. (ironic ;-)) Look around! The world is full of desktop apps. Always, when usabitity and performance matter it doesn't make sense to create a web app! I think you want to say: Hey guys, web apps can be very powerful today. Then I would say: True. Check this jscript stuff out, maybe it's all right for your use case. But saying it makes no sense to build desktop apps today is just 100 % wrong.
He linked in the first paragraph. 
Or, you could check out the 3482934 posts about this last week.
Well im no stranger to web dev ... just got off a project using web2py and mssql xD i just want to make a desktop app now
It all depends on your app and the usage. The more power you need for your logic (that can be graphics, but also can be text formatting or the data crunching in the background) and the longer the application will be used in one session, the more performance and usability are important. Then you need a proper GUI toolkit. On the other hand, you can't go wrong with a proper GUI toolkit. Worst thing that can happen is, that you have learned it. I've seen huge projects having big acceptance problems because of their sluggish, unintuitive web-client that lacks tooltips, keyboad shortcuts and the look and feel power users just need.
Unless you're on Arch Linux, where ``#!/usr/bin/env python`` is Python 3.
&gt; And it is no longer ugly in this day and age. Actually, it still is. Try to use a menu bar and you'll see. Plus, setting a GTK+ look and feel makes it really, incredibly slow.
Yeah i know where your coming from and i understand as much. Fortunately im just making a simple app mainly for my own use but im hoping that others can enjoy it as well. ... if i was worried about speed i would do it in C ^ ^
you gotta love a GUI documentation without a single picture. edit: i take that back, i just saw some icons. but still, come on, we want to see what the application will look like.
Sorry, but this is wrong on so many levels: &gt; GUIs are just like web apps No, they are not. Web apps are HTML cobbled together with JavaScript and whatnot to run partly on someone elses computer and partly in your browser and generally much more a mix of technologies than the integrated approach of a "native app". &gt; except that use OS sockets instead of internet sockets (the latter are more powerful) Not all "GUI apps" use sockets at all, plus "internet sockets" (what the hell is that, even? Do you mean websockets which are not yet popular or straight XMLHttpRequests?) are definitely less powerful, think SCTP, UDP or pretty much anything in TCP that is not HTTP traffic. Not to mention ``select()``, ``epoll()`` or ``kqueue()``. &gt; and use OS controls as opposed to browser controls (the latter are extensible and customizable). With Qt you can apply CSS-like styles to your application, and customizing widgets haven't been a problem since about the last *decade*. Plus, you have a much greater set of widgets (calendar-widget? coming up in HTML5; seen them in Windows 95 back in the day), plus the possibility to define new ones. You can't technically create Widgets that you could use in forms in HTML, you can create something that looks like a widget by using HTML and JS, like ExtJS does extensively, but this is still a far fetch from what you get on the native desktop for free, with *every* notable GUI toolkit. I agree that web apps are sometimes handy, but saying that they are the same is utter bullshit.
if you are looking at some piece of code written by a scientist look for the new set syntax, {1,2,3}. i am wondering why we don't even have it in python 2.7. saves so much typing.
It isn't actually too bad. Anything you want to do with it (ok, most everything) can be found with a simple search. Sure, http://www.wxpython.org/docs/api/wx-module.html won't have everything you need, but you can get pretty good ideas about syntax and semantics from a wide variety of places, especially Stack Overflow.
I have no idea. I don't make any particular effort myself. I just happened to be reviewing Python HTML parsing libraries myself recently (for the Nth time) and noticed a few things at the sites for these projects. 1. [BeautifulSoup author corrects a long-standing problem that illustrates how neglected the project has been for a long time](http://www.crummy.com/2010/11/21/0) 2. [html5lib considers its BeautifulSoup integration deprecated](http://code.google.com/p/html5lib/wiki/UserDocumentation#Parsing_HTML)
 &gt;&gt;&gt; from mpmath import factorial &gt;&gt;&gt; print factorial(2**128) 1.62672186878756e+12963922773915897352139996524992575205380
Set literals *do* exist in 2.7.
At the shell type "easy_install" and then hit the tab key twice. That will tell you what versions of easy_install are available. You'll see something like this : easy_install easy_install-2.4 easy_install-2.5 easy_install-2.6 Use the version that matches your Python version.
This isn't a definite indicator because `print (x)` is valid in Python 2.
If you click the 'formatting help' button below at the right bottom of the comment box, it tells you how to format inline code and snippets: Use `__backticks__` or... indent lines four spaces
Try importing the code in Python 2 and see if you get any syntax errors. You might want to do this in a virtualenv.
Instantaneously. But I was already comfortable with the whole concept of classes, having used them for years in other languages. I was kinda shocked/happy to find out how minimalist Python's implementation was. I had a brief moment of concern about the explicit lack of private &amp; protected members, but I got over it really fast. The biggest adaptation was the transition from thinking in classes to thinking in modules. *....and then there are metaclasses....whoooo.....* 
`class Foo: pass` is valid in Python 3. The difference here from Python 2 is that in Python 2 not specifying a base class gives you a "classic class"; in Python 3 classic classes have gone away, so `class Foo: pass` is equivalent to `class Foo(object): pass`.
Re Private classes: as the BDfL put it "private classes? were all adults here aren't we?"
OK- then let me rephrase- how long did it take you to get classes when you first learned them?
About half a semester for me, but it was my first programming class ever.
2 minutes.
I have had many a-ha moments in my programming career, I don't remember if classes were one of them. Everybody understands and grasps things in different ways, and thus some things are harder for some to grasp than for others. Don't get discouraged. What is it that you think you're not understanding? Their purpose?
Basics? A few minutes. Details, deciding what "good" classes are? Lots of experience :) You can start by reading something on the *original* wiki, like http://c2.com/cgi/wiki?ObjectOrientedProgramming or http://c2.com/cgi/wiki?ObjectOrientedForDummies :)
Ah. Well.... It was a warm summer night when I first met classes. I was a young programmer, still reading RFCs by flashlight under the covers late at night. I had used Pascal and C and was familiar with composite data structures like Record and struct and union. Then some friends told me about this strange danish man, Bjorne and his *craaaazy* ideas. I read his C++ book and got my grubby hands on a compiler. (Thanks Borland!) The concept made sense, to fold code into the data so that the thing knew what it was and what to do with itself. For me, the conceptual bridge was thinking of objects as a way of modeling the problem. If "regular" structured code described the process, then object oriented coding modeled the situation. Each element in the problem was it's own object. Types of objects were classes. Similar things could be organized by hierarchies of classes and subclasses. It made lots of sense to my naive young mind. While all that was all still fresh in my mind, I took Smalltalk out for a spin. It took a little while to get used to the strange and wondrous syntax, but the ideas were understandable enough. Then I read the Gang of Four and my conversion to the dark side was complete. Then, a few years later, I move onto Java. Happy to free myself from the nit-picky details of memory management and fully indoctrinated into classical design. But still...a deep and nameless dissatisfaction remained. The seduction of classes led me down garden paths into designs that were chtuluian in organization. Either I was doing something wrong, or.....horrors of horrors....classical object orientation was not the panacea I had been sold. One warm summer afternoon early in the new millennium I was mucking about and spun up this thing some wacky dutch guy had done. A fresh breeze blew thru my mind and thus I was enlightened. Object orientation is *just another metaphor* for modeling the problem, and should be used or not used as is appropriate for the task. Not everything fits that model. Some things fit it really really well. And to answer your question....it took me a week or so to "get" classes when first introduced. Several months to use them effectively. Several more months to use them efficiently. And several years for all the deep implications to sink in. The "ah-ha" moment, was thinking of classes as representing a type of thing. And that things do things, have things and are things.
So he did. Either I'm blind, or that was edited in later. Either way, disregard the above.
I first learned C then C++ so it was not too difficult because the concept of classes resemble a lot to "struct". 
[IronPython](http://ironpython.net/) which runs Python on .NET.
I still don't really 'get' them. I mean, I think I know what they are, but not how to use them.
Python was my first OOP language. The more I used classes (reading didn't help much) the more I understood them. Actually, when I'm now thinking about it, it didn't take long at all :)
Also: python -mpy_compile &lt;file&gt;
Massimo, how does it compare to Web2Py ?
The licensing is also different: LGPL for Qt (but PyQt is currently GPL + commercial), versus the wxWindows license for wxPython (similar to LGPL with an exception stating that derived works in binary form may be distributed on the user's own terms).
qooxdoo is a JS library so I cannot compare. I guess you can use it with web2py. I did not try yet.
One of the things that helped me understand classes was to look at them as "functions with memory". e.g., functions are usually one shot deals. Classes on the other-hand can remember things. e.g., value = function() and you're pretty much done. classes are like value = function() except now value has access to functions memory. If you assigned say self.memory1 in your class, later on down the road you can ask "value" for memory1 e.g., value.memory1 and BOOM, it just remembers. If you create a regular function in your class (AKA method) that function can be called from memory later e.g., value.function(). That function you created in your class has access to all other self.variables and other functions defined in the class. You simply access them e.g., self.memory_this, self.memory_that... Everytime you access a function (method) in your class, it can create, read, update and delete memory in that class. This makes it a super cool contained object in which it will continuously modify information about itself as is needed. Theres so much more to classes but the 101 to me was looking at them as some sort of super functions that could remember things. A sort of function that contained variables that were very specific to it (so I didn't have to litter the global namespace to carry over information from function to function to function to function). Granted we all have our a-ha moments and that was mine. I hope it made some sense. 
? If you are referring to web2py. I write my web2py programs with emacs. The web based IDE is a feature that only use occasionally. Most web2py users use eclipse. I stand by my statement: makes no sense to write a regular desktop app except for high intensive graphical apps. Desktop apps are more expensive to maintain, they are more difficult to write, they are limited to one user at the time, the force you to follow a business model in which you sell the software as opposed to a service.
In the past I have used Qt and was happy with it.
It took me several months, mostly because all the explanations I came across were more focused on the language details (C++) rather than what problem they were trying to solve. I finally ran across a book in my university library that explained classes in one short sentence as "abstract data types, with operations". That was my a-ha moment.
I started reading the first link you sent there, then got distracted reading about the origin of 'decimation'. Thanks for that.
I did not say "they are the same" I said they "are just like web apps" in the sense that they both need to handle concurrent events that are triggered by the user. [here](http://en.wikipedia.org/wiki/Internet_socket) is the definition of internet socket. Under the hood, in C/Posix GUIs use struct sockaddr*, while web apps use struct sockaddr_in*. Web apps do not need to have an interface in html/js. The interface can be done in Flash, can be generated by a tool like qooxdoo or pyjamas or GWT.
With IronPython you can use WinForms or WPF. Plus, you get a lot of good stuff from the .NET framework. I wouldn't necessarily recommend this choice for cross-platform work (though still possible); however, you said "for Windows on Windows".
I still miss public/private. The whole "aren't we all adults here?" argument misses the entire point of public/private. Private declarations aren't there to protect you from me meddling with your private members. They're there to protect ME from YOU and your implementation. Wouldn't it be nice to pull in a python module, do a dir() on it, and get a list of things that are *important to the user* rather than list of every implementation detail used in the module?
also `from __future__ import print_function` in Python 2.
My "ah-hah" moment came when reading [Alex Martelli's description of classes in "Python in a Nutshell"](http://books.google.com/books?id=JnR9hQA3SncC&amp;lpg=PA82&amp;ots=JaaSLu035x&amp;dq=Alex%20Martelli%20Classes%20Python&amp;pg=PA82#v=onepage&amp;q&amp;f=false).
It's not combat, it's cooperation. We are all reasonable adults here. You're just going to have to trust me that I won't stick my finger in your eye. It's up to me to make sure I don't break your implementation - unless I need to. 
&gt; print 2**128 doesnt work? EDIT: Not the point. I didn't notice the !
It was a 'snap' moment for me while taking classes about OO with Java. I was coding exercises without really 'getting it'. Someday: "wow... this makes sense". Took me two months to understand it (and I had 4 months of a structured programming class before it). The first thing was: it's not about modelling the real world as it is. Is about modelling a world for your program. Some real world abstract concepts are translated as objects in 'the program world'. Example: "Withdraw" or "Deposit" may make sense as classes and objects in a program. And this occurred because I understood what OO programming is all about: abstractions. It provides a way to encapsulate code and data thus allowing focus on the communication among objects. You program thinking about how objects interact in your system. Those objects provides an way to divide-and-conquer while programming: each small unit knows about some other units and think how they interact and how it works to do its part. This is how I 'got' classes. But this is not the challenge. How to make a good model of objects and interactions is the most hard part of it. I think if my first OO language was Python, I would still get the same "snap" moment. The first thing to understand classes is to know what this is all about...
Classes just came to me, and Python was the first language in which I became proficient that used them. I've met a lot of people using Python that just can't seem to grasp classes, even when they've used them in other languages (this includes java programmers, wtf). *That* is the idea that I'm having trouble "getting."
I tried GTk. I found it ok BUT why can't I have a scrollable container (ala ScrolledWindow) but that hides (doesn't display) its scrollbars? I had to manage a hack where I enlarge the window (fullscreen) just enough that the scrollbars don't show, but what the hell, do I need to create a complicated subclass just to do this?!
This mimics my experience pretty closely, except my first c++ compiler was THINK, not Borland. Also, I never used a flashlight to read RFCs.
Here are a couple apps I wrote in tkinter. They aren't hideous, but a few things about tkinter are. http://bitbucket.org/jgrigonis/mathfacts http://bitbucket.org/jgrigonis/mortgagecalculator I am accidentally becoming pretty good at tkinter, with the plan of doing the *next* project in wxPython or PyQt.
I'd say it depends on where you envision your program being used. I'm a GNOME desktop user, so I went with GTK+ and Glade, and it has been a joy to develop in thus far, my programs are very fast and responsive. That's my recommendation for a conventional desktop application. If you're looking for something more avant-garde, try Clutter http://clutter-project.org It is a more flexible, more stylish, and more basic hardware accelerated GUI library. I'm using it as the sole GUI library to build a trading card game, and it has been very productive and fun to use, providing animation and special effects right out of the box.
I first learned programming with Pascal, and I used the Pascals record a lot. When I at a much later stage picked up python (around 1.5.2) I quickly understood that classes are records with functions attached to them, operating on the record. Of course there is much more to classes than this, but that first moment (approximately 3 or 4 days into meddling with python) was a breakthrough. However from the point where you understand what a class is to the point where you understand classes and can design good classes by yourself can take months or even years. Today - 12 years on - I still have to look into the python documentation if I want to do some deep class magic (i.e. use a metaclass)
cool thanks for the info
I wish scrapy supported PyQuery, instead of just selectors. There's some useful stuff in there.
Scrapy 0.11 (which hasn't been released yet) allows you to use whatever you want for HTML parsing.
Since no one has mentioned it yet, I should mention [PySide](http://www.pyside.org/), which is another Qt binding for Python. This or [PyQt](http://www.riverbankcomputing.co.uk/software/pyqt/intro) would be my recommendation.
I think you misunderstood what I said. It's not about breaking things. It's about information overload. If I can't easily partition someone else's classes stuff into "here's whats important to you, the user" and "here's whats important to me, the implementor" then it takes me a lot longer to understand how to use your stuff. I don't care about violating encapsulation, call private methods all you want. But simply mark them private - give me a clue that "these are not the droids you are looking for".
I remember writing code with lots of module-level functions took different kinds on data structures as inputs and outputs, or modified them in place. As soon I was naming functions things like "display_recipes" and "display_ingredient" to display to different kinds of nested lists or dictionaries, the organizational advantage of encapsulation provided by classes was obvious.
This is the best way I can think of -- you can quickly add it to any python file: import sys print(sys.version) Edit: Whoops -- I realized that this will tell you the version of Python running the code, not the code itself. This page provides a good overview of changes you can look for; including the print function, and other built in changes: http://docs.python.org/release/3.0.1/whatsnew/3.0.html#library-changes
EDIT: I was stupid and didn't notice the ! after that.
The only thing I've noticed so far is that it thinks &lt;br&gt; is a new node, so that this span has a child. &lt;span&gt;lorem&lt;br&gt;ipsum&lt;/span&gt; For my purposes I can just remove the breaks though.
No special reference to web2py or any web based IDE here ... I just wanted to point out that we all use proper desktop apps all the time, e.g. emacs or eclipse or gimp or vlc or powerpoint or dvddecryper or ccleaner ... for performance and usability reasons. So, in my opinion you can't make such a general statement like proper desktop apps don't make sense at all (OK, you've made the exception for heavy graphics). Also, once you know the API of Qt or wxwindows it's quite easy to write GUIs. But hey, I think we just don't come to the same conclusion regarding each aspect of the discussion. ;-) No worries.
Yes- I don't 100% grasp their purpose yet. I can look at other people's code and know what is happening, but don't yet see where I can use it myself. I know it will take experimentation and practice and I'll get it. I just want to know how long I should expect to take to 'get it' Python is the first language I've studied and I've been at it for a month. I get functions, global/local variables, passing variables, etc. I get recursion and know how and why to use it, just now started on classes. Recursion took a little bit, but once it clicked, it clicked. 
If you know Smalltalk, C++ and Java like me, never problem with the concept.
I first learned classes in college when I was learning C++. I was very confused at first. I remember going throughout the day trying to wrap my head around what a class was. I read the chapter in my text book over and over again. I remember that the book had an example of a ball. A ball has a size and color; properties that can be used in a class. It just didn't make sense to me. Then I remember the instant it hit me. I was standing in line at the cafeteria waiting to get my dinner when it just all made sense. I said out loud "OOOOooohhh!". I got weird looks from the people in line with me, but I didn't care. I then ate dinner thinking just about classes and how they can be applied. I then went straight to my room and started coding classes over and over again. That was a good day.
I don't think there was ever a point where I just "got" classes out of the blue. Our high school was almost entirely in turbo pascal. Turbo pascal had OOP but we never really covered it in the course work (even when we touche on delphi). I had read a C++ book during high school and tried to apply what i had learned to a bunch of personal projects in turbo pascal, but I never really "got" it, I was using a lot of function pointers instead of defining derived classes because I thought defining a class to override one method was wasteful. I don't know at what point I got it. My first year was mostly in C, but with a strong emphasis on object oriented design. I think because the assignments were designed around OOP it was a lot easier to get.
The factorial of 2^128 is definitely what the code computes and claims to compute (although it does so inaccurately -- the result has no correct significant digits (the mpmath value is correct)). "2^128 using stirling factorial" doesn't even make sense.
Requires Python 2.x.
Hang on. I just thought I was getting the hang of web2py and then along comes a massive feature that I missed that warrants about 3 lines in the manual. Does it also make the tea?
I noticed that it is not the point, but are you really using python 1.x?
As far as I can remember, I have never used Python 1.x :-)
Probably the same thing will happen with classes. Recursion is usually something that messes people up for awhile. Maybe you can try thinking about it like this - first of all, don't think of the class itself, think of the object that you make with the class - the class itself is just the definition of the object, more like a blueprint. Then, maybe you can think of the objects as uh, just to imagine up some sort of crazy scenario, how about a robot, just because robots are cool? A robot that stores stuff in it. The robot has buttons on it that you can press (member functions) that make it do certain things, like give you some of the objects that it stores inside (member variables). Maybe you could use other buttons to make it store other objects inside of it, or reorganize the objects, or merge two objects together, or create new objects. The great use for classes is something called [Encapsulation](http://en.wikipedia.org/wiki/Encapsulation_%28object-oriented_programming%29). Specifically, in Python, this is the meat of it: &gt; A language construct that facilitates the bundling of data with the methods operating on that data. Basically, it's a way of tying together data with methods that work on that data, and it makes for a clean design. With classes, you can avoid having a file full of global functions, and instead separate each piece of your program into its own interface. The other part of Encapsulation ("A language mechanism for restricting access to some of the object's components") doesn't so much apply to Python, only because there is no actual language mechanism for it, only best practices. But it's still useful - you can have a data member which another interface may not actually know about well enough to modify (and really, I mean "another programmer trying to use the interface"). This is a pretty bad example, and I could think of other ones but I'm not sure if they'd be over your head. Let's say your class had some sort of data which, whenever it needed to be modified, it had to be sorted in some way. Let's say your data is a list, and you wanted to maintain how it was sorted whenever data was inserted to it. Other functions rely on the data to be perfectly sorted (because you don't want to make sure it's sorted every time you have to use it). Normally you'd have to insert it at the proper position every time, but a better solution is to use a class method which "knows" how the data should be sorted. This way, the class itself knows how to handle the data properly and you save that burden from other things. The other way to do it is the "C style" way, where you'd have a variable, and a global function which specifically knows how to operate on that variable (your sorted list) to insert data. Another way to look at classes is that each function can really just be looked at as a global function which gets passed a reference to the object itself, which contains other variables. So, these are kind of equivalent: ### Example of modifying a global variable with a global function global_a = int() def my_function(): global global_a global_a = 1 ### Example of doing the equivalent with a class class c: a = int() def my_function(self): self.a = 1 ### Demonstrate how the global variable method works my_function() print "Global a is", global_a ### Demonstrate how the class method works my_object = c() my_object.my_function() print "Object's a is", my_object.a The difference with the class method of doing this is that you can have encapsulation (and it looks a bit cleaner, without using any global variables which is generally considered bad practice). I hope at least some of that made sense, I had a long day and I probably just babbled on for a few paragraphs. :)
Thank you for your time. That helps. What I need to do is an assignment that I can do with functions then redo with classes so I realize how the class structure works better. In your example the class structure is much neater. I'll practice the heck out of it the next few days. 
LOL. It is documented here: http://web2py.com/book/default/chapter/05?search=elements#Server-side-DOM-and-Parsing 
I'll do that, thanks. It's more that I've never needed it too much, otherwise I'd learn it, but it's not the most straightforward thing in Django...
 sage : -1 ** ( 1/2) I sage: i ** 2 -1 sage cares : ) Though I'd be interested as to why 'I' was chosen primarily. http://www.mail-archive.com/sage-support@googlegroups.com/msg07815.html cares enough to raise and fix an issue also : http://www.mail-archive.com/sage-support@googlegroups.com/msg18889.html http://trac.sagemath.org/sage_trac/ticket/9017
Yes, "#myElementsID" is css, but this is jQuery: $("#myElementsID").children("p").find("input[type=text]").attr("name") CSS selectors are only half of the story. The other half is the amazing traversal methods. I'm not familiar with anything other than jquery so maybe there are better tools, but that's the reason why this is so awesome. I use jQuery so much that PyQuery has no learning curve.
Yes we all use non-web based app but why? Mostly for historical reasons. When you use Eclipse for example, it runs in a window. If it were a web-app, that window would be rendered by the browser. Since it is not a web-app, that window is rendered by the OS. That window generates and responds to events very much like a web app. In fact you can export the window of any desktop app to another remote desktop. We would all be happier if our OS where a single browser window and our programs, local or remote, were accessible via a URL (anywhere from anywhere, with appropriate security restrictions). The faster we move there, the better.
I've never used python, but went through a CS program and probably a year of web development without really understanding OOP. I could get by using it, but definitely couldn't build anything from scratch. I can't tell you what it was, but one day it finally just clicked.
Don't forget that if you don't like the licensing of PyQt, there's nokia's own [pyside](http://www.pyside.org/) bindings. LGPL, the same as the rest of Qt.
I think a big part of the 'a-ha' about classes and objects, for me, was that it was a nice way slough off painful parts of the application, conceptually. So, if you're writing code from a top-down perspective, you can just sort of invent objects and actions on those objects as you go, even though they don't exist yet. Complicated stuff you don't want to think about right now just becomes some convenient class with a method that just makes it happen. Later, you will have to implement that method, but you have the comfort of knowing (well, having faith) that you once you write this class and it's methods, you'll never have to think about this awful mini-problem again (think parsing or encryption or whatever is loathsome to you). Of course, none of that is *true*, but it's a lovely fiction that helps us get through the day.
True, but PySide hasn't yet reached the maturity of PyQt.
I won't deny that. I'm sure it'll catch up to PyQt soon enough, and probably surpass it.
Great! Back when I was learning this stuff, I definitely found creating my own examples and uses for stuff was the best way to learn it. That's my learning style though, I learn best through personal experience. Yours may be different, but it sounds like we're pretty much the same.
Pretty nifty, but I wish that 'hello' were not both the `id` and the `class` in the example.
Also, I wanted to add: as much as you may think you don't understand this stuff right now, I guarantee you that if you stick with it, a few years from now you'll look back on this moment and think "how did I *not* understand this?" For me, this stuff is engrained in my mind so much that I don't even need to think about it, even to the point where it's a bit hard to put into words. Have you ever learned to drive a manual car? I've tried to teach people how to do it, and I actually have trouble sometimes figuring out exactly what they're doing wrong. They ask me what they should do, and the only thing I can think of is "I don't know, how does it feel?" Same sort of thing applies here. It'll sort of become "muscle memory" in a way (even though your brain is doing the work, not your muscles). Another thing - try not to concentrate on the details. Those will come with practice. I live mostly in the C++ world, where the syntax rules and things can be much more complex than Python. I found it all very overwhelming in the beginning, until I eventually realized that all the memorization wasn't really working. When you get it, these things will make sense to you in a whole different way - the people that design programming languages really knew what they were doing, and they put a lot of thought into it. Often, they design things in a way that makes a ton of sense when you can see the whole picture. I'm a self-taught programmer, and I sometimes find myself coming to the same conclusions all on my own, and only later realizing that language designers had already thought of that solution. Good luck, stick around /r/python and ask questions if you're stuck! Also try IRC (Freenode #python can be pretty good), or Stackoverflow.
you think self dot is minimalist?
Worked like a charm. Thank you.
Dude, scientists already use ・ and () for multiplication. 
you can and should do the whole [single and double leading underscore](http://docs.python.org/tutorial/classes.html#private-variables) way of naming variables. it really signals to the user what is internal and what is external, and allows the user to get their hands dirty if need be.
My first language was C and while learning I had never heard of classes. One day while working on a small program I found a guy's tutorial explaining how to store related functions together with the set of data they apply to in a struct using function pointer. It just made sense right away. Then a friend, a much better programmer, came by, looked at was I was doing and said "Dude, that's fucked up, you're reinventing c++". I tried C++ and I was happy until I went on to read boost source code and I discovered template meta programming. 
There's also an [html version](http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html) which may be a little easier to read.
Exactly. What is explicit in other languages is hackish and convention here. Shouldn't be that way.
It's actually getting harder and harder especially with 2.7 which backported a lot of Python 3 syntax. In some code-bases you can browse for hours without finding anything (take into account that large bodies of code were re-written to be both Python 2 and 3 compatible). So my advice is - don't. Find another way to achieve what you need. If you randomly find a library online and it mentions absolutely nothing about the version of Python it needs (which is rare), in 99% of cases it will run on Python 2.
yeah i love how on stackoverflow they OHNOES everyone who wants to talk about using a regex to parse html. Fact is most html parsers suck and break easily where regexes work just fine if you are using them correctly. I mean a parser is great for when you need to parse something, but if all you need is one tag ... well its kinda retarded
Blender from blender.org has a built-in console. That got me hooked.
well the most obvious pitfall is that you lose geek cred.
Well, there's the obvious pitfall of your scripts working everywhere Python is installed, while shell scripts need to be very careful to stay portable :)
why?
 Enter any module name to get more help. Or, type "modules spam" to search for modules whose descriptions contain the word "spam". help&gt; this The Zen of Python, by Tim Peters Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren't special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you're Dutch. Now is better than never. Although never is often better than *right* now. If the implementation is hard to explain, it's a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea -- let's do more of those! Help on module this: NAME this FILE /System/Library/Frameworks/Python.framework/Versions/2.6/lib/python2.6/this.py MODULE DOCS http://docs.python.org/library/this DATA c = '!' d = {'A': 'N', 'B': 'O', 'C': 'P', 'D': 'Q', 'E': 'R', 'F': 'S', 'G': ... i = 25 s = "Gur Mra bs Clguba, ol Gvz Crgref\n\nOrnhgvshy vf o...bar ubaxvat ... 
You see the light! Or maybe your stuck in the shadow with me... well that is why I posted this.
Bash has its sweat-spots. It is very easy to put two processes in the background then wait for them both to finish for example. And bash promotes the Unix philosophy of solving a problem by scripting together the standard Unix tools, in what can be a much more lightweight manner than Python. Sometimes bash would fit better than Python, and vice-versa. Its good to know both and know what is appropriate.
coz it's already submitted to reddit http://www.reddit.com/r/programming/comments/29kgk/code_like_a_pythonista_idiomatic_python/ http://www.reddit.com/r/Python/comments/7dwt3/code_like_a_pythonista_idiomatic_python/
Program an Asteroids clone using classes and you will understand.
What is a program that you are interested in writing some day? If we work through something you're interested in, this might help you better understand classes.
it's just not a very unix thing to do. i use python extensively for scripting, but i catch a lot of shit for it from more oldschool/hardcore unix/linux guys.
I agree. The problem is that if you know Python very well, you are tempted to use it for everything, even if it is inappropriate. If you have a hammer everything looks like a nail.
huh? everywhere python is installed and has the same libs installed, and are all at the same version perhaps. If you have to support say RHEL 3-6 you have python 2.3.4, 2.4.3, and 2.5.2(iirc on rhel6). So, a bash script is going to be simpler to use than having to backport all your python knowledge 4+ years.
I find the lack of an equivalent (and easy) way of using backticks in Python annoying. Mainly just the lack of backticks. Ruby has backticks, why not Python?
Which really sucks... beside that issue I love arch :-)
No. I've done it for years. I use python for the skeleton and control flow, and long bash one-liners accessed with os.system for the actual guts. I wrote an entire tkinter file manager that worked this way. Worked great.
Python (2.x) has backticks, it's just that they mean repr() rather than os.popen() :)
[Here](http://pastebin.com/sJu0k7eY) is a very basic program I've been working on. Its a cointoss game that saves the top scores and displays them when you finish. I'm sure there's a few bugs left, but it basically works. Could I convert this into classes and make it better?
heh. this is the problem, I want to be able to use backticks in python like I can use them in bash. :P
&gt; But simply mark them private - give me a clue that "these are not the droids you are looking for". These _are_ the droids you are looking for: &gt;&gt;&gt; import re &gt;&gt;&gt; public_dir= lambda x: [s for s in dir(x) if re.match(r'[^_]+.*$', s)] &gt;&gt;&gt; public_dir( re ) ['A', 'ASCII', 'DEBUG', 'DOTALL', 'I', 'IGNORECASE', 'L', 'LOCALE', 'M', 'MULTILINE', 'S', 'Scanner', 'T','TEMPLATE', 'U', 'UNICODE', 'VERBOSE', 'X', 'compile', 'copyreg', 'error', 'escape', 'findall', 'finditer', 'match', 'purge', 'search', 'split', 'sre_compile', 'sre_parse', ' sub', 'subn', 'sys', 'template'] **Ninja edit:** But yes, it would be nice if it were built in.
It's valid but you will (almost) never see it in Python 2... It is an indicator, but it has an error margin.
The job security working for Digg doesn't look too good. That ship has been sinking for awhile now. 
it does in some context : - when you need to deploy a compiled app - when you need computational power (graphics for ex). 
Damit, where is the burry button on python.org? :P
&gt; everywhere python is installed and has the same libs installed How do you know this is true, specifically the second part?
Then just write bash.
Wow I had no idea there were job listings on Python.org!! I need to apply for some of these right now
&gt; Wouldn't it be nice to pull in a python module, do a dir() on it, and get a list of things that are important to the user Docstrings are good for this. help(obj) Or, if you want code, re-use the "\_\_all\_\_" convention from modules in your class. &gt;&gt;&gt; Klass.__all__ [ "methodx", "methody", "membera" ] If you're clever, I bet you can make a decorator that adds a method name to the class' index. @public , perhaps?
I just started looking at [Python for Unix and Linux System Administration](http://www.amazon.com/Python-Unix-Linux-System-Administration/dp/0596515820/). It seems an interesting idea. The first chapter is all about using IPython as your shell, but then it goes into scripting.
But bash looks horrible, and is naff for doing maths in. I just want to be able to run multiple experiments, parse the results, and then do statistics all in one language. Neither bash nor python let me do all three points without also looking horrible, or relying on the other language. Okay, okay, in Python it is possible to run a separate process, and read what it writes to stdout, and you can certainly wrap it in your own special function, but it is not backticks, and that makes me sad.
I completely agree with you. I just remember I couldn't get to cracking classes until I saw them as super functions with memory. Once I saw them like this and made them work like this, inheritance and special methods starting making more and more sense to me as my needs grew up. Granted 2 years in on classes and I am still a nub with them. I just remember my own a-ha moment about them and thought I mention it as a way to get-to understanding them.
that was my point (thought the perhaps at the end would denote a soft scoff). if you're using the same script over a multitude of operating system versions, you're most likely not going to have them all running 2.6, and if you are that seems like more overhead to have than relying on bash in those cases.
if this-&gt;isnt() ? s = self : print "meh"
Easy to do in Python. _protected __private __no_seriously_do_not_touch__ 
s/not a very unix/retired-in-place/ All of the good unix people I know are fluent in a real language like Python, Perl, or Ruby. There are people who still only use /bin/sh but they've never been worthwhile technically - doing that in 2010 is really a sign that you aren't interested in improving your work.
I've been using python this way for years and have recommended it in a couple conference talks [for mac admins](http://code.google.com/p/pymacadmin), too. I generally follow this rule: if the entire script won't fit in an 80x25 window or requires an array or other non-trivial structure, use a real programming language. The only valid critique is that if you're using an antique Unix you'll need to install Python but there are binary packages available for Solaris, AIX, etc. so it's not that much of a challenge for most places. Otherwise, it really gets into whether or not you have colleagues who feel strongly against this. If they're /bin/sh or Perl die-hards, feel free to ignore those concerns if possible and you're not within a year or two of retiring; if they were, say, a Ruby shop I'd follow convention because that's a modern language and there's little benefit for debating Python or Ruby when the alternative is a stick in the eye.
The oldest supported RHEL ships Python 2.4, which is going to be an enormous step up from any version of bash ever shipped if you need more than a one-liner. There's almost no knowledge to "backport" - what does that even mean beyond knowing which stdlib modules weren't added by then? - but that's a distraction because bash doesn't have a standard library at all. (or error handling, unicode support, usable/complex data structures, etc, etc) The first time you need to write an ini file, deal with XML, operate on the network sanely (no, /dev/tcp isn't capable enough to count), etc. you're looking at something which is standard in Python and requires an enormous amount of work to do in the shell and/or installing an external program, just like Python except it's different for every task and you'll need to learn a bunch of command-line syntax and escaping which doesn't apply as a concept to Python code. There's a reason most of our scripts shrunk to about half the previous size when we switched from /bin/sh (or even Perl) to Python…
it's more difficult to do file manipulation because there's a textual overhead associated with shelling out to cp, ls, mv etc. and an overhead with using the python built-in equivalents that being said, it's a helluva lot easier to do anything with even a modicum of decision-making or input manipulation.
I agree with your general point but would note that process management is actually a lot harder in Bash once you start needing to deal with complex redirections or error handling, both of which are [very easy to do using subprocess](http://docs.python.org/library/subprocess.html).
Look at the subprocess module: [Replacing /bin/sh shell backquotes](http://docs.python.org/library/subprocess.html#replacing-bin-sh-shell-backquote)
I can't recommend it enough once you start building complex sites: definitely a "Why did I think I was saving time not learning this?" moment
I frequently use Python to script together utilities.
Docs are updated for 1.2 Finally also includes installation instructions :)
Docs are updated for 1.2 Finally also includes installation instructions :)
Supported doesn't mean people don't run it, so support aside, 2.4-&gt;2.6 have a large difference in the stdlib, and running 2.4 code on 2.6 is just not fun, as you don't get to use everything available, everywhere. (main example I use being some webby stuff, and multiprocessing (which is backported to 2.4, though not 2.3)) Bash does have error handling, traps, and you can just as easily examine return codes. It also does unicode, if it didn't you couldn't use unicode paths in your directory tree or to make your shell prompts pretty. That and claiming python has good unicode support isn't really being honest, since that's a main push of the 2.7,3.x stuff, which in turn make the libs unicode friendly by force. No one cares about data structures in bash, because once you're using them, you're not shell scripting any longer, you're programming and might as well switch to python (or whatever) for that. But if you were thinking dicts and array's it has arrays, and awk has associative array's a simple enough dict in a pinch. Saying it also has no library is a little like saying the GNU tool chain doesn't exist. If you using bash the library is the os, and all the bins it provides. bash though also gives you coroutines, and os level job control by default. It also has fun things like dir stacks (pushd/popd) that allow you to have temporary dir changes, that will keep the original starting dir at the bottom of the stack. It's got a lot more in it than people give it credit for. My main point being though that python everywhere all the time is a bad place to put oneself. Knowing bash (and for that matter you GNU tools) is an essential piece of knowledge to have. I use python for lots of things, but in this debate I am claiming bash isn't usless because when it came time to make a backup system leveraging rsync, it's simpler to make a ~200 line backup command, and add some bash exec hooks to an rsync daemon than expect that I had python everywhere at an acceptable version and mostly to not be forced to use 2.3.4. I also wouldn't use bash in the examples of xml, or server like interaction, but in those instances, that's pushing a shell script a bit far anyhow. I feel thats more of a program straight up, rather and a collection of shell commands.
In other news, we are seeking an immediate welder to help repair damages to the titanic. Great benefits! 
If in your python script, you are making lot of external calls/using other scripts with subprocess, that is a hint -- use a shell script instead. Many may argue bash doesn't have lot of stuff, well it is not the only shell. Zsh is way more better and advanced than bash and highly suitable for scripting. As some interview question/answer analysis stated -- someone wrote a 200 line code something for which other guy used grep + some glue code and the latter performed well with all edge cases covered. Guess who got the job ?
[Paver](http://paver.github.com/paver/) or [waf](http://code.google.com/p/waf/).
What about [Scons](http://www.scons.org/)?
Some people even have IPython as their default login shell (less crazy than emacs, probably).
Well, I wasn't here 2 years ago so I stand by my upvote, sorry as I should be :)
if you want rake with some capistrano thrown in, there's [fabric](http://docs.fabfile.org)
`d = {k:v for k, v in iterable}` works in Py3K but not in any Python 2.x
Well put- this is probably in line with what you are saying:http://media.pragprog.com/titles/ahptl/chap2.pdf I've always thought the difference between a professional and an amateur is that the pro "makes it look easy." Some people see guys doing play by play for a sporting event and think - "Wow- that looks easy, he gets paid to talk about sports, I could do that!" Then they get in front of a mic and freeze. The difference between the amateur and pro is the 1000s of hours of practice. So I just need to keep practicing :-) 
Cheers, I'm certainly aware that there's ways to do it in Python, but... ...it's not as nice looking as backticks. :)
womp womp
True it's not as nice looking, but it would be pretty easy to wrap that in a function that would take a string and split it, or take a list/tuple and apply directly as an argument to Popen.
You'll probably want to get familiar with `virtualenv` and `pip`. The ["Tools of the Modern Python Hacker"](http://www.clemesha.org/blog/modern-python-hacker-tools-virtualenv-fabric-pip/)
After having figured out how perl did OO after perl5 came out, python's support seemed familiar, refreshingly easy, and sensible.
I agree it's convention, but disagree that it's hackish. It's been documented to hell and back again, and the basic inspection tools should tell me as much as they can about an object when I look at it. Everyone knows about it, so it's not like it's something that's little-known and unsupported.
 from multiprocessing import pool p = pool(5) p.map(main, [args]) How could bash be easier than that? 
Yes, that is an example of doing something the wrong way. I can't find anything that is easier in bash. I know bash. I know python. I don't see any reason to use bash.
And Python is super easy to handle message passing, blocking until a process finishes, sharing memory, or rejoining the process.
Right... and it is easy enough to code for 2.4 without requiring libraries and still having more functionality than bash.
That is called 'being stuck in the past'. Python is where the cool kids are.
From an operational point of view, if the machine is that old the it needs to be upgraded. So, I then make it happen.
I stopped trying to predict who would go down. Myspace has been struggling and pretty much nonviable forever now imo, but they appear to still pay their employees as they've made improvements lately (source: Facebook status of friend, probably unreliable since they're still using Myspace.) I also thought Yahoo was going to die years ago and for some reason they're still around (perhaps to help keep the trolls in yahoo answers?) Could be some lucky person will get a few good years of experience and have their career catapulted. 
Except this isn't quite valid. If grep + some glue code will do it, then a proper regular expression in python plus some glue code will do it just as fast. If it is as simple as a grep one-liner with a pipe then of course I would do it that way, but that is standard linux use. Nothing wrong with piping grep to a python script.
Rumor has it they use Pylons
I actually saw this the other day when I made a presentation about Python for class, I made an image for it but i'll post it later. (To edit)
MySpace is still going because it was purchased by Newscorp at its peak. For $580 million. Even Rupert Murdoch can't just admit that he flushed half a billion dollars down the drain and move on. MySpace will be around for quite some time, as they frantically try to make a bit of money off it.
That's a debatable issue, and I'll admit that there is a point when bash loses to python, but that's not to say python wins in all and every case. As if you're going to just use python like bash (lot of popen/subprocess) just use bash, if you're instead using libraries of python, stick with it. Though I argue that's less shell scripting, and just plain scripting.
I highly suggest [Waf](http://code.google.com/p/waf/).
I did something like that recently (though not 20 lines). I was writing a shell script, and I needed yesterday's date in a certain format. So I just added the following line: YESTERDAY=`python -c "import datetime; now = datetime.datetime.utcnow(); print (now - datetime.timedelta(days=1)).strftime('%Y%m%d')"` When the code got reviewed, my much more 1337 coworker noted that you can just do: YESTERDAY=`date -d yesterday '+%Y%m%d'` I stand by my approach which took me 1 minute to write after spending 15 minutes trying to figure out how to do it in bash. Sometimes the low-time approach is the right way to go even if it's not optimal.
That's not really true, as bash has poll/wait/kill/trap which with them you can do all that subprocess provides, as well as backgrounding, subshells, and coroutines. Not to mention a simple way to make daemons with disown. The GNU toolset provides more command line process control than python's subprocess mondule does anyhow, as most of that work is set about replicating what bash already has, albeit in a nicer more pythonic way.
not really applicable. legacy machines don't just get upgraded, that's why they're legacy. They'll usually be replaced, but when it is forced upon the company. 
1. that's only offered by default in python 2.6+ 2. it's already in shell land with [xargs](http://www.xaprb.com/blog/2009/05/01/an-easy-way-to-run-many-tasks-in-parallel/)
It's the natural end for social media websites that get too large. The community becomes washed out by poor one line attempts at humor and the users who would flag or downvote that content are outnumbered. Then the users move to another site that still maintains a smart and interesting community where the comments are often more interesting then the articles themselves. Reddit is well on its way there, most of the larger subreddits are already pretty terrible, luckily the smaller ones provide some of what I'm talking about.
A small, family-like team with an HR director. Mmk.
[Not Me!](http://www.reddit.com/r/reddit.com/comments/d5zy3/wondering_whats_been_going_on_with_digg_read_this/c0xtzkv)
They're probably going to be using [Reddit's code](http://code.reddit.com/).
Where do we go after Reddit?
diggit ftw
you can do a bit more with date than that as well: date -d "15 days ago last friday" +%Y%m%d will do exactly that.
Working on it ;)
Can I get a beta invite?
I'll PM you a link to the shonky pre-pre-alpha version if you like...
sweet sagan and all his great ideas! I've been bash scripting for a while now and I never realised you could do *that*. Thank you for a rather nifty example - now to find a place to use it. :)
I use it for a rolling window of dirs that are in 12_06_2010 format for dir_name in $(ls $dir_path) do dir_date=$(echo $dir_name | sed -e's/\_/\//g') if [ $(date -d "$dir_date" +%s) -lt $(date -d "$window_size days ago" +%s) ] then rm $dir_name fi done
i just did that for shorthand, i meant, you pass the array or arguments so like main(5) would become p.map(main([5,5,5])) And why is requiring Python2.6+ a drawback?
Lol? I have control. I'm sorry that you feel that way. Not all company's are so short-sighted.
Well hell yeah, I'm all about alpha testing ;)
This sounds alluringly mysterious. Care to give us a pointer to your project?
A terminal one liner is not exactly the same as bash scripting to me because you are not using bash functions... you are using some other binary. I'm focusing on anything that would require bash control structures and vars. I use pipes and python scripts, and I rarely, if ever, use subprocesses.
again, it's not that it's a drawback. I'd love to have 2.6 on all my server. Its not something you can count on, as upgrading might break os level scripts requiring python, and installing a second python just to run scripts is a bit overkill in most instances. It's also pose the question: if I have to install all this for every server I run, is it an edge case that wouldn't be better served by what's provided by default.
Perhaps then you'll be just fine, though shortsighted is different than accepting that companies run stable builds, and leave well enough alone.
I'll send you a PM too, though as above, it's such a prototype that it might not stand up to scrutiny of the implementation :) Have a look at the message and let me know what you think. PS I'm not keen to make the link public because I'm sure it'll fall over horrendously with more than about 3 users!
Why the downvotes? Seems an interesting q to me. Even more interesting would be some pointers to some comparisons between the tools (&amp;/or with Rake).
If I promise to submit bugs and try to break things, can I as well? Have nothing to do tomorrow morning at work.
good.
|
They were actually profitable after the first year IIRC 6 adverts per page has that effect sometimes. AOL paid 500 Million for bebo and are now thinking of just deleting the site as they can't even pay server costs.
Ok sure! Right now the thing that needs most bug-searching is the concept itself; PM on its way, knock yourself out!
[Do-it!](http://python-doit.sourceforge.net/) is an automation tool, and it has specific features that make it a 'make' alternative.
That's not a bash-ism, of course. That's gnu date magic.
On the opposite end of the spectrum, I worked at a place once where the idiot in charge would write thousands of lines of perl (no functions, no-siree!) and in the middle, to get things from files he'd invoke open(CMD, 'grep pattern /filepath|'); hundreds of times in his code (hi Ryan, if you're out there!). Because 'grep is written in C, so it has to be faster'.
All this secrecy ... now I too would like to know what it is!
Sometimes you can do it, sometimes it takes 6-7 figures of $$$ to replace something. Installing a python interpreter is more economical.
oh- if you could bring a mop too--- that'd be great, tnx!
Real life example of why classes are good: Quickbooks has a web-based version of their small business accounting software. I use it to keep track of my business finances, but downright loathe how it handles timesheets (used for generating invoices that I send clients). So I wrote my own timekeeping app. However, to make sure my books are accurate, my office manager has to print out the invoices in the timekeeping app and then do manual data entry into Quickbooks. It's a lot of pointless typing. Now, Quickbooks has a way I can pass data to and from their web app. This means I can have my timekeeping program automatically create matching invoices in Quickbooks so the data entry method can be skipped. However, the Quickbooks API is XML-based that uses session tokens and SSL for authentication. It's a real pain to work with because of it's complexity. So I am in the process of writing a Python-based wrapper that handles all of these complex things behind the scene. I intend to release it as an open-source project so other developers don't have to go through the same headaches as I did. They won't even have to know XML. The end result is a "black box" where I just pass in some simple data and get some simple data neatly back. *How* it works is irrelavant, they just write: qb = pyQBOE( intuit_url = "webapps.quickbooks.com/j/AppGateway" ,key_file = "./my_key.pem" ,cert_file = "./my_cert.crt" ,app = 'myapp' ,conn_ticket = 'TGT-103-zH0474534_r9DSDTcevQ' ,appid = '182456972' ,appver = '1' ,debug = False) customers = qb.getCustomers() for customer in customers: print customer.full_name 
Python can handle stin and stout better then you would (I did) expect.
Either this doesn't have anything to do with Factor, or Factor is not a Forth at all. The crucial point of Forth is that you don't have the distinction between the interpreter and the program being interpreted, at all. Forth being a concatenative language is a pretty insignificant property, in comparison. If you can't even imagine how that would even be possible, to not have any distinction between the evaluator and the program being evaluated, read [jonesforth](http://www.annexia.org/forth). Understanding how is this even possible is important. It is important because it gives valuable insights about programming at large. It is important because if you understand this, you can see that [return to libc](http://en.wikipedia.org/wiki/Return-to-libc_attack) is possible because any sufficiently large executable contains a Forth interpreter, and their "return oriented programming" is just the threaded code reinvented. Last but not the least, it is important because it provides a valuable perspective on different programming languages and their properties, most notably Lisp. As in, smug Lisp weenies (who can't take a joke btw) want you to believe that shedding all this syntactical bullshit and operating directly on the AST level gives you a lot of power and that is good. Because Lisp is kinda pinnacle of shedding evaluator crutches, and it sure is powerful as a result. This is not true, because Forth is the pinnacle, actually. As we dissect an imaginary Visual Basic compiler, Lisp sits at the point where the syntactic parsing is complete and the AST is being evaluated (and if you are allowed to do stuff at this point, you are being empowered), while Forth sits at the point where the evaluator decides to recursively evaluate a subexpression and use the returned result. Which gives you a lot more power, if you can operate at _that_ level, but also drives home an extremely important point: Forth is still awful and disgusting and unmaintainable, and is so by design even, so raw power available doesn't equal usefulness. You can see that additional point of data which shows that usefulness goes down drastically with more power added (and it's not Assembly, it's an ultra-high level language!), which allows you to think that maybe the power-to-usefulness graph is not an exponent ending with Lisp, maybe it is shaped as a hump, and the maximum is _before_ Lisp, somewhere between Lisp and Visual Basic. **EDIT**: When I talk about "power" here I mean the readily available options. Most programming languages are Turing complete (C is a notable exception, ask me about it), but there's a difference between being able to define a macro and being able to emit and use some MSIL code.
The beauty of Reddit is its subreddits. If the mainstream content on Reddit gets uninteresting, you can find more subreddits and subscribe to them.
Man, I'm always wrestling with the correct way to use the logging module.
in python, methods which are implementation details should be prefixed with _ (underspace). that way, when you look at a class, all the _ prefixed methods are "private", but you can still see them if you need to. can i get a PEP?
Hacker News, or Less Wrong
It needs a policy maker with some vision.
Me too, please?
Hopefully Reddit's structure will prevent or at least diminish that effect. When a particular subreddit gets too fucking retarded, we can just unsubscribe and move on. I'm amazed at how many isolated, yet vibrant communities are on reddit that are pretty much hidden from the default front page and the more mainstream sections of Reddit.
I first came up against classes in Excel VBA and it took a while to figure out what was going on. I'd heard of OOP and knew the general concept - encapsulate the data along with the functions that operated on it. However, I was only doing Excel macros as a peripheral part of my job (electronic engineering, not IT) so wasn't interested in studying up further on OOP. I'd been used to working with Excel 4 macro language then suddenly in Excel 5 or 6 (can't remember) this crazy VBA stuff came along. Dots all over the place. Some of the things after the dots were called methods, some properties and I couldn't tell what the difference was. I was quite confused but got used to looking up the help for both methods and for properties - if I couldn't find what I was looking for in one I would find it in the other. To start with I had no idea what was going on and leant heavily on sample code to get things working. Mostly I had no idea of why things worked or what each line of code was actually doing - I just kept tweaking the code until it stopped throwing errors and started doing what I wanted. After several weeks of this I realised one day that everything had become understandable without me noticing it - methods were functions, properties returned data, some properties were actually objects in themselves and had their own methods and properties. It had all slotted into place unconsciously, without me being aware of it happening. Suddenly I realised the object model made sense and I could use it without having to just copy and hack other people's code. By the way, I'm fully aware that VBA isn't fully OOP. But it is enough to be able to get the basics of OOP by just using it, without knowing any OOP theory. Since moving into IT and working in C# I've taken the time to learn OOP principles properly.
you'll have to do something like: BlankString = BlankString[:LetterLocation] + CurrentGuess + BlankString[LetterLocation + 1:]
The first class that really made sense to me was a barcode class (in a C# application). Users scanned a barcode which was then validated. If it validated ok it was entered into the order system. The barcode class was really simple - the Barcode property output the barcode converted to a number, and the Validation method checked to see if the scanned barcode was valid or not. The Validation method was called automatically in the class constructor so when the barcode was scanned it would be validated automatically. Looking at this simple little class I finally got why it was a good idea to encapsulate everything in a class. The class was used all over the place and, since the validation was included inside the class it just happened automatically, like magic, wherever the class was used. Brilliant!
Definitely, though I was joking, I don't want to move anywhere anytime soon!
It's not a real Factor implementation, but I think it's incorrect to say it doesn't have anything to do with the language. The syntax looks the same.
I use a function in Vim to simply alert me while typing: function ToggleOverLengthHi() if exists("b:overlengthhi") &amp;&amp; b:overlengthhi highlight clear OverLength let b:overlengthhi = 0 echo "overlength hilight off" else " adjust colors/styles as desired highlight OverLength ctermbg=darkred gui=undercurl guisp=blue " change '81' to be 1+(number of columns) match OverLength /\%81v.\+/ let b:overlengthhi = 1 echo "overlength hilight on" endif endfunction map &lt;silent&gt; &lt;C-l&gt; &lt;Esc&gt;:call ToggleOverLengthHi()&lt;CR&gt; NOTE: I chose 81 because 79 is end of code, 80 *should* be the newline character, so if I have something at 81, I'm doing it wrong. SOURCE: https://github.com/kmwhite/skel/blob/master/.vim/functions/toggle_overlength_hilight.vim
[EPEL does let you install Python 2.6 in RHEL](http://download.fedora.redhat.com/pub/epel/5/x86_64/repoview/python26.html); so that helps a little.
I usually just do a 'set textwidth=78'.
God, I hate that stupid recommendation ! And especially the nonsensical "reason" for it - some poor schmuck might be stuck on an 80-character terminal. Aww! Some other poor schmuck might be stuck on a teletype, or an N900, or whatever. Why are the rest of us "crippled" on their behalf? And I would be grateful if you c- ould explain how splitting a con- cept over multiple lines manages to increase the readability Pshaw !
Me too ... I feel strange and tingly, like I'm witnessing the very beginnings of a brilliant viral campaign or something ...
&gt; Most programming languages are Turing complete (C is a notable exception, ask me about it) C is most definitely Turing complete, disregarding the limited memory of modern computers on which every language is technically Turing incomplete.
What do you mean by "point to" ? class A: def set(self): self.i = 0 class B(A): def method(self): self.set() Seems to me like B is "pointing to" A in that example, and I can think of no way for A to be aware of the existence of B, let alone "point to" it. OTOH, I agree that "if b is thrown you can catch it with a" so I obviously do not understand how you are using the phrase "point to" 
I know people who have wide screen monitors set up so that their text editor shows 80 lines and the have a browser or other application open with the remaining space. I don't necessarily encourage strict adherence to the 80 column rule, but it's not a bad goal.
I have a similar scheme that doesn't have a toggle: autocmd FileType python match Error /\%&gt;79v.\+/ I'm not sure why you'd want to toggle it off; over-length lines are *supposed* to be annoying.
I usually just do: &gt; set colorcolumn=79 Which gives me a nice highlighted column indicator.
I agree--sticking to &lt; 80 characters while writing is often annoying and can reduce readability. However, it is nice to limit the number of columns: 1) When reading someone else's code 2) When reading/writing code and you want two files side by side The way I envision this script working is you could tell it to edit the file in place or output the column limited file to a new file. edit: formatting.
I do the same thing in vim, and it has been very helpful. However, I've found that trying to limit the number of columns while I am writing can interrupt the flow of code and sometimes reduce readability. It would be nice to have a script you could run (such as before a subversion commit) to restrict the number of columns in a file to &lt; 80. Looks like I might get to write this one.
&gt; And especially the nonsensical "reason" for it - some poor schmuck might be stuck on an 80-character terminal. That's *a* reason. An old one. Today the reasons are more varied. Such as: * Typical screen widths are evenly divisible by 80 allowing for code to be placed side by side uniformly * It's been shown that the longer a text line is, the more likely it is to slow down reading and comprehension [citation](http://desktoppub.about.com/cs/finetypography/ht/line_length.htm) Ideal line length is 39 regardless of font size. When you throw indentation and formatting into code, you'll probably find most of your lines hover close to or at that number (e.g. 80 ~ 2*Ideal line length) * Convention. In existing projects, uniformity of formatting is very important. By convention, most projects require 80 columns. So it's not *just* that old 80 character terminal. :)
&gt; I've found that trying to limit the number of columns while I am writing can interrupt the flow of code and sometimes reduce readability. All PEP style guides are recommendations that should not be taken as hard, fast rules. If breaking a line at 80 columns would reduce readability and code flow, then you shouldn't do it.
You are right. The time is what is important. That, however, includes future maintainability too. I don't think your example is more complex to read even though it is longer.
To scour old files... I really, really hope you would use a standardized utility than a standalone script.
If you call Perl's special symbols prettier also, then I would understand your point.
OMG ITS A PIPE What are you insinuating?
[the goto decorator](http://code.activestate.com/recipes/576944-the-goto-decorator/) :O
Yahoo! still has a lot of talent and goodness. If they ever find their direction I would expect great things. Of course, the same could have been said for Sun. 
perhaps you need to look at that a little closer. those are directories named 12_01_2010. then changed to 12/01/2010 to compare against another date. it's not like I'm using find to look at modification times to then compare. It's all based on directories, and removing the directory of a certain name is the only requirement.
Also: I might start over if I were the OP Then brew install python (re-symlink sys /usr/bin/python -&gt; /usr/local/Cellar/(whatever)) brew install virtualenv brew install virtualenvwrapper Then read about virtualenv and pip 
May not be entirely applicable to WX but the Gnome human interface guidelines are decent reading: http://library.gnome.org/devel/hig-book/stable/
Thanks, I appreciate the help. I was hoping for a way to get this done if I had multiple words to guess for the game, and to check it all at once. Like if the answer was Los Angles, I'd have ___ ______. I'll just have to break it down word by word. Less elegant than I hoped, but it'll do just fine. Thanks again!
 import os from datetime import datetime, timedelta for directory in os.listdir(path): if datetime.strptime(directory,"%Y_%m_%d") &lt; (datetime.now() - timedelta(windowsize)): os.rmdir(directory) I'm not seeing the benefit of bash scripting. But for any kind of scour operation, because they are so common, I'd require my people to have configuration in a centralized place with a centralized utility. Too unmaintainable otherwise.
You also might want to try pyQT which is a set of python bindings for qt. It's pretty easy to get used to.
Okay dammit now I'm curious. Can I get an invite as well?
Me too!
Maybe. We never really grow up, we only learn how to act in public.
true.......true...I'm so confused
imo.im look's awesome to work for.
So that only works on python 2.5+, kinda what I've been getting at. If you have machines with software that can't be upgraded to rhel 6, you're aiming at many different python versions or installing a standalone python version for each os instance. So a downfall, as you asked for originally, is that you have to install new pythons all over the place, instead of relying on the GNU tool chain. If that's something you can do, more power to you, and you original question was kinda useless. If you can make your cake and eat it too, you're fine with whatever you choose to use, be it perl, ruby, erlang, or lisp. 
I'm not sure at all, I was hoping for the same thing (comparisons between the tools or rake).
also: * some people say also for printing code (as in paper). I'm not sure why someone would like to have code in paper, but I'm not judgmental. * also 79 and not 80 because diff adds an extra character before the line, so reading/printing/wtv a diff would give you the 80 lines. 
Do want Edit: kinda
We should have a subreddit for Python GUIs. I myself even made a post about this once. To answer your question, I would go with PyQT if I made GUI applications with Python. But I usually don't (aside from a few "Hello World" GUI programs). I either go with a web interface or straight up command line.
Back to the mothership, either Slashdot or 4chan as appropriate.
FFS AO-fucking-L is still alive and kicking, now that they've stop cramming every crevice in the universe with their damn CDs.
Searching is a great resource.
Any chance I could get an invite as well?
Meh, I know. I just think name mangling and naming conventions are a bit hackish when we've already got perfectly good public and private sections.
Python uses more memory and requires more disk space to be installed. This is might be important in small resource constraints environments such as embedded systems or small VMs. Also the shell is always running and so shell scripts should start up faster than Python scripts. 
This is probably the only real drawback in this whole thread. Thank you.
Reddit will also go through a process of Diggification.
I contributed to a pygtk based application for a year or so now... I hate GTK. Hate it, hate it, hate it. pyQT is so much more intuitive. On more than one occasion I've seriously considered rewriting the whole application to use QT.
I myself learned of these magical incantations using `at`
What app? I'll help if I can.
Which library you use to create the GUI is secondary, though I personally would recommend (Py)Qt. More important and a lot harder, than I previously thought, is the process of designing the GUI itself, i.e. trying to understand what the user wants to achieve with the program and enabling him or her to do it with only minimal annoyance. I started writing GUIs for automizing experiments in my lab this summer and watched other people using my software. Oh, the horror! Try to focus on the user and the task he or she wants to achieve with your program. Think first, make buttons and shiny things later! Keep things simple. I recommended this book before, but I'll gladly do so again. Read Alan Coopers 'About Face', if you can find it in a library. The guy has put a lot of thoughts into designing interfaces and even if he gives little recepies of how to do it right, you'll get a good feeling of what to avoid. Tldr: Focus on the user, not the tools.
I spent some time learning Tkinter a few months back. I could get everything to work, but like you I found it bland-looking. Based on a suggestion I read here, I started investigating web2py, and using a web-interface instead (even though I only ever intend on having the web2py server running locally). I've found it to be far, far easier to learn and it produces much better results visually. Obviously it depends on exactly what you want to do, but it's worth considering.
The question is: What is great? Is it flashy? With lots of gradients, nice custom colors and web 2.0 buttons? Or is a great GUI a GUI that is highly usable and doesn't stand in the user's way? I tend to be in the latter camp. Currently I'm building an app for professional powerusers. There the answer is easy. Usability is extremly important. I'm using PyQt (wxpython is also very good) and the windows 7 standard scheme with some custom icons and logos. A really great ressource on GUI design principles can be found at Microsoft (see the whole section): http://msdn.microsoft.com/en-us/library/aa511440.aspx If you want "eye-candy" then with PyQt you can use style-sheets or customize the look and feel completly. But I wouldn't be to fancy here. I think something like ccleaner has a nice GUI with standard elements for usability but a unique scheme.
I'm interested.
That's not nonsensical, just irrelevant.
I noticed that in the python podcast I was listening to this morning. "Well...uh...the documentation isn't that good. But...yeah it's not backward compatible...wait yes it is!"
i wouldn't work there solely on the basis of the phrasing "re-start up". which should really be "re-startup", but whatever :p
&gt; tons of 'em 32 to be exact. :P
I still can't get my mind around decorators. I've read about them and I've tried to use them, but I still can't figure them out.
PySide is the official Qt Python implementation. That's said, I don't know if there is something wrong using this package (I just started to dive into Qt with Python). I guess it should be better maintained than PyQt in the long run.
I too request this please :).
You know what if they are starting over this wouldn't be a bad place to start. 
Unless you enjoy wrestling, why not ask for help on comp.lang.python when you run into problems?
Learn by example. Look at great GUIs, both the ones that you consider great and the ones that get a lot of praise for greatness from other people. Look at Mac apps that get a lot of love. Read the Apple Human Interface Guidelines, they are by far the most complete. Even if they refer to Mac apps, the guidelines are universal. Widgets compete for user attention. Simplify, simplify, simplify. Read Kathy Sierra's blog (even if it hasn't been updated in ages), Read [37signals' weblog](http://37signals.com/svn). And if there is ONE thing I could warn you about is white-space. Pay EXTRA care to the space between widgets, the space around the edges of the windows. The HIG touches this but I cannot stress enough how important this is. Most of the sloppy UIs I've seen had very bad white-space. 
How does it work ?
This can't be repeated enough. If you have had one hour to prepare for making a great GUI, you should spend 5 minutes finding the best tool and 55 minutes reading human interface guidelines and thinking about what you are going to design.
&gt; Read the Apple Human Interface Guidelines, they are by far the most complete. Even if they refer to Mac apps, the guidelines are universal. This.
Sadly, some of the things there are labeled decorators but just plain aren't. For example: Recipe 576957: Asynchronous subprocess using asyncore (Python)
I'd like to add to that question: An important point of a "great GUI" is *responsiveness*. With Python programs I often observe, that when the program is doing a lot of work, it get's unresponsive (even greyed out by Compiz on Ubuntu). I have looked at the underlying code and talked to developers in some cases (namely exaile and quodlibet when using the autoqueue plugin). In the first case the GUI freezing was improved by adding a time.sleep(0) to a loop to release the GIL; a trick I googled, not 100% sure, that actually does what I think it does. But there are still cases, that lead to freezing. This is probably not the GIL, but actual CPU load. In the second, the developer moved some CPU heavy stuff into a separate process to completely decouple. Still the quodlibet GUI freezes, when autoqueue is looking for recommendations. So my question is: How do I really, 100%, always, guaranteed separate the workers... with database lookups, retrieving data from the web, writing a lot of data,... things that are slow and may fail... from the GUI? But not just "use an event and write a callback, duh!". My two examples do that, but the problem is still there. How to prevent eg. CPU starvation in the GUI thread? Recommended read? Tutotials? Recepies? Suggestions?
&gt; Most programming languages are Turing complete (C is a notable exception, ask me about it) Excuse me? Please, go on..
Over the last weekend, I tried out Flask on a project of microscopical scale. While not representative to the work I have in mind, I have to say that I liked my first hour of Flask *a lot*! Still, I shall give the other contenders a try as well.
The problem with C is that it can address a limited amount of memory by design, unlike most other modern languages. In Python or Java you can (theoretically) take a running program and convert all pointers from 32bit to 64bit to make use of some additional memory that you just hot-plugged, and the program couldn't possibly notice anything. You can't do that in C because it has an interesting property that I might call "representational transparency": for any value of any type you can call `sizeof`, allocate a sufficient array of chars and `memcpy` the contents of the value there, and you are guaranteed by the standard that if you then `memcpy` the contents back into another value of the same type, you get the equal value. Also, `sizeof(sometype)` is guaranteed to return the same value during the lifetime of the program, of course. Which means that 1. all your pointers can address a limited amount of memory, 2. you can't cheat and associate some hidden state with them (and then follow assignments etc) which would allow addressing more memory, because two pointers which have the same apparent representation must point at the same address. By the way, regarding having nontrivial inner structure in pointers: by itself it's allowed by the standard which clearly states that pointer arithmetic is undefined outside the allocation unit (a single structure or array in automatic storage or a single block of memory returned by `malloc`), so you can write a standard-compliant C compiler that doesn't allow buffer overflows for example. But all that structure (like the buffer base address and size, in addition to the pointer itself) must have a defined size known at compile time. Then it turns out that the standard doesn't provide any interesting functions like `chdir` which could be abused to store arbitrary amounts data in the file system (by nesting directories to arbitrary depth) -- only that much files that you can name with finite strings, each containing no more than `size_t` chars. Which is _a lot_, but we are being pedantic here, aren't we? Of course you can say that your C program should emit commands on stdout (move the head to the left/right, write a symbol) and read current symbols from stdin, then C _is_ Turing complete, but other languages don't require such tricks, which is interesting.
[Here!](http://www.reddit.com/r/Python/comments/eidjg/factor_implementation_in_150_lines_of_python/c18etef)
Reading text is very different from reading code. I doubt that the same principles apply.
Hey - I said that! https://twitter.com/#!/voidspace/statuses/12518680168501250
I think you just broke an unwritten rule of r/Python and that is to never ever ever mention PyGTK. Even if GUI toolkit preference is entirely subjective and based on preference, No one is allowed to mention PyGTK (except as a warning to fellow redditors). /s
Sorry for commenting 8 days later, but what do you doubt about it? It's how the GPL works.
I've been doing OOP for a long time so the concept of classes wasn't a huge step in python. I believe that python gives you a lot more flexibility in classes (no private members, etc), but that means you have to be a bit more disciplined with your coding. 
i want one
&gt;It's about information overload. If I can't easily partition someone else's classes stuff into "here's whats important to you, the user" and "here's whats important to me, the implementor" Although it isn't enforced, doesn't double underscores imply a "private" function in python (as in, ignore this function, fellow programmer, because it's not for you)? 
Ok, so you just said it yourself at the end. C *is* Turing complete by using I/O channels to represent storage.
I was talking about the underlying mechanics. In C++, you can define a super class pointer to an instance of a class lower in the hierarchy. That's what I said and that's what I mean by a can catch b.
I also said that I consider it important that Java or Python do not need a very specific external entity, not mentioned in any standard, to represent storage. If I only knew C, C++, Pascal and the like, I would say that this external entity is trivial enough to make the pedantry _completely_ pointless. Like, it is obvious that in a system *"C program + tape device connected via stdin/out"* the bulk of Turing-completeness resides in the C part, so to speak. But since I know that such an extension is not required by some other languages, the fact that it is required by C gains some significance in my eyes!
I hear virtualenv is the solution. I have yet to look into it myself, though.
I've never heard of that. Thanks. That's a nice key word for a Google exploration.
yup, that with the virtualenvwrapper and pip make life pretty simple.
 public_dir= lambda x: [s for s in dir(x) if not re.match(r'^_', s)] public_dir= lambda x: [s for s in dir(x) if not s.startswith("_")] 
You need to take your sarcasm detector in for repair. It totally missed the /s
I would've suggested wxpython but it seems you're already using it. Go through the sample demo included if you haven't already. This should give you a good idea of some of the features you can add to your GUI. Try to see what kind of elements you can blend together (ie. textbox inputs as tree elements). wx is pretty powerful and is great for getting that "standard" GUI look. You also have to remember that the flashiness of your program shouldn't get in the way of usability. Case in point, GUI2exe: [link](http://www.blog.pythonlibrary.org/wp-content/uploads/2008/08/gui2exe3.png) *\*shudder\** The screencap might not look that bad but they abuse the hell out of tooltips which open immediately on everything and don't always disappear on their own. 
Anyone mind doing a tl;dr?
When a logging event occurs which needs to be output to some log, the behaviour of the logging package *when no explicit logging configuration is provided* will change, most likely to log those events to stderr with a default format.
Thanks!
For those interested, [Instant Press](http://code.google.com/p/instant-press) [[video](http://www.youtube.com/watch?v=gtdJ5JCxiJQ)] [[demo](http://instant2press.appspot.com/)] was the winner of web2py Application Exhibition 1.0. Some other web2py-powered sites and applications can be found [here](http://web2py.com/poweredby) and [here](http://web2py.com/appliances).
I used to use print x and print(x) inconsistently until I heard that python3k would have print(x) and since then I've used print(x) in all my code regardless which it is edit. python3k as in well before python 3 actually came out
Why do you feel that way? Care to explain a bit more? You can always just put #!/usr/bin/env python2 or #!/usr/bin/env python3 there
To which package does mpmath belong to? 
I recommend: http://www.library.usyd.edu.au/libraries/rare/modernity/newton3.html Or more usefully: http://www.amazon.com/Principia-Mathematical-Principles-Natural-Philosophy/dp/0520088174 or any basic physics textbook.
It's not about compressing a script, it's any file that is compressed that knows how to extract itself.
&gt; Wrong. you need to install python. Technically yes, but mostly true on non-linux systems only, since just about every linux distribution contains python by default.
Actually Glenn's [experience](http://code.activestate.com/lists/python-dev/102628/) rings true to me. A brief best practices for using logging in the 80% case right at the top of the help might help reduce the barrier to usage in simple scripts. 
It's a standalone package.
I always had an idea of something like this, which would have probably been awfully similar too. I wonder what licensing on this thing is. Then again, as I said, this is so minimal that I'm not sure it can be copyrighted
They are functions that run your functions.
ah, I should check it out, thanks :)
I recommend [this guy](http://www.amazon.com/Beginning-Game-Development-Python-Pygame/dp/1590598725/ref=pd_bbs_sr_1?ie=UTF8&amp;s=books&amp;qid=1237028553&amp;sr=8-1) for any starter on Python/PyGame. He teaches a lot of game basics like how to use vectors, and from there you can apply it to a spaceship game. Other than that, take a look at some examples already existing on PyGame itself. It's good to look at other people's code and see what can be learned. There's also some code under the cookbook that you can check out for additional reading.
subprocess does offer all of that, but it's not really relevant to the major point: I was referring to things like complex redirections, not the trivial stuff. Try redirect all of stdout, stderr, and stdin to variables and pipes, particularly if you want them to be different (or bidirectional, interactive, etc.). Or efficiently managing lots of subprocesses (where the data structure issues dominate), etc. Once you get out of the basics it starts getting hard to follow with brittle syntax - that's the threshold where I find myself noting that if I use Python, my code will be much easier to follow in 6 months when I revisit it.
I would give steering behaviours a try. I've always wanted to create a spaceship battle game using boid-like entities.
I'm starting to think no one besides Vinay (the author) really understands it...
Space physics is pretty easy; one velocity vector per object (in 2d, two scalars), modified by firing engines, the angle determining how to change the vector. (which scalar in what proportion - use trig) I'm confused by "But maybe with a little more real control. I would like the ship to rotate, and fire its engines to help steers its vector." But if it reads like I think it does, * You do realize that in Asteroids you can rotate the ship, and fire its engines? (when I first played asteroids I didn't realize you could move the ship) * If by "steer its vector" you turning left causes your current velocity vector to be turned to the left, THAT'S NOT SPACE SHIP PHYSICS! But might still be interesting.
Then you perhaps don't follow comp.lang.python, where plenty of other people give good advice when logging questions come up. Why, Peter, I do believe that in your post which announced your alternative logging library, you said about the stdlib logging package that &gt; In the numerous applications I’ve used it in, I’ve found it to be useful, featureful and very well documented. If you got that much out of it without understanding it, that's great!
Sounds like a fun project. Have you checked if there's source code for similar projects written for pygame? (ex. [space shooter](http://www.pygame.org/project-Space+Shooter-1292-.html))
Have a look - http://whice.dev.archadesign.com/
Thanks for the interest :) http://whice.dev.archadesign.com/
Cool, give it a once over http://whice.dev.archadesign.com/
You have one - http://whice.dev.archadesign.com/
There's not really invites, so have a look and see what you think! http://whice.dev.archadesign.com/
Which podcast is that? 
Writing documentation is hard, and you can never please everyone. Many people have said they want a simple use case/example at the top, so that's what there is - and while it's not right at the *very* top of the logging documentation page, it's [pretty close](http://imgur.com/ndKK8.png). That screenshot's from the Python 2.7 docs. The tutorial section was adapted by Doug Hellmann from his [PyMOTW entry on logging](http://blog.doughellmann.com/2007/05/pymotw-logging.html). Doug's (deservedly) a respected writer and has made a lot of information on Python very accessible. I can't see why that first example wouldn't &gt; help reduce the barrier to usage in simple scripts. Can you elaborate?
x(t+dt) = x(t) + x'(t) dt x'(t + dt) = x'(t) + x''(t) dt x' = dx / dt. For a 2d game you'll want x and y, store the components separately. Probably have a direction vector, and have v = some scaling factor * direction vector. There, done. Oh, you'll need to know how 2D rotations work. I don't know if you've ever used complex numbers before, but it might make your life easier. Rotations are just multiplication.
Incorrect. If you think grep is all about running a regular expression overa file then you are in for a surpise. Grep is much more than that. I recommend http://news.ycombinator.com/item?id=1626305 for more info on grep. The gist is that people tend to reinvent the wheel (or even the nail for the wheel) when it can be accomplished in a second with already existing tools much more efficiently.
&gt; force_vector/mass = acceleration vector &gt; integrate(acceleration vector) = velocity vector &gt; integrate(velocity vector) = position vector now give you spaceship some force vector and the rest will handle itself. I'm simplifying but that's basically it.
I wrote an astroids-like space shooter game demo a couple of years ago and it's free software. I don't remember what the code looks like, but hey, there's a change it's clean enough to learn from. [Geometry Cometry](http://geocom.kupesoft.com/).
Absolutely. Let me preface by saying that I really appreciate the work you've done on `logging`, use it a lot and hopefully my criticism is constructive. The documentation appears to be targeted towards someone with a relatively large application that *already does* logging and is pointing them to all the (genuinely) cool things they can do with that logging, auto-rotating files, debug/warning in different files, the root/logger name hierarchy, etc. My personal problem (with which Glenn seems to agree) is that 90% of the time I'm starting from #!/usr/bin/python2 import logging and moving on from there. I don't have anything happening yet so I don't really care about where the log files go or if they're rotated, I just want to use warn() instead of sys.stderr.write(). The very simple example up top and the slightly less simple one in the [Configuring Logging](http://docs.python.org/library/logging.html#configuring-logging) section are what I need, maybe with a little elaboration of issues that might come up while writing a program that uses logging. &gt; The example shows a 4 line cost... it is not clear from the first 8% of the documentation if it requires 4 lines in every module; it is not clear if I can or should or if by default, the file I configure for one module is available to other modules, such that only two lines are necessary in those modules (import, logging.debug (or other levels of message)), etc. tl;dr: the first page of the logging documentation should IMO be the one-- and preferably only one --obvious way to do it, oriented towards someone starting a new program from scratch. 
This just recently clicked for me. First, it helped to understand that python variables are [not boxes](http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html#other-languages-have-variables) in which you store values, but rather [name tags](http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html#python-has-names) that you hang onto objects. Second, here's a simple definition of a decorator: It's a function. It takes another function as an argument. It returns a function. Third, function names themselves are just variables hung onto their respective function objects. If that just sounded like I said, "Function function function function function," (which is how I felt when trying to wrap my head around decorators), here's a small python program that may help out: def orig_function(): print "Hello!" def my_decorator(orig_function): def third_func(): print "Take Off, eh?" return third_func # prints 'Hello!' orig_function() # now, we're going to decorate orig_function with my_decorator orig_function = my_decorator(orig_function) # prints 'Take Off, eh?', because of the decorator orig_function() That above syntax is what made decorators click for me. We've moved the `orig_function` nametag, and hung it on the `third_function` object. So now, when we call orig_function(), we're really calling third_func() I used the above syntax until I was sure I understood how decorators worked befure I switched to using the shorter @ syntax. orig_function = my_decorator(orig_function) is equivalent to @my_decorator def orig_function(): #orig definition here which isn't as intuitive, but nicer to use once you've got the hang of things.
Thanks for the reply! I didn't quite expect waking up to this in my inbox. I'll have to read it later; gotta go to work!
Not arguing that python is simpler syntax overall, though you can get 'nice' named pipes from subprocesses using the [coproc](http://www.gnu.org/software/bash/manual/html_node/Coprocesses.html#Coprocesses) command, which'll set the name to an array of the std{out,in,err}, and allow for further redirections. I'll freely admit that people may not be as comfortable with it, but that's inherent in any comparison of language choices. I also agree that being a python dev primarily, that if I had to do that much process management magic I'd be more inclined to use python over bash. People using *nix, though are still greatly served by learning more about what's available, over just taking their 'insert all encompassing platform here' and pushing it everywhere.
I toggle it because I use vim for things other than development work. In such, I don't care how long the lines are. It does start by default, however. And I agree, they should be annoying.
I have: autocmd Filetype python setlocal textwidth=79 ts=8 sts=4 sw=4 autoindent expandtab in my .vimrc Why do you use 78 over 79? My understanding is it (79) would make 80 the new-line? Note, I'm merely curious to see if I could be doing something better. :) EDIT: clarification
Lots of people are recommending checking out other peoples code. I will start with yours. Thanks for the link. 
I tried that and got: E518: Unknown option: colorcolumn=79 Which version of Vim do you use?
if I have a current heading vector, how do I apply a force from a different angle to modify the heading vecotr? At least that's what I think I am trying to figure out. 
I prefer how [fudge](http://farmdev.com/projects/fudge/) handles multiple calls to a mock with different return values. I think that's a case that most python mock libraries need to handle more easily.
Thanks for the recommendation. Looks like this book would help me with other questions / struggles. 
What if you wanted to have different coins and choose between them? Perhaps you don't want to always use fair coins, so fairness/bias is an attribute of a coin that you might want to change. And what if you wanted to allow for multiple players? Maybe each player has some amount of luck that increases the probability that they are correct. Can you see how you might uses classes in these simple situations?
Is that first book in Latin? ^_^ 
I checked out this game, the ship just moves left/right/up/down. I would like to fire and engine have it travel that direction until it turns and fires engines at a different angle. Then have that new thrust affect the heading of the ship. Thanks for the link, there are lots of games I might find what I am looking for. 
Yep. It was the *lingua franca* for academia, back then. English was for the uneducated plebs.
That particular example isn't about multiple return values - it is having the first call raise an exception and the second call return a value. Which fudge technique for handling multiple return values do you like? Because it is an expectation based framework the examples I've seen involving next_call, with_args and returns seem much more complex (although probably marginally less code) than how I would do it with mock (a side_effect that just pops return values off a list). I work in a team that makes extensive use of mock, and it just turns out to be pretty rare for us to use mock and require multiple calls to the same mocked object to return different values.
I want to use any constructive criticism to improve the initial sections in the documentation. I take your point that the rotating file example is perhaps too early in the documentation for simple usage, and it wouldn't hurt to move it further down. IIUC you're suggesting that I could add a slightly more involved example similar to the one in "Configuring Logging", soon after the first code sample, and that's about it for the initial part of the documentation. Thanks for the suggestions, let me know if I missed something. Re. your statement that 90% of the time you're starting from "import logging", is that because you can't remember what you've done before (perhaps you don't need to write scripts that often, so no need to remember stuff you hardly use), or do you mean something else? Would something like a cheat sheet be useful, for example?
&gt; Reading text is very different from reading code. Why would you think that? They both use the language centers of our brain and both adhere to short term memory constraints. I would say this is an interesting hypothesis that would make a very interesting topic of research. But I don't see an a priori reason for disconnecting the two. 
I am having to much fun playing your game, well I was having fun unill those stars came out and started shooting back. Cool game, and this is very very close to what I am trying todo with my ship. 
i still prefer SQL Alchemy
Give ActivePython a try -- it provides a tool to install [pre-compiled modules](http://code.activestate.com/pypm/). To install modules from source into your $HOME, run: pip install mechanize --install-option="--user" Both the approaches above will install packages into `~/Library/Python`.
See [this thread](http://stackoverflow.com/questions/1352528/why-does-activepython-exist).
&gt; &gt; Reading text is very different from reading code. &gt; Why would you think that? Because people rarely try to fit a complete concept into one line of text, whereas that convention is very common in code. Because no one has to guarantee the that all tokens used in the text are defined, so misssspelings can easily be accommodated. (And for rules other, language reading natural again can accommodate.) Because "they both use the language centres of our brain" is an unsubstantiated assertion. And even if they did, there is [no evidence](http://en.wikipedia.org/wiki/Mirror_neurons) that they use them in the same way
Though I generally don't like DSLs, I find the fudge dsl: foo.expects('add').with_args(1, 2).returns(3) foo.expects('add').with_args(3, 4).returns(7) ... to be more readable, and more easily usable in the applications I work on, where I'm mainly mocking out 3rd party services that may be called multiple times and return different things within the scope of one test.
Sort of a distinction without a difference. GNU utilities are to bash (or CSH or whatever) what functions are to other programming languages. Can you write any useful shell scripts without using echo, ls, cp, rm, mv, grep, sed, awk etc?
People aren't familiar with [dejavu](http://www.aminus.net/dejavu) so I thought I'd shameless plugged in that quite interesting ORM project.
Time will tell. Currently PyQt is certainly more mature and should be used for production. It's a one-man-show, but I think it's very amazing one man show. Overall PyQt is extremly well maintained. PySide uses the same API (also adopted some changes known as "new style" API) which is a great decision by the PySide team. I've tested PySide recently on some smaller apps written with PyQt and it worked very well without any modifications needed. No doubt, PySide is very promising. What we all gain from this are two python bindings to Qt which are API compatible. Also, Nokia pushing Qt is great even if they have mainly the mobile apps in mind. There're a lot of good things currently happening in Qt (features and performance). E.g., I'm using a TreeView (with columns) with more than 200000 items and for the huge amount of data it's very smooth. A lot of other toolkits can't handle that much data at all.
current stable. it's a relatively new feature.
sort of. They use the same structures, though something different appears to be going on in the brain. But, without further research it's hard to say if the structural overlap does or does not translate into overlap in this specific case. Or if the difference in processes result in a differences in this specific area. [Mathematical logic in the human brain: syntax.](http://www.ncbi.nlm.nih.gov/pubmed/19478999) Given the structural overlaps and use of the broca's (language) areas though, I don't think it's completely unreasonable to assume the processing limitations we see in may apply in the case of formal languages (like programming) as well. Oh, if you're interested be sure to check out the related citations which offer a lot more context on the overlap between music, formal, and natural language centers. Particularly in the area of syntactical processing.
I have it set to 78 in my .vimrc because our internal style guide recommends 78 characters. 78 allows for diff to add an extra character without it overflowing lines. I'm one of those crazy 4-5 terminal sessions side by side on my screen, so I vastly prefer to 80-character terminal.
What about where the args are objects that will be constructed by the code under test? (i.e. you don't want to or *can't* construct the precise args in your tests - you *just* want to specify the return values.) Personally (and I realise this is a matter of taste - some people have it), I find that putting the expectations code ahead of the action to be backwards and makes for less readable tests. I wrote mock specifically to avoid having to write code like that. (Seriously though - I *really* don't mind if not everyone agrees with me on that. Having a diversity of mocking and testing infrastructure around is a good thing.) I might write the same test in mock with: foo = Mock() returns = [3, 7] foo.add.side_effect = lambda *args: returns.pop(0) perform_action_using_foo() foo.add.assert_called_with(3, 4) pop_last_call(foo.add) foo.add.assert_called_once_with(1, 2) So setting up the return values is just two lines of code and is separated from the assertions about the calls. Because the asserts are *after* the action (instead of being setup as expectations), the test will fail on the line of the specific assertion that fails... (I would generally create the Mock through patch instead of constructing it directly.) If the args are objects constructed by the code under test - i.e. I can't use assert_called_with - I would pull the arguments out of foo.add.call_args and could make individual assertions on the objects. (Assert their type and attributes for example.) Oh, another way to do it that might be more analogous to what you're after: foo = Mock() results = {(1, 2): 3, (3, 4): 7} foo.add.side_effect = lambda *args: results[args] Any call other than the expected ones (i.e. args isn't in the results dict) would fail with a KeyError.
&gt; Typical screen widths are evenly divisible by 80 Only if you are measuring pixels, not characters Starting the terminal on this machine, using full screen, and then changing font size I find that the number of columns in the screen is: 43, 57, 84, 115, 158, 211, 254 &gt; It's been shown that the longer a text line is ... It may have been "shown" to someone, but not to me: Your "citation" is just a collection of assertions and has no evidence (nor other citation) to support its claims. Why should I believe it? Or that the number "39" is pulled from anywhere other than his nether regions? &gt; you'll probably find most of your lines hover close to that number No - I don't, quick calculation on a local directory of python, and rounded down the line length to the nearest 5 for presentation: * (0, 182), (5, 42), (10, 54), (15, 74), (20, 88), (25, 109), (30, 93), (35, 68) * (40, 73), (45, 76), (50, 41), (55, 40), (60, 21), (65, 36), (70, 19), (75, 19), * (80, 8), (85, 7), (90, 3), (95, 3), (100, 2), (115, 1), (150, 1) So, e.g. there were 42 lines whose length was 5, 6, 7, 8 or 9 characters I do not see any indication that the lengths are hovering close to multiples of 39 The argument "by convention" also needs some substantiation: I have never even heard of such a convention applied to line lengths. Not even when we were working in RPG (which was punch-card based, so at least that language had a good reason for the 80-char limit, but we had abandoned it for practical use, because we had decent screens.)
This will work: import os for name in os.listdir('.'): if not name.endswith('.py'): continue original = open(name).readlines() with open(name, 'w') as h: for line in original: h.write(line[:80].rstrip() + '\n') Making it recurse into directories is left as an exercise for the reader. Code may need some *limited* manual tweaking after processing...
PyODE
Very good points. I haven't researched this topic deeply (nor am I particularly interested in it), I mostly just intended to offer the common justifications I've seen and point out they are not limited to ancient 80 character screen widths. Personally, I think the _most_ important is convention. Convention being defined as "whatever the style guides for a particular project are". For example, if I joined a project that has a style guide of 120 I would happily conform to that requirement without a peep of resistance. I'm more interested in programming than painting tool sheds. ;)
&gt; The argument "by convention" also needs some substantiation: Oh, on convention: It's a [python convention](http://www.python.org/dev/peps/pep-0008/). Though I've seen it in other languages and projects style guides. 
Yeah, I think that expresses what I'm going for well. I end up writing a lot of scripts but they don't all survive past "gets job done" to "hey I should probably have some logging (and error checking and...)" This is mostly my laziness but if there was a "hey here's how you do logging The Right Way" cheat sheet I expect I'd be more likely to use it from line 1. Does that make sense? 
If you don't care about arguments, fudge would say: foo.expects('add').returns(3) foo.expects('add').returns(7) (Or use .next_call() after the first, amounts to the same thing). The last mock example is not bad -- it's cool to see how flexible .side_effect is -- but for me, the fudge way is nicer. Bikeshed? ;)
I found the text of the article [here](http://www.plosone.org/article/info%3Adoi%2F10.1371%2Fjournal.pone.0005599) The article found a number of brain structures which are commonly used when reading natural language text and mathematical text. Most of these were very unsurprising, as they are assumed to relate to (e.g.) the visual processing of characters, memory of encoded instructions and so on. The article hypothesized, but did not find that Broca's area was used in decoding the formal languages ("Note the non-overlap of the present IFG activation with the cytoarchitectonically defined Broca's area"). I think this is odd given that Broca is especially associated with comprehension of "complex" and "ambiguous" syntactical structures. And the presented structures fall within that class for normal English speakers. (En passant: I found [these sentences](http://www.ncbi.nlm.nih.gov/pmc/articles/PMC2685028/figure/pone-0005599-g001/) to be relatively straightforward to read, but my wife did not ("Well, they might be sentences in your world"). I think it reasonable that she and I would use different brain mechanisms in parsing these sentences. In this context it is interesting that the study identified one sub-group of patients who showed no difference in performance when presented with bad maths sentences, and good maths sentences. This sub-group's activity measurements were not significantly different from the others' which tends to suggest I was wrong: my wife and I probably use the same brain structures in the same way.) The article also suggests that despite both types of reading involving the decoding of syntactical hierarchies this decoding is achieved in different areas depending on the type of language. The article does not address the further differences (such as significance of lines, relative strictness, etc, etc) between formal and natural languages at all. In summary, I'll have to go with confirmation bias on this one: AFAICT the article tends to support that assertion that &gt; Reading text is very different from reading code.
&gt; There's a gap between mentioning your tool/framework/lib/whatever when the time is right (e.g. an open-ended question such as "what are the web development options in Python" or a question specifically about the tool) and spamming every single web development thread (including threads solely about a specific question concerning a different web framework)... Hmm, [here](http://www.reddit.com/r/Python/comments/ej0p1/new_standalone_web2py_database_abstraction_layer/) we have a post that is specifically about the web2py DAL, yet the first two comments are promoting *alternative* ORMs. And [here](http://www.reddit.com/r/Python/comments/dgbj1/complete_conference_management_system_runs_on_gae/) is a post about a web2py application, and the second comment points to an (inferior) alternative. It seems reddit doesn't really have a problem with this kind of thing.
I do find this stuff fascinating, my BSc dissertation was on proving that an artificial neural network could be used to recognise structures in source code. But I know what you mean about painting [bike](http://bikeshed.com/) sheds, &gt; For example, if I joined a project that has a style guide of 120 I'd resign immediately. That's why Guido's nonsensically pedantic recommendation annoys me so much. P.S. Sorry about the "bike" shed, sometimes [I just can't help it](http://xkcd.com/386/)
best xkcd ever.
There are three differential equations that control the motion of the ship, where boldface indicates vector: **p**(t + Δt) = **p**(t) + **v**(t) Δt **v**(t + Δt) = **v**(t) + **a**(t) Δt **a**(t) :: given by user input. You're going to want to work with cartesian coordinates because they align with the monitor's pixel grid, so vectors will be represented as (x,y). If you know the length (r) and angle (theta) of a vector, you can represent it in Cartesian form as (r cos(theta), r sin(theta)). That's how you apply a force from a different angle to modify the velocity. If you want to vary inertia, you multiply **a** by a constant in the differential equation determining **v**. To render, set Δt to a constant value and update each iteration. This topic is covered in numerical solutions for ordinary differential equations.
&gt; Reading text is very different from reading code That's why I said "sort of". There's definitely something different going on, but (and the publications referenced in the paper cover this too) it seems there's overlap as well. I think it'd make a great study to see if that overlap included processing effects on saccade and eye motion as well as retention of syntactical meaning correlated with line length.
For the most part, fabric is considered the 'Make alternative' but really, make and python are not mutually exclusive. Fabric is closer to a python-like Capistrano but even then... Make is strictly a utility. You could use Bash scripting to do a lot of the same things Make, fabric and Capistrano do if you so desired.
Very glad you liked it! Hope the code helps. As with everything, I'd planned to rewrite and clean it up and finish the game but never did. The code should be (fairly) straightforward, nonetheless.
I never thought about that in regards to diff -- thank you. I'll probably be updating my dot-files now. :)
`virtualenv --no-site-packages` will get you an environment with nothing installed or inherited (except what you instal after setting it up), so you can use it to test that you've got a list of everything you are using.
PyQt - and its easy for x-platform
why?
Do not worry. I think it is always good to point out alternatives. What do you like better about dejavu?
Good job. IMO this could become relatively popular if: - you split the code in several modules and make it a package (5k lines in 1 file is a lot) - add tests in package - release it under MIT/BSD or at least LGPL. That should even make web2py more popular. - Add it to pypi as standalone package. 
All good ideas.
&gt; What do you like better about dejavu? Probably the fact that he wrote it? :D
1) it is under discussion on the mailing list. Some like to have this into a single file 2) tests are in there already 3) I do not want it to be popular. I want to stay free. I think GPL does a better job. Anyway I will think about it. 4) that can definitively be done. Thanks for your feedback.
Even though web2py and I don't see eye to eye, their DAL is quite nice. In fact, I wanted to congratulate mdpierro and team on a great job. Questions about the library: How do you define and use it for hierarchical models ? Adjacency list or nested sets type of structures. Can you hydrate the result sets as raw arrays and not objects to save on memory use ? &lt;- this is a carry over from PHP Doctrine orm and it may not apply. 
&gt;it is under discussion on the mailing list. Some like to have this into a single file Single file is difficult to extend and maintain. &gt;I do not want it to be popular. I want to stay free. I think GPL does a better job. Anyway I will think about it. IMO BSD/MIT are free'er licences. Do you charge for commercial licences? See PyQT/PySide discussions and you'll see what i mean. Django/Flask/SQLAlchemy etc etc are free and popular.
* SQLAlchemy will autodetect your tables and foreign keys * Instead of joins, SQLAlchemy keeps everything in an object-oriented manner: you can simply set up references to foreign tables, and instead of joining all the time, you can (for example) just set up "employees" as a many-to-one relationship with "company" say company.employees and it will return a list for you. You also don't have to call an "insert" function -- you just create a new object instance and commit. * Instead of getting a table object like in webpy, in SQL Alchemy you associate an existing class with a table in the database. This allows you to not only define a lot of methods for dealing with that table, and keep them in the same namespace, but you can also edit the __init__ function so when you create a new row, you can build any logic you need into the class. * SQLAlchemy has more data types, like the PickleType, which allows you to just dump Python data into a blob/binary row. You can also create your own data types, too. So bottom line is I prefer SQLAlchemy's abstraction over this, and it's just a more robust system, and better at doing its job. That said, I'm not saying that this is a waste or anything. It's probably a lot simpler to get started than dealing with SQL Alchemy -- there is a decent amount of overhead setting everything up. 
Hah, I apologise for misleading my dear readers (ahem) but I'm not the author. I simply used in the past and found it quite versatile and less SQL-ish.
Make was created to build (compile-link) source code in an efficient way through the concept of "rules" and "targets". Since Make knows how to build a project it is also used on deployment... Fabric, Paver, Buildout are more like deployment tools. Scons, and waf are build-tools with a focus on source code compile-link kind of task. doit is based on concepts of make but more generic (not designed to do only compile-link tasks). So your choice for a Make alternative will be quite different depending if you are looking for deploying, building C/C++ projects, or something more general. (disclaimer: I am "doit" author)
don't know anything about pygame and if it comes with it's own physics engine. If not it might be good to read up on how to do your own physics engine / integrator. [Here](http://gafferongames.com/game-physics/) is a nice intro. A good book is [Physics for Game Developers](http://www.amazon.com/Physics-Game-Developers-David-Bourg/dp/0596000065/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1291934921&amp;sr=1-1) Edit: um , why the down votes? example might be in C, but it's the theory behind that's matter. :-/
So, what you are basically saying is that the program that is labeled "Global | Regular Expression | Print" can do more than regular expressions? What do you think the python library uses for regular expressions anyways? As soon as you want to do something complicated with the output, you should be using something like python anyways. And, if you really need performance, then pipe the grep output to python! I'm a pragmatist not a fanboy. The ability to turn the output of such an action into a generator is priceless.
web2py does not auto-detect tables. The problem is that, like SQLAlchemy, it has more data-types than SQL, and as SQLALchemy, you can define your own (like a pickle-type if you like). Auto detection and custom data-types cannot work together. For mysql and postgresql we have script that autodetect tables and generate web2py models. In web2py you do not have to "join all the time". You can also use recursive selects and it works like in sqlalchemy. In web2py have to call an "insert" function because, by design it is not an ORM, it is a database abstraction layer. We feel forcing a relational model into an object model is sometimes too much of a stretch. We do not wish to hide the underlying relational model: web2py has functions like insert, update, delete, and select which map 1-to-1 into the corresponding SQL. Moreover our tests indicate that the logic to run a database abstraction layer into an object relational mapper involve metaclass programming and that introduces a considerable slow down. web2py is faster, small and easier to read then sqlalchemy because of this. web2y supports computed fields and virtual fields. Syntactically this is different from defining methods in SQLAlchemy but functionally it is the same. Even if web2py is not an ORM, more than one year ago, as a proof of concept, [we implemented both the Django ORM and the SQLALchemy ORM](http://web2py.com/AlterEgo/default/show/189) on top of the web2py DAL. This allows you to define some tables, using Django syntax, some using web2py syntax, and some using SQLAlchemy syntax in the same program. Nobody showed an interest in this functionality so we did not spend extra time on it.
It does not matter. Have you compared it with the web2py dal? What did you find in dejavu that you did not find in web2py's?
About hierarchical model web2py supports 1-to-1, 1-to-many and many-2-many no more no less that rmbds databases do. You can do for example. person=db.define_table('person',Field('name')) dog=db.define_table('dog',Field('name'),Field('ower',db.person)) me=db.person.insert(name='Max') scooby=db.dog.insert(name='Scooby',owner=me) print scooby.owner.name for dog in db(dog.owner==me).select(): print dog.name for row in db(dog.owner==person.id).select(): print row.person.name, row.dog.name The result sets in are not Objects in web2py as in SQLALchemy. They are Storage objects with are very similar to python dictionaries. They are parsed from the raw data but does not add too much memory overhead. They are parse to make sure the format of the data out is the same as the data in and independent on database engine. Not sure I answered all your questions.
Sure, but that wasn't my point. Just about every *NIX contains tar by default. That doesn't make tar archives self-extracting. All I'm saying is, the title "self-extracting" is misleading.
It is not true a single file is difficult to extend and maintain. The dal.py file for example is divided into sections seperated by comments. Almost all functions are grouped into classes. So far the issue of license never came up because web2py allows commercial closed source distribution of apps developer with web2py. I can see that if you want to use ONLY the DAL, it may be better for you to have a MIT/BSD vs a GPL license. The point is that I am happy if you use this for free as long as you contribute back by giving your work for free too (that is what GPL says). Anyway, I will think about LPGL. 
While SQL Alchemy is a definitely more robust and a full featured ORM for applications. I can see myself using web2py's DAL for simple scripts where I need database persistence. SQLAlchemy requires much more boiler plate code just to get started.
I would fire someone for being able to read that.
I do think sqlalchemy does a better job at handling legacy databases. web2py has limited support for legacy databases (although we are working on it). Buy why do you say "more robust"?
represent the position as a 2-tuple (or list, or a class like Vec2 below, your choice). pos = (x_coord, y_coord). you can represent this in real-world units (for example, meters) or screen units (pixels from top left) or however you wish. Often it's helpful to use SI units as then you can apply formulas from textbooks once you start doing more complex stuff like drag coefficients, soft body dynamics and all that stuff, but for an asteroids game pick whatever you find easiest. If you want the ship to move, then the ship will need a velocity - this is a 2D vector representing the change in position over time. If you're using SI units then make this meters per second (m/s). you basically add this to your position every tick (frame, vsync, whatever). if your game loop is running at 30 fps, you add Vel/30.0 to your position every 30th of a second. Again, if you want to keep this simple, you can make it number of pixels per frame instead of m/s - the logic is the same, only the scale is different. If you want the ship to change direction, then you need to change the velocity vector. for this you'll need an acceleration vector . This will be a 2D vector representing change in velocity over time. If you're using SI units, this should be m/s/s. If you're using arbitrary units like pixels per frame for the velocity, then you will want to use very small values for acceleration ;) The principle is the same as above - add a small amount of acceleration each frame to your velocity vector. Assuming you want to rotate your ship, then you need a ship heading vector. keep this normalised (length 1.0) and spin it around the ship center of mass so it points in the direction your ship points. When you want to change the ship velocity (i.e. your player is pressing the "fire engine" button) then you multiply the ship heading vector by some amount (how powerful the engines are, how long the button has been held, whatever you want) and this is your acceleration vector. class Vec2(object): def __init__(self,x,y): self.x = x self.y = y def update_coords( frame_len_in_secs ): dt = frame_len_in_secs if engine_active: accel = Vec2(heading_x * engine_power, heading_y * engine_power) else: accel = Vec2(0.0,0.0) ship_vel.x += accel.x * dt ship_vel.y += accel.y * dt ship_pos.x += ship_vel.x * dt ship_pos.y += ship_vel.y * dt 
Well, yes - my code-snippet only activates the highlighting when a Python file is detected - things like documentation or email aren't affected.
&gt; Auto detection and custom data-types cannot work together. That's the thing; SQL Alchemy can handle both by allowing the user to autoload the table if necessary. If web2py has a function for autodetecting tables, that's almost the same thing. However, this isn't really shown in the link. &gt; In web2py you do not have to "join all the time". You can also use recursive selects and it works like in sqlalchemy. SQLAlchemy allows you to specify relations to other tables and will automatically populate those relations with a list if appropriate. How does it work in web2py? I think it would help users evaluate your tool if you included some joining examples -- joins are pretty much the *point* of relational databases! &gt; We feel forcing a relational model into an object model is sometimes too much of a stretch. Fair enough! Like other people have said, it would certainly be useful where you don't need all of SQLAlchemy's features and preferred to do things much more simply. SQLA does have a lot of boilerplate to work through. This is a design choice, not a flaw, and I am just preferable to the way SQLA works. I love web2py and I'm using it in the (huge) project I'm working on now. I just prefer to plug in SQL Alchemy to handle DB stuff. Also, I have a completely unrelated web2py question: while you guys were working on adding session capability, you published an API of how sessions were going to work. IIRC, it completely changed when you eventually did add session capability. Why was this?
When I saw the title name, I had a hard time imagining what obfuscated python might look like. Looking at the examples, seems my suspicions are confirmed as it was very legible (as far as obfuscation goes). Python can't hold a candle to perl or ruby when it comes to utterly bafflingly obfuscated code.
You know both of these claims are full of crap. if you want the "no boilerplate" version of SQLAlchemy, use [sqlsoup](http://www.sqlalchemy.org/docs/orm/extensions/sqlsoup.html). If you want enough configuration to actually have some semblence of control over your domain classes (which just about any app worth anything will), use [declarative](http://www.sqlalchemy.org/docs/orm/extensions/declarative.html). It lays out in a very similar manner to every other ORM out there. SQLAlchemy also rocks the house on *any* database and our users know it.
The comments ruined the challenge. Should have padded the page.
We only provide these two files [1](http://code.google.com/p/web2py/source/browse/scripts/extract_mysql_models.py)[2](http://code.google.com/p/web2py/source/browse/#hg/scripts) that extract a mysql or pgsql table and write a dal model. It is not as good as sqlalchemy because we have not been much concerned with legacy tables. We will improve this anyhow. web2py handles joins a relations to the extend the underlying database does. Suppose you have Person=db.define_table('person',Field('name')) Dog=db.define_table('dog',Field('name'),Field('owner',db.person)) where dog.owner is a reference to a person. You can do a INNER JOIN for row in db(Person.id==Dog.owner).select(): print row.person.name, row.dog.name a LEFT OUTER JOIN for row in db().select(Person.ALL,Dog.ALL,left=Dog.on(Person.id==Dog.owner)): print row.person.name, row.dog.name or you can fetch a dog and find his owner print Dog(name="Skipper").owner.name or you can fetch a person and find his dogs for dog in Person(name="John").dog.select(): print dog.name I am not sure what you are talking about session capability. Web2py had session support since the first public version in Oct 2007 and we never changed it.
"your users". I apologize I do not recognize you from the username. Which claims are "full of crap"? It is not clear from your post.
I am the author of SQLAlchemy. Claims I'm tired of are that SQLA is only good for "legacy databases" and that we require "lots of boilerplate just to get started". Responding to two posts at once, I apologize.
&gt; or you can fetch a dog and find his owner &gt; or you can fetch a person and find his dogs These are pretty important features! You should definitely have them listed on your project's page.
Do you actually believe a single file of 5 freaking KLOC is not difficult to extend and maintain? His argument about the GPL not being as liberal as BSD/MIT is exactly that &gt;use this for free as long as you contribute back by giving your work for free So it takes away your freedom to hide other parts of your code that use that library. One may want to prevent other people from seeing their code for a number of reasons, It's a choice one should be free to make BTW the GPL doesn't require you to give your work for free it just requires you to redistribute your work along with your sourcecode along with the GPL license
Please do not put words in my mouth. I did not say "SQLA is ONLY good for legacy databases". I said "sqlalchemy does a better job at handling legacy databases [than web2py]". I did not actually say "than web2py" but it was obvious from context. I also did not say that SQLA "requires lots of boilerplate". fake_spoiler said that. Anyway, I do think that the web2py DAL is easier to use than SQLA and has a more natural syntax. That is why I wrote it. I also think SQLA is an excellent system. For the record, I did not bring up SQLA here. Somebody else did. I guess we are a little in competition but this can be good and can be done in a civil manner. Let me know if I ever said something incorrect about SQLA and I will rectify that. I trust you will do the same about web2py.
This is my favorite... &gt;&gt;&gt; db.define_table('item',Field('ho','reference item'),Field('lalala')) &gt;&gt;&gt; hihihi=db.item.insert(lalala='ooooooo') &gt;&gt;&gt; print hihihi.ho.ho.ho.ho.ho.ho.lalala ooooooo 
&gt; I guess we are a little in competition but this can be good and can be done in a civil manner. Regarding which database abstraction is better, it's not even a competition.
&gt; Do you actually believe a single file of 5 freaking KLOC is not difficult to extend and maintain? Yes. I have been doing so for 3 years. It is just a database abstraction layer not a parallel hybrid monte carlo algorithm for lattice quantum chromodynamics in 4 dimensional SU(3).
sweet! something to put on my christmas tree!
So at what point of domain complexity do you pull the line and split that in a 10-15 file package or multiple packages even? Why are then all other database abstraction layers I know of split in multiple packages (or equivalents in respective language)?
what evidence do you have to support the claim that changing the license to MIT/BSD would make web2py more popular? the only figures i've seen, and they only estimate the penetration of the license, not the 'popularity' of the software, nonetheless suggest that GPL is hardly an obstacle... ref: [blackduck](http://www.blackducksoftware.com/oss/licenses#top20)
I split them then the components have a use independently of the whole. In this case they do not.
Then why wasn't web2py one 20 or whatever KLOC file up until now? Since it's only a web framework.
Why do You think the most popular frameworks are released under BSD/MIT? Why does nokia make PySide when we have PyQT and it does the same job?
if that 'freedom' is so important to you, write your own code... it strikes me as rude to lecture someone, who has written a bunch of useful code and made it available to the world for free, about how it 'takes away your freedom' if you can't do exactly as you please with it...
Why the hell is it all in a single file? 
When I give away code for free you are free to do whatever you want with it.
Pyramids - BSD derivative Django - BSD Flask - BSD Werkzeug - BSD cherrypy - BSD webob - MIT bottle - MIT **web2py - GPL**
Because the individual web2py modules "have a use independently of the whole" web2py. You may want to import only the dal or only the template system or only the validators.
He really should have picked a letter other than 'q' to name the function. My train of thought was: this is a recursive algorithm with empty list base case and two cases that handle values around a pivot...q for quicksort, oh. To be really obscure you have to use nested list comprehensions. (;
Yo dawg...
Some kind of ugly. However, seeing \[[Spoiler](/s"two recursive calls to itself joined by a pivot")\] kind of gives it away. 
web2py is GPL but read the [license](http://www.web2py.com/book/default/chapter/01#License). The GPL applies to derivative frameworks. It does not apply to applications built with web2py. Applications built with web2py can be distributed under any license you wish.
That is up for discussion and not definitive. For now it is in a single file because it is small and its parts are useless without the whole and we do not wish to expose modules that should not be independently imported by users.
show me that they're the most popular... because nokia want to influence the development and use of python qt bindings... they spent a decent amount of money buying trolltech iirc... if your argument had any validity, it would suggest that freebsd should be way more popular than linux... i think we both know it isn't... you seem to have an incredibly oversimplistic, and possibly dogmatic, take on software licensing
what on earth do you think that proves?
good for you: doesn't give you the right to be a jackass to other people who don't share your view...
And why is the DAL standalone now and wasn't before? If it only made sense importing it from places within a user's web2py app I get that. But then if you split your DAL as say a module for handling PostgreSQL, a module for MySQL, a module for handling transactions etc. What's wrong with that? In the case of the parallel hybrid monte carlo algorithm for lattice quantum chromodynamics in 4 dimensional SU(3). Any part of your code might not be meant to be imported by anything else as a separate part, one might just want to see the program spit out furballs or whatever it's supposed to do. But you'd still split it in multiple modules. 
This is an important issue and I do not have a definitive answer. It was always possible to use the dal without being into a web2py app (some use it with Flask for example). We just eliminated the dependency on web2py modules. The API is the same and you can use it with or without web2py. We may break it into separate files. It is not obvious to me this is better. If you care about this, and you are not just trolling, please join us on the web2py mailing list where this discussion belongs and where we already have an one thread on the topic. 
If you are following the discussion you'll notice it's quite civilized. At least no one was being called a jackass up until now. Massimo and everyone else who posts links to their work here should accept both positive and negative criticism. If he doesn't agree with my world view so be it. He may also not agree with me on wether a 5 KLOC file is too much, but you don't seem to have a problem with that part of the discussion. If he decides to keep it GPL so be it, I may or may not decide to use it. If he decides to keep it 1 x 5 KLOC I may or may not decide to look at it or fix it if it's broken. People find his work useful. And I respect the man.
Unobfuscated version: def quick_sort(l): return [] if not l else quick_sort([i for i in l[1:] if i &lt; l[0]]) + [l[0]] + quick_sort([i for i in l[1:] if i &gt;= l[0]]) 
I think the point was that it only works with the `date` from the `GNU Coreutils` package and not on BSD's `date` or any other.
I work on unixen besides linux, so it's essential to communicate which tool is needed. If I have bash, but no gnu date, then I cannot get flexible dates. If I have gnu date without bash, then I can. So it's a distinction that is important to remember.
This shorter version seems to work too: def quick_sort2(l): return [] if not l else quick_sort([i for i in l if i &lt; l[0]]) + quick_sort([i for i in l if i &gt;= l[0]]) 
Please remind me. Is it appropriate to talk about SQLAlchemy in a thread about web2py?
Here's a use case that I see as pretty much ignored in the docs. I've tried to do this myself, but I never like what I end up with: Writing a piece of system software, by default log errors to syslog, when testing or in dev, write to a file that's defined as relative to the location of sys.argv[0], and that can still be overridden in case someone has a special case they need. I don't understand how to get what I want out of the logging module. I recall having a really hard time getting it to log to syslog, and needing whole bunch of definitions when what I wanted seemed like it should be as simple as warn_logger = syslog(facility), and later I should be able to type log_warn(level), and have it work. I notice that I don't see an awful lot of system software written in python that use the log module, nor log to syslog. To me, as a sysadmin, the log module is a failure because of the lack of clear documentation as to how to make it work for a system-scoped application (or larger).
Those are some good points. I am looking at doit right now and it seems to be pretty awesome and exactly what I needed. I might be able to replace all of my uses of make with this tool.
Seriously, that statistic is broken.
Yeah, that was my reaction too. It's really not that different from a non-obfuscated version. You just don't name variables very well, and don't indent. Of course, it is possible to obfuscate Python (as with any language). Here's my version: def q(l): lr = [[], []]; return [] if not l else (list(map(lambda i: (lr[0] if i &lt; l[0] else lr[1]).append(i), l[1:])) and 0) or lr.__setitem__(0, q(lr[0])) or lr[0].append(l[0]) or lr[0].extend(q(lr[1])) or lr[0] Edit: made the flow control more readable
So can YOU explain that phenomenon, please?
for small values of civilised maybe... i'm glad you do, it certainly didn't sound like it...
 def public static void protected notexactlyeasier():
Oh I see. Indeed, this doesn't seem to work on OS X.
This is the ONLY LEGITIMATE RESPONSE I've seen. Touche salesman.
Has anyone picked up this book? If so, what do you think of it compared to wxPython in Action?
Learn it by writing and debugging it using Python Koans. http://bitbucket.org/gregmalcolm/python_koans/
yep, it should be mature enough when python 3.x ready for production...
This looks great. I've been salivating over python3 for some time and now I may get to eat. Perhaps a PEP based around this module would be in order to update the dbapi. Particularly, the db.prepare call, returning a function, seems quite powerful. Backends that don't support prepare (sqlite perhaps), could fake it "client" side.
Hmm, aside from Django, I'm not sure those other frameworks are particularly more popular than web2py, so it's not clear the license makes much of a difference. Also, note that web2py is not strictly GPL -- it's GPL with a [commercial exception](http://www.web2py.com/book/default/chapter/01?search=license+commercial+exception). And, of course, the license applies only to the framework itself, not to any applications you develop with it. That's not to say that the standalone DAL couldn't have a different license from the full framework.
&gt; Do you charge for commercial licences? No.
&gt; So it takes away your freedom to hide other parts of your code that use that library. If "parts of your code that use that library" refers to your application code, then yes, [you *can* hide that](http://www.web2py.com/book/default/chapter/01?search=not+subject+to+any+license+constraint). If you modify the web2py framework code itself, then no, that would have to remain open.
awesome! thanks!
&gt; Claims I'm tired of are that SQLA is only good for "legacy databases" I think he was actually paying SQLA a compliment -- saying it is *better* at handling legacy databases (not that it is *only* good for that).
Note, the post does include a link to the [book chapter](http://web2py.com/book/default/chapter/06) detailing all the DAL functionality.
It's just a suggestion. Someone like me who's just browsing to see what kind of features it offers will look at the list provided and come to the conclusion (as I did) that those features aren't offered.
Sir, ending your sentences with smileys is blah xD.
Yes, definitely a good suggestion.
No.
&gt;So, what you are basically saying is that the program that is labeled "Global | Regular Expression | Print" can do more than &gt;regular expressions? You could have just checked the link I pasted instead of asking me. (and answer is yes, grep when started was just g|re|p, but now it has evolved a lot). Also grep is written in C, can you guess which one will be faster ? &gt;What do you think the python library uses for regular &gt; expressions anyways? Not sure but is it identical to how grep works ? &gt; And, if you really need performance, then pipe the grep &gt; output to python! I'm a pragmatist not a fanboy. I don't think you got my point from last para of the previous comment. This is precisely what I am emphasizing. Use whatever tool is appropriate (in true UNIX way) instead of religiously sticking to one tool at hand and making it do all. You can pipe it to whatever you want -- perl, python, awk, sed -- and so on. *And* the point was *never* grep, let me repeat again -- you should not try to write/rewrite something which has been written/developed already as a tool(like the gnu coreutils) and has matured a lot, you may continue to reinvent wheel and be a 'pragmatist' but instead it will be a waste of time, unless you are improving them (better than existing ones) in which case it is good (and push upstream :)). On a technical note, "The ability to turn the output of such an action into a generator is priceless." Not sure how well it may work with a generator. The pipe buffer is 64 KB and after it fills up, you may end up with a EPIPE, so you may have to consume the whole output in python code (like less, ex: dmesg | less) and then iterate over it, so not much lazy behaviour achieved there.
Checkout `mk` http://github.com/ActiveState/mk $ cat Makefile.py class sdist(Task): """python setup.py sdist""" def make(self): sh.run("python setup.py sdist --formats zip") class pypi_upload(Task): """Upload release to pypi.""" def make(self): sh.run("python setup.py sdist --formats zip upload") $ mk pypi_upload [...] [More examples](https://github.com/ActiveState/mk/tree/master/doc/examples)
No worries. It has nothing to do with how the GPL works, it's simply how *copyright* works. I only need to abide by the GPL if I want to make use of rights the GPL gives me. The moment I stop using those rights, I no longer need to abide by the GPL. This is why some organisations require contributors to assign their copyrights: to allow the organisation to relicense the work in the future. The FSF does this so they can update to newer versions of the GPL. Other organisations sometimes do this so they can release proprietary versions, without the requirement to obey the GPL. EDIT: From http://www.gnu.org/licenses/gpl-faq.html#HeardOtherLicense &gt; The GNU GPL does not give users permission to attach other licenses to the program. But the copyright holder for a program can release it under several different licenses in parallel. One of them may be the GNU GPL. EDIT2: ... which has nothing to do with the topic at hand :p
I didn't say anything about web2py.
You can check it yourself and tell me where it's broken.
But the reason they had to follow the GPL wasn't OP's copyright, but the GPL license on the library he chose. If his professors ever want to distribute those binaries they still have to obey PyQt's license.
&gt; I recall having a really hard time getting it to log to syslog What you do is: import logging import logging.handlers slh = logging.handlers.SysLogHandler('/dev/log') # or '/var/run/log' or whatever logging.getLogger().addHandler(slh) logging.warning('Watch out!') Obviously you don't want to go through all these steps each time, but you can always define a function and call it each time. The SysLogHandler takes a second, "facility" argument (defaulting to LOG_USER). &gt; I don't see an awful lot of system software written in python that use the log module, nor log to syslog. Python contains a builtin module called syslog which wraps the Unix syslog system calls, so if system software writers wanted to log to syslog but didn't want to use the logging module, they could have used the syslog module. &gt; To me, as a sysadmin, the log module is a failure because of the lack of clear documentation Instead of just calling it a failure (easy to do), you could ask for help on comp.lang.python (not too hard to do) or log a request on the bug tracker asking for specific changes you would like to see to the documentation (yet more work, but perhaps ultimately beneficial not just to you, but other sysadmins like you). The SysLogHandler documentation is [here](http://docs.python.org/dev/library/logging.html#sysloghandler): what would you like to see improved?
I haven't compared because I have better things to do right now. I only mentioned dejavu as I felt people might want to have a look at it :)
is S supposed to be a "kill everyone with a massive never ending burst" button?
I use PyODE and it's very useful, but it's a hell of an overkill for this situation....
Nice one. Looking forward to CouchDB support in Jan. Thanks.
If you wanted to protect code then there are better ways http://www.markus-gattol.name/ws/python.html#protect_code
I guess it is as appropriate as pasting web2py code in a post entitled [Getting Started with Pyramid](http://www.reddit.com/r/Python/comments/e6abx/getting_started_with_pyramid_a_notes_application/c15p52v).
take a look at http://pypi.python.org/pypi/pgmagick many django apps I know switching from PIL to this one for example
Screw that, does PIP work with 3.x yet? Python doesn't work for me unless I have Virtualenv and Pip.
I looked into this recently and couldn't get it to work on windows. There are some of us that develop on windows and deploy on linux. 
Yeah, I misread "library" as "license" in the parent. I blame font hinting. That said, the obligations still only hold while that library is used; if they were given the copyrights, they would have the option of stripping out the GUI, or replacing the library with something else, [EDIT: or [buying a license](http://www.reddit.com/r/Python/comments/ed5xr/help_i_cant_get_my_head_around_gpl_and_pyqt/c178h34)], and would then be free of the GPL's terms. Whether that's worth the time/money is another matter.
That's too bad. But, I really see the advantage of open source at times like this. The project may "die" but the code will be there, and when someone decides to pick it up, it can be continued. Or can merged with other projects.
Let's hope PyPy matures enough to be a usable alternative to CPython, then. We really need a faster way to run Python code.
NOOOOOOOOOOOOOOoooooooooooooooooooooooooo!
Wha'll i agree. We are on the internet soooo fuck it xD
Is Spring really needed to Python? I am not sure…
It doesn't take long to figure out when tuples and lists should be used, and come on, the answer to "do I need a mutable type here?" is basically always no. Plus if you link to Python's lexical parser docs, of course it's not going to be super accessible. Conversely, where's the BNF grammar for PHP's string literals?
The "no 2.x support" part is the most important part of this project. Put it on the front page. 
US is not dead, it's just irrelevant given the more promising PyPy and a strange lack of support from Google (surprising considering their python needs internally, oracle suit re: android vm, etc..) Google should financially support PyPy. In fact, all pythonistas should support PyPy... the momentum on that project is just awesome! 
I am also a bit skeptical of PyPy, it seems like the authors might have bitten of more than anyone can chew, but as far as I know, except for lacking CPython modules, PyPy runs regular Python code perfectly, though sometimes with unacceptable memory usage. Am I missing something? 
I heard they haven't been getting the improvements they hoped for, and they are hoping some of the python-devs will carry on the work. Unfortunately, no taker for now. Let's hope for the best
Perhaps its not the same thing, but what about using cygwin?
Please take the time to inform yourself of the current status of the project before making such clueless comments.
Firstly, they are working on it. Secondly, CPython modules expose the weird and silly double garbage collection of CPython using both reference counting _and_ a real garbage collector - a PyPy implementation of the API would need to jump through some rather inefficient hoops in order to simulate this.
next sprint: http://groups.google.com/group/comp.lang.python.announce/browse_thread/thread/3525940018684145# 
[It's not dead, it's just resting](http://www.youtube.com/watch?v=4vuW6tQ0218)
The PyPy guys have a flattr account, which makes it really easy to give them a little support now and then.
Nothing in that sprint about improving CPython bindings, which is rescind's largest complaint, as far as I can tell. And I kind of agree with him, very few real world projects don't use at least a few CPython modules.
&gt;&gt;What do you think the python library uses for regular &gt; expressions anyways? &gt;Not sure but is it identical to how grep works ? Missing facts are a bitch, aren't they? I started this comment line with this: &gt;If it is as simple as a grep one-liner with a pipe then of course I would do it that way, but that is standard linux use. So I'm not sure what you are trying to convince me of.
Well, you may have missed a lot of what waf does then http://waf.googlecode.com/svn/docs/wafbook/single.html#_essential_build_concepts See also: http://waf-devel.blogspot.com/2010/12/make-your-own-build-system-with-waf.html 
Have you even bothered to look at current PyPy progress? Current memory performance? Semi-working c binding support? It appears to me that progress has been remarkably swift in recent months and you either know something I don't or you're a troll.
I do not mean to be rude but I did not ask you. I really interested in his opinion on the topic. Anyway. A computer programmer should be able to simply answer Yes or No. You did not answer either.
You can already do insert, update, delete and select by id with couchdb. The ability to translate dal queries into couchdb queries is the missing part.
No, I don't think it is appropriate or elegant to continuously spam other people's threads about their framework experiences with code from **your** framework.
Cross posted from HN: No, it's not dead, and I'm sad that this is sitting at the front page, because it's so misleading. The fact is, it's stalled (https://www.google.com/buzz/bcannon/bZDN1jNZ3uC/Is-this-fina...) - http://www.python.org/dev/peps/pep-3146/ was accepted. This means that a branch was made with the intent of merging US into Py3k. Unfortunately, this proved to be a greater task then originally planned. Stalled != Dead. To quote Collin: *"Unladen Swallow is stalled because merging the code into the py3k-jit branch plain sucks: lots of new compatibility work to be done, lots of corners we had to un-cut, lots of drudge and suffering. It doesn't help that Google is full of far more interesting and influential projects."* So add in the fact that the resources Google had "assigned" to the project got moved/reassigned onto something else, and what you have is a very stalled project. Collin has stated that they hope(d) that other python-core devs would/will step up to help, but everyone is pretty tapped out as it is. I'm as disappointed as anyone that it's stalled - given it's compatibility with C extensions, potential speedups and future potential, it has been one of the projects I've had the most hope for. That said, PyPy is also coming along; when they hit 2.7 compatibility and they have drop-in replacement capability, the ecosystem will be very interesting. Competition in the interpreter space is good, and I feel that Unladen's aggressiveness helped spur/move PyPy along. That said Unladen (in my mind) remains the CPython interpreter's best way of moving into the future. It still has the most promise for that code base.
It's pining for the Fjords!
Troll title detected.
Semi-weekly repost also detected.
more pics...and does it do Djando projects out of the box?
Hsssss....it burns us!
Even if you were making a general statement about the GPL (i.e., lack of freedom to hide your code), the clear implication was that your concern would apply to web2py, and I was just pointing out that it does *not* in fact apply to web2py applications. *Explicit is better than implicit.* :-)
I haven't seen any reviews either. It is much newer than the Action book so it might be better...also Cody Precord (creator of Editra) is the author so at least he has real world experience as well and an editor is not a trivial task.
He didn't seem to talk about one liners there, just that if you are going to use shell commands (as you implied in the heading 'shell scripting') that using python has an overhead. How much of one is up for experimentation. 
This thread is about the DAL from web2py which is GPLed. And I've an issue with just one OSI license being promoted as "the one true free license" while other licenses are more permissive/liberal/less restrictive. Still in essence every existing software license defines restrictions or conditions for the use of the software they apply to.
It seems to me the speedups they achieved don't really take Python to any different level of usage niche, so while it would be nice, I'm not sure I really care that much how long it takes to get merged.
supports any python project out of the box. I guess wouldn't be hard write a plugin to run/stop the server 
But that's the point, isn't it? mdipierro gets chided for providing information about web2py in other threads, yet people have no problem posting about other frameworks in web2py-related threads. If you read through this thread, it's clear that mdipierro [doesn't actually have a problem with the latter](http://www.reddit.com/r/Python/comments/ej0p1/new_standalone_web2py_database_abstraction_layer/c18g0va) and is happy to engage in constructive dialogue about design decisions and the pros and cons of different alternatives.
... so you can function while you function?
Awesome! Another Python PostgreSQL driver. Everyone keeps creating a new one because all the others suck. If people would give up the NIH attitude and actually collaborated, maybe the wheel wouldn't keep getting reinvented. Then, just maybe, a Python PostgreSQL driver that doesn't suck would get released.
This critique sucks.
Keep in mind that reddit is an open forum -- it's not the same thing as the dedicated mailing list or discussion forum of a specific framework. Some people reading threads on reddit are not already (or solely) committed to a particular framework and so may be happy to learn new information about other frameworks (including web2py). One person's spam is another person's treasure. ;-)
OK, but who's saying the GPL is "the one true free license"?
Perfect. So by your admission above my "spamming" in other threads is "as appropriate as" what other people are doing here to me. Are we even now? Can you stop now spamming my own thread about how I spam other threads or this disinformation meme has to go on forever?
Maybe in theory, in practice taking over a problematic system sucks.
You asked if it was appropriate. I only reminded you that that was a pedantic question given your past behavior.
Here is where we disagree. I welcome the intrusion of SQLAlchemy people and dejavu people. It does not bother me one bit that somebody mentioned Flask and Django on "my" thread. I am a grown up. This is a public forum about technology and it does not bother when people talk about "competing" technologies. We can and should all learn from each other. I am sorry to see that some people act like kids: "this is my thread and I am the only one who can play with it". It bothers me instead that some people chime in just to lower the level of the discussion from a technical one to a personal one and without providing any technical contribution to the discussion. I am also frankly surprised that some people continue to propagate this meme about me spamming when they do the same all the time in different and possibly worse ways. I do not think it looks good on your community (whatever that is) which I trust to be as nice and friendly as the web2py one.
I consider rudeness what mdpierro did in the thread linked above, about Pyramid. If he did it once, it would be forgivable, but we know it is not the case. Better would be if he would write a blog post and submit a new link instead of trying to steal other people's thunder. It's kind of a gentlemen's deal. Yes, this is an open forum. It is not a place for things like "I did not ask you".
one look at the authors pic at the bottom tells me everything I need to know. 
Okay, maybe i misunterstood you when you questioned if it was appropriate to talk about SqlA on a web2py thread.
I guess Google support died down when Unladen Swallow worked, but failed to bring significant improvements. Given that it results in an [approximately 1.5x speedup of pure Python code at the cost of 3-4x memory use and 1.5x slower interpreter startup time](http://www.python.org/dev/peps/pep-3146/#performance-vs-cpython-2-6-4), and complicates the build process and CPython source code with the inclusion of C++ and LLVM, I'm not even sure if it is worth the merger. Most server workloads are memory-limited: you can always start extra parallel threads or processes to handle the requests if you have enough memory.
nope you will have to learn python and do it yourself. :)
But apparently this "gentlemen's deal" doesn't extend to web2py-related threads. Note, this post is actually an *announcement* of a new release, and the very first two comments were promotions of *alternative* ORMs. The Pyramid thread you reference, on the other hand, was not an announcement about Pyramid, but just a code tutorial. In his comment, mdipierro was making a point that he thought it was particularly verbose -- a separate blog post would have been out of context. In any case, I'll grant that maybe the Pyramid comment was a borderline case (it did get a lot of downvotes), but are there really lots of other examples of the "gentlemen's deal" being violated? &gt; It is not a place for things like "I did not ask you". In fairness, this was in response to a rather impolite dig.
Everyone who mentions the words free or freedom 2-3 times in one sentence in their rationale for using or praising it. You'll notice how everyone else likes to put "permissive open source license" when refereing to BSD/MIT/Apache for example. Free - no restrictions Permissive - some restrictions apply
At least there is a possibility.
not to mention that style is great for one off iterations on tools: for i in 1 2 5 6 7; do fsck -fy /dev/sda$i; done; (didn't use seq, cause 3 is swap, and 4 is lvm) And, I've also done bits for mounting, and rsyncing with similar loops, hard to argure that type of work'd be simpler in python, as in RIP style envs you don't really have much of an option.
&gt; Everyone who mentions the words free or freedom 2-3 times in one sentence in their rationale for using or praising it. Just because someone uses a license because it protects particular freedoms that they care about does not mean they believe it is the *one* true free license. I think you're over-interpreting. &gt; You'll notice how everyone else likes to put "permissive open source license" when refereing to BSD/MIT/Apache for example. Actually, I haven't noticed this. I think people often use the word "free" when referring to open source software. You really appear to be splitting hairs here.
haha, actually cygwin is nice once you get puttycyg installed as a frontend for it (the windows console is pretty terrible). I don't think I could live on windows without it.
Is it an African or European swallow?
African. The main reason Santa is so jolly is because he knows where all the bad girls live.
That looks like it might work. I'll see if I can get it working on Windows as well, if I can then it looks like it should do what I need. Thanks!
Anyone know what kind of refactoring capabilities it has?
So do you believe that there is no predisposition in people that makes them evil? Why do we look in our handkerchiefs after blowing our nose?
compared to pycharm ?
Will PyPy ever actually be ready for production, though? It's been how many years now?
Genuine question: How is this not exactly the same IDE we've seen over and over?
So what can I do with this that I can't do with Eclipse + PyDev?
If it isn't dead, then it's stagnant; which isn't much different.
A shorter time than Perl 6, surely. It's more or less "ready for production" if you don't use C modules or language features past Python 2.5. It may not be a drop-in replacement for CPython quite yet, but don't discount the enormous amount of work they've done so far. They have, as far as I know, the only good JIT for Python (Psyco isn't a "real" JIT, it just performs one specific optimization), and the only working sandbox.
save ram memory
I have 8GB of ram. It's not really an issue. Any other advantages?
I'm not sure there's a lot to innovate in this terrain.
open source.
is not written in java
So why should we bother learning this IDE over the ones that are already ingrained into our minds?
How is that an advantage? It's not like python is 'faster' than java.
This critique does seem a little half-hearted but I followed up some of the links to other critiques and there are a lot of complaints about things which seem totally irrelevant as well. Nobody seems to mention a trailing comma creating a tuple. Ha that one shafts me about once a week. I can understand how that would be hard to fix though. Python's data structures are its power so I would never complain about having too many unless they become redundant. You can get pretty far on just the power of lists, dictionaries and tuples and not touch any of the other data structures.
o.O How does that qualify as an advantage? I mean, I know Java is horrendous to develop in, but I've never had a problem with performance in Eclipse. I guess what I meant was, what features of this IDE (better plugins/plugin structure, better code editor, better autocomplete) are superior to those included in Eclipse+Pydev? What reason are you giving me to switch?
That's really lame as an advantage. I like that it uses QT on the other hand. 
There's not much information on this site. Probably because they havn't got very far as of yet. Wing IDE and PyCharm are also focused on Python. No selling point here. These two and PyDev+Eclipse will be very hard to beat. Nevertheless, good luck and fun with the project. Edit: I forgot Eric IDE, which is also extremly feature rich and dedicated to Python.
In-process debugging?
You can say that again. Isn't it a bit unnerving that doctors call what they do "practice"?
Did you try reload(time)? I'd be curious as to whether that changed anything. I know it's been a while, but I just thought of it.
Palindrome testing was the first thing I thought of when I saw this in the Programming Python book. The only thing I added was to first strip out any whitespaces or punctuation, convert everything to lowercase then run the test.
it doesn't. it was just a joke.
No offense, man, but this novelty account sucks.
http://dpaste.com/285406/ Using Python 2.7 and PyQt4.8.1.
I get to avoid hardcoding 1 2 5 6 7 better.
Anyone know if it gracefully handles virtualenvs?
It's developed by a group of python programmers thinking what would make the life easier to another python programmers. I started using it mostly for the extensibility.
Ah OK cool. How is it extensible? Does it work towards making plugin developing easier than eclipse/netbeans?
I found it easier. I'm a python programmer and I don't want to write Java. That's why, if you check the title, says Focused on python.
there's plans to support virtualenv. I'm not sure if out of the box or with a plugin.
I disagree. - I want my IDE to track every change I make anywhere. - I don't know about you but my screen is really quite wide compared to my code. What about strips that layout across my screen that wrap from one to the next? - Word wrap sucks. Certainly we could do better here. - I want to have a python console for the project itself, so I can do find and replaces or line changes through that. - I want shared help documentation as part of the UI - I'd like to view the code as a large graph, create functions by creating new nodes, etc. - Built in git / hg support. - Issue tracking. I could go on. These are just off the top of my head. 
Interesting. I was originally under the impression -- perhaps erroneously on closer reading -- that pygame natively supported BMP only, and relied on a dependency (which I assumed was PIL) for other formats. I will have to experiment with that, as that would more or less solve my immediate concerns. There are still a few other libraries which are somewhat hobbled by an explicit dependency on PIL, but there's not much that can be done about that in any case. And as long as I have access to the image data, as I would by loading it into a pygame surface, I may be able to trick those other libraries into working properly. Thanks!
&gt; I want my IDE to track every change I make anywhere. like to ctrl+z all over the place or like to commit to git? &gt; I don't know about you but my screen is really quite wide compared to my code. What about strips that layout across my screen that wrap from one to the next? I didn't get that point. could you elaborate on that? &gt; Word wrap sucks. Certainly we could do better here. sure, but if you stay in the 80 chars limit, you never will need word wrap. &gt; I want to have a python console for the project itself, so I can do find and replaces or line changes through that. actually I'm writing a eval plugin for doing this. Vim (at the top of my head) also can do it. &gt; I want shared help documentation as part of the UI done &gt; I'd like to view the code as a large graph, create functions by creating new nodes, etc. wat? &gt; Built in git / hg support. I guess that would be a killer feature &gt; Issue tracking. like integration with jira / trac ?
sorry if it sound harsh. Is not meant to.
[Cython what you looking for?](http://www.cython.org/) compile pretty much straight python code into a C extension for Python, with often a many hundreds fold increase in speed, it introduces static typing if you want it, which results in massive speedups. Or use it to expose C libs to python as an extension. Cython rocks, I dunno why you need PyPy, as cool as it is.
1. Like what files have I edited in the past month? Oh, what did I do to that file? Like ctrl-z on hyper-steroids that changes you understanding of what ctrl-z can be. 2. http://min.us/mvphlym (first image) 3. 80 Character limit is a lie. Even if I wanted to hold myself to it, you as the IDE developer should not assume I will. I was thinking maybe something like an icon that appears at the end of the line to indicate the line has gone over, and possibly when you mouse-over it, it shows you the rest of the text. 4. Great! Make it easy to use. Run all your commands through it so we can leverage all the IDE has to offer in macro form. 5. Shared editable documentation, like a Wiki? If so awesome! 6. http://min.us/mvphlym (second image) 7. Yes it would. 8. Possibly! Or hell, just something really simple that dumps an txt file into my repository. A ninja is a master. A ninja can perform awesome feats as if they are second nature. Something that makes me feel like a ninja, that's all I've ever wanted.
So in other words it's dead. It's just like when the girl says "we need a break", you know it's over then and there
So this is what "ninja coders" use. I was wondering what was holding me back....
huh? are you saying your partitioning doesn't go past 4? or that you think python over bash would have kept me from having to hardcode that?
It doesn't do anything because it's a compiled module.
Here's the only caching @property you need to know: class memoized_property(object): """A read-only @property that is only evaluated once.""" def __init__(self, fget, doc=None): self.fget = fget self.__doc__ = doc or fget.__doc__ self.__name__ = fget.__name__ def __get__(self, obj, cls): if obj is None: return self obj.__dict__[self.__name__] = result = self.fget(obj) return result What goes on here, is that the object is known as a [non-data descriptor](http://docs.python.org/reference/datamodel.html#invoking-descriptors). It's specifically the fact that the object has only `__get__`, and not `__set__` or `__del__`, that values placed in `__dict__` override the descriptor. This means after the first time `__get__` runs, all subsequent accesses are direct attribute access - zero method call overhead. 
I'm honestly pretty hard to please when it comes to code editors (I generally hate them all, and whenever anyone tacks on "IDE" I tend to hate them more :-) but I do have some honest questions: * After messing with it a bit, my *absolute* biggest gripe so far has to be the fact that I can't seem to do anything about the BRIGHT default colors. I'm someone who prefers dark themes (give me something like zenburn or rdark, or give me death). Do you have any plans to support re-theming for those of us who prefer our eyes not being raped? * I notice that code completion is on the TODO-list. What do you guys mean by "code completion"? Do you mean simple "search through currently open document for similar words" or something more complex like [IntelliSense](http://en.wikipedia.org/wiki/IntelliSense). Personally, I've started and abandoned an IntelliSense-like Python API several times over the years (I've just never had time to complete it)- with Python being reflective, it just *seems* possible to build something that can parse code quickly as it's being typed and populate a DB (I was thinking like sqlite, but, again, I've never gotten far enough to really know for certain what would be best) with the classes/methods/functions in a given Python file (or module) for quick searching by a Python-friendly editor/IDE. Even though I'm hostile to IDE's in general, I'd still cream-my-pants if I found a Python editor that did this right... Also, kudos to "[eating your own dogfood](http://code.google.com/p/ninja-ide/source/browse/#hg/.ninjaproject)" on the project, and kudos to using Mercurial... *Edit:* Screw it, I'm checking out the source to try and answer some of the questions myself... hell, I may even find something to contribute, who knows? Stranger things have happened..
Even the C modules problem is changing. PyPy recently added CPyExt, an implementation of CPython's C/C++ API. CPyExt is still at alpha quality, but the pypy devs are working on it. Also coming down the pipeline: A [memory optimization](http://morepypy.blogspot.com/2010/11/efficiently-implementing-python-objects.html) that removes the need for a full hash table for each object. It's like \_\_slots\_\_, but automatic and without the weird inheritance issues. It even has a proxy "dict" at obj.\_\_dict\_\_ that can be treated like a dict, right down the the type.
&gt; Cython rocks, I dunno why you need PyPy, as cool as it is. Simple, because I don't want to "compile" to an extension which I have to install in order to be able to use it if I can have a fast Python interpreter instead. Also, a faster Python interpreter is generally good, wouldn't you agree?
If no one takes care of it, it will be incompatible in no time and picking it up then will be painful.
&gt; Also, kudos to "eating your own dogfood" on the project, and kudos to using Mercurial... I really appreciate that. I'm not even part of the development team, but I know some of those guys and I'm sure they'll read that. &gt; Edit: Screw it, I'm checking out the source to try and answer some of the questions myself... hell, I may even find something to contribute, who knows? Stranger things have happened.. that would be *Awesome*!
I'm not sure if you're one of the developers of the IDE but, I was browsing around and got this error &gt; Over Quota This Google App Engine application is temporarily over its serving quota. Please try again later. [Here](http://filevo.com/0l4oavs7bgcy.html) is a link to the source of the IDE if anyone wanted to try it out.
Pardon my ignorance (I only use vim currently), what IDE is that? The graph view especially seems useful!
It is no IDE, it's just a quick mock-up of something I have imagined. Hopefully someone will actually turn it into an IDE.
I don't know about you, but every time I start up basically any GUI in Java it feels clunky and sluggish. Eclipse is even worse. Open up Notepad, and then open up Eclipse, notice how Eclipse takes 20 times longer to do *anything* that Notepad can do? Even with the massive feature set, it doesn't have to be that slow.
Well that's debatable. My machine is pretty powerful, so while eclipse takes longer to load than notepad, I'd rather have the features that eclipse has. You are right, eclipse has room for improvement with speed, but it wouldn't be any faster if it were written in python unless it used a smarter set of algorithms.
Drat. I was getting giddy. The two column spread is a pretty sweet idea.
&gt; surprising considering their python needs internally, oracle suit re: android vm, etc. Google has got [Go](http://golang.org) now...
No, it's definitely faster. Because remember that although its written "in python", all the important stuff is in C. I have tried this out by writing my own IDE and comparing it to Eclipse.
No shit, it should be called nonsensical_questions
Should this line be: return dict(form=crud.update(db.note,db.note(request.args(0)),next='index')) or redirect(URL('index'))
And your IDE has the all of the features and can load of the plugins that eclipse can? And it can handle all of the different languages and environments and localities? What about the local history and source control integration?
Well, no that's what I was saying, it doesn't have all the features, nor can it load java plugins, although I did have a really sweet (and simple) plugin system. It could handle all the different languages / locales though, cause it was built on-top of a library that could do that. So it came pretty close, and was quick as a whistle.
To say that it came pretty close I think is a borderline lie. Eclipse is meant to be an everything and the kitchen sink application. It's not surprising in the least bit that you can code up a text editor that is faster than it, that's not the point. Even though your editor had a sweet and simple plugin system, unless you go and implement all of the plugins that give it a feature set similar to eclipse, comparison of the two in any way is just garbage. A better a much more fair comparison would be to implement the editor using [eclipse's RCP](http://wiki.eclipse.org/index.php/Rich_Client_Platform) and then compare performance that way.
Eclipse is over-engineered, as evidenced by it being built on an "RCP". Maybe I don't understand you, but what I'm saying is, I have a hawk here, and you have a fish. The hawk is faster, so you suggest putting it in water and seeing which is faster. But my point is, the water is what slows you down. I meant "pretty close" on a relative scale. If I had gone to implement all of the features, it would take me a long time and many developers, but I am confident it would be much faster than Eclipse.
I don't think we're disagreeing with much here, so I'll try to make this brief :) Eclipse is not meant to be a lightweight editor. It's meant to do everything. Therefore comparing your editor to eclipse is simply not a fair comparison. They are two different products attempting to cater to two different audiences with two different needs. It's like comparing a ferrari to a hummer. It just doesn't make sense.
A Little Bit of Python. 
No, it's exactly like comparing a ferrari to a hummer. They do different things, one is meant to be fast and agile, the other a giant utility vehicle (okay, ignore that really hummers are big luxury items). What I'm saying is, if the ferrari company made a giant utility vehicle it would still be faster, because hummer design is based on poor ideas from the get-go. Okay this analogy just got strained well enough. Anyhow, I suppose it all comes down to me saying: "Eclipse is full featured, but is built poorly and is slow, part of that is the Java libraries it uses and part of it is its over-engineered quality." And you are saying that I can't demonstrate that, because nothing else matches its features. Which is fair, I just think you can extrapolate from existing, less featured, IDEs and come to a reasonable conclusion as to what its speed would be if it were as full-featured as Eclipse.
Site is down, is there a mirror?
I do!
i needed to rename those 10 files, as well as replace their content, that is, all instances 8898800 becomes 8897500, and so on. this was a one time operation. where did you get the idea it is regularly? 
Yes, but C libraries are fantastic, there is no sense re-inventing the wheel in Python when so much is already done efficiently in C. Cython compiles fast, and the module doesn't have to be "installed" once its compiled its dropped directly into the right place and can be imported immediately. Cython's aim is to be able to compile any plain Python code, when that happens, what exactly is so hard about compiling your existing Python script and seeing a 50x increase in speed? The speedups the PyPy and Unladen Swallow are offering pale in comparison to what Cython can offer.
Ah ok fair enough. The problem lies in that extrapolation though. Netbeans' kernel is actually pretty tiny ( I haven't done eclipse dev in a while so I can't comment on eclipse's). But they are meant to scale to large amount of plugins. (Hence the over-engineering). So the reason why you need to have a comparable feature set is because the "kernel" program has to be able to scale to same number of plugins and allow the same amount of flexibility that all of the plugins desire. You have no evidence as to how your program scales.
&gt; the answer to "do I need a mutable type here?" is basically always no Do you use tuples more often than lists? &gt; Conversely, where's the BNF grammar for PHP's string literals? How many programmers need the BNF grammar for string literals? And how many programmers need the simple, easy-to-read description with examples?
Yes, and it'd be nice if I could eat my birthday cake riding atop a flying unicorn while choirs of angels sing my praise, but it's not going to happen.
Your comments don't work. 
oops. yes.
&gt; Yes, but C libraries are fantastic, there is no sense re-inventing the wheel in Python when so much is already done efficiently in C. Cython compiles fast, and the module doesn't have to be "installed" once its compiled its dropped directly into the right place and can be imported immediately. You're absolutely right, re-using mature, established C code is very important and useful. &gt; Cython's aim is to be able to compile any plain Python code, when that happens, what exactly is so hard about compiling your existing Python script and seeing a 50x increase in speed? The speedups the PyPy and Unladen Swallow are offering pale in comparison to what Cython can offer. This is all wrong, Cython (nor anything) *can't* efficiently compile pure python code using even a fraction of the dynamic expressiveness that makes python what it is. It's true that Cython can compile a static-ish subset of python, and generate very efficient code from it, but it's not Python, it's Cython.
Yes. Sadly the difference between 'stalling' and 'death' in an open source project is very small.
As of just recently, the PyPy devs consider PyPy ready for production. Lots of production stuff will need binary CPython extensions, which are not quite working yet, but many will.
Cython, ShedSkin and RPython are all **subsets** of Python - that can be compiled statically, so they become fast. That's cool, but it isn't all the power and expressiveness of Python. 
I read his wxpython tutorial. It was good. Nothing else on the internet made wx make sense. Someone needs to re-think the way we create GUIs.
&gt;Missing facts are a bitch, aren't they? That was more of a rhetorical question. When a whole file and not a multi-line string is considered, I dont think pyre has any special provisions like """ #1 trick: GNU grep is fast because it AVOIDS LOOKING AT EVERY INPUT BYTE. #2 trick: GNU grep is fast because it EXECUTES VERY FEW INSTRUCTIONS FOR EACH BYTE that it *does* look at. """ If there any differences, please mention them here so I that I also can check instead of making generic banal statements.
It is Cythons stated aim to be able to compile any Python code, I said its their *aim*. You might typically only need to convert a few functions to Cython code to get some decent speedups.
Yeah but you would typically only need to compile a few functions, then you can import them into regular expressive Python and use them in a regular expressive pythonic way, like so many Python addons. Its a pretty simple step to get incredible speedups.
You are not reinventing the wheel. Cython is cool for certain applications, but you cannot seriously take it as a complete Python replacement. It just is not as easy to use.
This was a great resource when I made my first PyQt app. Unfortunately, I screwed up somewhere along the line, so the method I used was pretty much unique, making getting support on the net pretty hard. That's the only downside for PyQt right now - getting help. People are willing to give you aid, but your problem might be novel.
No, it's not. Only the string literal is ROT13'ed, not the source code itself.
I was hoping the pdb stood for protein data bank :(
How is this better than ipdb?
Go is new and has some interesting features. It is also still classified as [experimental](http://golang.org/doc/go_faq.html) by its creators. Python, on the other hand, is mature and on a different plane of development in terms of its ecosystem. Go is also (at least from the perspective of someone who likes to predominantly code in python) quite an [ugly](http://golang.org/doc/go_tutorial.html) language. I would surmise that Google should probably keep their options open just in case... 
Uhu? What is 'ugly' about Go? It has one of the most clean and pragmatic syntaxes I have seen in any language. It is certainly much less ugly than Java or C++, or Ruby or Erlang (which btw I love).
I wolud also like to suggest you check out [pudb](http://pypi.python.org/pypi/pudb), too. it uses urwid (ncurses replacement) and looks and feels pretty nice.
I recommend ensuring that the `__get__` can be invoked more than once though in case someone calls the special method with reflection: https://github.com/mitsuhiko/werkzeug/blob/master/werkzeug/utils.py#L30
I could not find a list of ipdb features, so it's hard to compare. However, it seems that ipdb does not offer much more than pdb, just source highlighting and the new pdfe, pinfo and pdoc commands. On the other hand, pdb++ offers tons of features: even the sticky mode itself is a killer feature imho. Also, being a drop-in replacement means that you don't have to modify a single line of code to use it. E.g., py.test --pdb will use it automatically.
Hi! I'm one of NINJA-IDE developers (and one of the creators of this project). It was really nice to hear about some comments and suggestions for the project here. Let me tell you that the project has only 3 months of life, and we are working really hard to achieve all the goals that we consider important and the community suggests. If you consider that there is a really important feature that has to be implemented in this IDE, you are welcome to join the mailing list and suggests it or ask for an enhancement in the Issue tracker. That is the idea, we are all python programmers, and this IDE wants to cover all the needs of a python developer. Here is the source code: http://ninja-ide.googlecode.com And this is the main page: http://ninja-ide.org.ar
I'm a big fan of this one; feels like the Matlab debugger to me, but in a terminal so it works on a gnu screen or a remote session.
After `sudo pip install pdbpp` completing successfully, I seem to still be getting the old pdb prompt. I'm trying `pdb script.py` and end up with a regular `(Pdb) ` prompt; trying to use the new `sticky` command results in a NameError.
* Yes, we are going to support re-theming, not only for the editor, but also for the IDE through something similar to CSS. * With Code Completion we mean something similar to IntelliSense, currently is supported but with some limitations... but we are working on it.
&gt; I can understand how that would be hard to fix though. Fix the language? That's implying the behaviour is unintentional. Trailing commas for single-value tuples is necessary because there's no other way to define a tuple. Of course writing `(spam,)` makes it clearer that the trailing comma is not a mistake, but in Python code there simply isn't any ambiguity about whether it should be a tuple in the first place (if it's not supposed to be a tuple, the code doesn't work as intended anyway).
You should check out [Activestate Komodo](http://www.activestate.com/komodo-ide) - it actually does a lot of what you ask for, including split-pane (different code views of the same page), a source browser (it acts like a file-tree but checks functions), it has a vertical ruler for marking the 80 char mark, and the fully paid for (admittedly a eyewatering £250 ($330)) has full git integration. It also is based off of Mozilla Firefox - and as such has support for XPI extnesions, meaning you could add the extra functionality in yourself. Also, it has an opensource version - Komodo Edit, which is almost as good as IDE. *edit: phrasing*
that's weird, "sudo pip install pdbpp" works correctly on my machine (ubuntu, python2.6). You probably get this behavior because pdb++ is placed somewhere in sys.path that is *after* the stdlib dir, so when you do "import pdb" it finds the old one. Could you tell me the content of your sys.path please? Also, as a temp fix you can just put the directory where pdb.py is installed in your PYTHONPATH
My attempt at obfuscated Python a while ago: https://gist.github.com/737430
Putty is a must
&gt; Version Hell So the main argument is that there is Py3k and Python 2.x right now? They're trivial to install side-by-side (at least on Linux, which is what matters for web development). The issue itself isn't very different from PHP4 vs PHP5, except that Py3k is a major overhaul of the underlying language principles. That said, the differences developers must cope with when moving from 2.7 to 3.x are minimal. Most code is easily portable, there is even an automated tool to do much of the conversion for you. The existence of older 2.x versions isn't really a Python-specific problem either -- at least it's possible to install them side-by-side if necessary. &gt; Incomprehensible Language Reference Oh, come on. BNF is incomprehensible? True, it's not as easily scannable as plain English, but at least it is unambiguous (that whitespace is not allowed isn't surprising at all: there is no reason to assume the contrary). The PHP docs may give examples, but they're often worthless beyond that because they fail to document the underlying behaviour (the implementation _is_ the specification). All that aside, the author failed to note that the plain English explanation is given right there in the quoted docs. Providing a formal definition _in addition to_ a plain-English explanation is a Good Thing (tm). The reason PHP doesn't explain all forms of string literals in one paragraph is because they're very different both in syntax and behaviour. Heck, you can't fully explain PHP string literals without mentioning magical quotes. This would be akin to including the format of `Template`s and format characters in Python's definition of string literals -- note it doesn't have to do that because strings by themselves are not magical in Python and these characters are meaningless on their own. The plain English description of strings is concise because it doesn't have to be verbose. Strings consist of a matching pair of single or double quotes, optionally prefixed with a type indicator. If the string should contain literal newlines, it is enclosed in a pair of triple quotes. The backslash is used as escape character. Any questions left? Look at the formal definition. Unless you've never used strings before (Why are you looking at the docs? There's a very neat tutorial to help you out!), this is all you need to know to get going -- and the BNF allows you to make sure you didn't misunderstand anything, too. &gt; Optimized data types For most intents and purposes, lists and maps are enough to get going. It helps to understand tuples if you don't think of them as immutable lists but instead as values of their own. Coordinates, for example, are much like numbers, except they usually come in pairs (or groups): on a 2D plane, you always have an x- and y-coordinate and you usually need both. Sometimes it makes sense to have a special `Coordinate` class to deal with these, but in many cases you don't want to waste time overengineering a simple problem and instead just need a way to pass multiple values that form a unit. In other languages you'd often have to use arrays or lists for this purpose. In Python you can just treat them as a tuple and you can pack and unpack the tuple on the fly. This fact is especially handy in iterations: in PHP you have to use a special syntax like `foreach ($my_arr as $key =&gt; $value)` while in Python you can simply say `for key, value in my_map.items()`. Likewise, to iterate over a sequence of coordinates you can simply say `for x, y in coords` where you'd otherwise have to say `for coord in coords: x = coord[0]; y = coord[1]; ...`. Don't worry so much about the performance implications, think of the semantics first. Your code should be readable to start with, only then should you try to optimize it. Of course being aware of the language's idioms helps (often idioms are taken into consideration as the language is improved, so idiomatic Python is often also faster Python). Generators exist for a reason. But chances are you won't encounter that reason in your first couple of programs. It's good to know that things like these exist and what they are there for, but that doesn't mean you have to use them from the get-go. Learning when to use them and what problems they help solving is part of the learning process. Just like inheritance, meta-classes or decorators, generators aren't the cure for cancer or the answer to all your problems. But they are answers to some problems -- you probably just haven't them encountered yet. &gt; Conclusion If you want to learn Python, take a look at the many good tutorials out there. The language reference is mostly a technical guide for implementers. The library reference is a good starting point if you want an equivalent of the official PHP reference (it documents all the standard libraries and built-in functions). If you're wondering whether to pick 2.x or 3.x, there's a good article on that, too. Basically the choice is whether you want to get things done today, working with existing code and third party libraries, or whether you want to learn a cleaner and purer language that still has a few gaps in its library support (if you're into FLOSS, you can just jump in there and port your library of choice to 3.x, though).
Wow... those images are sweet. I'm salivating...
why the heck would you name something about an operation your language doesn't include.
I have yet to find a Python IDE that I like, so I'm not gonna complain when someone makes a new one.
**N**inja **I**s **N**ot **J**ust **A**nother IDE :) Thanks, I'm looking forward to trying this!
&gt; and the task manager is probably going to get even more crowded I'm not sure this is a real issue.
The first few lines are: ['', '/usr/bin', '/usr/local/lib/python2.6/dist-packages/python_graph_core-1.7.0-py2.6.egg', '/usr/local/lib/python2.6/dist-packages/pip-0.7.2-py2.6.egg', '/usr/local/lib/python2.6/dist-packages/pdbpp-0.6-py2.6.egg', '/usr/local/lib/python2.6/dist-packages/wmctrl-0.1-py2.6.egg', '/usr/local/lib/python2.6/dist-packages/pyrepl-0.8.2-py2.6.egg', '/usr/local/lib/python2.6/dist-packages', So I should put `/usr/local/lib/python2.6/dist-packages/pdbpp-0.6-py2.6.egg` on my PYTHONPATH in the meantime? ...That doesn't seem to be working either. FWIW, I'm on Ubuntu 10.10 with python2.6 as the default, and python2.7 installed elsewhere for when I invoke it via `python2.7`. (That is to say, `python` still invokes 2.6.)
It makes killing off certain tasks a bit of a pain when I'm debugging applications; &gt;pythonw ... &gt;pythonw ... &gt;pythonw ... &gt;pythonw ...
ah wait, I did not realize what you were doing. Indeed, pdb++ does not install a pdb script, so by running 'pdb script' you are still invoking the old one. If you use python -m pdb script it will work. I'll add the pdb script in the next version, thanks for pointing it out :-)
Aha! Wunderbar. $ python -m pdb Problem031.py &gt; /home/isarl/.virtualenvs/Project-Euler-Python/Problem031.py(3)&lt;module&gt;() -&gt; Requires Python &gt;= 2.7 for combinations_with_replacement.""" (Pdb++) Thanks. =)
the multithreading option could get very hairy. I suggest to leave each task in a separate process, but find a way to label them differently, so that the Task Manager makes them more obvious. Search for "win32com python" 
win32com isn't going to do me any good. They are all hidden terminal applications, so they only show up under the processes tab as "pythonw.exe" with the only differing thing being the Command Line column.
How are you launching them? You could at least use [ProcessExplorer](http://technet.microsoft.com/en-us/sysinternals/bb896653) (you really should anyway it's **so** superior to task manager) and then child processes will nest under the parent process and reduce the clutter. 
I would perhaps cheekily rephrase your question to 'what is not ugly about Go'? But we are now deeply off-topic and in the end to each his/her own. 
Combining them into a single process isn't going to help you with that...
Never heard of this framework until now. Looking through the tutorial it seems to be the bastard child of Django and Flask. Which is a good thing.
What sets its apart from he other ones? What are its unique features? Why is it better - in your opinion - than the other ones? What should other framework learn from KalaPy?
Haha that's kind of what I was thinking... it could have been named pdb+=1...
I never said it was a complete Python replacement, not once. I merely said why do you need a complete python replacement when you have Cython? which is already making regular Python many times faster than PyPy or Unladen Swallow promise to be. Whatever you guys like, thats fine, I was just pointing out a really good tool to someone in the hope that i might help them. Fuck me I wasn't trying to start a flame war, how dare I upset the PyPy support base, I am eternally sorry.
Eclipse as Python IDE? Are you joking?
Well, PyDev is pretty far along and usable. I developed in it until my computer couldn't cope with it anymore. Then I tried Vim and have stayed with it ever since. But is still lacks a few things to be a nice working environment (I actually agree that these things lacking are by design) so that's why I started searching for an alternative. In a country were all college students graduate using visual studio it is hard for them to start developing in real technologies. Eclipse used to make this transition seamless, but I don't like the Java thing at all.
This isn't strictly relevant to what you're talking about, but I'll mention it anyway. I'm not a professional programmer (actually a physics student), but I do a reasonable amount of work in Python. I've also tried Eclipse and loved some of its features, but it's just far too unwieldy for most of my simple work, and I very rarely use its features enough to be worth the bloat. I've also switched over to Vim for all of my coding (I'm still learning how to be truly effective in it, though). Anyway, my solution for programming so far has been creating something like a very rudimentary "eclipse mode" for Vim. The way it works so far is that opening a .py file starts up a standard Vim window, 80 columns or so wide, and nicely set up to load quickly and get me hacking right away. If I need more tools, pressing &lt;C-r&gt; loads up NERDTree in a column on the left, which means I can use the current folder as a kind of project directory (sufficient for what I do), and Tagslist in a column on the right (great for exploring the contents of a file). &lt;C-e&gt; switches back to the regular, small editing window. I've also installed a plugin to use tab for all my completions, which works nicely. This is nowhere near what Eclipse offers, but it's sufficient for me right now, and it has a lot of advantages, namely: * it loads about as fast as regular Vim (i.e. dramatically faster than eclipse) * it doesn't enforce a project-based perspective when I just want to write one little script * it lets me use the same editor I use for everything else * vim plugins and config files are all stored in my dropbox and symlinked to their appropriate locations. This means that all behaviors are exactly the same on my mac and my PC, and I never have to do any configuring twice A more well-featured IDE that offers those advantages (and more, perhaps), would be extremely attractive to me. Good luck with your project!
Eclipse sucks, so all of them.
I totally agree with you. For myself Vim is enough. I love working on the terminal and not having to right-click and select "Run As" or any other menu in an IDE. But most people do not, and inside my institution this is a problem. We only hire people based on their willingness to work. Although we only develop in Python that is not relevant. Anyone can catch python from any other language in no time, but the tools available are lacking. So I am looking for something that makes new people productive in less time. Eclipse does it, but 2 GB of RAM for an IDE on a language overly technical for any fast response is odd
I am leaning towards ninja because it is more IDE like already. Pida is way too flexible. Flexibility also brings complexity (Hours spent configuring flexible tools like Vim and Emacs are proof of this)
and i get multiple downvotes too! does that mean that i'm just judging a book by its cover, that the title is knowingly ironic, or that people actually disagree and think its a good name? downvotes without responses are frustrating.
So much Eclipse hate. I often use Eclipse + PyDev for python work. Granted, it's bulky. However, aside from that it doesn't seem that bad to me. However, I don't have much experience with other Python IDEs, so what's your recommendation aside from "all of them". Keeping in mind that the features I like with Eclipse + PyDev are: * All projects viewable and easily accessible in a pane / list * Code completion * Refactoring * Syntax Highlighting * Debugging * Smart Indenting * Code Folding There are more, but these are probably most important to me that an IDE I use should have.
Apparently it's "developed with fun"
Actually I don't hate Eclipse at all. It's an awesome tool. I would just love a pythonic alternative. It is way easier for noobs (pretty much like myself) to get a grasp on python than java, which would also allow noobs to write extensions for the tool they are using. That's the main reason. Also that I don't like the Java/Oracle debacle and the fact that to maintain a totally opensource alternative I have to use a subpar JVM. 
Hi, I'm one of the NINJA-IDE developers, we are actually working in several improves of the application and trying to bring to python developers tools that we found for other languages as Java and .NET. If you are interested in participate, suggest ideas or anything, I invite you to join the mailing list. All the decisions, questions and functionalities are discussed there, so any member of the community is able to express their vision about what a Python IDE should have. Regards!
Great! I would actually love to contribute and put a team behind it. Do you use it? Is it close to production ready? Is there anywhere else where I can find docs and info on it? I would really love to write plugins for it and help make it more Eclipse like in a "Complete development environment" kind of way. I would really like to know more. Monday I'll get a team to work with it and give me feedback. I'll post it in the mailing list.
Thanks! The doc for "How to write a plugin" is in spanish (http://code.google.com/p/ninja-ide/wiki/CrearPlugins). We are working to release the first stable version on the January 22nd. We don't have any more docs at this moment, but we hope to have it near the official release, anyway through the mailing list you can ask anything, we are always available for any question.
Great! Would love to participate. I'm mexican so the spanish part should not be any trouble. What we would need the most is a Django plugin for it. So I think it is the first thing we will work on. I'll join the mailing list and just found you on twitter. Hope to hear more from your crew and great software producing skills.
I've been using Wing IDE for a couple of years now, and I've been VERY happy. It's elegant and functional, and the guys who build/market it are fantastic at supporting the thing. I grabbed the Personal Edition, which is pretty cheap. They have a Professional/Enterprise edition and a free version too, I think. 
I actually saw that too. It seams like a great product but the fact that it is not opensource puts me down. I really want to have tools that are fast to develop for and can freely modify shall the circumstances arise (That is kind of the business model of my upcoming project. Not monolithic expensive and late technologies but rather small, quick and cheap) Wing IDE is a great product, but doesn't fill certain requirements.
Komodo and Komodo Edit (Free) is probably the best Python IDE.
&gt;2 GB of RAM for an IDE Exaggerate much?
Duno if I think four spaces are optimal for indenting in bracketed and similar languages; I tend to use two for CSS/HTML/XML for example, not that those are programming languages.
[Just so everyone knows](http://www.python.org/dev/peps/pep-0008/)
Why do people insist on sticking to the 80-char limit? &gt; There are still many devices around that are limited to 80 character lines Apart from my phone I haven't seen one in years. My 1920x1200 screen can handle 240 easily, and with dual monitors, the two-window argument doesn't hold either. Get with the times people.
It's generally better for readability. It's easier to process only 80 characters per line. There's a ton of studies that I'm too damn lazy to look up that show this.
I concur with this. Readability studies appear to float around 40 characters being a good length -- but those studies were for English, not code. I've seen too much code made notably more difficult to decipher because the author was taking 80 characters as an edict not to be questioned. I prefer treating 80 characters only as guideline; if it makes a line harder to read, I'll happily ignore it. I'm not a fan of PEP-8's minimal use of vertical whitespace either, nor how it treats whitespace in assignments. What we really need are readability studies of code. Until then one argument is as good as another.
Part of the argument is also that you should avoid excessive nesting in favor of refactoring.
Somehow I doubt it will ever happen (as I'm not seeing a big push in this area anymore), but I will say that the limits of Python's dbapi came up in a discussion I had with the developer of the PyGreSQL Postgresql driver.
I have huge dual monitors, but I strongly support the 80 line character limit. I have documentation in one window, and an Emacs buffer in the other. With an 80 line limit, I can (and always do) have three files open with vertical splits. It's the most ideal way I've found to code, and I'm very happy that my shop's enforced style guide has 80 line limits. It drives me crazy when I check out other people's code from GitHub and I can't depend on professional line limits.
https://github.com/radiosilence/core Pretty much adheres to PEP 8 because the PHP "standard" of coding style is undefined and took too long to become accepted.
I find that although 80 characters is too low, keeping shit wrapped manually makes it so things are clear especially if you are coding with two column layouts. If your function has a lot of arguments, it is nicer to do: blah = moo( whatever, "some string", oh_hey, )
Oh my fucking god, no. The idea that you should use CamelCase for classes but lower_case_with_underscore for variables and methods is plain retarded. I hate it soo much. And when you do it in otherwise mostly sane languages like Python and Ruby, where the distinction between a class name and some other type of variable is more than a little bit murky sometimes, it really helps to obfuscate your code. 
Mostly, yes. I wouldn't argue about PEP8 producing the "best looking code" (matter of taste), however, after a couple of years of intensive python dev I find it extremely efficient. Any convention will have its share of arbitrary decisions, of course, but PEP8's are sound and unobtrusive (except the line length thing, that I just ignore... because my display isn't a 1980's terminal). One thing (coding) maturity taught me is that my adolescent will to customize everything and set my own conventions was both immature and inefficient (most of the time). If it is easier to get used to using someone else's convention, UI or thought process, I'll gladly embrace it because efficiency is what matters, in the end.
Depends on who you're developing for. If you're developing only for yourself or you know that only people with 1920x1200 dual monitors will be modifying your code, then sure, go with 240 columns. However, if you're developing anything that you plan to release into the wild then you can't really make any assumptions about their setup. Besides, I find that 80 column line code is much easier to scan.
Yes, except for javascript, where I use CamelCase to match the dom methods, jquery, etc.
As a web python developer (django, flask and scripting, no GUI toolkit) I just never felt like I really needed an IDE... Textmate or Vim + ipython never failed me. I can imagine that GUI building would benefit from an integrated IDE, of course, but for the rest, I don't really see the perks. Would you guys bother telling me what I'm missing?
I actually think it makes it really easy to understand code you didn't write. CamelCase = a class; camelCaseWithFirstLetterLowercase = a function (EDIT: This actually isn't right, see pridefulpropensity's comment); lower_case_with_underscores = a variable; UPPER_CASE_WITH_UNDERSCORES = a constant.
I've got a 1920x1200 widescreen monitor and a 1440x900. I rarely even turn on my 1440 screen because I don't need it and the times I do I do so to watch a movie or have an otherwise fullscreen application open while I do some work on my main screen. So having said that I'll go even further and say I never maximize my browser; it's just too big and a complete waste of space. [Here's](http://i.imgur.com/Big0k.jpg) a pic if you're curious, also opened notepad++ to see how I keep that. I used to maximize the window, but there was just way too much whitespace after awhile and I think it looks a lot better framed inside the desktop. Another huge reason that applies to both is have to pan my eyes back and forth, after a certain length it just becomes too long and difficult to read. 
for some reason I have the habit of 2 spaces with JS/CSS/HTML/XML and of course 4 spaces with python
It's like a wall of text, no one wants to fucking read it.
According to PEP-8 you should write_functions_this_way. &gt;mixedCase is allowed only in contexts where that's already the prevailing style (e.g. threading.py), to retain backwards compatibility. 
Crap, you're right. I've been programming in C/C++ too much lately and I'm forgetting my roots.
Netbeans had a link to a beta version for Python like a year ago, but it has been 2 or 3 versions later so I am not sure what happened to it..
Agreed. I didn't buy a 24" monitor so I could write longer lines, I bought it so I can open multiple files next to each other. The point that ultimately gets picked is arbitrary, but 80 cols results in 3 columns of readable code on a vertical 24" monitor (or whatever has 1200px width). 132 columns may be more practical, though, from the point of view that you won't have to do gymnastics to make a genexp fit on one line.
I hate reading code with 2 space indents, especially html and css. The indents look like they were mistakes
I've found that the nice part of a 1920x1200 screen is the ability to have 12 terminal windows open simultaneously, not to have one gigantic window. I have to do much less futzing with window widths if each window is limited to 80 characters, and I get more total information on screen. Also, I do a good portion of my development on laptops with SSH windows open (like now). It sucks to have to manually resize each terminal every time I SSH in. (I suppose there's probably a preference setting somewhere to make them automatically bigger, but the point of this thread is that preferences = bad, defaults = good.)
Google coding standards call for 2-space indents, and after an initial adjustment period, I've found I really like it. Indents add up, and I find I can fit much more on an 80-col line with 2-space indents than with 4-space indents. Plus, Google has this convention where continuation lines are indented 4 spaces (or lined up with the last parentheses), which I found *really* confusing at first but have really grown to love. It works, it makes wrapped lines fairly readable, and it preserves horizontal space.
Traditional C style is also to use\_underscores\_like\_this. C++ varies by vendor, but a lot of them use underscores as well.
Not to start a religious war or anything but if we used tab instead of space everyone would be able to get whatever visual indent depth they want and make them feel good.
lets fight
emacs/vim/eclipse? Which operating system do you want to fight about? :)
I like geany myself.
Have you used IronPython on Windows? That's what I use Edit: Sorry, misunderstood the question
go tabs!
List comprehensions will blow their minds.
[Tabs for indentation; spaces for alignment.](http://www.emacswiki.org/emacs/SmartTabs) :)
Actually yes. Yes I do. But usually is a process with over 500MB of RAM which to tell you the truth it is not a big problem. Hardware is cheap in a way. But I really really would like the same thing in Python. It's easier to teach and to use to make cool stuff.
Actually I am an ex Netbeans user. Awesome tool and better than Eclipse in a ton of ways, the thing that killed that preference for me was the lack of community. I mean, in Eclipse you can find a plugin for about anything, Netbeans not so much.
There is a Mono port am I right?
I'll look into that also. But NINJA-IDE is actually really nice. I like the well written codebase and plugin arquitecture quite a lot. Not flashy but it gets the job done easily for beginners.
You are really missing nothing. The thing is that if you want to build a team out of talented people from different software methodologies (Most of them from a windows platform or borland, which is what is taught in schools here) it is easier for them to catch up on the new opensource python technologies by using an IDE. I want to start building awesome things right away, not configuring a text editor for a couple of days after learning a few basics before actually going to work. If you are already proficient in the tools you mention I suggest you don't change. There's nothing like a well configured Vim. But to tell you the truth, it scares most people away.
NINJA as I was told was actually written with Geany. I tried it and it is awesome, but it still is a text editor. I also though on plugin writing for gedit, but it still missed the point of a full python environment like the javafolk have with eclipse or the netbeans platform.
Also Pygame. It is impresive everything you can do with a couple lines of code. And kids love games. Anything creative in fact that moves. Nintendo is what got me into programming. Also List comprehensions as said before, but only if they are already programmers they'll get what's awesome about them.
I actually started using it for the same reason. I find Eclipse limiting in a way that programming a plugin is close to rocket science, specially with the inherent complexity of Java. Extending in Python is a breeze.
wow, I can't believe how dedicated some people are. To think that 19 different people (probably groups of people, since these are fairly complex packages) took the time to write this and then were generous enough to release it to the community. I can't imagine how much time it must take to maintain all 6 lines of code, though.
Just being an alternative for Eclipse in a friendlier environment seems enough of a difference. It is lacking. Eclipse has been in the market for years. But I believe this project has a future because of Python. It is faster and easier to write something in Python than in Java. Also easier to teach. Would love it if it turned out to be something like xcode for Ubuntu. That would increase Ubuntu's market share easily.
Of Visual Studio? Last I checked (about a year ago), there wasn't. Honestly, that's what's kept me with Windows, or installing a VM on my Ubuntu machine just to be able to use Visual Studio (I use it for Python, PHP, SQL). 
VPython will make their day. It's fun, easy, and let's face it, graphics ROCK!
seeing PIL in action was an eye-opener for me when I was learning since I had a need for batch image processing. Also, I would suggest matplotlib (pylab) if just for it's instant visual gratification and as a tool for report-writing. I am also very impressed with sympy and would think after learning algebra and calculus, they might be impressed with it. It all depends on the student's needs. If they can write a program that makes a tedious/difficult problem (possibly from another class) easy, they will be impressed.
I meant of IronPython. Never ever used Visual Studio. I've heard that it is about the only thing Microsoft has got right. The thing is again the opensource part. I don't mind paying for software but in this case it doesn't cover the requirements I have. Still there is a lot of good comments about it and will try it on a VM on my machine. I am sure a ton of good ideas can come from there.
Ah, IronPython, I believe so. I only use IronPython for the IDE portion. I have vanilla Python installed, with a hotkey within VS setup to send the current file to that interpreter for debugging, etc. It will redirect that output into a window within the editor. I believe IronPython installs the VS Shell Edition, which is free. But yeah, it's a great IDE, it can give you some ideas. I've tried switching to Eclipse and Netbeans, etc, but I always come back to VS, because it just _feels_ right, for some reason, I've never really been able to pinpoint why.
80 chars isn't a problem at all if you stick to terse names, few args, and minimal indentation. Unfortunately, I prefer descriptive names. So sometimes 80 chars is a PITA. The fact that some people prefer a length ideal for their monitors doesn't deter me from writing a 100 char line. It's like allowing the IDE to drive the programming language. EDIT: fixed nonsensical grammar
Just curious: what about refactoring in Python (in particular), shines?
That is a really bad excuse for it these days. It would be better to have 3 monitors for each file then to muck up the code.
Consider that in python a function really is just like a variable.
thank christ. tabs &gt; spaces any day.
I have currently come to recognize the unbelievable ease of multiprocessing with Pools in the multiprocessing module. I'm going to have an article up about them tomorrow but I must go to sleep now... I remember writing C++ code to do message passing based parallelism between process and thinking about how easy and powerful it was. To think of the hundreds of lines of code I could have replaced with: pool = Pool() pool.imap_unordered(blah,stuffToProcess) No link for the article yet (as it isn't up) but if anyone is interested it will be accessible from www.ragingsloth.com It will cover creating a pool (not exactly tough) and the different ways of sending tasks to them (apply apply_async map map_async imap and imap_unordered)
What seems crazy to me is that so many have the *exact same* description, capitalization and punctuation and everything. It almost seems like someone did this as a joke or something.