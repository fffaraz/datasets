Where are you now?
yes it is stupid. I would venture to guess that it is because pip is not part of the std lib (this might change in 3.4 though) so yeah, when I learned that venv was a part of python 3 i was excited to try it out, and disappointed that it doesn't really do anything for you if you cant install packages in it. 
Those graphs are nice, but not what I would call 'publication quality' - graphs on paper require very different styling than those on a computer screen. A gray background with a white grid is nice on a screen, but horrible on paper. Also, you would typically want graphs to look good both in black and white and in color. But maybe seaborn has modules to do this? I haven't checked in detail.
Explain how you set it up
I'm not sure I completely follow but this sounds like normal behavior. In the Python interactive interpreter any complete statement (ex: a = 5) will not be a continuation. Most interpreter implementations will allow you to go back and change a previous statement with the up arrow key. Here's some brief examples of what I mean by "continuation" &gt;&gt;&gt; a = 1 &gt;&gt;&gt; a 1 &gt;&gt;&gt; a = \ ... 2 &gt;&gt;&gt; a 2 &gt;&gt;&gt; if a == 2: ... print True ... True Also, the interpreter is typically used for small bit of code instead of entire scripts. It will probably be easier for you to place your code in a python file then execute it on the command line (ex. "python foobar.py") PS: this kind of question is normally better suited for /r/learnpython
There's several other mistakes on the page too...pypix.com site seems to come up a lot lately often with inaccurate or overstated information....
I interpreted the Python 2.8 as "bring as many features as possible from Python 3, but let the same code run on Python 2.7 or 2.6". So `yield from` would be reserved for Python 3.
I haven't seen this one yet, more homework for myself https://pythonmonk.com/
It depends on how your system is set up. If the command "python" is associated with Python 3 then it should do it automatically. But on many systems, "python" still refers to 2.7 while something like "python3" refers to Python 3. If that's the case, edit /Packages/SublimeREPL/config/Python/Main.sublime-menu and replace all the cmd fields that reference "python" to use "python3" (or whatever your Python 3 executable is mapped to in terminal/command prompt). There might be an easier way to do this that I don't know of, but this works fine for me on a couple of my systems. You can also remap "python" to point to the Python 3 executable instead of Python 2.7, but you might not want to depending on your system. I've never found an issue with it on OSX, but some Linux distributions use Python 2 code.
Is that what I said? I thought I was responding to the name-calling and derision and the blatant mind-reading. Furthermore, Guido *supports* people using Python 2 and realises that the transition is difficult for many. Heck, add "straw-men" to that list.
I've been using miguel grinberg's and a couple other tutorials to try and make a very simple portfolio page for myself. Wanted to try out FlaskWTF and MySQLAlchemy so dabbling with those currently. Just a simple login page. (Hoping to get to bootstrap after that, and then deploy to heroku or OpenShift.
No. But entering code directly into the interpreter like this is quite difficult, partly because of reasons like this. I recommend that you get and editor (Sublime Text is fine) and use that to create a file. Then run the file from the command line. Alternatively, download Pycharm for the full IDE experience.
My impression is that it's relatively easy to "learn" Python 3 and then go use something in Python 2 when you have to. Most of the differences are things that *work* in Python 2 but don't in Py3 (like `range` being an iterator vs. list). So learning Python 3 you should be fine.
thanks. I figured out that I have to open Python shell and then click file and open a new file and then I get a completely blank file similar to a txt file and then I can hit "enter" and not get a new "&gt;&gt;&gt;" line... not sure why I have to do this. I think I will do txt files and save them as .py files from now on. 
ggplot works on Python 3. Current version on PyPI is broken for both Py2 and Py3, but ggplot master totally works and it's clear they have it in mind.
If you start with Python 3, there will be little that you end up doing that *wouldn't* work with Python 2. Whereas there are a number of things that you do in Python 2 (use print as a statement, exception syntax, etc) that you *can't* do in Python 3. If you're learning now, I'd suggest you use Python 3 to start, because you'll still be absolutely fine to use 2.7.
Bootstrap shouldn't give you much pain. No experience with Heroku deployment (I use github.io or DO), but one fun project I found was this: https://nicolas.perriault.net/code/2012/dead-easy-yet-powerful-static-website-generator-with-flask/ Give it a read. It'd be a great way to make a neat little blog and/or portfolio without going too database-crazy. Best way to learn with these things is to do. Don't feel like you're asking the wrong questions.
Ah you know what? I've been running into Flask-FlatPages all over the place. Frozen seems a cool tool as well, I'll go thru this tutorial. You're right though, I don't need to meddle with databases or login pages at all for a simple portfolio page, but we've been doing hibernate/liquibase java stuff at the office, and I was curious about how we can handle db migrations in py (turns out its a lot less manual work with SQLAlchemy). Been using the [SQLLite Firefox plugin](https://addons.mozilla.org/en-US/firefox/addon/sqlite-manager/) to look at the .db files generated, not too bad. I've seen nice stuff hosted in github.io too, I guess there's a lot of alternative to cloud website deployment now days. Havne't heard of DO though? 
What do you mean by being able to handle large projects? Do you mean having a lot of developers contributing to the same code at the same time? Do you mean having a lot of simultaneous http client connecting to your web app? Do you mean having a lot of database/storage requests at the same time? Do you mean if it can work across multiple physical servers for the same application? Do you mean having a large project like facebook, twitter or youtube? Even if the answer is yes to all those questions, Flask and Pyramid could be some good solution or framework for your application. Pyramid and Flask are quite close in term of scope. Pyramid has a little more batteries included and some stronger suggestions about what you should or might be doing but you can also get many of those batteries or suggestions with Flash by looking at the [snippets](http://flask.pocoo.org/snippets/) or the [extensions](http://flask.pocoo.org/extensions/). Both of these framework are kind of lightweight. You are most likely going to include external packages, libraries, modules or use third party providers in order to do what you want. You still need to know what you are doing and know what is available around. For instance, they do not include an easy way to send email. You might need to use something like [marrow.mailer](https://pypi.python.org/pypi/marrow.mailer) or the Python built-in email module (if you are a masochist). Flask has an interesting but short page about becoming [**big**](http://flask.pocoo.org/docs/becomingbig/). I think you can go big with both of these frameworks. I have a slight preference for Flask because it does not impose too many choices on me and I can build/test/debug things it does not have quite fast and easily like if I need a permanent cache or an authentication mechanism. I know most of the pitfalls and when I don't, I just use a library/package/module somewhere or I get *inspired* by them to create something similar.
Both are suitable for what you want. I tend to go with Flask for everything, since mostly I'm creating API's that are consumed by webapps. Even when I need templating or other server-side stuff, it's simple enough and doesn't require too much boilerplate. Pyramid comes with more stuff out of the box, but Flask has enough extensions that you can essentially drop in whatever you need. For me less is more, since I usually find the built-in bells and whistles to just get in the way.
https://caremad.io/blog/setup-vs-requirement/ is the correct URL
Thanks. I really wanted to read that.
&gt; I can only attest to pyramid being able to scale from the small to the huge How did that go? Was it a good experience? Would you recommend Pyramid? Flask seems to be 'lighter' than Pyramid, which I like, however Pyramid makes me feel more warm and fuzzy when it comes to support and longevity.
&gt;What do you mean by being able to handle large projects? Sorry, I should have been more clear about what I was talking about. I meant more of large DB, many simultaneous HTTP request, etc... nothing as large as FB/Twitter though AFAIK. I like the lightweight thing going on with Flask. I like that I can include whatever extensions I need (or roll my own if necessary). I love the fact that it "gets out of my way" unlike stacks like Django. &gt;Flask has an interesting but short page about becoming big[4] . Yeah, I read that, and tons of all the other docs. The problem I've run into though, is that they are kind of short and not really informative beyond the obvious. For example, the tutorials, are all centered around writing one page apps. They don't really go into how all the parts actually fit together. I had to go to https://github.com/mitsuhiko/flask/tree/website to truly begin understanding what was going on with the pieces and parts. TBH, I am just trying to make sure that if I go with Flask I'm not going to be in a bind later down the road if/when it becomes time to expand.
When I try to import ggplot, I get this: In [2]: import ggplot as gg --------------------------------------------------------------------------- ImportError Traceback (most recent call last) &lt;ipython-input-2-4dc624ad9214&gt; in &lt;module&gt;() ----&gt; 1 import ggplot as gg /Users/anton/anaconda/envs/py3k/lib/python3.3/site-packages/ggplot/__init__.py in &lt;module&gt;() 18 19 from .ggplot import * ---&gt; 20 from components import aes 21 from .geoms import * 22 from .scales import * ImportError: No module named 'components'
NO GOD NO STOP RECOMMENDING DISTRIBUTE [USE SETUPTOOLS, PLEASE](http://pythonhosted.org/setuptools/merge.html) [It's right here.](https://bitbucket.org/pypa/setuptools/raw/bootstrap/ez_setup.py)
IMHO Flask will be better for serving an API (which you then might build a client app off of) whereas Pyramid will be much better for a more traditional web app (not that it can't do a rest api well either).
It's because `venv` is the barebones machinery. It's not supposed to be a complete replacement for virtualenv; in fact afaik virtualenv uses the new `venv` machinery under the hood when run on python &gt;=3.3. If you wish for the niceties, just continue using virtualenv as usual.
hmm... it worked fine for me with python3, but I was using master (since, as I said, PyPI version is broken). Maybe try downloading from GitHub?
I've got Windows 7 Home Premium, and I downloaded the 64 bit version of the PyScripter, through the website: www.python.org. When I open the downloaded folder, there are about eight different versions of PyScripter, ranging from Python 2.4 to 3.3. However when I try opening any one of them the same message pops up: "Python could not be properly initialized. We must quit."
&gt; How did that go? Was it a good experience? Would you recommend Pyramid? it went splendidly. the app in question was very complicated as far as row level permissions goes and pyramids traversal mechanism made it very easy to do. it was also awesome to just be able to tweak the security policy for custom requirements when that need came up to support mobile later on. if the future project has complicated needs around permissions (user can read this doc, and update this other doc, only this user can admin other users, or only this user can update this doc after this date, but not if an admin has already rated it...) I can't see how anything BUT pyramid or zope could handle that without the devs losing their minds. if the app is not going to be that complicated, anything would work. 
Exactly! Making 3 non-backwards compatible was a really, REALLY stupid move.
Because a language that introduces code rot as a feature makes people worry about the sanity of staying with that language. What will Guido suddenly decide the world doesn't need NEXT, for no good reason? The good things introduced in 3 don't make up for the stupidity of introducing that rot.
Yep you were right, I just needed to grab it from github directly
Where "the right thing" is any silly idea dictated by the Bondage Dictator For Life. (But I agree about the main idiom.)
&gt;All you're managing to do is convince me that Python was the wrong choice. That is a matter of opinion, not a course of action. What are you going to do about it, rewrite in a language other than Python 3? That would be even *more* work, and you'd probably have to retrain all your developers. The entire company would be largely nonproductive for six months or so.
Closed, of course
If it really were just Guido's opinion, we'd be using tabs. I don't know of any proposals that Guido accepted without majority support from Python's core devs, so I don't know what your complaint is.
&gt; invoke I hadnt seen it before. Do you use it over Fabric? What features do you like? Honestly, my initial perusal of their website makes it look like a Fabric where the `run` command is local rather than remote. I'm don't see any other valuable features. It doesn't look like you can define file dependencies that only update when a file changes (a la Rake/Make), rules that can apply to all files of a filetype, etc etc.
having just come off a django project, I disagree with authority.
What went wrong?
This is insanity and madness. Madness and insanity. Then some madness. Then some insanity. This is not how development works. "Why are porting?" "Because there's a new version out." End of story. Period. It's a duty of a developer. If you don't have time to refactor your code, you don't have time to create the code in the first place. If you leave code alone it eventually becomes incompatible with something (OS, libraries, whatever) and dies. There's a term for it: bitrot. You have to maintain code to avoid bitrot. Otherwise you incur another term called technical debt. http://en.wikipedia.org/wiki/Technical_debt It's like documentation: it's not about what you gain if you write it. What you lose if you don't is justification enough. Sooner or later you HAVE to port your code. Or freeze it forever on a certain version of python (not a good idea if the code is to have much active development). The longer you wait, the more work there will be - the two codebases aren't going to converge over time. The more lines of 2.x code you write, the bigger your job will be. Thus, like a debt with a huge interest payment, the sooner you pay it the better. Python3 doesn't need to kiss anyone's a$$ and give the flying ponies that shoot rainbows to entice people to port to it. It paid Python 2.x's technical debt and fixed the language. Now, you port to it. Period. I've never seen another language hand so much to users on a silver platter: from the multi-year support window to backports to 2to3, etc. And a large portion of the community were like Pyjamas' original lead developer: "Why should I port my code when Python 2 will be supported FOREVER?" Now that the cutoff date is starting to loom, people who have squandered all the benevolence of the BDFL are screaming about not having had enough time to do something they never started, demanding more features first (which they will no doubt want backported next) and even threatening Python with a fork! No more kissing asses. Guido needs to embrace the D in BDFL, channel his inner Linus Torvalds, and open up the Dutch equivalent of whoop-ass! Python has had too much Zen. As Joe Biden explained to Paul Ryan during their debate about setting a firm withdrawal date for Afghanistan, if you don't people will think you're staying forever and never step up. Guido needs a firm date, a steely resolve and a big stick. We've already discussed Python 3.0 - years before it was released. The community has already proposed and accepted the PEP banning any more versions of 2.x. Guido's time machine lets him see your future needs - he's not going to modify it to go backwards to undue all that's been accomplished in the past five years. Instead of pestering him for a 2.8 (a debate that's already over, and lost) the 3.0 Denialists, Refuseniks and Procrastinators need to talk amongst themselves about which of their three options they're going to choose - freeze project, port project, learn a new language and completely rewrite existing code in it. One of those is not like the others, leaving two realistic options - the same two they were given five years ago. It's way past time to choose one.
I prefer Flask to be honest (more a matter of how the code looks, than functionality), that said I haven't gotten much into Pyramid. Flask for medium/semi large projects and bottle for tiny projects if you ask me - I don't really like Django.
Brilliant argument in a nutshell - which always takes me a few paragraphs to say. ;-) You've got to port some time or freeze the code, and the longer you wait the higher the cost. 
I hope you see that relying on a library that hasn't seen an update since 2007 is a bad idea regardless of the 2/3 issue. Bitrot will set in eventually. That's compelling enough. 
&gt; Here's how I'd sell it: ... before one of our key libraries drops Python 2.7 support. &gt;I don't think this is a good idea. You think waiting until something breaks is a good idea? &gt;Ruby, Java, Perl, PHP, C++ and JavaScript have all somehow managed to &gt;introduce new features without telling everyone to rewrite everything in the "new &gt;version". Python3 didn't break compatability to introduce new features. It broke compatibility to fix existing ones. Java deprecates but never removes anything and thus it's a gigantically verbose morass with a diagram in its documentation to help users choose which of five different means of opening a file is the right one of any specific occasion. PHP is language design by random number generator and there is a subreddit here devoted entirely to laughing at the bizarre inconsistencies in the language (as well as several classic damning essays). C++ has grown so complex that there are books devoted to discussing "the good parts" and talk of companies requiring developers to only develop in subsets of the language. This is the price you pay if you never pay your technical debt. Python is the opposite of those giant, verbose languages. There's a reason people claim Python needs 1/10 the code of Java. Adopting their policies means gaining their drawbacks as well as their benefits, and I don't think anyone wants to turn Python into bloated, stagnant Java. &gt;All you're managing to do is convince me that Python was the wrong choice. &gt; I mean seriously, No, you're not serious. Or you're very, very young. Just about everything breaks compatibility sometime. Otherwise you'd still be using DOS or AOL or cassette tapes. When you say "HOW DARE ANYTHING IN PYTHON EVER CHANGE EVER?!?!" you may be serious, but I can't take it seriously. Hell, you can't even be guaranteed code written for C++ compiler A will compile on C++ compiler B, yet you're marshalling outrage that Python fixed a broken Unicode implementation five years ago? Really? &gt;they didn't threaten me with code rot; they didn't suggest things that were working &gt;just fine are suddenly going to stop working because of something someone else &gt;is doing. If PHP is telling you things are working just fine... well, there's your problem right there. :-) You do know that Perl and PHP are both working on new versions of their languages for several years now, right? And that they consider them parallel tracks just like Python 3 was to Python 2 and will supplement rather than directly replace the old versions, right? And that in some cases they're even suggesting these changes are so significant they should really be considered a whole new language? And the reason these other languages haven't threatened you with these things is simply that they're so incompetent in design and hard up for good developers that they're many years behind schedule? &gt;FFS, Programs written for Windows over twenty years ago still run today. And many don't. &gt;It seems to me that having the open discussion about how Python can fix this &gt; would be much more productive than trying to argue with my boss who doesn't &gt;seem to like Python that much to begin with. It wouldn't be more productive for the Python community, which debated the need for 3.0 in 2006 and the path to migration and proposed and approved a PEP ending 2.x backporting quite some time ago. We've had those debates already. They're over, and no one's getting the keys to Guido's time machine to go back and change them. &gt; Maybe 2to3 can get good enough we can make it automatic and just have our &gt;python2 and python3 coexist transparently. Maybe something similar for the C- &gt;library interface. Maybe we backport python3 features to python2 and just pretend &gt;python3 never happened. Maybe lazy developers get off their ass after five years and start porting some code? &gt;I mean, I get refactoring projects for the point of rethinking algorithms; restating &gt;program logic using knowledge and learnings of the running system, but I don't feel &gt;comfortable telling my boss we need to rewrite lots of code that we didn't even &gt;write, keeping the same algorithm and the same logic, just because python3 isn't &gt;compatible with python2. Everything changes. Even your precious Windows has already announced that all new development of features will occur in the WinRT library, not Win32, and the classic desktop has been reduced to a WinRT application. This should have been explained to your boss 5 years ago - or 7, since we knew 3.0 was coming since at least 2006. If you've not explained this fact to your boss yet, that's a major source of the problem. This is something one should have been planning for, just as IT departments have been planning to migrate from XP for quite some time now if they haven't already. Waiting until a year before D-Day then requesting Microsoft continue to support XP despite the 10+ years already given is not a good idea.
It fixed things. Making Python 3 backwards compatible with the flaws of Python 2 obviates the purpose of Python 3 in the first place. 
&gt;Which leads to the conclusion not to invest any more time/effort on Python. Oddly enough it didn't lead to the decision to not invest any more time/effort on Python 2.x, did it? This is a fantasy scenario for 3.x Denialists that simply doesn't exist. Delphi is going through the same nonsense except the users have no control and not much warning but they're protesting before the changes, not after. It's quite a laugh - if you give me immutable strings and memory management I'll take all my code to - to - oh yeah, some other language with immutable strings and memory management that will take a lot more time to rewrite my code to than it would to port my existing code. 
No. Ignore old tutorials. Don't use ancient libraries. Don't use crappy old IDEs that don't support the current version of the language. Don't uninstall Firefox and switch to Netscape. Don't format your hard drive for FAT32. Only Guido gets to travel through time; don't go back to the past. I'm a new Python user and I've had no problems. Dive into Python ***3*** and Head First Python, Eric5 IDE, and I choose not to use any module that chooses to harm the future of the language by not having upgraded to the latest version of Python. And I've found things so incredibly awesome that you couldn't pay me to go back to the old language I was using. Pandas, SQLAlchemy, NumPy, SciPy, IPython - Python should be a paradise for research related data analysis. 
That's only if you're using ancient tutorials. We have plenty of fine books like Dive Into Python 3 and Head First Python. I learned Python with Python 3 and it wasn't bad at all. Eric5 IDE and IPython... all working fine with Python3. Python3 included (but not default) out of the box on my Linux distro. Really everything I need working on Python3 already. It's not bad at all. 
Which website are you crawling and why if I may ask? Every attempt to cut down on the amount of requests should be made if possible.
PyScripter is just an IDE, I think you still need an interpreter (could be wrong though). Try [these instructions](http://www.ics.uci.edu/~pattis/common/handouts/pythoneclipsejava/python.html)
People are lazy and work-adverse, and are especially embarrassed by being found caught out at their own shoddy work - so if it becomes easier to hide that than man up and fix it, they'll hide. This is what has occurred. Python 3 was [intentionally backwards incompatible](http://docs.python.org/3.0/whatsnew/3.0.html) hence work is required to port existing code. The unicode changes were especially damaging, as popular libraries were caught out at blindly assuming everyone speaks english so encoding/decoding bytes at the network layer was not done - and fixing these issues becomes non-trivial the poorer their code was. Also, early versions of Python 3 had lower performance than 2.7 especially due to the need to handle str == unicode; so people who cared that their code ran 0.0004 milliseconds slower railed against Py3 (even if this slowdown was irrelevant in their application - its a perception thing slower == bad) Now we're at the point where all their previous excuses don't account for much anymore (e.g. library support) they're now finding new ways of whining about Python 3 (it's backwards incompatible! How dare they make a backwards incompatible major version change and tell us about it 7 years ago! I haven't found any time during those 7 years to whinge about this also!) In short, ignore this vocal minority &amp; enjoy Python 3. 
Since Python can coexist with multiple versions of itself, you've got a number of paths forward: * [Anaconda](http://continuum.io) (or [miniconda](http://repo.continuum.io/miniconda/)) * [Canopy](http://www.enthought.com) * [RHSCL](https://access.redhat.com/site/solutions/472793) * [ActivePython](http:///www.activestate.com/activepython) - currently 3.2 only :( * [build it yourself](http://www.python.org) Core RHEL will remain 6+ years behind the times, the reason they came out with RHSCL is to try to stem the flow of users onto actually supported Linux distributions like Ubuntu which have current software. If you're stuck in this situation, follow even Redhat's current example and avoid the core system toolchain with one of the options above. 
What's the point? Python 3 is [intentionally backwards incompatible](http://docs.python.org/3.0/whatsnew/3.0.html). Even if such a layer was created, the same lazy people would **NOT** port their code to Python 3 but instead just tell people to use Python 2^0.5 forever. There would be substantial development resources dedicated to this compatibility layer rather than focussed on Python 4 and beyond, crippling Python for the sake of this small band of lazy devs who are in this boat by ignoring the advice and also writing shoddy code to begin with. 
http://en.wikipedia.org/wiki/Comparison_of_open-source_configuration_management_software Scons is great. You might take a look at Baker, docopt, and clint on pypi. http://paver.github.io/paver/pavement.html tasks work similarly. "python cli docstrings pypi decorator"
&gt; What are you going to do about it, rewrite in a language other than Python 3? That would be even more work, and you'd probably have to retrain all your developers. The entire company would be largely nonproductive for six months or so. I am *not* proposing we rewrite our python code in another language, but *you are*: Python3 *is* a different language than Python2. What I *am* proposing is that we at least try to figure out how to make them the same language before we resort to selling the rewrite to our bosses. We might have to do that, but I'd rather try everything else first.
i hope the fuck you are trolling. 
Those "flaws" are embraced by the majority, whereas the "fix" is being ignored. Before release, fix all the flaws you want. After release, they're features. 
How do you add a feature to 2.8 so that code using that feature still works on 2.7? You couldn't add anything.
python 2 has first class unicode objects.
&gt; TBH, I am just trying to make sure that if I go with Flask I'm not going to be in a bind later down the road if/when it becomes time to expand. You are not going to be.
Reddit is built on Pyramid, you can download the source from github if you want. 
- imports are missing: `localStorage` in DataModel and `weba` in ViewModel. - `DataModel` repeats `webtodomvcdata` - should be moved to a variable to by DRY - imports should be at the top of the file - look at [all the logic stuck in HTML](https://github.com/skariel/webalchemy/blob/master/webalchemy/examples/todomvc/todomvc.html#L14) - are [these javascript classes](https://github.com/skariel/webalchemy/blob/master/webalchemy/examples/todomvc/todomvc.html#L300) manually or automatically generated? If they are manually generated, then you should look at the technology behind [muntjac](http://www.muntiacus.org/) which is much simpler and truly pure python 
Or just use IFTTT.
&gt; The PYPL PopularitY of Programming Language Index is created by analyzing how often language tutorials are searched on Google : the more a specific language tutorial is searched, the more popular the language is assumed to be. Holy shit that sounds like a rubbish metric.
Why? 
out of the 2 you list, gunicorn is the only one that is a wsgi server and thus can serve/run a python app. vagrant is a tool for managing virtualbox images, it has nothing at all to do with python.
What do you propose instead? 
&gt; Python is the Language of the Year, according to some random guy from the internet who takes the trends for "$language tutorial", disregards foreign languages, discards possible name collisions, limits the results to the top ten, and even then picks second place because it made the most improvement in one year. FTFY
When I went to college my first time (for programming) it was for VBasic and C. Things can change. VBasic is dead.
I know, just wishful thinking.
I'd wager in the next 5 years ObjC might start coming close. That all depends, it's a relatively new language - but in the past 3 years it's gained a huge share.
They can change, but it will take time I think. Then again I'm no expert on language trends. 
It's from 1983 making it *older* than most languages in that list. Apple gave it a new lease on life. See: http://en.m.wikipedia.org/wiki/Objective-C
It means people are learning Python and need help with it more frequently than they are other languages. As with all statistics the precise meaning is open for interpretation. It could mean Python is harder to learn than lower ranking languages and easier than higher ranking ones. Without a few more data points it's hard to draw solid connections but I would be confident this indicates significant increase in use. I would not trust comparisons between languages based on solely these numbers. 
I don't think we can draw meaning from it at all. Could just be more projects, etc. 
Its just my opinion but from my prespective java is slow at changing. Still no lambda expressions (coming march 2014) modules coming on jdk9, date api sucks (being replaced in jdk8 if im right) gui framework sucks(being replaced too). Its been slow to change. Thats why clojure scala groovy etc exist. The jvm is good, performance is fine, ecosystem is fine but the language needs improvements in many different ways. Like the theory of evolution says its not the strongest or smartest who survives but the one who keeps changing. Now all languages have prons and cons and i believe all of them have a usage. The purpose is not to start another language war, that's just what i think about java. 
I was talking with some of my college professors and they asked me about changing our intro class from Java to Python. So it is definitely starting to change (I actually voted against that change, but that's sort of a long story)
I'm mostly not convinced that it's a sufficiently accurate metric of popularity at all. Using this indicator suggests an assumption that for each language a similar relative amount of people actually ends up *doing* something with it.
I don't know how much it's driving popularity, but scientific computing support is just awesome in Python. I've found Python and its scientific package ecosystem to be a magnitude better than any other language/ecosystem.
Hey thanks for the response! If you don't mind my asking, what packages/libraries in particular? 
We chose Pyramid over Flask...and Django. Django - We use Django for standard websites. For pure CRUD with little customization Django is a nice convenience. Once a more customized experience creeps in, it begins to become irritating. Url's and redundant file structure are pains from a project level construct. Many items do not fit in an app and you are left juggling a nomenclature that is forced around a construct that may or may not make any sense once the project has matured. The Django admin can be nice on one hand and a pain on another. Quick changes to a model while developing and you need to go update the admin, etc... Just another thing to have to keep tabs on. Then there is the need for managers within the ORM as well as the separation of InclusionTags from their use within say the global template library. Things can get strewn across the project relatively easy and it is somewhat clumsy in the ability for you to force your own structure on top of it. Flask - We looked at it for its strength supporting a JSON api structured project. While it is light and wasy to get going we found a few issues that we had dealt with in Django. The main one was the idea of Blueprints. We felt that it to be a big "App" like within the Django environment. Not nearly is prescriptive but a structural norm which may or may not make sense in our project construct. That being said we had a nice time getting a Flask instance up dancing with MongoDB in no time flat. There seems to be more batteries with Flask than with Pyramid from my inspections. They are not tightly coupled but are norms within the community and could easily be considered coupled, such as the Flask admin, Flask mongoengine, Flask version of anything Django does, etc. Flask seemed to be what Django could be if it were liberated of all the constructs that make Django "accessible" which actually end up confusing things. Flask gets out of your way, but its community and its ecosystem can easily get you there with tools made to plugin right in to Flask. Pyramid - We love Pyramid. To us, Pyramid is Python. Almost every convention or issue we have had to learn, consume, rationalize, wrap our heads around has resulted in us realizing it is done just the way you would do it in Python. No tricks. No special cases. Pure openness to the rules that already exist. And while the community is smaller in numbers on Reddit and SO, I have found them to be very responsive on IRC. Actually, I have had more questions answered in a constructive, helpful and timely fashion with the Pyramid community than any other. It was part of the reason we were able to get up to speed so fast. With Django things would be helpful but not specific to what one may be doing. i.e. you may be resolving problems that have crept up in many difference ways so as the answer may have been answered but not in a directly logical way from the condition in which one may be experiencing it. With Pyramid it is not so esoteric. Want a module, plug it in. Want nested modules within a view package. go ahead. Want to attach a whole new package with self contained routes, go ahead. Want a single reusable template library that can fetch data without needing to render to its own separate template (inclusion tags django?), go right ahead. Most of what makes Pyramid nice to us is that it has taken care of what is many of the headaches and stepped away from the places where individual need might determine a unique use case. Everything is easily extended as well as battle tested. If you want some hand-holding or some weight lifting you can use scaffolds. But they by no means define a structure that is imperative to the function of the overall project...just help connect some boiler plate. Rearrange as needed. It deals with routes somewhere between Flask and Django. It pushes no template language, no ORM, no session store, etc. But can plug them in easily in a standard method that Python libraries plugin. The really only Pyramid specific concern is the Config object...but that is a positive from my perspective. We are using Pyramid to spew to templates (mako) , return JSON (from apis and mongo), sqlalchemy and pymongo(who needs a mongo orm?), some nice template tools with webhelpers for the web served side. Lots of access to tools that are not easy to integrate into a Django project. We could do all the same with Flask and considered the possibility heavily. --- I am sure one could do a project in either Flask or Pyramid and have very similar results using basically the same tools. It is merely a choice of what one is comfortable with. Best of Luck!!! *edit - spelling
i move from java to py for many reasons. This are the basic ones 1) I used to code java on my free time. when i started python i found out that i could do things much faster. and after work you may have 3 hours to code. you want to get things done as fast as possible. 2) lambda expressions, first class functions,decorators, list comprehensions, cleaner code, generators, more freedom(e.g. can overload operators) 3) In general Standard library is better. take for example itertools 4) Lot of nice libraries that allow you to do your job in much less code e.g. a) flask,bottle can have a web app in 4 LOC no xml config or whatever. b) requests i can just send an http request in 1 line in the interpeter and it saves me time. text-blob, scikit-learn etc.. 5) Culture 
I can pretty much guarantee that the scipy stack will be the main one.
Isn't Celery a little overkill?
&gt; At the end of the day, it is a balance I totally agree. I believe all languages are useful if they didn't keep backwards compatibility they wouldn't be so popular. I am aware of joda time is the same principle with groovy i think. If there's a feature that people really want and can't get they will just do it. In general i agree 100% with what you said. All languages have good and bad things you choose depending on what you prefer. The only problem is when you don't actually choose (e.g. go to uni learn java because that's what they teach do it for money without having an opinion, in general don't care about programming just do it) 
Ooh ooh! Storytime! 
Yes, but that seems like a reasonable assumption.
Yes i don't disagree. Java will easily get you a job. But a good programmer will also learn other languages. Say i go to school they teach me christianism. Well the principles of christianism if i follow they would make me a better person. But studying buddhism gave me a different perception and would still make me a better person.
OK so this is the python sub so I feel that I do need to preface this with I really do like python a lot. That said there are a few flaws with teaching it as a first language and especially as a first language at my school. In general : Python protects you from a lot. Too much, in my opinion, for someone just learning programming when they will go on to more languages. For example, dynamic variable types. It protects the programmer from making a conscious decision about what the variable needs to be. That means the programmer doesn't see a difference between a char and a string or an int and a double. These are important distinctions to be made later on if you learn python first. There are a few other issues with python as a first language but I'll leave those out. The main issue is that it complicates later languages because it is so easy. So it's great for people who won't learn another language but not so much for those who will. Which leads into the problem for my school particularly. We have three main intro classes - intro to programming ( java) - object oriented programming (java) - data structures (C++) The issue with the third class is that a good chunk of the class is dedicated to teaching C++ rather than data structures. Now the issue with changing the first class is the administration isn't willing to change the second class to python as well, so that means in three subsequent classes, the student loans three fairly distinctive languages. And as I pointed out about the third class, learning a new language is one of the most time consuming parts, so it makes sense to stay at least fairly consistent in the languages. Java is enough like C++ (I agree completely that data structures should be in C++) that that transition is not that complicated, but python differs fairly significantly from C++. 
I would say sysadmin and operations work is also driving its popularity. 
Not necessarily; I was taught python as a first language at university - during which time I had to google for a lot of tutorials! I've hardly ever used it since. 
I'd say it's a better metric for future growth than extrapolating from TIOBE Index data. But it's a piss-poor metric for overall popularity.
Did you take any statistics courses while you were there?
On the flip side making people learn Java first increases the number of people who just "don't get" writing code and aren't interested in the meager pay-offs for their time.
No, it's one reasonable metric. The problem is that you need multiple metrics to evaluate most things. Imagine choosing a car based on just a single metric. Doesn't work. But, this is a reasonable one to include.
Python is the most liberal language I have met. When you say language-lawyers, I can think of Java for instance. IMO Python is evolving in the right direction.
Git is an SCM, basically you can use it to version control your software. I'm really bad at explaining, so hopefully this is useful for you http://git-scm.com/book
&gt;What I am proposing is that we at least try to figure out how to make them the same language before we resort to selling the rewrite to our bosses. We might have to do that, but I'd rather try everything else first. I agree, actually, but PSF doesn't seem to be on-board yet.
to be fair some times its a positive thing, because people abuse freedom. It doesn't allow multiple inheritance either. But i'm preety sure if those features were allowed some people would misuse them. I personaly consider python a "more free" language. Not saying is positive or negative. It's preference
I prefer to work on a Mac, but my day job had me working with C# in Visual Studio and I *loved* it. You're unlikely to find an IDE for Python that is better than VS. For this reason, you should consider [IronPython](http://ironpython.net/) and [Python tools for Visual Studio](http://pytools.codeplex.com/). Going this route will let you leverage your knowledge of VS and C#'s libraries and make it easier to integrate Python code in your projects. Should you ever need to make your projects cross-platform [the Mono project](http://www.mono-project.com/Main_Page) will let you develop and execute on Linux and Mac machines. So far, I've only sold you on VS and the CLR (technology behind C#) and not on Python. If productivity is crucial, Python is for you. For one, the syntax is easier to learn than C. So if you learned C#, you can learn Python. You don't have to learn *all* of the syntax at once. Learn the basics of defining functions and using builtin types like dict and list. For two, Python has an interactive prompt which is *great* for trying out a snippet of code, getting it to work, then pasting it into your source file. Finally, the Python community is as vast/global as Python's libraries. So it's easy to get help online at nearly any time of day.
My school did the same thing, but they decided to also have the Data Structures I class be Python, and the Data Structures II class remained C++.
It's semesters. "Object oriented programming" is learning about the design of objects and how they interact. Generic programming, UML, etc. JavaScript would make sense for non majors who are going into web design but most of our non majors are mechanical engineering who want programming before taking control systems (which is why my idea was rejected - there is a C non major course already)
I too am a mechanical engineer, and use python (with some c interspersed) for almost all of my simulation, analysis, and computation. **Good things:** 1.) **Writing Speed**: Writing code in python is super fast, saving you time. There's a library for most everything you could think of doing. If it's not in the standard library, it's only a [pip](http://www.pip-installer.org/en/latest/) away. 2.) **Execution Speed**: Even though it's interpreted, in most cases python is fast enough that you don't care. And if you need it to be faster, you can write code in c, and wrap it in python using a variety of librarys (I prefer [ctypes](http://docs.python.org/2/library/ctypes.html)). Or write it in [cython](http://cython.org/). 3.) **Free**: It's all opensource, so it's free. If you're making things to sell you may need to work around liscensing, but for in company tools this is a plus. 4.) **Science**: You're an engineer, so I assume most of what you're doing is computational. Here's what I (and most people) use: * [Scipy](http://www.scipy.org/) - Scientific computing * [Numpy](http://www.numpy.org/) - Array and Matrix routines. Base for almost all scientific computing in python. Written in C, so it's *fast*. * [Sympy](http://sympy.org/) - Symbolic computation. Need to calculate a complicated integral? Don't use Mathematica/maple, this works just as well. * [Matplotlib](http://matplotlib.org/) - Publication quality plotting library. * [Ipython](http://ipython.org/) - Interpreter on steroids. Great for interactive computation. The [notebook](http://ipython.org/notebook.html) is the killer feature. Mix code, text, and figures all in one file. I use it for data analysis. Pull in the data, run the code to analyze it. Generate plots (inline). And discuss the results. Need to send a report to your boss? [Ipython nbconvert](http://ipython.org/ipython-doc/rel-1.0.0/interactive/nbconvert.html) can format the notebook into a publication quality LaTeX file or html file, among other things. Other libraries with more focussed interest, that you may be interested in: * [Python Control](http://sourceforge.net/projects/python-control/) - If you're doing controls work, this is similiar to Matlabs control package. It's not maintained as much as I'd like, and is missing some things, but overall it's a good library * [Pyqtgraph](http://www.pyqtgraph.org/) - Matplotlib makes pretty plots, and is *the standard* plotting library. But it's slow. Need realtime plots? Use this. I'm pulling in 6000 points a second, and plotting them in realtime, without issue. Great library. * [Pyside](https://pypi.python.org/pypi/PySide) - Coupled with the above, if you need a GUI this is a good library to start with. Bindings to the Qt framework. There's also [pyQt](https://wiki.python.org/moin/PyQt) which is a different set of bindings. If you're more familiar with wxWidgets, [wxPython](http://wxpython.org/) is pretty popular as well. There's not really a best one, it's more preference here on what to use. **Bad things:** 1.) **Packaging**: It's a mess. Writing something on your computer, and trying to get it to work on a different one isn't always the easiest thing to do. [This tutorial](http://www.scotttorborg.com/python-packaging/) is pretty good. 2.) **Versions???**: Python 3 is not backwards compatible with Python 2, breaking lots of things and making many people unhappy. For new things, you're recommended to go with 3, and most (but not all) libraries have been ported. Python 2 isn't going away anytime soon though, so you'd be fine working in that. Just need to make sure everyone is consistent if you're sharing code. 3.) **Multitasking**: The infamous [GIL](http://en.wikipedia.org/wiki/Global_Interpreter_Lock) issue. The python interpretter can only ever do one thing at a time. Even with threads, it's just switching back and forth quickly, not truly multitasking. For most things this doesn't matter. And python makes it super easy to use processes with [Multiprocessing](http://docs.python.org/2/library/multiprocessing.html) that this can be gotten around trivially. **Final Verdict** All in all, python is an excellent language, and I highly recommend it to anyone in an engineering career. While matlab and .NET seem to be the standard for in-house tools these days, there is definitely a shift towards opensource tools. The community is huge and very supportive, and as outlined above there are plenty of scientific tools at your disposal to do virtually anything you'd need to do. The few issues with the language I mentioned above can be worked around, and for the most part don't get in your way. Definitely something worth adding to your toolbox.
Object oriented programming is a general concept, and I think it can be tought well with any language that implements it decently. Hell, you could teach people extremely decent OOP with PHP if you wanted to. I think the best breadth of programming to achieve is to learn the practical experience of programming with both dynamic and static languages. Pick your ideal one from each. It still comes down to preferences, mine would be C and python. C because you can get past learning the syntactical / structural elements of the language much faster than Java / C++. Python is just super clean and practical. Also something to be said for practicing programming with and without memory management. I especially am sad for many Java programmers who wouldn't have the foggiest what to do without a JVM. 
My first University CS class was actually an "Intro to Programming" type class that used python. The argument in favor of Python (as given by the professor) was essentially that the 'protection' many feel to be detrimental is actually beneficial as Python 'gets out of the way' and lets students focus more on CS than language details and syntax. The class introduced types briefly (only explaining what they are and that python 'manages' them for you), but spent most of the duration focusing on control structures/conditional statements, boolean logic, functions, recursion, simple tracing, libraries, etc. I've seen programs that do something similar using psuedocode, but personally feel the use of python was advantageous as it allowed for simple testing and experimentation. The following class, first in the CSE major track, was somewhat similar, but in greater depth, and added lower level concepts (memory management, stack/heap, pointers, structs and basic software design elements) using C. Following that was OOP then Data Structs in C++. I found my school's program to be rather logical and linear and avoided the pitfalls of learning multiple languages until later on, once core concepts were fairly well understood and differences between languages could be better appreciated. Python provided me a fairly good foundation to learn on (though as mentioned, it was optional at my school), but the focus was less on the language and more on the core concepts of basic CS. I don't necessarily think it would be a good core requirement, and definitely wouldn't serve well as a replacement to any of the other classes you or I mentioned, but it can have a useful place ime.
Thanks for the feedback. I'll respond to each of these in turn. 1. By convention, people use `open` over `file` - I've never used the `file` object directly. It's even been removed in python3. 2. I definitely do have some redundancy here. I thought a lot about how to do dependencies with a single method, but they all break down for various reasons. I'll reply to this with some considerations I did. 3. I definitely am using some magic to do those format strings. (Plan to implement in with voodoo from inspect module). However, including the argument seems like too heavy of syntax. 4. I think this is okay. It seems annoying and redundant to do func([arg1, arg2]) if func(arg1, arg2) can be used instead. 5. I looked it over and you're absolutely right. I'll update with a easier to understand version. 
Can you use all of them together? I thought pandas, skikitlearn, and sympy were incompatible. I have the rest of them installed.
And to use most libraries, you need to downgrade your unicode strings to a plain str.
See I actually argued for the reverse. Learn the hardware low level stuff relatively early on, then when you get to complicated material (algorithms, AI, security, automata, etc) you don't have to concern yourself with minor details like pointers, memory management, etc. Early on, it's a lot easier to work with pointers because your projects are simpler. But later, the focus isn't on "programming" it's on computer science. 
thanks :)
Where's perl on that list? Just wondering.
nope I did not clone that. I made a new one following https://github.com/mitsuhiko/flask-pastebin I hope that clears away all the misconceptions :) __EDIT:__ secondly most of the pastebins give same functionality so it is not difficult to confuse their source codes with each other. Mine one now supports diff as well and I am adding new functionality as I write this post.
&gt; Your bosses are wrong. Switching to Python 3 is a textbook example of eliminating technical debt. Right. And if your boss is any good he will then ask about the wisdom of choosing (and now staying with) python in the first place... Alternatively, he may not even ask, but on your next project you will be told not to use python. This is a very bad battle to fight.. 
Git is amazing. Not only is it used for version control but you can have your application on a local git repo or on your GitHub account and easily clone it between systems for deployment or dev. As /u/SerpentSix said, check out that link to get a QuickStart on it. It's super easy to use. I also recommended dabbling with Linux. Not only because its developer friendly but it's ,much cheaper in the long run. Hosting applications on windows servers can be pretty expensive at most hosting companies. I started programming on windows too but a friend told me to give linux a go, best advice ever. I will only develop on my Linux boxes.
One problem with that approach is that \_\_file__ [is not necessarily defined for an executed script](http://stackoverflow.com/questions/2632199/how-do-i-get-the-path-of-the-current-executed-file-in-python). Also, the relative pathname will fail if the cwd changes before the function call. As suggested in one answer in that stackoverflow link, you could add a special locator module in the same directory, import that, and get its \_\_file__ attribute. There are also solutions that use inspect. Assuming the directory path is correctly identified, the fact that imp.load_source always re-initializes modules could cause problems in more complicated cases.
[Let's check on Google Trends](http://www.google.com/trends/explore#q=ruby%20tutorial%2C%20rails%20tutorial&amp;cmpt=q) : search on rails tutorial are about the same as on ruby tutorial. Indeed, the index would benefit from combining rails and ruby. But their popularity is not growing. 
belated response, but honestly given it's python here, I'd have to say: asyncio has been merged into python 3.4. It's become blessed by python-powers-that-be. I quite like gevent, mind, but in python-land, that has to be a major consideration.
Yes it has, though I think pulsar is the library framework I always wanted for python. Thanks
pyNastran exists. Now if you don't use Nastran, then you don't care, but it's a good library (I'm a bit biased) that's being adopted by NASA into OpenMDAO (their open source ModelCenter clone written in Python). https://code.google.com/p/pynastran/ Oh yea...OpenMDAO www.openmdao.org and soon to be VSP written in C++ but soon to be swigged into Python http://www.openvsp.org/
&gt; Pyqtgraph - Matlab makes pretty plots, and is the standard plotting library I though Matplotlib was the standard? Their webpage is better, the docs are better, they have more financial support, it supports Python 3, it has more functionality, what's worse (other than speed for GUI interaction, which even that can be made real time depending on data size if you stop updating the axis object every time you plot). I thought PyQtGraph was only better for mass amounts of data.
For your point about multitasking, most of the time, I don't really care about speed in python. If speed was critical, you would write it in C.
&gt; their popularity is not growing We can only hope. I can't believe that we (the programming community) seem to be doomed to repeat the same mistakes over and over. All these unmaintainable apps do though represent true job security.
hmm. never used it, in fact wasn't aware of it. Mind you, an Actor model can be done in things layered on top of other apis though - in fact that's how I last used gevent, a partially-assed actor class that was a greenlet with a gevent queue as an inbox, pretty much [as per this stack overflow response by someone else](http://stackoverflow.com/a/3435125), then do the bulk of my actual domain modelling as actors. 
I had been using a linux laptop. Lived it, but the wireless driver support was really bad. I've just bought a new laptop, may try to dual boot. I had been using Python with the assumption that the same code would work on a Linux server, no?
&gt; I had been using Python with the assumption that the same code would work on a Linux server, no? It probably would, don't worry.
Reworked from [here.](http://codegolf.stackexchange.com/a/17010)
What does it mean that `imp.load_source` always re-initializes modules? This part was not clear in the docs either. Can you give an example where it causes problems?
What do you mean "bytestrings are gone"? edit: I read your thing. I never realised python 3 was so broken.
I (and Ian, I think) sees this issue from the perspective of a developer that uses Python and has written a lot of Python code. I've created code in Python that others find valuable (and so has Ian). But I believe we're not here for Python, Python's here for us. While we don't want to "sabotage" Python, our priorities are not primarily towards Python the language. Nor should they be, I think; we naturally care about our codebases and our work and the ecosystem surrounding that. The problem with Python 3 is that a previously well aligned interest between the core developers and developers using the language has diverged. An interest in Python 3 adoption compared to an interest existing codebases that need to be maintained and evolved, and the ecosystem surrounding it. When Python 2.x was evolving in a backwards compatible manner, the interest of language evolution was more aligned with that of the developers already using the language in existing projects, but less so now. I'm a bit tired of non-starters concerning this whole discussion. Writing code compatible in both 2 and 3 was considered crazy talk and a non-starter when Python 3 was released. But people who wished the language well with existing codebases had to figure this out, as it was the only way forward to evolve codebases. In 2011 we've heard that Python 2.8 is a non-starter. 
In your opinion, would a parallel course teaching both C and Python, finishing up with how to extend each with the other, be sufficient to address Python's academic deficits?
&gt; Try getting it to update ~20 fps with 10000 data points and scrolling axes I can do better than that. It's work and you have to think about it differently and use all sorts of obscure (and occasionally buggy) interfaces, but it can be done. The examples on the website will leave you with a very slow code. http://bastibe.de/2013-05-30-speeding-up-matplotlib.html
What on earth are you talking about?
It's funny you should mention that, because that is almost exactly like one of the things I suggested. This was supposed to address some of the issues we have in our third class - learning C++, version control, and Linux. My suggestion was to have a class in parallel with the second class in which you cover basic Linux, version control, and the basics of C++. This suggestion was independent of switching from Java to Python, though. With that method, I suppose Python would work fine for both the early classes. I apparently made a good case for that one, because that responsibility got off loaded to me. So now I get to teach basic Linux and git to first year undergrads.Yay me. 
Still up from NYE is impressive :) Interestingly.. I used to think I preferred dynamic, "non-declarative" (which Matlab uses). Going to C# and needing to declare stuff seemed silly - "Why can't it just figure out what it needs to be at runtime?" However, the (mostly) static typing in C#.. now I'm starting to really dig it, for what it lets the IntelliSense do. 
http://git-scm.com/book read it.
I love Python. But this article is biased nonsense garbage.
Numerical computing. Python is dominant in the scientific community because it's easy, expressive, has great libraries, and easily interfaces with optimized C code. The OO paradigm of Java maps poorly to the problems in this space and the lack of interactive computing makes it difficult for scientists to experiment. 
You should not be using Git for anyone else's sake, use if for your own! Since you don't know about version control yet you got something quite fantastic to discover, a tool that will help you tremendously when coding. Note that Git is not at all a tool for rolling out software to servers, but it so happens that you can use it for that as well. To get you started on Windows, try http://code.google.com/p/tortoisegit/.
&gt; I had been using Python with the assumption that the same code would work on a Linux server, no? That depends: They do some things differently due to the underlying OS. Multiprocessing, some stuff like handling filenames and network paths, and of course doing fancy menus in the terminal. Performance may also differ: Linux uses sockets for async networking. On windows, sockets are a toy and you would need to use IOCP. But then you should be using a library like Twisted or Tulip if you are doing serious networking. If you run into any 3rd party libraries you need, you might have trouble finding windows versions of them. On *nix you would just do "pip install &lt;package name&gt;". On windows this site might help: http://www.lfd.uci.edu/~gohlke/pythonlibs/ Oh yea and remember almost all Linux distros USE python internally so DON'T mess with the system python interpreter or packages. On windows you're free to monkey patch it to get around some weird problem, on Linux you'll break the OS doing that. The recommended method is to install Python in a venv (virtual environment) and then each app can have its own copy of the interpreter and libraries. http://docs.python.org/dev/library/venv.html
&gt;if I go with Flask I'm not going to be in a bind later down the road if/when it becomes time to expand. I think you'd actually be better off with Flask than with Django if your web app started suddenly getting a surge in visitors. Flask is faster overall, and if you find bottlenecks, it's really easy to swap out the slow parts with alternatives. In Django, the templates and ORM are generally considered the slowest, and it's quite a bit harder to swap out components. Django wins, or at least tries to win, in terms of programmer efficiency. If your web app falls in line with traditional Django apps (a blog, some kind of a CMS, or otherwise anything that requires user profiles and benefits from a rich admin interface that's able to update content), then you can save quite a bit of time and get something up and running quickly. Pyramid and Flask requires you to put a little more work into the beginning, both in choosing your components and writing your code, but I think in the long run you end up being better off with them.
they don't joke around when they say "batteries included". the stdlib is amazing, and big. there's very little you can't do using only the stdlib.
Not sure why someone downvoted you. I don't think your method is bad. From my own experience, I feel I benefitted from having a firm grip on the basics of programming, which allowed me to better focus on learning lower level stuff and CS later. Understanding conditional statements and simple logic helped me write programs to test pointers or whatever in practice. Conversely, I am not sure that knowing what a pointer is would have helped with learning program flow and logic. Though, I don't want to imply any topic is taught in a vacuum. That said, I can imagine the benefits of your method just as easily: it's something akin to "building from the ground up", and is probably more in line with how the 'official' CSE major path operated in our program. I suppose I just feel the intro class helped prepare me for what followed but may not work for someone else. I may be giving it more credit than I should, I don't know how I would have fared otherwise. However, I will say that one of the benefits was that the class was 'fun'. Had I taken the C class first, I don't know that I would have enjoyed it enough -- or done well enough -- to want to stick with it. That Python class put me on a completely different trajectory. I am not sure either instructional method is inherently flawed, it really depends on how the courses are planned/structured overall. That said, I'm not an educator, just a schmuck with an anecdote that's being recalled through rose tinted lenses.
In this case I was talking about the folks who think that it's BAAAAD that Python 2.X allows you to a print statement easily, instead of making it look like a function.
Two things 1) The [iPython Notebook](http://ipython.org/notebook.html). Imagine a word processor into which you could just type python code to suck in data from the web or from a spreadsheet, and then more code to output a pretty graph using the standard graphing libraries, after perhaps doing some computation on it. Previously you would be downloading data, calculating in matlab, preparing plotting in excel then pasting the graphs back into word? The single screenshot on the front page of that website says everything. That's an actual live document, not a cut and paste, with code and formattted text smoothly integraated, and the graphs being generated in real time from the code. 2) There;s an advocacy program called [Software Carpentry](http://software-carpentry.org/) partly sponsored by the PSF (python software foundation) and Mozilla for chaps like yourself - folk who can program, but who are not CompScis or software engineers or full time developers. While a lot of that is basic workflow stuff like how to use git or a database (scientists are really bad at this, they like to email excel sheets at each other, then someone asks for a copy of the data for weeks X to Y put on the web and it's simply not possible because it's an Excel and has no collaborative version control) they go into a lot of task automation and sci/eng specific tricks using Python in much more detail than I can.
Sorry to eat bandwidth for it, but I just have to say that this is well-said. Thank you, faassen!
You guys should read the PEP. It describes the needs and the advantages of this new module http://www.python.org/dev/peps/pep-0405/
The downvote has nothing to do with my comment. I got into an argument with a very mature redditor recently and he has been downvoting every comment I make. The advantage of my method is that I came from a hardware background, so thinking of what is physically happening in the computer makes more sense to me. Ideally, I would like a separate track designed for practical programming that would focus on low level and another that was the more math side and you do those concurrently. But that would be a complete overhaul that unlikely to happen. Edit: By practical, I do not mean python is not practical in any way. That is just the word that came to mind when I thought of the concept of the hardware side of computer science.
Interesting. That's quite the hacky way of doing it, but seems to be effective. Note that for this test only 100 data points were used, I wonder how it would handle more. Still 500 fps is impressive; as the eye can only see roughly 30 fps, that's more than enough.
I have no idea how they play together. I'm just saying those are some major tools in the python scientific computing ecosystem that contribute to its solid reputation. 
Each time `imp.load_source` is run on a module the module-level code in that module will be re-executed. Suppose you have a file `globals.py` for sharing data between modules. Now suppose a module imports `globals.py` and then reassigns the value of some variable which is set inside `globals.py`. Now if another module imports `globals.py` using `imp.load_source` the module-level code in `globals.py` will be re-executed, resetting that variable back to its original value. A situation like that may not happen very often, but it could be a nasty bug to track down if it does. 
Interesting. I'd have to be sold on the iPython Notebook. Sounds kinda similar to how MathCad works (which I had to use a bit in college). In that particular example, it was great in theory but pretty rough in practice, turned off from that sort of thing since. Would be at least potentially interested if iPy Notebook is more polished.
&gt; Poor packaging is a bit of a scary prospect. It's not that packaging is impossible, it's that there doesn't seem to be a standard way to do it. Many options, which all muddy the water (setuptools, distutils, distribute, pip, easy_install, etc...). The posted guide is a decent overview, as is this: http://guide.python-distribute.org/ &gt; how about putting together GUI's / user interfaces? Definitely do-able in Matlab, though a bit clunky at times and not a huge selection of controls. GUIs and user interfaces are super easy in python. Qt or wxWidgets are the most common frameworks, although tk comes in the standard lib. You get all the power of any of these frameworks, with the ease of a high level interpreted language to set them up. PyQt comes with [Qt designer](http://pyqt.sourceforge.net/Docs/PyQt5/designer.html), which is a GUI tool to help build GUIs. Drop in widgets, and it generates the code for you. Doing it by hand isn't terribly difficult either. Here's a good tutorial on [pyQt](http://zetcode.com/gui/pyqt4/), and one for [wxPython](http://zetcode.com/wxpython/). &gt; How about OOP support in Python? Good? That's a big question. In python, everything is an object. Everything. However, python doesn't mandate object oriented design like Java does. You can make classes and inherit if you want to, or you can just write functions. Or a bit of both. It's really up to you. So yes, it has support for it (excellent support), but doesn't require it.
I don't know your standards of polish or your use cases. There's a lot of example notebooks on the website. ipython is better than mathcad but how to measure how much? As for Python itself, all languages can do anything. Python gives me development speed and it's just fun. It does also have some amazing libraries for sci and eng.
They aren't incompatible, at least as far as I've explored. I have them all installed and have poked and/or prodded most of them to one extent or another.
&gt; Why can't it just figure out what it needs to be at runtime? One reason for this is that you catch a lot of errors in compile time in C languages that you only see at runtime in dynamic languages. For the most part these are errors that could/should be avoided by scope and naming conventions, but every now and then I create a variable in one part of a function, and mistakenly overwrite it with a different data type in a later part, and end up wondering why I get an error trying to add "Susan"+1. There are other reasons, mostly to do with speed I think. If the system doesn't have to spend time at runtime determining the type of a bit of data, then you get that much faster.
been following wrobstory since I got into python and I love what he's doing. Shame reading this that he's focusing primarily on maps but no big deal he's helping lay the framework.
Good link. That book is how I started with git. (Had already used Mercurial. Git seems more industrial-strength.)
we can absolutely say more people are looking up tutorials for Python 
You can get a lot more speedup than that, though I don't know why you'd want to on this trivial 100 point problem. We use an interface that you pass in a dictionary with the key=standard method_name, value=[arg, kwarg] that wraps the appropriate matplotlib method. It's blindingly fast for GUI and non-GUI applications (e.g. make 50 plots in a loop). I'll post the call line if I remember...
Last year I had at least 2 "advisers" telling my costumers that choose php alternatives over my projects because according to them nobody was using python. Fortunately I had a good argument and saved the situation, but now with this metrics I'm more capable to defend my proposals.
Where do I sign up?
While I don't disagree, python doesn't really fill the niche that a Stringly typed language like Java does. There are is however, a lot of websites which could use python rather than Java. It seems that Go may be getting somewhat popular with those that would use Java, though that could just be my filter bubble.
Thanks :)
You are lucky to have learned Haskell in Uni, that would have been very fun I think.
To get the file name, you can use `__file__` instead of `inspect.getfile(inspect.currentframe())`
The problem with IDEs in Python is that the language is highly dynamic: It's quite hard to do certain types of analysis on Python code. The Microsoft IDE for Python in VS is a bit lame; Jetbrains PyCharm is probably the most common Python IDE that I see - it's the one we (as in the Python community) are "encouraged" to recommend to Windows users. It's free for open source and hobby work; you only need to to buy a license if you're doing commerical development. Call me an old fashioned emacs hacker but I've yet to see the benefits of an IDE (or one that can run in a terminal via SSH). This however isn't relevant to the topic at hand.
I would *assume* caninestrychnine is a Ruby zealot who thinks of it as the One Language to Rule Them All. But that seems like a rather harsh thing to assume, so I'll withhold judgment for now.
&gt;It could mean Python is harder to learn than lower ranking languages and easier than higher ranking ones. It *could*, but Python is ranked higher than C and C++.
RPI now does CS101 in Python. The remaining courses, however, tend to be C++ by default.
For instance, this code: for _ in evilobject: pass Could do absolutely anything, depending on the value of `evilobject`. But by convention, it does nothing (except if `evilobject` happens to be an iterator, then it will be exhausted).
TIL. Thanks.
I don't mean to be an asshole, but you deserve what you get with RAID0. 
I may be misunderstanding what you're doing, but is there a reason you can't use Pandoc instead?
I'm not sure I can be of a great deal of help here but I would strongly suggest going the Python route looking at it as a very good tool to have in your tool box. I don't do a lot of programming in Python but here are a few reasons why I like it: . A high likely hood that I can understand something I wrote months or even years later. Python just feels right to me when read. Contrast that with Ruby which leaves me feeling that the rug has been pulled out from under me. . I don't know of any language that is faster to develop in! . Python 3 ( I switched real early) feels even better as some loose ends have been dealt with. As for IDEs there is PyDev for Eclipse which is good but you have to be willing to install Eclipse. Frankly Eclipse has gone backwards reliability wise so I'm not sure if you really want to go that route. As for other languages, learning C++ is an entirely different commitment than learning Python. It may be worth it but frankly you have to consider school to really leverage C++ well. You can use C++ at a fairly elementary level and get good results though. Realize that C++ is a language of gotchas. 
Agreed. Saying &lt;Product Name&gt; is an &lt;Acronym&gt; doesn't help anyone.
RAID 0 means that several drives are combined to form one 'virtual' drive where the data is 'striped' (split up into pieces) evenly across each drive to improve performance (reads and writes are sped up proportionally to the number of drives). The problem he's alluding to is that in this setup, if one drive in the RAID fails, you effectively lose everything because the data in the other drives is now useless. It's common practice to use RAID 5 which combines striping and mirroring (duplicating the same data across multiple drives) so that if one of the drives fails you don't lose all your data but you still get the performance benefits of striping.
Maybe it means more amateurs are learning Python and PHP, while more professionals are learning C and C++ (e.g. in college). I know I'd probably reach for the professor's notes before Googling "[programming language X] tutorial." But then I can't account for Java being #1. It's almost like there are many independent forces driving the positions of the items on this list.
 &gt;The niceness of PyDev makes up for the clumsiness of Eclipse in my opinion. You've just gotta work around the bugs -- you know, the little things, like your entire project folder disappearing. ;) And I was blaming that on Windows! Right now using Eclipse is a big risk if you are doing anything important. Always back up. I literally had this happen with the latest version of Eclipse but until now thought something happened on the crappy Windows machine at work. &gt;PyDev is probably one of the best Python "tools" I've found. Yes absolutely it is a fantastic tool. But the latest versions of Eclipse are huge regressions in reliability. I really think the Eclipse community needs a reboot and needs to focus on a revision entirely wrought to squash bugs. &gt;Some of the features it gives makes it feel almost like your working in a statically typed language. The intellisense (or whatever it's called in PyDev) has been generally pretty reliable and the refactoring tools get it right, like, 90% of the time. It makes aggressive refactoring on a big project -- something which usually rather sucks with Python (in my opinion), relatively pain free. Like I said I really like PyDev, but I'm extremely frustrated with Eclipse right now. It is more of a virus than an aid to development. 
He spelt raid 0 together like this "RAID0" and I thought he simply misspelled radio. Sorry.
Thanks for the feedback. As for C++ etc, picking them up wasn't entirely by choice! Some very specific small projects at work where I've had to figure out C++, potentially Fortran. Larger project upcoming which will involve Modelica. Anything in Python will / would be of my own choice for projects where I have a bit more creative control. Getting into some other languages - even if only small scale stuff - has at least given be some better perspective on programming in general!
Well in my case that is bull crap. I've basically have installed every major release of Eclipse out there and frankly the last three have been very troublesome. So bad in fact that I'm serious thinking about giving up on Eclipse. Honestly one of the only reasons I've installed Eclipse is to use PyDev. To a lesser extent I've used Eclipse to edit a bunch of HTML. So the state of Eclipse will have an impact on how well PyDev is accepted. 
so... more people (than have in the past) are searching for help with Python... which indicates a general increase in use of Python.
Does this also include front-end development of the website and streaming portal? Because I could definitely help with that.
i prefer looking at hiring. enterpise is practically all java and microsofts flavor of the week. startups are all ror and php. small biz is mostly php. that's probably 90% of all jobs in any major city. python is fighting with R and some enterpise analysis languages, and django has nothing on other web stacks. honestly, i'd love to stop writing 2 codebases for my ML and web stack but python for web is just so far behind everything else.
Yes, it absolutely includes that :) I'm not OP but am involved with Radio Reddit (just to clear up any confusion), and thank you very much for your interest. 
can you give more details about what you're trying to accomplish ? Without it youre basically askng a reddit full of devs what their favorite web harness is. For example, i enjoy using twisted webserver factory over both of these and have a project that handles &gt; 600,000 request a day and never falls over or has latency issues. BUT if you told me you prefer to work in an mvc style, want an admin panel and user-contributed plugin support i might point you to web2py or django. 
Some fairly impressive [demos](http://salvatore.pythonanywhere.com/RapydScript) too (like [this](http://salvatore.pythonanywhere.com/RapydRay) raytracer and [this editor](http://salvatore.pythonanywhere.com/RapydBox/editor)).
Nowhere. No-one learns perl (at least few enough that it isn't in the top 10).
You did the research, right? You didn't just guess those rankings at all, did you?
This is why Python is cool (and scary..): import sys, datetime def happy_new_year(type, value, tb): print('%s!!!' % datetime.date.today().year) sys.excepthook = happy_new_year Now try: &gt;&gt;&gt; Happy new year! 2014!!! **edit**: Python 3 compat.
I am a beginner in Python, can I also hop in? What are qualities mainly you looking for?
I'm interested, I have a few professional Python experience. is there any specified architecture or are we free to propose?
His current about page states : "Welcome to Pypix.com, where we live, breathe, and eat everything about development with Python. Were passionate about Python Development and everything that goes along with it. Our goal is to share the latest and greatest findings, tips, and techniques for web designers and developers in Python Community. From Flask, Pyramid to SciPy, Pypix is the perfect showcase for Web savvy python Developers. Youll find in-depth articles on a variety of red hot topics such as Pyramid, Django, Flask, Scientific Computation, usability, and more. Not to mention features looking at the business side of design, freelancing, mobile applications, inspiration, and resources, to name a few. In short, if it relates to Python, were interested. What do we know about development? Quite a bit actually. Pypix doesnt just have its finger on the pulse of the modern Python Development world. Its at the very heart of web development. Pypix is a powerful collaboration between worldwide leading developers eager to share their knowledge. Expert developers from around the globe regularly contribute articles, features, and tutorials to help grow the design community." Which is not only says they/him are/is good at Python and also, the content seems to be copied from several other websites. 
Honest question -- now that it's possible to just get two 1TB SSDs, would that be more reliable than spinning disks in RAID 0? Besides, RAID 0+1 is usually best for almost any mission-critical server (since you get the uptime of RAID 1 and the performance boost). 
Questions: * Open sourced? Where will the source live? Github? Another VCS host? * What license will the code live under? * Having a single hosted server sounds pretty terrifying. Do you plan on moving to clustering with this rewrite or possibly offsite hosting? * How will you reconcile the rewrite with the currently hosted system? Will you run the rewrite and the current platform side by side? Will you move each feature over one at a time, or will the rewrite switchover be in one big go? * Any plans to use continuous integration or deployment?
I learned for at the university Turbo Pascal which was a good choice, because the language was sufficient for algorithms and at the same time easy to learn. Even when OO was missing, Pascal should be the language at universities for the first courses. The support for more complex projects isn't good, but for learning it's awesome. [http://www.freepascal.org/](http://www.freepascal.org/)
Teaching C as a first programming language seems like it would turn a lot of potentially really good programmers off. It's very low-level and abstract compared to a simpler "get up and code" language like Python.
It also has a ton of support for statistics and machine learning.
Crayon syntax highlighter. 
With vim plugin it's great, thanks!
No! I'm just not too articulate. I'm sick of Ruby and Rails and code with so much magic that it's impossible to tell what's doing what.
IMHO that's not a matter of magic, it's a matter of shitty developers. A good developer will use magic very sparingly in places where it actually makes sense. For instance, in Python, this: foo.bar Will be automatically converted, under certain circumstances, into this: foo.bar.__get__(foo, type(foo)) Now, if you just use this feature without knowing what it's meant to do, the result will be an unmitigated disaster. But if you understand the semantics of the descriptor protocol and make it behave properly, it can make code a lot nicer and cleaner. I believe Django uses it to implement models and fields. Going in the opposite direction, it's quite easy to make byzantine object hierarchies in, say, Java. The language is notorious for its overabundance of nouns. A shitty developer will see this and think it's because having lots of nouns is desirable. Next thing you know, your "lightweight framework" has grown three layers of abstraction overnight. TL;DR: Anyone can write bad code in any (Turing-complete) language. Magic does make it easier for bad programmers to write bad code, but it also makes it easier for good programmers to write good code.
Actually, C is very concrete. The marginally higher level languages, like Ruby/Python/other "get-up-and-code" languages, feature much heavier abstraction. What makes C a great beginner language is that its core feature set is very small and easily digested (this is true with Python as well). The added bonus of teaching them in parallel is that the main implementation of Python is written in C, so not only can you teach people how to use the language, they can look at the source and be able to understand what is happening.
Great project. See also Pythonium, which runs on Python: https://github.com/pythonium/pythonium most of the demos should be ported easily to Pythonium, maybe I'll do that...
So, which framework are you going to be using? 
One thing python has in great numbers is libraries wrapping extremely fast C libraries. You write easy to read code in python, but the core inner loops doing actual computation are still going blazing fast in compiled code.
You also might like Go. Way faster than python, static, but far simpler to write than C++. It will figure out types you want at declaration!
I can tell you from personal experience that Pyramid does stellar job for projects both small and big. I've created [App Enlight](http://appenlight.com) in Pyramid - that mostly speaks with JSON (it's mostly AngularJS), and I've worked on points2shop.com that has over 6 mil users and is still Pylons based - on pyramid our codebase for p2s would be even better.
Right, but I can't help but feel that's a bit much to ask from people who have never done any kind of programming before. It seems like teaching addition and multiplication at the same time to children who have never seen basic math.
Same, I'm a beginner but would like to help.
Same here. I think it'd be a great learning experience. 
You did it! Congratulations! Language of the year! Great job, everybody! It's great to be here.
Thanks for the clarification. Then what is the best way to do it? How to run a script in a submodule as a stand-alone script, knowing that it wants to import another submodule? There must be a nice pythonic way. So far my best guess is modifying the `sys.path`.
&gt;* Having a single hosted server sounds pretty terrifying. So does RAID 0. That better be some high quality HDDs.
Very interesting. The introduction is very scattered but I'm glad I kept on reading. Perhaps a concise list of features somewhere will increase reader retention.
I actually started with python then learned java through my school. 
How this any different than just specifying PYTHONPATH ? cd sub2 PYTHONPATH=../ python utils.py This doesn't need any special code in your module and work as expected and documented.
Which web framework will you be using? Which database?
having used both for medium/large size project, i largely prefer Flask, which, in my opinion, is adequate for any size of project (small to very large)
exactly, in much the same vein you *could* make an object compare equal to None, but in practice you will get chastised if you do.
Quite a few hinted at this. It's incredibly fast to roll something out. Even if your doing something in another language, it's a great tool to sit down with and work out algorithms and framework and not archaic enough to make switching code base too much of a headache. It's still a good quick tinkering tool. A few months ago I was going to send my vacation photos to my parents but each picture was 8mb and they have slow net. Within 5 minutes I found a photo library (can't think of which one and I'm not at home right now) and in 10 lines of code had it convert all my photos scaled down. To me, that's amazing. I wouldn't even know how to start that in C. At work, I rewrote some image acquisition and analysis software in Python. Quick and easy, then with some profiling isolated the computational intensive parts and only took a few hours to rewrite just those parts of the code into C with Cython and the project still worked seamlessly. All in all, it's just a fun language to tinker in and you can still get decent performance without too much of a headache. That being said, the multitasking is a pain in the ass. Yes the multiprocessing library makes it easy on a small scale. I have to use two external libraries for calculating zernike polynomials and do some phase unwrapping. Somewhere somehow something is locking the GIL between the interaction of the zernike library and Numpy. Trying to go into that (I've think I've narrowed it down to a linalg package in Numpy that calls BLAS that's trying to then multitask that computation) is nearly impossible on a windows machine, especially since I have to fight for 3 day periods of admin rights on the development machine at work. After that part of my library is interpreted suddenly the multiprocessing is locked to only one process at a time. In fact, generally working on a windows machine is somewhat of a task, not difficult just not out of the box workability. So if you want to optimize the hell out of something to squeeze out as much performance as possible, I'd avoid Python for that specific task. But it's a good idea to know a scripting language and Python is just a fun language to play and tinker in.
What makes Python so great is the friendliness of its community.
&gt; startups are all ror and php. small biz is mostly php. not true. lot of them use python. and i'm preety sure most of them who did choose php regret in the end. 
Thanks! The best way to contribute to the project at the moment would be to give me feedback about it (both the documentation and trying out the code), as I can learn a lot from that. You can place issues in github, or drop me an email (PM me if you can't find it). I also try to hang out regularly in #morepath on freenode irc so you can look for me there. Of course code contributions would be welcome too, but it'd make sense to talk first. 
if you search in stackoverflow spring it has 38 jobs and search django it has 40. spring is a web framework like django. now search java has 310 and python 213. Your search was wrong python is not django. There's more java jobs for sure. I personally enjoy coding python more than coding java so it doesn't matter how many java jobs are there.
Thanks but setting the `PYTHONPATH` each time seems too much work. I want to launch any script and they should just run: $ cd sub2 $ ./utils.py There must be a way to do it nicely.
Thanks!
You chose two sites, neither the largest, for your survey, and you compared frameworks with programming languages. I wish I could permanently avoid seeing your nonsense.
Rails' philosophy is to rely on magic.
Django tutorial is much lower than Python tutorial. See [here](http://www.google.com/trends/explore?hl=en-US#q=python%20tutorial%2C%20django%20tutorial&amp;date=today%2012-m&amp;cmpt=q).
Yes, it does. In this case you would need three 1TB HDDs for 2TB effective storage space in RAID5, where as RAID0 you need only two. But if one disk fails in RAID5, you only need to replace one disk, in a RAID0 configuration you will need to replace one disk and all the data that was on both HDDs.
1. Python is amongst the best glue languages i know of. For you it means you can easily integrate matlab with [mlabwrap](http://mlabwrap.sourceforge.net/) , java using [py4J](http://py4j.sourceforge.net/) , R using [rpy](http://rpy.sourceforge.net/) and others, while having access to the huge amount of available python libraries . 2. [Spider](http://code.google.com/p/spyderlib/) offer a great dev environment for mathemtical applications . If you're looking for a general IDE with good intellisence , wingide or pycharm are the way to go. 3. UI development : [traitsui](http://code.enthought.com/projects/traits_ui/) and [enaml](http://docs.enthought.com/enaml/) are very good tools for GUI. 
Surely OP will deliver.
I find it useful, thanks!
Also jumping in. Is there ways we could volunteer our efforts? Could be QA/QC work.
&gt; pip no longer will scrape *insecure* external urls by default nor will it install externally hosted files by default. Wording is a bit flaky. From what I understood, `pip` will no longer ask a server different from the main mirror you've set (which defaults to https://pypi.python.org/pypi if I understand correctly) unless you specifically request for it. The way this is phrased could make a user think that `pip` keeps a white list of secure servers. I assume this is not the case, right? 
I cannot code worth a darn, but if you ever need photography or design help again, you know how to reach me!
&gt; Honest question -- now that it's possible to just get two 1TB SSDs, would that be more reliable than spinning disks in RAID 0? Yes, but there's still a problem: each physical drive individually failing destroys the whole disk, so your chance of failure in the RAID drive is multiplied by the number of physical drives. RAID 5 solves this problem, essentially through redundancy.
Spring is not a web framework. Spring Web MVC is a web framework. Other things in Spring have absolutely nothing to do with web frameworks.
The source on github is here: https://github.com/atsepkov/RapydScript
What exactly makes one syntax more "readable" than another. Every Javascript transpiler seems to make this claim I'm doubting it has any objective meaning at all.
articles with titles in the format "do [something] in &lt; [some amount] lines of [language]" are slang for "there's a library for that"
I'm wondering if keeps a CAs whitelist.
Well presumably most fans of Python (at least) would find it more readable than CoffeeScript. Of course you really can't objectively make a claim like that though.
What framework(s)? What database/driver? Which version of python? What roles do you have filled, and what are you looking for? Are you using Bitbucket? Github? I'm mostly interested in how the work is to be split up - is there a directorial role somewhere or will it be a bunch of redditors scrambling around with an "I think there should be XYZ functionality here, push 2 master"? I can do some backend stuff if it looks like a reasonable project. 
I thought perl is used often for data stream processing (or data searching). I read that it's more powerful at it than many other languages, and much faster.
Maybe stop reading out of date materials or propaganda from diehard enthusiasts. 
Ok, that's a fair answer. I think it's also bracketed to specific families of lexical syntax as well. Most Python folks seem to regard block-structured languages in the style of C as more readable.
you are right but anw the point is the same: you cant compare a framework with a languge
&gt;def load_src(name, fpath): import os, imp why do you import inside a function?
Thank you! 
Are there any practical cases where import order matters? If one import messes with sys.modules, it could alter the behavior of later imports, but obviously you shouldn't do that without a good reason. Maybe some mock or profiling frameworks do that sort of thing though.
Benchmarks from when? I note the complete lack of links.
What you said made perfect sense to me. NYKevin seems to lack reading comprehension.
if youre looking for an IDE to help w the process, try PTVS: http://pytools.codeplex.com. free &amp; supports git.
Right. Since `load_src` can be called several times, it would be better to place them outside of the function.
I have shipped numerous rich-client GUI applications with Python. It's not always painless but I don't think it's as much of a cluster**** as you imply. We are also working hard to make this even easier via [Anaconda](http://continuum.io/anaconda). A huge part of the pain of distributing Python applications is just the packaging problem. If binary packages were built in a relocatable, self-contained manner, then you could use a number of standard installer-builders that are available for each platform. With the packages in Anaconda, we have this, and so that hairy variable is removed from the equation.
IPython notebook is not like Mathcad, it's a lot more like Mathematica.
I think this was one of them that I read. [stackovervlow](http://stackoverflow.com/questions/12793562/text-processing-python-vs-perl-performance)
Bitbucket is what we were thinking however, we are up for anything. The plan is to have multiple frontend servers with a separate database cluster. This is still on in planning phases, however the thought is to rewrite this side by side, and get beta testers involved to help us work out kings. Once things are good to go we'll make the announcement and schedule the switch. As for the last question, this is exactly what we need devs to help us figure out. 
That was a typo sorry. We have them mirrored in Raid 1. 
Man that was the costliest typo ever! It is Raid 1. 
A lot of pre-existing Python code-bases I have worked with in the past have had import order dependency as described. I built in handing for this problem into isort, and you can easily force certain modules to be on the top of their respective sections - or add an '# isort: skip' comment to skip the processing of a single import.
I think I found a working but quite hackish solution [here](http://stackoverflow.com/questions/2943847/nightmare-with-relative-imports-how-does-pep-366-work). See also [PEP 366](http://www.python.org/dev/peps/pep-0366/). I modified the code a bit, thus `utils.py` could look like this: #!/usr/bin/env python # encoding: utf-8 from __future__ import (absolute_import, division, print_function, unicode_literals) if __name__ == "__main__" and __package__ is None: import os, sys d, f = os.path.split(os.path.abspath(__file__)) f = os.path.splitext(f)[0] __package__ = [] # __package__ will be a reversed list of package name parts parents = "" while os.path.exists(os.path.join(d, '__init__.py')): # go up until we run out of __init__.py files d, name = os.path.split(d) # pull of a lowest level directory name __package__.append(name) # add it to the package parts list parents = os.path.join(parents, "..") sys.path.insert(0, os.path.join(os.path.dirname(__file__), parents)) __package__ = str(".".join(reversed(__package__))) # create the full package name mod = __import__(__package__) # this assumes the top level package is in your $PYTHONPATH sys.modules[__package__] = mod # add to modules del os, sys #################### from sub1 import helper from sub1.helper import hi from . import nothing def main(): print(helper.PI) print(hi()) print(nothing.nothing()) #################### if __name__ == "__main__": main() Now you can launch it as a stand-alone script too, i.e. `$ python ./utils.py`! The complete source code is here: [project.zip](https://dl.dropboxusercontent.com/u/144888/wordpress/20140402-relative-import-hell/project.zip)
This is a fantastic project ! I wish you the best luck on this ! I'm sure there is something cool to do with Machine learning. I'm sad not having enough time to help ! I really wanted to try http://prediction.io/ on your data. Again Good luck :)
Not sure I understand how that answers my question. Is curl keeping a CAs whitelist as well?
Holy Shit! (sry for language) I've shouldn't been away from reddit this long. How could I've missed something awesome as this!? Anyhow, I don't know if you already have a baseline of developers but I'm interested as you can be! Been hammering python for a while now (feel more at home with C# and other .net applications, but python is so much fun writing with). But a few questions: * Is there any plans on using websockets etc (you might even do so right now, didn't really check out the site that deeply)? * What's the plan for the actual player? (it's somewhat hard to see sometimes) * TAKE MY MONEY! ***** End of list ******
That's quite reassuring! Thanks
Awesome! If you can email us at admin@radioreddit.com we can chat further! These are all questions we are working on and could use some guidance with ourselves.
I think my most realistic approach is to do it semi-manually, but through the process of elimination and can cut down on the manual-ness of it - I can start by flagging all recipes/ingredients that contain steak, then chicken, turkey, etc, until I have a subset of recipes that contain none of these. Once I get to that point I may need to just flip through the recipes to flag those that are still not vegetarian.
Author here, thanks for the kind words :)
For me, the threshold to irrationality is when the code defies static analysis. That is, you can't just look at the page and know what methods are invoked on what objects or classes. Python, on the other hand, excels at this while still being dynamic.
No, Ruby and gems would have the same problem if gems with C code were as sophisticated as the ones in Python land. Python does the same thing as Ruby, and will attempt to build the C code on the user's system. The problem arises when two pieces of C code are dependent. Now, you have to either build both on the user's system, or, if you want to distribute binary packages, you have to ensure that everything about the build process (including, sometimes, the compiler version) matches between these two. This is hard to get right. Requiring that the user be able to build all the packages from source is also a non-starter, at least for a big chunk of Python land. Whereas Ruby is heavily used by Linux &amp; Mac devs to deploy web apps onto Linux, there are many Python users on Windows, who do not always have the right build tools. Some have Cygwin and GCC. Some have outdated Visual Studio. etc. Add to this the fact that many people build rich client apps with Python, and link to very complex C and FORTRAN libraries, and this makes the "always build from source" thing even more of a non-starter. Qt, VTK, ATLAS, Freetype, Cairo, Imagemagick, etc. etc. - the list is long. For many of these, the configure &amp; build process is nontrivial.
You can use wolfram alpha to give you a nutritional table. http://www.wolframalpha.com/input/?i=rice+potato+and+beans
Yeah that's why I wanted to try to conquer determining vegetarian first rather than gluten-free. It's looking more and more like I'm going to have to build up dictionaries of gluten-free and gluten ingredients, then if new ingredients aren't flagged, determine if they are GF or not then add that to the dictionary. I guess the machine would technically be learning, but just at a very slow pace :)
Linked for the lazy, virtualenv changelog http://www.virtualenv.org/en/latest/news.html
Having that data would definitely help, but Wolfram's API isn't free and I'm more of a hobbist (aka, cheapskate).
How is Python behind for web? Speed? uWSGI takes care of that. I can have a decently interactive website up and going in Python in under a day. Can that be done in Java? Database connections and user logins, comments, etc? 
What is a better method can be debated to the end of time. But, we do have to compete with other schools and part of that is reassuring high school seniors that they will have marketable skills coming out of our program. It's not likely we can convince some 17 year old with limited knowledge of programming that this generally unused language is going to benefit them more than the school a couple hours away that teaches one of the most used languages.
I actually think that the song suggestion/playlist generator algorithm is an ideal candidate for machine learning. 
It will definitely NOT be a bunch of redditors scrambling around, as it stands we are looking for all developmental roles including that of a project lead. Noting that, u/pextris and I both have a lot of professional experience. Pex is a network security guy and I have been the VP of a manufacturing company for ~7 years. We're essentially looking for people who want to work on this project so that we can fill those roles, its a cool/noble thing to do and there is also pretty serious monetary opportunity here...for obvious reasons we'd like to have Redditors in as many roles as we can. We were leaning toward Pyramid and 2.7 and Bitbucket, though if we are massively off base on something then we're open to change, indeed, we're not trying to make developmental decisions without dev's involved in the discussion. Ultimately it will be a reasonable project because we won't have unreasonable people working on it. We aren't ready to start development say, tomorrow, and we aren't going to just throw it out there and hope something good lands, I promise you that. 
Hey, thanks for posting this mate...I was actually totally unaware of this service which is odd because I have done a pretty thorough search of similar corporations. 
I use it, yes. &gt; What features do you like? It runs commands and seems to have decent marketshare. &gt; It doesn't look like you can define file dependencies that only update when a file changes (a la Rake/Make) I had no idea Rake could do that. I've never needed this functionality outside of writing C/C++, and I'd use a C/C++ build tool for that (e.g. Scons). &gt; rules that can apply to all files of a filetype I don't understand what this means. The code in a rule runs; it affects whatever files you make it affect. ---- My needs are simple - I have some shell commands that do things, and I want a common interface to them. Invoke handles this perfectly.
Honestly the number one quality we are looking for is heart...seriously even above experience. We want people who are passionate about music and disruption...ideally those people will also be expert coders but I'd take the former over the latter any day of the week. (Again, a mix of the two is ideal :) ) It isn't likely that we'd give responsibility of the most critical aspects of our coding process to people who can't handle it, of course...but over time it is heart that keeps people motivated...it isn't experience. Professionalism also, I find, is a quality that is independent of experience. Also note that RR is an open source project, if we can get some experience for beginner coders then we are all about it. Beyond that, attention to detail and ability to commit to a project through the life of that project. Ideally we will get a project lead who can then divvy up developmental aspects to people based upon their ability/strengths...as with all things there are things beginners can and cannot do. We are a community at RR and we don't turn anybody away. 
You have an intimidating username. 
this is why im studying pthyon and django. in 2014 i plan to become a rockstar developer and move to SF
Yes, CURL maintains a CA bundle.
This is a module for the [python IRC bot Phenny](http://inamidst.com/phenny/), and runs on my bot name Eiko (if you were wondering). I didn't include my random generators module, since I stole a number of the name and other generators from other places and don't want to take credit for stuff that's not my own work (though I did translate almost all of them to Python, so there's that). This has been a labor of love for me, since I only started programming in Python a month ago. If you have any suggestions to make it work better, I'd love to hear them. Things I plan on adding: 1. Potions for a variety of effects (using a Rogue-like random color system) 1. Traps 1. Some kind of epic item/monster system, though I'm not sure what that will entail 1. A better shop update algorithm... Thoughts? Concerns? Questions? Well-deserved praise? Lol. 
I was wondering what was going on. I was rebuilding a VM that I had left alone for a while and it kept giving me an error going something like this: &gt; pip's wheel support requires setuptools&gt;=0.8 Took me a while to figure out that I hadn't pinned my Pip version to 1.4 in my provisioning script, and a new version had come out. Anyone have an idea what might be the deal with that?
If you are going to be including random developers in the project, you should set up some base requirements for the project. If you have a core group of developers or a group of the most experienced developers, talk with them about what tools should be used in the creation of the project. Whether you need Python 2.x or 3.x and what other modules will be required and what not. While the project is in the early stages, you should get everyone the correct base for them to work on.
Okay. Thanks for the tip :)
This is more or less a classic AI classification problem. Whether it is vegetarian or someting else does not really matter. The essense is that there is a corpus, and you need to classify the current datapoint. Very broadly, your choices are: * Write a learning algorithm which is able to teach itself what is vegetarian and what is not. * Classify every ingredient as Vegetarian or not, or find a database that does this. * Some hybrid of the two. 
It's not a question of terminology. The claim you can substantiate is much less important and impressive than the one you made.
that really sounds like something someone would already have done ;) so search for those tables/lists/databases. Might save you a lot of time
The good news is that for each of the most popular ingredients you classify, you will increase the number of covered recipes dramatically. With not too much work, you will cover lots of recipes. The bad news is that there will be a [long tail](http://en.wikipedia.org/wiki/Power_law) of many less common ingredients that would take forever to classify.
Looks awesome :) I'm a fellow beginner to python and it looks legit :) *thumbs up* 
http://flask.pocoo.org/
Nice work. Could you provide your `namegen` module too? Is Percival a reference to Ready Player One? ;) *Edit:* Remark: instead of tabs you should use spaces everywhere. In your text editor you can set that TAB is replaced with 4 spaces (that's the recommendation).
Oh I've been searching!
Exactly. I was working on classifying 2-grams for the ingredients, but there were a few thousand in the _sample_ dataset that I was using. It'd take ages to do it manually.
Import order matters in the case of [future statements](http://docs.python.org/2/reference/simple_stmts.html#future-statements), for instance. From the doc: "A future statement must appear near the top of the module. The only lines that can appear before a future statement are: * the module docstring (if any), * comments, * blank lines, and * other future statements."
I dunno, Python seems to be rather well suited since the languages are fairly similar, and I've looked in benchmarks of similar projects and the performance impact can be negligible. Dart or whatever might be more modern, but I love Python and I see no reason no to use it if I can.
this gives me an awesome idea for a multiplayer text adventure game...
I'm hesitant to do that, since as I said in the comment above, most of the generators aren't my own work exactly (and my code doesn't credit the original sources, I don't even remember what most of them are!). What's the protocol for things like that? Percival is because my IRC nick is sirpercival. Which is based on one of my favorite D&amp;D characters from back in the day.
I'm using XCode, and it's just easier to press tab. I dunno. 
I pop in every now and then to nudge about this. Radioreddit is the one place I'd love to hear awesome quality through my phone and my PC... these musicians really are good. 
Without that file we cannot try it :(
Not really what you are looking for, but while you wait for a better answer you could checkout [zipline](https://github.com/quantopian/zipline) and [Quantopian](https://www.quantopian.com/). Quantopian has a beta program for live trading as I recall.
Sure, you must press TAB, but you can tell the editor to *replace* a TAB with 4 spaces. You don't need to press 4 spaces, you can continue using TABs.
Yeah there are some incredible talents on there, I wish we did a better job of showcasing them honestly...which is what we aim to do. In all seriousness I am blown away on a daily basis by the caliber of truly independent music across all genres. The opus codec seems very cool also. Ofc quality of streaming is important to us and it seems at first glance it actually offers a lot of important options as well. Working my way through the video now. Seems like a pretty important project. 
no it doesn't.
its better to always have them on top(even if only called once). its also mentioned in pep8. http://www.python.org/dev/peps/pep-0008/#imports. 
This is an awesome idea. I first heard about it about a year ago and instantly posted to /r/radioreddit asking them to implement it. I got a lukewarm reply. With that said, I think that redeveloping for a v2.0 is the ideal time to really explore what the Opus codec can do. And it's a win/win if the public hears of it and wants to check out what it sounds like... by going to the radioreddit app first every time. Exposure for the station, exposure for the performers, minimal bandwidth. 
Yeah, it does. Next I have to figure out how to comment using it. 
just so you know, there is a subreddit for testing bots and clients (/r/test)
Great points. We are digging into it big time right now. 
I've never really dealt with relative imports (as in the ones from [PEP 328](http://www.python.org/dev/peps/pep-0328/)). I would have used just `import nothing`, which does work. I assume that the relative import does something different and desirable. That being said, apparently relative imports aren't supposed to work from the main module, because they use `__name__` to find path information. See PEP 328, [PEP 366](http://www.python.org/dev/peps/pep-0366/), and [this SO question](http://stackoverflow.com/questions/11536764/attempted-relative-import-in-non-package-even-with-init-py). The `site`+.pth method does work with the posted answer (`cd the-directory-with-main.py; python2 -m sub2.utils`).
alright, I'll drop it [here](http://pastebin.com/KGtdhWkc), buried in the comments so it's not so obvious XD sandgen() is not included in this file, so I would take that part out and just put in "a very tasty sandwich" instead.
I use Python 2.7 but recently I decided to do a small transition towards Python 3. From now on I want to add this line to the top of every new script: from __future__ import (absolute_import, division, print_function, unicode_literals) So, `import nothing` works in Python 2.7, but in Python 3 (and in 2.7 with `absolute_import`) it doesn't work. I posted here another comment with a hackish solution that works for me. However, that's quite ugly...
PEP-8 is explicitly optional and only exists to settle disagreements over style. Since OP is doing this solo, his/her preference gets priority.
The code would be a lot easier to read if your functions, classes, and methods had docstrings.
I don't know what to tell you. It works me. $ 7z x ~/proj-C.zip $ cd C/sub2/ $ sed -i "s/from . //" utils.py $ python2 utils.py 3.14 hi from helper nothing $ python3 utils.py 3.14 hi from helper nothing BTW, I have that same `__future__` import at the top of just about all of my files too. It's really good for making 2to3 work better and minimizing porting issues.
I fail to see how that makes any difference whatsoever.
I initially held out on moving from tabs to spaces, but it's the right way.
You can launch `utils.py`. But now step back to the parent and try to launch `main.py` with python2 and python3. You will get an error.
If you could also figure out how to stop spamming useless crap that'd be greeeeaaat.
Oh, thanks!
yes, that's true. I'll go through and write some over the next couple days... I just decided to post this today, so it isn't documented very well...
irony!
If you ever remember, I'd love to see that. I'm using Pyqtgraph due to need for speed, but as most users will already have Matplotlib installed, that's one less dependency to worry about.
Indeed. You can do `import sub2.nothing` and it works for everything. Or figure out how to use PEP 366. 
well it would be irony if you saying little directly caused it to be larger.
It might be easier to read if you split it into multiple files.
If you're thinking about MySQL, please consider PostgreSQL.
What's the first?
Well, there was this guy with two dicks...
Oh yes, the guy that made an AMA!
Package managers aren't the solution. That's not to say conda and wheel aren't great; they are! ...but for non-technical folks, the barrier to entry in installing and running the package manager is insurmountable. The python distribution story *is* as messed up as I described, people need to stop fooling themselves. Having a great packaging system will never make python better to use as an application development language! All it does is make life easier for *developers*. Pyinstaller is a mess. It currently can't even pack anything which has a shared namespace, which is, oh... anything that uses zope.interface. Or that as a dependency, like say, twisted, or tornado. Or sqlalchemy. If you've seriously managed to ship rich-UI applications, I take my hat off to you. I've literally *never* had a project that didn't have issues and problems when it came time to try to package it up that way; I love python, but I stand clear of it for UI applications these days, especially if all you need is a little shoddy UI to share around the office; C# is just fine for that sort of trivial task. I'm not saying don't use python; I'm just saying, pick your battles. This isn't pythons strength. If that's what the OP needs, maybe it's not the right choice. 
I think that this is the direction we are leaning. 
Also pyalgotrade
ok, so as i said below, i'm working on splitting this across multiple files and putting it on GitHub as a normal .py thingy. So we'll see how that goes (oddly enough, I've never written a program in Python with a main function...).
You upgraded pip but not setuptools. Please upgrade setuptools. Note if pip is not working for you now because of this, you may need to manually install setuptools by downloading/extracting the source and running "python setup.py install" This is also true for users of systems like [Anaconda](http://continuum.io) where the included venv support currently installs older versions of setuptools/distribute.
Cool, pip still doesn't support pip home &lt;package&gt; pip info &lt;package&gt; pip pypi &lt;package&gt; Awesome! How about the pip devs just copy all the features of `homebrew` and then get back to us. Just checked, https://github.com/pypa/pip/issues/33 still isn't in pip 1.5, at least it doesn't work in my upgraded version. 
That's what I came here to say... I'd separate it out logically so you open one file to add a quest, one to edit monsters, one to edit character skills, that sort of idea. Looks fun just by skimming it though!
pip install pip --upgrade 
Similar to zipline though, [pyalgotrade] (http://gbeced.github.io/pyalgotrade/) is for backtesting strategies with historical data. That's cool and all but it doesn't let me implement new trades live through a brokerage. 
Yes it is possible. Ingredients listed in commercial products are classified by the FDA and here is their database (http://www.ars.usda.gov/Services/docs.htm?docid=22771). I have already converted this to CSV and I have an API to query it. I am planning to release it open source as soon as I find the time to document it.
That's awesome! Let me know once you OS it so I can contribute!
posting to use this later on my other laptop. Looking forward to testing it out!
Please, please use spaces. Tabs vary per editor and can brutally distort the readability of your code.
ror and any major php framework can get you that far in minutes... just a few commands and you're there. django isnt nearly as far along. python has the edge in data science, but its still behind java tech. netflix is straight java for a reason.
Neat post. I got bored and converted it to readable python: http://pastebin.com/heYc5XnN Couldn't really figure out what it did without knowledge of bitcoin or ECC, though.
https://github.com/pypa/pip/blob/develop/pip/_vendor/requests/cacert.pem
Link the GitHub once it's all live so we can help!
Consider [Sublime Text 2](http://www.sublimetext.com).
If you do open source it, please add an acceptable license to it. Here's a [discussion on stackoverflow](http://stackoverflow.com/q/16933385/86263) explaining why.
Interesting. Care to outline how one might go about writing such a "learning algorithm"? I was thinking something along the lines of breaking down foods into their chemical components and then determining if the right chemicals to make up gluten exist in the food. But, in that case, I would still need a database of foods =&gt; parts =&gt; smaller parts =&gt; chemicals and of gluten =&gt; smaller parts =&gt; chemicals.
Why doesn't homebrew copy all the features of pkgsrc and get back to us in 1997?
You will have to use a broker api for that depending on where you trade
The irony is that in python 3, `class Monster:` is the shorter way of writing a normal class derived from `object` :)
Rapydscript looks extremely lightweight, and the generated code looks very similar to the source code, competely different from tools like Pyjs/Pyjamas: http://rapydscript.pyjeon.com/?q=uOHNRK Assuming it works as advertised, I would gladly have an extra step to get more readable source &amp; make inheritence easier/more obvious.
Looks like you have the problem described here: http://stackoverflow.com/questions/19531969/segmentation-fault-11-in-os-x That thread includes a fix.
wow, such wrong. No, both print i and print(i) works fine in python 2.x
Thanks pal, that worked.
how long did it take you to make this game?
&gt;pip no longer will scrape insecure external urls It should never have done it in first place: it's such a bad design flaw from security/system design. 
When you install pip for the first time, you can do it from an official repo with `sudo apt-get install python-pip`. However, it's very likely that it installs an older version. So, for me the next step is to update pip using pip itself: $ sudo pip install pip -U Where `-U` means update. Now you have the latest pip and you can proceed with Step 2.
 * No more than 3 levels of indentation for ... : for ... : if ... : for ... : is a no-no. You should really rewrite function item_type(item) 
&gt;on non-beginner projects, 'tab' is the go-to Heh, no. Tab is objectively worse. The only reason you might prefer it is if you were trying to code in notepad.exe or something.
Nice post, but some words of advice: never generate your private keys without knowing: source of entropy of the prng and the prng method.
makes sense. I will start off quickly. This is what I have planned to get started: - I will try out the code, see how I can deploy using it - I will read full documentation - Try to build a simple app using the framework. =)
Oh, you're one of *those* people. You're one of the handful of people who think it's better for `print` to be a statement. Don't assume you're the majority. Oh, and it wasn't done to make it "look" like a function. It actually is a function now, and it was done because it was genuinely harmful that it wasn't.
a couple weeks to get to its current version.
it runs via the Phenny IRC bot. if you have a phenny clone running, you can load it into the bot like any other phenny module. I'm working on something you can run from the python command line, though.
It uses requests', which uses mozilla's.
&gt; Use packages. I'm splitting this into multiple files to improve readability... hopefully that's sufficient, since (when I read your comment) I looked over what exactly "packages" are in python and it's damn confusing! lol. &gt; Use pylint This... looks very cool. I'm going to read through it and probably use it. &gt; Use comments Yeah... I'm terrible about documenting my code in general... XD I'm at the very least adding docstrings to all the functions. &gt; Move strings (aka resources) into external files. I'm doing some of this by grouping the many dictionaries into the files for which they are relevant. Would you recommend a specific further step? &gt; Stick to 80 col width Seems like something pylint can help me with. &gt; Use actual names for things, instead of shrtNmsWthCmlCsWoVwls or unhelpful variables when you're not within a loop (ps: even within a loop a good name is worth so much more). This isn't the 80s and you don't get extra points for short unreadable variable/function/class names. Yes I'm doing some of that in the rewrite as well. &gt; Move it to github instead of pastebin Working on it! Never used github before but it doesn't seem too complicated. &gt; Post a demo of the thing being run, that would be much cooler! And, probably the biggest question most of us have (that aren't gamers) is what does this thing actually do. Haha! I'll definitely do that. Basically the way this works is you generate a character, then wander into a dungeon and kill monsters for gold and glory. It's all text-based. &gt; [Edit 1] &gt; Please, for the love of all that is pythonic, use new-style classes: class Monster(object): instead of class Monster: I will figure out what this means, and then do it!
Will do. EDIT: I'm going to assume you didn't intend the double-negative?
And `pip install -U setuptools ` while you're at it.
How is it different from project [six](http://pythonhosted.org/six/)?
I vote on vim.
This looks like a very promising approach. I would think though that some Python 3 constructs cannot be used in Python 2, even with python_future, because of syntax errors : x = print('hello world') x = yield from y If confirmed, it should be clarified in the documentation.
There's also yummly.com . i believe they offer an api. 
&gt; code that's required when using six ends up being pretty ugly That's because six tries to support every version &gt;= 2.4 which is generally recognized as a herculean task, and thus requires uglifying your code to a great degree. It has long been acknowledged that the sweet spot of cross-version Python is supporting only 2.6, 2.7, and 3.3 (and later.) If you can manage that requirement, you can more or less write compatible code by hand without a terrible amount of work. It's the approach that most projects have taken or plan to take, and it seems that it's the same approach that this library takes as well. 
why not paste here? import os import re import hashlib import binascii KEYSPACE_SIZE = 2**256 # ? LARGE_CONSTANT = KEYSPACE_SIZE - 2**32 - 977 # ??? # &lt;?????&gt; def V(W, Q=LARGE_CONSTANT, L=1, O=0): if W == 0: return O % LARGE_CONSTANT return V(Q%W, W, O-Q/W*L, L) def M(W, Q, R, G): V1 = (W*W-Q-G) % LARGE_CONSTANT V2 = (W*(G+2*Q-W*W)-R) % LARGE_CONSTANT return (V1, V2) def A(W, G, J, S, T): if W == 0: return (S, T) G2, J2 = M(3 * G**2 * V(2*J % LARGE_CONSTANT), G, J, G) if W % 2 != 0: S2, T2 = S, T else: if S: S2, T2 = M((J-T)*V((G-S) % LARGE_CONSTANT),S,T,G) else: S2, T2 = G, J return A(W/2, G2, J2, S2, T2) # &lt;/?????&gt; def binstr_to_int64(binstr): return binstr_to_int(binascii.a2b_base64(binstr)) def binstr_to_int(binstr): return int(binascii.b2a_hex(binstr), 16) def int_to_digit_list(number, base = 58): if number == 0: return [] return int_to_digit_list(number / base, base) + [number % base] def sha_hash(binstr): return hashlib.sha256(binstr).digest() def int_to_binstr(number, byte_len = 32): if byte_len &lt;= 0: return "" return int_to_binstr(number/256, byte_len-1) + chr(number % 256) def binstr_to_printable(binstr): binstr += sha_hash(sha_hash(binstr))[:4] # ??? printable_str = "" printable_chars = [char for char in map(chr,range(123)) if not re.match(r'[0OIl_\W]', char)] while binstr.startswith('\0'): # ??? printable_str += "1" binstr = binstr[1:] for digit in int_to_digit_list(binstr_to_int(binstr), base = len(printable_chars)): printable_str += printable_chars[digit] return printable_str def main(): address_hash = hashlib.new("ripemd160") private_key = binstr_to_int(os.urandom(64)) % (KEYSPACE_SIZE - binstr_to_int64("AUVRIxlQt1/EQC2hcy/JvsA=")) + 1 S, T = A(private_key, binstr_to_int64("eb5mfvncu6xVoGKVzocLBwKb/NstzijZWfKBWxb4F5g="), binstr_to_int64("SDradyajxGVdpPv8DhEIqP0XtEimhVQZnEfQj/sQ1Lg="),0,0) address_hash.update(sha_hash("\4" + int_to_binstr(S) + int_to_binstr(T))) print "Address:", binstr_to_printable("\0" + address_hash.digest()) print "Privkey:", binstr_to_printable("\x80" + int_to_binstr(private_key)) if __name__ == "__main__": main()
I also upgraded `setup_easy`,`easy_tools` and `toolsup` is there anything I missed?
You're comparing frameworks to languages, that's why you're confusing everyone here.
I'm glad there's some competition for six and python-modernize, but as this stands I wouldn't use it, at least not in the form shown in the Overview page. Redefining builtins just seems too magical. This is designed to try very hard to let Python 3 code run on Python 2. But many more projects still have Python 2 code and want to start supporting Python 3 - changing all your code *and* adding a magic shim to keep Python 2 support doesn't seem like a great option. For projects written in Python 3 that want to support Python 2, it's more appealing, but I'd still recommend importing parts of it as needed, rather than `from future.builtins import *` - at least then you can see what you're replacing. Also, have a look at the [future_builtins](http://docs.python.org/2/library/future_builtins) module.
OK I'm storing all my dictionaries (particularly from the namegen module) into external JSON files. Does that help with your resources suggestion?
I'm not sure about yeild but print("your string here") is syntactically valid in python 2. Edit: The above is true but is not what Pcarbonn was talking about.
as a statement, yes, but not as a function in an assignment.
Hey, good idea!, the UI still needs work, but the basics are there. good work. Do you have any plans on make it open source? 
For Python 2.7 you ran try https://www.pythonanywhere.com/try-ipython/ and http://www.repl.it For Python 3, the best I can think of is a cheap linux box on Digital Ocean. They run $5 a month and you can easily find enough coupons to make your first 2-4 months free.
Ah, got ya.
Webalchemy is easy to use and a good fit when you need lots of interaction between client and server. It's very new and there's no documentation except a few examples, so that's the major downside. you can host on heroku. https://github.com/skariel/webalchemy 
Thanks for your response! Currently, I have no plan about it because I have to get some money. But If this service is dying, I'll make it open source . 
&gt; it's clear to me that python 3 has some huge errors (mostly around bytes and unicode) Could you elaborate on that?
pip did that because setuptools/easy_install did that. Setuptools/easy_install did that because originally PyPI didn't allow uploads and it was designed to be a human usable index of packages. PJE came along and started scraping the human usable index pages looking for things that could be installed, including the linked home and download pages. Over time an installer focused index page (found at /simple/) was created to cut down on bandwidth costs but the core functionality was still the same. Recently we've begun cleaning this up and this change was one of these changes to move to a much saner position. So yea, it sucked, especially from a security standout, but it existed for a reason that is no longer very applicable.
This looks well put together and clean and, were I to redo the pandas 2/3 compatible codebase, I'd want to use this. That said, I'm concerned because in reviewing some of the code I already found a bug and it feels like some parts are a bit thrown together (maybe because of how the merge was done). I'd want to wait 3-6 months before using it in production. I also really don't like `from future.builtins import *` as an idiom. Kills much of the ability to do static analysis and trace from where particular items came.
This looks like a job the *set* data structure. If *food* and *meaty* are sets, then the set *food - meaty* is suitable for vegetarians. The *meaty* set is the union of *beefy*, *chickeny*, etc.
My background is C#, Java (desktop and Android), Python, PHP, etc... when I looked into Django I felt like I was about to use another Joomla/Wordpress/whatever-attempts-to-do-it-all-for-you-and-is-ridiculously-bloated-as-a-result. If I was simply needing to whip out a simple site and didn't want to screw with it I probably would have gone the Django route. Instead, I do have time. I am seriously falling in love with how elegant Flask is every day I work with it. I think I have made the right decision to go the Flask route... my only real concern left is long-term stability. I think though that enough people, myself included, like it enough that if the dev decided to abandon it, Flask would live on.
I'm the author of [introtopython.org](http://introtopython.org), and I'm happy to answer any questions about this tutorial, or about the overall introtopython project as well. Thanks for sharing it!
Flask is pretty good. http://flask.pocoo.org/
Thank you for the excellent reply! You have definitely given me many things to think about. I have been messing with Flask for about a week now and I'm digging it for sure. I agree, the Blueprint thing is interesting. I don't know how that is going to end up TBH. We shall see I guess. I'm thinking that once I get what I am working on in a working (but prototype) state, I'm going to switch gears and use Pyramid to build the same thing and see which I like the best. One question, was getting Pyramid to deal with return a JSON API a big deal? I saw somewhere else (IIRC) that it wasn't quite as easy as it is in Flask. I'm thinking it shouldn't be too much of a pain.
[Digital Ocean](https://www.digitalocean.com/) gives you a VPS for $5/mo. [Heroku can also use Python3] (https://devcenter.heroku.com/articles/python-runtimes) and has a free tier for small sites.
Free tier Amazon EC2.
You make valid points. The rich client world is not as "sexy" right now as the web dev world, and pyinstaller/py2exe/py2app etc. do not get the love and attention that random web-oriented projects get. But, they are much more heavily used than people give it credit for. In the past, I used an in-house mechanism that was put together by the author of EPD (and now, Anaconda &amp; conda). On Mac, it had a working minimal .app which then would get the relevant packages and startup scripts injected into it. I forget how the .MSI installer got put together now, but it was similar. We didn't use the slipstream stuff, but instead used our own payload &amp; post-install scripts. (This is due to MSI's internal database limitations on number of files, etc.) Hopefully with Anaconda Server and some of the things we're working on, this situation will improve over the next year or two.
"Replaces" how? `str` didn't go anywhere. Python 3.2.3 (default, Mar 1 2013, 11:53:50) [GCC 4.6.3] on linux2 Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; for i in "foo": # This is a str. ... print(i) ... f o o &gt;&gt;&gt; for i in b"foo": # This is a bytes. ... print(i) ... 102 111 111 
http://python-future.org/faq.html#what-is-the-relationship-between-future-and-six
&gt;Have you worked on a project in which a tab width isn't 4? Never.
`str` became what `unicode` was, which is great if you work with text at a high level, but if you work with low-level I/O that actually requires a sequence of bytes instead of Unicode codepoints, you have to switch everything to bytes and prepare for different behavior.
Does it ever return a meaningful value that someone would be actually be assigning to a variable? A more likely case of syntax that only works in Python 3 is exception chaining raise exception1 from exception2
bytes are not the same as strings. It was a mistake to ever consider them equal in python2, and thats part of the reason why python3 is not compatible. &gt;&gt;&gt; "Hello, World!".encode("utf-8") b'Hello, World!' &gt;&gt;&gt; "Hello, World!".encode("EBCDIC-CP-CH") b'\xc8\x85\x93\x93\x96k@\xe6\x96\x99\x93\x84O' &gt;&gt;&gt; Not to mention that "some string here {}".format("hello") still works, as does the % overload... 
OP came here for suggestions (which is a clever idea). His project is good but if you look at the comments, he has a lot of work to do to polish it and make it a nice project. Since most people use spaces instead of tabs, and he started Python just 4 weeks ago, I think he should follow the crowd and use spaces too. PEP8 is there to be followed, it gives good practices. Most people (try) to follow it. OP should do the same IMO. He has no big experience yet with Python (that will change with time), so in his case we cannot really talk about "project-specific guides" that "take precedence".
I work with tab width 4 because this is my setup in my text editors. In a new env. I do this each time, then I can start working. TAB is 8 spaces by default, which is too much. Google used to use 2 spaces, but AFAIK they also switched to 4 spaces recently. For me the punishment is to see TABs ("\t"s) in a source, that really hurts my eyes.
But you *should* have to deal with text encodings yourself if you're working with bytes. Why on earth shouldn't you?
Try `type(u"")`. 
Yes, it turns out that if you want to work with something as a string, it needs to be a string. Mixing things that are strings of characters, and things that are sequences of bytes which may be interpretable as characters in some encoding, leads to madness.
I certainly agree, they aren't the same, and python3's direction was an excellent step in forcing programs to have some clarity on the matter. But removing % from bytes prevents using % to format already encoded data, where no such ambiguity about encoding exists. Now that I type that out though, I suppose that's probably a really minor border case... one worth sacrificing :( in order to force programmers to do the Right Thing in the more general case, where the formatting should be done under unicode.
It's valid in 3.3. The `u` prefix is treated as valid and ignored in 3.3+ as a backwards compatibility measure.
You are making the common mistake of assuming that you can treat a bytestring as characters. That is what gets people into messes and causes so much pain and hardship. Bytes are bytes, characters are characters. You can't treat bytes like characters or vice versa. Python 2.x's default string type (`str`) is a series of bytes, not characters, but the fact that you can pretend that it's a series of characters is a source of neverending pain. Disallowing what you're trying to do is exactly the right thing to do, because it forces people to be explicit about decoding bytes into characters before doing character-oriented operations on them. 
Yes, you have to read and write bytes, and if you want to interact with them like strings you have to decode them with some specified character encoding. (Although in most cases you can arrange for that decoding to be handled automatically.) But that's kind of the whole point -- Python 2 let you be lazy and skip that step where you specify what encoding you want to to use to convert bytes to characters, in essence adopting ASCII as an implicit encoding by allowing bytes to be treated like characters as long as they are in the ASCII range. But text in the modern world is not ASCII and that sort of lazy thinking is responsible for creating a large amount of software that is utterly incapable of properly dealing with text. By forcing you to deal with the reality instead of authorizing laziness, the result will eventually be software that has a fighting chance of working properly with text. 
Amazon Free Tier EC2. Free for first one year. Or for lazy ones, Heroku. 
Yes, I'm one of THOSE people. The people who think that simpler is better than more complicated, that believe that backwards-compatible (And thus, WORKING) is more important than how it looks. So, enlighten us, just how is a working print statement "genuinely harmful", when the new version that breaks so much code, isn't?
i dont even understand why you would want to do % on bytes, it has no idea what are the 'marker characters' to use as the format string, as the normal printf style specifiers that you use in strings are suddenly potentially different for every encoding &gt;&gt;&gt; print("Test %s" % "hello") Test hello &gt;&gt;&gt; print("%s".encode("utf-8")) b'%s' &gt;&gt;&gt; print("%s".encode("EBCDIC-CP-CH")) b'l\xa2' &gt;&gt;&gt; print("%s".encode("EBCDIC-CP-CH")) b'l\xa2' &gt;&gt;&gt; # what bytes do you use as the %s? b'%s' or b'l\xa2' ? 
&gt; Seven bit ASCII runs the world It most certainly does not. Even when you're dealing with pure English text, ASCII is not sufficient -- typographical elements like em dashes, apostrophes, left and right quotes, etc. are very common. Claiming that ASCII is sufficient in 2014 has got to be the programmer equivalent of claiming the world is flat. The world moved on. Python did not "break" anything, it merely exposed your undisciplined and lazy thinking about what characters actually are. 
&gt;Yes, I'm one of THOSE people. The people who think that simpler is better than more complicated, that believe that backwards-compatible (And thus, WORKING) is more important than how it looks. No, you're one of those people who are too arrogant to view the Python devs as any more educated than fools who would go into changes like these to make it look pretty. Personally I think that's insulting, hence the tone. Nevertheless, some advantages of a print statement (aka. those that take me a few seconds to think of): * Simpler AST * Allows local replacement of the print function (say, to a `logging` equivilant), and globally through its binding in `builtins`. This primarily helps testing and debugging. * Allows usage inside expressions, removing the incomplete `def _print(x): print x` hack. * Allows mapping and currying * `print` is now more powerful with more options, primarily by allowing unpacking, `sep` and `end`. All of these have directly affected me, never mind the millions of other Python programmers out there.
&gt; You are making the common mistake of assuming that you can treat a bytestring as characters. WHAT?!! Is that why I have so much of a problem...why don't they just say that?!!
&gt; But you should have to deal with text encodings yourself if you're working with bytes. Why on earth shouldn't you? Because this works... &gt;&gt;&gt; "5=%s" % 5
Good point. Darn you EBCDIC! In the contexts I was thinking of, the encoding could be relied on to be an ASCII-superset. EBCDIC &amp; UTF-16 always pop up to derail things in the general case :) 
that's a purely academic distinction that has little to do with the realities of architecting a system. comparing languages without frameworks or libraries is meaningless in the real world. it's like comparing cars without engines. in other words, a language includes the best and worst of its commonly used frameworks. honestly, how often do you see a web stack use ruby but not rails? how often do you get a project where specs say "you are not allowed to use any frameworks, libraries, or codebases that have been written before... you must code everything from scratch"? anyone CHOOSING to do that electively has a serious case of expert beginnerism, or is just an outright beginner. ruby + rails &gt; python + any python web framework. php + any major php framework &gt; python + any python web framework. django is currently the leading web framework for python and it's still years behind.
Yep, we were wanting to make the switch.
It is not pointless. What you are really saying is that you are working with characters encoded in ASCII, so you just need to say so: with open('filename', 'r', encoding='ascii') as file: for line in file: ... Or for sockets: sock = socket.socket(...) sock.connect(...) for line in sock.makefile(encoding='ascii'): ... Voila, you're automatically dealing with character strings, not byte strings, and you can do all the things you expect to be able to do with characters. All you had to do was specify the encoding, Python takes care of the rest. And the examples don't change if you're using UTF-8, CP1252, UTF-16, ISO-8859-1, or god knows what. The point is that you must state your intentions; the era of ASCII being given a free pass has ended, and for good reason give the amount of confusion it creates. ASCII is just one of a hundred various encodings that you might want to use to interpret bytes as characters, it holds no claim to special treatment. 
Its validity wasn't my point. (I was counting on you using 3.3 because I didn't look at your interpreter version line closely enough. Side note: Don't use Python 3.0, 3.1, or 3.2. :-P) My point was it returns `str` not `unicode`. Python 2's `unicode` was renamed to Python 3's `str`. Python 2's `str` was renamed to `bytes`, but it also lost a lot of methods that it used to have. The lack of methods on `bytes` is the thing people complain about.
You said this: &gt; but it's weird. For example, if you iterate over it, you get the integer value of each byte, not a character. It's not weird at all -- you shouldn't *expect* to be able to do that, because it makes no sense. The fact that Python 2.x allows iterating over a byte string and getting characters is what is weird; it sets up these false expectations of how bytes and characters interact that is very unhelpful and must be eventually unlearned whenever you want to work with anything that isn't ASCII. 
It's valid, but does not always behave identically to py3k's print function. E.g. `print('a', 'b')`.
I am not sure exactly what you are responding to here. You can refer to the comments made by earthboundkid for some examples of the weirdness... I suspect that you have not really done all that much programming that involves ASCII strings used in a purely functional way, not as a representation of some human language...
I have no idea what this handwavey made up term "purely functional way" means (give an example in actual code), but I assure you I have done every kind of programming under the sun and I don't find Python 3's model in the least bit restrictive. In fact I find it refreshing and intuitive, and (as of 3.3's new flexible string representation) one of the only mainstream languages to have a proper model for how to deal with characters and bytes. Nearly every other language fails miserably, except possibly for Perl and Go. 
I know that mixing characters and bytes are bad, but neither of those are strings of characters. People who work on I/O often want to make format strings that operate on bytes. For example, if you are working with HTTP headers, you need to build up formatted things that are defined to be made of bytes. This doesn't even apply to my code most of the time, but it slowed down the porting of many of my favorite libraries such as Flask.
What you're saying is a great argument for why Unicode should be the string type. And I know that considering bytes and characters to be equivalent is sloppy and causes bugs. Your argument is exactly right when the data you are working with is text. However, I was talking about situations where you are working with bytes that *are not* supposed to be interpreted as text. It's a corollary of the fact that text and bytes aren't equivalent. Some text shouldn't be thought of as bytes. Some bytes shouldn't be thought of as text. In Python 2, some old ugly standard libraries that don't understand Unicode force you to pretend text is bytes. That's bad. Python 3 fixes it. In Python 3, some new standard libraries force you to pretend bytes are text, even when they aren't. That's also bad. I prefer Python 3 to Python 2, but really, Python 3 could have been more helpful in that use case than it is.
no worries -- actually this was the kind of thing i was looking for. :) my code is getting much more robust from the re-do, which is maybe half done. i have a github repo for it, but i haven't updated that since i made it, so the stuff is just sitting on my machine at the moment.
can i ask why i WOULDNT want to use autobahn with twisted ?using an event driven framework w/ something that all about events seems to make sense 
I'm surprised it compares itself to Pyjamas. I think of Pyjamas as a port of Google Web Toolkit. RapydScript sounds like just a python-like to js compiler.
&gt; This is designed to try very hard to let Python 3 code run on Python 2. But many more projects still have Python 2 code and want to start supporting Python 3 - changing all your code and adding a magic shim to keep Python 2 support doesn't seem like a great option. It claims that you do NOT need to change over all of your code. You can write new modules in "future" mode and leave your old modules in Python 2.x. As you update or replace them for other reasons, your Python 2.x code base will shrink. Also, your new code will be compatible with both your old Python 2.x projects and your new Python 3.x projects. &gt; For projects written in Python 3 that want to support Python 2, it's more appealing, but I'd still recommend importing parts of it as needed, rather than from future.builtins import * - at least then you can see what you're replacing. It's well documented what you're replacing! 
This was a well-crafted, thorough tutorial. I look forward to seeing what else you do for the projects section. 
Not everyone likes twisted dependency or datamodel. Its is nice that one has options.
Twisted is as much for writing servers as clients. If you absolutely want a requests-like interface, you can try treq.
Consider [web2py](http://www.web2py.com) perhaps.
Fair enough. The underlying oddity is that Python has no concept of a character or a byte, just strings and bytes, so indexing a string gives a string. Based on that you'd expect to get a `bytes` of length one.
many, many years ago they systematically spammed delicious with a ton of shit, to the point where i had to ban them from public search results. i'm not at all surprised.
Torrents seem like the only way to host large content these days
[Here](http://bugs.python.org/issue3982) is an issue in the python bug tracker where twisted &amp; mercurial devs want to use bytes.format to help porting. The main use case seems to be protocols (e.g. FTP) that mix 7-bit ASCII with binary data. 
It currently meets my demand. I'm really not trying to check if is there anything better. I just want to know from people that started with bottle, when they faced the growth challenges, if they stick with bottle and it was able to support them so far. I'm rally happy with Bottle and wanted to hear from others.
Just verified this myself. Frameworks that support 3.3 (Django, Flask, Bottle) are available for 3.3.
_from folks that use &amp; like BottlePy_ &gt; BottlePy is the Sh*t! _from folks that don't use or don't like BottlePy_ &gt; WTF, BottlePy? That's basically what it boils down to. The right tool for the right job, and maintaining legacy code in a way that doesn't blow things up either now and later. Framework wars or "Yay, X-Framework is awesome" sessions are probably fun if you're a fan of X-Framework, but those threads are less productive than if you were addressing a specific concern about the framework. Maybe something like "can BottlePy support 10^3 / 10^5 / 10^7 req/sec" would be more useful. Or "can BottlePy work for middleware just as well as for web stuff?"
I used pyramid + gevent with socketio + angularjs on an arduino project for the user interface. With those tools I could push updates from the server to the user interface and back. Such as temperature updates as well as a button that turned a light on and off. I had a separate process running that communicated with the arduino and the web framework processes(es) though. What are you using to communicate with the Arduino ?
Bottle does what it does very well. It is [fast](http://www.techempower.com/benchmarks/) and [extensible](http://bottlepy.org/docs/dev/plugindev.html) and does not force anything onto you. The web framework is probably only a very small part of your infrastructure, and that is a good thing. Bottle is more a library than a framework in that regard. You do not build applications *for* bottle, like you would do with Django or Ruby on Rails. It is just one of many libraries you use in your application. If you like that, keep it. If not, you can switch any time. Your application code does not depend on it (hopefully). Disclaimer: bottle.py suits *my* needs very well, I wrote it. 
Interesting article and cool use case for the inspect module. I would never recommend this, but couldn't one just use the type function directly to achieve this sort of behavior? def Foo(**kwargs): return type('foo', (actualClass), kwargs) And have all of your class methods defined in the passed "actualClass". This would return an object of type 'foo', inheriting all class methods from actualClass with all key value pairs of kwargs set as attributes. I guess the main difference is that the attributes need to be passed as kwargs instead of args. And I repeat, I would never recommend this :). 
I saw this was fixed but I [googled segmentation](http://en.wikipedia.org/wiki/Segmentation_fault) fault and ended up learning a lot.
Very interesting. The combination of ugliness and "why do I need to think about this stuff?" of supporting both Python 2 and Python 3 in the same codebase has been holding me back of doing it. I prefer to simply write clean Python code. If future can make this code cleaner, it would be a good way forward.
*First para from linked [Wikipedia article](http://en.wikipedia.org/wiki/Segmentation_fault):* --- A **segmentation fault** (often shortened to **segfault**), **bus error** or **access violation** is generally an attempt to access memory that the CPU cannot physically address. It occurs when the hardware notifies an operating system about a memory access violation. The OS kernel then sends a signal to the process which caused the exception. By default, the process receiving the signal dumps core and terminates. The default signal handler can also be overridden to customize how the signal is handled. --- ^[(?)](http://www.reddit.com/r/autowikibot/wiki/index) ^| ^[(CC)](http://creativecommons.org/licenses/by-sa/3.0/)
Flask or Django is the way to go. I'm really interested on a project like that. It's a personal project? If yes, you will publish it?
I'll give it a look. I've been messing with Django, and while I like it, it's just a behemoth.
BitTorrent Sync seems as a little bit more user-friendly alternative.
Not for sharing videos to people, torrent support comes built in to most didtros, I don't want to have to add a repo to be able to download a file. Also you have to download every file and are forced to keep up with updates.
I had a problem at work that required I create a map from responses returned from the Maps API and played around with Vincent. It kept breaking and when I searched around for an alternative, found Basemap and your tutorial. Was surprised how easily I could map stuff (after following your instructions).
And you're one of THOSE people, the ones who think that any drivel is okay if they can't answer the question. For reference, the question (Based on YOUR statement, btw) was "just how is a working print statement "genuinely harmful""? Because breaking it certainly was.
If you use something on the back end that requires a different event model. ZeroMQ isn't well supported on twisted for example.
They suck. They brought down my channel with over 65+ tutorial videos :( These were tutorials of themes and plugin scripts that I developed and used to package the videos as instructional howtos. all gone. I should have used Youtube.
Hey! This is a cool concept. One easy win, I think, would be to find someone to spell- and grammar-check the website. A lot of it is hard to understand. In particular, I'm not sure I understand what the connection could be for finding videos based on star count...does it compare what sort of projects you work on with search terms, maybe? Like, finding JavaScript videos for people who work on JavaScript a lot?
Bottle.py is also a candidate and what I use.. 
I'm really happy to hear it helped you solve a real-world problem. Did you find the introtopython tutorial first, or the old version posted on my blog? ([peak5390.wordpress.com](http://peak5390.wordpress.com)) I'm just curious if introtopython is showing up meaningfully in google yet.
&gt; I should have used Youtube. This is such a weird phrase to hear in the middle of the ContentID debacle. Is Blip seriously just targeting Python content of all kinds, or are you and your videos affiliated with PyCon?
The best way to learn the relationships of the building blocks of a programming language is 1) write programs and 2) read the documentation. At first, you want to start small and make little toy programs then gradually build bigger and bigger programs as you get comfortable with the syntax. There's plenty of tutorials but this is a good place to start: http://interactivepython.org/courselib/static/thinkcspy/PythonTurtle/helloturtle.html#hello-turtles or this: https://www.khanacademy.org/cs/programming/good-practices/v/the-power-of-the-docs
So, some people relied on a free video hosting provider to serve their videos for free, for forever, and are upset when that fell short of expectations? Is that the beef? Or am I missing something?
The scripts and themes I mentioned din my previous comment were all written in PHP, Javascript and made use of MySQL database. Nothing Python in there. That is not the point. The thing is they delete stuff without sending e-mail notifications and even after removal they do not send any e-mail notification. Their support says they had posted a notification to my blip.tv dash board. the heck - why will anyone keep their dashboard open all the time unless it is something very very important.
Whaaaat the actual fuck?
Looks like a pretty forward case of someone taking their ball and going home. Fine. Just dont lure/invite the schoolyard next time by telling them they can play with your ball.
I've never understood this assumption. It would make more sense to me that larger frameworks would be slower simply because they execute more code for each response, all else equal.
To be fair, Java makes a very similar distinction with byte[] vs char[] (and the higher level String class) and demands a character encoding to convert between them.
What should be in the __init__.py file? Where does the main function go? I haven't run pylint yet, though I have it installed. I'll check out flake8 as well.
The conversion to/from bytes only needs to happen at the I/O edge. shit.decode(correct_codec) from the network, work with strings as strings, shit.encode(correct_codec) to drop it back on the wire. If you are continually encoding and decoding in the middle section, *you're doing it wrong*.
Don't be so judgmental. I'm talking about libraries that *are* the I/O edge.
`__init__.py` can be empty. It really just marks the directory as a package. If you want, you can put code in it. There's nothing really special about it other than the fact that every package has to contain one, even if it's empty.
I found the introtopython tutorial first. 
Also it looks like blip.tv has reposted the channel after all. http://blip.tv/pycon-us-videos-2009-2010-2011
Lastly, pyvideo.org links to the same content (for the first few that I checked) still work as well http://pyvideo.org
&gt; I'm talking about libraries that are the I/O edge. An entire library is not the I/O edge. The same rule applies regardless of what you're writing. File descriptors/sockets want bytes - read and write them with the correct codec. End of story. 
Hm...redditor for 15 hours with a single post which is a advertizement Sounds legit....
link? 
&gt; No, you'd expect to get a character. Applying an appropriate character encoding, that could be encoded as a bytes of length 1 _or more_. "Character" is an ambiguous term. It can mean either "one eight-bit number" (a byte) or "one Unicode codepoint" (Go calls these "runes" which is a decent enough name). Getting a codepoint from slicing `bytes` wouldn't make any sense. If you want codepoints, you'd be using `str`/`unicode`, not `bytes`/`str`. &gt; You are very obviously an English speaker because everyone else knows that bytes aren't characters Dude, I read the Joel thing about Unicode in 2005. I lived in Japan for two and half years. I picked the BOM out of my PHP files around the same time. Don't make presumptions.
So, I saw everyone was giving me a negative score and realized I posted a html parser. I apologize.
I love bottle py because of its lightweight nature. It's my go to for writing performant JSON and REST APIs. With bottle and gevent I have servers pushing over 500 reqs per sec per core (spike load testing shows it's capable of 3k reqs/sec for a 6-core VM.) It easily handles our average load of 160 reqs/sec. (Self-plug: backed by http://HumbleDB.readthedocs.org and MongoDB) That being said, I wouldn't use it for a full blown site - frameworks like Django offer much more for your time and efforts over piecing together a stack from different projects. 
UTF8 should never have been implemented to be fair. It has led to too much cavalier thinking.
&gt; "Character" is an ambiguous term. It can mean either "one eight-bit number" (a byte) ... This is not true. Characters are concerned with language, not math. The number of bits is just an implementation detail of the character set. There are some character sets that define 7-bit characters. Even in C, the number of bits in a `char` is platform-dependent.
It would appear that you're getting downvoted because people disagree and forget that isn't what downvotes are for.
I always wonder why quite a few Pycon videos were hosted on blip.tv. It is an unreliable service. The videos often do not load properly or slowly when accessed from outside US. And now this.
this is kinda what i was looking for . thanks! Ive used twisted for zeromq but i found the built in factory to be clunky and ended up using someones client lib from github instead.
What experience do you have with other (which?) programming languages? 
Great answer! Well though points, good to learn that the performance hits he's afraid (like unnecessary copies and allocations) are easier to avoid on modern python.
[Folium](https://github.com/wrobstory/folium) might be of interest. 
You may want to use the new asyncio module, and/or Python &gt;= 3.3.
And so does &gt;&gt;&gt; "5=%s" % b"5" Well... to some extent (you get "5=b'5'")
&gt; You do not build applications for bottle, like you would do with Django or Ruby on Rails. It is just one of many libraries you use in your application. I did not understood the above part.
Yes, they were selflessly hosting video for free, certainly making no money off of what they were doing, kind souls that they are.
Depends on your definition of large. I'm currently using bottle.py for a gaming website that gets 75,000 visits per month, with a lot of AJAX operations per visit, and have never seen a problem. Setup is fairly similar to yours... you do need a production grade server (I use nginx) in front of bottle.py for anything above trivial use, but once you have that, it seems to scale relatively nicely. Databases tend to be more of an issue for large sites that servers.
This is interesting. I prefer TIOBE's index though, which names Transact SQL as the language of the year. http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html
Redis is a key values store with some extra features like queues... It is usually used as a cache, not a primary storage, like web session or any application state in a distributed environment. (You should post this question somewhere else, it has no direct relation with Python)
That's actually exactly the same question: &gt;just how is a working print statement "genuinely harmful" * More complicated AST * Prevents local replacement (say, to a logging equivilant), and globally, since there is no binding in builtins. This primarily harms testing and debugging. * Prevents usage inside expressions, causing the incomplete `def _print(x): print x` hack. * Prevents mapping and currying * Prevents additions to make it more powerful with more options, primarily by preventing unpacking, `sep` and `end`. Maybe there could be work-arounds for the second and last of those, but it was deemed too poor a choice (replacement is no good without a proper following of scope and extending the statement's already-messy syntax would have yet-more degrading an impact on the implementation and learnability). --- Because of the aggressiveness of your responses I'm going to stick out of this conversation for now on. I understand you'll think the blame lies on me, but I disagree. Have a good day regardless.
Redis is not a database. If you need an analogy, think of it as a `dict` that runs on another computer. Where in regular python dict you take things out and then modify them, in Redis you modify things inside and then you take them out. This helps if more than two Python applications talk to the same Redis. In web development, you can use Redis as cache (key=url or post_id, value=html), as rate limiting backend (expiring entries, key=ip, value=count). In any Python project, you can use Redis as queue backend (Celery can use Redis), or to synchronize your non-essential state between Python instances.
Ah, never mind. I read your &gt; Based on that you'd expect to get a bytes of length one. to refer to indexing strings rather than indexing bytes. Given that, I think ll my conclusions would hold :-) I agree that a char type would clear things up a bit, but python doesn't really like a proliferation of bytes. &gt; "Character" is an ambiguous term. It can mean either "one eight-bit number" (a byte) or "one Unicode codepoint" Well no, in python 3 it finally isn't any more. It is definitely the latter and the former is a byte.
This is the correct answer
Hey! No, It just take care of developer's star count. I'll fix my spell miss. Although it is lack of document,I'll push this code to Github in the few days. When I done it , I'll post it here. 
If you can go, please do. It's a really fun event to go to, informal and well spirited. Not to mention the awesome belgian beer in the evening :)
http://nr.reddit.com/r/IAmA/comments/1u75hh/i_am_the_guy_with_two_penises_ama/
...and it then proceeds to make an own-goal by defining `char` as a 16 bit integer, completely flubbing the handling of code points outside the basic multilingual plane, and requiring atrocities like the following just to properly iterate over characters in a string: for(int cp, i = 0; i &lt; str.length(); i += Character.charCount(cp)) { cp = str.codePointAt(i); ... } (Yeah right, when was the last time you ever saw anyone do that? Most Java programmers just ignore non-BMP characters and hope for the best, causing terrible breakage when they occur.) 
These resources may also help you to gain an understanding of Git: * [Git Immersion](http://gitimmersion.com) is a guided tour that walks through the fundamentals of git, inspired by the premise that to know a thing is to do it. * [Atlassian](https://www.atlassian.com/git/) Git tutorials and workflows. * [A successful Git branching model](http://nvie.com/posts/a-successful-git-branching-model) - this blog post really helped me to understand branching and I now use the model discussed for client work. Atlassian also have a free GUI client for Mac and Windows called [SourceTree](https://www.atlassian.com/software/sourcetree/overview).
&gt; if varname == 'obj': &gt; next &gt; else: o\_O I mean, I understand what happens here, `next` is a builtin function that gets a next value from an iterator, but that's actually irrelevant because you don't call it, you just sort of mention it. Like, any expression can be used as a statement, even if it doesn't have any side effects. So you can say `if ...: len`, too, or `if ...: 2 + 2`. Also, that's how docstrings work. But please, don't do that! It's really, really confusing, because the reader sort of expects that saying `next` in particular actually has some meaning there! That it's like "continue" or something! You're supposed to use the `pass` statement in such cases. Or even better just negate the condition and don't use the else clause at all. After all, teaching people basic boolean logic is your job. Oh, or don't negate the condition, use "continue" and extract everything from the "else:" clause.
Why is DM better than YT?
If you have an existing application, say a desktop GUI application with no web frontend. You can create a separate file, say web_frontend.py and do this. from bottle import get, run from myapp.utils import getCurrentStats @get('/') def display_stats(): rows = ["&lt;tr&gt;&lt;td&gt;"+stat+"&lt;/td&gt;&lt;/tr&gt;" for stat in getCurrentStats()] return rows run() $&gt;python web_frontend.py 
Google "YouTube content id"
Couldn't you just upload these things to youtube?
Does it matter that it's free? Removing all the videos without warning is still a massive dick move.
Glad the information was helpful. Glad to share after all of our efforts in investigating the same. What I enjoy about Pyramid is the lack of structural tools such as blueprints. I just don't want to have to learn someone's wrinkle and having to rationalize it within my project. Anyway. As far as json goes...Pyramid is a piece of cake. Plus you have the use of traversal if you want to use the document/file hierarchy to feed json. A really nice feature, but not anything I am forced into using. config.add_view('myproject.views.my_view', renderer='json') *Responses* http://docs.pylonsproject.org/projects/pyramid/en/latest/narr/renderers.html *Traversal Example (not mine)* http://pieceofpy.com/blog/2011/08/01/pyramid-and-traversal-with-a-restful-interface/ 
Yeah, the free part matters (regardless of revenue generated from "free" hosting) but this evidently happened to paying customers as well.
OP has a good question here. I too am looking to trade using my programs instead of clicking around on UI buttons. Uploading a csv ascii file containing the order would be good enough. Example. Ibm,buy,100,market aapl,sell,100,market That is the basic but Of course more data is also to be helpful like authenticating my credentials, getting a trade fulfillment confirmation,.... A perusal of the famous discount trading sites seems to suggest that all expect a human client to be issuing all orders, not a program. This sucks and I would like to hear if anyone finds a discount broker that DOES provide any API. Of course I could hack up a web scraping program since http is being used, but that is much more laborious and sketchy than desired.
They're dicks. Agreed. Was it smart to let them hold the only copy of your original content?
My understanding of their business plan was that they host high quality videos focused on producers who produce serial content. Blip runs the ads in front of the content and splits the revenue with the original creators. What happens when the revenue that comes in doesn't cover the expenses? Do you try to make your company profitable? Or do you fund some producers at a loss until you go bankrupt? They're dicks for not giving adequate notice, agreed. But was it smart to let them hold the only copy of your original content? 
You are going to get that regardless of whats popular, though. There are still companies that refuse to use OSS because they are told by 'enterprise software' companies that its 'insecure'.
We stopped using blip.tv many years ago due to them pulling similar tactics with an Australian (non-python) conference. pyvideo.org is where people should be going for Python video, anyway - not to blip or youtube etc directly - pyvideo.org URL's will remain constant even if a host pulls the plug (we can upload videos elsewhere and change the embed). We also generally keep copies of all encoded video and/or send copies of it to the conferences we record - it should be evident uploading to a third party site *only* is a silly long term archival strategy. Much of it is at archive.org, too.
totally worth it, thx
but I can do above with Flask or Tornado also right? then whats special about it?
Yup. You can do this with all microframeworks. Most microframeworks are actually libraries that can be plugged in your existing application. You can have a frontend for a command line python application if you wish. I believe the thing that differentiates microframeworks from the big ones is that they don't impose a predefined structure or a set of conventions. You cannot use big frameworks like Django this way. Even if you could, it would be too much of a hassle. Microframeworks make this sort of a thing trivial. Although you can use importd http://pythonhosted.org/importd/ to use Django in a similar fashion if you are comfortable with Django. 
One reason you'd want to use Redis is because it would cache information that would otherwise have to come from a database or a hard drive. Since accessing memory from RAM is significantly faster it can speed up queries. There are also benefits to reducing disk reads or connections to databases.
I dont have copies of more than half of that content which I lost in a HDD crash. Rest, I am now in a dilemma where to upload back - Youtube or Metcafe. I was not paying any money to them for storage, but they were making money off my videos too "the 50/50 revenue share". If all of a sudden they felt all my videos violated their TOS then i feel they should have checked those in the start. Crap.
&gt; Also you have to download every file and are forced to keep up with updates. If anything it's a technology that had its day before mobile devices and domestic bandwidth caps.
Why is it better in your opinion? Elaborate on that please.
there is a post here saying you are right http://mindref.blogspot.co.uk/2012/09/python-fastest-web-framework.html
Redis is a (mostly) in-memory key value data store that can also persist. Contrast that with, say, postgresql - which is primarily a **persistent** data store that can also be in memory. Redis is good for storing and retrieving key/value data FAST. It's an unreliable data store, though, so your app should be prepared to lose data if, say, the power plug gets pulled (this is much less likely with a relational DB, but the relational DB will be slower). Redis is primarily good as a cache and a place to store user sessions, but it's also handy to put a message queue on. Mongo is just horrible, and you should probably stay away from it.
Be wary of how much you're trying to mash programing into something else through an analogy that fits for you. Functions and variables aren't actually crayons and blocks, for example. I see how 'visualizing' programming can help but it can also hinder. Think of a hair brush for a moment, sure you can see the edges of it, and you know it's function (to detangle and smooth hair), but when you really start analyzing it you see that its made up of a lot of little things. The bristles actually do the detangling but they're held in place by a frame. I could go on breaking it down, to finer and finer degrees. But there comes a point when you're looking at atomic interactions and really wondering if you absolutely need to know about quantum properties when all you wanted to do was brush your hair... With programing you can learn a lot, like a lot a lot. You could go read the python documentation for a function or whatever and see how that works. Often times that will be a good enough understanding. But sometimes you might need to learn about how the things it works with work and so forth. But be careful of feeling a necessity to learn it all the way down because you might be overwhelmed about assembly and then see after that there's electrical engineering stuff to learn. (Note: I'm not saying don't learn how subsystems work, I'm just saying you don't have to if that's not your thing.) 
http://showgen.com/ is built with kivy.
&gt; Software Carpentry Thanks for posting a link to this. 
This is cool from a hacking standpoint but there is a mature Yacc and Lex implementation in Python called PLY 
Got a chuckle out of "Because of the aggressiveness of your responses" from the ass-hat who started with "Oh, you're one of those people.". 
you can use old school parsing tools designed for c with python.
You're absolutely right. The assumption/supposition is that creating a big web app in Bottle or Flask will require the developer to write more code, sometimes said as "all big web apps rewrite 80% of Django". Bottle/Flask will likely outperform Django most of the time, but in some cases you might tack on additional development time. With the thriving Flask plugin community, though, this is more like "decision-making" time rather than actual programming time (Django, on the other hand, makes all the decisions for you, like Ruby on Rails).
you remember back in third grade, when you diagrammed sentences? This part is a noun phrase, which we break down into an article, an adjective, and a noun. that's the verb, and the word on the end, that's a direct object. Essentially, that's what parsing is. Programming languages, whether compiled or interpreted, do that to your code. All they see at first is a string of assorted characters which is your program. they have to take that string, and decide that this one sequence is an assignment, which is further broken down into an identifier, an equals sign, and a value of the right, or a more complex expression. This other piece of code is a function call, and so on. One the code had been parsed, a compiler can take the parse tree and convert it to machine code, or an interpreter can start executing the instructions given to it by the code. Usually, parsing is broken down into two phases, scanning and parsing. Scanning breaks the code into tokens, and parsing analyzes the structure of the tokens. Flex is a tool for generating scanners (Fast LEXical scanner) and bison builds a token parser from a grammar specification you give it (bison-&gt;yacc-&gt; Yet Another Compiler Compiler). 
That's a pretty nice collection. What projects do you use from them? Please give a short sentence what it is good for. I start: * pudb (Debugger in the console. Reminds me of the times when we used Turbo Pascal under DOS.) * schedule (A lightweight and simple scheduler. Example: call this function every in 5 minutes.) 
Dat Flask documentation. I haven't had a real chance to dig into the actual code (actually, never had a desire to until right now...before work...fml) but the documentation at [pocco](http://flask.pocoo.org/docs/) is 300 pages of interesting and informative. I got my hands on the PDF and printed it (tiny screen on my phone) and read it before bed.
Yes, I think the ability to do module-wise upgrading to something at least close to Python 3 is the essential bit that was missing all along. It makes gradual upgrades possible, though of course I haven't fully evaluated yet how ugly the compromises would make my code. I think this might be a good candidate of what Python 2.8 would be like. You could argue that with a library like this you don't need a Python 2.8, but it would make the upgrade path a lot smoother if it was the official way forward. 
Couldn't you [link straight to the actual results](https://docs.google.com/spreadsheet/pub?key=0Aq1sLIA-T44zdEhYdkQ3WVlhSnVRX2tobjVoRFdpTlE&amp;gid=0) or at least a blog that pretended to provide some sort of analysis or commentary?
thank you! I was about to post the same thing. like 4 clicks just to get to the PDF. wtf.
I think arrow might be a better datetime replacement than delorean?
It seems the users in this survey like/endorse Python 3, but are still attached to Python 2.
Ah, but what if a builtin type is passed as a parameter? It's not very common, but it is possible, and it would be a potentially difficult error to locate.
Well, then it depends on what you mean by framework! Is Wordpress a framework? Flask is, so is RoR. Django, etc.. also are. But cakePHP? It's hard to make the distinction. You never see a web stack use Ruby not Rails, but that's fine. It's similarly fine how some Python frameworks are a lot lighter than RoR, because certain things (routing) are needed, and other things (for example, an admin page) are better left to the user, depending on your circumstances. It's very easy to say X is better than Y. What, in your opinion, is lacking from Python frameworks? 
Well you always can find ways to break it, but since the builtins supposed to be compatible they should to work.
&gt; Mongo is just horrible, and you should probably stay away from it. Why? So many people now seem to using Mongo
nosql
&gt; think of it as a dict that runs on another computer. Redis does stand for "Remote dictionary server"!
http://stackoverflow.com/questions/18582509/difference-between-lxml-and-html5lib-in-the-context-of-beautifulsoup#comment27352922_18582509 : &gt; You can use html5lib parse and BeautifulSoup parser within lxml. See lxml.de/elementsoup.html &amp; lxml.de/html5parser.html ... http://html5lib.readthedocs.org/en/latest/index.html 
x-post to /r/ipython?
I'm dependent on mayavi2 which depends on traits and vtk. matplotlib and pyqtplot (and others) don't have all the features I need for 3d interactive plotting - at least I don't think so.
fucking seriously?
I have been using both libraries for quite sometime (pun intended) arrow at first was quite trivial and provided very little knowledge for people getting started and solving problems from time zones. Although did help with time zone manipulation. Delorean aside from the name was very well thought out and I admire Mahdi's work it handles time zone shifting and creation with safe default and clues in the user in docs so they can make effect choices on how to handles times zones as well as extensive utility functions for generating time series. Matter of choice now, but Delorean in my opinion is a better library and is built on top of other solid timezone libraries. 
Your comment is less than clear. What did you want to say?
You can use BeautifulSoup to work with incorrect HTML, while still using the lxml API. At least, that's how I interpret it.
Ideally, for string processing, duck typing would you to allow to use either `str` or `unicode`, with the same implementation. (C extensions are a different matter, and they need to perform conversions.) I get that this breaks down on the I/O boundary, but apart from that, why doesn't duck typing work here?
The duck typing worked on 2.x for the most part. On 3.x `bytes` and `str` have incompatible interfaces.
He talks a lot of sense. I don't know what's wrong with the Python core devs. Python 3 is so obviously broken, but they just put their hands over their ears and go, "LALALALA".
&gt; What is stopping anyone from developing a Python 3 PyPI module, say, bytestr, that reproduces Python2's str behavior exactly? That's actually not possible because the interpreter lost support for it. The string type is an integral type in the interpreter and needs to be supported at that level.
I bet this stuff really confuses beginners.
/u/mitsuhiko, after reading the last section of the article I conclude you're no longer willing to advocate killing 3.x. I think all of us would like to hear what's your preferred solution now. Are you in 2.8 camp, for example?
I have this strange feeling that someone will fork Python 2 and people move there instead of Python 3.
It is not broken. It is just way too different to quickly adapt any huge project to it.
Well, I think that's exactly what is going to happen. Many of us devs still can't justify switching to Python 3, especially if you have a large codebase.
1. consistent syntax 2. easy extensible syntax 3. easy parallel execution 4. easy integration with java ecosystem
It might. But then again, beginners wouldn't really care since they don't have thousands of lines of code to port. For a beginner the difference is not that huge and they are really very similar in terms of syntax and internal libraries. Except maybe the first thing that they'll find confusing is print function syntax:)
It does not need to work at interpreter level. If you want to accept either, wrap your params in a proxy object that implements the interfaces you want. I see the argument of `bytes` needing `.encode()` as similar to people asking for `list` to get a `.join()`: it might seem convenient for you but its lack in no way stops you from using a language. Especially given the point that codecs can turn anything into anything else: would you expect to have `object.encode()`? And while you seem to encode bytes a lot what if a poll decides that even more people use gettext? Do we really want `str.translate()` or is it already outside of the convenience-versus-bloat boundary?
&gt; I'm sure that Python 3 is not the only language to have a string type that doesn't implicitly coerce with binary data. So how do those other languages do their tricky IOs? That's a good way to start a discussion :-) Rust's strings are utf-8 internally and can be unsafely transmuted into a vector of u8s. If you are writing a protocol you can use them almost interchangeably for as long as you know what you're doing. You can easily convert freely from one to the other for as long as you're UTF-8 or in the ASCII range. Ruby and Perl store the encoding on the string itself. In Ruby for instance each string can be annotated with the encoding it most likely contains and there is a generic 8bit encoding to store arbitrary data in it. As far as I am aware, the same is true for Perl as well. Java/C# traditionally have problems with file systems on Linux if they contain tricky filesystem names. Filesystem access is exclusively unicode and sometimes you do need to tell the whole JVM that it needs to use a certain encoding. Mono always uses the LANG variable. This has not been without issues. For IO Java and C# have a very strong IO system that carries enough information about whether it works on bytes or characters. Since Python has lots of decorator APIs that come without interfaces this information is not available and no replacement API has been provided. PHP rolled back it's unicode plan which looked similar to Python 3. JavaScript has not solved that issue, for the most part it's wild west because it never had a byte type and traditionally no interactions with files. Node JS I think just assumes an UTF-8 filesystem for filenames. &gt; How do they manage the mix of a unicode email with a binary attachment embedded in it? Same way as Python 2 and 3 now: correctly. That was an example of a broken testcase on Python 3, not as something inherently wrong with Python. &gt; How about a "mixed type" string wrapper? That is basically going back to Python 2.
I use Python but I want to start learning a new language this year. Clojure has been on my radar for a while and I think I will pick this language, that's why I asked.
&gt; It does not need to work at interpreter level. If you want to accept either, wrap your params in a proxy object that implements the interfaces you want. There are no interfaces in Python. The only way your proposal would make sense if it there was a `to_bytes()` and `to_str()` method on it. This however would have to copy the string again making it inefficient. It just cannot be a proxy since the interpreter does not support that. You cannot make an object that looks like a string and then have it be magically accepted by Python internals. It needs to be `str`.
It's probably not what you want for your production apps, I use it personally for a couple of hobby projects running for free on Heroku.
My point was having the proxy coerce it to the needed type depending on which method you call. That's what `str.encode()` did in Python 2 anyway. The more important argument is that `str.encode()` was a convenience shorthand for `codecs.lookup(name).encode(foo)` which continues to work for any type the codec can handle.
`str.encode` did not coerce anything. The codecs did. Not sure what exactly you mean. Can you give an example?
It wouldn't be hard to rename the project to something new, provided there was a corporation willing to push the initial development. PSF only has control over the "Python" name. The Fork-thon name could be anything.
Yes, but that's not the hard part of forking. The hard part of forking (aside from claiming enough "marketshare" from the original project) is keeping the fork running, which the /u/nieuweyork claims the PSF does well.
It seems to be more like `list(b'foo')`.
&gt; To the risk of exposing my ignorance: I'm really curious about how "unsafely transmuting a str into a vector of u8s" is any different from 'foo'.encode('utf-8'). An unsafe transmutation is a noop. It does not do anything but telling the compiler that this thing is now bytes. In C++ terms it's a `reinterpret_cast`. A `"foo".encode('utf-8')` looks up a codec in the codec registry, performs a unicode to utf-8 conversion after allocating a whole new bytes object and then finally returning it. That's many orders of magnitude slower.
Ok. So, Rust works the same as Python 3, but is faster? Or is there something else that it does differently? I don't remember speed being at the forefront of your argumentation against Python 3's `str`.
&gt; Ok. So, Rust works the same as Python 3, but is faster? No, it does not work like it at all! There is a huge difference from a programmer's point of view between being able to treat bytes as subset of strings (Python 2 / Rust) and always going through an unicode layer (Java / Python 3). Java is a case similar to Python 3, but Java is a very fast language and you can write lower level code to deal with things like that. In Python 3 you now kinda have to write C extensions.
I never understood why python 3 was created and the features not just rolled into 2.7. I have always had this gut feeling that Python 3 was some sort of internal politics thing. My python codebase is about 2.5 lines long and I still don't want to port. When I google how to do something the code sample has a 90% (or more) chance of being 2.7. They say that most of the major libraries are ported but again the key word is "most". To me Python 3. Reminds me of Windows ME. It technically was better than Windows 98SE but nobody made the upgrade; most waited until XP and generally not until SP1. The same with Vista. Another version that people generally skipped and waited until Windows 7. I sense some Anger from the Python people at these conference talks that people aren't switching to 3. They need to be careful about this. If you continuously display anger at a huge portion of your users they will feel bad and bullied. I am getting the same thing in the C++ world. There is this huge push toward templates. One of the results of this is a resurgence of C. A simple symptom of this in C++ is when people ask stackoverflow about one library vs another is that people will bash the library that is too heavily templated. Yet the library favored most by the C++ crew is boost. So in Python you have actual users stubbornly holding on to 2.7 and in C++ you have people C'ifying their C++ code. 
Oh well, this is getting complicated and I don't feel like we're getting somewhere. It's probably my ignorance's fault. But still, when looking at Rust's `std::io` doc, I see that these functions don't take `str` as arguments, but rather `Path`. This is probably the way to go in Python as well: stop taking strings as IO arguments and have Path and URL classes to encapsulate all the trickiness related to IOs. The inclusion of a native path class slated for v3.4 is probably a step in the right direction.
Excellent! Can't wait to watch the rest of the videos. Much appreciated, man. 
Windows ME? Technically superior? This thing was crashing *all the time*.
Thank you few doing this for free!!!
Oh wow. I had no idea. This is sad.
&gt; For IO Java and C# have a very strong IO system that carries enough information about whether it works on bytes or characters. Since Python has lots of decorator APIs that come without interfaces this information is not available and no replacement API has been provided. Can you expand a bit more on that? Because that's the weird thing: Java and C# don't have anything like the bytestring class at all, all strings are always Unicode and besides that you have arrays of bytes. Yet I've never seen anyone saying that working with text is fundamentally broken in those languages, and that having an 8-bit unencoded string in the core language is the only thing that can save it. I mean, it seems that it's possible to work productively in an environment where you simply never have raw strings in the application, as strings. So you never have any problems with mixing raw and Unicode strings, etc. It appears that in Python3 we are supposed to adopt the same mindset, what exactly goes wrong and why when it does the easier solution would be to go back to the Python2 way instead of doing it the C# way? And why exactly do you need interpreter support?
&gt; Can you expand a bit more on that? Java/C# have an interface that identifies a stream that yields strings and a different one for one that yields bytes. Python does not have that, because it's a dynamically typed language. It unfortunately also does not have a method or attribute that is required for streams to implement to identify them. So right now the only way to check which type of stream you're dealing with is reading zero bytes from it. Which apparently breaks for some streams. &gt; Because that's the weird thing: Java and C# don't have anything like the bytestring class at all, all strings are always Unicode and besides that you have arrays of bytes. Yet I've never seen anyone saying that working with text is fundamentally broken in those languages, and that having an 8-bit unencoded string in the core language is the only thing that can save it. There are many reasons for this. The first one is that Java/C# are JIT compiled and nearly at native speeds. A protocol parser in Java/C# is almost always a state machine that operates on a byte at the time. This is completely unfeasible performance wise in Python, you need to hack something together out of the primitives provided. Alternatively you need to write a C extension. As the filesystem support goes: C# never had to deal with that because it came from Windows which has a unicode filesystem. Mono has to deal with it, so does the JVM and both of them have very crude support for this. There are cases where people have troubles addressing files because of this. For Java it does not show up much because people generally don't write command line tools due to the slow startup. Those are the ones that suffer from that the most. &gt; It appears that in Python3 we are supposed to adopt the same mindset, what exactly goes wrong and why when it does the easier solution would be to go back to the Python2 way instead of doing it the C# way? Different situations require different solutions. Python 3 is seen as a Python language, the mindset that went into Python libraries is fundamentally different than the one that went into Java. If Python 3 was a strictly typed language it might work better because we could take some of the meta information from the type system (like is it a thing yielding strings or bytes). Unfortunately we don't have that, so it gets hard. &gt; And why exactly do you need interpreter support? Because there is no way to construct strings cheaply. There is no API to convert a byte array into a string without copying and there is no way to make a class that the interpreter would accept as strings either.
Thanks, and thanks for adding a short description about kivy too for people who don't know it. A short abstract should always be provided and this is what I miss sometimes. Unfortunately, I get strange reactions when I ask about it, like *"hey, if you don't know it then it's clearly not for you"*...
Python 3 allows you to use string semantics with arrays of Unicode code points and with arrays of bytes. Python 2 allows you to use use string semantics with array of Unicode code points and with arrays of (bytes or 8-bit code points). Python 2 applications often do not identify the contents of *str* type objects as either an array of bytes or an array of 8-bit code points, and often do not identify the character encoding or code page of the 8-bit code points. Because Python 2 allows different content types to appear in the same language type, it allows one to easily break PEP-20, The Zen of Python, "Explicit is better than implicit." The conversion of existing code from Python 2 to Python 3 requires one to identify the content of *str* type objects as binary or text, and for text, to identify the encoding or code page of the characters. Python 2 is **not** the better language for dealing with text and bytes. It is simply less rigorous about the typing of the objects to which you apply string semantics.
No it's not. Text (str) and bytes (binary data) have totally different purposes. Giving them a common interface Just Doesn't Make Sense. Duck-typing bytes into str is just stupid. The correct way to convert one to the other is via encode/decode. Why do people have such trouble understanding that text and binary data are different and not interchangeable. 
define quickly. 5 years?
I think it is not about text vs binary, but multibyte text vs singlebyte text. Multibyte text has one coding, singlebyte text can has different codings. Python3 drops singlebyte text, and I think mitsuhiko claims that sometimes using singlebyte text is more convinient/efficient. B/c real world not all unicode, if you get singlebyte text, it is binary in python3, you need convert to multibyte text, make operations, convert to binary back.
Thank you, waiting for more!
&gt; Java/C# have an interface that identifies a stream that yields strings and a different one for one that yields bytes. I went and refreshed my memory on this. C# has a couple of text-oriented stream classes, and then a [BinaryReader](http://msdn.microsoft.com/en-us/library/system.io.binaryreader\(v=vs.110\).aspx) and Writer which look nothing like the corresponding text versions but are instead specialized classes for parsing/composing binary protocols. Note that the underlying stream is always byte-oriented. So, do I understand it correctly that implementing similar BinaryReader/Writer as extension classes would solve 90% of your problems in a nicer and faster way than Python2 does? I want to emphasise that with this approach you don't need to distinguish between byte and unicode stream interfaces because they have radically different, well, interfaces. Just throw an exception if the underlying stream returns unicode for some reason. &gt; As the filesystem support goes That's an entirely different problem, as far as I understand you want to be able to roundtrip filenames as opaque blobs of bytes in an unspecified encoding. I'm not sure it's a good idea, because the next thing you'll inevitably want to do something with said filenames, like log them for example, and everything goes to hell. Much easier to say that if someone doesn't have their LANG set properly, it's their own problem. The overwhelming majority of people do have it set properly. &gt; Because there is no way to construct strings cheaply. There is no API to convert a byte array into a string without copying and there is no way to make a class that the interpreter would accept as strings either. Why exactly do you want that? Don't streams already support the buffer protocol, so you should be able to avoid most extra copies, if you design the API properly?
As a newb, you are absolutely right. I've been learning Python for the last few months and dealing with the 2 vs. 3 thing is incredibly frustrating. People keep telling me "learn python 3 because it is the future" but then you ask them what they use and its all "oh, definitely 2.7 because Python 3 is broken/wrong/immature/lame etc." What people don't mention enough is that right now all the resources for newbs are split between Py3 (Dive into Python 3 etc.) and Py2 (LPTHW, Codecademy etc.). The end result is that tutorial code rarely "just works." More importantly though, as a newb, setting up a py3 stack for data analysis is WAY more complicated than py2. Something that takes 2 seconds in py2 takes five SO questions and 4 hours in Py3. Want an example? A month ago I spent a full day trying to figure out why Spyder IDE was giving me a strange and unhelpful error when I pointed it to my Anaconda Py3 stack. It turns out the Spyder just doesn't work with Py3 at all. Now, some experienced Python programmer would already know that Spyder didn't work with Py3, but as a noob, the idea that **a mainstream python IDE** doesn't work with **the official, active Python release version** sounds f**king stupid. Currently I'm sticking with Python 3, but frankly all this Py2.8 talk is making me migrate back to R, where your stack just works ... at least until the Python community gets it's shit together. Why don't I move to Python 2.7? Because I don't want to spend the next two years learning 2.x while the Python community spends the next two years learning 3.x. (apologies in advance for the mini-rant, but its just been a miserable road).
Turns out that text encoding is hard for everyone, do you think having to learn ASCII makes things easier for Korean beginners?
&gt; Why exactly do you want that? Just read this issue: http://bugs.python.org/issue3982
I'm not really sure what you're asking, but I suspect what you want to know can only be learned through experience. It sounds like you are trying to work out how programs should be structured, which can only be learned by reading and writing lots of code, ultimately the aim is to make programs which are easy to read by humans and easy to modify. The first part of this book has some good things to say about design: http://dreamsongs.net/Files/PatternsOfSoftware.pdf
Let's get real: it hasn't been mature for at least first few years of development. We've been watching the whole time though and huge businesses are very careful with such decisions as switching to a new language (which is almost the case here since so much has changed, even though not necessarily in a bad way). But let's provide a better example of why our company isn't switching to 3.x. Let's start with Twisted. Has it been ported yet? Try to guess. Erlang comes to mind and the idea of writing our own stuff instead, tailored to our own special needs. But that's just Twisted, right? Nope. While django supports 3.x, it isn't just django that people use. A lot of code accompanies it, from custom api clients to different analytics and other custom reports and views and forms and tests and filters, etc. We just can't afford suddenly going to 3.x. Even if by some magic we could, we still have to justify it financially. All those work-hours spent on what? No new tools for business? Nothing that allows at least not wasting money or saving money? That's a clear no-no from management.
Yeah, I skimmed through that when I read the OP actually. The dude there proposes adding a `bytestring.push_string` method (callable as `push_string(b'POST')` or `push_string('POST', 'utf-8')`, I guess), which is basically half way to the C# approach. Now add a bunch of stuff like `push_uint16` and maybe instead of a `bytestring` actually use a `binarywriter` wrapping the stream directly, for a bit of extra efficiency and so that you could implement it as an extension class in the remainder of the weekend without any help from the core (though I think you can implement your own bytestring clone too, as I said I hope it would work with streams with no extra copying if you support the buffer protocol, no?). I don't see any extra copies in this approach, compared to the way you used str.format in Python2.
I find, it makes it confusing where it needs to. I have recently helped a few guys migrating to py3, and unicode handling was one of the bigger issues. It turns out, while their code in py2 worked it was flawed. They were doing text processing on bytes without knowing the proper encoding. Out of sheer luck they never got anything else than ASCII as input. Now on Python 3, the operations they use return bytes, and they are forced to think about the encoding. They have to be aware of this, which in my eyes is a good thing. But unfortunately /u/mitsuhiko has a point. There *are* cases where the way py2 handled strings was a lot more useful than now. Honestly, I hope this gets resolved. Python 2.8 would *not* be a good sign for the community.
I'm tired of this Python 2 vs. Python 3 stuff. Python 3 is better, and the people that refuse to adopt Python 3 [are in the minority](https://wiki.python.org/moin/2.x-vs-3.x-survey). This minority should get over it already. By refusing to support a language like Python 2 going forward, the the Python community as a whole can focus on creating more compelling stuff that encourages more people to upgrade, rather than worrying about Python 2 compatibility. 
I think you may be confusing 2000 with Me.
No, 2000 was pretty good, but the bulk of the population didn't know to use a Server OS on their desktop. If I understand correctly XP was largely built on NT and that ME was a dead end. But if MS marketing had their way everyone would have dumped 98 and made the "amazing" leap to ME. 
For this particular point (convenience), my original point stands: What's stopping anyone from developing a `bytestr` package? 
Binary protocols are not supposed to sound exciting. As they say, when you're too excited one careless movement and you're a father. Anyway, you're totally free to implement `writer.push_format(...)` if you want. I thought that the main point of contention was that you'll have a lot of extra copying (like your `x.get_bytes()` maybe) so you need that functionality on the bytestring/bytearray classes themselves. No, you actually don't, as far as I understand. Like, I'm not really sure about implementing the buffer protocol or being able to return the underlying bytearray to the stream, but if you do it C# way and do `writer = BinaryWriter(response)` then you can really do it for sure, literally in a couple of hours. In pure Python at first too, just use the struct module I guess.
I do think it does it well, notwithstanding the py3 debacle. What's your perspective on this? I'm genuinely interested to hear concrete criticisms, because discussing this is the first part of getting an alternative community going. For those who think that getting code going is the first part: it's not, not least because there are already multiple codebases that could form a base for pyfork (PyPy might be even better than CPython as a base).
| This is completely unfeasible performance wise in Python, you need to hack something together out of the primitives provided. Alternatively you need to write a C extension. Well, we're kinda working on a thing that makes this statement a lot less true.
&gt; This minority should get over it already Why? The point of free software is literally that we don't have to if we don't want to. &gt; Python 3 is better Clearly that's a matter of opinion. Those of us who prefer python 2 have specific criticisms of python 3, while those on 3 side who bother to respond with anything other than a "shut up" (like you), point to the shiny new features. Those new features are good, but there's no reason why those have to come at the cost of introducing poor designs and incompatibilities in other areas. &gt; people that refuse to adopt Python 3 are in the minority. You literally have no way of knowing that. You are relying on a survey of self-selected respondents. If you have a subset of the community that wants to appear to be the majority because they are so enthusiastic about their favourite thing (python 3), it is quite natural for a large proportion of them to self-select as respondents; meanwhile people using python 2 may not care at all about visibility because python 2 is still in reality the default. Having trashed the representativeness of the survey, I note that it doesn't even support your contention: the survey shows that most respondents say they write most of their code in python 2, AND it shows that something like 40% of respondents have never written any python 3. That's not a majority for python 3: that's a majority of respondents having tried python 3 out and rejected it.
You're talking about RDB mode, but that's not the only option. Keep reading: if you use AOF mode with a strict fsync policy, it's reliable.
That the interpreter does not know what a `bytestr` is, so at the very least you need to convert it back to bytes or into a str. Which would be especially annoying when dealing with layered APIs.
True :)
If the type is based on `bytes`, you can get that conversion for free. Or whatever, it can also be just a `format(str_or_bytes_fmt, *args, **kwargs)` function implemented in C. My point is, we're talking about convenience here (and my "here", I mean the example you've given above about formatting), not something fundamentally broken.
&gt; Why don't I move to Python 2.7? Because I don't want to spend the next two years learning 2.x while the whole Python community spends the next two years learning 3.x. I think you're dramatically over estimating the time to upgrade your skills from Python 2 to 3. Maybe...a couple of weeks?
&gt; The point of free software is literally that we don't have to if we don't want to. Of course, but then your new language stops being "Python", because Python is what the community decides it is. It's like whitespace haters. They can easily change Python's code to adopt braces, but it stops being Python. Sure you can try to make your new language take off, but I wouldn't bet a lot of money on your success.
Pretending all the world is either unicode text or arrays of 8-bit integers is just as stupid as overly conflating the two. The vast majority of `bytes` I get are only coincidentally of that type (mostly pseudo-ascii) but technically unsafe to decode. Python 3 makes actually *working* with this sort of thing needlessly painful, as many people have found out, in a tradeoff that benefits absolutely nothing I can think of that isn't usually implemented in C anyway.
It is not only just 'not quite the same'. I think it is a completely different situation. By the way, people (myself at least) aren't bitching about Python 3. Many just ignore it as if it doesn't exist. And for most it really doesn't exist as a viable option right now in existing projects. I still often happily pick Py3k for some personal projects or freelance stuff that I do, but those are small and do not affect the 'big picture' at all. I'm quite a lot happier learning a completely new language (erlang or Go comes to mind again) than learning and adapting to a new version of something I've been working with for a while. How much of your code did you have to rewrite after C++11 got feature complete? I'm guessing nearly nothing and most of the old code worked. Here between python 2 and 3 though, switching really gets shit broken and wrecked (say hi to pdb). Especially the str thing. It might look awesome as a feature of py3k, but it is a huge pain in the ass when you are porting something older than that.
Pull requests welcome! I'm really hoping to continue the development of this library but I'm looking for some help from the Open Source community on this one. 
No, it's good, because mixing bytes and strings is stupid.
&gt; It's like whitespace haters. They can easily change Python's code to adopt braces, but it stops being Python. You're making a very silly analogy. You're comparing people who want to keep python compatible with their code to people who literally want to ditch the signature syntactic feature of python. &gt; your new language stops being "Python", because Python is what the community decides it is. Well, that's the question, isn't it? The evidence is that the community likes python 2, but "Python" is something created by the Python Software Foundation. The point of a fork would be that the community would no longer feels itself represented by the PSF. &gt; Sure you can try to make your new language take off, but I wouldn't bet a lot of money on your success. You may not see the irony in this, but thousands will. 
&gt;survey shows that most respondents say they write most of their code in python 2, AND it shows that something like 40% of respondents have never written any python 3. Perhaps it is because over 60% of respondents say that dependencies keep them on Python 2. We can't infer the majority of respondents have tried Python 3 and rejected it - less than 25% agreed to the question "Do you think Python 3.x was a mistake?"
The survey was probably completely pointless and had a huge selection bias.
That's an enormously poor survey question. What's a mistake? To even begin the project? To try to force it down everyone's throat? To use it as a testbed for new features? It also requires the respondent to take an affirmative stand against python 3; most respondents don't use it very much, so relatively few of them will have bumped their heads against the problematic parts. The question is both ambiguous and leading, *almost as if it were designed to come up with the result it obtained.*
&gt; The evidence is that the community likes python 2 There's a big difference between not having moved to Python 3 yet and not wanting to. I think you overestimate the importance of the later.
I write large scale web archiving software, I've seen things come off the web that would make your hair curl. URLs however are still URLs. For a start there is no such thing as an "unparsed URL", a url is an encoding scheme, it is a string of US-ASCII text. If you do not know the encoding of a given string then you do not know how to translate it into code points and you do not know how to parse it. If you do know the encoding then you have a way to make a sequence of codepoints, i.e. a unicode string. If you are dealing with URLs which do contain non-ascii characters then you still need to handle them as unicode strings, otherwise you have a nonsense. You then need to use the encoding schemes specified for URLs to put them on the wire. Your idea that you need to manipulate strings as byte arrays is not only wrong, it is harmful. It leads to racist software that tells people that their names are invalid, it leads to people receiving incomprehensible messages, it leads to crashes. You should only ever manipulate strings as a sequence of unicode codepoints.
&gt;multibyte text vs singlebyte text Eh? What has the number of bytes needed to represent a Unicode code point got to do with anything?
IMHO, forking to continue the 2.* branch would be a bad idea. I think the best way forward is looking into ways to migrate the lagging parts of the community, possibly with new releases of Python that make that less painful.
&gt;a mainstream python IDE I agree with your point that it should support Python 3, but I wouldn't call Spyder a mainstream IDE. Isn't it specifically geared toward scientific programming?
With him talking about data analysis that puts him solidly in the scientific community. Hence for his purpose Spyder is mainstream, wouldn't you say?
Agreed.
Nah, `from __future__ import print_function, division` basically sets you up, next you just fix some other imports and that's all. `from __future__ import division` you should do in Python2 code anyway, because it's one of the really good changes. Actually, as you should be able to tell from all this hubbub, Py2 and Py3 are _extremely_ similar, to the point where people mostly figured out how to make code work in both, but are concerned about minor but annoying details. Just switch to 2.7 and wait for them to sort out the mess.
I'd be tempted to use this for fancy exception handling and logging, how's it play with exceptions?
Are the Unicode design issue in Python 3 not solvable? There is no way out to fix it in a future update such as Python 3.5? 
&gt; I never understood why python 3 was created and the features just rolled into 2.7 A big reason is that the changes that Python 3 introduces are not, and shouldn't be, backward-compatible (notably the byte-sequence/Unicode distinction). 
&gt; There's a big difference between not having moved to Python 3 yet and not wanting to. Well, no. If people really wanted to, they could make it work. You posit that people secretly want to move to Python 3, but haven't done anything about it because of...something. I posit that people haven't moved to Python 3, and haven't taken steps to do so because they actually prefer Python 2. Your position sounds a lot like wishful thinking.
Why don't you install both python 2 and 3 and test it against both? That's what I do. You might need to fiddle a bit more with libraries or some things but it's worth it. Oh, and use source control in case you weren't before.
&gt; Currently I'm sticking with Python 3, but frankly all this Py2.8 talk is making me migrate back to R, where your stack just works ... at least until the Python community gets it's shit together. Just to let you know, that is *purely* wishful thinking being said aloud by some people. I'll buy some sort of hat and attempt to eat it if it ever happens.
PyCharm works with Python3 just fine. THAT is a mainstream IDE.
&gt; Eh? What has the number of bytes needed to represent a Unicode code point got to do with anything? ASCII text is often used in protocols next to binary data. Python 3 does not have efficient ways to work with that. The fastest is partially working in unicode and then encoding into bytes, which is not particularly fast. On the contrast you have Go, Rust or Python 2 for instance which either implement unicode as utf-8 internally or have efficient ways to deal with ASCII data which for most protocols is good enough.
Pretty much the entire Python scientific stack works with Python 3. The differences between them are quite minimal and mostly matter to *library* developers who have to write things to abstract those issues away from you. There are tricky edge cases but generally if you know 2.X you can use 3.X and vice-versa. Side note - what took you 4 hours to figure out in Python 3?
That's not what 2.8 camp says, just the opposite. They want 2.8 as an additional transition path to 3.x.
Meanwhile it was incredibly obtuse for anyone on py2 to interact with the universe of translatable text where the world doesn't revolve around the English alphabet. You run into the "I need strict ascii characters" problem a lot less than the "why is everything showing these black boxes or no text? Oh, I accidentally forgot to use unicode".
&gt; I can only assume you only have a cargo cult understanding of programming and character encoding. Are you aware of flask? &gt; For a start, I do not use the built-in url parsing available in the standard libraries because it's all terrible. I need url parsing written by people who know how character encoding works and what URLs actually are. Same question.
The scenario you've described is literally what I have right now: 2 for 2 in huge projects, 3 for newer personal stuff. I'd gladly spend some time porting old code at work, but I'm not the one to decide there. I guess this should be the end of our argument if we had one:)
&gt; and the people that refuse to adopt Python 3 are in the minority. I don't know how you came to that conclusion from that survey. For example, question 3 shows that 80% of the survey respondents write primarily python 2.x code. Hardly a minority. 
Many many things, but off the top of my head: - Getting Anaconda's Python3 stack installed (2.7 is default, 3.x requires terminal commands [which I had never used much before]). - Getting pip/conda to install to Anconda's py3 stack instead of default py2.7 stack - Getting Sublimetext2 to work with Anaconda's py3 stack (required a custom build file) - Getting SublimeREPL with iPython (required a different custom build code) - Getting iPython notebook to use the py3 stack These might all be easy to some Python developer, but as a beginner, this was all stuff took probably 40-50 hours of searching, reading, asking SO questions, etc... and all BEFORE I could actually start digging into the language itself.
Well, for starters you were talking about third party web libraries. Just go look around the Flask and Pocoo site and see if you can figure out the rest.
&gt; Pretending all the world is either unicode text or arrays of 8-bit integers is just as stupid as overly conflating the two. All the data on a (modern, disregarding older architectures with word sizes that weren't multiples of 8) computer system is in arrays of 8-bit integers. What is pretended about that? String are the type for text where you don't care about the internal representation. When you know the representation, it isn't in the text format yet and needs to be converted - or it isn't text and therefore doesn't need to be converted and can be used as is.
I actually completely agree. PyCharm was the first IDE I got working with Anaconda's Py3 stack and it was straightforward.
As an aside, you can be setup in R in 10 minutes: 1. Download R from [the official website](http://www.r-project.org/) (this is your interpreter) 2. Download RStudio from [it's website](http://www.rstudio.com/) (this is your IDE) 3. Install any packages you want using the [install.packages()](http://stat.ethz.ch/R-manual/R-devel/library/utils/html/install.packages.html) command. (this is your pip/conda) You now have the same stack as some of the most advanced quantitative researchers in the world.
Except for the last 2, those are problems with anaconda, not problems with Python. I do understand that frustration though - and it seems like it's not really one of those things where you can end up learning something useful, because it's so mindless :-/ EDIT: Also, if you only had Python 3 installed wouldn't even be an issue :P That's some of the push for having Python 3 be the default on Linux distros.
Of course it works, since it's just humming along in its Java VM :-)
&gt; Java/C# have an interface that identifies a stream that yields strings and a different one for one that yields bytes. Python does not have that, because it's a dynamically typed language. It unfortunately also does not have a method or attribute that is required for streams to implement to identify them. So right now the only way to check which type of stream you're dealing with is reading zero bytes from it. Which apparently breaks for some streams. Ignoring issue 20007 (which is the only case of zero-bytes breaking I'm aware of), as of Python 3, at least in theory, io.RawIOBase and io.TextIOBase should be inherited in all stdlib file-like classes. Although this only gets so far given duck-typing, it does provide a further alternative. &gt; This is completely unfeasible performance wise in Python, you need to hack something together out of the primitives provided. Alternatively you need to write a C extension. Instead of making (yet again) large changes to the VM to change the language to resolve the unicode/bytes dichotomy, perhaps trying to do something about performance should be favoured?
I am frequently amazed at the ability of people to cargo cult some quite large pieces of software. As for the industry as a whole's inability to grok unicode I only have despair. I don't take the fact that a person has written some code to mean they are incapable of talking utter shite.
http://url.spec.whatwg.org/ should in principle match what browsers do with URLs; as far as I'm aware, everything sent on the request-line by (at least major) browsers is always ASCII.
&gt; Ignoring issue 20007 (which is the only case of zero-bytes breaking I'm aware of), as of Python 3, at least in theory, io.RawIOBase and io.TextIOBase should be inherited in all stdlib file-like classes. Although this only gets so far given duck-typing, it does provide a further alternative. There are too many custom stream objects out there. Relying on these classes does not work, I tried that.
ME was a trainwreck of features that nobody wanted and bugs that nobody wanted. 2000 on the other hand was a beautiful blend of everything that was good about 98SE built on top of the stability and modern features of Windows NT. I don't think he's confusing them at all.
Why not have a series of ustr functions that deal with unicode? I primarily program in C++. One of the core features is that pretty well without exception you can compile fairly old C code in the newest compiler. So that is generation after generation of C and C++ still working. They didn't toss printf in favor of cout. On a different programming front it was sort of funny when PHP went from 4 to 5. The vast majority of people made the leap because 5 was so much better in almost (but not entirely) every way. So you pretty well had people fork 4 to keep it going. I suspect that there are 4 stalwarts to this day. Personally I think that this has become a religious issue and the 3 crowd would see it as a serious blow to make a 2.8. But for most users of python they would probably happily go from 2.7 to 2.8 if 2.8 broke little or none of their code and happily ran all the sample code out there. If the 3 crowd aren't careful this whole thing could kill python altogether. 
I moved my personal code from 2 to 3 one weekend when I was bored. It doesn't take long if you're not dealing with stuff like in this post (low level bytes/string issues).
They're not ancient, but definitely antique. Have you seen the C code they output? A bunch of variables are explicitly declared `register`, there are a bunch of compatibility definitions for things like integer types, and you sometimes see code like this: #ifdef YY_NEED_STRLEN static int yy_flex_strlen (yyconst char * s ) register int n; for ( n = 0; s[n]; ++n ) ; return n; #endif Of course, this bespeaks a lot of effort having been spent on stability and compatibility; it's not at all surprising that they'd continue to work the same as they always have.
And if you look at the top voted comment in this thread, what do you posit? At my job, we're 100% Python 2, and I can guarantee you that it's not because we don't want to. We're working on it, we're going to get there.
Hmmm. Interesting. Thanks!
&gt; And if you look at the top voted comment in this thread, what do you posit? That you and 36 other people don't do much with communication protocols?
Unfortunately, just like it there still are huge swaths of mature python code and libraries that are 2.x only. If you'd like to add a voice, I'd suggest putting a star next to the "support python 3" bug, assuming it should already be there.
If those projects have easy to use issue trackers I'd suggest raising one to ask them to update their code to be python 3 compatible.
blinker claims it's Python 3 compatible and (apparently) has been for some time. flask-restful also claims 3.3+ compatible. flask-sass is not. It might be really simple to fix...going to go see what I can do.
Relying on them alone, no, but it does work as an initial attempt (before falling back).
See? You're the first to appeal to the will of the majority ("The evidence is that the community likes python 2"), and then the first to discard it. Do you really think that the majority of Python devs "do much with communication protocols"? Rhetorically, you're toast.
&gt; You're the first to appeal to the will of the majority ("The evidence is that the community likes python 2") Well, not the first. &gt; then the first to discard it Well, no. 36 people do not a majority make. &gt; Do you really think that the majority of Python devs "do much with communication protocols"? Yes, actually. Python is huge in web development, and computational science. Both of those involve working with bytes which represent structured text which makes up a format or protocol for transmitting information. Even if those developers aren't working at the lowest level, the representations at the lowest level leak, and infect the higher level APIs. And so, yes, that would account for low adoption of a version of python which is worse for that task. 
Heh, the one browser I wasn't sure about behaviour of. :) Encoded as what? I'm guessing the current locale default encoding? What if you use something that isn't in that character set? [Edit: I couldn't reproduce this happening in IE11; Googling suggests IE6 pct-encodes the request URI, but transmits the host as (raw) UTF-8 in the Host header.]
Or, you could use Python 2, and avoid the pain you went through. 
I decided just a few days ago to add this import to all my new (2.7) projects: from __future__ import (absolute_import, division, print_function, unicode_literals) Is it a good practice? Now as I read all these problems with strings, I'm in doubt concerning the `unicode_literals` part.
&gt; You confuse web development (a.k.a. using a web framework) with web framework development (a.k.a. making a web framework). Did you not read: &gt; Even if those developers aren't working at the lowest level, the representations at the lowest level leak, and infect the higher level APIs. 
Encoded as utf-8 or latin1 if I remember correctly.
Man, I never realised the massive scope of engineers that IE could manage to annoy. Even backend devs.
And your writes are just as slow (probably slower) than a traditional database. At this point, are you any better off than just using a tradional database?
It's just a different attitude. Python's goal is to be simple and only have one way to do something so they made breaking changes in Python 3 with that aim in mind.
And that's 80% of the people who are relatively interested in the development of python /itself/, as they are on python-dev / python-list.
I presume by latin1 you mean windows-1252 (as opposed to ISO-8859-1, which practically doesn't exist on the web)  but see my edit above; this doesn't seem to happen with IE11, and I can only find references to the Host header, not the request-line itself.
It's pretty slow.
Yes, windows-1252 :) //EDIT: there is one utility which is widespread and also shows that behavior: curl. Can't test IE myself right now because I'm on a mac, but you can easily reproduce it with CURL :)
&gt; What is pretended about that? Nothing. I just don't *care* about the bytes; they are irrelevant to almost everything I want to do in Python. Off the top of my head the only occasions I'd run into legitimately binary data is things like compression, encryption, or weird formats I probably don't want to parse myself anyway. Most of the time this stuff just gets handed off to C code. So I don't care. What I *do* usually care about is pseudo-text. There's a lot of it out there in the form of not-quite-ascii protocols or things with poor standards or badly behaving software and lots of other things that's perfectly sensible to want to handle in Python. Some of it can be decoded to ascii, but that's just a convenient lie and not always actually possible. Leaving it as `bytes` is the "proper" option but Python 3 makes this a nuisance to do: the type itself has stupid behavior and the standard library randomly discriminates against either `str` or `bytes` in arbitrary ways. Until somewhat recently, for example, the `binascii` module would [refuse to decode hexadecimal](http://bugs.python.org/issue13637) if the input was a `str`. Python 3 has some nice principles, but they're uncompromising and badly implemented and reality is not so kind.
if PyPy gets enough numpy compatibility that we can port pandas to it (or something with the pandas interface), that would be really nice...
HTTP is based on ISO-8859-1, it's right there in the RFC. However we can't send codepoints over the wire, we can only send bytes, so every network protocol is bytes, that's a trivial tautology. This has nothing to do with whether or not URLs are text.
A Python 2.8 could make it easier to move to Python 3 if it offered a way to elect to use bytes/text on a per module basis. There's existence proof for this approach: python-future.org has such a facility. I don't believe all has been done to Python 2.x yet to let people upgrade to Python 3's way of doing things incrementally, while keeping code reasonably clean. A standard way forward for people to help migrate code further would help. Of course if you define Python 2.8 as a Python version that doesn't help with the painful bits, you're right. But that's stacking the deck in a discussion By the way, your counterfactual scenario where Python 3 uptake would have been faster without a Python 2.7 release seems rather hard to prove. You can boldly state it and then conclude from it that Python 2.8 would make things worse, of course, but you'd have to back it up. 
&gt; Why do people have such trouble understanding that text and binary data are different and not interchangeable. Because if you only ever speak English, and ASCII encoded network protocols, it's *really easy* to pretend they are and have 99.9% of things just work anyway. Most never even realise a 1% or 0.1% problem exists.
I didn't think of this as a conda issue at all, but a library or pypi availability issue. In fact, I'm extremely happy with (Ana-)conda and it's made out lives much easier. Especially the poor OS/X guy's, but it also allows us to deploy across differing ubuntu versions without significant problems. The one thing, and I promise to write this up in the morning, is that basemap 1.0.7 (the one that's available) requires matplotlib 1.3.0 while there is a 1.3.1 release in Anaconda and, wouldn't you know it, we're using the expanded support for alpha channels introduced there. **Edit:** I'm going to have a better look at the failing libraries and test which of those will install in virtualenv and pip. Anything that works in virtualenv+pip and fails in conda+pip I'll post issues about. It's just that I've had a couple of glasses of wine and I'm not in a state to do meticulous comparisons like that.
This is great, thank you, please keep them coming!
right so I can't seem to figure out how the survey proves that people who "refuse to adopt python 3 are in the minority" the survey sited proves the exact opposite to me. 
More great new features I can only get depressed about as I won't be able to use them any time soon... How I wish for the times where that wasn't the case. 
&gt; One of the core features is that pretty well without exception you can compile fairly old C code in the newest compiler. For any cross-platform project, though, that is *really really old* C, either C89 or ANSI (Because... Microsoft MSVC, who would've guessed). Congrats, the spec for your language that is 20 years old works, I'm sure it's a joy for everyone to use. &gt; If the 3 crowd aren't careful this whole thing could kill python altogether. 2.8 would kill 3 all together, for the reasons you listed - people would be happy to stay on a 2.x interpreter and give zero fucks about ever migrating major version numbers. So it depends whether you want 3 to die altogether or not.
If that's too slow it doesn't seem like there's any way to bolt on a new type to Python that wouldn't be too slow.
Why? People use wsgi nowadays..
Thats why you create separate unicode friendly commands and distinguish them all with an u or something. C++ had no problems with std::string and unicode. There has been a little dance with wstring. The same in the Qt environment. Their QString class made the transition very smoothly. No need at all for a non backward compatible leap. I would say that Python could add braces (dumb idea) while keeping backward compatibility. I think the whole 2.7 3.0 thing was convenient for the Python developers but not for the developers using python. 
I feel like I'm missing something here. Python 3 still lets you work with arbitrary strings of bytes. It's called `bytearray`. Python 2 had a similar division, but it was implicit and would often cause conversions and exceptions in places you didn't expect. Python 3 makes the division explicit. Sure a few library functions and APIs were changed to only work on unicode strings, but that's a problem with those APIs not being well updated for the division and supporting bytearray too, not the problem being that there is a division.
Hi thanks for comment. Why? Just because I'm a total noob and I don't know any better. :-) Now you've mentioned wsgi i'll look into it.
yeah, that one cost him some of my respect. * support for non Unicode data text what does that even mean? non unicode is equivalent to a subset of unicode or something as exotic as TAFKAPs symbol. * From a purely theoretical point of view text always in Unicode sounds awesome. And it is. If your whole world is just your interpreter. Unfortunately that's not how it works in the real world no. bytes is data that may be decoded to text. and text can be encoded to bytes again. if you cant decode stuff due to flawed data, leave it as bytes. * &lt;use cases of default encoding&gt; (encoding coercion): no, those ale all surprisingly insane for python. glad this stuff is gone and doesnt cause subtle errors all over the place anymore! * For instance you could no longer parse byte only URLs with the standard library with emphasis on the past tense: bugs happen and get fixed.
Thinking about C++ (which I mostly use and thus would be the most passionate about) I would be really ticked if C++14 broke my code in any way but the most superficial (such as adding a keyword that I use as a variable right now). So if the core C++14 developers did that I would never use it and advocate for a new C++ steering group who's first job would be to toss C++14. Now I am not so aware of the nuances of Python; so for all I know people were crying on the streets for the changes made in 3 and that backward compatibility would have caused people to break out the torches. 
Forgive me as I almost never work with unicode in python or otherwise, however isn't the issue fixed in 2.x by disabling the automatic string coercion? It seems like a world in where str() and unicode() exist as they do in python 2 but require explicit conversions between one another with .encode() and .decode() is a good solution.
But there are working projects in the same sort of problem domain as mentioned in your post (web application frameworks or HTTP clients) which apparently haven't needed the integral interpreter support you're saying is necessary.
&gt; The duck typing worked on 2.x for the most part But it sometimes made stuff harder to reason about. I remember having problems with porting Werkzeug's URI functionality (before you added 3.x support) and IIUC you had to rework a reasonable part of the URI functionality when you addressed 3.x support.
Of course they don't *need* to. Flask, Django, Werkzeug and many other things work just fine on Python 3. That however does not make the code look nice.
Fingers crossed for a sane Python 4.
God, I wish.
Python and C++ are pretty different languages with different histories, heritage and uses, though. I don't think it's very useful trying to compare worthwhile reasons for breaking backwards compatibility between the two. Plus, I doubt you'd call a backwards-incompatible C++ simply C++14. ATM that's intended to include minor improvements only.
I'd like to parse whatever text is on a website even if that website contains invalid unicode points. I'd prefer python not to throw its hands up in defeat. Said text should be text because it is text. Binary files contain text. I'd like to run regexes on them please. &gt; if you cant decode stuff due to flawed data, leave it as bytes. Get fucked. I want anything that can be treated as text, as text. Even if it's a token that contains an invalid character. It's pricks like you that give python a strict html parser and then expect it to work worth a damn. While the world needs libraries that won't lose their shit entirely when the 2nd byte of an otherwise fine file has the wrong bit set. 
Python 4, as it'd break backwards compatibility.
&gt; It's just that these cases aren't widespread enough to warrant a full literal treatment. Aren't widespread enough? What's python 3 adoption at this point? 5%?
You'll take my correct 2.7 division from my cold dead hands.
And we're glad that there's people like you elevating the level of discourse. Decode your bytes as `latin-1` and save your ranting for another day.
They're not latin-1. They're *mostly* unicode.
Caution here, Tornado is a framework that refuses to play nice with other code.
&gt; Rust's strings are utf-8 internally and can be unsafely transmuted into a vector of u8s Safely, actually: `my_string.as_bytes()`.
No, it's broken. File paths/names in Python 3? Unicode. Filenames in Linux? Bytes. It *cannot* work. With Python 2, it's a PITA; with Python 3, it's impossible. Like the article says, Python 3 is lovely in theory, but broken in practice. And the core devs are pretending that their oh-so-strong belief in The Right Thing will somehow warp reality to match their wishful thinking.
Yeah, you're wrong. Completely wrong. The author of the article is one of the most prominent, most skilful Python devs around. And, apparently in contrast to you, he runs up against the limitations of Python 3 on a daily basis. The most egregious example I've come across is that Py3 treats filepaths as unicode. On Linux filesystems, they're explicitly bytestrings. There's no way around that, regardless of what Python pretends.
Because people are dependent on Python 2 dependencies. The survey clearly indicates that.
Not necessarily. 2.x made incompatible changes regularly, just in a piecemeal fashion, and it mostly involved library features rather than core features. But the underlying deprecation scheme is quite sound.
Also, just to attempt some soothing words to the debate: I work on a project which passes a lot of binary and text files back and forth between Python 2 at the bash shell and Python 3 in the Blender internal interpreter. I have to admit I've had way less problems than this blog post implies. From some comments here it feels like the first time I reached for a linux filepath in Python 3 I would get unexplained unicode errors or something. Not the case.
Seriously, instead of splitting the community into 2 pieces you're splitting it into 3. 
What I'm saying is that if they ever came up with a backwards-incompatible C++ that regardless of its name it would either be the end of C++ or the end of the steering committee. I like Python. But what the PSF doesn't seem to realize is that they are playing with fire. This sort of war can kill a language. There are other languages out there. It won't happen overnight but once a person drops a language and moves on then they are generally lost forever. Also they will not only find another language but stop evangelizing Python and start evangelizing whatever they found to replace it. So if PSF ever dropped support for the 2.7.x series then I am gone. .Net lost me when they bloated the language to try to sell other MS products. Java lost me because they started bouncing around fundamental architectures from AWT to struts and so on. Perl lost me because PHP was a better web language. Objective-C lost me because I can now use C++ for iOS and it is portable to other platforms. Oracle lost me because MySQL was easier to install, lighter weight, and it was free. XML lost me to JSON because of KISS. MySQL lost me to MariaDB because Oracle. But some things haven't lost me: C++, SQL, Qt, Cocos2d-X. Of these Cocos2D-X has depreciated a few things but nothing fundamental as strings and the replacements are usually a global search and replace to fix. The other key is that I don't get any sense of anger or conceit when things are fixed. It is more of a: Everyone was begging for this fix so we delivered. In all the areas that I just said haven't lost me they have grown immensely over the years. Little of my C++ code or Qt code look much the same, so in fact, they could have dropped many features as there are better ways of doing things now. But they don't. (Qt did get rid of somethings but nobody used them much). 
I shamefully admit to being one of "those bemoaners". So many, many thanks for doing this.
Boggles the mind, eh?
&gt; I wonder what happens when Python 3.4 won't be used just like Python 3.3 hasn't? That really isn't a fair thing to say at all. If you look at the [python 3 WOS](https://python3wos.appspot.com/) you'll see that 141 of the 200 most popular python libraries support python 3. Even if you can convince yourself that most of these packages only support 3.x because some python 3 fanatic wanted to show there was packages, it would only mean that they were lowering the barrier to switching. &gt; So maybe Python 3 needs a second moratorium, one which effectively stops advancing language and features beyond Python 3.4 which do not serve the 2to3 transition. Any features that makes programming better in python 3 will help get people to want to switch, if you're talking about having a single codebase that supports both that would be a different story. &gt; A possible exception may be anything which has to do with the GIL.. The GIL is an implementation detail, and doesn't really have to do anything with changing the language. 
And then support needs to send someone into the database to kill off a macron. 
So many people are also novice developers. Google "MongoDB loses your data".
Having written projects in both 2 and 3, I can say that I prefer 3 hands down. I have had a few situations where a library I needed wasn't fully ported (twisted and a few others), but it seems like there's more and more effort to bring those libs up to Python 3 compatibility. Someone commented on maintaining legacy code and legacy OSs. Yes. If you let your code fall behind current software developments and trends, you're going to have that problem. It is hardly the Python developers' jobs to help you maintain ancient relics. So if you try to get it running on FreeBSD 6 and there's no port for it, that's your problem. I've worked for several companies in a similar situation- language lock-in with a dead language, OS specific code that new versions don't support, etc. After seeing it so many times and hearing the same reason, "we didn't have time to update", I no longer have sympathy. You must make time to groom code and upgrade OSs. Period. As for Python 3.4, I'm excited to test the improvements. I've run into many of the problems that the devs seem to be painfully aware of, so hopefully I can go back to my projects and do some real testing of new features.
For comparison with the other article recently posted on Reddit from Nick Coghlan: http://python-notes.curiousefficiency.org/en/latest/python3/binary_protocols.html#binary-protocols Nick says: &gt; do [conversion] right (i.e. converting to the text format for text manipulations), knowing that this may lead to performance problems on Python 3.2, but will benefit directly from the more efficient Unicode representation coming in Python 3.3 Armin says: &gt; It makes writing code for Python incredibly frustrating now or hugely inefficient because you need to go through multiple encode and decode steps Does that mean that Nick's assertion is incorrect? Is there a performance penalty for the multiple conversion steps? Does anyone have any data to backup the inefficiency claims of the proposed Python 3.3+ solutions? *** Also, Nick's article didn't address a great point that Armin brought up: &gt; My favourite example now is the file streams which like before are either text or bytes, but there is no way to reliably figure out which one is which. The trick which I helped to popularize is to read zero bytes from the stream to figure out of which type it is. If true, that seems like a fairly big gap between 2 and 3. Knowing what a ~~file stream~~ file-like object will return seems fairly important for "people that are writing the libraries and frameworks on the boundaries", and a legitimate gripe. Is fp.read(0) the only way to get that knowledge? 
No, as a beginner I'm confused about why someone doesn't want to move on. Coming from a language with four (!!!!!!!) string types and still in the process of moving to one - and dealing with reactionaries threatening to leave if they lose ANSI strings - I found Python 3's string handling the most wonderful, amazing, perfect implementation of Unicode and strings the world has ever known. I was dealing with strings that carried encodings around with them like dragging a dead weight. Now - the most simple and amazing realization in the world: there's no such thing as a unicode string! Strings are sequences of glyphs. Unicode is an encoding of bytes. Asking what encoding a string is in is an illogical question. Amazing! And now to see someone claiming that the most amazing, simple implementation of strings the world has yet seen is broken and we should all go back to the madness I left behind of multiple string types - THAT'S confusing. And sad. I'd hoped to leave that kind of thing behind, but at least in Python it seems that reactionary attitudes are the minority rather than majority. 
It hasn't been confusing for me at all - I just don't deal with 2.x ever, the same way I don't ride a horse and buggy or churn my own butter. If I see a learning resource that's using 2.x it registers immediately in my mind as if it said "Windows 98" and I discard it as being old and irrelevant. &gt; the idea that a mainstream python IDE doesn't work with the official, active &gt;Python release version sounds f**king stupid. It's partly a reactionary mindset and partly Guido's fault for not behaving like a Linus Torvalds-like tyrant the one time he needed to be and shoving people into Python 3. I looked at Spyder and remember deducing from their website that they didn't support Python 3. That said, there was a beta or alpha or something that did work with Python 3. Eric5 (although I'm playing with PyCharm now), Pandas, NumPy, SciPy, CPython, IPython... I haven't had a problem with Python 3 and data analysis so far. Resources like Head First Python, Dive Into Python 3 for learning. LPTHW turned out for all the hype to just be a bunch of coding exercises with negligible learning material, along with being based on old Python. Just think of Python 2.7 as Windows XP. It's old and creaky and people will say "I have no compelling reason to upgrade" even though there's really lots of compelling reasons to upgrade and they'll be using it until the day the support gets turned off. You just learn to scan for a sign that the book/software/etc. you're looking at is for the popular old or current new version. 
Why would you want to write one line of code with an obsolete version of Python? Stay with Python 3 and don't contribute to the mess by switching to Python 2.7 and writing old code. 
2009 makes it mature? As my boss used to say, "I've got socks older than that!" :-)
IPython might be more mainstream though for science... 
I feel like I'm missing something here. I used to have all sorts of issues trying to handle Unicode properly in 2.x to the point where my over-reliance on UnicodeDammit was seriously concerning me. 3.x makes handling Unicode a breeze, and at what cost exactly? I'm unconvinced that any of those outlined in the article are anything more than implementation issues. Honestly, my only issue with the transition was the realisation it caused me that I'd been very very *lazy* with all things relating to string processing for years. The true issues I had with Unicode in the past were really rooted in the lazy acceptance I had of strings and bytestrings being somehow interchangeable. Now the distinction between bytestrings and strings in 3.x is much more explicit, easy to handle, and conducive to good practice. And I really can't believe this is apparently a core issue to the 2.8 people. I really don't know what I'm missing here.
I've seen comments that did indeed advocate releasing 2.8 and phasing out 3.0. I then announced that I was appointing myself a representative of Python 1.6, officially decrying the compatibility-breaking change to Unicode in Python 2.0 and demanding a release of Python 1.7 and the phasing out of 2.x. ;-)
Although, there a multiple ways of doing things, one example of a web stack would be like this: * nginx - web server * uwsgi - WSGI gateway handler (nginx &lt;-&gt; python) * Flask, Bottle or even Django as your framework of choice.
Windows 2000 was NT 5.0, XP was 5.1, vista and the rest of the newer versions are 6.x.
I think it's really important to find ways to make writing Python 2.6/2.7/3.3 compatible code easier under Python 2. Providing this on a per-module basis is vital if conversion of packages is to happen in parallel. A 2.8 interpreter release should be a last resort though, other mechanisms (import hooks?) should be investigated first.
Nope, it doesn't. I am a regular on the Python tutor mailing list, which is aimed at beginners, and believe me, the differences between Python 2 and 3 are the least of their problems. Yes, there are a few confused emails wondering why they get a syntax error for `print "Hello World"` but for the most part they just pick a version and learn it.
The problem with ``sys.setdefaultencoding('undefined')`` is that it is global, effecting all the libraries used, not just your own application code. For people to write forward compatible code under Python 2, I think we need some way of enabling it on a per-module basis.
More like a couple of minutes to learn the syntax changes, and a couple of days to get used to the new library names.
&gt; The author of the article is one of the most prominent, most skilful Python devs around. And, apparently in contrast to you, he runs up against the limitations of Python 3 on a daily basis. Just because he might be the most and skillful Python dev ever still doesn't mean he knows jack shit about unicode. &gt; The most egregious example I've come across is that Py3 treats filepaths as unicode. On Linux filesystems, they're explicitly bytestrings. There's no way around that, regardless of what Python pretends. Well, Python also runs on other platforms. VFAT, NTFS, HFS+, ZFS and [many others](http://en.wikipedia.org/wiki/Comparison_of_file_systems#Limits) do use unicode (most often encoded as UTF-16). Just because Linux restricts paths to 8 bits (and it uses as encoding whatever does not mean Python should place that restriction on anything else. In any case, when Python is accessing filesystem it encodes unicode to whatever [sys.getfilesystemencoding()](http://docs.python.org/3/library/sys.html#sys.getfilesystemencoding) returns. For Linux, BSD and others this returns UTF-8, which is pretty much accepted standard anywhere where US-ASCII is not enough, as long as you set LANG variable correctly all system commands (ls, cp, mv etc) will work just fine with non ASCII characters. Many distros set it to en_US.UTF-8 by default.
Hear hear! If you want a challenge, try supporting Python 2.3 through 3.3 in one code base! Not that I do this -- I gave up on 2.3, and I'm thinking of dropping 2.4 as well.
I'm not shameful about it, the docs aren't very good, the tutorials aren't well spaced and half the examples don't work.
Great stuff! I'm currently making GUI tools for controlling hardware over the serial port - I need semi-async execution all the time. I will try this tomorrow, thank you very much!
Not so huge. The "Python Wall Of Shame" became the "Python Wall Of Superpowers" a long time ago. The majority of popular Python libraries have supported Python 3 for a while now: 70% of the top 200 libraries. https://python3wos.appspot.com/
python broke stuff but it was for the best. Bytes and strings are not the same thing, so mixing and matching them doesn't make sense, and everyone is just irritated because they have many years of work invested in the now 'improper' way of handling strings and bytes together as if they are the same thing. 
Great write up. It seems to me that breaking compatibility is for the overall benefit of the many. Whilst it is unfortunate that the 'few' in this situation are mainly framework authors, I'm sure we'll all be glad once the transition is FINALLY over.
All this is why I believe that IDEs are the *wrong solution* for developers. Or at least, Python developers. Python is not Java, and it shouldn't require the same level of hand-holding to get things done. http://michaelochurch.wordpress.com/2013/01/09/ide-culture-vs-unix-philosophy/ IDEs are more of a symptom rather than the cause, but if somebody calls themselves a Python programmer but can't manage to install Python from source (at least on a Linux box), or be at least moderately productive with nothing more than a plain text editor and the built-in interactive interpreter, then there is something seriously wrong. Yes, even Notepad, when push comes to shove I've written small projects in Notepad, it's possible and while we all love to hate Notepad it's really *not that bad*. (You should try using `ed`, the Linux line editor.) I'm sorry to be harsh, I'm actually not trying to attack you, but perhaps inspire you to stop being beholden to the IDE and roll up your sleeves and get your hands dirty. You learn so much more that way. Even if the only thing you learn is that an IDE is better for you and you'd rather pay somebody to install Python than install it yourself, that's still a good lesson to learn!
The problems that Armin Ronacher is talking about has nothing to do with whether strings are known by the interpreter. The only thing that you gain by interpreter support is that you can write string literals `"spam eggs"` rather than have to coerce them to the extension class `bytestr("spam eggs")`. Most uses of strings in a library are variables, not literals, so this really doesn't matter.
Why are you talking about things being "magically accepted by Python internals"? What does that even mean?
You're joking. A majority of Python users are now using Python 3 at least in part: https://wiki.python.org/moin/2.x-vs-3.x-survey One Fedora move to making Python 3 the standard system python, that will encourage Ubuntu and others to follow, and that will *really* accelerate the migration. I give it another five years, and Python 2.x will be as dead as 1.x.
Nah, that would take actual work. The haters are constantly asking for *somebody else* to come out with Python 2.8, but they won't fork it themselves. Even if somebody did fork Python, they wouldn't be able to call it that, the PSF would see to that.
For context, [this post](http://lucumr.pocoo.org/2014/1/5/unicode-in-2-and-3/) expresses what the author refers to in the first paragraph or two.
If I could upvote this a dozen times I would. There is absolutely nothing wrong with running old obsolete code. I know of a guy at the last PyCon who is still using Python 1.5 in production. Good for him. But that shouldn't be permitted to hold everyone else back.
What py3 debacle? A few whingers complaining is not a debacle. The plan was always to make it easy for people to *avoid migrating* for many years. The fact that people have avoided migrating is *part of the plan*. Ten years is how long the core Python developers expect it will take to migrate everyone away from 2.x. We're only half way through. No, a debacle would have been if Python followed Perl's lead, and just talked about how awesome Python 3 would be, when we eventually build it in another 10 or 20 years. Or if Python had followed Delphi, and never actually forced the cut over. In another five years or so, the issue will be forced. Until then, if people want to take their time with Python 3, and wait for 3.4 or 3.5 or 3.6, good for them. Just stop with the FUD.
Eventually you'll need to migrate to Python 3, either that or find some company that will charge you big $$$$ to support Python 2 with security patches. But you've still got plenty of time -- nobody is expecting Python 2.7 to drop out of official support for another five years.
It is a good solution. There are a few applications where it is useful to blur the lines a bit, and Armin Ronacher is working on one. That makes him cranky, because he's now responsible for explicitly blurring the lines, instead of having Python accidentally and implicitly blur them for him as it used to.
&gt; Multibyte text has one coding Wrong. There are many multibyte encodings other than Unicode. Most of the legacy encodings in use in East Asia are multi-byte. 
Deprecating ASCII as a default is a very sensible move. Having dealt with constant problems with Chinese and Japanese languages I am very pleased. A reasonable alternative would have been defaulting to utf8 - at least then character strings can be passed around deep inside. Obeying the system encoding would have also been a good alternative (I always set mine to en_AU.utf8). Explicitly setting the encoding is also a good alternative
&gt; Is there a performance penalty for the multiple conversion steps? Of course. If you sweep the dust from one side of the room to the other, and then sweep it back to the first side, then sweep it to the other side again before picking it up, that's going to be more effort than sweeping it once. Armin has picked the *worst possible way* to handle text/bytes, namely to repeatedly encode and decode backwards and forwards from one to the other. You should only encode and decode on the edges -- decode bytes to text when they come into your application, encode text to bytes when it leaves. Or possibly the other way around, if that's what your application needs. There may be some technical reason why Armin cannot do that, but I doubt it.
&gt; PHP was a better web language Ha ha ha ha!!!!! Oh man, you ought to go into stand up comedy. PHP is *rubbish* from start to finish.
&gt; I think the whole 2.7 3.0 thing was convenient for the Python developers but not for the developers using python. You're joking, right? This has been a **HUGE** extra burden for the Python core developers. They didn't do it for their jollies, they did it because it is the right thing to do in the long term.
&gt; Armin has picked the worst possible way to handle text/bytes, namely to repeatedly encode and decode backwards and forwards from one to the other. Out of curiosity: how do you get the idea that I'm doing that? All my libraries encode and decode at the boundary and have been doing for years and years. I took good pride in having really good unicode support well before Django or Paste did.
We won't have to find another company to support our python 2 codebase. We have over 200 python programmers already that are quite capable of supporting any product of ours. I doubt we'll switch to python 3 though. Chances are we'll just switch to another language with better support of concurrency. 
 &gt;&gt;&gt; def divide(a, b): ... print a / b ... &gt;&gt;&gt; divide(5.0, 2.0) 2.5 &gt;&gt;&gt; divide(5.0, 2) 2.5 &gt;&gt;&gt; divide(5, 2) 2 For me it doesn't seem to be a "correct" behaviour. If I pass real values, everything is fine. If I forget and pass integers, I get a different result. Wat?
Noob question here but, what do you use to edit your code?
Why would anyone use Notepad when there is the free alternative Notepad++? No one uses ed either. Unix geeks stick to vim.
Oh, that's fine, I wouldn't notice if not your comment :)
Then you **need** to watch these vids. I'm up to chapter 6 and these are really well done. Starting right at the beginning and going step by step. Great!
it seems [Armin Ronacher](http://lucumr.pocoo.org/2014/1/5/unicode-in-2-and-3/) (/u/mitsuhiko) wants the added option mentioned on Nick Coghlan's write-up: &gt; develop a custom extension type for implementing a str-style API on &gt; top of encoded binary data (this is hard to do without reintroducing &gt; all the problems with ASCII incompatible encodings noted above) ... &gt; The last option is still one of the options for possible future Python 3 &gt; improvements listed under &gt; [Is Python 3 more convenient than Python 2 in every respect?] (http://python-notes.curiousefficiency.org/en/latest/python3/questions_and_answers.html#room-for-improvement) So, a STR-Style API for binary data might come on the future... (one can hope that it would have good performance ) making everyone happy!
Exactly. See my windmill fight [here](https://github.com/tals/uber.py/issues/1) for instance :)
I agree, it's indeed silly.
yeah, it would be a good practice if more 2.x APIs would work with unicode. with python3, everything is right, though; you wont even need that line.
which in no way proves that "people that refuse to to adopt python 3 are **in the minority**" do u even logic bro? 
&gt; Why would you want to write one line of code with an obsolete version of Python? Because it gets shit done. &gt; Stay with Python 3 and don't contribute to the mess by switching to Python 2.7 and writing old code. No, thanks, it doesn't get shit done.
The libraries I care about (sqlalchemy, kivy, etc.) that work in python3 work in python2 as well, and will continue to do so for the foreseeable future. from _ future _ import covers the few things from python3 I consider worthwhile bothering with (eg. absolute_import), and [virtually no one is using python 3 for anything serious anyway](http://alexgaynor.net/2014/jan/03/pypi-download-statistics/). I'm far from impressed with either the features on the 3.x line, or the response from the core developers to what is clearly some quite robust criticism (seriously? up to 3.3 no one has been using it, but 3.4 will be amazing!) Here are some things that would make me consider using the 3.x line: - A proper first class way to publish applications (binary distributable) that works better than py2exe, pyinstaller, etc. - A proper first class port to the ARM architecture with support for mobile platforms. - A simplified embedding process for bundling python as a scripting layer into other applications. Here are things I couldn't care less about: - unicode - function annotations - interators that work differently - a standard library with modules in various slightly different places - embedded pip and virtual env &lt;--- Great, but these already work - a *more complicated* way of [embedding python](http://stackoverflow.com/questions/18245140/how-do-you-use-the-python3-c-api-for-a-command-line-driven-app) (...which list do you think made it into the 3.x line?)
hmm, when you said &gt; It makes writing code for Python incredibly frustrating now or hugely inefficient did you really mean *writing* code became inefficient, as opposed to running that code became inefficient? in the former case, i cant agree: some corner cases need you to be more explicit, but thats a good thing! and in the latter case, i also dont see why: youre still en/decoding at the edges once.
creating 2.8, i.e. further reducing the incentive to port to python 3, would kill python alltogether.
No shame, I didn't intend it as an insult! I think kivy's documentation is pretty okay, but is lacking in some examples and tutorials, and I think there was almost no video tutorial stuff before.
I mostly use emacs (including in the video). It's fairly vanilla, but with evil-mode for vim keybindings, and conveniently there is an emacs mode for syntax highlighting and appropriate behaviour in kv language.
not at all ATM, but it slowly becomes more painful as python 3 gains new features. tulip (asyncio) is the first thing that makes it really painful (no `yield from` in python 2)
"Let your code fall behind current software development and trends" -- but that's not what happened. Instead Python went ahead of current software development and trends, and still is, if you look at PyPI download figures. 
I'm somebody who loves Python and have contributed to it and have been active in it since 1998. I helped start EuroPython and everything. But I also use Python on a day to day basis to get stuff done. Since Python 3 those two sides of me have been increasingly been pulled apart. :( 
python-future is a step towards such an approach. I think making something like that official as Python 2.8 is important though - many people won't see python-future, and Python 2.8 will be visible to everbody. There should be one way to do it, and I think after 5 years if we can't think of one way to do incremental upgrades to Python 3 from Python 2, then will we ever? 
Thank you for this video! I was planning on compiling my Kivy app this weekend, but now I'm glad I procrastinated. Your second video had a ton of useful information for compiling to APK. There is only minimal information available on the compiling to APK, and your video probably just saved me an hour of troubleshooting, thank you!
You are right, I was lying. The whole post was a grand conspiracy to undermine Py3. And I would have gotten away with it if it weren't for you pesty kids and that talking dog.
getting stuff done != working in a fixed environment as a scientist, i also get stuff done  using whatever tools i choose. i chose python 3 for every job without specific requirements, and didnt have any library problems for some years (except that one time i wanted to try OpenOpt, but i didnt really *need* it)
The evolution of this is sort of weird. Initially the internal Unicode representation of Py3 was a series of code points with each code point represented with 16 or32 bits. This was considered inefficient or not portable so now it is done as a variable length encoding. But that variable length encoding is explicitly not UTF-8 as one might expect but a brand new variable length encoding that better preserves the notion of a string of code points. The problem here is that there are few practical applications for a string of code points so there isn't any point in having everyone go through any amount of pain to support such a thing. It seems like things are heading further away from usefulness for no reasons other that philosophical. Python might be better off by just using the popular and useful UTF-8 as a generic internal encoding. That's assuming that there is actually any value in a generic internal encoding. I am still not sold on this...
&gt; * PEP 435, a standardized "enum" module it's what i've always wanted. 
He means the interpreter. Once a Python version has been fully EOL'd, it doesn't even get security patches anymore. At that point, you basically have to rely on RedHat or similar to do it for you, or maintain the interpreter yourself.
He's right in that case. But we still have some time and I'm really interested in what Stackless can bring in terms of features and security in the nearest future (related to 2.8).
It still makes sense. It's an edge case so optimising towards it (legibility-wise) is not necessary. Although I'd have string management to be Python 2 and leave it there. Take the other features of Python 3. Maybe go this way for Python 3.X? Unicode cannot/shouldn't be the foundation of all string management because it doesn't/cannot cover everything out there.
&gt; as a scientist: that data is extremely incomplete and certainly not representative. Unlike the microscopic sample size survey that is being quoted on https://wiki.python.org/moin/Python2orPython3 you mean? The one which had all of 5000 respondents? And I quote... &gt; Some people just don't want to use Python 3.x, which is their prerogative. However, they are in the minority. A little bit of proselytizing going on there I dare say. I really do look forward to having access to a nice big chuck of pypi data to play with. Until then, I guess we'll agree to disagree. I think that although it's a relatively short (27 hour) period, **1981765 package installs** is relatively representative. As for your other points, I maintain staunchly: I really don't care how technically superior obscure parts of the python 3.X line have become. Unless there is a tangible benefit for using it, I won't be. All of the best features of python3 will *remain unused for the foreseeable future* by libraries that plan to continue to support python2 and python3 on the same code base (like the ones I mentioned). That includes the libraries I maintain; the tests pass in 3.3, maybe someday someone will actually use them in 3.x. *shrug*
I actually meant "variable length" to mean that. I suppose this would be a good time to point out that such a scheme means that the addition of a single "larger" character in a code point string would suddenly cause the length of that string to double or quadruple in size. Not really a good method compared to any obvious alternatives.
Sadly, in the real world there are horrible protocols like HTTP and MIME/email, horrible interfaces to such protocols like WSGI and horrible implementations of standards, like mis-encoded URLs. All must be handled by realistic applications, but that is harder in Python 3 for no particular reason.
**Summary:** Python 2 is better for dealing with text and bytes than Python 3. I hate working with Python 3. It makes me angry to see people who have been working on Python 3 say it's better than Python 2. The Python 2 way of dealing with Unicode is error prone. Python 2 does confusing things (implicit type coercion) when bytes and Unicode are mixed. This makes nonsensical things seem to work. But text processing in Python 3 is not mature enough for me yet, and I hate working with it. The codec system has taken some time to mature in Python 3. There are still some rough edges. On the other hand, Python 3 codecs give nice error messages when the wrong type is used. Still, I'm really mad that they took away `bytes.encode` and `str.decode`. But I'm so tired of arguing about it I don't care anymore. Text operations only work on text in Python 3. That is, they only work on Unicode not bytes. Some APIs have been upgraded to be Unicode-only, although the only examples I can think of to list here (email and `urlparse`) have been fixed. Decoding bytes to Unicode to do text processing is not practical in the real world. The Unicode support in 2.x was far from perfect. There were missing APIs and problems left and right, but we had workarounds for that. Now some of those workarounds are broken. For example, the stream protocol needs a reliable way to determine the stream encoding before reading from it. There are may more problems with Python 3's Unicode support (but for some reason I will not list them here). I am fed up with reading about people who think Python 3 is amazing. I nearly published a piece about how we should kill Python 3, but I'm not going to do that now. Python 3 core devs should be more humble and listen to those of us who hate it. I think Python 3 is a failure (have I mentioned how much I hate Python 3)? **My thoughts:** You're a brilliant developer, Armin. We need people like you to make Python 3 better. The transition from Python 2 to 3 is not a painless one. Keep working on trying to expose the weaknesses of Python 3, and try to present them in a constructive way so we can continue make Python great for beginners and seasoned devs alike.
For making the typical web page it is very good. It might not set a CS professor's heart aflutter but if your goal is the rapid development of basic websites, then it does its job.
Last I checked Paramiko needed to move. https://github.com/paramiko/paramiko
I think you should at least use google before asking suck blatantly basic question you fucking tourist.
Check https://python3wos.appspot.com/
You should contact archive.org to see about getting your material there.
Too late, learned the hard way a while ago. 
I _think_ it's been ported: https://github.com/paramiko/paramiko/issues/16
I tried about a month ago on an Arch box using Pypi. Don't have a python 3 install handy so I cannot say.
Holy hell, I can't believe you got that response.
Hi Ryan! I haven't talked to you in a while. Most of the discussion about this happened in email among pyvideo folks (by folks I mean Will and me) and also on the pyvideo issue tracker [#37](https://github.com/willkg/pyvideo/issues/37).
2.3??? Where was your code being used? I'm pretty sure even RHEL 4 was on 2.4
I lie! I do not think Carl lost his keys. He's getting the 403 despite using the info from http://archive.org/account/s3.php
What in your mind is an example of such an "obvious alternative" that maintains the invariant of O(1) indexing? 
Is Stackless doing a 2.8? Because the PSF will never do one.
Yep looks like it: http://www.pyinstaller.org/ticket/85 And they reference pefile as a dependency that needs porting: https://code.google.com/p/pefile/issues/detail?id=36
What do you mean exactly by "the invariant of O(1) indexing"? What are we indexing? If you mean "displayed glyphs" or "characters" then py3 does not presently do this correctly as Unicode maps more than one code point to a single resultant glyph. My contention is that o(1) indexing of code points is a fairly useless feature in practice. This is a very old discussion... 
Check out the wall of superpowers https://python3wos.appspot.com/
You are really just restating the premise behind the Unicode handling idea that is behind Python3. That is; that we can throw all our string operations behind a wall and entirely disregard any of the details. The linked article is a rebuttal of an article that argues that this is a bad idea. 
No, the function of a programming language is to support an ecosystem where developers can build applications. One way a programming language can do this is by offering features and functionality, but it can also be done by supporting the existing ecosystem. 
I'm talking about O(1) indexing of code points, not of grapheme clusters. It's one of the fundamental guarantees of the string type, and breaking it would be a cause for a lot of uproar. 
I have an alternative implementation in Reg of functools.singledispatch, which is in some ways more powerful. Concerning why people aren't using Python 3, see my take on it here: http://blog.startifact.com/posts/python-2-gravity.html
Such are the rumors. And I do hope they will. And there is still a slight chance psf will be forced to do one.
The code I was referencing was here: https://github.com/mitsuhiko/flask/blob/master/flask/json.py#L39-40 def _wrap_reader_for_text(fp, encoding): if isinstance(fp.read(0), bytes): fp = io.TextIOWrapper(io.BufferedReader(fp), encoding) return fp I *think* this is one of the fp.read(0) tricks that Armin was referring to with file-like objects. It looks like the use case is to take an unknown file-like object and turn it into a known one, but only if it's a binary stream. (This only applies to Python 3 in Flask)
&gt; What py3 debacle? A few whingers complaining is not a debacle. You're entitled to your own opinion, but not your own facts. The facts are that the PSF's survey of the true faithful shows a minority using Py3, and almost no downloads from PyPi are for Py3. If you claim non-adoption is part of the plan, then all well and good. But there's no way for you or anyone else to distinguish between the plan failing and the plan succeeding, if your plan is that hardly anyone switches over until the far future.
pika
This isn't about mixing and matching. This is about the fact that a lot of formats - perhaps the majority - have a byte representation which can be usefully dealt with as a string, using the same methods as apply to strings.
Interesting article. I'm myself struggling with this very question at the moment as I'm about to start a new Pyramid project and toying with the idea to do it in Python 3.3 rather than 2.7. I'm wondering how painful it will be to start Python 3 and then (maybe) have to abandon and re-write either in polygot or back to Python 2 if I run into a library requirement (I've not yet foreseen) somewhere down the road!
[xlwt](https://pypi.python.org/pypi/xlwt) for writing xls files
My mother is currently learning Python from the MIT courses currently. She's picking it up pretty well for age 55!
**1)**: https://python3wos.appspot.com/ As far as I know, WOS uses "classifiers" found in `setup.py` files to determine if the package explicitly claims to be py3k compatible. It lists the packages by number of downloads (descending order) and caps the result. The less popular packages don't show up there. **2)**: Not that I know of. I would suggest, go to WOS, start at the bottom and contact the devs. I'm sure everyone will be happy to get a helping hand.
i'll look into that error... and clearly i need better help lol
Pretty easy. Python throws nice exceptions as well in the 2/3 area (to help reassure users in your exact situation).
There seems to be a xlwt-future by the same people: https://pypi.python.org/pypi/xlwt-future
&gt; Why not have a series of ustr functions that deal with unicode? Because there shouldn't be any string functions that deal with anything else. If you've just got a sequence of bytes, how can you apply a string function to it? You don't know what the encoding is, so you don't know what character sequence it represents.
Yep, this is the most recent reference to work on that I can find: https://github.com/pika/pika/pull/312
&gt; What do you mean exactly by "the invariant of O(1) indexing"? I believe /u/Rhombold is referring to the fact that that, currently, the time taken to determine and return the *m*-th code point in a string, being simply a multiply operation followed by some pointer arithmetic, is approximately independent of the length of the string, *n*. This is an important invariant for performance and is commonly assumed by a programmer. A UTF-8 encoding, for example, requires one to decode the *m*-1 characters preceding the *m*-th one and so the average time to retrieve a code point from an index scales with the length of the string. This is usually denoted O(*n*).
[cx_Freeze](http://cx-freeze.sourceforge.net/) is an alternative that already supports Python 3. Not to say people shouldn't port PyInstaller, but it needn't hold back applications.
Here's a list of popular Python modules, and whether or not they've been ported to Python 3: [https://python3wos.appspot.com/](https://python3wos.appspot.com/) There are currently 200 packages listed, out of which about 60 still need porting.
boto, fabric
In other words, @whatever def something_else(stuff): things is just shorthand for: def __internal_name(stuff): things something_else = whatever(__internal_name)
OK, I fixed that error -- typo in the artifact generator json. github repo is updated. As for the help, it seems like the main issue is that it tells you what your options are at each prompt, and you're ignoring that information... lol! Also, what OS are you running? All those codes around the prompts are supposed to bold them, which works on my Mac from X11... I'd like to fix that, if possible.
I'm on windows 7. I did find the prompts a little odd :) Making it hard to read where I was.
hm ok, i'll see what i can do about the bolding codes. thanks!
boto seems to have a py3kport branch which is where that work is happening as far as I can tell https://github.com/boto/boto/tree/py3kport
What indicates whether a given sequence of bytes is in one of those formats so those methods know whether they can be correctly applied?
try it now! get the full distribution, as i included colorama for processing colors on Windows.
CGI is old, simple, and extremely slow. For every single http request that is made, the CGI model launches a new instance of the handler script (i.e a python interpreter instance) to handle it; so it essentially reboots python every time. WSGI is a python standard for handling requests that doesn't suffer from such problems. It defines an interface which both persistent python servers and extremely efficient compiled http servers can implement. For a "toy" web server, even CGI might provide somewhat marginal performance; but these days there are easier ways to handle things. You can just use python's inbuilt server with a framework like flask to run simple development and experiments, and it allows for great flexibility of development (like hot-reloading code in the server when you save a file).
I haven't but only because I haven't been able to pinpoint where it is in the code that it's slower. Additionally, most of the benchmarks are against closed source projects, so I can't simply post them for the pypy team to look at. However, I do have one against one of my more complex OpenSource projects - that ill spend some time looking through tonight to see if I can pinpoint the point of slowness and then file a bug.
The answer to everything regarding why something is a certain way: Because Guido wants it that way, and it's Guido's language. ;)
Only to the extent that I maintain a Python 3 compatible library (someone else did the port) and contribute to others, admittedly they need to be 3.2 compatible too. It stays working because of travis, but needing to check on multiple versions means it is not something I'll do for application code. If I could ``import strict`` (or perhaps ``setmoduleencodeing('undefined')``) at the top of each module and be pretty sure things would work under Python 3 I'd be more likely to put in the work on application code too.
awesome, thanks!
thanks!
That is relatively rare as strings go. Python already provided O(1) indexing for long enough that changing was not really an option. Of course it's not that useful to index code points since you usually want graphemes, but the end result is not much worse than UTF-8.
That's a pretty neat article! I had never heard the term "Regex Golf," but in my searching I found [this site](http://regex.alf.nu/). Great for fine-tuning your regex skills! Ninja edit: Can anyone thing of any real-world applications for the script in the article except for playing Regex Golf?
It doesn't use `/dev/random` because you aren't really meant to use that for everyday purposes. You have to be very careful when using `/dev/random` because if you try to take too much data you can exhaust the pool and your program will block, potentially for a long time. `/dev/urandom` is what you want to use 99% of the time. Only on those few rare occasions where you need the utmost quality of randomness, like generating a private key, should you use `/dev/random`. 
Look's like it was written by Peter Norvig (from the URL)
Thanks to you and /u/odonnellryanc for the encouragement! I'll do a bit more research on some of the obvious modules and see how it goes.
ok here's the github: https://github.com/sirpercival/PercivalsQuest
github repo: https://github.com/sirpercival/PercivalsQuest
* Fetch the list of the posts of the considered subreddit made during the considered period (possibly using the reddit API). * Split each text post and comment at spaces to form lists of words. * Concatenate all the lists (or concatenate the posts before splitting). * Filter (convert to lower case, correct misspellings, get rid of uninteresting words, ...). * Count the occurrences of each word. * Keep the top 100 or so. * Generate rectangular images for each word, scaled by occurrences. * Place the biggest rectangle in the middle of the final image. * Progressively place the smaller ones around it decreasing order, filling the blanks. * Save the image file.
I guess my gripe is that the Python docs say that "the returned data should be unpredictable enough for cryptographic applications", although on a second read it isn't really that strong of an assertion...
`/dev/urandom` *is* fine for most cryptographic applications except for the rare instance of generating a key. From the [man page](http://manpages.ubuntu.com/manpages/trusty/en/man4/urandom.4.html): &gt; If you are unsure about whether you should use /dev/random or &gt; /dev/urandom, then probably you want to use the latter. As a general &gt; rule, /dev/urandom should be used for everything except long-lived &gt; GPG/SSL/SSH keys. 
It is. It's on his homepage: http://norvig.com/ Kind of cool that a Google executive still has time for fun stuff like this.
Also top article at http://norvig.com/ "This site contains technical papers, essays, reports, software, and other materials by Peter Norvig".
Hey, *I* am ancient. And actually, the "ancient" was a reference to when I first did it, around 2001. I'm surprised it still works.
You can start by [reading it's source code](https://github.com/rhiever/reddit-analysis). Open Source is great!! :)
It's not at all for the best. Being able to write code that can sanely deal with both character and byte sequences is extremely useful and nececessary to be able to port Python 2.x code without breaking backwards compatiblity. The changes introduces with Python 3.x make it effectively impossible to write something as simple as a useful URL parser that supports both bytes and str without writing separate parsers, one for each type. The same problem applies to any code that interacts with streams. This isn't "for the best", this change is only useful for the sexual fantasies of unicode fetishists.
That's convenient. Thanks for sharing! I don't think it would be that hard to extend this to support something like bcrypt which would definitely enhance the security.
&gt; do I need to use 3 now? No. No-one else (to a first approximation) is using it either. In fact, it still has problems that mean it's not great to use on POSIX systems. The only reason why you would "have to" upgrade is to use specific libraries which are 3 only, and there aren't many of those.
This reminds me of a [/r/dailyprogrammer challenge I came up with a while back](http://www.reddit.com/r/dailyprogrammer/comments/122c7h/10252012_challenge_107_difficult_english_word/). You had to write a program (regex or otherwise) that would match each of 10,000 12-letter English words, but not any of 10,000 random strings of 12 letters. The winner was a regex of 880 characters. I wonder how well this would do.
How do you suppose plans are evaluated and adjusted without discussions and disagreements? I think meta finger pointing about finger pointing is not really helping either, is it? 
As an outsider, all I see is finger pointing. I'm sure you're right about the internal nuances and events but as a user I don't know any of that. I'm sure there are some ways of migrating that are better than others. Take the perspective of an outsider in this - it all just looks stupid. If I want this drama I'll go to Ruby.
I laughed at your last phrase! Yeah... it was a bit radical to complete remove text-api for binary/byte, specially since it was heavy used on protocol/codecs domain, and specially because it's one of the "leading" features of the "new" python that (ideally) everyone should migrate to. They could add something like bytestr (or unsafe_bytestr) which could be used both as text and as byte...
&gt; How do you suppose plans are evaluated and adjusted without discussions and disagreements? That's all well and good but when I'm in architectural meetings and evaluating platforms and Management(TM) starts reading aloud hate mail between community members they start questioning validity.
&gt; I'm sure you're right about the internal nuances and events I'm not sure what you mean by this. Python is open source, but proprietary to the PSF. "The community" can no more do anything about their decisions any more than they can about Microsoft's decisions. As to what you, as a user, need to know: just stick with python 2.7. It's well supported, it works, and the PSF is backporting features.
Unfortunately, open source projects need to have room for discussion. It'll be difficult to find an open source project where you can't find examples like this -- heh, just take a look at Linux kernel development! 
wx. I know Phoenix exists, but I'm afraid to touch it before it's done. Compiling wx is hard enough on linux. I'm not going to try on windows.
That sounds like a good call. I just hope the PSF folks know that they aren't doing much for their reputation prolonging these issues.
Oh no! If you perform an operation on different types the result is different! &gt;&gt;&gt; def concatenate(a, b): ... return a + b ... &gt;&gt;&gt; concatenate('a', 'b') ... 'ab' &gt;&gt;&gt; concatenate([1], [2]) ... [1, 2] Oh no, you get a different result! Wah wah wah. The 'new' division still exhibits the old behaviour with complex numbers, or any other kind of number. It's a horrible special case for reals. It's also different from other programming languages. 
I always loved Norvig's articles. It's the first time I see him using ipython notebook. If I were an ipython dev, I'd be popping champagne right now.
Scrapy is built on top of Twisted. I wouldn't say that not supporting Twisted (which has most of Tornados features plus some more) is "not playing good with others". In fact... Most of Asyncio rationale is to standardize the common aspects of both implementations of an event loop, deferreds and some more stuff and lay ground for interoperability...
Much better looking!
there should be ways to do the same sort of methods on bytes, like things being discussed lately, but i strongly disagree that python is 'worse off' by making a clear distinction of bytes versus strings, as its ONLY useful if you are considering ASCII, which is not the only encoding out there. for example: &gt;&gt;&gt; "Hello, World!".encode("utf-8") b'Hello, World!' &gt;&gt;&gt; "Hello, World!".encode("EBCDIC-CP-CH") b'\xc8\x85\x93\x93\x96k@\xe6\x96\x99\x93\x84O' &gt;&gt;&gt; I have no idea how a str like api would even be applied to bytes, as i commented in another thread, having '.format()' would be weird, as what would you use for the formatting replacement marker? &gt;&gt;&gt; print("Test %s" % "hello") Test hello &gt;&gt;&gt; print("%s".encode("utf-8")) b'%s' &gt;&gt;&gt; print("%s".encode("EBCDIC-CP-CH")) b'l\xa2' &gt;&gt;&gt; # what bytes do you use as the %s? b'%s' or b'l\xa2' ?
I guess the shopkeeper allows credit purchases? Town&gt; Shop You head into the shop. The shopkeep greets you cheerfully. 'Welcome, hero! What can I do for you?' His current inventory is: 1. Barrel (1) 2. Dagger (1). Your current loot bag contains 0 gp, and: Nothing! Buy Item# [Amount], Sell Item# [Amount], or Leave. Shop&gt; 2 Sorry, I didn't understand your choice. Try again? Shop&gt; Buy 2 You buy 1 Dagger! His current inventory is: 1. Barrel (1). Your current loot bag contains -1 gp, and: 1. Dagger (1). Buy Item# [Amount], Sell Item# [Amount], or Leave. Shop&gt; Buy Barrel Sorry, I didn't understand your choice. Try again? Shop&gt; Buy 1 You buy 1 Barrel! His current inventory is: Nothing! Your current loot bag contains -2 gp, and: 1. Barrel (1) 2. Dagger (1). Buy Item# [Amount], Sell Item# [Amount], or Leave. Shop&gt;
Thanks for the pointer. I'll have to test that out on my app and see if it works well for me across Linux, Windows, and Mac. I have a new project I'm starting and I'd love to be able to use Python 3 on it.
Read the [PEP 238](http://www.python.org/dev/peps/pep-0238/), maybe you will get enlightened.
There's also [Vim Golf](http://vimgolf.com/), which is pretty neat.
Thanks. We take performance bugs serious, but it's also hard to do anything without the bug report :-)
Popular Python apps: supervisord, ansible
&gt; You are really just restating the premise behind the Unicode handling idea that is behind Python3. That is; that we can throw all our string operations behind a wall and entirely disregard any of the details. The linked article is a rebuttal of an article that argues that this is a bad idea. I don't agree that the article is about the *internal implementation/encoding* of Unicode. I think that it is about the *interface* (methods available, and their return codes). Python 2.x and 3.x both normalize to a standardized internal implementation, and yet he prefers Python 2.x to Python 3.x. So I don't see why you think that the internal implementation/encoding is the problem discussed.
Whatever, it's the biggest reason I'm never porting any existing code to python 3. It's also a major pain in the ass when the fucking convention is the old way. Guess why I don't use Julia? Because of 1-based indexing. They messed with learned convention. When your language has some special case that I'm always going to keep in mind while writing code, you're failing in the same way perl does. The less I have to keep in my head, the better. It's also against the whole duck typing thing. Why not ++ for string concatenation, +++ for list concatenation and + for integer addition and ++++ for real addition? This would make division less of a special case. It's way more pythonic3!
Hopefully the PSF will come to a rational solution to this issue at the next PyCon as the longer this goes on the more damage is done to the Python community. There needs to be a Python 2.8, 2.9, etc releases that smooths out the transition to 3 even more than 2.7 has done, so that we don't end up with a lot of polygot software or just drop Python 3 all together. IMHO, polygot software is not Pythonic and we need to put an end to this madness .
I had to add a dummy "flush" method to the class the answerer provided, but otherwise it worked well. I copy and pasted his code into the interactive interpreter and then started my server with "execfile" and then used the tracebacks to find the offending files. It was pretty awesome.
How would you create a bot though? 
How does `/dev/random` work? How does it fill the pool? And how big is this pool usually?
grep
1-6 is covered by the natural language toolkit, the remainder is covered by any # of js libs. 
My favorite Norvig cameo recently happened when I was debating whether to buy Structures and Interpretations of Computer Programs. I'd heard good things about it from a few people, but ultimately it was [the top-rated review on Amazon that sold me.](http://www.amazon.com/Structure-Interpretation-Computer-Programs-Engineering/dp/0262510871)
True, but it at least solves a substantial part of the task. Using it as an basis or inspiration should help you in your own coding.
Can someone knowledgeable explain what is happening here? 
You've confused static typing with strong typing. Python is dynamically and strongly typed. What you're suggesting is a method or set of methods that assume that data are encoded in a specific way (i.e., the encoding is implicit), running the risk of raising exceptions if you're lucky and blithely spitting out gibberish if you're not. Avoiding situations like that is one reason that [explicit is better than implicit](http://www.python.org/dev/peps/pep-0020/) and that strong typing (static or dynamic) is a useful feature. Of course, if you prefer weak typing, there are a number of extremely mature and well-supported weakly-typed languages with various kinds of risky coercions that may interest you. I suspect you'd find many folks who concur over on /r/PHP/. ;-)
The porting of libraries will continue to happen, but people should use whatever version is appropriate until that's finished. Just because 3 is newer doesn't mean there are any drawbacks to using 2. It's a testament to the success of 2.7 that there wasn't enough room for improvement to motivate people to switch from it.
Is this what "Petrify" is supposed to do? You've stumbled on an enemy! It seems to be... a cockatrice! You get the jump on it. Attack, Trip, Flee, or Equip Action&gt; attack The attack is unsuccessful. It tries to cause you bodily harm! The attack is unsuccessful. Attack, Trip, Flee, or Equip Action&gt; attack The attack is unsuccessful. It tries to cause you bodily harm! Ouch! You're bleeding, maybe a lot. You take 4 damage, and have 59 hit points remaining. Attack, Trip, Flee, or Equip Action&gt; attack A hit! A very palpable hit! You deal 3 damage. It tries to cause you bodily harm! The attack is unsuccessful. Attack, Trip, Flee, or Equip Action&gt; attack The attack is unsuccessful. It tries to cause you bodily harm! Ouch! You're bleeding, maybe a lot. You take 4 damage, and have 55 hit points remaining. Attack, Trip, Flee, or Equip Action&gt; attack A hit! A very palpable hit! You deal 4 damage. The enemy uses Petrify! You're in the dank dark dungeon. What do you want to do? Options: Explore, Backtrack, Leave Dungeon&gt; attack Sorry, I didn't understand your choice. Try again?
Yes, we were using virtualenv. I am saying it is a hassle to install distribute/setuptools and virtualenv on certain systems. On OSX, the problem can be solved using Homebrew, but installing Homebrew itself is non-trivial. On Windows ... well, I guess the problem can be solved by installing Linux ;).
Yes, but this whole issue shows the weakness of that model. 
Uh oh: Attack, Trip, Evade, Flee, or Equip Action&gt; evade You feel more evasive! Traceback (most recent call last): File "percivalsquest.py", line 181, in &lt;module&gt; main() File "percivalsquest.py", line 178, in main town(rpg_instance) File "percivalsquest.py", line 68, in town dungeon(rpg) File "percivalsquest.py", line 108, in dungeon deadchar(rpg) File "percivalsquest.py", line 127, in deadchar town(rpg) File "percivalsquest.py", line 68, in town dungeon(rpg) File "percivalsquest.py", line 106, in dungeon rpg.explore() File "C:\dev\PercivalsQuest\pq_rpg.py", line 180, in explore self.combat.advance_turn() File "C:\dev\PercivalsQuest\pq_combat.py", line 284, in advance_turn self.pc_turn() File "C:\dev\PercivalsQuest\pq_combat.py", line 224, in pc_turn self.attack_enemy(self.char,self.enemy) File "C:\dev\PercivalsQuest\pq_combat.py", line 76, in attack_enemy self.advance_turn() File "C:\dev\PercivalsQuest\pq_combat.py", line 282, in advance_turn self.monster_turn() File "C:\dev\PercivalsQuest\pq_combat.py", line 259, in monster_turn self.attack_enemy(self.enemy,self.char) File "C:\dev\PercivalsQuest\pq_combat.py", line 79, in attack_enemy self.advance_turn() File "C:\dev\PercivalsQuest\pq_combat.py", line 284, in advance_turn self.pc_turn() File "C:\dev\PercivalsQuest\pq_combat.py", line 226, in pc_turn self.use_skill(action,self.char,self.enemy) File "C:\dev\PercivalsQuest\pq_combat.py", line 106, in use_skill user.temp_bonus(["Defense"],user.skill[5],4) IndexError: list index out of range
thanks for all these bug identifications! fixed, though it hasn't been put in the repo yet.
Regex golf is a brain teaser to come up with the shortest regular expression that matches a clue. Sounds like fun. I need to get better at Regex. 
it's just Shrine&gt; 1 ## or Shrine&gt; 2 ##
no, that's the same problem. it looks like petrify killed you, but it didn't register.
i didn't get a chance to test all of the skills, so excellent thank you. i'll fix this one too.
Those who complain on python3 are propably people sitting on lots of old code and dont have time on their hands to port. You should start fresh on python3, most libraries are ported or about to. But read up on new stuff on python3 like print() and unicode/string so you dont get confused when googling old info.
[I've used this before for making word clouds](http://peekaboo-vision.blogspot.com/2012/11/a-wordcloud-in-python.html). I had a bit of a problem implementing it on my own though, [example](http://tarki.net/GIS/SEAGISF/main), click on any of the rep names. 
I'm way too tough to get killed by a level 2 cockatrice though :)
ok this bug and the buying-on-credit bug are fixed and uploaded to the repo. i'm still working on the zombie bug.
In cases like mine, ArcPy is only available for python 2.7, so all my code is in 2.7, because it's hard to manage packages across multiple versions. I would love to change to 3.x, but ArcPy is limiting me both in version, and the fact that it's 32-bit. 
it's probably that you equipped the ring and then didn't save.
HA that's what you're *supposed* to think.
&gt;Regex golf is a brain teaser to come up with the shortest regular expression that matches a clue. Well, a key part of it is that there is some other clue which it must NOT match. Actually, there is a list of both kinds of clues.
I wouldn't recommend including the .pyc files. Another thing I think would be nice is some way to identify items. For instance, it's hard to tell what's better, a leafweave lamellar or a splintmail armor or whatever. Also, some things I can't tell if items are armor or weapons based on the name, since my medieval vocab isn't up to snuff. If you could identify things, that would be really nice. Another thing that I don't really understand are the character attributes and skills. It would be nice if they had explanations in the help. Atk 2 Def 3 Ref 4 Frt 5 Mnd 8 Skl 10; hp 5/5; sp 10/10; exp 0/10 Atk, Def, hp, sp, and exp all make sense to me. I have no idea what Ref, Frt, Mnd, and Skl do, and or are. 
found it. i'll update the repo shortly.
Oh, neat - I was oblivious to that occurring because I'm not subscribed to discussions in that repo. Am now!
You can copy the source code and run it. No sense wondering.
The `logging` module can be a bit intimidating at first, but in the long run it is absolutely better than `print` for debugging and diagnostics. I used to use `print`, but I spent an afternoon learning `logging` and would never go back.
By using [PRAW](https://praw.readthedocs.org/en/latest/), a very popular Python library for the reddit API.
&gt; Give up on ever using RabbitMQ? or you find another lib, like kombu https://pypi.python.org/pypi/kombu I do get what you are saying though. 
&gt; You cannot apply string methods like isupper(), capitalize(), That's true. That's still not a reason to completely eliminate the class. &gt; or even len() to byte strings unless you assume that they represent characters using a given encoding. Now you're being silly. Of course you can apply len, and pretty much anything else that pertains to sequences. 
&gt; Why does it matter that "nobody is using Python 3"? it matters if you are responsible for maintaining a **library** that is used by others. given you can provide the functionality to every human being on earth, logic would dictate that you cater to the majority if your motivation for maintaining the library is marketshare/ego boost whatever. 
There is a definite push to port those libraries over. [This graph](http://dev.pocoo.org/~gbrandl/py3pkgs.png) shows more than twice as many packages supporting Python 3 as there were a year ago. But there's a *lot* of code out there that's written for Python 2, and it takes time and effort to make it work on Python 3.
virtualbox and vagrant
~~I haven't the foggiest idea what gave you the impression that I don't do well by book learnin', or where the g went, but you're right that the lectures are outstanding.~~ **Edit:** sorry, my comment came off needlessly defensive, and there's no reason for it. You're absolutely right about the SICP lectures. I recommend them to anyone with even a casual interest in computer science  I even watched the first one with my dad!
Well, this solution doesn't scale that great. Based on how quickly it runs for 100 entries, I calculate it'll take about 5 hours to run for 10,000. I'll report back when it finishes, but in the meantime, might as well wonder....
This is in the context of a 2-hour long workshop in a room with not the best internet. So having to download a VM image is out of the question. But yes, we do use Vagrant boxes for our internal infrastructure projects, and it is pretty awesome.
But how is being able to access the nth code point in the string in O(1) useful? It doesn't correspond to the nth glyph because of combining characters. Usually you'd be iterating over the string anyway to do anything, eg printing, substring matching
That is so bad ass.
Aaaand subscribed. I've been wondering if there was a subreddit for Project Euler-style problems for a while, and this seems to be exactly what I've been looking for.
Yeah, XCode is the worst. We've tried getting people to just download the XCode command line tools, but even that takes a while. And if they have a previous version of XCode installed, fuhgeddaboudit.
Dang, posted 28 minutes ago... And now we play, the waiting game. 
Dang, posted 28 minutes ago... And now we play, the waiting game. 
I imagine it would be possible to use it for cryptography or data compression. For example, if I had a list of star wars and star trek movies, and I was only willing to talk to people who knew all the star wars movies, then sending an expression like this would be a short way to tell me all of the staw wars movie titles. Obviously in any realistic application you would need much larger lists, and odds are there are more efficient methods, but I would count it as a practical application.
I've recently been using this site to help with learning python myself, and I've found it really cool and fun. There's even a subreddit dedicated to it, /r/robotgame Go check it out :D
Can't beat the price, right?
Amazing. These videos made kivy click for me. I was able to plan out the functionality for a couple small apps today using kv language thanks to these. You're awesome, can't wait for more! 
I had some old code written for 2.3 which I migrated to more recent versions. I tried to keep compatibility with 2.3, but it was just too hard. I know some people have done it, and I am in awe of them.
How many of your 200 Python programmers will be backporting security fixes from the official Python 3.5 or 3.6 codebase to Python 2.7? It's not just hacking a few Python source files, but actually maintaining the core language written in C. As for switching to another language, well, that's your funeral. If you think it's hard to migrate from Python 2 to Python 3, which has a few minor incompatibilities, imagine how hard it is to throw away your entire Python code base and re-write it in another language. As for concurrency, why don't use use IronPython or Jython? No GIL in those. Or multiprocessing and futures? They're more powerful models for concurrency than threads.
Are you Armin Ronacher? Perhaps you should have said. I quote: "It makes writing code for Python incredibly frustrating now or hugely inefficient because you need to go through multiple encode and decode steps." Or am I misinterpreting what you (Armin) meant? 
Wonder no more: 'atio|esse|ting|ical|ment|able|tive|inte|over|ator|ties|ated|ates|logi|ogra|zing|anti|ions|usly|tr.n|ence|lity|ters|snes|alis|ines|enes|ized|ries|ance|izes|nder|ally|ists|cies|ings|ther|isms|uper|stic|sion|ling|a.ic|teri|comp|ding|tric|tero|ning|ias|ount|ture|ntly|etic|ress|micr|lect|king|lnes|ably|roph|ides|ight|izer|pers|cont|hing|ying|hnes|cons|enti|rian|uses|scop|an.a|ular|hips|ulti|poly|ores|dnes|stra|kers|omet|full|erin|th.s|th.l|ogen|illi|pr.c|ishe|onal|phil|logy|comm|orph|plas|less|hype|onis|ered|cent|back|ible|ophy|tely|thro|acti|econ|ious|disc|ecto|semi|asse|arch|pher|itis|boar|nonc|late|hand|cyto|ants|titu|neur|lers|ingl|chro|ace|ivel|stre|ases|iums|otro|hold|rite|erma|roof|ised|head|hear|tera|otom|intr|oses|ners|iers|gers|rous|fied|ctiv|alle|thor|ette|nary|ents|ping|tnes|gran|disa|prot|nshi|ante|atch|u.tr|endo|form|vers|misc|hypo|oste|omat|peri|ency|ones|osit|tori|orks|ower|ound|chem|anch|mine|ribu|ydro|aste|ital|hous|ncin|poli|raph|fies|circ|urin|tter|hedr|shes|mmer|mono|cate|misd|some|ille|mili|perc|hosp|da.e|ibly|orth|fi.r|opho|nate|bber|quad|serv|rage|alli|ferr|ript|disi|rain|carb|ssor|psyc|stom|cros|mber|cycl|nies|bili|este|espe|ecre|char|ptic|atis|brea|seud|ckle|ggin|llow|ddle|ians|ttle|ucle|athi|icke|o.li|hemo|chlo|oned|etro|ttis|olle|lini|tary|rodu|ounc|cial|blio|phen|loid|t.ed|ospo|orse|quis|mega|arri|ococ|isen|nsiv|shor|asts|xtra|itch|bing|iste|ndis|mphi|fect|ater|inal|cipa|ront|ambu|udes|bloo|ints|thin|meta|ngin|angu|erer|ough|mont|gree|quen|shar|ostd|urch|hyto|sher|ledg|stor|chym|nonr|pend|ocha|nsch|alin|icin|rise|rnes|tura|lagi|mbar|prol|once|iest|etra|bble|culo|osin|evin|legi|esta|esti|estr|sque|ancy|nsur|otor|buil|eeri|benz|icul|meth|horn|chee|stru|tons|emin|dact|mmin|pect|i.lo|dite|azin|ules|erry|hipp|gnes|ocke|reec|ostc|osta|auto|swee|scho|schi|caly|warm|anit|lous|hood|nife|omyc|nona|blac|augh|orce|lent|ener|nage|aker|icid|onit|corn|cyan|ussi|esci|ined|chry|inco|acka|mbr|osiv|rviv|lege|glyc|tech|agne|pita|rgic|easp|chth|tami|elor|leev|time|apto|ords|juri|iari|ixes|nell|stle|acqu|ubli|anim|blad|otto|resu|isem|clai|ulus|lign|mast|sync|otoc|otos|osci|axil|rmen|shly|gola|ukop|etry|ntat|lins|sent|raci|ibio|cess|ytic|gues|ende|phan|phag|npar|mete|dize|mide|anal|brat|aram|chil|ntra|osop|ndro|rine|aero|lite|igno|kins|imal|ropr|eede|e.ep|isat|ex.i|indu|rase|nath|ente|iser|ecke|cand|omer|lici|chys|acta|gery|lter|oiso|rand|ulli|etee|oids|sure|diss|rede|onem|ntal|ooz|ngen|esol|yled|carp|culu|vigo|itho|abra|mmun|huri|excl|lved|ilin|ilis|wing|opyg|vard|inau|inad|urmu|cion|arqu|whif|ehav|wash|ronc|boxi|atto|ntha|speo|lfon|zymi|priv|hyll|bles|etig|ebri|onga|pite|esic|esio|ongr|ogno|hone|honi|stne|foss|deut|gado|fluc|subc|fruc|mben|timb|nbro|iaro|ooke|requ|lido|lgri|ogly|tors|didy|mimo|opei|uria|cita|anki|boya|noti|elan|ibra|doms|unpr|gged|blaz|anio|sreg|resc|ecks|heet|luci|ffer|dous|dnis|llgr|mbus|nore|taic|ybde|oton|picu|maln|ordp|hotc|sell|urus|inth|maqu|emar|llum|eurs|eled|oach|intu|atou|aust|lant|achn|udin|opod|rack|hyde|sies|writ|elga|blew|ptid|faci|nisi|nise|iece|ayne|ppre|ntem|tick|tyra|onuc|nfon|rsap|work|iote|eelb|auna|inni|eres|tpro|istu|arav|born|poss|emii|ivin|erco|sify|itti|gnen|grav|eris|ieve|negl|radu' Length: 3185. 
Reasons: * Python 3 is not backwards compatible with Python 2 this includes both language features and libraries at the moment. * Python 3 for quite a few people doesn't offer enough benefit (in other words 2 is not broken enough and/or 3 doesn't offer too many out-of-this-world awesome features) to justify spending time and effort converting to it. Benefit can be performance as well not just features. Like say Python 3 had PyPy integrated and it ran 30% faster. Ok, now I will spend 1 month converting my code base to 3. Another way to look at it is that Python 2 is actually pretty nice and not broken at all. * Python 2 is used in a lot of places. This speaks to Python's! A lot of existing, running, money-making code out there in Python 2 that is not broken. Porting it to 3 will take time and will possibly break it without a measurable, tangible benefit * Python 3, I personally feel, came a little too late. It needed to come 2 or 3 years earlier. By now people are wanting speed, concurrency, monitoring, scientific computing enhancement, they don't want yield froms and yet another async library that looks like Twisted or better unicode support. &gt; May be a total noob question but I'm confused on what I should be investing my time in. It depends. If you only plan on playing with Python core and a few libraries that use Python 3 already, use Python 3. Say stuff like: solving Project Euler. Writing your won web crawler for fun. It has some nice-ish features you'd enjoy. **However** f you want to get any real work done and will get paid for it -- say "talk to this database, then render a report or a graph, all by next week or kiss your bonus goodbye" well then pick 2.7. If you happen to use Ubuntu, just boot up your machine and you already have it as a default. This way you'll have access to most already existing, tested libraries.