Kid grows up to be president of a country. Finds it acceptable to turn of the internet to make it easier to control dissidents. I'll stop now.
Comments (where else?): Mailing lists, issue trackers, IRC, twitter, StackOverflow, random forums. None of them are exactly 'comments', but questions and bug reports turn up in all of them. The more channels there are, the more likely it is that users ask for information somewhere that the developers aren't checking. Popularity: The favourited counts make it a bit more useful. I think the biggest issue is that you have to already know what package you're looking for. If you want to assess Django (say), it's fine, but if you want to find a web framework, it's no help. And there are already good ways to assess a package you know of - you can look at its download count, its docs, or Google it to see what people are saying about it. Perhaps you can harness crowd sourcing: get enthusiasts to tag Django as a web framework, and write a brief description of what makes it stand out. Then when a user wants a web framework, you can show her a list of the top 5 packages tagged 'web framework', with a summary of why she might want to pick each one. The rating could be a combination of download count, favouriting, and maybe other factors. This is something PyPI really lacks: the Trove classifiers are a start, but there are over 3000 packages tagged 'web environment', and no good way to filter them. The search is also fairly rubbish. There's definitely an opportunity to build something that helps people *find* the packages they need.
As a first step, it would be good to get a python2 symlink, so there's an explicit target that will keep pointing to Python 2.
Awesome! As a first step I only really need to change a character at a location, so I'll check out both methods you mention. I've been putting this off for ages just because I can't be bothered dealing with ncurses! One thing that really put me off ncurses was (not) being able to draw at "the same time" as taking input (well, that was more simply a pain in the ass with C, at the level I was coding at back then). Do you have any experience with this? I'm thinking of using something like Twisted to facilitate this, but perhaps that's going overboard.
I was actually thinking more about `eventually`. Which - in a way - reflects the "loop has not stopped prematurely" concept.
true... I was still half asleep when writing this. But I think the fragment still makes a valid point.
This feels wrong to me. The condition checking for the datum is *inside* the loop block, while the `else` statement is "attached" to the loop block. I agree that it's convenient (semantic sugar if you will), but it feels not right to me. Again, someone who does not know about this syntax (which is a lot of people), might not make the connection between a condition *inside* a loop and a block "on" the loop.
... which is nice ... but has nothing to do with the discussion at hand... ;)
I would think an else below a while or for would be if the loop never executed. a = 5 while a: doThing() a -= 1 else: doOtherThing() This would enter the while and doThing() 5 times as `a` decremented. The else would never be called. A break wouldn't get there either. Only the while never taking place would trigger the else. I don't know how it works in reality, but this would be my expectation. "Do this while that. Oh, never that? Okay, then just do this."
This is a quite silly discussion, still I can't resist: for ...: ... done: ...
I unthinkingly assumed this was a customised packaginator deployment, they have the same sort of domain names.
I guess that's not dissimilar to "finally".
Twisted sux. It completely subverts control flow. Better replacements will become available to Python 3 before Twisted is able to assert itself there I hope. 
Yes, it makes a point that emulating `else` with a sentinel easily leads to writing incorrect code. Which, as the comments show, is also easy to _understand incorrectly_, which is a very bad thing. for a in range(10): if int(raw_input("Enter a number")) == a: break else: print "You never guessed the number!" There's nowhere to make a mistake. There's nothing to misunderstand (of course you have to know what `else` does in this context). So your post most certainly makes a valid point -- if only the complete opposite to what you intended. (btw, the whole thing reminds me of misguided people who, when confronted with a problem of exiting a multiply nested loop in C, add a flag and laboriously check it everywhere (except where they forgot), because *"goto is bad and leads to buggy, incomprehensible code"*. Mind boggles.)
Not all programming language constructs are supposed to make immediate sense to everyone. Once in a while you have to RTFM. After you did that, it's easy to remember: "the `else` clause always executes after the loop if unless it was interrupted by `break`". One might argue that "else" is an unfortunate choice of word, and "unless broken out" might be better, but that's a kind of a mouthful. On the other hand, there is not a lot of possible alternative interpretations -- basically, your ("executes if the loop never executed") is the only one that makes some sense, but, I guess, is even less useful. At least we can hope that most people will have enough common sense to recognize that they don't quite understand what else does here and go RTFM, and then never have any problems.
doesn't sound like a good idea to me. it's a feature the router people should implement not a third party 'desktop app'.
What you say is true, but rarely is there a project that I would be employed ( by the hour ) to work on that would require writing a new programming language. A DSL perhaps, but not a Ruby/Python knockoff. That being said, this book itself is really no better than the "Teach Yourself VB.NET in 24 hours" kind of writing. Anyone who thinks that writing a successful language amounts to writing a lexer in Ruby is gravely mistaken. Modern programming language design is an academic discipline that requires quite a bit of knowledge ( type theory, compiler design, etc ... ).
&gt; Not all programming language constructs are supposed to make immediate sense to everyone. In this case, it doesn't immediate sense to anyone, and if it does, it's the wrong sense.
It didn't make any sense to me, but then I RTFM and it makes the right sense to me ever after.
And therefore, there is no way to do things a better way: it is perfect as it is, and any attempts to make it work will just end up in tears.
No, it is not perfect. But it is good enough, it better than nothing, and I, for one, don't see any better alternative.
A better alternatively would be to use more descriptive words other than "else". How is that not obvious to you?
Yeah, a better alternative would be to use a better alternative. Obvious, indeed.
I might be wrong since I'm not very good at programming BUT, learning about the inner workings of a compiler/interpreter might provide a person with a better understanding about the impact of ones decisions. I do a lot of stupid things while I code (as I said, I'm not very good at this) and I think that a book like this might help me better understand the stupidity. Anyway... I'm not trying to sell you on the book. I was just providing a different perspective. I for one will buy it. Maybe not now, but I've added it to my wish list. 
Yea, that's true, but you aren't even going to scratch the SURFACE of what's going on in 77 pages. An adequate discussion on the parsing phase alone would be longer than that. 
I fucking love old jazz. Either that, or I'm confused. Ray Charles...?
Maybe, maybe not. From (my) programmer's perspective, the relevant stuff is how the languages implement the semantics, and parsing (and syntax analysis) are less interesting. So 77 pages might do a decent introductory job.
Skim through. IIS. Thats a back-button click.
You can do inline if-esque statements, too, with dictionaries. It's ugly, though. {True: x, False: y}[1==0] You can even go nuts with this stuff, and have MANY different keys, and like, use them in function call parameters, etc. Doesn't really deserve it's own thread. Here's a REALLY ugly line I've written. float_scale_ratio = ({ True: float(self.tuple_screen_size[0]) / tuple_raw_image_xy[0], False: float(self.tuple_screen_size[1]) / tuple_raw_image_xy[1] }[float_raw_image_ratio &gt;= self.float_screen_ratio])
The parsing is the easy part. I have a sneaky suspicion that the technique in this book basically breaks down into a the ruby equivilant of lots of str.replace, and then throwing the whole thing into an eval.
why is so hard than a python guy learn a new language??...learn a language is fun, and always you will find new features and new ways to programm than you can appy to python....today python community is the same than java community 10 years ago...a people group than don't want learn a new language and do everything with only a lang...and you need know than any language is perfect for all jobs
How long do you stare at code before you RTFM? For me, it depends on how well I think I know the language constructs I'm looking at.
I think the last time I tried it was enough to install the free Visual C++ Express edition. It used to be a big hassle trying to get Mingw working with it.
When you see an `else` clause after a for loop for the first time, how well do you happen to think you know the language construct you are looking at? I don't know, I realize that it's somewhat of a wart, but I believe that very few people would decide that they don't need no FM when they first see that stuff, and I think that the consequences are fully their own fault. Python is a newb-friendly language, but there's a fine line between that and trying to be moron-friendly, like, removing 'confusing' features etc.
I find that kind of stuff only comes in handy when writing obfusticated code or competing with another coder to do something in as few characters as possible. Besides, you can still do: foo = result_if_true if condition else result_if_false
I mostly use it as a case statement, but I don't usually encounter that sort of situation. Can you do your example in a function call?
If you have a number of cases then that's warranted, but for a boolean condition I'd stick to an if statement or the ternary operator. Also bear in mind that without modification you will be calculating all possible values in the case, whether the result is required or not. Not sure what you mean about my example in a function call. You can stick a return statement in front of it, rather than assigning it to something. BTW In your example, you could have used a tuple or list, rather than a dictionary. Since False and True are equivalent to 0 and 1 respectively. 
Now perhaps. But he may not be in the future. I'm with sushibowl here.
Mmmmh, read all those comments about the else clause in the for loop statement being hard to understand, not much used, etc., ... and I totally disagree. I use it all the time and every person I know who is a savvy python programer does to. Let me explain the *typical* usage in my (and other people code) case: It is interesting when you are using a for loop to *search for something*, not for its side effects, aka, using a for loop to search for a value in a list vs using it to print all values in a list. In that case, the semantics becomes very clear: search for a value, and if it fails (you cannot find it), do something else. # Search for value for value in list: if my_test(value): break else: value = None 
The use case for this (in my experience) is for loops which you expect to exit out of early with a break statement. def find_f(f): ''' Attempts to find `f` in any dir in sys.path Raises ValueError if `f` is not present in any dir ''' for d in sys.path: path = os.path.join(d, f) if os.path.isfile(path): break else: raise ValueError('Cannot locate %r' % f) *sh behaves similarly to this when you type in a command
You're missing a template module of some kind. It's rarely a good idea to generate HTML directly from Python -- it just gets too messy and hard to maintain. Generally you prepare a dictionary containing all the information needed in a page and run that through a template to generate the output. The template contains HTML plus a syntax that allows for substitution of the data you have prepared. There will likely also be loops, conditions and filters. Examples of template libraries are Mako, Genshi and Django templates. You can use any, but if you are working with a particular web framework there will probably be a preferred templating library associated with it.
... this made me chuckle ... and think ... you are absolutely correct! Have my +1 :)
I've used it for certain hardware operations when it's not guaranteed to work the first time: for _ in range(num_retries): do stuff if success: break else: print "test failed" The search might be better done with generator expressions: value = next((value for value in list if my_test(value)), None)
I mean can you: def foo(herp): return(herp) foo({True: "arse", False: "dicks"}[1==0]) But with your inline assignment? Also, I didn't even think of the pre-calculation. I suppose, if I was feeling particularly malicious, I could: def foo(): return(1.8**0.03) def bar(): return(time.time()/9) # I think time.time() returns a float. It's an example, get off mah dick. def boof(herp): return(herp) boof({True: foo, False: bar}[1==0]()) Of course, that's a very complicated way to do something stupidly simple, but the function wouldn't be called until it's chosen from the dict, right? (I know my examples can do things more efficiently/simply, I just put a concept in the most simple and definite way I possibly can, so I'm not learning/getting caught up on the semantics of an actual real-world implementation).
&gt; At least we can hope that most people will have enough common sense to recognize that they don't quite understand what else does here and go RTFM, and then never have any problems. The problem might not be that people *don't* understand it. But rather that they *think* they understand it. This was the case for me when I first saw it. I was *convinced* that it had the meaning outlined by gfixler above. And as it was, I was not under the impression that I did something wrong. Until my application broke... Only *then* did I read up on the docs. You could call my initial assumption ignorant. And you would be right. I'm certainly not the only one. I doubt that there are many developers reading the language-specs front-to-back, unless maybe if it's the first language they learn. I believe it is a flaw in the language design if a statement conveys the wrong meaning to the majority of people using it. But let's be honest: Python is an awesome language. And bickering about something like this is completely meaningless. *Every* language has it's quirks. This is one of Python's. Let's just leave it at that... ;)
done is actually better. too bad we cant alias it.
This is a pretty cool website, but the code snippet box is a total fail it doesn't scale with what code is in the box. Other than that, I could see myself using it as a "Word a day" for Python, providing it gets more advanced than a demo of built-ins.
Sure, you can do that in any expression. This works: foo("herp" if bar() else "derp") &gt; but the function wouldn't be called until it's chosen from the dict, right? Yeah, making them functions solves the problem of always calculating the values. Personally, I would only implement that if the number of conditions is so large that an if/elif chain becomes too inefficient.
i was never able to get it to work with visual studio back when I did .net for a real job(3 years ago) mingw worked fine after you added it to the path and created the file C:\Python27\Lib\distutils\distutils.cfg containing [build] compiler=mingw32 Then the only hassle was getting headers for things but that was dependent on what package you were trying to install. 
The retries is an other nice example of why the construct can be useful. However, the generator expression is cramped. With that particular example it might be readable, but as soon as the search gets complex, it is subpar. Please note that my above example was kept simple to allow people to understand the *semantics*. But of course, in the real world, these get often more complex, possibly with nested loops and more lenghty code you don't want to put into your generator example. However, that generator trick _is_ useful under some circumstances, and I use things along those lines myself, but I have too say I have more afterthoughts regarding readability of using the generator idiom than the for..else construct. In fact, I tend to refrain from using it at all, because I noted that more than often, when extending the code, it gets refactored into something else for readability sake.
Python isn't designed to be used to generate HTML the way PHP is. The simplest approach is to write a Python CGI program. The built-in [cgi module](http://docs.python.org/library/cgi.html) helps a little, but you are still left with `print` statements all over the place; it isn't much fun. A step up from there would be using a small Web framework such as [Bottle](http://bottlepy.org/) or [Flask](http://flask.pocoo.org/). These make it easier to structure your code and include templating systems which will help you with escaping text and and handling request variables. These small frameworks typically leave it up to you to choose how to connect to a database or handle authentication, but they strike a great balance between simplicity and features. The other end of the spectrum is a "full stack" framework such as [Django](https://www.djangoproject.com/) or [Pylons](http://www.pylonsproject.org/). These provide a lot of infrastructure for a complex Web application. Great for what they do, but sometimes over-kill. However for most non-trivial applications you will need the functionality these frameworks provide, or you can choose to implement your own solution on top of a smaller framework. Here's a page listing [Python Web frameworks](http://wiki.python.org/moin/WebFrameworks).
Cool site. It would be nice if there was an easy way to browse the facts, instead of selecting one at random by clicking a link. I keep getting the same few facts over and over again.
To answer your question straight, you're talking about [Python Server Pages](http://en.wikipedia.org/wiki/Python_Server_Pages), but almost nobody actually uses them. I personally started Python web development by doing [the Django tutorial](https://docs.djangoproject.com/en/1.3/intro/tutorial01/), which I found to be very informative.
I would much rather just have this as a list of items on a static page instead of this cutesy web 2.0 nonsense where you have to hit reload a million times and suffer through repeats. 
Python is quite different than PHP in the way it is executed by a server and than sent to a browser. With PHP, you can simply drop a .php file on some hosting with mixed HTML/code in it and it will work. This is not the way Python web development code is usually executed or deployed. I am not aware of any middleware that does the simple mixed HTML/code execution/deployment for Python. The most popular middleware right now is called [WSGI](https://en.wikipedia.org/wiki/Web_Server_Gateway_Interface). You can see how it is used with this nice [web development diagram stack](http://speakerdeck.com/u/mitsuhiko/p/python-web-development?slide=31). It creates a bridge between calls from a web server to your code. It is really easy to use, but it requires more setup than PHP. You need a web server that support WSGI ([the most popular do](http://www.wsgi.org/en/latest/servers.html)), you need to configure your web server to use it and you need to configure your WSGI middleware to call your code. If you just want to try out Python web development, you do not need to know all the details about WSGI or how Python code is served by a web server. Just grab [Flask](http://flask.pocoo.org/) and try their hello world example which is on their front page. Like Flask, most Python web development frameworks use a simple web server that is preconfigured for development purpose to make it easy to run and test. Web development is really simple when you think about it. You get a request from a client for a resource and you return something. If the thing you want to return is a complex HTML document, the best way to do it with Python is using a template module. If you want to build any web application that is not trivial, you will most likely want to use some kind of [framework](http://wiki.python.org/moin/WebFrameworks). Most Python frameworks come with a preferred template module and some conventions to help you get started. If you do not like your framework templating engine, you can have a look at the various [other template modules](http://wiki.python.org/moin/Templating) that exist and use another one.
That is how I see it as well. To take an example from http://docs.python.org/tutorial/controlflow.html, let's say I want to print whether `n` is a prime or not. Zeus would write code in HeavenPython like this: if n % 2 == 0: print n, 'equals', 2, '*', n/2 elif n % 3 == 0: print n, 'equals', 3, '*', n/3 elif n % 4 == 0: print n, 'equals', 4, '*', n/4 elif n % 5 == 0: print n, 'equals', 5, '*', n/5 .... elif n % (n-1) == 0: print n, 'equals', (n-1), '*', n/(n-1) else: print n, 'is a prime number' Zeus can do such tricks because he's a God. But I, who is mortal, can write this: for x in range(2, n): if n % x == 0: print n, 'equals', x, '*', n/x break else: print n, 'is a prime number' That's how I get my head around 'for else'. 'For else' is just 'if elif elif else ... else'. For the number guessing example, some newbies could write: if int(raw_input("Enter a number")) == 0: print "You got me!" elif int(raw_input("Enter a number")) == 1: print "You got me!" elif int(raw_input("Enter a number")) == 2: print "You got me!" ... elif int(raw_input("Enter a number")) == 9: print "You got me!" else print "you never guessed the number!" We write: for a in range(10): if int(raw_input("Enter a number")) == a: print "You got me!" break else: print "you never guessed the number!" Edit: When I get confused, I just imagine branches branching out of a loop, the break branches and the else branch. [Let me draw that in Sumopaint](http://www.sumopaint.com/image/?id=1699681).
Oh please yes please! And if someone would then port the basemap sub-component of the matplotlib library, we'd be able to cross over completely.
Cool, thanks for your help. When you say "an if/elif chain becomes too inefficient", are you referring to one that has, say, 30 cases, and needs to be run through in multiple parts of the program, or is there a situation where if/elif over dictionaries and functions becomes computationally inefficient? Oh hey, while we're here, can you add "finally" clauses to ifs/loops? I mean, it's redundant as all hell, but it'd be cool to break out at a party.
Also if they checked their code and data so when you click to run the snippet it doesn't give a traceback error.
FYI there is also a [/r/django](http://reddit.com/r/django) where you can post this ;)
I'm trying to highlight that if you're breaking out of a loop you should probably use `find` or `any` instead, rather than the unintuitive `for...else` clause. I think that adds to the discussion. Sorry for not being clearer. Also, I think mine was _much, much, much_ easier to understand (c: 
That's definitely a weird but absolutely valid interpretation, probably the most valid one, thanks. I mean, at first it seems counter-intuitive: with `if-else` only one of the blocks executes. But loops are kind of different, the first block can execute any number of times, and indeed the `else` block executes only if the condition ended up being false at some point (as far as the loop machinery is concerned).
I'm not sure. Have you looked at PyGame? They have a keyboard module which can tell you what's pressed.
You're supposed to keep the generator expression simple by factoring the complexity into `my_test`. The cases where you can't do this are ones where you're concerned with complex relationships between adjacent elements of the list, or something similar (in which case maybe there is something in NumPy that can help you? Those sorts of problems are usually numerical, at least as far as my imagination can stretch at the moment...)
&gt;`{True: x, False: y}[1==0]` If you're just going to select two values based on a binary condition, I prefer: [y, x][bool(1 == 0)] although I would still prefer the y-if-z-else-x construct. In the example: index = 0 if float_raw_image_ratio &gt;= self.float_screen_ratio else 1 float_scale_ratio = float(self.tuple_screen_size[index]) / tuple_raw_image_xy[index] which actually avoids duplication. Again, switching the array order around (and relying on implicit bool-to-int conversion) could get rid of the if-else bit, but readability counts.
What's the approach for supporting bytes/str in WSGI? I thought that issue in the spec hadn't been settled yet...
And even if they did, they could plausibly expect the 'else' to take the opposite sense from what it actually does: "run this if the loop didn't complete all iterations", rather than "run this if the loop didn't explicitly break".
If you want to mix the two Python is not the language for you. Stick to PHP. The closest you will get is using a template engine like Jinja or Mako. Look into some web frameworks like Flask or Bottle. Also to post code indent with four spaces: &lt;?php echo "ewwwwww" ?&gt; 
Except "the condition" is "a `break` was encountered", which isn't exactly the default expectation for a for-loop.
i dont particularly want to mix the 2, but was just wondering how i can get HTML (ish) designing on python
It looks like [someone already has](https://github.com/matplotlib/basemap/pull/3).
Like I said, I prefer to oversimplify when demonstrating or clarifying a point. Something I'd be more likely to use would be: class Whatever(object): pass class YeahRight(object): pass class HeyMawImUsingCamelCase(object): pass class StopLookingAtMyClassNames(object): pass def foo0(): return(0) def foo1(): return(1) def foo2(): return(2) def foo3(): return(3) a = HeyMawImUsingCamelCase() b = {"Whatever": foo0, "YeahRight": foo1, "HeyMawImUsingCamelCase": foo2, "StopLookingAtMyClassNames": foo3}[type(a).__name__]() Ok, I just realised you're replying to a different comment I thought you were, but I spend 2 minutes of my life writing that and I'll be damned if I delete it. Anyway, that line I pasted was before I found you could use if inline. I may revise it.
I'm too much of a newb, but I commend your efforts. :)
The spec was finally settled this summer and published as [PEP 3333](http://www.python.org/dev/peps/pep-3333/). In a nutshell, PEP 3333 clarifies that all data passed to or from the server must be a bytestring (i.e. `str` in py2 or `bytes` in py3) and that the client is responsible for all encoding/decoding concerns. There's a few wrinkles, but you can read the details in the PEP if you care. See in particular the [Unicode Issues](http://www.python.org/dev/peps/pep-3333/#unicode-issues) section.
You rock man, keep it up!
+1 for the hidden "be pythonic" message ;)
The book uses Ruby and Java. Why is this in r/python?
One way to learn is using web2py. There is a file called default.py. Every function in the like def index(): return locals() is mapped into a web page: http://..../myapp/default/index The output of the function (a dictionary) is filtered by a views/default/index.html which is HTML with embedded Python between {{....}}. A line ending in : opens a block and a {{pass}} closes a block. For example &lt;html&gt;&lt;body&gt; {{for i in range(10):}}&lt;h1&gt;{{='hello %i' % i}}&lt;/h1&gt;{{pass}} &lt;/body&gt;&lt;/html&gt; There is much more to this: a web based IDE, a Database Abstraction Layer, helpers that generate HTML and web forms for you, a mechanism for catching errors, logging and issuing tickets. 
What you just described is exactly the situation where test-driven development helps a lot. Try designing tests (e.g., using pytest) for the script, and each time you add features. That way, when you add features 6 weeks from now, you can know that they haven't broken any of the original functionality.
Upvoted you and sushi.
PHP-to-Python convert here. I think the only way to find out is to give it a try. Python is weird. It looks different. It feels different. It doesn't even use braces. And I've never been happier with another programming language in my life. PHP is inherently messy. It lets you do many things. It comes with all kinds of batteries included, but every good PHP developer knows that a core element of writing good PHP code is avoiding certain features and functions that are very seductive to the unenlightened but quickly turn your code into an unmaintainable mess. For example, PHP has no concept of modules. Sure, there are namespaces now (kudos if you use them despite the awkward syntax) and you can usually keep your code somewhat clean by spreading it across several files and using includes/requires, but the language doesn't do a lot to nudge you into that direction. In Python, OTOH, namespaces are built into the language. In fact, you'll frequently use them without being aware of it. Sure, there are modules and packages, but conceptually they're no different from classes and objects. PHP's type system is also pretty poor. Sure, PHP5 brought C#/Java inspired classes to get rid of the old POOP, but that usually brings more complexity than would be necessary in most PHP scripts. Python OTOH is conceptually ridiculously simple: everything is an object (even functions and classes), all objects can have attributes and methods. Python also isn't primarily a web language. A big problem with PHP is that it has its own web framework built in. Apache's `mod_rewrite` is your router, PHP is your controller and the scripts are your views. PHP was created to serve as its own template language. Super-globals allow easy access to all the necessary state. But this means that if you want to handle things differently or even more elegantly, you'll basically have to ignore everything the language provides you with even though it will still be there, luring newcomers to abuse them instead of your shiny, safe infrastructure. Inline HTML is still only an angle bracket and a question mark away, you still have to prefix all your code with `&lt;?php` and god help you if you ever need to work with Unicode because all the built-in text manipulation functions will suddenly break. Finally there's the third-party libraries. PHP has them, of course, but to find good ones, you'll have to navigate through seas of broken code written by teenagers with no understanding of security or re-usability. And you'll have to look all over the web, too, and then the deployment will basically consist of copy-pasting files into subdirectories -- ideally outside your web root if you care. Python has PyPI. It's done for Python what CPAN did for Perl in the nineties. And it's perfectly alive and kicking. Of course not every module you'll find on PyPI will be good, but more often than not, you'll be able to find sufficient documentation, contact details and a Github or BitBucket repository to fork and commit patches to. And the best thing is, deployment is only three words away: `pip install &lt;package-name&gt;`. **I think all of this boils down to one, central, killer feature. As Eric S. Raymond put it: Python does not get in your way. PHP does -- you just get better at working around the annoyances.** The only reasons I could see why you wouldn't like Python are if you prefer Java (for its strict bureaucracy), Lisp or Haskell, (for their conceptual purity) or Ruby (for how it embraces individualism and eccentric creativity).
1) Again, this was just an example and my_test() is probably actual code, not an ad hoc function. Writing ad hoc functions for every kind of search body seems a little overkill and verbose, even for moderately complex ones. 2) Even simple relationships between adjacent elements make the generator idiom unusable or very awkward. For example, find the first element of the list that is followed by an odd element, or that is last in list. 3) I don't understand why the two of you (zahlman and stillalone) are making simple things complex, especially when the topic is about *else clauses* ? 
&gt; Also, how does python handle scrubbing inputted data? Try to get rid of that concept. You only want input validation if it is absolutely necessary, i.e. if you immediately want to pass it on to a vulnerable resource as input (e.g. the shell, or a database interface). Most of the time what you want to do is output validation. Because such concepts as "escaping" only work with context. What may be safe in HTML may not be safe as a JavaScript string, for example. &gt; What books or resources do you suggest for learning python? Look around a bit. This question has been answered plenty of times in this subreddit. But personally I would recommend the Python tutorial, which is part of the [official documentation](http://www.python.org/doc/). Your first step should be to make sure you have access to a Python installation and open the interpreter. If you feel comfortable doing so, you may also want to install `pip` (the de facto standard replacement for the built-in `easy_install` for package installation and dependency management) and `bpython` (a helpful substitute for the standard interpreter shell). The interpreter is a great tool for getting used to the language because it allows you to input Python code and see it executed immediately. `bpython` is helpful in that it offers auto-completion for imports and accessing object properties (it also shows inline help for functions and such). The two functions you'll want to memorize are `help()` and `dir()`. The former opens the documentation of whatever you pass to it as argument (you'll probably use this more often than the online docs as the content is pretty much identical). The latter will show you a list of all the attributes and methods the passed object (remember: everything is an object) has. Also, `exit()`, to leave the shell ;) The Python shell also makes a really good calculator, btw.
&gt;Writing ad hoc functions for every kind of search body seems a little overkill and verbose, even for moderately complex ones. If it can't be written as a simple expression, there's a good chance it will have value as a separate function anyway. Even if just to give it a meaningful name. &gt;Even simple relationships between adjacent elements make the generator idiom unusable or very awkward. In practice, needing to worry about even simple relationships is rare, except perhaps in string searching, where we're using regexes anyway. &gt;I don't understand why the two of you (zahlman and stillalone) are making simple things complex, especially when the topic is about else clauses ? I fail to see how we're making anything complex.
Seconding the pseudo-code. I actually catch myself sketching difficult problems I encounter while programming in other languages by writing the code in Python first. Python may not be the most concise language possible (that's probably Perl, unless you delve into more esoteric languages), but it's rarely more verbose than necessary.
Ah, well in that case (as others pointed out) you just use the errors argument to open which is there for *exactly* that purpose. There is even the surrogate escape error handler that will allow you to decode malformed utf-8 and then write the malformed bits back out losslessly if you so choose.
Development has certainly cooled, but there are definite signs that we are warming back up. We'll put out a 2.5.3 in the next couple of weeks with some important bugfixes, and we should be able to get a 2.6 out sometime next year. Longer term, I have a start at a grammar for 3.x and expect to start seriously on a 3.x Jython next year. It's hard to give you anything more concrete than that.
Did you know parsing source code for TODOs and aggregating them is patented?
"done" sounds better if the loop body runs at least once, but "else" sounds better if it doesn't. Plus "else" is consistent with the if-statement and doesn't require an extra keyword.
&gt;I was actually thinking more about eventually. Which - in a way - reflects the "loop has not stopped prematurely" concept. Do you think? It doesn't convey that to me at all. Actually, as pauric mentioned, it's sorta reminiscent of "finally" which runs no matter what. Also, "eventually" would sound quite odd in the case of a loop body that doesn't run at all.
No, no, the condition I meant was the one that comes after "for" or "while". Just like an if-statement except that the loop body can execute zero or more times whereas an if body can only execute zero or one time(s).
Exactly. I guess this seems counterintuitive to some people because they see for and while loops as indivisible constructs or something. If you think of them as if...then goto statments, for example, it makes a lot more sense.
In the scenario he's using as an illustration, the else would apply to the if-statement that checks the condition. In an actual while loop, for example, you have the condition, the body, then the else block. If the condition is satisfied, then the block executes and the control flow loops to the top of the loop. If the condition is not satisfied, the else block executes. You can see that, apart from the branching back to the top of the loop, this works just like an if-statement. The end result is that the else will always execute eventually unless the loop is infinite or you break out of it. It may seem strange to some people, having an else block that is always eventually satisfied unless you have a break, but that's a consequence of how loops work: the condition always fails eventually - that's how a loop ends. Only by using break/continue can we end the loop without failing the condition.
Its more complicated than that (in particular its native strings not bytes) but yeah pep # is right
&gt; If someone new to Python reads this, there is a high risk that the person will read it as "Loop through this block. If the block did not run successfully ('else') then run that block". Which is not quite what this means... &gt; For this reason, I never use this construct. Why should code be written with the expectation that a total beginner can understand it? I know Python generally aims for simplicity and clarity, but at some point, people do need to learn the language. The various `else`s are quite useful and make the code simpler *once you understand them*.
I'm going to look into that extremely hard on Monday. Thank you.
&gt; surrogate escape error handler ? To make matters more interesting, the script I encountered this with was actually using argparse.FileType() not open() directly, it doesn't have the capability of using any of the encoding/errors/etc arguments. I since changed that to a regular 'store' and do the open() myself now. If I remember I'll raise a FR for argparse. 
Just want to say thanks!
true...
No matter how much you quote the zen of python and some other general guidelines of programming, it won't make you right first, because they are guidelines and not rules and second, because those still don't apply here. But I don't have the time or desire to keep going back to this conversation, if you want to think your solution is better, fine with me. If you don't want to understand what I'm saying, fine too. I'll answer any question you have, but I won't keep arguing about something that really isn't important. Thanks for your thoughts anyway :)
A much better choice might be a real introductory text on the subject like Structure and Interpretation of Computer Programs, which is available online for free and has been proven by generations of MIT students as well as being a standard text used at Berkeley and other top schools. This is an etext that no one has ever heard of, and this link looks to me like fairly transparent marketing spam.
There's no one answer to your question. Every web framework has a different way of doing things. That said, none of the successful ones work like PHP, because the PHP paradigm of mixing code and templates is dumb and unmaintainable. Instead you want to separate out your data, logic, and presentation into three separate things. The data goes in a database of some sort. The logic is written in normal Python. The presentation is done with some sort of template code, such as Jinja or Mako.
Are you serious?
You don't need a dict. You can do a tuple or list as well, (FalseCondition, TrueCondition)[Boolean] As, when it's an index, True == 1 and False == 0 You can also do TrueCondition if Boolean else FalseCondition or Boolean and TrueCondition or FalseCondition I would stick to using .. If .. Else .. Though.
This is not pythonic. Do not do this. 
Strawman argument.
Mmmh, you seem to have pretty set ideas about use cases. I do not know where you get your "practice" from, but I know that *my* practice definitely disagrees with your assumptions. And I have been writing large apps in python as my main occupation for years. But hey, YMMV. Who am I to argue if *you* say that *in practice* "needing to worry about even simple relationships is rare, except perhaps in string searching" ?
You can overload the existing operators (+, -, /, *). But for matrix stuff, those can be misleading, because which kind of multiplying do you mean? I suppose they could add dot as operator, but it would break the language, since this is legal now: &gt;&gt;&gt; object() . __class__ &lt;class 'object'&gt; I don't think it's very good style to put a space around the dot in property/method accessing, but it is legal, so there's probably a bunch of code that would be broken by it. And for all that breakage, what do you get? One more operator, when there are already many others to use like &amp;, |, and ~.
You have my support-- what can I do to help?
I should have been much more clear in saying that dot was just an example and would rather have someone smarter than me come up with a suitable operator or keyword. I also would definitely not overload the existing operators for the reasons you described.
I think the core language should be as lean as possible. Matrix operations are too special purpose in my opinion. 
i think that's precisely the reason its not been done it is NOT simple, clear and easy to do and if its hard to explain -&gt; bad idea
I fail to be convinced by this when we have operators for bitwise operations.
If it was a mistake, why should we repeat it?
Because numpy is a library, not part of the language, and matrix types are not builtin types. Even then, you might as well ask why we don't have a special operator for string concatenation instead of overloading `+`. :/
&gt;and could save you a lot of time getting stuff set up. Based on my last experience with installing the standard python.org distribution, it's hard to imagine that there's significant time to be saved.
Thanks. There are a few things you could do to help: * Confirm that you can reproduce the results, perhaps on another platform * Assist with finding the reasons behind the remaining test failures * Try it out in some real scenarios - e.g. in a virtualenv, and with other backends than the sqlite backend used in the standard tests
you're right
With NumPy you can already do: matA.dot(matB) Not quite as nice as an operator but not too bad. Or even: matA .dot (matB) 
I found a [cool hack](http://code.activestate.com/recipes/384122/) that makes it possible to write any function as infix, so you could write: matA |dot| matB === dot(matA, matB) In Haskell you can do this without any trickery involved. I guess Guido just never thought it would be useful, Python philosophy is all "One way to do things" etc. That said, nothing is wrong with prefix notation, it's mainly a matter of habit.
Matrix operations are used in huge amounts of computing, basically the second you need another dimension.
If you want arbitrary infix operators, this works today: &gt;&gt;&gt; class Infix: ... def __init__(self, f): ... self.f = f ... ... def __ror__(self, first): ... return RInfix(self.f, first) ... &gt;&gt;&gt; class RInfix: ... def __init__(self, f, first): ... self.f = f ... self.first = first ... ... def __or__(self, second): ... return self.f(self.first, second) ... &gt;&gt;&gt; @Infix ... def mul(x, y): ... return x * y ... &gt;&gt;&gt; 10 | mul | 3 30 
Don't strain yourself, persistence is key. Safer communities together.
Why are you calling dot product on matrices?
They have been proposed twice: PEP 211 and PEP 225. Neither PEP is going anywhere. The short answer is: it's an awfully domain-specific thing. If we're going to grow and complicate the Python language, it should be in service to everybody, rather than a small (if vocal) minority.
Maybe this is what you want http://www.pylatte.org/ 
NumPy has a matrix class that does what you want - or doesn't that work in Python 3? import numpy as np matA = np.matrix(np.eye(4, 3)) matB = np.matrix(np.eye(3, 2)) matA * matB ~~Unlike in Matlab, adding/subtracting a single value from a matrix will result in operations on all the elements, not just the diagonal.~~ Nope, that was Maple.
Yep, a feature request for argparse sounds more than reasonable. On the surrogate escape handler: &gt;&gt;&gt; open('foo.txt', 'r', encoding='utf-8', errors='surrogateescape') &lt;_io.TextIOWrapper name='foo.txt' mode='r' encoding='utf-8'&gt; What it does is decode invalid bytes in the file into technically invalid (I believe) surrogate pairs. If you write back out with the surrogate escape errors handler these surrogate pairs will be written back out as the original data. This is used internally by Python to handle undecodable file names / environment variables etc when accessed via the text API (I believe - I'm a bit hazy on the details). It is particularly useful for platforms like Linux that don't have a filesystem encoding - so decoding filenames and paths can be "hazardous". So the 'surrogateescape' errors handler is very useful for working with mostly-utf-8 data. It can also (but shouldn't) be used for handling bytes as text...
The difference with concatenation is that the + operator is not ambiguous for strings whereas all the numerical operators as well as the bitwise already have defined roles within arrays.
It's non-domain-specific in some sense, as matrices and other methods from linear algebra are used in virtually *every* scientific domain (be it artificial intelligence, engineering, statistics, bioinformatics, ...) but I agree that the language itself should rather focus on giving the user primitives that more complex things like matrices can be built upon, so having them in a library is fine. If python was a language built with the primary intent to be used for scientific computing, I'd probably vouch for putting them in. On the other hand, python also has the "batteries included" philosophy, so if people really want it, I think I wouldn't be opposed to including numpy into the python standard library alltogether.
Yes this is indeed already possible to use 2D matrix operators on numpy matrices. However I find this API a pain in practice and I prefer to use the np.array datastructure instead. Numpy arrays can be any dimensions (not just 2D). Furthermore you often want to have a consistent operators set for element-wise operations and have dedicated functions for more complex stuff such the dot and tensor products which are non trivial to generalize to higher dimensional numpy arrays of arbitrary shapes.
You must not have been on windows 7 64 bit then. 
Bitwise operators are the "axioms" of programming; they cannot be composed, and are the foundation of every other operation. They can be used to compose the arithmetic operators, but those are the basic operations of an ALU, so it makes sense to give them simple, atomic operators. On the other hand, matrix operations are not trivially composed, non-atomic (matrix multiplication is still stuck at `O(n^2.376)`, which is most certainly not `O(1)`), and the appropriate method for performing most matrix operations depends heavily on the structure of the matrix, leaving the operation best performed by a library like numpy (the optimal algorithm is different depending on if the matrix is diagonal, sparse, dense, upper-triangular, symmetric, etc).
Matrix operations *can* be atomic depending on what hardware you run on. For almost all intents and purposes, I agree that they're not, though. If you're implementing a video codec or something similar that can utilize SSE or possibly run on the GPU, and your matrices are restricted to a fixed size like 4x4 single precision floats, you get atomic matrix-matrix, matrix-vector, inner product, vector addition, vector scaling and so on. But the majority of numpy users probably want to operate on large, variable-size matrices for various reasons (doing linear regressions is a common task, for instance...)
That's rather amusing.
Trivially, any algorithm operating on a constant size dataset runs in "constant time", but we can all agree that that is cheating with words. The operations that GPUs perform in "constant" time do so because the vector buffer is fixed length, and it operates on the entirety of it at once. But, as you've said, generic operators is a horse of an entirely different color.
Well, then bitwise operations are not constant-time either, so I'm not really sure why you brought it up in the first place.
Read the comment I replied to, in regards to getting rid of bitwise operators. I'm not saying you are wrong; in fact, you are technically correct (the best kind of correct). I would argue that bitwise operators for arbitrary precision integers would also not be necessary, as they are easily composed; fortunately, integers are typically limited in size to 8-, 16-, 32-, 64-, or 128-bits, making operations on them `O(1)`.
Somehow this feels very awkward. Probably the unnecessary accidental complexity. 
Matlab also operates on all elements, or am I mistaken?
"science" is a domain and matrices are kind of specific to it. ;-)
"science" is an extremely very broad domain, and matrices are not even specific to that. I just used it because it's the best and broadest example. But for instance you also need them when viewing images or videos, or playing games, or many other tasks that in some form or other pertain geometry, data transformation, statistics et cetera (coordinate changes, compression, signal decomposition, ...). If you stretch the argument a bit, you might come to the conclusion that numbers should be excluded from the language, because it's only needed for mathematics.
&gt;If we're going to grow and complicate the Python language, it should be in service to everybody, rather than a small (if vocal) minority. All of Py3k is complicating Python in service to a very small but very vocal minority. To deprecate the % format operator just to satisfy the 0.0001% of users who want to mix positional and named parameters in the same formatting operation is something I could never understand. 
Along with about 85% of the PC-using population, sure. Well, back then Windows 7 didn't exist. But it wasn't about the OS, but about Python - the builds at that time were made with Visual C++ and nobody cared about binary compatibility with anything else.
&gt; All of Py3k is complicating Python in service to a very small but very vocal minority. Ignoring the hyperbole, you're more than welcome to speak up. In fact, we need more people to do so. &gt; To deprecate the % format operator... It's "deprecated" in that it's not the recommended practice in the documentation, and that's probably as far as the deprecation will go for the near future. Some have said that it would live through Python 4. If you're using %-style and you like it, keep on using it.
I sometimes would like Python syntax to be more matlabesque, but it works well so far and it also enables me to do other bits in a piece of code that I cant do in matlab such as sympy integration and string functions.
Twisted is an asynchronous thing. And there are ways to make said control flow more imperative-like in Twisted, like [the deferred generator feature](http://twistedmatrix.com/trac/wiki/DeferredGenerator).
I have used Python for 7 years (web, database access layers, formatting of data, distributed computation, graph processing, job queues, natural language processing) and I never felt the need to use a matrix operation.
Good to see they realized how badly they fucked up and are now trying to backpedal. At first they had announced that the % format operator would be deprecated in Python 3.1 and eliminated starting at 3.2. Unfortunately people get carried away and forget the K.I.S.S. principle, we see it everywhere in computing. It's a very simple principle, why can't people remember it: simplify the rule, not the exception. Because most of the time you'll be performing the most frequent tasks, that's a simple tautology that people always seem to forget. Another badly fucked up evolution in Python is the way subprocesses are becoming more and more complicated. The Unix system introduced some extremely powerful and useful concepts: everything is a file, data is alphanumeric by default, output from one task is input to another task. output=`dmesg | grep hda` One uses expressions like that every day, it saves a lot of effort in any Unix system management. Then that simple expression becomes this nightmare in Python: p1 = Popen(["dmesg"], stdout=PIPE) p2 = Popen(["grep", "hda"], stdin=p1.stdout, stdout=PIPE) p1.stdout.close() # Allow p1 to receive a SIGPIPE if p2 exits. output = p2.communicate()[0] What used to be (child_stdin, child_stdout) = os.popen2(cmd, mode, bufsize) Became in Python 3: p = Popen(cmd, shell=True, bufsize=bufsize, stdin=PIPE, stdout=PIPE, close_fds=True) (child_stdin, child_stdout) = (p.stdin, p.stdout) Simple day to day tasks become complicated, lots of useless parameters are needed just to cater to a few special cases. Why the hell everyone needs to state that "shell=True, bufsize=bufsize, stdin=PIPE, stdout=PIPE, close_fds=True"? Why can't all these default values be hidden in the system? If they had to introduce any new features in Python 3 that should have been the backtick operator. 
What about anything involving 3D?
I don't really understand why so many people here are arguing that this is domain specific or that the people who use matrix operations are a small minority. Matrix operations are used in nearly every science field, finance, game development, image and video processing, etc. The list could go on and on. In fact, I think that the only programming heavy fields that would not at some point find a good use for matrix operations would be pure computer science and web design. Additionally, the scientific community is rapidly adopting python. Throwing the scientific community a bone by giving them an easy to read way to do something they do daily would greatly help the growth of python's user base and number of contributors.
&gt; Good to see they realized how badly they fucked up and are now trying to backpedal. At first they had announced that the % format operator would be deprecated in Python 3.1 and eliminated starting at 3.2. 3.1.0 was released June 27, 2009 and even days before then (among other discussions), one of the developers behind the {}-style formatting said that %-style probably [can never go away](http://mail.python.org/pipermail/python-dev/2009-June/090168.html). Perhaps the documentation wasn't updated in-line with this and other comments, but the deprecation was clearly never carried out. I know I've seen in other places that people would be against *ever* removing %-style, perhaps it was later in that thread, although I seem to remember it being more recently. This doesn't need to be some "us versus them" backpedal call out. Getting things right isn't always easy, but it's way more important than any of our egos. &gt; Another badly fucked up evolution in Python is the way subprocesses are becoming more and more complicated. `subprocess` *is* a bit complicated, but the convenience functions are pretty usable and should be preferred. They're at the top of the documentation for a reason. `subprocess.call`, `subprocess.check_call`, and `subprocess.check_output` handle a lot of the common cases. Not everything is covered, so you can still go back to `subprocess.Popen` if needed. Those changes aren't specific to Python 3. Going back to Python 2.5, most of that stuff is pretty similar. `check_output` was added some time after 2.5, but the `Popen` signature looks to be the same in 3.3 as 2.5.
No you are not mistaken, your parent commenter is.
Honestly, if you're doing NLP without matrices, you're probably doing it wrong. (Or at least, inefficiently). 
 import operator class Matrix(list): @staticmethod def sumprod (row, col): return sum(reduce(operator.mul, data) for data in zip(row, col)) def __mul__(self, b): return map(lambda row: map(lambda col: Matrix.sumprod(row, col), zip(*b)), self) a = [[1, 3], [-5, 6], [2, 4]] b = [[1, 4], [8, 7]] A = Matrix(a) B = Matrix(b) print A * B 
&gt; ##that simple expression becomes this nightmare in Python So... you're looking for something like [this](http://docs.python.org/library/subprocess.html#subprocess.call)? &gt; Warning: Executing shell commands that incorporate unsanitized input from an untrusted source makes a program vulnerable to shell injection, a serious security flaw which can result in arbitrary command execution. For this reason, the use of shell=True is strongly discouraged in cases where the command string is constructed from external input *That's* why shell is false by default. With stdin and stdout == None close_fds should *not* default to true, you can pass in existing file objects and there's no reason to close them by default when the call finishes. &gt; ##should have been the backtick operator Why? What would it do? &gt; ##the % format operator &gt; The '%' operator is primarily limited by the fact that it is a binary operator, and therefore can take at most two arguments. One of those arguments is already dedicated to the format string, leaving all other variables to be squeezed into the remaining argument. The current practice is to use either a dictionary or a tuple as the second argument, but as many people have commented [3], this lacks flexibility. The "all or nothing" approach (meaning that one must choose between only positional arguments, or only named arguments) is felt to be overly constraining. &gt; [source](http://www.python.org/dev/peps/pep-3101/)
What errors are you getting?
We get it, you hate the change in string formatting: http://www.reddit.com/r/Python/comments/mi4of/do_regexps_hurt_your_head_do_you_know_format_for/c314gf6 I personally find the new option makes much more sense. If you're worried about keystrokes, go program Perl.
&gt; &gt; The more people disagree on how "for/else" should be spelled, &gt; the more I think there is no keyword that can encapsulate what it does &gt; unambiguously. Certainly "then" leaves me as clueless as "else" for &gt; the reasons above. I was thinking of something verbose like &gt; "elifnotbreak", but not only it is ugly, it is not 100% accurate; the &gt; correct spelling would be "elifnotbreakandnotreturnandnotexception" ;) &gt; It is something that has to be learned. Now, lots of things have to be learned -- the behavior of range(1, 10) does not come naturally to many people either. But apparently for-else is used rarely enough that, given the way most people learn (by trying and by reading others' code, not by reading docs), many people don't know about it. &gt; That's a flaw, and I don't quite know what to do about it. It's about 20 years too late to remove or rename it. But we probably should not do more of these. That's a lesson. There was a suggestion to remove this for Python 3, and it was stated pretty much that it's a mistake to have them in the language, but they've existed too long for them to remove it. 
&gt;I don't understand why the two of you (zahlman and stillalone) are making simple things complex, especially when the topic is about else clauses ? I think *you're* making simple things complex. You're arguing against a generator formulation because it's too cramped "in the real world", but you can't seem to admit the possibility of breaking it up. Your assumption seems to be that the generator code has to have everything defined inline while your for-loop can be nicely spaced out. As for the topic being else clauses, the generator example was only brought up by stillalone as an aside: you're the one who started discussing it, so it's a bit unfair to suggest other people are OT. 
In general there is little need to run from trunk these days (those instructions date from a time when Django was in a state of contestant heavy flux). I would try again with a normal 1.3.whatever install.
This is already the behaviour of the numpy.matrix class. This is unsatisfactory for two reasons. The first is that the matrix class only allows for two dimensional arrays and the second being that we now need to call numpy.multiply for element-wise multiplication. Now numpy.array allows for ndimensional arrays and the * operator defines element-wise multiplication (as it should) but we now have to fall back on numpy.dot. Hence the need for the additional ~* operator. 
&gt;If you're worried about keystrokes, go program Perl. if you're not worried about keystrokes, go program Java. Python was supposed to be an easy to learn and easy to use language. Version 3 turned it into a pissing contest with Ruby on who can be more pedantic about the features you are least likely to ever need. 
Microsoft Windows [Version 6.1.7601] Copyright (c) 2009 Microsoft Corporation. All rights reserved. C:\Users\Nate&gt;cd Desktop C:\Users\Nate\Desktop&gt;cd myp C:\Users\Nate\Desktop\myp&gt;django-admin.py startproject mysite C:\Users\Nate\Desktop\myp&gt;python Python 2.7.2 (default, Jun 12 2011, 14:24:46) [MSC v.1500 64 bit (AMD64)] on win 32 Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; import django &gt;&gt;&gt; print django.get_version() 1.4 pre-alpha &gt;&gt;&gt; ^Z C:\Users\Nate\Desktop\myp&gt;django-admin.py startproject mysite C:\Users\Nate\Desktop\myp&gt;python Python 2.7.2 (default, Jun 12 2011, 14:24:46) [MSC v.1500 64 bit (AMD64)] on win 32 Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; import django &gt;&gt;&gt; django-admin.py startproject mysite File "&lt;stdin&gt;", line 1 django-admin.py startproject mysite ^ SyntaxError: invalid syntax &gt;&gt;&gt;
&gt; i have also tried to type in (Directly to cmd) django-admin.py startproject mysite but that simply opens up django-admin.py in notepadd++ That means your command interpreter (i.e. cmd.exe on Windows) doesn't know what to do with a .py file. Try "python django-admin.py startproject mysite". Also, Windows. Why? :)
Sure. All I mean is that I've used Python for my day job for 10 years, doing a variety of stuff, and never needed matrix operations for it.
So, they are again backpedaling, renaming os.system to subprocess.check_output. Still, no professional programmer gains anything from making things more complicated than necessary. Yes, we know about shell injection. Apart from the false sense of security there's nothing to be gained from tying up the programmers' hands, you don't need to "protect" us. If I'm writing a web application I will use precautions against shell injection, along with many other precautions. Better, I'll use a framework whose designers have taken care of such details. There's no need to encumber all the tasks that will never be affected. It seems that people in the Python community are entirely unaware that professional programmers use the language. In the 30+ years I've written software I cannot remember one single instance where I felt the need to use both positional and named arguments in the same string formatting operation. OTOH, I simply cannot take a program that has been tested and validated, sometimes at a great cost, and say, "hey, folks, let's migrate this shit to a new version" just like that. That's why I still use Fortran 77, I work in the aerospace industry, we have software that was developed decades ago, the people who wrote it have mostly retired or died. There are formulas and parameters there that were developed in field tests that cost millions of dollars, there's no way one could justify redoing them. What Python 3 is demonstrating is that Python is NOT an "industrial strength" language. It's a shame, because it was a nice language to use. It will still be used for things like automating operating procedures, sure, as long as one freezes the version in the system and never update the software. I was interested in SciPy, it seemed a very good alternative to Matlab. Alas, I cannot justify its use, not for aerospace quality work. I cannot risk finding a case where a formula that truncated a division result in one version of Python returns a floating point number in another version. You see, that's another big fuck-up in Python 3, a mathematical operator that behaves differently in the new version... 
Except it's the opposite of "finally". Finally clause is executed even if you are trying to run away with break or return.
You might want to read up on the many things you can do with them, then, I imagine you have re-implemented things like matrix-matrix, matrix-vector multiplication, matrix inversion etc many times over without realizing it. (I'm sure I did before I learnt about matrices)
I mean in terms of word choice. Eventually is very similar to finally.
Once you look up how it works, yes, it's easy to understand, but it's not intuitive when you first see it, and I think Python strives to be intuitive to beginners. A "done" or "last" keyword of some sort would make more intuitive sense. "else" may make sense if you consider its logical implications, but it does not make a lot of sense when you can consider the implications of the word itself in the natural English language, and the more Python is like English, the better, in my opinion.
What Python could *really* use is user-defined operators (as in Haskell). Then stuff like this could be handled by libraries. It's incredibly useful for writing clear, readable domain-specific code. Has anyone written a PEP for this? Is there any impediment to it?
Please prefix your lines with 4 spaces so that they're not mangled. You're typing `django-admin.py startproject mysite` at the python interpreter prompt (`&gt;&gt;&gt;`) but that is not valid python code. That's a command that you run from the command line prompt, it's not python. When you're in the python interpreter (the `&gt;&gt;&gt;` prompt) you can only enter valid python code. 
If you join the web2py google group we an help you more with this. Your config file above is supposed to server static files by-passing web2py. First I would check whether this works when you type in directly the url of static file (if not then it is a web server config issue or a permission issue). If that works, I would check the path of the url to static files generated by web2py. It is possible the generate urls are wrong. This could be because of a web2py routes_out configuration. Make sure you are using the stable web2py or the latest nightly build. There was one trunk/development version where we experimented with automatic compression and minimization of static fields and had a problem with static link. A feature that we are still testing but now works properly.
got it working with : python C:\Python27\Lib\site-packages\django\bin\django-admin.py startproject mysite thanks for clarifying...still dont understand why i need the abs. path to admin.py, when the guide tells me to use simply django-admin.py 
&gt; So, they are again backpedaling Grow up.
It turned out create-mime.assign.pl didn't have execute rights. I u+x it and all is well except for FastCGI not staying running, but that's another issue entirely. But while I have you on this subject, is it acceptable to use routes.py to rewrite a URL if I'm bypassing web2py for static files? Will this cause static file URLs to not be rewritten or might it force web2py to server static files? I would much rather use routes.py for this as the syntax is infinitely easier than mod_rewrite.
Yes you can use both but have to be careful. If you web server will serve static files bypassing web2py, the routes_in is ignored. routes_out instead will rewrite URLs linked by your app. So if you rewrite them, you have match the re-routed URLs in the above config file. My advice is write routes so that leave the URLs of static files always unchanged.
So did you actually use it?
There is a lot of new stuff this time: A CLI interface, new routing syntax and lots of convenient helpers for request/response objects and templates. The change-log will tell you more. If you don't know bottle yet: Bottle is a fast, simple and lightweight WSGI micro web-framework for Python (2.5+ and 3.x). It is distributed as a single file module and has no dependencies other than the Python Standard Library. * Homepage: http://bottlepy.org/ * Changelog: http://bottlepy.org/docs/0.10/changelog.html#release-0-10 * PyPi link: http://pypi.python.org/pypi/bottle/0.10.1 * GitHub: https://github.com/defnull/bottle * Mailing-List: bottlepy@googlegroups.com * Twitter: https://twitter.com/#!/bottlepy * Original reddit thread: http://www.reddit.com/r/Python/comments/ba3rk/bottle_python_web_framework/ IAmA bottle developer and open for questions.
"math" is a domain to, so I propose we move all operators in a separate library, because no normal person should use 'math'.
Bullshit. If matrix calculation is awfully domain specific, then string handling is domain specific too.
Well, things like the number of comments are just stored as local variables that almost instantly go out of scope, so if you did anything with them, it'd have to be with a debugger (`pdb` might be able to do something programmatically, I don't know). `Home`, `Login`, and `next()` aren't defined, unless one of the modules imported from `r.doqdoq` does some funky stuff. Other than that, it's valid syntax, but it'd be silly to use it to do any data scraping.
[docs.python.org](http://docs.python.org/) has pretty much everything you need. Start at the tutorial, then go to the library reference and hit the language reference to fill in any details. 
Not in any useful way, or at least in any more useful way than just using the API, as far as I can see.
If you're a senior engineer, grab the slightly out of date Python Cookbook by Alex Martelli. It's a book of clever solutions but the main point is introducing you to how Python is used to solve common and uncommon problems. Otherwise for Python: setters/getters are generally frowned upon, interfaces are almost non-existent ( ignoring ABC's ), and though Python supports diamond/multiple inheritance it's used with some restraint. Slightly major difference between Java and Python classes is the concept of class properties and class instance properties. class Foo(object): index = 0 def __init__(self): Foo.index += 1 self.cid = Foo.index print "I am class instance #%s" % self.cid Foo() &gt;&gt;I am class instance #1 Foo() &gt;&gt;I am class instance #2 EDIT: Fixed class property to use Foo.index instead of self.index Otherwise Python is a fairly forgiving language and I've seen several Java engineers be able to quickly pick it up, just got to dive into the deep end. 
I agree. Though at least the provide a way to get a list of hyperlinked titles to all the facts if you click on "view all". Which is better than nothing.
&gt; web, database access layers, formatting of data, distributed computation, graph processing, job queues, natural language processing Certainly doesn't seem like it.
That example does not work in 2.7
my personal favorite. http://www.amazon.com/Expert-Python-Programming-practices-distributing/dp/184719494X covers all the necessary things to become an expert programmer in python.
_Dive Into Python 3_
You seem to have missed the memo that Python3 *is not backwards compatible* with Python2. Mathematical operators that differ between versions is not a "fuck up" - it's a design choice, and it's not intended to let all 2.x programs work without modification and testing. (Not that they're forbidding you from staying on 2.7, either)
Even if is it not really a tutorial or a guide, you should have a look at [Code Like a Pythonista: Idiomatic Python](http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html). It contains purified Python wisdom that anyone with a good programming background will understand. It shows the main features of the language.
The example itself is wrong, and does not work for new-style classes (not sure about old-style). It prints instance #1 both times because member access on an instance will attempt to access the member on the instance's class only if it does not exist on the instance itself. "self.index += 1" is equivalent to "self.index = self.index + 1", which accesses Foo.index (since there is no instance member named "index" yet), then creates an instance member of "index" with value Foo.index + 1. Since Foo.index is never changed, this will always be 1. In order to work as he wants it to, he'd need to replace "self.index += 1" with "Foo.index += 1" or "self.\_\_class\_\_.index += 1"
Try these two. http://www.korokithakis.net/tutorials/python/ http://www.siafoo.net/article/52
What exactly is this function supposed to be doing? It's not doing string matching: &gt;&gt;&gt; string_match('b', 'b') 0 &gt;&gt;&gt; string_match('bb', 'bbbbbb') 1 If you just want to see if two strings are equal, then `return a == b`. Also, what's this `if (str1) in (str2):` business? It's more efficient and straightforward to write `if str1 == str2:`. Moreover, why create a list if all you care about is the length? Just increment an integer. Finally, assuming there's some unseen logic to what this is doing, you can write it as def string_match(a, b): return len([1 for i in xrange(len(a) - 1) if a[i:i+2] == b[i:i+2]]) Edit: more efficient: def string_match(a, b): return sum(a[i:i+2] == b[i:i+2] for i in xrange(len(a) - 1)) 
[The modules documentation](http://docs.python.org/tutorial/modules.html#packages) should explain this nicely
 &gt;&gt;&gt; string_match('foo', 'foo bar baz quux spam foo bar baz quux spam') 2 I think he's trying to get it to match runs of characters, i.e. return the number of times it appears.
If that's the intent it's not even close to correct: &gt;&gt;&gt; string_match('foo', 'foo foo foo foo foo foo foo') 2 And there are much better ways of accomplishing that: &gt;&gt;&gt; 'foo foo foo bar foo'.count('foo') 4 
For what it's worth, that's the same idiom you see in [Coding Like a Pythonista](http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html) but you can do it with a list comprehension: def string_match(a, b): count = [ i for i in range(len(a) - 1) if a[i:i+2] in b[i:i+2] ] return len(count) or skip the middle man: def string_match(a, b): return len([ i for i in range(len(a) - 1) if a[i:i+2] in b[i:i+2]]) with one line functions like that, I usually just make them a lambda: string_match = lambda a, b : len([ i for i in range(len(a) - 1) if a[i:i+2] in b[i:i+2]]) 
That code is so broken I have no words. Even though I don't know what it's supposed to do, I can tell it's broken.
The first thing you want to do when you want to improve a piece of code is establish what it does, preferably with a test suite of some sort. As you can see from people struggling to understand the intent of this code, we can't really proceed without that.
Remove the square brackets and turn it into generator comprehension instead. 
sorry for my broken English, I hope I can understand what your means, and I can express what I want to. if you can give us some testcase, it will definitely help a lot to both side. first, we need pairwise from [itertools recipes](http://docs.python.org/library/itertools.html#recipes).pairwise('abcde') returns 'ab', 'bc', 'cd', 'de' then sum(bool(ai == bi) for ai, bi in izip(pairwise(a), pairwise(b))) maybe enough. below is the code: #!/usr/bin/env python # -*- coding: utf-8 -*- from itertools import izip, tee def pairwise(iterable): "s -&gt; (s0,s1), (s1,s2), (s2, s3), ..." a, b = tee(iterable) next(b, None) return izip(a, b) def string_match(a, b): count = [] for i in range(len(a) - 1): if (a[i:i + 2]) in (b[i:i + 2]): count.append(i) return len(count) def main(): a = "abcdefg" b = "abdcefg" print sum(bool(ai == bi) for ai, bi in izip(pairwise(a), pairwise(b))) print string_match(a, b) a = 'foo' b = 'foo foo foo foo foo foo foo' print sum(bool(ai == bi) for ai, bi in izip(pairwise(a), pairwise(b))) print string_match(a, b) if __name__ == "__main__": main() #output #3 #3 #2 #2 
Sorry, I should have specified that, editing the original post to give it context. Edit: Thanks Rhom, your final edit (after having received the context) is awesome as others have noted.
Yep, that's what I'm going for, with the added requirement that "[the matching] substrings appear in the same place in both strings"
Sorry about that, clarification added
Why are you collecting the matching indices if you don't need them? def string_match(a, b): count = 0 for i in range(len(a)-1): if a[i:i+2] in b[i:i+2]: count += 1 return count Edit: However, I think Rhomboid's second solution is the most elegant. Not the easiest to understand, though. The comparison there returns True or False (1 or 0) (just in case ... someone is wondering) Edit 2: Corrected "=+" bug in code example
Thanks! No good reason at all.
Here's my go at it: len(filter(bool, map(lambda c: c[0] == c[1], zip(zip(a, a[1:]), zip(b, b[1:]))))) where a and b are your strings.
Is that lisp or python? :D
Reading up on how to do this, is the following a good example of what you mean? http://wiki.python.org/moin/Generators#CA-e105f471dc62dde7c779472a0386d1b676a6c0df_1
A great collection of ressources is here: http://jessenoller.com/good-to-great-python-reads/ Some of the main concepts to understand coming from Java are: - Python has functions; modules (files) create the namespaces for them (and all module level names) - everything is an object, even a class or function definition. Therefore these are first class citizens. - no getters/setters; Python has properties. - list and dict comprehension - iterators (not really Python specific) - overloading special methods (doubleunderscore___*___doubleunderscore) and how they relate to statements like del and print - strong introspection features. It's easy to get a function by the name my_func = getattr(my_module, "name_of_my_func") # now execute: my_func() Edit: One more: - Python's dynamically typed, of course. Think in names to types in your code. Everything you handle is a name. Then, what matters is the behaviour of the types your names refer to. Not the type itself.
Useful perhaps for surreptitiously browsing Reddit at work.
How about semi-functional approach: def string_match(s1,s2): eq = [x==y for x,y in zip(s1,s2)] # Find equals return sum(x==y for x,y in zip(eq, eq[1:])) # Find pairwise equals and sum them print string_match("xxcaazz", "xxbaaz") Handles corner cases with empty strings too. EDIT: see correction below.
Too much Haskell. :) Here's a shorter version with a list comprehension: sum([1 for (i, j) in zip(zip(a, a[1:]), zip(b, b[1:])) if i == j]) .
I don't disagree, I wasn't sure if it was a contrived example to show what he was looking for. 
best of all it looks like test suite code :)
 def string_match(a, b): shorter_len = min(len(a), len(b)) - 1 return sum(1 for i in range(shorter_len) if a[i:i+2] == b[i:i+2]) 
It's called a generator expression, but you can't do that with len(), because generators have no length.
I think you can omit calling bool on the result of comparing tuples ai and bi, even if the individual tests don't return a bool: &gt;&gt;&gt; falsey == 1 '' &gt;&gt;&gt; truthy == 1 'True' &gt;&gt;&gt; (falsey,) == (1,) False &gt;&gt;&gt; (truthy,) == (1,) True 
Generator comprehensions don't have a length though. Instead do `sum(1 for ...)`.
Your second line is matching if `eq` is the same as `eq[1:]` at that index, _not_ if they both match. If you have two falses in a row, you'll get bad output.
Good catch, the second line should read: return sum(x and y for x,y in zip(eq, eq[1:]))
Exactly what I was looking for. Thanks!
Mod here, going through the spam queue. Next time you go submit a link to Amazon please scrub the referrer link (in your case it is the one added by duckduckgo) because it triggers the spam filter. Thanks!
Mod here, going through the spam queue. Next time you post a link please do the following: [to see what is built-in](http://www.markus-gattol.name/ws/python.html#built-in_modules) The use of URL-shorteners triggers the spam filter. Thanks!
Annoyingly, the basemap 1.0.2 debian package only contains python 2.6 and 2.7 versions of the .so files. I'm guessing that's because the current release version of matplotlib doesn't support python 3, so there wouldn't be much point. Looking at the mailing lists, it looks like the plan is for matplotlib 1.2 to support python 2.[67] and 3.[1+] and I see python3 (or __future__) code supposedly from master in git, so the py3k branch is clearly merged. So... close... :)
Nice, seems like some overkill for such a task but nice execution.
The next time you post a code sample, please put 4 spaces before each line so that it shows up nicely formatted. Thanks. 
Mod here, going through the spam queue. If you want to post a link, please do this: [Karls Sims's work](http://www.karlsims.com/papers/siggraph94.pdf) Using a URL shortener triggers the spam filter and got your comment flagged. Thanks!
In bioinformatics, cheminformatics, and structural biology (three scientific fields in which I have worked) , "matrices and other methods from linear algebra" are not common enough to warrant specialized syntax support. "batteries included" refers to modules. It does not refer to grammar. Otherwise, built-in syntax for regular expressions is another missing battery.
Debian packaging doesn't seem to quite be keeping up with Python 3 compatibility. Numpy has supported Python 3 for over a year, but it's still only packaged for Python 2. Similarly for PyQt, although I understand there is some progress on that.
next() is a builtin function since Python 2.6 ;-)
I stand corrected. But that's a weird design. `len` should work on any iterable or generator. 
Since the release versions are less then 1.0, what do the bottle devs say about backwards capability with older releases?
Good Job. But can It run Crysis ?
&gt; `len` should work on any iterable or generator. No. Not all generators (and thus not all iterables) are finite. Take for example: def squares_gen(): i = 1 while True: yield i * i i += 1 This will yield perfect square numbers for as long as something iterates over it (or calls next). Other times generators will be used to manage datasets that cannot be held in memory all at once. Calling `len` on an iterable whose result set is unknown would require iterating until you get a StopIteration and counting the number of results. This is problematic because the iterable may not be finite (and the halting problem dictates that you cannot know whether or not it is finite). Additionally, you can only iterate over a generator once without reinstantiating it. If you iterate over it to get the length, you can't iterate over it again. Given that generators can have side effects, you can't guarantee that you'll get the same result when you iterate over a second instance. The only way to get the length of a generator is to iterate over it, and this has enough consequences that you don't want the interpreter to make any assumptions for you.
Each release is aimed to be backwards compatible to the last one, meaning that you have a full release cycle to adopt new APIs and fix deprecation warnings. Security issues (very rare) and annoying bugs are patched in stable and old-stable (e.g. 0.10 and 0.9). Even the unstable development branch is not pushed to the repository until all tests pass. Many users just download the latest bottle.py for small projects and don't bother using pip at all.
Right, sorry. I must have confused it with Maple, which does treat individual values as diagonal matrices.
Good point. Thanks for pointing it out. 
Bottle is the best micro-framework!
I agree that the common solution is cumbersome, but using the tuple notation for this might be a bit confusing as ```import simplejson, json``` already means that you want to import *both* packages. Why not something like ```import simplejson or json ```?
Why not just forward port 80 to an unprivileged port and then listen on that?
I've been told many times (read, I suppose) that the `range(len(x))` idiom is unpythonic, and to use `enumerate(x)`, even if you don't use the indices.
Optimized Windows builds [here](http://www.lfd.uci.edu/~gohlke/pythonlibs/#scipy) BTW.
I could be wrong, but I think if you submitted that as a PEP it would be shot down for having a low benefit to effort ratio. It's just not need often enough to deserve its own syntax (IMHO).
Python 3 cleaned this up for packages in the standard library. E.g. for pickle, (where in Python 2 you'd try cPickle), "import pickle" now tries the C implementation, and falls back to the pure Python version if that fails. I think there's something similar for the io package (where StringIO now lives). Of course, that doesn't help for packages outside the standard library, but I think there are very few cases where different packages are interchangeable. JSON and PyQt/PySide are the only ones I can think of.
I admit that I don't like it too. But I think it's OK to use it. I find it less unintuitive then using enumerate and use only the index. With range and len the purpose is clear. Nested, a bit ugly, but clear. With enumerate the syntax would be more elegant and clean looking, but the purpose would not be to the point.
While it cleaned it up for 3, the issue still exists if you want to write code that is compatible with both 2 and 3 and prefers the C implementations. You also have some of the re-organized names, e.g., `Queue` vs. `queue`.
This wouldn't help with that case as the feature won't exist on any 2.x implementations.
I agree, special syntax is not really warranted, but a module in the standardlibrary might be.
I agree, it always bothers me to extract that extra bit of information that I just don't need. As a reader, I would find that confusing: "Where the hell is this used? What am I missing?" Use of enumerate is just what I've read and been told.
3D in Python? That is what C is for.
If I did, I would probably use C anyway.
I don't think python needs more syntactic sugar. Also, your solution doesn't solve all the possible imports with aliasing (eg: from bla import foo as bar).
A possible downside to this would be that 1) or 2) make it pretty obvious what you're doing with quite simple Python grammar. Your solution however could be more confusing, since `import a,b` already imports *both* a and b
I'm not sure making it a boolean expression is a good idea. How about: import lxml but xml if you must
Or you could just use [six](http://packages.python.org/six/#module-six.moves).
Speaking of security, I meant to bug you more about the default mako template filters.. the built in template language automatically escapes xml, but if you switch to mako you are open to XSS attacks...
 import cStringIO or StringIO or .... as StringIO
Unfortunately, your solution would only return a count of 0 or 1. You have a really tough bug in there. count =+ 1 is significantly different than count += 1
Other pylint alternatives to consider: pychecker, pyflakes
Ahh, then you disagree with the comment that there should be new "operators or reserved keywords for matrix operations." I misread it to think you wanted a new syntax for matrix multiplication.
Maybe "import simplejson else json as json" would be a better format.
Just use json: http://www.reddit.com/.json (tacking .json at the end of reddit urls will return the data in json format pretty much site wide)
&gt; Also, your solution doesn't solve all the possible imports with aliasing (eg: from bla import foo as bar). What does it miss? I'm assuming this is only intended to work at the module level for modules that have the same internal function and class names. You could do from (bla, cBla) import foo as bar Or import (bla, cBla) as foo You couldn't use the failover imports on the things within modules, so: from bla import (foo, foo2) as bar would be out of scope. &gt; I don't think python needs more syntactic sugar. I disagree in this case. I often write code that must run in both CPython and Jython. In many cases this necessitates using a module that has been optimized for the target interpreter. For example, when parsing JSON I may need the simplejson speedups in CPython, and the [jyson](http://opensource.xhaus.com/projects/show/jyson) module in Jython. There have been cases where I've ended up with: try: import com.xhaus.jyson.JysonCodec as json except ImportError: try: import simplejson as json except ImportError: import json It would be much cleaner if I could just put import (com.xhaus.jyson.JysonCodec, simplejson, json) as json And unlike many proposals that I've seen on reddit, as far as I can tell this has a clean syntax, no negative side effects, and would have no real issues with backwards compatibility. I don't know that it's particularly likely to succeed, and even if it does it wouldn't be available in the 2.x line (where I would be able to use it with different interpreters). But I would still encourage mrynx to submit it as a pep.
...I thought that was funny :)
It's effectively overloading the ```or``` operator.
*Optimized* builds? Talk to me.
yeah, I would like to say int(...) instead of bool(...), but ai == bi itself should be enough here. thanks 
Where can I find more information about the CLI interface you mentioned? I see *"Added command line interface to load applications and start servers"* in the release notes, but no links to documentation.
Been meaning to look into this, it looks great so far. What's the easiest method to get ssl going? http://pl.atyp.us/wordpress/index.php/2011/04/using-bottle-py-with-ssl/ Is what I've found so far.
I would think that matrices would be possible if you can come up with a valid proposal. However I'm not at all about to support a dot operator. The whole point of Python is readable code, that becomes a problem when you start to overload common symbols. So to support this idea I would expect that a different set of operators be used where there isn't a one to one mapping of meaning. Or use function calls which aren't a problem even if you imagine them to be. In any event I have to agree with others here, matrix support should be considered as it is used widely. That is just a start though, Python could use a lot of work with respect to mathematical support. Floating around in various parts of Boost are some interesting concepts worth looking into also. Accumulators being one example from boost. Now the question becomes how much of this new stuff should be built into the language or instead offered up in a library? Frankly that could be a very long discussion. In the end it would come down to what can be provided cleanly in a library and what requires deeper modifications to Python and it's interpreter. I very much want to see Pythons mathematical abilities increase, but I also want it done rationally. 
I like this idea. I've written a little utility function that provides similar functionality: import sys def import_failover(*modules): for name in modules: try: __import__(name) except ImportError: continue else: return sys.modules[name] raise ImportError("No module in [%s]" % ", ".join(modules)) This allows you to do things like: StringIO = import_failover("cStringIO", "StringIO") json = import_failover("simplejson", "json", "django.utils.simplejson") Not quite as nice, given that 1. It differs significantly from the standard import syntax, 2. You have to import the module containing import_failover first. 3. You can't import components of a module (there's no equivalent to `from json import loads, dumps`). But it may be preferable to several (potentially nested) try/except blocks.
This sounds like you are crying over milk spilled long ago. It is interesting that you mention Fortran in this discussion as it is a language that more or less remained static. As a result it is dying, we don't want to see Python die. Healthy languages grow and evolve, the C family is one example. Even here 100% backwards compatibility isn't there, old source often needs considerable reworking to compile and work correctly. However because of the evolution in the C family it is a far better place to write new code. As to the division In Python 3 they did the right thing for a scripting language and more so did it the right way. That is at the point of a major revision. If you can't handle that fact in your code then the problem isn't Python. Python 3 was an opportunity to fix a large number of issues in the older versions of Python. By doing so they give the language an extended lifetime. As to Matlab why would you trust that anymore than any other suite in a safety critical app? It is still possible to make programming errors and it is still possible for a Matlab revision to slip out that has a problem. It sounds like you have unwarranted confidence in a software platform. Do you honestly accept every answer Matlab spits out at you as correct? If not, would you not be equally skeptical of Python and thus verify that your code works correctly. 
I found the same issue with Codingbat. It's a Java programmer's site and Python just got tacked on at the end. All the solutions for the Python side are the Java solutions even if you can do it much more elegantly. Take this one for example. &gt;Given a string and a non-negative int n, we'll say that the front of the string is the first 3 chars, or whatever is there if the string is less than length 3. Return n copies of the front; front_times('Chocolate', 2)  'ChoCho' front_times('Chocolate', 3)  'ChoChoCho' front_times('Abc', 3)  'AbcAbcAbc' This is the solution from the site... def front_times(str, n): front_len = 3 if front_len &gt; len(str): front_len = len(str) front = str[:front_len] result = "" for i in range(n): result = result + front return result Though you could do this so much easier in Python like so. def front_times(str, n): return str[:3] * n I personally gave up on the site after this exercise and turned to better sites for practice.
It's because the guide assumes you've got your c:\Python27\Scripts folder added to the system path. 
&gt; Anyone looking for a lean, cross-platform Python editor with (optional) IDE/debugging functionality, check out Vim + a Terminal (Seriously. Though I'm sure whatever this is might be worth trying, if you're doing serious stuff, typically nothing beats vim / emacs for productivity in Python land.)
The functional programming approach: we want the number of equal pairs, in a list of pairs of length-2 substrings constructed from each original string. We don't actually need to compare length-2 substrings; we can use pairs of characters. We can get the sequence of pairs of adjacent characters by taking two overlapping string slices and pairing them up. Given two sequences of character-pairs, we can make a sequence of pairs of character-pairs (to compare to each other) with `zip`, and then `filter` those to get only the equal character-pair-pairs and count up the results. def pairs(x): return zip(x[:-1], x[1:]) def equal_adjacent_pair_count(x, y): return len(filter(lambda z: z[0] == z[1], zip(pairs(x), pairs(y))))
When you only need the list for its length anyway, it's awkward to map and then apply a trivial filter, when you could incorporate the map function into the filtering logic instead.
I just reviewed the Norvig article and found that much of it is no longer valid/relevant for Python 2.7/3.x.
Excellent point! Thanks. I applied that and came up with this: len(filter(lambda i: i[0] == i[1], zip(zip(a, a[1:]), zip(b, b[1:])))) . Do you think there's some other way to tweak it? I know itertools.izip might help with perf. Also the duplicate "zip(a, a[1:])" construction bugs me a bit (nice func?).
happy cake day!
Seriously, such a dogmatic approach "nothing beats vim/emacs, so don't bother trying" won't get us anywhere. The vim/emacs approach has serious shortcomings (like sloppy python integration on the scripting side, you can't use graphics nicely etc.) so I for one welcome anyone who *tries* to improve the picture.
This would be my most pythonic way, in sense of elegance and readability (as well as how I would implement it, given the task in a real situation): def string_match(a, b): pairs_a = zip(a, a[1:]) pairs_b = zip(b, b[1:]) return sum(aa == bb for aa, bb in zip(pairs_a, pairs_b)) Which of course can also be written as this rather opaque *holy-shit-look-at-my-sweet-listcomprehensions* oneliner: def string_match(a, b): return sum(aa == bb for aa, bb in zip(zip(a, a[1:]), zip(b, b[1:]))) But I'd probably rewrite that back really soon to the first solution because, you know, I might still want to read my own code in two weeks :-) Another possibility is calculating the matches first and then count the pairs: def string_match(a, b): matches = [ca == cb for ca, cb in zip(a, b)] return sum(x and y for x, y in zip(matches, matches[1:])) But for some reason that solution seems a littlebit less readable, in the sense that it's not immediately obvious what is being calculated. Plus, this one doesn't translate into a oneliner as easily either :-) [well, a really *really* horrible one]. Thanks for the fun morning puzzle btw :-D Seems I shall need to check out that codingbat website some more!
What graphics are you talking about? And what exactly do you mean by "sloopy"? In my vim I got: * Cross module auto-completion * Syntax aware auto-indentation * Static source checking with annotations in the buffer * Tight git integration, etc. So, what am I missing? Honest question.
Does it need a specific version of Numpy?
Has anybody proposed allowing user defined operators? or perhaps restricted user defined operators(something like {.*},{^},{!})? Or would that be laughed offstage due to concerns over abuse.
I thought the Intel MKL was commercial, hence you had to charge for NumPy / SciPy linked with it just like the Enthought distribution.
But ```or``` is not just any boolean operator, it actually returns the first non-false value. &gt;&gt; 222 or 333 222 &gt;&gt; 0 or 333 333 So it's consistent and fine.
I'm not aware of anyone seriously proposing user-defined operators in Python. I don't think Guido would be interested. IIUC, he sees Ruby's runtime-modifiable parser as leading to less-readable code, rather than more-readable, as it forces one to read a new one-off syntax. He said something like "In Python, we don't use domain-specific *languages,* we use domain-specific *libraries."* Certainly such a dramatic change in the language would have to wait for Python 4.0. It would affect *everything,* right down to the format of .pyc files.
Well shit. But still, an import error is not logically equivalent to the modality of 0.
Scroll down a bit: &gt; This release requires Python 2.4-2.7 or 3.1- and NumPy 1.5 or greater.
[Editra](http://editra.org/)'s homepage says: &gt; Editra is freely available for personal use under the terms of the wxWindows License. This *seems* to prohibit commercial use, but the wxWindows License is a modified version of the LGPL that contains no such clauses. It concerns me that [this licensing issue was raised on its bugtracker](http://code.google.com/p/editra/issues/detail?id=417) 2 years ago, and the project's developer never even deigned to respond.
Haskell's backtick syntax is nice. As far as I can tell it is invalid Python3, meaning it could be added (it means repr in Python2). matA `dot` matB 
I'm not sure about ruby having a runtime-modifiable parser but ruby doesn't have user defined operators and I don't see why user defined operators would need one. 
True, but if we really wanted to address the issue it'd still be more elegant than the other proposals. Also, some Python keywords are dependent on context anyway (like ```else``` after ```if``` or ```for``` or in a ternary expression) so they could just as well say that ```or``` catches the preceding import error from now on in an ```import ... or ...``` context and be done with it without introducing new keywords or syntax.
Feel free to submit this to the python-ideas mailing list. Personally, while I'm not really sold on the solution you're actually proposing, I fully acknowledge the problem - the current way to do this is tiresome.
I don't believe I was being dogmatic. Actually I think I specifically said this might be worth trying, and then just suggested that vim / emacs would probably make you more productive. Which I believe is true.
The documentation is a bit lacking in this regard at the moment. If you call bottle.py without parameters, you'll get a help text.
You don't need the `[:-1]` index because `zip` automatically adjusts for the shortest of the two sequences. And maybe have a look at [my solution](http://www.reddit.com/r/Python/comments/mqms8/how_can_this_be_made_more_pythonic/c33c7n6), you can do the `len(filter(lambda` thing with just a `sum` as well. Boolean values evaluate to 0 or 1 in an integer context.
There are some SSL-capable WSGI servers available. I use gevent for a lot of of my projects: import bottle from gevent.pywsgi import WSGIServer server = WSGIServer( ('0.0.0.0', 8443), bottle.default_app(), # Or any instance of Bottle() keyfile='server.key', certfile='server.crt') server.serve_forever()
This is hard to do in a backwards compatible way, but I'll look into this.
I did even moar shorter: sum(aa == bb for aa, bb in zip(zip(a, a[1:]), zip(b, b[1:]))) Because a bool evaluates to 0 or 1 in a numerical context. You also don't need the square brackets because `sum` also works with generator expressions. In my "official" solution I just split the two inner `zip`s into a `pairs_a` and `pairs_b` variable for readability and it's no longer too much like Lisp or Haskell but IMO very Pythonic. 
These features weren't left out of Python by accident, they were exorcized. Strings are literal because it's so much safer, especially with multithreaded code. Of course, the async crowd are starting to say that "thread safe" is a contradiction in terms, and it's better to just use processes. And no-one denies that memory copying is a slow operation. 
Thanks for the feedback. I agree we should try an ad and haven't posted here for the last few releases (more by accident than design, I have to admit; interesting to see these comments here now). Perhaps the criteria should be if we can list some interesting new features in the title then it's worth posting here. voidspace is right, of course, that the community seems to vote our posts up more than down, but I also don't want to post enough uninteresting stuff to annoy people. ;-)
I've downloaded and run it. So far I am using it to run a random simulation and it runs 10x faster that Python 2.7 which is great.
Definitely not. The point of iterators is that items are computed only on demand, and it is quite common that this means you can't compute in advance how many items are left (or even if it is a finite number).
Huh. While the safety aspect is important for built-in elementary data types, the *ability* to use tools with caveats never left Python. The magic sometimes needs to happen, and Python doesn't stop you.
Awesome. That seem like the ticket to this problem. It probably would make sense to throw "pairs" in a lambda so you would end up with something like "sum(aa == bb for aa, bb in zip(pairs(a), pairs(b)))". Python's cool. :) That got me thinking... Why not to just use sets? You could do something like "len(set(pairs(a)) - set(pairs(b)))" where pairs = lambda x: zip(x, x[1:]). Let sets handle the comparison for you. :) It would be really interesting to know how various solutions compare performance wise. EDIT: Figured sets aren't the way to go. Matched way too much!
I'm not sure what you mean - *what* was left out of Python?
Ctrl+F 'fewer'. I was disappointed.
hmm.. I don't know if many people using mako with bottle realize it is not escaping xml by default. I believe most frameworks that use mako enable the default escapes.
I'd like to see some builds with the Oracle module in it.. I guess I should download this and test it, but last time I had to compile it myself to get the Oracle module compiled in :(
I believe he's saying that the things you just showed were not left out of python were left out of python. Which is just as strange as it sounds.
I'd like to see some builds with the Oracle module in it.. I guess I should download this and test it, but last time I had to compile it myself to get the Oracle module compiled in :(
Yeah, my initial hunch was "do something with sets" as well, but that was before I understood they only count pairs that match at the same position. Personally I try to avoid using lambdas (in Python) unless I really need an anonymous function in an expression and I can't come up with another way to do it. I find I usually get a cleaner/nicer looking solution that way. Lambdas are cool of course, don't get me wrong ;-) But in this case I would sooner write def pairs(x): return zip(x, x[1:]) You could even write that on one line if you prefer oneliners :) Arguably, this way is even better than my original solution with the variables, because it follows the DRY principle.
I did some further research on this. Apparently it's possible to implement an ordered set by using an ordered dict (Python 2.7+). I guess in this case the diff would work just smoothly. It was a bit disappointing to notice Python doesn't provide an ordered set by default. I would rather write lambdas like this: pairs = \\. x -&gt; zip(x, x[1:]). I really don't know why they chose "lambda" keyword instead of mathematical notation. Perhaps it has something to with the whole "explicit over implicit" thing. It's true it's pretty easy to overuse lambdas. They're kind of limited in Python by design, though, so I guess that cuts that down a bit. In that case you're pretty much forced to use a regular function definition.
If you're already using supervisord, then [superlance](http://pypi.python.org/pypi/superlance) is probably a better solution.
A similar feature has been proposed before: http://mail.python.org/pipermail/python-dev/2008-January/075788.html
I wrote a Python tutorial aimed directly at existing programmers. The slides themselves are "open source", written in reST, compiled using Python into HTML and viewable via the web. Here is my blog post about them: http://bit.ly/import-this And here is the link to the code (read the README, which includes a link to a compiled version of the slides themselves) https://github.com/Parsely/python-adv-slides I've used these slides for a 3-day course on Python for existing programmers, and also used it to train new hires for my company, Parse.ly. Enjoy.
Seriously. Though I'm sure this might be worth trying, if you're doing serious stuff, *definitely* nothing beats Sublime Text 2 http://www.sublimetext.com/ for productivity in Python land.
Came here to say that.
Making something read only doesn't really make anything thread safe. It just moves the problem. Either you have multiple references to one piece of data, which means you need to use mutual exclusion around your reference system (or whatever else you're going to use for memory de-allocation), or you copy the data, in which case you may as well have it mutable.
What?
Annnnnd, I just released Blessings 1.2, with MIT licensing and Python 3 (&gt;=3.2.3) support.
I'm assuming the rest of that file is supposed to be UTF-8, because `&amp;trade;` encoded as `0x99` means the file (or that portion at least) is encoded using [cp1252](https://en.wikipedia.org/wiki/Windows-1252), a Microsoft extension of the Latin-1 encoding. A bit of code I've started using to slightly santize inputs is the following: def decodedamnit(data): for codec in ("utf8", "cp1252"): return data.decode(codec) return data.decode("utf8", "replace") Since "cp1252" is a superset of "latin1" which is a subset of "ascii", that takes care of "ascii" and "latin1" decoding; and since cp1252/latin-1 should very rarely be valid utf-8, the code checks utf-8 first. Mind you, this is very USA/Western Europe -centric, other regions probably have other codecs that are more "common", but I've found this works for a lot of simple cases. 
While the link is somewhat different, this is a [repost](http://www.reddit.com/r/Python/comments/mqe7d/bottle_010_released_singlefile_web_framework/) with basically the same title which is also on the front page.
Less is incorrect here---it should be 'fewer' copies.
Ups, thanks.
Interesting post, but shouldn't all that stuff happen transparently? Why should it be necessary to delve into (somewhat) obscure functions to get better performance? 
I actually like Learning Python by Mark Lutz. There is some stuff for beginners, but it was easy to just zip through.
You don't have to delve into anything obscure. That was just a peek under the hood to see how it works. If you don't care about that, all you really need to know is that you can do this: data = bytearray(...) f.readinto(data) instead of this: data = bytearray(f.read()) ...if you know that you're going to be working with a large amount of data. It's not transparent because python made the conscious decision to go with immutable types as the default for things like strings, numbers, and tuples. You can argue that this decision has certain advantages and disadvantages, but it was one made a long time ago and likely isn't going to be changed any time soon. Since immutable is the default, you need a separate type that is mutable for each (e.g. tuples vs. lists). I don't see any way that `f.read()` could possibly know whether its caller expects an immutable string or a mutable bytearray to be returned, so there is no way for the choice to be transparent; you end up with two interfaces, `.read()` which returns an immutable string and `.readinto()` which takes a buffer and copies into it.
How did I know this guy only tested this on a 32 bit machine? Because he makes lazy assumptions like `sizeof(int) == sizeof(long)`. The source is right in front of him saying that `ob_sstate` is an `int`, but he accesses it with a `ctypes.c_long`, which means his example prints nonsense on a LP64 system: &gt;&gt;&gt; ctypes.c_long.from_address(id(a) + ob_sstate_offset) c_long(8030592600085889025) &gt;&gt;&gt; ctypes.c_long.from_address(id(b) + ob_sstate_offset) c_long(8030592600085889024) &gt;&gt;&gt; ctypes.c_long.from_address(id(intern(b)) + ob_sstate_offset) c_long(8030592600085889025) He makes similar mistakes assuming that `sizeof(ssize_t) == sizeof(long)` which is false on Windows x64 (LLP64) where `long` is 4 but `ssize_t` is 8. This article has inadvertently demonstrated why **YOU SHOULD NEVER EVEN THINK ABOUT DOING THIS KIND OF THING.** 
Actually strings are immutable because they have to be hashable for dictionaries.
Yeah, that'd be a nice addition, too (if they don't already have another use in mind for backquotes). It's almost as uncluttered as user-defined operators and even avoids the one potential disadvantage: lack of descriptive naming. It would work quite well in a dynamic language (with variable/optional args), too: you could use a backquoted operator to join two operands, but by the same definition, be able to use the function form in cases where additional, perhaps keyword parameters are required.
It's simpler to use `ctypes.string_at` in conjunction with the object's `__sizeof__` method and `struct.unpack` to just take a peek under the hood for fun and education. Obviously it only works if `id` returns the address in memory, which isn't guaranteed on all implementations.
Amen to that, high five!
Seems pretty peppy - I ran it on a [simulation I've been writing](https://bitbucket.org/ccoughlin/break_detector/overview); Python 2.7 was ~ 1.5 minutes on the default 100,000 cycles and PyPy 1.7 was ~ 42 seconds (PyPy 1.5.0a0 used to do it around the 1 minute mark). No errors or anything unusual to report.
I've seen Guido call them dunder methods...
Pics or it didn't happen.
PySpeed might be an easy way to add a useful progress bar, http://wiki.python.org.il/PySpeed Download the module, copy the "speed" folder next to deepzoom.py, and at start of file add: import speed Then on some interesting for loop, like for level in xrange(self.descriptor.num_levels): ..change it to: for level in speed.progress(xrange(self.descriptor.num_levels)): (or maybe just change `xrange` to `speed.xrange`) 
Well played ... [here's a pic](http://imgur.com/mQESm) :)
You can also use the buffer-protocol stuff to read data into ctypes based structs, sockets, multiprocessing connections and so on, http://dabeaz.blogspot.com/2009/08/python-binary-io-handling.html
It's all lexical, yo. And that's Guido's baby (see: `from __future__ import braces`). Will he ever admit that semantic whitespace is an unnecessary hindrance to language simplicity? Not a chance.
Not sure, but I made your code a little bit easier to read in the post. This is what I have so far: Protein.py A program that converts mRNA condons to an amino acid protein sequence A string of text import string Class Protein: Class Codon: A = ['GCU','GCC','GCA','GCG'] R = ['CGU','CGC','CGA','CGG','AGA','AGG'] N = ['AAU','AAC'] D = ['GAU','GAC'] C = ['UGU','UGC'] Q = ['CAA','CAG'] E = ['GAA','GAG'] G = ['GGU','GGC','GGA','GGG'] H = ['CAU','CAC'] I = ['AUU','AUC','AUA'] L = ['UUA','UUG','CUU','CUC','CUA','CUG'] K = ['AAA','AAG'] M = ['AUG'] F = ['UUU','UUC'] P = ['CCU','CCC','CCA','CCG'] S = ['UCU','UCC','UCA','UCG','AGU','AGC'] T = ['ACU','ACC','ACA','ACG'] W = ['UGG'] Y = ['UAU','UAC'] V = ['GUU','GUC','GUA','GUG'] START = STOP = def main(): print "This program converts mRNA condons to an amino acid protein sequence" RNA = input("please enter mRNA amino acid sequence: ") This program seems pretty easy to make, but I just started taking an intro level class. Good luck. 
Do you need to make `sleep_time` global?
Ah, that. Well, I didn't give the title a lot of thought, but now I see that 'fewer' would be more appropriate, although you can't say that 'less' is entirely incorrect. Anyway I'm not going to change the title now
Is this the only/main reason, though? Couldn't strings be mutable *and* hashable for dictionaries? Sure, then an unsafe situation could arise if a string serving as a hash key was modified without the dict knowing about it, but this is something that can be said to be the user's responsibility (i.e. it's possible in other languages).
I mean, I personally find it grating, but complaining isn't going to help. If you want to use less, go right ahead.
[r/learnpython](http://www.reddit.com/r/learnpython) is probably better for homework help. You might also want a more descriptive title.
downvoted for thumbnail. Sorry, but I don't like having asshats point at me.
It would be a lot better to invert this and have the codons as keys and the amino acids as values. Looking up a key in a dict is ultra-efficient O(1) and much faster than having to loop through the whole thing every time. 
So all you have do to is add something like: &gt;CODON_TO_ACID = { AMINO_CODES[acid] : acid for acid in AMINO_CODES } and alter accordingly EDIT: My bad, the above doesn't work. You'd have lists of codons as keys instead of codons. And actually it would fail because they're lists, not tuples, and therefore not elligible for Serves me right for glancing. &gt;CODON_TO_ACID = { codon : acid for acid in AMINO_CODES for codon in AMINO_CODES[acid] } is correct.
All that proves is your on reddit &amp; viewing the source. Fraudster!
My major recommendation - use the Pickle Format in send_carbon instead: http://readthedocs.org/docs/graphite/en/latest/feeding-carbon.html#the-pickle-protocol Let me know if those docs are clear (if not, I'll fix them up). Also, take a look at Diamond (written and open sourced by my team). It's pretty good Python, and will provide you a set of metrics collectors ready to go!
TL;DR - DSL stands for Domain Specific Language; a fact which is totally irrelevant to the subject. This is a collection of sentences. SENTENCES!!
I don't know what's lazy about those assumptions. They're bad assumptions, but I'd think the lazy way would be to just copy the headers as closely as possible, so use a `ctypes.c_int`, `ctypes.c_ssize_t`, `ctypes.c_long`, `ctypes.c_void_p`, ctypes.POINTER(ctypes.c_char), etc. A more ambitious attempt would create a `ctypes.Structure` for `PyObject` and `PyVarObject` along with factory functions to create structures for other objects. Then you could more safely (as if) mutate objects in memory. But beyond satisfying basic curiosity and earning trivia points, I don't know what good it would do. 
Keep this shit in r/pics. It's disappointing that *anyone* upvoted this.
Oh man.. how did I not know about superlance. So many servers to put it on now ;) Thanks
 class AminoClassifier: A class is an object with different methods (inner functions that modify/access stuff inside of it), attributes, and such. So when you spawn a monster in a game, the game calls a class named Monster(), like you will be calling a class called AminoClassifier(). AMINO_CODES = {...} A dictionary of amino acid codes. 'A' is mapped to ['GCU','GCC','GCA','GCG'] and each element in that dictionary can be called like so. If we open IDLE up... &gt;&gt;&gt; AMINO_CODES = {blah: blah} &gt;&gt;&gt; print AMINO_CODES['A'] ['GCU', 'GCC', 'GCA', 'GCG'] It gets accessed like that. def __init__(self, encode_string): self.encode_string = encode_string __init__ is the function called on what is in the parentheses when you do AminoClassifier('amino string here'). Because of how Python was conceived, each function/method in the class must be passed "self" in the code so that it can modify and look at itself. So by that concept, it takes in 'amino string here' and sets the class's own instance variable -- self.encode_string -- to the value of a variable that happens to be called encode_string. You can pass it a variable called panties and it'll do the same thing. def to_amino(self): I'll summarize. It makes an empty list called result, splits the amino acid string that it's given by spaces (e.g. 'GCU AAU CAA UUU UGG' -&gt; ['GCU', 'AAU', 'CAA', 'UUU', UGG']) and goes over each given codon to see if it's in a letter's dictionary value. It then appends the corresponding letter to the result list, returning it all when it's done. So the program will recognize that the 'GCU' codon is in A's list. Plop 'A' into result. Repeat for each given codon. if __name__ == "__main__": If you're running the script from the console with "python script.py" or "script.py", running from IDLE, or just double clicking it, run the following code... thing_to_do = raw_input("Enter space separated amino string: ") classifier = AminoClassifier(thing_to_do) print " ".join(classifier.to_amino()) 1. Ask the user to type in an amino string. Read it. 2. Make an amino acid classifier with the input as the argument. (like making a Monster) 3. Join the interpreted list of amino acids by spaces. And then print them out.
Do you have a link to Diamond?
I think it should be a global for 2 reasons. * It's something that end users may change, so it would be good to have it defined at the top of the script. * I change the sleep_time in the send_carbon function, but it doesn't actually sleep anywhere but in the main. Perhaps I am missing something? I appreciate you taking the time to look at it.
Oracle module doesn't come by default because that would create a dependency on oracle libraries, which most people don't have. We're thinking about a solution for that problem, but no success so far.
for example I can imagine an IDE that makes nice tex-based formulas based on your numpy expressions. And many many more things that are relatively hard to do in text-based environment. Graphics *can be* better than text, the fact that most time it's not is just not a proof.
Yes. I think the patent is slightly more specific than that (e.g. aggregating them, indexing them in a centralized storage and integrating them with a ticket system), but there's a patent for that.
Great suggestion! I have updated the code to do just that. Thank you very much. Also I'm now checking out Diamond, very cool!
I had to search for it as well, but [here it is](http://opensource.brightcove.com/project/Diamond/). 
&gt; if they don't already have another use in mind for backquotes Backticks will not regain any new functionality. The current plan is to leave them out of the language.
It has a syntax. It is a language.
Still, the sleep_time in send_carbon doesn't have to be the same variable as in the main, or does it? Consider using a constant (marked as such by using UPPER_CASE) as a global sleep interval and a local variable in send_carbon that you increment.
More like: reverse_map = {} for acid_key, rna_list in AMINO_CODES.items(): for rna in rna_list: reverse_map[rna] = acid_key Or a one-liner: reverse_map = dict((rna, key) for key, rna_list in AMINO_CODES.items() for rna in rna_list) 
"note that this method is just intended to show how the Python objects are structured in the memory"
It may not help you learn the syntax, but we should mention the existence of [Biopython](http://biopython.org/wiki/Main_Page), which can do many things like this.
I thought in all the discussions about coding for PyPy, people had said that we would write pure Python code and let the JIT make it fast? I understood RPython was just for the internals (and numpypy, as a special case)? But the description says this involves porting code from C/Fortran to RPython. I'm not trying to troll, I'm genuinely surprised by this. RPython is a statically typed language for static compilation. The key selling point for PyPy is (IMHO) its ability to speed up Python code - a dynamic, interpreted language. Why the apparent change in focus?
&gt;keep in my that this needs to be object oriented. 1. ... Because... ? 1. That particular restriction is about as vague as requirements for a program can possibly get.
I guess they simply didn't know any better, but yes, you're right. I'll contact the guy and try to see how it can be clarified.
 import ctypes import os import subprocess from distutils.sysconfig import get_python_inc def pansy(struct, member): EXE = "/tmp/pansy" CODE = """#include "Python.h" int main(void) {{ printf("%li %li\\n", sizeof ( (({struct} *) 0x0000)-&gt;{member} ), (long) &amp;( (({struct} *) 0x0000)-&gt;{member} ) ); }} """.format(struct=struct, member=member) MAKE = "gcc -xc -I{0} -o{1} -".format(get_python_inc(), EXE) gcc = subprocess.Popen(MAKE, shell=True, stdin=subprocess.PIPE) gcc.communicate(CODE) if not gcc.returncode: pansy = subprocess.Popen(EXE, stdout=subprocess.PIPE) size, offset = map(int, pansy.communicate()[0].split()) os.unlink(EXE) return {struct:offset, member:size} print(pansy("PyStringObject", "ob_refcnt")) print(pansy("PyStringObject", "ob_type")) print(pansy("PyStringObject", "ob_size")) print(pansy("PyStringObject", "ob_shash")) print(pansy("PyStringObject", "ob_sstate")) print(pansy("PyStringObject", "ob_sval")) print(pansy("PyUnicodeObject", "length")) print(pansy("PyUnicodeObject", "str")) print(pansy("PyUnicodeObject", "hash")) print(pansy("PyUnicodeObject", "defenc")) print(pansy("PyIntObject", "ob_ival")) print(pansy("PyFloatObject", "ob_fval")) **Edit:** Made the C clearer...
I'd pick bitbucket over github. Don't give in to the flavour of the month.
I wouldn't really call github the flavour of the month at this point, although personally I do prefer mercurial. Ultimately I think this decision will mean Django gets more attention and therefore contributions which we can all agree is a good thing. Edit: Also don't forget you can always use something like Hg-Git, which works pretty well.
It's just common sense. It's a very strange thing because more advanced python programmers know their tools and how to do things. They don't need a hand holding custom IDE for such a framework and a lot of things to sugar coat the fact that this is just a combination of buzzwords to make people think they really need this piece of trash for their next "change the world, get everyone involved rich" startup. More than that, most of the things they claim that this framework is able to do can be easily accomplished with existing tools, libraries, frameworks and some lines of code. Can anyone take these people seriously, given that they put their "masterpiece" behind a $$$$$$ license and that it's "invite based" for now?
I already get Django through GitHub. The official mirror is seeing some pull requests too, they just need to be notified to the other bugtracker. Hopefully a full-on move means less patches get lost.
Thanks. I modified it a bit to work in Windows (MinGW) with Python 3 (temp directory, exe extension, and ASCII encoding for the pipe to gcc). import os import sys import subprocess import tempfile from distutils.sysconfig import get_python_inc def pansy(struct, member): ext = '.exe' if sys.platform == 'win32' else '' EXE = os.path.join(tempfile.gettempdir(), 'pansy' + ext) CODE = """#include "Python.h" int main(void) {{ printf("%li %li\\n", sizeof ( (({0} *)0)-&gt;{1} ), (long) &amp;( (({0} *)0)-&gt;{1} ) ); }} """.format(struct, member).encode('ascii') MAKE = "gcc -xc -I{0} -o{1} -".format(get_python_inc(), EXE) gcc = subprocess.Popen(MAKE, shell=True, stdin=subprocess.PIPE) gcc.communicate(CODE) if not gcc.returncode: pansy = subprocess.Popen(EXE, stdout=subprocess.PIPE) size, offset = map(int, pansy.communicate()[0].split()) os.unlink(EXE) return {'struct': struct, 'member': member, 'offset':offset, 'size':size} def print_object(obj, members, pre=''): if pre: print(pre, end='') for member in members: print("{struct}::{member} -&gt; offset: {offset}, size: {size}".format( **pansy(obj, member))) py_bytes_members = [ "ob_base.ob_base.ob_refcnt", "ob_base.ob_base.ob_type", "ob_base.ob_size", "ob_shash", "ob_sval", ] print_object("PyBytesObject", py_bytes_members) py_unicode_members = [ "ob_base.ob_refcnt", "ob_base.ob_type", "length", "str", "hash", "state", ] print_object("PyUnicodeObject", py_unicode_members, '\n') print_object("PyLongObject", ["ob_digit"], '\n') print_object("PyFloatObject", ["ob_fval"]) 
I do prefer mercurial to git, but github is just amazing and more than make up for the problems with git (specially the cli interface).
It's the only sane way. Look at the mess it is in Ruby.
If you use a def for a function in some local scome, then that function can use all of the variables in the scope. In this case you can define it (taking no arguments, or some), then immediately call it. AFAIK this is the only way to do it.
The person making the builds has to pay for a license, but nothing says you have to charge for the binaries you distribute. Or at least, that's my understanding of it, anyway...
Addendum: there is an alternative, to use a class defined as class A(object): pass then you can use a = A() a.width = ... a.height = ... del a and just keep the 'holder' class A around for uses like this.
Hi, thanks for both answers!
Nice, but I think a light weight version for py.test could work better. Just use the docstrings of test suites/cases and print then with the konira reporter. That would get all the benefits I see in this without a dsl. (I should do this... plugins in py.test are a bit confusing but you can write one really fast after you learn the api)
A command line interface isn't really something that needs to be made up for.
I think you're probably being a little OCD, but why not create a width/height property for your my_rectangle class. EDIT: Unless your code above is a contrived example (which I just realised it probably is)
Cool. It seems we're delving into madness though. All these little intermediate binaries remind me of autotools configure scripts. Check out gcc's `-fdump-tree-gimple-slim` option. A command like: gcc -xc -S -I{0} -fdump-tree-gimple-slim -o{1} - Will produce a file called -.????.gimple containing: main () { size = 8; offset = 16; } **EDIT:** Whoops. Well, it'll produce that file if the source is like #include "Python.h" int main(void) { long int size = sizeof ( ((PyBytesObject *) 0)-&gt;ob_base.ob_size ); long int offset = (long) &amp;( ((PyBytesObject *) 0)-&gt;ob_base.ob_size ); } ...and you might as well do a whole \*_members list at a time.
This is spam shouldn't be in r/python
&gt; When you start using unittest you need to think about the test runner. This is an important piece of the puzzle since unittest does not provide a standard way of running your tests via auto-discovery or any other kind of niceties the most popular test runners provide. This is no longer true. The "Easier to use" documentation part should be updated.
Cross-site posting of homework questions is ridiculous, especially because you posted it only 13 minutes ago. Please don't do this.
I am sorry. I will remove this. But this is not a HW question. I am just a indepedent learner.
Yes you're right on both counts, I'm probably being a little OCD and the example was contrived, well maybe contrived is the wrong word; reduced would be better.
Coming from PHP, I found it easier to start working with Django and build a project, then to fill in the cracks as I went.
I apologize for calling it HW then, but in general, just asking people to answer your questions on other sites is frowned upon. Let people get a chance to answer the question on SO, then if you have specific questions from there, I think it'd be alright to bring something over here to discuss.
Very nice [logo](http://pycon.b0.upaiyun.com/images/PyConChina.png).
I think he is suggesting that git's command line interface is inferior to mercurial's (which is admittedly a subjective preference, but one I personally share) And as an extension of that, it makes git's command line interface "a problem that github makes up for".
Ah, go'cha. I've only tried git with GitHub, so it sounds like I should give Mercurial a try.
Sorry, I noticed my mistake and edited. I still prefer dictionary comprehensions, it makes more sense to me and is more 'pythonic'. And although I'm not sure I believe it is more likely to be optimized.
When Nicklaus Wirth came to the conclusion that Pascal needed radical upgrades he didn't call the result Pascal, he called it Modula. A language that creates radically different behavior between one version and another is a different language. There comes a time when a project must be considered mature. Like Linux, to give another example. Linux 3 is just a number of small adjustments. The new number is only a symbolic statement that Linux is entering its third decade. If it isn't broken don't fix it. &gt;(Not that they're forbidding you from staying on 2.7, either) Perhaps they should do what Donald Ervin Knuth did with TeX, whose version numbers approach pi asymptotically. Python would be just fine with version 2.718281828... But, alas, that's not how the real world works. Soon it will become harder and harder to find an updated system that supports Python 2.7. 
Wow, where to start. OH YES, the beginning. 1 &gt; Never bothered me. You may wish to try something more fully featured, like Eclipse. 1.1 &gt; Agreed. Home should move to after the "&gt;&gt;&gt; ". Home from there should move before it. 1.2 &gt; Ctrl+C is so hard. 2 &gt; Why is this a problem? 3 &gt; Don't be stupid. If you don't know Ctrl+C, you haven't started on the right tutorial. ^C is universal to pretty much any terminal I've used. If you want something more fully-featured than IDLE, use Eclipse. 4 &gt; Haven't opened a menu in forever. Hand time spend on the mouse is hand time spent not on the keyboard. Learn your hotkeys. 5 &gt; No. 6 &gt; No it doesn't. ^C will bring back the prompt, and you can pygame.display.quit() there. Alternatively, Ctrl+F6, but you lose the program state. 7 &gt; It becomes second nature after a while. Not particularly disruptive to work flow. Especially when you can Alt+Shift+S or Ctrl+Shift+S to resave. 8 &gt; Exactly what size screen are you on where 2 windows taking it up equals 158 lines? Conform to PEP 8. 9 &gt; Personal preference. I'd hate my shit randomly being highlighted as I move through the file. 10 &gt; No opinion. 11 &gt; For something that you only use once, it's not a problem. 12 &gt; Utterly unneeded, line numbers are shown at the bottom. This has even been discussed on bigger forums than this. The reason it's there in the shell is so you can understand tracebacks in "live" code. 13 &gt; Wrong. I use them all the time, and it's for multiline. TABs are awful, you should be using 4 spaces. You can remove tabs (and 4 spaces) with a single backspace. 14 &gt; No reason for this at all. 15 &gt; Completely frivolous. 16 &gt; My quick launch shortcuts have the version on them, and you can rename shortcuts in the start menu. Also, why are you programming on windows? You seem to think that IDLE is anything more than a garage/shanghai tool. Use it to edit small files, or write small projects. If you're getting serious about shit, use something like Eclipse. Alternatively, write your own. 30 minutes, and you'll reproduce all of IDLE's functionality with your own implementation.
What's wrong with numpy?
If wishes were fishes...
I admit I was exaggerating but I do think a lot of their popularity comes from people that like things that are popular and once the next sourceforge or github comes along they'll move onto that. github is nice (I have an account there though only for watching projects) and I'll admit I'm a bit biased because github does attract a lot of jerks and people who think they're rock star developers so that does put me off it a bit.
From the article: &gt; First off, my philosophy is that no serious Python programmer uses IDLE as their dev environment. With that assumption, we can get rid of any need to cater to them and make IDLE aimed at people who are not only new to Python but new to programming in general. **IDLE should be an education tool more than a development tool.** This means that the IDLE default options should all be set for the basic user, not the power user. And: &gt; I also understand why IDLE isnt at the top of the priority list: people code away with it for a while, and then move on to a bigger and better IDE. Its a disposable IDE (though I mean that in the nicest possible way).
Mercurial tends to be more Pythonic, imo - it's a bit simpler, things make more intuitive sense. Git shows its roots from being designed for Linux kernel devs - it has some odd ideas about what normal syntax is, but is *extremely* powerful (see gitfs).
Flavor of the last couple years, you mean?
I'm not sure which of my questions you are answering. I've introduced 3 separate friends to Python, 2 with prior programming knowledge, 1 without, and not one of them has had any troubles with anything on the list, save for #1.1.
&gt; The reason it's there in the shell is so you can understand tracebacks in "live" code. I thought of this, but the problem is when you get a traceback, the "line" that it gives you is something like "File "&lt;pyshell#11&gt;", line 1, in -toplevel-". That "pyshell#11" part refers to the 11th &gt;&gt;&gt; prompt that you typed something in. But the only way to get that is to manually count up the &gt;&gt;&gt;. The line/column info the lower right tells you the line number as though the interactive shell window were a text editor, which makes it useless on that window. We should get rid of it and free up that screen real estate.
It's more of a general response to all of them. A lot of your comments would apply if we wanted to make IDLE into an IDE for developers, which I don't think it should be (there are already plenty of good IDEs out there). The strong point of IDLE is that it comes with Python, which makes it a good choice if you're introducing non-technical people to programming without throwing Eclipse at them.
Heh. My dirty secret is that I probably will get around to doing these changes myself when I have time in a few months, but I posted it as a blog article to get feedback on them. :) But if anyone else wants to overhaul IDLE, these are a few good starting points.
&gt;It is interesting that you mention Fortran in this discussion as it is a language that more or less remained static. As a result it is dying, we don't want to see Python die. Healthy languages grow and evolve This shows how little you know Fortran. The last version of Fortran that was widely used, the "benchmark" language in science and engineering, was Fortran 77. Fortran versions 90, 95, 2003, and 2008 introduced many new features. Fortran kept "growing and evolving", actually it's evolving much faster than C. No one gives a single fuck. Ironically, there are probably more programs running today in Fortran 77 than in all other versions of Fortran that came after it. That's because there are many libraries written in Fortran that have been debugged, tested, and validated. If someone is going to the trouble to migrate those libraries to newer versions of Fortran they might as well migrate them to C. The users of Fortran are people like me, who work in engineering and not in programming. We couldn't care less about features if it doesn't solve a problem we have. &gt;Python 3 was an opportunity to fix a large number of issues in the older versions of Python They didn't fix the biggest issue that's more or less unanimous of everyone who tried Python and didn't like it: whitespace syntax. The first revision they should do is to prohibit either space or tab as a valid whitespace symbol. The problems with mixing tabs and spaces is the most frequent complaint I have seen against Python. Also, there should be an option for using some symbol other than whitespace as block code delimiter. Let's face it, the days of monospace monitors are long gone. It's very hard to publish a Python code snippet on a forum in the web, inevitably as someone copies it the whitespace formatting will be destroyed. Ironically, [Guido van Rossum](http://en.wikipedia.org/wiki/Guido_van_rossum) is the brother of [Just van Rossum](http://en.wikipedia.org/wiki/Just_van_Rossum), a typeface designer. If I were a psychologist I'd be wondering about sibling rivalry here... As it stands now, Python in version 3 took a radical leap away from its initially stated goal, to be an easy to learn language. Every single change in version 3 makes it more complicated to use. Some changes, like the replacement of os.system by popen.check_output, show that they didn't think things through but are unwilling to concede it. All in all, I think Python 3 will be much more likely to kill Python than to keep it alive. I, for one, have stopped recommending Python to anyone. All the engineers I know are very wary of Python 3. Only the CompSci guys like it. But the CompSci guys would rather use Lisp or Ruby anyhow. 
Nice job on the presentations, I'll definitely check this out. I'm using Cognos today for the front-end along with python on the backend. That seems to map well to the typical division of labor. Getting some of the python guys to think about OLAP has historically been difficult.
Ahh, yeah I guess I knew that. What about a version with oracle support built in being available for download? :) Or.. is it statically linked against the oracle library when built, like where it expects it to be in the exact same place on your system?
Ahh, yeah I guess I knew that. What about a version with oracle support built in being available for download? :) Or.. is it statically linked against the oracle library when built, like where it expects it to be in the exact same place on your system?
Ahh, yeah I guess I knew that. What about a version with oracle support built in being available for download? :) Or.. is it statically linked against the oracle library when built, like where it expects it to be in the exact same place on your system?
$10 says nothing will happen until you do the work. Unfortunately, no one works on IDLE. Ever. Here and there people speak up on the dev list about wanting to fix things and to get development started up, then nothing happens after that. I'm not sure if IDLE is hard to work with or not fun to work on, or whatever, but it has been a dead end for a while.
So it does, never noticed that before.
Integrated _Developer_ Environment. I'm still not sure what you're talking about; IDLE is fine for what it is, apart from #1.1, as I said.
[Leo](http://webpages.charter.net/edreamleo/front.html) - the learning curve is acceptable and it is written/extendable in Python itself.
Actually, people do things with IDLE. [IDLE X](http://idlex.sourceforge.net/) One example does not really contend against your point though. There isn't a whole lot of work on IDLE and obviously not many python developers consider it a serious tool. 
I helped teach a 101 Python course last year. The issue 1.1 drove me crazy, I hated it.
IDEs are not only for hand-holding, they usually speed things up as well. Anyway, I'm sure all this can be done by mixing and matching open source libraries. But, that doesn't mean enterprise products are "crap". You probably get a cohesive product (not different libraries in various stages of development), training, documentation, support and SLAs. There are still companies paying tens of thousands of dollars for MSSQL/Oracle, why do you think they are doing that when they can get MySQL/Postres for free?
What's the reason you guys picked Ant as the build tool? Seems like a strange choice for a Python project.
If anyone is interested in working on this stuff, a meta-issue was created on the CPython bug tracker. [http://bugs.python.org/issue13504](http://bugs.python.org/issue13504).
Serious question, does anyone actually use IDLE? Not trying to bash on it or anything, I've been programming Python for like 7 years and I've never seen any developer use it.
The way to have a clean namespace is to make your code modular. That is: * Don't do logic in the global namespace * Write many small functions rather than a few large functions (especially if you plan on unit testing) If you're truly concerned about declaring local variables, you could do something like this (which may or may not look better to you): area = ( abs(my_rectangle.left - my_rectangle.right) * #width abs(my_rectangle.top - my_rectangle.bottom) ) #height (Note: parens required or you'll get a ``SyntaxError``) 
The last person I introduced to Python specifically mentioned issue 7. If you haven't asked your three friends if they've experienced these issues, don't claim that they haven't.
I imagine most of the people who might be bothered by the limitations of IDLE have long since moved on to [ipython](http://ipython.org/) or [dreampie](http://dreampie.sourceforge.net/).
Fine, not one of them has *mentioned anything on the list, apart from 1.1.
EDIT: IdleX 0.5 has been released. [IdleX](http://idlex.sourceforge.net) fixes some of these problems. If you like to see these changes incorporated into IDLE, let the developers know. &gt;1) PROBLEM: In the shell window, if you click anywhere but on the current line and move the cursor there, the window stops handling key strokes. See http://bugs.python.org/issue2704 [IdleX](http://idlex.sourceforge.net) has this feature with the Terminal.py extension. &gt;1.1) SUB-PROBLEM: Pressing the Home key moves the cursor before the &gt;&gt;&gt; prompt, which then makes the keyboard unresponsive. This issue is actually fixed: http://bugs.python.org/issue3851 &gt;1.2) NEW FEATURE: Auto-Copy-On-Highlight X11 already does this by default. Although it is an interesting suggestion. &gt;2) PROBLEM: When debugging, the current line of code loses its highlighting when the window loses focus. I'm working on a better debugger. &gt; 3) PROBLEM: Theres no obvious way to stop a running program. (Dont expect them to know Ctrl-C) Ctrl-C is also "Copy" using a Windows key binding. Perhaps a "Stop Program" could be added to the "Shell" menu. &gt; 4) ANNOYANCE: Get rid of the detachable menus feature. Meh. That's an easy fix. &gt; 5) PROBLEM: Opening a file editor window or a shell window isnt clear. See http://bugs.python.org/issue7136 &gt; 6) PROBLEM: IDLE crashes when you quit a Pygame game without calling pygame.quit(). Hrm, I'll take a look at that. I don't use Pygame. &gt; 7) ANNOYANCE: Its too easy to forget the .py extension when saving a file. This is not a problem on Linux, but on Windows. See http://bugs.python.org/issue10364 EDIT: http://bugs.python.org/issue6804 http://bugs.python.org/issue6858 &gt; 8) NEW FEATURE: Get rid of the Windows &gt; Zoom Height feature. I'm not sure why this is a problem. Windows has a drag-and-maximize-to-half-screen feature, as does Compiz. &gt; 9) ANNOYANCE: Get rid of the Edit &gt; Show surrounding parens feature. Meh. &gt; 10) PROBLEM: The Debugger UI needs to be cleaned up. I'm working on it. &gt; 11) PROBLEM: The Configure IDLE UI needs to be cleaned up. I agree, but I rarely use it. &gt; 12) NEW FEATURE: Add an option to show line numbers along the left side of the editor window, and have it enabled by default. [IdleX](http://idlex.sourceforge.net) has this feature with the LineNumbers.py extension. &gt; 13) ANNOYANCE: The Indent Region and Dedent Region lines use the keyboard shortcut Ctrl-] and Ctrl-[, even though nobody uses that because you can indent the region by pressing tab. You can rebind the keys. See http://bugs.python.org/issue694339 &gt; 14) IMPROVEMENT: Get rid of the Format &gt; Strip trailing whitespace option from the menu Hey, I wrote that extension in response to http://bugs.python.org/issue5150 &gt; 15) MODERNIZATION: The Save dialog asks Do you want to save this untitled document before closing? and then presents you with Yes, No, and Cancel buttons. I agree. Tkinter default dialogs are not great, but okay. &gt; 16) ANNOYANCE: The Windows shortcuts for IDLE dont have the version in their name. Yes, see http://bugs.python.org/issue10747 EDIT: I do a lot of work with IDLE. EDIT2: I thank Al Sweigart for bringing attention to the need for more IDLE development. It's a good list.
Thank you.
You don't want to update `cl` and `sl` by adding to them each time, that's not going to make any sense. You want to simply compute new values each time. Instead of this: sl = lenrays*sin(angle) cl = lenrays*cos(angle) for i in range(1,numrays+1): .... sl = sl + lenrays*sin(angle) cl = cl + lenrays*cos(angle) You want something like: for i in range(1,numrays+1): sl = lenrays*sin(angle) cl = lenrays*cos(angle) .... 
I use it for research computing.
I am a beginner python enthusiast. Does anybody have a problem where IDLE doesn't quit a process even after you run exit()? That sucks, and makes me avoid IDLE. :{ I sometimes run and edit the same or different scripts multiple times, but even after exit()'ing them and quitting IDLE there are tuns of pythonw.exe's running.
What you are describing may be related to: http://bugs.python.org/issue8093 What version of Python are you using?
IDLE, why u no work with matplotlib?
Will have to give this a try. Ipython doesnt work on windows. 
Please don't implement the copy-on-select (or at least make it an option to enable); clobbering the clipboard is rarely a polite thing to do. The highlight copy/paste you've seen comes from the X11 world, where selected text goes into a *separate* paste buffer from the usual copy/paste. Without that distinction, it's exactly the sort of power-user thing that's different from most any other app (much like the detachable menus that you despise :)
Python 3.2 on Windows 7
As soon as I worked out that it had serious limitations, I dumped it and never went back. For quick tests the command line isn't too arduous. For proper programming I just used one of a variety of editors until I finally paid for PyCharm this year.
X11's select buffer is a bit different than the description makes it out to be. Selecting text uses a different buffer, which doesn't clobber the contents of the clipboard. A "paste" command will always use the clipboard, while a middle click will paste the select buffer (which will be the last thing selected, even if it's been deselected in the mean time).
When I started using Python, DreamPie didn't exist. IPython was nice, but I also needed a code editor. Vim's python plugins were lacking, and Eclipse crashed too often. So I hacked on IDLE and it works for me. 
Thank you for your reply. I finally figured out what to update in the loop. It still doesn't work with &lt;4 rays(which was actually the number I was using to test it with leading me to revise my code many times) but it does other positive integers. 
You're right. I know to use middle click, and it's a feature I miss when I use Windows.
Let me know if you have any problems with IdleX.
XP, Vista, 7? 
started checking this editor out because of your post, liking it so far and gunna get the portable version so I can use it while I'm managing my computer lab.
I sometimes do this in C++ with an extra pair of braces. It's rare that I wanted it, but sometimes it made sense. &gt; have I missed a nice existing way to do this already I don't know about nice, but... &gt;&gt;&gt; width = abs(my_rectangle.right - my_rectangle.right) &gt;&gt;&gt; height = abs(my_rectangle.top - my_rectangle.bottom) &gt;&gt;&gt; area = width * height &gt;&gt;&gt; del width &gt;&gt;&gt; del height &gt;&gt;&gt; print width Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; NameError: name 'width' is not defined
I edited the reply.
Hey, idle_guru, while I have you here :) So I have Idle X running on my desktop being ignored, but not doing anything for a couple of days. My machine starts slowing down and I check my memory and IdleX is eating like 1.6 G. I have restarted it and am going to watch to see if the behavior continues or it is was some kind of very odd fluke. Are there any known memory leaks or conditions that cause excessive memory use in IdleX? I was doing some nooding in it a few days before, but just playing about, nothing that should have eaten any significant memory at all and I didn't have any code still running in it.
IdleX with EventLoop.py works with Matplotlib.
Also [bpython](http://bpython-interpreter.org/) and [reinteract](http://fishsoup.net/software/reinteract/). We have a of great interactive shell options.
That's a very interesting bug. Can you tell me your platform and if you are using the latest version? EDIT: Bug is fixed in version 0.5
The machine in question was ubuntu 10.10 on a thinkpad x201 with 4g memory. I am running idlex 0.3 against python 2.6.6 complied with GCC 4.4.5. Happy to run any diagnostics you want and I am going leave idlex running for a couple of days again and see what happens with the memory. If the problem keeps up, I will msg you and get decent data to file a bug report.
Ok. Have you tried running IDLE from the command prompt? It may offer some diagnostic information. I'll assume you installed to the default locations. Open up "cmd" and type cd c:\Python32\Lib\idlelib start idle.py This will open up a console for any output IDLE may have. Try restarting the shell a few times and check your running processes. 
I appreciate your help. I'll see if I can reproduce the problem on my computer. I will contact you in a few days. EDIT: If you could, try it with version 0.4.
From the article: &gt; First off, my philosophy is that no serious Python programmer uses IDLE as their dev environment. With that assumption, we can get rid of any need to cater to them and make IDLE aimed at people who are not only new to Python but new to programming in general. **IDLE should be an education tool more than a development tool.**
True, but in my programming book (for complete beginners) I tell them to just use IDLE because it's simple enough and it reduces the amount of software they have to install before they get started with programming. That's IDLE's winning and redeeming quality.
I like your method of calculating the matches, then counting the pairs, that's very pythonic in my opinion (even if it might not end up being the most performant solution possible).
"I personally gave up on the site after this exercise and turned to better sites for practice." I can see that. What sites did you turn to?
So.. I've never used this IDLE thing... but after reading the article, I don't really want to.
 # with width = ... height = ... # let area = width * height or ... lots of local variables and other code ... def compute_area(): height = ... width = ... return width * height area = compute_area() 
I understand your sentiment. What editor do you use?
Emacs, mostly. When I run a python shell, it's usually in an external terminal window, or in an emacs buffer.
I've seen several Emacs users embed IPython and then highlight/execute code in that shell. Is that part of what your workflow? 
No, I don't use IPython, I only use the normal python shell -- not really that commonly, either, usually only when I have to try small expressions (to make sure I got something right) or when testing how a function behaves or something like that. I usually only run python in an emacs buffer when I need to copy/automatically process huge amounts of data spit out by python directly in emacs, as elisp makes that pretty convenient -- but even then, I mostly just use the shell and pipe/redirect to file.
Please use [r/learnpython](http://www.reddit.com/r/learnpython) for questions like this.
&gt; Actually, people do things with IDLE. [1] IDLE X Forking IDLE is less of what I was looking for, but yes, IDLE X apparently gets the action.
Do you have anything else in Emacs aside from Python mode to help with development? I try Emacs every once in a while to see if it has any cool new Python-specific features. &gt; usually only when I have to try small expressions (to make sure I got something right) or when testing how a function behaves or something like that. I suggest given SubCodes with [IdleX](http://idlex.sourceforge.net) a try and go through SubCodeTutorial.py. It may be useful to you because you can iteratively test segments of your code very quickly. 
Why not ipython?
I needed a good code editor.
 data = [] for i in xrange(50): data.append(numpy.loadtxt('data' + z + '.txt')) Get at the different arrays using `data[0]`, `data[1]`, etc. For something more compact/pythonic: data = [numpy.loadtxt("data{0}.txt".format(i)) for i in xrange(50)] 
Thank you so much! 
In response to my replies ... dreampie's best feature, IMHO, is that you can type a few characters then press ctrl-up to load any previous code that started with them. "Copy Code Only" is also invaluable. I don't know about the rest of you, but I tired pretty quickly of up-up-up-enter-up-up-enter-up-enter-enter-enter, just to make a tweak to some code. To me, that is well worth the download of a setup.exe for windows or an apt-get or equivalent on other platforms, even if it is an extra step for a student. bpython would be my choice where a gui is not an option.
To elaborate on mikm's response: The problem is that you're thinking in terms of creating an arbitrary number of variables, depending on the size of your data (50 in this case). Instead, you should have a single variable, named "data", that is itself a collection (specifically, a Python list) of these 50 arrays. You then index into "data" using the value of z, as opposed to trying to somehow form a variable name using z.
Absolutely reasonable. Glad that it works.
Use a dictionary. data = {} for i in xrange(1,51): data[i] = numpy.loadtxt('data' + i + '.txt') Now you can access each element like this... data1 = data[1] data2 = data[2] etc... You could use a dict comprehension to accomplish the same thing... I haven't tested this but, it should work: data = dict([(x, numpy.loadtxt('data' + i + '.txt')) for i in xrange(1,51)])
&gt; but I tired pretty quickly of up-up-up-enter-up-up-enter-up-enter-enter-enter, just to make a tweak to some code. Try IdleX with SubCodes. You can block off code in the editor with "##" comments and then press Ctrl+Enter to run a part of your code. See http://idlex.sourceforge.net/SubCodeTutorial.html
thanks. I was not having the best luck trying to search for "diamond carbon statistics python" Though now I do see that it's linked from http://graphite.readthedocs.org/en/latest/tools.html
I have this exact homework. Are you also having to do drawRotatingBoxes? 
Using flymake with pylint is popular; there's also pymacs, basically a foreign-function-interface between emacs-lisp and a child python interpreter - so you can extend emacs directly in python - not something that specifically helps for python development, but something that makes emacs more attractive for python developers...
Here's my list of bookmarks for Programming challenge sites. * [Sphere Online Judge](https://www.spoj.pl/) * [Code Kata](http://codekata.pragprog.com/) * [Facebook Engineering Puzzles](https://www.facebook.com/careers/puzzles.php) * [TopCoder](http://www.topcoder.com/) * [Programming Praxis](http://programmingpraxis.com/) * [Project Euler](http://projecteuler.net) * [The Python Challenge](http://www.pythonchallenge.com/) * [UVa Online Judge](http://uva.onlinejudge.org/) * [Singpath](http://www.singpath.com) * [Program This](http://programthis.net/) Take a look through them and see which ones you like. I like having a wide selection. 
I use it to teach python to my students. It greatly minimizes what I need to teach if they all use the IDE that comes with their download from python.org. Also, after that fiasco with a student thinking they need to get something from python.com when I tried to introduce other IDEs taught me that I shouldn't complicate things unnecessarily.
Is there a good chance your modification/program would get into the official python package? It would greatly help in teaching if the students would only need to download one installer to get started with Python.
Yes and no. Some extensions in IdleX are not appropriate for the standard distribution, such as CythonScript.py which provides Cython support. Others, such as Terminal.py, LineNumbers.py, and ClearWindow.py should be included. I already have RstripExtension.py included in the official package. We'll see what happens. 
I'll give the latest version of flymake a try in the upcoming days. Thank you for the info.
IPython DOES work in windows with python 2.x, 3.x in 32 and 64bits.
In the small: ipython uses readline for command line editing, so a minimal .inputrc will give you access to your vi-fu on the ipython command line: $ cat .inputrc set editing-mode vi set completion-ignore-case on Control-j: menu-complete Control-k: menu-complete-backward set completion-map-case on In the large: ipython uses vi(m) by default for the %ed(it) command. Run %ed and you open a vim (or your designated editor) session, write and exit that session and your vim-edited python code is executed. $ man ipython ... -editor &lt;name&gt; Which editor to use with the @edit command. By default, IPython will honor your EDITOR environment variable (if not set, vi is the Unix default and notepad the Windows one). Since this editor is invoked on the fly by IPython and is meant for editing small code snippets, you may want to use a small, lightweight editor here (in case your default EDITOR is something like Emacs). ... $ ipython Python 2.7.2+ (default, Oct 4 2011, 20:03:08) Type "copyright", "credits" or "license" for more information. IPython 0.10.2 -- An enhanced Interactive Python. ? -&gt; Introduction and overview of IPython's features. %quickref -&gt; Quick reference. &lt;-------------------------- Run that. help -&gt; Python's own help system. object? -&gt; Details about 'object'. ?object also works, ?? prints more. In [1]: %quic&lt;hit tab here, ipython uses readline for some command completion&gt; ... %ed: Alias to %edit. %edit: Bring up an editor and execute the resulting code. ... &lt;q&gt; In [2]: %ed for i in range(0,3): print i :wq IPython will make a temporary file named: /tmp/ipython_edit_jAjtGG.py Editing... done. Executing edited code... 0 1 2 Out[2]: 'for i in range(0, 3):\n print i\n' In [3]: %edit? ... Options: -n &lt;number&gt;: open the editor at a specified line number. By default, the IPython editor hook uses the unix syntax 'editor +N filename', but you can configure this by providing your own modified hook if your favorite editor supports line-number specifications with a different syntax. -p: this will call the editor with the same data as the previous time it was used, regardless of how long ago (in your current session) it was. ... &lt;q&gt; In [4]: %ed -p for i in range(0, 2): print i :wq IPython will make a temporary file named: /tmp/ipython_edit_AO72g1.py Editing... done. Executing edited code... 0 1 Out[4]: 'for i in range(0, 2):\n print i\n' 
Not sure if my other answer would help you. You can get in and out of vim easily from ipython. Then the question is whether the vim that you get to is still lacking for you. http://www.reddit.com/r/Python/comments/mtnbr/the_things_i_hate_about_idle_that_i_wish_someone/c33y8f9
I was talking just about THIS particular web development framework, not about every single commercial software product out there. If you need a SLA for a web framework, then you're evaluating the wrong framework and doing it wrong. edit: Are you working for them?
Why dict when a there are lists, and he has sequential indices?
Thoughts on PyCharm? Thinking of treating myself..
Progress meters are kinda cool. Here's a simple spinner: from itertools import cycle progress = cycle(['/','-','\\','|']) for item in your_long_iterable: print(next(progress), end='\r') do_something(item) The basic gist of a progress meter is to setup a generator that will return the current status in whatever format you want. If its going into a GUI, I recommend letting the generator be simple (i.e. return a value or something similarly tiny) and let the GUI widget draw that appropriately (e.g. update the progressbar widget with that value returned from the generator). In the example above, itertools.cycle() is my generator (though its not returning a useful value for a progressbar) In pseudocode you'd do this: def myprogress(p, max): yield p/max*100 n = len(all_my_data) p = 0 for thing in all_my_data: update_progressbar(val=myprogress(p,n)) dosomething(thing) p+=1 Hope this helps! 
This is just, let's say, a demo or practice code. It is yet an other demonstration of how can you use the multiprocessing module to speed certain things up. So it is not intended to be used in production. It was inspired by a [recent thread on matrix manipulation and python3](http://www.reddit.com/r/Python/comments/mpt2f/can_someone_tell_me_why_we_cant_add_matrix/) Anyway, there is nothing's wrong with numpy (except it won't install on an Intel 64 bit Windows box, which I happen to have at this moment at work, so I'll have to compile it, if I want to use it on that box). 
It's great. Beats all the free alternatives I tried (which doesn't include Eclipse/PyDev, incidentally), and seemed to offer more than the paid ones I looked at. Needs a fairly beefy computer to run well though, but then so does pretty much every IDE except Visual Studio these days. Oh, and it doesn't support PyPy yet.
What do you use for python programming?
I've seen a fair few vids on it, there was some really nice examples on this kind of 'Battle of the IDE's' a while back, can't remember the name.
You also calculate angle wrong, you need another variable e.g. angle_base: angle_base = 2*pi/numrays and inside the for loop angle should be updated: angle = angle_base * i What you currently do is multiply angle by 1,2,3,4... and you end up with values greater 1,2,6,24,... times than the original value of angle. 
I think I prefer dict comprehensions too, but I'm still stuck in a Python 2.5 mindset and so I just choose compatibility almost every time.
For 64 bit packages for python libraries try this page (I use the numpy/scipy builds on an intel i7) http://www.lfd.uci.edu/~gohlke/pythonlibs/ but maybe you're on itanium
I have tried several installs on different computers and could not get it to work. The window opens up and closes right away, or I get various error messages, etc.
Depends on how he'll be using them, if he'll be accessing them in a random order then dicts might have performance benefits, if sequentially then lists are the way to go. However, I doubt if he has only fifty arrays this will have a huge impact on his performance though.
To further mikm's idea, if the array in each data file is the same length then read them in to a numpy array. data = numpy.zeros(50, length_of_datafile_array) for i in xrange(50): data[i] = numpy.loadtxt('data' + i + '.txt') or perhaps: data = array([numpy.loadtxt("data{0}.txt".format(i)) for i in xrange(50)]) although this means creating an intermediate list, before converting to an array.
Thanks! I already have this page bookmarked, although I was a bit confused whether the binaries marked as "win-amd64" will run on my processor architecture which is http://ark.intel.com/products/33911/Intel-Core2-Duo-Processor-E8500-(6M-Cache-3_16-GHz-1333-MHz-FSB) Your response suggests that this "win-amd64" label only indicates that it won't run on Intel Itanium but runs on any other 64 bit Intel CPU?
Yes they do, this is to do with the history of the 64bit architecture or something. If they were for itanium amd64 would be replaced with ia64.
Do you know of any sites with IDLE themes? I found one for "desert" but that is about it.
I use it as well. It is very good. Also, they are continuing to make it better and respond to bugs and questions.
[There's a PEP a bit like that](http://www.python.org/dev/peps/pep-3150/ "PEP 3150"), proposing this syntax: sorted_data = sorted(data, key=sort_key) given: def sort_key(item): return item.attr1, item.attr2 Yours reads in the order the code is executed, which I think I prefer, and puts the keyword at the beginning of a line, which is more readable as well. The "given" proposal doesn't need paired keywords, on the other hand, but there's precedent for that (with/let could be similar to if/then/else). 
So, if IDLEX fixes a lot of these things...does it get merged into the main as "the" IDLE at some point?
Aah, fair enough, I can get behind that. Thought it was reinventing the wheel or something.
Thanks, just installed [win-amd64-py2.7](http://www.lfd.uci.edu/~gohlke/pythonlibs/xmryrnqy/numpy-MKL-1.6.1.win-amd64-py2.7.exe) and works fine
&gt; In the large: ipython uses vi(m) by default for the %ed(it) command. Run %ed and you open a vim (or your designated editor) session, write and exit that session and your vim-edited python code is executed. I tried a similar recipe a few years ago with IPython. Vim didn't have good python editing at the time and it was tedious switching between Vim and IPython for doing minor tweaks to code. IPython is an excellent shell, but I wanted an integrated editor. I've considered writing an extension to allow IDLE to use IPython as its shell, but I haven't found any compelling, must-have features of IPython that warrant the effort. (If you can name a few, please do. I'm open to learning about it.) 
I just answered your other post.
I don't know of sites with IDLE themes. It wouldn't be hard to write a couple and then consolidate them somewhere and I'd be willing to host any on the IdleX site. EDIT: No [Hot Dog Themes](http://www.codinghorror.com/blog/2005/07/a-tribute-to-the-windows-31-hot-dog-stand-color-scheme.html)
It was release only a few weeks ago. The IDLE developers are aware of it: http://mail.python.org/pipermail//idle-dev/2011-November/003090.html
What do you mean by "only on port 8000"?
"Krondo" is apparently [this](http://krondo.com/?page_id=1327) in case you were wondering.
I guess calling %ed from within ipython doesn't bother me, and doesn't really feel like "switching between." But I only use a repl for experimentation; for full on development I just use a text editor. Compelling features? No. The only compelling thing about ipython is the same as the python shell or a usable IDE over edit-write-print-run without an IDE or repl. If you prefer an IDE with a live editor in the window, then ipython's only compelling feature is that it's a (much) better repl than python. I think IDEs and repls solve different problems, IDEs for development and repls for experimentation, even though each can do the other's job. Anyway, my original reply was to point out that, *if* you're using ipython you have access to any nice editor that you want to specify. Although now that I know about IdleX I'll definitely give it a try.
Have you used PyScripter? I use that daily and I have very little qualms with it, the developer(s) response within hours, minutes sometimes to bug tickets.
It's listening on port 8000, so when something connects, the port's in use, and no-one else can connect, right...?
Lists will be better in terms of performance either way, or why do you think that random access would make a dict faster than a list? Lists have constant lookup time after all, with no hidden hashing calculation going on either. I agree that with 50 elements, performance is not an issue. It is almost a matter of principle to use lists when this is a classic use case - an array.
You need to learn about sockets and TCP first.
No, that's not how socket programming typically works. I'm not familiar with Twisted, but from the code it looks like there is a new Echo instance (instantiated by the factory object) for each incoming connection.
So... It listens on 8000, then tells whatever connects to it to go to a different port?
Thank you. If you will have any questions, comments, suggestions, let me know. I'm trying to create an open-source light-weight OLAP framework and server that would be easy to use (not quite there yet, it is the goal) and easy to set-up without need of "big" database systems and tools. What do you mean with "Getting some of the python guys to think about OLAP has historically been difficult"? Not too many frameworks or what is the issue with current OLAP in Python? 
Vim usually.
PyPy is supported in PyCharm 2.0 beta: http://www.jetbrains.com/pycharm/nextversion/index.html
Thanks, yes, that 'given' is very like Haskell's 'where' syntax which I really like. However I think that the out of order 'where' syntax works well for Haskell as it is a lazy language, but I thought for python it would make more sense to be in order of execution as you say.
If you want to describe your problems more precisely on the [IPython user mailing list](http://mail.scipy.org/mailman/listinfo/ipython-user), we can try to improve matters. It is definitely working on Windows for plenty of users. Probably the easiest way to get IPython on Windows is to download a distribution like [EPD Free](http://enthought.com/products/epd_free.php) or [Python(x,y)](http://code.google.com/p/pythonxy/).
Thanks, will try those out.
Using vim and IPython together: Paul Ivanov has written an integration layer called [vim-ipython](https://github.com/ivanov/vim-ipython). I'm not a vim user myself, but I know it's been well received. Compelling features of IPython: I might be biased, as a contributor, but... * I particularly like the ability to get information about something just by typing "foo?" (and source code with "foo??"). * Input and output history, with the input history stored between sessions. Lines from the history can also be saved to a file. * You can run a file with "%run spam.py", and debug an exception after it's happened with "%debug". * Easy access to shell commands, e.g. "!wget $url" or "files = !ls". It's probably not a great tool to teach Python with, because it adds all sorts of extras to Python syntax. But for power users, it's got a lot going for it.
Both the server and the client have a TCP/IP port number. The server's port number in this example is 8000. The client's port number is a unique number negotiated when it makes a connection. That negotiation is often referred to as the TCP three-way handshake. This allows the service to continue listening on port 8000 while correctly servicing multiple client connections. There's a bit more to it than that, which you can look up if you're interested, but rest assured that TCP/IP handles multiple connections.
When a program listens on a port, many connections can be made to it simultaneously. The reason you need a ServerFactory object in that code example is to create new Echo instances whenever a connection comes in. Twisted will accept the connection, tell your factory it needs a protocol object to associate with it, and the factory then (in this case) creates an Echo object for that specific connection. You can repeat this process as often as you like (subject to your OS's limitations). 
Sorry, I was talking out of my arse. I had some notion that lists were linked lists, and you would have to walk through the list until you found the right index. Maybe, I should look at python's list implementation in more depth. Just to prove you right I'll link this page, giving the complexity of manipulating python's data types http://wiki.python.org/moin/TimeComplexity
It's a bit hard to explain a concept without knowing what you are already familiar with. TCP is the networking layer that allows many clients to connect to this daemon. TCP "listens" to port 8000 because its header need to contain information about source and destination port. Contrary to what you are thinking, when client A is connecting to this daemon, it doesn't block the daemon completely. Why? Because TCP sends data in chunk. And that's why it can respond to many connections at once. Hope that helps. 
TL; DR PyPy 1.7 &gt; PyPy 1.6 &gt; CPython 2.7 &gt; CPython 2.6 on this benchmark. PyPy 1.7 is a bit more than twice as fast as CPython 2.7. Also, the thread mentions ctypes bindings for PostgreSQL and MySQL that work in PyPy.
collections.deque is the linked list in Python
This vim-ipython looks interesting. I'll take a look at it. &gt; I might be biased, as a contributor, but... Thank you for contributing to IPython. It's a great project and I know a lot of people using it. &gt; I particularly like the ability to get information about something just by typing "foo?" (and source code with "foo??") I do miss having that feature, but "help(foo)" isn't that bad either. I didn't know about "foo??" - that's interesting. &gt; Input and output history, with the input history stored between sessions. Lines from the history can also be saved to a file. IdleX with SubCodes is a work-around for this. The editor acts as your history buffer. I've seen requests for a persistent history extension in the idle-dev archives. &gt; You can run a file with "%run spam.py", and debug an exception after it's happened with "%debug". I wish IDLE had a better debugger, like IPython. &gt; Easy access to shell commands, e.g. "!wget $url" or "files = !ls". I didn't know you can assign the output of a shell command that easily. 
Thanks! I'll take a look at this. I didn't know about this project.
[reddit_api](https://github.com/mellort/reddit_api)
&gt; Do you have anything else in Emacs aside from Python mode to help with development? No, I like to keep it minimal. I don't really need autocompletion, syntax-checking and all that jazz, it usually only inhibits or annoys me. There are probably huge plugins that can be added to emacs to get a lot of integration with python libraries etc, but I haven't really looked at them/searched for them, so I don't really know. Iteratively testing segments of code is pretty much what I use the shell for. I can see IdleX improving that part, but if it requires me to have another full-blown IDE running, that wouldn't really be my cup of tea. Preferably it'd be something I could just run in an emacs shell buffer or so.
Seems like the 'multiprocessing' library would be a good first place to start. But from the outside, it seems odd that you're using dictionaries as your data structure for a variable named 'queue' (a dictionary may be good for lots of things, but queuing isn't generally considered to be one of them).
That's a good package, I wrote my own little function mostly as a learning experience.
A server may create several concurrently established TCP sockets with the same local port number and local IP address, each mapped to its own server-child process, serving its own client process. They are treated as different sockets by the operating system, since the remote socket address (the client IP address and/or port number) are different; i.e. since they have different socket pair tuples (see below). --- http://en.wikipedia.org/wiki/Internet_socket
thanks, I will look into that. The reason I use dict is becasue the data is related: hyperlink and description. One hyperlink has one description. Is there a better way than to use dict in this situation?
It's listening on port 8000. Clients A, B and C *all* connect on 8000, and stay on 8000 -- you don't lock a port when a client connects. Webservers run on port 80. I'm not calling your phone asking whether you'll *please get off google.com -- I want to search!*.
Ok, thanks for everyone's help, I think I'm closer to understanding now.
You need to learn how tcp sockets and servers work. Read up on that first. A webserver listening on port 80 is able to handle multiple client browsers connecting quasi-simultaneously. Likewise the server you are creating can handle multiple clients connecting simultaneously. 
Ok, now I am blind because of that theme. lol
Yeah I didn't finish that one though. Do you go to University of Texas?
To be pedantic, the client port number is not negotiated during the three-way handshake. It is established before that point -- when the client calls `socket()` to create a socket, it either specifies the port number or tells the system to pick one from the ephemeral range. This all happens before the client calls `connect()`. Both client and server port numbers are of course used during the handshake.
This will do what you actually asked for, although the others are right that you probably want one list instead of 50 variables: for i in range(50): locals()['data'+`i`] = numpy.loadtxt("data%d.txt" % i) 
pygame's joystick module? I don't know how you have your wiimote connected specifically, but I believe there are drivers for them that operate them as a joystick (for emulators, etc) so you should be able to set it up that way I would imagine.
So I should go add these to all my projects?
[GlovePIE](http://glovepie.org/) is what you're looking for. It allows you to map the inputs from your wiimote (connected via bluetooth) to pretty much anything you like. I never really played around with the accelerometer output, but it's there as well.
This + GlovePIE + PPJoy would work. There is probably a better (and cross-platform) method though.
GlovePIE's creator is all kinds of crazy, so I highly recommend using an [alternative](http://alternativeto.net/software/glovepie/) if possible.
by the way, it's easier and idiomatic to use json.loads(str) import json data = json.loads(json_string) You can also use urlopen like a file handler: import urllib import json data = json.load(urllib.urlopen(url)) 
The insensitive clod! I use Ctrl-] and Ctrl-[ extensively!
Be nice.
+1 to glovepie, it's an excellent program. Don't bother with the automatic script generator, the "language" is super easy. I wish there was a good alternative to this program that worked under linux, however.
He is?
He uses emacs instead of vim! 
Anyone know how to do the opposite? Control a wii from python?
Yes I do, are you taking CS 303E?
Guess you've never been a Slashdotter...
There's a fair amount of work that's been done on reverse engineering the Wiimote protocol, which communicates over bluetooth; you could probably use pybluez and a BT adapter to imitate a Wiimote pretty easily.
Check out his website. =/
In my experience, the typical programmer isn't interested in reporting applications, or thinking about how to slice &amp; dice data via cube navigation. It's just not a problem space that historically has gotten much attention in programmer circles (at least since the COBOL days). Hell, the entire java community seemed to deny that reporting existed at all until a java-implemented reporting tool appeared (jasper-reports). In all fairness though, my favorite programmers are fascinated with what they can do with data and thoroughly enjoy this kind of thing. Plus, all the talk about data science has helped to also illuminate how cool some of this stuff can be. 
Anything in particular? At first I thought it was the links on the bottom but: Scientology: The link seems to be anti-scientology Falun Gong: The link seems to be down so I'm not sure what it's about. I'm also uneducated on the matter so I'm not really sure what the whole issue with them and the chinese government was/is. Homeopathy: The link is anti-homeopathy. Those don't seem too crazy and the blog posts don't differ from the general conduct of reddit (regarding israel and regarding draw mohammed day). Anything I am missing?
I haven't checked in a while, but he had some stuff about soldiers *anywhere* or anyone in a military base not being allowed to use his software. Anyway, it's not any of those views specifically (I'm all for calling out Homeopathy, Scientology, etc.), but the manner in which he expresses them, and politicizing software to such an extent, especially software based on multiple open source libraries. Don't you think something is a little off there?
I hate you 
Works great! I got idle to finally work with matplotlib. Good work on this package!
Thanks for the suggestions. It has helped a lot. For this particular case it would be more helpful to see a X of Y completed rather than a true progress meter. so it would display 1 of 450 2 of 450 3 of 450 and so on. I have been working it out and I am starting to make some progress. I'm not a python guy so I am fumbling through it slowly. 
I did a presentation at OSOCON a few years ago on using Wiimotes to do odd things. Here's all my code: http://blog.insightvr.com/uncategorized/source-code-for-oscon-wiimote-demos/ I was on a Mac and used/modified a python wrapper for Darwiiremote.
Ill just leave this [here](http://wiigait.blogspot.com/)
`input(wiimote=True)`
New rule for r/python: release announcements for obscurely-named packages must include sufficient text or keywords to help me avoid clicking on them if I'm not interested. Exceptionally well-known packages are exceptions: numpy, PIL, Django and one or two others.
Why would I want to use this over sqlalchemy-migrate?
You on Linux? I've had a lot of luck with cwiid/wminput (available now at a packaging system near you!). I've got an example for producing a keypress off of a "shake" here: https://github.com/nemec/nemec_wminput_plugins/blob/master/shake.py
You might want to mention the Python version you are using in there. `range` returns a generator in Python 3.X versions. Also worth mentioning would be that in case the list you are generating is transient (i.e. not the end result), the users would be better off dealing with generators than creating the lists in memory, especially for large lists.
&gt;Also note that using nested list comprehensions returns a list of tuples. It returned a list of tuples because the item is the tuple `(x, y)`. Nesting the `for` clauses isn't a nested comprehension. A nested list comprehension returns a nested list: &gt;&gt;&gt; [[j for j in range(3)] for i in range(4)] [[0, 1, 2], [0, 1, 2], [0, 1, 2], [0, 1, 2]] 
In sqlalchemy-migrate, the semi-automatic migration tools are flagged as experimental, and they have been for a long time, while they are a design goal for Alembic. Also, Alembic is made by the main maintainer of sqlalchemy.
Dear GOD!
You should post that here: https://github.com/fabric/fabric/issues
So Python can get a Google+ account, but obtu can't? ETA: so can [Stack Exchange](https://plus.google.com/101120115153580954446/posts), created two days after.
To expand, the OS ensures TCP sockets are unique for the (source ip, source port, dest ip, dest port) tuple. The client can create other connections to the same destination port simply by connecting from a new source port.
Interesting looping for the lists. 
if you set up rndc, you can control bind from a non-privileged account (start, stop, restart, reconfig, reload, etc.)
map(lambda x:str(x), my_list) can be written as map(str, my_list). I tend to stick with list comprehension for most cases unless I'm just mapping an existing function. 
When did obtu try?
Sort of. The act of connecting creates a new socket on the server, and that is what the other side becomes connected to. But a port is not an actual 'thing', just a number. What distinguishes a TCP connection is the combination of both IP addresses and both ports. So you can have loads of TCP connections to the same local port, as long as their remote addresses are different (eg. different computers connecting), or their remote ports are different (eg. multiple connections from the same computer).
A while ago, currently I have an account stuck in read-only mode. I tried to get it unlocked when I heard about [this](http://mashable.com/2011/10/19/google-to-support-pseudonyms/) ([counterpoint](http://www.jwz.org/blog/2011/10/eff-declares-premature-victory-in-nymwars/)), but that's the last I had heard on the topic.
GEMA sucks ...
Unless you need to have them all in memory at once, you can loop thru the csv file line by line: for row in csv.reader(open('file.csv')): print row If this is not possible, yes, "reblanking" the lists would cause the original list to be dereferenced, which would allow python to free up the used memory.
If you no longer need the container, you can use: del N Or if it's defined inside a function, it will automatically be freed when the function completes. The rule is that, once your code is unable to access the list (or any data structure), Python will clear it up. The technical details of how this works depend on the implementation. CPython does reference counting, so as soon as the last reference is gone, it can release the memory. Other implementations have garbage collectors, so they might hold onto it for a bit longer.
Having you considered using [generators](http://docs.python.org/tutorial/classes.html#generators) to process the data? For large problems they can use much less memory than using lists to store results. However, not knowing what you need to do with your data, some problems won't fit well with using generators. Here's a good [introduction to generators](http://www.dabeaz.com/generators/Generators.pdf) (PDF) by Dave Beazley, who has some [more links and examples on his site](http://www.dabeaz.com/generators/).
Lists, much like other object in python, are managed by reference counts. When a list is created, a reference is made. If nothing else is pointing to that list, the reference count is decremented and when it hits 0, python automatically cleans it up. Consider the following: list1 = [1, 2, 3] print id(list1) # say this is 1 list1.append(4) print id(list1) # this should still be the same ID# list1 = [2, 3, 4] print id(list1) # this ID should now be different. Now that nothing points to the first list created, it is cleaned up. This applies to references from functions that return lists as well. There's a caveat to this, however. Some people will recommend re-populating a list using the slice method to save on memory: list1 = [1, 2, 3] print id(list1) list1[:] = [2, 3, 4] print id(list1) # still the same ID I'm not 100% sure on this but if your original list has a million entries and you re-populate with only 3 items using this method, I believe the amount of actual memory this takes up is still for a million entries.
What's pil? 
Hi there, If you're running CPython, allowing the last reference of the list to go out of scope (e.g. returning from a function where the list was made) should be enough. "del lst" is a slightly more explicit version of that. Note however that if your list has references held elsewhere, neither of these approaches will work. If you still want to explicitly clear the list in this case, assign an empty list to its full slice, e.g. "lst[:] = []". This guarantees the backing memory for the list will be deallocated immediately (at least in CPython, no idea how that works in e.g. PyPy). Finally, if you are working with lists of integers, consider array.array() instead of a list, as they are far faster and memory efficient. I believe for fixed length strings, NumPy also has an array type that is more memory efficient than a regular Python list.
The most important thing is to e sure that there are no references to the list hanging around in objects or global variables. If there are none, then you can get rid of your last reference in one of many ways: del N N=None N="anything" N=[] It's important to understand that all of these are rebinding the variable except for the one deleting the variable. NONE of these are changing the list you have. All are replacing a reference to it with something else. If other references exist to the original list then it will still exist in memory. To delete the contents of an existing list, you would do this: del N[:] I think that would get your memory back but I am only 80% sure. I'm not in front of a computer to test.
Regarding your last point, Cpython will shrink the array used by a list when the new size is less than half of the currently allocated size. See [list_resize](http://hg.python.org/cpython/file/8527427914a2/Objects/listobject.c#l24) in listobject.c. You may not see the result in your OS process stats until after you run `gc.collect()`, and maybe not even then depending on your C runtime. But at least the freed memory is available to Python.
Doesn't look like it. Under Python 2.6.2: &gt;&gt;&gt; a=range(1000000) &gt;&gt;&gt; a.__sizeof__() 4000020 &gt;&gt;&gt; a[:]=[1,2,3] &gt;&gt;&gt; a.__sizeof__() 44 Judging from some further experiments, CPython seems to use some variant of amortized reallocation, but behaves correctly after changes like the one you pointed out.
One thing to keep in mind is that "freeing up memory" by getting rid of unused data structures won't necessarily return the memory to the operating system immediately, or possibly ever, unless you do a manual garbage collection call. Memory usage will grow and grow over time (or at least plateau) unless you call GC. That's been my experience with Python 2.6.5 and earlier versions. Open a python process and watch it in Task Manager or the Linux equivalent. Create a large list or data structure and watch the memory usage of the process go up. Now get rid of the data (del item, or let it go out of scope, etc.) Notice the processes memory usage will usually stay the same. Now call gc.collect() and you'll see your memory usage go down. Keep in mind, calling gc.collect() has a CPU time cost proportional to the size of the memory pool. So your program can run gc.collect() periodically to keep memory usage under control. Unfortunately Python is kind of weak when it comes to memory profiling / analysis so sometimes it's hard to figure out where memory is being consumed in a large complex program.
is there something in python that allows you to look through all the references by size? in case you didn't properly remove all the references to the object or something like that?
Here's a demonstration of the reallocation using ctypes to peek inside a list object: import ctypes class PyVarObject(ctypes.Structure): _fields_ = [ ('ob_refcnt', ctypes.c_ssize_t), ('ob_type', ctypes.c_void_p), ('ob_size', ctypes.c_ssize_t), ] class ListObject(ctypes.Structure): _fields_ = [ ('var_head', PyVarObject), ('ob_item', ctypes.POINTER(ctypes.py_object)), ('allocated', ctypes.c_ssize_t), ] We'll use a list with a million entries. Then shrink it down to 500,000 entries, and then down to 499,999: &gt;&gt;&gt; x = range(10**6) &gt;&gt;&gt; xc = ListObject.from_address(id(x)) &gt;&gt;&gt; xc.var_head.ob_size 1000000 &gt;&gt;&gt; xc.allocated 1000000 &gt;&gt;&gt; del x[5 * 10**5:] &gt;&gt;&gt; xc.var_head.ob_size 500000 &gt;&gt;&gt; xc.allocated 1000000 &gt;&gt;&gt; del x[-1] &gt;&gt;&gt; xc.var_head.ob_size 499999 &gt;&gt;&gt; xc.allocated 562504 Edit: Here's the rule in CPython: &gt;&gt;&gt; newalloc = lambda n: n + (n &gt;&gt; 3) + (3 if n &lt; 9 else 6) &gt;&gt;&gt; newalloc(499999) 562504 
This syntax is so awkward that I try to avoid it, but dang it's convenient.
Python imaging library
Have you looked at numpy/scipy? If you're doing mathematical operations on large amounts of data, it will be a lot faster and use less memory because it's based on C code and native binary data structures.
Wouldn't it be a lot simpler to use Pyinotify?
Yup, but it seems that recipe is made for windows primarily.
Question: what would be an advantage, if any, of using map over comprehension if you are using already existing functions?
I think without the lambda, map seems shorter and easier to read. I think it's also faster: http://stackoverflow.com/questions/1247486/python-list-comprehension-vs-map
Hrm, the name for this will make it hard to adopt by all the major animation and vfx houses since they already have an Alembic: http://code.google.com/p/alembic/
I take your point :) New list: numpy and django.
I agree and this is the first release of Alembic ever so I don't think anyone knows what it's.
Measuring when process memory is released to the OS is almost always going to be misleading, for two reasons: 1. OS memory allocation and deallocation are crude and operate at the level of pages, not individual bytes. As a result, because of fragmentation, most libraries (libc) tend not to bother figuring out how to release memory back to the OS. So your application may be using a very small working set, but the OS will still show 100 MB usage. 2. Releasing memory back to the OS doesn't matter (outside the embedded context) because OSes can reclaim memory from processes by swapping them out. So processes don't have much incentive to release the memory. I would recommend not putting too much stock on OS-level memory usage measurements -- at least, not if you are expecting to see deallocations. If a process is going rampant on memory then you will see that in Task Manager, but shrinking is much less reliable.
If you have several million data points and doing math on them I strongly advise you use numpy arrays instead of built in lists. Your memory usage will likely be reduced and your program will almost certainly be faster. 
Haha yeah Chen's 3-4 class
I will have to try. I am dealing with string variables as well. I have to first organize information from three databases, piece them together, and then analysis. 
If you don't need to access all the information at once, there are a lot of reasons to prefer handling this data sequentially rather than in one giant list. If you're doing statistical methods, like t-tests, it's quite easy to write a wrapper that sequentially computes the necessary information rather than manipulating a very large vector of numeric data.
Hey, if the list is really large and you don't mind loosing a bit of performance, try to use secondary sorage (HD). You can try sqlite ;). Works well for me.
Same here :) I'm in the Friday 3-4 discussion how about you?
It's not a normal account with a pseudonym, but a business/brand page, and they were opened a few weeks ago.
I don't see them on the Python cheeseshop and it's not even clear this is a python module with the name lowercase "alembic", so AFAICT I have the name "alembic" within the Python ecosystem. Software projects with duplicate names is not a new thing (look for projects named "storm" for an example).
Neat, didn't know about the common maintainer. Also, the repo has a decent readme on it that I wish I'd read before I asked. https://bitbucket.org/zzzeek/alembic
PyPy 1.6 had some memory leakage issues with Tornado, but they are all sorted in PyPy 1.7.
It's so awesome to see that PyPy is actually getting to a state where it's very usable.
I think if you want help you need to tell us a bit more about the data and your problem. 1. Do you need the full data set loaded into memory before running the analysis? Can the analysis be done row by row? 2. If you want to remove something from memory, a better option is to use the [del()](http://docs.python.org/tutorial/datastructures.html#the-del-statement) function. 3. [Numpy](http://numpy.scipy.org/) and [Scipy](http://www.scipy.org/) are often used in the python community for heavy data loads. 4. If you need a graphical output, [matplotlib](http://matplotlib.sourceforge.net/) can do most of what you'd need. 5. Sometimes people load the values into a database (like [SQLite](http://sqlite.org/) which comes [with python](http://docs.python.org/library/sqlite3.html)) and then run SQL commands to process the data. [SQLAlchemy](http://www.sqlalchemy.org/) provides a nice pythonic interface to do something more like this and [Elixir](http://elixir.ematia.de/trac/wiki) makes it relatively simple to build tables. 6. If you intend to use a presentation, then many people will choose to create a [web server](https://www.djangoproject.com/) and run [some interactive javascripts](http://media.liquidx.net/js/plotkit-tests/) to create images. 
Is csv.reader a generator, then?
You're right. I had a bit of trouble with the wording on that part. I've updated my post and added a better example of nested comprehensions. Thanks.
Thanks, not sure why I put that lambda there, leaving it out is much more readable. I've updated my example. 
Err. Doesn't that rather suck for long-lived processes such as web apps? Especially on shared hosting where RAM is the most constrained resource. Is there any reliable way to give memory back to the OS?
Good points. I've changed the example to declare the list explicitly and eliminate the `range` call. I'd like to do a separate intro. to generators and wanted to keep the list comprehension intro. as simple as I could.
AMD introduced 64 bit x86 processors before Intel since Intel was pushing Itanium. They're completely equivalent for installation purposes these days but the name has stuck. If you actually want to speed up matrix ops, look into your BLAS libraries that numpy uses. Intel MKL is one of the fastest, and Gotoblas, IIRC. You can also get GPU ops through a few different packages.
Back when Python was purely reference-counted you could lose memory by having cyclic references. I made a tool for finding those, and Tim Peters then made a much better one, called [Cyclops](http://www.koders.com/python/fid3F2344BF19377BE08C9C8AC25847F24CCC030510.aspx). You could probably adapt bits of that code (for crawling references) to do what you want.
Could also build it on top of [watcher](http://pypi.python.org/pypi/watcher). I think I have a `tail -f` implementation somewhere that I should check in to it.
I bookmarked this a long time ago but have never tried it. http://www.aminus.net/wiki/Dowser 
thanks Ill check it out.
A different point of view. 1. Buy more RAM! RAM is incredibly cheap right now and thus is the lowest cost way to solve a memory issue. That assuming you are not exceeding Pythons ability to manage memory. 2. Try C++ or another compiled language that gives you more control. You may be able to structure your data in memory much more efficiently and speed things up a bit. 3. You said the data is in CSV files, if so import into a spread sheet program and let it do the calculations. These are all alternatives to what have been mentioned so far. Depending upon your computations the spread sheet might be a non starter. As to a low memory machine there is no reason for such a beast to exist these days. 
Thanks for that. I'm new to python so every clarification helps!
Hardware solutions are possible too. Memory is very cheap, and often useful for a variety of other purposes. Not that I haven't squeezed stuff in my early days of machines with memories of 2K and 20K BIT, but these days it generally isn't worth while unless you are doing something really strange, which given your description might be.
It is an iterator of some kind, which is what's important (for saving memory, not reading the whole file in at once). Generators are just a special kind of iterator (created either using a yield statement or a generator expression). For the curious: An iterator is any object that repeatedly returns results a result when you call `next()` on it (which the `for ... in ...` expression does implicitly), and raises StopIteration when it runs out of things to return (which `for ... in ...` catches implicitly and stops looping). Iterators also have an `__iter__()` method that returns self, which is part of what defines an iterator. Objects can also have `__iter__()` return a separate iterator object, which is used if you try to iterate over it. A generator is any function that yields results instead of returning them. It's basically syntactic sugar for creating iterators without having to declare a whole class. The generator object conforms to the iterator protocol (as above).
Is is only an issue if your memory usage is highly variable, such as if you were to use the webapp to process a large chunk of data, and there may be multiple simultaneous requests for different sets of data working at the same time, but generally speaking, no. If you are going to work on any sort of large data sets, you should do it out-of-process by invoking another program to do the work and signal when it is done. Keep the long-lived webapp streamlined and avoid large memory allocations. You should never run into any issues doing it that way, and if you do run into any issues due to the out-of-process workers sucking up all the memory, at least it will be transient and once they crash your webapp should still be fine.
No I haven't. I like PyCharm because it runs in multiple environments and I also use IntelliJ IDEA so it is nice to know both but use one "ecosystem".
Try `pty=False` in the `sudo` call. https://github.com/fabric/fabric/issues/320
I like the concept, but it doesn't seem to ship with any unit tests or documentation and it's not properly internationalized.
What about an iterator makes it important for saving memory? If I do: a = [1, 2, 3, 4, 5, 6 , 7] b = iter(a) b isn't saving memory (except through not having to copy the list, though I don't believe a regular `for` loop over the list would so that either). Now, if `a` is a generator instead, memory *is* saved.
Generators are a shortcut for making an iterator that saves memory by making the content as it's consumed. Saying that generators save memory and iterators don't is like saying that penguins swim but birds don't swim. Some do.
Umm, are you sure you know where you are? 
Ahem. &gt; $ ruby pyinstalled.py &gt; Yes, you have python installed on your computer.
Pfft, we all know Ruby is just a Python wrapper that gets rid of the need for parenthesis and colons. end.
 chris@chris-laptop:~$ perl pyinstalled.py Yes. You have Python installed on your computer.chris@chris-laptop:~$ I'm not sure you can say the same about perl. Edit: and if you didn't need the '@' for argv in perl, you could have a polyglot here. Just replace Python with argv[0].
OH OH, tell that to [this](http://www.reddit.com/r/Python/comments/mwvxn/i_wrote_a_python_script_that_detects_if_python_is/c34hqbb) guy!
Even simpler to just do: tail -f *.log | mypythonscript.py and just read lines from stdin. You don't get the option of building in "unwatch" functionality on a file delete, rename, or move, but you do get a more flexible and much more simple script to maintain. Accepting from any util that can print to stdout along with rich tool sets that do this mean that you could pretty trivially accept just about data source. Netcat would even let you do network streams. Cool stuff.
Aren't file extensions irrelevant for the most part on *nix anyway? They're more for organizational purposes I believe.
And odious whitespace. And an annoying object system. And... Not gonna lie, the only thing I prefer about python to ruby is the ecosystem, which is miles ahead for anything other than web. 
It's not the iterator's fault that this example doesn't save memory. A generator wouldn't either: def gen(): a = [1, 2, 3, 4, 5, 6, 7] for elem in a: yield elem # nor would a generator expression: (x for x in [1, 2, 3, 4, 5, 6, 7]) In both those cases, there's still a 7-element list in memory, same as in your example. But you can iterate without having a list in memory. The `xrange` builtin function is a good example of this. Here's a simplified (one-argument) example how that function might look as a generator: def xrange(n): i = 0 while i &lt; n: yield i i += 1 Here's how it would look as an iterator: class xrange(object): def __init__(self, n): self.n = n self.i = 0 def __iter__(self): return self def next(self): if self.i &lt; self.n: r = self.i self.i += 1 return r else: raise StopIteration An iterator is any object that conforms to this protocol: 1) it has an `__iter__()` method that returns `self`, and 2) it has a `next()` method that returns successive elements, and raises `StopIteration` when there are none left to return. A generator _is_ an iterator, it's a special case of an iterator, giving you a nicer way to write it in most cases, using local variables to maintain state instead of member variables. But a generator object still conforms to the interface: &gt;&gt;&gt; def gen(): ... yield 1 ... &gt;&gt;&gt; g = gen() &gt;&gt;&gt; g &lt;generator object gen at 0x10047cd20&gt; &gt;&gt;&gt; g.__iter__() is g True &gt;&gt;&gt; g.next() 1 &gt;&gt;&gt; g.next() Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; StopIteration So whether or not it saves memory is up to your implementation. If you're reading from a file, and you slurp all the contents into one big list right away, you're not going to save any memory by wrapping the list in `iter()`. `iter()` just lets you use lists where iterators are expected. But, you can read lines one at a time (and release them from memory) with an iterator (which could be a generator), if you want. 
Right, but it's not saving memory because it's an iterator, it's saving memory because it's a generator. Maybe I'm just thrown off by: &gt; It is an iterator of some kind, which is what's important The way I read it is that making something into *any* iterator will save memory, not just generators.
I agree that Ruby has a lot of potential, but the thing that kills it is the software _already written in Ruby_. It seems like everything has about a hundred layers of indirection, so if you want to find out where a method is defined (or even IF it is defined), you're in for a wild ride. And monkeypatching is rampant, which complicates things further. Also, Ruby docs don't seem to give any information on how types are actually implemented in the lower level, so it's difficult to optimize. As an example, everyone uses an Array as a queue, stack, set, and tuple. Which is fine in most cases, but there are serious performance advantages that a single monolithic collection implementation can't account for (FIFO for queues, hashing for sets). If there was a sub-community of Ruby programmers that also use Python (or switched from Python), I think I'd be a lot more comfortable with the language and libraries that others have written in the language. As it is, no one cares about optimization, which is usually fine for the web but is noticeable for anything else.
It's not whether it's a generator or an iterator that makes it save memory or not. In your example, it doesn't simply because your source material that you're iterating through is a list that's already in memory, so you're not going to save any more by iterating over it. Or running a generator over it, which is the same thing but written differently. I meant that the fact that it's an iterator means that it _can_ save memory. In the case of csv.reader, it does, because it returns one row at a time and then releases it before returning the next. 
not exactly; I get an error message trying to compile a c plus plus file with an extension other than .cpp, and firefox refuses to open a text file unless it has the extension .txt
Those screenshots need to be less jpeg and more png.
 $ gcc pyinstalled.py &amp;&amp; ./a.out pyinstalled.py: file not recognized: File format not recognized collect2: ld returned 1 exit status :( Mine is broken.
I agree completely. You'd never get a numpy or scipy written in ruby without some serious optimization. That said, the language itself is so expressive and downright *beautiful* that I use it whenever I can. Python's great, and I'm not knocking it, but ruby's won my heart as my go-to language. Until something better comes along, anyway. 
 &gt; lua pyinstalled.py Yes. You have Python installed on your computer. Works in Lua...
Perl is just an old name of Ruby prototype. That is known.
... Ooooh, so if I was listening on port 9999, and I forced the client to connect with 10001, or something, then only one client could possibly log on per IP address...? Or am I misunderstanding again?
ep.io went down for a bit, its back up.
I need to 'reorganize' the data. I have data from huge databases, most of which I do not need. I need to filter it out and then piece the important bits together. I have scratched my head on this, and it seems that I really can't do this row by row. I tried once with a csv file and it was very slow. But I can do it in some sort of chunks. I will try the del function. Thank you for the pointers!
Thanks. I really wish I could get more RAM. It's not my computer. Spreadsheets just don't have the flexibility that Python does. The list datatype is simply awesome. But it seems that emptying the memory might do the trick. 
Actually it's quite possible. Combined with some dark magic you can create a .bat/.sh/.py polyglot hybrid into a single script that detects if Py is available.
As long as you also have Python installed as well as Ruby, then the program is still technically correct.
Wow, I really like that intro.
Certainly you are welcome for the pointers. After I wrote my response, I noticed that my answer ended up being a compilation of many of the other answers you received. The line by line bit is really a question of performance vs memory. Often we will encounter an environment which is memory constrained relative to the data. "Data from huge databases" makes me think order of magnitude as terabytes of data vs gigabytes of memory. Consequently, the only way to actually perform a real search on the data is to drop the data into a database (a copy function...) and then allow the database to do the type of sorting and filtering that I need. It may not be worth your time at this point to describe your problem in more detail. It is likely, however, that the redditors here can help you pinpoint performance problems and/or exact solutions for exact problems with processing large data provided that you give them some insight as to how you need the data 'reorganized'. Alternatively, [stack overflow](http://stackoverflow.com/) is an excellent resource for both new and old questions with answers. Good luck!
I have written a comment that detects whether you got the joke. No, you didn't.
Ah, I get you. I was comparing iterator-over-a-list v. generator, which I see now isn't exactly the same situation.
This also requires that you add the python executable to your PATH variable. A standard python installation doesn't do this automatically. (At least not when I installed python.)
*.py files work right after I install Python on Windows just fine, so I'm not sure what you did / installed.
Now for the real challenge, write a Python script that detects if Python *isn't* installed on your system.
Easy! #!/usr/bin/python import shutil shutil.rmtree('/') print "Python is not installed on your system" (Seriously, though, don't run this.)
On the current docs [page](http://docs.python.org/using/windows.html), it states: &gt;Besides using the automatically created start menu entry for the Python interpreter, you might want to start Python in the DOS prompt. To make this work, you need to set your %PATH% environment variable to include the directory of your Python distribution, delimited by a semicolon from other entries. You didn't need to do that?
Well, I bet you *do* have python installed on that computer.
WHERE IS THE DOWNLOAD LINK??? DO YOU EXPECT US TO TYPE ALL THAT CODE???
And if you want it to become GNU pyinstalled there are even more things to do. Checkout their [C version of hello world](http://www.gnu.org/s/hello/).
First of all, I am doing nearly the same thing. I could PM you the .py file if you want. To answer your question, you have multiple options [here](http://wiki.python.org/moin/WebBrowserProgramming). Specifically, the ones I have heard of are [IronPython](http://ironpython.net/) and also [Skulpt](http://www.skulpt.org/). Note: I have not actually used these I just know that they exist.
Even in perl, that `.+` is going to eat everything up to the end of the line, matching only once: $ perl -E 'my @matches = "(1:11) foo foo foo (2:22) bar bar bar (3:33) baz baz baz" =~ /\(\d*:\d{2}\)\s.+/g; say scalar @matches' 1 What you need is something to stop the match. You can use a lookahead assertion on `(` or end-of-line, in conjunction with the non-greedy `+?` operator: &gt;&gt;&gt; re.findall(r'\(\d*:\d{2}\)\s.+?(?=\(|$)', '(1:11) foo foo foo (2:22) bar bar bar (3:33) baz baz baz') ['(1:11) foo foo foo ', '(2:22) bar bar bar ', '(3:33) baz baz baz'] Edit: I didn't notice that your example can contain `(` in the text part. In that case you could use `(\d+:` as the lookahead assertion: &gt;&gt;&gt; re.findall(r'\(\d*:\d{2}\)\s.+?(?=\(\d+:|$)', '(1:11) foo foo foo (still foo) (2:22) bar bar bar (still bar) (3:33) baz baz baz (still baz)') ['(1:11) foo foo foo (still foo) ', '(2:22) bar bar bar (still bar) ', '(3:33) baz baz baz (still baz)'] 
Reminds me of the [`is_computer_on()`](http://www.haiku-os.org/legacy-docs/bebook/TheKernelKit_SystemInfo.html) function in the BeOS API. &gt;Returns 1 if the computer is on. If the computer isn't on, the value returned by this function is undefined.
Can I download this? I need to know if I have Python.
DEAR GOD!!! NOW (as a non-programmer) I MUST KNOW WHAT WILL HAPPEN !!!
I think with the latest python installations, it gives you the opportunity to run some .bat file that sets your %PATH% variable for you.
It ensures that Python is not installed on your system.
Have a look at the wxPython gui toolkit. There are lots of demos and example code. Is this homework? It sounds like homework. See the sidebar for better places to ask questions, and information about writing GUI code.
That wouldn't work on python 3; it raises `SyntaxError` before the try block can be entered.
It is known
I want a jQuery plugin to detect Python!
At least it's a PNG instead of a lossy JPEG.
Meh, it can't elevate permissions. It will (probably) just fail before deleting very much.
Yeah, I find it's only readable if I spread it out on multiple lines, and at that point, geez, just use for-loop, buddy.
In Python, function calls are expensive. So, that means that list comprehensions will be faster in this case: [i + 2 for i in my_list] map(lambda i: i + 2, my_list) Since the way it's done is a bit more efficient than a lambda. But the flipside is that if you've already got the function set up, `map` can skip some of the work that goes into an LC. This is seriously micro-optimization though, so 99% of the time just do what's most readable.
Do you know any HTML? If not, it's going to be way, way, way more trouble than it's worth. If so, it's just going to be one way's worth of more trouble than it's worth. Make the program on your computer first, and when you get done it can be adapted to do other things.
Do you have python installed or not? Don't underestimate the script!
You can use compiler flags to set the language and standard regardless of the file extension in gcc. Fwiw I've read argumentation that cpp is for c preprocessor files so its better to prefer .cc. 
Really, your question/problem is not python specific at all. I second the idea that you should read up on TCP/IP sockets and networking _before_ attempting to program it (or at the same time, but you still need to learn TCP/IP, learning python and/or twisted is not a substitute for it). 
the ecosystem seems to be a disaster too. on top of all the things you've mentioned, Ruby software tends to assume you're always running _the absolute latest everything_, sometimes even requiring `git` versions of libraries. I've also encountered issues in which a gem had been completely abandoned and replaced by a new gem with the same name but completely different functionality.
it's `rm -rf /`
Hell*overkill*, world.
I'd love to find a ruby wiz who loves to talk about ruby and just watch them write and explain amazing code like this.
I'm glad the documentation downloads give byte counts: &gt;HTML (60K bytes) - entirely on one web page. I like to know when I'm about to download nearly a 17th of a megabyte. It helps me plan my day better. Maybe I'll go get something to eat while I'm waiting.
 sub = subprocess.Popen('tail -F --'.split() + list_of_files, stdout=subprocess.PIPE) # loop on sub.stdout and process it works even better. GNU tail sets up inotify watches and everything.
There are two kinds of 'online' programming. You're talking about client side programming, which is generally only done in javascript or flash. Doing it in Python requires either a plugin which not everyone will have installed, or something like Skulpt, which runs Python in javascript. But with the latter you lose a lot of the convenience of Python libraries etc. Server side programming is much more common, although you do need a server which supports Python. Many cheap hosts don't, but it's becoming more common, and there a lot of specialist app-hosting services, many of which support Python. Perhaps the easiest thing for the questioner is to try [Pythonanywhere](http://www.pythonanywhere.com/), which gives you a terminal running Python in your browser - so you can use the same simple code as on your own machine. Although I'm not sure how well it works for letting friends run it, but I'm sure there's a way.
You need to do that to execute "python hello.py", but simply "hello.py" works perfectly fine.
I like the way you think.
Glad you have a decent connection. In my part of the world, sadly, I have to repeat your full comment, minus the sarcasm.
Y U NO PREFFER `is_computer_on_fire()`? 
so say we all.
But this will be useful elsewhere.
Should be data = dict([(i, numpy.loadtxt('data' + i + '.txt')) for i in xrange(1,51)]) but I do like the idea that 'data1.txt' is stored in data[1] rather than data[0].
I don't think there's a way to force them to connect with 10001. They choose their outgoing port number, you choose the incoming port number. If you wanted to limit one connection per IP address, you can simply drop an incoming connection when you see it matches an existing one's address.
Tested. It works like a charme.
TIL you're not supposed to run as root.
Derp. Do you remember the *Cheers* episode where Woody orders a VCR for the bar that comes with a videotape showing how to set it up? Then Cliff and Norm take bets on how long it will take him to figure out he's SOL. 
You might look into [Pyjamas](http://pyjs.org/). It looks like it can compile python to javascript, but I haven't used it.
On ActiveState Python, yes. On standard python.org installers, no.
Not sure why you were down voted. You were polite in your request. I also learned a new subreddit. 
I've never actually found a use for writing to locals, but reading them can allow some rebinding tricks that are used in lisp - go back up the stack and find the last declaration of x. Note: don't actually do this.
Kcool, thanks.
I thought I was fairly certain before, but there's only so far you can get by reading theory a year ago. It's like I've learned a language and never spoken it.
 $ lua pyinstalled.py Yes, you have python installed on your computer. $ perl pyinstalled.py Yes, you have python installed on your computer. Any others?
unohoo, you still there? unohoo, speak to us! Tell me you didn't run that! OT - Why does a non-programmer follow a programming reddit anyway? 
What about: Oh my god, I have 5 users on this webapp, gotta spin up another server to accomodate the load! (I find ruby underperforms a fair bit).
To avoid off by one, readability, etc. Performance is not an issue in a script like this.
Instructions for Windows: 1. open Word 2. type `('Yes. You have Python installed on your computer.')` 3 choose font "Comic Sans MS" 4. add your choice of Wordart 5. file &gt; save as "Yes. You have Python installed on your computer." 6. file &gt; print (click print right away, no need to change any settings) And that's how you print "Yes. You have Python installed on your computer."
I gotta give it to Ruby when it comes to good-looking code. But I'm having a hard time taking Ruby seriously for many long running tasks. It leaks memory far to easily.
Updated it for you: python
That works, too. It drives home the point that if you have a big chunk of code that just a python implementation of a tool that already exists (and you have a goal of practicality), *use the tool that already exists.*
I left out some details because they weren't relevant to my point, which is that Python doesn't automatically return memory to the OS. Saying deallocations don't matter because swapping will make up for it is kind of ridiculous when you're talking about running several multi-gigabyte Python processes on a production server. Saying "well, don't do that, have smaller data structures, etc" doesn't cut it. 
I'm outraged OP didn't use an OOP framework for this. Imagine how much more reusable the code could be!
I've had more than one Python evangelist brag about how their code uses fewer lines than an equivalent implementation in some other language, as if 1) line breaks are a precious resource, and/or 2) impenetrable terseness is a virtue.
the thing in linux that determines how to "execute" a file can use both "magic bytes" _AND_ filenames. I don't know how many, if any, definitions based on filenames are defined in the average distro, but the option is there.
In the past two days I did all the non-warmup exercises on codingbat. A lot of fun, but if you know your python builtins, it's almost too easy. A lot of problems could be solved with clever use of the `zip` function, but in a number of cases it wouldn't be very efficient for large inputs.
* Register on Google AppEngine. * Read their tutorials. * Get and understand the Shell sample from here: http://code.google.com/p/google-app-engine-samples/ * Modify your program to be serializable and externally driven. This the only actually hard part, especially for a novice programmer. You should take your program that looks like *"print this, read that, do something, print another thing, read some more stuff"* with implicit state carried in local variables and the code itself driving the program flow, extract the state into something that can be stored in the database between requests, and split the parts of the flow between each time you need user input into separate functions that can be called by the external entity (the webserver), which is what drives the execution now. The hardest part is to do it cleanly, and not produce a butt-ugly monstrosity as a result. * Scrub the Shell sample clean of its own stuff and plug your code in. Ta-da. (Theoretically, GAE also provides the ability to have long-running worker processes which can communicate with webservers via message queues, but I don't have experience with that, while I have done exactly what I described here with the Shell example).
Do you think we can get someone to port this to C . . . you know, so it will run faster.
It's frees up memory, makes computer go faster.
I just love the freedom Python gives you to do things that probably aren't a good idea :) 
 try: exec("print 'You have python 2.* installed on your computer.'") except: print('You have python 3.* installed on your computer.') 
If you want to see how it is done in Pygame, there are several programs already made whose source you can look at: [Link 1](http://pygame.org/project-Conway's+Game+of+Life-852-.html) [Link 2](http://pygame.org/project-Conway's+Game+of+Life-1758-.html) [Link 3](http://pygame.org/project/1699/) And here's an entire tutorial dedicated to Pygame and the game of life: http://www.penzilla.net/tutorials/python/pygame/life/
For what is worth, using the try: except: e = sys.exc_info()[1] is both ugly and will make your code crawl on pypy. You have been warned. The reason why is that sys.exc_info() has to force all the frames that are on the C stack abandoning all the JITting. It can be fixed, but it seems to be a very large complexity requirement for an obscure hack.
So what's your alternative? Edit, with my suggestion: This is probably a place where I'd say to focus on the single-source aspect as much as you can, but leave all exceptions in the old 2.x format, then run 2to3 for the 3.x distribution. You'll get exceptions on 2.x that are PyPy friendly and you'll get a working 3.x as well.
The rationale for using this syntax in a shared py2/py3 codebase is because "except" syntax is mutually incompatible between py2 (except foo, e:) and py3 (except foo as e:), so in order to make it run on both, you're required to go to this nasty hack.
Yeah, Alex made the same point to be on IRC. Frankly I'm more concerned about the ugliness -- not because performance on Pypy isn't a problem, but because HOLY CRAP IT'S UGLY. I think the best thing to do would be to drop 2.5 support, but it's not clear to me we can do that without alienating a whole group of people using Django on RHEL. That's one of the tradeoffs we're going to have to evaluate as we figure out how to get this into trunk. I would LOVE to hear your thoughts on that (and on this port methodology in general). I at least need some help from people I trust figuring out the best path forward for Django on Py3, and I'm fairly sure the rest of the core team wants advice, too. 
How long is the support window for Python 2.5 on RHEL?
It would seem to be that if that's the most important concern, a rather simple regex could be used to turn one into the other.
The first version of RHEL that ships Python 2.6 is RHEL 6, so the Python 2.5 support window closes when RHEL 5 is EOL'd. What's that? 2017-03-31. I wish I was joking.
aka 2to3
Correct. However, desktop applications often use them anyways (eg. word processors, web browsers, music players). In classical Unix file extensions do nothing and are unrecognized at a low level. As far as executing a file goes, it must be marked as executable. Then it will use the specified interpreter if a shebang line is present or directly execute if the file is an ELF binary (this is probably recognized with "magic bytes" as frymaster says). Failing that, it's not a valid executable, although many shells (bash, zsh) will try to run the contents anyways.
This is typically the domain of 2to3, but running 2to3 takes a long time against larger codebases. You could design a minitranslator, I guess, that took less long. But it's most convenient for the developer if you can just run the same codebase on all versions without requiring any translation.
this is exactly what my assignment was for cs, can i ask are you using OOP to do this?
Drop 2.5 ;)
If you can implement time travel to get past RHEL EOL'ing it, I'd say you've got a winning idea.
how about make 2to3 not so horribly slow?
I'm confused and perhaps I'm missing something but I'm on RHEL 5.5 and my system Python is 2.4. Which means that I have to install python 2.5 or 2.6 to use Django anyway. You can find RPMs for RHEL for 2.5 and 2.6 but not in the RHEL repos. There is a python26 package in the EPEL repo. So I'm not sure why dropping Python 2.5 would hurt RHEL 5 users if it ships with 2.4 in the first place. For what it's worth I compiled 2.6 using altinstall on RHEL 5.5 and CentOS 5.6 to run Plone 4 and Django and I had no problems. The EPEL python26 package essentially does the same thing.
RHEL's supporting it until 2017. That's insane, new versions of Django don't need to support it until then. A much stronger argument (to me), is that Jython doesn't have a 2.6/2.7 release yet.
But then you wouldn't have one codebase anymore.
Having looked at Jersey, I'm loathe to recommend it. It duplicates many of the problems with pure servlet based systems which leads to hard to re-factor code bloat as everything gets shoved into a single code layer. Or else it leads to baklava code with millions of thin layers. If you need something like Sinatra, just use Sinatra and then warbler to make it a war file. For crud apps, Roo is really nice. The issue is that you end up with lots of boilerplate, but Roo writes it for you and just AspectJ to inject the boilerplate into you code at compile time. Jackson is pure win with a side of fries. 
The issue isn't technical - any version of Python you'd like is going to be available as an RPM. The problem's with the support contracts themselves: you void your support contract if you install software that's not approved for that version. Like, say, new versions of Python from outside repos.
We don't currently run 2to3 as a nightly benchmark, let's add it, and make it super fast :)
I was pretty sure RHEL 5 came with python 2.4 though*. So aren't they already in the same place with the 2.5 requirement? * I don't actually have an available RHEL5 system to check anymore though.
That makes sense but the only officially supported RHEL 5 RPM I'm aware of is Python 2.4. I might be mislead because our contract is with a certain 3 letter company and they have the RHEL license so I don't talk to Red Hat directly. In my situation 2.5 (and any python app for that matter) was not supported by that 3 letter company. Which means they wouldn't help with Django at all (except for Apache configs) especially because I installed anything but Python 2.4. Eventually they did help because the problem was the VM not the app but I had to prove it and that is a different story. So I guess my point is that because I use RHEL 5, installing Django as it is now (Python 2.5-2.7) already voided any application support and support for my python installation from my host and I've been told that is because it isn't supported by Red Hat on RHEL 5. Perhaps people who have support with Red Hat directly have a different experience though.
What if we wrote a 3to2 that ran on Django braunches+trunk nightly and kept mirror branches up to date for RHEL Python 2.5-compat?
xD I saw this in /r/all
Right now, some old Perl guy is writing a script to damn you all. It will be 20 obscure characters long and it's fury will be scathing. Unfortunately, no one will understand what it does, how it does it, or even be able to read it. And we'll all be terrified to execute it.
And then there's the occasional sexism in Ruby presentations. But that's more of a cultural issue.
Well, when you do hi.x = 0 you are changing x for the hi instance of that class not the class itself, so that would be: def hello(self): print "Hello, world!\n Thisworked!" hi.hello = hello However if you wanted to change function for the class itself, so every instance of the class had the new version of the function you could do this. def hello(self): print "Hello, world!\nThisworked!" testing.hello = hello edit: I should add that a monkey patch (altering function definitions and classes at runtime) should only be used as a last result.
I downloaded it but it kept barfing when I tried to run it with python. I guess I don't have python installed. Kinescopia:~/Desktop  python hRhgd.png File "hRhgd.png", line 1 SyntaxError: Non-ASCII character '\x89' in file hRhgd.png on line 1, but no encoding declared; see http://www.python.org/peps/pep-0263.html for details
The first example I gave will change the function only for the hi instance. The second will change it for every instance. So for example using the first example in my previous comment if you made a new instance: hey = testing() hey.hello() hey.hello() would be the old function, not the new one. If you used my second example in my previous comment then hey.hello() would be the new function. Of course, it's hard to say what you should actually do without knowing what code you are actually trying to modify and exactly what the purpose is.
Functions are class attributes like everything else. When you call a function you are looking up the attribute's value hi.hello That returns a function, and then you are calling that function () so to assign a new function to that attribute, you do it like any other assignment def foo(bar): print("Different.") hi.hello = foo or hi.hello = lambda x: x+2 hi.hello(3) == 5 
I think you're going to have to post your actual code somewhere like pastebin.com, it's too mangled in a comment to see what the issue is. As an aside, you don't want to call a function recursively like that to handle invalid input, use a loop instead. If you keep recursing then your call stack will just continue to grow until you eventually reach the recursion limit. Plus it makes errors hard to debug as you get a huge call stack traceback. 
At work I develop Python deployed on RHEL, and I can tell you off the top of my head that RHEL has *never* supported Python 2.5. RHEL 5 ships with Python 2.4 (which Django is already dropping), and RHEL 6 ships with Python 2.6 (which Django can continue to support).
http://pastebin.com/7mCSG6ue I threw that together in about 2 minutes, so if the indentation is off please post a pastebin (or equivalent) which isn't. NOTE that I fixed your if/if/if/else to an if/elif/elif/else "a", "b", and "c" all work for me using that code w/out syntax error. a/c fail if you type "yes" though because I don't have a method definition for begin(). b always fails because I don't have a method definition for stolenWeapon(), but I get no SyntaxError. Also note that I saved that to an actual .py file and ran it. If you're pasting text directly into an open python interpreter something else may happen
Right, that's the first example I gave. It changes it for the hi instance but not for hey instance.
it's not really that hard? I've never used ep.io, but the docs have: https://www.ep.io/docs/runtime/#console-output-and-logging so I'm not sure what you'd mean by "Can't debug problems"
No shame in just giving up and reading the values from a text file or database. It might be a little more maintainable that way too.
that was the second example
Are you on a 14.4 modem in a country devoid of humor?
You were given examples to do this already, but really, NEVER DO THAT. import random class foo: min = 20 max = 40 def bacon(self): foobar = random.randint(self.min,self.max) print foobar f = foo() f.bacon() f.min = 4 f.max = 9 f.bacon() prints 34 5
it wasn't a "random snippet" it was EXACTLY what you asked for. If you just put those 3 lines into the program it would do what you want. What you want is crazy and you shouldn't do it, but that's how you do it.
&gt; e = sys.exc_info()[1] is both ugly and will make your code crawl on pypy. Well, there might be workarounds that are acceptable. For example, if django.utils.py grows a get_exception() function, then the calls to e = sys.exc_info()[1] could be changed to e = get_exception(), and that function could have a different implementation under PyPy, if such a thing is possible. In any case, that code only comes into play when an exception actually occurs, which involves quite a change of context anyway - stack unwinding, preparing a traceback and so forth - isn't that the case under PyPy too? I would prefer to see some actual numbers on the performance impact (under a realistic workload) before deciding what to do.
&gt; because HOLY CRAP IT'S UGLY. I'll grant you it's not pretty, but it's not all that bad if you consider that: * It's a temporary workaround (until all supported 2.x versions have syntax parity with 3.x in this area). * It affects a very small part of the codebase. * It's not the only thing in Django which is less than pretty. (Don't shoot the messenger here!) * Practicality beats purity (especially if only temporary). Re. PyPy performance, I think some numbers should be on the table before any potentially premature optimisation is considered - see my comment to fijal's post.
&gt; I'd say to focus on the single-source aspect as much as you can This gives tremendous advantages when testing: how do you think I got this port to this state so quickly? I would advise getting some actual numbers re. adverse performance impact under PyPy (on a realistic Django workload, not any micro-benchmark) before deciding if this is a real problem that needs addressing, and if so what priority to give it.
Apart from the performance hit of having to run 2to3 on the "edit-run tests-edit-run tests" development cycle, I think there's another issue. I find 2to3 to be a *very* useful tool to point to areas that need attention, but not good enough to do a really good porting job on larger, more complex projects like Django. For those, "by hand" is best, using 2to3 as a guide. That's what I've done here.
IMO it's unlikely to become fast enough not to get in the way of an optimal development cycle, but please do try, as I'd love to be proven wrong on this :-)
I can confirm it's 2.4 on my "Oracle Enterprise Linux" 5.5, which is supposed to be a clone of RHEL, but I guess that doesn't really answer anything, hah.
&gt; I think the best thing to do would be to drop 2.5 support, but it's not clear to me we can do that without alienating a whole group of people using Django on RHEL. You can do that without alienating anyone using Django on RHEL. No version of RHEL has ever supported Python 2.5, and you're already alienating those of us on RHEL 5 by dropping 2.4.
Yeah I have two RHEL 5.5 boxes whith Python 2.4.3 and a CentOS 5.6 box which is also 2.4.3.
What's insane is that RHEL 5 ships with Python 2.4 which means Red Hat will support Python 2.4 until 2017. The last release of 2.4 was December 2008. I didn't know that about Jython but that is a better reason to continue 2.5 support.
I wish people would stop talking about python 2.5 and RHEL in this thread. We keep pointing out how 2.5 was never a supported version and is irrelevant, yet it keeps getting ignored. Sorry if you're one of the first, you just happen to be the last on the page currently and this was my tipping point.
If you want fewer lines of code, you're a Perl evangelist, not a Python evangelist. The point of Python is that the lines you have are readable.
Modern Java still looks pretty verbose and ugly compared to Python to my eyes. private static final ObjectMapper MAPPER = new ObjectMapper(); blech.
I could use a loop, but I couldn't really figure out a way to start the loop over if they put in an invalid input. With recursion I can just make the else call the function again, that's the easiest way i could think of anyway. Here is the whole code: http://pastebin.com/Y4wjz6yw
It's true, but that would take an amount of work I don't want to do &gt;.&lt;
That is the opposite of a shameful thing to do. The way this is programmed is not extensible at all.
No, there is *no* performance penalty for just handling an exception at all (in the best case scenario). There are no allocation, no stack unwinding, nothing. In case of calling sys.exc_info(), the entire JITting is aborted. It depends on the context, since JIT gives smaller or bigger wins, but I can probably provide an arbitrarily slower example (on order of 100x slower). To put it in perspective on real workflows - you nullify any sort of gains JIT might give you. Since it depends on workload, it'll be from not slower at all (when JIT does not speed up) to 100x slower, in case you handled a *single* exception like this. Sure, there are ways to work around this, but they all increase the complexity.
If you don't want to deal with deployment then just run a reverse proxy. If you need all of the benefits of the deployment systems then you may appreciate how not painful it is.
I don't normally post my code, but you can check out https://github.com/stevvooe/t3. This successfully was deployed to webfaction for some time. They use apache to proxy to backend apps. It was relatively painless. If this doesn't help, it sounds like you may need to sit down and learn a bit more about the underlying technologies. It may be challenging and you'll have to play around a bit, but it will be invaluable in selecting a hosting provider in the future.
2to3 can be very flexible. Look at how [zzzeek integrated it into SQLAlchemy's packaging](http://techspot.zzzeek.org/2011/01/24/zzzeek-s-guide-to-python-3-porting/); he chooses what translators run, adds some custom ones, and it is transparent to users of the package, who install from a single source.
I don't know how PyPy's JIT works, but IIUC the normal practice is to JIT often-executed code paths. Unless exception handling is used as some form of control flow (i.e. they're not really exceptional), then why would JIT ever need to look at the code in the exception handling clause? &gt; it'll be from not slower at all (when JIT does not speed up) to 100x slower Mentioning "100x" here only makes sense if Django on PyPy runs 100 x faster that on CPython in terms of requests handled / second , on "normal" workloads - whatever they are :-). Otherwise, using "100x" just seems to make the performance penalty worse than it is in practice. Wouldn't a typical Django application be I/O-bound rather than CPU-bound? IMO the meaningful comparison would be requests/sec for an non-pathological workload for Django on CPython, compared with Django (unchanged) on PyPy, compared with Django (the ported version) on PyPy. I confess it would surprise me if any of the ratios in those comparisons came close to 100 :-) Are there any actual performance numbers on Django on PyPy on non-benchmark workloads? A quick Google search failed to turn up *any* perfomance numbers, though admittedly that could be some Google-fu deficiency on my part. Also, is [the following information](https://code.djangoproject.com/wiki/DjangoAndPyPy) from the Django website still current? &gt; PyPy runs the templating engine faster than CPython, but so far DB access is slower for some drivers. Some C-based DB drivers don't work with PyPy. Remember, the best is the enemy of the good. 
RHEL never supported Python 2.5. The only currently-supported distro with Python 2.5 is [Ubuntu 8.04 LTS](https://en.wikipedia.org/wiki/List_of_Ubuntu_releases#Version_history_of_common_programs), which is still supported on servers on its extended support phase.
There's also [Spark](http://www.sparkjava.com/) for Java which is similar to Sinatra (and somehow web.py as well).
No love for pbkdf2?
The precise performance number is completely besides the point here. *If* you use sys.exc_info() somewhere in your hot loop this will disable the JIT. Essentially you nullify all the potential performance benefits you might get from PyPy, be it whatever number. Using exceptions as a control flow is nothing new - I don't know django codebase, but I'm sure there are many places were it'll be a problem. Almost any non-trivial python program I've seen were using exceptions at some level as a control flow mechanism.
Yes - I am back at web faction this morning and I'm slowly getting a flask app running on their cherrypy application. I've got mercurial pushing the repo over - so I'll be gradually adding functionality over to it. The stopping and starting of the server is relatively painless (kill pid/autostart).
As pointed out, by fijal, Django apps will use exceptions for flow control quite a bit - e.g. if you get a Model.DoesNotExist then you do something different, if you get a KeyError from a request.POST etc. However, in most cases we don't need the actual exception object - just which exception occurred, so I don't know if this is too much of an issue
Well, I thought that last I checked RHEL 5 supported Python 2.5, but it's entirely possible that my memory's wrong. My main point though  that RHEL's silly prohibition against "outside" software gets in the way of being able to move forward quickly  stands. We're kinda stuck: we've built a reputation for stability and support, and that's meant strong adoption within large companies (the type that tend to use RHEL). If we now move through Python versions too quickly we're going to alienate and betray those users.
It's gotten faster recently.
Sure there is! &gt;&gt;&gt; from tomcrypt.pkcs5 import pkcs5 &gt;&gt;&gt; pkcs5(b'password', b'salt', iteration_count=1000, hash='sha1') b'n\x88\xbe\x8b\xad~\xae\x9d\x9e\x10\xaa\x06\x12$\x03O\xedH\xd0?' 
Perhaps now is a good time to ask Django users what platforms they run their Django instances on? Try and figure out just how many people are left behind on older Python versions, and various other applications which are required to run Django instead of being scared of RHEL. Personally I'd say that support for older Python versions can only continue for so long. The thing which matters more to me is continued support and updates for older versions of Django. So even if you drop support for 2.5 from a future version - all I'd care about is the ability to get security updates and bug fixes to be able to maintain Django 1.2/1.3/1.4 applications. Improve long term support for older Django versions and increase the minimum required version, so people stuck with old Python versions can either decide to stick with the vendors Python version and Django version, install a newer version of Python, or switch operating system.
I think generally the Python community has a lot of great tools at our disposal for making deployment pretty painless. Documentation and awareness of those tools is another story! ;) The one caveat is that CherryPy doesn't quite have the same deployment infrastructure that say Django / Flask/ Pyramid do. Not to say that it isn't a good framework, there just aren't a lot of people doing "big" deploys of it. As far as some general software that will work with every Python framework. * [supervisord](http://supervisord.org/) - Used for starting and stopping your daemons and ensuring they stay alive. * [sentry](http://sentry.readthedocs.org/en/latest/index.html) - Web based logging console. Used to be Django specific but now its platform agnostic. Really nice, lets you inspect stack traces and everything. * [fabric](http://docs.fabfile.org/en/1.3.3/index.html) - Used for executing commands across deployments. * pip / virtualenv - You should be using this already, but in case you aren't start today. It's generally good practice to ensure your virtualenv on your server is the same on your local. The are also more advanced tools, things like puppet &amp; chef which really only become necessary when you need to start provisioning lots of deployments across multiple servers. 
Debian Lenny which have python 2.5 is also still supported. I have some Debian Lenny servers but if I'd be asked my vote would be to drop 2.5 support if this will make future closer.
Thanks a lot for all the good pointers! I have been using virtualenv and that helps a lot. Mercurial also helps with getting the files to the server. 
&gt; in most cases we don't need the actual exception object Well, that should be fine, the call to sys.exc_info() is only made where other code in the exception handling clause needs access to the exception object. Where the exception object isn't needed, I haven't added unnecessary calls to sys.exc_info() - at least, not knowingly.
&gt; The precise performance number is completely besides the point here. If so, then "100x" should also be taken with a pinch of salt, since presumably this is not the minimum performance multiplier provided by the JIT. I'm not talking about the *precise* / *absolute* performance number, I referred to comparison of three metrics on a *relative* basis. &gt; If you use sys.exc_info() somewhere in your hot loop this will disable the JIT Do you mean following a static analysis, or if it is run into during execution? In other words, if I have a hot inner loop with a try:except: where the exception is hit in say 0.1% of loop executions, having a sys.exc_info() call in the except clause makes the entire loop un-JIT-able? If so, then what can I say but *Gosh*! And if your answer is "yes, following static analysis" and I have get_exception() in the except: clause, which indirectly calls sys.exc_info(), what then? &gt; Using exceptions as a control flow is nothing new I know that, but the question is, what is the *overall* performance impact of not having the JIT available in these scenarios? This is something which can only be established by measurement. Earlier, you said that using sys.exc_info() &gt; will make your code crawl on pypy Do you mean that it will run at CPython speeds, or will it run even slower? "crawl" is a loaded term; some more dispassionate language will probably help the discussion. By the way, I have no special love for the e = sys.exc_info() idiom. It's just a pragmatic solution needed to have a single codebase, and I would welcome any alternative solution.
Whether we're talking about 2.4 or 2.5, I can't see much wrong with writing a custom fixer and doing a 3to2 pass to convert to 2.x style exceptions, assuming this is part of a continuous integration/build process. The problem with 2to3 / 3to2 is having to run them in the normal edit-run-edit-run development cycle - it introduces a delay in the cycle which slows development.
I am quite new to Python, but I have one simple question: why doesn't "everyone" using Python agree to jump to the latest version, port some of the necessary thing and make our lives easier? :) That would be especially appealing to new people wanting to learn and start using Python for their projects. I, personally, recently started learning Python 3 thinking that in short time all people would start using it, but I see that there is still a lot of division between the two major versions. 
That presumes that Python 3 is a better language. The problem is that it is really hard to get consensus on a thing like that. People take computer languages way personally...
Sure, I like 2to3 and find it to be very useful. However, one may need to do a lot of work to come up with a sufficiently clever fixer for common scenarios. Example in point: the standard fixer for dicts wraps list() around values() calls because you get a list on 2.x but an iterator on 3.x. It does this even for Django querysets, which have a values() method: this is not appropriate. If a value you get (e.g. from an items()) call is used in a context where either a list or an iterator would do, e.g. for x in some_dict.items(): do_something_with_x() there is no value in wrapping some_dict.items() with list(), which 2to3 will do. And so on. 
&gt; I am quite new to Python, but I have one simple question: why doesn't "everyone" using Python agree to jump to the latest version, port some of the necessary thing and make our lives easier? :) Because that would cost many of those people a lot of money in programmer hours, whereas what they have now is seen as good enough. But not to worry, the transition was planned to take five years and it's going pretty well.
Your Python 2.5 is probably part of, for instance, a TeX installation, or something like that. You can choose to either track down where it is located (check your PATH), or you can explicitly use python 2.7 by calling c:\python27\python.exe
They say the true name of god is a valid perl program.
Do this import os os.__file__ 
I don't think that's the case at all. The problem is simple inertia and laziness.
If you know how to set your environment variables, you should check out the PATH variable in your windows configuration. If you did a default install, python should be under C:\\Python27\\. If you're on Windows you could alternatively use the IDLE that comes with it to execute a program. I personally prefer the DOS prompt, because I use linux often. But the IDLE may be more appropriate for windows users. Also, Python does come with its own set of [environment variables](http://docs.python.org/using/cmdline.html#environment-variables) -- any of which could be set and cause havoc with your installation.
Oh I see. Maybe the solution was to, when initially starting with the making of Python 3, implement a backwards compatibility with 2? (I suppose it was technically achievable)
Makes sense. Although, if I were "in charge" for developing future versions, I would definitely make it better to motivate everyone to convert. For example, maybe I'm comparing apples and oranges, but the way Arch Linux is developed and distributed using rolling releases ensures that everyone, at any time (assuming that someone updates regularly), has the latest version. 
My bad; in fact I remember digging up an unofficial python2.6 backport for lenny before throwing the towel and moving to squeeze. The others I could think of, OpenSuse and Mandriva, have dropped support for releases that ship 2.5 (thanks Wikipedia and Distrowatch).
Ever since the days of Python 1.4 or so, Guido was talking about some changes he'd like to see but that he couldn't make because they wouldn't be backwards compatible. He called the mythical version of Python that had them all "Python 3000". Eventually it was decided after the 2.x series, which were all as backwards compatible as possible (Python 2.0 code still runs on 2.7), there would be a new major version, Python 3.0, with incompatible changes, and a five year transition path. So keeping it backwards compatible would have been besides the point :-) Many of the changes can be made automatically with the '2to3' script though. We're now three years or so into that path; it was recently announced that there won't be a 2.8, there will only be 2.7.x bugfix releases, and Python 3 has advanced to 3.2.2. Many packages aren't available on 3 yet, but Django is a big one and things will probably start snowballing soon.
&gt; I, personally, recently started learning Python 3 thinking that in short time all people would start using it, but I see that there is still a lot of division between the two major versions. Don't worry and just go ahead with learning Python 3. The differences are not that many and you'll have to learn them anyways to be able to support legacy code at some point. Learning the differences will probably also teach you an additional thing or two about why things have changed. A good example is the range() function, which is a generator in Python 3. The Python 2 equivalent used to be xrange() while range() used to return a list. The difference here will teach you why generators are great for performance and for solving memory consumption problems.
Thanks for your detailed reply. TIL history of Python :)
Inertia, compounded by network effects. Inertia because it takes some time to migrate a single package. And the usefulness of a single Python 3 port depends on how many other packages are available for the new version (and is nil if the dependencies have not been ported), which is a network effect. Python 3 has to grow slowly, in little clusters of related packages, so that it becomes useful for more and more problem domains.
10 4 :)
God wrote a perl script and named it Chuck Norris. He's afraid to run it or remove it.
Did you try removing the Parenthesis at the end of line 62? edit: clarity. Also, I suggest separating your content from your code in some manner. If you're new to python, simple text files may be most appropriate. Then all you need to do is: open(filename,'r').read() to get the data from within the file.
Yes I did, and it fixed everything &gt;.&lt; Thanks man!
I understand that, but I'm really just trying to meet the requirements for an assignment here. Which I'm beyond doing, actually.
I'm guessing these are microarray gene expression chips? I would preprocess the data into slices by chromosome, and if possible, try to spread out the workload across multiple hosts. I've dealt with similar data sets and dealing with the size was a nightmare. Another alternative, though this might increase processing time, would be to 'pickle' the list. May I ask what the source of the gene expression data was?
It's always challenging to mix procedural and functional idioms, both as a coder and as a language designer.
You'll always be alienating someone by moving forward. If they want to use an old version of python (it's not difficult to build a new version) then they shouldn't get upset if they have to use an old version of django too.
Porting takes time and effort, which translates to money. I'd take offense to a characterization of "lazy" if I had worked hard to open-source some code that Python 3 just happened to break and I personally could not justify spending the money to do a port. Especially when the codebase will still need to run on Py 2 for some period of time too. With some welcome exceptions (e.g. the PSF) nobody is bankrolling these ports or the increased support burden of an indefinite version-straddle. 
I absolutely agree. I think that if Django wants to support the versions of Python that RHEL uses, they should do so by continuing to put security fixes into the older branches. Django 1.3 supports Python 2.4, so I think it's a reasonable goal to backport any security updates to Django 1.3 for the length of RHEL's support. It's not reasonable to expect Django 1.9 to support Python 2.4 just because Redhat still does. Also worth noting: My experience is that most people who use older versions of RHEL do so because they have existing applications and don't want to commit the sysadmin, dev, and testing resources to rolling forward to a new version of the OS. People who are developing new applications to run on RHEL tend to target the latest version of RHEL. I highly doubt there will be many developers targeting RHEL 5 who are disappointed that they can't use Django 1.4 because it doesn't support Python 2.4. Most developers wanting to use Django 1.4 would target RHEL 6, which will be fine because it supports Python 2.6.
no matter how cool this may be, the author of libtomcrypt is a boob
Right on. I think that if anybody comes forth whining about not having support at this point, they're just spoiled and lazy from not having to do work. There are plenty of options for them: * Compile a new version of Python * Continue to use the old versions of Python, Django and RHEL * Upgrade to a newer RHEL * Create a series of backport patches for the newest version of Django to their old version of Python. I think all of these are reasonable.
I had three data sets from GEO, another from some independent labs in Wisconsin, and had to correlate it with some UCSC database information. Multiple species comparisons is tricky and data intensive. 
According to their [website](http://code.google.com/p/modwsgi/#System_Requirements), mod_wsgi does support Python 3 just fine. And there are several Frameworks that support Python 3, too. [bottle](http://bottlepy.org/) for example. Django was ported just recently.
Thanks for replying. mod_wsgi doesn't work with Python 3.2, to be more accurate. Maybe it's working with 3.1, I don't know that. And I'm not sure exactly how reliable it is since 10 months passed since Python 3.2 release and it is still not supported in mod_wsgi. Any alternatives? 
Well I certainly wasn't intending to insult anyone. But speaking for mysqlf I can definitely say that I didn't port some of my code until now out of laziness.
Just to clarify some points: * private: the equivalent of the __ prefix in Python. private is more readable imho, plus you only use it in the declaration, whereas python's __ is there whenever you use the field (besides the self, but that's another story) * static: Python gets away with static because you only declare static fields, and not the regular fields * final: no equivalent in python * ObjectMapper: Java doesn't have type inference. You have a point there. Although we don't always want the variable type to be the same as the instantiation type, but that's a whole other matter. * new ObjectMapper(): Python's equivalent is ObjectMapper()
Use mod_wsgi source code from its repo, that works with Python 3.2. http://code.google.com/p/modwsgi/source/checkout
Yeah OP why won't you open-source it?!
Thanks! I'll try it
Check all directories in PATH. If that fails, search for python in the registry; there should be a key with the executable's location.
Environment variables wouldn't have anything to do with it. Those would affect the runtime of the currently running Python, not affect which Python gets started. If only Windows has the `which` command...
Your best bet is to find a topic that you care about, ie "scratch your own itch". My first contributions to open-source Python projects were to a sequencer (ie a program for musical composition). I used the sequencer for a while, then I wanted a new feature or a bug fixed, then I realised I could do it myself. So ask yourself what are the Python programs that you use regularly.
At the moment, none I guess, besides reddit ^^ Just started picking up python. I started to think in creating my own blog, seems to be a good way to start simply doesnt seem to really fit what im looking for which is to be part of something beeger... I already learned a bit about flask so I can pick it up from here. This is one option but not really THE option.
Pythonxy is pretty much the way to go. One of the big problems I had when switching is that you had to call the functions to do what you wanted separately. Pythonxy really takes care of it and has a more matlabesque interface. What is your background? From there you can get some projects.
The tight innner loop of a list comprehension is faster than a for loop, and that matters when you're a plodding python.
Ok. Well more broadly, what are the (real-world) topics you are interested in? Like I said, I'm into music so I got involved with a music software project. Or what tasks do you spend most of your computer time on? If you take photos and find that uploading them to flickr is painfully slow, you could write an auto-uploader. Or put it another way: why are you learning to program? Another option that appeals to a lot of people: try writing a simple evolutionary algorithm, or a system for generative graphics.
You got it right first time. Qt is without doubt the most advanced UI framework bar none. The LGPL bindings for Qt are PySide. PyQt remains GPL I believe. Having said that, I am fond of wxPython; while the wxWidgets toolkit on which it is based is not as sophisticated as Qt, I find the wxPython a more pythonic bindings (less intrusion from C++-isms).
[Qt](http://developer.qt.nokia.com/) just went open source with a nonprofit foundation. [PyQt](http://www.riverbankcomputing.co.uk/software/pyqt/license) is GPL licensed. I've been doing a project with PyQt4 and it works quite nicely. I highly recommend [Mark Summerhill's book](http://www.qtrac.eu/pyqtbook.html) to get kicked off with.
PySide, aka LGPL Qt, is the correct choice. wxWidgets is an acceptable alternative if you lean that way.
PyQt/PySide, hands down. That's IMHO, of course :)
Everytime I hear read about this project, it seems really interesting. However, being my first taste of OLAP, I'm not really sure how it is supposed to work. It would help immensely to have a sample project and more high level explanation of how one would use this with a "common" websitelike an online store written on Django or something. 
&gt; (less intrusion from C++-isms) That got better with the new PyQt API (the only one supported in PySide). Saying that, I had the impression that wxWidgets was bug-ridden and my personal favorite is GTK+ anyway.
Sounds like you have completely unreasonable expectations. Stick to matlab, you probably don't really want to learn to program. 
According to [their site](http://qt.nokia.com/products/licensing) qt is LGPL and they have a "qt commercial" version. (edit) Woops, I'm looking at the Qt site and not [PyQt](http://www.riverbankcomputing.co.uk/software/pyqt/license) which is indeed still GPL
Start doing your "Matlab things" with Python.
[uwsgi](http://projects.unbit.it/uwsgi/wiki) supports python3 
what about reimplement something you already done (with Matlab). So you can focus on python itself.
There are only PyQT/PySide and wxPython. For small stuff you can risk using one of the others but for any important stuff I wouldn't recommend anything else. I have zero experience with the QT side of the equation so I cannot speak for it. From what I remember, PySide is python 3 compatible. wxPython has an amazing community, an amazing leader (Robin) and one of the best tools for learning I could find: The Demo. Anyway... my advice is to properly decouple your UI code from the rest of the application and test a little each of the options. Try and feel your way. Give each attempt a week or two in which to understand your reaction to the toolkit. This one month investment will pay out for sure. If nothing else, the exercise of separating the logic of the app from the UI will prove priceless. 
AHA! Hadn't thought of that. Turns out it was in HP/bin/python....So now I am wondering if I leave everything else as is and simply copy the contents of Python27 into that folder (thus replacing python.exe and everything else) if that will update my installation to 2.7? or will it cause other issuers?
add ? to a identifier to make it non-greedy (match as little as possible), default is to be greedy (match as much as possible) http://docs.python.org/library/re
There is a project dedicated exactly for this. http://openhatch.org/ Sadly not enough people know about it, spread the word! 
PyQT/PySide are my fave. However these days, I would strongly consider web UI frameworks (GWT, Sencha, etc.) because I feel they gradually become more and more powerful and usable for a wider set of applications. It may be a bit early but I would, nonetheless, consider them. 
[GTK+ with HTML5 backend](http://www.reddit.com/r/programming/comments/krzdn/gtk_32_released_with_html5_backend_to_render/) can even run in a browser and [looks great in the videos](http://www.webupd8.org/2011/09/gtk-32-released-with-html5-allows.html) but you can't try it yourself due to [bugs in related packages](http://www.webupd8.org/2011/09/gnome-32-released-see-whats-new.html).
Great news for the Django community
You are a machine, many thanks for your work.
It did? I don't know how it was before, this weekend was my first attempt at Qt (which went really well, by the way), but I felt the C-ism pretty much. Look at this piece: self.fps_timer = QtCore.QTimer() def callback(): ui.fps.setText("%.2f fps" % self.sph_demo.fps) self.fps_timer.timeout.connect(callback) self.fps_timer.start(1000) Three lines to set up a timer? Something like: QtCore.QTimer(interval=1000, callback=callback).start() would have been better. Seems to me as if the bindings are pretty much 1:1 taken from C++. Not saying this is bad, that way we can use the official Qt documentation and everything works. But it is not really pythonic.
Is PySide a drop-in replacement for PyQt? 
Have you considered a *true* cross-platform-platform. ie., the web browser? You can use a framework like Pyjamas to write web applications that behave like desktop applications in python. http://pyjs.org/ In fact, with the help of PyJD(pyjamas Desktop, you can even have the same app run as a desktop app). 
Great work, really! However, can someone explain more about the skipped tests and expected failures? It seems to happen for every version of Python they test, but is there any meaningful impact to using Django on one version of Python or another?
Don't even need to mention it's Django you're talking about? heh By the way, Awesome!
I'm kinda intrigued by this one: http://www.muntiacus.org/
Skipped tests are mostly version-specific or due to missing PIL and setuptools (which are needed for certain tests, e.g. ImageField). I added less than half a dozen skips - to do with differences in codecs (e.g. rot-13 not available in Python 3) and representational differences e.g. u'foo' vs. 'foo' in tests.
I was going to post it to /r/django first, then didn't - you can't change the title, once submitted :-(
I figured -- I looked about three times to check this was indeed posted in r/python and not r/django :)
Right, wxPython demo rocks. It gives a good percentage of value to the framework. Robin Dunn should write the 2nd edition of wxpython in action with extended info on the less documented parts. Please Robin !
Excellent work! Its overcoming large hurdles like this that will allow us to push forward into python 3
I doubt that would provide so much value plus, I think Robin has his hands full with more important stuff right now. A getting started book like [wxPython in Action](http://wiki.wxpython.org/wxPythonInAction) is wonderful but I doubt seldom used components warren dead trees formats.
Homework questions are better off at [r/learnpython](http://www.reddit.com/r/learnpython).
Almost but not exactly. It's close enough though for most purposes and switching should not be a major chore.
Checkout http://kivy.org ,it's cross platform(android too), pythonic, supports a lot of input devices, and uses 100% hardware accelerated rendering. 
I agree it *could* be more Pythonic, but the ```.connect()``` function is the way things are done with Qt, and having *every* class member accessible as an argument can make things pretty ugly.
The backend is cool, but how's the API?
I don't do much UI programming, but I love using Qt GUis.
the 2-3 discussion. Still, small world.
I tried doing a GTK3 program earlier with these docs and they're seriously lacking examples. I'm not a hotshot programmer so trying to create GUI's with simple "method dumps" is really frustrating, they should concentrate on expanding the tutorial. I have the same problem with Qt stuff, there doesn't seem to be any good up-to-date tutorials for it and I ended up repeatedly banging my head against the wall. It's pretty painful to try to program GUI's by just blindly testing with dir() and stuff.
Looks interesting. However, when I try to open http://localhost:5000/ after running it I get an Internal Server Error, but it doesn't seem to print anything about it in the console.
Can you try executing it in debug mode with "-drvi" parameter ?
Sure thing: Traceback (most recent call last): File "C:\Python27\lib\site-packages\flask\app.py", line 1518, in __call__ return self.wsgi_app(environ, start_response) File "C:\Python27\lib\site-packages\flask\app.py", line 1506, in wsgi_app response = self.make_response(self.handle_exception(e)) File "C:\Python27\lib\site-packages\flask\app.py", line 1504, in wsgi_app response = self.full_dispatch_request() File "C:\Python27\lib\site-packages\flask\app.py", line 1264, in full_dispatch_request rv = self.handle_user_exception(e) File "C:\Python27\lib\site-packages\flask\app.py", line 1262, in full_dispatch_request rv = self.dispatch_request() File "C:\Python27\lib\site-packages\flask\app.py", line 1248, in dispatch_request return self.view_functions[rule.endpoint](**req.view_args) File "C:\Python27\lib\site-packages\stallion\main.py", line 118, in index return render_template('system_information.html', **data) File "C:\Python27\lib\site-packages\flask\templating.py", line 123, in render_template context, ctx.app) File "C:\Python27\lib\site-packages\flask\templating.py", line 107, in _render rv = template.render(context) File "C:\Python27\lib\site-packages\jinja2-2.5.5-py2.7.egg\jinja2\environment.py", line 891, in render return self.environment.handle_exception(exc_info, True) File "C:\Python27\lib\site-packages\stallion\templates\system_information.html", line 1, in top-level template code {% extends "main.html" %} File "C:\Python27\lib\site-packages\stallion\templates\main.html", line 33, in top-level template code {% for dist in distributions|sort(attribute="project_name") %} TypeError: do_sort() got an unexpected keyword argument 'attribute'
That's a problem that happens with older jinja versions, try upgrading your jinja2 "pip install --upgrade jinja2". I've to add the dependency on the setup.py.
That fixed it, thanks!
Nice website. Will look into it. Thank you! 
I will. I have 2 major projects build in matlab which will eventually be rebuild into python. One of those is related to genetic algorithms and the other I cannot reveal but involves heavy processing. I was looking for something to do in my personal life for now...
That is planned.
That's not fair, basically OP is just asking how to learn by doing instead of learning from the manual. And before "RTFM", there's nothing wrong with learning by doing, as long as you don't avoid the manual when you get stuck. It's the same argument as people being visual or audio learners; people learn in different ways. As a matter of fact, Project Euler has worked for me fine, but it's far from ideal, and I just can't "learn" a language by working through a book either.
I already know about other languages but at a basic level. Like html, css, c, c# &amp; javascript. Python is a great language and I ve been loving it so far and I'm willing to stick with it. Also because I will not have access to matlab my whole life and I want to avoid piracy.
There's also a bunch of tests normally skipped in Django, because they're for a specific database backend only.
Yeah, you're right. 
At a first glance, the tutorial looks good for me. I see in each chapter code examples. Maybe have a look at [GNOME Screencasts on vimeo](http://vimeo.com/dgsiegel/videos) and [GNOME Developer Platform Demos](http://developer.gnome.org/gnome-devel-demos/stable/) thank you baijum, I bookmarked the link. :)
100x comes from how slow can be a convoluted example that I can provide (read the original post). Believe me, I can provide a pretty convoluted example, but that's besides the point. It'll probably go slower than CPython, how much slower? I don't know, depends a bit what you do, but besides PyPy's interpreter being a fair bit slower, you also need to abort JITting and do some maitnenance related to that. There is no static analysis, but each time you hit it, there is quite a bit of performance penalty to recover from the situation. It's not 0.1%, because you pay quite a bit extra for each time you hit it. To be honest, we never measured, because we assumed that those things happen relatively exceptionally, which means say when you want to run a debugger or otherwise not care about performance at all.
I completalty agree with you. I like project euler but I believe even if I do alll the problems, I will never get further that a certain point. I also started the python challenge and got until the 7 level. This was sometime ago. Need to pick it up again and start over until the end. Also, you're right, I prefer learning by doing but don't avoid the manual. I simply don't like reading programing books.
I'm sorry, but I couldn't detect the joke in your comment. Only sarcasm.
I found and liked ipython ^^ but pythonxy seems interesting too. Since I'm an recently graduated engineer most coding I do is for scientific purposes. But programing is something interesting for me, I like t create.
From [the README](https://github.com/tito/kivy): Introduction ------------ Kivy is a Python library for development of multi-touch enabled media rich applications. The aim is to allow for quick and easy interaction design and rapid prototyping, while making your code reusable and deployable. Kivy is written in Python, based on OpenGL and supports different input devices such as: Mouse, Dual Mouse, TUIO, WiiMote, WM_TOUCH, HIDtouch, Apple's products and so on. Kivy is actively being developed by a community and free to use. It operates on all major platforms (Linux, OSX, Windows, Android). /!\ The main resource for information is the website: http://kivy.org I found it amusing because that introduction has more information than the website does. It's a shame you have to go [into the docs](http://kivy.org/docs/philosophy.html) to find "what Kivy is all about and sets it apart from different solutions".
&gt; 100x comes from how slow can be a convoluted example that I can provide Ok, I see - it doesn't relate to Django, especially, IIUC. &gt; we never measured, because we assumed that those things happen relatively exceptionally Unfortunately, there are some uses of exceptions in Django in scenarios which are not really exceptional, e.g. 404 errors. &gt; It'll probably go slower than CPython, how much slower? I don't know Fair enough: I think we need to wait and see. If it is really problematic in practice, then we can probably come up with a solution which is not too painful (e.g. in terms of reversing those changes relating to calling sys.exc_info() directly, perhaps automatically using a 2to3 or 3to2 fixer approach).
I always work off the server so I never need to deploy. Here's my setup: port XXX1: production port XXX2: development When deploying switch the actual website to point to port XXX2. Start developing on port XXX1, rinse and repeat. Edit: Use github to sync code
That's a good idea and a really polished work. A global check for update would be a great feature. Keep up the good work!
For my information, why are there two separate bindings to Qt that are almost the same? Why is PyQt not, like Qt itself, LGPL? 
Thanks ! Global check for updates is the next feature in my todo =)
PyQt is a binding developed independently. It's not a part of Qt, and it's owned exclusively by the people who authored it, and they chose a GPL license for their work. Nokia eventually decided there needed to be an LGPL binding for Qt in Python. As I understand it they initially approached PyQt's authors to try to convince them to change the license to LGPL. When that failed, Nokia released their own set of bindings, called PySide, and released them under LGPL.
I thought the same thing. Ateast we have one less barrier when it comes to python 3 promotion. 
I see lots of support for QT bindings which is fine for bigger apps. However I'm one that leans towards simple for simple apps. So just use what comes with Python. Note being a step above a command line program I'm not expecting a complex app. Sometimes a minimal interface goes farther. 
The PATH environment variable has everything to do with which version of Python will run when you type "python" at a command prompt.
That's not what bixmix was referencing. If you look at the link, the environment variables he was talking about are ones which affect the already running Python. (I know as well as anyone about the Path situation - I'm adding it to the installer for 3.3 so people don't have to do it themselves and have all of these blogs explaining how)
look into Mongrel2
oh this looks cool EDIT: actually, [doesn't look like they support websockets yet](http://mongrel2.org/static/mongrel2-manual.html#x1-640005.1.3)