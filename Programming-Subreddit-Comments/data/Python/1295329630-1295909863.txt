The problem is that packages, hashes, bless, Exporter, etc. have nothing to do with OO. They're bits of perl hacked together to build something like an OO system. I **could** write an object system in python using modules, dicts, and some special operation for turning those two things into an "object", but why would I do that? That's a hack. I would rather just use a good OO model from the start. The fact that Moose exists means that the perl OO model is deficient. There is no Moose for python (or ruby, etc.), because its OO model was pretty well designed, and easy to extend without requiring major surgery and arcane knowledge. If I want to do some funky MOP type stuff, I don't have to learn a different object system like Moose, I just build on top of the solid OO system that python comes with and everyone else uses.
This is about perl vs. python though, not PHP, so you should be comparing: @a = (@b, @c); With: a = b + c
[MCEdit](http://www.minecraftforum.net/viewtopic.php?t=15522) is written in Python and uses PyGame. I think that is as close to proof of concept as you can get...
I disagree. Say what you want about their annoying recurrence, but debates are useful. Without debates there would be no advance. Without questioning facts of nature, or by being answered "because this is what God did", wouldn't have advanced science, although it would be "the most applicable way to end any nature debate ever".
Installing a JVM and a browser plugin for it aren't minimal setup.
What are your threads doing? Heavy processing of shared memory? Heavy processing of little bits of data? Communicating with a network/internet?
I find the simplicity of C to be elegant. Java is complex but not quite in a way where it offers me the flexibility of something like Python. I personally feel like Java and C++ (among others) live in this land between the simplicity of C and the flexibility of Python, and don't quite compete with either.
Also codepad.org has sandboxed execution of anything you throw at it. These environments are nowhere near relevant to a browser client that sandboxes python. Mackstann's point remains relevant. Even though python is a cooler language than javascript imo, I enjoy the fact the internet has a *single* standard for client side scripting.
I have never once used the browser plugin-based Minecraft. I don't know anyone that has, and I can't understand why anyone would want to. Perhaps my experience is atypical, but based on it, I doubt the success of the game would have been much different.
You'll actually probably want to use pyglet.
Yes, I don't know python well enough to know their array syntax, so used PHP for example. =) . ( Granted, PHP is poor for making an example of )
http://www.skulpt.org/ http://syntensity.com/static/python.html
We're using it for a data processing pipeline. We've got several scraper workers at the front, followed by a verification worker, which passes successful data onward where it is then initially written to the database, and depending on certain conditionals, messages are then dispatched to separate workers to gather and process missing/additional information. The advantages I see with it are that running code is very...compartmentalized, for lack of a better term. One of the benefits would be that if an API used by worker_foo goes down, the rest of the workers will work as intended, while worker_foo's queue grows in size until the API becomes available once more. This is especially helpful when there is not an all-or-nothing relationship between the data and the effects experienced by your users, of your workers processing it fully. Also, it's super easy to scale this up, as well as determine when you need to do so, and with which workers. Just take a look at the queue stats and figure out where the processing bottleneck is, if anywhere, and fire up additional workers processing that queue. On a side project I use beanstalkd on a single server running a web app, with only one worker queue. The web app gets some info from the user, sends it to the api, then does another api hit and some processing on each of n pages of results, where n can be up to 50 or so. Hitting the api is rate-limited to once a second or so. There was a huge time delay when I tried to do all of this before giving a response to the user. I switched to beanstalkd and I now hit the api once when I initially get the info from the user, then dispatch n-1 messages to the worker queue, where n is the total number of pages that need to be read. I've honestly got almost no experience with working with threadpools, so I'm not sure which of these perceived advantages would also be present if I were doing this with multithreading.
you're right. brain fart.
PyCon and Djangocon always conflict with PAX :(
German psychologist Hermann Ebbinghaus coined the term during his research on memory and memorization in the late 19th century. In his 1885 work, *Memory: A Contribution to Experimental Psychology*, Ebbinghaus described his findings regarding both the learning curve, or rate at which knowledge is gained, and the forgetting curve, a related graph that measures how quickly memorized information is lost. His book is considered a groundbreaking work in the field, and quickly led to the popularity of using learning curves as a means of measuring progress.
Certainly. Tangentially related: http://codeflow.org/entries/2010/dec/09/minecraft-like-rendering-experiments-in-opengl-4/
recompile python with oss support. Why don't you use something that works on mac out of the box if someone needs it? (I'm not sure what you're doing but pygame's audio stuff would probably work) Looking at the source I don't see it directly calling ossaudiodev mind giving a trace?
[Eve Online](http://www.eveonline.com/) is a multi-player online role playing game that is written almost entirely in [Stackless Python](http://www.stackless.com/), with a little bit of C in the inner loops. Both the GUI client and the back-end server are implemented in Python, and It has successfully managed up to 100,000 user simultaneously. Edit: Stackless Python was used instead of regular Python because it has microthreads and coroutines, which fit in very well with games that have large numbers of independent interacting objects. I think that nowadays you could do the same thing with [generator coroutines](http://www.dabeaz.com/coroutines/) instead. You could also use [Cython](http://cython.org/) as an alternative to C code for the parts that need to be optimised. 
You could have written it in any language. But some like Java are just more up to the task. Python could for sure. But it would all depend on the skill of the developer(biggest part), and how much tweeking of the libraries you are willing to do. Java is just more suited for full suite programs as that is what it has matured into on the backs of other developers. Python is moving in that direction but has traditionally been used as a scripting language so full program implementation if specialized. Also Python is a little to high level to easily control the stuff that Java takes for granted. So you have to learn to deal with that as well. From past newbie to current newbie. Learn Python now because in 10 years it will be where Java is now as far as stack depth.
&gt; You could optimize your Python version to be more performant than a Java version In pure Python I doubt it, I expect Minecraft has boatloads of numerics-based code for the simulation, which is a sweet spot of JIT and native numbers, neither of which CPython has. If you allow yourself for C or Cython code, on the other hand, then yeah.
You know JIT isn't a magical word you can throw around. Python is 10 years late to Java or .NET. Every language languages is not made for everything. It depends on what is the task. And yes I'm a Pythonista. But not only.
 Load: &lt;type 'exceptions.Exception'&gt;No module named pymedia.muxer Traceback (most recent call last): File "gw.py", line 99, in &lt;module&gt; from main_thirdp import soundmixer_linux as soundmixer File "/Users/me/gw/main_thirdp/soundmixer_linux.py", line 4, in &lt;module&gt; import ossaudiodev ImportError: No module named ossaudiodev 
I guess the question is "could minecraft have been made using *only* Python", but most heavily-Pythonic apps I know are really mixed Python + C/C++ apps. That's how the language was designed to be used: make your edge cases easy, and make your core logic fast. The C/C++ engine + Lua/Python/ActionScript/JavaScript scripting pattern is really common, both in games and in products as big as Google, and I'd hate to call it "only" scripting when that's a core part of the architecture. There're lots of benefits that come from a multi-language system.
File an issue with them.
Well it's not designed for OS X, so it's not so much an issue as me wanting it to do something it currently isn't designed to.
+1: When I was doing Perl programming the weak typing was a big source of irritating bugs. Ditto for the lack of proper exceptions. 
What Python can do that Perl can't? You can actually read Python source from someone else and understand it the first time.
I would say that modules are a win, and a flexible language does not tie itself to initial design decisions. There are many Perl OO systems, and that is actually a good thing, because it encourages people to think about the underlying design of the language, rather than passively consuming a tool.
No, it's actually a plain old unicycle. endtime claims that since all languages are Turing complete, all can do the same things. And given an infinite amount of memory and infinite amounts of time, Turing completeness does make that true. But in reality, Intercal isn't fast enough to run a modern FPS game at decent frame rates. What endtime is saying is equivalent to: It has been theoretically proven that if you pedal a unicycle quickly enough, the amount of energy you release through your pedaling will be large enough to collapse the planet into a black hole. According to science, this should open up at wormhole that allows you to travel to any point in the universe. So a unicycle really has no drawbacks compared to a spaceship, so long as you work hard enough. Therefore, it doesn't matter if you use a space ship or a unicycle for your travels. His statement is factually correct but doesn't answer the question asked and is in every way completely useless.
I don't really understand what you want to do but I think you might want to look into regex parsing. Regex is always the answer.
*There is no Moose for python (or ruby, etc.), because its OO model was pretty well designed* There have been a few Ruby clones of Moose already. For eg. Doodle &amp; classx.
R.E i have done a lot of it, but the case here is not just extraction, but also deriving meanings from those lines. Complexity with R.E Ex: For extraction of worldwide mobile/telephone numbers, its gets very hard!
&gt;Game logic can be run on a separate core. LOL, GIL, WHUT?
It's not just implementation technology, but also language semantics, which affect performance. Looking up global variables in a hash map all the time is never going to be very fast, for example.
this? http://pypi.python.org/pypi/CodeTalker/0.5
Todo * modify codetalker to allow for streamed input 
win32com.client for *GNU/Linux* ?? 
Perl 5 does not have a default OO system. It has a fucking OO petri dish. c. f. perldoc {perlobj, perltoot, perlboot, perltoot, perltooc, perlmodlib and, most of all, perlbot}. TMTOWTDI was always one of Perl's strengths, but imho when it comes to OO, TMTOWDI is one of Perl's weaknesses. I love Perl, but saying Perl has a default OO system is like saying the Bible describes a kind, loving, and all-powerful God. You might be able to find a few sentences here and there to support your opinion, but if you dig into the perldoc you'll see what I'm talking about. Sure there's a default system - but does anyone use it? Not really. It's hardly a default system then. You can even write a "Modern Perl" reinterpretation/testament but that does not change the truth on the ground. 
&gt;A special announcement in the coming days... is what really excites us, and we're hoping it excites all of you as well when we announce it in the next 48 hours. wow
No ... maybe through wine if you're lucky, but not natively. OpenOffice supports python however: http://lucasmanual.com/mywiki/OpenOffice
The expressive power of python is not an issue at all. Neither is library availability - the pyopengl bindings work rather well, and there are also suitable libraries for sound, input, etc. Minecraft is not a very graphics heavy game, so performance should not be a huge problem, though you'll probably have to use the array lib instead of lists of integers for the voxel data. According to the language benchmark game, you can expect Java to be at least twice as fast as Python. Python should still be fast enough for a game like Minecraft. These are the major problems I see with Minecraft in Python: * GC pauses. All current Python implementations have a GC of the stop the world type, whereas there are JVM:s with incremental GCs. Once every few minutes the GC will cause a slight, but very noticeable pause. The only way around this is to disable the Python GC, but that means you have to do some manual memory management work. * No Python browser applets. This one should be self explanatory. 
There is ANTLR for Python.
Can't tell exactly what you want but maybe something like PLY? http://www.dabeaz.com/ply/
*Regex is always the answer.* ... haha.
Screen resolution only affects the amount of work the graphics card must do (not even the driver!).
PyPy?
We already have Jython, which is great and IMHO just about all one could ask for, except for performance. This JSR is about improving the JVM so that it can provide better performance for dynamic languages like Python, so essentially it's about making it possible to solve that last issue with Jython. An excellent (and old!) write-up that gives a good idea of what this is about is [Olin Shiver's proposal from 1996](ftp://publications.ai.mit.edu/ai-publications/pdf/AIM-1576.pdf).
Well...pyglet is using hardware acceleration. And 'rendering' can be as simple as throwing it all at the gpu, which in this case, it was. You run into issues with parallelization with Python, with the global interpreter lock. Additionally, pyglet accesses opengl via ctypes, which is the slowest way you can interface with a library in python. I'd say you could make a minecrafty game with python/pyglet, and you could make a passable clone with cython/pyopengl.
same result here. it's a pain to build on windows, lib path are hardcoded in the makefile. It's also a pain to install on [MacOS](http://simonharrison.info/talk/mac-os/pgmagick-on-mac-os/).
Which Python 3D engine are you comparing to?
[antiword](http://www.winfield.demon.nl/) then, and [pdftotext](http://www.foolabs.com/).
I wish iPython has bash style history. E.g. $_, !!, et el
I agree with you! I didn't say it was impractical, I was only stating a conditional, to better explain what kvsn was getting at a few posts above. =)
Natural language parsing? If so, you should start with [NLTK](http://www.nltk.org/).
&gt;This is disingenuous, though. Perhaps "poorly defined" would be a better word than disingenuous. As you point out, many of Python's libraries use lower-level extensions. It would be good to ask the OP to clarify exactly what "using only python" means in this instance. Perhaps they meant "only pure Python and any of the standard libraries". On the other hand, perhaps they meant only that they wouldn't have to write any C code themselves, but using a library like Numpy would be OK. Or, perhaps using the extension module system would be fine, too - but unless OP chimes in and lets us know their original intent, we're just speculating. =)
pdf : [pdfminer](http://www.unixuser.org/~euske/python/pdfminer/index.html)
What about the pyglet bindings to opengl? They were made to get good performances.
It is if you don't really have to lookup because the name may always point to the same variable in the loop. That's the kind of optimization that a JIT can do.
&gt; a flexible language does not tie itself to initial design decisions Agreed. But isn't it nice when the initial design decisions were good? Or if the initial design decisions were lacking, that they were corrected within the language? &gt; it encourages people to think about the underlying design of the language, rather than passively consuming a tool You could apply this argument to other things, e.g. I should do my own memory management because it encourages me to think about the underlying design. I can think quite a bit about the underlying design of Python without having to rewrite its core functionality, especially because its designs make sense and are easy to extend.
This is so much better than the comment I was going to write which was just "yes" but I'm tired and lazy :D
Panda3D is a pretty good Python graphics / game engine (although underneath it is written in C++). You should probably use that rather than rolling your own solution. You'll get much better performance.
I can read my Perl code from 5 years ago because from the start I decided to write it that way. The programmer is responsible for how readable the code is regardless of the language. Every language allows you to shoot yourself in the foot, some are just easier at it than others. Doesn't take the responsibility from the programmer.
You can read python code, that's a start.
Hasn't Jython effectively been stagnant for quite some time now? They still haven't moved past 2.5.2 compatibility.
Python’s new life already started — we call it PyPy.
 def get_txt(f): output = subprocess.Popen(["lesspipe", f], stdout=subprocess.PIPE).communicate()[0] return output works for me.
OK, ok, coolness factor of a language doesn't seem to be a selling point here, I've been downvoted straight through the ground to Australia. ;-) From a slightly more factual point of view, the bindings to application frameworks like Qt are in a pretty damn good shape. PyQt is nothing short of awesome (mature, well thought (see new API design), very well maintained) and the new PySide project is stepping up to the community counterpart with API compatibility to PyQt. I'm not aware of an equally active Perl binding project. Maybe some Perl-guys can provide more information on GUI-framework bindings?
Or, in the case of assembly language, it may take several lifetimes to write code to do poorly what a higher-level language can do very well in one line. It works the other way, too; Python and the assembly language used in a Renesas 4-bit microcontroller are both turing-complete, but only one can be used to write useful programs that work when there are only 4096 10-bit words of ROM and 256 4-bit nybbles of RAM available.
The power set of the [empty set](http://en.wikipedia.org/wiki/Empty_set#Properties) is a set containing only the empty set --- not two instances of it as this will return: &gt;&gt;&gt; list(powerset([])) [[], []] 
&gt; Some people, when confronted with a problem, think “I know, I'll use regular expressions.” Now they have two problems. --Jamie Zawinski &lt;jwz@netscape.com&gt; wrote on Tue, 12 Aug 1997 13:16:22 -0700
The point was Turing-completeness equates the abilities of any two Turing-complete languages. Brainf*ck is Turing-complete as well, so Python=Perl=Brainf*ck using this argument. The humor from the statement stems from the complete ignorance of issues of speed, syntax, etc.-- the stuff people actually care about. Next up: vi vs emacs-- They both create, edit and save text files!
Every so often these discussions come up concerning which programming language is best. The following should clear up any confusion. The best programming language is, of course, the BEST programming language. BEST is a programming language that I developed to answer the frequently asked question "Which programming language is best?" once and for all. BEST is an RFC2795-compliant Befunge-93[2] pseudocompiler written in x87 Malborge[3][7] with library calls to routines written in Microsoft[4] Visual BogusFORTH++[5] (!Kung edition)[9] that invoke various functions written in[6] Reverse Polish Whitespace[1] (for clarity). It requires the GLaDOS operating system or RUM emulator. I hope this helps... References: [1] http://compsoc.dur.ac.uk/whitespace/ [2] http://catseye.tc/projects/befunge93/doc/befunge93.html [3] http://www.lscheffer.com/malbolge_spec.html [5] http://www.tlc-systems.com/babbage.htm [4] http://www.cantrip.org/nobugs.html [6] http://zapatopi.net/blackhelicopters/ [7] http://www.lscheffer.com/malbolge.shtml [7] ftp://ftp.freebsd.org/pub/FreeBSD/ports/distfiles/malbolge.tar.gz [9] http://en.wikipedia.org/wiki/!Kung_language ]~[ http://zapatopi.net/afdb/ [Q] http://www.ietf.org/rfc/rfc2795.txt 
[Itertools Recipes](http://docs.python.org/library/itertools.html) has a powerset too: def powerset(iterable): "powerset([1,2,3]) --&gt; () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)" s = list(iterable) return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))
I came across [openxmllib](https://code.google.com/p/openxmllib/) while researching for a related project. I wasn't able to make use of it but it parses .docx natively in Python.
try googling for that phrase, you'll notice immediately that its a C++ joke
not working for me, running in the same directory as my pdf get_txt('test.pdf') OSError: [Errno 2] No such file or directory 
thanks i'll check it out when i get to docx files!
&gt; The programmer is responsible for how readable the code is regardless of the language. To take an extreme example - python is vastly more readable than assembly Or - python is vastly more readable than java - if you're not using a custom-configured IDE environment OR - python is vastly more readable than perl - unless you spend the time to define standards in perl and then the time to test that they're being followed. Having a million options is great when you're a single person working on your own app. Having a million options is not great when you've got a team of a dozen people at a time, maybe 40 over ten years supporting a large application.
MCEdit is a 3d application, and as such would preserve field of view. I.e. switching from 100x100 to 900x900 would mean that your objects are now 90x90 pixels, rather than you can somehow see more objects. (this is not strictly true, since switching from 1:1 to 16:9 aspect ratio would increase horisontal FOV by some 50% (due to perspective distortion), but that's much less than what you mistakenly expect).
Install less/lesspipe
My bad.
Yes, of course, but it's difficult to prove in Python that the name always points to the same variable. def my_fucked_up_function(foo, val): globals()[foo] = val def my_jittable_function(whatever): for x in range(whatever): my_fucked_up_function("foo", foo * 2) Now where is your JIT? Like I said, language semantics matter, because they limit what assumptions your JIT compiler can actually make. Language semantics is a major part of why PyPy doesn't produce code that runs at the same speed as the Java JITs. The way global variable references work is obviously just one part of that.
nltk?
I'm perfectly happy for Jython to be semi-stagnant, I must admit. It's great the way it is, and I don't use new language features in Python until 3-5 years after they're introduced, anyway. In any case, JSR 292 is going to do nothing to make Jython less stagnant.
&gt; c. f. perldoc {perlobj, perltoot, perlboot, perltoot, perltooc, perlmodlib and, most of all, perlbot}. Even if your implication were true (that each piece of documentation you named described a *different* object system), each of those object systems uses the same few fundamental primitives provided by both Perl 5 and Python's default object systems. &gt; Sure there's a default system - but does anyone use it? Outside of a fair few people who've written object systems in Perl 5 which avoid bless, method dispatch, and the package-is-a-namespace-is-a-class mechanism (and I'm one of those people), everyone who uses an object system in Perl 5 uses the default object system.
&gt; Having a million options is not great when you've got a team of a dozen people at a time, maybe 40 over ten years supporting a large application. What if you had coding standards like you have to have in Python already? (Python's parser only governs indentation in the small, not consistency of indentation over a large project.)
&gt; I could write an object system in python using modules, dicts, and some special operation for turning those two things into an "object", but why would I do that? That's a hack. I would rather just use a good OO model from the start. Barring the superficial syntactic element of `bless`, that *is* Python's object system.
&gt; If a function decorated as being single threaded was executed *within the context of a second thread*, a runtime exception [..] would be logged. How do you find that out?
&gt; Python has strong typing where Perl has weak (like C). Perl has *operator* typing, not value typing. &gt; I've seen many people use Perl eval for exception handling (as it lacks throw/catch) Perl 5's `eval` STRING and `eval` BLOCK are different mechanisms. The former parses and executes code at runtime while the latter catches exceptions. The latter should have been spelled `catch`.
TIOBE couldn't differentiate between a web browser and a programming language for over a year. Roll those dice.
Improved and even simpler version of this posted [here!](http://program-nix.blogspot.com/2011/01/simple-countdown-progress-bar-remake.html)
&gt; I wonder if there's a way to make Perl crash and burn at runtime as well. You can have Perl promote any runtime warning category into an exception.
Jython's been languishing because there just aren't many people working on it. Its recent gains were because Sun hired some folks to full-time just on Jython, but Sun laid them off a couple years ago. JSR 292 will make "eval" much faster in Jython. It won't make Jython more popular / attractive / current.
Of course you can design complex unoptimized algorithm that use the namespace of python to produce a result. But the thing is most code isn't written like that. Usually it is obvious which names may have been defined and where they could have been. If you want me to analyse your particular case it is not that hard. Let's assume foo is define so that calling my_jittable_function will not simply crash. The compiler could see that my_fucked_up_function is only called with "foo" and use a pointer instead of the string "foo" to get to the variable. Of course if you call my_fucked_up_function with some kind of input as its first parameter you're screwed, you'll have to recompile all your functions after the call. 
Corrected and reviewed my overview. Thanks for the explanation.
My version of Python's documentation has another one: def powerset(iterable): "powerset('ab') --&gt; set([]), set(['a']), set(['b']), set(['a', 'b'])" # Recipe credited to Eric Raymond pairs = [(2**i, x) for i, x in enumerate(iterable)] for n in xrange(2**len(pairs)): yield set(x for m, x in pairs if m&amp;n) 
&gt; most code isn't written like that Right. So a JIT that produces misbehaving code now and then is OK? &gt; If you want me to analyse your particular case it is not that hard. Write an optimizer that does what you just described, and you'll be famous. It *is* hard. Much, much harder than you think until you've tried it. (Of course, something as specific as what you described isn't hard, but it needs to be much more general, so that it works for most code, and not just for this trivial example.)
Can it paint my house?
Could you write it in xml?
What's the use case for wanting this? I'm not putting it down, I just can't remember when/if I've ever needed this.
I know of at least one person who has Django in production on PyPy.
pyPDF http://bit.ly/fFNMnV . I have used it for basic python processing and works well in most cases and If I remember right it is a pure python implementation too.
neat. Not really sets, though (elements in seq / yielded outputs are not necessarily all distinct).
Sometimes puzzle solvers use this kind of stuff... I wrote a kakuro solver a while ago that needed the permutations and combinations functions to generate lookup tables. Mostly useless, but fun!
No problem, thank *you* for the overview and the post. I'd never heard of Beets before, and it looks fantastic. Exactly the kind of thing I come to Reddit to find.
The use case that comes to mind would be any brute force graph searching algorithms. In this example, if you had a graph and you wanted to search its subgraphs, you'd use the powerset of the edges. This is a required starting point for many algorithms, but you generally try to avoid searching the entire powerset. If you can lazily calculate the powerset using a generator you can save on a lot of initial overhead.
&gt; Right. So a JIT that produces misbehaving code now and then is OK? Nah, misbehaving code would just make it very slow. &gt; It is hard. I agree with you on that. And sadly this hard work is now starting to get done in javascript instead python.
In case anyone wonders (I'd totally forgotten about this): use warnings FATAL =&gt; 'uninitialized'; 
As far as I know, PyPy has a backend targeting the JVM. Would using this new JVM feature allow this backend to generate more performant bytecode?
So, what is the website address?
[The missing link](http://blog.aclark.net/2011/01/18/new-website-for-2011/)
It's great when there is a sensible default, and while perl got some things right off the bat, OO probably isn't one if them. But then again, I still like the ability to retro-fit the language as I see fit. Perl's essential looseness about what exactly an object is (at heart little more than a reference and a namespace) means it is at least possible to have several interoperable object systems, where the user doesn't have to care which one was chosen. In most languages the object orientation is fairly fixed, and of the parts where additions seldom appear. Ruby's module/mixin system is at least an acknowledgment that no designer can foresee every use case.
How you are getting upvoted is beyond me. Sorry you don't know how to do it.
You can use python to program a robot to paint your house. Here is some code that I hope will help you get laid: [activestate](http://code.activestate.com/recipes/577403-more-sex-is-safer-sex-paradox/)
Ok, so my point was that it could be parallelized and made to run on a separate core. You can do this. The GIL isn't the show stopper you seem to think it is. I am irritated that you say that you have made something similar, then make an unfounded statement that it might have been too slow had you implemented x,y,z. You masked your lack of knowledge, yet you actually got this many upvotes. Nice trick.
Hello, can you explain how Eve Online was coded to me. kthx You wrote a lot, but don't seem to know a lot.
Congratulations! You've completed a sophomore level CS exercise!
Wait, Plone is a technology nobody knows about? &gt;Plone's development team has also been ranked in the top 2% of the largest open source communities. -Wikipedia
As soon as you'll start working on that. These are not things that happen on their own, they need commitment. If you don't have time, there are people who you can pay to do that.
I have used [PyUNO](http://wiki.services.openoffice.org/wiki/PyUNO_bridge) On a number of projects working with Excel/Word files. 
The fewer people that know about buildout, the better. Use Chef + pip + venv for a far far far far better solution.
When my Grandpa died it was a time of sad reflection but what made matters worse is that my inheritance came with strings attached: to get my dues I had to spend a night in .Doc Manor, a spooky old house of weirdness and quirks (some intentional, some unintentional). Although the skinny neighbourhood kids who loitered around the library carpark bragged that they'd made it through the manor they couldn't tell me what colour the 1995 carpet was, or what the photos of Wilfred Matthew Frankel or Elanor Mildrid Frankel looked like. They even talked about snakes and a --headless horseman which I guess means that they walked through the building with their eyes closed. I arrived that evening with my sleeping bag to find that house was falling apart except for a single room. The office door was left ajar and inside was a clean wood-walled control room with levers and cranks and switches. The rumoured photos weren't photos at all, but pencil drawings. Security cameras let me observe the rotting or caved-in walls in the rest of the house. I didn't sleep at all that night and as soon as the sun came up I left the dilapidated manor, never to think of it again until today. tl;dr: Use PyUNO/PyODConverter w/ LibreOffice/OpenOffice if you want software that understands the vagaries of the .doc format. Don't believe the claims that other libraries are as sophisticated.
I don't know if this is the best method but you can always use the string function 'replace' to simply remove all the "=\n" instances in the text: new_text = text.replace('=\n', '') # second parameter is two single quotes
the ultimate source. http://www.regular-expressions.info/
I learned regex by reading "Learning Perl" by Randal Schwartz. It has three chapters (totaling ~40 pages IIRC) over just regex. I highly recommend it as it's presented in a very accessible way. Edit: [Link](http://books.google.com/books?id=lNVHi3TunxsC&amp;printsec=frontcover&amp;dq=Learning+Perl&amp;hl=en&amp;ei=jCY2TZaXFJGcsQOhg9SGAg&amp;sa=X&amp;oi=book_result&amp;ct=result&amp;resnum=1&amp;ved=0CC0Q6AEwAA#v=onepage&amp;q&amp;f=false)
[Here](http://docs.python.org/library/re.html) is a good place to learn about Python's regex implementation. If you're trying to pull hyperlinks from your email text, you can use something like this: import re regex = re.compile('http://[^ ]*', re.DOTALL) Don't use that pattern though, it's not a good one... Anyway, you can then use the regex object to do all kinds of useful stuff. It's all there in the documentation I linked. 
To clarify, even when throwing everything at the GPU in batches for rendering, adding collision detection, game logic, pathfinding, etc - which I did - caused unacceptable performance. It was like falling off a cliff. I did not attempt to parallelize on multiple cores, and that is something I've never attempted with python. However, the performance penalty for deviating from batch rendering - due to the ctypes interface, and the performance of python for the other processing necessary to make a minecraft clone would definitely push the boundaries of what is possible. The question was could Minecraft have been made using ONLY python. I tried to express that the major challenge would be performance, not capability.
It's not a regex problem, it's an email problem. Check the Content-Transfer-Encoding of the message body and decode it appropriately first. There is an [email parsing module](http://docs.python.org/library/email.parser.html) that will do this for you. You can't just replace('=\n', '') because that will fail when the C-T-E isn't quoted-printable. Source: myself, I wrote a mail-to-web gateway for mailing lists.
&gt; Perl has operator typing, not value typing. It's the first time i've heard of "operator typing" and Google does not want to come up with a good answer. &gt; Perl 5's eval STRING and eval BLOCK are different mechanisms. The former parses and executes code at runtime while the latter catches exceptions. The latter should have been spelled catch. Even then, it just puts a string into $@ so you have to be checking the output of this string to see if **your expected** exception was raised and reraise manually if it's not the expected string.
Mastering Regular Expressions is an excellent book.
[Here](http://code.google.com/edu/languages/google-python-class/regular-expressions.html) is my favorite python-specific regex tutorial. It's not comprehensive, but it's short and to the point.
Game logic _can_ be run on a separate core, it's just that stock Cpython makes it a pain in the ass to do so because the GIL forces all your threads onto a single core. That's why I got up votes, because it's easy to write, "run on separate core," but very difficult to actually pull off in an efficient manner. 
Yeah it is, I just wanted to do it with the least amount of overhead possible. I'll probably just load the entire mail into a buffer and do what taybul said and just pulling the links after. thanks for the help.
I didn't see this posted yet. Check out [http://pythonregex.com/](http://pythonregex.com/) for a test-in-browser tester that's pretty neat. Good luck!
Yup thats exactly the problem, I was just hoping I can do some quick regex and not bother onverting it all and text.replace()'ing it. the problem is that it will do that for all of the lines rather than just the one I want. and just be a little slower. =/ I really dont want to convert it either.. so much overhead =x oh well, guess i have to do one of the two things thanks for the info.
i thought about doing that but that means that it would do that for every single line, which is just going to slow it down (however negligible)
Thanks! I'll look at it soon
&gt; It's the first time i've heard of "operator typing" and Google does not want to come up with a good answer. Where operators such as `+` may be polymorphic in various languages (concatenation when applied to strings, integer arithmetic when applied to two integers, floating point arithmetic when applied to at least one float), Perl's operators are monomorphic. That's why `+` is always numeric and `.` is always stringy. Every Perl operator imposes a type context on its operands. &gt; Even then, it just puts a string into $@.... Perl certainly allows the use of exception objects. `$@` contains the single operand provided to `die`. It's much safer to throw an exception object than a string, though few people do so. Performing pattern matches (or worse, exact substring matches) against exception strings is far too fragile for larger programs. I agree that it's a shame that too few programs use the more robust mechanism for reporting errors.
C is simple when dealing with simple data. But when the data gets complex, OOP is needed to keep things manageable. 
Not sure why this is being downvoted. The code isn't going to write itself.
PyGLet requires Python version 2.5 or 2.6, so if you are set on 3.x this is a no go. I personally like it and am willing to stick with it because it is so lightweight and natural to program in.
Moose provide much more than Python OO system
Plone sucks imho.
[pyparsing](http://pyparsing.wikispaces.com/) is fairly intuitive. You define the grammar through composition of regular python objects. It has built-ins such as 'Word' and 'Optional' to get you started. You can also define actions to be executed when the parser encounters a particular token. Pretty cool stuff, and it's all packed in to one .py file so it doesn't take much to get going. 
It's being downvoted because OP did not ask for fucking attitude. I am pretty sure that OP is aware that the code is not going to write itself. All he wanted to know was if such an effort was in the works. If you know there is one, then say yes. If you know that there are no plans, then say no. Otherwise it's best to just STFU.
yes, i know the code is a bit eccentric (well, maybe ugly is a better description!), it was an experiment... mainly looking for interface comments and suggestions for improvement...
Damn. I use Python 2.7, which it also doesn't seem to support :(
it should work with 2.7
Preparing the data for regex parsing might create less overhead than trying to regex for anomalies. (Some people have already provided good answers in this thread.)
The answer is really all of the above. We are processing a fairly large, constant amount of data coming in off a bus from a vehicle. We also interact with sockets over several interfaces, GPS, and several other external sources of data. In addition, we need to persist objects to flash periodically or on-demand in response to user/system actions.
I used pyglet for a couple projects and I really liked it. I have not used PyOpenGL so I cannot make a comparison. 
We would like have the decorator active (actually decorating the decorated function) in a develpoment/debug environment. The idea would be to have a collection where keys existed for each decorated function (hashed on id of the function perhaps), when the decorated function is executed we would check if the current thread of execution matches what is in the collection... If not, we log or crash, noting which threads of execution executed the function and which function was being executed.
A good part of the system is using bastardized actors. Much of the code has been inherited and the initial principles put in place by the architect were slowly hacked away by various developers over time. I really like the ideas behind the actor model. We are looking to refactor or rewrite some of the worst parts of the system. Part of the motivation for adding, basically, concurrency assertions would be to help enforce isolation constraints. Some of the concurrency models are nice but require features of python &gt; 2.4 (this is the version available to us on the embedded platform we target).
Why isn't pygame on your list. I've never even heard of PyOpenGL until recently.
In the same spirit but with without focusing on any specific language there's http://gskinner.com/RegExr/.
Maybe get a hacky version working first with encoding done properly, albeit slowly. Then, if that actually turns out to be a bottleneck, optimize. By the time you have a working product/module you might have found a solution better than hbar suggests, or the regexes you look to today.
Regular expressions are much, much slower than string operations. If you're not parsing complex text or working on something that varies, string operations are what you should be using.
PyOpenGL is nothing but a wrapper for OpenGL itself - no sound, no window management, just 3D graphics. pyglet does a lot more than PyOpenGL; it includes window management, sound, video, etc etc. Choosing between the two depends mostly on your application's needs. PyOpenGL's API is more pythonic, so it's easier to learn with nicer, clearer syntax. pyglet's graphics API is closer to OpenGL's, and requires you to be at least passingly familiar with ctypes. But, because pyglet's API is 'closer to the metal', it can perform significantly (1.5x, 2x) better than PyOpenGL. PyOpenGL plays very well indeed with PyQt via PyQt's QGLContext. I don't recommend combining pyglet with PyQt, since there's a ton of functional overlap between the two. Pick one UI framework &amp; use it. Both PyOpenGL &amp; pyglet should work fine with 2.7. Both do indeed suffer maintenance &amp; upkeep issues, but I'd believe pyglet is better &amp; more actively maintained than PyOpenGL. Also note that you can actually use PyOpenGL along with pyglet, as a drop in replacement for pyglet's own graphics API. tldr: pyglet &amp; PyOpenGL are different tools for different jobs. Consider your application's needs when choosing.
Google apps for Business is _awesome_ and there are great python libraries for gdata. I assume that there are specific contacts for education, as well as discounts. 
Not that much slower. But you are right.
superb! I use regex a lot at work. looks like it will come in handy. Thanks for the link!
Well if you can break out the data somehow, so that you don't need a lot of shared memory, it might be worth considering a cocktail of **zeromq** and **eventlet**. So you use eventlet to drive things, it's sort of like threads, except you don't have to worry too much about locking, the GIL, nor the other headaches of threading, and your "green thread" won't be triggered as long as it's waiting on io (e.g. sockets), so you're not waiting resources spinning in the mud, waiting for a socket. And then you could put together a bunch of child processes that talk to each-other with zeromq. The other great part of this architecture is you can throw hardware at it for scaling whenever you need. Consider also **redis** as a data store / common memory, it's crazy fast, and can be chained up to handle load balancing. These are my new hammers, and perhaps all I see are nails. I like to use and abuse them, but I really find they work marvelously well and fit a wide swath of problems.
I don't mean to be rude, but that is a rather nonsensical question. To state something obvious: python app are run on a user computer by the interpreter of the user's choice. With the caveat that some apps may use features available only on a given Python version, the interpreter could be CPython, Jython, PyPy, IronPython, ... 
They are similar in the same way many object systems are similar. The details of the two are what's important. How do you get the method resolution order of a class in perl? How do you do it in python? Like this: &gt;&gt;&gt; bool.__mro__ (&lt;type 'bool'&gt;, &lt;type 'int'&gt;, &lt;type 'object'&gt;) What makes more sense for overriding lookup on an instance, `AUTOLOAD`, or [\_\_getattr\_\_](http://docs.python.org/reference/datamodel.html#customizing-attribute-access)? (or [method_missing](http://ruby-doc.org/docs/ProgrammingRuby/html/ref_c_object.html#Object.method_missing) in ruby) How do you use a metaclass in perl? Here's how you do it in python: class X(object): __metaclass__ = MetaX How do you create a static method or class method in perl? In python, it's [staticmethod](http://docs.python.org/library/functions.html#staticmethod) and [classmethod](http://docs.python.org/library/functions.html#classmethod). The OO vocabulary of python is much more rich than what perl provides. That's why Moose was created. It's also why perl 6's OO was redesigned. The fact that it's possible to do some OO stuff in perl5 is totally different from perl's OO model being good, or being similar to Python's.
Not directly relevant to the question, but helpful none the less: stay away from glBegin/glEnd and go with VBOs. Also spend time learning the programmable pipeline (shaders, OpenGL 2.0) you can produce results practically unachievable with the fixed pipeline, but realize that even today not all graphics cards will support them (namely netbooks running linux drivers) so have a fall back available. If you haven't found it already this [modern OpenGL tutorial](http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Table-of-Contents.html) it is a great start, but as of writing it is unfinished and looks to be down right now. It is a good starting point, covering the basic theory well and transitioning into usage. Looking over the [github repo](https://github.com/jckarter/) namely ch4-flag and ch5-flag should be a good enough start to get the gist of what you need to be doing for OpenGL 2.0, just make sure you reference the OpenGL docs for the calls you don't understand. Good luck.
I want to extract the **headings** from doc/docx/pdf is it possible ? 
If it's specifically regular expressions you want to learn, [this book](http://www.amazon.co.uk/Mastering-Regular-Expressions-Jeffrey-Friedl/dp/0596528124/ref=sr_1_3?ie=UTF8&amp;qid=1295408986&amp;sr=8-3) is fucking awesome. But Schwartz's book is very good too.
I didn't say that Python's OO provides more than Moose. I said that Python's core OO is better designed than perl's. However, Python's core OO functionality certainly provides a good chunk of Moose's features, without the need for a third party library.
There is a py3k branch in the [Sourceforge SVN repo](http://matplotlib.svn.sourceforge.net/viewvc/matplotlib/branches/py3k/), but nothing much is going on. 
mathematics. although, I don't really do any thing that would require this either.
I want to stress the... &gt; you can actually use PyOpenGL along with pyglet Pyglet handles all of the init stuff brilliantly, and with one line of code gives you a pretty frame rate display. Then in the drawing loop use PyOpenGL's glBegin() and start throwing geometry at the display. The cool thing about OpenGL, is it doesn't need a handle, like almost every f***ing API Microsoft does, so it doesn't matter "who" is sending OpenGL calls, they all go to the active context. You can very literally use a pyglet glBegin, some PyOpenGL glVertex calls, and finish it off with a raw C glEnd(). The things to keep in mind... * PyOpenGL makes the OpenGL calls more friendly with python. It just makes sense. * pyglet gives you useful "game" type things, like setting up your window, handling input and signals, one line frame rate display. Yes you can make code that uses only one or the other, but using both is just so damned easy, and really quite a joy. edit: binding OpenGL into GUI toolkit is... well the way I put it is... "It burns, it burns!". The setup is the bit that hurts, because you have to make sure you get all of your signals through your parent window. pyglet's main feature is that it takes care of that shit for you, so using Qt will render large portions of pyglets awesomeness irrelevant. If you're making a tool that uses Qt for widgets, and has an OpenGL window that displays the foo that you're interacting with, you're going to have to learn enough 3d maths (matricies, trigonometry) to make heads and tails of [gluUnProject()](http://pyopengl.sourceforge.net/documentation/manual/gluUnProject.3G.html), for which I strongly recommend you get your hands on a copy of the [Red Book](http://www.opengl.org/documentation/red_book/) and read its chapters on perspective transforms. Using an OpenGL native widget toolkit may be easier. edit edit: [gluUnProject()](http://pyopengl.sourceforge.net/documentation/manual/gluUnProject.3G.html) is for when you what find the point nearest to your click, if you just want to click on an object, check out [gluPickMatrix()](http://www.opengl.org/sdk/docs/man/xhtml/gluPickMatrix.xml)
I'm not talking about syntax. &gt; It's also why perl 6's OO was redesigned. I was in the room for those discussions, yes.
Come on. Of course you could, if it was read by a parser in a programming language. XML is a markup language it is not the same as a programming language. But I like your sarcasm, very pythonic old chap. 
Did you use Numpy for your arrays? There are so many different ways to optimize with Python that I still feel your claims are simply due to your chosen methods.
Really? Seems pretty streamlined to me. I've never seen "Click here to install PyGame"
By adding the word efficient, you can say that it is difficult. I have written some Multiprocessing applications that share memory. Yes, the taboo oh no! I've also tried it with message passing, and it worked pretty well, though I wouldn't do it like that in this case. I'm sorry it is so hard for you, to me it is considerably easier than programming a game in the first place.
This is relevant &amp; useful info for a graphics neophyte because PyOpenGL is [deprecating glBegin/End.](http://pyopengl.sourceforge.net/documentation/deprecations.html). There's a ton of intro tutorials out there that cover display lists, but display lists should not be used for new code. Learn VBOs.
Yeah, all these tools sound good but they aren't a particularly good fit for the environment we are working on. We are running python on a semi-embedded platform where we have a limits on computing power, memory usage, and storage. In addition, there is no good way (with the current iteration of the product) to add in our own (or third party) cpython extensions. We do our best to make use of the reactor pattern, having resources providing fileno() so that can be selected on via calls to select (which is supported and very efficient on the platform). Eventlet looks nice but is probably a dependency we wouldn't want to add in at this point -- does anyone know of a similar library based on select that would work with python 2.4, doesn't require epoll/libevent, and has a small footprint? If anyone is curious, the platform is the following (full disclosure: I work for Digi): http://www.digi.com/products/wirelessdropinnetworking/gateways/connectportx5.jsp 
It's not just PyOpenGL, the OpenGL spec itself has deprecated the entire fixed function pipeline. Most tutorials only cover fixed function stuff and mention the shader pipeline as an "advanced concept", which is a bit irritating. 
Nice. I'd just add that PyOpenGL + PyQt works similarly: create your UI and GL context in wonderfully simple PyQt code, then whenever you want to draw 3D stuff, activate a GL context of your choice and draw away with PyOpenGL. The only difference is PyQt has no OpenGL API of its own. So really, to me the question should be: learn PyOpenGL + pyglet, or PyOpenGL + PyQt? And that's only answered by the desired type of application (game vs. general UI-heavy app).
It wouldn't be any more strenuous than using regex on each line. In fact, I think the text you're getting is considered one large string so they're not lines, per se, but simply a large text containing newline characters. 
Namespaces - you're doing it wrong. Replace: 'import OpenGL' with 'from OpenGL.GL import *'. Usually, 'from foo import *' type imports are bad, but the OpenGL API comes from C, and everything in it starts with 'gl' or 'GL', so name conflicts are almost non-existent. Also, it's GL_LINE_SMOOTH, not GL_LINES_SMOOTH.
Use the email module. Overhead of dev time + debugging &gt;&gt; overhead of a few string ops.
I only glanced at the code, but two things stood out to me: 1. Use a class as a namespace instead of using global variables. I know, it's Python, and we're too cool for that Java OO Astronaut Architect crap, but sometimes classes are OK. 2. In the `if __name__ == '__main__':` part, you have an `except: # in the event of an error, restore the terminal to sanity` which repeats what you just wrote in the regular part. You can use a `finally` instead and not repeat yourself. 
Or as we liked to call it on the qmail list, quoted unprintable.
The overhead should be trivial no matter what regex approach you take whether in perl, python, ruby, or sed. It's pretty trivial once you get the content-transfer-encoding to confirm it. The message headers will usually be in a separate buffer/variable/stream before you parse it in a sane library/framework for email parsing.
oh yeah i know, its just a dumb project i am working on to see how fast i can get it working.. i got a hacky version working w/ sed &amp; awk, but really its slow in comparison to what it can be.
Go [here](http://www.youtube.com/user/derekbanas#p/search/2/DRR9fOXkfRE) this guy has some great Python tutorials. He explains regex so they are easy for newbies. Look at the rest of his stuff as well Derek Banas of newthinktank.com. I used to follow his python stuff religously. He has a bunch of other stuff. Shout out Dereck from gent2910. He is a wizard and I am sure he will find this post. 
yeah but for what I am doing i need more than basic string operations. i do string operations to cut out everything outside of the boundary lines.. maybe i will recode it for just string operations though I want it to be able to be dynamic in collecting the links and not needing me to keep giving it values to look for.
Oh sweet, I haven't played with them together. I've done some GUI toolkit + opengl stuff, and it's invariably more painful that it should be, but I should've expected that the Python folks have taken care of the messy bits by now :-)
A small remark on the regexp being slow: [take a look at this thread on stackoverflow](http://stackoverflow.com/questions/3411006/fastest-implementation-to-do-multiple-string-substitutions-in-python). It's not *that* slow, it seems.
just watched some of it, its pretty nice, thanks.
Noob. Great question. Only one way to find out. Download and try out one of them. Seriously no sarcasm intended. You will see all these masters with post trying to give advice but you know how they learned it. By using it. For reals homey. You have to see it in action to understand what they are talking about. They are just tools to help out with implementations of other languages while using python. You could think of it as if you were a Java programmer but you wanted to try to use python. Of course you are more versed so you would get something like Pava(made that up). That way you could do things with python without leaving your comfortable knowledge of Java. I could fill a freakin book on the topic but the only way to try it is to get it and tinker then you get the feel for what they are trying to do with Jython, Cython etc. But first and foremost learn Python. You will know when you need these tools and if you are a noob then it may be awhile so dont get to hung up on tinkering. One word of sage advice. Download and install as much of every python module and derivative you can and start to build a master python portal of hell. Just by trying to get the stuff to work you will graduate from noob to semi-noob, cause the stuff ain't always easy to get to work. 
No, OP is asking for estimates on how much time it'll take for open source software to do what he wants it to do. Sometimes there are good answers, most of the time there are no good answers except "you can do this to help". This is a very annoying attitude for an open source guy.
AFAIK, you don't even have immediate mode in OpenGL3 (or OpenGL-ES, for that matter). The sad part is that all of the various OpenGL tutorials out there use immediate mode, and there's very few that talk about VBOs and such.
SDL (which pygame wraps) handles everything except OpenGL - although it will setup a context for you, and load textures (with SDL_image). If you want 3D you have to go through pyglet or pyopengl to call the relevant functions, since SDL doesn't deal with OpenGL directly.
Also, have a look at Kodos. This little desktop app will let you debug your regex. It's nice to have when you learn it: http://kodos.sourceforge.net/
Ah yes, that does change things immensely. It seems to me that you don't have very many options if you can't add cpython extensions. Hrm, well good luck!
I'm curious if you could contrast the difference between vanilla python and stackless python some more? As fas as I know vanilla python can implement generators and coroutines? Clarification would be appreciated!
A half-assed implementation is always worse. You'll get clients that do silly things that you need to deal with that a full implementation would handle easily. You'll end up putting more and more hacks in until you've spent a buttload of time reimplementing a module in an inferior way. 
A truly decent implementation won't be any slower than string replace.
http://www.txt2re.com/
Kind of strange, think about it. Why isn't python a runtime environment that you can click and install to run applications in the browser? Nobody ever implement such a feature? It would have to be sandboxed and adapted to the browser setting, but it could be interesting... Though personally I like the limits there are between desktop apps and browser apps.
[EVE Online is written in stackless python](http://www.youtube.com/watch?v=3jOJR5Xauf0). So you're probably just wrong.
So, pyglet it is...
I was trying to write some tests that would test all possible combinations of inputs, which would be a powerset.
Yeah not "set()". It's a "powerlist" then
Best source I've ever found: Friedl's Mastering Regular Expressions. Worth its weight in gold. 
[Related discussion on Stack Overflow](http://stackoverflow.com/questions/279912/pyopengl-or-pyglet).
Open Source Software grows and becomes sucessful because there is a community of developpers working on it but also because there is a community of end users. Maybe end users do not know or even dont care about how to program a C extension or whatever, because they are working on a different level. They demostrate the usefulness of the tool, bring it to its limits and are the most effective evangelist for it. This is specially true for software that has been widely adopted in the scientific research community such as numpy/scipy or matplotlib. We all should be fond having end users asking for a new release even if they do not contribute. There is no way for a software to be developped for some time without people using it (and reporting bugs and asking for more). 
How about: startPython or noobpython I agree not much better than beginnerspython but lets face it, the chatter you are trying to move and better serve - thats what we are.
This forking in Open Source is killing us! The humanity!
Yes, please create a subreddit for beginners. I'm too afraid to ask noobish questions here :(
startPython sounds good, would be nice to have a place where you I post my nab questions.
yes, I´m new to programming;Python is my first language. I would really appreciate it.
using com is nothing that justifys "being lucky". using com through wine even less justifys "being lucky" :) 
Python also has PyCon. When Googling for Perlcon I found something to decorate walls.
Id be very happy about this too! I don't want to post my stupid questions in /r/python.
Does anyone have some performance stats for this vs a c implementation, just curious.
If there's a reddit for beginners, I'll send my 1st year students over. Hopefully, they'll won't be too shy to ask questions. But I know they'll learn a lot.
They have YAPC (Yet Another Perl Conference) and OSDC (Open Source Developers' Conference).
No, fragmentation is bad. Apart from that, in a reddit for beginners, who is gonna to answer the questions?
In my never to be humble opinion, I've found the Python community to be one of the coolest/nicest group of people on the internet - and that extends to r/python. I never felt too bad about asking "n00b" questions because nobody ever made a big deal about answering. So, if python has gotten too big for that to be comfortable, I'd rather see r/python figure out a way to bring it back rather than split it off into a whole different sub-reddit, but that's just my $.02. 
You mean something like r/learnpython ?
There's already an excellent place for python newbies: The python tutor mailing list. The quality of the answers in terms of technical correctness but more importantly in terms of educational value cannot be topped. There're real gurus over there. Instead of forking and creating another place I would highly recommend newbies posting their questions there. As additional argument against forking I 'd like to point out that I have never seen any misbehaviour here against newbies and their questions. It becomes a bit rough once the web-framework discussions start. Even if you post a topic which was dicussed three times the week before you still get answers. Also, I think reddit is primarily meant to be a place where new announcements and developments are discussed. For general question regarding programming I think mailing lists or stackoverflow are more approriate (but that's my personal view as I don't know how reddit sees itself).
Very well put :)
yeah, the code would be less ugly using classes... i just wanted to see how far i could push the 'just functions and lists' thing... i should get rid of the redundancy you mentioned out in point 2. anyway, thanks for the comments...
agreed. i think the r/python community are excellent, and have no problem answering n00b questions (many of them mine), so i dont think we really need a beginners' (myself one of them) reddit... id rather we keep it one reddit, to have max exposure
Yes, please! Let /r/python become a news aggregator again instead of a Q/A forum. 
Ah, OK. I thought this may be something different. Per the top rated comment, I thought itertools had things like this already.
Don't. Ask away. There is also /r/learnprogramming and the like.
I'd appreciate a Python news aggregator separated from a forum. I don't mind which one is called r/python, but at least I think the latter shouldn't be associated with beginners. Something like r/pythonquestions might be more appropriate, where advanced questions should be asked as well.
Perhaps to encourage new python users **to** post (and thus attract more people to the subreddit) the subreddit mod could do some CSS trickery to give little gold stars (or even a comment) next to the name of people who are extra helpful. As a new user if I saw that most posts on /r/python are replied to by people who are verified non-trolls it would encourage me to ask daft (to everyone else) questions.
The only scenario I can imagine even wanting such a thing would be if you had a large code base and you only just realised you need the precisions of Decimals. If that's the case then you are probably better off just going through the code line by line and making the changes. Sometimes that kind of grunge work is unavoidable -- but ultimately less painful than the dark magics you are hinting at.
There already is one! http://www.reddit.com/r/learnpython, it doesn't look particularly well used but perhaps this is a chance for a little revival, if it gains traction I'm happy to add a link to the sidebar.
&gt; I thought itertools had things like this already. I think it does. This was something I wrote for scratch before I found that reciepe. :P
As long as people don't mind us newbies continuing to lurk/post in python despite a background, I am happy staying here. I subscribed to this subreddit on a whim, cause I wanted to know more, and this posting by the OP reminded me to look into python. (still not sure where it will fit in amongst my other languages, but I am educating myself slowly). Wondering if Python.org is the best place to start, or if there is a better place to talk about the bennifits of python vs. other solutions to problems. It seems to be a language somewhere between scripting and C, if the tutotrial "wetting your apetite" is to be believed.
Add it to the sidebar so that it gains traction.
Done!
Your link ate an extra comma: http://www.reddit.com/r/learnpython
I think the Stack Overflow question might have generated an answer like the one you found had it stated that you wanted to replace floats in a string with Decimals and then evaluate that string as a Python expression. That's nothing at all like making "Decimal the default type for all numerical values in Python". Based on your question, I thought you wanted to hack the interpreter itself to work more like bc.
We already have /r/learnprogramming, and /r/learnpython. Don't start another one.
I was not aware of learnpython, but since I posted this thread, a kind mod has put it in the sidebar for other people interested in learning it.
Nice with that tokenize ;]
Very nice tree, have you seen [FireLogger](http://firelogger.binaryage.com/) ? It's nice too, but I think it doesn't has a tree structure to filter logs.
The Windows installer doesn't work with 2.7, I'll have to try installing manually.
what is this *The python tutor mailing list* you speak of...
I tried something similar in /r/PHP. Assuming that /r/PHP is for news, articles, tips, etc, I created /r/PHPHelp for beginners with specific problems. The idea was to troubleshoot broken code. It never really caught on.
Too bad matplotlib's 3D plotting still looks like derp.
\#python on freenode is a really awesome place to ask questions, it doesn't matter if its a noobish question or a something extremely complex.
You can't quarantine parts of sub-reddits you don't like in this way. It just doesn't work. People would still ask noob questions here. Especially if they find they don't get a response in the other subreddit. Or they are new to python and /r/python and don't know not to ask. People have been trying for ages to quarantine politics, or more specifically american politics, or cute pictures, but having additional subreddits is about inclusion, not exclusion, no matter how much you wish it to be.
Look up the ast module and NodeTransformer, should be almost trivial.
Yes, FireLogger/FirePython are nice for web apps. Their use is complementary to this desktop app: for example, while webapp developers will likely use FireLogger when debugging, once the app is in production it's unlikely they'll use it/ask users to use it for their apps. Then, the support team for the app can add network handlers to the app's logging configuration and then view the collected logs using this desktop viewer.
&gt; PyOpenGL is nothing but a wrapper for OpenGL itself ... &gt; ... PyOpenGL's API is more pythonic ... &gt; pyglet's graphics API is closer to OpenGL's ... Don't those statements contradict themselves? 
+1 for IP and Silverlight
downboated for link bait. 
Seems more like an argument for r/pythonnews
The same sort of people that answer questions on the python tutor mailing list.
http://www.google.com/search?q=python+tutor+mailing+list
why?
IMO, that's what Planet Python is for. I read /r/python mainly for the questions and the discussions that follow.
One, buildout is not fully compatible with setuptools for certain things (notably script generation). Two, buildout claims it can help manage your whole environment but it really does a poor job of it. Example, how do you manage what apt packages to install? There are some recipes that try to fix this, but they are generally some form of crazy, like the main Apache recipe will actually build apache from scratch (which is nuts for a production system). Three, buildout doesn't have anything like venv's --no-site-packages so it is always a difficult game to know that you have all the correct dependencies listed. Just as a general aesthetic choice I personally prefer a small, well-documented tool that does one thing well to an almost-entirely-undocumented behemoth that does everything but nothing well.
Sorry for the confusion, but no, there's no contradiction. Both PyOpenGL and pyglet 'wrap' OpenGL's C API with Python. However, a wrapper need not expose the wrapped API 100% faithfully - the wrapper can expose the API any way it chooses. pyglet chose to do the bare minimum work necessary to wrap OpenGL, so we get an API that's more like C, (a bit) harder to use (need ctypes), but performs better. PyOpenGL chose to enhance the C API by avoiding ctypes, and making it more pythonic. I think the biggest difference is you can pass lists directly into PyOpenGL calls that expect a pointer to an array. pyglet requires that you convert lists into ctype arrays. Note that none of these differences are extreme - pyglet's API is not *that* much harder than PyOpenGL's, and the performance gap isn't that big.
There was some discussion of that comment on HN, including a response from Mark. [http://news.ycombinator.com/item?id=2120616](http://news.ycombinator.com/item?id=2120616)
I'm learning Python, have this added to my frontpage, and understand, well, none of it. I think a place to ask newbie questions would be great, if experienced folk watched and answered. Edit: I kinda hope that that's just /r/Python but if it needs to be split, so be it.
Use PyODConverter to convert doc/docx to ODF and then extract the headings by unzipping and reading the XML, or use PyUNO to query OpenOffice about the document and extract the headings. pdf files may not have semantic headings but you can determine font sizes with PDF Miner and maybe that'll let you extract "headings".
Job trends Perl Vs. Python: http://www.indeed.com/jobtrends?q=perl%2C+python&amp;l= Indeed.com would have the most accurate data. It's "THE" job search engine with lots more sources then any other job search engine. This chart is based on CURRENT job data. "Indeed.com searches millions of jobs from thousands of job sites. This job trends graph shows the percentage of jobs we find that contain your search terms. " .. just sayin' 
Or you could talk to someone who has more than one coupon :)
Ah, thanks. I keep going back and forth between the two libraries; now I'm leaning more towards PyOpenGL and its Pythonic API. Do both support the new(est) OpenGL API that everyone keeps talking about?
See: /r/learnpython. 
Since when did TI calculators do unlimited precision arithmetic?
I started working on CRAWL-E in 2008 when it was used to crawl overstock.com's auction site as part of a research project at UCSB. Immediately after that we used CRAWL-E to crawl the publicly viewable Facebook pages for all users listed in the top approximately 15 regional networks which if I remember correctly was about 20 million profiles. More recently I was crawling newegg each day to maintain my website pricetrackr.com. That crawl is no longer occurs unfortunately as newegg recently asked me to stop crawling them. What I'm looking to do is spread word about my crawling framework in hopes that it'll help others out, and in addition to receive feedback as to how to make it better and more usable. All comments and questions are welcome. Thanks!
thanks for the info on buildout, learned a few things, I agree on the no-site-packages thing, that is a pain in the ass. But I was more interested in Chef because I have never heard of it. I know pip and venv, and if chef fulfills the same role as buildout recipes and has some solid ones for appengine apps and can get bootstrapped from a simple script I would like to know. :)
Is your link for the "modern OpenGL tutorial" broken, or is the website down?
[man, people still use 1.5.2 in the future?](http://mail.python.org/pipermail/tutor/2027-January/011993.html)
Alternatively, you could learn how to use Python properly: &gt;&gt;&gt; 2.3 * 2.3 5.2899999999999991 &gt;&gt;&gt; str(2.3 * 2.3) '5.29' TI calculators are doing math just like Python does, they're just displaying the result differently.
Chef is a system management tool, so not something you would really use for GAE. It is what would handle things like installing and configuring Apache, Postgres, etc etc, all things that GAE just does for you.
It's not that they won't, it's just that they haven't yet. The Py3 conversions are in progress and should unfold over the course of the upcoming year. If you have new project that doesn't require one of these unconverted libraries, use Py3. Otherwise Py2. Basically, only use the older version if you *have* to. 
Yes
why not just tack onto the end and make it * r/Python-beginner * r/Pythonbeginner
Start with Python 2.7, and you can then keep an eye on Python 3 progress library-wise and port to it when there's better library support.
Seconded. 2.7 backported a huge amount of python 3 syntax. 2.7 and 3.x are NOT to be confused with one another, but starting with 2.7 will probably yield an extremely smooth transition. FWIW I'm still running 2.6 and won't be upgrading to 3 until matplotlib is ported.
It's fortunate that the majority of the opensource community doesn't share that opinion with you.
Yeah, that's the main reason I made this post. Nothing seems to have happened there for 6 months now.
Yep, most of the good stuff came in 1.4+ and definitely covered in both.
You could also add a tag like [Question] and then link to a filtered list of other people's questions, kind of like [BestofWoahDude](http://www.reddit.com/r/BestOfWoahDude/) . Cause i never felt /r/python was anal about asking questions. So why seperate when we can just organize? 
Dig up the differences between 3 and 2 and pick the one that seems to make the most sense. Either way you take a chance. Take the one you like the best... There has been a lot of porting done already. Personally I suspect that the big issue could be that Python3 versions of things might not get reliable fast enough. There is a dangerous period between a port and wide scale use that sometimes causes problems in this sort of situation. I personally don't care all that much. I have little or no interest in python3... 
&gt; No; it is handled as a decimal internally. There is no floating point rounding on the TIs. Wrong. TI calculators use ordinary floating point. Read the developer's guide, for Christ's sake. And learn about how floating point is handled so you can actually *understand* why `2.3 * 2.3 - 5.29` isn't equal to 0 in floating point.
I understand why 2.3*2.3 - 5.29 is not equal to 0 in floating point; that is not the issue. It was my understanding from reading the documentation that the TI-84 used exact math. I understand that floating point math in computers is handled by summations of 1/2**n power for fractional numbers. There is no need for you to be a jerk about things. &gt;&gt;&gt; p = 0 &gt;&gt;&gt; for e in xrange(1,10): ... p += math.sin(1./e)**9 ... On the TI-84, the same result is not yielded which was one reason I did not think it used floating point.
After doing some more fooling around with Python and decimals, the TI seems to be less accurate. I repeated the same for-loop using decimal.Decimal and the sin function in the documentation. The end result was closer to the floating point version in Python. I have no problem admitting I am wrong and can concede graceful defeat, but you could have been a lot more helpful, polite, and less condescending.
Everyone will be adopting python 3, its just a slow progress. A lot of projects have kept backwards compatibility support all the way back to python 2.4 and they have to slowly phase those out as linux distros start shipping 2.5-2.7. Once they can drop support for older versions they can start porting to python3 more easily. Your best bet is to use Python 2.7 and just slowly migrate up as the libraries you are using start supporting python3.
Isn't convincing me to click on a link the whole point of Reddit? I don't understand what is wrong here.
I think he just has a marketing disaster. What did he expect? Naming something "Dive Into Python 3" makes it sound like its the 3rd version of the Dive Into Python Series... so many people probably purchased it thinking they were going to learn widely adopted versions of python. Python3 wont be a commercial success or adopted until 2012 most likely when all major linux distros have started shipping more recent versions of python and libraries can slowly adopt it.
it needs proxy support so i can crawl newegg :-)
Thirded. Python 2.7 has a ton of Python 3's syntax/features. I haven't been able to move on from BeautifulSoup—even though I know quite a few people love lxml. [Once the parser for 3.1 is pluggable](http://www.crummy.com/software/BeautifulSoup/3.1-problems.html), I'll probably upgrade to Python 3.
if you're wondering why this is getting downvoted, the content in the article is already well-covered in the official docs and elsewhere. 
I don't even think that different list is neccessary. Just tag submission and it will be easily skippable by those who doesn't want to see it.
&gt;Basically, only use the older version if you have to. I would change that to &gt; Use the newer version if you can. While it sounds like the same thing, you're ok with the new version until you find you need one of those unconverted libraries. Whether that's because you find you need an additional library or an alternative to the one you're using. tl;dr Unless you're absolutely sure you don't need any libraries only available on the 2.X version use the 3.X version. 
I don't see any handling for robots.txt or connection throttling so as a sysadmin I now hate you and everyone that worked on this. You are what makes the internet a worse place. On a technical level. QueueNode looks almost exactly like collections.deque but slower (since deque is written in C).
On the one hand I'm always on the lookout for a better text editor but that is because *all* editors suck at one thing or another. Then every other week someone decides to begin a new text editor so that's great, they will make a better one. On the other hand, the world are full of text editors that are anything from not quite there to totally not there. Is it just me or does there seem to be a pattern here? Why not invest some of that energy in making an existing great editor perfect?
you can 3to2 right? I seem to recall 2to3 being kinda crummy when it first came out (and I havent tracked it since then).
In the Arch linux distro, python3 is the default python installation. It made me rewrite a lot of scripts however some I could not yet. Use python3. If you see any libraries not yet available for 3, use 2.7
All I can say is I've been using Editra for a couple years now. I *highly* recommend it.
You should know that python has excellent documentation and the tutorial is a great place to start. http://www.python.org/doc/
/r/python *frontpage* message: "news about the dynamic, interpreted, interactive, object-oriented, extensible programming language Python" I don't see how this is ambiguous. 
No. Planet Python is simply a feed-reader for a couple of registered blogs. 
I'd recommend WingIDE, TBH, haven't tried too many others. And what kind of project are you looking to start.
Think of Python as crystal meth for the mind. (I know some people will argue that crystal meth is the crystal meth for the mind, but this is much cheaper. Not necessarily healthier, though.) It's fun. It's addictive. It's waaay too easy. (Kinda like my first girlfriend, but I'm getting off track.) A few spare moments with Python will have you cranking out a user interface, writing a spyder to browse web pages, or simulating physics. It takes TWO lines of code to get your normal web browser to navigate to a new page. List comprehensions are a thing of wonder. Classes act the way that classes SHOULD act, dammit. Dictionaries are just amazingly friendly. Oh, and speaking of friendly, the pythonistas are exactly who you'd want them to be, knowledgeable yet nice. But beware, there be rocks along that shore: You'll find yourself skipping classes, missing meals and avoiding friends just to have another chance with your beloved interpreter. And it's not uncommon to have a two or three-time a day habit of checking for new and improved modules, there always seems to be something new. On the coding side, the spacing thing will drive you to distractions for a few days, maybe longer. And globals seem to work exactly backwards, but maybe that's just me. Oh, and save your very finest curse words for the joy of a case-sensitive language, 'cause it can be annoying. But otherwise I think you'll find that the joys far outweigh the pain, and in no time you'll be just as hooked as the rest of us! Have fun! 
On Fedora this is located in the wxPython package if you want to try it out. (older version though)
Project wise, I'm not sure yet. I may start looking at web and network based applications, but I'd also like to write scripts to solve Statics and Dynamics problems, and stuff using the math libraries.
The beauty of Python is that it is so light weight you can use any text editor. Try http://www.e-texteditor.com for example. I suggest you to jump straight into source code to keep the excitement level high. If you do web development then I have a few good suggestions: * https://github.com/defnull/bottle * https://github.com/facebook/tornado I suggested them because they are short and easy to follow. Also, learning on how to install pip on your OS is a good starting ground. pip is like Maven on Java. Good Luck!
Really, once the web framework go to Python 3 (which is now possible), i think Python 3 adoption will speed way up, because Python 3 is a definite improvement over Python 2.
This might not be the place to bring it up, but does anyone else really hate google code?
so annoying. By default, "python" = Python 3, "python2" = Python 2. I created a "py" alias for Python 2 to make it more convenient. I would learn Python 2 and then learn Python 3. I know of exactly 0 serious Python developers right now that learned Python 3 first. If you gain a firm understanding of Python 2, Python 3 will be easy to learn. Odds are, any code that you are writing that does anything complex relies on a Python 2 library.
I'm a newbie to this sort of thing. How do you "run" the program, so that it's always doing this? Do you have to host it on a webserver and send requests to it or what?
I love PyCharm IDE, which is based off of IntelliJ. Really though, I would just learn Python using your editor of choice, the command line, and (later) pip and virtualenv.
Very good observation regarding robots.txt handling. The framework doesn't have built in support for robots.txt nor throttling (yet) because that functionality is to be implemented by the crawler handlers. The use cases for CRAWL-E thus far, have been to crawl only a single domain, thus the robots.txt and any rate limits that are required can be applied on a case-by-case basis. In the event there was a large demand for such a feature, I would be happy to add it. Regarding the QueueNode, it's actually just an entry in the LRU queue, thus it doesn't quite fit the collections.deque model because entries in the LRU queue need to be removed in O(1) time which collections.deque doesn't support. Finally performance isn't currently a problem as the crawler is without a doubt bounded by I/O.
Do you have an particular RFC in mind? I haven't done much with respect to proxies myself.
I don't know what statics and dynamics are, but you may be interested in [Sage](http://www.sagemath.org/).
What's wrong is that the link says something the content of the link doesn't support. What Mark said -- and then elaborated on in other discussions -- was that his book on Python 3 was poorly timed, and was a commercial failure because of the poor timing. He said nothing whatsoever about Python 3 itself, but the sensationalist headline is trying to spin it that way.
Yeah, even Notepad2 works well.
This is not a Python problem, it is a lack of consistency in your runtime environments, more specifically, what is allowed the individual user. Python itself is VERY portable and carries a VERY consistent set of modules around all environments. numpy/scipy are not part of that load unfortunately (I think they should be, given the wide use Python has in the scientific world). So ... you need to "encourage" your sysadmins to give you a consistent execution environment. I speak as someone that routinely writes Python code that runs without modification on *NIX, MacOS, Windows, and Linux, so I know this is not a remarkable thing to do. 
Pure Python scripts are portable -- you don't need to port anything. :) A few notes: * Do note that Python 2.x and 3.x are not completely compatible: your script will need to be tweaked if you want to move from one to the other (and there are tools to help with this). * If you don't have root access -- and Python is not installed on the machine -- you can always install your very own Python (or most any other scripting language) into your home directory. * If you need to install packages, you probably want to be using virtualenv to do it (so that any newly-installed packages live somewhere in your home dir, rather than in the system Python's lib dir). * You probably want to install packages (again, probably while using virtualenv) using pip. This makes things much easier. pip is gradually replacing `easy_install`. Also, you write: &gt; Do most python programmers run only on a single system? That's an interesting question. My hunch is that no small number of Python programmers are hobbyists, and run on only a single system. &gt; Appreciate any help.. If you want someone to be able to run your scripts, it might be easiest simply to sit down at their machine (or log in remotely), make sure Python and the relevant supporting modules are installed, and then give them some simple instructions on how to run the scripts you send them. 
So, it runs a search on Twitter in a continuous loop? Wouldn't that be a substantially larger load on the servers than that of a human user?
3 when you can, 2 when you must.
might be worthwhile to throw something together with SDL and call it from Python if that is all you want.
Putting out a crawler framework without these features by default is irresponsible at best. I truly hope you checked with the admin of the site in question before DDoSing them.
The above link links to a Reddit comment by Mark Pilgrim which says, and I quote, “Python 3 is a commercial disaster”.
I'm guessing that you don't consider it Python development if part of the effort involves writing C/C++ python modules... which is an integral part of any large python project. That to me explains all of our differences. It is preposterous to me to think of Python development separate from module development.
Try using py2exe to package your script into an executable.
[This](http://www.youtube.com/view_play_list?p=21BA2DB4B055FB12) is an excellent tutorial provided by Google. After going through this, I was able to do some pretty nifty stuff that saved me tons of time. Tutorial is about 4-5 hours IIRC, but is **very** worth it.
Care to elaborate? I really think it's fantastic. My reasoning being the ability to preform code reviews, bug tracking, and most importantly an awesome way to view change sets. What do you prefer?
It's very nice. I am planning on working on a project that may warrant something like this. I glanced at the source and it looks promising. Being that crawling is very network I/O bound I would have maybe opted for some sort of green thread implementation as you can probably get more throughput as opposed to using multiprocessing only. But I am not entirely sure since you've implemented gzip/deflate support and if site(s) you're crawling are fast green threads may not be all that beneficial, it all depends on how much threads wait on IO as opposed to doing real calculations. gzip support is definitely a nice touch though. As far as good netizenship goes robots.txt support would definitely be nice. If I end up using your code I'll implement it and contribute back.
..for Windows only.
Use easy_install and/or package your own programs to include dependencies.
You probably want to read his other comments. Like [his reply over here](http://news.ycombinator.com/item?id=2120705): &gt; Python 3 is technically very good, but no one is using it, hence no commercial interest in the book.
In the crawls I have done with the University, yes, we have been in contact with the websites. In some cases, they volunteered to give us the information we sought, and in other cases we implemented rated limiting through CRAWL-E's URLQueue class. I don't completely agree that having these features is irresponsible. One could extend your argument to python's httplib, urllib and urllib2 modules. (I just realized there is a robots parser for python3, however that was previously non-existent and the bigger issue is with rate limiting.) My framework, just like the modules, provides you with the basics to perform a task. The person utilizing a framework still has to do all the leg work to get it to crawl a particular site. To favor your argument, I do provide a URL crawler handler example which should by default obey a site's robots.txt. I will correct that.
This was the problem I faced. I completely agree. One solution is that [enthought](http://www.enthought.com/) has a free academic license. But that's still one package every environment needs to get to run your code.
I run Python code on Solaris (sparc or x86), Linux and OS X and generally it is not a big problem. - Module managers like setuptools(easy_install) or pip make things much easier. - If you would like to move modules across the same (similar) platform you could look into something like virtualenv. - If you truly want to have portable code no matter the platform you could look into Jython. However unless the module you intend to use was written in pure Python you will have to use Java's alternatives. But it's not a big deal as Java's library is pretty extensive. - Another alternative you have for sharing working examples is making virtual images using something like Virtual Box. You can get an ubuntu image (server only) at around 1 gig of disk space. I find Ubuntu (or any debian based distro) to be easiest as far as working with Python goes. You can then share your VM images with friends which require minimal setup. In fact you can fit multiple VMs on a thumb drive now days. This has lately become my favorite way of actually developing in general. Because you can just fire up the VM(s) for the project you're working on. And have all the right modules always installed. You can then use SSH reverse tunnels (ssh -R) to open any port to your VMs. 
Oh, I see now how the quote, out of context, seems to refer to Python 3 itself rather than the book. Thanks for taking the time to explain that.
Moreover, list comprehensions (and generator expressions) are usually preferred than `map` and `filter` functions nowadays.
It is usually possible to build the modules you need in a local dir, say, /home/dansin/python/lib/... Then add that to your PYTHONPATH. Package management may make this easier, or not, depending on how flexible they are with alternate installation paths. I have spent some fairly frustrating hours trying to get everything cross-compiled from source on "exotic" platforms (Sparc/Solaris... which apparently is "exotic" to some).
lxml + pyquery Once you tried it, you'll never miss BeautifulSoup
Some libraries wont get rewritten, those libraries will eventually get replaced.
You may find differences too between 2.x.y and 2.x.z, but in most cases a program written for a lower version will run fine on a higher version. So be aware of this when choosing the version to develop on. And there are good rules and tools for packaging that make it much easier to install an app in multiple (even different) environments. I'm no expert on this aspect, but setuptools and virtualenv work very well for me. I develop on both Windows and Mac and deploy to various flavours of Linux.
&gt;Pure Python scripts are portable -- you don't need to port anything. :) I agree, and would love to do more pure python. But one of the reasons python is so attractive is all the mods people make. I saw a post recently about people using python to parse and someone suggested using a mod. For me, parsing string is the number one most important thing, I couldn't imagine having to install a parsing mod to all the systems. Also, for other people, it's not like 1 or 2 people. I'd prefer to make my scripts downloadable online so people can just download and go.
I don't run on any windows machines. This make's me wonder, is there something like that that combines all the includes to a non-dependent py script?
This is intriguing. It doesn't exactly solve my main problem, but it looks like a neat all-in-one package. Do you use it extensively?
Awesome feedback. The biggest bottleneck I've seen is with I/O thus there wasn't too much of a need to optimize that portion of the code. Additionally, I wanted to try to keep the code as simple as possible thus using built in operating system constructs was the way to go. I want to point out that by default, CRAWL-E only supports multiple python threads, not multiple processes. If you extend the Queue class, you can handle multiple crawler processes, which in turn can have multiple threads.
An interesting discussion of Python weeknesses at Quora.
Dude, you don't need any special addons to parse text in Python! There are really nice tools in the core language, what were you trying to do?
One of the trouble I always run into is...What do I do with it? I know the basic syntax and conditional statement but without an end goal its hard for me to ultilize it
The downvote/upvote button is the tool of choice for differentiating trolls from snakes.
More like: "Create visual output with a _Mac OS X only_ application that is _scriptable_ with python". 
While your intentions are no doubt honorable, I think the differentiation lies in a library or API (such as urllib) versus a complete tool (such as CRAWL-E). Don't get me wrong, I think this looks awesome and I can think of many use cases for CRAWL-E... it's just that there may be inadvertent misuse by your users who are not familiar with web crawling and spidering etiquette. Good job!
I am implementing yet another python crawler with a sleep() method for sleeping a random time between five and ten seconds between web accesses. Do you consider ok this? On the other hand, my code sucks. It is far bigger than Crawl E. :-(
And from __future__ import unicode_literals There are other Python 3 ``__futures__`` but ``2to3`` handles them; the most common issue in porting is unicode vs bytes.
&gt; Is it just me or does there seem to be a pattern here? IMO it's just you. My counter-theory is that everyone out there is unique and has unique tastes. I'm pretty sure would be *no* editor out there which can possibly liked by everyone. Hence the reason editors stress a lot on their plugin system wherein developers/hobbyists can make the editor do things *their* way. :)
You can always DIY: just put all the modules you need into one folder, then zip it up (Python can import from .zip). But it sounds like your real problem is that you want to use C-extensions that are architecture specific on multiple architectures (numpy).
Github and Bitbucket are attractive choices. Not sure about Bitbucket but at least Github provides a really nice UI.
Ask Eliza.
Your work is very nice. I am developing yet another crawler, using httplib2 and lxml. Why httplib2? It has some interesting features (at least for me) like a cache for responses, easy access to Google accounts, and a minimum footprint in my code. Why lxml? I have less trouble managing non english pages with lxml than with BeautifulSoup. I have a doubt about distributed crawling. Like you, I am also in a university. I have ten computers (connected to a university router) for running my programs If I ddos a site, i am also ddossing my router. if I need to wait five to ten seconds between web accesses just to be "polite" with the remote site (and my router), I think it is easier to go for a non distributed, no threads program. I think that Google or Yahoo have a different case for distributed crawling, because they have multiple static IP for their bots. 
I tried that, but few have heading.xml and few other have style.xml making it more complex!
I have to disagree. With Java you can easily build and distribute a jar file that contains all dependencies (and resources) your application needs. This is simply not possible with Python. Some dependencies need to be compiled per platform so out of luck even with easy_install/pip. I'm not sure if it's even possible to make such distribution with pure-python dependencies.
Currently I use this trick to special-case mod_wsgi environments: if __name__ == '__main__': bottle.debug(True) bottle.run(...) # Start development server elif __name__.startswith('_mod_wsgi_'): application = bottle.app() But this seems to be undocumented behavior. I would like to see an official API to detect mod_wsgi environments at runtime. 
silence
recently it's "Tarot Sport" by Fuck Buttons. Especially 'Lisbon Maru' and 'The Flight of the Feathered Serpent'
OK, well here's why I use buildout instead of virtualenv. The codebase I hack on is a gae app, with a gwt front end. The goal of our team is to make the code bases for all our projects readily hackable by anyone who wants to do it(on the team anyway). Thus, documentation on how to get going is a must. And the time for a new dev to go from nothing but an operating system + python2.5 to productive in the code needs to be as short as possible. If all the dependencies were eggs, I would have no need for buildout. If everything that needed to be deployed were eggs, I would have no need for buildout. But this is not the case, gwt is java and built with ant/maven etc.... And deployments to gae require all dependencies to ship with the app in the same directory plus an app.yaml, index.yaml and other googley things. And the appengine sdk is a zip file, not an egg. virtualenv has no method that I'm aware of for doing stuff outside of eggs/setup.py http://wiki.opscode.com/display/chef/Quick+Start | sudo apt-get install ruby ruby-dev libopenssl-ruby rdoc ri irb build-essential wget ssl-cert git-core /dislike So here's some issues..... #1 ruby #2 linux only chef may be useful for some things I guess. but helping a developer go from zero to hacking/testing deploying on a new (less than trivial) code base with minimal documentation is not one of them. That quick start reminds me of my java days... * Step 1: install Maven 2.x * Step 1.1: download java * Step 1.1.1: setting up an account with oracle * Step 1.1.1.1: activating your account * Step 1.x: configure your config file it's xml.....fuuuuuuuuuuuuuuuu Anyway, I'm sure Chef works out great for you, and I came across your slides while trying to figure out what the fuck you were talking about. (http://blog.coderanger.net/2010/11/chef-slides/) looking forward to that "longer post on Chef". But, I think your statement "Chef + pip + venv for a far far far far better solution" is far far far far far from being convincing. :)
OK, everyone post your [last.fm profile](http://www.last.fm/user/willistg) unless you don't want anyone to know you are really listening to black eyes peas and lady gaga. :)
Learn python2.7. No serious work is done in python3 (not yet). Use the -3 switch, this will warn you about python3 incompatibilities: python -3 yourscript.py
Tool's discography on shuffle mode.
By "mods" I assume you mean modules. &gt; For me, parsing string is the number one most important thing, Then you might have a look at Perl. It easily beats Python (and everything else) at string processing. &gt; I couldn't imagine having to install a parsing mod to all the systems. What modules do you need to install to process strings? Python should come out of the box with pretty much all you need for string processing. 
For some it's too much but for me this style is just right. I don't have any formal programming education (besides BASIC in high school) so the more verbose, the better. I think my only trepidation at this point is that it seems that Python 3 just isn't taking off like some thought it would. I really like 'Learning Python' 4th ed. as it showed both 2.x and 3.x code so I could work in both worlds at once. The fact that this edition is only 3.x puts me off a little as I would have preferred a mix of 2.x and 3.x.
http://www.deezer.com/fr/#music/python ;) truely : http://www.deezer.com/fr/#music/slash/slash-special-edition-542459
[This](http://listen.grooveshark.com/playlist/Coding/41865096) is the base playlist. Only a few songs - but I just drop more into it (which don't save) depending on my mood, or type of work.
Unless you need numpy, then you're stuck at 2.6
I'd recommend that you change the name before you get a letter from Disney.
Don't think of python as a scripting language. It's a programming language.
I do on my mac because it was just impossible to install pylab, graphviz and other libraries. I have several python versions and easy_install (+others) couldn't seem to get the right paths when installing dependencies. Enthought is a package where all of the parts just work together so that you could use python as though it ships with all the addon libraries. 
Get out.
Lacking the ability to enforce static typing on some structures (sp. function signatures) is one weakness. Having to guess what sort of object a callable expects for its arguments can be really annoying in some cases. Lack of a formal language specification is another. EDIT: Although the author is bang-on with the scoping issue (it *is* utterly stupid), he is way off with his criticism of the type system. Untyped? Seriously? A cursory reading of the tutorial would convince anyone otherwise.
There are limitations and shortcomings to every language. That is why there are so many and new one keep cropping up. Python is a good tool to use for some situations. Being loosely typed and easy to read; it also is a good language to introduce people to programming. That said, it is important to use the right tool for the right job. There are things I use python for and things I would never consider using python for. I don't understand why some people are beholden to 1 particular language. 
Dynamic typing has some advantages and some disadvantages. One important disadvantage is that your tests need to cover more ground to approximate the same level of safety you get from less tests with static types. Another is that static types are helpful hints for optimizers/compilers, and when they're not there, it is significantly more difficult to optimize code. Dynamic naming means that IDE's cannot help you much, for example it is impossible to rename a variable correctly and automatically in a Python program. Other refactoring tools are also limited. Lots of Python programs I see unnecessarily opt for dynamic mechanisms (e.g: Lots of spurious __getattr__ and lots of runtime method injection) which makes some code difficult to see through, difficult to grep, etc. The main Python implementation (CPython) is extremely naive and slow. Reference counting is a very poor way of implementing GC. 
What a crummy list of weaknesses. I wrote a long reply here, but in the end the commentary is crap because the author doesn't cite what his actual problem is, he just declares his preferences and declares that because he's not satisfied it's shit and someone else should clean it up (except the indentation on eval thing... to which the answer is use something that makes it easier/automatic like cog.py instead of trying to screw bend the language around you). Pretty lame.
Recently - Daft Punk - soundtrack from [Tron Legacy](http://www.tronsoundtrack.com/).
I use python3 for my day-to-day stuff (like "write a script that updates the source-code repository and regenerates the generated code"). I have both installed though, and can change the interpreter if I really need to.
Things in python look easy, and as you learn you will find out that the code you wrote could have been written much more elegantly and much simpler (at least that's what happened to me). Regarding IDEs, you don't really need them (I am almost dead without an IDE in C++). I write python code using vim (linux), and notepad++ (windows). If you really want an IDE, I can recommend SPE ([Stani's Python Editor](http://pythonide.blogspot.com/)).
Read this article by Zed Shaw: [Curing Python's Neglect](http://www.zedshaw.com/blog/2009-05-29.html) It discusses several subtle weaknesses in the design of python as well as its standard library.
In other words, &gt; Regex is always the answer is true. Regex **is** always the answer. Many times though, it is also the wrong answer :)
A lot of people are far more interested in PyPy than Python 3. In other words not everyone will be adopting Python 3.x in the foreseeable future.
see lastfm : http://www.last.fm/user/manatlan ;-)
The top voted comment essentially boils down to "Python is not a statically typed functional language. And I think Guido is an idiot." Maybe a valid opinion, but certainly more about programming paradigms &amp; personality.
If you're really a newb, then you probably have some idea of what you want to do with the language, but not how to do it. So, get yourself started with a framework like Django for the web, Pygame for 2D games, etc. and just do whatever they require for compatibility. You'll be happier doing it that way so you don't feel pressured to pick the "best choice", which is never an absolutely context free decision anyway.
Upvotes for mission of burma :-)
If you only make one connection to the server at a time, I suspect it would be fine to go as fast as you can (after all a server can handle many simultaneous connections, and you would be just one connection). What you don't want to do, however, is make many, many simultaneous connections to a server. So, if you just make your crawl sequential (one connection after the other), you should keep from doing much harm and don't have to worry about sleep timers. However, I realize this is not how you would want to write a real crawler. :) On the other hand, if you are trying to make a real crawler that can handle multiple connection at the same time; one option I've considered is to place a limit on the number of simultaneous connections you make to a single domain. In the end, I say most of this in theory, as I do not know enough to say if this is true or the right way to go about it... but it does seem like it would keep things under a reasonable load for most any server.
DAE find the lexical scoping issue to be a bad thing? I had written code that had a few globals that contained some configuration data. When I tried to write code that modified that data on the fly I kept on hitting brick walls. I ended up moving those globals into a class and ended up creating a much more object oriented solution that was much more robust and it was much easier to do than maintaining those globals. This event highlighted to me Python's "there is only one way to do it" philosophy. The language encouraged me to write better code.
&gt; Untyped? Seriously? According to some, "type" is reserved to specifically refer to things used during *static* checking only. Python is certainly type-safe, and dynamically checks that operations are appropriate, but it could still be described as untyped by that definition. You could say it has *classes*, but not *types*. 
That's a really nicely written article and he has some good points.
bboe: Maybe you could limit the number of open connections to a single domain and set it to some low number (like 5 or 10?) by default? Then in the docs, explain this setting to the users and let them deal with how and when they should raise that limiter? (Or were you saying this was really really hard to do the way Crawl-e was made? :) ) In this way you could prevent people from causing abuse who may not fully understand all web crawling issues ... and just use your library as is. Then, anyone who wants more, must first read your little comment on changing this value and how they have to consider not overloading the servers they crawl.
Yeah those definitely are comparable. I guess I just prefer google code as I spent a summer working at Google, and we used a similar tool for code reviews.
The GIL really needs to be exterminated. edit: Kind of cliché but.. what's up with the downvotes? The top threads in this post are either about how the article OP linked to is wrong or sarcasm. I love python as much as anybody and do 90% of my programming in this language right now, but all languages have problems (even though this is kind of CPython specific). Do you people seriously think the GIL is not a problem?
Velvet Acid Christ - Sadder Still, Infected Mushroom - Heavyweight, Wumpscut - Mother (Monastic Interpretation), are my top picks this week ;-) http://www.lastfm.pl/user/ergo14
Sweet! I hadn't previously seen httplib2. The different login features look pretty nice. I'll say that CRAWL-E "supports" most of these features, however, it's up to the developer to handle them as needed. Regarding lxml, that looks pretty solid. We attempted to use BeautifulSoup originally for our Facebook crawling, however it actually became the bottleneck in our crawling. We switched to just using regex to find the pieces that we needed. Obviously you can't parse html with regex, but if you know exactly what you're looking for it works quite well. &gt; If I ddos a site, i am also ddossing my router. I want to say that that's not true. Your router essentially is mostly stateless, made to forward loads of packets. The web server on the other hand has to establish state for each TCP connection and then handle a request. There is a much lower limit to the number of concurrent connections a single front-end web server can handle, than number of flows your router can forward. Regarding Google and multiple static IP addresses, they have an even bigger challenge, because despite requests coming from different IP addresses, they still need to obey rate limits in a distributed fashion. This probably isn't too big of a problem for them because they can interleave requests to multiple domains and still achieve really high throughput whilst ensuring requests to the same domain have sufficient time between them.
My first reaction as well - I would think that some sort of subscription model would make more sense. Also, for this type of "How To" I was hoping for something a little more basic and nitty-gritty than "use this API wrapper." But what do I know? I'm a newb.
Sleep is probably the simplest way to introduce delay. Another method would be to interleave requests to different domains. In this way your crawler can be 100% efficient, assuming of course you have enough unique domains to crawl.
TIL Facebook created a PHP REPL that doesn't suck like every other one I have tried. Plus they wrote in python.
&gt; One important disadvantage is that your tests need to cover more ground to approximate the same level of safety you get from less tests with static types. I think this is an oft-repeated fundamentally wrong notion, and I'm not sure where it comes from. For example, both Django and SQLAlchemy have extensive test suite's for their ORMs. We aren't writing tests to verify we've got lists in the right places, we're righting them to verify we generate the right queries! You need to test your algorithms (because nobody proves those correct), knowing that your `generate_sql` method returns a string isn't useful to proving correctness, knowing it has the right JOINs is.
ah yes. mission of burma is the most welcome band comeback of the century. I saw them a few years ago and they fucking killed. The night was absolute magic.
wait what? i tried nodebox on windows. and there was even a purely python one, can't remember the name though.
well shit. I guess I'm going to have to go back to java.... *cries* /sarcasm
* GIL gets in the way of taking full advantage of real threads. Note: Jython and, hopefully someday, PyPy don't have this problem. * No alternative to scope by indent. I like indenting but it is the number one reason people won't give Python a try. 
That's completely feasible. In fact currently the number of open connections to a domain is limited by the number of threads, so rate limiting was done by decreasing the number of threads if CRAWL-E is only crawling a single domain. However, even with a single thread and thus only one TCP connection more than a few requests can go through in a single second. CRAWL-E makes this even more efficient by using persistent TCP connection when possible, thus any rate limiting has to occur at the QUEUE level as that's the central piece in charge of what to crawl. I suppose I could add, and make a rate limiting queue that's the default for the examples. It seems this would be the responsible thing to do.
&gt;Much of the language consists of special cases rather than general features that combine in orthogonal ways. This results in infelicities and weird corner cases. Huh?
Same. The only slight gripe I have is its startup time. But keep it open and that's not an issue. It's a beautifully customizable editor, allowing you to go from a simple Notepad++ style text editor to a lightweight Python IDE by enabling a few plugins.
The startup time issue might be due to CPython. I don't know if using the Windows binaries makes much difference, but I've never really had that problem.
Some excellent points here... I'm amazed that it came from Zed Shaw :)
that the module system even allows something like monkey patching to happen.
* Having to type ":" for not good enough reasons ("readability", yeah... whatever). * Coming from a different language, feeling at home at once, and then finding you hit some hard walls, and that it takes you too much time to know what the problem is... because you didn't really understood some of it's features (assuming they were the same as in your previously known languages). Other than that... I'm quite happy with it.
That answer is quite ignorant; I think whoever posted it has not used Python significantly, and does not understand how to use it properly. * Python had incorrect scoping rules in the past, but its current implementation (variables visible but not rebindable) is the best you're going to get in an imperative language. * Python has information hiding -- use `self.__underscores`, or closures, or local variables. Yes, it is possible for a sufficiently motivated person to work around all of these -- however, the same is true of every practical language. There's no way to implement complete information hiding without preventing ugly-but-useful idioms * `eval()` is one of those "ugly but useful" cases. It should be treated the same way as dynamic code modification in C, ie, as a horrible but occasionally useful hack. * Python is, like Haskell and OCaml, strongly-typed. Type errors cannot occur, unless you drop down to C and start mucking around in the private structure attributes. * Although Haskell allows brace-based syntax, in practice, nobody *ever* uses it. My sole objection to Python's indentation is that `-tt` isn't enabled by default. * Single-expression lambdas have never been a problem in most languages with them. In fact, the only languages I can think of that allows anonymous multi-statement blocks are Ruby and Smalltalk. Looking at an example of how they're used in Ruby ought to be sufficient motivation to ban them in Python. * This complaint is simply that Python doesn't have algebraic data structures. While occasionally useful, they are by no means important enough that their absence should be counted as a "main weakness". ----- IMO, Python's main weaknesses are: * It's slow. Sloooooooow. Some code that might take a few seconds to run when written in C or Haskell can easily take half an hour when written in Python. The only way to write fast Python modules is to use C (via the CPython API). Weird features like `__getattribute__()` make optimizing Python practically impossible. * CPython uses reference counting instead of GC, which enforces a global lock on all operations. Programs running in CPython are therefore effectively single-threaded, except with a fake `threading` module the user can use to make their code run even slower. All attempts to remove the GIL have failed, because trying to unfuck two decades of third-party code is a massive undertaking. Workarounds like `multiprocessing` exist simply to trick you into thinking they work (they don't -- try mixing `multiprocessing` with signal handling some time when you want to cry). * Strings are completely broken. There is no reason why `len(u"\U0001D11E")` should ever, *ever* be `2`. Someone needs to sit Guido down with a copy of Unicode for Dummies, because right now the only way to process any text with non-ASCII characters requires re-implementing half of UTF.
A lot of people say this, yet few have analyzed and documented their actual gripes with it. GIL hate is contagious.
Well, recently I was writing some parallel code and had to put the computations in a C module to get any actual parallelization (disregard the fact that computations in python aren't efficient to begin with..). GIL hate is not unsubstantiated.
Like I said, Chef isn't a replacement for Buildout in your case (because GAE isn't a normal server). Not sure where you got that it is Linux only, my desktop at work is Win Vista so I would say thats pretty clearly untrue ;-)
That probably won't overload a server, though if you are running 100 copies in parallel it wouldn't matter. There are good reasons to write a web crawler, but 99% of the time people just write them because they are too lazy or scared to just talk to the owner of the website they want data from. Luckily more and more places are catching on that adding a web API is a good thing, and those have published usage guidelines (and can be enforced).
Looks like a simpler and less flexible version of Yelp's MrJob.
What do you WANT to do with it? I mean, if you're one of those people who goes around fat, dumb and happy, then you probably won't do a lot of programming in any language. But if you have a critical eye, if you hate doing dull, repetitive work, if doing something that could be automated makes the bile rise up in your throat, then you're a natural born programmer. Then, figure out what you want, do a bit of design, crank up your Python environment and get going!
i was going by the quick start. hell, I could see where someone would try that command on redhat and have it fail and give up. :) doesn't matter you clarified your original blanket assertion. good job
Too often it's just hand-wavy "omg the GIL sucks!" and then everyone else chimes in with "yeah! I hate the GIL too!" There's no doubt people are running into the limitations, but I highly doubt that number equals or is even close to the amount of people complaining about it.
Relinking python to python3 is one of the most moronic things Arch has ever done. No other Linux distribution does it, so the shebang in scripts (#!/usr/env python) has to be changed to explicitly be python2 (#!/usr/env python2). Other distros don't have /usr/bin/python2 at all, so a changed script will only work on Arch. Just after the change, there were so many Arch users turning to Freenode's #python channel that the mere mention got them a kick. Someone was not thinking.
why?
&gt; Some code that might take a few seconds to run when written in C or Haskell can easily take half an hour when written in Python. I'd be interested in seeing this code.
If you are even having this argument with someone, they have usually already made up their mind.
If Django and SQLAlchemy were statically typed with a Java-like system, you could guarantee that at runtime, there wouldn't be a NameError/AttributeError under *any circumstance* (And not just under tested circumstances). That is, tests establish an upper bound on correctness, whereas types establish a lower bound. This means that in Python, you have to get a lot more serious coverage to have reasonable certainty about the absence of this kind of bug (and even then you cannot be sure..) Additionally, more advanced type systems (e.g: Haskell) can do a lot more than "verify you have lists in the right places". For example, you can prevent "null dereference" (in Python's case, "NoneType has no attribute ..") completely statically. Even more advanced type systems yet (e.g: Agda) can express any arbitrary property as a type, and the compiler can verify those. That means *any* property of correctness you want to express is expressible and provable in the type system. I think your arguments amounts to "Type systems will not guarantee correctness", but the situation is not black &amp; white. Guaranteeing certain aspects of correctness is useful too (even if you don't guarantee all of them), and if you have these guarantees even with less coverage, that is great. Even with full line-coverage, you still will miss out on a lot of interesting things to test, and you will still hit the occasional error which is completely *detectable* and *preventable* in a static type system.
Agreed. The article appears to be either a way for the author to vent his frustrations of not being allowed to use his preferred language, or is intended to be nothing more than a means to incite and raise emotions. As with all languages there are issues and annoyances. Learning to work around these are part of a developers job. If you don't like something, offer solutions and constructive feedback. Articles like these provide no benefits to anyone besides the authors page hit counter. 
Perhaps it is fairer to say that you should use pip+venv when you are only working with Python (and Python modules) and are using a host that supports it natively (djangy, gondor, ep.io, etc, all grok requirements.txt so you don't have to jump through the annoying hoops GAE insists on). In this situation Chef is the replacement for GAE, not buildout.
&gt; Some code that might take a few seconds to run when written in C or Haskell can easily take half an hour when written in Python. Out of curiousity, what kind of code do you have that exhibits this problem? (to be clear, I'm not questioning that what you're saying, I'm just curious) My experience with heavy data processing so far shows around 10x-20x performance decrease with Python, which for me is perfectly acceptable. Taking 1-2 minutes instead of 5 seconds is within reason for my purposes. I'm curious where the extreme case comes out. &gt; There is no reason why len(u"\U0001D11E") should ever, ever be 2. Isn't this a philosophical question of whether or not len should count code units or code points? Don't many other languages return the number of code units rather than code points? For example in Java they used point out that they count code units but after much confusion decided to say "number of 16 bit Unicode characters." The visual studio reference for wcslen also specifically states it will return the number of 16 bit characters. A quick google search shows that many other C implementations have their length function return code units, not points.
Propensity for developers to strain to name things in a snake or Monty Python way.
fair enough
[di.fm](http://di.fm). Over the past year I've moved from Vocal Trance / Eurotrance to Hardcore / Hardstyle and now I'm mostly listening to Chiptunes. If you're into that, [SlayRadio](http://slayradio.org) is worth a try, too.
For me, its definitely github &gt; bitbucket &gt; google code. I've never used google code myself (only experienced github) but the UI for github is very nice, and I can quickly look at a project and get the general idea of what its about and who is involved with it. Also, its probably just me, but I always have trouble finding the documentation that goes with Google Code projects.
That's a bit of a True Scotsman, though.
I usually expect more ranting. His sites are actually blocked at work under "profanity."
&gt; but its current implementation (variables visible but not rebindable) is the best you're going to get in an imperative language. What is imperative language? Common Lisp can be as imperative as Python but I don't think it has the same problem. &gt; In fact, the only languages I can think of that allows anonymous multi-statement blocks are Ruby and Smalltalk. And all Lisp and FP language.
for the record: it isn't an article, quora is like stackoverflow, it's a crowd-based Q/A site.
Extract the text:h elements from content.xml. Those are your headings. (alternatively, install my docvert software and that'll generate DocBook for you to use)
&gt; Strings are completely broken. There is no reason why len(u"\U0001D11E") should ever, ever be 2. It doesn't. Unless you use a UCS-2 build, but nowadays I think just about everyone uses UCS-4 builds.
&gt; self.__underscores NOOOO. Bad. Using underscores for private variables can break things if someone uses the same class name twice in an inheritance hierarchy. The lack of true private variables has been one of my complaints for quite a while.
&gt;&gt; In fact, the only languages I can think of that allows anonymous multi-statement blocks are Ruby and Smalltalk. &gt; &gt; And all Lisp and FP language. And all stack based languages with quotations. Think Postscript or Factor.
By the way, take a look at Cython's nogil feature. Super handy if you don't have to deal with any Python data structures for a while.
lol. your job sucks then. :)
Yeah I guess the documentation aspect isn't the greatest with google code. There can be a "wiki" tab which just lists all the wiki pages by default when clicked. That is confusing thus I simply disabled it. I definitely prefer mercurial over git thus github isn't really an option, though bitbucket looks like it could work. I do prefer being able to use my Google account for things though, which obviously Google code works well with.
&gt; Your best bet is to use Python 2.7 and just slowly migrate up as the libraries you are using start supporting python3. Or better yet, port the libraries yourself and contribute the changes. Some libraries only need a few tweaks to work.
Fabio's comment was enlightening. &gt; [PHP is] nothing more than a glorified web page template system that grew too big. ... It doesn't mean that PHP is useless or something. It is very useful on the domain it was originally created for: creating web pages fast. But do not try to use it outside of that domain. Strong agree. PHP is a great language for quick-n-dirty web projects that go slightly beyond static HTML. However, PHP was not intended to be good at general programming. Reading [Rasmus Lerdorf quotes](http://en.wikiquote.org/wiki/Rasmus_Lerdorf) makes that painfully clear.
This is due to the way comparisons work. See the [section on comparisons](http://docs.python.org/reference/expressions.html#notin) in the Python Language Reference. c = (1 &lt;= X) &lt;= 5 is equivalent to __tmp__ = 1 &lt;= X c = __tmp__ &lt;= 5 whereas c = 1 &lt;= X &lt;= 5 is equivalent to c = 1 &lt;= X and X &lt;= 5
Ah, I was not aware of that. I guess that explains the tone of the list then. Although I do notice some little voting options. Perhaps just a quora karam whore then. :)
Here's an example from the [Programming Language Shootout](http://shootout.alioth.debian.org/u64q/performance.php?test=fannkuchredux) (a really great site, by the way). The task involves performing fannkuch permutations on the n! permutations of {1,2,...,n}, and keeping track of the longest chain. Currently, the best C++ implementation takes 12.63 elapsed seconds, whereas the best Python implementation takes 49 minutes. The C++ version fully loads four cores, whereas the Python version only runs on one, but that's still a big gap even if you divide 49 by four. By the way, the site accepts new submissions, so if you think you have a more efficient Python code, or can improve or tweak existing code, you're welcome to do it. As an aside, it's a bit mystifying to me why Python and Ruby get so much attention, when languages like Haskell or Lisp are at least as powerful and expressive, yet their implementations perform almost as well as C/C++.
I gave an example in reply to unpythonic, if you're interested.
Python has strong dynamic typing, which has it's pros and cons. Hell, if he wants static typing, why not use a different language. I like Python for some purposes and other languages for others. There's no point in calling a language bad because you disagree with it's design goal.
I've been programming python for 10 years and it never ever occurred to me to do this. Upvote for creativity.
Thanks for that explanation, makes everything clear. Is there a way to tell Python how to handle 1 &lt;= X and X &lt;= 5? I tried defining __and__ and __rand__ methods in the Variable and Constraint classes, but they're not called. EDIT: Reddit doesn't like me using underscores, but trust me, I'm using them.
three things come to my mind. 1. GIL 2. Poor quality libraries for example mysql db bindings. 3. Documentation. (Even though I don't have any interest in java I adore javadoc generated documentation).
About as useful as #define true false in C.
I believe you just created a new variable that hides the built-in.... Given this script: print True print globals() True = 0 print True print True == False print globals() you get this output. Note the change in the contents of globals() True {'__builtins__': &lt;module '__builtin__' (built-in)&gt;, '__name__': '__main__', '__file__': 't.py', '__doc__': None, '__package__': None} 0 True {'__builtins__': &lt;module '__builtin__' (built-in)&gt;, '__file__': 't.py', '__package__': None, '__name__': '__main__', 'True': 0, '__doc__': None} 
Not in 3.x &gt;&gt;&gt; True = "lol" File "&lt;stdin&gt;", line 1 SyntaxError: assignment to keyword
Override [\_\_nonzero\_\_](http://docs.python.org/reference/datamodel.html#object.__nonzero__). And backslashes escape reddit formatting for the immediately following character 
&gt; edit: never do this. You're a good man.
That's right. `__and__` and `__rand__` define the behavior of the object when used with the binary arithmetic operator `&amp;`, not the behavior of an object when used in a boolean context.
Great to see another TOOL maniac coding python... :) I also sometimes listen to our own music: def shameless_advertising(self): link = [DeZombification by Anokato](http://www.dezombification.org/) (site coded in python on appengine ;)
I'll try the editor, the features sound good. I just wanted to say your lightbox screenshot viewer is HIGHLY annoying. I have to click and wait for an animation *three* times to view a screenshot at a useful resolution, the largest of which are still not 1:1 (I think, otherwise whoever took the Linux screenshots did something fucked up to their fonts) and I have to wait for the slow sliding animation poop to close and open and it won't even stay at the large size. What's wrong with just having thumbnails (as large as possible to fit your column width) that link to full-resolution 1:1 PNGs? Or does that make too much sense? I hope whoever designed that website isn't also responsible for the UX of the editor :)
I got really annoyed when I looked up Python's standard threading library and found they were execution locked. Only one thread can be executed at a time. If you're going to be doing concurrent processing, python is not the way to go. Since that's probably going to be the way of the future, I'd recommend python hoping on that particular train. They may have to write documentation about it, with a big disclaimer that says *don't mess with concurrent processing if you don't know what you're getting into.* Either that or restructure the whole idea so it's simpler (That would be the python way to do things).
Yeah - looks like you can "del True" and then things are back to normal :)
I have a few ideas..while I know some basic syntax and basic programming I can't figure out how I would accomplish some of things I want to do.. ie: a youtube video downloader/uploader
 True, False = False, True
ditto, really nice bunch of guys too.
Two reasons, in no particular order: 1) Haskell and Lisp can "force" an imperative programmer to operate under a different mental model than what they're used to. 2) The languages are better documented and so are their libraries - for both the standard and 3rd party variety. Python more so than Ruby, but Ruby more so than Haskell and CL. People are simply taking the path of least resistance to solve their problems. They'll go for languages built on paradigms they already understand, with a mountains of documentation to back them up when they inevitably need assistance. 
dang I thought my company is shit
I've never seen anything here that wasn't also announced on Planet Python. In fact, a lot of the news type posts here seem to be reposts from PP. And there are way more than just a couple of blogs aggregated on PP. I counted 435.
&gt; Out of curiousity, what kind of code do you have that exhibits this problem? (to be clear, I'm not questioning that what you're saying, I'm just curious) I was doing a combination of string and arbitrary-precision numeric processing on large (&gt; 500MB) datasets stored in JSON files. Pure Python code (using `decimal.Decimal` and `simplejson`) usually took between 25-40 minutes, depending on the input data. Rewriting in C with a thin Python wrapper (using GMP for math, writing my own module for JSON) reduced typical processing time to around 12-17 seconds. Obviously this is a somewhat extreme example, but any time you need to do a lot of array/string mutation Python will get bogged down quickly. &gt; Isn't this a philosophical question of whether or not len should count code units or code points? Don't many other languages return the number of code units rather than code points? For example in Java they used point out that they count code units but after much confusion decided to say "number of 16 bit Unicode characters." The visual studio reference for wcslen also specifically states it will return the number of 16 bit characters. A quick google search shows that many other C implementations have their length function return code units, not points. Counting code units used to be common, when people still hasn't gotten used to the idea of non-BMP characters. But now, every language/library which claims Unicode support will process strings as code points. UCS-2 Python is one of the lone stragglers, which causes problems when trying to work with more modern libraries.
&gt; What is imperative language? Common Lisp can be as imperative as Python but I don't think it has the same problem. Imperative meaning not based on the lambda calculus. &gt; And all Lisp and FP language. LISP doesn't even *have* Python-style statements; neither does my FP language of choice, Haskell. I can't speak for others, but most seem to favor single-expression functions/lambdas.
The official Windows and OS X builds are UCS-2.
I was hoping for something more on the lines of "A and B" being mapped to a custom function "A.merge(B)". \_\_nonzero\_\_ just seems to let me tell Python how to evaluate Variable or Constraint objects to True or False, when I don't really want to be doing this.
Interesting -- I hadn't thought about that case. Have you ever seen it in the wild?
Oh, I see. As kisielk pointed out, you can use the &amp; operator instead, that should call \_\_and\_\_
&gt; Reference counting is a very poor way of implementing GC. Language implementation is an area I'm not too familiar with, so forgive me if this is a dumb question, but why is this, and what's better?
&gt; \_\_builtins\_\_.True = 2 
After going to Python he has less to rant about and has stopped being the inflammatory fellow he was before. If you try to find his ruby rant, for instance, it will direct you to his page which he has replaced with a sort of "this post is too inflammatory, go focus on better things in life."
So, as it appears there's no way to map "and" to a function, do you know of a way to make Python map 1 &lt;= X &lt;= 5 to 1 &lt;= X &amp; X &lt;= 5 rather than 1 &lt;= X and X &lt;= 5 ? This would enable me to use \_\_and\_\_, and thus be able to write the algebraic expression without having to use brackets.
Stop being evil. 
Problem is, I know of no way to tell Python to use "&amp;" instead of "and". Remember that it's Python, not me, taking "1 &lt;= X &lt;= 5" and transforming it to "1 &lt;= X and X &lt;= 5".
Here we go again... :-(
And JavaScript. And Lua.
My Problem is with the way documentation is organised. 1. No easy navigation between modules, you have to use browser back button to go back. 2. One documentation page per a module and it becomes awfully hard to lookup particular class in particular module. 3. Documentation readability is also an issue, it's been long time since documentation visual style changed. There is one more documentation generation tool called sphinx which is used on official python site. And sphinx still makes it hard to move between modules/classes. It feels more like reading a blog than browsing documentation for quick lookups. I like php documentation style too. just enter php.net/&lt;function_name&gt; that's all you need. A function help page that will include syntax, usage, user contributed snippets.
Actually, most distros install python as /usr/bin/python, as you said, but then symlink back to it from the more precise names. For example, Fedora 14 has 2.7, which is installed as /usr/bin/python. /usr/bin/python2 and /usr/bin/python2.7 are both symlinks to that. I use #!/usr/bin/env python2 in my scripts on Fedora, and I've never had an issue.
Good answers; I suppose there's quite a bit of interplay between reasons 1 and 2, as well. I don't think Lisp necessarily demands a different mental model though, since you can easily write "C in Lisp"-style code if you like. Probably one problem with Lisp is that it had its shot at being a hot new language, but due to the constraints at the time (slow implementations, bad garbage collection, slow interpreters), it failed to catch on. It's hard to get people excited about an old language.
You know, I used to write similar code in Java and Python, and in Python I'd have a bunch of useful abstractions in my mind that would hold most of the time. In Java, I'd first think about the problem for a while, try to think of abstractions that would be useful if I extended the program in this way or that way, cobble together a bunch of interfaces to express what I want them to do, implement code, get complaint that class X would have to belong to interface A, and refine the interfaces a bit more, and then end up with half a dozen interfaces for something that would have just been implicit in Python. And I'd still have to shake out all the functional errors in that code. TL/DR: I don't like the fact that I have to provide proof for all the nice generalizations I had in mind when writing that code, and I won't settle on simple, concrete classes without polymorphy either. In such a case, Python with its duck-typing works more to my advantage than Java's half-assed generics.
Is the a cairo equivalent?
The languages with well-performing GCs all use generational garbage collection schemes where objects are moved around depending on their history, which generally messes up any useful interaction with C libraries, but performs almost as well as pool-based allocation in C (read: very fast). The next step down the ladder is a conservative GC which lets you have pointers to your objects anywhere you like and is probably slightly slower, but more convenient than malloc/free. Python (and Objective-C, if I remember right) use reference counting with cycle detection, where objects have a reference counter, for swift deletion when they're not needed anymore, plus some code to detect cycles in the reference graph and free even those objects that are part of the cycle if the cycle itself is not visible anymore. Reference counting with cycle detection usually does exactly what you want (i.e., no file handles left open until the garbage collector comes along and calls finalize() ), but it's as complicated to implement as an actual GC because of the cycle detection. Finally, pure reference counting has problems (see above) but is easy to implement, so it's a fixture in every CS student's completely-broken-but-self-made Lisp 1.5 clone.
One annoyance I have is that Python prefers whitespace except for this, if True: pass when it should be whitespace-based like this, if True pass because in the rare case that you want to do it on a single line, if True: pass you could instead write if True; pass just like how you'd write, print "blah";print "blah";print "blah" when you'd want multiple python statements on a single line. The ":" on "for" and "if" seems redundant and ugly considering that there is whitespace and ";". Also, and this is a minor point, by ditching the ":" you can now have more of the language as single key presses without a modifier key (in my example there's the T in True but obviously that's just a sample variable unrelated to the syntax I'd prefer)
&gt; Finally, pure reference counting has problems (see above) but is easy to implement, so it's a fixture in every CS student's completely-broken-but-self-made Lisp 1.5 clone. Now that we've entered the era of pluggable GCs in C++, I doubt anyone will be writing a reference counting GC for their Lisp 1.5 clones.
in response to his first point about deleting items from lists, you can use the pop method on a list with the index number as an argument: &gt;&gt;&gt; x = [1, 2, 3, 4, 5] &gt;&gt;&gt; x.pop(2) 3 &gt;&gt;&gt; x [1, 2, 4, 5]
I kind of see where Rasmus is coming from: If programming doesn't solve problems then what is there to like about it? Many problem solvers by nature drift towards programming, and may confuse their love for the one with the other.
Its' kind of odd there. Are there any other keywords with a first capital letter except for True and False?
None.
Why would that be useful?
Well, there's also the fact that Lisp fragmented. There is no canonical Lisp, like there is with Python. When you can't just tell newbies to go "download Lisp", you've got a problem.
 I like this one (works best with newbies coming from CL): &gt;&gt;&gt; quit Use quit() or Ctrl-D (i.e. EOF) to exit &gt;&gt;&gt; quit = 'I will never quit!" &gt;&gt;&gt; quit 'I will never quit!' &gt;&gt;&gt; def quit(): print "You can't make me quit!!!" ... &gt;&gt;&gt; quit() You can't make me quit!!!
No. That's not possible. `and` is a language feature like `is` and can't be overridden. The chaining is handled by the parser, not the language.
numpy v1.5 supports Python 3.
If you use names with underscores, make sure to wrap the names in \` backticks. It's a good habit to do that for all variable names and inline code so people know when you're talking about code.
This is why, when writing loops, using "while 1:" is preferable over "while True". With "while 1", the interpreter can loop without checking the conditional. With "while True", the interpreter has to reevaluate whether or not True is still True upon each loop.
To be clear, private attributes should use a single leading underscore. A double leading underscore invokes name mangling (see [PEP8](http://www.python.org/dev/peps/pep-0008/), which recommends restraint when using __name). I think a clear convention is sufficient; "real" private attributes aren't necessary.
`&gt;&gt;&gt; exit()` sucker.
To clarify: `True`, `False` and, indeed, `None` are the keywords that start with a capital letter in Python 3 (in Python 2 the first two are just variables and the latter is probably magical).
I don't run into it for the very simple reason that I know it's there, so if I *need* threads (so I can leverage multiple cores), I just use a different language. Honestly, I don't *need* threads very often, though. I have to admit, one nice thing about Jython is getting access to the `concurrent` packages, though. Nothing like a worker pool that uses threads and automatically knows how many to use based on the number of available cores.
I find it interesting that the top answer silently corrected "Barbara Liskov" to "David Parnas" when talking about the invention of information hiding. UPDATE: By silently, I mean it's not acknowledged in the answer itself (it is in the comments). This is in contrast to the update about `namedtuple`.
http://code.google.com/p/modwsgi/wiki/TipsAndTricks#Determining_If_Running_Under_mod_wsgi
Its awesomeness
That makes sense. How are you defining performance, though? Memory footprint, number/percent of CPU cycles for memory management activities, etc? 
Is the last point (strings) still valid in Python 3?
None isn't a keyword in python 2 either: &gt;&gt;&gt; def None(): ... pass ... File "&lt;stdin&gt;", line 1 SyntaxError: cannot assign to None Changed in 3.x though.
I love Haskell for the mental stimulation, but it will never catch on like Python because in all seriousness, Haskell is way too hard to learn. I am a CS master student with lots of experience in all kinds of languages, have solved many projecteuler problems with Haskell, and still could not use it for any serious developing. It takes months to grasp one of the fundamental concepts of Haskell (Monads), yet it takes no more than a few days to get used to Python enough to start using it for medium sized projects (done it, worked out extremely well).
Why do you need private variables enforced by the interpreter? The convention that self._underscore is private and should not be messed with is easy to understand and follow. Never had a problem with it.
&gt;Python is untyped, which means that a whole bunch of errors that are easily detected ahead of time aren't detected in Python until they happen He says python is untyped, but that's wrong isn't it? It's strongly typed, but just dynamically typed.
TIL [Hemispatial neglect](http://en.wikipedia.org/wiki/Hemispatial_neglect)
What kind of systems are you working on? You said none of the 40 systems are Windows boxes, so I assume the rest all provide SSH access of some sort. You should be able to script the installation of required modules at the very least. I have a few Django projects, and many of them come with a list of prerequisites. More often than not, the prerequisites are already satisfied for other reasons, but when they're not using the already mentioned easy_install/pip route makes their installation quite trivial in most cases. There's even the "requirements" file that pip can handle. Just make it part of your documented installation process.
This should be the only way, and with a better function name. Putting an index parameter in pop is so good. For a second I even thought it means "pop the last 2 elements" or "pop the second element from the end".
Posted there, but I'll post here too. zip() is simpler: &gt;&gt;&gt; zip(*l) [(1, 4, 7), (2, 5, 8), (3, 6, 9)]
So it's not a problem because other languages provide proper threading?
While doing some profiling will always yield exactly why it was slow, its very likely the speed issues are mostly due to `Decimal`, which has a very slow, pure Python implementation (simplejson has native C backing it up these days). Use [cDecimal](http://pypi.python.org/pypi/cdecimal/) which is a drop in native replacement for `Decimal`. You can't make the blanket statement "anytime you need to do a lot of array/string mutation it will be slow". Python strings and arrays are very fast. Every performance issue must be carefully analyzed.
It's not random. Apparently Guido did some usability tests with absolute beginners and found out that it was easier for them to understand block of codes if ':' is used.
That's a good point about Haskell and the side-effect problem, but none of that really applies to Lisp. Maybe all those parentheses just scare people away. By the way, whatever happened to PyPy? I thought that was going to solve all the Python performance problems.
Yes -- Python 2 and 3 use the same basic string handling, which is either UCS-2 or UCS-4. UCS-4 works properly, but UCS-2 builds (such as the official Windows and OS X builds) will work incorrectly. The main difference is that Python 3 corrects the names of the types. In Python 2, the `str` type can actually only store bytes. To store characters, you have to use `unicode`. In Python 3, bytes are stored in `bytes` and characters in `str`.
This was roughly 2-3 years ago, before simplejson had a C extension module.
??? gg@fermi:~$ python2 Python 2.7.1 (r271:86832, Jan 6 2011, 11:45:30) [GCC 4.5.2] on linux2 Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; len(u"\U0001D11E") 1 
Examples on the second point would be helpful.
There are many multiline expressions and the like. I think the colon really is a visually distinct feature that is helpful. Did not bother me ever.
Yes basically I connect all of them through ssh. Actually I did design a script to zip my entire script directory then scp and unzip it in a remote location. So as long as I have consistent naming for the directories all the dependencies should be taken care of.. Yeah that's a really good idea, thanks!
If there had been an alternative, people would have used it, and Python would not have been considered one of the most readable languages.
The binary-trees benchmark is a classical GC benchmark: it creates lots of small objects, most of which are really short-lived, and tears them down again. Languages/VMs with a "proper" GC such as Haskell/GHC or Java have a considerable advantage over malloc-based allocators such as the FreePascal entry or the more straightforward C and C++ entries. The best-performing C and C++ entries both use pool-based allocators. I have no idea about the memory footprint - in the benchmark, you do see weird effects like Java using up 500MB where the most memory-efficient programs (C and FreePascal) use 70-100MB and most *reasonable* ones about 180-250MB.
&gt; Obviously this is a somewhat extreme example, but any time you need to do a lot of array/string mutation Python will get bogged down quickly. I think even extreme examples are worth keeping in mind. I'll keep it in mind if I ever see that condition. &gt; But now, every language/library which claims Unicode support will process strings as code points. UCS-2 Python is one of the lone stragglers, which causes problems when trying to work with more modern libraries. I don't think that's fair. In Java 6, [String.length](http://download.oracle.com/javase/6/docs/api/java/lang/String.html#length%28%29) "Returns the length of this string. The length is equal to the number of Unicode code units in the string." and in [.NET 4 Strings](http://msdn.microsoft.com/en-us/library/system.string.length.aspx) "The Length property returns the number of Char objects in this instance, not the number of Unicode characters." Those are two of the most used languages today and the behavior of their default string object's length exactly matches the behavior Python's default string object.
Circular import errors are really weird and get in the way in day-to-day programming.
Try it in a UCS-2 version, such as the official Windows and OS X CPython builds
Yeah thats a good idea. Even better if I can keep it zipped! That means I can transfer faster. Thanks!
In spite of Python's problems, I still find it to be the most enjoyable language for me to program in, and *extremely* useful. Is it perfect? No, but there is no perfect language. All of them have their warts and historical oddities. I think of Python as providing a local optimum of programming language trade-offs. There are plenty of other languages that do some specific thing (or narrow set of things) better, but Python does almost everything I need very well (especially if you consider the libraries as part of the language). Sooner or later some "better over-all" programming language will come along. Until then I'll stick with Python.
Well.. I was going to counter you with a readability argument, but you are absolutely correct (in Python 2.7): &gt;&gt;&gt; import dis &gt;&gt;&gt; dis.dis(compile('while True: pass', '', 'exec')) 1 0 SETUP_LOOP 12 (to 15) &gt;&gt; 3 LOAD_NAME 0 (True) 6 JUMP_IF_FALSE 4 (to 13) 9 POP_TOP 10 JUMP_ABSOLUTE 3 &gt;&gt; 13 POP_TOP 14 POP_BLOCK &gt;&gt; 15 LOAD_CONST 0 (None) 18 RETURN_VALUE &gt;&gt;&gt; dis.dis(compile('while 1: pass', '', 'exec')) 1 0 SETUP_LOOP 3 (to 6) &gt;&gt; 3 JUMP_ABSOLUTE 3 &gt;&gt; 6 LOAD_CONST 0 (None) 9 RETURN_VALUE In Python 3 there is no difference &gt;&gt;&gt; import dis &gt;&gt;&gt; dis.dis(compile('while True: pass', '', 'exec')) 1 0 SETUP_LOOP 7 (to 10) &gt;&gt; 3 LOAD_NAME 0 (skip) 6 POP_TOP 7 JUMP_ABSOLUTE 3 &gt;&gt; 10 LOAD_CONST 0 (None) 13 RETURN_VALUE &gt;&gt;&gt; dis.dis(compile('while 1: pass', '', 'exec')) 1 0 SETUP_LOOP 7 (to 10) &gt;&gt; 3 LOAD_NAME 0 (skip) 6 POP_TOP 7 JUMP_ABSOLUTE 3 &gt;&gt; 10 LOAD_CONST 0 (None) 13 RETURN_VALUE 
wow..pretty neat..Didnt know about this one thanks goodger
I have used elisp to extend emacs, and I did not like that much. What makes people fall in love with Python is how easy it is to learn and use it. It was really painless to learn Python, whereas in elisp I had to struggle quite a bit to make up my short, but useful function (see [my-ido-project-files](http://www.emacswiki.org/emacs/InteractivelyDoThings#toc12) which I am sure is not nice code). Had no interest to pursue this language further, afterwards.
Java was designed before Unicode added the supplemental planes -- it does not have full Unicode support, and cannot unless Oracle wants to break backwards compatibility. From the Java docs: &gt; The methods that only accept a `char` value cannot support supplementary characters. They treat `char` values from the surrogate ranges as undefined characters. For example, `Character.isLetter('\uD840')` returns `false`, even though this specific value if followed by any low-surrogate value in a string would represent a letter. .NET is designed specifically as an alternative to Java -- it attempts to be bug-compatible in many respects, including this one. Like Java, .NET does not claim full Unicode compatibility. --- Python's Unicode support was added in version 2.0, released in October 2000, four years after UTF-16 was created. It was broken from the moment of its release, by virtue of being unable to represent non-BMP characters at *all*. Strike 1. In version 2.2, released December 2001, Python gained support for non-BMP characters. This version also introduced surrogate generation in UCS-2 builds, so non-BMP characters were stored as two code units. At this point, `unicode.__len__()` and `unicode.__iter__()` could have been modified to support surrogates without breaking backwards compatibility. The Python devs left them alone, dooming the rest of the 2.x line to broken strings. Strike 2. Python 3 was the next opportunity to fix things. Since string backwards compatibility had already been discarded, it would have been no major issue if characters were finally counted/iterated properly. Unfortunately, the devs once more left this behavior unfixed. There is now no way to support correct behavior in Python 2 *or* 3 without breaking compatibility with existing code. Strike 3.
If you, as a user, subclass while not knowing the implementation details of the superclass, which is how it's supposed to work, and you just happen to use the same underscore name for one of your private variables, you'll run into problems. 
And this again is proof that the oh-so-great Quora is just a soapbox for self important know-nothing windbags. I'm going to stick with StackOverflow thanks.
I don't use __foo much these days, but using the same class name twice in an inheritance hierarchy isn't worse ?
What kataire said. Also, Python doesn't *literally* turn your expression in to one containing `and`, it just does the equivalent logical operation. I don't think there's a way you (easily) can achieve what you are trying to do, which is basically changing Python syntax.
Bugs that manifest randomly are the way to go: import random True, False = random.sample([True,False],2) del locals()[random.choice(locals().keys())]
So which languages are these "every language/library which claims Unicode support"? We may disagree that Java has full Unicode support, but Java seems to claim to have Unicode support. In C++, "use [ICU](http://site.icu-project.org/)" seems to be a common refrain, but even ICU's [Unicode string length function](http://icu-project.org/apiref/icu4c/classUnicodeString.html#ac4cf80391a0e523c27aacaba796aede6) returns the number of code units, not code points. I'm not arguing that it is better to count code units, just that the most used languages all tend to do so and offer you another mechanism if you want to know the number of code points. Python is not necessarily one of the "lone stragglers" since it looks like you're going to have the same problem with the most popular languages. Sitting Guido down in front of a copy of "Unicode for Dummies" may not do very much since if such a guide were to exist it would have to address the fact that supporting code points vs. code units is inconsistent across programming languages and you may need to choose carefully which battle to engage.
Personally, it's the syntax. Python is overly noisy.
Ctrl+PauseBrk
About your second point, The whitespace scoping really did make me hesitant to learn python. I think I tried 2 or 3 times to get into python before it stuck Each time I started it felt like I was writing in some strange exotic language, where every function required an opening brace followed by a backspace.
Good point.
"Learn Python the Hard Way" is pretty much one big, inflammatory rant though...
&gt; By the way, whatever happened to PyPy? I thought that was going to solve all the Python performance problems. We're trying! http://speed.pypy.org/timeline/?exe=1&amp;base=2%2B35&amp;ben=grid&amp;env=tannit&amp;revs=200 should give you a sense of our current performance status (don't read too much into that giant twisted regression, it came when we merged our 2.7 branch and it's being investigated).
I don't know if those are still valid in current versions of mod_wsgi because I've switched to uWSGI / gunicorn on all my systems but the things that always greatly annoyed me were: * The need to have an empty "global" pythonhome (or whatever it was called) in order for virtualenvs with --no-site-packages to work properly. * The need to restart the whole webserver even if I just want to redeploy a single app (out of possibly many). 
Python is definitely typed and you can create type errors. What they mean is python has weak typing. I do think python (and javascript) could likely benefit from a system that allows for both loose typing and strong typing perhaps similar to actionscript that allows you to tag some variables. This would allow people to have type managed error checking in some cases or take advantage of performance improvements that could be had.
Bury this line somewhere in the middle of your code and suddenly begin using True as False and vice versa; then other people will have a nightmare trying to read the rest of it. I sense a Daily WTF in the making.
 class Quit(object): def __repr__(self): return "I will never die!" def __call__(*args, **kwargs): print("Never!!!") quit, exit = Quit(), Quit()
Call a function to switch it every five lines or so--call it neverDeleteThisFunction().
Speed aside, is PyPy itself ready for everyday use? Cause it looks like the Django test is much faster than the CPython one.
You don't have to have an empty 'global' virtualenv in order for virtualenvs with no-site-packages to work properly. You could just point WSGIPythonHome at your final no-site-packages virtualenv directly and it would work. You only need to introduce an empty 'global' virtualenv if you are going to be hosting multiple WSGI applications running in different sub interpreters and/or daemon process groups under the same Apache and those different WSGI applications need to have different virtualenvs. You also do not need to restart the whole webserver if you want to redeploy a single application so long as you use daemon mode. Restarting of the whole server only applies if using embedded mode. Have a read of: http://code.google.com/p/modwsgi/wiki/ReloadingSourceCode
I know of at least one person running Django on PyPy in production (as one of an eight server cluster, the rest running CPython), so yes I believe PyPy is in a state where people should be trying it out and putting it into production.
I know of at least one person running Django on PyPy in production (as one of an eight server cluster). I believe PyPy is at the point where people can feel confident putting it in production.
Ok, fine, imperative means not based on lambda calculus. Now, do we know how that *conceptual* design is implemented in Lisp? And now that we know that implementation, tell me how Python not being based on lambda calculus prevent it from using the same implementation technique used in Lisp to achieve the same scoping rule? The only reason Python has incorrect scoping rule is because it doesn't have variable declaration statement. It's all because `i=0` implicitly means declare variable `i`. Change the syntax it to `var i = 0` and see if you need any lambda calculus to fix that. &gt; LISP doesn't even have Python-style statements; Ummm, irrelevant implementation details. Lisp can use `PROGN` to represent multi-statement blocks. It's just syntax, Ruby and Smalltalk block can also be rewrite as Haskell Monad, and vice-versa. 
 __builtins__.True = 0 == 0 __builtins__.False = 0 != 0
&gt; You only need to introduce an empty 'global' virtualenv if you are going to be hosting multiple WSGI applications running in different sub interpreters and/or daemon process groups under the same Apache and those different WSGI applications need to have different virtualenvs. Yes, that's what I meant. (Mostly multiple projects using differing versions of some frameworks (e.g. django)). &gt; You also do not need to restart the whole webserver if you want to redeploy a single application so long as you use daemon mode. Restarting of the whole server only applies if using embedded mode. Have a read of: &gt; http://code.google.com/p/modwsgi/wiki/ReloadingSourceCode Right, I remember now that I already read that at some point and I even had the reloading monitor going for a while but had some kind of problem with it later on (sorry, can't really remember what it was). Anyway, thanks for making mod_wsgi.
The people over at the [Portland Pattern Repository](http://c2.com/cgi/wiki?WelcomeVisitors) agree with you: Python is dynamically and strongly typed. See http://c2.com/cgi/wiki?TypingQuadrant Compare to C, which has weak static typing; or Perl, with weak dynamic typing; or Java, with strong static typing.
Honestly, I wish the GIL would be fixed. Since that seems highly unlikely, I've decided to stop worrying about it, and sidestep the issue completely by not using Python when I need to use threads.
Can someone explain this? Python Expert Programmer fact = lambda x: reduce(int.__mul__, xrange(2, x + 1), 1) print fact(6)
Did you ever finish that postgres DB module? gunicorn seemed to work last time I tried it under PyPy so that seems like all the big moving parts.
Yup, the postgresql module works nicely, well enough to pass the entire django test suite at least: https://bitbucket.org/alex_gaynor/pypy-postgresql
Python's documentation summarizes reduce rather nicely: [Python Built-in Functions: Reduce](http://docs.python.org/library/functions.html#reduce) Calling reduce() in this manner is functionally equivalent to making a bunch of recursive calls, but it avoids the overhead of doing so. This operation is common when following the functional programming paradigm.
&gt; Python is, like Haskell and OCaml, strongly-typed. Type errors cannot occur, unless you drop down to C and start mucking around in the private structure attributes. WTF? &gt;&gt;&gt; len(5) TypeError: object of type 'int' has no len() &gt;&gt;&gt; Python had incorrect scoping rules in the past, but its current implementation (variables visible but not rebindable) is the best you're going to get in an imperative language. By current you mean Python 3's *nonlocal*? Current is Python 2.7 for practical purposes, and the original article cited examples of broken scoping. Using whether a variable is assigned to to determine whether it's local is just retarded. Clojure is imperative and has a non-broken scoping implementation. So does Groovy, you just have to use *def*. Your complaints are also complaints about Python implementations, not "python as a language".
Thanks. What is lambda?
A lambda function is one that can be used inline without naming it. sum = lambda x, y: x + y is equivalent to def sum(x, y): return x + y
Is this common with functional programming also?
Heathen. Ctrl+D
Always wondered what type of paranoia lead to this code that I see all the time at work if ( boolA == True) { boolB = True; } else if (boolA == False) { boolB = False; } 
"Weak typing" isn't a well defined term, but it usually means something like "1" + 1 = 2, as in JavaScript or Perl. Python doesn't do that. 
just a bit
make it a decorator
&gt; There is now no way to support correct behavior in Python 2 or 3 without breaking compatibility with existing code. Not true. The behavior of non-BMP characters in Python 2/3 is system specific, not universal, so it can be changed tomorrow without breaking any (well written) code since that code already has to deal with systems where things are set correctly. As it is today, you can compile Python with a flag to use UTF-32 internally and the non-BMP problem will go away. I have heard some Linux distros ship with that flag already compiled in. The main problem though is that the Python devs still believe that the trade off of performance/size/correctness still favors doing the wrong thing for most systems, so that remains the default. I can't say that I entirely disagree with them either, although I would like it fixed more generally. Edit: Looking further down the page, I see you already knew about the UCS-4 compile time option. So why do you say this can't be fixed?
The lambda is so named because of the [lambda calculus](http://en.wikipedia.org/wiki/Lambda_calculus). Lambda calculus is the original inspiration for functional programming.
interesting.
&gt; The only way to write fast Python modules is to use C check out numpy &gt; via the CPython API check out pyrex and swig
[Ipython](http://ipython.scipy.org/moin/) is a must! It adds many features to the interpreter, such as completion, better history, editor integration and much more.
And what about None?
lambda is Python's way of declaring anonymous functions. See [Wikipedia: Anonymous Functions](http://en.wikipedia.org/wiki/Anonymous_function#Python)
Not really. There are plenty of languages that fall within that definition of "type": any statically-typed language. I'm not saying I use that terminology, just that it is used that way by some.
btw other readers, if you've never used `dis`, its fucking amazing.
Some languages (lisps, erlang, haskell are ones that I'm aware of), defining a function is actually doing two things: creating a function and giving it a name. For example, in scheme, you'd write (define (add2 x) (+ x 2)) To write a function that takes in an argument and adds 2 to it. However, that's just shortcut for: (define add2 (lambda (x) (+ x 2))) Here, lambda creates the function that adds 2 to its argument and we use define to give it a name add2. In python, lambdas are less powerful than def because you can't have multi line lambdas.
Is the tailcall decorator standard?
That makes no sense at all. I mean... huh?
Ah very interesting. Is there anything in your opinion that's fundamentally holding python back from performing comparably to compiled C? Are there a lot of obvious optimizations not yet tried due to lack of resources?
Do you think it's just the weird syntax? It may be slightly unfamiliar, but with a good IDE (say SLIME in emacs), the language seems quite pleasant and readable to me. Plus, the core of the language is so simple: everything's either an atom, or a list.
No, it was more to show how "leet" the Scheme hacker is. (Tail call optimization is required by the Scheme specification.)
Since you're mutating the instance after a comparison, you can write the constraint setting as 1 &lt; X X &lt; 5 if you wanted to. Personally, my tendency would be to avoid mutating the instance and return a new instance instead. In general, Python's convention is to return `None` after mutating an instance, so that it's clear to the caller that what just happened has changed the object.
Perhaps I'm missing the joke, but couldn't that be written as: boolB = boolA 
 Windows Programmer NULL = None &amp;#3232;\_&amp;#3232; 
The way that function is written, it has to return an integer type, which probably isn't right if you want to do any calls on numbers greater than about 12 or 13. Someone else already explained how it works; I find it funny though that for getting higher order factorials it doesn't.
Thanks for the post!
 CalculateAndPrintFactorialEx(6, sys.stdout, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL) 
I'd go one further and suggest going py3 even if it hurts. If a lib hasn't been converted find one that has or use an alternative approach. Like it or not py3 is the future, switch over will be rather rapid once there core libraries are done. What is notable is that part of the hold up appears to be resolved at this point, well when 3.2 comes out. That should allow for many of the web related libs to convert over. I look at this way, if you are about to start a brand new project that will have a long life, why saddle yourself with an outdated version of Python. C programmers often have to keep an eye out for future standards but more so try to use the news features their compiler supports. It makes a big difference five years down the road when nobody wants to support old legacy code written to a different spec. 
Oh cool.. Here, have an upvote.. and a nice day
Absolutely. I've seen code where someone imports a class and inherits from the class using the exact same name. from module import Options class Options(Options): ...
But what if two classes in the inheritance hierarchy accidentally use the same name? There's no way to be sure.
Screw IRC! Python 3.2 will be out real soon, from there I expect to see a more rapid migration to 3.x. Frankly you call yourself a noob so look at it this way, if you where looking for a Windows Job which would you study up on, GW BASIC or Visual BASIC? While the situation with Python is different why learn the old ways first? Or better yet, say you are using C++ and the STL, do you learn the current and waiting approval versions of STL or something that was around ten years ago. I don't expect that every lib will be converted to Python 3. Frankly some shouldn't be as the community can do better. But many are or will be soon. Further there is enough in Python 3 and the packaged libraries to keep you busy for a few months. Personally I implemented a solution for work not long after Python.3 came out. Works great and I've had no trouble through multiple upgrades of the 3.x series since. Granted an extremely simple task but in a way that is what Python is for. I would expect it to keep working for the next ten years to (if Windows is around that long). It should be noted that I've seen a lot of excuses in this thread to not use Python 3. Lets face it if everybody had that attitude there would be tremendous stagnation in the industry. Somebody has to move forward. The comments about Arch Linux pretty much support the idea that Luddites are still a powerful and negative influence on humanity. 
I like Python myself, don't use it a lot but it is easy to remember which is a key factor. As to IDEs, first remeber that Python comes with Idle which actually works well but isn't fancy at all. At the other extreme there is Eclipse with PyDev, which is extremely powerful. Inbetween many editors work fine including EMACS and Vim. There may be better environments for whatever OS you are developing on. Kod on the Mac is an interesting approach that uses modern tech to implement and editor. Nothing is perfect and in this regards you have to try them on for size, fit and feel. Otherthings you need to know. For one the Python community is in transition with the shift to Python 3. I strongly reccomend that you learn Python 3 first and only regress if you absolutely have to. If you think scripting your programs will end up looking like scripts. Python is an interpeted programming language, if you think of it that way I think your programs will be better for it. One nasty thing with Python is the indenting to delimitate blocks of code. It isn't a bad thing unless you are merging somebody elses code or switching editors and end up with indentation screwed up. This can really screw up your day. If you switch editors make sure that any white space manipulation they may do is rational. As a side note XCode is a terrible place to edit Python code. Before you start to use any libs learn the language well and it's standard library. Don't even bother with web frameworks and the like until your knowledge of the basics is solid. You mention statics and dynamics which means that you are likely in school, so I'd make acceptions for some of the math packages to get home work done. I would ask around on the math and science related python sites for suggestions about where to start. As to your friends and their wonderful opinion of Python, well what can I say it is pretty good programming wise but it is also slow thus the tight integration with C. Of course slow is relative on modern hardware, it isn't like you are trying to do engineering calcs on a Mac Plus. In my case I use Python sporadically to solve problems here and there, mainly because it is easy, rational and sticks more or less. By sticks I mean that you can write some Python code one day and then come back months or years later and feel as if it was yesterday. You can't do that with a lot of languages if your programming efforts are sporadic and not your main interest. 
Not necessarily. Original code does not modify boolB if boolA is neither True nor False. Whether or not that's possible depends on the language.
You can easily fix that by adding an L to the 1 at the end, and using long.\_\_mul\_\_, as follows: fac = lambda x: reduce (long.__mul__, xrange (2, x), 1L) This works because you'll start the loop by multiplying 1L * 2, which yields 2L. Then, you're multiplying 2L * 3, which yields 6L and so on. If you just use 1, then it will complain that you were trying to use a method for longs on an integer.
Thanks! You just wrote that didn't you?
I agree that Python is a far more pleasant experience than Java, and I also think it's because of java's horrible type system. Some think all static type systems are that horrible but they aren't. 
I think you may have misread me. Being magical implies not being a keyword.
I don't want to sound like an asshole, this is just advice. You're not going to get very far in programming or any CS-related field if you feel you have to ask somebody in order to know something. A Google search for "python lambda" gets you the answer you need, quicker and with more information. Google is your friend.
&gt; Is there anything in your opinion that's fundamentally holding python back from performing comparably to compiled C? Yup, the semantics of Python fundamentally do not allow it to be as fast as C, there's too many checks that must be performed at runtime. &gt; Are there a lot of obvious optimizations not yet tried due to lack of resources? That said there's plenty of space between where CPython is and where GCC is, PyPy is somewhere in between and rapidly getting faster.
or just use `operator.mul`
How so? Just finished it and saw nothing rant-like or inflammatory. As a newb, Perhaps I lack the appropriate context to detect its inflammatory effect on others?
Is the project in a staff crisis?
Well projects always want to drum up interest and get more developers, opportunities like writing relatively easy bug fixes are a great opportunity for that. I wouldn't call it a staff crisis.
That's the joke. I probably run into this at least a few times a day, It works, but dear god does it make me cringe. 
The language is C#, and none of the values were nullable. So completely pointless.
not at all, but new contributors are always welcome
For anyone who's curious, here are the numbers on committers in the last ~3 months: http://paste.pocoo.org/show/324332/
The general formula for getting good at any language is: Write code, ask for criticism of your code, rewrite code. Repeat indefinitely. Doing open source is a good way to do this.
I'd say "[Line by line chimp](http://www.pygame.org/docs/tut/chimp/ChimpLineByLine.html)" and also digging the tutorials [here](http://pyratesarecool.appspot.com/Pygame/Tutorials).
We are not being Luddites. We are being pragmatic. I am old enough to remember when people were going around telling everyone to ignore C because in a few years everyone would be using C++. History is littered with upgrades to popular languages that did not ever go anywhere at all. It is not responsible to push a person looking for a language to learn toward the new thing simply because you like the new thing better. 
Good to know. 
~. hehe. hehehehe. :-)
* No assignment return. I'd like to do this: if foo = True: statement * Still no switch statement. I believe the common suggestion is to use dict_of_functions[switch_case_key](**kwargs). I do this but come on... give us a switch statement!
&gt; Python had incorrect scoping rules in the past, but its current implementation (variables visible but not rebindable) is the best you're going to get in an imperative language. public static KeyValuePair&lt;Action&lt;int&gt;, Func&lt;int&gt;&gt; MakeCell() { int value = 0; return new KeyValuePair&lt;Action&lt;int&gt;, Func&lt;int&gt;&gt;( x =&gt; { value = x; }, () =&gt; value); } static void Main() { var cell = MakeCell(); cell.Key(10); Console.WriteLine(cell.Value()); } Either C# has suddenly become utterly non-imperative and based on pure lambda calculus, or you are wrong.
Just tried it on Python 2.7 32bit windows build and it does indeed return 2 for those of you downvoting him. &gt;_&gt;
My Advice: Don't. You're going to end up teaching the whole team Python and probably doing the majority of the work. The whole project will take longer to start up because of learning time. I'd rather have a quick startup (in a school environment) than a crunch time at the end. Now, if this wasn't a school project, you might have more weight to your argument but remember you only have a semester.
I've only been programming Python for about 9 years, and I remember versions of Python that didn't include True and False. Back in the Python 2.1 / 2.2 days, it used to be pretty common to write code like this: try: True except NameError: True = 1 False = 0 (Or just use 1 and 0 instead of True and False for maximum compatibility, but some people find that ugly.)
Fair enough, I was much too quick critisizing - I just installed it, it has real column edit and regex which in itself will make it one of my preferred editors. Someone else said something about upstart time, it started instantly on my machine (ubuntu 10.04)
Sorry for my hasty criticism. Just installed it and like it. I have eight different editors right now and sometimes shuttle around to make my edits - it's annoying - so I'm always hoping for an editor that will make everything.
Python 2.x versus 3.x is a portability problem, however I don't think there are any systems out there without Python 2.x available. There are tools like zc.buildout and virtualenv which let you download the libraries required for your application into a local directory "sandbox". If some of those libraries contain C extensions (and numpy/scipy/matplotlib do), then you need to have a C compiler and all the required C header files. (Some of those libraries require Fortran as well.)
ugh, I'd have to do that a thousand times a year - that would be miserable
Even worse, they'll always have the "I could have done this in C with half the effort" thought going through their head every time there's something difficult with python. Unless they have expressed strong interest in learning python, I'd definitely recommend against it.
Have you asked their motives?
**Python Osmosis** http://python.secsup.org/ **VIM** http://www.vim.org **VIM TUTORIALS** http://www.derekwyatt.org/vim/vim-tutorial-videos/vim-novice-tutorial-videos/
I highly recommend you stick to Python 2.7 for now. The world isn't ready for Python 3.x yet, unfortunately, because of the small percentage of projects/libraries that actually support it. My projects don't support 3.x. It's on the roadmap though. Everyone else is the same way at the moment. In 2-3 years, hopefully this will be different, but in the meantime, use 2.7.
This is why I write my windows programs in x86 assembly. Just copy the stack pointer to EDI and "REP STOSD".
So, you were just being an asshole?
Don't press the issue. Your team has a higher chance of success the more democratic the decision-making practices are. Also, this being school, you should focus on learning, not achieving the best possible score. The process of building a compiler is pointless difficult task anyway, even better that it be done in the "wrong" language. That said: Most of the arguments are on the python.org webpage. Industry really likes it as an internal tool because it saves a lot of money in development costs and is easy for non-programmers to pick up and use. I assume you've said all this and if they are willing to give it a day or so to try it out, I think that's the best you can ask for.
I always found this, Vtiger, and Sugar to be 90% shit i don't need and cant get rid of and 10% shit that barely does the job properly. Running it on a server for any of them is a nightmare and doesn't seem to follow and standard of deployment. (Trac is guilty too) If you're a python developer, you will likely be better off building something for your business with the Django admin.
If anyone was curious, I ran the script [Python 3 #6](http://shootout.alioth.debian.org/u64q/program.php?test=fannkuchredux&amp;lang=python3&amp;id=6) from the Shootout with CPython and PyPy, with N=12: Python 2.6.6: 33m48.100s PyPy 1.4.1: 9m35.539s 
&gt; the only languages I can think of that allows anonymous multi-statement blocks are Ruby and Smalltalk. Looking at an example of how they're used in Ruby ought to be sufficient motivation to ban them in Python. Care to elaborate? Not that I'm keen on Ruby's blocks, but I'd like to hear your gripe about them. 
I always forget about dis and then whenever I see it again, I'm pleasantly surprised all over again.
I found the book "Expert Python Programming" by Tarek Ziadé very interesting, it covers some advanced topics. That's for theory. For practice, start following some open-source app that is written in python and that you find useful (this is important). Pull the trunk on a daily basis, see what's new. There's a good chance that you'll meet people who are better than you at python, this is great because you'll be able to learn a lot from them. Eventually you will understand the codebase better, you might find some bugs and even contribute some patches. At this point it will be a win for everyone, not just for you.
Yeah, well, our code base is littered with "while 1:" statements. After spending some time with our code base, you'd probably start giving "while True:" the stink eye too.
Read SICP. You're curious enough to spend a couple of days learning the basics of functional programming, and it will help you a lot. The lisp code can all be converted easily to Python as long as it doesn't use macros.
Also, you're in a class. Take advantage of the opportunity to use and learn a language you might not use on your own.
People are still using Python 2.x?
I desperately want PyPy too. NumPy, SciPy and Python 3 support can't come soon enough :(
I hate the way "while 1:" looks though.
In my mind, the benefit to a small academic team is that you can iterate quickly. A scripting language like python allows you to re-run your application without waiting to rebuild. When I worked on group projects a big problem for me was synchronizing our development environments, this is considerably easier in Python vs C/C++ A lot of de-facto parser tools are built for C (flex, lex, yacc, bison, etc). There are some Python versions of these tools, but they are less mature than their C counterparts.
Don't do this! There is to much to draw on in the C/C++ world for this sort of project. 
Start an open source project. It'll teach you everything you need to know about programming, software development, project management, customer service, marketing, community building and more. It doesn't matter what the project is. Just write something you'll use and you think you'll enjoy.
&gt; WTF? Python is dynamically-typed; that means type mismatches occur at runtime, vs compile time. Both options prevent type errors, where a value of type A is processed as if it's of type B (usually leading to a crash). &gt; By current you mean Python 3's nonlocal? Current is Python 2.7 for practical purposes, and the original article cited examples of broken scoping. Using whether a variable is assigned to to determine whether it's local is just retarded. Clojure is imperative and has a non-broken scoping implementation. So does Groovy, you just have to use def. IMO Python 2's behavior is correct. `nonlocal` is a terrible hack that should never have been included in the language.
IMO that behavior should be a compile-time error.
They allow arbitrary rebinding of up-scope variables.
Why? It seems that you have some pretty weird ideas. I mean, like, lambda-calculus __does not__ allow rebinding of any variables, so when you say *"Imperative meaning not based on the lambda calculus"* to clarify your statement, I can't imagine what the thought processes behind that could possibly be.
You can't easily reinterpret an object and stomp on arbitrary memory like in C, I'll give you that. http://stackoverflow.com/questions/1195577/python-scoping-problem This type of issue with the python 2 scoping rules is way too common, and it's the price of not requiring explicit variable declarations. In hindsight the Groovy style "def foo" works much better than just allowing variables to be defined implicitly by use because it prevents typos from accidentally defining new variables, as well as making scoping explicit. 
I've never had a problem using PLY. It uses the same shift-reduce concept that the C equivalent tools use.
Your point is that `value` is defined in an outer scope and rebound in an inner scope, right? I think that allowing that behavior is a design flaw in the language. The lambda calculus, and most languages based upon it, do not allow variable rebinding at all. That allows some more reasonable scoping rules to take effect.
&gt; I think that allowing that behavior is a design flaw in the language. Right. Why? &gt; That allows some more reasonable scoping rules to take effect. Ah, I think I understand now. Do you mean that unlike in Python you can't accidentally shadow the upper scope variable with an assignment and that's the one and only thing that is more reasonable (also unachievable in an imperative language)? Well, actually you can do it just as easily, as far as I understand. `x = expr; statements` is translated into '(\x . statements) (expr)`, kind of.
&gt; Right. Why? Spooky action at a distance. Closures can be executed from arbitrary points in the program, so seemingly-immutable local variables might be modified from anywhere. &gt; Do you mean that unlike in Python you can't accidentally shadow the upper scope variable with an assignment and that's the one and only thing that is more reasonable I'm talking about rebinding, not shadowing. The actual variable reference itself is modified, which affects all other code sharing the scope. Consider: def outer(): xs = [] def reset(): xs = [] def push(x): xs.append(x) return xs return reset, push In this code, calling `reset()` will actually change what variable `push()` assigns to.
ooooh, snake! jiiip jip jip jip jip jip jip jip.
&gt; Closures can be executed from arbitrary points in the program, so seemingly-immutable local variables might be modified from anywhere. The code that modifies the variables is right here -- inside the lexical scope. It can be called from anywhere, but from the "reading the code" standpoint I can't see any difference from having mutable variables in general. What's the difference between changing the variable from inside the nested scope and from inside the nested loop? I mean, sure, some people consider mutability in general to be restricting rather than liberating, but I think that it's a bit unethical to attack a special case because you dislike the general principle, but as if there's something wrong specifically with that special case. &gt; I'm talking about rebinding, not shadowing. Then I'm confused. What you said initially had the form, "you can do x in y and it's the best way you can do x in any Y, as opposed to Z". Which I took to mean that there are some Z (functional languages) where you can do x (lexical scoping) better than in y (Python). Also than in the rest of Y (imperative languages), but that doesn't matter right now. So I don't get it: how can you do lexical scoping better than in Python and what do you mean by "better"?
You might also be interested in the [Fabric](http://2ze.us/3t) project. This will let you script the process in a Pythonic fashion, and it's designed to work with multiple hosts. It's a very neat project. I use it to deploy all of my Django sites.
have you ever deployed an accounting system?
&gt; What's the difference between changing the variable from inside the nested scope and from inside the nested loop? The nested loop can only be entered from a single point. All the logic related to it is immediately visible. A closure can be executed from anywhere, so figuring out what's calling it or when it's called relative to other parts of the code is very difficult. &gt; So I don't get it: how can you do lexical scoping better than in Python and what do you mean by "better"? The best lexical scoping supports arbitrarily nested scopes, with variable shadowing, but not variable rebinding. Most functional languages use this model, because lambda calculus does not allow rebinding. Most imperative languages with nested lexical scope allow arbitrary rebinding, which leads to difficult-to-reproduce errors and confusing behavior. Python 2 only allows rebinding of local variables, not variables from an outer scope (ignoring globals). This is probably the best choice for an imperative language, because so many imperative algorithms depend on local variable rebinding. It *is* possible to emulate variable rebinding in Py2 by using a mutable wrapper, which is unfortunate, but usually ugly enough that it's obvious something fishy's going on. Python 3 allows arbitrary rebinding, but only with a magic "shit's about to get magical" keyword. Essentially, standardizing and endorsing the mutable-wrapper idiom.
Pendulum, or Prodigy, something with loads of bass :D
No no. PyPy wants people who are much better at programming than me.
Startup time is certainly a consideration, but if these people are already experienced programmers, they shouldn't have much difficulty picking up Python. Back when I first tried Python, I was surprised by how easy it was to be extremely productive with it literally hours after I had picked it up. Still, if your teammates don't feel comfortable with the change, it's probably best not to pressure it on a project that has a deadline. Maybe get the group together for one meeting to try a little experimentation with Python to see how they like it? Also, FWIW, you don't have to work with regular expressions in C if you don't want to! Writing a scanner by hand is pretty easy unless your language has an excessively complicated lexical structure.
You can also join ones which already exist. Plenty of those around
you can try #define exit(x) &lt;Python_Exception_Function&gt; in your c code. Not the best thing to do in general, but it will probably work.
&gt; A closure can be executed from anywhere, so figuring out what's calling it or when it's called relative to other parts of the code is very difficult. Yeah, but the point is, there's no reason to consider the problem of noticing that variable rebinding _does_ happen to be of different importance whether it happens inside a nested loop or a nested function. And _if_ you know that this variable is modified from the nested function, then either you either use that function inside the same scope and never return it, or you are using closures as poor man's objects, and in that case you explicitly refuse to know when and how your consumer calls your `reset`/`push` methods. In either case I don't see a problem. I can't honestly say that I've ever used the second approach in a serious context, but the first one is occasionally useful. As in, def do_something(data1, data2): stuff = [] def process_data(data): stuff.extend(data) process_data(data1) process_data(data2) return stuff ... Obviously, where 'stuff' is a rather complex structure which it is easier to modify imperatively than aggregate over several calls of the nested function. I've never encountered any difficult-to-reproduce errors or confusing behavior while doing that.
Seeing you already got an explanation, I thought I'd churn in with a FPL implementation of this FP concept. In Haskell, this is: fact x = foldr (*) 1 [2..x] Read as: "fact of x is a right-associative fold, using (*) and 1, on the list 2..x (inclusive of both sides)" Though the expression "foldr (*) 1" already has a name, it's called "product", so we can just say: fact x = product [2..x] 
I didn't know about that book and the subject truly interests me but that review left me wondering whether or not it was worth it. The whole metaphor aspect worries me. Has anyone else read it?
&gt;Startup time is certainly a consideration, but if these people are already experienced programmers, they shouldn't have much difficulty picking up Python. Back when I first tried Python, I was surprised by how easy it was to be extremely productive with it literally hours after I had picked it up. See, that's what *I* would have thought too... When I picked it up for a job back in 2004 it was cake and I've *never* looked back (e.g., now Python is my "go-to" language for everything). But then I got into this team that I'm on now and when I suggested using Python a few months ago (they wanted a high-level interpretive language like their beloved C# except natively supported by a *very* wide array of Linuxes, and, honestly, *only* Python satisfied that requirement due to two of the Linuxes being embedded and *only* including Python as a native interpretor) my team *freaked* out at the concept of learning a new language. In the end, we went with C/C++ and statically built binaries (which is a mess since libstdc++ can't be used to build static binaries under most Linuxes anyway). So, ultimately, consideration of your team's... what's the best way to describe it? ... *temperament?* is probably more important than their actual skill... And if the OP is going to be fighting a bunch of douchbags all semester long, it may be easier to just say "screw it" and do it in C/C++ anyway... 
http://www.cplusplus.com/reference/clibrary/cstdlib/atexit/ EDIT: NM. It won't cancel the exit.
use sed
 x = bigassstruct_alloc(); if (lol) exit(-1); bigassstruct_free(x); Yeah, not going to work. The assumptions on exit mean that you can't just make the function return early, or any such convenient thing. The guy that wrote it was thinking: "Hey, you know what would be a ton of work with little immediate gain? Graceful cleanup." Cue OP to touch it up!
PyPy wants me? No longer am I forever alone!
From experience, Tornado is so underdeveloped as anything but a pretty featureless HTTP server that adding to it is particularly difficult. For example, asynchronously monitoring a subprocess appeared to require nontrivial edits to ioloop last I checked. If you want something that is not (just) a web framework, check out Twisted instead. For a slight loss in performance, you get 1000000x more functionality.
If you don't have source to the module, it should be possible to edit the existing binary to link against some other symbol instead. Then you just provide that symbol. In general it sounds like what you're doing is going to be doomed: you suddenly have all these execution paths that previously won't return suddenly returning. What about `os.fork()`? If your module isn't called 100000000 times a second, how about forking the process and making the function call in a subprocess?
I've built many python based business automation products for clients. Ecommerce and stock tracking mostly.
Wow, neat. I've wanted to do this before but didn't know how to get it to work.
Thanks for the review. I ordered one yesterday and am even more excited for it to arrive now.
OK, well I've spent a decent portion of my early career rolling out mid-level accounting systems and customizations. These systems are complex for a reason. Mainly because they help companies comply with the laws and regulations that they need to. While providing a significant amount of flexibility to be able to taylor to the specific needs of the industries their customers are in. it is not trivial, and for the programmer it's not fun. to think that someone can come up with an out of the box solution that will work for everyone is absurd. on top of django-admin is laughable. I don't exactly know what your expectation for this kind of thing, but i think it's a little naive. I'd love to be proven wrong..... someone write a django erp for me. **edit** It's not that an erp couldn't be written in django-admin, it's that by the time it's an erp, the fact tat django-admin is in there somewhere would be a very minor detail. I'm sure a lot of the downvotes are from some flyby django fan taking my comment as a criticism of django. I am in fact pointing out that erps are boring and difficult and that it's silly to think you are going to get an out of the box solution that works. Every company is different, thus every erp implementation is different. At least there's a core written in python that could be used if you are unfortunate enough to have to do this kind of work. 
The ones I have looked at do not work with P3 yet. I have looked at Django, Pylons, Flask and web2py.
http://bottle.paws.de/docs/dev/index.html http://www.cherrypy.org/ (Latest release candidate supports Python 3)
No one will fess up to it, though I'm guessing it is the same person who constantly uses stringVariable.ToString(). Incidentally "We need to make it more stringey damnit!" has become a favorite tagline of late.
If it hasn't been mentioned, you can always do both with ctypes or SWIG.
I don't know how, I don't know when, but this is going to make my life *much* easier at some point. Thank you for not trying to explicitly port structs to Python.
web2py makes a promise to its users about backward compatibility. We have written it to pass most of 2to3 but we are not planning to port to 3.x because of such promise. It is not technical issue, we could make it happen tomorrow. It is a markting issue. There may be a web3py (or a web4py or hopefully a better name) that runs on python 3.x but it will the same as web2py. If we need to break our users's app, we'll try to make it worthwhile to them. ;-) Anyway, I am waiting for 3 things to happen to python: 1) to replace reference counting for garbage collections; 2) to remove the GIL; 3) to include support for lightweight threads (like erlang). Without these features I am not motivated enough to move on.
This looks fascinating and quite useful. I've got a project on the back burner that needs to manipulate a number of media file formats and I'll definitely be adding biwako to the hopper of potential tools when I move that puppy to a front burner this summer. 
Am i right in my understand that if you can either download and set this up yourself, or pay to use it hosted my the company? Sounds like a sweet deal.
This is a terrific idea. I have a bunch of different data structures from different devices on different networks that I have to create python structs to support and it's such a pain to pack and unpack them in a rational way. Too bad it doesn't work with 2.6 and there are no options for bitfields.
having a look at the pika module he linked, I have to ask, why is he using a timer to schedule write events as opposed to using the ioloop write event?
Make sure it still returns from that function, otherwise you'll probably get crazy undefined behavior. Even with that precaution, you may still run into undefined behavior... Nonetheless, it should be something like: #define exit(retcode) do { \ PyErr_SetString(PyExc_RuntimeError, "Aw shit, something really bad happened!"); \ return; \ } while(0)
Is subclassing `list` in particular an important requirement? If you just need fast matrix math, use `numpy`. Otherwise it shouldn't take too long to write this class yourself. You just need to override `__add__`, `__mul__` etc.
Agreed, it's about 10 minutes work, really you just need to know the magic methods to overload operators in Python (see http://docs.python.org/reference/datamodel.html#emulating-numeric-types)
You're joking, right? A lot of people are still using Python 2.5 and Python 2.4 (RHEL, CentOS, and SUSE AFAIK use it). No one uses Python 3.
Couldn't all this be implemented with linked lists to make insertion and deletion trivial?
Sure, but linked lists have their own shortcomings, like the speed of looking up a particular index. If there was one ultimate data structure, people wouldn't bother with all of these different ones. You really have to pick the one that best suits your problem. Then again, most of the time, it doesn't matter much anyway.
It's all about the application. Insert and delete aren't too common in Python. Append, however, is.
That's a nice comparison, but why would someone set their font-size to 11px?
It would be nice to see this information included in the official documentation for each method. One aspect of the C++ STL I always liked is that time complexity documentation was widely publicised.
Jython or IronPython would give you items (1) and (2) on your wish list. The latter has performance generally equivalent or better to CPython. However, neither offers Python 3 language compatibility yet.
Usually, i do dir(something) to get the functions of that something that i know does what im looking for. In your case, you could do dir(1) to get the operations that ints implement (add, sub, div, shift, etc). Usually works wells and you may discoverr some magic functions you didn't know about before.
I honestly forget about Python 3 until I see it mentioned in a blog. Maybe it was just a honey pot for language lawyers. Like the part of Hitchhiker's Guide where they send all the middle managers and hair dressers on the first rocket to the new planet and tell them, "Don't worry. The rest of us will follow along in another rocket soon.". But I heard Guido has a plan to *make* us use Python 3. Damn, has CPython jumped the shark? I just sent $100 to the PyPy team.
well, for now python 3 is just a clever way to really have the language moratorium on python 2 work - because all changes from now on will only happen in python 3 (as there are no plans for a python 2.8 in sight) and so finally alternative implementations get a realistic chance to catch up with python 2. which will probably make python 2 the scripting languages with the best infrastructure due to several compatible implementations :) 
also the colour scheme has imprinted black and white stripes all over my vision now I've moved away from the page. It's most unpleasant.
&gt; well, for now python 3 is just a clever way to really have the language moratorium on python 2 work The language moratorium is on Python 3, not Python 2. Python 2's development is not under a moratorium it's under *being dead*.
The revised PEP can be found at: http://www.python.org/dev/peps/pep-3333/ You can compare it to the original at: http://www.python.org/dev/peps/pep-0333/ Don't know what you are referring to when you say 'with a weird error handler at convert time instead'. The end result of everything was that bytes just wasn't practical. See Armin's recent comments about it in: http://lucumr.pocoo.org/2011/1/22/python-the-web-and-little-things/
Use Notepad++ it does a good job. But if you really want a good editor use Eclipse or Aptana Studio (basically the same thing) they have a python extension it is a big program and kindof hard to set up but if you are looking for a fully functional code editor. I think the problem is your python path which has to be set in windows through the control panel or it will not be able to find your file. The easy fix to that is to simply save the module in the same folder your python program. Depending on the editor some will allow you to set a path. Python has a pretty good editor built in and you dont have to dick with it as much . Edit: [This one looks good](http://www.pnotepad.org/) might give it a try. Try a bunch they just make you a better programmer by trying to get them to work. Good Luck 
I thought that some decision had been made to use `errors='surrogateescape'` which takes a byte string and converts it as UTF-8 where possible or some Private Use Character where not. Maybe I'm confusing things together. 
Sorry, I forgot to mention that I'm using snow leopard on the mac. 
Oh I don't have a clue. Call up Steve. That is the problem with Apple. They work great till they don't then nowbody knows what to do as they have those machines locked down so tight. Still I reccomend eclipse if you want a powerful editor. If you really get into coding you can customize it for about any type of code. It really is an editor built for projects and lots of people use it. I have it set up for Android now and am messing with that. Point being, once you learn how to use Eclipse you can use it for about anything with code and it pretty easy to use really after a little time. Alot of people especially older wiser programers swear by emacs, but that is a whole other realm and you have to put in as much effort learning it as you do learning a language but you should try it if you want to fully expeiriance the world of code. 
I'll try Eclipse. Thank you for taking the time to help.
A generally useful language needs a stable interface. Is ANSI C dead? Perhaps Python needs a formal standard...
&gt; Is ANSI C dead? There is no relation between ANSI C and Python 2. Your question makes no sense, because the ANSI C spec predates implementations, and most C implementations *still* do not fully implement C99. Furthermore, nothing prevents JTC1/SC22 from creating a new revision if C99 is ever fully implemented by compilers. ANSI C is not dead because ANSI C has *not* been declared dead (as in no future evolution) and a stable target forever. Python 2 *has*. The PSF and Python's core maintainers have explicitly stated there would be *no* further development of the Python 2 language. &gt; Perhaps Python needs a formal standard... What for?
I can understand Armins doubts of porting werkzeug to Python3, but of course I would like that. In fact most Python libs I use (PyQt, lxml) are both running allready with Py3 and only the web-Programming let me stay at 2.7. Of course one could switch versions depending on which problem he must solve, but honestly it is difficult for me to keep all changes in mind. So I will stay at Python2 at the moment and wait for werkzeug is ported to Python3 :-)
regarding (3), what do you think of greenlets? I find them delightful to work with and they're supported out of the box by the awesome PyPy. They're not actors though, like Erlang, but they come pretty close with abstractions that are provided by e.g. gevent.
numpy is overkill for the project. I have already started working on it, but there are [a _lot_ of magic methods](http://www.rafekettler.com/magicmethods.html)to override. Luckily, I was able to write a code generator for most of them, and I am now just filling in a few missing ones.
[Ten minutes?](http://www.rafekettler.com/magicmethods.html) Not if I want to override all of them, but I was able to cut the time down using code generation for methods that needed to be handled similarly.
being dead is a very efficient moratorium. and the ultimate way to allow others to catch up.
&gt; being dead is a very efficient moratorium. No. A moratorium is a *temporary* cessation (/prohibition) of activity. Being dead implies it's not temporary.
the permanency of death is highly overrated.
Form PEP-3333 &gt; On Python platforms where the str or StringType type is in fact Unicode-based (e.g. Jython, IronPython, Python 3, etc.), all "strings" referred to in this specification must contain only code points representable in ISO-8859-1 encoding (\u0000 through \u00FF, inclusive). It is a fatal error for an application to supply strings containing any other Unicode character or code point.
Personally, I prefer vim. You'll get a lot more done in a command line editor, and you'll feel like a boss doing it.
Good point, I don't know why I left that in there... was experimenting with something at the time. Anyway it's been fixed in Pika. Thanks!
I've used Tornado fairly extensively in some large scale applications and haven't had the same experience than you. I'm not keen on full stack frameworks in general though (Django, etc). RE monitoring were you using multiprocessing or handling the forking on your own? Why would you put this in the IOLoop in the first place? FWIW I've played with Twisted and found it to be lacking in the web area which is why I ended up with Tornado in the first place. I am working on a Pika adapter for the Twisted as well.
I'm sorry I'm not quite clear on what you're trying to do. Are you trying to run a python file from within the python shell?
&gt;&gt;A pretty depressing quote on Python 3 came from Mark Pilgrim: &gt; Python 3 is a commercial disaster. In 2010Q3 I had negative sales of DiP3 [Dive into Python 3]. More people returned it than bought it. I'm considering retro-fitting the book's content to Python 2.7 and re-releasing it as “Dive Into Python 2.” Seriously. &gt;&gt;At least this clearly shows that Python 3 is not going as good as it &gt;could, and that rethinking the roadmap might be a good idea. If the author of that blogpost would have bothered to read the rest of the comments, he would have read that most returns are due to shoddy quality of the physical book. 
yeah, but now you're not removing the write event when your buffer is empty ._.
I really meant ANSI C89 as my example of a static language target that is extremely important mostly because it is static. People that want C that will run everywhere forever do not use C99 specific stuff. If the Python3 faction really wants people to adopt Python3 they will have to sell it. The specification of a language exists independently of the major development of that language. There is much more effort invested in Python programs than the Python language and core libraries. This application code creates its own standard version of Python even in the absence of a formal standard. The Python3 people are free to suggest that we should all change the way we program to the Python3 way but we are free to ignore them. In the unlikely event that the present Python implementations become unusable then we have all the various languages to choose from, not just Python3.
I did not know they were supported by PyPy. Will give them a try. Thanks.
&gt; and you'll feel like a boss doing it. I use vim, but I'm not yet at the stage where I can operate it with dazzling efficiency, so this is the principal reason I use it. If you do use it: 1. swap your caps lock and escape keys and 2. go through the tutorial.
You don't mention whether you're an accomplished programmer picking up a new language, or whether learning Python is wrapped up inside the bigger issue of learning how to write code. Assuming you're new to programming, I'd avoid Eclipse and other programmer's environments, because they present you with too many things that you'll have to consciously ignore (because you're not ready to understand what they do), which just increases the complexity of serving your fundamental learning objective. I would also avoid vim at this point (even though it is my personal editor of choice) because, again, it is presenting you with more things you have to learn about, that have nothing to do with programming. I would get [TextWrangler](http://www.barebones.com/products/textwrangler/) and give that a try - it's a decent text editor for the Mac. Another alternative you could try is the Java-based [jedit](http://www.jedit.org/), which is somewhere between simple text editor and full-blown IDE. It starts out as a text-editor but with hundreds of plugins and extensions available, can grow with you as your needs mature.
I wouldn't say I can operate it with dazzling efficiency, either. I don't think I know any of the more advanced commands. Eliminating use of the mouse and using vim tabs in screen has really increased my productivity, though.
&gt;as there are no plans for a python 2.8 in sight And never will be. 2.7.x is the end of the Python 2 line.
Thanks :)
&gt; If the author of that blogpost would have bothered to read the rest of the comments, he would have read that most returns are due to shoddy quality of the physical book. There was one single comment that said the physical quality was bad. However the follow up comments from Mark Pilgrim on hackernews are here: http://apps.ycombinator.com/item?id=2120616
Gentoo does this too, altho it is user-configurable.
&gt; I really meant ANSI C89 Then you might have wanted to say that. &gt; as my example of a static language target that is extremely important mostly because it is static. Which has 0 relevance. &gt; [reams of completely irrelevant word-salad] Have you considered the concept of words as the medium for meaning? Because your second paragraph seems to contain only hot air.
I sure see people write an awful lot of new code in a supposedly dead language. 
That's the party line.
I can't recall now, but I think it was related to handling subprocess exit without either interfering with other code in the process, or something else closely related. You either install a bunch of global hooks (e.g. SIGCHLD handler) which will trample on other code creating subprocesses, or do something like waitpid(WNOHANG) when a 0-sized read() from the subprocess's read FD (i.e. an EOF signal) occurs. The IO from the subprocesses was to be handled streamily (there were more than 100 to be run simultaneously), so integration with the main loop was very desirable. Whatever it was, I gave up and moved 'home' to Twisted, despite its evil WWW support :)
1. I wrote that Python 2's *development* was dead. 2. That a language be considered dead does not mean it's unused, Cobol is generally considered a dead language and there are still thousands of banks running on them with staff and contractors fixing existing cobol code and writing new cobol code.
&gt; only the web-Programming let me stay at 2.7. Not if you were using [CherryPy](http://www.cherrypy.org/browser/branches/python3).
Not only can CL use progn: lambda and many other functions/macros implicitly allow for multiple forms: (lambda (x) (setf *some-global-var-or-something* x) (princ "Success!"))
Could you elaborate on what you mean by Lisp not having Python-style statements? I'm not sure I understand what your point is. 
also why does my browser need to be wider than 960px? 
I thought I was having a grand mal seizure...
I guess we're thinking of different layers of the onion. True, at a level *below which most of us do not care to go*, there are basic primitives that everyone uses, but those primitives don't give you [edit: working] objects until you put them together. Which can be done, and is done, in an insanely divergent myriad of ways. So many ways, as paraded in the perldocen, that the paradox of choice kicks in. 
I'm writing a guide to all the magic methods in Python. Should be pretty useful when it's done.
If you're using Python on a Mac there can be no better editor than [TextMate](http://macromates.com/). In fact, that's a great editor for most languages, my only exceptions are Obj-C which I'll use XCode for and Java which I use Eclipse for. 
Eclipse is fantastic for developing with Java, but I find it's very bulky and unsuited for Python, particularly if you're only working on small-scale projects. Although I can see it possibly excelling at helping to organize large Python projects.
&gt; So many ways, as paraded in the perldocen, that the paradox of choice kicks in. I suspect--and have great confidence that a systemic study of working could would demonstrate--that the one point on which Perl OOP may differ the most widely, 99 out of 100 programs bless hash references and nothing else. In practice, this is not a problem.
Komodo has a good free version on their editor that works on Mac. I use emacs myself (killing end of line whitespace is a nice feature in this particular use case).
Thanks for that info, but I chose the libs and freamworks I use by the quality, documentation and "feeling", not by the language version. So I am used to use werkzeug and flask and I have no interest in using cherrypy.
According to the [developer's manual](https://docs.google.com/viewer?url=http://education.ti.com/calculators/downloads/US/Software/Download/en/177/6584/sdk83pguide.pdf), the TI-84 floating point format is not a `2**n` or `1 / (2**n)` data type; the values in memory are exact to 14 digits. See page manual page 23 / PDF page 33. From the text, -234.5 is represented as (128, 130, 35, 69, 0, 0, 0, 0, 0) or (0x80, 0x82, 0x**23**, 0x**45**, 0x00, 0x00, 0x00, 0x00, 0x00).
CherryPy is quite good. Just saying.
Didn't know CherryPy wasn't quality software.
No, stuff is converted by byte preserving latin-1 and not utf-8, so don't need surrogateescape.
But Python 2's development is not dead. The CPython 2.x interpreter may not be developed at present, but PyPy for instance is still writing a Python 2 interpreter last I looked. At present, the Python 2 language definition is not being evolved. I don't think that will last. 
Maybe I'm thinking more of the blogs posts about it, but the entire premise of the book is that every other Python textbook babies people into becoming terrible programmers. The book itself is almost one big troll. It's written in an incredibly condecending tone and *actually says* things like "type this out again and again until you get it right" and "There is something wrong with this example. See if you can figure it out. No, I'm not going to tell you."
&gt;Python 3 is clearly the better language, hands down It's odd that the author mentions this with such vigor that he doesn't even feel the need to give evidence or even try to argue much why. It begs the question however, if python 3 is the better language hands down then why.......(you can pretty much fill in a good number of questions here)? 
Then there should be one perldoc that all other OO related perldoc point to showing a best-practices way to do this. Let's not pretend there aren't a bunch of details. There's a book about OO Perl, and it's largely an exploration of arcane and wonderful hacks, but the meat and potatoes is hard to find. Or you can go to Perl Best Practices book, and read about some "best" practices until you learn that the community no longer approves of them. OK, I'll stop my moaning. I gotta say I think it's a great thing that your book is out, and I'm looking forward to reading the section on OOP in Perl next time I have a need to do some of that. Or hopefully before. And I do wish some of the newer stuff would kill off some of the old perldocs that present the paradox of choice. 
&gt; I do wish some of the newer stuff would kill off some of the old perldocs that present the paradox of choice. Me too, but removing anything from Perl 5, even something almost universally reviled, is a long, laborious process.
Firefox, readability plugin.
&gt; In my thinking, containing all of the database-driven models on a database object feels safer than having them be free-standing classes. This statement doesn't really seem to make sense to me.
I'm kind of disappointed by pyramid. I was hoping for a microframework using webob.
[PEP-3333](http://www.python.org/dev/peps/pep-3333/) was just approved so support should be forthcoming with the full release of python 3.2.
Thanks. Here ya go @OP
Broken link. edit: Unbroken.
I pick web2py for good idea and how a framework should be. But I also point out you wont find alot of sites using it as much as DJango which seems to have a cult following and lots of extensions. I think web2py is simpler and made with hindsight. But its like the electric car. Great idea to bad we did not start that way but now that we all drive gas(django), its a bitch to change. 
Thanks for posting this. Just a general note: Never hesitate to email us or submit feedback from the Help menu in the IDE. We are quite interested in hearing about the features that people miss in Wing IDE.
Beta6 should be faster. There were definitely some performance problems in beta5.
Wing 4.0 beta6 supports Python 3.2. We'll try to update Wing 3.2 soon also.
"Pyramid, Y U no microframework?"
If you try Wing, please let us know how it goes (by email or you can submit feedback from the Help menu). In general, I'd recommend trying the various IDEs first hand as the only really good way to see how they're going to compare for your particular needs and code base.
Oh, he means “forward compatible” or “forward-compatible”. It might seem like an inconsequential difference, but “forwards compatible” had me really scratching my head. http://en.wikipedia.org/wiki/Forward_compatibility
&gt;But I also point out you wont find alot of sites using it as much as DJango Very true, though more and more sites are [using web2py](http://web2py.com/poweredby). It's also used by a lot of organizations for internal sites/applications that are not publicly visible. &gt;its a bitch to change These links are old, so probably no longer completely accurate, but see [here](http://www.web2py.com/AlterEgo/default/show/189) and [here](http://www.web2py.com/AlterEgo/default/show/101).
It's clear [to me] that my problem is not sufficiently defined, but I think I got the jist of it across. I'm just having problems thinking of new search terms to narrow the scope..
I really like web2py dont get me wrong. And I am much better with it than django which seems to have its own way of doing thins. Massimo created it to teach people about frameworks so I think it is very pythonic in the way it does things. I just have not seen the steam build up behind it. But I truly would choose web2py if I was to be given one or the other. I consider myself a medium level programmer. 
you're STILL doing it wrong. It's okay though, I did it the correct way here: https://gist.github.com/791855 
If you're interested in using the tornado.web, tornado.application, etc.. see Cyclone. It's a port of the Tornado framework for use with Twisted. https://github.com/fiorix/cyclone
The last thing the Python web-ecosystem needs is another microframework. An alternative to Django would be preferable, IMO.
does it have support for c-strings (variable length, terminated by null) and prefixes (bencoding like item that prefixes its length, so that you'd have to use the previously parsed item to parse the next)?
random.shuffle shuffles the list in place. When you add a list to another list (yo dawg...), it simply puts a reference in there. Therefore, you have a list of 10 references to the same list. To get what you require, copy the list before appending it: a = [] for x in range(10): random.shuffle(listx) a.append(listx[:]) Note the **[:]** on line 4, which takes a slice of the entire list. Note that in your generator example, you would need a function that has a side effect: def shuffleAndCopy(x): b = x[:] # copy list random.shuffle(b) # shuffle copy only return b a = [shuffleAndCopy(listx) for x in range(10)]
slices!! thanks rlayton!! Solved the problem perfectly! damn thing was staring me in the face this whole time, only I didn't know enough to know that... Thanks again, rlayton!
which bits do you want to throw out?
&gt; At present, the Python 2 language definition is not being evolved. I don't think that will last. But it's unlikely this will happen at pythondev. 
You can also copy lists with a list(): random.shuffle(listx) a.append(list(listx))
You can also copy lists with a list(): a.append(list(listx))
OT: `#python` on freenode uses the `+r` mode, which means you must register with freenode (`/msg NickServ help register` for details on how to do that) and be signed in with your registered nickname.
Also, LOLing is strictly forbidden.
Just forget the Python 2.7 compatibility, nobody needs this. What everyone wants is Numpy! 
and the sun shines brighter than the moon ... 
&gt; The CPython 2.x interpreter may not be developed at present, but PyPy for instance is still writing a Python 2 interpreter last I looked. That's not the development of the language dammit, that's development around the language, just as developing Python 2-based libraries. &gt; At present, the Python 2 language definition is not being evolved. I don't think that will last. There is nothing preventing a reversal of the core team's stance, but so far their response to queries on that issue have consistently been "no it's not going to happen". And further developments of the Python 2 line by a third party would be a fork. And frankly, I don't see why the core team would go back on its words when so far [the adoption of Python 3 has been on track with their estimates](http://sayspy.blogspot.com/2011/01/my-semi-regular-reminder-that-python-3.html) &gt; Something that all the Python 3 naysayers forget when they complain about library support is that python-dev has said from the beginning that the timeline for solid Python 3 adoption is **5 years**. Python 3.0 was released December 3rd, 2008.
Gedit is pretty reliable. Are you sure you're saving before running the Script? My text editor, [Scribes](http://scribes.sf.net/) is also fantastic for Python hacking and it saves automatically by default. You get free automatic python error checking by default too. Might solve your problem. 
I wouldn't want to throw anything out. It's still too complex. I want something that lets me build WSGI microapps fast. It just annoys me that all the microframeworks define their own request/response objects when webob already solved that problem.
As for your problem with #python: you probably need to register your nick with NickServ (try `/msg NickServ hello` to get started) before you are allowed to join the channel (or before being voiced). This is a typical precautionary measure to cut down on spam in high-traffic channels on IRC. You'll need to set and memorize a password. Make sure not to tell anyone but NickServ about it, ever. Also keep in mind that your nick may already be registered (you can change it with `/nick yourNewNick`, where yourNewNick is your new nick -- you'll probably be told off by NickServ if the nick is already registered or in use).
We have plenty of full stack frameworks. Pylons, Pyramid, Turbogears, etc.
Let me amend my comment by saying that I don't think Pyramid is too complex for what it's intended pyrpose. It's intended to be a simple full stack framework, which it appears on the surface to do so simply. It's too complex for what I hoped it was when I heard about it. I was hoping it was a microframework compliment for Pylons, it turned out to be a replacement for Pylons. That's a good thing. It just wasn't what I expected when I opened up the Pyramid docs, hence the disappointment. 
Don't worry, by that count Python 2 is 1023 technology years old and 31 years is a mere blip...
If you did care about repetition, perhaps: perms = itertools.permutations(listx, len(listx)) random.sample(list(perms), 10)
rofl 
Now lets get Matplotlib and PyPy updated.
http://www.downforeveryoneorjustme.com/python.org
Yes, websites go offline sometimes, and then come back up. Everything breaks, move along now.
ok son, thanks for chipping in
thanks a3q
Point being there shouldn't be more than one socket.send call per write event?
You're welcome
The way I've always defined it, Pyramid is not a full-stack framework. Neither is Pylons or CherryPy. TurboGears, Django, and Zope are full stack-frameworks though. I make this distinction because (AIUI) full-stack frameworks highly encourage a particular development style based around a particular persistence mechanism and various other sets of opinions. I'm not not sure what to call these "middle" frameworks like Pyramid/Pylons/CherryPy which are neither microframework nor fullstack. Maybe just "web framework"
I guess you mean you want Flask, except based on WebOb. I'm kind of hoping we can find some time to bring together WebOb and Werkzeug in such a way that both Flask and things like Pyramid can use the result. 
Although maybe you'd prefer a framework with fewer dependencies, Pyramid does let you build an app that lives in a single Python file. This was not really true of Pylons, so I think it covers more ground in the "micro" direction. But yeah it does have 16 or so dependencies, and doesn't promote an app development style that encourages people to depend on import or function definition ordering. These decisions were made purposefully. See also http://docs.pylonsproject.org/projects/pyramid/dev/designdefense.html#pyramid-has-too-many-dependencies and http://docs.pylonsproject.org/projects/pyramid/dev/designdefense.html#application-programmers-don-t-control-the-module-scope-codepath-import-time-side-effects-are-evil
It didn't help that Mark Pilgrim called Python 3 ["a commercial disaster"](http://www.reddit.com/r/IAmA/comments/f545e/i_am_a_fourtime_published_author_i_write_free/c1dcgsm) because _Dive into Python 3_ didn't make him any money. I realize that the Python dev team probably has different criteria for Python 3's success than he does, though.
I agree with his comment about missing the python 2 string formatting operator, %. Python 2: "Sample: %0.2f (%s, %s)" % (temp, a, b) Python 3: "Sample: {:0.2f} ({}, {})".format(temp, a, b) 
Every time I have subclassed list, it has turned out to be a huge mistake... Add some basic tests for the desired functionality and implement the correct magic-methods (as pointed out by rafekett): http://docs.python.org/reference/datamodel.html#emulating-numeric-types
I agree. I also have come to a similar realization about Haskell and Python... IMO: Haskell &gt; Python &gt; Perl6
What do you mean missing? The python 2 example you gave works fine under python 3.x. As well, PEP3101 and "what's new in python 3.0" both refer to the format system as supplementary to the % system, not replacing it. I'm not entirely sure why they have two systems, how / if they're going to be merged, but certainly not any time soon. 
I implemented all but the comparison methods. See [here](http://pastebin.com/HTEBciDm).
Python 2to3 conversion will take years, if not a decade. I think, PSF has to come out with tools and best practices to support the parallel living of two versions. The -3 switch and 2to3 is not enough, as you can see from the blogspot. For the coming years there will be plenty of users, who write code on python 2.7, but want to switch to 3 if the dependencies allow it. I would like to see a chapter in python 2.7 documentation with this title. The moudle unicode-nazi - or similar functionality - must go to the conversion toolset. 
For how long have you used Haskell? Problem with new Haskell users is that they think they have found the best language ever, start a blog and want to convince everybody else. And a few months later they have given up on Haskell and code in some dynamic language. 
What is so obvious today wasn't at all ten years ago. Back then the majority of programmers on slashdot or in any office I worked were far, far more approving of perl than python. I started a number of python projects in 2001 - and met anger from the perl crowd, anger from a lot of programmers over white space, etc. Not sure exactly how we got here. Maybe the wait for perl 6 was too great? Maybe enough people got exhausted with the "java platform"? Maybe enough people got burned by unmaintainable perl applications?
I've been using Haskell for a few years now, and the chances of going "back" to Python are only shrinking with time. Each of my other friends' who dived into Haskell is in the same position. I know a few who learned a tiny bit of Haskell, liked it, but didn't get enough to actually use the language, and have remained in Python. But I think once someone gets skilled enough in the language to use it for real-world stuff, they typically wouldn't look back to Python. Python is a pretty great experience, and lots attribute it to its dynamism. But Haskell shows that for the nice Python experience dynamism is (almost always) not required, and you can have the benefits of static typing with the benefits of concise &amp; elegant code. Then, beyond that Haskell has some pretty great ideas and features that Python lacks.
The latter is more readable and makes more sense in a dynamic language. It also allows reordering of positional arguments: "Sample: {:0.2f} ({1}, {0})".format(temp, a, b) Very useful for i18n, for example. Yea, you should use named parameters in such cases, most of the time, though can you honestly say ``"%(name)s"`` reads better than ``"{name}"``?
I know, you quote me on the language definition; I'm trying to help with interpreting you positively here (dammit!); you weren't so specific originally. Anyway, I know Python 3 adoption was estimated to be years, and we're in that period now. I was talking about this in 2007; you can go find it in the record. I think we're still in for pretty bumpy parts of the ride as some libraries will stop supporting Python 3 while some libraries won't support Python 3yet. Concerning "everything is going according to plan!" statements from this month in 2011, I'd need to dig around to see what the status of this plan was in 2007 or 2008. It's not very easy to find. 
Perl 6, when it eventually ships, is looking real good though. A great improvement over Perl 5 (it's like a completely different language, even) and interesting features that competes positively with other languages as well. It's even more expressive than Perl 5 while still more sane than that or Ruby. Parrot is cool too. I'll stick to Python until Perl 6 is stable and has widespread adoption, though, then I might add it to my arsenal.
Twisted...
I do have plans to add bitfields, but I have a lot to flesh out before I get that far. It's only a few weeks old so far, and still under heavy development. Though you do make me wonder if I should write up a proper TODO list and publish it so people know where I'm headed. And yeah, sorry about Python 2.6, but it just doesn't make sense for this project to support anything before 3.0. I know integration with other tools might be hard for now, but it's getting better all the time. Trust me, Python 3 is well worth the wait!
C-strings are the default if you don't specify anything else (and the terminator is configurable, but defaults to null). Fixed-length strings (with configurable padding) are currently implemented as well. Length-indexed strings like you describe are on the agenda, but they're not quite there yet. To answer your second part more generally though, yes, you'll be able to pass in a previously parsed field into another field in order to configure that one. Length-indexed strings are one example; another would be a stored encoding that can be used to decode a string that follows it. Both (and much more!) are definitely in the works.
If you read his comments on HN you'd have seen he said it was the book that was a commercial disaster, and it was too early to say for Py3k.
I figured I was being too harsh when I posted. I read that to mean, "Python 3 was a mistake for Dive Into Python" but I've seen that quoted as a "death knell" for Python 3 and was more interested in bursting that balloon. I'll check HN, to get the scoop.
Useful observations. I take Armin's admonition against print function lightly, as I prefer to use it, deal with (for me) the minor inconveniences.
Lots of perl hackers are all angry in the comments. You would have thought someone had killed a puppy and put the video up on youtube...
[The 3.0 release notes](http://docs.python.org/release/3.0.1/whatsnew/3.0.html#pep-3101-a-new-approach-to-string-formatting) state that the '%' syntax will be deprecated. I don't think that's happened yet, however, so it's currently in an ambiguous "will be deprecated" phase. Regardless, the new formatting system has many benefits over the old one, and I prefer it.
I take that as a compliment. If we are judging the quality of my English on that level, I am getting better :)
Indeed: *forward compatibility* is technical jargon, so this is an error that even a native English speaker might make.
not really, it's more like you should stop calling socket.send when the bytes written = 0, and then add it to the ioloop so it can tell you when it's ready for more (i did not do this, lazily, i just have it write once per callback to assure that the fd is always ready) mainly, you forgot to update your self.events, and the write event was still in the ioloop, meaning that it would be called over each iteration of the ioloop, as the socket will always be ready for writing. and that will make your script hog cpu cycles ._.
Here's the post: http://hackerne.ws/item?id=2120952
Trust me, we (PyPy) are working on it, this week we merged our 2.7 branch into trunk. Once that's released I think one of our next tasks will be putting together our Py3k plan. We really want to do Py3k as it has some semantics that are quiet nice (exception lifetimes, map/filter/zip as generators, etc.), however we also want to be where the users are.
TIL that "import dis" does not print out the Zen of Python in a New Jersey accent.
Python 3 support isn't actually a huge deal for me. I'd much rather see 3rd party libraries get better support (particularly numpy).
Looks interesting. I'm experiencing a lot of the issues that el_isma mentioned though. Also, experienced a ZeroDivision exception on line 117 in lastid.py. This is very much what I want out of a music library. Is there an IRC channel somewhere the devs hang out on?
There are lots of different ways to compute a hash of a string. I would take a look at the [Wikipedia entry](http://en.wikipedia.org/wiki/Hash_function) for more information and even some code examples under the "List of hash functions" section. 
Okay. Who's stopping you?
/r/domyhomework ? Seriously, couldn't you at least pretend to care about programming? "How do I prompt the user for input?" or "Please explain ___ about hash tables to me" would be much better than copy-pasting your homework assignment verbatim. To spite you I will give an inefficient partial solution performed in the ghci prompt in Haskell. Prelude&gt; filestr &lt;- readFile "fakefile.txt" Prelude&gt; filestr "this is a fake file\nit is fake\nisn't that awesome\n" Prelude&gt; let ws = concat $ map words . lines $ filestr Prelude&gt; ws ["this","is","a","fake","file","it","is","fake","isn't","that","awesome"] Prelude&gt; length $ filter (== "is") ws 2 
what's not sane about ruby?
Did you read the documentation for input()?
Unless you have a *very* good reason to do otherwise, don't use input(). Use raw_input() instead. input() will *evaluate* what you enter. raw_input() will give you a string. Take the following code: foo = [1,2,3] bar = input() print bar Let's say that you run this script and type "foo". It will output `[1, 2, 3]`. Replace "input" with "raw_input" and run it again. It will output `foo` as you would expect. 
I'll save him a [click](http://docs.python.org/library/functions.html#input): input([prompt]) Equivalent to eval(raw_input(prompt)). Consider using the raw_input() function for general input from users The docs are correct; OP wants `raw_input()`. There are about a dozen other improvements that could be made but it looks like a first stab at Python after learning Java or C++ so I'm not going to rip it apart.
This looks neat :) This should just be an ipython command.
IPython *does* do this, via the save command.
have you tried using collections.Counter? also I cannot even begin to explain how unpythonic your code is.
That appears to save lines, not variables.
Right, but you can save the lines where they are defined.
Still insufficient. What if you did something like `data = open("somefile").read()` and the file has changed since then? Or what if you are working with a set of generated data that, while small, would take a long time to reproduce? My code pickles all of the data available in locals() as well as user defined functions.
Try [this](http://lab.arc90.com/experiments/readability/).
Try the [session logging system](http://www.ics.uci.edu/~dock/manuals/IPython/node6.html#SECTION00065000000000000000) or the store command. 
That still does not address the problem of data that takes a long time to produce or may have changed. That just re-executes the commands you typed and assumes the output will be the same which is not guaranteed in a number of cases e.g. random number generation, reading from changing files / databases. If I run `some_function_that_takes_10_minutes()`, when iPython "restores," I would have to wait ten minutes while the function executed again. 
Ahh I see. I believe the magic function %store in IPython does that. EDIT: %store: Lightweight persistence for python variables. Example: ville@badger[~]|1&gt; A = ['hello',10,'world'] ville@badger[~]|2&gt; %store A ville@badger[~]|3&gt; Exit (IPython session is closed and started again...) ville@badger:~$ ipython -p pysh ville@badger[~]|1&gt; print A ['hello', 10, 'world'] Usage: %store - Show list of all variables and their current values %store &lt;var&gt; - Store the *current* value of the variable to disk %store -d &lt;var&gt; - Remove the variable and its value from storage %store -z - Remove all variables from storage %store -r - Refresh all variables from store (delete current vals) %store foo &gt;a.txt - Store value of foo to new file a.txt %store foo &gt;&gt;a.txt - Append value of foo to file a.txt\ It should be noted that if you change the value of a variable, you need to %store it again if you want to persist the new value. Note also that the variables will need to be pickleable; most basic python types can be safely %stored. Also aliases can be %store'd across sessions. 
Thanks guys, from what your saying raw input does make more sense but now I'm getting this error. NameError: global name 'raw_input' is not defined Ironic this code was written by my cs professor for me yo modify. 
False. Values of variables can be saved. See my comment.
Now try that on a function, and tell me how I can use that to save all the data in `locals()`. ;)
Does not work on functions or modules, and the user must supply the list of variables to be saved as opposed to them being pulled from locals automatically.
Ok store sucks. Touché. Your solution works much better.
You must be running Python 3. Python 3 has no `raw_input` function. However, its `input` function works the same as the old Python 2 `raw_input` function. Which version of Python does your prof expect the class to use? 
:D Not the response I was expecting, but I am glad you see its utility.
3
I remember that a few years ago, people were talking about 2.x convering toward python 3.x to make transition smoother, but I cannot find a reference at the moment. That's at least one big change in the roadmap. The pragmatic in me says that since python core dev say all new dev will happen in 3.x, people will have to do so as well. People making technical arguments around this are missing the big picture: whatever you think of python 3.x usefulness, you will have to move to it in the long term.
That's not what he is saying (or more exactly not the only thing he is saying). He said that no one was using python 3, and that it was too early to say whether the lack of success of his book is because the book came too early or because python 3.x is indeed a failure. While not excited by python 3.x, calling it a failure seems quite harsh and premature to me.
Okay. So ignore what the other posters are saying about `raw_input` and `input`. Upon staring at the code, I notice that the `_locate` function is bizarre. Per the docstring, sometimes it returns an `_Entry` object and sometimes it returns an integer. Either way, the `get` function then takes that and tries to access its `value` attribute, something an integer doesn't have. Although the docstring for `get` says a precondition is that the hash contains the key, the user's input is never tested with the `contains` function. User input could be any darn thing. Edit: try: print(get(hTable, Word)) except AttributeError: print(Word + ' not found.') 
He's using print as a function, so he's probably on Python 3, where they got rid of the stupid `input` function and renamed `raw_input`. 
Speaking of Java-ish editors on a Mac, I quite like jEdit with a few plugins. It's leaner than Eclipse and decent for smaller projects. Edit: I forgot to say, I use jEdit for Python. 
Actually that's not completely true (a lot of people did ask for 2.7 and complained), but it's also not completely untrue. For one, I would like to see numpy working (and fast!). It's definitely on track to happen, but that's one of the cases where more people would not hurt one bit.
Why pass locals() in to the function? Just use inspect to grab it out of the enclosing stack frame. PS: Use of this technique in "real" code is punishable by inquisition.
How to contribute for Numpy?
&gt;\2. [Python] is readable. &gt; &gt;The implication is that Perl isn't? I use perltidy on my code -- cleans the code up beautifully. The fact that he uses perltidy kinda proves the point.
People, why are you downvoting this guy? It's a valid question. My primary answer is the global namespace, to which the modules in Ruby are not a very elegant solution.
Interesting. http://www.downforeveryoneorjustme.com/downforeveryoneorjustme.com And this is what I get: &gt; If you can see this page and still think we're down, it's just you. 
aptitude install workrave
Though note that this is not a good option unless the list is guaranteed to be very small. It'll end up generating most of the permutations of the list (it's an iterator, so random.sample is going to have to step through them all), which is going to take a *long* time for a list with even 15 elements. If you've a small number of samples, you'd be better just weeding out duplicates by just checking and regenerating them.
Please please please submit a patch to the ipython guys. This would be a **killer feature**.
This pomidoro soup, Is it working?
“Assume that get_next_car() is a blocking call returning the cars one by one.” Well, that’s not a very good assumption. Most people will want to call the asyncNextCar function which doesn’t block, instead. But even when you’re stuck with a blocking function (which is rare) you don’t need that ugly while True thread; Just use twisted’s deferToThread: d= deferToThread(get_next_car) Then you get a deferred that will fire when the blocking call returns. The thread will be in a threadpool and that will be very fast. When you find out a new way to get a car without blocking, you can easily change the code, since it’s already using deferreds.
Interesting. Some time ago one co-worker (Java guy) didn't think python was "ERP material". I sent him this :)
Thanks for working on this. This is something that other languages with a command line interpreter do that I have missed in python. For example, take a look at the esoteric language IDL and it's [save function](http://idlastro.gsfc.nasa.gov/idl_html_help/SAVE.html). When I was in grad school, this saved my butt many many times.
vim will feel very clunky to you for a while, but now that I've worked with vim for a few years, I would never switch to anything else.
Hmmm, I wish I had thought to switch my caps lock and escape keys a long time ago. It's a great idea but it's going to take some getting used to. I assume there's not a way to just do it in the .vimrc so it only applies to vim, is there? Also, map and visual mode have boosted my efficiency significantly now that I've gotten a decent handle on how to use them.
Personally, I'd say to dive into vim. It's hard at first, but once you know it, you'll never give it up.
It doesn't say what is the Insert complexity for collections.deque
It's totally unreliable.
Could it be improved, or is the design fundamentally flawed?
And %store is much better?
Marshal will not serialize the function for you. You must pass it individual pieces. As for calling FuncType, you're probably right. That did not cross my mind.
What is %store?
Can't. Python as a language does not support this idea at all and pickle is an incredible crappy serialization format. Worse: many things in the standard library don't pickle properly. I wrote a module like that a while ago for dumping arbitrary shell sessions, and it was entirely pointless and useless for real world usage.
Likewise. Be where the users are and improve compatibility and performance for existing code would make many users very happy. And would give you a competitive edge over certain other Python interpreter implementations, if you care about that. 
If he uses Python3, then input() is totally ok! But otherwise he derives from object which indicates he is programming for Python 2 and then you are right.
See [this thread](http://www.reddit.com/r/Python/comments/f7u3p/code_to_save_the_interpreters_including_variables/c1dy3mr).
 It just made sense to. No point in limiting options and pulling in another module unnecessarily. Passing in locals() is a trivial matter. I am not always interested in the locals() that would be available in the stack free. Instances of and subclass of code.InteractiveConsole have their local variables stored in code.InteractiveConsole.locals. Whenever I use this function, I call it outside of the stack from I want to save. If I were to pull it from the stack frame automatically, it would include all the modules used for my interactive console such as code, restate, and threading.
I made this specifically for saving sessions at the interactive console. I never imagined it being useful outside of that. I do homework just about daily, so it's "real world" usage for me :P. Just because you do not have a use case for something does not make it useless.
Is #2 even going to happen? Everything I have read said it is being "tweaked" but not removed. I totally respect why you are not moving to P3. I am not even worried about it. The road of P3 was laid out to be 5 years long for major adoption and we are just into year 2.
It is useless for real-world usage. As soon as you are dealing with external resources (files, sockets etc.) this totally falls apart. The same is true for situations where unpickleable objects are involved. Been there, [done that](http://dev.pocoo.org/hg/sandbox/file/98ce1ce17c7c/pshell.py).
Luckily my statics homework doesn't require me to open sockets or files. The code is of great use to me in _my_ daily tasks, so I thought to share it. If you don't need the code, don't use it. I just needed a persistent calculator with arbitrary precision, and my favorite programming language just happened to fit the bill.
fair enough
Nice and easy, I worked on something similar (but more general) and I'm still having trouble with the sound. I'm probably going to steal the mpg123 idea. :P Thanks.
On another note, thanks for posting that code. I may very well modify and use it instead.
I wrote a challenge in my blog the solution of which will interest you. Here is the [challenge](http://www.algorithm.co.il/blogs/challenges/small-programming-challenge-no-5-generating-a-permutation/) (the solutions are in the comments) and here is the [explanation of the solution](http://www.algorithm.co.il/blogs/challenges/the-mathematics-behind-the-solution-for-challenge-no-5/). 
Model View Controller is your basic layout for anything. Views are a little weird in this case, but you should certainly attempt to separate out your models (all your data, and classes and represent it) and your controllers (which receive inputs, act on the data, and manipulate it, usually resulting in an output to the views). Your views are really the actions you're going to be passing out into the game, so I guess it makes more sense to think of them as outputs. Therefore I'd try to split your modules up into models, controllers, and outputs, or action handlers, or whatever you want to call the bit that actually does the clicking on the game. I'd also have a module for your input handling, which would then feed into the controllers. Is that the kind of thing you're thinking of?
Do you use source code management (like git or SVN)?
Couldn't you save the function definition as a macro? Maybe memoize it and save the variable? I don't know about locals(), but ipython can show you what has been introduced with '%who' ('%who_ls' for list). What ipython maybe needs it the ability to bring up the line number(s) of the last (and maybe other previous) definitions of a variable/function; though maybe if you use '%ed' or an external file to define them there might not that problem.
If I used iPython, I might be willing to put forth the effort to integrate it properly and submit a patch.
Ipython has 'store' which cannot store items which are declared interactively, which I think is the issue. The advantage of a macro is that you can access the original code, so you can eventually save the functions you want to keep; I'm not sure if that is possible with the way you pickle them. That said, any increase in functionality wouldn't be bad, but I personally would want a way to turn interactively declared items into macros. Maybe a mix of the two would be best, a special function macro?
Really it just comes down to breaking really long files into smaller ones, and organizing your methods based on similar purpose. Ditto, breaking really long methods into smaller ones. Usually refactoring (as the pros call reorganizing) is done to increase performance, or to eliminate duplicated code. So maybe the code that fakes the keyboards / clicks is in one file, and the code that keeps track of inventory is in another, and the code that calculates prices is in a third, etc. But it can be as simple as looking at which files are biggest. And if you have the same code in multiple spots, definitely start there!
Oldie but goldie.
When I use Python 3, it seems that I’m going to choose [py-postgresql][1] for PostgreSQL driver. It has a rich feature set and is written in pure Python. [1]: http://python.projects.postgresql.org/
For those unfamiliar with Pomodoro (and perhaps familiar with GTD), here's [an informative writeup](http://www.swaroopch.com/blog/pomodoro/).
Perhaps, but again, I do not use iPython so I am not too terribly concerned with modifying my code. You are more than welcome to do so. Consider it public domain or PSF compatible if you need an explicit license.
While I personally believe that any programmer worth their salt should at least consider SCM, I hardly see how it being used or not is relevant to darkray16's question.
I suppose I'm not getting an error anymore but its printing not found when I know the words in there. 
By these folks, he is of course referring to [Andrew Godwin &amp; Andy McCurdy](http://south.aeracode.org/wiki/Developers) (among others). I might just add this is a useless post.
So, none of the examples show data parsed based on previous values, or iterating over repeated variable-sized data. Without those features, it seems too early to really be usable. I've done some work on a python-based ELF parser (https://bitbucket.org/thermostat/orc); some of these formats can be very complex. It does seem like it has potential, I'd like to see it when it's a little closer to being ready for prime time.
Well, it's always a good advice. Since he's going to refactor he may break some things and he'll appreciate the possibility of going back.
aera hangs around here, hopefully he will notice this (and yes, South is basically the best thing ever). PS: Come to PyCon and you can thank them in person! :-)
I'm not too worried about dependancies. In fact I'd encourage dependancies like webob for a common req/resp API among frameworks. I basically want something like this: from something import App from auth import riakauth import riak import json import solr from webob.exc import HTTPNoContent app = App("config.ini") client = riak.RiakClient(host=app.config['riak_host'], port=app.config['riak_port']) search_client = solr.SolrConnection(app.config['solr_url']) @app.route("DELETE", "/entries/{slug}") @riakauth("users") def entry_delete(request, slug): bucket = riak.bucket("entries") obj = bucket.new(slug) obj.delete() return HTTPNoContent() @app.route("PUT", "/entries/{slug}", accept="application/json") @riakauth("users") # authenticates using the users bucket def entry_update(request, slug): bucket = riak.bucket("entries") username = request.remote_user data = json.load(request.body) # validate in someway data['author'] = username obj = bucket.new(slug, data=data) obj.store() return HTTPNoContent() @app.route("GET", "/entries/{slug}") @app.view("entries/details.html") def entry_detail(request, slug): bucket = riak.bucket("entries") obj = bucket.get(slug) return obj.get_data() @app.route("GET", "/entries/") @app.view("entries/list.html") def entry_list(request): query = request.str_GET("q", "") # do some paginations stuff start, rows = some_pagination_function(request) return solr.query(query, sort="pub_dt desc", start=start, rows=rows) if __name__ == '__main__': from wsgiref.simple_server import make_server httpd = make_server('', 8000, app) print "Serving on port 8000..." httpd.serve_forever() In fact I'd want both the app instance and the function's themselves to be valid WSGI apps so I could use any WSGI middleware around them: from somemiddleware import SomeMiddleware # wrap the entire app app = SomeMiddleware(app) # wrap one function entry_list = SomeMiddleware(entry_list) 
How exactly is a (Py newbie) giving someone who has done a good job that solves a problem a shout a useless post?
Model/View/Controller. It's clean, allows for reuse of code, and is organized by default. I also suggest going the extra mile and making separate directories (inside the project's main directory) for your models, views, and controllers. Also, use git. If you break the code somehow, at least you can get it back to a working state.
I don't think this post is _that_ useless, it made me feel happier. Then again, I'm one of the very few people it's targeted at :)
I really don't think it's [that bad](http://www.boost.org/doc/libs/1_45_0/libs/regex/doc/html/index.html).
I wish I'd used Python for my statics homework -- not sure why you'd use Newton-Rhapson in statics, though. Also, good move using stuff like Decimal (there's also a arbitrary precision class based on the GNU MP library). I wrote a simple nonlinear finite element solver in python during grad school and the matrix conditioning using floats screwed things up pretty badly.