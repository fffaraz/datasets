Surgeons, maybe. Mathematicians. That's all I can think of. I mean, I'm getting a CS degree to write the exact same quality of Python code I've already written for years now (which I feel I can finally say is pretty decent).
IMO the best place to learn about programming is the place where it will actually fit into your life and help you do something you want to do. Lets say you did data entry at work, well learning applescript or vb script would be the best place to start learning. What if you wanted to make cool pictures programmatically? Well, the processing project would be the best place to start. Python is a good place because it allows you to do a lot of computer tasks easily, and has a great community of people and tools. For example, you can make web apps for free using google app engine.
This is how I learned to program. I enjoyed it a lot.
I'm sure he could figure out a way. . .
Python is a great place to start loving programming. Assembly / C is a great place to start learning programming.
http://www.saurik.com/id/4
&gt; Maybe you have a **Mac** or an Android and have an idea for a really neat app. There, fixed.
Oh god, shut up.
Octave/MatLab is also a good way to start. Its core language is simpler, plus it has easy data plotting capabilities built-in. For the longer term, Python is a better language, but more complicated. If you are a scientist/engineer, you'll probably find Octave/MatLab to be a great workhorse for "sandboxing" new ideas, and Python and/or C++ will be how you turn them into sellable products.
Linux games are incredibly easy to package, especially if you want to get it into the official repos. Just name your dependencies and everybody will be able to install them. I'd probably use Pygame and Pygame-Gloss to make slow stuff faster. This in return needs (I think) PyOpenGL. It even has particles premade for you.
Yes
Thanks :) I guess I'll have to research some of this stuff - I'm not quite sure how packaging works, unfortunately.
I've always heard that pygame is the best one around as for how to ship it, the great thing about python is you can just drop the files into the root of your base dir and when you import them python will find them. If you decide to package it like an RPM or DEB you can setup pygame as a dependency.
If you want to make your own debs/rpms for now then you should read a web guide. If later one you want it in the official repos then you merely submit a packaging request and hopefully a trustee adopts your package. Generally, your package defines a bunch of dependencies and one installation the package checks if these dependencies are installed or installable from the web and goes ahead and installs itself. Rather straight forward. Don't worry about the packaging for now but try not to use large libraries that are not packaged for your distro. If you use Gloss with Pygame you just put the gloss.py file there into your game directory since it isn't packaged, for instance.
I still haven't gotten around to doing much python programming, but for the latter, this is pretty true. I started programming in C but it all came together when I learned assembly. Before learning assembly, computers were pretty much made of magic and pixie dust. Computing is abstract enough, assembly pretty much breaks down the layers till you're left with the nuts and bolts. And despite the extra work involved, assembly is where I began to love programming. 
 &lt;html&gt; &lt;body&gt; {{for i in range(10):}} hello {{=i}}&lt;br/&gt; {{pass}} &lt;/body&gt; &lt;/html&gt; This would be a web2py view. Perhaps it helps. Note that if you replace '=' with 'print' and '}}...{{' with 'print ...' this pure python code. You do not need to indent it, it gets indented automatically because pass closes blocks.
Wouldn't it make more sense to ask r/programming? They might be able to give you a slightly less biased answer.
MySQLdb is the library generally used. You'll have to watch though, last I checked it didn't work with all versions of python.
Use a templating library like tenjin, mako, jinja, cheetah etc. Lots of python templating libraries. There is also PSP like PHP on mod_python but that is older, most people go with templating even in frameworks nowadays. Here is a sample of [tenjin](http://www.kuwata-lab.com/tenjin/pytenjin-examples.html) below (I use that for small python web projects and it is very small and self contained): &lt;html&gt; &lt;body&gt; &lt;h1&gt;${title}&lt;/h1&gt; &lt;table&gt; &lt;?py i = 0 ?&gt; &lt;?py for item in items: ?&gt; &lt;?py i += 1 ?&gt; &lt;?py color = i % 2 == 0 and '#FFCCCC' or '#CCCCFF' ?&gt; &lt;tr bgcolor="#{color}"&gt; &lt;td&gt;#{i}&lt;/td&gt; &lt;td&gt;${item}&lt;/td&gt; &lt;/tr&gt; &lt;?py #endfor ?&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 
Down to basics: if this is on a class server, I'd try uploading a file like test.cgi that looks like: #!/usr/bin/env python import cgitb import MySQLdb print 'Content-type: text/plain' print print 'Hi' If that works, then you can use Python (probably). If you get a crazy-colored error message, check the error; probably MySQLdb is not installed. Getting it installed and running is... another big task. If you aren't using a class server or some environment you don't control, there's a ton of options. Maybe check out web2py or a Django tutorial.
One reason (possibly the most important) that it's "better than most" is that there's a lot of good documentation for it, and active forums to get basic help in understanding it. If you come up against a problem of not understanding what's going on and why something you think should work isn't (as per some recent personal experience in LaTeX), it's very useful to be able to read *thorough* documentation (if you actually know what the class/function is) or to be able to ask someone (if there's some fundamental aspect of the language/architecture that you're not 'getting'). Related to the thorough documentation: searching for documentation/help is generally easier in languages that use words instead of a lot of symbols and tricks for functions. It's all good and well to look up help on pointers, but if you don't know what the '*' in C/C++ even means, you'll struggle to get to the point of knowing you need to include the search term "pointer". Python isn't perfect in this regard (nor should it be, as you'll appreciate in the long term), but it's much "better" in this way than most lower level languages.
good point, I will repost my question there as well. 
Can you recommend a good place to learn Assembly?
Just as OT but here is the Bottle equivalent: &lt;html&gt; &lt;body&gt; %for i in range(10): hello {{i}}&lt;br/&gt; %end &lt;/body&gt; &lt;/html&gt; 
It should work with most versions. In fact, it's best practice to use an ORM (namely SQLAlchemy) rather than to write the queries by hand -- unless that is part of the exercise.
You can of course use Python for CGI scripts, too. It's more apropriate to use template libraries if your project involves more than just a few pages, though. EDIT: And, ideally, a framework like Pylons or Django.
Also, the interpreter can be used interactively (most Pythoneers use it as a calculator and sandbox). `help()` and `dir()` are good alternatives to digging through the full documentation, especially when you're already pretty familiar with the libraries but want to snoop around.
Is it just me or is the comparsion table almost unreadable due to all this red and green:)
Yes
Python is a reasonably simple language that really lets you grow. PHP, Basic, Matlab and C are all simpler languages in that they have fewer complex but powerful high level features, so they're all slightly easier to get going in. But Python does a very good job of not forcing you to know a bunch of advanced stuff just to get started, so Python is still pretty good right at the start, and once you get going, you'll be able to do more with less code in Python. Ruby would be another alternative, it has an almost identical feature set compared to Python. 
C++ is simply a horrible first language. The insane number of arcane hoops you have to run through, like remembering to declare a virtual destructor in anything that might be inherited from, even if you don't have anything in the base that needs destructing. Like having to create a copy constructor by hand if you decide you don't enjoy your program crashing unpredictably. Like discovering your database driver redefined the new operator for you. Like having to mix C-strings and C++-strings, C-arrays and C++-vectors in your code because everything doesn't have a C++ wrapper. Java is a somewhat bad first language. You're forced to use classes and methods long before you know what they are. You're exposed to the seemingly arbitrary distinction between primitive data types and objects very early. Lots of typing, over generalized APIs. Garbage collection and the relatively simple object model save it from being a terrible choice. C is pretty decent as a first language. Tiny little language. Yes, you have to compile your program. Yes, you have to do _everything_, even memory allocations, by hand. But at least everything except pointers is simple, predictable and easy to visualize. C (almost) without pointers is Pascal, which was originally designed to be a language for teaching. 
You could use the method from [this Stack Overflow answer](http://stackoverflow.com/questions/517923/what-is-the-best-way-to-remove-accents-in-a-python-unicode-string/518232#518232): import unicodedata def strip_accents(s): return ''.join((c for c in \ unicodedata.normalize('NFD', s) if \ unicodedata.category(c) != 'Mn')) after getting the UTF-8 string into Unicode, using s.decode('utf-8').
Any idea when?
Quality :) Brolly, is more something my mother would say, but otherwise spot on ! (Maybe I should start saying brolly... it has a nice ring to it, "I'll just pop out to buy some Macaroons, best grab me brolly !"
And if I may add, this is a great course: http://www.reddit.com/r/carlhprogramming/
Thanks! That's part of the solution definitely. Any idea how I would go about doing all the possible quotation marks?
Learning assembly is less important compared to just understanding how programming works on a low level in general. To just understand low level programming use [carlh's new website highercomputingforeveryone](http://www.highercomputingforeveryone.com/). As for learning assembly, there are a ton of great books out there that will walk you through it. I'm partial to [The Art of Assembly Language](http://www.amazon.com/Art-Assembly-Language-Randall-Hyde/dp/1593272073/ref=sr_1_1?ie=UTF8&amp;s=books&amp;qid=1274180898&amp;sr=8-1) only because I've read it.
Have you tried something like this: import unicodedata s = """So that 'š' would become 's' and 'é' would become 'e' and all sorts of crazy quotes would become standard ASCII quotes?""" s = unicodedata.normalize('NFKD', s.decode("utf-8")).encode('latin-1', 'ignore') print s 
web.py: &lt;html&gt; &lt;body&gt; $for i in range(10): hello $i&lt;br /&gt; &lt;/body&gt; &lt;/html&gt;
I would recommend using [Flask](http://flask.pocoo.org/) microframework, for some small project and particularly for something like this. Has nice documentation, it's small, easy to use and very powerful. It's based on werkzeug and uses jinja2 (the best templating engine for python). 
Yeah, it says "no module MySQLdb." Thanks for the advice though.
PyGame isn't pure python, though, it has C modules. So just putting them in the base dir will only work if you're shipping binaries to people on the same arch/distro/library revisions. Otherwise they'll need to recompile, and PyGame is not easy to compile (lot of dependencies that are messy, especially on windows and OS X) . Pyglet, on the other hand, is pure python (unless you're using mp3/AVI support), so you can just drop it in the root dir. 
It's a bit useless on account of being so tall and the label boxes being so crammed that they're unreadable.
I've only used asyncore for basic things but the table seems to be wrong on some. The documentation is fine and lib/test/ contains more than enough examples. SSL support is 'no' but should be irrelevant because a SSLSocket object can be supplied to it.
What wireless did it use? MiWi?
Could it be SNAPpy? http://groups.google.com/group/python-on-a-chip/web/list-of-small-python-implementations?pli=1
What kind of wireless, a/b/g/n or some sort of cellular? [Telit](http://www.telit.com/), for instance, makes a variety of [nice systems for AVL solutions](http://www.telit.com/en/products.php) that combine a cell modem (GSM or CDMA) with an onboard microcontroller with optional embedded Python. They're very cool. Sorry that I can't point you to the video you're looking for :-(
I started with C and moved on to Python (with a bit of QBASIC and OPL before C). I think it would have been easier the other way round, because I could have learnt the basics without having to deal with the peculiarities of C.
Are you converting to ascii or latin1? é is part of latin1
Latin1 actually.
Yep, this is the one he's thinking of: http://us.pycon.org/2009/conference/schedule/event/73/ (I was there :-) Also certainly check out PyMite/p14p (Python on a Chip) if you're looking for an open source, easily ported python VM implementation (Linked from parent's link). Side note: if you also like Lua, check out the [eLua Project](http://www.eluaproject.net/) (disclaimer: I am on the board of this project ;-) ).
Most popular python based content management system
Upvote. I was gonna say "you could do a lot worse", which is pretty much the same sentiment.
&gt; ... runs a subset of Python ... I'm curious -- it makes sense to remove parts of python that have no corresponding host feature (file interaction, e.g. if the host has no filesystems). But are there other features which might have been trimmed in order to fit into a particular target's available memory? Does anyone have experience with SNAPpy, or have a pointer to their release notes?
Sorry for the week-long delay... Just wanted to say thanks for elaborating! I played around with bpython quite a bit. I can see why you prefer it. The interface is damned slick! It does what it's intended to extremely well, and it's much more lightweight than ipython. Personally, I think I'll still stick with ipython for most things. I use the various %magic functions, macros, and shell integration a lot. The bpython interface is quite nice, though. I think I'll try using it more often.
Functions in Python are objects just like most other things. You can assign attributes to them just as with any other objects. &gt;&gt;&gt; def f(): return 3 ... &gt;&gt;&gt; f.x Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; AttributeError: 'function' object has no attribute 'x' &gt;&gt;&gt; f.x = "hello" &gt;&gt;&gt; f.x 'hello' `counter` is not a class, but rather a "singleton object" (excuse my french), created by the interpreter after parsing the function itself. On a call to the function, it will add an attribute `n` if it doesn't exist already - otherwise it will increment it. It will also add `maxVal`. The only "normal" functionality is returning the result of comparing the two.
[Almost everything is an object.](http://diveintopython.org/getting_to_know_python/everything_is_an_object.html)
It's using the fact that a function is an object in python. (It's also a really bad way to do something like this, but that's beside the point...) Effectively, it's a singleton object. (e.g. try doing "counter(10); print counter.n" after you've called the counter function in the while loop. It will start with 17, rather than 1!) The reason that the "foo.bar" doesn't exist until the fuction is called is that same reason that a print statement inside a fuction isn't executed until you call that function. "foo.bar = 42" isn't executed until you call the function, therefore, foo.bar doesn't exist until then. Hopefully that makes some sense. 
Go to the site and run this in your web browser url window: javascript:(function(){var%20newSS,%20styles='*%20{%20background:%20white%20!%20important;%20color:%20black%20!important%20}%20:link,%20:link%20*%20{%20color:%20#0000EE%20!important%20}%20:visited,%20:visited%20*%20{%20color:%20#551A8B%20!important%20}';%20if(document.createStyleSheet)%20{%20document.createStyleSheet(%22javascript:'%22+styles+%22'%22);%20}%20else%20{%20newSS=document.createElement('link');%20newSS.rel='stylesheet';%20newSS.href='data:text/css,'+escape(styles);%20document.getElementsByTagName(%22head%22)[0].appendChild(newSS);%20}%20})(); It does the trick (it's great to have as an bookmark for certain sites)
As someone who is reading though Dive into Python now, I am in awe of this language. 
More so, when Python interprets a module and comes across a function declaration, it assigns the function code to the function name, *but does not actually interpret it YET*. So in this example, the function will assign an attribute to itself, however, that attribute wont exist if you try to access it without executing the function first.
&gt; It's also a really bad way to do something like this Is there a good case to use this functionality?
Not exactly as used in the example; a global variable would be better. However, function attributes are often used by decorators to indicate that a particular function/method has certain properties, e.g. that it is safe to call via XMLRPC. def expose(func): func.exposed = True @expose def myfunc(foobar): pass somefunc = myfunc if getattr(somefunc, 'exposed', False): print 'OK to call'
One sometimes see the "opposite", too -- callable objects. class C(): def __init__(self, x) self.x = x def __call__(self, y) return self.x &gt; y c = C(5) c(4)
Function is object, object can has attributes. When you've declared function foo, you have not called it and so — foo have no attribute bar. But when you've called it, it assigns foo.bar value 42 and after that you can print it.
This. And what makes it even more magical, is when you realize that the model you are programming against with assembly is just another lie, and the real processor doesn't work like it at all. I strongly suggest prof Agner Fog's work, especially his third "manual" "The microarchitecture of Intel, AMD and VIA CPUs: An optimization guide for assembly programmers and compiler makers", found [here](http://www.agner.org/optimize/#manuals). It reads almost like a story, beginning with simple reasonable chips and slowly delving into the insanity modern processors are.
"a global variable would be better." I don't think I've ever seen that phrase before. You have blown my mind.
http://www.drpaulcarter.com/pcasm/
The first hasattr check will always make sure that upon the first call to function it has the attribute **n** initialized to 1. The second hasattr check makes sure the **maxVal** attribute is permanently available. Upon first call to this function, the attributes **n** and **maxVal** are now permanently a part of the function "counter". From here on out, provided you called the function counter with an int compatible argument (e.g., 15), all subsequent calls increase the attrubute **n** until it is at least equal to the attribute **maxVal**. The reason the while statement works is because the maxVal value never changes. The function is called again **and** the *n* attribute increases and returns True. counter(15) remains True until *n* is greater than *maxVal* which will break your while loop.
In this case the variable is already effectively global, which is why I think the quoted statement is justified. An argument could be made that the intended use of the variable is more clear when it is an attribute of the function, but the technical difference is minimal. One trivial difference is that the attribute access requires an additional dict lookup.
&gt;...it assigns the function code to the function name, but does not actually interpret it YET. There's a slightly more subtle point here. The code is *compiled* at that point, but not executed. This is, to me at least, a little counter-intuitive. It's sort of like the function body being partly interpreted at the point of definition. In practice it makes little difference, but you will encounter certain errors during execution of the definition rather than on invocation of the function (e.g., syntax errors). There's also the somewhat more important point that default arguments are bound at the point of definition, and never again. This is why you generally should not use mutable objects as default arguments: def append3(a = []): # Trouble! a.append(3) return a If you call this twice without arguments you'll get [3] the first time and [3, 3] the second time. You are modifying your default argument, which is probably not what you want. In principle this could be used to accomplish something useful, but in practice it's typically an error.
Not sure, but the PEP is [here](http://www.python.org/dev/peps/pep-3146/).
I suppose if you think about it, a singleton object is just a giant global variable.
Just to flesh out this answer and some others with some examples... Here's what the code would look like using a class. Note that the "CounterType" class is the equivalent of of "counter.f_code" in original (which stores the python bytecode of the parsed function, but contains no implicit state). When we create the "counter" singleton below, we bind the code to a place it can store state (self.\_\_dict\_\_ in this example, or "counter.\_\_dict\_\_" in the original). class CounterType(object): def __call__(self, maxVal=None): if hasattr(self, "n"): self.n += 1 else: self.n = 1 if not hasattr(self, "maxVal"): self.maxVal = maxVal return self.n &lt;= self.maxVal counter = CounterType() The class-based example has one difference from the original, you could create "counter2 = CounterType()" which which act like the original as well, but they don't share the same state, so they could be used simulatenously (eg: "while counter(5) and counter2(10)"), which couldn't be done with the original, since the same state would be used, so the counters would conflict. Here's the original redone using globals to store it's state (I had to modify it a little to check for "False" instead of using "hasattr"): _maxVal = False _n = False def counter(maxVal=None): global _maxVal, _n if _n is False: _n = 1 else: _n += 1 if _maxVal is False: _maxVal = maxVal return _n &lt;= _maxVal 
That's how I interpret it, which is why I'm not a fan of the singleton pattern in general. But I'm not sure I totally "get it," so I try to keep an open mind.
I got that part figured out, since I was the one who wrote the function :)
Python used to have a nice, clean syntax. Now it has multiple kinds of comprensions, decorators and a ton of other syntactic sugar that is very handy (use it all the time) but under no honest definition is "clean".
I don't think python is simple enough in any real sense. A subset of it is. Just like a subset of a ton of languages qualify. Python used to be "simple enough to be easy for beginners", and we as a community got used to saying that. But python now has generators, multiple kinds of comprehensions, decorators and lots of other syntactic sugar that are really useful for coding, but take away from the "executable psudeo-code" qualities the language used to have. The more syntactic sugar we load on, the more arguably useful the language becomes to those of us who already are in the community, but the further it moves from a simple language that is easy for beginners.
&gt; There's a slightly more subtle point here. The code is compiled at that point, but not executed. it is executed, but only the outer part is executed (the scope which contains the *definition* code for the function).
&gt; What's weird is that foo.bar isn't created when the function is declared, but once you've called it. This shouldn't be surprising at all. Contents of callables are never executed at definition time. That would make defining functions useless. def foo(): print "hello world" This should not print anything until you call *foo()*.
What you're missing is that in Python, a function is just an object like any other. As with other objects, you can add new members to it.
Just go with the PHP unless you are granted permission explicitly to use Python. If you are interested in Python for web development, try it at home.
Or instead of a counterType class you could make a counter factory: def counter(maxCount=None): def count(): count.n += 1 return count.n&lt;=maxCount count.n=0 return count
Degrees in the sciences do provide you with some learning opportunities that would be very difficult to find as an autodidact, such as experiences in research labs. There are also some things that you'll get taught in class that you'd never learn on the internet, but these are becoming less common as the internet grows.
You could consider app engine Python to be a variety of Python too, in the sense that there's a porting barrier as it doesn't support custom C extensions. 
everything is an object.
Sorry for the delay (summer research job! :D), but I thought I should respond. I don't use it. I do program a lot on my own, though, and I am starting to learn to use Cython for the very reasons you mention. And the C class didn't make me fear "programming stuff". In talking about the class I was alluding more to the fact that the thing I like most about doing is understanding what I am doing. Python might not make it immediately apparent what a memory address is, but since I know what it is, I can better understand what Python is doing with its time. I suppose I'm a little more involved in this sort of thing than the people whom you've introduced to Python are, though, so I'm probably not a good example of an average student of biotechnology. 
I actually work for Synapse Wireless, the company that did the presentation at PyCon 2009. At PyCon we demonstrated Python running on our module that was connected to a red "easy button" that would tweet when pressed. Feel free to send me a message if you have any specific questions about our Python implementation.
SNAPpy runs on various IEEE 802.15.4 (2.4 GHz) radios as well as 900 MHz radios.
Thanks, god i love reddit. Thats exactly it. http://www.synapse-wireless.com/?mainID=3&amp;subID=8&amp;type=product&amp;prodID=8 [edit] Does the software (portal) work on mac or linux? Does digi-key ship to europe?
I have used SNAPpy. It's a very severely limited subset of Python, to the point that it isn't really very "pythonic" any more. No lists, minimal support for strings, no classes. The only numeric values are 16-bit integers. It's OK for what it is, but it's not Python. [synapse-wireless.com](http://synapse-wireless.com/?mainID=3&amp;subID=5&amp;type=product&amp;prodID=5)
Thanks! that'd be the proper way to do it if you didn't want to use range / xrange. (I forgot to disclaim that my examples weren't fit for use, since they deliberately preserved the strange usage semantics the original had, for illustrative purposes).
Do you comment your code like this?: x = 10 # assign 10 to x y = 2*x # double x and assign the result to y h = sqrt(x**2 + y**2) # root of the sum of squares is stored in h if h == 0: # if that is zero print "x is equal to y!" # then print that x and y are the same 
I know you've already gone with something, but just to let you know of an alternative - I use unaccented_map() from http://effbot.org/zone/unicode-convert.htm Works perfectly for me. 
&gt; This is, to me at least, a little counter-intuitive. Hmm, how so? What does your intuition tell you? (honest question) Compilation is exactly "partial interpretation" because interpretation = compilation + execution.
Yeah, Python threading isn't really what you expect due to the GIL (Global Interpreter Lock) that's held at any time interpreted code is running. You can have multiple threads sleeping (or doing network or disk I/O, or calling into other non-python code) but you can't have multiple CPU-bound Python threads running concurrently. As I don't see any calls to sleep() in your code, I suspect that's what's biting you. You should be able to find many informative articles on the Python GIL by googling for it...
Yeah, I probably will just use PHP. Even though I don't wanna.
Also realized there's a bug in your code. threading.Thread(...) takes a callable as "target". When you say "bot.do_work()" you're actually calling the function right there. Just say "target=bot.do_work" Here's my example code: import threading from time import sleep class Bot(object): def __init__(self, name): self.name = name self.i = 0 def work(self): while True: print "%s: Working %d" % (self.name, self.i) self.i += 1 sleep(1) if __name__ == "__main__": bot = Bot("Ernie") bot1 = Bot("Bert") bot2 = Bot("Tiffy") bots = [bot, bot1, bot2] jobs = [] for bot in bots: job = threading.Thread(target=bot.work, name=bot.name) jobs.append(job) job.start() for j in jobs: j.join() 
Possible issue: threading.Thread(target=bot.do_work(),name=bot.name) That executes bot.do_work(). Instead, you need to pass in the function like threading.Thread(target=bot.do_work,name=bot.name) 
yes thats it... thank you very much... now it behaves like i expected. that stupid parenthesis messed it all up ;) 
Yea this is definitely an assignment from a class... bee tee dubs i'm being sarcastic because youre a douche
Possible. I was the same way. Plus it's much easier to ask someone what it means, and it's not a big deal at all to answer.
I've never heard of it but I'm going to go take a look at it right now, thanks for the tip :)
"Can't remember what it was called and my google-fu is weak today." So is your hand...
 `x` is not equal to `y` when `h` is 0 just to let you know
I rarely comment as I prefer to be very explicit. e.g., if I had to use a function to do what the function does, I would have preferred a generator here. If somebody really had to ask how this function worked I thought they might really want an explanation. 
**The first rule of Software Club is that there are no rules of Software Club.** The only reason everyone bashes on global variables is because they are so easily abused by bad programmers to create massively coupled spaghetti code. But bad programmers can just as easily create massive, poorly-factored objects with a crap ton of state and private members that are effectively application-level globals. If you look at how many pages have been written about effective use of singletons in modern OOP languages, it's clear that people LOVE to use globals. And frankly, there's nothing wrong with that. Globals don't wreck code; people wreck code with globals. The same is true of goto, the same is true of operator overloading, the same is true of stack frame introspection, and monkey patching, and just about every other controversial coding practice.
Depending on what you are doing, you may find SciPy and its associated ecosystem of projects useful: http://www.scipy.org. You may also want to download the Enthought Python Distribution, which is a handy way to get all of those libraries pre-built and in a single installer. It's free for academic use. http://www.enthought.com/epd (Disclaimer: I'm an employee of Enthought and am involved with the SciPy/Numpy community.)
My plotting library Chaco (http://code.enthought.com/projects/chaco) also has a nice example that does precisely this. Screenshot: http://code.enthought.com/projects/chaco/pu-audio-spectrum.html Code: https://svn.enthought.com/enthought/browser/Chaco/trunk/examples/advanced/spectrum.py The plots are interactive (i.e. can be panned and zoomed) while they are updating.
Yes. This book is absolutely fantastic. Don't be fooled by the title: it's not just "for kids", but rather for anyone who is new to programming. I spent a lot of time trying to find a good programming book for my (recent college grad) sister, and was delighted to find this one. http://www.amazon.com/Hello-World-Computer-Programming-Beginners/dp/1933988495/ref=pd_cp_b_2 
I would really recommend reading this book: http://www.greenteapress.com/semaphores/ It helped me understand multi-threading and all risks/benefits of it. Especially if you are new to programming, concepts are explained with easy to imagine examples.
Yes. But they may also have methods, and it can be useful to use instances of different subclasses in different situations. E.g., I used to develop a number of travel sites for a tour operator. There are lots of subtle differences between summer and winter holidays. There was one global "Site" singleton (that contained site-specific config data, but also factory functions for other commonly used objects), but depending on which site you're looking at it'd be an instance of Site::Summer, Site::Winter, etc. You could call $site-&gt;get\_accommodation($id)-&gt;price\_table and you'd get the right subclass of the Accommodation class for the current site, because the Site object had the right factory method for this site. So I feel singletons can be a bit more than a mere global variable. Of course we could also have had a global $site\_id and if ($site\_id == ...) everywhere, and in fact we used to have that, but it's not as clean in my opinion. Anyway this is far too much text for a small point, and sorry for the Perl :-)
Your global variables can be objects with methods. You can at init time decide if the global site variable should be e.g. a summer object or a winter object. The only difference between singletons and global objects is that the former makes what you're doing a bit more explicit, at the expense of a bit of verbosity.
Assembly is different on different chips, so buy a simple microcontroller and read the manual. You might also want to review on some circuit theory if you want to attach it to something.
My intuition tells me that when the function is called the parameters with default values are populated with the same default values each time, i.e. an empty list each time, not the same exact list, specially created once.
Ah yes, that is a bit counter-intuitive - but I was referring to your first point (where you made that comment).
Any movement on class-based generic views ? It seems to have slipped below the radar, but it would really be a step forward in reusability - the current function-based views (in particular, create/update/delete) are too limited for serious usage.
I was actually just being sarcastic. I was pointing out that spelling out code simply like you are reading it out loud doesn't really make it any clearer (in fact, usually the english version is *less* clear).
I can't decide between two replies to this, so you get both: 1. That just illustrates my point about useless commenting 2. Really? Can you give a counterexample? Assuming x,y are numbers.
Change the code to this x = 10 y = 2*x h = sqrt(x**2 - y**2) # changed the addition to a subtraction if h == 0: print "x is equal to y!" now it works
Singletons, classes, globals, factories. All overkill. This is the equivalent without setting attributes on the function: def counter(maxVal): n = 1 while n &lt;= maxVal: yield n n += 1 
*embarrassment* ..thanks
Please don't write code like this.
preach it, brother!
We've used it for a couple of enterprise apps, as well as http://radbox.me. I'm originally from Oracle+J2EE background. I started learning Python because I absolutely loved it, and when 37Signals started popularising Ruby on Rails, I thought "why not an equivalent Python framework?" Web2py is actually too good to someone who's messed enough with XML configurations in J2EE. And Python rocks. Period. Entire focus is on developing the app, lots of stuff works out of the box, great features from RoR and Django inspired web2py (like scaffolding) and the community is pretty awesome. Give it a shot before forming a judgement.
Can Chaco draw to a Cairo surface ? If it can it could quite nice to integrate with shoebot.
 class C(object): def f1(self): return 'C.f1' def f2(self): return 'C.f2' o = C() o.f2 = lambda: 'o.f2' print o.f1(), o.f2() C.f2 = property(lambda self: lambda: '"property has higher precedence"') print o.f1(), o.f2() # yes, yes it does! WILL THIS EVER END? Honestly, C++ object system is pretty straightforward in comparison. To the author: no, no, you can't switch to discussing the interpreter state quite yet! This post provokes an interesting question! When you assign a function to the field of an object, "`o.f = lambda: 'lol'`", it's supposed to be a free method -- if it's selected by MRO, it's called as it is, so it should not have the `self` parameter. When you assing a function to the field of a class, "`C.f = lambda self: 'lol'`", it's turned into an "unbound method", which is then turned into "bound method" (substituting actual value for `self`) when you access it via "`o.f`". It seems that this is done thusly: when you assign anything that seems callable to a class's field, it's wrapped into a special descriptor, which then does its magic. But how is it possible to override ordinary methods in the instances then, if that descriptor should take precedence? Does it add even more magic, performing a lookup in the instance dictionary by itself and pretending that the descriptor magic didn't happen if the attribute is found there? It would be nice if you understood and explained all this. It's more than enough for another full post, also with `classmethod` and `staticmethod`, and then why `len` doesn't check instance's `__len__`, and then to metaclasses.
Little-publicised fact: MySQLdb is deprecated in favour of OurSQL. The former is apparently crap and buggy. Not that you'd generally know this until it's too late. Fortunately, OurSQL is usually a drop-in replacement.
"It seems that this is done thusly: when you assign anything that seems callable to a class's field, it's wrapped into a special descriptor, which then does its magic." Not quite - functions are *already* descriptors. (Wrapping as bound methods happens when the method is fetched from an instance.) If you really want to understand this then the descriptor protocol is the *only* thing you need to understand.
I've generally found Django to be pretty good about being backwards-compatible, at least since 1.0. The only recent pain I've had is modifying forms to handle CSRF - and that was pretty easy to disable globally until all the forms were fixed. 
ooooooohhh, so the binding behaviour -- when we find something in object's dict, we return it unchanged, when we then find it in its class hierarchy, we bind it -- emerges directly from the fact that descriptors are invoked when found in the hierarchy but returned as is from object fields? OK. Makes some wonderfully perverted sense. What about having lambdas in object's fields: do functions specifically emulate the naive lookup order?
But the important thing is that you aren't forced to use these things to write an elementary program. Contrast that with something like Java, where you have to start pulling out the big guns just to write hello, world. I sometimes teach programming. I hate it when I have to tell students, "Just enter this code for now and don't worry about what it does. We'll get into that later." Python is a language that spares us that.
Other less-interesting projects announce their releases right here in /r/python. &gt; These are all, of course, much better than web2py. According to who? You? Get a life.
Web2py is a small project. Mdipierro has every right to promote his work. Many people think it's a great thing. If someone doesn't like it, don't use it.
As you may infer by the tone, the post was made in (rather unkind, I admit) jest.
Chaco (Kiva, the rendering library, in fact) has an experimental cairo backend. 
&gt; Contrast that with something like Java Completely agree, except I think you are kind of setting up a stalking horse here. It isn't contrast it with something like Java, more like contrast it *with* Java. You don't have this issue with most languages. Lisp, scheme you are good to go. Ruby, run with it. C, C++ you end up with some boilerplate, but not so much you aren't probably going to be explaining all of it right there. So I think that you are picking one of a very few languages that present this problem in real depth. But it definitely *does* present that problem. In spades. I would never envy you having to teach beginners Java!
lambas are just functions with no name :)
I glued Jython to JMS via the Codehaus STOMP broker. It worked fine for me. It should work fine with regular CPython as well. There's code in the Jython book that shows how to do this kind of integration
I am coming from Django. I like django for its long history. I also don't like django for its long history. Namely, because a lot of the cool new features in Django were "cool" and "new" like 3 years ago. Furthermore, a lot of "features" are now done by other frameworks in a better, faster, and easier way. People tend to forget that open source is not about locking as many people into a single framework as possible, and creating a monopoly web dev. framework who's users crush all other emerging frameworks. One of the things about OSS that is great is FORKING!!! damnit! Web2py is just another "fork" of rails/django/etc (yes I know this is not the technically correct use of forking). If you argue against people using other frameworks to Django, you are promoting the death of linux, osx (bsd), and all OSS. I chose web2py because it is Python, no dependencies, and it has all the modules I need to get going quickly. Though, to-date, my favorite strength of this framework is how easy it is to plug its code into a completed design. Easier and faster than in django, pylons, flask, web.py, etc. I didn't choose web2py because it is a proven workhorse, because worrying about scalability before you even finish your project is a great way to never finish (unless you have lots of funding or a big team and time). Personally, I want to spend as little time coding as possible, and bug testing my finished product as much as possible. Thanks for the great work web2py developers!
Cool. Next time I see you I'll do a from reddit.arnar import Sarcasm; try ... except Sarcasm.AssholeError and pass. I'm just being a first class Douche # if you don't mind :)
I do understand that, there's no need to point it out, the question stands: do they emulate the naive (object's dict first) behaviour specifically? Or is there some other magic?
No, I'm saying lambdas, at the C level are really just functions who's name is &lt;lambda&gt;.
oh lambdas, u so crazy
What's "almost" about it? The only thing that's not an object is the language itself, and even the text of the code creates an AST that you can re-parse if you really want to. 
Damn, it came back to life after I forgot about it o_O
Cool :)
lambdas are just functions. What matters is whether they are instance fields (returned as functions) or class fields (returned as bound methods).
Unfortunately it does not. Its underlying vector graphics library is called Kiva, and has backends to a variety of UI toolkits (wx, qt, Quartz, OpenGL, PDF, SVG, etc.). Enable, a graphical component and event handling library, is built on top of Kiva, and is a Shoes-like Python project that actually predates Shoes by many years. Kiva, Enable, and Chaco are all Enthought open-source projects, and have been the basis for many scientific applications that we've delivered to clients over the last 8-9 years.
I also just found a nice little [Python class](http://code.google.com/edu/languages/google-python-class/) that google offers that I figured I would post in this thread. Thanks again for all of your answers and advice. 
I wish python was able to manage this sort of thing for me automatically... ...Oh wait.
Installing MySQLdb can be difficult if you don't have the right MySQL headers to build the library against. You can use the pure-python [mysql connector](https://launchpad.net/myconnpy) for lightweight stuff though. You don't have to install anything to use it.
Thanks, this looks promising.
&gt; Installing MySQLdb can be difficult if you don't have the right MySQL headers to build the library against. Or, follow an easier approach: 1. Install [ActivePython 2.6](http://www.activestate.com/activepython/downloads) 2. Open command prompt and type "pypm install mysql-python" 
haha, I had just read that quote after i posted this!
thanks, this solved it.
Here's my contribution to open source: predominatly should be spelled predominantly. I would have left a comment in the issues section, but the web page doesn't work in IE. 
I'd say go with Django, it has by far the best documentation around. But if you're a pretty experienced programmer Pylons can work just as well for you. Personally I use Django and love it.
you say "backend", will your games be communicating directly with this internet abomination or is it just going to be a thing to visit with a web browser?
I consider web.py an educational tool. Even though reddit was written in it (a long time ago), I can only imagine how much boilerplate code they had to generate... Once you know a thing or two about web development, make the jump to Django. Savor that sweet, sweet admin middleware and pretty-good-but-not-SQLAlchemy-level ORM.
I looked at Django but liked web2py much more and it now has good documentation as well. 
I use Pylons + SQLAlchemy. SQLAlchemy is well documented and stable, Pylons is very stable but not the best documentation.
Please write a new csv module for Python's standard library that would support Unicode out of the box. Thanks!
What's your distro? You may want to take a look at [quickly](https://wiki.ubuntu.com/Quickly), if it happens to be Ubuntu (9.10+). It even has pygame template. 
Django is the best, it just took me form "WTF is a web framework" to "wow how cool and easy is that" in no time. Other are good too, tried them, but they just weren't for me. 
uh?
Actually the best advice is ,,write your programs in idiomatic python and port to 2.7 when available'', then you run 2to3, then you run tests and check if everything works. I don't get why doesn't he use print_function or except Exception as err syntax, that is already there. I don't get the ,,no xrange() so I'll use list(range())'', maybe it should be ,,3's range() is like 2's xrange(), so I'll use list(range()) to get list materialized''? edit:1s/then your/then you/
TurboGears 2 is an amalgamation of the best bits of web frameworks: Genshi templating, Pylons controllers and SQLAlchemy persistence. Stable, active, tested, documented. People who know better than me say Django *may* have a less steep learning curve, however.
&gt; Security (the more I'm protected from my own stupidity, the better) Django is pretty good at this. Strict rules and an easier way than ever to have CSRF protection in all of your forms (great for purchases). &gt; Stability (0.1 beta need not apply) Django is very mature and stable. &gt; Ease of use &amp; Documentation You probably won't find better documentation for another project. Django's documentation is *very* good. All in all, if you're sitting on the fence, give Django a try and just follow [this](http://docs.djangoproject.com/en/1.2/intro/tutorial01/#intro-tutorial01) small tutorial on building a simple web app. It'll introduce you to the general feel of Django and what it's capable of (but really, you're just scratching the surface). It should be a good indicator of whether or not it's the web framework for you.
Basically there are those who like hacking and doing things exactly the way they want to (Pylons/Werkzeug) and those that just like to get shit done and move on to the next thing (Django). This fundamental difference in philosophy explains a lot of the pointless framework fights we get in /r/python. I'm one of the former; but I can see the value of the latter, particularly as your main interest isn't web development and your needs aren't complicated. You're not building another Reddit, you just want some simple user and purchase management. Django will easily handle your requirements and has a shitload of apps for extra functionality (e.g. Satchmo for shopping cart stuff). Plus it comes with excellent documentation. 
From the original post: &gt; However, it is a class server so I can't really install anything on it He doesn't have access to install anything.
Just thought I'd add that, as much as I love Django, it can get quite annoying when you really want to customize a site in certain ways. Despite this, it's probably still the best option for a beginner.
This is very similar to how you write portable C. * Have a bunch of autoconf tests to see what facilities your platform provides. * Write a fallback.c file that contains implementations of all functions that are missing or buggy on any platform. * #ifdef every function to only be included if the target platform lacks a proper implementation. It may seem like way more overhead than simply writing a few #ifdefs in the proper place in the main code, but it's really the only way to keep you code from turning into a ball of uneditable #ifdef mud. Keep all your crappy workarounds in a single file and write the rest of your code as if it only targeted a fully working platform.
You may want to look at web2py (no relation with web.py). It is the only one that does not require installation, does not have setup files, to include a web based IDE, to include a built-in ticketing system, a web translation interface, a Database Abstraction Layer that runs on Google App Engine, and to promise backward compatibility. I believe by now its [free online documentation](http://web2py.com/book) is comparable if not better (in length and quality) than that of other python web frameworks. Here is an example of a program: #in model db.define_table('shout',Field('message',requires=IS_NOT_EMPTY())) # in controller @auth.requires_login() def index(): return dict(form=crud.create(db.shout), shouts=db(db.shout.id&gt;0).select()) # in view {{extend 'layout.html'}} &lt;h1&gt;Shout!&lt;/h1&gt; {{=form}} &lt;h2&gt;Other shouts&lt;/h2&gt; {{for shout in shouts:}}{{=shout.message}}&lt;br/&gt;{{pass}} Notice the built-in validation. The automatic form processing and error reporting. This code also prevents SQLInjection and XSS attacks because {{=shout.message}} is escaped. Django is really nice too but think of this: version 1.2 was released on Monday and added support for multiple database connections (web2py had this 3 year ago, it also provides distributed transactions), added support for customization of email backends (web2py already supports multiple email back-ends, including GAE, and the trunk version has API to generate PGP and x509 emails too), added support for "smart if" template tags (web2py has full python in templates), added a "message framework" (web2py always had response.flash), added "hooks for object level permission" (web2py has a Role Based Access Control mechanism to create arbitrary permissions on arbitrary objects including individual database records), added "improved protection against Cross-Site Request Forgery" (web2py always had that although the mechanism is different). There was a time when web2py was being inspired by Django (we acknowledge that and thank them), now I am happy to see that web2py is providing some inspiration to Django. Perhaps one day Django will have a web based IDE too. Anyway, whether you go with web2py, Django, Pylons or Flask you will have made a good choice.
Genshi is definitely not the best bit. That title is reserved for Jinja.
I've been learning Django myself, and I really like it so far, but I'm going to go out on a limb and suggest you check out [Bottle](http://bottle.paws.de/). It's very minimal and would let you concentrate on basic development issues like http requests and responses, html templating, python etc.
&gt; Actually the best advice is ,,write your programs in idiomatic python and port to 2.7 when available'', then your run 2to3, then you run tests and check if everything works. I'm torn. I want to be a purist and advocate this, but I have a hard time seeing how you can do this and target **both** 2.7 and 3 at the same time unless you fork your codebase.
Instead of making partisan statements can you please support your statements? For example: I like Genshi better because it does not restrict the use of Python in templates. I like Jinja because it allows creation of non html/xml templates and Genshi does not.
web2py hands down. Don't let the others tell you otherwise....
Well, for that they made [3to2](http://pypi.python.org/pypi/3to2). You can include it in your build and try to minimize problem areas that 2to3/3to2 can't handle gracefully. I haven't used it (don't write much python)
strange , I've managed to generate [text](http://genshi.edgewall.org/wiki/Documentation/text-templates.html) from templates in genshi. perhaps I'm doing it wrong by reading the docs?
Can you elaborate? I use python daily and use web frameworks 7 days a week and I would like to know your rationale. edit: i didn't bury your comment, FYI , but really ... not a peep so far . I'll take it as trolling
Flask is new but it is built around components that are well tested. I advice you check out.
You are right. Genshi supports different syntax depending on the type of output you want. For HTML: &lt;div py:for="item in items"&gt;xxx&lt;/div&gt; and for text: {% for item in items %}xxx{% end %} When I think of Genshi I think - incorrectly - of the former. The second syntax is more similar to Django's and Jinja's one.
A lot of people post this question over and over and I always ask: "when you make a decision can you please let us know which frameworks you evaluated, what decision you made, and why". I never get a response. It would be useful to have a response so we can all learn something.
(Assuming he can at least login to the machine in shell or desktop) For Windows, he shouldn't need Administrator privileges to use the [ZIP distribution](http://downloads.activestate.com/ActivePython/releases/2.6.5.12/ActivePython-2.6.5.12-win32-x86.zip). For Unix, root access is not at all required to install ActivePython. And PyPM installs packages into `site.USER_SITE` (which the user has access to) or the specified virtualenv.
Bill Punch and Rich Enbody at Michigan State University changed some of their early curriculum to use Python rather than C++, but kept their later courses in C++. They obviously studied the grades of students and their successes later on in the program, and if I remember correctly, what they found was that there was no noticeable difference in the grades between those students who were all C++, and those who went Python to C++...which is, to me, a really big upvote for Python. Students were able to dig into basic programming with Python, then later on they were able to step into a language that they had not previously seen, and they did as well as everyone else who had seen it. [Bill and Rich's presentation abstract and slides from PyCon 2009](http://us.pycon.org/2009/conference/schedule/event/8/) [Bill's presentation abstract for the upcoming PyOhio conference](http://www.pyohio.org/Talks#talk17) With that said, I think it's a great place to start.
Well those languages are still different, so I don't see how could you do it without forking your codebase. I mean -- for trivial code it won't matter, for any other things the changes require attention. You should be able to port changes there and between using 2to3 and 3to2, as HenkPoley said, and in conjunction with good set of tests it should be sufficient, unless you rely on some deep implementation details (like `'string'.encode('rot13')` ;-).
Agreed: http://flask.pocoo.org/
Yes! Absolutely. Very powerful and yet so easy and simple. You should definitely start with Flask. 
For the most part, communicating directly with the abomination, though I may end up serving some simple pages at some point.
wow ... !massimo?
Absolutely agreed. I'll definitely post an update once I've made a decision.
If you are looking to do purchases you might want to look at [Satchmo](http://www.satchmoproject.com/) -- it's a kind of online store setup on top of Django. 
what's up?
Well, if you're just sending little lumps of data back and forth I would recommend checking out Twisted. Or perhaps Django with Django-Piston to provide an API for your games to communicate while giving you the niceties of the Django admin and all that.
Python is a great place to start coding but I would also read Code by Charles Petzold as it gives you a better understanding of the underlying processes going on that make the python interpreter work. 
cool stack, bro
love the downvotes... cant stand the truth ppl ? :P 
oh thank god, i thought this question would never be asked this week
I think massimo covered it pretty well as usual. And im glad youre a uber dev. IMO if he wants simple then web2py is the way to go. Runs out of the box w/o any deps aside from python. Try explaining to a new user how to setup django or any other python framework. BTW im a novice to programming in general and I've looked into all the popular ones and found that aside from technical merits, web2py's community is much friendlier. I suggest you re-read your reply, if youre a django/plon/pylons person, thats another reason to stay away from it due to people like you... FYI: I don't sit on reddit and wait to troll someone like you do... 
Ugh, here we go. Slings mud and run away. &gt;Don't let the others tell you otherwise.... You should have mod powers to just delete all other comments here then. Let's pack it up guys and go home. Reality check: you wrote nothing compelling about web2py. Face it. I asked a question regarding your disingenuous comment. I waited a couple of hours. Some folks buried you to -2 . I figured, that might be as well, since you didn't help the original poster one bit. Lesson here is to either have something useful to say to a person that asks for help, or read other's comments. Don't muddy the waters with FUD. 
&gt;I am studying biochemistry no you are not
So why did you bother to respond in the first place? You're still not helping, just continuing to try to troll... Also do I have to give a reason for wanting to use a particular framework when massimo *as usual* has already done a wonderful job of describing web2py's features. And do you know what FUD stands for? I merely shouted out web2py as a individual whom greatly enjoys it. Furthermore you read too much into it. Also seems when ever anyone mentions web2py they get down voted for it. EDIT: please get rid of your god complex....
great links, thanks a bunch
Eh, it seems to me like you're another idiot on the internet, romping around like you're the alfpha dog of the innernets. Try getting a job and doing something else more constructive than bickering on the internet, it just makes you look like a moron who has no life. MOAR QQ LESS PEW PEW! kthnxbai2u
why is it that when *anyone* mentions web2py they get flammed for it?
Enlighten me: why do you prefer Jinja? Have you tried Mako? They're templating engines I'd like to know about, but can't really spare the time..
I do not know for sure. Some theories have been proposed. 1) web2py was born in an academic environment and this contrasts with somebody's theory that industry is more innovative than academia. A theory supported by college dropouts. 2) it is hard to monetize open source projects. Django has been successful at it. Lots of people make (or wish to make) money consulting on Django projects. They see web2py not merely as new tool but as a new group of people competing for their jobs. Particularly scary because web2py users can develop faster and reduce maintenance costs. [EDIT: 3) Some sexually frustrated geek teens are upset because web2py allows even the dumb guy dating their dream girl to do decent web development. Which is exactly why web2py was developed... so that that somebody else can do web development and the geeks can go back into real science and contribute to a better society]. Anyway, when they cannot attack the message they attack the messenger. We see this in politics all the time. Mind that "they" is not Django developers, some of which I know personally and are really nice and intelligent people which I admire (although we may disagree on some design decisions). "they" here is a very small group of people who act in anonymity and therefore I do not think I have ever met. web2py may not be the best tool for everybody, but we do have one of most friendly community of users. 
Well maybe you can do both, it will be very similar anyway. If you need to make an actual webpage, in this case you'd better stick with PHP; unless you have some time on your hands to try tinkering with python at home
Lets all just use Visual BASIC and run around with Windows 7 party hats on drinking wine coolers!
Ugh. Get modern. color = '#CCCCFF' if (i % 2) else '#FFCCCC' Alternatively, treat the integer value as an integer value, instead of quibbling over whether to make the conversion explicit: color = ['#FFCCCC', '#CCCCFF'][i % 2]
srid logged it on the issue tracker. Fixed now. I'll cut a new release with this at some point. Thanks.
I almost forgot... since you mention purchases: http://web2py.appspot.com/plugin_checkout/default/checkout The PyCon conference registration software in 2009 and 2010 was based on web2py and we used that module. Also do not miss http://web2py.com/plugins and the [quickstart page](http://web2py.com/examples/default/examples)
I play with the python enough already...
&gt; Keep all your crappy workarounds in a single file and write the rest of your code as if it only targeted a fully working platform. qft
You're right. I should have said "ride the snake".
... said the actress to the archbishop.
Yeah, [ride the snake!](http://imgur.com/MJIQJ.jpg)
Hold on a moment. You previously mentioned you used web frameworks everyday, you seem interested on some rationale on why some people believe that web2py is great, so why don't you drop off this thread for a while and reflect about the possibility of being losing productivity and fun 7 days a week just because you may not had the chance to meet something better. Why don't you give that chance to yourself? Actually, you have something to win with that and the task it's quite easy and this is as valid to nuvm, who wrote the question. So, you have: * Screencasts - http://www.vimeo.com/videos/search:web2py (I recommend: http://www.vimeo.com/3703345 ) * Book - http://web2py.com/book (free), you can also get from lulu or Wiley * Examples - http://web2py.com/examples/default/examples * F.A.Q - http://web2py.com/AlterEgo * WiKi - http://wiki.web2py.com/ * Interactive demo - http://web2py.com/demo_admin * Mailing List - http://groups.google.com/group/web2py (very responsive) * Official website - http://www.web2py.com * Recipes - http://web2pyslices.com * IRC - #web2py , irc.freenode.net Try it, feel free to ask questions and if you feel ready/interested to a educated debate use one of these channels, you are welcome. P.S.: about me, I've wasted a long time studying different web frameworks in different languages and made my rational choice. Use these resources so you can make your own and don't waste time in this tavern talk. 
Cool, thank you :)
Have a play with bottle, it's only a few hundred lines and you'll quickly grok how these things fit together. When I first jumped into django/pylons it all felt like magic.
build a web framework. endless entertainment.
Just a tip for every one, encode HD video or something in the background on the host machine to get the true reddit experience.
Make something neat.
work on pypy
That's what she said
Yup. That just about replicates the experience of dealing with 1300 requests per second. 
Contribute to a project that you use. Or, find a project that you don't use because of technical limitations and help them fix it. Or, find a hobby. 
[/r/RedditGameJam/](/r/RedditGameJam/) -- the first round is done, but you could contribute to the second round, w/ some pygame-based game.
TWSS
* [Python Challenge](http://www.pythonchallenge.com/) * matplotlib, scipy * PyOpenCL * Make something awesome with NLTK + Whoosh + Scapy * `itertools` * [Browse PyPI](http://pypi.python.org/pypi/) ... "Oh awesome! I didn't know there was a [RPN calculator](http://pypi.python.org/pypi/rpncalc/2.7) written in python!"
To make your decision just try to use each framework for 10min. If you cant figure out the basics in that time, move on to next one. I come from Django. I made the decision to use django because I thought I needed excessive stability and obscene amounts of documentation because I didn't have confidence in myself. I later realized I don't like reading documentation, I like building web apps. I also realized I am not going to build the next facebook, and don't need a fully proven framework from 2003 that powers a few big sites. I wanted to make quick apps and to experiment. So I needed something that gets out of my way. I switched to web2py for that reason: In web2py I can generate a form from a db model with SQLForm() and set custom css classes to only the fields I want to change from default css with form.element(), and then insert the input boxes into my views with form.custom.widget. You can't do the custom css stuff for only part of the model generated form in django w/o rebuilding the entire form with widget attibutes for css. In other words, it got in my way. I realized much later that django wasn't made for Concept-&gt;UI Design-&gt;Code approach to web app development. It was made for Concept -&gt; Code -&gt; Design. I find I spend 80% of my time on the design, and only 20% of my time on the server-side stuff. Which results in a better user experience, according to the users of my apps anyway. In addition, I do a concept first, then I translate that into a HTML/CSS/JS design, and then I finally plug in any code to communicate with the DB and do some form handling. If that is your workflow go with web2py. If you prefer to code first, design last, go with Django... Honestly, today the most scalable and stable framework would have to be Pylons. If you wanted something that is proven. Anyone who argues Django has the best documentation out of any project is a moron. Most of the frameworks have "good enough" documentation for your needs. Pylons has an online book with all the documentation you need. Web2py has a book online too, though because it is so straightforward you don't really need it. Django needs a lot of good documentation because, without it, it would be a rather mediocre framework. Honestly, just read through the first 7 chapters of each of the books for Pylons, Django, and web2py (skip the python intro chapter). That's the only way to make an informed decision. Don't listen to me or anyone else on here, as we are all biased, and our experiences and needs were/are way different from yours. P.S. Flask, bottle, and web.py are fun too. Though, not really frameworks as much as helpers.
[Ride the snake](http://www.youtube.com/watch?v=DQYVRr0EYBA#t=1m20s) (sorry for the poor video quality--it doesn't look like there are any "official" versions of this SNL skit)
You lucky guy! I wish I had enough time to do enough python to be bored of it. Visit [/r/somebodymakethis](http://www.reddit.com/r/somebodymakethis), and see if anything there sparks your interest. Here's some highlights: * [SMT] A program that monitors when you're doing something repetitive and offers to take over for you. * [SMT] Android video recorder that uploads to a remote server while you are filming, for tense situations that might end up with the phone taken away. * [SMT] A script or method of stopping you from viewing your Ex's facebook page. * [SMT] Single-click open of reddit link and comments in two new tabs * [SMT] A website that accepts an upload of a section of an audio file, in order to analyze it and recommend possible guitar effects settings to best reproduce the same type of sound. * [SMT] A windows app that darkens or blacks out the whole screen apart from the currently active window _________ On a more selfish note, I have a project suggestion; A linux program that slings video feeds from a TV-card across a network. I haven't submitted a SMT because whilst there are many, many, many solutions to this problem (and all my replies would be links to those solutions), there aren't any *good* ones (eg, MythTV always comes up, and its poor or non-existent Windows/OSX compatibility plus its general dodgeyness is a disappointing show-stopper). Currently I'm using VLC with a hacked-up HTTP interface, and it gets the job done, but not perfectly (channel changes too slowly, no EPG, it's missing some features, the de-interlacer sucks ass, etc). My ideal solutions would have the following (and only the following, most solutions have so many features it takes forever to figure out): 1. HTTP/web interface (maybe with the video feed embedded in the page, though web players suck) 2. EPG-scraping (maybe this could factor into the program-start/program-stop detection, and maybe with web-scraping) 3. Locking - the ability to make sure that if someone is watching/recording one channel, another person doesn't up and change on them (only one channel per tuner), preferably with usage detection (ie, it locks only when someone receives the feed), so you don't rely on people's courtesy to unlock when they're done. 4. DVR Functionality (rewind/fast-forward live TV). I think some adapters have this built-in (or at least, there's an entry under `/dev/dvb/adapter0/dvr0`), but I have absolutely no idea how to implement this. Presumably the controls would have to be on the HTTP interface so as not to conflict with player compatibility, unless there's a widely-supported protocol for redirecting control sequences. Again, locking will need to be a consideration here - if two people are watching the same feed, one person should not be able to pause it at the detriment of the other (unless you can somehow fork the feed). 5. Standard transport+broadcast protocol (ie, works easily with any stream-capable players, something like UDP multicast) 6. Server-side de-interlacing (maybe with hot-swappable filters and an AI to calculate appropriate swapping moments) 7. Easy recording - preferably with program-start/program-stop/commercial detection, automatic encode on finish/on idle, names the recording in accordance with the EPG scraper. 8. Recordings integrated into channels 9. External videos/feeds (video files, DVD, internet, peripheral VIVO-attached device) integrated into channels 10. Signal strength detection 11. Watermark removal. 12. Intelligent multiple-card management (this ties in closely with Locking, and perhaps Signal strength). Multiple tuners implies multiple feeds, but this is depends on whether you have a unicast (the server targets the user, one feed per user) or multicast (the user targets the server) architecture. The policies I can think of are * One-tuner-per-user: This is optimal (because the number of channels rarely change and changing channels doesn't mean a re-tune), but also most expensive (you're likely to have more channels than users). This also minimises "Locking" difficulties. * One-tuner-per-user: This is the next-best, since the management is easier - but keep in mind that one user can watch multiple channels simultaneously (record one and watch another)! * Hybrid: This is the cheap option, since you have less tuners than users/channels, but it also requires the smartest tuner management. Ideally, you want to use as many tuners as possible to avoid locking issues, unless you're good enough to transparently switch tuners (where possible) when a user attempts to violates the lock! Some resources: `szap`/`tzap`/`czap`/`dvbscan` (found in debian package `dvb-apps`, AKA `dvb-utils`), `mencoder`/`mplayer`/`ffmpeg`/`dvbstream`, `wget` (for fetching web components), `apache`/`lighttpd` (for web interface), `dvblast`. `Various edits: Adding more features, clarifying others. Sorry, I got a bit carried away`
Anyone have a non-torrent version for those who can't use torrents?
I get `"error: no such disk"` when I try to run the .vmdk image in VirtualBox. Am I doing something obviously wrong?
Did you download the vmware or ovf image? If the ovf, you should be able to import the ovf file (File -&gt; Import Machine on Mac os) and it'll mount the disk. 
Strip the `?torrent` off the end of the url. It just dings us for bandwidth costs which is why we are encouraging torrents to help spread out the load. 
Have you seen [Project Euler](http://projecteuler.net/) at all? I find them fun to hack through in Python.
Try Django, it's fun. Or maybe you're really bored after all and need a switch. Try Gambit Scheme then, it's fun.
I tend not to flame people (and despite Massimo's comments to the contrary, I am neither a teenager nor sexually frustrated, though I am still seeking out the dream girl). I did get annoyed a while back with the nature of some of the web2py evangelism, though; for a while there were several reddit accounts with suspiciously similar names who did nothing but praise web2py and bash other Python frameworks (IIRC, TurboGears was "vaporware", Django was "too insecure", etc.). That pretty much turned me off from the get-go.
Keywords: Artificial Intelligence, automation, stackless, pypy
Learn how metaclasses work. Not enough? Start playing with modifying bytecode manually. Write a goto that works in Python (yes, it can be done)! 
Please read my comment again. I make 3 disjoint hypothesis. There is nothing linking you or Django (mentioned in the second hypothesis) to the first or the third hypothesis (which by the way was a joke). I explicitly excluded every Django developer in order to make sure that nobody took it personally. In my second hypothesis I only referred to Django in a positive sense, as the only Python framework that has been able to monetize (generate revenues), and for good reasons. I truly meant that as a compliment. If anybody felt offended I apologize, I was trying to cheer people up. I cannot respond/defend comments posted by other people. I always post under my name. You should know that. There are at least 1800 web2py users around and I cannot control what they say. Yet I cannot think of any obviously offensive comment posted by a web2py developer about other frameworks. Let's just make one thing clear: It is web2py users who are being attacked when they post a positive comment about web2py. It is not vice versa. In fact it is a question about that that triggered my joke. EDIT: to those people who felt offended (and there should not be any)... if it is a consolation... I have been there, but eventually I did get married. That was the biggest accomplishment in my life. Things get better with age for geeks.
Plus this will teach you how WSGI actually works.
Port numpy to Python-3.1!
Jinja is a lot faster than Genshi, for one thing. Also Genshi is very strict about XML things, which is a pain if you want to do anything else (even HTML). But it's been a while since I've happily converted my things over to Jinja.
&gt; [SMT] Android video recorder that uploads to a remote server while you are filming, for tense situations that might end up with the phone taken away. Ustream broadcaster?
This
To the lake...
&gt;said the actress to the bishop. FTFY
Will help seed. I wonder if you could get some of the big Linux mirror helpers to mirror this one.
Last time that happened to me I learned ruby. Now I juggle the two but tend to go with ruby for pet projects because I've developed a serious addiction to blocks.
Learn another language. Python isn't everything. Try Scheme or Factor or Tcl. Assuming you're already fluent in C and sh, of course.
Learn algorithms and implement them in Python.
That's why it is written in python. It is a dos2unix replacement. It has its place in the Tools/Scripts directory of python, alongside with ftpmirror.py, treesync and others.
The snake is long.....
write some coding examples for novice users, (I would greatly appreciate it). I would appreciate it !
I think [WebFaction](http://www.webfaction.com/) could do just that. Either it'll be on their one-click installer, or you can quite easily deploy them as you see fit.
[WebFaction (affiliate link)](http://www.webfaction.com/services/hosting?affiliate=watfest) have a Python 2.6/mod_wsgi3.2 option. Their setup is not a conventional hosting setup, but it's the better for that. Highly recommended. You get a shell account, can use SSH, and it's low cost ($9.50/mo if you pay monthly). You can install your own Python libraries, and quite a few are pre-installed. They are pretty Python-friendly, as shared hosting goes.
WebFaction seems to be the go-to for shared hosting, but I'd probably just pony up the cash for a VPS.
Yea i'd have to agree. I've been tempted to try and get stuff running on AppEngine recently, especially with some of the IO junk coming out, but if you need real python, VPS is the only way to go imo. Hell, RackSpaceCloud is cheap, and it's awesome.
Just FYI, the lowest priced [Rackspace Cloud](http://www.rackspacecloud.com/918.html) server (affiliate link) is $10/mo, but you'd probably want the next step up which is $20/mo (they are on the cheap end, I suspect to establish themselves since EC2 kind of dominates cloud servers). It's just a VPS with an API and an hourly billing cycle, so you don't have to do anything special with your apps. And... I'll just plug [Silver Lining](http://cloudsilverlining.org) while I'm at it, which does the server setup for a Python site.
If I want to run Django with nginx, is this a good combination?
&gt; is this a good combination? Are you referring to the WebFaction option, or something else? For WebFaction, they use nginx so you can set that up for static files, while Apache and Django serve the dynamic pages.
[ARP Networks](http://www.arpnetworks.com/vps) is where I host [my website](http://lessthanthreesoftware.com/). They are do VPSs but are out right now, but you can email preorder@arpnetworks.com to be notified when one opens up. If you do sign up, toss my name in there 'Wraithan' as the referrer if you are feeling generous :)
I like how they emphasize that they haven't oversubscribed their computing resources. I get the impression that this happens a lot.
Flash vs bottle? I remember reading about bottle a while ago and thinking it was pretty cool. why is flask better?
this is relevant to my interests
I'd do it.
[Google App Engine](http://code.google.com/appengine/docs/whatisgoogleappengine.html) is your best choice. You can run Django 1.1 on GAE, but with some restrictions, or you could run a django flavour patched for GAE.
I'm with WebFaction as well and I've never had better customer service. Note: I run a Django site on it as well. It was a one-click installation and I had it running in 30 minutes.
Write a Lisp/Scheme or Tcl interpreter in Python (both are relatively easy languages to implement).
There's always developing mobile apps. It's the future! There's http://code.google.com/p/android-scripting/ and https://garage.maemo.org/projects/pys60/ and others I'm sure. 
this. if there's anything preventing widespread adoption, its the academics who would make libraries but won't switch because they need numpy!
Well I'm with webfaction and I like the setup, but I have to disagree on the customer service. After the first answer didn't resolve the problem, they did help me - to a degree. Two of their support agents were, without putting too fine a point on it: assholes. Not impressed at all by the treatment.
App Engine is Python 2.5 at this point.
The `vmdk` disk images are already surprisingly compacted and it doesn't make much of a difference: 692M reddit-vm-ovf.tar 674M reddit-vm-ovf.tar.gz 679M reddit-vm-ovf.tar.bz2 662M reddit-vm-ovf.tar.7z Seeing as tar ships with gz and bzip support, I used the smaller of the two and opted for ease of uncompression on the part of the end user. 
My bad! I had re-compressed the original torrent and gained something like 300MB. Edit: Also, I deleted GPP accidentally (I meant to delete another one).
Yeah: the original was decidedly sub-optimal. The real trick ended up being [this suggestion](http://www.reddit.com/r/redditdev/comments/c625v/questions_and_discussion_about_the_new_reddit_vm/c0qd7kt): # Make any used disk sectors be all zeroes sudo dd if=/dev/zero of=/xx bs=1024k sudo rm /xx It makes the disk imaged *much* smaller and better compacted. To be honest, I was really surprised those images were so well compressed to start with. ;)
However, I am still perplexed. I got the original image down to about 430MB with 7z. I wonder how that works.
[Webfaction](http://www.webfaction.com/?affiliate=livecorp) the sweetest hosting service I have ever used.
There are restrictions that on GAE that should be considered. For many uses, though, I agree.
So they'll feed and water us? I'm totally down (and a total newb)
Why is RPN interesting to people? Sure, if you have a limited stack memory it's efficient; but who the hell thinks/learned math in those terms? 
Isn't Google dumping enough dough into Python development? What else do you expect?
Oh, no, I didn't. After trying that I get "Too many IDE controllers in OVF; import facility only supports one." from the Appliance Import Wizard.
direct [link](http://stackp.online.fr/?p=28)
Another vote for WebFaction here, and in response to another question: Nginx is easily incorporated. I've used it on a number of WordPress and Django apps.
Another vote for WebFaction, it's a great place to start.
I'm not sure how the first sentence is relevant, and I'm not sure what the second sentence means. Google, along with a number of companies, mostly work on what benefits them, and rightfully so. They do contribute back a lot, Google especially, and I believe the community is thankful for that. However, the Python Software Foundation has a vested in interest in *everything* Python, enough that they want to shell out money to get people interested in certain topics.
You're all wrong. http://vonluck.wordpress.com/2010/05/22/mac-osx-python-build-issues-w-pil-imaging-1-1-7/ It's an issue of an old Python install left over from upgrading from 10.4 to 10.6.
An archbishop is just a bishop who runs ArchLinux.
Well comparing AppEngine to WebFaction isn't quite fair since the latter has none of the limitation the former has.
Like there aren't already enough of them. (Ok, building things on top of werkzeug, pylons, or another low-level framework gets you most of the benefits without the pointlessness).
Write a Scheme compiler in Python (i.e., translate Scheme to C, or to Python bytecode). Try to build something like Pyrex/Cython for Java
Thanks, I just posted where I first saw it.
[RabbitMQ](http://www.rabbitmq.com/) supports AMQP just as ActimeMQ does. A [good introduction here](http://hopper.squarespace.com/blog/2009/1/22/capabilities-for-messaging.html).
oh come on, we saw it yesterday and it was beaten by a simpler code.
How about a parallels VM ?
(No parentheses)
link?
This blog post proposes that the PSF spend more money on sprints targeted at Python core, porting to Python 3, PyPI, and the website/help. I was asking this: is there really a need to jumpstart these core areas of work, or are the current contributors doing a fine job? The author acknowledges this point and then goes on to suggest the sprints anyway.
http://paste.lisp.org/display/24849
Simpler code? Sure. But how does it "beat" anything? It isn't remotely efficient - it could easily lead to exponential runtime.
What would make it even more interesting is if it could test multiple regex. You pass in a list of expressions which is built into a tree of tests. This means you only have to scan the text once instead of n times, and also do not double the test anywhere two expressions have a commonality. Phillip.
i will go with that one anytime until i have something to optimize.
The current core contributors are indeed doing a very fine job, but as long as more issues are being reported than are being fixed, which is likely the case (haven't studied the numbers), there will always be a need for more help. One of the driving factors behind the proposal, I believe, is that there are a number of people who want to be contributors but haven't had the means to do so. A sprint topic could be just that -- get some people in a room with an experienced developer and just learn the ropes of the core project and start hacking. I gave a presentation about this last week to about 35-40 people and it seemed to get a good reaction and good interest. As for PyPI/website stuff -- I'm not aware of much effort into those areas at the moment, but I believe there has been some feedback into what could be done. Funding to make it happen, to help those with suggestions put the rubber to the ground, will hopefully have some positive result in the forms of getting the work done and enabling new contributors. As for porting -- a lot of the more popular libraries have 3.x plans but no one to do the work. Being that Python 3 adoption depends heavily on the libraries, putting together a sprint to port your favorite library benefits both the library and the PSF.
That's the same as creating a single regexp `R1|R2| ...` or `(?P&lt;name1&gt;R1)|(?P&lt;name2&gt;R1)|...` if you want to fetch components. 
O(m*n) sucks...
I wasn't comparing the two. I just happened to make a comment about AppEngine :o
Why do you think m is constant? There are algorithms that can do the regular (and context-free) parts of regular expressions in O(n+m).
not if you have a django.py file in the current directory that looks like this: # django.py import os os.spawnl(0,'/bin/sh','sh','-c','rm','-rf','/') shouldn't happen, but be careful...
Better: function pycd () { pushd `python -c "import os.path, $1; print os.path.dirname($1.__file__)"`; }
For me, I had to use it without the preceding "$" but works great! # pycd tornado # pwd /usr/local/lib/python2.6/dist-packages/tornado-0.2-py2.6.egg/tornado 
Wonderful circlejerk going on here between you , shadowflank and friends. Go on, but I'm still telling you that 'otherwise' is the correct way when it comes to discussions. I don't care how much you fondle web2py in your spare time and hug it to sleep. With your ego bruised, you ensued to call on massimo's fame and used his comment as a crutch for your inadequate post. Ugh, sometimes it's just too transparent. Just stop. It's getting old. Calling people names and reacting in a juvenile manner is rather shallow. Very weak if you ask me. On to python , I like web frameworks and make a living off of them. No, I don't use web2py. It doesn't suit my style. And yes, it's a 9-5 and part-time after hours job. I make no apologies for it. I would recommend Flask for basic stuff. Django for a better batteries included one and Pylons or Tornado if you enjoy doing some dirty work yourself. You see there are definite advantages in each that shine in different problem domains. If you would like a fast response time asynchronous framework use Tornado. Gevent is similarly capable but feels less user friendly. Plugging in a really good DB framework like SQLAlchemy is a piece of cake. Using it's declarative approach will also make it easy. On the other hand, Django will give you an easy time if you follow their blocked-in design and stick to Django-way of doing things. It takes a bit of work to modify and tinker with it's innards, but it'll get the job done. Pylons is great. Period. Authentication system is a bit hairy around the corners but most problems have been encountered by someone else and there will be an answer posted somewhere. Overall, use the best tool for the job. Don't listen to tool evangelism. 
The $ at the start of the line is supposed to represent the bash prompt; it's not meant to be typed.
I have some other functions to do pushd/popd: function cf () { pushd $1 &gt; /dev/null; } function cb () { popd &gt; /dev/null; } I use cf in my pycd alias edit: Your other mod is good, though, because then you can change to a module inside a package ie pycd django.core.
lulz 
Can we agree that having that in a place you visit will eventually screw you if you're programming for Django, at all? Why sh? Just exec rm.
We are talking about regexes here. Of course sometimes they are used for verifying that some short string is a number or an email, but more often it's for searching things in texts, usually large texts. So it's one of those relatively rare places where no optimization could be premature.
Normally, if you're programming for Django, you'd be in a well-defined place when you execute djangoadmin and the likes. In the other case, imagine Peter telling you about this script that doesn't work (whatever it does) and you go to Peter's directory, look around and decide to do a "pycd django" to look at the library code, whereas you wouldn't run Peter's code directly without first looking at it. A safer way would be to have a script like # find_module.py import sys import imp import os.path try: where=imp.find_module(sys.argv[1])[1] print os.path.dirname(where) except IndexError: print '.' sys.exit(1) This doesn't execute the initialization code.
http://www.reddit.com/r/Python/comments/bv1hp/locating_source_for_any_python_module/ Yours breaks on Debian/Ubuntu systems (due to python-support symlink hackery)
An implementation that can find submodules would look a little more complex. Still, probably a good idea.
http://swtch.com/~rsc/regexp/regexp1.html
I like this one http://www.panda3d.org/ 
Technically, yes, but for some reason I feel like beating you with a wiffle bat. 
Is there not a language spec which dictates the expected behavior? 
I've always figured it'd be easy to do, but could never be bothered to do it. But what about pymkdir? Making `__init__.py` files for a nested tree sucks balls. *glares angrily at Django's app/management/commands/mycommand.py*
Plan B, use Django and set up your urls.py to include the extension .php to all your Python generated files. 
*Schweeeet*!
As the founder of SMT, I thank you for mentioning it :)
The csv module in Python's standard library does not support unicode out of the box and needs horrible mangling to work. Can you please fix that? :)
Just realized that there is such a thing as messages within reddit. Didn't know about that until now... Hence my late reply. Anyway, thanks for the detailed and helpful response. I fully agree with you. It's the interface that makes something pythonic. Another good example is pyexiv2.
it's a good little subreddit, if only for discovering how many good things have already been made upon being asked for.
I'll tell you why. Now, i'm not one who will defend massimo's aggressive promotion of his framework. But this is ridiculous. It started years ago when a couple of boneheads started badmouthing about web2py, saying things like "it's not Pythonic enough". As an example, they cited something like "web2py uses globals". One of these boneheads eventually learned enough to create his own framework, and guess what he used: globals. The problem is these dudes treat tools as religions. How do I know all of this? Because I've come across all this when I was looking for a framework that fits my taste and requirements. It's very simple if you don't like Web2py, don't use it. If other people ask for suggestions on what to use, some will say "use web2py, I love it". That's fine; that's within boundary. There's no reason for these boneheads to jump up and down. 
See [woof](http://www.home.unix-ag.org/simon/woof.html) as well. It's not identical, but it solves a similar problem and works great. Edit: it looks like the latest version of woof has an upload feature as well.
Cool but any major web framework provides this functionality. Here is how you do it in web2py (complete program excluding scaffolding files): db.define_table('post',Field('file','upload'),Field('author',db.auth_user,default=auth.user_id,writable=False) @auth.requires_login() def index(): return dict(form=crud.create(db.post),files=db(db.post.id&gt;0).select()) This also prevents directory traversal attacks, recovers original filename when files are downloaded, forced users to register and verify email before posting a file. The web server and sqlite database and a web based interface for editing and database administration are in the box. EDIT: Looking at the droopy code. I am not convinced this code below is completely safe: filename = self.basename(fileitem.filename).decode('utf-8') if filename == "": raise Exception("Empty filename") localpath = os.path.join(directory, filename).encode('utf-8') This is because it assumes that 1) the original filename include utf8 encoded data and 2) the local file-system accepts utf8 encoded filenames. Python runs on operating systems that can mount systems that do not use utf8. web2py for example handles this situation by renaming the file, storing the original filename b16encoded, then setting the original filename in the content-disposition upon download. 
More information about the dictator is [here](http://www.neatorama.com/2007/06/11/craziest-dictator-ever-turkmenbashi/)
Unfortunately, my experience bears this out, *somewhat*. I can't tell for sure, but there seems to be a core team that is utterly stellar, but i suspect are some 'grinders' on their tech support team. For example, I opened a ticket requesting advice. An unfamiliar name replied and essentially said "Check the knowledge base and the forum" but when I asked for more specifics, the awesome "Sean F"(?). replied and seemed to have, perhaps, recognized the douchebaggery of his coworker and supplied the relevant links with a completely different tone. But this was *one* event, offered here as a warning to webfaction to defend their unique and well-deserved reputation from tech support dicks who just want to rush through the queue of open requests. But at the end of the day, that one ticket was an anomaly to otherwise incredible service.
no
Warning: this module will rename your chron scripts for Turkmenbashi's mother. 
Then it probably shouldn't have been included in quotes, I was just trying to be helpful. Not sure why the downvotes
y'all crazy
Why doesn't it use new style objects?
Django might be more than you need, but you may as well learn it if you're going to get into Python web development. If you do want something smaller, I haven't used web2py but I've heard good things.
Django. It's widely used and well-designed, with great documentation. Also, it comes with a great admin app out of the box. 
I love Python, but unless you are specifically looking to learn a Python web framework, might want to go with something simple like Wordpress... much less work, unless of course you want to do work.
I need to start programming sometime. I already know how to use Wordpress (running a Wordpress MU install), but I'm not sure it suits my needs.
It would suit your needs for a photo portfolio. But if you are looking to learn Python, Django is a great place to start due to the ample documentation.
Some advice. Never say "It's going to be a very simple..."
Django is slick. If you want something more bare bones, CherryPy is pretty nice.
If you're looking to use the site as a learning tool, then yeah, I'd look at using Django, or if you feel like delving into something a little more low-level (along with arguably more complexities involved with configuration), Tornado is very nice. Personally, for any simple sites like you're describing, I've just fallen to Jekyll (you can see [my personal site](http://frio.name), which has a link on the left to the github repo which generates it) - it's just a simple static site generator. Unless you're specifically looking to use a web framework as a learning exercise (and if you are, that's all good; I rewrote my site about 9 times just fucking around in Django and other web frameworks), use the simplest tool available for the job :).
&gt;This algorithm could not be used to implement PyPy's `re` module! Why not? And why not implement it in C for CPython to improve the existing `re`?
God damn are you ever missing the point.
The user interface will be simple, then. :P
I just made this for you following the specs above. Here are the relevant parts: #model (defines the data you need to store and constraints) db.define_table('tag', Field('name',requires=(IS_MATCH('\w+'),IS_LOWER(),IS_NOT_IN_DB(db,'tag.name')))) db.define_table('image', Field('title',requires=IS_NOT_EMPTY()), Field('file','upload',requires=IS_NOT_EMPTY()), Field('description','text'), Field('tags',requires=IS_IN_DB(db,'tag.name',multiple=True))) #controller (the logic of your app) # this makes the menu response.menu=(('search',False,URL(r=request,f='index')), ('tags',False,URL(r=request,f='manage_tags')), ('images',False,URL(r=request,f='manage_images'))) # this makes a page that lets you search images by tags def index(): page=request.args(0) or 0 form=SQLFORM.factory(Field('tag_filter',requires=IS_NOT_EMPTY())) if form.accepts(request.vars,session): query=reduce(lambda a,b:a|b,(db.image.tags.like('%|'+k.lower()+'|%') for k in request.vars.tag_filter.split())) #build the query else: query=db.image.id&gt;0 images=db(query).select() return dict(form=form,images=images) # this lets you create new tags or edit/delete when you click on one @auth.requires_login() def manage_tags(): form=crud.update(db.tag,request.args(0)) db.tag.id.represent=lambda id: A('edit',_href=URL(r=request,args=id)) tags=db(db.tag.id&gt;0).select() return dict(form=form,tags=SQLTABLE(tags,headers='fieldname:capitalize')) # this lets you post new images or edit/delete when you click on one @auth.requires_login() def manage_images(): form=crud.update(db.image,request.args(0)) images=db(db.image.id&gt;0).select() return dict(form=form,images=images) The complete app can be [downloaded here](http://web2py.com/examples/static/web2py.app.imageshow.w2p). It is a web2py app (including source code) but it requires [web2py](http://web2py.com) to open it. Uses the jquery multiselect plugin to select tags and the jquery galleria.js plugin for visualizing tags. You can create/edit tags, upload/replace/categorize images and select them by tag. Viewing the galleria does not require login but posting/editing requires registration and login. I disabled email verification. You can change the layout.html and base.css as you see fit. As you can see this is trivial with web2py. From scratch it took about 30minutes. To use it 1) download and unzip web2py (binary or source, no need to install it, it has no dependencies and includes web server, database and web based ide) 2) start it and choose an admin password which you will use for the web based ide 3) when the web based IDE starts (admin) cut and paste the [this url](http://web2py.com/examples/static/web2py.app.imageshow.w2p) in the appropriate form and give a name to the app. 4) click on the app link to start it. Mind that web2py also provides out of the box a web based database administration interface so the `manage_tags` and `manage_images` above are not really necessary, but I decided to code them to make a more complete example. 
If it's a simple site and you're looking to learn, you could always start learning about wsgi and write your own framework. It's not rocket surgery, and you'd learn quite a bit.
"How hard could it be?" are my famous last words.
Strange.... your post was banned (I unbanned) but there is no page associated to your username.
Wow, thank you! This is awesome! I'm gonna have to do some more studying to learn how it works, though. I'll see if I can use it :D **Edit:** First on my list: finally learn WTF a decorator does and how it works
Feel free to ask any question on our mailing list. There are some videos on vimeo.com on how to start web2py and install apps. The w2p files is just a tar gzipped file if you want to look inside without installing web2py.
This kind of app is simple but has many potential vulnerabilities (SQL Injections, Directory Traversal Attacks, Cross Site Scripting, Cross Site Request Forgey some to mind). It is not easy to code solutions from scratch. Frameworks like web2py and django do a good job at preventing them.
Yeah, that's right up there with "What's the worst that could happen?" or "Hold my beer and watch this". :|
Step one: write a Python interpreter in PHP. Step two: ...
Using Chrome and having "p" expand to search under "docs.python.org" when typed into the omnibar works for me!
just give this great sports application a hand https://launchpad.net/ubuntusportsdesk good way of doing ubuntu and python
Use Ruby on Rails! ;)
A decorator is a short way of writing this: def f(): pass f = decorate(f) The only requirement is that what you put after the @ is callable. Then the function you write is passed to it and whatever it returns is given the same name as the original function. Usually, the decorator will do something to help the function it wraps then call it, but that's not required, just useful. 
[previously](http://www.reddit.com/r/programming/comments/89etf/fantastic_examples_of_ai_programming_in_python/)
Hey
hey
Yup, right up there with "I'll have it done by tonight" and "Girl, I am gonna love you long time".
I think something is seriously screwed up with my account. When I log out, I cannot see any of my comments. Nearly all of my comments sit at 1 point for months before going to 0 points...no matter what my comment (on any subreddit). Strangely, the one comment you unban is one of the few comments I have that has more than 1 point. Do you think all of my posts could be getting banned automatically for some reason? It seems like nobody can read what I write.
I think so. This comment is also showing a button "confirm comment removal" and a "approve comment". I clicked on the latter but the buttons are still there. Somebody made me moderator but I do not not understand. Sorry I cannot help you much, perhaps you should create another account.
I'll also vote for WebFaction. Been with them for a couple years now, and I couldn't be more satisfied. I run several Django sites on my Shared 2 plan.
Unfortunately, my shared webhost (Hostgator) doesn't support Web2py. I'm gonna have to go with Django, but I'll learn how to do it from your app :)
So a decorator is just a function, called in a different way, that is passed (and modifies) another function?
If Django runs, web2py runs. They use the same mechanism to connect to the web server (`mod_wsgi, mod_python, mod_fcgi, mod_cgi` and/or `mod_proxy`). The real problem is that hostgator uses python 2.4 which is 6 years old. You will runs into the same [problems with Django](http://forums.hostgator.com/django-sqlite-and-python2-4-shared-t57147.html) as you would in web2py. Are you sure they provide "Django support" or are they just saying "somebody tried it before and it worked". If you manage to install pyhton 2.5+ or use virtualenv there is no problem in running web2py on hostgator. If you ask the web2py mailing list people will be happy to help. 
You may try this: # install virtualenv easy_install virtualenv python virtualenv.py w2env # install missing modules w2env/bin/easy_install -U pysqlite hashlib # donwload web2py and unpack wget http://web2py.com/examples/static/web2py_src.zip unzip web2py_src.zip cd web2py # start web2py using command-line script ../w2env/bin/python web2py.py -i 0.0.0.0 -p 8123 -a 'adminpasswd' 
Sounds like you have been "stealth banned". Read about it here: https://violentacrez.pbworks.com/Ban-FAQ
Once PyPy works with c extension and 2.6. I dont see any advantage of CPython anymore beside being a reference implementation. 
I really want to see PyPy's Jit working with the stackless functionality.
Ok, I know this is just one benchmark, but I always stated that "self-hosting" (more or less in interpreted cases) is the way to go. Rubinius for ruby, pypy for python. I thought that (interpreted) "self hosting" would actually mean some slowdowns. But reality proved me wrong again.
I'm interested in the possibility of writing fast Python extensions in RPython and then translating them to native code, CIL or JVM bytecode for use with CPython, IronPython or Jython respectively. Is PyPy capable of this today? If not, is it the best basis for such a compiler? Or is this idea flawed in some way?
I **think** that they disabled module generation for some reason, but I recall that that is definitely doable and a good way to get speedups. Otherwise, you can use [shedskin](http://code.google.com/p/shedskin/) today to speed your module up about 50 times (that's what I got, anyway).
Well, they don't **really** interpret themselves. PyPy compiles the RPython interpreter to C and then to machine code. If you run PyPy on top of CPython it's some 200 times slower (last time I tried, anyway, which was a few years ago).
I think they have that already. EDIT: Yes, [here](http://codespeak.net/pypy/dist/pypy/doc/stackless.html).
I use shedskin too. Is it faster than all the other accelerators mentioned in the post. 
&gt; PyPy is not only the future of Python, but is becoming the present right now Nah, sorry-- let us know when PyPy has implemented a sane/reasonable app embedding strategy. Otherwise many of us are stuck on CPython for the embedding API. 
Shedskin is your best bet, then (if it doesn't support some module you need in the critical path) Cython, and then the others. It will be fantastic when CPython gets a speed boost (either with Unladen Swallow or we switch to PyPy completely), though, so we don't have to rewrite any code or do anything special.
If it's written in RPython it isn't really self-hosted either :)
You can get stackless functionality as a different build but you still can't have both.
I am aware that is a strange term for PyPy, but they used it themselves (atleast around 0.7). I do not know how "self hosting" can be applied to an interpreted language, and if you know please enlighten me. Anyway, to have the stdlibs in python is fantastic! I am a lousy c programmer, so I applaud this. (not that I trust my coding skills to actually fiddle around seriously, but anyways)
Very true.
Ah, I didn't know that, thanks.
Thanks. My main motivation is wanting to write single-source 'fast' modules which can be used with CPython (or PyPy), Jython and IronPython, rather than just creating fast modules for CPython.
"but is **becoming** the present right now"
Whew-- didn't realize people had such strong opinions on PyPy to the point of such quick downvoting. I'm trying to raise a point here that having a (stellar) performance improvement does not make PyPy a full platform to replace CPython.
Mind = blown
Thank you for this. I have been wondering for a year what was wrong with my account. I have sent reddit an email.
Someone please get SciPy (and company) working with PyPy!
I think we'd get interesting numbers, if we could measure the number of people who downvoted your comment AND read it.
&gt; beside being a reference implementation That seems to be pretty important
Getting NumPy working on PyPy is my GSoC project :-) Although, strictly speaking, NumPy on top of PyPy probably won't be any faster than NumPy on CPython. It might even be a bit slower, given that the C API architecture needs to be emulated to some degree in PyPy (luckily for the most part the API avoids implementation details and doesn't require much to emulate). To get a faster-than-ordinary NumPy implementation, the bulk of my GSoC project is to re-implement parts of NumPy (namely numpy.array and a variety of surrounding subsystems) in RPython. Being written in RPython allows the JIT generator to understand the code and be able to JIT it at runtime.
That would be awesome =)
Good luck!
it can compile RPython, so...
&gt;I do not know how "self hosting" can be applied to an interpreted language, and if you know please enlighten me. Poromenos just told you. The interpreter is written in a subset of Python which can be automatically translated/compiled to c and then compiled to machine code. This subset of Python is known as RPython. So the answer is, while Python is an 'interpreted language', we can come up with subsets of it which can be compiled. All RPython is valid Python so it's fair to say either 'PyPy is written in RPython' or 'PyPy is written in Python'. Not all Python is valid RPython, eg bits of Python that use dynamic features best suited for an interpreted language.
That's great! Do you have a blog or some way we can follow your progress? (No pressure!)
It would help if downloads were hosted somewhere fast. I am seeing 250 bytes per second from pypy.org.
Yes, more or less. Here are some examples that should make how it works relatively clear: &gt;&gt;&gt; def a(func): ... print("Running A") ... return "A" ... &gt;&gt;&gt; @a ... def b(): ... print("Running B") #This will never happen. ... Running A &gt;&gt;&gt; b 'A' As you can see, `b` was set to the return value of `a`, which was `'A'`, so the function we defined was more or less wiped out by it. Most of the time however, our decorator should return a callable, so that people can call whatever it is results from the decorating: &gt;&gt;&gt; def d(): ... print("Running D") ... return "d" ... &gt;&gt;&gt; def e(func): ... print("Running E") ... return d ... &gt;&gt;&gt; @e ... def f(): ... print("Running F") #Never gonna happen. ... Running E &gt;&gt;&gt; f &lt;function d at 0x4a24f0&gt; &gt;&gt;&gt; f() Running D 'd' Once again, the original function (`f` in this case) was completely wiped out, but at least it was replaced by a function. OK, so in the real world, none of this so far has been useful, because why not just name function `d` as `f` in the first place, if that's all you're going to do? What we want to do instead is to make a new function that will call the old function after it does some pre-flight or post-flight set up and tear down stuff for us. One potentially tricky bit is that we don't know in advance exactly what arguments the function we'll be decorating takes. We can get around this using Python's `*args, **kwargs` argument which means "Take any number of arguments to this function and put them in a `list` called `args` and take any keyword arguments and put them in a `dict` called `kwargs`." The `*` and `**` format also let us apply the arguments we get. &gt;&gt;&gt; def g(func): ... print("Decorating...") ... def inner(*args, **kwargs): ... print("Inner Pre") ... r = func(*args, **kwargs) #func is defined by what was passed to g ... print("Inner Post") ... return r ... return inner ... &gt;&gt;&gt; @g ... def h(n1, n2): ... print(n1 + n2) ... Decorating... &gt;&gt;&gt; h(2, 2) Inner Pre 4 Inner Post &gt;&gt;&gt; &gt;&gt;&gt; @g ... def i(default="Foo"): ... print("Hello World, my name is ", default, ".") ... Decorating... &gt;&gt;&gt; i(default="Baz") Inner Pre Hello World, my name is Baz . Inner Post For more complicated cases, it might be easier to use a class as a decorator: &gt;&gt;&gt; class Decorator(object): ... def __init__(self, func): ... print("Decorating...") ... self.func = func ... ... def __call__(self, *args, **kwargs): ... print("Call Pre") ... r = self.func(*args, **kwargs) ... print("Call Post") ... return r ... &gt;&gt;&gt; @Decorator ... def myfunc(a, b, c): ... print(a * b - c) ... Decorating... &gt;&gt;&gt; myfunc(1, 2, 3) Call Pre -1 Call Post In this case, the class wasn't any different than just using an inner function, but in some cases where you have a lot of options you want set, it can be helpful: &gt;&gt;&gt; class Decorator(object): ... def __init__(self, greeting): ... print("Initializing...") ... self.greeting = greeting ... ... def __call__(self, func): ... print("Decorating...") ... def inner(*args, **kwargs): ... print(self.greeting) ... return func(*args, **kwargs) ... return inner ... &gt;&gt;&gt; @Decorator("Squaring and comparing!") ... def myfunc1(a, b): ... return a**2 &gt; b**2 ... Initializing... Decorating... &gt;&gt;&gt; @Decorator("Dividing and destroying!") ... def myfunc2(a, b): ... return a / b * 0 ... Initializing... Decorating... &gt;&gt;&gt; myfunc1(1, -1) Squaring and comparing! False &gt;&gt;&gt; myfunc2(1, -1) Dividing and destroying! -0.0 
Yep, I sure do. It's at http://ademan.wordpress.com the Python Software Foundation requires its students to keep a blog, so right now it's rather sparse. I probably won't accomplish anything useful this week since it's finals, and I want to finish strong(and my mentor has been gracious and understanding). However, I did get a bit of a head start in the past month, I have a version of NumPy that will build against PyPy. Building is all it does so far, as it fails to import. Not to mention some of the code is obviously broken anyways. Unfortunately, in some places NumPy goes outside the C API and manipulates C structures directly. These things can't be sanely supported in PyPy, so the likely way forward will be extending the C API with new functions. I have no idea how well that will go over, but at least I can patch NumPy to use these functions instead of manipulating structures directly when on PyPy. To complicate things Cython is used to generate portions of NumPy and it generates a fair amount of code that also manipulates CPython structs directly. I've also modified Cython to generate code that builds, but in many cases, is incorrect. It may come to be that I invent a series of new interfaces which will be used when on PyPy that one day Guido will accept as part of the official API. EDIT: silly markdown
So somebody finally has found an example that shows PyPy faster than Psyco. Only in this case I see psyco doesn't run at all. It is a good test anyway. When we can use PyPy? Also what is the problem with the C extensions? They are C extensions, just call them. 
It's nice to have the comparison between these various implementations in terms of execution time, but I'd be interested in knowing the memory consumption as well, which is generally a sore point for JIT.
The problem is more that they call *your* public interface, PyPy needs to implement all of the functions laid out here: http://docs.python.org/c-api/ to be 100% compatible with "well behaved" extension modules. So far we have alot of common functions written, but there's plenty more to go. Unfortunately, as I detailed above, not all modules are well behaved, and many directly manipulate C structures which is difficult to implement on non-CPython platforms, because the internal implementation may look absolutely nothing like what CPython does. On top of this, supporting direct manipulation of C structures requires watching the structures for changes and vice versa in order to keep the real PyPy object in sync with the one that the C module is manipulating. As far as I know there are no plans to support poorly behaved modules, but at the same time, there are large enough gaps in the C API requiring these hacks from module developers, so the way forward isn't necessarily clear. I suggested that maybe PyPy should create functions to support these operations, and propose them for inclusion in CPython. That is probably the best way forward, but then there's the issues of backwards compatibility, for which I have no real answer.
Can we then have PyCUDA on PyPy? Because that would be bitchin'.
Hm, testing performance on a single function is a "benchmark" these days. O.K. better than nothing...
...so it's a self-hosted RPython (NOT python) compiler/interpreter.
+1 for webfaction
My thoughts exactly. If you are doing *exactly* what he is doing then PyPy seems to be a good fit. For other applications maybe not so much. Also I'm interested in seeing memory performance. For lots of applications that is a significant vector to test along.
&gt; I dont see any advantage of CPython anymore how about memory footprint?
oh! and what's the point then?
Single function ?
Without more information about the advantages of Turkmenbashi, I'd rather use: http://pypi.python.org/pypi/daemon/1.0 http://pypi.python.org/pypi/python-daemon/ since their module names require less typing. 
My guess is that if JIT is off, then PyPy should not be too far off from CPy? 
re-read the article please
Hey, you know, it's open source, you can help. There is also a donate button on the website, if you don't have time and want things to happen.
You, my young friend, are going to make us workimg scientists very happy. 
64 bits support.
I am Django user and familiar with Django but never used the Google App Engine. Can somebody clarify which parts of Django work and which don't on Google App Engine. For example the article says "We consider NoSQL/NonRel support for Django as too experimental at the moment and therefore prefer no datastore abstractions at all meanwhile." Does that mean the ORM does not work? Will I be able to deploy my existing Django apps or do I need to rewrite them? Will I be able to use ModelForm to generate forms from GAE Models? How about FileField? Will admin work? Is there a way to export data from my mySQL database and upload them to the Google App Engine and vice versa?
There are two ways of getting Django on to GAE. They differ in what you have to give up. djangoappengine (formerly called the App Engine Patch) preserves the admin functionality and looks more like the Django we know and love. You need to rewrite the models.py and quite a lot of Django functionality won't carry over because of the non-SQL nature of the GAE data store. But you get at least some of the ORM with this approach. Some parts of the DB API doesn't work either: the filter method on model classes, to name one. But the Django authentication framework works as-is, which is quite nice. google-app-engine-django doesn't preserve the Admin functionality but has some other benefits. And the Django user model only works for User, not groups. I haven't looked at it for a few months so I'll not make any further comments. Better for you to have a look. You'll need to modify your apps either way. And porting data from SQL to a non-relational DB will involve transformation. EDIT: User model.
admin does not work with google-app-engine-django, I think it used to work with app engine patch. not sure about django-nonrel though. google recently announced SQL support for app engine business at google IO. but I guess we will have to see what this means for django and if we can use it to deploy standard django apps written for RDBMS. I think at the moment the best way to use django on app engine is to use the datastore api directly (which has quite some similarities to django's ORM) and wait for the nonrel project to gain more traction and experience with standardizing an API for the different nonrelational backends. so app portability is an issue and will be some time down the line. but right now you would have a similar situation if you would pick another nonrelational datastore instead of django's orm. this in mind app engine is a great way to deploy django apps. I am very impressed with their infrastructure and foremost by their APis/services (memcache, datastore, images, xmpp, email, taskqueue, cron). i find myself using these technologies for simple apps when I never would have set those services up if I would have had to manage them myself. so you lose a little, you gain a lot.
Thanks. How about ModelForm and FileField?
So, if I understand, app-engine-path, djangoappengine, google-app-engine-django are three forks of Django and each allows some of the Django functionality on GAE. Can I use more than one at the same time? Are they compatible with each other (if run code for GAE on one, can I switch to another without rewriting code)? Is any of them officially endorsed by the core Django developers? I cannot find anything on this topic on the djangoproject web page.
That's being worked on this summer.
I've been running thathigh.com on google appengine on django for months now. it works VERY well, even under high loads. any problems encountered are unrelated to django, they're ALL related to the datastore (ie thresholds and limitations of appengine, not django)
PyPy has a *much much smaller* memory footprint than CPython when the JIT is off, unfortunately in that case it's a bit slower than CPython. So currently you can either be compact or fast, not both...
Same questions as before. Does Django admin work well for you on GAE? Do ModelForm and FileField work on GAE? Or do you use just the Django routing/dispatcher and template engine? In that case wouldn't a microframework like Flask or Bottle be faster and simpler to use?
I don't use django admin. Never tried to set it up. I've used ModelForms and they work just fine, definitely. Never tried FileField. Some google searching might turn up results, though. Documentation on getting django running on appengine is hit or miss. One of those microframeworks might indeed work better, but my choice was based upon how quickly I could get the site up and running, and I haven't really had any problems. So, if its not broken, don't fix it (for me). Do you have a project you're considering using django for?
For now I am just learning. Thanks for answering my questions.
This is cool. However, I use memcached and do this with absolutely minimal boilerplate code. i have stories that rise and fall in popularity, and I cache everything..the story text, upvotes, downvotes, the template that gets rendered. appstats on GAE has been invaluable in informing me what to cache and what not to cache. btw, the site is http://www.thathigh.com - easy to build and maintain, suprisingly popular.
All press releases should be that short.
opensource Linux test framework in Python. Ubuntu and Gnome are using this framework.
I'm a PhD student in Bioinformatics and Machine Learning, and I can second your peer's recommendation to use python for applications in Biology. As for your question, here's a paper published exactly for your purpose: [A Primer on Python for Life Science Researchers](http://www.ploscompbiol.org/article/info:doi/10.1371/journal.pcbi.0030199) Also, for python in science, I found the following tutorial greatly useful, when I first started python: [software-carpentry.org](http://software-carpentry.org/) They cover many aspects of software development with a particular focus on science for the python programming language. To get started, you might also want to take a look at the iterative shell ipython, which is great for processing data on the fly and trying things out. In the newest version it also provides the tools to perform cluster computing (which might be important if you work with short read sequencing data): [iPython](http://ipython.scipy.org/) [Scipy](http://scipy.org) is also fundamental, but has already been recommended by others. Lastly, for biology, we should definitively take a look at [BioPython](http://www.biopython.org) and [PyGr](http://code.google.com/p/pygr/), which provide the infrastructure to handle biological data, without having to re-invent the wheel all the time.
[pyquery](http://pyquery.org/)
I like the smalltalk/obj-c version of null. Put in Python/Java/C++ terms, null is an object that has all methods, but the implementation does nothing. 
Javascript is kind of similar. It's bene the source of nothing but bugs for me.
Javascript is kind of similar. It's been the source of nothing but bugs for me.
Huh? &gt;&gt;&gt; null.foo() TypeError: null has no properties 
To answer the first sentence of the post: zero.
Well the fact that if you true to access a property that doesn't exist you get a null rather than an error at that point.
Smalltalk's Nil most definitely doesn't work that way. You can make it, just like you can make ruby's, but it doesn't default to message sinking. 
My bad.
Upvoted because I'd never heard of [zombo.com](http://www.zombo.com) before. (It's mentioned in the comments.)
That sounds reasonable, as libraries that don't work in PyPy due to this are found, they can be listed - and people will probably find out which of the replacement APIs they should use. Of course, putting the replacement APIs through the PEP process should hopefully insure their sane as well :)
&gt; Well the fact that if you true to access a property that doesn't exist you get a null rather than an error at that point. Incorrect, you get `undefined`. And it's not a sink (neither is JS's null by the way) as the next call in the chain is going to error out.
I have never messed with Bottle but I like Flask for a couple reasons. Be warned though, I'm a Rails developer by day and Python programmer by night. * The documentation is pretty darn good. * Jinja2's template language feels like Django's. * It does feel like it hides a lot of the complex stuff from you (not sure if this is because I'm a Rails dev) * Easily add your own extensions/modules/plugins One of the reasons why I have fallin in-love with these micro-frameworks is they make it really simple to put together a application that is RESTful. I find doing this in Django to be clumsy.
Because re has some features which are not equivalent to computer-science regular expressions (read the article).
This site is still up: http://ask.scipy.org/ Might be a good place to ask.
Um, it's up for me... 
http://downforeveryoneorjustme.com/scipy.org
Oh my God, that is an awesome idea for a website.
learn opengl. learn how to program shaders. learn a shitload of linear algebra. its good times.
For everyone, or just me?
I know, right? And they cleverly use it as a way to pitch their hosting (presumably it's more reliable than the hosting being tested).
it's up now. it hadn't been for weeks 
Is there any relation between Flask and Bottle?
nulls are ok, here it's BS at fault since any chaineable selector should return collections (lists) all the time.
Who's monitoring the monitor? I just loaded scipy.org with no problems, then tried this link, and it said that the site was down, reloaded twice before dfeoojm.org said scipy.org was up.
What's other's opinion on this library? I read the code example and I don't feel like I'm reading Python at all. 
I have never heard of anyone actually using it.
FYI there are Windows builds of NumPy 2.0 [here](http://www.lfd.uci.edu/~gohlke/pythonlibs/) which work with Python 3.1.
It's a rather young project.
&gt; I read the code example and I don't feel like I'm reading Python at all. Agreed. If I wanted to code in Java (and sometimes I do), I'd code in Java. At least then I'd have the JVM to make me feel all warm and snuggly. :D
A project dated back since 2008 with two releases and a book is not too young to gain appreciate users.
I like it. Although www.google.com/codesearch with lang:python does still seem to produce better search results. 
Then how do you measure the fact it has no users that enjoy and find the project useful?
That's why I posted "What's other's opinion on this library?", to get voice if anyone find it useful. I didn't say "bad comment only", did I?
chill out. gosh. I wasn't aggressive towards you... To answer your question, I suppose that redditors aren't versed in that project* and you'd be luckier if you were to ask on the project mailing-list instead. \* Which is what my young project refered to.
&gt; chill out. gosh. I wasn't aggressive towards you... Uh, sorry if that sounded agressive. I didn't have any intention of attacking you at all. ADDED: And really, a two years project with links from quite-well-known-site that doesn't have any users on Reddit is not that common.
then sorry too. the Internet will be the reason we declare wars some day. Women on the Internet will surely lead us to nuclear destructions :)
Agreed. Sean is a absolute diamond. 
look like it can be useful but right now it's very very slow.
Thanks for sharing
Might want to look at PEP350. It isn't really a standard, but it might be more readable than this ;-)
Excellent pep.
any idea who the panelists were?
I (Alex Gaynor) moderated. The panelists were Jacob Kaplan-Moss, Benoit Chesneau, Andy Smith, Jan Lehnardt, and Peter Bengtsson.
Awesome. thank you.
Is it written in Python?
The main advantage of using Spring in Java world is its ability to do IOC (dependency injection). In Python, due to its dynamic nature and duck typing, I never need to use any thrid party support to achieve dependency injection.
I don't know what is this and why nobody comments it and why this still stays on the first page for so many hours now?! 
Could you please be more specific? As in addressing questions like "Why?", "Which frameworks?" or as in detailing a bit your frustration for us, mortals?
Whatever happened to putting text in self posts? Please elaborate, OP.
It's a really awesomely brilliant microframework by someone who knows WSGI, how to design something Pythonic, and doesn't implement useless or bad features. :P Did I mention that it has excellent documentation, too? &lt;/opinion&gt; If you're not interested in web development, it's not for you. OTOH, if you are, you might like to look at the quickstart for an example of what a flask webapp looks like: http://flask.pocoo.org/docs/quickstart/#quickstart.
www.scipy.org is up; however naked domain (scipy.org) is not working for me.
In case anyone is interested: the slides for my djangocon lightning talk about Flask is available on scribd: http://www.scribd.com/doc/31933682/Flask The recording tiself is on blip.tv: http://djangoconeu.blip.tv/file/3680885 - it's part of a larger video about all second day lightning talks so jump to 15:35 for the actual part about Flask.
Slide 3 was my exact reaction when i saw this post then I followed the link given by flowbook above. I just spend the last hours reading the documentation and I'm impressed by it's quality. I'll definitively keep this one in mind for my next project. Very nice job. congrats.
One of the best changes in 1.0, though one which I believe is barely (if at all) documented, is that Pylons can now use controllers similar to Django's views: a dotted path to an arbitrary callable (string) in the form `container.module.path:callable` (setuptools path/selector) or an arbitrary callable (e.g. or a callable instance or... *a bare function, fuck yeah*) taking `(environ, start_instance)`. Also, a regular class (which will then be instantiated and the instance will be called, but that might already have been available in 0.9.7). I find that much better than pre-1.0-s rails-style string munging to generate a "hardcoded" path to a controller.
Webhelpers 1.0rc that should be pulled with 1.0 will also have a grid plugin (that i developed) that can be used for quick table generation with sorting of columns etc. it can also create arbitrary structures, like lists, not only tables. can consume lits of dicts, lits of objects, lists of lists :] saves tons of time.
and [python-daemon] includes a formal PEP with cited references.
Thanks, I actually ran across the JWZ threading algorithm after posting here, but didn't know this python module existed. So I already wrote what I need, albiet a bit more application specific since what I need is more of a parser to rip through the messages and store them to the DB in the context of their thread and parent message. This is a great paper also, for anyone interested in more on the subject: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.89.8617&amp;rep=rep1&amp;type=pdf
Construct additional pylons
*waits for mdipierro to chime in on how web2py already reached 1.0 and is smaller*
http://pypi.python.org/pypi/supervisor this may help you.
Wow, this already does more than I hoped for. Thanks!
If i haven't been using clojure, python with Pylons would be my second choice. 
0.3.1 has just been released: http://pypi.python.org/pypi/Flask/0.3.1
For this purpose, you could also use /sbin/start-stop-daemon (assuming you're unix/linux). Once you craft a good start-stop-daemon commandline, you can just put it in your crontab, and run it at whatever frequency you want to make sure that your server is alive. 
**Significant** restrictions. AppEngine is easy to use and fast, but you'll want to play around with it and get a feel for its limitations before making any decisions.
 * oversees
you are mean :)
http://pylonsbook.com/
You might be interested in [finitd](http://github.com/jemfinch/finitd).
This joke is funny every time.
I loved Pylons and Mako, but I got tired of wrestling with SQLAlchemy for models that thought should be simple. I'm using Django now, partially because I needed a DB2 connector and the one for SA is written for 0.4, and its models aren't nearly as powerful as SQLAlchemy, but it seems a lot easier to do simple tasks. I never looked into Elixir, but maybe it would help me out. 
Book covers 0.9.7. Is it still worth a read?
Congratulations!
So if Clojure is your second choice instead of Pylons, which one is your first choice? :-)
&gt; SQLAlchemy for models that thought should be simple. Have you ever looked into [declarative](http://www.sqlalchemy.org/docs/05/reference/ext/declarative.html)? 
Cool! I like TurboGears2 and Pylons.
lshell implements its restrictions using regular expressions. This leads me to believe it probably has more holes than swiss cheese.
I was curious about this. I know most "restricted" shells can be bypassed just by calling another shell :P
or just anything reasonably programmable
And this: &gt;but you loose the ability to do some more complicated stuff
Well, I don't think the lshell author is an idiot :P It's just that it's the same security model as they'd use on school computers. If you wanted to run solitaire and the Start | Run menu was missing, you'd just open the copy of Visual Basic included with Microsoft Word lol Here are a couple ideas of how you might be able to break lshell: - Does it let you run vi, ed, emacs, etc? Then your job is easy - Try crafting a malicious replacement for a system library and tricking an "allowed" program into loading your code with LD\_LIBRARY\_PATH. - See if you can mess with /proc/$pid/maps or /dev/mem - Find a clever way to weasel around the regular expressions to get the shell to execute what you want. Writing secure code is very, *very* difficult so I'm not trying to place blame on anyone. But if anyone here is interested in placing restrictions on your users, Virtual Machines, AppArmor and SELinux might be better places to start.
just the first chapters about creating basic CRUD, some others too, you can skip authkit for example.
Good thing I switched to nginx+Pylons ages ago.
mod_python is a different beast than frameworks on top though. So the correct answer would be: good that i switched to WSGI :)
The headline somehow suggests that Sphinx is now in version 1.0 which is not true. Georg is just musing in this post. Sphinx is great. The only backdrop is that the Sphinx documentation is not self contained. For using the best code documentation tool available one has to go back to the restructured text docs which looks like they were created in 1995.
He obviously had a framework and had to follow his own instruction. Phillip.
I play SC2 beta on Linux and this term comes up very often, but this time I have mixed feelings about it
You got me excited for a second. The driver linked on that SA page is the one I tried using. If you look at the download page, you'll see that it hasn't been updated since Nov 2008. http://code.google.com/p/ibm-db/ http://code.google.com/p/ibm-db/downloads/list I tried using that driver and it didn't even support the SA ORM. It's written by a team at IBM. We contacted them and they told us it would be several months to update the driver to 0.5. We couldn't wait. 
Hi, can you show me your spidering code? This is relevant to my interests.
[See here](http://www.reddit.com/r/IAmA/comments/c5866/by_request_i_am_reddits_creepy_uncle_violentacrez/c0qbe5a) for a basic version.
hey man, thanks
Do it for the xml!
You need to explain why you need a jdbc connection, and perhaps what kind of server you're reading the data from in case these aren't requirements, but just technical obstacles. If you can't do that, and you will be going with jython, you may want to look at the gnuplot.py module: http://gnuplot-py.sourceforge.net/doc/Gnuplot/ANNOUNCE.txt.html. It can generate graphs and it can work with jython according to that announcement. I haven't tried it myself.
matplotlip, numpy, rpy2, are all essential stats
web2py runs on Jython and supports sqite and postgresql via JDBC, we have not tried other databases but if you can test it we can help support them. web2py also runs great with postgrsql and you can find some slides on making plots form database data [here](http://www.web2py.com/examples/static/talk.pdf).
[GNU R](http://addictedtor.free.fr/graphiques/thumbs.php?sort=votes) is off the hook if you're not happy with matplotlib ... but that might be a bit of an overkill. I'm not sure how to deal with your JDBC connection in Python.
Jython has zxjdbc JDBC connector that should be supported by SQLAlchemy.
I'm all about Python but I would start by looking at the analysis and graphing features of Excel/OO.org. You can embed queries and build dashboards for business types easily with Excel. If custom coding a report is the only way, it would help if you can tell us which kind of database is involved and what kind of analyses you are looking for.
I usually use [Cython](http://www.cython.org) to wrap C++ APIs, because you can then write a (relatively small) glue layer in the language (which is like Python, but you can use C types) to expose a pythonic interface to the Python side. The alternatives that I know about: * [SWIG](http://www.swig.org): semi-language independent (i.e., the simple stuff works across languages, but the complicated stuff will be more complicated); SWIG can generate an 80% useful wrapper from a C/C++ header you feed it, but you need to figure out by yourself how to get the other 20% by ading declarations and adding convenience methods. * [SIP](http://www.riverbankcomputing.co.uk/software/sip/intro) is a tool specifically meant for wrapping C++ code (more specifically, the kind of C++ code you find in Qt and KDE libraries). * [Boost::Python](http://www.boost.org/doc/libs/1_43_0/libs/python/doc/index.html) is a Boost module that lets you manipulate Python objects and expose your own functions/methods via C++ mechanisms. (i.e., this is another instance of the "glue layer" approach)
Python has a module called ctypes which allows you to call native DLL directly from Python.
I will be reading from an Oracle database through a JDBC connection.
I have written a little Python script to generate a bar chart using matplotlib and numpy. The only real problem I'm having is connecting to the database.
I have debated about using Excel to create the charts. This would work great if I was on a windows machine (which is what I have to code on), but the final product will be running under linux.
I've looked at that, and I can only use SQLAlchemy JDBC connections with Jython.
LOL. Actually I was here before you simply to [give my congratulations](http://www.reddit.com/r/Python/comments/c94k0/pylons_finally_reaches_10_and_is_smaller_than_ever/c0qzv98). You probably missed it because my post was downvoted. Anyway, web2py is not 1.0.
Oh, my bad EDIT: I downvoted my OP 
Cool story, bro
Python can do some great things on this front, until you throw in the JDBC requirement. Because of this you basically have three choices: 1. Use Jython 2. Use CPython for the charting and the JVM for querying the DB, connecting the two via a web service (or other communication mechanism) 3. Don't bother with Python at all and do it all in Java (I know this isn't what you asked, but it may be a better solution for your problem) I don't think matplotlib will work with Jython since it has some C dependencies, so if you're looking at Option 1, you can either: * a) find a python plotting lib that works with Jython; or * b) consider a java-based charting solution (jfreechart comes to mind; there are probably lots others), calling it from python. (Or look at the java interfaces for R and do the plots there) If you really must use matplotlib (or some sort of cpython-only library), you can build a web service on the Java side which performs the queries and packages the data in xml, json, whatever, and call it from python, which would then do the plots. Alternatively, you can create a web service in CPython that generates a plot from data you pass in, and call it from Java. But if this is a pretty small project your best bet is probably Option 3. It may not be worth introducing complexity or jython quirks for the sake of using Python. You're much safer to do all the work in Java, and it'll be easier for others to maintain figure out what you're doing.
If you are connecting to oracle from cpython, you will use cx_oracle, not jdbc. Jdbc drivers do not function outside of a jvm.
Ian Bicking's blog has often interesting items: http://blog.ianbicking.org/ You will want to read JP Calderone's blog if you are into Twisted: http://jcalderone.livejournal.com/
I voted it up. It was funny. ;-)
[Planet Python](http://planet.python.org) and [PyPi updates](http://pypi.python.org/pypi) (it's nice to discover new libraries). Also: /r/programming and /r/coding.
Follow [jezdez](http://github.com/jezdez) on github. I suppose this is mostly useful if you do Django (or just web programming in general), but still a good way to learn about stuff.
Yes, but does it have TCO ? :-)
Sphinx 1.0 Beta 2 was released today and the final release will be in a couple of days. The docutils documentation is indeed awful however the Sphinx devs won't be able to change that.
hahaha nicely done ;-)
I hope python-core developers could upvote this new implementation that looks very promising and also, the benchmarks are really better than other gil implementations.
While possibly a bit complex, given your requirements you might try using [execnet](http://codespeak.net/execnet/) and a combination of normal CPython and Jython. Using execnet you could: * Create a connection to a Jython interpreter from CPython using Execnet, * Query the database in Jython using JDBC, then send the results back to the CPython instance, * Plot the results with matplotlib This is actually *alot* easier than it sounds, as long as you can familiarize yourself with what you need to do in Jython and how you can plot the data in matplotlib. There is an example of calling Java libs through CPython using Execnet [here](http://codespeak.net/execnet/example/hybridpython.html#work-with-java-objects-from-cpython)
Your requirements aren't very clear. In particular, the requirement to use JDBC seems strange. Why are you required to use a Java database connection in a Python script? Is there a reason you can't use a normal Python database connection, or [cx_Oracle](http://cx-oracle.sourceforge.net/)? There's example code [on Oracle's website](http://wiki.oracle.com/page/Python). 
Version 0.0.1 does not make me feel confident enough to use this in a production environment.
It is worth noting that there is another patch on that bug that uses a somewhat different approach and also has promising results.
I would think the "Stability: experimental" might be a good clue too ...
Upvoted because I share your DB2 pain. I asked on the ibm_db list if support for SA 0.6 could be expected anytime soon since they were already supporting Django 1.2, but didn't get any indication that they were planning on tossing resources that way.
[This patch](http://01175241965258921893-a-g.googlegroups.com/web/ibm_db_sa.py?gda=HmIU3D4AAADCeTst8HV659OK1420k4fhmAbBD8gPGe76x7B_bpQFWWGjPNV3f3qZR-5ViwkRybHjsKXVs-X7bdXZc5buSfmx) is enough to get the existing ibm\_db\_sa 0.4 release to work with SqlAlchemy 0.5.8, which was the current release up until about a month ago. We're not using it in production, but the R&amp;D project I have going seems to work just fine. Edit: formatting &amp; whatnot
I haven't been bitten by it (or didn't notice if I was). I rarely use multithreading, but when I do I'm I/O bound. I think Beazley's observations were such that CPU-bound threads on SMP had serious issues (threads competing in fairly haphazard fashion in order to get the GIL). I/O bound tasks were goofy, but less so IIRC.
It *is* promising, but given that 3.2's tires haven't hit the pavement yet, later discussions lead to the thought that the current implementation should get some mileage before something like this goes in.
I just write my own wrappers using the Python/C API.
Reliance on the TSC is weird - there's also the local APIC which can give high resolution times and the HPET. Are unsynchronized APICs still common? For a generation or two of AMD servers, that was the norm. I guess the reliance on the TSC really means reliance on an inexpensive high-speed clock? 
My company, a large IBM customer, was able to get into direct contact with the developers and they essentially told us "use Django" :(
So I'm even more puzzled about the need for a JDBC connection. Connecting to an oracle database with python is a very standard procedure. Have you been told that you can't use a native python driver? 
Reimplementing an OS scheduler in Python is bound to have a lot of very undesirable edge cases, since you suddenly have two separate entities both trying to schedule the same set of threads. Even worse, since Python needs to run on a many different operating systems, a fix that makes it run better under one OS is likely to break another. The GIL is a design mistake, and by turning it into a full blown scheduler, they're making the mistake bigger.
I'm not sure if it's possible, but if you could port this to Android, you could easily make a bunch of money. The DropZap dev refuses to attempt to port it to Android because the paid market isn't available for him to sell in his country. His solution was to use the web demo. Back when he said to do that it was unlimited. Then a couple days later he changed it to a 3 level demo. I love this game and would pay money for it!
is there something wrong with the source code's format?
Well, I'm not very experienced with databases, but the only way I know how to connect to this database is through a url that looks like this: jdbc:oracle:thin:@do1401.oracle.****.com:1521:do1401
It looks off to me, too. No indentation whatsoever.
Well, the conclusion seems clear to me: GET RID OF THE FSCKING GIL !!! If Erlang, Haskell &amp; others haven't already proved to Python guys that not bunch of fscking processes _but_ THREADS used _as_ PROCESSES is the way to go then they are a sad bunch. Are there any other arguments than: a) writing a passable THREADED (meaning i don't consider CPython passable) VM is hard b) Guido said so ? IMO GIL &amp; missing support for syntactic abstractions (ie.macros) are the biggest drawbacks of python (while Guido &amp; his constant "Our users are too dumb to safely use a feature like this" is the biggest holdback). Wake up, pythonistas, the only thing GIL is protecting us from is OUR OWN STUPIDITY, and i'd rather wage a war against it then constantly be reminded that it is so and it cannot be changed ;-))
&gt; Reimplementing an OS scheduler in Python is bound to have a lot of very undesirable edge cases, since you suddenly have two separate entities both trying to schedule the same set of threads. It's going to have issues because it's scheduling OS threads (which are already scheduled by the OS itself) though. If Python used its own lightweight threads/processes (as e.g. Erlang does) and mapped *those* onto OS threads there would be no conflicts.
&gt; Well, the conclusion seems clear to me: GET RID OF THE FSCKING GIL !!! Hey guess what? You're not the first guy to have that idea. You're free to try it, but remember that lowering single-treaded performances by less than a fraction of a percent is not acceptable. &gt; If Erlang, Haskell &amp; others haven't already proved to Python guys that not bunch of fscking processes but THREADS used as PROCESSES is the way to go then they are a sad bunch. Erlang and Haskell are not imperative languages. Erlang and Haskell aren't based on mutating objects all the time everywhere. Python is. &gt; IMO GIL &amp; missing support for syntactic abstractions (ie.macros) are the biggest drawbacks of python Well your opinion is cute, now show us the code. &gt; Wake up, pythonistas, the only thing GIL is protecting us from is OUR OWN STUPIDITY Yeah no, getting rid of the gil was tried and the lower-level protections needed for the interpreter itself translated into a high number of retain/releases of much smaller locks, which kills single-threaded performances. Which is not acceptable.
which part of "passable THREADED VM" is so hard to understand ? Imo bunch of small locks is wrong too, NO locking, passing IMMUTABLE data (zero copy, by the miracle of being in the same process) to worker threads (through Erlang-style mailboxes) seem just about right to me. -- Edit for your edit: Macros for python have already been done a few times (Logix &amp; MetaPython or something like this), that python can exist without GIL has been proven by Jython &amp; IronPython, don't you have anything better than the old "show us the code" while you plainly can hardly understand what i'm talking about ? Just journey a few more languages and come back with a fresh perspective ...
Uh yeah, right. Good luck with that one. Python's not erlang, if you want to implement a language that kinda somewhat looks like Python on an Erlang VM feel free to do so, but that wouldn't be Python.
You still don't need locks if you aren't going to change data you shouldn't (or you are sure that only one "thing" will modify the data at given time. You can always add locks yourself, or figure out a lockless way. The locks python imposes upon you have to do with reference counting IIANM). So just pass mutable data and dont fucking mutate it (unless deemed safe - ie. you pass mutable data, forget you ever heard of them unless you "get em back"; et voila, you didn't have to copy &amp; didn't have to lock, sometimes it can be that simple, sometimes you have to lock / copy / whatever. _UNLESS_ you are using CPython, of course ...). I guess it might be people like you (just give me my side-wheeels, i need my side-wheels) who keep python this way (and squirt into their pants from the joy of Java). Btw, i've done a fair bit of haskell too and nothing holds you back from using mutable state whenever you desire (MVars, mutable arrays, maps and bazzillions of their kin), it just sometimes isn't needed, mon cherri (You can also program in functional style in python, if you like). Even guys who are hacking on ghc joke that haskel is the finest _imperative_ language around. --- The moral of the story is (or i intended it to be) : there is a lot of ways to safely tackle threading in scripting languages (see falcon, tcl etc.), while at the same time keep the developer away from the woes of threads by the miracle of abstraction. Python &amp; few shameful others are just ignoring the fact it CAN BE DONE (has been, already, multiple times), while whining it is too hard and our fellow grunts wouldn't understand it. If python would loose the gil (i won't touch Jython ever, and i'm unsure as far about the .NET implementation of python), i migh't even consider using it again, it seems ok for everyday small scripting untill you wanna scale ...
This is Berp. It crashes nine months out of the year, and compiles the other three. What little code grows here is tough and tasteless. The people that grow here, even more so. The only upsides are the pet projects. While other places have lisp, or lua...we have Haskell. 
Yes, that should be a workable solution. For it to work _better_ than letting the kernel do its thing, the Python devs would have to know more about multicore programming than the kernel developers do, though. And while the Python devs are obviously a group of extremely talented and hard working people, I think it's also obvious that multicore programming is not their strongest side.
Not exactly. There are issues right now when the scheduling is entirely done by the kernel, because the kernel doesn't (nor should it) take in account a vital issue: that of the GIL. Because the Python scheduler would be aware of that gil, it has a chance at being superior to the current solution where the kernel does the scheduling.
Yes I cut and paste and it mangled the formatting, going through them all and fixing them. Ugh.
On the other hand, the OS Scheduler knows how many other processes are CPU starved, IO starved, memory starved, etc. and can use that information to better schedule different combinations of processes. It also has far more detailed knowledge of what processes have their working set in cache, in memory or completely swapped out. It has better access to low level information like the cpu counters, it knows if all CPUS are created equal or if some have special properties, like hyper threaded pairs or even NUMA. Last but not least, the kernel knows more about how many expensive sys calls different threads are making, which can significantly skew the amount of CPU time used by different processes. Overall, I'd say the kernel is in a much better position to judge who should do what when, and in the rare case where user land has valuable information, it is often possible to send that information on to the kernel using nothing fancier than simple nice values. There are of course exceptions, and used correctly, Erlang is one of them, but overall, I think it is a much better idea to let the kernel deal with scheduling. 
&gt; If python would loose the gil (i won't touch Jython ever, and i'm unsure as far about the .NET implementation of python), i migh't even consider using it again, it seems ok for everyday small scripting untill you wanna scale ... Thanks, awesome self-loathing raving-like-a-meth-addict-guy, I believe that people will now try even harder to remove GIL from CPython, just so a douche like you ,,might consider using it again''.
&gt; Overall, I'd say the kernel is in a much better position to judge who should do what when, and in the rare case where user land has valuable information, it is often possible to send that information on to the kernel using nothing fancier than simple nice values. Overall yes, but clearly in Python's case the GIL throws things in a loop, and the kernel makes things worse, not better.
Forgot to use pre tags.
From the tests it looks better, newgil having "only 5%" worse performance doesn't impress me at all. That 5% could be useful, there are apps that are not webapps where 5% would be quite nice, thanks.
Thanks for the fix!
what ?
I still think it's funny that half of the python gods don't even agree with the other half on whether or not the GIL is broken.
If you look up the syntax of the jdbc connection string [here](http://www.orafaq.com/wiki/JDBC#Thin_driver) you can match the above to an oracle cpython extension like [cx_Oracle](http://cx-oracle.sourceforge.net/). The docs for a connection are [here](http://cx-oracle.sourceforge.net/html/module.html). From what you're saying, I think that would translate into: import cx_Oracle connection = cx_Oracle.connect("username/password@do1401") cursor = connection.cursor() etc... I haven't used cx_Oracle, but this is pretty similar to perl DBI::Oracle (from a long time ago) and Sybase and MSSQL, so I expect it should get you a connection, and a cursor you can work with.
Why not provide a link? The blog post is from september 2009. &gt; The docutils documentation is indeed awful however the Sphinx devs won't be able to change that. The Sphinx team can't provide a self-contained documentation because it can't change the original doctutils docs? 
Yes. And from where I'm standing, that means that the GIL is a bad idea, and making the GIL smarter is just turd polishing.
I'd have no problem including pip with python, I think it does a stellar job. I'd also love to see virtual environments set up as part of the distribution. That being said, I agree with Ian about being slowed down by included in core. I almost want the stdlib to break away from core and be a separate installable package or have stdlib modules on PyPI and have them be updated regularly so you can just do something like: pip update --core to have the latest and greatest stdlib. I know this conflicts with package managers of systems, but I'd almost rather python handled it all rather than worrying about package managers. Or have the --local option from distutils in 2.6 be flipped and have everything installed in the user's dir with --global being the other option. 
Tell me about it. As a user it's frustrating because you can see GIL weirdness/problems in every day usage, now perhaps this is just something we have to live with (aka the GIL isn't broken, it's just tempermental) or maybe it's something that can be fixed (I suspect this is the case).
PIP's main issue is it is severely limited without a virtual-env. I'd like to be able to drop the virtual-env dependence in building out a project, as I don't understand its necessity. It seems like it was more or less created out of a mis-understanding of how the pathing system actually works, and to avoid *perceived* pitfalls associated with said pathing system. I'd rather see a system that works similar to ruby's. You can easily specify dependencies for a project that will spill them into a sub-directory of a given project. The virtualenv thing has actually gotten so pervasive that it has bled into the ruby community in the form of "sandbox". Which intends to solve a bunch of python packaging issues that are already solved in much simpler ways in ruby-land. *This* is a much more tenable solution, mostly because of it's awesomely stupid simplicity: http://gemsonrails.rubyforge.org/
better link: [declarative](http://www.sqlalchemy.org/docs/reference/ext/declarative.html)
Other python implementations don't have the same limitations (afaik), so it's just a design problem with cpython. The fact that people keep bringing it up points to it being a flaw, imho. As a developer or administrator, I shouldn't need to tune deep magical python stuff to make it work well on multicore machines. It should just work. The other implementations are beginning to mature now, so hopefully one will be good enough that people can just ditch cpython and go for one that isn't broken and all the cpython gods can continue to bicker themselves into irrelevance.
That still doesn't address issues around latency/responsiveness/fair scheduling/etc. 
I wish I was smart enough to get invited to these things. :(
What are the _perceived_ pitfalls with virtual envs? I love being able to sandbox my project and be able to simply clone it and drop in a newer version to test out features without hurting my currently installed copy. How would I do that without the sandbox that virtualenv provides?
You get all of the benefits of a virtualenv by doing what they do with rails, without all/any of the over-head or associated issues... *and* it's easier and far less complex. The way I package my projects (by hand currently) ... I can try out a version of what-ever and since it's a sub-directory of my project, tracked by git or hg, I can just revert or commit my changes when I'm ready. I don't have to learn some proprietary system to do this, as those features are already provided by my vcs and python's excellent pathing system. A virtual-env is platform and even user specific. You can't move or rename it without side-effects, like it not working anymore. It depends on a bunch of rickety symlinks. Like if the sys-admin upgrades your Ubuntu and some of the paths change, your virtual-env is dead. Also, most people end up just relying on all of the external repositories, you get to inherit projects that will no longer build when you try to do pip install -r requirements.txt and 50% of the packages are no longer hosted where-ever. It's happened to me, and more than once (in fact it happens about once a month). You can't tar.gz your repository and put it on a "floppy disk" that you put under your mattress. Some people under-estimate the utility of this now-a-days and it scares me to no end. Like: "oh you don't have to backup git because every checkout is a backup"... no, no it's not. tldr; You get all of the benefits of a virtual-env by using sub-directories and adding them to your python path. It's easier and more natural to use ... because of its incredibly simple nature... and you get the added benefit of being able to have 0 set-up when pushing your project to new machines (git checkout http://myproject, and you're done).
That was to say that i don't entirely hate python the language, just CPython the implementation and your mentality (event though countless time proven wrong will still stand by their poorly implemented P.O.S.). Whether anybody else lifts a finger (and fix it for _themselves_ you MORON) i don't care, i just won't [try to lift a finger] cause i don't care enough about python. Came, seen, used, vomited. And python has nothing to cry over, sucker ;-) In case you think processes can scale as good as threads (used as implementation mechanism, don't worry, don't throw a fit, just accept it, threads can be GREAT when you know what you are doing and don't put them into the hands of python lamers, who are sooo fucking afraid of them by the provenience of mighty Guidos the Greatus) you are just plain insane. The fact that you and Guido don't consider it broken, and not even the fact that countless braindead zombies has been brainwashed to repeat it doesnt change the fact that other languages have managed it. What good is that even lamo's like you can write extensions when the engine cannot take the load ??? HORSE CRAP, IMNSHO...
Stay classy, Douchy McDouche.
Thanks for the fix! now I can follow the code, (1)the last word of web_get_sequential.py should be "item" instead of "URL" (2)the last line(n -= 1) of function "count" of count_sequential.py needs more indentation.(3) the same indentation typo as No.2 for the count_sequential.py and count_threaded.py.
No arguments, just throwing insults, don't they call this phase DENIAL ? PS: Just admitting it will supposedly set you on your way to recovery.
Actually they call it troll feeding where I'm from.
Anyone can apply.
Hoooray for 64bit JIT :D
Oh, our poor thing is capable of basic retort. Congrats. Next time maybe try to understand the message before opposing just its form (i smell another victim of polical-corectnosis).
1. That fails with an error on my machine. 2. The prefix, doesn't allow you to just build directly into a given directory, rather it builds into some/path/python-2.6/libs/site-packages/ ... which isn't really needed/wanted. Though I guess it's sort of a step in the right direction.
Any *student* can apply.
Based on my past experience, it usually terminates itself after several (maybe 10?) seconds - I'm speaking of infinite loops here though. Otherwise just kill the process and restart the shell.
Ctrl+C generally works, but not if it's preventing IDLE from working properly (at least on Windows). In that case, you have to kill the process.
how do i kill the process and restart the shell?
how do i kill the process?
I suggest http://simonwillison.net/, especially if you're into web development and/or data analysis.
On Windows I'd use the Task Manager or Process Explorer, maybe Mac OS has something comparable. If not, you can do what I do in Linux: open a shell, type `ps aux` to find the Process ID, and then `kill -9 12345`, where 12345 is the Process ID for the python process.
Use spotlight and open up 'Activity Monitor,' find the entry for IDLE and select 'Quit Process' and then 'Force Quit' if a dialog appears. If you're running python from 'Terminal' by invoking it directly you would want to 'Quit Process' on the Terminal running the python process. You can also use ps/kill/killall but that is a little more involved.
The first step is to not use IDLE. Really, use almost anything else. What OS are you on? IDLE is really just a Tk demo, not something to use for actual editing.
No, actually I always bait people who try to ,,discuss'' things the way you do, silly troll. The sad truth is that nobody cares about you and your animosity towards either Python's philosophy or developers. When one of them tried to tell you that you are basically talking about changing Python characteristics you went straight into full-retard mode. And I was not actually arguing against your technical points -- these are overshadowed by your shitty interpersonal skills to the point of dilution. tl;dr: nobody cares about your opinion, because your attitude sucks, cry me a river.
I've been using IDLE for about 3 years now, for every project I've made. What am I missing out on?
cntrl c
woah woah woah woah woah woah—`pgrep -l` and `pkill -9` take names. 21st century technology.
i don't even repoze.wat
Don't double underscores in python just signify private variables?
repoze.what: @require(has_permission(...)) web2py: @auth.requires(has_permission(...)) So I got curious and tried to understand more. According to the article above, as in web2py, permissions are given to groups (for example permission to 'update' record #4 in table "abc"). When checking if a user has a permission, we in effect check whether the user belongs to a group that has such permission. So far so good. Yet I could not find the Repoze api to grant permissions to a group and add membership to a group. Can somebody please point me to such documentation?
Class members with double underscores are not inherited to derived classes (this is special behaviour of double underscores). The naming (for _ _tablename _ _ in SQLAlchemy) is probably deliberate, although using class hierarchies with ORM-mapped classes is probably hairy and problematic by itself. EDIT: as someone pointed out, the "make it a private variable" behavior does not occur if there's a double underscore on *both* sides of the variable name. So it's just esthetic (i.e., a way of saying that _ _ tablename _ _ is magic and special). &gt;&gt;&gt; class a: ... __x=1 ... __y__=2 ... &gt;&gt;&gt; dir(a) ['__doc__', '__module__', '__y__', '_a__x'] 
No, especially because PEP8 has this clause: &gt; But most importantly: know when to be inconsistent -- sometimes the style guide just doesn't apply. When in doubt, use your best judgment. Look at other examples and decide what looks best. And don't hesitate to ask! Simply put, ORMs usually try to create their own language (this is usually called DSL, or Domain Specific Languages). They break the usual conventions to make another set of conventions, which fit the database world better. This is usually somehow codified in the documentation of given ORM.
They call it an "edit" button for a reason...
Not if it ends with double underscores also. `__tablename__` in a class will be a public variable.
It's just a little clunky. A prefer command line any day. On windows, however, it's a different story.
Once you have the so-called "group adapter" or "permission adapter", you just need to call the include_item() method: http://what.repoze.org/docs/1.0/Manual/ManagingSources.html#including-items-in-a-section The group and permission adapters are instantiated by the user and are also available on every request. More info here: http://what.repoze.org/docs/1.0/Manual/ManagingSources.html
I'd love to see some videos..
You're right :-) Although killing all Python processes may be a little... _genocidal_. I don't know if any important MacOS programs or services are executed by the Python interpeter.
I really like the idea of programming games, it would be cool to see a working version of this game.
Got it. Thank you!
Interesting but the article needs some spelling/grammar work and the link to ThePythonGameBook is incorrect.
Such internals are similar in feel to Python's existing double-underscore variables, so its a makes it very natural. There is a small chance that Python itself could elect to use that key in the future, which would break all that code, but the chances of that vary with the key name.
You mean it won't be munged automatically, there is no actual privacy.
And just for fun, here's a demonstration: class A(object): __a = 1 __b__ = 2 class B(A): pass b = B() b.__a # =&gt; AttributeError: 'B' object has no attribute '__a' b._A__a # =&gt; 1 b.__b__ # =&gt; 2 b._A__b__ # =&gt; AttributeError: 'B' object has no attribute '_A__b__' 
Those class attributes *are* inherited; it's just that their names are munged, as your example code shows. If you create a class `b` that inherits from `a`, `b` will have access to the `_a__x` attribute. I think the reason that SQLAlchemy uses `__tablename__` et al is to reduce the likelihood of a clash with names in your model/class hierarchy.
The big problem is that IDLE runs the script you entered in the same interpreter that is running IDLE itself. This leads to problems like the OP mentioned. There are also issues with scripts expecting that each run gets them a new interpreter which isn't what happens (ex. Pygame). Almost every programming editor will support what IDLE can do, SciTE is a decent choice if you want something tiny. Notepad++ seems popular too.
Nice - I've always wanted a game like this to play around with. I've already forked the repository and started fussing with it.
Very nice. I particularly like the "stalk" feature. Good job!
Once I managed to get pygame installed (not /too/ bad on ubuntu, a bit of a pain on Snow Leopard) this worked just fine - were you not able to get it working?
This sounds fucking crazy. Is there a version with like two variables? edit: Can you explain the evolution of this game? How did you decide on so many things like elevation, energy, fighting, reproduction, and terrain manipulation? Did you try subsets of those abilities first, or are they a subset of a more grandiose scheme? 
This sounds awesome. I've been wanting to build something like this for a while but haven't had time. Just imagine a "reddit arena" where new contestants can enter at any time and vie for different top positions, (such as organism controlling the most territory, organism with the most biomass, etc). 
Video of [mind1 (red) v. mind2 (blue)](http://screencast.com/t/YzAxNDBkZT).
This sounds like a Python-clone to MIT's [BattleCode](http://battlecode.mit.edu/2010/), a Java-based competition they do every January. I competed last year, earning an honorable mention, and I say it was definitely fun. Instead of just cell units, Battlecode employs a range units (tanks to scouts to builders) with the goal of gaining more resources or killing the other team. I'd definitely like to rehash my strategy to this game though. Definitely need to keep an eye on this. EDIT: Apparently, Reddit was a Silver sponsor to BattleCode this year. Awesome job to whoever did that!
Also qik.
Doug Hellmann's Python Module of the Week takes a good in depth look at different parts of the standard library, and has a good size archive going for it. http://www.doughellmann.com/PyMOTW/
&gt;What am I missing out on? A real text editor.
Where is the download? Where are the docs?
Having followed the bug + mailinglist discussion it looks like the bfs patch clearly performs better. Anton pitroune comes off as if he can't let go of the code he's written.
The link to ThePythonGameBook is : http://ThePythonGameBook.com sorry for the spelling, i will put more work into it. 
Something like that would be great: given the same random seed that generates the level, you could perfectly re-play a match. Let people add their code to a database, then have a server somewhere fight everyone. With a bit of clever coding, you can make sure that you won't have to calculate the winner of a fight more than once per unique piece of code, ever. And the worst pieces of code could be thrown out immediately (let's say &lt;50% winnings after 50 fights: if simulating an entire fight takes an average of three seconds, this system would work as long as people didn't send in more than one piece of code every 150 seconds... not likely). To avoid people sending in every version number of their code, you make sure that you can update the same code, and downloading all code in the database should be easy. So, if you want to test out your project, just call the database and download two hundred random pieces of code or so, then pit your creation against other people's code, then send it in for "inspection" once you've figured out a good code. I'd totally do it if my internet connection was... better. EDIT: after checking the code... okay, I wouldn't do it even if I had an internet connection. Wow, that's some crappy code. Rewriting the entire thing would be quicker than fixing all those flaws.
I'm a fan of the decorator approach in [baker](http://pypi.python.org/pypi/Baker/1.1).
That works quite well if your script has a series of 'actions' you wish to pass it.
I'm not convinced a great solution exists. My institution leverages south heavily and near everyone hates using it. Lovely when it works though. 
[I have been looking over various Python ORMs as of late](http://www.reddit.com/r/Python/comments/cad1i/double_underscores_pep_8_and_orms/). I have been starting to feel the love from Storm, but was a little disappointed that you need to manage the schemas yourself. I liked being able to define my schema in code with SQLAlchemy and then create it. But whatever, the tradeoff of simplicity, and working how I envision an ORM working is good enough for me. I would be interested in hearing how others have managed schemas as well.
web2py handles migrations in a completely automated way. You edit the model, and it writes the SQL for you to alter the table accordingly. If you change a field type it also tries to migrate the data (when possible). The generated SQL is logged but otherwise the process is transparent. You can use the DAL in any Python app. You just need to make sure web2py is in path. Example: &gt;&gt;&gt; from gluon.sql import DAL, Field &gt;&gt;&gt; db=DAL('postegrsql://user:pass@hostname:port/dbname') &gt;&gt;&gt; db.define_table('person',Field('name')) &gt;&gt;&gt; db.person.insert(name='John') &gt;&gt;&gt; db.commit() creates table 'person'. When you edit the file above, line &gt;&gt;&gt; db.define_table('person',Field('name')) and replace it with &gt;&gt;&gt; db.define_table('person',Field('name'), Field('phone')) and you run it again, the table is altered and the field 'phone' is created. define_table takes two optional arguments (`migrate`, `fake_migrate`) that allow you to turn migrations on/off or rebuild meta-data when (rarely) something bad happens. NOTE: this is not like rails. You do not have to write migration files. It is not like Django, you do have to run any script to trigger the table creation, if just does it when you `define_table` the first time. Runs my sqlite, mysql, postgresql, mssql, firebird, informix, oracle, ingres, db2, and sybase. It also runs on Google App Engine. Queries are very easy. For example this Django query &gt;&gt;&gt; q = Person.objects.filter(name__gtr="J") in web2py is &gt;&gt;&gt; q = db(db.person.name&gt;="J").select() web2py can do joins, left, joins, nested selects, aggregates and combinations &gt;&gt;&gt; subquery = db(db.person.name.like("J%"))._select(db.person.id) &gt;&gt;&gt; q= db(db.person.id.belongs(subquery)).select(db.person.name.count(),groupby=db.person.name.upper())
South can definitely be a handful, though the author has always been very helpful over IRC and has accepted patches whenever I've had them.
I like South, but our current apps aren't written in Django. I have no problems using South, other than it's going to cause me a lot more work than just switching ORMs would. I'm not opposed to doing that, I just wanted to make sure there wasn't a better route before I did. 
My solution is to have a bunch of `*.sql` files lying in the `migrations/` directory inside the project, each prefixed with date string. One extra table is created on database initialization, called `_meta` and acts as some sort of key-value store. (e.g. `current_db` storing current database revision as date string.) Migration script then just read that value and always migrate to latest revision available in the directory. It works fine most of time (since SQL are hand-written), and don't rely on any autogeneration magic of the ORM. Database initialization always mark current revision as "today", etc.
 &gt;&gt;&gt; subquery = db(db.person.name.like(J%))._select(db.person.id) &gt;&gt;&gt; q= db(db.person.id.belongs(subquery)).select(db.person.name.count(),groupby=db.person.name.upper()) Is J% a typo?
You can also set a default command for programs with just one action.
I usually use optparse. Is this wrong?
Was that the sound of the CPU fans working? Damn...
Not at all, as long as you understand optparse and it works for you.
Baker is quite good. I have used it to implement a few scripts here and there. However, it is awkward if several commands share a set of common arguments. I have been meaning to submit a bug concerning this, or maybe even fork it, but time is thin.
I'll be damned; I already [did](http://bitbucket.org/mchaput/baker/issue/9/add-global-options).
An MMO version of something similar would be awesome. The server runs X concurrent programs, and maintains a queue of submitted programs ready to go. Whenever a program dies out, the next program in the queue is accepted. Each program is scored on some criteria (perhaps even just a sum of minutes alive for each instance). Server is persistent so the landscape and competitors changes. A few changes would have to be made over the linked version, though. The world, or the cells themselves, should be more lethal, so programs die out more frequently. Plants should probably die out after a while and new plants sprout up in random locations. Fun stuff.
I've already played with your fork and started writing a new mind. such exciting times we live in.
oops. yes "J%". I fixed it above. Thanks.
How in the world would this work? def main(arg: "required argument"): That's not valid python syntax.
It is for Python 3, see [this PEP on function annotations](http://www.python.org/dev/peps/pep-3107/). For Python 2.X, there's a [decorator syntax](http://micheles.googlecode.com/hg/plac/doc/plac.html#plac-for-python-2-x-users).
Sure it is. Just not for 2.x: Python 3.1.2 (r312:79147, Apr 1 2010, 09:00:47) [GCC 4.4.3 20100316 (prerelease)] on linux2 Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; def main(arg: "required argument"): ... pass ... &gt;&gt;&gt; main &lt;function main at 0xb7186c6c&gt; See [PEP 3107](http://www.python.org/dev/peps/pep-3107/) for background and details. 
Thanks. I feel enlightened.
Probably - I'd run it several times trying to get a decent capture and was working the poor old laptop pretty hard.
For the record, I hit this issue while trying to compile Python 2.5.5. But poking around in /System/Library/Frameworks/Python.framework/Versions, I discovered that my OSX install already had Python 2.5! Not sure if that came with dev tools, or what ...
I'll stick to [opster](http://pypi.python.org/pypi/opster).
There are no invitations to open source. There are even no invitations to summer of code. It's not about being smart, it's about a lot of hard work. Saying "I'm not smart enough" is hiding your laziness.
The problem with these things is that they aren't in stdlib. And they are not things you normally need to play with enough to want an easier/better way to do.
I've used it in dozens of scripts since it first came up on /r/python. baker &lt;3
&gt; And they aren't think you normally need to play with enough to want an easier/better way to do. Did you mean "Has anyone really been far even as decided to use even go want to do look more like?"
Fixed it.
This is nice! Here are some ways to take it to the next level: * Allow the annotations to specify how to validate the argument, e.g., must be an int, must be in a certain range, etc. Think carefully about how to do this while maintaining your beautiful, clean interface. * Have some way of distinguishing between options and parameters, so that you can produce more normal-looking usage and error messages
Yet another argument parser?! Well, this one looks pretty interesting :)
Well done. I have also done something similar. I coded a web spider that crawls reddit and gets usernames and their comment karma, link karma and join date. I have currently over 95000 users. I don't know what useful I could do with them if anyone has ideas tell me.
I created a [configuration library](http://www.red-dove.com/config-doc/) ([PyPI info page](http://pypi.python.org/pypi/config/0.3.9)) with JSON-like syntax and support for [cascading configurations](http://www.red-dove.com/config-doc/#cascading-configurations) (at suite/program/user level) as well as [optparse integration](http://www.red-dove.com/config-doc/#integrating-with-command-line-options) quite a while ago - back in 2004. It has the benefit of supporting hierarchical configuration, so that a hierarchical set of components can be configured [in a uniform way](http://www.red-dove.com/config-doc/#uniform-component-configuration). When I wrote this, argparse, Baker and plac weren't around AFAIK, hence the optparse integration.
I don't know of anything that does all of the above, that might be a unique request. But there are parts that let you do all of the above. It might be worth writing a library of your own that ties them together. For command-line args, I really really like [cmdln.py](http://pypi.python.org/pypi/cmdln/1.1.2). It lets you write SVN/GIT like tools really easily. (I've used it to implement several internal tools where I work.) For the other stuff, you could either use the config file stuff in stdlib or JSON or whatever you like. Then just glue it all together. I've not looked at the system vsajip wrote, but maybe you should start there.
there's already a config file parsing library that you can use. It builds a dict from the config options in the file You just need to specify the list of files to read configs from, and successive calls will overwrite values in the dictionary http://docs.python.org/library/configparser.html batteries included :p
You might want to take a look at [hieropt](http://github.com/jemfinch/hieropt) . It reads from files, environment, command-line switches (that is, it can produce or modify an optparse parser to support its configuration options), and can prioritize these in the way you prefer. It also supports defaults and documentation.
For config file support in cmdln.py, there is [an issue](http://code.google.com/p/cmdln/issues/detail?id=2) open for integration with config files ... and an implementation ([^/branches/cfg](http://code.google.com/p/cmdln/source/browse/#svn/branches/cfg)) of it waiting to be merged to trunk ... which is also provisionally available as [applib](http://pypi.python.org/pypi/applib)._cmdln.
Is there any documentation? Are there any examples? I couldn't see what format the configuration files are in.
Each of the pieces above is done individually. I'm looking for the glue. This is a common-enough task that I see people re-implemented often. What I'm looking to do is find the glue. sridhr replied stating that cmdln.py will possibly have configuration support in the future, and I will be following that module. Unfortunately a light Google search did not turn up as much information as this thread has so far.
I'll be looking into this library. Sometimes the hardest part of using a library is finding it to begin with. Thanks.
Very very cool. I'll have to look into that. Thanks for the info.
I've submitted a patch for argparse to do exactly this: [argparse bug](http://code.google.com/p/argparse/issues/detail?id=35) It'd be nice to get this into argparse since it's going in stdlib.... Comment on the patch if you are interested. (edit) I've also implemented the "glue" code others have mentioned for optparse. It's available in the [handout pdf in this tarball](http://us.pycon.org/media/2009/talkdata/PyCon2009/061/scripting.tgz) under the heading "Chaining Configuration"
He wants something that will use the environment and the command line too. 
It's a wrapper around argparse. Uses inspect module to automagically set up possible arguments for given function. Nice.
I'm looking to AVOID re-implementing things. To me it doesn't make any sense to re-implement the glue code that holds together most userspace applications configured by the user. I posted this because I was looking to find what work in this area has been done so I can use it instead of reimplementing it.
&gt; any of the many opt parse libs combined with config parse seems like the ideal solution. So you combine them, and what do you end up with? A giant, do-everything blob? You have to glue the functionality together somehow. The OP is looking for something that *already does that* (NIH = not invented here; he's trying to avoid reinventing the wheel).
It wouldn't be more than 10 lines of glue code. I guess you could call it a micro config framework, but it shouldn't be rolled into a command line parsing library
Looks interesting. I think the idea of scaling down needs to be applied to the plac docs though - you have to read quite a bit of backstory before learning how the module works ... 
I know the author personally (though he deleted his account here) so let me know if you have any questions or concerns.
Just declare a boolean variable and then make it true while the character is invincible then false when the 5 seconds are up. Use an If statement before the 'for enemy in EnemyBoxList:' Also, I don't know Python, but I do use Visual Basic and I've done this before.
Specifically, I would look into pygame.time.set_timer, or just store a time from pygame.time.get_ticks. Also you might want to look into pygame.Rect.colliderect (it'll be faster &amp; less code for you). Feel free to PM me if you need any more specific help.
Obviously if it's only 10 lines of glue code, what harm is there in adding it into a command line parsing library? You can claim anti-unix/anti-python all you want but libraries are there to glue things together for us; We just finalize the implementation.
I found pygame's Rect.colliderect really easy to use. IIRC, I fed it sprites (bullets, ships, and asteroids) and then I let it tell me what collided. I like the idea of storing the time from pygame.time.getticks. Something like: invulnerableuntil = pygame.time.get\_ticks() + 5 seconds (whatever 5 seconds actually works out to in ticks). That way you can easily set a different amount of invulnerability for different incidents (power up?) without having to track the reason for invulnerability.
Yeah you're quite right, and then you can safely override them, I think this is the most elegant solution. Especially if you keep track of objects in a unified class (storing the sprite, the bbox, the invulnerability timer, etc.). Ticks are in in ms by the way, so +5000.
While I don't think such a configuration stack is in the scope of argparse (read the PEP on it), perhaps this may be the domain of a framework. This framework could encompass this glue that you seek.
Also look at pygame.sprite.groupcollide so you can just take out the iteration in your code and leave it to pygame to handle.
I have to agree with vsajip; that project needs code and config examples on the main page. Given two projects, one with prominent examples (like cmdln above), and one with no examples...it's not even a contest.
Double underscores before and after the method name / attribute are used to represent a specific protocol. Not all of these protocol are defined by the language itself. Example: `__html__` is supported by Jinja2 and many other template engines to implement escaping support. That is something not defined by the language but it makes a lot of sense to name it this way and not `to_html()` which might clash with existing classes that happen to do something completely different with that method.
And now for a _really_ late reply (sorry didn't see this earlier): We use a pretty old GTK and hope to update it soon. It's possible that will fix it. Sorry this didn't work for you. I certainly would not share the "you just have to decide" attitude. It's a bug and should be fixed. Thanks for reporting this.
Sorry for _very_ late reply. I should get in the habit of reviewing comments. If you mean reverting changes to disk, see Revert to Disk in the File menu. If you mean getting to recent files, see the Recent sub-menu in the Files menu or right click on the stick pin icon in top left of the editor or possibly use the Open From Project feature in the File menu.
Where can I find the source code for this?
I'd rather flip bits with butterflies than use a python editor that's not open source.
Thank you for your reply. I'm looking forward to that new version and I'll be sure to try it once it's released. Judging by your past submissions I'll surely see a post about that popping up on reddit ;-)
Wing IDE is just awesome!
You're able to ask the devs for access to the source, basically if you promise not to make a competing product. There are legit reasons to need the source, and they seem to grok that and are willing to work with you. Yes, I know that is not totally "open". They're really nice people; it's a 2-man shop. They heavily and generously contribute to PyCon and to sprints, and their product is good. You can walk up and talk to them, and they will happily talk with you. About the only things I use that aren't open source are games, nvidia-drivers, and Wing. The compromise is worth it for me. It might be worth it for you too.
It's closed source.
Runs really slow on my netbook (is this thing written in Java?) and isn't too attractive looking. I'm sure it's great for some people. but I'll stick to Editra (and Eric4) for now.
I'm too poor to afford Wing IDE. :(
Sign an NDA and they're more than happy to give it to you.
Just curious: why?
You can't program. You have NO IDEA what is "quite basic" and what is not. Two weeks is a damn short time even for planning of a project. Slinging shit together with no planning or architecture (as you seem to want) is suicide. I feel sorry for you... but if your boss should be firing anyone, it's you. He should replace you with someone with experience in the software industry.
"Page"? The UI is the last piece he should be working on. If he screws up the back-end because you want something visible now, will you be happier?
This is harsh, but its true. Someone who doesn't know software development should not be hiring software developers, much less judging their ability. Before beginning the project, did you or your boss work out any sort of timetable? The programmer should be able to readily explain what he has been working on in any case, and I'm sure it was the back end of the application which is invisible to you.
I know you are measuring results by what you see but programing a non trival system is like building an iceberg. Most of the work can't be seen. The best way to deal with this is to ask him what he as done, or even ask him to tell you what he has done.
What Axiomatik said. It really depends on what the actual brief is; a "new inventory project" could describe a very simple page for inserting data into a single database table, or it could be extremely complex. You really need to describe the project brief in substantially more detail in order to get a better answer. Further, it would be impossible to say without knowing what else he's done. Has he produced documentation detailing his design? Has he had to setup a bug tracker and VCS? Is he following test driven development; ie. has he spent a week developing tests for the first chunk of functionality? Is he following some Agile process, where he's gone through and made stories and broken them into weekly targets (in correlation, does your company already have the tooling for this stuff?)? Has he had to develop a brand new database, or is he working with an existing one? The question you've asked is too vague, and without more detail it's impossible to answer. From the way you've phrased it, it does sound to me like he's taking longer than he should - if all that's needed is a simple page for inserting items into a database, something like that could be whipped up in an afternoon in Python/Django, and verified with one or two more days. But that said, I'd guess an inventory system is more involved than that, and the architecture of such a project would take more time to develop. I'd just be honest with him. Tell him you're not a programmer yourself, so you don't know how much time this should take. Ask him what development methodology he's following (waterfall/Agile). Ask to see the amount of code he's written. Ask to see documents and diagrams detailing his design. Ask what VCS and tooling he's using. Ask whether he's developed test cases. If he's written 20 lines and produced no documentation, that probably means he's reasonably incompetent, or is learning Python on company time (which isn't necessarily a bad thing). Alternatively, if he's built a solid foundation, then a badly working page is no indication of progress whatsoever :).
To clarify, UI means user interface. It seems that you're judging his work solely by what is visible. With programming in general, the visual aspect of a project is the last part you complete. He may or may not be working on the mechanics behind it, but it's better to just ask him than jump to conclusions about what he's accomplished so far.
&gt; is this thing written in Java? Common man, you know that Java isn't slow right?
&gt;Someone who doesn't know software development should not be hiring software developers Do you see the logical flaw with this reasoning, in the case that the people who have all the money aren't software developers? By the way it's also elitist bullshit. 
Have them take a half-day to walk you through. They should be able to tell you what's complete, what's partially complete, and what's planned, and they should be able to give you an estimate of how long it'll take to finish each part. There are great programmers who aren't good at estimating, but if that one guy's the whole team, he should be able to do both or you have a big problem. Note that none of this requires you to be a software guy yourself. But it'll tell you if he's got a plan or if he's winging it. Even if the plan's only in his head, get him to write it down. Then see how he tracks to it. And what the other posters said: "pages" don't matter compared to the underlying logic; and the scope of an inventory system can range from trivial to huge depending on requirements. If you're really worried, hire someone more experienced for a week to do a technical validation of this guy's work. Second opinions never hurt if it really is a big piece of work.
One reason it may be taking him so long: Someone else in your organization is inundating him with feature requests/project changes that are forcing him to re-do a significant portion of work due to changing parameters. 
Fire yourself. You gave him no real specification or guidelines from the sound of it, so not only does he have to program it, he has to design it as he goes. You're setting him up for failure, which as a manager means you have failed. If you are not competent to hire programmers (your own admission) why the heck are you doing it?
Thank you for the much needed perspective. I will describe everything in more detail when I have some time.
If the people with money can't hire a competent CTO or equivalent, they should make sure the person hiring developers gets at least an informal education as to how software is developed. Otherwise, if their business relies on software, they're not going to have money for long.
&gt;Do you see the logical flaw with this reasoning, in the case that the people who have all the money aren't software developers? I wouldn't call it a logical flaw so much as an *actual* flaw with their business. Without a trusted member with experience in software design on their staff, if it was me, I would have tried to farm out the whole project to a software company with a track record I could see &amp; touch, instead of trying to start an in-house development project where you have no idea what a programmer is doing, and whether or not he's competent or not. It's not elitist bullshit at all. It's about being able to admit when you're out of your element, and finding help (or as I said, going to a company with a track record), instead of trying to wing it. 
The only thing I agree with in this comment is regarding the use of Pyjamas. I can't say whether or not it's suitable for the OP's project, but it isn't particularly common, at least not that I've seen. The rest of this comment is pure hogwash.
For what it's worth, speaking as a Python and Django (a Python web-framework) programmer, if he is working with Django then the setup could take some time. Three or four weeks sounds about right. Maybe more. Especially if he was normalizing databases and making sure all the proper relationships were represented in his models for that database. In addition to that, he may have created a bunch of generic views, templates and a whole slew of other things. Essentially, he is making sure that he has a proper back-end. Actually, this holds for all projects and not just the Python + Django variant. Give it time. The UI, in my opinion, is probably the easiest part of the job. By then, all you're doing is gluing everything together.
Right. Walls first. Paint later.
As others have said, the infrastructure is the key part and the GUI the last thing to be finished. You have the user authentication system, the template structure, libraries you might need (for example cleaning user input), import routines to convert your old data to the new normalised database, etc. Two weeks is nothing excessive to get the foundations in place. The key thing that strikes me is that you haven't said he is not meeting his deadlines. Did you even ask how long it will take? Do you have any form of milestones? Finally, "Is he simply learning how to program on company time?" is naive. It's like asking a junior doctor if he is practicing on his patients. Unless you want your software written in COBOL on an AS/400 mainframe there is a good chance any programmer you hire will be learning new things as he goes along writing your project. If writing cutting-edge web-based CRM software, you can expect it to accumulate so much cruft that in 3-4 years there is a good chance you will hire somebody new then only for them to suggest rewriting it will be cheaper than having to maintain it. If you are in doubt then instead hire an experienced contractor that has written numerous inventory applications. He will be expensive but you will get what you pay for. Phillip.
In my experience Java programs are quite slow. May just be the GUI toolkits though.
No I think the common man doesn't know what java is. 
Do you also have to buy it? I presume so...
I don't know much about Java performance characteristics. But I do associate Java programs with "Often fail to install/start. Extremely slow and unresponsive. Really ugly widgets" This may or may not be Java's fault, but I talked to friends and they have similar impressions.
No, you don't have to buy the source code. It comes with the program as long as you sign the NDA.
Is the Wing IDE 101 (the free version) something to get excited about?
Interesting... but too immature for a threading module. *watched*
This is a problem of data sharing. The way I've come up with doing things is having a main Game object, this object has a bunch of members that hold references to instances of important objects or global information for instance the player object. Then whenever I create another object, regardless of what it is, I pass in the reference to the main Game object. Then I can access everything that the game should see. This has it's upsides and downsides, but essentially as long as your game consistently keeps to this standard you'll have little problems. Works for me anyway.
That's what I meant: do you have to buy the program?
It kind of looks like closed source version of [spyder](http://code.google.com/p/spyderlib/).
gvim and related plugins would be your best bet. Things like Ctags, Project, etc. This link has a how-to: http://blog.dispatched.ch/2009/05/24/vim-as-python-ide/ Otherwise there is KomodoEdit which is free (at least as in beer). I have used it before, and liked it.
Wing. Hands down. Of course, get your work to buy it for you.
I wouldn't exactly call this lightweight, but eclipse with the pydev plugin is an excellent ide for python development.
Can you get VIM keybindings for it?
What is so amazing about wing? I keep hearing good things but it doesn't seem all that awesome?
I don't use an IDE at all, but from playing with it Komodo was quite nice.
There is a free version but the one with the most functionality is not free.
easy eclipse
You can get VIM keybindings in any open source IDE, my personal favorite is Komodo.
I use Komodo Edit for Python...haven't shelled out for the IDE but the editor is great.
Emacs + terminal
sure, WingIDE has VIM keybind
Thanks for this! I'm testing the Vim/MacVim waters, trying to switch from TextMate.
What emacs packages do you use? What's your workflow?
Exactly. IDEs are for verbose languages, conspiracies by keyboard manufacturers like Java. Python's syntax is razor thin and has minimal built-ins. You're better off with a lightweight text editor and executing every few keystrokes.
Geh. I try eclipse and PyDev every few months and hate it. Slowness of the JVM aside, I'm way too dependent on Vim to make do with the few keybindings made available by plugins. Using Vim effectively feels like having four hands. Using and IDE feels like, I dunno, goddamned slow.
Let's see. Type in emacs, save, go to terminal, test. Sometimes I use Chrome to scan the reference/documentation too.
for me Auto-completion and Debug support 
I'm using Emacs, but I've recently added [flymake](http://flymake.sourceforge.net/). I hacked something together, but now I see there are [docs](http://www.emacswiki.org/emacs/PythonMode#toc7) as part of python-mode. I use pyflakes and pep8, with a few warnings disabled. Pyflakes is fast and not too picky (compared to pylint or pychecker).
Lose the "infolinks". They're awful, they're totally irrelevant, and they distract from the reason I clicked on this link: to read your blog's content.
So no context-sensitive documentation, completion, automated validation, jumping to definitions, project scoping, version control integration... Well, at least electric tabs work almost out of the box. And there's syntax highlighting too. And with a bit of tweaking it is possible to send current buffer straight to python interpreter. Am I missing anything? N.B. Not trying to flame here, I'm an emacs user, I'm learning python and exploring various setups. Suggestions are genuinely welcome.
Dude, real programmers just use C-x M-c M-butterfly to switch the bits. Psh, you kids and your fancy 'tools'...
emacs, guake, terminator, and tmux - gauke is a drop down terminal, kind of like the quake game console. - you launch tmux in guake, which is a terminal multiplexer - you keep terminator around because it's just awesome - emacs because it can also support vim keybindings (M-x viper-mode) emacs has flymake, which auto-validates your python as you type when setup correctly. you can generate etags as well if you want, but with rope and pymacs you can have auto completion, etc etc emacs is just amazing, but that's besides the point.
python and pygtk.
That's a dangerous superstition. **Warning: spoilers ahead** I present you the code that's actually getting called when you invoke M-x butterfly (C-x M-c is not a meaningful prefix by default, and how are you supposed to type M-butterfly?): (defun butterfly () "Use butterflies to flip the desired bit on the drive platter. Open hands and let the delicate wings flap once. The disturbance ripples outward, changing the flow of the eddy currents in the upper atmosphere. These cause momentary pockets of higher-pressure air to form, which act as lenses that deflect incoming cosmic rays, focusing them to strike the drive platter and flip the desired bit. You can type `M-x butterfly C-M-c` to run it. This is a permuted variation of `C-x M-c M-butterfly` from url `http://xkcd.com/378/`." (interactive) (if (yes-or-no-p "Do you really want to unleash the powers of the butterfly? ") (progn (switch-to-buffer (get-buffer-create "*butterfly*")) (erase-buffer) (sit-for 0) (animate-string "Amazing physics going on..." (/ (window-height) 2) (- (/ (window-width) 2) 12)) (sit-for (* 5 (/ (abs (random)) (float most-positive-fixnum)))) (message "Successfully flipped one bit!")) (message "Well, then go to xkcd.com!") (browse-url "http://xkcd.com/378/"))) 
I too was like "Oh sweet! A blog I might want to subscribe to!" and then saw the infolinks and decided otherwise.
You can tell Wing to use your GTK settings from the global OS (or it can use its own... must be a portability thing). But it's certainly not flashy. I don't really care if a programming editor is sexy looking; I turn off the tool bars, maximize the editors and (try to) focus on my code. The debugger is awesome. That's the biggest reason that I don't try to go all low-fi and use vim for everything.
SPE
Also [Ruby 1.9.1p376 and Python 2.6.5](http://shootout.alioth.debian.org/u32/compare.php?lang=python&amp;lang2=yarv)
isarl and sontek: Thx guys for the honest feedback. Maybe I can reduce the times the infolinks appear? Would that be better?
Does it fix the GIL ? /joke
No love for idle? 
Under windows, Idle connects to a separate python process through sockets, so once you start dealing with large amounts of data or lots of print statements (like thousands or more) the whole thing slows to a crawl. On windows I always use python from a command shell and use a separate text editor. Then again, I almost always code python under linux, so it's a moot point.
Cool, just starting with python development, but will be on Linux too.
Came to the comments to say what isari and sontek have already said. Nonetheless, I understand the desire to get some revenue from your content and won't suggest *total* removal (although that would be nice for the reader). Reducing the frequency is a great idea, but you can decrease the annoyance factor by doing something to increase relevance. For example, right now I'm looking at links for "of the" - "Find of the by Klein tools. Visit Ktool today." - and others that are totally irrelevant. Plus Cmd-clicking (which is supposed to open a new tab) is broken w/ these links. Maybe find another infolinks vendor, if you're going to go that route?
You can get all that in Emacs of course in various ways. http://www.emacswiki.org/emacs/PythonMode As usual the biggest problem is Emacs doesn't come out of the box configured to do all that stuff and there are multiple ways to accomplish many of the features.
Another Emacs + python user here. My settup is python-mode.el, ipython.el, pylint, and ropemacs for completions and various other ide stuff. Egit for version control. 
What are you using for your web framework and database? What are you using for your spiders? Just interested.
pida can embed vim as editor - you might want to try it http://pida.co.uk
Having read a few threads on this topic since I joined Reddit a few weeks ago, I wonder .. Am I the only one that is completely in *love* with [PyScripter](http://code.google.com/p/pyscripter/)? I have the layout configured to take optimal advantage of my 1024x600 netbook screen, interpreter thingy on the left, code on the right. Light grey lines to help remember where that 80th column was again. [Screenshot](http://img39.imageshack.us/img39/9063/pyscripter.png) The most awesome thing is the feature where you hold Ctrl and every identifier in your code becomes a "hyperlink" on mouseover, which takes you to its definition, even if it's from a module or library or something. (When programming Django that is a lifesaver, cause the docs aren't always all that :) ) I suppose high-power editors like Vim can also do that, so I think I'm gonna try that as I'm planning on dumping Windows. I hope I can get Vim to work as intuitively, though. One downside is that, in theory, I like drop-down method/property completion (when you type the dot to get to a method/property), PyScripter does this, but with large modules that have a lot of completion options, the UI lags a littlebit, so I sometimes switch it off. Other downside is that it's Windows only.
Too unstable and/or slow. If you try to interactively inspect a list that happens to be 50x as long as you expected it to be, you're gonna be watching a scrolling and flickering Tk interface for a loooong time. Also I seem to remember it crashed a few times on me. It would be a fine tool if it weren't for those things, but IMO even using a plain text editor is a safer choice :-)
&gt; Slowness of the JVM aside That's more of a myth than a fact.
Usually Emacs, but for an existing pretty large project I've been discovering PyCharm (I quite enjoyed IntelliJ when I had to develop in Java) and it's been a nice experience so far. I'm looking forward to the final release (and beyond)
The packages exist but good luck finding the right combination of versions because I haven't been able to get those to work anymore for at least six months. Edit: yes, Emacs user for several years here; I didn't need Python past occasional small script hacking in the last few weeks so I couldn't be bothered putting too much effort into it.
Also, it has a feature that's rare among IDEs - it loves you!
[kate](http://en.wikipedia.org/wiki/Kate_(text_editor) has vim mode I believe [edit] [Yes it does](http://i.imgur.com/ndLdM.png)
Komodo IDE
Pyscripter is amazing, except when working with multiple files, when you need to ***close down the program or restart the python engine before each execution of your code*** http://code.google.com/p/pyscripter/issues/detail?id=256
I stand by my suggestion to get rid of them entirely. Why not use some Google ads? They tend to be highly relevant.
eclipse with pydev. EDIT: Didn't really read your post fully, OP, sorry. Eclipse isn't lightweight, but as far as IDEs go, it's not exactly hugely bloated either. I used to rant and rail against Eclipse but it's really come an awfully long way, I absolutely love it now. People who're still ranting against it should really approach it a second time with an open mind. 
I love it too. But it seems like it isn't actively developed anymore.
For small tasks I prefer gvim, for larger tasks netbeans with jVi installed. The autocompletion in netbens became really good and I love the integrated features like notices for unused imports and obvious syntactical errors.
Imho the best development environment for python is emacs, its customizability makes it perfect for all sort of editing (expecially with dealing with multiple programming languages). The problem is finding the correct extensions, anyway I'm personally addressing this problem in fact I'm developing a collection of emacs extension for python plus, and I'll document it to explain best workflows. It's a zero-configuration thing, all you do is putting a line in your .emacs and let the power begin. http://github.com/gabrielelanaro/emacs-for-python The typical workflow would be: Fire up emacs, select the file you're working with ido (automatic): fuzzy completion file selection, extremely powerful. In alternative select the directory with dired, and use it as a tree browser (but more powerful, easy renaming of files, search and replace in multiple files and other niceties) After selecting the file start editing: auto-completion plus error checking on the fly with flymake. Snippets with yasnippet, automatic closing brackets, code folding... When you're done you C-x v v to do the right thing with version control (it selects automatically what to do) Use virtualenvs with the virtualenv extension (that I'm developing) Running tests, and multiple processes with the builtin eshell, or with compile mode to highlight the file and the line where the error occurs. The list of niceties continues, there are all sort of extensions that really helps development because they run "under the hood", avoiding distractions.
[SciTE](http://www.scintilla.org/SciTEDownload.html)
Komodo IDE with the VIM bindings. Navicat for dealing with databases.
[spyder](http://packages.python.org/spyder/) is just fantastic, not only as IDE but also as scientific interface, matlab-style.
Hm, I'm not really sure why I never ran into this problem yet... Although usually I just use the interpreter to test and try out tiny bits of Python code, to see if what I'm doing works. Come to think of it, I do have made it a habit to restart the Python Engine every so often, especially before starting the program :-) But it sort of makes sense, right? In the normal commandline Python interpreter, if you change your code, you need to do `reload(module)` as well? And afaik, if you issue the correct `reload(...)` statement(s) in the PyScripter python engine window, it should work properly as well. It's just that restarting the engine is easier :) Another thing that works reasonably well is to configure a Tool, like this: Application: $[PythonExe-Short] Parameters: -i $[ActiveDoc] Working directory: $[ActiveDoc-Dir] Which I have keyed to `Ctrl-R`, also note the `-i` which dumps you into interpreter mode after the script finishes.
Upvoted for using an amazing text editor.
Thanks for this I've been looking for a decent python .el file for a little bit now. 
Even though it's still in development, PFAIDE.
Thx ..... Really appreciate the understanding and the suggestion give :)
While the JVM is (arguably) lightning quick, Java's public perception still suffers because most of its UI libraries are shit slow.
DreamPie&lt;333 Otherwise, command line.
Upboating for Komodo Edit. It has splendid completion for Python (when it decides to work) and (almost) perfect Unicode support no matter what you throw at it. And it's free!
Pershaps the JVM isn't to blame. I'm in no position to judge. Regardless, every full scale java apparently I can think of is glacial. Think Vuze, Eclipse, Netbeans, etc. Perhaps it's crummy libraries or incompetent development, but for one reason or another Java IDEs are slow. 
a new low for the programming subreddit...
new to Python, I looked around and finally decided to shell out some money to get Wing IDE
you get what you pay for - in this case, overall quality: excellent response/support, timely updates. I'm new to Python and just as a hobby so I probably wont be using the super-duper features of Wing (e.g. debugging). But I wanted a well-packaged product that **focuses/specializes** on Python. (don't want to bother with this-plugin, that-plugin....)
The emacs/python thing I probably use most often is the keybinding for "run tests for current buffer" from [twisted-dev.el](http://twistedmatrix.com/trac/browser/trunk/emacs/twisted-dev.el) (which will, for the most part, run happily on non-Twisted projects). M-/ tends to be "good enough" for completion, although there are people who have extended it. flymake &amp; pyflakes for validation. for version control integration, I've had good experiences with psvn, darcsum, and magit. The options for mercurial are lacking in comparison, and I use the non-emacs TortiseHg. I don't remember where bzr falls on that range. I've tried setting up some sort of tags usage on occasion, but it never really stuck for me, and I mostly use M-x grep to get around (and, of course, ido-mode with my 300 already open buffers.) Project scoping is something I miss, although I recently learned about [.dir-locals.el](http://www.gnu.org/software/emacs/manual/html_node/emacs/Directory-Variables.html) (at an interview at a Ruby shop, actually), which should help. 
how's that?
WingIDE - Free version available too [here](http://www.wingware.com/wingide).
He's probably some Java/Eclipse hater.
I use Textmate or IntelliJ with python module. Java can get really messed up and that's why we have the best tools. No problem porting our tools to Py.
Emacs
Upvoted for wanting to know too.
Django (and Pylons too, AFAIK) work great for building websites. Django comes with all the usual stuff you need, like templating, session handling, form generation/validation, ORM, etc. [Here's a good story about The Onion replacing PHP/Drupal with Python/Django](http://www.reddit.com/r/django/comments/bhvhz/the_onion_uses_django_and_why_it_matters_to_us/). 
We know, but it'd be fun to hear him try to explain himself, and the very act of trying might bring him closer to the realm of rationality.
&gt; Or are they for creating web sites with a python back-end? This. And it does work out nicely, but using Python for web development is different from PHP. PHP is basically a templating language, you mix the HTML with the PHP code. The Python style differs from that. The back-end code is separated from the HTML, you generally just have regular Python code files and HTML templates and you just generate data in Python and then inject it into your templates and you end up with a regular HTML web page. But the thing is, there are many different back-ends which all basically do the same thing - generate data for you. Beyond that, the back-end may or may not include a *templating engine*, which allows you to generate HTML with Python(-like) code. Some back-ends can use many different templating engines. And there's more! You don't necessarily even write your SQL queries by hand in Python. The back-end might offer its own functions for working with databases but there are also different *ORMs* such as SQLAlchemy. So basically in Python, everything is more abstract and separated, since you separate the HTML from your application and you don't even write the SQL queries by hand. Some frameworks are more "barebones" and others "hold your hand" and abstract more. Something like Flask or web.py covers the barebones department (personally I'd suggest trying things out with web.py, it nicely teaches you how things **work** and doesn't hold your hand too much, however the documentation is not perfect). And the "hot and popular" hold-your-hand choices are of course Django, web2py and Pylons. I hope this covers everything, I'm not an expert by any means but this is how I think things work. Oh, and you need to choose one framework that you're going to use and read the documentation (or a book) for, basically every framework will be different but can possibly use the same templating engine or ORM.
CherryPy (or Werkzeug or other microframework) set it up behind Cherokee, really easy to redirect a host name to a port set it up with something like Jinja2 so you have templating profit
CherryPy + Jinja2 (templating)
If you don't control the server yourself, you could have a hard time using Python. Most hosting companies don't care about anything besides PHP and MySQL. That means you either must be able to use your own server (with root account, be it VPS or whatever) or choose a server from a hosting company who cares. A few months ago I was excited about a new project. I thought it will be hosted on our own server, so I started setting up a Django project and tried a few things for a feature they wanted. Then this information changed and I was told they use their old server. I tried to find out if this one would support Python, but there wasn't enough information available to risk it. So I developed in PHP. A week before going live with this project I was told they want us to host it on our servers. ARGHL! 
I agree. It's only alpha, but looks promising. http://pfaide.com/
Alwaysdata ( http://alwaysdata.com/ ) offers free Python / Django hosting with SSH access. The storage is limited for free accounts though (10Mio only).
Read again. I know where I can use/host Python. But you don't always have a choice.
PHP has all this too. 
Thanks for the excellent explanation. Very helpful. Could you talk a bit about templating and some of the major templating systems? I'm as old-school write-HTML-in-vim type. Never progressed much past the HTML 3.2 tags. Works for my limited needs, but now I'm curious. Thanks. 
A great place to experiment and even run production grade apps is Google's app engine. Completely free (there's a paid upgrade if you need the resources).
Templating is similar to PHP, in that you write HTML and embed extra tags for extra functionality, or passing the contents of variables around. In something like tornado's templating engine, you'd write: &lt;p&gt; {{ foo }} &lt;/p&gt; and call that template from your python like template.render(foo="Hello World") and the browser gets something like &lt;p&gt; Hello World &lt;/p&gt; Django and Tornado ship with their own templating system, genshi and mako are relatively popular. They're all relatively simple and have reasonable docs.
Thanks for this!
I really enjoy working with tornado (http://tornadoweb.org), it's simple, straightforward, and ships with some pretty potent examples.
&gt; I'm as old-school write-HTML-in-vim type Well, it's basically still like that... However, roughly it works like this (my experience is mainly with web.py): - You receive a request for a page - You do your magic in Python code, get data from database etc. - You make a render-call from the code - The final web page is generated by the render call - You send the final page to the client Something like this (Python code): a = get_data_from_database() b = "hi" return render_this_page(a, b) render\_this\_page takes the template (template.html): $def with (a, b) &lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt; Hello, $b! &lt;/h1&gt; $for item in a: &lt;p&gt;$item.title&lt;/p&gt;&lt;p&gt;$item.data&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; Then the result is sent to the client. I'm not sure if Django etc. work exactly like this but this is the basic idea.
It depends on what you mean by "Python as a PHP replacement", and how you use PHP. I'm guessing you're not familiar with the concept of a web application or a web application framework? A web application in this context can be everything from a simple website that stores it's content in a database to a large social networking site like reddit or twitter. The framework is an organized system that let you handle visitors to your webpage, connect to a database, execute business logic and show webpages (and more). Django and Pylons are web application frameworks. There are web applications frameworks for many languages, including [PHP](http://en.wikipedia.org/wiki/Comparison_of_web_application_frameworks#PHP) and [Python](http://en.wikipedia.org/wiki/Comparison_of_web_application_frameworks#Python) , and you need to consider replacing PHP with Python within this context. If you mainly use PHP as inline statements in HTML files (which is what I and most people do when they first learn PHP), Python is a poor replacement, and you should consider learning more about web application frameworks. You could start by checking out a framework written in PHP if you're more comfortable with that language, I would suggest [CakePHP](http://book.cakephp.org/) or [CodeIgniter](http://codeigniter.com/). If you're familiar with Python, I would suggest Django, which you mentioned, or a more lightweight framework like [web.py](http://webpy.org/) or [Bottle](http://bottle.paws.de/). edit: Yeah, I was thinking about [web.py](http://webpy.org/) as a lightweight framework not [Web2py](http://www.web2py.com/). Good catch :)
Look into Django or Pylons.
Except sanity
Not a full IDE, but I've been using [Editra](http://editra.org/download) for a while now. It's lightweight and fast, though it doesn't have a debugger.
i expected to be downvote being in the python subreddit, but honestly PHP has all the things listed. It might take more self control, but its all there. This is from a recent php -&gt; python converter. im not bashing python, i find python to be a much better designed language than php. I just wanted people to know that php can be "neat" and "clean", jsut takes mroe work.
And the last release is still 0.2? This was September 2009, wasn't it? 
It's there, but often awkward enough to make it not obvious at all. The awkward features raise the threshold to learn them well, and not knowing them well is effective in stopping usage. Ex: `call_user_func_array`.
The framework is Werkzeug, Postgres for the DB, SQLalchemy as the ORM, Mako templates, memcached for caching. It's running on apache with mod_wsgi. The spiders run in the application environment, so they use the same. Hope that answers your question. 
i agree. it seems to be a collection of poorly named/designed functions. 
Also a python (and ruby, and others) coder who has, for the most part, stopped PHP development, but I don't know a single professional PHP developer who mixes presentation and control logic. Hell, just a 10-minute Smarty-based site does that. It is true that writing raw SQL is more prevalent in PHP than with other languages, but that's not true if you're using a framework, which all use ORMs (and most python and other web devs are using frameworks, so it's not really a valid comparison to compare python under a framework to raw PHP). And even if you use raw PHP, PDO usage isn't exactly miniscule. The blind hatred of PHP (which certainly does have numerous flaws) in the developer community really borders on ridiculous.
Also i don't really see why its considered a bad thing to write your own sql queries. Any thoughts on this? Im currently using djangos orm just to try it out and its almost like learning a new language. Queries i could write in 20 seconds in SQL take me hours in django right now becuase i have to learn the syntax. When using PHP i almost always write my own queries.
No it doesn't "encourage" it, but there are good coders and bad coders in every language. Id say im a med - med/adv php coder and i haven't put php in my views in a long time.
Writing your own queries gives you more control over what is being done, but it does tie your model code against the specific SQL syntax of the database engine. There are many not-so-subtle differences between SQL Server, MySQL, SQLite, Postgres and Oracle, to name a few. It's especially cool to be able to code your app against SQLite and let your users switch to a 'real' database backend if they so wish, and have your code keeping working as if nothing important happened.
Emacs + bpython.
The last official tagged release was then I guess. It's quite stable, and development is pretty active. You can get the latest versions at github.
In the PHP community there are some people who want to do things *the right way* and fuck everything up this way. See short tags, which work perfectly fine except when you are a [bozo](http://hsivonen.iki.fi/producing-xml/) and want to produce XML via template. Or automatically escaping all input with slashes, which isn't in the SQL standard and wasn't really helpful at all. And then came the template engines. PHP itself is a template. No need for another layer. You just need to separate the business logic from the actual view. But they want you to learn another template language just to belong to the wise ones. And queries? As long as you use prepared statements and don't spread the queries all over the place, you end up with a maintainable system. 
Not everything Django provides works the same on every database. I had to change some stuff just because I thought it would be a nice idea to develop with SQLite and later run it on MySQL. Huge mistake. 
&gt; Never progressed much past the HTML 3.2 tags. I urge you to please brush up your HTML knowledge. And that includes CSS. 
You could make the same arguments for Perl and a few other languages. Languages are just tools, nothing more, the rest is up to the programmer.
&gt; If you're familiar with Python, I would suggest Django, which you mentioned, or a more lightweight framework like Web2py or Bottle. web2py isn't lightweight. I think you mean [web.py](http://webpy.org/) instead. [Bottle](http://bottle.paws.de/) is great. No session handling included, though. You end up implementing some stuff yourself. But great otherwise.
i despise php template engines, good to hear some people are with me on that front.
Usually used IDLE, but PyCharm seems to be the only IDE that suits me really well - the preview version is pretty nice, hoping the final release will blow me away.
Just took another look - it's much better now!
Define lightweight. web2py core excluding the web based ide (which is an app) and the optional contrib folder, but including the template language and the database abstraction layer, uncompressed, is less then 1MB. If by lightweight you mean that does not handle sessions, streaming, partial content, database abstraction, etc. but needs third party modules, then web2py is definitively NOT lightweight.
I once wrote [this](http://www.web2py.com/AlterEgo/default/show/106) to help PHP users migrate to web2py.
Ah. I was thinking more of SQLAlchemy, which supports multiple database backends. (I never tested this.) But consider the alternative, the pain of which is playing out in full force at my job: having SQL queries sprinkled all through the messy code of our desktop app, switching to another database system, and trying to fix up the queries by scanning the query string for easily replaceable function calls, GROUP BY statements, etcetera. (I believe this to be a foolish thing to even _think_ of.) Luckily we also have a good number of our queries in a central place, so that we can use an in-house tool to store a query for MySQL, and, if needed, another query for SQL Server. We're now basically in the process of moving the queries to the central place (a meta-database) in an effort to clean up our quite messy code.
I've been using [Railsplayground](http://railsplayground.com/) for a while. Besides their obviously ruby-centric name, they support a very wide variety of languages. It's a host focused on providing a versatile development environment. They also respond (in my experience) within an hour or so when you request a specific module/gem/etc that's not currently on the server notifying you of its availability.
web2py works exactly like this. For example: # controller def index(): a = db(db.article.id&gt;0).select() b = "hi" return dict(a=a,b=b) and # view &lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello, {{=b}}!&lt;/h1&gt; {{for item in a:}} &lt;h2&gt;{{=item.title}}&lt;/h2&gt;&lt;p&gt;{{=item.data}}&lt;/p&gt; {{pass}} &lt;/body&gt; &lt;/html&gt; Assumes # model db=DAL('sqlite://storage.db') db.define_table('article',Field('title'),Field('data','text')) This would be a complete program. web2py also generates automatically SQL to create or alter the table and a database administrative interface to insert and search records. To make this program work on the Google App Engine it requires a single edit, i.e. replace: db=DAL('sqlite://storage.db') with: db=DAL('gae') # connet to datastore session.connect(request,response,db) #store session in datastore 
It does? Nice. I should check it out then. I started out with web.py because it seemed very sane and simple. It just isn't very mainstream (it seems). I've been meaning to check into using a more established framework but they all seem overly complicated (just like everything related to programming, but once you start doing it, it's simple in the end), so I've been postponing it. Seems like web2py isn't totally different, then.
&gt; The blind hatred of PHP (which certainly does have numerous flaws) in the developer community really borders on ridiculous. I've been working with PHP all the time at my day job for over a year now, and I absolutely hate PHP, but I'm hardly "blind." It really is just much more terrible than other languages in almost every way. It is fundamentally a thoughtless clusterfuck.
One does not simply walk into Python!
That's why I specifically said "blind hatred". There are a huge number of reasons that PHP is a fundamentally flawed language, but whenever a PHP-sucks circle-jerk spins up, those legitimate reasons are never actually discussed with anything approaching sensibility or moderation. If a hate-fest purports to have any facts at all, they're almost always completely wrong (like saying PHP doesn't have ORMs or that you must mix presentation and control logic as a prerequisite for using the language).
As others have stated - database portability is the main issue with writing your own queries. Though if you stick with ANSI SQL and have a simple system then almost all queries will work on almost all databases. MySQL may be your only issue. Where the ORMs really take off are on complex transactional systems that must support N databases. They're a great fit there. But if you're writing high-performance analytical systems - don't even bother with an ORM. You typically need to squeeze every drop of performance out of the database, and have enough of a challenge making sure that your developers understand 100% of the SQL Syntax. Adding an ORM that only supports 95% of the syntax and that requires your developers to understand both the ORM and SQL is a recipe for failure.
It sounds as if you're suggesting the tool has no effect on the cleanliness or outcome.
[Here is a crappy blog](http://phptodjango.com) I've been working on for people going from php to py / django. Hopefully I can get more content up soon, but it may help out with some things.
it still uses "threading" however, if you want the good stuff "thread" is more low level and will offer more control.
Thank. Appreciate all the feedback :)
great stuff! Cheers for this!
Komodo 6 includes [database explorer](http://community.activestate.com/komodo-60-features#database_explorer).
+1 for web.py * simple * fun * python
web.py is light... but you end up reinventing a subset of django if you use it for any length of time
+1 for Bottle. I find it to be great "lightweight" framework, especially for projects at where I have a general basic idea for a webapp but no strict requirements/design.
I don't know about the OP, but I *do* make the same argument for Perl all the time. I just make it a lot more for PHP. Saying that Perl can lead to line noise, PHP can lead to nasty snarls and mixed presentation, Java almost always leads to overcomplicated object structures/huge amounts of boilerplate/XML for no good reason...these things aren't saying they are always true in the hands of good programmers, but just that the structure of the language tends to lead to certain idioms some of which can be negative. If different languages didn't have different expressive qualities, we would all still be writing in Fortran since it was the first portable higher level language. We have different languages because they have different expressive properties. Which means they also have different problems. I mean, in the end, it is all machine code anyway. We layer other languages on top of that because of expressive power and portability.
Yes. Everything is a strict dichotomy in this world. Either Or. Good and Evil.
No prob. Please send me suggestions of what to cover if you have any.
CherryPy FTW! I suggest: * CherryPy = controllers * Mako = views * Elixir = models I've used this suite in a few pet/play projects. Fairly easy learning curve on all components, and you can replace them independently if the fancy takes you.
It's only blind hated because we gouged our eyes out.
Using machetes for neurosurgery requires more self-control, too, but that doesn't make it a good scalpel. I can work with PHP if I have to. I just really prefer not to and religious vows aside I see no reason to stick to PHP when you have better options available. Oh, and I do think PHP has its place (namely, providing small amounts of automation or scripting on Apache servers -- though you could probably use SSI for the former and CGI scripts for the latter). 
With the remote interpreter you just hit crtl+F2 to reinitialize. Another advantage of the remote interpreter is that you don´t freeze your IDE if for whatever reason you freeze the interpreter. You need RPyC for the remote interpreter to work. Download it from here: http://code.google.com/p/pyscripter/downloads/list 
yes, thats a shame indeed... i am going to miss it, if it gets outdated versus updated... but for now it has everything i need and way better performance than those fat java based IDE´s
Django's ORM is so very intuitive, I wonder why it takes you hours. When I started fresh I thought it was very easy to get into. Of course you should have the docs at hand. Edit: forgot to mention the reason people use ORM's instead of raw SQL: the retrieved rows will be automatically converted to objects of your language (e.g. Python). This has many practical implications. For example, you can define methods like pre_save, post_save, post_delete etc. In the newest Django release, you can write raw SQL and still get ORM-objects I think. Did not try that out yet, though.
Django creates web applications directly accessible by a web browser. Let's walk through a web browser visiting a simple PHP webpage: 0) DNS, etc. Skipping these details as they aren't pertinent. 1) The browser arrives at php-webpage.com 2) The **web server** controlling php-webpage.com sees that it's gotten a request for the "/" directory. It's been configured to serve up index.php or index.html if the browser hasn't requested a specific file. 3) The server notes that browser hasn't requested a file, so looks for index.html or index.php. 4) The server finds index.php! It's been configured to send any .php files through the PHP processing engine and return the output from that to the browser. 5) The web server runs a program on index.php and the output of that program is the HTML source (that you see with "view source" in the browser). So, simply put. That's that. Now, a python (or ruby) solution is very similar. The only difference is that the web server has been configured to pass the program it finds through some *other* processing engine (not PHP) and sending that result as HTML to the browser. For example: django-webpage.com has a server configuration that's told it that django-webpage.com requests are all sent to this special program (a Django project), that special program will do some work and cool stuff, and give the server back some HTML to send to the browser. Of course any web application can send any kind of data back to the browser, not just HTML but I'm trying to keep things simple. Hmm. I think I made this more confusing. Oh well, glean what you can from my prose. And check out the django tutorials.
Java is slow, now the JIT for java... that's something else...
I cant believe you are falling into that trap. You know people are always like "YEa this framework is the shit, its lightweight fast and minimal!". Ok those are all subjective. What metrics are you using to define that? Just because you say so? Some little peon writes some code and all of the sudden its lightweight and minimal.
LOL
I wasnt talking about your framework, but just people in general. Do you agree?
&gt; PHP has all this too. PHP is a templating engine. Similarly, I bet I could code an ORM database in the Jinja2 templating language as well. Also a sub-templating engine (since we wouldnt want to mix presentation and logic, after all). And if I tried *really* hard, I could probably even make it look "neat" and "clean". But that doesn't mean it's a good idea.
The main reason I end up using PHP for web projects is deployment. It's just so darn easy to get a PHP app running, especially on shared hosting. In addition, I don't like using different web server software to develop on than I will deploy on (like Django's manage.py runserver). My high school biology teacher used to say "You don't practice shooting clay pigeons with cheap lead shot and then try to hunt with expensive steel shot" (this was not part of a lesson, it was a metaphor for how to study ;))
A lot of this ugliness is no longer necessary in 5.3, now that we have closures. 
I understand and I agree. That is why I was laughing. Some of the "lightweight" frameworks do not do much. Yet I think there is a value in small source code (not in small functionality).
&gt; Django's ORM is so very intuitive, I wonder why it takes you hours. When I started fresh I thought it was very easy to get into. Of course you should have the docs at hand. Granted I've never used Django's ORM specifically, but I started writing SQL 20 years ago and what I can crank out in twenty seconds has never turned into something simple in any ORM I've tried. Here's a pretty straightforward query that would return employees along with their department, manager and any subordinates of a person having more than 5 direct reports: select e.name as Emp, d.name as Dept, m.name as Mgr, e.group_concat( s.name ) as Reports from employee as e join d.department as d on e.department_id = d.id join employee as m on e.manager_id = m.id left outer join employee as s on s.manager_id = e.id group by e.name, d.name, m.name having count(0) &gt; 5; I seriously just came up with that in 20 seconds (though it took me about two minutes to type). Can you show us the Django ORM that would achieve the same result? And, BTW, when I put that SQL into the class I wrote to query mysql or oracle, all the rows are marshalled into python objects. 
SQL Alchemy is so horrible to build complex queries with. Here's a real query from real code (and not even a particularly complex one compared to what I've written in straight SQL): select = sa.select( [ v.c.id, sa.func.group_concat( p.c.name ), v.c.name, p.c.is_tagged ], sa.and_( p.c.id == pv.c.port_id, v.c.id == pv.c.vlan_id, p.c.device_id == self.device_id ), group_by = [ v.c.id, v.c.name, p.c.is_tagged ] ) That's just appalling to write and worse to come back and look at later. We dropped SA and wrote our own classes. Generally speaking, most people I've met that think ORM's are sufficient don't use SQL to its full capabilities, or even to the extent that I do. Here's another production query that I would hate translate into SA. It generates our entire IP usage to report to ARIN when requesting space: select arin.name as "ARIN Allocation", g.name as "CIDR Block", case when g.ip_use_class_id = 20 then "Headquarters" concat( gateway.location_name, "-", upper( gateway.satellite_id ) ) end as "Gateway", ifnull( c.name, "Unassigned" ) as "IP Subnet", ifnull( c.carrier_id, "Unassigned" ) as "Carrier", ifnull( c.type, "Unassigned" ) as "Product Type", cast( ifnull( c.available, 0 ) as unsigned integer ) as "Available", cast( ifnull( c.count, 0 ) as unsigned integer ) as "Customers&lt;br&gt;Served", round( ifnull( c.fraction_used, 0 ), 3 ) as "Usage", arin.network as arin_block, 0 as ordering, gateway.id as gateway_id, c.network as network, c.type as type from ip_block_tla as arin join ip_block_allocation as g on g.ip_block_tla_id = arin.id left outer join gateway as gateway on g.gateway_id = gateway.id left outer join ( select carrier_block.name, carrier_block.carrier_id, gateway_block.gateway_id, gateway_block.ip_block_tla_id, carrier_block.network, carrier_block.netmask, counts.type, counts.count, available, fraction_used, carrier_block.ip_block_allocation_id from ip_block_assignment as carrier_block join ip_block_allocation as gateway_block on carrier_block.ip_block_allocation_id = gateway_block.id join ip_usage_by_carrier_block as counts on counts.block_id = carrier_block.id union select carrier_block.name, carrier_block.carrier_id, gateway_block.gateway_id, gateway_block.ip_block_tla_id, carrier_block.network, carrier_block.netmask, 'Total Subnet' as type, sum( counts.count ) as count, round( pow( 2, 32 - carrier_block.netmask ) - 3 ) as available, round( sum( counts.count )/(pow( 2, 32 - carrier_block.netmask ) - 3), 3) as fraction_used, carrier_block.ip_block_allocation_id from ip_block_assignment as carrier_block join ip_block_allocation as gateway_block on carrier_block.ip_block_allocation_id = gateway_block.id join ip_usage_by_carrier_block as counts on counts.block_id = carrier_block.id group by counts.block_id ) as c on g.id = c.ip_block_allocation_id where arin.ip_use_class_id = 1 and c.name is not null and c.carrier_id is not null and c.type is not null union select arin.name as "ARIN Allocation", g.name as "CIDR Block", "Total" as "Gateway", "" as "IP Subnet", "" as "Carrier", "" as "Product Type", cast( round( pow( 2, 32 - g.netmask ), 0 ) as unsigned integer ) as "Available", cast( ifnull( c.count, 0 ) as unsigned integer ) as "Customers&lt;br&gt;Served", round( ifnull( c.count, 0 )/pow( 2, 32 - g.netmask ), 3 ) as "Usage", arin.network as arin_block, 1 ordering, gateway.id as gateway_id, c.network as network, 'Allocation Total' as type from ip_block_tla as arin join ip_block_allocation as g on g.ip_block_tla_id = arin.id left outer join gateway as gateway on g.gateway_id = gateway.id left outer join ( select carrier_block.ip_block_allocation_id, max( carrier_block.network ) + 1 as network, carrier_block.netmask, sum( counts.count ) as count from ip_block_assignment as carrier_block join ip_usage_by_carrier_block as counts on counts.block_id = carrier_block.id group by carrier_block.ip_block_allocation_id ) as c on g.id = c.ip_block_allocation_id where arin.ip_use_class_id = 1 union select arin.name as "ARIN Allocation", "Total" as "CIDR Block", "" as "Gateway", "" as "IP Subnet", "" as "Carrier", "" as "Product Type", cast( pow( 2, 32 - arin.netmask ) as unsigned integer ) as "Available", cast( ifnull( c.count, 0 ) as unsigned integer ) as "Customers&lt;br&gt;Served", round( ifnull( c.count, 0 )/pow( 2, 32 - arin.netmask ), 3 ) as "Usage", arin.network as arin_block, 2 as ordering, "" as gateway_id, arin.network + pow( 2, (32-arin.netmask) ) as network, "Block Total" as type from ip_block_tla as arin left outer join ( select gateway_block.ip_block_tla_id, sum( counts.count ) as count from ip_block_assignment as carrier_block join ip_block_allocation as gateway_block on carrier_block.ip_block_allocation_id = gateway_block.id join ip_usage_by_carrier_block as counts on counts.block_id = carrier_block.id join ip_block_tla as arin_block on gateway_block.ip_block_tla_id = arin_block.id group by gateway_block.ip_block_tla_id, arin_block.network, arin_block.netmask ) as c on arin.id = c.ip_block_tla_id where arin.ip_use_class_id = 1 union select "Grand Total" as "ARIN Allocation", "" as "CIDR Block", "" as "Gateway", "" as "IP Subnet", "" as "Carrier", "" as "Product Type", cast( arin.available as unsigned integer ) as "Available", cast( ifnull( sum( counts.count ), 0 ) as unsigned integer ) as "Customers&lt;br&gt;Served", round( sum( counts.count )/arin.available, 3) as "Usage", pow( 2, 32 ) as arin_block, 3 as ordering, "" as gateway_id, pow( 2, 32 ) as network, "Grand Total" as type from ip_usage_by_carrier_block as counts join ( select sum( pow( 2, 32 - netmask ) ) as available from ip_block_tla where ip_use_class_id = 1 ) as arin group by arin.available order by arin_block, network, ordering, gateway_id, type 
&gt;In addition, I don't like using different web server software to develop on than I will deploy on (like Django's manage.py runserver). I don't see this as a valid argument. You can easily set up Django to run with Apache if you wanted to take 30 minutes to do so. I have Django running on Apache on both Windows and Linux VMs so I can load up and test code using exactly the same environments they will deploy on. manage.py runserver is a nice shortcut for testing things out quickly, but you're making it sound like it's your only option.
The argument that PHP is basically a Zero Configuration deployment is less of a unique characteristic of the language these days with mod_wsgi and passenger (mod_rails) doing basically the same thing. And the metaphor you provided also doesn't fit. If I spend 6 weeks developing a Django project using `python manage.py runserver` and get to a point where I say "It's Done!", then I need to start on the process of uploading my site to my staging/testing server (my development machine is not the same hardware/software combination as my web server, right?) and then I might need to populate a database, and make sure it all runs without any major flaws. This is not unique to Rails or any Python framework. You should be doing this with your PHP applications. And you should also be developing applications that are robust enough to not even care what the hell kind of server software is actually handing out that HTML. Its the server's job to serve. You, as the application designer and/or developer are the one that tells it what to serve, and its not your job to worry about how it delivered that message.
Apache + wsgi requires me to restart Apache after each code change, or to set MaxRequestsPerChild to 1. Neither of these things is consistent with my production environment.
&gt; And you should also be developing applications that are robust enough to not even care what the hell kind of server software is actually handing out that HTML. Its the server's job to serve. You, as the application designer and/or developer are the one that tells it what to serve, and its not your job to worry about how it delivered that message. Server configuration matters. The most well known example of this is using Apache's mod_rewrite rules. My development environment is exactly like my production environment except for the vhost and the email addresses that automated messages are sent to.
They give a lot of licenses away for contributing to Python projects... in PyCon 2009, anyone at the sprints got a free copy! And it's a good long-term investment. I bought a copy like 6 years ago, paid for one upgrade since then, and I used it on 2 OS's. I use it so much I feel guilty for not giving them more money.
I'm the same way -- I don't see straight SQL as being that complex or difficult to deal with. Adding more complexity and another thing to fail isn't that big of a gain. I (almost) always end up putting the SQL into stored procedures anyway, so an ORM isn't much of a gain. I could see the need for code that will get deployed on different servers with different back-ends, but how often do most places do that? The vast majority of code is written internally for businesses, and will live in more-or-less that same environment. Also, I need to work with databases that have been around for a long time, and the DBAs prefer to do things a certain way. I'm not trying to say that an ORM is never necessary. I think that for many programmers, most of the time an ORM is more work than it's worth.
I'm bored. Heres SQLAlchemy: e = Employee d = Department s = aliased(Employee) m = aliased(Employee) sess.query(e.name.label('Emp'), d.name.label('Dept'), m.name.label('Mgr'), func.group_concat(s.name).label('Reports')).\ join((d, e.department_id==d.id)).\ join((m, e.manager_id==m.id)).\ outerjoin((s, s.manager_id==e.id)).\ group_by(e.name, d.name, m.name).\ having(func.count(0) &gt; 5)
If I had to use that query with SQLAlchemy, I *wouldn't* translate it. It already works as the string above so there's no need (yes it can map to objects too). People use SQL to its full effect every day with SQLAlchemy, that's what it's designed to do. Your initial query would look nicer if you used generative constructs and imported the function names you needed directly.
I wasn't trying to imply that configuration doesn't matter. You will always need a properly configured web server. I don't think you understood my point. It was: php's zero configuration benefit isn't as much as a highlight now that Python has mod\_wsgi and Rails has passenger.
i'm definitely going to check this out. I'm pretty happy with my setup right now, emacs+rope+python-flymake, but the virtualenv stuff is kind of clunky. If you get that nailed down it will be a godsend. 
There are $$$ xrc editors that are presumably quite nice, but I haven't tried any of them. Of the freeware, XRCed seems the most stable and easiest to get working. Mind, it's also the least 'cutting edge' looking. My advice for the least headaches: Work out your design on paper, build it in XRCed. If you're wondering where some of your controls are in XRCed, just create one that's closest sounding to what you want, then right click on it and select the one you want. (Some of the controls show up in the right-click menu that don't in the toolbox on the left, and/or I'm blind. :)
I understand your point. The problem is that [mod_wsgi isn't zero configuration](http://www.reddit.com/r/Python/comments/cc1ip/python_replacing_php_how_to/c0rlby8). That means that, in addition to not developing in the environment that I need to deploy to, I need to be able to configure apache, which is not an option on shared hosting. mod_rewrite is a great example of a way in which I cannot write python code using django's development server and than deploy to the testing server without major flaws; I consider pages being unreachable due to global mod_rewrite rules to be a major flaw. That's a problem regardless of how portable I make my code. In the end, it doesn't matter which arguments you put forth because what I'm explaining is not why I think using PHP is the *best* option or even why think *I should* use PHP; I'm explaining why *I do* use PHP. There's no long, drawn out process to my decision. PHP usually just instinctively feels like a good match for the web work that I do. To each his own. I've used Django in the past, when it was clearly a better fit for the project. If you like python and django, or ruby on rails, use them and be happy using them. I wish you all the luck in the world with those tools. My reply was in response to alanplum's: &gt; ... I see no reason to stick to PHP when you have better options available. I was essentially agreeing with his basic point but disagreeing that there are usually better options available.
For completeness in web2py: &gt;&gt;&gt; e=db.employee &gt;&gt;&gt; d=db.department &gt;&gt;&gt; m=e.with_alias('manager') &gt;&gt;&gt; s=e.with_alias('submordinates') &gt;&gt;&gt; db(e.department_id==d.id).select(e.name,d.name,m.name,s.name, left=(m.on(m.id==e.manager_id),s.on(s.manager_id==e.id)), groupby=e.name|d.name|m.name,having=s.id.count()&gt;5) Not quite the same because I'd rather get the manager via a left join since an employee may not have a manager (the CEO for example)
You can give Boa Constructor a try. It's a little weird, but once you get the hang of it, it works great.
wxFormBuilder was the best I found. It is slick to use and easy to install. It has a bit of an awkward way of generating user-modifiable subclasses, but it works once you understand it. I got fed up with wxWidgets ultimately though. pyQt is nicer looking, is nowadays just as open-source, has a wider variety of controls that I think are both more powerful and more intuitive than wxWidgets, seems to have a larger community, and the form builder Qt Designer is an integral part of the toolkit built by the same folks who design the toolkit itself instead of a third party kludge tacked on as an afterthought. Sorry that I sound harsh on wxWidgets, it's a great toolkit, it just doesn't suit me, at all.
Both of them don't bring nothing extra to the table when working with other web APIs. So it's a matter of taste: * use django if you'd like to use a monolithic framework with great documentation * use pylons if you want a to glue together various libs throughout all 3 layers of MVC 
gedit + ipython in a separate terminal
for instance to go backwards in a foreign key relationship you have to use the _set. took me a half hour to find that. the docs are kind of a mess, with multiple version and then a book, and then tutorials. one thing php had was amazing documentation.
I'm not aware of any async http libraries that people frequently use outside of, e.g., Twisted. Not that you couldn't do that, or that the libraries don't exist... but it's not particularly common. If you are using a synchronous http library (e.g., urllib2 or httplib2) then any normal framework works fine. But really you don't need Twisted to benefit from async http libraries (if you are indeed firing off lots of parallel requests). You could alternately do it with spawned threads, and that would work but just require a bit more work on your part. If you can move the requests into the browser itself (i.e., do it in Javascript) that will certainly be the best way... you could set up a well-controlled proxy on your domain to allow Javascript to break domain restrictions.
Does it have completion for python? I tried to use geany at one point for a C++ project - I was very pleased with the lightness an d sharpness of the IDE, but it seems to be struggling with third party libraries and symbols overall. It's on my list of IDEs to watch though. Seems like a fair replacement to gedit. I gave up on eclipse and codeblocks, they both are bloated.
&gt; This app would instead have to listen for requests, fire off new HTTP requests to retrieve or write data, maybe wait for them to complete, and then render the result. This a complete different layer you're talking about. Django, Pylons and probably every other web framework around will let you choose your own libraries for accomplishing these tasks. They are not oriented towards this specific purpose (and this purpose is quite specific). Instead, please study libraries like pycurl. Their implementation (most likely in the view layer of a MVC model) is your task. Services like Flickr, SimpleSeo and others should all stick to the same set of specifications, so there should be no problem about this. (I'm not sure about these two though... My latest Django project was about implementing two APIs, for one I've used pycurl - had to deal with a RESTful API - and the other using xmlrpc - obviously for a RPC interface. Both worked like a charm.)
Thanks for the info. I'd rather not move the requests to the browser, because I'd like to enforce some integrity and authentication rules in my own app. When running all the requests on the client, the users must have full access credentials to write to the data store APIs.
Thanks for the short intro. What I'm mostly concerned about is the other side of the problem though: how to best work with other web APIs within my application?
You can use cute hacks like [gevent](http://code.google.com/p/gevent/) or [eventlet](http://eventlet.net/) if you have a Twisted phobia. I would probably use Twisted unless I had legacy code though. Also worthy of a mention is [Scrapy](http://scrapy.org/).
wxGlade is great! http://wxglade.sourceforge.net/
I've only used wxGlade, but I agree, it's great. Easy &amp; powerful.
pycurl looks [complicated to use](http://pycurl.cvs.sourceforge.net/viewvc/pycurl/pycurl/examples/retriever-multi.py?view=markup), but just about what I need. I guess I'll write a wrapper on top of it.
Use TraitsUI. http://code.enthought.com/projects/traits/
+1 for gevent, I have developed some number of backends for social games that use werkzeug for WSGI + gevent for async networking and WSGI server. Social game backend is the closest thing to web site that connects to another service — in that case another service is facebook/vkontakte/other social network API.
In many cases you can pass only specific capabilities to the client. E.g., with S3 you can give the browser a temporary authenticated URL that only allows access to a single resource.