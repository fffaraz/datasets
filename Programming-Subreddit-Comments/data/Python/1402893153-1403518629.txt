http://www.reddit.com/r/Python/comments/27h10t/hey_rpython_im_teaching_a_course_on_udemy_about/ /u/Deusdies has a very good course on Udemy free to redditors on how to write a GUI in Pyside (almost exactly same as PyQT but with an LGPL license and he claims better documentation) if that interests you. And the course is for people who already know Python or programming enough to pick it up so no babying in it. The last 2 vids in the course are him using Pyinstaller to make an executable for Windows that doesn't require QT or Python installed on the users computer to run. Then he goes through how to use Inno Setup to make an installer for your Python program. Granted this is for Windows distribution but it helped me see distribution as a user friendly program is possible. I'm sure similar distribution must be possible on Mac OS X. 
Looks good =) I'll have a wee work through when I get the chance. Ta much.
Qt is a good way to go for the UI, though depending on what kind of UI you're interested in, [Kivy](http://kivy.org/) might be an interesting alternative. For packaging up applications on a Mac, look at [cx_Freeze](http://cx-freeze.sourceforge.net/) or [py2app](http://pythonhosted.org/py2app/). I think there's a lack of good resources for building desktop applications in Python. The course you mention sounds good, but something a bit easier to drop into would be useful. I might try to write a blog post about this.
I guess so. The only reasons are that I don't want to feel handicapped when my customizations are missing and that other people might not be used to them. I had a job where this was somewhat important and after that I pretty much followed this path.
This is a useful point to make - making desktop apps in Python is definitely possible, and even fun, but you don't get your hand held like you would writing a .NET app on Windows, or a Cocoa app on OS X. Python apps are a properly native option on Linux, but it doesn't come with the same support structure as Microsoft or Apple's ecosystems. The flip side is that each native toolkit only supports one platform. Once you've made a Python application on one platform, it's fairly easy to make it work on the others - although packaging and distribution might still be tricky. E.g. I made a fairly simple GUI for a tool for scientists ([link](http://taxonome.bitbucket.org/)), and even though I was working on Linux, I could distribute Windows and Mac versions - though I had to borrow a Mac to build the package for that.
Iâ€™ve had the best results installing WSGI on my Macbook and running my app in the browser with SQLite as a simple database. You can either do this with Server.app or skip it and use the built-in Apache, which is so much simpler. There are numerous frameworks for web interface, input forms, data retrieval and output formatting. Xcode works well with Python.
I hate that "feature" of syntastic.
Dude. Yours is super-similar to [mine](https://github.com/kalgynirae/dotfiles/blob/master/vimrc)! I too use only that "plugin".
https://raw.githubusercontent.com/jamesonjlee/dotfiles/master/vimrc Vundle is the new hotness, no more git submodules!
Here's mine: https://github.com/mvasilkov/dotfiles/blob/master/vimrc
 brew install python3 There, you're done. Not even a slightest pain, it isn't.
How does this relate to virtualenv?
Thank you! 
Thanks to your feedback. I'll fix it asap.
I'm not going to write everything I use because people in this thread have done great listings, but I HIGHLY recommend jedi-vim and flake8. I use pathogen for plugins, and they are listed here if interested: https://github.com/nichochar/vim-bundles Furthermore, I used this great article to make my VIM nicer for python but also everything else: http://mirnazim.org/writings/vim-plugins-i-use/
I can't believe no one mentioned https://github.com/klen/python-mode, which is an actively maintained collection of vim-scripts for python, glued up and easy to install.
as i am currently interested in Flask, it's great to have some inspiration from the post
Re as in "resurface", Jex as it sounds. But then I also pronounce SQL "squll" so don't quote me on pronunciations... :P
forums are pretty old now - they still have their place, but different formats have taken precedence completely (twitter/reddit/facebook/blogs/etc). At my old company, the chairman was diehard passionate about forums, took years to persuade him to drop them from existence - but finally achieved! So I'd say that is perhaps the main reason why no one has made an awesome django (or similar) forums application. It would be a very big project to make it generic enough for everyones' needs as well (like django-cms).
Because you have a lot of them already done in PHP. People satisfied with a forum will use them since they are good and battle tested with active communities and plugins, and because having a preferred language doesn't mean you have to have all your stuff coded with this languages. Not need to reinvent the wheel, espacially if the wheel rolls very well. People that are dissatisfied with the current forums, or with the concept of forums in general never found an agreement on what would satisfy them, in Python or any other languages. Some say SO like websites are the answer, some prefer live chats... 
The most important reason is that any game which needs 4 cores on a PC isn't going to run acceptably on a games console or older PCs. Backwards compatibility is key to sales. Having said that, some newer games will max out all the cores on older PCs (and some still won't, because good threading is hard to do in languages like C++.)
I would ask, why there should be a Board software written in Python if there are good enough boards written in PHP. If you need to integrate some php board with your python software you can use some XML-RPC API provided by this board or just use db level integration. If you need just run board you can download it and run, no matter which language it's written in.
Many if the sites out there prefer support for the bulletin board software so they rely upon VBulletin and other supported apps. Let's face it the only reason to go to some sites is the communications that some of these apps permit 
http://www.discourse.org/ MIGHT have been written in python but in the end ruby won :(
xml-rpc is a dying technology, nobody really uses it. db level integration becomes a maintenance nightmare. You end up writing stored procs and db triggers to handle the integration and it blows up in your face as soon as there's any changes to the schema.
You are right. It's always choice about integrate with existing software or write and maintain your own. Depends on your needs and resources.
Arrange your code according to [PEP8](http://pypi.python.org/pypi/pep8/), please.
yeah :( and discourse is amazing!
Here we go. Something like this. http://pastebin.com/numHWQNs
The last time I checked this one, it didn't work with python3. Interesting.
ELI5: Why is it so hard to port Numpy to work on PyPy? Are they doing something more than simply porting the glue code (e.g. rewriting it in RPython), or porting any C library would take as much effort?
Check out Pandas http://pandas.pydata.org/
Thanks for your input.
The code behind this: http://pastebin.com/bySbxM02
&gt; XenForo is a commercial Internet forum software package written in the PHP programming language using the Zend Framework. **The software is developed by former vBulletin lead developers Kier Darby and Mike Sullivan.** I think that explains why it's done in PHP...
No. I was replying to following: &gt; Because you have a lot of them already done in PHP. I thought you were saying there are already lot of them, no need for new one.
It's not just with forum software, it pretty much holds true with any sort of popular web software. There are multiple reasons but I'd say by far, it is because with Python it's harder to make it easily available like a "copy paste files and you are good to go" method. We under-estimate how significant these seemingly small barriers are.
My guess would be that numpy is written in a way that makes it depend on some implementation details of CPython.
&gt;I need to use objects, inheritance, methods and functions, recursion, and searching/sorting Why do you need to use all of those?
Sounds like schoolwork. 
Yeah, hence my question =\
`s/to/too` otherwise, I have to agree -- jetbrains' stuff is the shit, be it python, ruby or java &amp; scala
There is. I'm telling you this is very easy in Python to do. It's just most hosting are not doing it for Python, and most Python dev don't know how to allow it for their code. Basically, If you want your user to be able to just copy / past your app into the web root, all you have to do is provide a app.wsgi file with 3 lines of code. The user don't have to know that, he just copy your app, and the host find the file automatically and start you app. That's all. But again, most hosts don't look for that file automatically, and most dev don't create that file. When I do a project, I always create that file. If you use a good Python host like pythonanywhere.com, it will work out of the box. Nothing to do. Just copy/past.
I have started a forum in python/flask. You can basically do almost everything now but I don't consider it finished yet. Link to source: https://github.com/sh4nks/flaskbb (if someone wants to help out/give feedback :))
Conda is pretty much it's own virtualenv, but whereas virtualenv merely manipulates environment variables that point to your packages, Conda manages it at a lower level. That could be a good thing or bad thing. For instance, sometimes I find Conda breaks compilation tasks that link against Framework Python on OSX.
&gt; Basically, If you want your user to be able to just copy / past your app into the web root, all you have to do is provide a app.wsgi file with 3 lines of code. As a novice, do you have any guide to what you are referring to here? I would most appreciate it.
I don't understand this obsession with karma. Its completely useless.
WSGI is a standard for dynamic Python server-side applications to communicate with web servers such as Apache and nginx. Your Python code can be written using any framework you like (or none) but as long as it supplies an [AppName].wsgi file that will be picked up by the web server and executed, starting your application. It's nice because it's cross-web-server-platform. Drop your application in the right location and regardless of what your web server software your application will get picked up and served. Compare this to PHP where on Apache you'll need to install the mod_php module, with nginx you need a FastCGI configuration file and I don't use lighttpd but you get the point- configuration depends on your web server with PHP, it's not plug-and-play.
Brilliant. I have a few QA engineers at my office who are looking to learn Python, will definitely recommend this to them.
The vim-mode plugin in IntelliJ is actually really good. I imagine it's just as good in PyCharm?
Making websites myself, its more useful to analyse the total size of downloads required (not just html) and how many requests those are doing. Eg, for google.com is 568kb over 15 requests according to: http://gtmetrix.com/reports/google.com/nVi3DWTW Then perhaps consider browsing cache, which will eliminate most of those requests and a fair chunk of the 568kb (though not all the way down to just the html since there's bound to be ajax requests going on on page load)
&gt; First of all there's all the problems with the hosts which hardly support Python, if at all. I agree. &gt; Even if the host supported it, what do you do with the dependencies? You might need Postgresql and redis installed too. With PHP too. That's not a Python thing. Either your host has it installed for you be default (Postgresql and redis : rarely) or you have to install it. I don't know any PHP host giving you redis just like that. And there is no reason to use more redis in Python or PHP. &gt; And the WSGI copy paste thing, even if you have root access to a server is still non-trivial and full of gotchas. No, really, there is nothing to do from the user side. You don't need root access. You just need to copy / paste, provided the hosting is properly configured. &gt; A useful application is hardly a vanilla Python package without needing anything else. If you can code it with just PHP, you can code it with just django, flask or bottle. They don't need to be installed at all. You can just have them in your current directory, like you would do with any PHP lib. &gt; So when I say "an archive that you can copy paste...." what I really mean is a self-contained package that you can drop somewhere and forget about it and everything just works, without you ever having to run commands on the command line, etc. I am, again, telling you it's very easy to do. People just don't know it. Apparently you don't know it. Nobody tells that in the documentation. Few hosting are correctly configured. There is a big problem with hosting. And there is a big lack of knowledge from project maker (it's 3 lines, for god sake...). But everything you need are at disposal. Now it doesn't solves the problem to say "it's not pyhton fault". It get it, it's still a serious issue. &gt; Which would include configuration and database and task queue, third-party libs and everything else in-between. If you want task queues and complicated things in PHP, you can't just drop things in your www. You need to compare what you can compare. If you just drop your files in www root, then you just got simples features in PHP, which you can do with django, which you can just copy/paste. &gt; The closest thing to this now is Docker which recently hit v1.0 so I'm hoping that turns into something. I love docker, but it has nothing to do with the issue. You are reacting like you need things like redis, task queues, or postgres to do stuff in Python. You don't in PHP. And you don't in Python. You installed them if you want to do very advanced stuff. For blogs, forums, e-commerce websites, and all the stuff that have been made in PHP for the last 10 years, you don't need that. Maybe Mysql (but really, not most of the time, sqlite is much more performant than people think), but again, your hosting should have that installed for you. 
Because he doesn't like it. He's the IDE arbiter, his word is law. Obey. /s
&gt; WSGI is a standard for dynamic Python server-side applications to communicate with web servers such as Apache and nginx. Your Python code can be written using any framework you like (or none) but as long as it supplies an [AppName].wsgi file that will be picked up by the web server and executed, starting your application. &gt; It's nice because it's cross-web-server-platform. Drop your application in the right location and regardless of what your web server software your application will get picked up and served. Compare this to PHP where on Apache you'll need to install the mod_php module, with nginx you need a FastCGI configuration file and I don't use lighttpd but you get the point- configuration depends on your web server with PHP, it's not plug-and-play. Thanks for the reply, BinaryRockStar. :)
So u don't use the conda command? Why not? Any downsides? Are there any Licensing issues in using the anaconda environment inside the company?
print should not start with caps.
There's one called "Reddit" that is written in Python. https://github.com/reddit
all the best deploying it.
I'd guess in Python 3 it breaks right at the first print statement. I'll be honest, I'm following "Learn Python the Hard Way" and haven't been attempting to format my code for Python 3. I do have some documentation on the differences, and may be able to reformat it as such, but probably won't right now. I got a lot of info on things that could be fixed going forward, but it's so much that I'm going to focus on continuing and try rebuilding it from scratch once I have a better handle on classes, so I can just create a room class and make it cleaner.
&gt; It's like a car manufacturer saying "a beautiful car made with some brand of hammer". I love this. I'll steal it from you.
I find the "rej-ex" pronunciation silly... They are **reg**ular **ex**pressions, after all.
I never get this argument, a lot of things are done in other languages. If people were to follow this logic we wouldn't have Django because there was Ruby on Rails. Also who in the hell wants to work in php when you can work in Python?
Like jjangsangy said, they are kind of a replacement/alternative for virtualenv. The major difference is that conda works system-wide and virtualenv works with python. I haven't tried it, but it almost seems that you could create a virtualenv inside of a conda environment. This would be redundant, but it's just to say that conda is working at a higher level.
Check out jedi-vim. It has completion support etc, but I find the 'jump to definition' functionality to be super useful.
I honestly don't have a clue how to develop something like this, but I would gladly donate some time and few $ towards it, mostly because of my personal hate of php, long story short I had to read through a lot of php web-scrapers and port them to Python which was nightmare inducing experience. So needless to say I don't want to see php code ever again and that kept me away from starting few forum projects that I had in mind.
Yeah, even I don't mind donating! Really. And I guess there will be many people who would love to donate and see a good project alive and kicking
I can see how those would be problems if building a large code base (except for code size of the module - I don't really care about module size - if I did id be writing in C). For me, and I suspect the target audience, the goal is to make it easy to write proper basic docs for shorter scripts compared to larger projects. Docopt makes this doable where argparse/optparse don't. 
If running on Windows, I'd use Excel's native sort &gt; sort through them all. You mean you need to sort all sheets of all the files ?
Although redis might be seen as superset of memcache, I would not put them in the same category. Memcache is great when used as cache or super fast key-value storage without promise that data will always be there. Redis on the other hand provides 5 different data structures and you don't have to worry about disappearing data. Hard to judge the choice without any details given, but most of the time it's not the speed of the storage engine that is the biggest performance problem.
Because there's no such thing as a good forum?
I'd go with Redis myself. Gives you the option to add more powerful features if you grow. It also can save to disk periodically, ensuring your cache stays warm between restarts.
I already gave my definition of good.
ANN is an acronym for Approximate Nearest Neighbor and Artificial Neural Network, i think you should rethink how to use that acronym.
I won't call it new, but it's hot.
[.vimrc](https://github.com/OrangeTux/dotfiles/blob/master/home/.vimrc)
Yay this is awesome thanks!
So many people recommended it, I figured I'd see what it was about. I've been developing in Python for about 5 years now, in an environment I've been developing for for 12 years, in a package I've been learning and using for 18 years. I was quite curious to see if it could teach me some things. I did `pip install flake8`, and cloned syntastic to my vim bundle directory, and opened a small file from one of my projects. It lit up with issues on save. None of them were useful, though, at first. It said it can't import a package specific to the environment I use, but of course not. That can only exist inside of that environment, not out in the shell where I work; the package is generated from auto-converted C libraries on application startup (it's annoying, TBH). There's one, tiny, stylistic thing I do that's unusual, that's so tiny no one has ever called me out on it in all the code I've pasted here, other subreddits, stackoverflow, etc., so I'm not changing that one. Syntastic doesn't like it (and it's everywhere), but I do :) Syntastic doesn't like missing docstrings, but most of my libraries are in alpha stage, so I'm not putting in docstrings yet. I'd just have to micromanage them as I radically change things all the time, and I've several times been confused by out-of-sync docstrings while doing heavy refactoring. These are long-running libraries of code used in a production environment on the asset-creation side of things. They're behind NDAs and won't make it to the public, sadly. So, flake8 doesn't like camel case, but I don't like snake case, and I'm not changing. That's one thing I think was a bad decision from PEP 8 (I like most of PEP 8). It also doesn't like the unused `*args` and `**kwargs`, but I use these especially at the leaves of the system to allow indiscriminately calling things with buckets of information, e.g. `resolveNamespace(someName, *args, **kwargs)`, which lets me pass through from calling functions without having to pollute their argument space with the cruft of helper functions. &gt;"Used builtin function 'map'" What else am I supposed to do for this? def disassembleKeys (keys): return zip(*map(disassembleKey, keys)) &gt;"Used * or ** magic" That's a problem? def splitFramevals (framevals): return zip(*framevals) &gt; Unused variable 'values' Yeah, okay, but I need to work with frames here, so I'm splitting things apart while making it very obvious to future maintainers that I'm splitting apart frames and values, which is supported by all the naming in this line. I suppose I could go with `frames, _ =`, which it doesn't complain about, but I like the subtle reminder in this 4-line function that framevals are just frames joined with values. Meh. frames, values = splitFramevals(framevals) &gt;"No exception type(s) specified" I agree with this one, I think, though I'm never sure which exception I care about. In this library I'm looking at, I have 3349 LOC, but only 14 untyped try/excepts. Usually I use a try/except where I don't care if it fails, and will just return some empty value if it does, but I suppose that could occasionally be frustrating, as you have no idea *why* you're getting an empty value. I've thought about this from time to time. I should look more deeply into this one. &gt;"Blank line at end of file" That's [not a problem](http://stackoverflow.com/questions/2287967/why-is-it-recommended-to-have-empty-line-in-the-end-of-file). It's an old standard that has its reasons. &gt;"continuation line under-indented for visual indent" \**puts hands up*\* Hey, I'm just letting my Python indenter handle things in Vim for me. It doesn't like spaces around '=', but I find when I have to wrap very long argument lists, it's much more readable to let them breathe: loseChanges = cmds.confirmDialog( title = 'Warning: Unsaved Changes!', message = 'You have unsaved changes. Create a new scene anyway?', button = ['Okay','Cancel'], cancelButton = 'Cancel', defaultButton = 'Cancel', dismissString = 'Cancel', icon = 'warning', ) It also said a class didn't have a particular member, but in the constructor I'm calling a method of the parent class with that name to grow that member into the class in a particular way. It feels like there are just too many edge cases of my more esoteric needs that this would constantly fight me about. If I step out of the very standard uses of Python, which I often do (especially now that I'm dabbling in functional, composable things in Python, where it'll let me), then I'm going to have files lit up with non-issues. All that said, I did find it useful in a few small spots. In one, I was importing math in a file that didn't use it. Nice catch. In another, I was redefining the built-in `type` (locally, in a tiny function, where it doesn't matter, and it's an `__exit__` callback argument, which I copied from a tutorial thereof, but still). For a third, I have two functions a screen apart with the same name! That's a very good catch, and perhaps worth the price of admission. I think I'll take your advice, and just turn off all the syntax junk that bugs me. 90% or more of the flagged issues are its dislike of camelCaseVarNames. I might also make it more of a manual-run thing, instead of constantly yelling at me when I save. Thanks.
OK, doable was the wrong word. I probably should have written 'easy'. argparse and opt parse certainly can do everything docopt does and more (and provide things like input validation)...but they don't make it easy :) Also, happy cake day :)
hey man, thank you 
The best solution I've found is: PyQt + PyInstaller on Python 2.7 PySide will probably also work. The Qt libs are very good at cross platform GUI work along with doing things like saving window sizes and app settings in a cross platform neutral way. Then you can use PyInstaller to bundle the app up for various target platforms. I've used it to take my PyQt apps and bundle them up for Windows, Linux and Mac without much fuss. 
My very basic understanding is that NumPy is basically a bunch of code written in C in order to be efficient. When you call a function from Numpy, python calls that library and accepts the response. Pypy attempts look at what your code does and then compiles machine code that uses this information to be faster. This means that, ideally, Pypy can recognize simple for loops and can recognize the type of variables and then essentially rewrite your code to take advantage of this information. When you call an external library though you are essentially calling a black box, Numbers go in, numbers go out, and Pypy has no idea what is happening so it no longer knows the type of each variable or what kind of for loop it should write to optimize the code. This then is actually a pretty deep problem, *any* c library that you attempt to call is going to have this problem. Numpy gets the most attention because it is one of the most used and one for which performance is always an issue. It is such a deep problem in fact that the solution that the PyPy developers have seemed to have settled on is to simply rewrite Numpy in Python so that it is no longer a c-library and the PyPy complier can see what is going on. Please, someone correct me if I am wrong.
A content light promotion of a regional user group, python isn't even discussed, feels off topic.
In free time I am developing Misago which aims to be complete and competitively featured internet forum software in Python: http://misago-project.org There is compatibility with Django apps planned for next release (thus turning it into forum and "community sites framework" thingie), but we are still not there.
relax
These are very different technologies. Memcached is a memory-only, key-value store. This means that, anytime you happen to restart or have a brief power outage or anything like it, you'll lose its contents. For a cache, this is usually perfectly acceptable. Similarly, memcached really has no defined high-level architecture. If you start up two instances of memcached on two separate machines, they do not automatically connect , load balance, or share configuration with each other in any way. That responsibility is left entirely up to the client to figure out. Redis comes with a heap more features. The _biggest_ feature difference is persistence to disk. You can still lose data with Redis, but it will happen in on your terms.
Thanks for your perspective but I find it also frustrating. The title is accurate, and it's an interview with someone who's managed and promoted the Chicago Python community for over a decade. The organization has even sponsored member trips to PyCon (covered in a previous interview) and provides a very positive community for Pythonistas in Chicago. I argue that it's relevant because he's an active participant in the Python COMMUNITY which isn't just about coding. We chatted briefly about his new community venture but it is still arguably relevant to Python because it is so popular in the space of people he's supporting with the new community. If an interview with a major contributor to Python community in Chicago isn't relevant to Python then where would be more appropriate? 
Looks amazing! Do you have migration tools to migrate from vb &amp; xenforo? And also those live notifications which Xenforo has implemented? Lastly why you guys have not considered Ajax?
And also just curious, when is the next release planned
Forgive shameless plug, but I am supergrateful for all donations for Misago: http://misago-project.org/ (donate button is in forum footer)
Redis is also super fast key-value storage. Have a look-see at http://oldblog.antirez.com/post/redis-memcached-benchmark.html and http://oldblog.antirez.com/post/update-on-memcached-redis-benchmark.html
Note to self: posting 60 teens singing the cup song on r/python =&gt; not necessarily a good idea. EDIT: It's getting better. Apparently r/python likes covers mashups. Good to know :) Thanks people !
It's not about someone's favorite color. It's about a tech community that is by a Python community leader creating a new community that he thinks will be interesting to Python users. It is relevant to Python, maybe a subset of people, but still relevant to the Python community. 
I was thinking about you when I wrote the library :) If you ever run in trouble with the library (I hope you wont), please give feedback on Github or r/MoviePy, I try to be reactive if it's something I can fix.
The company I work at is the largest provider of hosted Redis &amp; Memcached. Both technologies are amazing, but Redis is far more flexible and powerful than Memcached. Besides the 6 data structures &amp; data persistence mentioned in other answers, some of Redis' additional features include: * Pub/Sub out of the box. * Server-side scripting with Lua. * Pipelining (batches). * Keyspace notifications. * Keyspace iteration. * Transactions. * Eviction policies. ... Redis also has [client libraries in every language](http://redis.io/clients), amazing (and interactive) [documentation](http://redis.io/commands), a ton of libraries that you can pick up and use (do a search @GitHub) and an extremely active community that's always ready to assist.
Can you really run much with WSGI without using a something like NGINX and Gunicorn? I've always been told that to just run Flask or Django straight from WSGI is just going to murder performance for most use cases. I found installing a Django app to run on my VPS very taxing, and spent 3-4 hours debugging Gunicorn errors apparently related to my WSGI file that was missing something stupid. 
The Julia code was improved by folks on the Julia mailing list to b only 18% slower than C++. So it seems faster than Numba. Numba is impressive though!
Once Misago 0.6 is released (dont have ETA yet, but hopefully this year) with cleaned implementations for users and forums, I will start looking into converters. As for AJAX, reasons are similiar: there always been more important things to do on server side of things + I am not really guy who writes good JS thingies. Hopefully when 0.6 arrives skillfull folk will step up and start making pull requests with such improvements.
Thanks for this, I was a memcache kind of guy (formerly APC), but Redis looks like redis will be taking things to a higher level. 
Have you seen [this](https://wiki.python.org/moin/PythonDecoratorLibrary#Memoize)? Since 3.2 there is functools.lru_cache to do the same thing and more.
I take it you can't use OBS?
I'm curious to see how Julia does in the coming years. It can take a while before languages gain widespread adoption and have many mature libraries. I've not used it, but the built in parallelization capabilities sound pretty cool. If it can improve writing hybrid shared and distributed parallel code (OpenMP+MPI) while maintaing the control that these utlities provided, that's a big win in my opinion.
I thought about memoization first, but decided to implement a datastructure because: * Serves a more general purpose * Can easily build a nice hierarchy of the information * Also allows normal values (not only cached functions) * Can be realized and saved (e.g. the Host class + pprint = complete overview over whole machine)
You made me laugh out loud.
I enjoy reading your blog! 
As far as I know, this is the only open source program to do video overlays. Awesome! 
Some editors like KDEnlive and Openshot can do overlays, but they are not scripted. Avisynth and its linux ports can do overlays, but I wasn't convinced (too complicated to code your own effects, or moving clips, etc.). Then there is, in Python, OpenCV and its pal SimpleCV, which I love, and which can overlay texts and shapes on movie frames. But they weren't very indicated for movie editing (they are very much 'frame-oriented', so to speak).
Well thanks, I enjoy reading that you enjoy reading the blog ! Unfortunately I will have to stop writing about funny little projects like this one (not enough time). There might be other articles, but they will certainly be nerdier and more public-specific.
It depends on your keyboard. In the turkish march I play 4 notes simultaneouly a lot of times. I think you can reach 5 notes on many keyboards, but not any combination of 5 notes. 6 notes... I have to try.
Look really awesome, I promise to donate $50 when it supports Python 3!
I've used PHP in the past with APC, but I was looking more into a language independent option for Python or whatever I throw at it. The momentum has been towards Redis lately, but it doesn't matter as both memcached and Redis are easy to install in Ubuntu 12.04/14.04.
Heh, I brew installed it, linked it (at least I thought I did), but my terminal still shows only 2.7 version (which doesn't surprise me, actually). And recently I switched from Aptana to CodeRunner and didn't find any option for choosing Python 3 syntax. Unless Yosemite comes out with native Python 3, I'll stick to Python 2.7.7. P.S. You left Python 2.7 as a system's one, didn't you?
Support for 3.4 is on the list. Hopefully it won't be too far after release.
thats pretty awesome man
My wish for you is to have some more time for this kind of projects. Keep it on.
Pygame was an absolute S.O.B. to install on OS X (I got there in the end) and then I found it would barely run a simple game loop at 25-27FPS. Whereas on Ubuntu it was super easy and ran blazingly fast. Might be worth considering doing your pygame in a VM, sounds heavy weight but after all the faffing (hopping on one leg, praying to the right deity whilst rubbing my belly and patting my head) I did to get it working - its just easier. I also wasn't too satisfied with the PyGame APIs, but that is a personal thing.
Yes it is.
Python3 lets me run python 3 in terminal. I have trouble with pycharm. 
Does anyone have any suggestions of good talks?
Wow, MoviePy looks like exactly what I need for one of my projects. Quick question though: Is it possible to specify the start/duration in frames instead of time (seconds)?
https://github.com/vitorfs/bootcamp
Which comment(s)? WSGI definitely requires that have a process that can run the WSGI file provided by your application, accept incoming connections and palm them off to your application.
/u/desmoulinmichel up above. 
Here's Embarcadero's forum for Delphi, specifically the subforum for 3rd party libraries. https://forums.embarcadero.com/category.jspa?categoryID=16 Note every vendor with a new product release begins their thread title "ANN:".
This is a fantastic find and really shows that Python can compete on the speed front with statically typed, compiled languages with the proper tools/libraries. I was very upset for a bit that there was no code included but I jumped to the references, the appendix and then scanned all the footnotes without seeing that they embedded a link in the introduction for the source code! I'm going to have a good time trying out their code on Linux and a lot of fun implementing their algorithm in some commercial packages (I have a sneaking suspicion Python will outperform some of them). Thank you very much for this link! Great post!
The bottom line is that PHP is the lowest common denominator. It will run on virtually any shared hosting package. All you need is PHP support and one database. So if you want to reach the widest possible audience, you go with PHP. Sensibly designed Python software, on the other hand, requires running several user processes on the server and editing Apache's configuration files. That's a whole different class of hosting package *and* administrative skill. Things *may* start to change now there are a whole host of providers offering one-click installation of Python/Ruby/non-PHP apps, but for the longest time, PHP was the only "drop-in" solution. It has a much lower bar for installation than apps written in other languages. Any halfway-intelligent person can download and install PHP software one their simple, cheap shared hosting package. 
YouCompleteMe (commented about it above, or the github page has everything you need). It's great. 
That's awesome. I didn't know you could edit video purely with Python. Now I'm inspired!
Just clicked on the page. Closed the tab. It's absolutly impossible to scan it. The noise vs signal ration is very bad, the ergonomics sucks (getting this right is hard with pure js apps, or more like, not getting this wrong is hard). I do know how to code is JS, but is falls in the category of my previous argument : &gt; People that are dissatisfied with the current forums, or with the concept of forums in general never found an agreement on what would satisfy them, in Python or any other languages. Some say SO like websites are the answer, some prefer live chats... We can't agree on this. It's ok, not to, but that answwer part of the OP question.
I'm going to repeat myself for the zillion time, but this is very easy to do with Python. This is not a Python issue. This is a hosting issue. The problem is that most hosting to automatically take in consideration the wsgi file, which they should. When the hosting is properly configured, you can just copy / paste your project, and it works.
A warning about memcached and Gevent: The standard memcached client for python uses a thread local instance for managing connections across threads. Gevent monkey patches thread locals to work with eventlets instead of threads. The way it does so, if you keep a reference to the eventlet object, the thread local doesn't get garbage collected. I had a case a while back where something I couldn't find was keeping references to the eventlets, so even though the eventlets were terminating, the memcached connections were staying open indefinitely. I think it might have been gunicorn or something keeping references to eventlets, and I couldn't find a way to clean it up. Ultimately I had to figure out the internals of the eventlet locals and explicitly clean up my memcached connections. 
Interesting. I've got a whole bunch of videos from my flying lessons. I eventually settled on having one camera in the cockpit, and another camera stuck to the undercarriage (so you can see the wheels etc). I never got around to editing them into a single overlay... tried it once and video editing drove me nuts, would definitely prefer a programmatic option... seems like MoviePy could be used for this?
Seeing that you are using Python 3.4, I am guessing you're simply experiencing the behavior of PEP 420, introduced in 3.3: http://legacy.python.org/dev/peps/pep-0420/
I don't think you'll need much experience to have a big impact. Check out the README to see how it works on unix. The basic idea is that we want all of that good stuff to work well on windows too. Out of the box. If you have cygwin installed, you should be able to get a feel for how the tool is supposed to work. I was told py.exe is already taken on windows, so I added the option to use wpy instead. But there are other issues, like the quotation (" vs. ') having a different meaning on windows. If you can make even small recommendations for things to change, those can be implemented. But it'd be even better if you just started tweaking the code yourself to make it work for you. If it works for you, then chances are that other people will like it too.
&gt; but of course git doesn't track files, only directories What? Git only tracks files not directories.
Without being at my PC, I'm guessing it's got to do with your boolean operators. Why are you saying `if (sales &gt; 10000.0) or (sales &lt;= 100000.0)`? It should be `and`, should it not? After all, a sales figure of 50000 would evaluate both conditions to `True`. The way it's written now, if `sales` is small, your first `if` condition triggers, and if it's big, the second one triggers. Let's say `sales = 5000000.0` and `time_employed = 5`. Then `sales &gt; 10000.0` is `True`, `sales &lt;= 100000.0` is `False`, and `time_employed &gt;=3` is `True`. So `True or False and True` is `True`.
Tried it on both 2.7.6 and 3.4.1 with the same result.
Free book: "Invent Your Own Computer Games with Python" http://inventwithpython.com Also has a couple sequels that are also free. And the author is a redditor who will answer questions you email him. *Full disclosure: I am the author.*
Thanks for catching that. Lysdexia is a cruel adversary.
Fantastic, I'll take a look today when I'm not working.
For the lazy, the source code is here: https://github.com/jesusfv/Comparison-Programming-Languages-Economics
Plus APC basically doesn't work with the newer PHPs. Memcache was a pretty good swap in; but this redis looks pretty cool. For some reason it never really showed up on my radar before.
This might be a dumb question but why would someone need this? Shouldn't you just alias `pyhon -c "print %1"` or similar?
I cloned [this](https://github.com/joedicastro/dotfiles) as I like both his vim and emacs setup (thanks /u/joedicastro!). The main plugins for me are unite, airline, neocomplete, ultisnips, python-mode, fugitive &amp; gitgutter. I also use something quite similar to the final code block of [VimTip605](http://vim.wikia.com/wiki/VimTip605) (the F7 mapping) as it helps overcome some stupidity in Firefox. Experience makes me predict in a few years Joe will have moved on and this setup won't be up-to-date with the future vim feature plugins and so people like me will migrate to the next big thing. Prior to this I was maintaining my own setup which was doing the same minus Unite, so I scored that by letting Joe do the hard work ;) 
haha yeah I think I may have typed it in wrong but it worked later once i retyped it
Good for you for sticking with it. When I tried, it also angered me with its constant whining about non-existent problems, and after about the 50th time it reformatted lines longer than 80 characters into unreadable nonsense I jettisoned the package. Why do I have lines longer than 80? Nested for loops inside class instance methods with sensible names for multiple return variables and function call. The last straw was when it did it to a line that was 81 characters. Anything that anal retentive is more trouble than its worth. More useful to me when coding is git integration, snippets, and completion. I have code coverage and unit testing covered as well, so anal non-problem checking is already being done ;) 
Great job. Really nice showcase of moviepy's capabilities
For clarity, I'd put in more brackets, like so: if ((a &gt; 1) or (b &lt; 1)) and (c == 2): But apparently that's not the problem. Also: Take note of /u/henrebotha's post; you probably want to be using "and" instead of "or".
Yes it can be used for this. To put one clip under the other (that's something that you could do directly with ffmpeg I believe), your code would be like that: cockpit = VideoFileClip("cockpit.mp4") undercarriage = VideoFileClip("undercarriage.mp4") final = clips_array([[cockpit], [undercarriage]]) final.to_videofile('myvideo.mp4') If you want to do some proper compositing (like placing the clips exactly where you want on the screen, etc.): cockpit = (VideoFileClip("cockpit.mp4") .resize(0.4) # size x 0.4 .set_pos(('center','top')) ) undercarriage = (VideoFileClip("undercarriage.mp4") .subclip(2, 12) # keep part between t=2s and t=12s .resize(0.4) .volumex(0) # no audio .set_pos((520,790)) ) final = CompositeVideoClip([cockpit, undercarriage], size = cockpit.size) final.to_videofile('final.mp4')
For the moment you would need to do the math to convert frame numbers into times, like this: clip = VideoFileClip("myvideo.mp4") # subclip between frames 15 and 65 new_clip = clip.subclip( 15.0 / clip.fps, 65.0 / clip.fps) I had objections to adding this feature directly in the program (because most video clips don't really have a fps, it would confuse things), but since you're not the first to ask, it will certainly be added in the future.
Thanks for advice. I have Parallels, so I can run it Ubuntu. The thing is that I am actually just a beginner. What I do at my current internship is data scraping, and PyGame is just a library I wanted to check out just for fun. : )
[Unfortunately](https://github.com/hoverhell/xmppforum/), donating won't really help with the popularity and contributions, not to mention the hosting infrastructure zeitgeist.
Tried to modify it a bit so that it's easier to read. if sales &lt;= 10000: print('Your commission is 0 and your bonus is 0.') elif time_employed &gt;= 3: elif 10000 &lt; sales &lt;= 100000: print('Your commission is {comm} and your bonus is 0.'.format(comm=comm2)) elif 100001 &lt; sales &lt;= 500000: print('Your commission is {comm} and your bonus is 1000.'.format(comm=comm3)) elif 500001 &lt; sales &lt;= 1000000: print('Your commission is {comm} and your bonus is 5000.'.format(comm=comm4)) else: print('Your commission is {comm} and your bonus is 100000.'.format(comm=comm5)) 
Right, also reproduced on my end. Weird, never noticed it before.
Reading Python/import.c (L1800), it's pretty obvious why this happens. It only checks that the stat system call succeeds on the path. It doesn't check the file type to consider it a success...
I had a bitch of a time installing moviepy with virtualenv a few months ago, and now it doesn't seem to work anymore.
from what I can see, they only made it twice as slow as C++: &gt; [doing some stuff] made quite a bit of difference for me, from 1.92 to around 1.55. If I also add @inbounds, I go down to 1.45, making Julia only twice as sslow as C++. Numba still beats Julia, which kind of bothers me a bit This was what the author of the linked paper posted towards the end of this discussion thread on the mailing list [https://groups.google.com/forum/?fromgroups=#!topic/julia-users/dl_ysr1TdXE ]
I would love to help. I would prefer to use Linux over Windows any day, but working in finance I am pretty much forced to use Windows at work. I'm just an intermediate developer, but I would love to lend a hand.
[Microcosm](http://microcosm.cc) is a SaaS solution for forums. The core is written in Go but there is an open-source client which uses Python/Django https://github.com/microcosm-cc/microweb The API is documented at http://microcosm-cc.github.io
What's your bug ?
I'm not sure the original author included all optimizations for e.g. devectorization. Look [here](https://groups.google.com/d/msg/julia-users/dl_ysr1TdXE/k7sRo8k4iTEJ) where Julia runs in 2.26s vs C++'s 1.9s
Thanks for the suggestion, saved me from implementing keys() and __contains__(). Also has __eq__ and __ne__ now. Not sure if I did this correctly though, would be great if you could check it out.
In python you can write if 5 &lt; x &lt; 10: pass You're using parentheses wrong. Learn the order of operations... `and` is higher precedence than `or`, so this elif (sales &gt;10000.0) or (sales &lt;= 100000.0) and (time_employed &gt;=3) parses as elif (sales &gt;10000.0) or ( (sales &lt;= 100000.0) and (time_employed &gt;=3) ) which is probably not what you want. You also probably want `and` conditions for most of those `or`s. And what if sales is between 100000 and 100001, or even equal to 100001? Use &lt; and &gt;= with the same boundary value. And factor out the time employed test instead of putting it in every branch.
Technically awesome! I guess you didn't create the footage you used so you can't be blamed, but gosh was that nasty to listen to.
You should separate your data and your logic. This makes your code easier to understand and/or change, and reduces errors, as well. It's also a good idea to name all your magic constants, such as 10000 and 3, for the same reasons. Your chain of elifs does the same thing over and over again. You should try to extract the data, put it in a list, and then apply the logic to the data in the list. # data min_sales_for_commission = 10000 min_employed_months = 3 ranges_commissions_boni = [ (10000.0, 100000.0, comm0, 0), ... (1000000.0, float("inf"), comm4, 10000), ] # logic def print_commission_and_bonus(sales, time_employed): comm, bonus = get_commission_and_bonus(sales, time_employed) print("Your commission is %s and your bonus is %s." % (comm, bonus)) def get_commission_and_bonus(sales, time_employed): if sales &lt; min_sales_for_commission or time_employed &lt; min_employed_months: return (0, 0) for (sales_min, sales_max, comm, bonus) in ranges_commissions_boni: if sales_min &lt; sales &lt;= sales_max: return (comm, bonus) 
Very nice, somewhere I am sure an ad agency is stealing that idea as we speak.
Maybe you want to use g:ycm_semantic_triggers. add to the map python : ['.', '(']. I don't have my linux computer right now so it's hard to test for you
I think it's interesting that you are mimicking JavaScript lingo, with multiple lines starting with a ".". I didn't know that it is possible by using encapsulating parenthesis. Maybe this will become a new trend in python as well. I like that you can manipulate a context in a scripted manner. It's kind of a nice blending between functional programming and object oriented programming.
Pick a project. Any project that interests you. Work on it. Write more code. Ask for tips on sites like [Code Review Stackexchange](http://codereview.stackexchange.com/) or Reddit. Look at some of the more well-written libraries out there like Flask or requests. See what pythonic code looks like. Familiarize yourself with PEP 8. Look for an open source project in an area that interests you. Preferably one with good code review processes. Write code and submit patches, it doesn't have to be anything advanced. Having people critic your code is crucial to improving. Also, did I mention that you should write more code?
Not that it helps you (at least not right away) but i'm currently writing one. it won't be primarily a "bulletin board" as such, in the sense that phpBB is, but it will be an online collaboration platform with a wiki and a space for time-sensitive posts; the latter will be both a collection of blogs and a bulletin board (i.e. they will be multiple views of the same data).
I stumbled across this the other day. I tried starting IPython notebook in my main projects folder. There were several subdirectories named like `$PROJECT.py`. When python tried to `import $PROJECT` all hell broke loose. Took me a few minutes to piece it together.
This looks super mean for cli work. I'm definitely going to be trying it out.
Check out [Real Python](http://www.realpython.com). You start with the basic syntax, then move into web development. We cover a number of web frameworks and have a ton of exercises and assignments, all covered in a practical, interesting manner. (I am the co-founder/author). 
That looks quite promising. 
No demo as yet. I'm starting on the wiki (it uses Markdown as the markup language). In terms of features: I'll include a lot of Python-Markdown's [extensions](https://pythonhosted.org/Markdown/extensions/index.html). The wiki will include subdirectories and there will also be the option of a `contents` file in any subdirectory to order the other files. The point of this is to be able to produce a sequential document, perhaps using pandoc. It will be an open-source project. I will also host it on my server so people can create their own sites with the ease that they could create a Wordpress blog. Hosting will be free, and there will also be extra paid-for features (the same business model wordpress uses). Every user on a site will automatically have their own blog (linked to their wiki home page). There will also be a bulletin board; this will not be separate from the blogs, they will merely be separate views of the same data (i.e. a blog is a list of head-posts by the same user, a bulletin board will organise head-posts by category/tag). It would be easy to add a Reddit-like view (i.e. display head-posts according to newness and upvotes) so I'll probably do that as well. Backing up the system will be easy (both full and incremental backups). Also there will be an option for people to download new stuff from the sites they're interested in and read them offline (like an offline newsreader for those of us who remember Usenet). Doing this will obviously require a local setup of **SiteBox** (my project's name), which might be on their PC or on a Raspberry Pi being used as a local webserver. There will also be security and anti-surveillance features but i'll write about them separately.
In addition to writing a lot of code, go to [pyvideo.org](http://pyvideo.org) and watch every presentation by [Raymond Hettinger](http://pyvideo.org/search?models=videos.video&amp;q=hettinger), [Alex Martelli](http://pyvideo.org/search?models=videos.video&amp;q=martelli) and [David Beazley](http://pyvideo.org/search?models=videos.video&amp;q=Beazley).
I used to have something similar with ticketmaster and redsox before they started doing captcha. Ticketmaster would usually release tickets day of the show if like good seats were sold out and pull from an XML to get those available seats as an option. I would continually poll the XML and email off a notification when tix were released. With the redsox ones they used to show which sections were available prior to captcha portal so I could poll those as well and wait for some good seats and it would email me when they were available. This was years back and I was greedy and never released the code, lol. Even if I knew where they were I don't think id be able to use em still.
Very cool idea, the specific seats is awesome. Captcha is work of the devil.
Hmm not sure, but which version of python are you currently targeting? It looks like python3 to me, but not the newest one?
It's not exactly much to learn... :-) And you learn it when you need it.
Wrote it for Python 2.7, but it also worked with Python 3.4.0.
Thanks, I appreciate it!
"Oh, udev changed my USB drives device name to `__init__.py` and now my Python scripts in `/dev` doesn't work!"
Well but the behaviour in case of python 2.7 for items() for example is wrong. What you do is there is a generator (since you use yield). In Python 2.7 this is iteritems() which behaves like this. Where as python 3.x doesn't have iteritems anymore but just items() So basically this is 3.x syntax.
Pick an ambitious project. When I was at your stage I picked something needing a ton of different sub projects to complete. I've been slowly picking off pieces as my skills improve and when I have time. It will also help you figure out how to break a larger task down into doable chunks.
Oh, yeah didn't think too much about not breaking the API when writing this - thought that generators as the default is the better choice. It's Python 3 then :P trivial to change it to either version anyway.
Hey Thanks for your response ! Triggers works on '(' ( thanks to jedi-vim ) what I want is to see the prototype of the function as I type. Right now I can see the syntax autocompletion as I type, but I have to trigger the semantic autocompletion to see the popup populated with the function and prototypes. I was wondering since it is triggered, it is possible to do it without trigger. But I can't find how !!
cant. trust. code. with. octopus. as. commit. message.
Is this python script yours? I need something similar made for retail electronics websites. I would be willing to give you some of my bit coin for the trouble. Message me back if you're interested. 
Harmless. There is no use case for naming a directory \_\_init\_\_.py
Look at the frame rate (FPS) overlay in the bottom right of this very popular commercial game (TF2 on Steam). http://imgur.com/f5vmd5a I take it you don't play many games? Just commenting that you might wish to study the field before you start designing your game :-)
That's great. Now if I could figure out why MoviePy refuses to do anything non-trivial on my computer...
As a geek with two grand daughters, I GOT to do this!!!!!
What's your bug ? Have you tried the most recent versions (less than 2 months old) ? 
Nice to see that you've answered your own question! As an aside, I'm not really sure that reddit counts as traditional forum software.
And the sad thing is the reason CAPTCHAs get used is because automated systems are pinging the system and the automated systems are generally only pinging the system because their own data sources are so terrible. I'm not aware of a Ticketmaster API (well, a public, "are tickets on sale?" one anyway).
I don't recall exactly, but I think it might have something to do with my laptop not having enough RAM (also, my version of ffmpeg was outdated and I haven't tried MoviePy with the never version yet).
Boto is a real life saver when you need that extra bit of glue between your deployment system and AWS. Cloudformation templates are powerful, but somewhat inflexible. There have been a few times where I've needed to reach in and manipulate assets dynamically.
FYI this is extremely simple
Yeah I have zero programming experience. So I would be willing to give you some btc? 
I would define them in `package/constants.py`. Then in `package/__init__.py` I would do `from .constants import *`. Users of your package would then do just `import package` and then use `package.CONST`. I think for your internal use I would go with `import .constants as c`.
Also, https://github.com/wearpants/playerpiano for doctests 
Who makes your websites?
Hmm, I like this solution. Then again, I still worry about being vilified for using import *
Speaking of web scraping with Python, is there a way I can look for companies information on google? A have a list of companies and I'd like to get their phone number/website, I started with Facebook, but some companies arenÂ´t on Facebook, any ideas on how to do this with google?
I created this game and website with the intention of making it a tutorial for newbies. It also showcases everything I have learned since mid-May of 2014. I would appreciate if I could have feedback. Fore example, easier ways I could have written the game, other than Pygame. Constructive feedback on the website is also well appreciated! http://asarenski.github.io/
I don't need a website. I need a crawler to find prices for me.
I meant that karma is useless, and i don't understand why so many people are driven to achieve it through unconventional means. I have no problem with you sharing your code.
Thanks for the info. I'm working on putting together a 15 minute video from a jillion (well, many hundreds) of smaller clips. Doing it by hand is awful. Using ffmpeg is okay for a rough cut, but not so great on transitions.
I used to have something like this for stubhub years ago, I decompiled the .swf seat map objects to get the price data in each seat area. The code was used to generate a csv of the ticket prices, and it was a lot more convenient than having to log in, do a search, navigate several forms etc. It was written in Perl, however I use Python more recently as the code is more readable and maintainable.
If it's Paul then how can't you trust it?
I got this feedback from a few sources. That's why the project also comes with a binary called "wpy". Windows users are intended to use that.
You should always rememeber: posting 60 teens singing the cup song on r/python =&amp;gt; maybe not a good idea.
Thank you for that. That looks like an awesome collection.
Thanks for the sugggestion. I know I am supposed to write more code, but what I am wondering is where to get started. I mean, I don't want to just read books on the same topic over and over. Is there any place where I can find such projects and start contributing? 
Thanks for the suggestion. Where exactly can I find such projects?
you need to learn how to walk before you can run
I put all that stuff in the package's init file.
Why the heck would you use Supervisor with uWSGI? uWSGI comes with Emperor mode, a smarter, simpler supervisor.
hmm ... run your query ... maybe use a loop construct over the resultset. use file tools to make folder using a regex pattern on CREATIONDATE. Then output a csv file per content of resultset rows. to find all the table names in your db, you'd likely need to query information_schema in Mysql or similiar construct in another DBMS. If you do enough research, your homework should be easy. :)
This is one situation where `import *` is acceptable (make sure to define `__all__` in `constants.py`), because it is only polluting the namespace of your `__init__.py` file, which likely has nothing else in it, and you are still importing single names from this file elsewhere (as `package.CONST`). See, for example, Django https://github.com/django/django/blob/master/django/forms/__init__.py
may he rest in peace.
From inside your soul! No, but really, take some time to think about why you are learning programming. Do you want to make games, other software, scrape data, analyze data, program a rocket ship to the moon? Find something related to one of those and just start whacking at it. It is completely acceptable to have multiple failed projects sitting there waiting for you to get better to complete them. Also consider toy projects with no real business use value. For example, build something that would model a real life scenario or thing. Doesn't have to be useful to be educational.
That's a pretty lame criticism. Obviously the lack of appropriate tools to facilitate teaching or learning about technology is not the *sole problem* faced by teachers. The author of that article wasn't arguing that 'teaching stacks' would solve world hunger, bring about world peace, or magically inflate teaching budgets. He was arguing that they would help with teaching.
I never used Tkinter. With Python, I've used PyGame. But using C/C++, I use OpenGL and SDL. There's a port of then to Python, but I never tried.
Thanks, that does reassure me somewhat.
Because some of us aren't 12.
That's gonna be neigh impossible unless all the info is conveniently in an accessible format (e.g very similar sites or in a database somewhere)
Ah, so that's what that 8 is for.
Interesting. A friend said I should check out Unity engine. Ever get into that?
Purely cosmetic but you can use a dictionary for the get parameters using requests.get(URL, params={dict} ). It makes it easier to modify the parameters if needed. 
Download the tool =&gt; hack the source =&gt; submit a pull request.
Kivy is good: http://kivy.org/#home It has desktop, Android and iOS support. Some online examples are available, not hard to use.
I use linkedin api for this I can give you my code if you are interested 
There's the ``csv`` module which can write csv file, the ``os.path`` module makes working with file paths fun and easy.
As an individual or a business? This is literally my job. http://360pi.com.
How about this thread? :) http://www.reddit.com/r/Python/comments/27dyx0/high_level_gui_library/
Excellent article explains it very clearly. Curious to know if there are other clustering algorithms that doesn't require you to know the number of clusters beforehand.
Why thank you.
RealPython and Michael have been awesome. I'd definitely recommend all three books. Source: Half way through their second book and loving every minute of it.
It is.
I should probably have made it clearer. Our problem isn't tools it is lack of teachers. That is all. This is less of a reflection on the article, more on my government.
What framework or CMS are you using for your website? As someone mentioned above, it's pretty smooth. 
Karma isn't that useless. If I wanted to create awareness cor testicular cancer on reddit, it'd require karma to get to the front page and really get some views. I do understand your point though, what with upvote bots and the like :P
Props on the solid scraping script. [Lingon](http://www.peterborgapps.com/lingon/) is great for scheduling Python cron jobs on the Mac. You could totally dump this info into a database with [pymysql](https://github.com/PyMySQL/PyMySQL) or into csv files with the standard library.
Oh, well I can't disagree with that. We do need more teachers.
Features I think are cool - settings are read from a config file, limiting the size of commands - ability to restore all previous versions to a git repository - python2 and python3 compatible
uwsgi emperor mode and supervisor are not really swappable; what to use depends on your context. In my case, supervisor runs every other process that needs to reload/restart after a deploy. To treat uwsgi as a special case complicates our deploy system without much benefit since we don't usually run multiple uwsgi apps on the same server (for now). These 2 can work together: you can have supervisor manage the emperor process. Not completely necessary, but this is getting to my point below. The benefit here is having a common interface for automation and teammates to work with. If someone knows that everything runs under supervisor, it's one less thing they they have to remember.
Real men use tmux.
PyQT is very hard compared to others. So unless you need to use all the power it gives to you, I'd suggest to try something lighter.
Started with screen sharing so this idea makes no sense. 
This is not a suggestion, this is a troll. -1. He is asking you to look at the code and make suggestion, or try the game, not write two words about your prefrerred rendering engines. Plus, Unity does not support Python as a scritping language, all Python project using unity are hacks using stuff like IronPython. Not that I don't think unity is a good product, but this comment is really irrelevant.
You probably use vi "IMproved" too. Sissy pants kids and their new fangled terminal multiplexers...
Try %.3f
Thanks. It's always something simple.
Thank you. It's always something simple.
Beautiful soup is very easy to use, but in my experience there's no such thing as simple web scraping.
Thanks I am using Ghost with the gamma theme. 
yea, that's the challenge. But still there's a lot of data out there well formatted.
Thanks, will definitely take a look at it. Have you done something with it?
It's just an initial code. Contributions are welcome. FIFA is randomly releasing tickets and I did it to keep a program looking for the tickets I want and warning me when new tickets are available.
I've used this library a little before. The userguide is a bit short on examples and there are some undocumented bugs. Google search and stackoverflow are a big help, as is reading the source code. When I first started using reportlab I searched for some blogposts to help find better examples of doing stuff. Here's one of the posts I still have bookmarked. Its from a couple of years ago but should still be helpful. http://www.blog.pythonlibrary.org/2010/03/08/a-simple-step-by-step-reportlab-tutorial/
Author here. The editor picked that title, unfortunately. I'm with you that a personal touch is needed to teach programming successfully. Trinket is much more about hands-on learning in person at personal scales. The kind of scale I get excited about is not one instructor teaching millions of students at once but lots of instructors working together on tools that make awesome experiences for their 10-30 students per class.
Requests + BeautifulSoup = heavenly web scraping. So easy. Just, so easy. 
The [PyQt page of the Python Wiki](https://wiki.python.org/moin/PyQt) has just been updated and points to a bunch of tutorials.
Find something that interests you. It's the best way to keep yourself motivated. Do you like making games? Writing tools to automate some aspect of your life or job? Scraping some data? There are a lot of domains where Python can be useful. Find one you like and use your imagination!
&gt; pyodbc to navigate SQL "navigate" ?
Uncheck ["Use subreddit style"](https://i.imgur.com/xJ1H3pl.png). If you want to make specific changes without throwing out the subreddit CSS, you'll need to install some sort of user style extension and write a rule for it.
I just use the Anaconda or Enthought Python distributions and have my own stuff on Github. Then just setup.py develop my own packages. 
Printing it out results in "h t t p : / / w w w . d"
That's UTF-16. Every character is two bytes. exif.decode('utf-16') Should give you what you want. Note it will return a unicode string, not an ASCII string. If you *really desperately* need ASCII, try exif.decode('utf-16').encode('ascii') but be careful of encoding errors. utf-16 can *easily* contain characters that are not representable by ASCII, which will throw an error. The only safe way to use it is as a unicode string, sticking to only unicode-supporting functions. Which is most functions. Try the unicode.
That means that moviepy can't even read the first frame of the video file. My guess would be that you are using an old version of ffmpeg or (less probably) an exotic file.
it looks like it might actually be little-endian UTF-16 (`h\x00` instead of `\x00h`) -- does `.decode('utf-16')` do the right thing with endianness?
Getting clips in sync is difficult. Maybe in the future their will be a tool that analyzes the sound and finds a delay between two video clips (I know at list one other person who is thinking about it). Generally I listen to the sound rather than watch the video to determine if two clips are in sync: # cut one clip 5s at start to have clips in sync final = CompositeVideoClip([cockpit, undercarriage.subclip(5)] final.audio.subclip(8).preview() # preview 8 seconds of the soundtrack final.audio.to_audiofile('test.ogg') # OR render the audio to a file. Another trick, useful in particular to synchronize video and audio with precision, is to render a slowed-down version of the video, it makes lags easier to see: # render with half-speed: final.speedx(.5).to_videofile("test.mp4")
You can stick it in a string with hex escape codes. 160 would be `'\xa0'`, if I can do math this late at night. See if your regex engine works if you just stick some of those in the literal.
Portugese and Spanish are pretty similar, but if I meet you at a Portugese event I'm going to talk about/in Portugese
If you specify `'utf-16'`, the native byte order is used. Since most machines that are likely to run Python are little-endian, that's usually fine unless you happen to be running Python on some non-Intel Unix platform or whatnot. You can specify `'utf-16le'` or `'utf-16be'` if you want to be explicit rather that using the native byte order. 
I think we have all done this. I certainly have! did a height map / topographical map (fake voxels circa 1997) and thought the problem was in my math. I used integer shifting and manipulation (penitum) vs float point vs MMX w/ qmov(P6) vs SSE coding (p4), SSE2 (P4). we used it for benchmarking and optimized the crap out of it, i rewrote memcopy for sakes... then i had to thread it :P one column just kept popping up to the top, it was unusable. took me about 3+ weeks to find out the MMX version screwed was screwing the float input using %.3f ... whole time one period. it only popped up 1-2 times a week. tl;dr; i too have been bitten by %.3f, life can be a bitch! 
My though exactly. 
...but they don't seem to have a problem talking about C, Haskell, Lisp, or really any other language. This issue seems unique to Ruby.
Python people are interested in doing actual work with Python :P
You do realize that I'm new and none of these are real answers, right? This is pretty frustrating.
Perhaps because Python and Ruby are so similar, folk have less reason to learn both. It takes a significant time investment to become fluent/idiomatic with a language, and I would (and have) chosen to invest that time in languages with different strengths. I don't have a problem with Ruby but have no experience with it and so have nothing to say.
Unforatunately it leaves a trailing \x00 at the end when using native (utf-16le) encoding. Here's the full exif data dictionary: &gt; {256: 5616, 257: 5616, 258: (8, 8, 8), 40091: 'h\x00t\x00t\x00p\x00:\x00/\x00/\x00w\x00w\x00w\x00.\x00d\x00r\x00e\x00a\x00m\x00s\x00t\x00i\x00m\x00e\x00.\x00c\x00o\x00m\x00/\x00-\x00i\x00m\x00a\x00g\x00e\x001\x001\x003\x000\x007\x003\x006\x004\x00\x00\x00', 262: 2, 40961: 65535, 296: 2, 34665: 504, 274: 1, 270: u'Young businesspeople having a coffee break, sitting at table in office lobby.', 40963: 5616, 305: u'Adobe Photoshop CS5 Windows', 306: u'2012:05:30 11:02:01', 40962: 5616, 277: 3, 36864: '0221', 33432: u'Copyright \xc2\xa9 Zsolt Nyulaszi. All rights reserved.', 283: (3000000, 10000), 282: (3000000, 10000), 315: u'Zsolt Nyulaszi'} Assigning x to the exif string, I get the following output &gt;&gt;&gt; x = exif[40091] &gt;&gt;&gt; print x # Correct only when printed, but unusable in string http://www.dreamstime.com/-image11307364 &gt;&gt;&gt; x.decode('utf-16') u'http://www.dreamstime.com/-image11307364\x00' &gt;&gt;&gt; x.decode('utf-16le') u'http://www.dreamstime.com/-image11307364\x00' &gt;&gt;&gt; exif[40091].decode('utf-16be') u'\u6800\u7400\u7400\u7000\u3a00\u2f00\u2f00\u7700\u7700\u7700\u2e00\u6400\u7200\u6500\u6100\u6d00\u7300\u7400\u6900\u6d00\u6500\u2e00\u6300\u6f00\u6d00\u2f00\u2d00\u6900\u6d00\u6100\u6700\u6500\u3100\u3100\u3300\u3000\u3700\u3300\u3600\u3400\x00' If this is just poorly encoded data then I'm happy with using str.replace('\x00', ''). If something is wrong in the encoding then I'm more than happy to learn something new.
Thank you. That makes sense. I started learning Ruby first, so when I'm learning Python, a lot of times I use references to Ruby and it feels like that's a problem in most cases. I realize that I probably have to stop doing this, but to me it feels insecure and it's really unnecessary, imo. Python is an awesome language. Learning both at pretty much the same time has helped my learning process, because they are so similar. Keeping track of the differences helps me to remember.
My opinion: Python is the better language due to it having a ton of libraries and basically a ton of support from major organizations. Basically, if the world were to vote on which language to kill it would be ruby. That said, ruby had a ridiculous surge in popularity in the mid to late 2000s due to rails making it really easy to write webapps. The python folk felt that was their rightful place and started getting jealous. Python folk hate ruby because it stole their thunder.
Thank you very much for explaining that. 
Strings in C are null-terminated, and it looks like whatever wrote this included the terminator. It may be necessary to delimit where the field ends, or it may be a mistake if there's also a corresponding length field. This has nothing to do with the UTF-16 encoding. 
I am not convinced that your experiences with Python users add up to a real trend that would survive a properly performed study. I don't doubt you've experienced what you say, but even several anecdotes should not be taken as evidence for a real trend. I know that's not a satisfying answer, and I don't fully expect to change your mind but that is what I believe. You might get a more satisfying answer by talking to the Python users at these meetups etc. Ask them what they think of Ruby and you might find some insight there. Online you're more likely to find glib and/or dismissive answers to these types of questions.
I started learning Ruby, in earnest in January, because my cousin told me that this was the language to learn about a year and a half ago. After I started learning Ruby, I talked to my cousin again and he told me to learn Python, because he said that people would stop using Ruby because of a security flaw. I was also told that you have to learn more than one language, anyway, so the best way to learn is to pick one language and stick with it, so I chose to continue with Ruby and tinker with Python, on the side. When I did this, I really started to enjoy working with Python, which led to me enrolling in Coursera courses in Python [there are way more Python courses on Coursera than Ruby]. So now I'm just at a point where I'm enjoying learning both. I picked up Objective C last week.
Thanks for that. I ended up using an .rstrip('\x00') at the end to trim off the excess.
I was speaking about my experiences only [not trying to suggest an overall trend], and these were at the meetups. I have actually found people online to be pretty helpful, which is why I felt like the people at meetups were being weird and didn't understand it. edit: ...but with all the people down-voting me even asking the question, I'm starting to wonder. Would they rather me not ask?
Jeez dude calm down. What do you expect us to tell you, python people hate ruby or something? There's a community war going on? That's silly. I don't know why ruby's never come up and frankly I think it's unfair to suggest that "every other language in existence is freely discussed but ruby is a forbidden word," as you do in your other comment. There's thousands of programming languages out there, I highly doubt ruby is the only one python people don't talk about. There's no satisfying explanation we can give you here, because there isn't one. Maybe python people tend to not learn ruby because the two serve similar problem domains, and are thus redundant. Maybe many python people don't like some of ruby's perl influenced heritage which is pretty contrary to python's "one way to do it" philosophy. Maybe ruby hasn't come up just by accident. Maybe one of the organisers in your area hates ruby with a passion for no good reason. Whatever the reason I can tell you there is no active effort in the python community to avoid ruby or something. If you think ruby should be discussed more why don't you bring it up at one of the python events you attend?
I have no idea how you got this far down in the thread and drew those conclusions. I have gotten what I feel was a satisfying answer: it's at the top.
Read source code of some open source Python projects (whichever gets your interest) just like you read a book.
That looks superb.
I would definitely be willing to donate what time I can (I can stand PHP for some reason either =D ) on a project but I am not sure I have the skills for it.
Thank you.
I believe the whitespace flag `` "\s" `` will match non breakable spaces. Another option could be to simply replace the nbsps in the string before doing regex on it, with ``mystring.replace("\xa0", " ")`` , of course I'm not sure on what your use case is and if you still need them in the output though.
I learned Ruby (and Rails) first then is currently learning/using Python. To me Python and Ruby are like Ryu and Ken. They can be the best of rivals, but can also have a mutual respect/friendship for each other. Warning: Street Fighter references are coming... Python is Ryu. Ryu means dragon in Japanese and the mythological beast Python is based-on is a dragon-like creature. Ryu is also known to be a more solid character than Ken. He's combos are not flashy but they work and do massive damage. Ruby is Ken. Ken means fist in Japanese and doesn't have something to do with Ruby (I got to say that). Ken is a more flashy character to play with. Someone may argue that Ryu should be Ruby since he is Japanese and Ruby was invented by a Japanese person. But... Do you know Ken is half-Japanese (Japanese mother)? Ruby is half-Japanese half-western since it was originally in Japanese then translated to English. 
I know both and both are quite similar but Ruby's culture of programming is the opposite of Python's. Python has its PEPs and usually one clear way to do things cleanly, Ruby is more like wild west with monkey patching as not just acceptable but often preferred solution.
Can I double vote your answer? 
This answer is based on python 2. String handling has changed a bit with python 3, so if you are using that, please say so. Are you familiar with the difference between unicode objects, and byte strings that contain a utf8 encoded representation of unicode? If not, this will help you understand the situation. A unicode object is a series of codepoints, each of which (usually) represents a glyph or character. How that codepoint is represented in memory is undefined and unimportant. If you have a unicode object that contains your non-breaking space, you need to match it with a unicode regular expression. As an aside, unicode objects are usually refered to by the hexadecimal (base 16) representation of their codepoint. So get used to using that instead of the decimal version. Instead of a non-breaking space being unicode value 160, think of it as being value U+A0 (or 0xa0 or 0xA0). The U+ marks it as being a unicode character. The 0x is a common programming convention for marking hexadecimal numbers in any context. In either case, the important part is what comes after those first two characters A utf-8 string, on the other hand, is a series of bytes that represents a unicode string, encoded in a particular way. Each unit is not a codepoint, but a byte. Some codepoints are one byte long, some two, three, or even four bytes long. A non-breaking space is made up of two bytes: 0xc2, 0xa0. So in order to match a non-breaking space, you need to match those bytes, in that order. If you are trying to match against a string (of bytes), you should build your regular expression as a string (of bytes): re.compile('\xc2\xa0') If you are trying to match against a unicode object, you should build your regular expression as a unicode object: re.compile(u'\xa0') Mixing the two is likely to lead to unexpected behavior. Alternatively (and this is the better choice most of the time), if you have a bytestring, you can decode it from utf-8 to unicode, and then match it against a unicode regular expression: import re string = '\xc2\xa0' unicode_object = string.decode('utf-8') re.search(unicode_object, u'\x0a') There are other ways to decode unicode. You might have a latin-1 string, for instance, which decodes any unicode character up to U+FF with a single byte having the value of the codepoint. latin-1 will fail with any codepoint &gt; U+FF. If you have a bytestring '\x0a' encoded in latin-1, you can get a unicode object from it like this: string = '\x0a' unicode_object.decode('latin-1') The tricky piece is that a string is just a series of bytes. It doesn't inherently "have" a particular encoding. You either have to carry that information alongside somehow or make heuristic guesses as to what encoding is being used. **Edit:** Fixed erroneous raw string literals. Thanks /u/chipaca 
%f 3 actually means %f (default 6 digits precision) followed by a literal 3 - which is why all numbers are not just 7 decimal places but also not so coincidentally end in 3. The formatting options for width and precision need to be after % but before the f. For example %10.3f will make the output at least 10 positions wide (spaces added on left for numbers to comma &amp; right align) with 3 digits after decimal point. If width &amp; right alignment do not matter at least the %.3f part needs to remain for digits after decimal point. 
 ^Before ^this ^was ^done, ^you ^couldn't ^find ^any ^articles ^on ^the ^page ^as ^everything ^else ^was ^so ^much ^larger, ^from ^the GIGANTIC MENU FONT ^to ^the BUTTON TO SUBMIT A NEW LINK +1 our bold article link overlord 
Totally with you on this. Decorators have their place but they should be used sporadically. There are better ways to achieve the same result if you're using them a lot, namely inheritance and meta-classes. Python should be clean and simple, easy to read, and there should be few surprises.
I use [vagrant](http://www.vagrantup.com). For everything. So I have a vagrant machine and the instructions to build the environment live either inside the specific project (for big projects) or in a general purpose vagrant repository. Therefore, setting up the enviornment means installing VirtualBox and vagrant, cloning that repo and doing a `vagrant up`. I can run the exact same stuff on my work PC with Windows and at home with Linux.
Yay! There are some very interesting ideas here. So many ways to spin this ~~data~~ anecdote. I love this kind of questions, because suddenly, we are forced to examine our biases and internal attitudes. The first reaction I had was: Well, since Python and Ruby fulfill somewhat the same role, there is little incentive for Pythoneers to venture into Ruby territory. But then on the other hand you mention that Rubyists seem to regularly talk about Python... So after some thinking, a somewhat masturbatory answer that came to mind was that maybe Python has more mindshare overall than Ruby does and thus people would talk about Python at more meetups in general whereas Ruby would only be talked about at a Ruby meetup. Since I'm also not satisfied with that answer, I'd say that it could be a fluke. My experience is that local meetups tend to be a social clique and if some of the members of that clique don't like Ruby and tend to flame any discussions of it, it would follow that Ruby isn't discussed much. I don't think there is enough data to form an educated complete big-picture opinion on why you experienced what you did. But there is certainly some truth to what people have been saying. I think the so-called rivalry between Python and Ruby is fought by a minority on either side (or maybe only by a minority on the Python side. I don't know the Ruby community well) One important thing: If the overall attitude of the meetup group or user group is poor or hostile, I stop going there. I have observed that with several user groups and it didn't always go hand in hand with the attitude of the respective community online. YMMV and have fun coding RuPython, I mean PyBy, I mean Ruthon, errr... ok the joke has run its course.
It's the internet, specifically reddit. Hotheads gonna ~~hothead~~ downvote. :D I enjoyed the question. 
My experience is very different, Python devs I know tend to use the best available tool for the job, even if it's not in Python (e.g. Node.js for a trivial MongoDB interop). Not sure why you mention Ruby, as there are also JS, Perl, PHP... I don't see how Ruby stands out.
What does "allow" mean? Because it usually just works, as long as you're working on unicode strings and not bytes -- more so in Python 3 than in end-of-the-line Python 2, but in both you can just ask for it: &gt;&gt;&gt; s=u"This is\N{NO-BREAK SPACE}all ok" &gt;&gt;&gt; re.findall(u"\N{NO-BREAK SPACE}\\w+", s) [u'\xa0all'] (note you can't use r"" strings and then expect escapes to work).
&gt; I believe the whitespace flag "\s" will match non breakable spaces. It does, but only in python 3, and on strings but not bytes. The latter is expected. The former just is.
Thank you.
Thanks.
I was introduced to programming with dynamic languages via Ruby and later found out about how awesome Python is. Yet I don't consider myself solely a Python programmer or a Ruby programmer â€” I'm a programmer. I think it's human nature for people to compare things that are similar to each other. In our case Python and Ruby. And when people compare things they usually pick a side. Picking a side can be to our advantage if our personal interests are at a stake, but closing our minds to another programming language (before we have tried it) can be to our disadvantage. Learning another programming language can expand our world-view to what's possible. To me learning Python made program better in Ruby and vice versa. Also, when you learn to know your former (perceived) enemy you may find out that he/she ain't that bad after all. You'll won't be feeling pissed-off when someone mentions (insert programming language here} in a forum or blog post. Reading something on the net... Python... that's cool! Ruby... that's also cool! Perl... well.... (just joking :) Perl is also cool! They are all cool! The world is a better place because of them! 
not sure why this was downvoted.. it's right... 
&gt; edit: nice. Down-voting me for asking a simple question. I'm not interested in seeing such content here and I'm using the downvote button for its intended purpose. Also, people "being weird" for never bringing up Ruby at random? Heh.
Yes I was on Windows but will be moving to Linux again - maybe it was just that the initial Windows setup was fairly tricky - making sure I had both 2.7 and 3.3 as well as all the packages installed.
But it is not an answer to the question which was asked.
Will give it a try - so you don't have any other stuff you configured from default - scripts, utils etc? 
I am not sure exactly what sort of response you are execting to your question, as it is very ambiguous. If you are using mysql, you can output csv directly. That may be of help to you. http://www.tech-recipes.com/rx/1475/save-mysql-query-results-into-a-text-or-csv-file/
show your working
Never tried to use, but it depends what you want to do. Unity is a good engine, but not for small games I think. You can build a chess game with SDL, it's more easy. :)
Is it though? I mean it barely works. There are a lot of tools to read the Captchas but why bother when you buy Captcha translations for few cents per Captcha done by some low paid workers in Bangladesh and it takes only few seconds. 
1) Use whatever language you like. They are all the same really. 2) I notice equal levels of (in)tolerance in most communities. Some people don't mind, some people get angry. 3) Why do you feel the need to mention this issue? You already know the answer to the question. User X likes product Y and therefore uses product Y over product Z. In some cases user X regards himself as a proponent of Y, and therefore product Y becomes part of who he is. Therefore any reference to an alternative product is seen as criticism of his lifestyle and he will *invent* reasons to defend it. A 12 year old knows this. What is your objective, if not to cause a reaction? While you are at it, why don't you write to Microsoft and ask them about Apple, Linux and Android?
Ah yes for me the sound wouldn't be as useful... the sound tracks are vastly different for each file (cockpit audio versus whatever sounds you pick up being strapped to an undercarriage). What I ended up doing was: - Trying to start both cameras at the same time (would be within 2s) - Immediately have them both film a high precision timer on my phone. (And by "high precision" I mean something that depicts milliseconds.) I then used pyffmpeg to dump a few hundred frames of each stream -- find a good source frame from one feed, i.e. where you can clearly see the millisecond tick over perfectly between that frame and the previous one... I'd then hunt through the other frames to find the equivalent timepoint, and from there, I'd have my offsets (frame number for each film, and time offset). Problem was, I didn't see an easy/obvious way to take that information and feed it into something that could then automatically sync/cut as necessary. That's the point I was like, meh, deferred. I think I might spin it back up again -- everything else you've shown would be awesome, once I've got the two streams in sync.
I'm not sure this is a terribly helpful answer, but:) I spent a year or so using ReportLab to generate PDF formatted reports from a web application, and overall it wasn't a very pleasant experience. The documentation seemed to be patchy and badly organised, and I had to dive into the code a lot, especially whenever I get near 'the edge' of what it could do. It felt to me that it was a package that someone had written to cover their own use cases, and that it was never really finished (BTW, that's not really a criticism, just an observation). More recently I've been looking at PDF report generation for a different web application which already generates a lot of reports in HTML, and I've found weasyprint (http://weasyprint.org/) to be very good (though its a bit of a shame having to include so much other stuff to support it).
yeah i've had to dive into the code, but i wish there was a better way. Thanks anyway
Thanks
Why has already been answered. As for how, it's a community knowledge thing. You can Google libraries but Google can't tell you if the library is any good. I would recommend asking "what library should I use to do XYZ" on this subreddit, or in #python on freenode IRC.
Yeah, i feel the same, i've heard this was the definitive tool for what a wanted to do, and i'm disappointed that the docs are so lacking. Anyway i'm not trying to convert from css/html, i'm generating them directly so i'm not sure if weasyprint can't help me much. Thanks anyway
Thanks, I will try to get into the habit of using with.
These both support SQL and CSV. http://dataset.readthedocs.org/en/latest/ http://pandas.pydata.org/pandas-docs/stable/io.html
You were just being a dick by showing the answer without answering OP's question.
It's UTF-16 so every encoded character is either one or two code units (2 or 4 bytes).
I didn't know either unipath or path.py and they both look really cool! Thanks for sharing!
The whole theme is messy at best but somehow it went through :(
Derp. Thanks. I've fixed it. 
The null bytes aren't garbage, though. As other answers have explained, this is UTF-16 encoding, and the characters in the example just happen to be all ASCII characters for which the first byte is the same as in ASCII and the second byte is zero. If you came across an entry containing a character outside this range, your approach would yield wrong results.
try using the ennumerate function since it returns both list members and their corresponding index. It lets you write a more C-style for loop without resorting to keeping track of your own counter variable for index, item in ennumerate(csv): print item print csv[index+1] http://azitech.wordpress.com/2011/07/06/pythons-enumerate-function/ 
For most uses, RabbitMQ is simply not worth the trouble to setup.
[HN discussion](https://news.ycombinator.com/item?id=7909201)
 iterator = iter(csv) for X in iterator: if X == 'Name:': print X, next(iterator) Why do you want to print the `Name:`?
(I assume Python 3) There are several ways of approaching it (including using itertools, etc): Here are 2 ways: Using "next": for X in csv: if X == "Name:": print(X) print(next(csv, "")) Classic flag: found_flag = False for X in csv: if found_flag: found_flag = False print(X) #next X else: if X == "Name:": found_flag = True print X 
But what's there so setup? It just works (tm). Also if you take into consideration containerization tools like Docker that give you images with rabbitmq out of the box, there really is no excuse. 
[citation needed]
just for understanding: in case the last entry would be 'Name:', would it print "Name:, "? edit: I just read that op does not want to print the 'Name:' part. would you still use a similar approach or something else (I'm asking you because you seem to have a decent understanding what the better practices are in python)?
It's a fairly common thing to want, and generally referred to as a "sliding window". (Ie. rather than iterate through each element, you iterate between a sequence of elements (here 2), moving the lowest one up one time. There's a bunch of recipes you can probably find if you google "sliding window python". The simplest case (just supporting 2 items) would be: def window(seq): it = iter(seq) prev = next(i) for cur in it: yield (prev, cur) prev = cur Which would be used in your example like: for X, next_x in window(csv): if X == "Name:": print(X) print(next_X) Of course the immediate reaction to that code for a programmer is to generalise it. Why only a function that looks one ahead? A generalised version that looks 3, 4, 5 or any arbitrary N ahead might be useful. That's why you'll generally see something a little more complex, like: def window(seq, n=2): it = iter(seq) current = tuple(itertools.islice(it, n)) if len(current) &lt; n: return # &lt; n items. yield current for next_item in it: current = current[1:] + (next_item,) yield current One other thing to mention is what the behaviour should be when you reach the end of your list and hit the last item (which doesn't have a next). Should this be returned with some placeholder value, or just be omitted? Ie. if you have the list [1,2,3], should you get: 1, 2 2, 3 3, None or just: 1, 2 2, 3 The usual approach is the latter (and that's what the above do), but you can turn this into the former just by appending a sufficient number of None padding elements to your list if needed. Bear in mind that a special case of this is a 1 element list (or a &lt;n element list), which will basically return you no items (since there's nothing that has a next element in it)
Great! I was hesitant a little, I found their price a little high but I've only heard positive reviews and comments, I'll definitely look into it! 
 for x, x_next in zip(csv[:-1], csv[1:]): if x == 'Name:': print x, x_next 
Note that this should work if the print statements are wrapped in a "if x=='name'" statement, and it is never the case that the last cell is 'name'. In general, this method will throw an index error, because you cannot examine the next index of a list when examine the last index. 
No.. not it doesn't. Maybe if you're familiar with setting up Java apps it's easy. But there's no up-to-date RPMs, no `pip install` type functionality. Redis was significantly easier to install -- and I tried RabbitMQ first.
You could try using regex and treating the file as flat text. Maybe something like: import re with open('test.csv', 'r') as file: for line in file: search_obj = re.search('Name:(.+?,)',line) if search_obj: print(search_obj.group().split(':')[1].strip(',')) **edit** fixed regex for better matching. Or, my first thought was to use awk: BEGIN { FS = "," } { for (i = 1; i &lt;= NF; i++) if ($i == "Name:") {print $(i + 1)} } 
&gt; Iterating over a csv.reader() called on a file handle will be very memory efficient. Efficient or inefficient? Is the process for iterating over the reader() very different from iterating over a list generated from the csv file?
Python 2 vs. Python 3 split?
Oh, awesome -- I'm glad to know the name going forward, thanks!
Nope. for row in csv.reader(...): # do thing with row
thanks for the explanation!
 l = [csv[idx + 1] for idx, fld in csv if fld == 'Name:']
You're really just reinventing `islice`: from itertools import islice for x, next_x in zip(a, islice(a, 1, None)): ... If the iterable supports slicing then you can even just go ahead and do `zip(a, a[1:])`, although this will make a copy. 
http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html http://langpop.com/
 [x_next for x, x_next in zip(csv, csv[1:]) if x == 'Name:'] would also do the trick
Look at how the script is being executed in the example. $ python ex14.py zed Are you providing the extra argument, 'zed'?
I installed it with apt and had zero issues. It just worked.
You're typing too much. perl -lne "m#Name:,([^,]*)# &amp;&amp; print $1" file.csv 
&gt; When you run this, remember that you have to give the script your name for the argv arguments. 
Typo: `s/ennumerate/enumerate/`
Second Post because, well, you didn't even read the rest of the exercise &gt; **Common Student Questions** &gt; [...] &gt; *I get the error ValueError: need more than 1 value to unpack.* &gt;Remember when I said you need to look at the What You Should See (WYSS) section and replicate what I did? You need to do the same thing here and focus on how I type the command in, and why I have a command line argument.
Sort of. It copies the list twice, which will use more memory, and if the lists are long enough, it'll be noticeably slower than if you weren't copying. But with modern computers, the list can be pretty big and it will still work well enough. My first thought was to use enumerate() though. It works just as well and avoids the copying.
It sounds like you actually don't care about the "Name:" lines. You already know what's on them and it's redundant. What I would do is just cut out those lines and loop over the other lines. for x in csv[1::2]: print x The 1 in the square brackets means start at index 1 (i.e., skip the first line), and the 2 means to only include every second row (so it alternates, skipping the "Name:" lines but not the other lines). Also, uppercase variables are bad style. Although, honestly, this is what shell scripting is meant for. grep -v ^Name:$ foo.csv
Slight correction... In utf-16 most characters are 2 bytes, some are 4 bytes (using surrogate pairs.) It's a common misconception that utf-16 is 2 bytes.
They're in separate rows, so I don't think grep would work here, right?
Bullshit.
grep -v would simply filter out the lines that have "Name:", and would print out all the other lines.
I've found lxml to be a great and easy to use scraping library.
Does anyone have suggestions for solutions that involve non-python dependencies? I can't just pip freeze my venv because setting up a project environment often involves many non-python dependencies.
* Discover list comprehensions * Discover generators * Incorporate map, reduce, filter, iter, range, xrange often into your code * Discover Decorators * Write recursive functions, a lot * Discover itertools and functools * Read Real World Haskell (read free online) * Rewrite all your old Python code with tons of higher order functions, recursion, and whatnot. * Annoy your cubicle mates every time they present you with a Python class. Claim it could be "better" implemented as a dictionary plus some functions. Embrace functional programming. * Rediscover the Strategy pattern and then all those things from imperative code you tried so hard to forget after Haskell. * Find a balance.
Right, but there are lots of lines I don't want.
The problem is that when I try to run it like that my command prompt instantly closes as I try to open it.
The problem is that when I try to run it like that my command prompt instantly closes as I try to open it.
I just stumbled upon "bpython" and was wondering if someone has some experience with using it? If so, how does it compare to IPython?
Well hell, I didn't know the answer, I was just trying to be helpful by possibly uncovering a small piece of the puzzle.
That's pretty neat. I hadn't been aware of that parameter to deques.
The mod responsible for it did an usability study with 43234653645 subjects and found a p&lt;10**-765567756 that shows this design is so great. But he won't show you how his study was carried.
You're certainly right. I was moreso responding to the overly broad and categorical claim that "it just works" and "there really is no excuse". 
I am not familiar with buildout. virtualenv always felt clunky to me, but [mini]conda is just right. Are you familiar with [mini,ana]conda and can compare them to buildout?
This is one of the neatest uses of zip I first saw for x, next_x in zip(y[:-1], y[1:]): print x, next_x itertools, especially izip if the lists are big, is probably the best way to go long term, as others have shown, but I always liked this for simplicity. Edit: Ha, answered before I read the whole question. Bad form.
Why would you immediately encode to UTF8? Standard practice is to decode to unicode when the data is received, work internally with unicode, and then only encode on final write as the data leaves your application. This is in order to keep things internally consistent in your code and avoid you having to throw in almost random encode/decode calls everytime you want to use the data or debug the program.
looks cool: ipython notebook style in command line
There's also now [bipython](http://bipython.org/), a bpython frontend talking to an IPython kernel (so you get IPython things like %magic functions and !shell commands).
Ill give them a read but the project is due in 2 days, i was swamped with all the other work i kinda forgot all about the python one. Thats why i added my skype id so i can ask questions and get replies quicker. But thanks for the help ill give those a read after i finish my game :D
I used Tinker for awhile then switched to Qt5.2 and after 5 months switched to Kivy which I think has the best mix of ease of use, cross platform support and quick development times. If you are only going to do desktop development then QT and its derivatives may work for you. But try writing android, IOS and windows 8 applications and you will find it takes much longer to produce working code. Kivy has lots of pre-built widgets that you would have to develop yourself within your android app. Kivy handles the different screen resolutions far better than the PYQt, QT. And the really big win is the ability to put trace points anywhere within your application and figure out what's going wrong. I find that apps get developed 4-5 times faster with Kivy than the QT and its derivatives. And the fact that these developments port far more easily across all platforms is what won me over.
No.. what made you think that? It's a pretty good system, it's just more complicated that Redis, would you disagree?
Did a quick comparison a long time ago, less features but much smaller/lighterâ€¦
This is also an example recipe in the [Python itertools documentation](https://docs.python.org/2/library/itertools.html#recipes). Itâ€™s called `pairwise` there.
There's also [plumbum](http://plumbum.readthedocs.org/en/latest/local_machine.html#local-paths), which may do too much if you're *just* looking for path stuff. For me, it's great to have all the junk it does together in one package.
Looks like UCS2.
 final_list = [next(iterator) for X in iterator if X == 'Name:'] You could replace 4 lines with the above list list comprehension, to do the list construction more pythonically. I actually think it's more clear too, after you get used to reading them.
It really looks the best of both world but on my machine it fails launching properly sadly.
What you're using? Some source is good to see what you need. Here a C++ OpenGL Snake game (not finished yet) https://github.com/alexandrevicenzi/SnakeGL and https://github.com/alexandrevicenzi/gcw_battery is a GCW application using PyGame.
This page might help answer the question: http://docs.scipy.org/doc/numpy/reference/arrays.html In short, ndarrays have a (void*) data buffer, plus a pointer to a data type code, an array of dimensions and an array of strides which define how this buffer should be translated into a multi-dimensional array.
For free? Maybe, if you have majority of the code already written and need help with something like exceptions and similar stuff.
I need something that doesn't require my project live inside a virtual machine. These tools are great when I can use them but far too often I need to deploy to an environment where I can't run a VM, or I need access to specific hardware in the host machine (eg. a GPU) which isn't available inside a VM. Compute performance is also not as good inside a VM.
I've been using it for about a year, maybe more. I'm not using heavily, I have an editor for real code. But for quick experiments, it's great. Much simpler than ipython, and the code completion and auto documentation work great. I usually use it when I take a new library out for a spin, evaluating options, trying complex one liners, etc. 
That's all very true, especially if you have to access hardware inside the VM. That throws Vagrant right out the window. However, Vagrant is only responsible for the VM. Puppet/Chef/Ansible are what you'd use for the actual provisioning - and they'd still be worthwhile for making sure your development environment matches what you'll expect in production.
I don't know how I have missed that reference. That answers my question. Thank you!
This is awesome! I was always wondering if this was possible with Python. Anyone have some source code? I'm a little too inexperienced to code up a comet hunting program. I wish I could. But after all my self-teaching of Python, I still don't think I could do this. Or even come close.
Vagrant looks interesting, thanks for that
/r/learnpython
The numbers here are a little off. Edit: I only tested with 42 billion people, not 43 billion.
When asking people for programming help its a good idea to explain in what way something isn't working or to give the entire traceback for any exceptions. So...in what way isn't it working?
Thanks. I am rarely using the IPython shell, but I am a big big fan of IPython notebooks. So it sounds like it is a nice tool, but a little bit less and more lightweight compared to the IPython shell. I think I should just check it out and see how I like it :)
Just "append" to the deque. It will remove the older item from the iterpair and add the new one to the end.
I thought there was only one column. My bad.
Congratulations on reaching this milestone! [continuum.io](http://continuum.io) are thought leaders and your dedication to the Python community is much appreciated. 
You can get ipython notebook in console style by running "ipython" (minus the "notebook") You can get it in IDLE style by running "ipython qtconsole" fwiw. 
Thought leaders - yeuck
And dump out a copy of the list? That's super ugly, now you have three copies of part of your iterable around: the original list, the deque, and the copy in the window. You're saying to do this, right: def window(iterable, n=2): d = collections.deque(itertools.islice(iterable, n), maxlen=n) yield list(d) for i in itertools.islice(iterable, n, None): d.append(i) yield list(d) That seems so much sloppier than a solution that just uses iterators on the iterable? edit: working off the `pairwise` implementation in the [itertools docs](https://docs.python.org/2/library/itertools.html), how about: def window(iterable, n=2): iterators = itertools.tee(iterable, n) for i,it in enumerate(iterators): for i in range(i): next(it, None) return itertools.izip(*iterators) Now all you've got is n iterators lying around, no data duplication. edit 2: some googling shows Nick Coghlan suggesting a neat simplification: def window(iterable, n=2): iterators = itertools.tee(iterable, n) for i,it in enumerate(iterators): for _ in itertools.islice(it, i): pass return itertools.izip(*iterators) edit 3: followed by [Raymond Hettinger suggesting that it's stupid to do it this way](http://www.gossamer-threads.com/lists/python/dev/491090#491090), and that you should use indexes. *shrug* I [quote](https://groups.google.com/forum/#!msg/comp.lang.python/jA48K6ea1G8/z77E7vmobQIJ): &gt; itertools.window() with n&gt;2 was also rejected. While use cases arise in markov chains, statistics (moving averages, etc), and cryptanalysis (trigraph analysis), there were almost always better solutions. window() spent most of its time creating new tuples and shifting each of the common elements by one position. A solution using collections.deque is generally superior because the popleft() and append() operations do not entail moving all the common elements. I stand corrected! edit 4: Which finally leaves us with, due to Nick Coghlan: def dwindow(iterable, n=2): itr = iter(iterable) current_window = collections.deque(itertools.islice(itr, n), n) while n == len(current_window): yield current_window current_window.append(next(itr)) Thanks for spurring me to read up!
I know. Apparently it was actually just a problem with my setup that inhibited me from working with argued variables. I had to re-check the setup of [learn python the hard way](learnpythonthehardway.org/book) and once I fixed it, it was all good to go. Thanks for the help though!
I've used it at work for over a year- CentOS 5.6 It's missing the magic functions of iPython, but makes up for it by displaying docstrings and being a really friendly way to work through modules you're not familiar with. It has the following annoyances: * Takes up the entire shell like vim etc. * The rewind feature seems unbelievable cool at first but you realize it's pretty unreliable and stop using it. * No one at work but you likes it
I'm not that great with Python but what immediately leaps out is that you have single quote marks around the x, so it's looking for files that literally end in x, not in the current value of the variable x. If name.endswith('x') there ^ It should be If name.endswith(str(x)) You should be careful because your test is very broad and will rename files with names like 'SOMETHING5'. Perhaps you should make the test stricter by making sure it's only the file extension that's a number, and that it's a single digit?
I like an initial priming pass, so you always get at least one window (even if the iterable doesn't have enough items to fill up the window). As a bonus you get to move that `if` test out of the main loop. import collections def window(iterable, n=2, fill=None): it = iter(iterable) d = collections.deque((next(it, fill) for _ in xrange(n)), maxlen=n) yield tuple(d) for item in it: d.append(item) yield tuple(d) for x in window([1, 2, 3, 4, 5]): print x
You can do stuff with pyephem to do basic astrometric calculations. I use it all the time to calculate alt az of stars based on my lat long
On my phone right now, but it looks pretty good. How long have you been coding? There's no way I could make this, but hopefully one day I'll be able to. Also, I'm unfamiliar with github, but am I under the right impression that it's for sharing open source programs, and I assume someone could change something, submit it to you, and then you could put it in the official file. Is that about right?
That's correct. Github offers free public repositories, managed by git, a distributed version control system. It's how people keep track of changes, and collaborate when programming. Basically, the code is at a certain state. It is a series of patches... patch A added this, B this other feature, and so on. So the code might be at version 5 which is patches A-&gt;B-&gt;C-&gt;D-&gt;E Two people could take it at v5 do some work, and create a patch. Person one makes F and person two makes G. At some point, person 1 decides to pull the changes... he sees there are none, so he applies his patch to the origin "branch" and pushes it back. Now the git repo has ABCDEF. Now person 2 pulls all changes, and he sees F. He merges F into his current local repo on his computer, and that has the series of ALL the changes. He pushes it back to origin. Now whenever anyone looks, they can see who did what and what changed. Someone else can come along and "fork" the project if it's public, and then make their own changes and submit a pull request, which asks the original owner to look at their changes and decide if they want to pull them in. This is how collaboration is done in a professional environment. I highly recommend checking out git. Another similar tool is mercurial.
That actually sounds like a lot of fun. Is there much for basic projects to contribute to? I may be able to help with this but I'm not sure if I understand it completely. 
I'm curious about your process and how much experience you've had with Python and PyGame. What version of PyTMX were you using? I have next to no experience with it, but it *seems* like there is support via pytmx3: https://github.com/bitcraft/PyTMX/issues/20
Welllll... It might be a bit difficult to just find a project and contribute out of nowhere, without much experience with that sort of thing. You should [check this out](http://pcottle.github.io/learnGitBranching/) and get familiar with it. Try creating a few projects on your computer first. You don't need to use github. You can just `cd` into a new directory, type `git init .`, start coding, then `git add $file` and `git commit -a` and write a "commit" message, which is the description of the patch. The workflow is to initialize a git repo, add files, commit them (creating a patch), make changes, commit them, and so on. Next time you work on a project, try using git. Or continue old projects you have and make git repos in them, and track new changes. If you're in school for programming, I recommend using git/mercurial for all school projects so you get up to speed. It'll be extremely useful. Honestly, mercurial might be a bit easier to learn but git is well known. The common saying is "commit early, commit often". Commit when you've made decent changes, and don't go so far that you commit a huge changeset that is impossible to read. Each change should be easy enough to skim through to see what happened.
I used a basic dictionary that I passed around. In tools.py in the data directory, you can see the initial dictionary loaded at the beginning of the game. I don't have any experience using databases but I'll definitely look in to that. Thanks for playing my game!
No problem! If you're new to SQL (I am still pretty new but I've used it for a few months now) check out my sqlite3 wrapper: https://github.com/panchr/PySQLite It's not perfect of course, but it's getting there :) --- if you're going to try it, I would wait until a bit later tomorrow; I added some updates today but it's pretty late so I didn't commit them to the repository
I've dealt with this. But it's not just Python 3. See [this open issue](https://github.com/pypa/pip/issues/1137) for Pip, only affecting Python 2 users. Are these failures when loading a text file? Or when loading a Python script itself? I'll just assume text file, but feel free to tell me if I'm wrong. Anyhow, one solution: use [cchardet](https://pypi.python.org/pypi/cchardet/). It is fast and effective. If you want a pure Python solution, use [chardet](https://pypi.python.org/pypi/chardet). It is slow and written in Python. Here's another option. It sounds like you know the encoding of the file. Great! Do this: # or whatever encoding you actually used with open('filename.txt', encoding='iso-8859-1') as f: contents = f.read() # write the rest of your code here! 
Looks neat, I really appreciate that they put an alternatives page on there as well.
Python 3 doesn't let you play fast-and-loose with encoding like Python 2 does. Python 2 will practically ignore file encoding, and just leave garbage like `\xe9` in your file that gets written out as a byte to the output file (if you're reading text and saving it). Nothing can parse it, you can't regexp for matches on it, but it just ignores the fact that there's an incomprehensible byte in your input data since it's just a bytearray under the hood. Python 3 uses real unicode strings, so you need to get the encoding right or it `UnicodeDecodeError`s like a real high-level programming language should do.
I've been coding with Python and Pygame for about a year. I'm not sure what you mean by process. I use the main branch of PyTMX. I know someone else who was trying to get PyTMX to work with Python 3 (even using the pytmx3 branch) but they had trouble with it. I haven't investigated it further.
I've been wanting to write a small game myself for quite a while now. Projects like yours really encourage me to finally start doing it, I hope :-) Thanks a lot for sharing, great work!
I would high five you, but my wrist is killing me.
thanks this helped
I'm using Python 2.7.7, (should have mentioned this). The '/s' does not work here.
Such a PITA. I'm doing some web scraping and everything will work until I try to print or dump the data to a csv. I basically have to try to print each piece of data, and when it can't print it, I catch the exception and print it letter by letter and remove the one that raises an exception. Some of them are understandable things like the ^TM symbol, but randomly there will be a weirdly encoded hyphen or accented vowel. Those should be fine, but apparently not.
Any reason why you're not using [bintray](https://bintray.com)?
`[:-1]` might be semantically better here. We're expecting exactly one null terminator.
If the full extension is just the number, you should include the dot of the extension in the search and replace strings.
I was disparaging the terminology rather than the sentiment :p
I don't read goodly.
aaaaaannnd... that is why I would never use Windows for developing software.. unfortunately some of you have to.
Except that you're using `endswith()` so your string doesn't pass the check to begin with.
This sounds very useful for WIP web apps, to fill in the gaps in order to achieve a plausible presentation. I like it and will definitely try it out over the next few days. 
Are you aware of the 'errors' parameter to [decode()](https://docs.python.org/3/library/stdtypes.html#bytes.decode)? Either 'ignore' or 'replace' might be what you want, according to your exact usage.
&gt; What do you mean with "such content"? Ridiculous flamebait.
Yea, it's basically the same thing. The dir for that would look like \Portable Python X.X.X.X\App\Lib\site-packages\libtcod\
The nice thing about this library is that it generates all manner of non-English data, too. If you've only tested your code with ASCII, you haven't tested it properly. 
I just finished the game. There were no crashes or bugs. Thanks for 30 minutes of fun.
So will this help with compiling a library A (which has some set of Python bindings that I want) that in turn requires other libraries B,C and D to be present in the system? Traditional systems like apt-get etc deal with this quite well, but having this sitting on top of it looks quite daunting, although quite necessary.
Thanks good catch!
It depends on what you mean by "help with compiling". This is a package repository for pre-built packages, so it's meant for install-time and not necessarily build-time. There's nothing preventing people from making source packages with development headers etc., but that's not really the common use case that we're imagining. Basically, the goal is for people to be able to contribute to a binary package ecosystem like CPAN or CRAN, so they don't have to wait for Continuum to cut a build of package &lt;X&gt; and then upload it into the Anaconda repo. Developers can make their own channels, upload nightlies or dev builds, and tell their users "conda install -c &lt;foo&gt; mypackage", and it will work. For your specific question, it depends on whether B, C, D are have already been built and packaged up. If so, then binstar can absolutely help. Since conda can be seen as a cross-platform rpm, you can definitely think of Binstar as a cross-platform yum repository.
Binstar supports conda and PyPI, which are great tools for Pythonistas. It looks like Bintray supports maven, gradle, yum, and apt. Not so good for Python folks. :-) 
Haha! Read what I wrote: "You have a grammar errors on your page." Sorry man, I'm completely stupid. Have a good day.
Yeahhh... about that. Pyephem will not install at all. I keep getting errors, and it doesn't exist through some popular package managers. I wish it did.
Read the sidebar, go to /r/learnpython, read the sidebar there.
What OS are you using? I'll just save you trouble if you're on a Mac - it doesn't work.
Python,C# and Java are great languages to start with. I would recommend Python, Python is very easy to learn. Go to python.org and download the Python 3.4.x installer( https://www.python.org/downloads/). Watch a few tutorials on python on youtube, search for "python beginner tutorial". This should get you started. Edit: http://youtu.be/IX6mc9l6tY4
Win 7 for the most part. So no problem with me - but thank you for saying that!
Perfect, let me try it!
I like Psychology and thinking about mindshare. The interesting question is not how this group of people managed to get through an evening without mentioning Ruby, that task is obviously facile. But somehow there was a perception of animosity that sparked this discussion and from the answers, I don't think it's entirely unfounded. I find that fascinating. That's all.
On what/where are you hosting your blog? Did you notice any downtime or problems because of the overload of traffic?
I am using the ghost blog platform and using there hosting. Didn't notice any problems it's been great thus far.
I was secretly hoping you were running it on a DO droplet. I'm running my (Ghost) blog there and it would be pretty cool if that could handle the HN frontpage load. Doubt it can though :)
Ok so it doesn't work. I did exactly as you said (the path is: C:\Users\RudolfAn\Portable Python 3.2.5.1\App\Lib\site-packages\libtcod\python\python.py) but I am getting this error: Traceback (most recent call last): File "C:\Users\RudolfAn\Portable Python 3.2.5.1\test2.py", line 1, in &lt;module&gt; import libtcod as libtcod ImportError: No module named libtcod the file only contains: import libtcod as libtcod * EDIT: I also tried deleting everything else so having only three files there with C:\Users\RudolfAn\Portable Python 3.2.5.1\App\Lib\site-packages\libtcod\python.py (still doesn't work).
Damn.. can't seem to brew install pygame on Mavericks (Python 2.7).. Anyone met and fixed the "ld: library not found for -lSDLmain" issue? I tried quickly googling around, to no avail..
Yea, I beat my head against a wall for a few days a while back trying to get libtcod working on my wife's MacBook while we living in a hotel room for a month. I figured "Hey, why not learn about roguelikes and get some more python practice in..." Yea, if you want to use Python and libtcod on a Mac, you're gonna have a bad time. That being said, the little I worked with it in Linux was fun.
I had a similar problem with ruby once. Fortunately for me [it's a bit easier]( https://github.com/xiongchiamiov/englify/blob/master/lib/englify.rb ) to monkeypatch there.
looks very promising ... hope to test with reality soon 
This has nothing to do with playing fast and loose, and everything to do with the fact that Python3 takes a "randomly guess" approach to file encodings. `open()` returns a stream whose `read()` and `write()` methods take and return `str` (nÃ©e `unicode`). This is despite the fact that there is **no** reason to believe that a given file's contents has any particular encoding. A considerably safer default choice would have been to either require an encoding, or to have it return a `bytes` based stream, and require users to call `decode()` themselves.
Wish I could, but I don't know much at all about setting up that stuff in a Win environment. I've pretty much kept all of my programming to OSX\Linux environments because of the ease of use. Unfortunately, there just aren't a ton of libtcod tuts that I know of either. I only spent about a week on it, most of which was dealing with the Mac issue I mentioned above.
http://softwareforgood.com/soccer-good/
Yeah I can't find one install guide. 
No more lorem ipsum? The fake date/time is actually really nice. LAT and LONG? this just keeps getting better!
Luckily I didn't have to draw any of the art, but I guess it was just a continuous process of getting the animations and level design right.
&gt; (and, in C++, destructor points). Ugh. Yes. One of the many reasons I code in c rather than c++. I'll deallocate when I decide it's appropriate. I don't want a "garbage collector" stepping in during some otherwise high efficiency real time execution. 
That's what "b" modifier is for.
This is actually quite interesting. Do you write these apps in a web framework like Django? Or are they desktop-based?
You don't need to install it per se, just import it. This tutorial covers using Python and libtcod and outlines exactly what you need to do to get it running: http://www.roguebasin.com/index.php?title=Complete_Roguelike_Tutorial,_using_python%2Blibtcod
Well done, sir!
This seems to be a one-off script. Supporting all strange and probably historic filesystems is probably not a requirement for OP. ;) In general, I'd still say people should use `splitext`, because it prevents the need for small hacks that slightly increase the expected number of bugs you'll have in your code.
`encode()` also has an `errors` argument, but you shouldn't need that unless you are forced to encode to ascii for some reason. How are you dumping the data to the CSV? You should be able to explicitly encode it to utf-8 or whatever before dumping it.
Why on earth would you force it to be UTF-8? That's the default for essentially zero platforms. Why would you force it to be anything? Every platform out there provides facilities to tell you what you should use as a default. You would rather Python act like web browsers and intentionally ignore locale settings?
I'm usually generating the data then pushing into reporting databases for downstream consumption. Could be with BI tools like Cognos, Microstrategy, Tableau; dashboards written in PHP, Python &amp; Flask; or analytical tools that don't necessarily have a front-end, but need to alert if they see abnormal conditions. Python has worked great for this purpose.
StringIO is just a replacement for a file in this example. If your data is small, I'd suck the whole thing into memory, run a transform on it to fix um the NA lines, and feed to to Pandas. If your data is larger, I'd preprocess it to generate a new file and feed that to Pandas. Either way, I'd file a bug, as this should not happen. 
Neat. If we totally ignore the 80 column restraint though, as they did in the original, we can cut it down to a svelte 3 confusing lines. from urllib.request import urlopen import json [print (home['country'], home['goals'], 'x', away['country'], away['goals']) for home, away in [(p['home_team'], p['away_team']) for p in json.loads(urlopen('http://worldcup.sfg.io/matches').read().decode('utf-8')) if p['status'] == 'completed']]
Or 1 and more confusing [print(jogo['home_team']['country'], jogo['home_team']['goals'], 'x', jogo['away_team']['country'], jogo['away_team']['goals']) for jogo in __import__('json').loads(__import__('urllib').request.urlopen('http://worldcup.sfg.io/matches').read().decode('utf-8')) if jogo['status'] == 'completed'] (not tested of course)
neat.
That's brilliant and I love it. Edit: Works if you replace urllib with urllib.request. Edit 2: A less crazy version, because a list comprehension on a line without the result actually being used was driving me insane. print("\n".join((["{} {} x {} {}".format(jogo['home_team']['country'], jogo['home_team']['goals'], jogo['away_team']['country'], jogo['away_team']['goals']) for jogo in __import__('json').loads(__import__('urllib.request').request.urlopen('http://worldcup.sfg.io/matches').read().decode('utf-8')) if jogo['status'] == 'completed'])))
The text file is huge. What do you mean by pre-process? This is actually my first time working with this large of a dataset. I'm only using 1M rows and that's not even all the records. Are you saying pull out the Continent Series from the csv, run some script on it to fix this issue (I may be able to figure that out), then put it back into my dataframe? 
I recently started this free class on Coursera. https://www.coursera.org/course/pythonlearn It's been very helpful so far. I started off with 0 programming knowledge. Another good place to learn some helpful basics is from this guy Bucky on youtube https://www.youtube.com/playlist?list=PL0213E8DC3AA8E21B
I use this in a DB sync/obfuscating tool, for different environments It's very nice and fast. 
how about 5 lines + requests https://gist.github.com/MB6/795b05e27733046995a4 (as a gist because i suck at markdown)
UTF-8 is the default for most modern platforms apart from Windows. Recent Linux and Mac installs have UTF-8 as a default. Yes, I'd ignore the locale for the default in something as low-level as opening files. It's a pain when low-level things like reading a file behave differently on different platforms - or even different environments in the same platform. We (IPython) have had tests that failed when Debian built its packages, because the environment variables on the build machines meant that the default encoding was ASCII. Now we've learned that *opening files in text mode without specifying an encoding is almost never correct*. I would probably allow something like 'locale' as an option for encoding, but I certainly wouldn't make it the default. Code rarely - in my experience - has to read text files that are guaranteed to be in the default encoding where that code happens to be running. It often has to read files that are in a known, consistent encoding (increasingly UTF-8). The default way to do that should be right as often as possible, and consistently wrong when it is wrong - not right when I run it but wrong when you run it. Even ASCII would make a better default than using the locale - that would be the *refuse the temptation to guess* option.
How about a static blog? Only write Markdown or Rst-files and let the HTML get generated. No need for a database or php on your webserver. Just plain HTML. I recommend pelican, since its written in Python. I also wrote about it [here](https://www.zufallsheld.de/2014/05/11/serving-static-content-and-comments-with-pelican/).
A csv is just a text file. Something like this: infile=open('foo.csv','rt') outfile=open('bar.csv','wt') for tl in infile.readlines(): ol=do_something(tl) outfile.write(ol) This reads the input file a line at a time, performs a do_something() transform on that line, and produces a new file as output. You can do something similar using the csv library built into python.(https://docs.python.org/2/library/csv.html) 
What about Hyde, do you know anything about it? I'm gonna have a look at your post, thanks.
Oh wow looks almost exactly the same. Never showed up while I was googling, guess I should've searched `python single dispatch` instead of `python visitor pattern` :P EDIT: Now that I think about it, `@singledispatch` doesn't quite work conveniently, because the visitor pattern is actually multiple-dispatch. Naively applying `@singledispatch` would switch implementations based on the type of `self` rather than `arg`.
I'm using static site generator (http://getnikola.com/) but there are plenty others. I'm using free hosting in github (https://pages.github.com/). My theme with some changes looks pretty good (for me): * http://marekwywial.name/posts/blog20130813python-soap-server-flask-wsdl-generation.html
Looks like the worldcup.sfg.io is timing out.
Hey, you could check out this information here https://docs.python.org/2/install/#modifying-python-s-search-path to figure how where your python interpreter is actually looking for its modules. Basically do import sys; print sys.path and see where it is looking for modules. 
I searched around after seeing the comments and this looked helpful: http://pydanny.com/choosing-a-new-python-based-blog-engine.html
bierre
But perhaps binary mode should be the default, and an "s" modifier be used for writing and reading strings... 
Nice!
Exactly. Pulling data from an api, parsing the json and displaying it is run of the mill stuff. Guess not much else is happening in the python world?
Windows :p
Python is already included as standard on Linux. So why this? It is on Windows where it would be usefull.
I stumbled upon [this](http://www.exiv2.org/tags.html) by chance, but yes you're correct! It is indeed UCS2.
&gt; I recommend pelican I second the recommendation for Pelican ([basic homepage/blog](http://mhermans.net)).
I'm not sure if I really understand what you want, but using `application/octet-stream` instead of `application/text` as content type may work.
Good catch, thanks. Not enough to get it working, but better than what I had. 
Why not make a simple django website and host it on the free tier of heroku? I spent an hour putting a portfolio website together with rails and bootstrap. Works like a charm! http://billturner-resume.herokuapp.com
I agree; I think that all `read` and `write` calls should require an encoding. By "Python 3 doesn't let you play fast and loose" I mean in practice these calls *do* require an encoding, and people who don't listen to that get stung by this. In one sense the Python devs did the right thing in actually caring about encoding, but in another sense they just substitued one problem for another - people will still mess up and not pay attention to encodings, but now they get a crash for it instead of letting it pass silently. The 90% of the time it *doesn't* crash, however, lets code that makes this mistake sneak through.
Thanks, this looks excellent.
See https://docs.python.org/2/library/cgi.html
&gt; you misunderstood what I'm trying to do Probably. I still don't really understand.
Isn't there some kind of "more pythonic" way of doing this, deriving directly from dict, using super() in the __init__ method and using slots and class methods?
The amazing thing is the accumulation of standards over the years that make this straightforward. 8-bit Bytes, IP packets, TCP sockets, HTTP request/response, UTF-8 strings, JSON data structures. I'd guess that on average it took 5 years between each layer of that hierarchy and it kind of makes you wonder what's next. 
Http requires you send the headers (each ending with \r\n) AND a \r\n before the body. You're missing a \r\n. When in doubt, surround the printed values with reprs and count the CRLFs. Also, print adds new lines. Use sys.stdout.write or remove the \n's from your statements. Your desired HTTP response (as seen by curl -Lv $URL) should be like: 200 OK\r\n Content-Type: text/plain\r\n \r\n $body 
this looks great, so pythonic, its like an extension of dicts. Will use if I ever have a need.
Thank you so much, glad you like the API!
This library has a really concise syntax, and a pretty interesting way of building up plots. It's also built on top of matplotlib, so you can always get a handle to a matplotlib figure, and just use regular matplotlib if you can't figure out how to do something using ggplot.
suppose it's 10M rows at 1K per - that's only 10Gb - which is peanuts. The script would run in about the time it takes you to get a cup of coffee. 
Good ! You know how to make REST API calls in Python 3.
Hey you could try out Google's web starter kit released today: https://developers.google.com/web/starter-kit/
Looks promising! 
Wonderful news! According to [this](http://py3readiness.org/) it's the 8th most popular package on PyPI and the only one in the top 20 that isn't yet Python 3 compatible.
Paste is discontinued and unmaintained. It's successor of sorts is WebOb, which is python 3 compatible.
Finally! This is very good news!
Python does not have compilers, it is an interpreted language. You probably want to ask about IDEs and Text editors. To name a few options: vim, emacs, sublime and pycharm are used a lot (there are more though)
To a large extent this is RestructuredText's fault. It allows you to not specify an encoding, and essentially just generate the output in the same encoding as the input. Or it allows you to use Unicode the whole way. This works as long as the encoding is 8-bit, and as long as you use Python 2. In Python 3, or if you want to use UTF16 (or UTF32) it no longer works. So I agree with one of the comments on the blog post, RestructuredText should grow an encoding marker.
No problem. Just make sure to understand the basics first and e.g. start by provisioning your box with a simple shell script. Don't look into the fancy tools (chef/puppet) to early. They are really big and might scare one away :)
Your question seems more focused on the frontend, so: /r/web_design 
If you are already using Python and know web stuffs, a week is enough IMO. I had to handover a project to non python programmer recently, and most of the concerns were Python language related. 
I see the Windows fan boys have given you a bunch of downvotes. Have an upvote to make up for it. Windows is a horrible platform for development. Its good for viruses and games though.
Everyone (beginner and experts new to django alike) start from here https://docs.djangoproject.com/en/1.6/intro/tutorial01/ It gives good overview of how django works. Yes, plugins are big part of django ecosystem. If you want to explore plugins for eg. registration and user management https://www.djangopackages.com/grids/g/registration/ For simple permissions like one you mentioned above, django ships with it, which you can see in /admin.
Are they global *variables* or global *constants*? Yes, I understand that strictly speaking Python has no "constants", but if they quack like a constant and swim like a constant, they might as well be a constant. If they're constant, then it's safe (although not necessarily wise) to use `from package.constants import *` in every package module. Or you could do `import package.const` then `print(CONST.SOME_CONSTANT_WITH_A_LONG_NAME)`. But if they're variables, then import * is right out, since then each module which imports them will get their own module-specific version.
TBH these examples don't look really good. &gt;`| sh` I bet it'd break on file names that contain characters sh considers special, such as spaces. Also: for f in *; do mv "$f" "${f//-/_}"; done for f in *; do mv "$f" "${f%.*}.php"; done ls -la | tr -s " " | cut -d " " -f 4- pkill sysmond
Yeah someone else also suggested Pelican, thanks.
&gt; I bet it'd break on file names that contain characters sh considers special, such as spaces. Good point, maybe I should do special command like "sh" for the case. Re Also: Is is examples, are not recommendations. But pkill doesnt allow you see what you want to kill before.
It only seems to work for Python3. Any idea how to adapt it for Python2 ?
Yea I can't share a row. But the records will say either 'UK' or 'NA' or 'EU' or whatever. The separator is a carrot (shift + 6). Reddit formats it funny and I didn't feel like looking up how to fix it. 
Weren't you pushing this article all over the place two months ago? Don't you have any new content?
Could be cool for embedded systems. It is apparently quite small. &gt;eGenix PyRun's executable only needs 11MB for Python 2 and 13MB for Python 3, but still supports most Python application and scripts - and it can be compressed to just 3-4MB using upx, if needed. Although, that's still pretty big for a lot of things, and CPU cycles could be at a premium. It could be nice for live CDs as well.
I hadn't even thought of that but that's a pretty neat idea... I'll see what I can put together in the next week or two. Thanks so much for the suggestion.
I actually think the syntax is pretty good. This is going to be a lot slower than awk and sed though, since it's written in Python instead of C.
No idea where you heard that. All sorts of companies and people use it to solve real world problems https://www.python.org/about/success/ 
https://wiki.python.org/moin/OrganizationsUsingPython
Yes, I think the tool good for daily routine. By example format logs, file operations, format output from utils. But of course for parsing a huge files the package is bad choice.
So Python is a not a toy language like some people say. Thanks for the link. And Can I make a career as a Python Developer or do I need to know other technologies with Python?
Yes you can use Python as the basis of a software development career, but that can't be the only language you know. You need to use an appropriate language for the job you are trying to do. These days, for example, I would expect most developers to know how to code in javascript.
For each project you are developing, create a virtual environment with virtualenv. It will install a pip for you. Use that pip to install the modules you need. That's it, really. Unless you need to support multiple Python versions for a project, when it gets a bit more complex. So it's not really much to document. :-) 
Thansks bob_sutor. 
Kind of: The first version was more like a draft in an IPython notebook and I corrected a few things afterwards. Also sections 6 and 7 are new: The Gaussian kernel vs. the hypercube and the example use in a pattern classification task.
[YouTube](http://highscalability.com/blog/2012/3/26/7-years-of-youtube-scalability-lessons-in-30-minutes.html) itself is made out of Python, Mysql and other technologies as well, but that says enough :)
Python 3.4 is great and all but speaking as a self taught beginner I would highly recommend starting with Python 2.7 and learn it first. The reason is because naturally there aren't near as many tutorials for 3...amd as a beginner and especially if you are going to move on to Django tutorials are going to be your best friend after learning the basics of Python. 
A "toy language" is typically the product of a single person or very small group. Often it is used to investigate language concepts or other CS research. It typically does not have extensive lib support. 
Wow, thank you! But i face a new problem - I am missing libtcod-mingw.dll. Do you know where that file is or where I could have it? I search for it through the entire folder but I can't find it anywhere. Maybe it's an old version of the tutorial? Also it states that Python 3 is not compatible with Libtcod but on the page there are several posts from 2012 that state that libtcod is starting to get support... ?
Check this out: [Django Tutorials](http://twoscoopspress.com/pages/django-tutorials)
Start with the tutorial, but quite frankly it is lacking. Then move onto tango with django and two scoops. Keep an eye out for dates when referencing help, there seems to be a lot of old patterns for doing things.
Thanks, but I think my problem is related to this (yet) unresolved issue: https://github.com/Homebrew/homebrew/issues/29487
It's far from being a toy.
programming sort-of-newbie question: what's the advantage of a virtual environment over just writing your modules in an IDE and following with a 15 line setup.py script when you're done?
I agree, if you've never used a framework before the django tutorial can be quite overwhelming 
I have found as I learn more and more the advanced features start to click. But there is a depth to the framework that is for sure. 
With a virtualenv you don't have to install python modules into your system path. You have all dependencies of a program seperatly and can even maintain different versions of a module.
&gt;They've been providing a superior package tool ([open source](https://github.com/conda/conda)) and binaries across three platforms for years +1 &gt;before pip finally caught up conceptually with 'wheels' (which is still in practice rarely available for one platform, let alone 3, and feels like a case of catch-up NIH syndrome) Wheels predate conda, which solves a wider problem. http://legacy.python.org/dev/peps/pep-0427/ http://pip.readthedocs.org/en/latest/reference/pip_wheel.html https://github.com/conda/conda/releases?after=1.7.0 Conda environments are compatible with pip. http://conda.pydata.org/docs/faq.html#installation Conda tries pip last (see: `--no-pip`) http://conda.pydata.org/docs/commands/install.html http://conda.pydata.org/docs/commands/list.html
Lesson 10/15 Censor Write a function called censor that takes two strings, text and word, as input. It should return the text with the word you chose replaced with asterisks. For example: censor("this hack is wack hack", "hack") should return "this **** is wack ****" Assume your input strings won't contain punctuation or upper case letters. The number of asterisks you put should correspond to the number of letters in the censored word. text = 'Hey yoU., how are you. going' word = 'you.' word = 'you.' def censor(text, word): a = 0 b = len(word) for i in range( (len(text[:-len(word)])) +1): if text[a:b] == word: print 'Found Word to Censor Out' str_temp = list(text) c = a d = b for i in range(c,d): str_temp[i] = '*' text = "".join(str_temp) #for i in range(0, len(text[a:b])): # new = text[i:] #print new a += 1 b += 1 print text return text censor(text, word) 
Great, now if only I could find a flask/boto contact developer who won't flake out after taking on the job. 
TROLL. TROLL SPOTTED. ABORT THIS THREAD. LEAVE NOW.
Try this. #!/usr/bin/python fileName = '/var/www/cgi-bin/info.cgi' # HTTP Header print "Content-Type:application/octet-stream; name=\"FileName\"\r\n", print "Content-Disposition: attachment; filename=\"FileName\"\r\n", print "\r\n", # Actual File Content will go here. with open(fileName, 'rb') as fh: print fh.read() # Close opened file fo.close()
^Your right. For a chess game don't bother, but if you are trying to make a multiplayer FPS (first person shooter) then I strongly recommend Unity. Since this post is Python related note that in UnIty there is Boo which is similar to Python, and IronPython but I have not tried either of them. I use C# with Unity because of the abundance of tutorials with C#. 
There are so many parallel processing options for Python. A summary article of them would be nice. Also the article says it is going to compute cubes in parallel but then the code sample computes random strings.
Not a TROLL 
Would a CRON job that "creates activity" not do the trick?
Do you have any suggestions for an aggregation framework? Never heard of nor seen one before, so not familiar with that area. I do thank you for your response. I'm building this entirely through Python so that's the language I want to stick with. Thankfully a lot of the data needed is already stored in PgSQL without my intervention, so it makes things a lot easier.
Brilliant! I wrote a python-based system last year for an AI seminar class where I was exploring how to create such equations using a genetic algorithm strategy. The frame story was creating moves in an RPG style game, which was a little wonky, but it was definitely fun to explore tree-based genetic algorithms. We had a series of attributes, and generated equations to transform them. For instance, consider the attributes "attack", "defense", "health" for two players - we could generate an equation: p1.health_next = p1.health - p2.attack or something much more complicated p1.defense_next = p1.defense_next - p2.attack * p2.attack The interesting outcome for me was the process of trying to mutate trees, and how quickly changes in the function's structure resulted in changes to the range of the functions. [Here's the (unpublished) paper](https://dl.dropboxusercontent.com/u/23141976/acbart.kar.cs6804.final-paper.pdf) I ended up writing, it goes into detail on that problem. Our [codebase](https://github.com/acbart/attribute-learning-system) is still around too.
Did you activate the virtualenv after creating it? Theres a *activate*-binary in the bin-dir in the virtualenv. Try executing this and then the setup.py.
Clarifying: you need to *source* the `activate` script, not just run it. So, `. my-virtualenv/bin/activate`, not `./my-virtualenv/bin/activate`.
IDE's and virtual environments are not mutually exclusive. Also, developing in a virtual environment allows you to develop multiple projects that may have conflicting dependencies. If project 1 needs library-1.2 and project 2 needs library-2.1, you don't want to have to deal with the broken dependencies every time you switch projects.
I always use ()s when mixing **and** and **or**. They have different precedence, but I don't remember which.
At it's basic level, buildout does the same thing as virtualenv, but limits everything to a single directory. In your project directory you'll have a buildout.cfg file and on "building out" all the packages you specify will be installed into an `eggs` subdirectory. You'll also get a `bin` directory which will contain everything that would've been installed in `/usr/bin`. But buildout is much more than that. Using recipes you can add routines/tasks to your bootstrapping process. So, if your app needs some empty directories to be created, use a recipe, give it the paths you want to create, and buildout will create them. That's a simple example; buildout can do things like build C libraries, run Ant, minify CSS/JS (for deployment), set-up/configure databases, etc. The key benefit is quick setup of projects, handy if you have a (distributed) team, or for continuous-integration, or for deployment.
If you need to keep everything project-specific, take a look at buildout (and my reply to beagle3).
Most of those that I've run into are oriented towards streaming data - like Storm. But I think they're more complex to use, and miss some important use cases. So, I've always had to write my own. Typically just something like: * framework determines next date to process * framework runs programs in a directory dedicated to a given subject area * each program is just simply a stand-alone executable. * example aggregation program using bash &amp; sql for daily trending for ids, device, severity, signature, category, daily would run through a few simple steps: first delete any data already there for that day, next generate the data for that date, finally move that data in. There's a variety of ways of doing this, just depends on how sophisticated you want to get. But the simplest is pretty easy. * Some aggregations aren't ideally done in SQL, these might involve selecting data from that date, generating more complex statistical results, then inserting back in. Python is ideal for this. So, the code that gets run is written in whatever language works best. But I typically write the framework itself in Python. It's an ideal language for walking through directories, determining which programs to run, handling logging, making sure only one instance at a time is running, making setting up default dates &amp; times, ensuring all dependencies have been met before running, etc. EDIT: I should add, the reason I like this approach over a streaming aggregator is that it allows me to easily reprocess old data if necessary, easily add a new aggregate and run it against a year of historical data, etc. Also, you could of course, simply write one big bash shell script and schedule it to run once a day. But I don't recommend that - you'll eventually need to deal with running just some aggregates and not others, re-running data, and running data out of order. This is where the sanity imposed by a framework is really helpful.
 Although last release seems to be from 2010. 
I find the -p argument to virtualenv never works for me --- I find I have to run virtualenv with the python I want to use. I use the following recipe to compile a local Python, and use it to install virtualenv. (I don't rely on packaged Pythons because I use Cython heavily, and sometimes need to control how Python is compiled.) https://raw.githubusercontent.com/syllog1sm/redshift/feature/binary/make_virtualenv.sh #!/usr/bin/env bash cd /tmp wget http://www.python.org/ftp/python/2.7.5/Python-2.7.5.tgz /tmp tar -zxvf Python-2.7.5.tgz cd Python-2.7.5 mkdir ~/.localpython ./configure --prefix=$HOME/.localpython make make install cd /tmp wget --no-check-certificate https://pypi.python.org/packages/source/v/virtualenv/virtualenv-1.5.2.tar.gz tar -zxvf virtualenv-1.5.2.tar.gz cd virtualenv-1.5.2/ ~/.localpython/bin/python setup.py install cd $HOME ~/.localpython/bin/python /tmp/virtualenv-1.5.2/virtualenv.py $ENV_NAME -p $HOME/.localpython/bin/python2.7 source ~/$ENV_NAME/bin/activate You'll want the following packages to compile a useful Python: sudo apt-get update sudo apt-get install build-essential sudo apt-get install zlib1g-dev libreadline-dev libncursesw5-dev libssl-dev libgdbm-dev libsqlite3-dev libbz2-dev tk-dev libdb-dev Without these, you'll lose e.g. zlib support, ssl support, etc, and things won't work right. At a minimum SSL support is critical, or distutils won't work.
This is probably not the right place to ask this question (esp. since it's not a Python question at all). Better try stackoverflow.com 
As stated on the Github issue thread, the future is still all about Botocore and Boto 3, which will be a significant change from the current Boto. The AWS CLI is already built on top of Botocore, which itself is data-driven from JSON files that describe AWS services. Great stuff is coming in the future, but until then adding basic Python 3 support to Boto solves a major customer pain point. The response so far has been extremely positive.
From taking a quick peek at the pizza.py page I've seen nothing that supports your claim that it requires a seperate Python install. You'll probably be fine with using a virtualenv ([here is a relatively good intro](http://simononsoftware.com/virtualenv-tutorial-part-2/))
 from datetime import * Now your birthday card namespace is polluted!
Ohno, it doesn't require one - it does however require Togl, which in turn requires python to be built with Tk/Tcl installed, which in turn requires me to rebuild python - that's the way I understand it anyway. EDIT: Virtualenv does seem like a fantastic solution though!
Thanks, I replaced the first example (cube) by this random string generator function and forgot to change the preceding text - I thought it would be a better example before I come to the part of ordered vs. unordered results.... I adjusted it.
&gt; actually I'm not sure why it hasn't happened already . Because PyPy is [not perfectly compatible with C extension modules](http://pypy.readthedocs.org/en/latest/faq.html#do-cpython-extension-modules-work-with-pypy), except for those which have been specifically modified for it. Worse, what compatibility it does have exacts a significant performance penalty, to the point that they actually recommend rewriting in pure Python.
A branch has already been started for Python 3.3 support.
I feel that your goal is admirable and the product may have an audience but you are posting a job with requirements (not really the target subject of this subreddit) while at the same time asking questions that indicate you haven't yet put much thought into this subject. Ask yourself, as a founder what value do I bring to the table. Clearly not technical expertise but there's some valid answerers to that question and the initial idea isn't one. Go check our /r/entrepreneur and/r/startups first
Oh. Then, in case the fact that youtube and dropbox are both partly written in Python is not enought, here are some sites using Django : - Disqus - Pinterest - Instagram - Mahalo - bitbucket - lanyrd - support.mozilla.com - addons.mozilla.org - The Onion - EveryBlock - GiantBomb - ComicVine - MichaelMoore.com - newyorktimes.com - washingtonpost.com - guardian.co.uk - lawrence.com - mercedesbenz.com - nationalgeographic.com - discoverychannel.com - orange.ch - developer.vodafone.com 
You are right on track with pip and virtualenv. I used Ruby for about 1 year extensively learning the language and also building web API type data viz stuff personally. I was hired by a small place that uses Python and I was able to switch over very quickly. One difference is that you have to actually install the libraries, you can't just put a request 'my_friggen_awesome_library' inside a script. I like using the terminal and vim but sometimes an IDE is nice. I enjoy having solid autocompletion while coding. Was a user of RubyMine and now am using the free version of PyCharm, both of which are JetBrains IDEs. PyCharm has integration with virtualenv actually and makes using it pretty easy!
I was going to call this the "monthly parallel processing introduction". Seems like I see one every month or so. :)
Simple is better than complex... but practicality beats purity. If PyPy cleaned up its act (w.r.t. compatibility and rapid releases) a *lot*, I could imagine it replacing CPython, in practice if not in theory. But that's a long way off right now.
Thanks for the message. I posted here hoping to get some ideas about how long such a project would take to develop and a range for the cost for developing such a product. I recognize that I gave only very limited info about the project and I should have worded the post differently. Are you a python developer? Do you take on any contract work and if so, how much do you charge? If you don't mind answering. 
On Ubuntu it would be as follows and Debian is *supposed* to be the same for this particular thing (but they might be on a different Python 3 version) virtualenv -p /usr/bin/python3 project project/bin/pip3.4 install package You don't need to activate if you explictly set which `pip` to use. Bear in mind that there is currenty a bug against `venv` in Ubuntu and Debian because `venv` doesn't work due to requiring some kind of dirty hack. `virtualenv` also uses the same dirty hack but was allowed to work. They will both however soon be 'fixed'. It's possible this might be affecting you. See comment 24 on https://bugs.launchpad.net/ubuntu/+source/python3.4/+bug/1290847 Anyhow I can confirm it's working on Ubuntu but may not be of use to you if Debian is different.
I think it's OK on a trival use such as this, and in the interpreter for testing. I really can't recommend it for general use.
It pretty much can't "clean up its act" w/r/t to compatibility if you mean "compatibility with C extensions". The sorts of things that incompatible C extensions do invalidate a ton of the optimizations that make it so fast.
Maybe perfect CPython ABI compatibility is not actually worth it. Maybe PyPy should have its own C API that can be properly optimized. Then we could have things like Cython compile to both APIs.
You might want to look into Cookiecutter (http://goo.gl/aMq6rm). WIth it, you can run a script and have it create a new project development environment. You can have it install modules, setup virtualenv, etc. Whatever you deem necessary for your base projects.
Some things I noticed: 1. Your documentation is pretty lacking and so a newcomer doesn't really know what to do. For instance, I didn't know that tk/tcl was a dependency and so it failed to load and then I didn't realize that there's some pretty big hurdles to get it running if your python interpreter isn't configured properly. Having all that information in your readme is really helpful. 1. ~~Just so you know, you linked to "192.3.21.183:5555" in your program and unless I'm mistaken, that's a server you've implemented on your own network. But that's an internal ip adress, not your public one. So you'll probably need to find your public ip address and link to that and then port forward 5555 so that others can access it.~~ 1. ~~An even better option would be to get a public server outside of your home network to remove a) any security risks in allowing other people onto your network and b) any complications of internal vs. external networks. A heroku or openshift are some good examples of free servers to test out your software.~~ I'll try again once I have some free time or when you've added some more commits. edit: crossed out some unnecessary stuff since /u/Rekvijem cleared them up.
They recommend using cffi.
1. Gonna assume you're on linux, which would mean you have to sudo apt-get install/sudo yum install/sudo pacman install python-tk, tkinter or something of that nature. 2. It's a VPS, and 192.3.21.183 is an external ip. (http://www.geoiptool.com/en/?IP=192.3.21.183 proof if you need it) 192.168.x.x is internal 3. Again, it's a VPS Updated the README.md to show you how to install tkinter. It's a simple command.
CFFI is supposed to be nice, but since I write Python specifically because I like Python, not C, it's not really an issue for me.
First off, this isn't a job for contact work. You will need a well designed system and the OCR portion is likely to be the most difficult part by a fair margin since it will be user facing and will have to deal well with low quality, noisy, distorted images. Additionally I envision a form management and creation scheme being in the basic specification since even perfect OCR can't miraculously parse an unknown form. On top of all of this is a well made web interface with some thought to scalability on the back end. You will need a minimum of 3 highly motivated and talented developers to get this running at all, and a larger team to make this sustainable. Web apps need constant intervention from developers and administrators, there is no way to get a turn key system of this nature made for you. Also, settle on a platform early on. Your mock job posting mentions RoR, PHP, and Python (ostensibly django based). These are very different platforms and while some developers are indeed talented in all, they aren't necessarily complementary skills, you might as well post a job for a doctor versed in oncology, cardiology, and emergency medicine. Sure maybe they're out there but it's a hell of a lot better to just know what you need. My last comment is on the proper course of action; you need a technical cofounder. Somebody who has made a web app before, even a simple one. There's no way around it. This isn't a system you can buy. Somebody who is unscrupulous may tell you otherwise but 100k down the drain and a half working system will be your future should you believe them. You can always learn much of this yourself. Remember, all of us that can program would rather do this without giving half the equity to you. The only reason we don't is because we know how hard it is and we like having money on our bank accounts. If you have 500k dollars to spend on this you have a good start on being an equity holding founder, otherwise you need to bring something substantial to the table. Your experience as a teacher isn't enough, teachers are easy to find and get opinions from.
Alright, glad I could help.
As a bonus, travis-ci has already merged the code to let people test against thsi: https://github.com/travis-ci/travis-cookbooks/commit/bc5977609140d959183425d1f6a06bebe7006c5d and hopefully it'll be deployed next week!
Maybe you can shed some light on this then for me, if you don't mind. I have the databases and tables, populated with data. The "services" themselves (where I would access the data) are simply classes that are loaded at run time via a plugin architecture, and they provide the standard methods for getting data. I already know I'm going to be needing to use a few JOINs in a lot of the queries. Would you suggest doing something akin to Nagios where critical/warning/ok have different weights, and if criteria doesn't match that weight then it doesn't get represented as a trend?
Looks a lot like a nerd's version of Omegle, lol. Its interesting and I like the idea. Just not sure of the usability, but every project made is a learning experience at least!
That's basically what it is lol I had an afternoon and didn't know what to program and just kinda thought of this
Am a request pypy developers. So many questions!
Thanks for the websites. I said it was a toy because some people said that Python is just a good language to learn only. But I can see that Python is an important and serious language. Thanks
I wonder if it's ever going to get merged back into mainline PyPy. It'd be awesome to do something like: * building from the same source either 2.7-compatible version or 3.x or... * selecting Python version with some command-line argument to the interpreter * and with either of those options - use some 3.x features in 2.x code (they would be in the same codebase anyway).
You're right that replacing a large C extension is painful and probably a bad idea. For new projects, though, I'd always prefer to use the more cleanly decoupled C library + Python with CFFI approach. C is so much more palatable without *PyObject_...* stuff sprinkled everywhere.
No problem at all. Thanks.
Most recent commit is from March.
`s/upcomming/upcoming/g` Other than that, very nice, thanks.
I haven't gotten it to work, no :/ I can do everything except get Togl to work, and Togl is deprecated and support is kinda scarce. The installation notes on the pizza.py website suggest that python needs to be rebuilt with togl already in place, and that's where I get stuck.
You can use [this](http://celery.readthedocs.org/en/latest/userguide/workers.html#pool-restart-command) control function to dynamically reload modules.
It works, I just tested it e.g. from PySide import QtGui QtGui.&lt;autocompletes&gt; It works for instances too.
Do you know what the problem could possibly be? I have searched all over the web and can't seem to find what the issue could be. What OS are you using?
Ye I have tried restarting pycharm (and my entire os) multiple times but that didnt work. autocomplete works for other third party libraries (e.g. requests, praw, sklearn, numpy etc...) EDIT: Trying to re-install PySide now in the hope that it works
What about modules containing new tasks that have not been loaded yet? Also, it doesn't look like there's a way to wait until the reloading is done and you can launch your new/modified task.
Solved the problem by uninstall PySide from pip and installing the dev version from github. git clone https://github.com/PySide/pyside-setup.git pyside-setup cd pyside-setup python setup.py bdist_egg --qmake=/usr/bin/qmake-qt4 sudo easy_install dist/PySide-1.1.3dev-py2.7.egg sudo python pyside_postinstall.py -install
I work on PyPy ask me anything :)
Sounds like you may have some confusion about the use of cffi. There would be no reason to rewrite the entire extension. The core of your extension would remain the same as its just the part that provides the interface to CPython or PyPy that would need to be modified. It's the part of the CPython extension that uses the CPython's api that would be replaced with cffi. For most extensions we are talking about modifying less than 5% of the code. [edit] fixed a typo
The only plans that are aware of were on the [donation](http://pypy.org/py3donate.html) page and the occasional [PyPy blog](http://morepypy.blogspot.ca/). The information on the donation pages was the plan for this release. The best source for information on the roadmap would to ask a question on #pypy on freenode or on their mailing list. I would expect that now that the first release of PyPy3 is out that future releases containing newer version of Python 3 would occur similar to how they handle newer version of Python 3. Typically its not a huge amount of work to upgrade to a new major release of Python as some times I have seen it done in as little as 1.5 months. This depends on availability of developers so sometimes there are long periods where no one is working on the language updates and instead working on other areas of the PyPy infrastructure. This can be sped up by [donating to the PyPy3](http://pypy.org/py3donate.html) effort which would increase the effort that is dedicated towards PyPy3 or to lend a hand with the effort. Of all the areas of PyPy development this is one of the areas which is easiest to be a contributor. On minor point releases I have seen them get them done on PyPy for Python 2 in a 1-2 weeks for the larger point releases and in a couple of days for the smaller ones. Of course these numbers are when there is a concentrated effort to complete the task and there are times when nobody is working on these updates. Usually what happens is PyPy itself has had enough new improvements that it warrants a new release and just before the release they will make a decision to bump up the Python version and then they just get the work done before the PyPy release. PyPy releases tends to occur every few months.
whiteboard.py 
I like that prettytable api. How do I convert or export a prettytable to csv? I looked at their tutorial but it didn't have an example doing this. Maybe it isn't possible. EDIT: using the built-in dir() function, I was able to find out I can get column names using PrettyTable._get_field_names() and to get the row data, it is PrettyTable._rows So I guess I will start with that.
Thanks for sharing your knowledge and experience!
can you source me whiteboard.py
The multiprocessing module looks nice. I'd love to see something similar covering fabric or greenlet. What I'd really like to see would be something similar to multiprocessing that sits on top of PlatformLSF.
I, to, am interested in this "whiteboard.py"
You might not see *too* many extensions rewritten to be PyPy friendly (I hope that's not true, but we'll see), but I think there's a fair chance you'll see a lot fewer C extensions that aren't PyPy-friendly in the future.
&gt;to be built with Tk/Tcl installed, which in turn requires me to rebuild python - that's the way I understand it anyway. I'm pretty sure you just need `python-tk` package installed (since it doesn't come with default installation on linux) and not building separate python version.
Damn this "for humans" shit. I'm sorry but stop with it. Also, awk and sed are fantastic tools.
Can you tell me about the development of PyPy3? Is rpython any different or is it the same as that for regular PyPy?
And they're nowhere near a new release, let alone a python 3 compatible one, whatsoever. After asking most recent committers in the respective repos (paste, pastedeploy) they said they have no plans for it at all.
You know, you can rotate images with imgur? http://i.imgur.com/z1sZfwG.jpg **UPDATE** Traceback (most recent call last): File "./prog.py", line 3, in &lt;module&gt; AttributeError: 'builtin_function_or_method' object has no attribute 'month' :/
rpython doesn't change, PyPy3 is a "fork" (kind of) of the PyPy2 interpreter, it's living in a separate branch in the same repository and language independent features are kept in sync.
Hi greenlinux. After reading your question, I thought you might be a troll, but decided to search your replies here and am happily surprised and impressed by your on-line manner in thanking those who helped and answering those who thought you were a troll. Not many programmers in other languages would still call Python a "Toy" language (as you have seen). The number of jobs available, active projects being used, and courses being taught in Python are usually enough to make most developers know that Python is used.
That site reports the following on chrome so I decided to play it safe. The site's security certificate is not trusted! You attempted to reach tavianator.com, but the server presented a certificate issued by an entity that is not trusted by your computer's operating system. This may mean that the server has generated its own security credentials, which Chrome cannot rely on for identity information, or an attacker may be trying to intercept your communications. You should not proceed, especially if you have never seen this warning before for this site.
Well, it *is* a Django related question and Django is written in Python. But still /r/django would be a better place. (SO is not really good for this kind of best practice question.)
Is this seen as a temporary measure for ease of development? Will pypy3 eventually become the default pypy?
No it's a JS / jQuery (or even a fundamental understanding of how a browser works) question. That the URL he wants to load is served by a Django view is (at least accorindg to how the question is written) incidental.
In a far away future maybe, since rpython is based on Python 2 being self hosted is kind of nice, you can also translate PyPy with PyPy which gives a nice speed boost. And since Python 2 is still the most popular language for production use (and what most of us use), Python 2 is the first class Python for now.
Argh did I link the https version? Oops, yeah that cert is just from CACert, it's not trusted by default anywhere. Anyway you can ignore the error, it's not like I'm your bank.
OK, let's talk about a more concrete use-case. I have a large and currently unfinished library I'm working on. One of the modules needs to do 3D voxel manipulation, which can easily become cubic in one of the input parameters. More accurately, this module needs to expose voxel manipulation functionality to other parts of the library and to the end user. Sensibly enough, this is wrapped in a class called `VoxelBuffer`, which provides all the necessary features. I quickly realized this would run dog slow under CPython, so I prepared a Cython version of the module. Cython is a superset of Python, allowing for static type declarations among other things, which can be compiled into a C extension directly. I'm not actually writing any C code at all, so telling me to use CFFI is a non-sequitur unless I want to split my Cython extension into a pure Python frontend and a Cython/C backend. That kind of split strikes me as... messy. Currently, I am maintaining the pure Python version of the module alongside the Cython version, but not for PyPy's benefit. Rather, it's intended to make life slightly easier for people installing from source who don't have or want Cython. I suppose PyPy users are a subset of that group, but they're not the primary focus here. They're supported more or less by accident, and may find themselves suddenly unsupported if things change.
&gt; Would you suggest doing something akin to Nagios where critical/warning/ok have different weights, and if criteria doesn't match that weight then it doesn't get represented as a trend? I'm not sure I understand the question. But I can say that I generally transform all product severities into a single standard numeric range. Some vendors will have 3 values (low, med, high), others five (very low, low, med, high, very high), others will use numbers (1,2,3 or 0,1,2). I keep all severity levels in the database - so it's easy to validate the data (a sum of all events for any aggregate table will equal a sum of all events for all other aggregate tables). Additionally, keeping them all means that you can support the largest number of potential queries. There's a lot of different ways to display this data. Personally, I like to present the highest-level aggregates then let the user drill-down into whatever they're interested in. More for reporting than monitoring. Anyhow, I will often show time-series by severity level, and let the user exclude/include whichever they want.
the problem with such projects is that you can't really predict. It ended up being possible, but not quite. Think about it as a risk factor - the more money you put the lower is the risk.
nope, never will.
Cython could easily generate cffi-based Python if it wanted to. There is very little interest from the Cython side to emit anything else than CPython C API and their answer is essentially "well, just make it work".
Python 3 is... what, ~~15~~ 6 years old now?
6 years old. Anyway, Python 3 is yet another story. PyPy is mostly supporting Python 2 and the releases has been going like 3 or 4 per year. If you mean "catch up with the latest Python 3", then Python 3 adoption is way too low to warrant that sort of effort. PS I think you're trolling with your widely misleading numbers.
/r/progether was created so that redditors can come together and work together on projects and discover new projects to work on. Feel free to drop by and help out (though there isn't too much activity going on recently)
I wouldn't be too concerned. There isn't much unicode in numpy and I'm sure it was written with Python 3 support at least a little bit in mind.
How do changes from CPython get applied to PyPy? Is it only major changes or also bug fixes? Do people just go through all the finished tickets, see if they apply, and update PyPy accordingly?
&gt;PyPy is mostly supporting Python 2 and the releases has been going like 3 or 4 per year. That's not very hard when your target basically hasn't moved in 6 years. &gt; PS I think you're trolling with your widely misleading numbers. No, I just have a terrible memory and didn't bother looking it up. But if I was a troll, accusing me of it would be feeding me, and we can't have that, can we?
Are you planning on doing a `pypy` â†’ `pypy2` symlink method now, similar to how CPython does it?
When you are on the download page, make sure you grab "Windows/MINGW C/C++/python". The .dll will be in the main folder. I've gotten libtcod to work with Python 3, but it involves some janky stuff when sending characters or string as arguments. You have to use the byte function in order to pass any text. http://stackoverflow.com/questions/6269765/what-does-the-b-character-do-in-front-of-a-string-literal Unless there's a compelling reason that you want to use Python 3, using 2.x might make your life a little easier.
That's a packaging issue IMO.
We pull CPython's standard library (what's written in Python) for each minor version of CPython (with a few changes), so we get those bug fixes for free, otherwise, most of the time, bugs that apply on CPython don't apply on PyPy (and vice versa).
this is pretty cool but need far more documentation in the code for it to be useful. 
True, but an official recommendation, [like CPython has](http://legacy.python.org/dev/peps/pep-0394), wouldn't hurt. I understand wanting to stay out of that debate, though.
Good luck learning a web framework within a week to the point of being able to rewrite a complex app. Your knowlege of Python will only carry you so far. Django's short learning curve is only short if you already have the contextual knoowlege of typically similar frameworks- since most frmeworks take the same approach these days to URL mapping, templates, models and views, Django is familiar to a lot of newcomers. OTOH if you are coming in fresh with a pythonic background, you may find Pyramid as easy as Django. If you are feeling adventurous, take a look at Grok.
I have that, and when I run pizza.py it says gl tool did not load: can't find package Togl
Try: http://bit.ly/pythonclass
&gt;I was considering to read Learn Python the Hard Way but from the review it seems the book could miss some details and lead you to search the web... Then read Learning Python by Mark Lutz, you won't miss many details with this thick book. I also like the Treading on Python series and Python Programming: An Introduction to Computer Science by John Zelle. Also, maybe in tandem, do a few of these projects listed [here](https://github.com/karan/Projects). Test your knowledge or understanding, see if you can do puzzles at [codingbat](http://codingbat.com/python). Good luck!
How did you install, or try to install it?
Makes sense. Any comment on web2py?
Thanks for the reply pybokeh. I think ill go ahead and try Learning Python by Mark Lutz as it has +1000 pages hahaha. Appreciate the share of the links. 
We've got an open ticket to include a `pypy3` name in the py3k version, to make it easier to have them installable side-by-side. I think a `pypy2` makes sense, but we'll see.
FWIW, I've ported (and participcated in porting) a decent number of things from C-extensions to cffi, and it's so nice. The thing about writing C extensions (particularly when you're doing them to bind C code) is that you end up with this gigantic bloat. Your code will be 5 lines of calling C-library functions, and 30 lines of refcounting, and CPython C-API shenangins, doing something like: for obj in sequence: call_some_c_function(int(obj)) in C is a huge number of lines of code, but with `cffi` it's literally no more than what I wrote.
Way to go on PyPy3!
It doesn't seem to get much use these days. Flask and Django are the main players. 
did you try setting the original image from RGB format to RGBA? what about manually specifying the size of the ImageTk object and pasting the PIL image onto it?
Being on the team means we get to say it to you, too. Have you written anything about the process of writing cryptography.io ? I've been curious how to address things like side-channel concerns, etc., in a high-level language like Python, especially if it might then get pumped through a JIT compiler.
There's some info in the talk Paul Kehrer and Jarret Raim gave at PyCon, the tl;dr; is we utilize lots of code review to make sure we're thinking about these issues, and we write functions in C when necessary, for example: https://github.com/pyca/cryptography/blob/master/cryptography/hazmat/primitives/constant_time.py#L22
Not seeing the word Pyramid anywhere... http://trypyramid.com/
Thanks for the reference to the PyCon talk. I haven't gotten to that one yet in my queue, but I think I will bump it up. CFFI-based C-code, right? :-)
Of course :-)
I'll admit that I only skimmed the article after watching the video but can we assume this is filed under "Coll, but useless"? I just can't imagine ever wanting to make a video this way instead of using a video editor.
I've not really used web2py, never used Django, and have touched Flask a little. But here's my thoughts anyways: Django - Not my favorite, which is why I've never used it. I get the point behind it, but if you know HTML then all it is is a fancy wrapper around all of that stuff. It doesn't do anything for me. Flask - As said, its better suited for APIs (more specifically RESTful APIs). Its a nice platform but if you're using a web framework anyways its usually overkill. Personally for my web work I use Tornado. Its a minimal web server but has a lot of powerful features available. It takes a little adjusting to, and if you use Django might be a bit more cumbersome, but there's a lot of people that integrate Tornado with Flask these days and it seems to be well-built.
Check out [pyenv](https://github.com/yyuu/pyenv). Tied with [pyenv-virtualenv](https://github.com/yyuu/pyenv-virtualenv) you should be set.
I would say Flask is for smaller applications, not just for APIs. I wrote an application recently using Flask that was not just an API, but a full on web page (pages made from templates, etc). I would use Django/web2py for sites that had logins, databases &amp; the like, and Flask for smaller projects.
I wouldn't know how the answer it. I'm a beginner myself but some of my friends have recommended it as better than Flask and Django. From what little I know it's not as "magical" Flask but it's more modular and more customizeable which works better for larger projects.
[Intro to Computer Science at Udacity](https://www.udacity.com/course/viewer#!/c-cs101) is a nice Python introduction, and is taught using video and forums.
If you want a full stack framework, but more modern and less baggage / far less held back by backwards-compat than Django, Pyramid is great. That and you can use it just as a routing framework (like flask) or it integrates really well with SQLAlchemy and alembic equally well.
Yes. I think the hard question is, if you have a 30 minutes clip that you want to correlate with a 12 minutes clip delayed by 7 minutes, this obliges you to correlate very large arrays, with many possible local maxima. So you might want to simplify your sound, for instance consider the intensity in just a few (well chosen) points.
I use web2py for every project I can. It's very quick and easy to make something work. 
Thanks for the advertizement ! But I already posted this project [a few days ago](http://www.reddit.com/r/Python/comments/28ak30/this_is_my_first_ambitious_video_entirely_edited/) on r/Python. If you want a very cool application of the library, have a look at [Videogrep](http://lav.io/2014/06/videogrep-automatic-supercuts-with-python/), a script released this week which has been an instant hit (660 stars in 3 days on Github) and would certainly deserve to be posted on r/Python.
See, you *did* have some useful words to put to it :-)
Very interesting, thank you! I'm working hard on the problem, this might help!
I was looking for a framework to use for a simple HTTP app, and it's daunting because there's so many options to pick from. I got a lot of advice from this [comparison](http://www.slideshare.net/r1chardj0n3s/web-microframework-battle), although it's a few years old now and there's probably been some more since then. I decided in the end to go for [bottle](http://bottlepy.org/docs/dev/index.html) just because it seemed the simplest.
I haven't used web2py anything, so I'll skip that, but for Django, Pyramid and Flask (which really are the most relevant currently) there's a few key differences (I won't tell you which to use where though, others have already done that and it's quite a bit about preference): Django is a full framework, meaning Django prefers if you use it's ORM (database management toolkit, short for object relationship management), templating system and too a certain degree even such things as authentication management. Even though Django is much more customizeable than say WordPress as it doesn't deliver a complete solution, but merely a half-baked one, but it's much less customizeable than either of Pyramid or Flask. Django was built to make websites, preferably news publishing and other kinds of interactive websites, while Pyramid and Flask makes much less assumptions about what you want too do. If Django is a half-complete solution, then Pyramid is sort of a third-comple solution. Pyramid's pride lies in the way it provides a stable foundation for anything and, without resorting to becoming a micro-framework, avoiding making decisions that might affect the developer's ability to make something useful (for example, Pyramid avoids taking decisions on what templating system or how you connect to the database, it's setup to help/guide you, but the ultimate decision is yours to make). Reddit is built on Pylons, which is the predecessor of Pyramid. Flask on the other hand is a microframework which essentially means that it's built to provide you with something to get you started. Flask heavily prefers the Jinja2 templating system and is dependent on Werkzeug, which makes it a bit less micro than many other frameworks, but the one of the key selling points of Flask is that the code is very well written and accessible, meaning that you can change Flask according to how your application works and such. It's made to never be in the way of you innovating, so even a sensible default that it provides should be easy to change if it doesn't make sense in the particular situation. As Flask is a microframework, the amount of concepts to learn is minimal, which makes it much easier to get started with. As Flask carefully avoids any decisions for you, it could get a bit complicated when your application is starting to grow, since it's not meant for holding your hands during development. Flask will not provide a set of magic tools, and you'll probably have to for example build your own profiler (Pyramid throws one in for you) and admin interface (which Django essentially gives you for free) and also figure out a working directory structure that'll work for your project. None of the Python frameworks are as "helpful" as Ruby on Rails or WordPress, which both tries their best to serve you as much as possible, with the side effect of you loosing control over the inner workings of your application. Django is slightly more monolithic and complete than Pyramid, which is slightly more complete than Flask, which in turn is slightly more complete than say Bottle ~~(and I think web2py too)~~ (*edit* I was wrong about web2py). Flask is good for learning, partly because it allows you to learn about Python and web servers without having to feel like you're learning a lot about some obscure monolithic framework rather than actually about Python and web servers. But really, all the big Python web frameworks are quite exceptionally done and quite useful.
I've never used that one.
+1 for bottle. I really like it. I've always liked it. Dat flask though....
Great summary. As a small contribution, I've generally used Flask to rig up a simple rest endpoint for another application. I doubt I touch it even close to it's power, but to quickly get something up it's fantastic. 
What kind of app did you build with bottle?
Thanks for the info. Did you have a bad experience with web2py?
&gt;Don't use web2py Why not?
What sort of apps have you built with pyramid and how was the learning curve?
What about tornado makes it difficult to adjust to?
I built a hello world app lol......the learning curve is a little steeper than Flask but only because Pyramid is more explicit which I think is a good thing.
There is no situation where UTF-8 will give you an error but ASCII will produce garbage. ASCII is only valid where UTF-8 would produce the same result - it will error on any byte or codepoint above 127. You may be thinking of latin-1, which can silently decode garbage text (as can many other single-byte encodings). Anyway, UTF-8 was my preferred option.
What are your plans for pyramid? How long have you been trying to learn it?
Flask *is* python 3 compatible.
What is the point of making comments about something you admit to knowing nothing about?
Plans are to build a small web app that helps SEM professionals (analyzing data, doing stuff with csvs &amp; excel files, etc). I only started learning it last weekend.
Django is a much larger, "batteries included" frame work with a larger footprint. It has most features you could want, but you more or less have to use those Django specific features. Flask on the other hand is less structured and much more lightweight, but you it with extensions as you see require. Someone on reddit once made the comparison that Django is like buying a complete toy that comes in a box, and Flask is like building your own thing with lego, it's a little more involved, but I enjoy it more. **Edit:** The reason you might not want to use Django is that it's just larger and potentially overkill or not suitable for the type of web app you want.
And are you happy this far? Any thoughts to try something else?
Any experience with web2py, tornado or pyramid?
In case you are on a *nix like system, I would recommend vim with a few python plugins. You wont find anything as much lightweight as that, and it really boosts productivity.
No, its just that as far as I'm aware, there are basically better options for everything. One of the others is better for everything.
I'm sure they could skip ahead if they wanted too but either way they do it requires the same amount of total changes/work. Since its less work to get to Python 3.3 they will be able to release it sooner then if they go straight to 3.4.
Not enough to give an informed/unbiased opinion I think. However I did read the [comparison](http://www.slideshare.net/r1chardj0n3s/web-microframework-battle) posted by /u/mfm24, and the gist of it appeared to be to avoid web2py, and prefer bottle or flask (Itty and Pesto are quite similar to bottle, and flask is on python 3 now). As for tornado and pyramid, again I haven't had much exposure, but they look a little more rigid than flask. There are some insightful posts in [this reddit post](http://www.reddit.com/r/Python/comments/26a0wr/flask_vs_pyramid/) too about Flask vs. Pyramid.
I think a souped up text editor is what you're going to want. for example SublimeText + [Package Control](https://sublime.wbond.net/installation) which easily installs [SublimeLint](http://www.sublimelinter.com/en/latest/) with [PyFlakes](https://github.com/SublimeLinter/SublimeLinter-pyflakes)
I have some with web2py and Pyramid. web2py is much more "monolithic" than even Django; you get the feeling it's more like an app written in Python than a framework written for Python. That's not necessarily a bad thing, though. If you come from PHP or are learning Python as maybe a first language and want to jump into web dev, web2py is a good tool. It makes a lot of assumptions and implications (stuff which most Python devs generally argue against) that can benefit newbies. Also, the creator is a professor who teaches Python and built the tool to help his students learn, so it's sort of centered around newbies if that's what you're looking for. He's also active on reddit. Pyramid, like memoryspaceglitch said, is less coupled with itself. You can use whatever template system and whatever ORM, as it's built to be pretty flexible. However, this also requires you *know* what you should be using, versus a solution like Django and web2py which makes the assumption for you but also lets you use whatever. Pyramid says, "We work with anything, including these things!" Django/web2py says, "We work with our things, but you can use your things if you really want." Honestly, I would say Django is good for 99% of apps. It's my go-to framework for work and personal projects that I just want to get up and running and don't have some prerequisite about an ORM or templating system. However, if you really want (or need) to use a specific tool like SQLAlchemy or Jinja2, then I would say go the Pyramid route. There's not much point in using Django if you're gonna strip out most of it just to hack around it.
For whatever reason my Uni chose to teach us web2py in web dev. Stay away, it is awful! 
It's easy to get up and running for a tiny project, other than that it's got nothing going for it
Just as an FYI, I believe you're thinking of [web.py](http://webpy.org/). [Web2py](http://www.web2py.com/) is the full-stack framework designed to take care of mostly everything, a bit closer to Rails/Wordpress than Flask/Bottle.
Sublime text has amazing syntax help. When creating a class, for example, you just pretty much need to write "cla+Enter" and it will generate a bunch of code with a constructor and so on.
web2py is a huge and easy to use framework which does much magic in the background. It's managing a lot of things, which is good for small and midsize projects, but can turn evil, when you want more, because changing the defaults isn't easy. Installing is easy by extracting an archive, because web2py has a webserver included. In the case of an public deployment configuration of apache should be known. Accessing databases is easy. But as soon, you want to setup new css codes, the amount of work to change the defaults is huge. 
There's really not a time where it would be *bad* to use Django, but there are times where it might be *easier* to use a smaller, more flexible solution. If you have some legacy code that requires its own ORM or template engine, for instance, it might be easier to use a framework like Flask. You can still use Django, of course, but you would end up rewriting that part of the code, and it would no longer work with Django's built-in admin interface, so at that point, you would really be losing the benefit of choosing Django. Also in the case of small, one-off APIs that need to be tightly tuned, it might be better to use Flask. You might not need some full-fledged, "batteries included" framework just to make some simple API for work, so all the bells and whistles Django brings might get in your way. I would suggest building simple apps in all the frameworks you're contemplating and seeing what would be best. A bit ago, I thought Pyramid was perfect for a project until I actually started using it and realized it didn't mesh with my train of thought at all. Then I got into Flask, added a bit of functionality specific to my project, and realized it was what I was looking for.
Pycharm is the most common IDE I see. It has the features you asked for plus being a full IDE has debugger support etc. It's also free. I would call neither Code::blocks nor Pycharm lightweight. You could also check out Komodo and Wing, which are also commerical IDEs (and also not lightweight). If you just want an editor with code completion and syntax colouring, there is Sublime and Geany. I am guessing you aren't the sort that wants to use emacs/vim. Geany is free, Sublime is $70. Sublime has better plugin support and looks prettier; apart from that I can't tell them apart. Note that code completion and synax highlighting aren't as good in Python as they are in C++ i.e. completion is mostly useless due to the dynamic nature of the language. As for an example of syntax hughlighting issues, it's impossible to tell the difference between variables and functions, except immediately after a `def`.
Any specifics? What did you hate?
Perfect. Thanks for the help.
The only thing its got going for it is that it's easy to set up and get going. But aside from that it's not particularly good at anything 
Got it. Thank you for the advice!
If you're experienced in SQL and general DB management, ignore all comments below regarding the ORMs. Just learn SQLAlchemy. You can use it anywhere. If you don't know what you're doing, pick Django. It has the biggest community *by far*. You'll find more help, and the differences between them probably won't be offensive to you. It's a perfectly competent framework that covers basically anyone's use case, although not everyone's use case is equally easy. Websockets in particular can be hairy. Web2py is my personal favorite. It does a lot of things without grief. I prefer its templating and ORM to Django's. Maybe more importantly, it's passively security conscious. As long as you don't go full derp, you're protected against the common cases of the common exploits. Its URL scheme is a little crufty, it doesn't support pre-existing databases as nicely as Django, but other than those two points, I'd argue it's the technically superior framework. However, the community is fairly anemic, and websocket support isn't any better. Flask is not like the other two. It's stripped down, far less opinionated, leaves a lot more up to the developer for better and worse. If you have very specific requirements for internal architecture, it'll be easier to do it in Flask than a more fully featured framework. If you need something small, you know exactly how to do it, and you just want something to stand it up, Flask is smaller and thus quicker to learn. If that's not you, I'd default to Django or web2py. Also, websockets suck less here; it's bound only by the general suckiness of Python websocket tools.
It was released in 2005, and its last stable release was last month, so it's definitely sticking around for a while. It's also Python 3 compatible. I do mostly [CRUD](http://en.wikipedia.org/wiki/Create,_read,_update_and_delete) apps for work, and Django has never gotten in my way. Just the other day I updated a Django 1.5 app to 1.6.5 and it only required a handful of small adjustments to the code base.
That's good to hear. I'm hesitant to invest a bunch of time on something that could be gone in a year. With regard to you building CRUD apps, I'm a novice, and I'm sitting here wondering opposed to what? I just assumed CRUD was what distinguished websites from web apps.
Do you recommend not using the stock ORM? It could probably be it's own post, but could you briefly tell me why I would or wouldn't use a framework's built in ORM or what that even means?
I just wanted to expose some simple properties to a web interface. Nothing complicated, and only designed for a single client.
[Bottle](http://bottlepy.org/) : smallest framework around (just one file). Best to use it for disposable tests, very small sites, etc. Fanstastique to teach and learn web programming. [django](https://www.djangoproject.com/) : most famous python framework. You can do pretty much everything with it, the ecosystem is fantastic (there is a3rd party django app for every thing, it's crazy) , how ever there is much to be learn before you can be productive with it. Use it if you have a complexe web site to code, with a lot custom logic. You will have to learn it in the end if you want to be serious about web programming in python. [flask](http://flask.pocoo.org/docs/) : size is between django and bottle. Good for small to medium sites. Is now pretty well equiped with a lot of 3rd party plugins. Use it when you want to build a site with custom features but don't want to load the whole django thing. [wep2py](http://web2py.com/) : try to compete with django AND flask, but provide a different philosophy and includes a lot of graphical tools. Honestly, I'm not a fan of it's style, but some collegues like it, and it's perfectly capable. [cherrypy](http://docs.cherrypy.org/) : a pure Python WSGI framework with very decent perfs without adding anything. But now that its server is available to be used separatly, I would recommand to just use bottle/flask/django with the server and forget about its framework part cause it's very verbose. [pyramid](http://docs.pylonsproject.org/projects/pyramid/) : strongest competitor to django in terme of features, it is much less monolithic and much more flexible. You got control. However, django components intÃ©gration make things easier, doc is better and it has a way bigger ecosystem. So I prefer django. But you can do everything django does with pyramid, it's a matter of taste. [twisted](http://twistedmatrix.com/) : asyncronous internet framework. You read it well : INTERNET framework, not WEB framework. You can do HTTP, of course, but also SSH, IMAP, FTP and so much more with it. Most powerful framwork of all, incredible performance, and the shittiest API ever. Learning/using twisted is like trying to fap with boxing gloves while saying the alphabet backward. [tornado](http://tornado.readthedocs.org/) : asynchronous web framework. Basically the current only nodejs competitor in pure Python (so no gevent, no extension, etc). The API is not fantastic, but not too hard and perfs are good. Websocket works out of the box. [cyclone](http://cyclone.io/) : technically tornado running on the twisted event loop. Meaning you can use the easy tornado syntaxe for the web on a twisted setup, and still leverage tornado crazy tool box for other things. This is so advanced you should not even think about it. [webpy](http://webpy.org/) : very old. Use it only if you like it's syntaxe that feels like you are talking HTTP directly, but with a nice Python wrapper. 
The ORM (Object-Relational Model) is a layer that converts database stuff to language-specific objects, generally masking the underlying SQL and allowing the developer to work in the paradigms of the framework's language. ORMs are like Churchill on democracy - they're the worst way to embed SQL in another language, except for every other way that's been tried. They all make tradeoffs, usually pretty big ones. SQLAlchemy has an ORM. You don't *need* to use it, but you generally will. It's a very unopinionated ORM, though. If you want it to handle a certain way, just tell it to. Most ORMs will let you drop down to plain SQL, but SQLAlchemy does it more gracefully. It also lets you build your own objects to hold the data you're pulling out, instead of a generic query result object. It's pretty awesome. SQLAlchemy is also awesome enough to let you shoot yourself in the foot. It really helps if you can grasp (or correct) the underlying SQL. If that's not you, the stock ORMs are probably better. They're less complicated and are generally very high performing for their supported operations, which is generally 90%+ of what anyone actually needs.
Just go with Django. I don't use python or Django, but I know Pinterest and Instagram use Django and if it serves them fine, it should be fine for you.
I've built a number of sites with django and used it for a handful of projects. I wasn't going to comment because I haven't used flask (aside from toying around with it) or the others, but I did have one thought I didn't see stated anywhere else above. I certainly cannot offer a comparison to other frameworks. What I can say is that every project I've ever worked on has started small and grown over time and become much more important than it was initially supposed to be. In these cases, I've always been happy with django because there are so many tools baked into the framework that it always seems to have my back with projects that unexpectedly get bigger. 
&gt; with SQL If you know SQLALchemy, using flask for small sites and pyramid for big sites might then be the best solution for you. Indeed, while django is my all time favorite, it comes with it's ORM, and you would have to start learning it all over again. Better leverage what you already know. Since flask and pyramid can use the same template engine (jinja2), it would save you even more time. Django can use jinja2, but you loose a lot of tools by doing so. 
That's an excellent point. The small project today can become huge in a couple years.
Good point. I wonder if there are any other wildly popular sites built on any of the other frameworks.
If CRUD is for simple apps, is there a term to describe more complex web apps, a la Facebook or Reddit?
I would suggest you to read a more in depth book now that you're comfortable with the basic syntax. One of the options is [Learning Python](http://shop.oreilly.com/product/0636920028154.do) by Mark Lutz. 
Not that I'm aware of. Generally, someone will say "basic CRUD app" or "simple CRUD app." CRUD is just used to cement the fact that the app is centered around those four basic functions instead of something more complex. The acronym itself doesn't necessarily imply simplicity. Just to clarify. :)
Start applying the stuff you learned! Write stuff, even simple things like a web scraper for content you care about. Maybe mimic a program you like (start small). Oh, and keep reading and get on StackOverflow following python, and read answers of interest and answer when able.
&gt; SQLAlchemy has an ORM you mean "is" ? 
&gt; &gt; SQLAlchemy has an ORM &gt; you mean "is" ? No.
Don't use web2py. Seriously. The code is terrible. It doesn't specify *any* dependencies at all and instead falls back to Python implementations of various libraries if they aren't installed. Things like falling back to pure python implementations of AES instead of failing hard when PyCrypto isn't installed is just bad news because cryptography is hard and the python implementation is almost guaranteed to have flaws in some subtle ways. I'm personally a fan of Flask but frameworks like Django works just as well.
Great info. Thank you. If you were building something new today that needed to scale, which would you choose?
If massive sites like Pinterest are using Django, do you suspect they are using some sort of customized ORM?
Are you familiar with the crypto package aptly named Cryptography? If so, does it solve the problems with PyCrypto?
Have you been able to call jQuery from Django? I know it's possible, I just haven't figured it out yet. 
Out of ignorance, why isn't it and why is there confusion?
Does pyramid make it a point to make backwards compatibility easier, or is Django making more disruptive changes?
Django is fantastic for large web application involving _webpages_. However, I find it cumbersome and painful to use for APIs. For that, Tornado is - hands down - the best I've run across. It also helps that it's unbelievably blazingly fast.
Y'all need to be using more unittest.
I'm not sure what's confusing about "it has an ORM, and it's optional." Maybe just that most people do use the ORM. Maybe that most ORMs don't have a decoupled SQL abstraction toolkit. It's not *that* weird, though. Reddit uses SQLAlchemy, but no ORM.
NLTK, maybe?
These might help: http://www.astropy.org/ http://www.astro.washington.edu/users/rowen/AstroPy.html
Nice find!
Thanks for the suggestion. I looked over the ntlk.org website to satisfy my curiosity, it looks promising. I'll research more onto it to see if it suits my needs. Example of my needs: Generating C# code from rules and inputs (used at work, I would rather code in Python if given the choice).
urllib urllib2 urlparse os os.path re 
I agree with you. After I got the basics of Python, I studied BeautifulSoup. I used it to scrape an informative blog that I read that doesn't have an archive of its posts (only next and previous navigation). It just feels good to make something useful in under 100 lines of code.
&gt; There is no situation where UTF-8 will give you an error but ASCII &gt; will produce garbage. Forgive me for my lousy attempt to explain what I meant. *Strict* ASCII, where bytes above 127 cause an error, is a poor encoding to use unless you know you have ASCII. It's a legacy standard of only limited use, Anglo-American-centric, and not one we should be encouraging or using by default. But when people say "ASCII", most of the time they mean some variety of "extended ASCII" or "8-bit ASCII", without really giving thought as to which f the *many* legacy encodings they actually want. They just want what Python 2 does: read a text file, do the right thing for pure ASCII, and silently generate *something* for bytes above 127, and if they happen to be vaguely close to what the file's author actually intended, that's a bonus. And that's even worse than strict ASCII for processing *text*, since errors shouldn't pass silently. (There are use-cases for processing bytes where the Python 2 model is good, but I'm not talking about them here.) 
Funny you should mention that, I am in fact a contributor to that particular library. :) In this case though, the problem is not with PyCrypto. The problem is that web2py uses a python implementation of AES when PyCrypto isn't installed on the system. (It literally uses a try; except; block when importing) From the fact that web2py's setup.py does not specify a dependency on PyCrypto and that the project *does not* have a requirements.txt file, I'm guessing that the majority of web2py users do not have PyCrypto installed alongside web2py.
I like using smtplib, imaplib, and base64
Most (READ: all) of these can scale well, to do that you would just run multiple instances with a load balancer (eg nginx)
Decimating the audio could work, but could hurt time accuracy. Alternately, you might pick a small segment, say, around 10 seconds, in the middle of one of the clips and correlate that against the entirety of the other. That would be O(N), but could easily pick the wrong offset if the audio contains a strong periodic component. (Ex: clips contain engine noise, which varies in loudness due to load, fuel/air ratio, things moving in the environment around the microphones, etc. Correlating a small section of one clip's audio against the other picks the offset where the engine noise is *loudest*.) Or you could [do it in the frequency domain](http://hebb.mit.edu/courses/9.29/2002/readings/c13-2.pdf).
I totally just read that as "Out of confusion, why isn't there and why is there confusion?". Man, was I confused!
I take it you have already tried to install Paramiko with Python 3? Can you be more specific about the problem you're encountering installing it? I'm going to try installing it on my machine to see if I can get it to work. 
I asked this question in another topic, but a more official answer would be nice: ELI5: Why is it so hard to port Numpy to work on PyPy? Are they doing something more than simply porting the glue code (e.g. rewriting it in RPython), or porting any C library would take as much effort? Please explain the approach taken in NumPyPy project and the idea behind it.
You can always bypass the ORM and do [raw sql queries](https://docs.djangoproject.com/en/dev/topics/db/sql/) you can even map the results back onto Django models ( a bit of a science project ). The thing is that Pinterest is probably not doing that much outside of what Django provides, at least in the layers of their app that rely on Django. Like most things, if you're working with the grain of the framework, things can work pretty well without needing fancy stuff. And what works for you may not work for the next guy. 
If you go this route, be sure to get vim-jedi, which offers decent code completion. There are also versions of this plugin for other editors, such as Emacs, Kate, and Sublime Text. Don't be scared away from Vim though. You can use the arrow keys if you want, or even enable mouse support (while no one's looking).
&gt; Languages, libraries and frameworks donâ€™t scale. Architectures do. *Cal Henderson* You can scale with any framework, but when you arrive at a certain scale, it usually implies breaking out the framework anyway, whatever the framework is. I use bottle and django massively. Bottle for all the small sites (one page sites, private ridiculous API, tests pages...). Basically for anything I would need a static site for, but like to have some Python backend for dynamism or just in case. For anything else, I go Django. Flask could handle most of the stuff I do with Django, it's just that with django, I know I got a thousand app ready to plug. Plus it already deals with RSS, i18N, forms and the admin really make my day. I dislike Pyramid. Too many ways of doing things. I like when "there is one abvious way to do it". The documentation is not as good as django's. The ecosystem is filled with zope stuff, which I dislike for being overengineered. I won't use twisted for anything except when I'm positive I can't do any other way. It's true this lib can do amazing stuff, but it's such a pain. I never used tornado for anything serious. I don't use cherrypy anymore, I use bottle and plug the cherrpy server on it if I want horse power, it's just one pip install and one variable to change.
Unless you already know you need a Python 2 only dependancy (mostly listed [here](http://python3wos.appspot.com/)), use Python 3. Things works pretty well now. Paramiko does support python 3.2 and hight : https://github.com/paramiko/paramiko I'm am not in the position where most of the time, it's just easier to blindly start a Python 3 web project, and if I encounter a Python 2 incompatible lib, I just port it. It usually take a day. Except for twisted. Twisted been stuck to 2.7 really fucks me up.
I've chosen Pyramid mostly because Reddit uses a modified version of Pylons, and Pyramid is the successor to that. But if you're starting webdev with Python, I would recommend Flask and a good book such as "Flask Web Development" that got released recently.
My thumb of rule, whenever I want to build services I use Flask. Services I mean Authentication layer decoupled from main web app. Making authentication as service makes sense when there are multiple web apps which will use this service. Django for getting site up very quickly and app will be monolithic code base. 
This misses one crucial point: **Use an efficient underlying BLAS library** Unless you're willing to shell out for the MKL-accelerated version offered by Anaconda, you can simply build this yourself e.g. using OpenBLAS or MKL. Things like `np.dot` or all the stuff in `np.linalg` will be *tons* faster if you use a decent BLAS. Also, I believe that numpy 1.9 will include some some improvements to the indexing code, so I'm not really sure these tips will even apply a few weeks from now.
SQLAlchemy is composed of two parts, the ORM and the query builder (the SQL Expression Language). The ORM uses query builder internally, so you have two ways of doing a query, with [ORM](http://docs.sqlalchemy.org/en/rel_0_9/orm/tutorial.html): from sqlalchemy import Column, Integer, String, create_engine from sqlalchemy.ext.declarative import declarative_base from sqlalchemy.orm import sessionmaker engine = create_engine('sqlite:///:memory:', echo=True) Session = sessionmaker(bind=engine) Base = declarative_base() class Post(Base): __tablename__ = 'posts' id = Column(Integer, primary_key=True) body = Column(String) session = Session() session.query(Post).all() # =&gt; SELECT posts.id AS posts_id, posts.body AS posts_body FROM posts Or querying with the [SQL expression language](http://docs.sqlalchemy.org/en/rel_0_9/core/tutorial.html): from sqlalchemy import Table, Column, Integer, String, MetaData, create_engine from sqlalchemy.sql import select engine = create_engine('sqlite:///:memory:', echo=True) metadata = MetaData() posts = Table('posts', metadata, Column('id', Integer, primary_key=True), Column('body', String), ) conn = engine.connect() conn.execute(select([posts])).fetchall() # =&gt; SELECT posts.id, posts.body FROM posts; You may ask, what's the benefit of using SQL expression language when you can do the same with raw query? The answer is composability. Let's say you have this clause where it needed to be use in several queries (for example, query for filtering posts with two ["foo", "bar"] tags but without ["baz"]), you can do something like: from sqlalchemy import or_, and_ from sqlalchemy.sql import select, func filter_stmt = or_(..., and_(..., ...)) # (a OR (b AND c)) select([func.count(post.c.id)]).where(filter_stmt) # SELECT COUNT(posts.id) WHERE ... select([post]).where(filter_stmt) # SELECT posts.id, posts.body WHERE ... The greatest thing about SQLAlchemy is you don't have to choose to use either. You can use *both* at once. If you're using ORM, you can always access the "raw table" with `Post.__table__` and can compose query in ORM using the query builder as well. This is where the confusion usually comes from, because you can mix the two, it might give the misconception that the whole thing is ORM, while in fact SQLAlchemy has both ORM and a query builder.
| That's not very hard when your target basically hasn't moved in 6 years. Most pypy releases are *not* about Python versions but about improvements in performance, stuff like STM, a better GC etc. Not sure why you think it's hard, but it seems to be the thing that our users care about a lot.
py.test. To elaborate: The py.test runner picks up all functions named test_something as tests and rewrites plain assert statements within them (e.g `assert 8 in some_list`) at runtime to give as much error information as the unit test assertX methods.
IDLE has syntax checking and code completion IIRC, and is light weight. For the purpose you're asking for, I think IDLE is a good idea.
Just sharing my experience with Pyramid, since nobody seems to really use it here. I've been using Pyramid for over a year for my [personal project](https://github.com/pxfs/fanboi2) (though I used to built a site in Pylons back in 2008 and had a bit of experience with BFG before jumped into rolling my own little web framework with Werkzeug in the pre-Flask days, then Flask, and finally to Pyramid). My experience with Pyramid has been very good despite the initial bumpy road. Just like what's shown in the [Try Pyramid](http://trypyramid.com) website, you can get a Pyramid site running with very minimal code. Compared to Flask, it may looks very verbose at first, but that very basic code mostly stays the same regardless of the size of your application (see its [defense](http://docs.pylonsproject.org/projects/pyramid/en/latest/designdefense.html#microframeworks-have-smaller-hello-world-programs)), whether you add the ORM, the task queue or even when you want to [split your views into smaller modules](http://docs.pylonsproject.org/projects/pyramid/en/latest/api/config.html#pyramid.config.Configurator.include). Everything that makes Pyramid is always returning a WSGI app from the `Configurator`. This is also the area where Pyramid is different, and is the initial bumpy road I said in last paragraph. If you happen to use ini-style configuration in Pyramid, those settings are only available within your `main` and within the request context. It may looks very inconvenience at first, but on the other hand, Pyramid is forcing you to get rid of a import side-effect by make it hard for you to initialize at the module level, at least for anything that requires reading from the configuration (such as initializing database connection), which I think is a very good thing despite it may be a little bit hard to get some module to fit with this pattern (e.g. [redis](https://github.com/andymccurdy/redis-py)). Also see ["Import-Time Side-Effects Are Evil"](http://docs.pylonsproject.org/projects/pyramid/en/latest/designdefense.html#application-programmers-don-t-control-the-module-scope-codepath-import-time-side-effects-are-evil). Pyramid is also very unopinionated. You can also write the views any way you want. It basically calls your view with `request` object and expect the view to return a `Response`. Whether you're going to render templates, or render JSON, or anything is completely up to you (although Pyramid has [renderer](http://docs.pylonsproject.org/projects/pyramid/en/latest/narr/renderers.html) that handles these kind of stuff). Nearly all of its components are swappable, even the "calls your view with `Request`" is also [changeable](http://docs.pylonsproject.org/projects/pyramid/en/latest/narr/hooks.html#using-a-view-mapper). Overall, I've been extremely happy with Pyramid, especially with its design decision and believe it is going to benefit me when the site grows. Its learning curve may be higher than that of Flask and Django (at least for getting a small-medium size website running) and you have to make all the decisions on what to use, and IMHO its documentation sometimes isn't very clear but #pyramid has been very helpful. I'm happy with my decision to go with Pyramid so far.
Directly, or indirectly ? Cause I use sqlite a lot, but use an ORM for that. I use datetime a lot, but with a wrapper on top.
+1. Once you try pytest, you never ever going to touch unittest again.
So many people using argparse, os, urllib and datetime. Guys, there is docopt, path.py, requests and arrow for that.
You didn't answer the question, you wsgi!
Digging the morphological methods 
This is good advice, from the point of view of someone who has used nearly all the frameworks. Django gives you nearly everything you could need, and there's a wealth of extra apps and addons to fill in any other gaps. If you go with a micro framework like Flask you'll end up having to write or integrate some of the same things. So more flexibility but probably more work too. Start with Django and you get a lot for free to get you started. You can opt out of any of the components that Django offers at a later date, though it does require a little work. 
&gt; But as soon, you want to setup new css codes, the amount of work to change the defaults is huge. It uses Bootstrap. And you can just add your own CSS to override the defaults you don't like. That's the **C** in CSS. 
argparse beats docopt for more complex cases IMO. Also concerning path.py, Python 3.4 includes pathlib which does everything path.py does and more. Cannot argue about arrow and requests though :-)
Tornado? You can't really use most of the available Python libraries. They need to be async or you lose all benefits from Tornado. It's OK if all you do is available in a Tornado specific library. So for normal Web + MySQL you are clear to go. 
No need to use SQLAlchemy with web2py. You have the DAL (Database Abstraction Layer) which is very capable and is integrated with form generation etc. 
Well to be fair the OP did ask about standard libraries. With so many smart people contributing to Python, of course it is highly probable that someone out there has created something better than what's in the standard library. That is the nature of Python's ecosystem. I'm sure someone on another day will start a thread asking what non-standard libraries people use often. That'll be interesting too.
Pyramid is python 3 compatible.
&gt; Tornado was developed by facebook No. 
[Did You Pick the Wrong Web Framework?!](http://marvinli.com/2014/06/06/pick-wrong-web-framework/)
How did I not ? Django is not a pure WSGI framework because it does not deal only with the wsgi model. Tornado is not a WSGI framework at all. Cherrpy is deals with WSGI from the start, and ONLY WSGI. Purely WSGI. What else do you want ?
Yes, what I meant is "why is there so many people using these ?" since we got better alternatives.
Yeah, but how many time do you need these in your life ? Twice ? And pathlib doesn't do everything path.py does. Far, far from it. It lacks : - iteration with filtering; - in place file rewriting; - file reading by chunk - tempdir shorcuts with context manager; - cd context manager - write/read shorcuts - hash shortcuts - alternative shortcuts for when you want to ignore errors - recursive delete/copy I'd say however it does everything pathlib does, and work with Python 2 and 3. 
Pip is now included w/ python 3.4+
Ok, it was originally developed by friend feed who were acquired by facebook who continued development. It is currently developed by facebook as one of their open source technologies. Better?
I've run into beginners who think they "know" how to program in Python after taking an introductory course, but find out the concepts didn't really sink in with them (myself included). To test yourself, head on over to [codingbat](http://codingbat.com/python). If you can do some or most of these puzzles without a problem, then great! Otherwise, back to the drawing board. Also look [here](https://github.com/karan/Projects) for programming project ideas. It has an awesome list of examples in different areas of interest. Also check out the "Sources" section at the bottom for more project ideas.
What is the point of insulting someone for adding something to the discussion when they're not trying to fabricate stuff to sound intelligent? Its not like I stated I used all of them and then proceeded to say nothing correctly.
If you are using Python 2.x and dealing with text files locally, check out path.py, although not sure what's the [state](http://stackoverflow.com/questions/3899761/will-the-real-path-py-please-stand-up) of it recently since I use Python 3.4's pathlib. It's not related to text processing per se, but it is a great library for dealing with files, paths, etc. which will be crucial with processing text files locally.
I read the question as "what is a WSGI framework in the context of Python, and what does it mean for one to be pure?" In two attempts you didn't define WSGI. PS I mean no offense, thanks for your summary.
Better. When I looked at Tornado in 2009 there was a bug in escaping for HTML. Not a good first impression. Just looked at the issues and it was closed (fixed) 4 months later. 
[Reddit](https://github.com/reddit/reddit/tree/master/r2) is built on Pylons. Pyramid is the modern version of Pylon's web framework. But other than that, Django is quite dominant. It's hardly a bad pick. When scaling up, pretty much anything you pick will struggle above ten thousand concurrent users or so. Don't worry too much about the scaling issue to begin with, I'd say. Think more about the general speed and such for your application, and to keep your code clean (both database and logic code, it's way to easy to forget about the database). That'll make it easier to cope with the scaling issue later.
You may have just rocked my vim world with this plugin!
Check out Geany. Good cross between heavy text editor and light ide.
Well, if you come Django then you're going to lose out on all the helpers, admin area, etc... Don't get me wrong, Django is a good framework, as its one of the most used in Python from my understanding. But Django gives you a lot of extra tools at your disposal that Tornado doesn't. Think of it like a server. You can either get it fully managed, one-click installers, cPanel-usage (which would be Django), or self-managed, thrown into the CLI and hope for the best (this would be Tornado).
Except sometimes even installing a library is more work than using a built-in one, however ugly it may be. When all you need is `os.path.join(os.path.dirname(__file__), something)` to find a resource, path.py is an overkill.
&gt; call jQuery from Django This doesn't really make sense! Django runs on the server. jQuery runs in the browser. Django delivers a page to the browser that contains jQuery code. It could even dynamically generate javascript based on server-side logic but I don't think that's what you mean. Try explaining your problem in a different way.
 ====== the side bar ==========================&gt;
Tango with Django is great but it's a bit outdated, challenge yourself to write everything using class based views (look them up!) and try to use something like Jinja2 as a template engine instead of the default Django template engine (which will be severely limiting once you start doing a real project). Since you're starting from fresh I also suggest you look into the JSON response views for AJAX calls, introduced in Django 1.7. Since you're pretty good with Javascript I can highly recommend checking out Twitters [Flight](https://github.com/flightjs/flight) for the Ajax stuff. Some of the stuff is quite advanced but Twitter has produced a really awesome piece of work, invest some time in it and it'll be greatly rewarding. Quite frankly, if you follow Tjango with Django the original way you're not going to be able to write a maintainable, stable web application. It'll make it a bit harder but if you do challenge yourself to do Tjango with Django the "modern right" way you should be equipped to create a decent application without any problems after this. 
I think Armin just shot himself. He goes through all the pain getting Flask to be Python 3 compatible, and then some people still think it's Python 2 only ;)
One of the reasons I went pyramid is because a significant portion of my time is spent on projects that 'need' an ORM, but aren't webapps. Learning SQLAlchemy is better use of time than learning SQLAlchemy + Django's ORM.
I'm not OP, but I did a brief evaluation of Flask, Django, Bottle, and Pyramid for a new project I'm starting and ended up picking Pyramid because its philosophy and way of doing things happened to align nicely with my project's goals. Namely, it doesn't try to be a minimalist micro-framework, it's suitable for a fairly hefty, complex app, but on the other hand it doesn't force you to do everything the "One True Way" (Django). You can mix and match the features you actually need. For instance, I am using jinja2 templating (what Flask uses) instead of Chameleon. In fact Pyramid lets you use basically any templating or ORM you like. I also like the flexibility of having both URL dispatch and traversal style lookups because my app naturally fits the hierarchy of traversal yet also needs some "special" views. [Here's a good article that explains and defends some of the design principles of Pyramid.](http://docs.pylonsproject.org/projects/pyramid/en/latest/designdefense.html) Also: [What makes Pyramid unique?](http://docs.pylonsproject.org/projects/pyramid/en/latest/narr/introduction.html#what-makes-pyramid-unique) 
&gt; forget about its framework part cause it's very verbose. Could you expand please?
Actually, CherryPy added support to WSGI but never was designed around it.
It means it's pure Python, it doesn't rely on a C extension. I have no idea what @desmoulinmichel is on about.
&gt; Cherrpy is deals with WSGI from the start, and ONLY WSGI. Purely WSGI. The last part is slightly misleading. CherryPy doesn't force you into using WSGI at all. See http://docs.cherrypy.org/en/latest/advanced.html#no-need-for-the-wsgi-interface
last time i reviewed such libraries(which was long ago) , i really like pattern http://www.clips.ua.ac.be/pattern There are also https://pypi.python.org/pypi/PyNLPl/ http://textblob.readthedocs.org/en/dev/
Yeah, I would prefer SQLAlchemy, but the Django ORM is fine for most use cases. Anything more complex and you can jump down to raw SQL.
Do you mean reference a jQuery script in a Django template? Sorry, I'm not very sure what you mean.
Because numpy is the cornerstone of performance with numeric code and it's very heavily tied with CPython, so if we emulate what CPython does (which is super hard), we end up being slow and both numpy and PyPy lose their purpose, by rewriting it in RPython the jit can also look into it and optimize it more. &gt; Are they doing something more than simply porting the glue code (e.g. rewriting it in RPython) There's no glue code (or rather, it's 100% glue code) it's completely tied with the cpython c extension api, and it sometimes look at PyObject fields, which is impossible to emulate on PyPy or any other alternative implementation.
I would say django is overkill for a lot of smaller Web projects. If you're not using 95% of the features, why not use flask instead? 
Time to look up some phrases. I understand it from a high level, but there are several terms in there I haven't come across yet.
How is the community support with Pyramid? I know Django had a huge community.
So would you recommend it as a first framework?
Thats a fair point, I don't know a lot about the community. I've never sought support, but I'm not aware of any forums or mailing lists either. That said- I've never needed pyramid specific support. Because its really just a loose framework around other products most issues have been specific - specific example is SQLAlchemy- its complex, but theres lots of help/documentation out there.
Is there a better framework for over 10k concurrent?
Great article. Basically, I'm stuck in analysis paralysis and just need to pick one and move on.
python brand? hand-blown glass bong?
Because 3.2 -&gt; 3.3 is a subset of 3.2 -&gt; 3.4 ?
Sounds reasonable. At a certain point, any framework will need to be modified for scale. Hopefully, by that point, I'll have several more developers with more relevant experience. Like most start ups, it's just me for now, but by the time scale becomes an issue, I should be able to bring in some experts.
And geographically routed requests?
That's awesome. I heard really good things about cryptography on a couple different podcasts. Sounds like you guys have something special on your hands. How has adoption been going? Do you have a cryptography for dummies? 
So is the data static, or does it come from or interact with another web app at your organization?
YouCompleteMe does completion for multiple languages and uses Jedi for its python support. Might be a better option to install
Understood. The ORM is optional.
Would you recommend it for a beginner in web app dev?
Any concerns about Django at scale?
Other than the initial setup being a little weird it went pretty smooth. I only had about 6m python experience at the time, but a long history of small php projects.
For three years now I've used Bottle for every web project, including one I'd label "mid-sized." I prefer staying close to the metal, I understand bottle and debugging has never been a problem as a result. I really enjoy this tiny framework and that alone boosts my efficiency in cases where something like Django might be the wiser choice. Go with what you enjoy most!
 ~$ find ~/Documents ~/tangent -type f -iname '*.py' -exec cat '{}' + | grep import | sed 's/^\s\+//; s/^from \(.*\) import .*/import \1/; s/as .*//; s/\s\+$//' | sort | uniq -c | sort -nk 1,1 1 import cProfile 1 import cpufand 1 import cpupower 1 import Cython.Distutils 1 import distutils.core 1 import distutils.extension 1 import errno 1 import multiprocessing 1 import nltk 1 import nltk.tag 1 import nltk.tokenize 1 import optparse 1 import pickle 1 import pprint 1 import praw 1 import random 1 import scipy.misc 1 import sqlite3 1 import squlite3 #oops, clearly never got that running 1 import sysfan 2 import math 2 import mutagen 2 import nltk.corpus 2 import socket 2 import telnetlib 2 import util 3 import contextlib 3 import docopt 3 import logging 3 import os 3 import re 4 import control 4 import filters 4 import hwmon 4 import threading 5 import itertools 6 import __future__ 7 import subprocess 8 import collections 10 import numpy 12 import scipy 12 import sys 19 import time I didn't bother to cull the non-stdlib, but it's a decent survey of my imports. The heavy use of `sys` is due to `sys.exit()` and using `sys.argv` for super simple CLIs when I'm too lazy to look up the docopt syntax. `time` gets imported a lot because many of my scripts perform some kind of data gathering function. Modules I particularly like are `itertools` and `collections`. `subprocess` is nice for scripting ffmpeg and the like.
For sure, if you're building a CRUD app. If you don't need auth, a database, forms library, translation support, etc., Flask might be a better option. I love Django, and I use it all the time, but it's definitely a heavy-duty framework when compared to some other python options.
you really should switch to docopt.
Not my experience at all. Basically, if you can do it in flask, you can do it in django. I've done plenty of non CRUD app, usually the hard part is not related to the web framework, it comes from in the task queue, the messaging layers, etc.
For small projects, having everything in one file, not settings file, and routing close to your views make things faster.
I didn't know that. +1 for you.
Flask and bottle requires 3 times less lines for the same job.
Import it like any other js script and then call what you want.
Sure, but scale is a much more complicated problem than "use this tool and you'll be alright". Approaches to scaling Django will be comparable to approaches to scaling any other framework. 
Weird... I had never felt that way. CherryPy is rather concise.
If you're doing a social app, there are a lot more things you should be worried about than scale in the beginning. But to answer your question, it scales fine. http://highscalability.com/blog/2012/4/9/the-instagram-architecture-facebook-bought-for-a-cool-billio.html http://highscalability.com/blog/2012/5/21/pinterest-architecture-update-18-million-visitors-10x-growth.html
Oh, you meant you don't know what WSGI stand for ? Sorry, It's true it's a bit of jargon. It's a Python standard for the API you use to turn an HTTP request/response (the texte ones comming from and to the browser) into Python objects. The initial goal was to make all frameworks using it compatible so they plug into servers the same way and even share middlewares (piece of codes intercepting requets). Basically, if something is WSGI, you can be sure it works based on a synchronous request/response workflow. You can't make nodejs / erlang competitors with a WSGI API.
I'll give it a try. I saw there is some bottle.py like syntax example for tornado. Maybe there is an asyncronous microframework to be written that finally doesn't need compiling a c extension.
There is value in sticking to the standard library modules as much as possible. Code can be copied to any machine and will just work, immediately, without needing to pull in extra dependencies.
Fair enough. I'm happy enough with CherryPy but there are enough frameworks that everyone finds his own gem :)
Exactly. Plus, cherrypy servers saved my ass many time.
And there are less points of failure, of course. 
...because they're part of the stdlib? Sometimes it's not practical to install additional libraries, especially when the standard one does what you need it to do.
Please don't just link to stackoverflow. Also, how about actually using the error message set in the variable so you see in what folder it searches? (instead of just printing the name of the variable that contains the error message?!) I suspect it looks in the wrong one, but you haven't shown enough to be sure
I will when it becomes a part of the stdlib.
why don't you use it now? it's easily installed using pip, and even easier to distribute since it's pure python.
Just a simple little module that I threw together a while ago, but just recently updated, and turned into a proper package. It was more a practice in packaging than anything else, but maybe some Python beginners will find it interesting/useful. I doubt anyone past the beginner stage would have any interest in this. **Edit:** Shortly after posting this, people pointed out that I forgot to change all of the calls to `build_deck` to `build`. That is fixed now. Sorry. Also fixed some botched documentation. I copied and pasted some of it from another, similar package I'm putting together, and forgot to change some of the import names. Today is one of those days, I guess. Brain not functioning. Also, anyone interested in this, might also be interested in my other package: [**PyRoller: Dice Package**](http://www.reddit.com/r/Python/comments/28tokw/pyroller_dice_package/) **Edit #2:** Noticed a few other things that need fixing. All of the docstrings for all of the methods are missing their parameter descriptions. Woops. Sorry. I think I need to start looking at my code a little harder, and double checking things more often. Too many stupid little mistakes. **Edit #3:** Alright, I may be in over my head a little, on Github. I didn't expect my little hobby project to get much attention, if any, but it seems that people are now making pull requests, and raising issues, and it's turning into a bit of work. I am not against that, I just am not sure how to proceed. I am not sure how to keep the project/documentation/changelog tidy if everyone is changing stuff. I need some help, I think. Maybe someone out there is a little more familiar with Github, and can help me out? I am in a pickle.
Probably `os` and `datetime`.
Sorry, i'm a noob and I cant get it to actually output the error message, here is exactly what I get: SystemExit: MISSING_CLIENT_SECRETS_MESSAGE. Thanks for the advice.
Why? If it suits mebimage's needs...
yes, because that is what you tell it to use as the error message: flow = flow_from_clientsecrets('CLIENT_SECRETS_FILE', scope='YOUTUBE_UPLOAD_SCOPE', message='MISSING_CLIENT_SECRETS_MESSAGE') You want to give it the variable MISSING_CLIENT_SECRETS_MESSAGE and not a string saying 'MISSING_CLIENT_SECRET_MESSAGE', just remove the '
!!! How did I not see that. Thank you.
Yea It is showing me the exact path that contains the client_secrets.json file. :/
Thanks for sharing this!
Depends on the need. I prefer it so I have more control over design and extendability. It is easy to learn how to set up a hello world app though.
You need asynchronous libraries: https://github.com/tornadoweb/tornado/wiki/Links You can't just use every normal (synchronous) library. IO to a database would stop your server until the data is collected. This request will then block until your IO is done. 
I don't think "confused" is the word you want, and, what's your actual question?
You are quite welcome. I am glad someone may have a use for it, even if it is just for toying/learning. Please toy with PyDealer to your heart's content.
So, yes, there are reasons to use those libraries. However, I think that you're mistaken if you think that's the list of all libraries that you can use. Consider: https://github.com/leporo/tornado-redis "I recommend using both tornado-redis and redis-py clients for your Tornado Web Application. Use tornado-redis to subscribe to Pub/Sub notifications and for blocking commands such as BLPOP, BRPOP, BRPOPLPUSH. You may safely use redis-py for most of other cases." This is true in many situations, including the default psycopg2.
&gt; I think that you're mistaken if you think that's the list of all libraries I haven't said that. 
Great docs, thanks for sharing :)
I like tornado, it is twisted that I have issues with (API, documentation - I always had to read the source) Edit: Is your question "Why would you use cyclone rather than tornado?" ? I would use it if there is some twisted component that I would have to use (like a database connector), but want to program my website like I would with tornado. If you have a website using tornado, you just change a few import statements, and you'll have a cyclone website instead (running under twisted's event-loop rather than tornado's own event loop).
No problem! I try to document my code as best I can - not only for other people, but for myself as well. It's easy to forget what does what, without documentation, even if you've written the code yourself. This package is pretty simple, so even without the documentation, I'm sure most people could figure it out, but I'd rather get into the habit of documenting all of my code as I go. 
I think 4chan is one of the worst places on the internet, and we'd all be much better off if it simply fell off the internet.
&gt; wouldn't using docopt be harder, not easier? learning a new thing takes effort. using a learnt thing might save effort.
You're going to see comments like this about almost every large web framework. As the complexity of a web site goes up, some of the generic components found in Rails, Django, Spring or any large web framework often end up being more trouble than they're worth. However, in the vast majority of cases you're never going to run into these problems because most websites are extremely simple CRUD apps and in these cases the framework often ends up saving you huge amounts of time. I don't even like Django, but the best thing to do is just pick one and start learning. Among Python frameworks, Django has the biggest community by a huge margin so it's definitely not a bad choice. 
&gt; However, the __iadd__ method supports only immutable types. I think you meant "mutable" there.
For some games (pitch that I know of), there's a big joker and a little joker, just FYI. Very nice work!
Ah, see, I did not know this. I am sure that my little package has it's issues. I'll have to look into these different jokers, and maybe find a way to implement them. Or maybe someone else wants to (anyone out there)? ;) Thanks for the feedback!
100% agreed. I'm running a large django-based product, it has saved us a huge amount of time and still does. The hard part comes when you have to turn your architecture into a suit of components because you need more than a request/response framework.
To compliment [my other little package, PyDealer](http://www.reddit.com/r/Python/comments/28t9xh/pydealer_playing_card_package/), here is PyRoller. It's for simulating dice, but it has a "neat" feature, which is that it uses [dice notations](http://en.wikipedia.org/wiki/Dice_notation) to build dice objects.
AWS' Route53 will give you that.
Oh thanks, that's right! I will correct that when I get back home later! Thanks!
Your architecture might need a bit of a revamp. Django really doesn't get in the way of scaling anything up. It is at its core url routing + request/response and there isn't anything slow or cumbersome about how these are implemented. Everything is replaceable and for good reasons. And in a very large majority of cases, you don't have to replace a lot, if anything. What did you have to rewrite?
Don't get scared. People might need to tweak their app (including whatever framework they use) on pretty much any very large project, regardless of language and framework. If you're sestting out to build something like Disqus for example, then your first concern should be your architecture, and then you should take into consideration your particular scaling problems and see which custom bits you need to put in place. Nothing out of the box will fit the bill perfectly for your business at this scale. This said, it's very specific and not a concern to get your product and company running using Django. I built my startup on it and we're still developing new products using it. Django is a very solid base, and very easy to get going with as far as exhaustive frameworks go. The consensus in its community is now that it's "boring" because it's so consitent and robust. And that's a good thing.
If your API is simply sitting on top of your website/webapp, and you decide to go with Django, do use django-rest-framework. It's great.
So all you're saying is that using the async features of Tornado requires using libraries which support async IO. Cool, I would have hoped everyone knew that. For what it's worth, Tornado is superior (in performance) to Flask even if you let it block. It's really, really fast.
so is Flask/Werkzeug (pure) WSGI ?
Ask and ye shall receive! Just run `pip install lurkmoar -U --user`. `Post` objects should now have an `image` attribute.
Woo woo, you used my pull request!
Ah, that was you? I had actually never even looked into pull requests and all of that on Github (I'm still a Github noob). This is the first project I've ever worked on where anyone has actually made a pull request. Actually, I wasn't even sure what I was doing when I hit "Merge pull request". Luckily it did what I thought it would. And thanks for catching that bug! I fixed the only other call to `build_deck` as well. You are now the first person I have ever technically "collaborated" with on a project. I would love to collaborate with people more, but I am really not a very good programmer. I am self taught, and have only been dabbling for about 10 months.
It was my first time to make a pull request. I just started using GitHub yesterday. I had an account but never did anything with it. I'm working on a deck of cards, too. I think you commented on one of my posts in the past couple days. Anyway, I'm taking a slightly different approach than what you did. Mine is incomplete. I'm building a game of war, but I'm building a deck of cards in it, too. I'll probably extract the cards and make a module for them and use them for other games, too, once I get done with this. Here is mine: https://github.com/danielveazey/pywar
The author should run their code examples through py-flakes so they discover that they have syntax errors before publishing... Or even just see that the rendered syntax highlighting in the post is off as a result.
Awesome! And yes, that was me that responded to one of your posts. Didn't even realize you were the same dude. Cool. And what you have there is looking good so far (not that I'm a great judge). It seems to work fine for me. I had planned on making a few simple card games myself, just to provide some examples of how PyDealer could be used, but I haven't got around to it yet. Who knows if I ever will. 
It's a fun hobby.
Flask works also with fastcgi, so I'sd say no.
Because Pypy is a candidate for the future of Python : lots of people wish for it to succeed in eventually replacing cpython as the default implementation to again speed and potentially go stackless. But this can't happen if it is stuck in Python 2.7. 
Forgive my frankness, but [it's terribly unreadable](https://github.com/autonomoid/wordsworth/blob/master/wordsworth.py). I wanted to see if you used `collections.Counter` for some of your stated features, but everything is a mass of module-level code. You should separate your concerns into functions so that the features are clearly defined. You've got a good start, now start refactoring. Also, check out [`collections.Counter`](https://docs.python.org/2/library/collections.html?collections.Counter#counter-objects) to simplify some of your code. Edit: To make me feel less of a dick, if you're interested in some suggestions, I'd be happy to help.
Excellent Package. I just modified it locally to handle Uno Cards and it only took me a few minutes to extend. This is beautifully written and very easy to use.
&gt;every library under the sun Personally, I'm developing a "just for fun" library exclusive to Python 3. Of course, it's not enterprise-ready, or indeed enterprise-targeted, but that's not what you said.
im avid fan of web2py but its DAL (at least a two years ago) broke on the stupidest stuff and straight up failed on some SPs in both oracle and sql server that i had to use sqlalchemy instead.. this isnt bad.. but i dont think the DAL is something the should be trumpeted as an accomplish.. its only an accomplishment vs django far worse implementation .
depends on perspective of easy. If you mean 'is it easier to port over an application after i figure out how i want things to work using the training wheel of web2py.. sure." but if you mean by syntax certainly not. theyre two different animals. 
Thank you! I really appreciate it. It's always nice to know that what your doing isn't complete garbage. I *tried* to make a nice little package. I am glad you are getting some use out of it. That pleases me greatly. :) To be perfectly honest, I am surprised at the number of upvotes it's received so far. I figured it was going to get buried, with maybe a few upvotes. Wouldn't be the first time, or the last. I am extremely pleased that people are finding something to like about it. I am stoked, actually.
That is good advice. I had not heard of many of these libraries, but I think the original used Mechanize because I believe he needed to actually interact with forms, as his tutorial was about searching google images for terms specified on the commandline. At least that's why I think he used mechanize, also not a python expert of course. I'll see what I can learn about requests and apply that thanks!
&gt; and potentially go stackless Stackless Python exists and has for a long time. http://www.stackless.com/
Hey, thanks a lot for this and especially for that generous release into public domain license. I know something recently changed with 4chan, maybe the day they added support for webm videos as pseudo gifs that broke applications and wrappers. Your wrapper is filling a void right now I believe as you said with others not yet updated.
not sure, I am not entirely familiar with the game. I found UNO / SkipBo fit the Suit / Number paradigm pretty easily so that one was easy to do. the cool thing with the more objective games is once you have this library all you have to do is code the rules. I have a play field right now that takes care of players / discard pile and card in play. Now all I would need is a way to handle wild cards, draw cards, player switching and an interface for viewing / playing cards thatâ€™s more sensible. And I would have a nice Uno game in about an hour of work.
My concern is basically that. The library, as written, provides support for just number/suit card games - which is likely the ones most people are familiar with. I think an abstract library with base classes for a deck, card and hand (which is essential a kind of deck, albeit in an extremely limited fashion) would be more versatile. However, I don't want to kick off an abstraction circlejerk. The library, as written, looks good and well suited to it's intended purpose. 
Also, you used "to different" rather than "two different".
Yeah, I can't say I had any other games in mind, other than basic french deck card games. But I'm pretty sure the package could easily be extended to add whatever functionality you want. It's pretty bare bones as it is. And now it's out there (on the internet), and if people want mess with it, they can, and I encourage it. I love the idea of people using/modifying something I wrote, even if it is just a very simple package, that anyone could have written, such as this.
I plan on dicking with it some and seeing what happens. Also, PyRoller made me think of a Python version of Agon I tried building a few years ago. Might revisit that, too.
PyPy has support for stackless, and a JIT, and maybe soon STM. Top commenter was referring to the fact that PyPy supports stackless.
One thing I would recommend, is not using tabs for indentation. [The PEP 8 style guide suggests 4 spaces](http://legacy.python.org/dev/peps/pep-0008/#indentation), which just looks a lot nicer anyway, if you ask me. Also, try to keep line length within an 80 character limit. It can be tough, and I don't even really understand why it's still recommended (it comes from a time when monitors could only display 80 characters per line, I think?), but it is. Some argue it's easier to read. And yes, the Requests package is your friend. Makes things a lot easier. I haven't used it much, but I did use it for a little [API wrapper I wrote](https://github.com/Trebek/DAPIWrap). And if you haven't looked into Python's extensive library of packages , you should. If you need to do something, chances are someone has made a package to do it, or at least help you do it. Wish I had some better advice for ya, but I am a rookie. lol
You can still interact with forms through GET/POST requests using, well, `requests`.
What ondra was getting at is that, at the very least, to do what you want to do, you'll need a simple web server running. Python has built-in libraries to do this, or you can run it as a CGI script (pretty much the simplest way of using Python to do web stuff). I wouldn't worry about being wasteful, if the machine is already running, a small web server script idling most of the time isn't going to use many resources.
One other thing to keep in mind is your function naming. The preferred python mechanic is all lowercase with underscores for functions/methods. So getPic would be get_pic. Capitals are reserved for class names. Granted, you'll see scripts that don't follow this, but most do, and it's good to be on the side of most.
hey. your code is pretty easy to read. nice job
To elaborate on u/ryeguy146, here is how you get the most frequent words using `Counter` and a regular expression: import re, collections with open("warandpeace.txt") as f: text = f.read() all_words = re.findall("\w+", text) counter_all_words = collections.Counter([w.lower() for w in all_words]) print (counter_all_words.most_common(4)) &gt;&gt;&gt; [('the', 34716), ('and', 22296), ('to', 16753), ('of', 15003)] For pairs of words it's a little trickier because they can overlap, so they cannot be found using `re` and you would have to use the `regex` module instead: import regex all_pairs = regex.findall("[\b|\n| ](\w+ \w+)", text, overlapped=True) counter_all_pairs = Counter([w.lower() for w in all_pairs]) print (counter_all_pairs.most_common(4)) &gt;&gt;&gt; [('of the', 3845), ('to the', 2203), ('in the', 2189), ('and the', 1387)] For some reason I don't get exactly the same exact numbers as you, but the ranking is the same.
I know dude, most Stackless concepts have been integrated into pypy : http://en.wikipedia.org/wiki/Stackless_Python. Pypy and stackless have been working hand in hand for a long time. Why is everyone on this subreddit so eager to try to find some lack of precision and correct it ? I feel like talking to 5 years old know it all.
fruit flies like a banana
Stackless is good old slow cpython with a mod. When performance is critical stackless cant compete with pypy. Now with pypy3 (esp when they fully support python 3.3) we will be able to use asyncio module which pretty much makes stackless obsolete. Please correct me if i am wrong with last statement. I may not be aware of other stackless goodies that asyncio does not have.
Working with python3 is more pleasant in general. Sure you still find some abandonware that does not support python 3 but it is not that often nowdays. Besides 3.0 has been released on 2008 december - thats plenty of time for it to get stable. I personally use python3 whenever i can and i am converting my old scripts (even if with pain, noone likes to do converting) to py3 and i do not plan to look back. One thing why i still use py2 in some instances is dependency on py2exe but that is being phased out by cx_freeze.
&gt;Sure you still find some abandonware that does not support python 3 but it is not that often nowdays. There are like 40000 packages on pypi that don't have support for python 3, compared to 5000 that do have it. While most of the popular packages do have py3 support I definitely wouldn't say that you don't often find pcakages without python 3 support.
I think its important because one of the most often cited problems with cpython (and by extension, python in general) is performance. Other languages like Javascript and Go are gaining valuable mindshare from our community due to python's inability to keep up performance-wise. PyPy3 gives python as a whole hope from 2 angles. 1. **Performance**. We can now advocate for Python without having the performance book thrown in our faces. This might also mitigate the recent trend of developers seeking faster alternative languages. 2. **Encouragement**. Now we have a fairly powerful marketing tool for the Python 2.7-only library crowd to make the jump to 3. We can sell them on performance. And this will bring the Python 2.7 developer crowd to the land of Python 3. In the future, hopefully this will bring more bright minds into the Python contributor fold. And THAT will take us one step closer to some bright spark coming up with a way to remove the last great hindrance to Python domination... GIL. So from every front its a good thing :-) 
If you have any suggestions I welcome them - this was just meant as a bit of fun /learning exercise.
Its probably a bug in my code
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**DOT (graph description language)**](https://en.wikipedia.org/wiki/DOT%20(graph%20description%20language\)): [](#sfw) --- &gt; &gt;__DOT__ is a plain text [graph](https://en.wikipedia.org/wiki/Graph_(mathematics\)) description language. It is a simple way of describing graphs that both humans and computer programs can use. DOT graphs are typically [files](https://en.wikipedia.org/wiki/Computer_file) that end with the *.gv* (or *[.dot](https://en.wikipedia.org/wiki/.dot_(disambiguation\))*) [extension](https://en.wikipedia.org/wiki/File_extension). The *.gv* extension is preferred in cases where there could be confusion with the *.dot* file extension used by early (pre-2007) versions of [Microsoft Word](https://en.wikipedia.org/wiki/Microsoft_Word). &gt;Various programs can process DOT files. Some, like *OmniGraffle*, *dot*, *neato*, *twopi*, *circo*, *fdp*, and *sfdp*, will read a DOT file and render it in graphical form. Others, like *gvpr*, *gc*, *accyclic*, *ccomps*, *sccmap*, and *tred*, will read a DOT file and perform calculations on the represented graph. Finally, others, like *lefty*, *dotty*, and *grappa*, provide an interactive interface. There exists also a *GVedit* tool which combines a text editor with noninteractive image viewer. Most programs are part of the [Graphviz](https://en.wikipedia.org/wiki/Graphviz) package or use it internally. &gt;==== &gt;[**Image**](https://i.imgur.com/SiZ4k5a.png) [^(i)](https://commons.wikimedia.org/wiki/File:DotLanguageUndirected.svg) --- ^Interesting: [^Graphviz](https://en.wikipedia.org/wiki/Graphviz) ^| [^List ^of ^file ^formats](https://en.wikipedia.org/wiki/List_of_file_formats) ^| [^Trivial ^Graph ^Format](https://en.wikipedia.org/wiki/Trivial_Graph_Format) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ciepq7m) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ciepq7m)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
If you don't mind I can append to your list several items more You can revert, for example, string just using slice ``` s = 'qwerty' print(s[::-1])``` You can check condition in one line ``` i = 3 print(i if i &lt; 5 else 0)``` or another if trick ``` condition = ['Error', 'OK'] value = 1 print(condition[bool(value)])``` As long as pyhton does not have switch construction you can use somthing like this ``` choice = 'i' print({'i': 1, 't': 4, 'j': 22}[choice])``` 
For me, the big deal about PyPy is that it's written in (r)Python. That's not just aesthetic, it's important to a language; if your developing user-base have no applicable skill to the improvement of the language itself, it's another barrier in the path of continued development. CPython is a blend of pure C and Python, but mostly C. Some parts of it are old and hackish and are not often maintained because they're pretty arcane. PyPy may not be pretty either, but at least it's written in roughly the language it implements; users who become experts at Python can start helping to improve PyPy. The "Self Hosting" achievement is considered a critical step of a compiled language. Most interpreted languages don't ever bother achieving self-hosting, because it's very difficult to achieve in the first place, because compilation of dynamically typed stuff is challenging and error-prone, and because most interpreted languages are not used as solitary languages but rather extension or scripting languages for compiled platforms. PyPy is remarkable for that reason; it allows one of the most popular interpreted languages in the world to *self host*.
 sudo pip install kills kittens. Use virtual envs or your distribution packages.
Although very old, still contains a lot of important examples http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html
From the python documentation of `random.shuffle` &gt;Note that for even rather small len(x), the total number of permutations of x is larger than the period of most random number generators; this implies that most permutations of a long sequence can never be generated. I do think a deck of cards `len(x) == 52` is long enough that shuffle won't generate all possible permutations. I saw an article on reddit not long ago how somebody had hacked an old poker game using the fact that their shuffle function would only ever reach a small fraction of the possible permutations of a deck of cards. Edit: Found the article. http://www.cigital.com/papers/download/developer_gambling.php It also highlights many other flaws with the particular alogirthm they examined. I am sure the random.shuffle function is pretty sound other than what they have mentioned in the docs. It turns out there are approximately 2^226 ways to order a deck of cards. If your RNG uses a 32 or even 64 or 128 bit seed it will only ever reach a small number of the possible permutations(which might not be a problem in itself but... it is complicated read the article :)). 