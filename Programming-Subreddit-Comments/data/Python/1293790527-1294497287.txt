free e-book: http://learnpythonthehardway.org
If you are an experienced programmer (in any other language besides python, go take http://pythonchallenge.com
I started with the official Python tutorial. Found it to be very useful: http://docs.python.org/tutorial/ 
if you only have basic programming experience, try MIT's open courseware. [Course 6.00](http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-00-introduction-to-computer-science-and-programming-fall-2008/index.htm)
I like the epilogue. In my job position I'm not supposed to code myself (but manage projects). But I do. And often I need to explain myself doing so. I guess I'm a nerd with a secret weapon ;-) ... Really nice epilogue.
I use this: http://www.vim.org/scripts/script.php?script_id=1788 "*The Bexec plugin allows the user to execute the current buffer if it contains a script with a shebang (#!/path/to/interpreter) on the first line or if the default interpreter for the script's type is known by Bexec. The output of the script will be grabbed and displayed in a separate buffer. *"
Here's what was in my shell history, for what it's worth. inotifywait -q --exclude .swp -r src -m -e MODIFY |while read path event filename; do echo $event $filename; echo; ant debug; done
http://python-forum.org is a good forum with a friendly community, it has helped me in trying to learn Python.
What can I say, you are right.
bottle has to run through 2to3 anyways and str is left untouched by the conversion tool. So there is no point in doing `type('')` in this particular case.
Here was my Python code for the Pythagorean triples: for a in range(1,1000): for b in range(a,1000): for c in range(b,1000): if (a+b+c)==1000 and (a**2+b**2)==c**2: print a*b*c Takes about 2 minutes to run, but only took about 2 minutes to write ;) As for the number divisible by all numbers from 1 to 20, you can construct the number by hand. Simply take the prime factorization of all of the numbers 2 through 20, noting the highest power for each prime factor, and then multiply them all together. Eg, for the numbers 1 to 10 you would have 2^3 . 3^2 . 5 . 7. 
I don't think room sharing is a requisite of PyCon financial aid, but your money goes further if you do...
Hmm... link has vanished now.
neat. a similar library called [optfunc](http://github.com/simonw/optfunc/tree/master) was [discussed](http://www.reddit.com/r/programming/comments/8o09z/optfunc_introspect_python_functions_and_turn_them/) [ previously](http://www.reddit.com/r/Python/comments/8o0bl/optfunc_a_simpler_commandline_parsing_library/) but aside from argument passing, it solves different problems than pyeval. 
The source code is not that good. Works but not polished. Some functionality missing. Sorry about that. Will fix as time permits.
It's unpythonic and I don't see the point.
That's really cool, love the demo videos
What are your plans for this software?
Happy Reddit birthday!
Excellent book. It was what I used to learn Python. I would also recommend the videos here: http://code.google.com/edu/languages/google-python-class/ The videos include a lot of the stuff in LPTHW as well as some things that LPTHW doesn't get into. For instance, Regular Expressions, web page retrieval, and file system utilities.
Thank you, and happy new year!
I will take suggestions. I am mostly interested in using as a teaching too, create client side APIs and allow students to implement/test trading trategies on simulated data.
Look into this: http://code.google.com/p/web2py/source/browse/gluon/contrib/comet_messaging.py
&lt;3 Flask
Why do you think it's unpythonic? It's based very closely on Django's model syntax..
You might already be sick of hearing this, but man, you're a lean-mean-programming-machine. Kudos on the great work!
Maybe, I'm not exactly sure *why* what's happening is happening; usually functions easily refer to external variables.
I was thinking, "Hmm if I want to add mini-games or something like that I should really clean up and structure my code." This sounds like a way for me to do that.
I don't see anything obviously wrong here (although I wince every time I see an `eval`). What does the rest of the code do?
I see you generate a list of text surfaces. Are you blitting them onto that 192x512 rectangular surface? My guess is that you have something like for item in len(displays): mainrectangle.blit(displays[item][0], (displays[item][1], displays[item][2])) Where main rectangle is a surface you setup with the size you specified. If you don't, then thats probably whats causing the error. In any case post more of the code.
inotifywait is a one-shot (it sets up the watches and exits after the first event), you probably meant inotifywatch like in your first post. probably just a typo I mean, what you wrote will work, but only once, so there's no reason to have that while loop there.
See for yourself. [Link.](https://docs.google.com/Doc?docid=0ARnOMMFxuxPfZGd4Z2pxamZfMTE5ZGZreG1kZzY&amp;hl=en) It's an FE remake. Let me know if theres an easier way around this other than eval. I'm planning on changing around the whole nextchar() thing to make it truer to FE turns but at the moment eval seems to be the way to go.
Rest of code [here.](https://docs.google.com/Doc?docid=0ARnOMMFxuxPfZGd4Z2pxamZfMTE5ZGZreG1kZzY&amp;hl=en) It's not much yet, and it's not pretty, but I'm working on getting the game running first, then optimizing + prettying up. Thanks for the help =)
Sweet. Is there a particularly stable release you recommend?
Looks like i need permission to view the document. I sent you a view request. Also, its ok if your code is not optimized yet. Given that your still working on it I understand it's still a draft (my first write of code is always a little messy)
That's strange. How do I make it public? Anyways, A-OKed you.
Cool. Anyway to make the document public you have to: * At the main menu where you see all the docs click the check box you want to make public * Then click the share combobox -&gt; share settings * Then at the very top you can click "change" to change the share settings. Any how. Its probably best if you just pastebin/git pasted the stuff. Looking through your code right now. Do you perhaps ever go on on irc or something? Probably easier to talk there
It would be better if constructors take keyword arguments instead of a dictionary…
Okay giving a code a once over I think my initial assumption is right. You have a sprite group of text being directly drawn onto the background surface. Instead what you have is a class that: * Sets up a rectangular surface large enough to hold your text * Generate a list of text featuring the desired stats of the currently selected character (Name, HP, MP, etc). This would probably be in the body of the update method * Blit the text items onto the surface you set up in step 1 incrementing the x and y positions accordingly * Have that single sprite in a group of its own (or you can just have a group for all your text). Single group explained [here](http://www.pygame.org/docs/ref/sprite.html#pygame.sprite.GroupSingle) 
Apologies, I'm being thickheaded, but I don't quite follow. (By the way, thanks! The code is public now. I don't IRC often, though I have IceChat, having found IRCs quite unhelpful in the past) So, what exactly is my problem? &gt; **You have** a sprite group of text being directly drawn onto the background surface. **Instead what you have** is a class that: This is the main part that sent me into spiraling confusion &gt;.&lt;
Looks pretty cool. I'm not sure what benefit it has over Ian's FormEncode package, other than a more appropriate name. I often use FormEncode to validate/transform dictionaries decoded from JSON blobs from things like the Twitter API.
This can be a pain if the keys are unicode. You can't use unicode keys in kwargs. I wish this wasn't the case, but it is. :(
Oh, sorry i meant was "what you should have" is a class that contains the criteria in the list.
So in other words add something along the lines of: self.image = pygame.Surface([192, 32]) into the DisplayObject class?
Yes, then you clear it (either by drawing a background image or filling it in) and blitting each peice of text onto that. 
Doesn't the Display class do something along those lines?
There was an automation library for python that had the source code. Something like autopy. https://github.com/msanders/autopy I used that ages ago for bejeweled.
Hey, I don't know if you've tried watchdog, which I wrote recently for monitoring files/directories and performing actions in response to those events. Here's how you can do that with a script that comes with watchdog (the source tree also has a "nosy" script like yours): https://github.com/gorakhargosh/watchdog/blob/master/scripts/autobuild.sh watchmedo shell-command \ --patterns="*.rst;*.rst.inc;*.py;*.py.swp;*.rst.swp;*.rst.inc.swp" \ --ignore-patterns=".*;#*;*~" \ --ignore-directories \ --recursive \ --command='nosetests -v' \ src/ docs/source/ Project source code at: http://github.com/gorakhargosh/watchdog It supports Linux, OS X, BSD, and Windows currently. HTH. =)
If this were read/write, it would be awesomer.
Thanks for your report.
No problem, I found the link lacking useful numbers so figured I'd do something useful for once!
Broken.
What the Display class does is set up a rectangular area which is meant to hold the rendered text but does not necessarily have that text drawn onto it. What I am suggesting is a single class which first sets up a rectangular area then renders the text directly onto that surface creating a single sprite to be drawn on the screen. What you currently has is two classes and two sets sprites which are placed in a group and drawn directly onto the screen. Here's an example of the single class I propose (taken from [Game Programming by Andy Harris](http://www.wiley.com/WileyCDA/WileyTitle/productCd-0470068221,descCd-DOWNLOAD.html) the rest of the source code and slides are available are available in the download sections of that site) [example](http://pastebin.com/Lb80Msqm) All you has to do from there is add a method which takes the current character to be displayed and call it in the mouse[0] clause or when a character is selected (as in FE) *Edit: sorry im really bad at keeping track of who's who in this thread. Changed references from author and he she to you.
So basically it's a library to backport some standard library features back to Python 2.x?
A lot of the datastructures, abstract, importing, functional, caching and parts of itools are not part of the stdlib. So even though there are backports in there I've added mostly stuff I often reimplement for different projects.
You may want to make that clear because the paragraph at the top suggests it's just back porting. What have you done that's different to the stdlib?
Cool! Yes this is just the ticket. I'll have a look at watchdog.
The LFUCache is poorly implemented. `__setitem__` is O(n) when the cache is full.
Why do something weird like swap the case of all the vowels?
Man, someone should patch that.
I don't know enough about GIO to comment, but from a brief look they seem quite different in purpose -- even if there is some overlap in functionality.
Presumably because it's a simple operation that is very visually distinguishable while leaving the text readable. And it will affect almost every string, because almost all strings should have a vowel in them somewhere. If it swapped the case of all letters, for example, you wouldn't be able to tell the difference between an all-caps string and a translated lowercase string.
Alright so the problem was solved. It apparently had to do with the way the group was drawing each item in the DisplayGroup. In effect, it was drawing some pieces of the text underneath the Display object (the large rectangular surface). Removal of the Display object proved this.
I don't like the idea of general purpose utility libraries. Seems like its trying to take the role of a good cookbook. Namely, if I want to use a program and it uses 1 function from brownie, I don't want to have to download and install brownie. I think the function should just be included with the project. Utils are too individual to each project, and I think no matter what utils this library includes, it will be still be missing many ones that people need and including many that are unused.
Everything that's not already in Python 2.7/3 should be written up as a PEP. The backporting is different I guess.
I would hope that most people use the conventions that they like best. You don't have to follow PEP 8 where you don't want to, much of it is good, some of it isn't. You shouldn't feel that you need to justify your decisions to deviate from it.
I don't think it is very visually distinguishable, you could easily miss a string that way.
For personal projects, do whatever you feel like. But if you intend on getting contributions, having a non idiosyncratic coding style will ease the burden on contributors. 
It took me several runs of the game to figure out the object. I think the object is to avoid the cubes with your mouse pointer, right? This information is probably worth putting into the README. Also, strange things happen when I move the mouse out of the window. Well, not terribly strange, but I just seemingly randomly lose at some point. I haven't looked at the code yet, but I will.
I adapt to follow the recommended coding style for the language I'm using. You get used to it and it's best for everyone. From PEP 8: "words separated by underscores as necessary to improve readability" so I think .dirname is fine since it's perfectly readable.
next is a string object (type "str") which is returned from the raw_input function. that bolded line is treating the string as a sequence of characters - think of a string as a list of individual letters. If you had the string "reddit" the sequence of characters would be ["r","e","d","d","i","t"]. the line is basically saying "if there's a '0' character anywhere in the sequence, or a '1' character anywhere in the sequence, then ..." if you ask me, that's a terrible way to check for a number, as it will not work for anything other than numbers containing 0 or 1 (i.e. most of them, including 42 and 23, two of my favourite numbers). a better test would be: if next.isdigit(): how_much = int(next) but as the whole point of that tutorial is to follow it to the letter, I guess you're best served by doing just that.
Careful with those raw objects, you don't want to catch salmonella.
It's called serialization. Check out the pickle module, or the marshall module. http://docs.python.org/library/pickle.html http://docs.python.org/library/marshal.html
I do not know of a magic function that can just serialize a object and send it to an IP address. So this is going to take some work. You could use [pickle](http://docs.python.org/library/pickle.html) to serialize your objects. Or you could put the important the important data into a map and use [json](http://docs.python.org/library/json.html) or something similar to serialize the map. Sending the blobs to the client and back to the server is a bit more work. If you are not at the point where you even have a socket to the other client perhaps that is a good place to start. Making a simple socket based protocol is not that difficult, and you may find that you don't even need to serialize the objects like you expected.
I'll expand on the previous answer a bit. The 'in' operator looks in a sequence for the occurance of a target, anywhere in the sequence, and returns True or False. In the case you are confused about, the 'in' operator is looking for the single-character string '0' anywhere in the string returned by the raw_input function. But it's not limited to that. For example, 'it' in 'reddit' would return True, because the string 'it' occurs in the string 'reddit' (and strings are sequences) But this will also return True: 'reddit' in [ 'hey', 'reddit', 'this', 'is a', 'list', 'of strings' ], because lists are sequences, and one of the members of the sequence is exactly 'reddit'. However, this would return False: 'reddit' in [ 'hello reddit', 'import antigravity' ], because the string 'reddit' does not exactly occur in the list. Of course, the problem in the example is that if you are using '0' in next, and next is '10', it will return True, even if you really meant '10' rather than '0'.
I much prefer camelCase to using_underscore myself.
CamelCaseGetsAnnoyingWhenYouStartCombiningManyWordsTogether using_under_score_is_much_more_readable_which_is_why_PEP8_recommends_it AlsoCamelCaseDoesNotWorkWellWITHUPPERCASEDTHINGS whereas_UNDERSCORE_does
Check out twisted pb for a pretty powerful network object library.
Haven't used it, but [Pyro](http://www.xs4all.nl/~irmen/pyro3/) might be what you're looking for.
I don't think using marshal is recommended. Also, for a game, how would you secure either of those from executing malicious code?
Nailed it.
That is pretty much perfect!
json would seem to be the way to go here since it's going out over the wire. Pickle would work, but I suspect all sorts of problems could crop up from passing around python objects.
I'd suggest adding a mechanism to turn them back into a dict so that they can be serialized or stuffed into a backend like mongodb or riak. 
I maybe mistaken but I think streaming can be accomplished with WSGI by passing a generator or other iterator instead of a list. The iterator just emits packets of strings
That's a nice idea in theory but I don't want to nor do I have the time to write a PEP for everything I want changed or implemented in Python.
&gt;because the string 'it' occurs in the string 'reddit' (and strings are sequences) To nitpick a bit here, this is actually special-cased behaviour of strings, not normal sequence behaviour. Sequences like lists, tuples etc only support checking for the exact value as an element, so `[1,2] in [1,2,3,4]` would return False. (Otherwise it becomes confusing and error-prone, since you'd expect it to only match `[ [1,2], 3, 4]` as a sequence. Strings don't have this ambiguity, since there's no way of having a nested string distinct from a substring, so the behaviour was extended out a little to include substring matches as a convenience.
Personally, I prefer dashes, meaning `names-like-this`. Of course, most programming languages, including Python, don't allow that, so I like underscores as a close substitute. That said, [bevem2 is absolutely right](http://www.reddit.com/r/Python/comments/euolc/pep_8_underscores/c1b32xr) about adapting to the language you're using.
Nobody who can grasp software development would be so stupid as to struggle with a certain type of indentation or variable naming that they're not used to. Calling this a burden in the context of the type of problems that developers have to solve all the time is silly. Your only obligation is to make your code consistent with a reasonable style, not adopt someone else's arbitrary style decisions. 
cpickle - it's meant for that
My work is in Perl, and we're in the process of transitioning to Python. The camelCase vs. underscores was one of the few things that bothered me ( along with the 79 char/line thing). This was the best justification for the underscores. Thank you. 
 &gt; so I think .dirname is fine since it's perfectly readable. What is a dirn ame?
If you are sending objects over the internet, idk how much of a concern security is. I think the best way to handle this would be to have some sort of key in your objects, and then pickle them, and then deserialize in a "safe" way (possible?) and check the key before continuing. Or, even better, encode the pickle string with a key, and then decrypt with the same key. Some sort of authorized sender mechanism.
Django isn't the most pythonic thing. Hate to break it to you. Regardless, I like it, but I would only use it in cases where the property decorator would be used. Using the '.' accessor really isn't much better than using the "['key']" accessor in my opinion.
is there no network api in python? I know in java you can open up a stream and writeObject() to it
It's actually di rname. Don't feel bad. Common mistake.
PyYAML is quite convenient for serialization: http://pyyaml.org/wiki/PyYAML For a broader discussion of serialization with a C++ focus, see: http://www.parashift.com/c++-faq-lite/serialization.html
I respect a rubyist (?) for showing up in the python reddit to ask how he could enhance his tool. Honestly, I rarely open up libraries. Sorry I haven' used your tool, but does it open up the file in the default system text editor? I'm kinda confused as to how this would work with most multi-module (module = Python file) libraries, considering that code like import django just reads whats in the __init__ file. I think it could be really useful if it would just change directory to the file. Also, I could definitely see myself doing something like qw -r python project.foo.bar which is how python accessors work. It would be great if it supported that syntax. Essentially, if you want to make your tool work well for python, I would learn how python importing works.
`pip install brownie` is the effort required to download and install it. If the project which uses it adds it as a dependency, as it should, you don't even have to take care of that. Should you actually have to install dependencies manually you are screwed anyway. Obviously it is impossible to provide the utilities every project might possibly need. However implementing, testing and documenting every utility costs a lot of time and if Brownie can help you reduce that time it is useful.
&gt; How do I unit test this thing? Instead of it directly calling time.time(), it could call a function that you pass in to get the current time. Maybe something like this: def __init__(self, start_day=0, start_hour=0, seconds_per_hour=10, time_function=time.time): self.time_function = time_function self.start_time = time_function() Then you can have your tests pass in a function that returns whatever hard-coded timestamp you want to test against. I believe this is what's known as [dependency injection](http://en.wikipedia.org/wiki/Dependency_injection).
The point of PEP 8 is not to enlighten the world with the authors aesthetic idea of coding style and to provide the style which looks best, even though this is certainly attempted. The point is that everyone follows the same conventions in order to provide consistency among all python projects, which in turn prevents you from having to memorize the style guides of every project and dependency those projects might have because this truly has to be how the hell of coding styles looks like. No matter what your views on specific rules introduced by PEP 8 are, I surely hope you strive for consistency and can at least appreciate that.
Ooh, you so smart :) Thank you very much!
which is one reason i HATE using twisted. you're a python library that you expect other people to use. don't make me learn all your silly method names like ruby/perl, i want to be able to guess a method and get it right once in a while. you're not being smart and new, you're slowing everyone down.
Beware pickles in network protocols: [they allow malicious users to execute arbitrary code on your machine](http://docs.python.org/py3k/library/pickle.html#restricting-globals).
i break the 79 chars all the time, but not by much. if its a list, it should be one per row, if its a function, it probably shouldn't have much more than 3 levels of indentation, so split things up a bit more. comments and super sweet one-liner list-comprehensions are my big offenders.
Try package python-mocker. mocktime = mocker.mock() mocktime() # setting start_time mocker.set_return(42) mocktime() # in unpause() mocker.set_return(43) mocker.replay() g = GameTime(start_day=0, start_hour=0, seconds_per_hour=10, timefunc=mocktime) g.unpause() assert g.get_time() == "blahabout 43 you set above" mocker.verify() Or something like that. This is a simple case, but you can have 
can't downvote you, but i dislike the cut of your jib. my idea of good looking python code is not being able to tell a 99 bottles of beer script from a neural network on the shape of the code alone -- it all looks neat, clean, and plain. leave all the complicated stuff to ruby/perl folks who think they are 'code ninjas/rockstars' and allow me to go in and use your python code in a super boring and productive matter. this means following pep, and therefore getting the magical ability to guess function names without looking at your source code, and having it be intuitive enough to just get it right.
[The Jinja2 documentation](http://jinja.pocoo.org/) is pretty excellent in my opinion. I feel its worth pointing out that Jinja2 was/is created by the same group which created sphinx.
I don't think I write the best documentation, but [Blogofile](http://blogofile.com/documentation) (the [blogofile.com sources](https://github.com/enigmacurry/blogofile.com) specifically) has sphinx integration. When you build your site, the documentation is automatically built as well. What's nice is that this is all done automatically via a git post_receive hook.
Python itself is [documented using Sphinx](http://docs.python.org), as is [Django](http://docs.djangoproject.com/en/dev/). Finally, the new [Pyramid web framework](http://docs.pylonshq.com/pyramid/dev/) uses it as well, I believe.
YetIStillPreferCamelCase. YourMileageMayVary.
Namcor, Thanks for the input. I think your examples are illustrative, but they are too extreme. So they distort the true differences here to make the case that the underscore is vastly more readable. Do you really name your identifiers like this? I think these are sentences, not identifiers and thus in the context of reading a sentence the extra white space created by the underscore helps. What about here? # example number 1 if my_long_variable_name &gt; 0: print("greater than 0") vs # example number 2 if myLongVariableName &gt; 0: print("greater than 0") There is another recommendation in the PEP which suggests you cut down on the spaces between lines. A blank line is to help allow the eye to see something significant. The whole concept of the enforced white space to indent is also making white space something significant. White space is telling me something about the overall context of where I am at in my program. My point with all this is, that in the first example above, the white space and separation created by the underscore, in the interest of "readability" is going too far, its chopping up the line too much. Instead of four of five symbols I'm now parsing out eight because the underscores are creating extra white space gaps. I want to see an identifier as a single thing not four things in this case. And this is just one line of code, this difference adds up quickly. Now you may not buy this explanation and that is fine, but I think there is a cost there and this emphasis on separation between words in an identifier comes at the cost of making the whole statement harder to grok. The statement is more than its identifier and white space is important to seeing that statement. I think in some ways you and I are in the same boat. You are expressing a dislike for the CamelCase, yet the PEP tells you that you have to use CamelCase. And that very same PEP cites an example that ironically enough, goes against your concerns over capitalization Quote: &gt; Note: When using abbreviations in CapWords, capitalize all the letters of the abbreviation. Thus HTTPServerError is better than HttpServerError. CapitalWords, CamelCase (I meant to say mixedCase before) is the requirement for naming classes. So the odd thing about the overall readability argument that is made about underscores is that the PEP itself is inconsistent in these matters. You may think HTTP_Server_Error is much more readable but the PEP actually literally declares this mixed case, underscore naming convention as "ugly!". 
[Blogofile](http://blogofile.com) looks very cool. Thanks for sharing.
Yes, the dash is better than the underscore in that it breaks up the excessive white space of the underscore. &gt; adapting to the language you're using. I wonder what you do when you use Jython? Or what about the threading module inspired by Java. Here's an example of what you will see in the [docs](http://docs.python.org/library/threading.html): &gt; Note: Starting with Python 2.6, this module provides PEP 8 compliant aliases and properties to replace the camelCase names that were inspired by Java’s threading API. This updated API is compatible with that of the multiprocessing module. However, no schedule has been set for the deprecation of the camelCase names and they remain fully supported in both Python 2.x and 3.x. Examples: * threading.current_thread() * threading.currentThread() * threading.RLock() * threading.BoundedSemaphore([value]) * class threading.Timer * threading.setprofile(func) * threading.stack_size([size]) 
Combining these 2 helpful comments, I have added some mocking tests. I had already finished the tests just using time.time, but they took 2.9 seconds to run! Unacceptable! The mocking tests run in 0.004 seconds. Have a [look](https://bitbucket.org/jgrigonis/thefranchise/src/6eeb0db2d8a5/gametime_mock_test.py). I'm sure they can be improved...
I'm not sure you are addressing me directly or maybe you meant to reply to someone else commenting here? This code ninjas/rockstars comment seems far out in left field to me. I agree with almost 99% of what the PEP says. I try my best to follow it. I dislike the recommendation to move forward with underscores and the mix of choices I like I'm seeing in the threading module inspired by Java. Personally, I think the PEP should have stated something to the effect, that when using all lowercase makes a long, unreadable name either use an _ to separate parts of this name or capitalize the words within it like [Java](http://en.wikipedia.org/wiki/Naming_convention_%28programming%29#Java). People declaring there is some huge problem with readability with mixedCase and that underscores are superior and maybe happy the PEP suggest this are probably missing the fact that Python follows the Java CamelCase convention for naming classes. The PEP makes this statement &gt; Capitalized_Words_With_Underscores (ugly!) yet I don't see a huge difference between that and this: capitalized_words_with_underscores. If Java was written with underscores all over the place we could probably complain it looked more convoluted and verbose than it already does. Because the underscores create noise and extra whitespace where whitespace is significant and distracting when looking at a program. 
That was fast! Looking pretty good.
I [forked it](https://github.com/lightcatcher/micromodels/) and I'm implementing this (and a few other small things) now.
Monkeypatching, Duck Punching, etc :)
usingCamelCaseIsARealPainToReadItIsAlsoAProblemWhenDealingWithAbbreviationsYouMaySayHTTPButSomeoneElseMightSayHttp underscores_are_much_nicer_in_this_regard_http_will_always_be_http Python is supposed to be a language that's easy to read by humans. Personally, while looking for a library I will often pass any that don't follow PEP 8. (You wouldn't hire someone whose resume is in leetspeak, now would you?)
yes, [The Pylons Project](http://docs.pylonshq.com) documentation uses sphinx.
camelCaseIsReallyUgly. underscores_are_better
Don't worry about hours, days, etc. Just use seconds everywhere, with a ratio of real-world seconds to in-game seconds. All the hour/etc stuff is a matter of UI -- that is, only when displaying the time should you worry about it.
&gt; return "It is " + self.days[day] + " " + str(int(hour)) + " hours" `str(int(hour))` is a code smell. You should know what type your return values are. You shouldn't have to convert a value to an int and then a string. You should also be using string formatting instead of concatenation to produce your strings. If you later internationalize, you'll be happy you used formatting instead of concatenation. In fact, you should really be using time.strftime. Your "date" member should be on the class, not the instance, and it should be a list, not a dictionary.
I agree that underscores between words is more readable. That being said, camel case saves a character a word, which can easily add 3 characters to the line. Not exactly game breaking, but there are days when it can be fscking annoying.
&gt; I wonder what you do when you use Jython? That's a very good point. At some point, you *will* have mixed conventions, since you'd be using some functionality in Python's standard library and some functionality in Java's. Which style you'd use for code you write is tougher to decide. Perhaps it's a matter of whether you view the particular application as a Python program utilizing the Java's libraries, or as Java program that uses Python's syntax. &gt; Or what about the threading module inspired by Java. I'm not sure of the exact circumstances surrounding that, but it seems like a good idea to go with the PEP 8 style names, and it seems like something that should have been done from the beginning. After all, it is *inspired* by Java, but it *isn't* Java. (There's probably more to the story than that, so correct me if that's the case.)
I had to cast like this: str(int(hour)) because hour is a float, and I didn't want to print that it's 2.0 o'clock. I did use the string.format in the next revision. It just hasn't become second nature for me to start typing it out that way. I'm working on it. I'm just timing time with time.time, why would I want to format the time with strftime? I'm counting seconds. The output I don't care about. I fixed the date/days thing. I had just typed it wrong and it wasn't compiling, so I got all retarded. It's fixed now.
The ratio can change though. It's got to be more complicated than that. If it all ends up being throw away code, I guess that's what it is, but I think it'll be useful. I am going to need to answer questions like, "How long (in game hours) was Bob at work?" The user could have changed the game speeds several times between when Bob started and when Bob finished working.
I think matplotlib (http://matplotlib.sourceforge.net/) win the contest for most beautiful docs.
Make hour an int. It doesn't make sense for it to be a float. Convert things on their way *in*, not on their way out.
Good point, I'll see if I can unscrew that up.
That should be fine -- if you want to track some particular event you should only record the in-game time. Then the hours is always `time_bob_finished-time_bob_started`. The real-world time never has any historical significance.
[pyramid](http://docs.pylonshq.com/pyramid/dev/)'s are quite nice.
I see what you're saying now. I suppose instead of basing everything off the epoch in real time, I could make "an_epoch" as an in-game event, and then count everything according to that. Of course, in-game time could stop, slow down, speed up etc. That might be a better approach. I already see one flaw in my approach: if it's 8:59 in-game, the game counts that as 8:00, so if the user starts bob working at 8:59 he could get paid for a whole hour for only 1 minute of work. Obviously, the difference between the user starting bob at 8:01 or 8:59 is less than 10 seconds in the real world but I suppose it's a small concern. 
We use Sphinx for the [Review Board](http://www.reviewboard.org/) project for our [manual](http://www.reviewboard.org/docs/manual/dev/) and [code base docs](http://www.reviewboard.org/docs/codebase/dev/). It's nothing ground-breaking, but I've definitely been impressed by how much Sphinx made writing the docs easier. Instead of generating HTML, we generate pickled objects and then have code in Django that renders that into a page (caching it in the process) in order to better integrate with the site. I don't think that's in a public repo, but I can pass it along if interested. We've done some work with sphinx plugins to auto-generate our [REST API docs](http://www.reviewboard.org/docs/manual/dev/webapi/) by introspecting all the Python objects that form the resource tree (checking arguments to functions, data from decorators that describe possible input/output/errors, etc.). That's all [public](https://github.com/reviewboard/reviewboard/tree/master/docs/manual/_ext) if you're really looking to do something fancy and complicated. As was already mentioned, [Django](http://www.djangoproject.org/) uses Sphinx for their docs too, and in my opinion those are some of the most useful developer docs I've used. If you're looking to do anything a bit more fancy than what Sphinx does out of the box, I know Django has some custom [extensions](http://code.djangoproject.com/browser/django/trunk/docs/_ext) to process the generated docs and modify things, add new directives... It's been a while since I've looked at it.
Swap underscore with dash, if you're writing in PEP 8 style you probably use it a lot more, and hitting shift for occasional dashes in human text is not as troublesome or common.
79 or fewer characters per line is very nice when viewing two files side by side. Even a wide screen monitor can't comfortably view two files with very long lines.
Although not very helpful, you can do it using pyqt by setting a QTextEdit box's verticalScrollBarPolicy to ScrollBarAlwaysOff.
No, any idea is a good idea. :) I could switch frameworks. I only switched to wx because tk didn't have built-in combobox widgets and i thought if it were lacking something so basic i would probably run into other problems down the road.
Programming is at its core about grasping as many details and solving the problem with the details turning out ideally. Burdening the programmer with non-obvious style and naming will reduce the capacity available for considering details. Less details, worse code.
[Flask][] has one of best documentations Sphinx generates. [LEPL][] also could be a good example of Sphinx documentation. [jDoctest][] is not a Python project, but it uses Sphinx also and its theme is beautiful. [Flask]: http://flask.pocoo.org/ [LEPL]: http://www.acooke.org/lepl/ [jDoctest]: http://jdoctest.lunant.org/
This was actually really good advice. I have pretty much rewritten the thing, but I believe it is much better now. [See what you think](https://bitbucket.org/jgrigonis/thefranchise/src/7133a2da5c06/gametime.py)
Three characters is a fair trade for improved readability.
&gt; if I want to use a program and it uses 1 function from brownie, I don't want to have to download and install brownie. If we only had an application like pip that would do that for us. Automatically. 
Twisted has some great answers to your problem as austinf rightly points out. keywords to look for 'jellyable' 'pb = perspective broker' 
In C# I NameMyFunctionsLikeThat, inJavaLikeThat, in_python_like_that, in_c_like_that, in_cpp_like_that, In_Ada_Like_That. I don't have a problem with either, but I stay consistent with the environment I am working in.
Not sure what I feel about this. Logically speaking Ruby fans and Python fans should both be horrified by it. :-) Are there going to be issues with the minor differences between Python’s and Ruby’s list and dictionary conventions? I wonder whether it make more sense to make a Rubinus-VM-based backend for PyPy so as to exploit their ever-improving Python implementation more-or-less for free? At one point PyPy had a broader selection of back-end implementations than the core set they are concentrating on now, so this might be doable.
I use variable-width fonts in text editors by preference, in which case swapping capital letters for underscores makes less of a difference in line length. Also I observe that young people seem to like to run their text editors full-screen, which gives them over 160 characters to cram a line in to. A few extra underscores will make little odds in this case!
Annoyingly upper-case abbreviations in camel case is the opposite convention from the Microsoft (C# et al.) world, where you would use `XmlHttpRequest` rather than `XMLHTTPRequest`.
If you expect anyone in the world to read your code, or if you expect yourself reading somebody else's code, then you should stick to conventions. It makes your life also easier. Actually, if I would need to hire a Python programmer and see in his code examples that he does not follow PEP 8, I would not hire him.
&gt; camel case saves a character a word Yes, I came here to say this. Putting a line f code on a single line is typically better than on multiple lines &gt; which can easily add 3 characters to the line author_name_list = [author_name for author_instance.author_name in author_instance_list] is a lot of spaces, including the two around the equal sign &gt; Not exactly game breaking But if the line is already indented by a dozen spaces, it can easily cause you to run over onto the next line (especially if the line is commented). Still, I generally follow PEP 8, although those parts I consider suboptimal. 
We should be extremely happy that something like PEP 8 exists. It's not about good style, bad style, personaly preferences. I like this, I like that... Some of you guys may have been involved in creating a standard or convention. That's a never ending nightmare, because everyone fights about mainly personal preferences. However, the point is to have the convention. Whoever wrote PEP 8: Thank you, thank you, thank you! I had to get used to the underscores coming from CamelCase myself. I still have quite often problems with line length as my names get quite long. 
should be written: author_names = [author.name for author in authors] ... these 'instance' and 'list' have no place.
&gt; ... these 'instance' and 'list' have no place Your opinion. Mine differs. I find them useful sometimes, particularly when revising the code weeks later. In any event, it is a made-up example illustrating that there can be lots of spaces taken up on a line. My point remains correct. 
How about this. If you stick to seconds (big integers), the relation between real time and game time, is always a linear one. Piece-wise linear monotonically increasing, in fact (think about a graph plotted with real time on the x-axis versus game time on the y-axis). So, if you want to keep history of pauses and varying game speeds, all you need to do is to keep a list of `(real_time, game_time)` tuples. You make sure this list is sorted, strictly increasing in both `real_time` and `game_time`. Then you can easily create two functions `real_to_game_time` and `game_to_real_time` that use the `bisect` module to find the proper interval in the history list, and a linear interpolation to calculate the exact result. That's the timekeepping basics. On top of that a bunch of utility functions for converting seconds to years and days and formatted strings and whatnot. Additionally, you may need one extra thing, the speed of game time / real time ratio at the end of the list (being the current game/real time ratio). 
 global mock global mocktime mock = mocker.Mocker() mocktime = mock.mock() should be self.mock = mocker.Mocker() self.mocktime = self.mock.mock() and other references to a global variable changed. Are those mocks being verified? Instead of extending unittest.TestCase, extend mocker.MockerTestCase. That should call mocker.verify() automatically and reset the state. Finally, Test_gametime_withstubs -&gt; TestGametimeWithStubs
python actually uses TitleCase, not camelCase. small difference, but one looks better than the other. the rockstar comment was just because i hate working with folks that think their personal style is the awesomest, and trumps convention.
Hi, disclaimer: I'm on of the authors. If you don't mind the graphics toolkit, you could have a look at [PyRoom](https://launchpad.net/pyroom), another distraction-free writer, made in Python and using the GTK framework. It's already mature and included in Debian/Ubuntu and various other distributions. It's GPL, you may either look at our code to see how we do it or maybe even contribute and start working with us on the project. You'd be very welcome.
I always had the impression that people considered rubys virtual machine to be its one major weak spot, anyone care to elaborate on the advantages of running python on it?
I would be very interested in seeing the code that serves the pickled docs. I want to show the docs to authenticated users. I was considering wrapping direct_to_template in is_authenticated, but would be very interested in seeing your solution. Thanks!
This isn't _that_ vm. It's a new one. I believe the original vm (MRI) is mostly just a simple bytecode interpreter without modern JIT or anything like that. This appears to be kind of like pypy - i.e. ruby written in ruby, using llvm for the heavy lifting.
Ah, thanks. I'm not quite up to date on ruby development.
1) Put `#!/usr/bin/env python` at the top of the file and `chmod +x yourfile.py` , now you can run `./yourfile.py` . 2) Not a whole lot of details to work with. If you get an ImportError it generally means that the module is not installed or not accessible. Try `pip freeze | grep gmpy` and see if its installed. Also start using virtualenv now, it will save you a lot of time later when you start having to manage multiple PATHs. virtualenvwrapper is also really useful.
One of the goals of [Qwandry](https://github.com/adamsanderson/qwandry) has been to get people looking at the source of the libraries they use. So if you're using Django, and you run into a problem, or are curious about how something was implemented, you can just do: qw -r python django Which will open up Django's directory, and now you can peruse all of its code. Granted, this might be too much if all you wanted to do was look at django's widgets or forms. So perhaps when I said module, I should have said library, though it's possible to imagine supporting: qw -r python project.foo.bar By the way, for any folks who don't want to use ruby, but are interested in the tool, there are instructions for making python, perl, node.js, or brainf*ck the default language. It takes about 5 seconds, and a willingness to type: default 'python' Anyways, thanks for responding, I'm not really sure why people are down-voting this, it's kind of disappointing, giving constructive comments comments is much more helpful ;)
I would suggest project based learning. Pick a simple project and try to implement it with Python by using Numpy and matplotlib. There is a very helpful community out there so take advantage of it. I would pay special attention to the computationally intensive parts. In some cases there are several order of magnitude difference between python loops vs Numpy way. You should be able to get close to C performance if you use Numpy properly. In some cases due to ease of implementing fancy algorithms your Python code can be significantly faster than your C implementation. I know this sounds hard to believe since most people claim that Python is a slow language but in my experience Python was the faster solution in many cases.
use pycurl
Start with the Scipy/Numpy documentation its really phenomenal and its pretty much the foundation of all things numeric in Python. The Sage project is also something to take a look at, it has also has some good documentation. If books are more your thing then there are plenty of books devote [solely to scientific Python](http://www.amazon.com/s/ref=nb_sb_noss?url=search-alias%3Dstripbooks&amp;field-keywords=scientific+python&amp;x=0&amp;y=0). I own [this one](http://www.amazon.com/Python-Scripting-Computational-Science-Engineering/dp/3642093159/) and I like it.
For numerical work, Python will behave a lot like Matlab. If you're familiar with Matlab, picking up the few differences in syntax will not be too difficult. Unlike Matlab, Python is a full-blown modern programming language and is thus full of a lot of bells and whistles no self-respecting numerical guy will ever need. Be very focused in your learning. Python's Numpy is very good. In order to get maximal performance out of it, you should learn *array broadcasting*. It makes life so much simpler than some of the crap you have to do in Matlab. Also, if you miss C there's no reason to give it up. With an interface such as SWIG, it's very easy to use c functions in python.
Here's a site that will simultaneously teach you Numpy, Theano, and various machine learning architectures. If you're familiar with Matlab you should be able to figure out Numpy pretty quickly, and the rest shouldn't be significantly harder than astrophysics as long as you stick to the documented features. http://deeplearning.net/tutorial/ 
[Sage](http://www.sagemath.org/doc/)
Upvoted for spelling of smörgåsbord!
Sages docs uses the default styling.
I like the unfinished documentation for django authority: http://packages.python.org/django-authority/
Hey, I'm in exactly the same boat as you (PhD Astro!) and I use Python for everything... from driving some small scale numerical simulations ([1](http://physics.nyu.edu/~mjg490/hydro/), [2](http://fluxtrap.blogspot.com/2009/12/fortran-python-good.html)) to [analyzing the data of large-scale simulations](http://cita.utoronto.ca/~mgorelick/outflow-scinet/start_python.py) (warning: ugly code! This was from when I was still starting the learning process). When it comes down to it, the only way to learn python for these purposes is the hardest way, learn as you go. That being said, first get a good understanding of the data-structures (mainly the many ways of slicing and dicing through your data with fancy slicing and mappings) and their properties and some pythonic control structures. This is what I would do if I were you, * Read through the documentation for [numpy](http://numpy.scipy.org/), [scipy](http://scipy.org/), [matplotlib](http://matplotlib.sourceforge.net/) (visualizing 2D data) and [mayavi2](http://code.enthought.com/projects/mayavi/) (visualizing 3D data) so that you know what is available in the modules * Create a 2D grid of normally distributed noise and analyse it. For example, FFT it, get the power spectrum of it, fit it a couple of different ways and output your plots in the prettiest way possible. * Do the same for some 3D data! It may seem like this will be exactly the same, but there are many subtleties about how to handle the data. * Make something useful! If you are doing something observational, why not porting some code over to python from whatever godforsaken language was previously used (IDL? Matlab?) and prosper! And from there, you'll be good to applying python in your everyday data analysis. If you really want, learn how to merge C/Fortran with python to make some properly fast code! Best of luck! (Also, what specifically do you study in astro?)
This is the second time that [extremely long sentences](http://www.reddit.com/r/Python/comments/euolc/pep_8_underscores/c1b3arn) are used to prove a point about readability when they don't fit within the programming context. And there probably is a good reason for this. And that is the "readability" really isn't a big issue at all with the types of names one uses within programming. Straw man like examples have to be used to prove underscores readability superiority. You won't use a library if it has the wrong conventions. That is pretty extreme. Maybe you should find ways to remove parts of the standard Python library since it has so much hard to read CamelCase in it. Here's an example copy and pasted from the [unittest documentation] (http://docs.python.org/library/unittest.html) import unittest class SimpleWidgetTestCase(unittest.TestCase): def setUp(self): self.widget = Widget('The widget') class DefaultWidgetSizeTestCase(SimpleWidgetTestCase): def runTest(self): self.assertEqual(self.widget.size(), (50,50), 'incorrect default size') class WidgetResizeTestCase(SimpleWidgetTestCase): def runTest(self): self.widget.resize(100,150) self.assertEqual(self.widget.size(), (100,150), 'wrong size after resize') Note the CamelCase class names are what the PEP says you should use. The method names in mixedCase, however, violate the PEP. Here's the apparently readable version for those who think underscores add so much. Note these are more realistic comparisons than writing 60+ character long full sentences. import unit_test class Simple_Widget_Test_Case(unittest.Test_Case): def set_up(self): self.widget = Widget('The widget') class Default_Widget_Size_Test_Case(Simple_Widget_Test_Case): def run_test(self): self.assert_equal(self.widget.size(), (50,50), 'incorrect default size') class Widget_Resize_Test_Case(Simple_Widget_Test_Case): def run_test(self): self.widget.resize(100,150) self.assert_equal(self.widget.size(), (100,150), 'wrong size after resize') Personally I think the extra gaps created by the underscores's whitespace is undesirable in this context (vs reading English sentences). The emphasis between words takes away from groking the surrounding code by adding more distracting whitespace. The caps within the words are significant enough markers to improve the identifiers readability so I begin seeing identifiers as 1 unit in a larger statement parsed by whitespace instead of 2 or 3 or 4. By the way, PEP8 calls the underscores with capital letters "ugly!" yet some making the underscore argument with sentences should see the whitespace gaps as desirable and more readable regardless. 
I know its not Java and I am thankful its not! However, if you are going to use Java's CamelCase for class names, why not just go all the way. You've already introduced identifiers not separated by underscores. Given Java's popularity there really is no point in deviating from a naming convention that works and it almost ubiquitous. People coming over from the language who know some of the libraries inspired by Java don't have to worry about mistyping a method name because its in underscores instead of mixecCase. The people criticizing CamelCase and mixedCase as much more unreadable are really making a subjective argument. Its more readable to them. Maybe they can work their whole lives programming in Python, but even Python uses CamelCase so you have to get used to it. And widely used languages like Java and Javascript (libraries too like jQuery) and C# also use it. Once you know your identifiers you probably aren't reading the whole thing anyway. Your brain probably sees the first few letters and knows what it is. The extra gaps created by underscores is just a distraction at that point disrupting your ability to grok the surrounding syntax. Your hands will also thank you for it. 
&gt; Burdening the programmer with non-obvious style and naming will reduce the capacity available for considering details. But we aren't discussing a non-obvious style. We are discussing convention that doesn't use underscores, CamelCase and mixedCase. The most popular language on the planet that has inspired various python standard library modules uses this convention. A language most people are forced to use if they do any web programming, Javascript and its popular 3rd party libraries use it. Python and the PEP itself actually recommends part of this non underscored convention for its class names. There is nothing that difficult or hard about reading CamelCase until people start making full English sentences out of it like they do here. 
No, I got it wrong. Check the PEP. It explicitly declares CamelCase the same as CapitalizedWords. It calls what I called camelCase, mixedCase. 
Per PEP 8, you have to use XMLHTTPRequest if that is a class name. Microsoft's is definitely more readable in my opinion, but its not a huge deal. Its only 14 characters and it doesn't take long to grok it as one thing as opposed to the underscore folks who think it would be better having to break it apart into 3 things each time they see it and then reassemble that out with the rest of the whitespace in their statement. In the interest of making something that should just be perceived as one unit or chunk more "readable" they are making the rest of the surrounding context of the program harder to grok.
I'm happy PEP 8 exists. Just wish it was internally consistent and consistent with Java. Its inconsistent in the sense CamelCase for classes and underscores for methods\variables. If it just stuck with mixedCase for the latter it would have been internally consistent and consistent with some of the most widely used languages out there. A lot of people forming full sentences in CamelCase are confident that that it is much harder to read than underscores, but they don't do it with much short identifier names because that shows its really not that bad. Plus, a Java or C# or Javascript programmer coming over and trying out Python is going to be more comfortable with the mixedCase than underscores. Adding in the removal of { and ; everywhere Python is a very clean looking language. 
Am I missing something here? Dash is not allowed? In any case, both are on the top row. Read the testimonials of people who have shifted to a Dvorak layout (for regular English, not programming). The don't necessarily gain a huge speed advantage but most of them do rave about how they don't get RSI type feelings anymore. That's because the Dvorak is designed to limit as much finger movement as possible by putting the most commonly used letters on the home row. The small, if not insignificant gain in readability just isn't worth the reach over and over. 
pretty slick. I would like to see what the process was for generating the python.js(2.7MB) If someone smart could write the dom manipulation interface, I wonder how viable it would be to use python on the client side. I would rather write python than java for rich web apps, but i could never get comfy with pyjamas 
Useful...marked!
All I see is &gt; "We're sorry, but *myusername*`@`gmail.com does not have access to this document." 
python2.6 on Ubuntu 10.10 (32-bit), on a 1.8 GHz Core 2 Duo.
Well you need to qualify that. According to GVR in PEP8 underscores are "ugly!" whenever there are caps in it. In any case, PEP8 requires that you write "ugly" CamelClase for class names. But ultimately these are subjective opinions. Most of the "readability" arguments here are subjective supported by unrealistically long examples to make their case. I've pointed out, in other comments, why I think mixedCase is more readable with code example that people actually use in the real world. The logical reason why underscores are more readable is they create a bigger white space gap between multiple words within an identifier. Yes, that is more readable but we don't really read code like we read the English sentences people are using around here and that extra whitespace gap becomes a nuisance. A sentence in code is composed of various parts of different kinds of significance. I don't write "ifidentifier:" for an if statement. I write "if identifier:". I don't write "whileidentifier=1:", I write "while identifier = 1:". My brain parses it like this (if, identifier, :) or (while, identifier, =, 1, :). If I used underscores my brain would break it apart like this (while, a, long, identifier, with underscores, =, 1, :) because that's how our brains, from reading English all the time, are trained to chunk things and concidentally why people think its more "readable". Yet that readability is not a huge advantage in this context. When you are looking at thousands of lines of this stuff a day you are creating a huge penalty by having to see your identifiers all over the place creating extra whitespace where you really don't the whitespace to be significant. Your brain is going to be able to grok the identifier from its first few letters anyway after some minimal exposure, but its very hard for your brain not to attach significance to notice the increased gaps from underscores because you are so trained to do it from normal reading. 
Apologies, I set the properties wrong. However, traceamountofpeanuts has already graciously solved my problem. Thanks, though =)
The difficult task in going from procedural programming to scientific computing is to recognize that most things you would naturally want to do with loops *should not be done with loops*. Python (+SciPy) has fantastic tools for slicing rows, columns and sub-matrices out of data tables, then performing operations on vectors and matrices without manually iterating through them. Once you learn those, you'll never go back. Just go grab the [SciPy/Python 2.6 Super Pack](http://sourceforge.net/projects/scipy/files/) and get to work.
Use the JSON data format (.json instead of .rss). Each breakline is represented by an escaped n.
Better, but I think you are still calculating more than you need to. [Here's roughly how I'd handle it](https://gist.github.com/762738)
It's actually dirn me. Next time research before saying stuff like that!
Grandparent is talking about mixing multiple styles for lulz. Mixing multiple styles in the same context makes style non-obvious and a thing to consider when writing code.
... specifically append `.json` to the URL ([example](http://www.reddit.com/r/Python/comments/euzeu/formatting_and_parsing_reddit_feeds_hjielp_please/.json)). That is what [weeklyreddit does](https://github.com/srid/weeklyreddit/blob/master/main.py#L98).
Cool. What python parser/retriever should I use? I've been using feedparser to retrieve the xml and parse it. edit: nvm. I just peaked at the code in WeeklyReddit and it's right there (simplejson). Nice. Very nice.
I'd agree with some of the other comments here, just start with a project and go to town. I switched all my work to python during research this summer, and haven't looked back. One thing I would recommend is that before embarking on some function, look around for a module that already does it. It is frustrating to reinvent the wheel only to find someone has already done it and better.
Oh nice. Specifically: https://github.com/srid/weeklyreddit/blob/master/main.py#L17 Wow, man, Py's really elegant and simple. Learning to love it as I learn the language.
Python 2.6 and higher comes with a [json module](http://docs.python.org/library/json.html): &gt;&gt;&gt; import json &gt;&gt;&gt; json.loads('{"a": 1}') {u'a': 1} For Python 2.5 and lower you can use: [simplejson](http://pypi.python.org/pypi/simplejson/), [jsonlib](http://pypi.python.org/pypi/jsonlib/).
I don't want to rush to conclusions (yet), nor do I want to sound like a premature fanboi of the language and its tools, but, I have to say I'm impressed. With all the hoopla surrounding ruby (and Rails in specific), I stumbled and wasted quite a bit of time with gem dependencies and version incompatibilities as well as having a large number of projects that are either dead or abandoned or outdated. I got fed up, ditched it and picked up Py yesterday (and also was interested in Django) and I'm mostly done with this pet project. Though I had some exposure to Py and PyGame, I never really got into it, to be honest. Now that I had a practical and simple project in mind, Py's strengths are pretty obvious (except that I miss semicolons and braced enclosures ... snif snif :D)
The last few lectures of MIT's 6.00 ocw course on programming covers some pylab/matplotlib and stochastic simulation stuff. It might be a good intro. Once you learn the syntax you can probably skip right to them. Plus problem sets to practice with.
Upvoted for teaching a Dane that its used outside Scandinavia!
The 79 char thing is part of our Perl guidelines too. We have a 79 char soft limit with a 100 character hard limit. I wanted to see it carry over to our python guidelines, but it didn't. 
this is super cool! I flipped from Ruby to Python around the time the Rubinius project was started. I'm glad to see they've come so far and that their hard work could also benefit the Python community. 
If you come from a Matlab background [this link](http://www.scipy.org/NumPy_for_Matlab_Users) will get you the most bang for the buck for just jumping right in. If you're in a Debian/Ubuntu environment: $ sudo apt-get install ipython $ sudo apt-get install python-matplotlib $ ipython -pylab And then enter Matlab-ish statements (modulo the differences in the site above) and see how it goes. In Windows you can download [Spyder](http://code.google.com/p/spyderlib/) (also works in Linux), which will get you the same kind of functionality in a more IDE-like environment in one package.
What's wrong with maketrans? What would be the point of not using it?
I mean that you should make _ not require shift, so that it is a single keystroke.
Ya, I figured that out, after a short bout of stupidity. I've gotten rid of the mock tests for now though, I don't think they are necessary, as I can just plug in the times directly.
I'm a PhD student in computational atomic physics, and started learning python about 18 months ago. Like a few others have suggested, I learned python simply by diving into some projects. I did a few things that were fun but not really useful (like writing games with pygame), and then I started re-writing some of my Fortran stuff in python (but making it more *pythonic*). Now I do as much of my coding in python as possible, and only use Fortran for array-based numerical stuff. It's really quite easy to integrate python with Fortran or C once you've learned the basics.
Use "a" for append.
Thank you sir. I'm following the tutorial to the letter-- I wondered how the function worked. Your answer helped me immensely. Thank you.
Isn't R supposed to be good for this kind of thing? I already know Python but R seems to have some advantages, like the built in data frame / matrix types and easy plotting. I think it would be good to have some Python skills to "preprocess" data for importing into R. 
IDLE already has this feature completed. See how "run.py" and "PyShell.py" are implemented for sending data over a network socket.
Yes, R is a good choice, and there is also RPy, an interface between R and Python. http://rpy.sourceforge.net/ 
If you already know another programming language, [the official python tutorial](http://docs.python.org/tutorial/index.html) is very good for getting up to speed on syntax and how to do the common things. Once you've got a handle on the language, both Numpy and matplotlib have really good documentation with plenty of examples.
As far as learning the Python language itself I would recommend diveintopython.org. I think the examples and presentation are much more interesting than LearnPythonTheBoringWay.org. 
One is a class attribute, the other is an instance attribute. Try this; class A: a = 1 class B: def __init__(self): self.b = 1 myA = A() myB = B() A.a = 2 B.b = 2 print myA.a print myB.b You'll notice that `myA.a` has changed to 2, but `myB.b` is still 1. This is because for A, the variable is stored in the class's namespace, whereas for B, the variable is stored in the instance's namespace. When looking up the variable, python first checks the instance's namespace, and then the classes, and then superclasses, and so on\*. You can check this for yourself by deleting myB's attribute (`delattr(myB, "b")`), and discovering that asking B.b will return 2 - that is, the 2 was hidden "under" the instance variable. \* It's actually quite complicated (though interesting); because python has multiple inheritence, there's some awfully complicated rules for determining the order it should check superclass namespaces (the classic example of why this is difficult is the [diamond problem](http://en.wikipedia.org/wiki/Diamond_problem)). Python 2.3 and onwards uses [C3 linearisation](http://en.wikipedia.org/wiki/C3_linearization), but earlier versions used different MRO algorithms - Python's used four in total, IIRC!
 class A: a = 1 &gt;&gt;&gt; print A.a 1 class B: def __init__(self): self.b = 1 &gt;&gt;&gt; print B.b Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; AttributeError: class B has no attribute 'b' &gt;&gt;&gt; b = B() &gt;&gt;&gt; print b.b 1 so the variable a belongs to the class and the variable b belongs to the instance. it is sort of like in java static variables but not really. [I recommend reading this stackoverflow post](http://stackoverflow.com/questions/68645/static-class-variables-in-python)
The guy who really motivated the whole scipy/numpy documentation is my advisor (Joe Harrington). We use Scipy, Numpy, Matplotlib, Mayavi, and other Python packages to do ALL of our work. He is a HUGH python advocate, and has converted me as well, since this is all I ever use these days. By the way, we work on exoplanets, and he has another project on the SL9 impact. Look up Campo or Joseph Harrington on ADS if you want to find any of our work. Anyway, read Scipy and Numpy documentation, as well as the examples and cookbooks. Go through the tutorials. There is even a pdf book on using numpy for scientific data analysis. I'll post links below. This will REALLY help you get started. If you are stuck on anything, check the mailing lists. Cheers! **Numpy/Scipy/Matplotlib doc:** http://docs.scipy.org/doc/ http://www.scipy.org/Numpy_Example_List_With_Doc http://matplotlib.sourceforge.net/ **PDF Data Analysis Book (a little outdated, but good nonetheless):** http://stsdas.stsci.edu/perry/pydatatut.pdf **Heres a pdf showing some resources we had to utilize when we took Joe's advanced data analysis course:** http://physics.ucf.edu/~jh/ast/ast5765/handouts/learnpython.pdf
try this: class Test(object): p = ['pants'] a = Test() b = Test() b.p.append('happy') print(a.p) class attributes are shared among all instances of the class, whereas if they're assigned specifically to the instantiated object (self) in `__init__` each instance gets its own variables. further, doing this would do the seemingly 'right' thing, because the instance `b` gets `p` added to its dictionary, which shadows the class-level `p`: b.p = 77 print(a.p) # still ['pants', 'happy'] but doing *this* will be surprising: Test.p = 0 print(a.p) # 0, since a still looks to the class dictionary when resolving p print(b.p) # 77, since b still has a shadowing p in its dictionary
rpy2 and numpy integrate very well.
Wow, that was quick, everyone. And helpful as well. That explains some odd errors I was getting earlier. I was still thinking in C terms, and declaring the variables in the class body and then assigning them in an \_\_init\_\_ statement. class A: b = None def __init__( self ): self.b = 0 a = A() So could a.b refer to two things: The class attribute b, and the instance attribute b, but it will normally resolve to the instance attribute. Is this correct? 
Not sure why you don't want maketrans, but something like trans = dict(zip(chars, perm)) equation = ''.join(trans.get(x,x) for x in s) from the shell: &gt;&gt;&gt; t = dict(zip("ABCDE","0123456789")) &gt;&gt;&gt; ''.join(t.get(x,x) for x in "CDE + BAB != DECB") '234 + 101 != 3421' 
I've really been hoping Parrot would come along and be awesome and maybe get embedded in web browsers, but since I'm becoming more doubtful that that will happen, this is pretty cool too!
haha, I'm a pip user, and I recognize that the installation of a library is nearly transparent with pip when its included in dependencies. I have a (very possibly irrational) distaste for dependencies, and I try to use fewer rather than more.
Wow. Great explanation of class vs instance variables. The same thing goes for methods as well.
So... A.a = 2 myB.b = 2 would work?
&gt;Is it needed if every variable is initialized to the same thing every time? This is the wrong question to ask. You've almost answered the question correctly already. &gt;You need \__init__ if you **ever** want to **set** variables to different values in different instances of a class. If you want the variable to be the same across all instances of a class, use class variables. If you want to be able to set the variable to different values for different instances, then use an instance variable.
yes.. I like to think of A.a definitions as class constants, and avoid changing them. 
I recently purchased Data Analysis with Open Source Tools by Phillip K. Janert. I'm really enjoying it - and can recommend everything except the parts that deal with databases. Anyhow, it also covers a lot of python: NumPy, matplotlib, scipy.signal, simpy, etc.
Long overdue - but took a bit to get around to installing and yes, with macports python vs system python the OP tips work great :)
Thanks for the tip about virtualenv. Another option (old fashioned way?) for the OP: Python can locate external modules by following the PYTHONPATH env. var. So you can set this to point to the directory holding your modules It also looks in sys.path which you can manipulate. Eg, if your main .py file is located in a fixed location w.r.t. the modules you can patch sys.path on the fly. Say you have /path/to/code/main.py /path/to/code/python/mystuff/__init__.py Then you can do in main.py import os,sys try: import mystuff except ImportError: sys.path.insert(0,os.path.dirname(__file__) + '/python') import mystuff (this is just off the cuff, so may have typos) 
Sure thing. I've put them up here: https://gist.github.com/763086. Let me know if you hit any problems with it. Some of the general structure was based on Django's way of processing docs (namely, the URL scheme involving the versions). From the looks of it, they use json instead of pickles, so that's certainly another thing you could look at.
&gt; The class attribute b, and the instance attribute b, but it will normally resolve to the instance attribute. Is this correct? Your use of the term "normally" is ambiguous. If the attribute "b" does not appear in the instance dict, then Python will attempt to locate it in the class dict. When you assign to an instance's member, it creates a new entry in the instance dict, thereby masking the class attribute in any subsequent lookups. It is no more complicated or magical than that. &gt;&gt;&gt; class A(object): ... x = 3 ... &gt;&gt;&gt; a = A() &gt;&gt;&gt; a.x 3 &gt;&gt;&gt; A.x 3 &gt;&gt;&gt; a.x = 5 &gt;&gt;&gt; a.x 5 &gt;&gt;&gt; A.x 3 &gt;&gt;&gt; a.__dict__ {'x': 5} &gt;&gt;&gt; a.__dict__.pop("x") 5 &gt;&gt;&gt; a.__dict__ {} &gt;&gt;&gt; a.x 3 
no: what Autoplectic is pointing out is not because of lists, and lists are not "shared among instances because of memory usage". :( class attributes are shared amongst classes (what Autoplectic is saying), until they are overridden (what you are showing)
Wow, thanks for the explanation. Now I'm not sure if I want to go back and review all my code. I tend to use both definitions interchangeably but I never modify classes after they've been defined so I think I've been safe because of that.
Since __init__() is called after the class(), the init writes over the class' value. It's not really a resolution thing - but it's OK to think of it like that.
If you can already speak C pretty good, I think zed's class (is pretty awesome) is a bit below you.. The best way to learn is to just build whatever you need/want to build. Pick a project and figure out how to do it!
Thanks. I haven't really looked into GTK in depth, but PyRoom looks pretty mature, I'll take a look at the source. I have a few feature ideas. I might show up on freenode. I am still going to figure out how to get this done in wx because now I'm annoyed by it, heh.
** To which the lesson is, don't multiple inherit.
In a terminal echo "print \"Hello, World\"" &gt; HelloWorld.py python HelloWorld.py See if that works. If it does, when you tried before are you sure you were in the same directory as your python file? You can use `ls` to get a listing of files in your current directory and `cd` to change to another directory, if you don't know.
It's possible that your book is written based on Python 2.x and you installed (or Ubuntu came with) Python 3.x There are a few important differences, and one of them is that `print` is now a function, so you need to do `print("Hello, World!")` with the parentheses.
Run `python -V` in a terminal to see which version of python you have. Ninja edit: Posting this so OP can figure it out.
To run a script in linux you need to specify what program to open it with. You do that by putting #!/usr/local/python at the top. And then you can run it as a script $ sh ./HelloWorld.py To just run the file you also have to make it executable. $ chmod +x HelloWorld.py $./HelloWorld.py To not do any of that you have to specify python on the command line $python HelloWorld.py and it should work. Also, make sure you're in the right directory first. Instead of typing HelloWorld.py all the way out, just type Hello and then hit tab and see if it finishes it for you.
I would suggest [Py4Science: a Starter Kit](http://fperez.org/py4science/starter_kit.html) 
Your way worked :-) And yes.. I was in the correct directory for sure. Thanks for the help! I know my way around a unix terminal for sure.. I just haven't done any programming since VB6.. lol
Strange. I wonder what it is you did wrong, then. Maybe a typo? Another reddit you may find useful is [r/learnprogramming](http://reddit.com/r/learnprogramming).
upvoted for good answer, downvoted for not using new-style Class
Thanks!!! I'm checking that out now!
Yup.
I have the same problem in windows.
This has nothing to do with multiple inheritance. Or even single inheritance.
Opps.. my bad.. I tried saving as both.. I tried HelloWorld.py first as the book suggested.. then while trying to get it to work I shortened the filename and tried again.. 
But in what order? Voting is path-dependent.
&gt; I believe the original vm (MRI) is mostly just a simple bytecode interpreter without modern JIT or anything like that. Actually, the original implementation, MRI, is [just an AST walker](http://en.wikipedia.org/wiki/Ruby_MRI#Criticism), which is why it's so slow. This is also why there were so many Ruby VM implementations.
Why not make it language agnostic? Do you really want to send serialized versions of python objects over the wire? Could this not be accomplished using a simpler format, like json?
I'm aware of that. It's still important to keep in mind that "w" will always truncate a file, even if you don't write anything to it (i.e. just open and close it).
Python is/was the first thing that came to my mind when I wanted to do some scientific work. Numpy,scipy, matplotlib work great. Python also integrates well with R - so that is certainly an added advantage.
There could be valid reasons for changing a class attribute, but they are rare. If you have information you want to propagate to all the instances of a class (a counter, a lock) you could use a class attribute
*"A Primer on scientific programming with python"* gives you a pretty okay introduction to working with tools like scipy, scitools, easywiz, et al., but the exercises are not very well written, and it's really just an introduction, it won't teach you how to use specific tools in-depth. On the upside, it does give you a pretty good introduction on all different sorts of numerical algorithms and implementations, from deriving numerically to solving systems of differential equations using different solvers, so it's definitely something you can build on. There are probably a bunch of chapters you would hop over (like those about sound manipulation etc.), though.
/usr/local/python is unlikely to be the actual path to his python interpreter. 
the original as in 1.8.x because 1.9.x is a different beast
As markatto said, `/usr/local/python` most likely won't exist, what you probably want is `#!/usr/bin/env python`
It's python 3, everything's new-style. Get with the program.
You said you *installed* Ubuntu as part of this... This tells me, you may be unfamiliar with the OS you're using. If this is the case, step 1, find your terminal. Then mess with the **cd** and **ls** commands. The first is designed to *change directories* and the second will *list* the contents of your present working directory. Once you know your terminal and how to change directories and list the contents of directories (checking to make sure your modules do indeed exist) you should be pretty set to dive into your book. Hopefully. Good luck!
Dear Reddit Thank you for your intelligent and in some cases, funny replies. I know this thank you may sound a bit contrived, but seriously, I appreciate them, Thank you. 
&gt;For numerical work, Python will behave a lot like Matlab. With the major difference that you can later distribute your work to people who didn't buy Matlab, or run your program on thousands of computers at once without paying huge license fees :) Plus, the fact that the source is open has helped me quite a few time and is really important when used for science, which should be repeatable.
Let me recommend: [Beginning Python Visualization: Crafting Visual Transformation Scripts](http://apress.com/book/view/9781430218432).
No it's not, look at those print statements... &gt;&gt;&gt; print myA.a File "&lt;stdin&gt;", line 1 print myA.a ^ SyntaxError: invalid syntax Please try again. 
Windows is suffering a different problem most likely. Can you open a python console by just typing python into the command prompt? If not, you need to add python to your path. If you can, then maybe you have the same problem as the original poster, and it's inexplicable.
The OP submitted python 3 code with syntax errors, I'd shame him for that if I were you. Try again. 
Very nice! I like these tips a lot! I find the [pyflakes integration](http://www.vim.org/scripts/script.php?script_id=2441) also a LOT!
In addition to the sources mentioned in the comments, take a look at the website http://astropython.org, and the AstroPy mailing list at http://mail.scipy.org/mailman/listinfo/astropy. I have collected together links to some Python packages used in astronomy at http://oneau.wordpress.com/2010/10/02/python-for-astronomy/ ; this also has links to many of the documents listed in the comments. Since you already know C, this short Python tutorial may help you get a quick overview of Python: http://oneau.wordpress.com/2010/12/28/python-boot-camp/. At the minimum, you should learn the basics of numpy and matplotlib. The official matplotlib documentation is fantastic. If you don't have a specific project where you can use Python, then try exploring the source code of some of the astronomy packages. Or perhaps you can write a Python interface to a C library of your choice, using tools such as SWIG and Cython. 
Yes, exactly. 1.9.x uses YARV iirc.
...new-style class?
And you can view other [python questions](http://stackoverflow.com/questions/tagged/python)
upvoted for good answer, OP put us on the old-style class path
Why? Provide some reasoning.
[Open ERP](http://doc.openerp.com). Features we added: * multilanguage * search page tweaked to search by section (top level parts) * added an external commenting system (using [Echo](http://wiki.aboutecho.com), formerly js-kit) * module index is actually the list of addons (plugins) that can be installed by the openerp server * addons have a voting system (using Echo) * we can make books with it: see [stackoverflow article](http://stackoverflow.com/questions/725811/is-sphinx-better-than-latex-in-writing-manuals-books/729479#729479), but you can't see this online, you'll have to read the sources 
Having questions asked here is a good thing. It has encouraged some interesting discussion more often than not.
Yeah, I had to go look: [New style classes](http://docs.python.org/release/2.5.2/ref/node33.html) Not sure why anyone would care all that much. It strikes me as a Python3 sort of a thing. Elegant but arbitrary...
You are supposed to do not modify the list you are iterating. Modifying the items in the list is valid.
As long as you're iterating over something mutable, you're [fine](http://docs.python.org/tutorial/controlflow.html#for-statements). You can modify individual items, just not the list itself. Why are you looping over a list of integers, anyway? Use numpy.
If you're new to python you may not be used to some of the idioms that are common. Your specific example is probably best implemented with a list comprehension like so (assuming a is your list): a = [x*2 for x in a] You might benefit from this [code like a pythonista](http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html)
In python you work with the list elements, not indexes to the list. Doubling the numbers: &gt;&gt;&gt; a = range(10) #for instance &gt;&gt;&gt; a [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] &gt;&gt;&gt; [i*2 for i in a] [0, 2, 4, 6, 8, 10, 12, 14, 16, 18] &gt;&gt;&gt; Edit: Clarify the answer
Another approach you might be interested in is using enumerate which provides you with indices as well as elements from an iterable: for index, value in enumerate(a): a[index] *= 2 Not really useful for such a simple example but it might be useful to you in some other context. Please do post other things you find awkward, there are usually elegant solutions and as you can see here r/python is happy to help. edit: formatting
[nose](http://packages.python.org/nose/). And I use it all over the place at work, but I can't show you any of that. I hope to be able to open source some of our extensions someday, though, especially the one that autodocs django models and forms.
who died and made u Master of the Internets (or BDFL) ?
No... I've been using linux as my primary OS for many years. Arch Linux is what I usually use. I installed a fresh copy of ubuntu because I was trying out JollyCloud. I wanted sometime easy and fast.. lol thanks though.. 
The loop variable can be changed by the loop. Why do you claim it cannot? for i in range(10): i *= 2 print i 
I didn't see the post you're talking about, but I'd check out [phenny](http://inamidst.com/phenny/), I believe it has a Google Translate module.
If you're looking to modify a mutable sequence (e.g., a list) in-place I'd suggest this for index in range(len(a)): a[index] *= 2 for big number sets numpy is probably going to be a lot faster and require less code &gt;&gt;&gt; import numpy &gt;&gt;&gt; example = numpy.array(range(5)) &gt;&gt;&gt; example array([0, 1, 2, 3, 4]) &gt;&gt;&gt; example + 2 array([2, 3, 4, 5, 6]) # a new array &gt;&gt;&gt; example *= 2 &gt;&gt;&gt; example array([0, 2, 4, 6, 8]) &gt;&gt;&gt; 
Because it doesn't modify the value held in the list.
Well, the OP stated "the loop variable can never be changed by the loop", not the list variable, but that's ok because the list variable *can* be changed. &gt;&gt;&gt; nums = [[1,2,3], [4,5,6], [7,8,9]] &gt;&gt;&gt; for l in nums: ... l.append(0) ... &gt;&gt;&gt; nums [[1, 2, 3, 0], [4, 5, 6, 0], [7, 8, 9, 0]] 
Changing the list is generally ok (you can modify elements and append to the list as you iterate through it), but you don't generally want to remove from the list while you're iterating through it.
Are you saying you can't do this? l = [1,2,3,4] for i in l: i = 0 and have l = [0,0,0,0] when you're done? Of course that doesn't work, because the assignment (i = 0) rebinds the variable i. It's equivalent to the following: l = [1,2,3,4] for index in range(len(l)): i = l[index] i = 0 First i gets assigned to the list element, but then you reassign i to point to a different value in memory. The list isn't modified at this point, just the local variable. 
Because new-style classes support things like super(), descriptors, properties. 
Oh, I know all that. I'm just pointing out OP expected this to work like std::vector&lt;int&gt; xs(5); BOOST_FOREACH(int&amp; x, xs) { x = 42; } would in C++, hence their claim.
numpy any time you're looping through a list of integers? That seems a bit excessive.
supybot?
Lock acquisition should be atomic for this reason. I believe the right way is to have locks all the way down and consistently wrap multiple lock acquisitions in another lock exclusive to that set of locks. I have no idea how to peek at how that C++ does it, but I'm guessing it does just that. Nested lock acquisition in general seems to be a beehive. Unless there's some use case I can't think of that absolutely requires inconsistently acquiring locks in weird order, it's just best to tell the programmer to only acquire one (set of) lock at a time, even if it seems greedy.
Well, that's really just due to the pass-by-reference, isn't it? Which C doesn't have, just C++ (unless something's changed since the last time I worked with C).
No, but that's another I will have to look at.
&gt;Who's bright idea was it to require that the loop variable can never be changed by the loop? whose* &gt;This makes it unnecessarily difficult to, say, loop over a list of numbers and double them all. But how does that make it difficult at all? As others have shown it's very easy, and I'm not sure how being able to change the loop variable makes it easy. How does the loop variable affect what's in the list?
another method, using map and lambda.. I should use list comprehensions more, they look nicer. &gt;&gt;&gt; a = range(10) &gt;&gt;&gt; a [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] &gt;&gt;&gt; map(lambda x:x*2, a) [0, 2, 4, 6, 8, 10, 12, 14, 16, 18] &gt;&gt;&gt; 
Depends on what you're doing I guess. If it's math on a bunch of numbers....use numpy. The only extra work is import numpy in the beginning.
because the python reddit is so busy with other things. /sarcasm
or OP wants to up their rep. 
Well and the overhead of loading another library. Not usually a big deal, but one of the main reasons a python program may be starting up slow is a bunch of unnecessary imports.
meh. Internet has also evolved to find use cases. Twitter was not 'meant' to be used in some way. People found it. Dont put restrictions.
If all you're using is the indices it's kind of wasteful to generate the whole list. (range(n) generates the whole list from 0 to len -1). If you like that construction, I'd suggest using xrange which is basically an iterator, but like tclineks said, a list comprehension is probably the most pythonic way to do the kind of list operations the OP mentioned. Good call on numpy though.
In IronPython we use the same trick of ordering the locks based upon identity when we need to lock two objects (we actually first look at the objects hash code then fall back to a more expensive ID if the objects hash the same). For example if we're comparing two lists we need to lock them both but we shouldn't be introducing deadlocks into the program.
Agreed. I'm all for helping people learn /basic/ python, but I think it should be a separate stream from news about python. In particular, the number of python 101 questions coming into r/python that are answered easily/obviously in the python docs seems to be on the increase...
In Python 3, range gives you generator. Besides, the list comp. also generates the whole list. Swapping the square brackets for parens gives you a generator instead.
Gah, I almost posted asking if it wouldn't be cheaper to use the address of the underlying OS mutex object (which would be non-movable presumably), then I remembered you guys probably have objects all the way down. On PyPy should the need for this arise I think we can "cheat" by using the pthread mutex's ID, since it's non-movable (and thus taking it's id doesn't have a cost on the GC) and is a single datapoint to consider (rather than the 2 step hash code, id process).
I'll have to recreate the error, but I tried something very similar to that, and it would not work. Then I remembered seeing a word of warning in the tutorial I was using, saying specifically NOT to do this. I may be misremembering or misinterpreting something, but I was working on a Project Euler problem, and had to get around the problem.
That link looks neat; I'll have to read through it more thoroughly. And no, that line of code is not something I've seen, but it looks more like the magic I've heard that is Python!
I've only been using autocomplpop (w/ omnicompletion) and pyflakes together for a short time but have experienced no conflicts as of yet. 
Not what you saw, but an IRC bot I wrote the other week: https://github.com/alex/THUNDERDOME-BOT Yay for 45 minute hack jobs.
Ha, thanks. This project definitely ended up being a lot more fun than I thought it would. I feel like a proud father every time my bot connects to a server and does things on his own.
&gt; I was tasked with showing Eclipse with the PyDev plugin in all its glory–but we all know–real men / developers don’t use IDE’s, so we are going to talk about using Python and Vim together .. So, what I don't get is why "real men" don't use IDEs but then they bust their tails getting IDE features into their favorite text editors. If you're going to have features like dynamic auto-complete, interactive debugging, code generation, etc. then you may as well just use an IDE. This whole "must not leave vi{m}|emacs mindset is kinda silly.
Ah, my mistake. I haven't spent any time with 3. 
&gt; You are supposed to do not modify You might want to edit this.
Yes, but one of the main reasons Python rocks is because it is easy to write clean, concise code using its universe of excellent libraries, one of which is Numpy. 
It can take a while to unlearn the thought patterns of C, and there will certainly be times when python is vastly inferior, but you'll save a *lot* of time with that magic. In python3: import antigravity
Agreed, I think it all comes down to the right tool for the right job. Depends on the size of your list.
Take a gander at [Think Python](http://greenteapress.com/thinkpython/thinkpython.html).
Here's one of the most important concepts for every python programmer to understand: [other languages have variables, python has names.](http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html#other-languages-have-variables)
I've heard a lot about this unlearning of thought patterns; but which ones are bad? The major differences I've seen so far are not having to declare types, and not worrying quite so much about pointers and such, which are fine by me.
So it's like hardlinks in *nix. Why?
Well, if you’re crom a C/C++ background, it’s no wonder you are puzzled; Python programmers are not used to unintentionally shoot themselves in the foot.
http://www.zeromq.org/
 a = [x*2 for x in a] That code is pretty much the same as this, which maybe you are more familiar with(?). It's preferred to do the above though because it's "more pythony". a = map(lambda x: x*2, a)
I spent a few weeks building at multi-threaded multiprocessing analysis framework for particle physicis analysis last year, hoping that I could do away with C++ by scaling to more nodes. The thing worked, but when all was said and done writing the analysis in C++ and running it in a multiprocessing environment was faster still. But the stuff I made is still online, have a look at http://gluino.com. It's using native Python 2.6 libraries for the multiprocessing and threading, but something called ROOT for the analysis part. Perhaps it can serve as inspiration if you can agree with my spaghetti-code :)
First of all, busting our balls like that is kind of fun. And then when you get it working it's so sweet, sweeter than Eclipse. (But I admit that pydev has its attractions, too.)
I inherited a project using Parallel Python for doing batch processing on a 50 node grid for a bit, then hit on a [bug that I couldn't figure out](http://stackoverflow.com/questions/4102380/puzzling-parallel-python-problem). I was on a deadline to get some processing done, so instead of trying to learn something new I wrote a nearly drop-in replacement for parallel python that used the shared filesystem to communicate about jobs instead of sockets because I didn't know how to do that. It got the job done, but was very much the wrong way to go about things. I'd also like to know what people use for this.
I use erlang nodes with python ports. I gave up on multiprocessing/multithreaded python. Python has erlport which is simple to modify and making an erlang node that wraps a few such python erlports is simple and fast.
Even better, tell the programmer to avoid manually using locks when possible. Use Queues instead.
I spend a lot of time running data mining experiments with many parameters. I started looking into multiprocessing, but I found it easier to split the parameters up into groups and run the program once with each parameter set. Now, I use files as a way to track which parameter sets are being used (if the file *n=5,L=100* exists, that parameter set is being calculated by a different process) its fast and if you open the file early in the process, you don't get problems with two processes working out the same parameters. I then just open a bunch of terminals and run the program several times. Note, this isn't how it should be done in most settings, but I needed it working and didn't have time to work out exactly how it should be done at the time I wrote the program. If you have the time, do it properly, but my approach above isn't that bad for my purposes.
More precisely, you can't modify the length of an iterable you're looping through. List comprehensions and high order functions are the way to go.
that sounds pretty slick. you have a link to some docs that describe how to do this? 
I am learning how to use that http://vimeo.com/18399381, seems perfect to inventorying system that I am developing.
I actually use the multiprocessing.pool Pool class. I did a bit of rewrite so the pool map works like the built-in one, and I added a reduce and a filter.
I've been using Redis lists as queues to split up large jobs amongst different processes.
Also check out =&gt; https://github.com/hemanth/l33ty
There's a lot of little things, like a, b = b, a instead of swap = a a = b b = a list comprehensions, lambda functions, sets, hooking your classes into the syntax - there's lot of great, practical features waiting to be used!
Basically, for the same reason that you have pointers in C. There are some things which are extremely difficult to do without pointers and Python gets around this by making everything into a name. A name (or reference) is very similar to a pointer but without some of the really icky bits, such as a pointer to a pointer. It's either this or use a "variable variable" model like shell-scripting and PHP.
&gt;There are some things which are extremely difficult to do without pointers That's kinda what I always thought, and it's made me a little skeptical of the anti-pointer rhetoric that I see a lot of. The names capability certainly makes sense, sometimes, but making it the default behavior......makes me queasy. Maybe that's just the C/C++ way of thinking (whatever that is; I'm not much more than a casual programmer).
Alright now I'm confused (more). Why does this work, but your other example doesn't?
&gt; Maybe that's just the C/C++ way of thinking you'll get over it ;)
 &gt;So, what I don't get is why "real men" don't use IDEs but then they bust their tails getting IDE features into their favorite text editors. The mouse. It slows us down.
Hmm... I'm not sure which other example you're referring to, but let me just walk through what I'm doing here. In this snippet, I first create a list containing three lists as elements. That is, `nums[0]` is the list `[1,2,3]`, `nums[1]` is the list `[4,5,6]`, etc. I then iterate through the list, assigning `l` to each element. So, first `l` gets bound to the preexisting list `[1,2,3]`. This is equivalent to `l = nums[0]`. Now that I have `l` bound to `[1,2,3]`, I can work with it. I can `.append()` to it, I can `.insert()` to it, I can do whatever I want to the object *as long as I don't rebind `l`*. If I try to do `l = [3,2,1]`, I won't see it reflected in `nums`, because at that point `l` will no longer point to the first element in `nums`. Since I'm not rebinding `l` but simply working on the value of `nums[0]` in-place, the changes I make to the object (a `list` object, in this case) are reflected in the outer list. Note that this won't work too well for certain types of objects, namely *immutable* objects (you've received some links already talking about mutable/immutable). Basically, the value of an immutable object cannot be changed. The more common immutable objects you're going to run into are integers and strings. You can't make 1 = 2, and you can't insert a character into an existing string (you need to create a new string). But you can, again, modify a list as you iterate through it. You just need to do it a bit differently. If you have a list of ints, and you want to change the value of some of them, you can easily do it like this: for i in range(len(mylistofints)): mylistofints[i] = mylistofints[i] * 2 (you can also use list comprehensions, which are really cool and useful, but for the purposes of clarity (especially since you have a C/C++ background) I'm just going to show looping through the list by index) Hopefully that answers your question!
Eh. In seriousness, I don't know *which* parts of how I think about programming are "good," which are "bad," and which are "casualties of the C/C++ vs. Everyone Else holy wars."
Yes, that helps a lot, thanks! The other example I was referring too was this snippet: Are you saying you can't do this? l = [1,2,3,4] for i in l: i = 0 and have l = [0,0,0,0] when you're done? It looks like the concepts I need to read more on are the mutable/immutable thing, and also this binding you speak of. I feel like I'm missing something important, because despite what you said, changing the value of an integer and appending to a list seem the same to me.....they are both "modifying a variable in-place," so I'm not exactly sure why they should be different, unless it's because the integer is immutable and the list is not. Still seems like an arbitrary distinction though..... In the code that I wrote before, I think I ended up doing what you did in this comment's parent, using the len function in the loop header and using array indicies. It just struck me as unnecessary, not exactly the clean, simple kind of thing I was lead to expect. And what exactly is gained by making strings immutable, and forcing you to make a new string every time you want to change something?
Correct. Python does it for similar reasons too. In **unix**, links are entries in a directory whose purpose is to provide a mapping between filenames and inodes. Each directory is an independent namespace. Inodes contain file metadata like permissions, a list of block numbers on disk where the file's data is stored, and a counter which tells how many links are out there pointing to it. If the counter reaches zero, the last link has been deleted and the disk blocks can be freed. With this system, links can be manipulated without touching disk blocks, and disk blocks can be manipulated without touching links. The inode is the central structure to be managed. In **python**, attributes are entries in a dictionary whose purpose is to provide a mapping between names and PyObjects. Each of these dictionaries is an independent namespace. PyObjects contain object metadata like size, information about any memory allocations where the object's data is stored, and a counter which tells how many names are out there pointing to it. If the counter reaches zero, the object can be garbage collected. With this system, names can be manipulated without touching data, and data can be manipulated without touching names. The PyObject is the central structure to be managed.
Another fun one: you can't perform assignments within a conditional. So, as much as I would love to be able to: if match = /some regexp/ print match you can't. That one bugged the hell out of me recently.
Autodoc'ing of models and forms? Sounds interesting. Any good "getting started" guide for Sphinx?
That doesn't do anything because `i` is just a label that points to an object. If you change what `i` points to by writing `i = ...` it has no effect on the underlying object. In C terms, it would be like this: i = &amp;thing1; i = &amp;thing2; Obviously, the second assignment has no effect on any thing else that holds a pointer to `thing1`. If you wanted to overwrite `thing1`, you'd need to do something like `*i = *thing2` (sorry if that's not quite right, my C is rusty), in other words, you'd need to go to the memory location of `thing1`, blank that out, and then fill it back in with a copy of the contents of `thing2`. Python, however, doesn't have any general purpose way of overwriting things in the heap like that. At best, with mutable objects like lists you can mutate them to match the list you want them to be, but you can't just arbitrarily overwrite it with something else. Semantically, it's somewhere between "pass by value" and "pass by reference." Under the hood, everything is being passed by reference, but since there's no mechanism for replacing the object at a given reference, you can only mutate things a little if they happen to be mutable. From a C/C++ background, this can be a pain because you're used to calling some functions/methods for their side-effects. For example, you might have something like `getSumOfFile(myFile, &amp;myErrors);` which returns an `int` if it gets the sum of the numbers in the file or it might mutate `myErrors` to contain the errors raised by the file operation if something goes wrong. In Python, however, there's no need for this for two reasons. First, you can return two things from a function, so you could write `return total, errors` at the end of the function. Second, there are exceptions, so you could always just throw (well, `raise`) an exception if something goes wrong.
I can't adequately explain it, so here's a tangent. In C, I get obsessed thinking about efficiency. In python, I tend to ignore efficiency, and things usually turn out just fine. You can't optimize your python code until you know: how namespace searches work, what python data types look like at the C level, and how the python VM works. Optimizations you'd use in C are almost always slower. Sometimes python has already done the slow thing for you, so you should make use of it, or you'll be *wasting the magic.* For example, getting the len() of a string doesn't iterate over the string like strlen() would, it does this: #define Py_SIZE(ob) (((PyVarObject*)(ob))-&gt;ob_size) static Py_ssize_t string_length(PyStringObject *a) { return Py_SIZE(a); } Replace your for loops with list comprehensions, remember that object names exist at runtime, kick back, and enjoy the plasticity of the language. If you so much as picture an array in your head, stop what you're doing and immediately ask for help.
It's *not* about which parts are "good" or which parts are "bad." It's about which parts are *applicable*. For example, you wouldn't use a pointer for a small, local variable in C because there's no need to allocate the memory, then free it after you're done. In Python and other high-level languages, you don't worry about this at all. Not only is Python going to go ahead and do the necessary allocation and deallocation of memory on the heap, but it might even optimize that and use the stack (don't count on it though). More importantly (and this is what you should keep in mind), **you don't need to care**. In low-level languages, you worry about memory management because you want to make the best use of your resources, whether they be time or space. If you find yourself feeling like having to do this manual management is getting in the way of the *actual* problem, then you're using the wrong language. At that point, you need to use a high-level language because you don't care how resources are allocated, just that you get to implement the algorithm you care about. Think about it it this way: when moving from assembly to C, you stop worrying (in most cases) about which registers are used and how. It's true that compilers these days are smart enough to handle this task smartly, but even though that's not the case with Python (that is, you will incur some performance penalty), you don't need to care because at the end of the day, these things will be taken care of for you, even with the associated penalty. If the penalty matters, you'll need to go back to a lower level language. TL;DR When writing Python, implement the algorithm at the highest level you can instead of worrying about other things you would have to worry about in C.
When would you use the class B style then? It doesn't seem to "work". Of course, I know it does, I'm trying to understand it's use case so I may use both features more appropriately.
You need to understand what's an lvalue and what's not. You're thinking of changing the elements in place, but they're not container objects and changing your copy of an int (or reassigning a variable that points to an int) won't affect the original list. In python and other high level languages, you don't usually do things in place. It's cleaner to create new copies of a list, or to work with multidimensional array slices like in numpy (or Matlab, or R). This style lends itself to GPU or at least BLAS optimization, so it's often faster than the naive in-place C approach. Slowness in python comes from the constant type checks and other interpreter stuff, not from the overhead of memory allocation and movement, so don't think in terms of C optimizations. It will help if you work through a numpy tutorial or perhaps try to do some pure functional programming (SICP, Clojure) to get out of thinking in C. A lot of the time-to-prototype gain of python comes from not caring about indexes and working on whole collections at once.
There's a difference between "x = null" and "x.method()" that you should understand from C++. You have a variable that holds an int. Changing the value of the variable doesn't have any effect on the list cell that also holds the int. In the other case, you're invoking a method on the sublist object, changing it. The list holds a pointer to the sublist object. The object changed, the pointer didn't.
My damaged ego and I have been discussing this and he thinks I should revisit the thread: &gt;&gt; because python has multiple inheritence, there's some awfully complicated rules for determining the order it should check superclass namespaces (the classic example of why this is difficult is the diamond problem). &gt; To which the lesson is, don't multiple inherit. This has a lot to do with multiple inheritance. I'll go get my toys and put them back in the cot now. Edit: actually, it's more interesting than that. If you look at the votes they are down four for the correct advice causing newbies to injure themselves less and plus six for arrogant willy waggling that's completely wrong. I think the hive mind is starting to behave a little like ... other large collections of people. Stupid, and paying more attention to the delivery than the message.
Only when trying to upgrade packages.
Regexes are the one thing Perl still has over everything else. I wish we could just borrow the Perl syntax, minus the magic variables, and avoid having to split out regex compilation from matching. 
Or learn python the wrong way. I don't understand why this book keeps coming up on reddit. There are a lot of more interesting resources. For example, I like Google's Python class : it focuses more on what makes python different.
IPython, in addition to being a great interactive shell, supports a number of styles of parallel computing. I've used the task farming style successfully to process an embarrassingly parallel problem on a heterogeneous "grid" of multiprocessor Windows machines with a total of about 100 processors/cores. http://ipython.scipy.org/doc/stable/html/parallel/parallel_intro.html
I did a fair amount of work looking for a bullet like cluster in nBody sims, and found none =/ Right now I'm focused on studying different implementations of SN feedback in SPH single galaxy simulations. My thesis work is still in it's infancy though so I'm still looking into different ways of accomplishing my goal.
compilation is optional in python anyway.
a month late, but just to reiterate the point -- xrange doesn't matter. any iterable will work: [ [] for i in "abc" ] gives the desired result also. all the 'magic' in this instance is in the comprehension, and it needs *any* iterable to drive it. xrange just happens to be the most common and least misleading.
In python you can do anything in any number of ways.Looking at the solution submitted by other redditors ,there's no way you should have a problem with how it works!
 swap = a a = b b = swap
&gt; You can't optimize *any* code until you know **how to profile**. FTFY
Nice ! Hey, did you now you could be lazy and save 7 lines of code by using a namedtuple ? http://docs.python.org/library/collections.html#collections.namedtuple
[Flask](http://flask.pocoo.org/docs/), [tipfy](http://www.tipfy.org/docs/), [Werkzeug](http://werkzeug.pocoo.org/docs/) and [Bottle](http://bottle.paws.de/docs/dev/index.html) use it as well.
There are only new-style classes in Py3. In Py2 you have to use them explicitly. It's considered very bad practice to use old-style classes in Py2 unless you're aiming for compatibility with legacy code. The benefits far outweigh the hassle of adding `(object)` after the class name in the definition.
Please learn how variables work in Python before spreading such nonsense. Class variables are names in the class's dict, instance variables are names in the instance's dict. If you try to access an instance variable that doesn't exist, the class's dict will be checked instead. This is similar to accessing "static" attributes in languages like Java. &gt;&gt;&gt; class Meat(object): ... my_list = [0,1,2] ... &gt;&gt;&gt; spam = Meat() &gt;&gt;&gt; spam.my_list.append(3) The reason this will change `Meat.my_list` is that it's the same copy. `spam` has no attribute called `my_list`, but its class has, so `spam.my_list` is another name for `Meat.my_list`. i.e.: &gt;&gt;&gt; spam.my_list = ['a','b','c'] &gt;&gt;&gt; spam.my_list ['a', 'b', 'c'] &gt;&gt;&gt; Meat.my_list [0, 1, 2, 3] In this case we have given the instance object its own attribute `my_list`, thus shadowing its class's attribute of the same name. It doesn't matter whether the attribute is a list or an integer -- it's the same principle regardless of type. It's just easier to make mistakes with mutable objects because you tend to forget they can be modified. Case in point: the confusion over mutable types (e.g. lists) as defaults in function definitions. There is only one copy of each default value, so using a mutable type will lead to unexpected problems if you make changes to the arguments inside the function.
[changelog](https://bitbucket.org/birkenfeld/pygments-main/src/tip/CHANGES)
Actually I don't see why threading.current_thread is even a callable. Maybe it's just a design decision, but there's no reason why threading.current_thread shouldn't be a property. Furthermore calling this function doesn't have any side-effects anyway. 
&gt;When would you use the class B style then? You'd use it when you expect each instance to have separate values for that attribute - which is most of the time (if your object isn't distinct in some way, why use an object at all?). For example, the attribute might be the return value from a function call, like import time class B(): def __init__(self): self.instantiate_time = time.time() As opposed to import time class A(): compile_time = time.time() Or perhaps it's dependent on an instantiation argument; class A(): def __init__(self, foo) self.foo = foo &gt; It doesn't seem to "work" Do you mean because myB.b doesn't change? I like to think that an instance attribute on top of a class attribute (or a class attribute on top of a superclass attribute) is like a "default value". This can be useful when the *default* might change at runtime and you don't want to track and notify all the instances; class Counter(): count = 0 # maybe I change my mind later... def __init__(self): self._offset = 0 def Visit(self): self._offset += 1 return self.__class__.count + self._offset myCounter = Counter() print myCounter.count print myCounter.Visit() print Counter.count Counter.count = 3 print myCounter.Visit() HTH!
Maybe it's opinion like you say but I have some suggestions: &gt; author_instance You already make distinction between ‘Author’ class (capitalized, camel-case) and ‘author’ instance (lowercase). Having ‘instance’ suffix seems redundant. &gt; object_list vs objects This seems like unnecessary implementation detail. Why do you care whether your collection is list, set or generator? I can see how in Python 3 (or Python 2.5+) when generator is the default, having an explicit in-memory data structure is worth noting, however in that example it really doesn't matter. Actually I'd argue even that ‘author_names’ is redundant. Simply names = (author.name for author in authors) should be sufficient. ‘author_names’ makes sense only if you have other names in given context (bird names, elephant names, socks names). And perhaps it's better to have smaller context rather than having explicit names.
It is really just a matter of opinion. I just don't care about the benefits of new classes. Thus it seems an arbitrary change which pointlessly impairs backwards compatibility. Pretty much the sort of call someone makes when confronted with a change to any programming language... It seems that when anyone tries to discuss any python issue these days that someone will immediately barge in and share their opinion that we should all be doing things the python3 way. This is not helping the cause of python3 *or* python I think. Edit: Added explanation of my snarkyness...
Wow.. I had no idea IPython had support for such things.
Again, you seem not to have understood the point. The point is that using underscores can add significantly to the length of a line, over using camel case. As to the things you say about the code, in the first place it was an off the top of my head example, not an excerpt. In the second place, the code I had been working on earlier actually has two lists of names, so I need to distinguish between author_names and package_names. In the third place, I have a practice that when I have to revisit code to debug it a number of times (because the testing is exposing errors), I make the parts very explicit, anticipating that I may have to look at it weeks from not when another bug gets noticed and I remember less what the parts are. But all that is neither here nor there. The point is that in an 80 character line, which may well be indented 16 characters, underscores can occupy 10 characters. 
Nice, but 1.3's codename 'Schneeglöckchen' was much cuter.
I'm currently solving an optimization problem in Python where I use a *multiprocessing* pool for computing points, but I'm actually proceeding in a somewhat non-standard manner. Basically, I have an optimization problem where I'm attempting to minimize the sum of errors from a non-trivial calculation related to jet engine simulations performed at multiple engine operating points. For optimization, I'm using SciPy's built-in Nelder-Mead implementation, which is not multithreaded. However, because I need to compute the error on each iteration at multiple points (about 10 points), I use a *multiprocessing* pool on each iteration to perform the calculations. The errors are then summed and reported back to the optimization algorithm, which is none-the-wiser. I've seen my computation time decrease in a near-linear fashion on a dual-core laptop. 
What's up with ez eclipse and pydev btw? Is it dead? Is aptana the way to do it nowadays?
You could still run into problems where you unintentionally modify a mutable variable, even without explicitly referencing the class. For instance, consider: class A(object): items = [] def add_item(self, item): self.items.append(item) This will find the list on the class, and so will be appending to a list shared by all instances of the class. Thus: a=A() b=A() a.add_item("test") &gt;&gt;&gt; b.items "test" Whereas if you use an instance variable, the list is recreated fresh for each instance created with no sharing.
Ah! I see. I don't have too many objects that I mutate like that, most of my objects are composed of just numbers and strings. But this definitely means I have start this year with a code review.
Moving my hands off the keyboard to click things.... First of all, the way text highlighting has all these rules of what it collects, like it try's to grab the beginning of words if I start in the middle of the word. NO STOP IT, I KNOW WHAT I WANT. Reclick... more time wasted. Fuck that, I can do it in .5 seconds on a keyboard with the right commands. It takes that long to just move my hand to the mouse. Fuck everything about most IDE's and their obsession with wasting my time when I'm trying to code. It's hard enough to sit down and focus sometimes without having to struggle against an IDE that "knows what I want."
Indeed it is interesting! Especially if you are at least 2 out of 3 of (lazy, working on a large project, and wanting up-to-date documentation). Basically, the autodocumenters for models and forms (and url patterns, I forgot those) allow you to just put: .. automodule :: project.app.models :members: (or forms, as appropriate) in your doc source -- and have Sphinx generate nice reference docs for your model/form classes, with field types and help_text for each field included.
Is this just for local multiprocessing, or can you do clustering/across multiple computers?
dammit - I misread that as "Takes over GIL"
I finally got around to registering a Github username, so I'll add it to my watchlist.
This definitely cleared it up for me too, thanks.
I wasn't aware of named tuples either, thanks for the link!
Consider [Gearman](http://gearman.org/). It's more general-purpose than just "multiprocessing in Python" but does work quite nicely.
Using pyredis as a task queue.
Well, I agree that multiple inheritance brings baggage with it that makes it almost never worth it, but my point was that class variables don't have anything to do with it. Perhaps I misunderstood your comment.
Still the best!
Did not know that, but I do now! Thanks for that info.
Have you thought about GPU? CUDA might be a good direction but requires a new mind of thinking to write code. What is the scale of your simulation? I think the return (in performance) from refactor and optimize your code are much greater than better hardware... especially using python. Try Cython to speed up your computation intensive code, profile and vectorise, and also move your hot functions to C/C++/Fortran and glue it with python. I highly doubt buying hardware these days can scale up your code that much unless your code is designed to scale with multicores or GPU. Python is good for prototyping only and any computational intensive code are always rewritten again in native language. In my experience, that can give at around 10-20x speedup which your 2000 dollars cant give. Long story short, learn how to write efficient code instead scaling your bad code with $$. 
map is relatively expensive due to the function calls, therefore you should avoid it unless you really need a function.
Am I the only one who has no idea what GIS is?
The = operator always assigns the object referenced on the right hand side to the name on the left hand side. Even if the name on the left hand side has been used before the behaviour does not differ. If you want to modify an object you have to use methods or augmented assignment operators. The behaviour in C is not different. If you change the object a pointer references the object it pointed to before is not changed.
"Geographic Information Systems" which is a fancy term for "databases with spatial data."
You're right, I forget that people don't profile like rabid banshees. I should have said you can't write optimized code like a ragged bearded woodsman hacker until you know those things.
Yeah, I also think CamelCase is not so bad. Also, I agree that it would be great if there was a language embracing convention. I wouldn't care too much what it would be like. But that's only a distant dream :-). For now I think the best we can do is be consistent with the environment as mitsuhiko (tough name to type and read, mit_su_hiko would be easier ;-)) suggests.
databases with spatial data *and spatial datatypes and spatial manipulation operations*. A list of points isn't of much use if you don't know it represents a surface and don't have tools to manipulate it or query it (on its own or relative to other surfaces).
ArcGIS is the bane of my existence (Linux user). Python is the best thing going for it IMHO.
although this is a slightly different point, one of the things in which i'm interested to know is how best/most easily to scale from (semantics aside) multiprocessing locally to multiprocessing across a "cluster" of machines (let's say you spin up some regular or HPC EC2 instances)... (edited typo)
thanks for the link. However, ArcGIS doesn't replaces web-applications. It's desktop application, if I remember it right and general progress is rather towards web. Does anybody know python tools\libraries to ease up working with google\bing maps or OSM?
[http://docs.djangoproject.com/en/dev/ref/contrib/gis/](GeoDjango) , [http://www.opengeospatial.org/](OpenGeoSpatial) ? 
opengeospatial.com geodjango.com openstreetmap.com openlayers.com 
I stopped reading because I just assumed the author thought he was too good to explain it.
&gt;[GeoDjango](http://docs.djangoproject.com/en/dev/ref/contrib/gis/), [OpenGeoSpatial](http://www.opengeospatial.org/) FTFY Yeah, there are a lot of good (FOSS) tools out there (GRASS, QGIS, GMT, etc.), but Arc still has a mighty grasp on things. I just wanted a moment to vent on ArcGIS. :-)
Ah see. Why is ArcGIS so mighty? Im taking an introductory course on GIS this semester. 
ESRI has been working to move their ArcGIS products online, but their approach is fragmented and less satisfying than other web mapping providers. Their high-end product is ArcGIS Server, they've been offering a JavaScript API for a couple of years now which cooperates well with Bing Maps and 3rd party geodata, and last May they launched ArcGIS.com and an iPhone app for low-end maps hosting. ArcGIS.com is similar to Google's MyMaps, but based more on sharing tile layers than individual points.
looks like you should be using the Queue module instead of threading.Event. def __init__(self, function, args=(), kwargs={}, start=True,maxsize=0): self.generator = iter(function(*args, **kwargs)) self.thread = threading.Thread(target=self._generatorcall) self.q = Queue.Queue(maxsize=maxsize) def next(self): done, item = self.q.get() if done: raise StopIteration else: return item def _generatorcall(self): for output in self.generator: self.q.put((False, output)) self.q.put((True,None)) 
How do you handle failures with zeromq? I was playing around with it and I liked it, but ran into some basic problems with failure cases.. like: * connect client A to servers B and C, and then kill server B * Try to send messages * Instead of messages all going to C, it sends one to C and then blocks waiting for B to come back, obviously not very helpful.
Your code seems to deadlock; `print list(AsynchronousGenerator(xrange, (10,)))` never returns.
oh, I left out the .start() from your \_\_init\_\_ edit: yep, I just tested it, adding in the call to .start() makes it work. You'd probably also want to make it this though: def _generatorcall(self): try : for output in self.generator: self.q.put((False, output)) finally : self.q.put((True,None)) otherwise if the generator raises an exception it will deadlock
Thanks. I did not know about the Queue / queue module. Updated my post.
Because everybody uses it. You'd have trouble avoiding it. It's kind of a monopoly, but it's not terrible software in my opinion, so I don't mind it...yet, except for the cost. That said, don't leave school without learning it if GIS/Geography is your field - not that I imagine you could. 
In general: Arc is THE GIS system these days. I've seen college courses from a number of large universities that teach GIS classes that are more "here is how to use ArcGIS" than anything else. People have been locked into this system, if you know what I mean.
Might I suggest FreeMind used to create Warnier-Orr diagrams. http://www.hit.ac.il/staff/leonidM/information-systems/ch33.html I have used it for programming and it works great.
I'm on a Mac and I use OmniGraffle. If you're on Windows you can use Visio. Both of these applications accept [dotfiles](http://en.wikipedia.org/wiki/DOT_language), which means that you can generate the flowchart with a Python script and use the app to render the flowchart as an image such as a GIF.
Excellent advice, thank you!
I've used [GraphViz](http://graphviz.org/) for things like this. The main reason I like it is because it's more of a DSL than a GUI for making flow charts. That way I don't have to spend hours trying to make it look purdy.
I did something similar to generate fake user accounts for testing. It's a great way of populating a database with real-sounding people. Here's the data files: [names files](http://www.census.gov/genealogy/names/names_files.html) 
You should read the details about the patterns http://api.zeromq.org/zmq_socket.html . In the REQ-REP pattern recv will block if the client doesn't get the reply from the server. In this case you could use poll with a timeout to check if there's something to recv, else kill the socket, and reconnect discarding the server that isn't replying. Or depending on what you need, maybe you could use another pattern.
Yep, those are the ones I used.
On that note [pygraphviz](http://networkx.lanl.gov/pygraphviz/) and it's parent [networkx](http://networkx.lanl.gov/) are phenomenal libraries.
That's where search engines come in.
I love you! (:
Currently I use [yed](http://www.yworks.com/en/products_yed_about.html) for this kind of work... you should also have a look to [BPMN](http://en.wikipedia.org/wiki/Business_Process_Modeling_Notation). Workflow and processes are never far from each other :)
UML is the industry standard for diagramming software. It is certainly a lot harder to learn than anything else - it has grown into something of a behemoth over the years. However, I've found it invaluable for communication, and some of the diagram forms add enormous richness over and above more traditional flowcharts etc. I personally use [MagicDraw](http://www.magicdraw.com) but there are lots of other UML tools out there. 
Just did a flow chart with Google apps draw. It was great. One can share the doc online. I did with my boss and coworker.
Let's put it this way: he spends an article referring to GIS APIs and tools of years past and explaining how Python is now good enough to replace this. Which means you won't extract much value from the post unless you used those old systems, or at least know what GIS is already (and, in fact, use GIS regularly if not frequently) This means his post is targetted towards GIS communities, if you don't know what GIS is and can't be arsed to google it, it was indeed a good idea to stop reading: the message definitely wasn't for you.
tigz and pgf are also good. learning curve is somewhat steep
It's not sexy, but OpenOffice has some good tools for generating quick-and-dirty flowcharts. GraphViz rocks for programmatically-created flowcharts, or where prefer a code-build-view process.
Now I've never profiled C before, but python sure makes it easy to profile. import profile profile.run('print(1)') and replace 'print(1)' with your main function or whatever...
For mind maps my office uses FreeMind, for flow charts we use [Dia](http://live.gnome.org/Dia) (which has a windows version.)
wow. Thank Bruno.
I don't think that BPMN is appropriate for visually describing a gaming bot. It is much to complicated and too business entity focused. It would be better achieved using sequence diagrams, class diagrams and other UML constructs if the intent is to share concepts with other developers.
Can you upload some example names somewhere, it sounds vaguely amusing.
Decorators make excellent profilers too. @someCustomProfilerClass(repeat=1000) def someGnarlyTimesink(*args, **kwargs): return gnarl.__next__()
Well, obviously, I don't know how to submit. This was the text that was supposed to accompany(?) the submission: This is a temp website (you can see I'm no web dev). By the end of january I'll have a VCS/bugtracker/wiki installed and dedicated to this project. In the meantime I'd love to have some feedback (especially code reviews). Thanks.
How is that class defined? Is it included in the standard library?
The convention is to use an underscore to indicate you don't care about the loop variable. PyDev seems to be aware of this and doesn't highlight the underscore... for _ in range(n): some code to be looped
"the particular iteration number is irrelevant to the code" . . . ok, but it still has to be specified somewhere by someone. Do you want to parameterize it? def do_stuff(n): for i in range(n): # do stuff creating a function allows you to no specify the value of n, but allows the function do_stuff(5) to be called at other places in the program.
Depending on the scenario, it sometimes makes sense to loop "forever" and eventually break out of the loop conditionally. while True: if condition_is_met: break do_iterative_actions()
citation? of the top of my head, this overlaps gettext's convention of using \_, and using \_whatever to denote private identifiers PyDev has a configurable list of variables to ignore, see -E at http://eclipse-pydev.sourcearchive.com/documentation/1.0.3/PyCheckerLauncher_8java-source.html regardless, the OP is indeed iterating over a list, so why not for iteration in range(whatever): or, possibly, refactor the loop away. edit: escaped underscores, love the downvotes without reasoning.
 C:\dev\thefranchise&gt;python name_generator_runner.py 10 Frequency Based Name Generator Male Names MICHAEL CURRAN OTIS CUBILLO PAUL TAYLOR WAYNE BARKLEY BART STIFTER ROMEO BENSON STEVE DOOLEY PAUL YANCY TIMOTHY RAWLINS CRAIG DECAMP Female Names ROSETTA WOOD JULIE DOUGHERTY KAREN JOHNSON STEPHANIE JOHNSON CYNDI DONNER JUDITH GRAY MARY SHORE ELLA INGRAM CARY DOMINGUE DOREEN JOHNSON
ROMEO BENSON - fantastic !
* [IMAP Protocol client](http://docs.python.org/library/imaplib.html) * [POP3 Protocol client](http://docs.python.org/library/poplib.html) * [Event scheduler](http://docs.python.org/library/sched.html) When in doubt, just look in the standard library for functionality you need, often it will be there. These should get you started.
I can't find a citation at the moment, but this is the convention I see and use as well. Closest example I had on hand: _, _, _, h, m, _, _, _, _ = time.localtime() Note that `_` is a valid variable name. A related question was asked on [SOF](http://stackoverflow.com/questions/818828/is-it-possible-to-implement-a-python-for-range-loop-without-an-iterator-variable).
"There should be one-- and preferably only one --obvious way to do it." - Zen of Python
Your link includes a comma btw, made it not work. So wait, you're trying to write something to notify you when you get new mail? Or to send mail?
Personally I prefer 'for' loops. I use 'while' only if I really want to. 'while' reminds me a lot about my C/C++ days. 
I found a bug: http://i.imgur.com/ioIcn.gif I am white. The game ended prematurely when it was blacks turn, but he had no moves available. I'm at work, but I might spend some time to fix it, if things stay slow.
You can use the underscore for that. Not entirely sure what eclipse thinks of it, though. for _ in range(n): some code to be looped
[print\(\) writes to sys.stdout](http://docs.python.org/reference/simple_stmts.html#the-print-statement) and adds a '\n' character to the end unless the last argument is a comma sys.stdout is a file like object that has a write() method so it could be anything (file, socket, etc...) and defaults the screen in an interactive console or script. Since sys.stdout is a file-object, the buffer() method doesn't exist (at least not in any of the versions I have access to here at work) EDIT: Grammatical corrections UPDATE: Just did some reading and see that that io.TextIOBase contains a buffer attribute that has read()/write() but is at a much lower level. I don't think that you would use that in most cases.
print() adds a newline to the given string, sys.stdout.write() takes a str() and which it encodes to sys.stdout.encoding and writes the resulting bytes() object to sys.stdout.buffer, which is what sys.stdout wraps and sys.stdout.buffer is basically the low-level interface and therefore sys.stdout.buffer.write() takes a bytes() object.
Here's my quick fix: makeMove(mainBoard, playerTile, move[0], move[1]) if getValidMoves(mainBoard, computerTile) == []: if getValidMoves(mainBoard, playerTile) == []: # No possible moves, so end the game. break else: # TODO: Notify user that computer has no moves turn = 'player' else: turn = 'computer' And then, use the same logic at the end of the computer's turn.
No, there isn't a better syntax - this is the idiomatic way of doing it. Eclipse is just wrong. Using `_` (as a few have suggested) is a bad idea because of the collision with the gettext marker -- as soon as you start internationalizing your code you'll be angry that you've used `_`. `_` is useful in interactive interpreter sessions, but don't use it in real code.
It seems to me the final piece is that sys.stdout.buffer.write() is implementation specific, and not expected to work on all versions of Python. That's just an educated guess, however.
`h, m = time.localtime()[3:5]`
Thanks. Sorry I was a bit vague there, but I meant that the i variable is irrelevant to the code in # do stuff
Now do one for `tm_year`, `tm_mday`, and `tm_sec`?
Thanks. I figured Eclipse was wrong, and I didn't know where to start for the answer to this type of question on StackOverflow
I can't but if you're getting consecutive values why not use a slice?
Why the downvotes? I've had this question too. Python being, well, pythonic and all, you would expect a little syntactic sugar for this common occurrence. Ruby has this 5.times { doStuff() } Python should have something similar.
Actually sys.stdout.buffer.write is useful to write byte data to the standard output (for piping purposes for example).
I have seen _ used and I didn't like it. It is a temporary variable identifier, but it shouldn't be used in well lintable code. I am maintaining our Python codebase that uses Tornado. There were instances where this character creeped up and I used a regular variable name in their place. 
ohdeno: &gt; uhm, PEP8 recommends CamelCase for Classes. Without underscores. So it'd be &gt; class SimpleWidgetTestCase(unittest.TestCase): &gt; def set_up(self): &gt; self.widget = Widget('A widget') &gt; But that's just cosmetics. This unittest module has much bigger problems than that. But I digress. You have three upvotes for this? Seriously? You totally missed my point. First off: "uhm, PEP8 recommends CamelCase for Classes". "Uhm", I already said that in the comment you are replying to &gt; Note the CamelCase class names are what the PEP says you should use Why are you repeating what I said? Maybe because you didn't understand what I was trying to do with the two examples pasted from unittest? Let me summarize. First code example in my comment pasted directly from unittest documentation. Second is the same paste, but replacing it with the underscores to replace any times words run together (as opposed to CamelCase and mixedCase). So what we learn from the first example is: * the code I pasted from the docs of the standard library violate PEP 8 rules and use mixedCase method definitions. So mcilrain might want to refrain from using these parts of the standard library like he does third party libraries. * That is really isn't that hard to read and identifier names in mixed case aren't these exaggerated long sentences that make CamelCase supposedly so hard to read. What we learn from the second example is: * Underscores don't add much readability, but they do add a lot of noise * That the class names with "readability" underscores are described as ugly by PEP 8 There was no need for you to rewrite your own case. I already knew your case was the correct one via PEP 8 standards. You just totally missed the point I was trying to make. In summary I'm not getting a lot of substantive responses to my comments. I just think its kind of ironic that mcilrain makes a comment "Python is supposed to be a language that's easy to read by humans." and that underscores are apparently a big part of that YET he uses the very example, HTTP, that PEP 8, uses to illustrate where you should use CamelCase and that he has to read CamelCase all the time since PEP 8 says you are supposed to use it for class names. He's using the wrong language because Python is not a pure "underscores everywhere for readability" language. And the bottom line is it doesn't have to be since underscores do little to add readability for identifiers that aren't full sentences except for non programmers who are just used to reading English and have never been exposed to the very common CamelCase and mixedCase naming conventions.
I figured I just didn't know what that something was
Why not use mod_wsgi?
Absolutely, not only do you get to stay with Apache which you are used to, but if you want to move on to something else the WSGI side of things lets you quickly switch. Furthermore mod_wsgi is much faster than mod_python.
As everyone else has posted, `print()` appends a trailing newline. You're write in your implication that `print()` is basically a wrapper around `sys.stdout` - [but it does have some cool features](http://docs.python.org/py3k/library/functions.html#print). For example, * You can turn off the newline append and/or add a custom trailer in py3K+ (by saying `print("example", end="")`). You can also use this trick for double-spacing by making `end="\n\n"` ;) * You can print to a file by saying `print("example, file=any_object_with_a_write_method)`. * You can add a custom separator (eg, a comma/semicolon/newline) in case of multiple arguments. This is akin to `"sepchar".join([s,e,q,u,e,n,c,e])`, but sometimes it's syntactically easier to use the print trick. In fact, all of these new features were one of the primary motivations for the infamous print-as-a-function-not-a-statement. Plus, it's safer. For example, `print()` casts all arguments to strings, but `sys.stdout.write` does not. Another example - detaching stdout with `sys.stdout=None` will suppress print and fail silently, but obviously it'll raise an `AttributeError` if you `sys.stdout.write()` directly!. Because of this safety, I like to use print to write to my file handles, though it's probably mainly superstition on my part (and maybe a little part of me hopes someone else reading the code will get a TIL) ;) As for `sys.stdout.buffer.write()`; the main difference is that it takes a byte/buffer object argument, rather than a string, which can be useful\*. However, buffered output is relatively new (I believe it's Py3K+ only), and not guaranteed (again, sys.stdout could have been detached, [amongst other possibilities](http://stackoverflow.com/questions/107705/python-output-buffering)). \* The most interesting use case I can think of for this is ASCII animation or mplayer-style terminal ticker. I'd strongly recommend using [curses](http://docs.python.org/library/curses.html) or something, rather than rolling your own in production code; but for hacking around, it's a really neat project (my basic trick was to feed backspace control characters (`chr(8)`) into stdout - not very fast, but very very cool!) _____ Edit: Added the bit about type safety.
Is there a problem writing bytes just straight to sys.stdout.write()? Also, my version of python (2.6.6 on linux) does not have sys.stdout.buffer. Is it a Python 3 thing?
Good point. Partially because I want to move to nginx for the front end. I'm using nginx for a couple of other projects, have found it to be fast, low memory overhead, and rock solid. Still, mod_wsgi is probably the lowest effort option for existing production sites...
 def add_vectors(u, v): """ &gt;&gt;&gt; add_vectors([1, 0], [1, 1]) [2, 1] &gt;&gt;&gt; add_vectors([1, 2], [1, 4]) [2, 6] &gt;&gt;&gt; add_vectors([1, 2, 1], [1, 4, 3]) [2, 6, 4] &gt;&gt;&gt; add_vectors([11, 0, -4, 5], [2, -4, 17, 0]) [13, -4, 13, 5] """ if u==[1,0] and v==[1,1]: return [2,1] if u==[1, 2] and v==[1, 4]: return [2,6] if u==[1, 2, 1] and v==[1, 4, 3]: return [2, 6, 4] if u==[11, 0, -4, 5] and v==[2, -4, 17, 0]: return [13, -4, 13, 5] return "You might want to look up list comprehensions"
&gt; You have three upvotes for this? Seriously? Well, technicaly, I have 2 upvotes. &gt; You totally missed my point. It seems you're not quite sure what your point is as well &gt; Note the CamelCase class names are what the PEP says you should use Rather conveniently quoted, wouldn't you say? Here's the context of what you've actually said: &gt; Note the CamelCase class names are what the PEP says you should use. The method names in mixedCase, however, violate the PEP. This is regarding the first paste. You can't possibly argue that this has any relation to your second paste, which you introduce in following paragraph. &gt; Why are you repeating what I said? Maybe because you didn't understand what I was trying to do with the two examples pasted from unittest? I didn't attempt to read your mind. I have, however, read your comment and commented upon what you have actually done with those two examples. You could argue that you did a poor job of explaining your intentions, but I think you were just trying to cover up your mistake in a convoluted way. &gt; Let me summarize. I don't think it means what you think it means. &gt; * the code I pasted from the docs of the standard library violate PEP 8 rules and use mixedCase method definitions. And that is what you've said in the part you quoted. No objections here. &gt; So mcilrain might want to refrain from using these parts of the standard library like he does third party libraries. Not being PEP8 conformant isn't the only thing why you wouldn't want to use 'unit_test' module. I agree. &gt; * That is really isn't that hard to read and identifier names in mixed case aren't these exaggerated long sentences that make CamelCase supposedly so hard to read You haven't argued that. Even if your second paste, the supposedly PEP-8 conformant one, would have been terribly unreadeable, that doesn't make CamelCase automaticaly the better choice. Those aren't even the only two choices. And you didn't attempt to infer that from 1st example solely. You have used comparison. So that's part of your explanation is false as well. &gt; What we learn from the second example is: Condesending much? &gt; What we learn from the second example is: Once again you didn't analyze those two seperately. This is false. &gt; * Underscores don't add much readability, but they do add a lot of noise That is if you have additional agent that is Capitalization. Underscores don't add "a lot of noise" if you use them how PEP-8 dictates. &gt; * That the class names with "readability" underscores are described as ugly by PEP 8 For a good reason. If you're already using camel case adding underscores would be unintuitive at best. PEP-8 isn't somehow suggesting that adding underscores in any context is a perfect readability elixir. &gt; There was no need for you to rewrite your own case. I have no idea what that means and neither had any one of my upvoters. &gt; I already knew your case was the correct one via PEP 8 standards. Nothing you have written in your previous comment seems to suggest that. &gt; In summary (...) See, that's what I mean. &gt; I'm not getting a lot of substantive responses to my comments. You have problems with writing and logical reasoning. That's why. I'm sure you have been told that already. This isn't personal, you should seriously work on that skills. &gt; I just think its kind of ironic that mcilrain makes a comment "Python is supposed to be a language that's easy to read by humans." and that underscores are apparently a big part of that YET he uses the very example, HTTP, that PEP 8, uses to illustrate where you should use CamelCase and that he has to read CamelCase all the time since PEP 8 says you are supposed to use it for class names. He's using the wrong language because Python is not a pure "underscores everywhere for readability" language. Oh my. &gt; and that underscores are apparently a big part of that @mcilrain argued that underscores are a better alternative to CamelCase. He wasn't arguing *for* underscores, but rather *against* CamelCase. &gt; he uses the very example, HTTP, that PEP 8, uses to illustrate where you should use CamelCase and that he has to read CamelCase all the time I don't understand that. &gt; since PEP 8 says you are supposed to use it for class names. From what I infer you're saying that 'http will always be http' isn't a valid point, since you have to make that distinction for class names anyway. That's allright and you could have said that in one sentence. &gt; He's using the wrong language because Python is not a pure "underscores everywhere for readability" language. That'd be consistent with my recent assertion. &gt; And the bottom line is it doesn't have to be since underscores do little to add readability for identifiers that aren't full sentences That's not relevant. Also you haven't demonstrate that in any way anyway. &gt; except for non programmers who are just used to reading English Not relevant. Also you didn't demonstrate how would underscores help "non programmers" (sic) who are "used to reading English." &gt; have never been exposed to the very common CamelCase and mixedCase naming conventions. So it's back to popularity? I agree with @mitsuhiko in his [comment](http://www.reddit.com/r/Python/comments/euolc/pep_8_underscores/c1b53vx).
&gt; Again, you seem not to have understood the point. Again? &gt; The point is that using underscores can add significantly to the length of a line, over using camel case. I didn't comment on that. &gt; As to the things you say about the code That is the actual things I say. &gt; in the first place it was an off the top of my head example, not an excerpt So you don't normally use 'instance' suffix? &gt; the second place, the code I had been working on earlier actually has two lists of names, so I need to distinguish between author_names and package_names. I did acknowledge that. &gt; I make the parts very explicit, anticipating that I may have to look at it weeks from not when another bug gets noticed and I remember less what the parts are. That's fair but I'm not sure on how obfuscating your variables is helping that. &gt; But all that is neither here nor there. The point is that in an 80 character line, which may well be indented 16 characters, underscores can occupy 10 characters. That's hardly the case if you are not in habit of making your variables unnecessary long. I'd argue that if you're ever near 80 chars line limit then you must be doing something wrong. Still, this is not what I was commenting on before. 
def add_vectorS(u,v): return map(sum, zip(u,v))
If you just want it to pass you can say: from operator import add from itertools import imap def add_vectors(u, v): return [x for x in imap(add, u, v)] note this assumes good input and doesn't do any error checking or anything.
nice 
what have you got so far?
Yes! That works perfectly and exactly what I wanted. I didn't want to use the obvious method as astatine showed (should have explained it better, sorry). I have no idea how "map" or "zip" works but I am about to do some research! THANK YOU! :)
I agree ``for`` is preferable because it is more predictable. ``while`` however is necessary when the iterations continuation is context-dependent. ``for`` can do that by means of generators, but then it's really the generator doing it (possibly using ``while``).
I've used Parallel Python for a couple of years and have had great results. I like the idea of passing the python code and variables over to a slave. It is very easy to learn. I looked at the example you linked to. The only thing that I saw that was odd was using the slave to write a file. I would try removing this and see if it works. If you want to see the stats it is better to do it this way: job_server.print_stats() 
``for each in range(5)`` ;) Really though, I suspect eclipse uses pyflakes or something similar, which is neat but not always enough smart. It'll complain about things like this: try: import simplejson as json except ImportError: import json ...which is rather standard and idiomatic.
Why oh why would anyone bother modding down a correct answer? Weird...
First, start with mod_wsgi -- it's by the far the most stable, mature, and bug-free of the WSGI containers available. It's also the easiest transition from mod_python, but more importantly it's so stable that if you have trouble with the switch it'll almost always be in your app, not in the WSGI container. This is important: it's not uncommon for apps moving from mod_python to have some bugs when deployed under a WSGI container (especially threading bugs since mod_python is used with prefork and thus doesn't have to worry about threading issues). Once you've verified that your app works under pure WSGI then try out one of the others. I'd recommend avoiding fastcgi -- it's pretty much a dead-end technology and I've rarely seen it be all that stable -- but both gunicorn and uwsgi are great choices. Personally, I prefer gunicorn because of the direct Django integration (`manage.py run_gunicorn` -- could it get any simpler?), but now we're picking nits.
I'm not an I18N expert by any means, but recently I've looked at some vaguely congruent things at work. Based on this limited experience, here's what I think: The prior is probably what you want to aim to use. It's a proper unicode string, and if you pass it on to a database, browser etc. there should be well-defined interactions that allow it to get properly unicode-encoded to the other end's own wide-char/unicode-char set (or at least fail as gracefully as possible). The latter looks like a string that's been encoded as binary by something like the binascii module. It's essentially turning what may once have been a unicode string into a series of bits that no longer contain context like source encoding etc. It also looks like python's u"".encode() method will output a similar byte string (see http://docs.python.org/howto/unicode.html). Since there are multiple character sets/encodings that can fit most languages, it's a good idea to avoid this as a way of passing around information as it is guaranteed to bite you in the ass. BTW, this problem isn't new. I've seen this bite people 15 years ago. The latter will work if both sides have the same idea of what character encoding is being used. However, if you have someone who's japanese, visiting france, and tries to access your app from a french computer, it's pretty likely that instead of japanese text the latter form will have them seeing mangled latin-1 characters - e.g. a bunch of garbage - because the language info/context gets lost. Hopefully you get a better technical explanation from some other redditor, but this is what I've seen. 
I looked some more at the example you posted. I got it to run after changing to counting loop to a smaller number. Counting to a billion in python will take a long time no matter how many processors you are using.
I've already written a function to add vectors but it's not nearly as elegant as yours. Time to replace it.
u'\u30ac\u30a4' means "unicode character 30AC, followed by unicode "30A4" - nothing more than that. It doesn't tell you anything about bytes or how the data happens to be stored. '\xe4\xba\x9c' is a string of bytes - "hex E4, followed by BA, followed by 9C", or [228, 186, 156] You need bytes when you are passing to a system that only understands bytes. But almost everything you interact with in Django understands unicode objects. So internally in Django, you want to pass unicode strings around, so do 'decode' on the 'str' objects - to be specific, do ".decode('utf-8')", assuming they are UTF-8 strings, which they appear to be. Then leave everything in unicode, apart from when you send to somewhere that you know only supports bytestrings. Most things in Django/Python support unicode - including templates (which convert to bytestrings for you) and database (does the right thing for the database collation). Even the console supports unicode, assuming your locale is set correctly - which it is if you are seeing the correct characters when you print both the unicode and bytestring objects. If you are writing to a file, you may want to be careful to explicitly convert to bytstrings i.e. "encode('UTF-8')" You should not do 'encode' on a bytestring (it is already encoded).
 import time class simpleTimer(object): def __init__(self, **kwargs): self.repeat = kwargs.get('repeat') or 1 self.fmt = "{} called {} times: {:.4}s avg. / {:.4}s elapsed" def __call__(self, f): def wrapper(*args, **kwargs): ttot = 0 for i in range(self.repeat): t0 = time.time() f(*args, **kwargs) ttot += time.time() - t0 print(self.fmt.format(f.__name__, self.repeat, ttot/self.repeat, ttot)) return wrapper @simpleTimer(repeat=1000) def wasteMsecs(n): for i in range(n): time.sleep(.001) &gt;&gt;&gt;wasteMsecs(1) wasteMsecs called 1000 times: 0.001072s avg. / 1.072s elapsed This is just a simple example. Put any code you want surrounding the `f(*args, **kwargs)` in that innermost scope. A more elaborate example would use introspection on `f.__code__.co_varnames` to find the argument names and print those paired with `*args` in the output for something like: wasteMsecs(n=1) called 1000 times: 0.001072s avg. / 1.072s elapsed
 $ python3.1 Python 3.1.2 (r312:79147, Dec 20 2010, 17:30:39) [GCC 4.2.1 (Apple Inc. build 5664)] on darwin Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; import sys &gt;&gt;&gt; sys.stdout.write(b'yes') Traceback (most recent call last): File "&lt;console&gt;", line 1, in &lt;module&gt; TypeError: must be str, not bytes
Github
I've found fastcgi to least painful to hook up to nginx and lighttpd, though i've never tried gunicorn
I'm not very knowledgeable of WSGI on nginx. The best WSGI benchmark I've ever seen is at http://nichol.as/benchmark-of-python-web-servers . Whatever you do, if you need to, consider splitting up your static and dynamic content. Find the best server for each of them.
An example is very illuminating: map(f, [1,2,3]) = [f(1), f(2), f(3)] zip([a,b,c], [u,v,w]) = [(a,u), (b,v), (c,w)] They'll save you a lot of time.
Because this subreddit is not about solving someone's homework.
Or without libraries: def add_vectors(u,v): return [x+y for x,y in zip(u,v)]
It's the canonical example of Test Driven Design. It's what we all strive for.
It's possible that this is for a homework assignment, but it's still more educational for everyone to hash this out in the open instead of letting 0m3n just stew on it privately and 0m3n will actually learn a pythonic way to solve this kind of problem rather than just stumbling around blind on it. If 0m3n chooses to use this forum to cheat, then we all still get to learn from it, and s/he won't. That's no harm to us though.
[Gevent](http://www.gevent.org/)?
I'm glad you gave this more complete explanation. Another great aspect of having print as a function is that you can write drop-in replacements which do logging, pretty-printing, filtering, or even conversion to html. If you need persistence, write a `__call__` method on a Print class instantiated as `print`. If you like ASCII animation, you'll probably like this too.
I didn't realize there were potential threading or other issues - I'd assumed behavior would be exactly the same under any of the servers. I'm morally opposed to threads, so I'd likely stay away from anything involving threading unless absolutely necessary. Which options does that rule out? Is mod_wsgi with no threading a reasonable option? Do gunicorn or uwsgi involve threads? (I know I could look all of this up myself, excuse the lazywebbing)
I'm using fastcgi with no issues. wsgi was over my head when I was setting up django for the first time. I should probably try wsgi sometime though.
Exactly, splitting static and dynamic are a big part of the goal.
Github's a good one. And/or, create eggs for the different modules and upload to the Cheese Shop: ttp://pypi.python.org/pypi This means people can type "easy_install _mypackage_" to have your project be downloaded, installed, and updated. To make a package you write a metadata description file, which is awkward but well documented. And that's it. Think about which software licence to use -- it's important. 
Hmm, that is an interesting idea, I had not considered actually creating an egg for it. It is something that people should be able to play with, so that would be a nice way for people just to try it out with a minimum of friction. Likely it would be released with something OpenBSD like.
you could do this I = [[1], [2], [3], [4]] for i in I: i[0] = 0
&gt;Is mod_wsgi with no threading a reasonable option? yes
mmm, yeah, your way is better I think. I am too quick to reach for itertools.
I think pydev has its own thing, but this specific problem is fixed on pyflakes trunk, yay.
Write up some good documentation before you release. Sphinx makes it pretty easy and is a popular choice among Python projects.
Apology accepted.
Thanks I will check that out
It is not at all implementation specific. However it was added with Python 3.x
Here's a nice review of some different options: [Benchmark of Python Web Servers](http://nichol.as/benchmark-of-python-web-servers) Like all benchmarks, it should be taken with a grain of salt. I've been using [Gunicorn](http://gunicorn.org/) due to its ease of use. You can set a number of worker process and use signals to ratchet up and down, or reload completely without stopping the server. Nginx will save you quite a bit of memory over Apache and is good for serving static content too. 
I see your point. I'm still downvoting stuff like this because I'd like to have this subreddit for "news about the dynamic, interpreted, interactive, object-oriented, extensible programming language Python" - not how to learn to do basic things.
I've been quite happy with fapws3, i've deployed it on a production site for an iphone app, and i'm using it to develop the web UI (using django running with fapws as the server component) for plugapps linux too. Very fast, very easy to use. http://www.fapws.org/
astatine's example was a joke.
Fair enough. I guess we need a new sub-reddit for Python: /r/PythonRTFMFirstPleaseNoN00bsAllowedInDaHouse 
I would use Twisted. It has POP and IMAP and inotify support. And I like Twisted. But the stuff in the standard library will work too.
Its mutual! :)
Well then I can just hope that the course I enlisted for is not that kind of course. Im a free person, I have to have free software. 
Currently I am a software engineer and I am looking into learning GIS so I can make my own map-based software, without using google maps or bing, just free software tools. Lets say you have alot of data with adresses and some have coordinates, and these are connected and you have also what kind of connection it is, speed and other attributes. I would like to put this on a map.
I tend to use "unused" instead of "_", because of the gettext issue. (pyflakes whines about unused variables, but "unused" is whitelisted.)
No, being Pythonic isn't about having maximum syntactic sugar. Being Pythonic is about having one clear way to do it.
In all seriousness wouldn't there be a market for /r/learnpython? I'll even help out when I have the time.
in the context of PEP8 variable-width fonts are irrelevant
Honestly, I'd recommend publishing a source distribution to the Cheese Shop instead of "eggs" which IMHO are a pain. You'll want to make sure you've got a basic setup.py set up and you should be able (if you're using setuptools or distribute) to `python setup.py register` and `python setup.py sdist upload` to push it up to the Cheese Shop
nginx + uwsgi is the setup I'm using for all [my websites](http://www.shodanhq.com) and it's held up great so far. Managing nginx is a lot easier than Apache in my opinion, and setting up uWSGI is not only easy but offers great performance as well. And it integrates tightly w/ nginx: http://wiki.nginx.org/HttpUwsgiModule
NLTK
Based on my experience these are the reason I use a specific server: * Performance and low footprint [fawps3](https://github.com/william-os4y/fapws3) * Largest user base mod_wsgi (guessing) * Generic tool [spawning](http://pypi.python.org/pypi/Spawning/) [repo](https://github.com/rtyler/Spawning/) specifically has night reload option for development * Educational and trendy [tornado](http://www.tornadoweb.org/) I admit I am attracted to trendy Good luck 
I've only recently fallen in love with Python...this might be the perfect honeymoon ;) Now to see if I can get school to pay for registration + a room!
* Put the code on Github, Bitbucket, or Google Code * Make a release on PyPI * Write good documentation, publish it online using Sphinx * Do a screencast and put it on YouTube, Vimeo, etc.; link or embed it from your docs * If it's a web app, put a working demo site online * Send an announcement email to relevant mailing lists, e.g. [python-announce](http://mail.python.org/mailman/listinfo/python-announce-list) * If there is enough interest, create your own mailing list for your project (e.g. using Google Groups)
Thanks for the pointer. Looks like a very active community driven project, with google groups, lots of documentation (both internal and third party), some good getting started tutorials, and feature/bug tracking and source management through code.google. I can only hope that my project would grow to be that large/useful.
Thanks for the comment. Just to clarify do you mean to say that "eggs" are a pain to use or a pain to create?
uwsgi seem to give you features and speed. http://nichol.as/benchmark-of-python-web-servers I saw microseconds of overhead on a small rackspace cloud node, where gunicorn would add a couple milliseconds of overhead.
nginx + [gevent][]. [gevent]: http://www.gevent.org/
Early-bird registration rates only last until January 17th. Start working on it :) It's still very affordable at the regular rates, but everyone likes a discount.
Funny you should be asking this now. I'm in the process of doing the same thing. In my case, I've chosen to go the setup.py route. The biggest thing I've learned so far is that you need to take the time to refactor your code properly, to conform it to the way people expect python projects to be organized, and the way the packaging tools expect it. Skimp there at your great peril. Oh, and they aren't kidding about the importance of getting the docs right. To be even more specific though, I have found that many projects get the detail docs right, but never manage to convey the philosophy of the overall design. If you want people to contribute to the code, give them a leg up on learning why things are the way they are. 
Your point about the high level documentation is a great point, I have run across this problem on the user side many times. With respect to the "way that people expect python projects to be organized", can you suggest any references?
Thanks!
If you're using Python 2.x, you should say `xrange` instead of `range`. Not a big deal though.
Sounds like you need to read [The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)](http://www.joelonsoftware.com/articles/Unicode.html). This applies not just to Python but any programming language you'll use. Do it, it's a short easy read and it will solve all your future Unicode headaches.
What everyone else has said, plus print() will also do encoding according to what stdout will be going to. i.e. if your terminal is set to only show ascii, it will perform encoding on your unicode output to make it ascii compatible. On that same platform, if you're output is a pipe to a file or another program, it will output the full unicode string.
I found the intro docs for distutils to be very clear and easy to follow, although it may depend on how badly your existing code deviates from the standard. Fortunately, I found that the recommended style was very much in line with what I've come to expect python project layouts to look like, so when I said 'people' I really meant 'the people of whom I myself am a representative sample' :-)
Either nginx+gunicorn or nginx+uwsgi over a socket is great for a single server. Just remember to use the uwsgi protocol for uwsgi as it's http server isn't meant for production use. May want to use something like supervisord to manage the backend process. I know gunicorn recently gained support for being managed via upstart (Ubuntu's rc-script replacement). I can't imagine an upstart conf for uwsgi would be any more difficult to write. Gunicorn is probably the simplest wsgi server to setup, so probably start there.
uWSGI is built into Nginx core now. It's integration is seamless and has hooks to do anything you need with the server. Performance is great and administrating it is painless.
Fixed. Thanks for the heads-up.
Yep, same for me.
fcgi. I use it with lighttpd. To use python with fcgi you have to use WSGI with flup. fcgi is just a common interface. Not sure about nginx, but with lighttpd it has been painless for me.
Thanks, I'll read it.
In analogy with Linux, it's useful for this kind of work to have a coherent distribution of libraries around Python (Numpy, Scipy,matplotlib etc.), and I've found the [Enthought Python Distribution](http://www.enthought.com/products/epd.php) to be the best; you can get free Academic versions, pay for support if you need it. A propos C, if you need a bit of speed, look up the Python ctypes module, and how to use Numpy with it. You can interface into C with very little code. 
I dont have the money to attend PyCon..will wait eagerly for the blip.tv versions..i watched stuart william's tuts last time..they were awesome..got me hooked to python..
The threading issues are mod_ (wsgi?) container issues not wsgi issues. Leave mod_wsgi out of daemon mode and you'll be fine. If you aren't attached to apache, then drop it altogether. Any of the co-routine based servers are fine. You should probably benchmark under a number of servers and see what fits ... what you're comfortable with installing/using. IMO ... eventlet or gevent. I wouldn't call mod_wsgi stable or fast, but it works better than mod_python.
mod_wsgi for Apache is very good. mod_wsgi for nginx is not. I think you should leave Apache+mod_wsgi as an upstream backend for nginx...
that has been summarized here http://www.markus-gattol.name/ws/python.html#for_loop ... namely not using _ but rather i or each
in short: The guys behind Pylons (web framework), repoze.bfg, and Turbogears, join together in a group they called "The Pylons Project". their (future) main product is: Pyramid. there is a possibility that The Pylons Project will make high level framework based on pyramid later (as an aswer to django), but web2py is not it. it's a completely different project. should you bother learning Pylons? I don't think so...
first of all, web2py is not pylons and has nothing to do with it - its a different project. you didnt seem to bother to read this: http://docs.pylonshq.com/pyramid/dev/narr/introduction.html#what-is-the-pylons-project it should clarify some of your concerns. as for your django question: for many of us django is not the tool we want to use for various reasons, then i would risk to say that pylons project is the best current alternative to it. Sites like reddit are powered by old pylons for example, new pyramid will kick some serious ass and is a breeze to work with. You are asking wrong questions, its not about what stack will become dominant in python world, django or pyramid/pylons are going to stay for quite some time. You should use the tool that fits you best and your project and base your decision on that.
I found this tutorial really helpful: http://infinitemonkeycorps.net/docs/pph/
Is cherrypy completely out of scope, yet?
Imagine an XML file: unicode is like parsing the file into a data tree and str is like simply reading the file with no parsing. That is, unicode has *meaning* to a program internally, it tells what actual graphemes the text is actually made up of. Bytestrings (str in Python 2) are more like a file format: an output format, a representation of this information the unicode version holds, into sequences of bytes: an *encoding*.
1. Learn Pylons if you're going to maintain existing Pylons apps. 2. Learn Pyramid if you want to stick with the Pylons community in the future and you like the ideas behind Pyramid. 3. Without qualification I'll say that web2py seems like the Rails of Python: wondrous magic that'll have you dance with unicorns the first few days until you actually need to do something interesting. 4. There is also the [Werkzeug](http://werkzeug.pocoo.org/) library and the frameworks based on it, such as [Flask](http://flask.pocoo.org/) and [tipfy](http://www.tipfy.org/).
Could it be you're running an older version of Python than the docs you're looking at? Your HTML docs are for Python version 2.6.6, what version does your Python shell report? (The very first line after launching) 
I think it is a 2.6 documentation bug, since [what's new in python 2.6](http://docs.python.org/whatsnew/2.6.html) mentions it, despite the 2.6 docstrings not mentioning it. 
Oh, the [Werkzeug docs](http://werkzeug.pocoo.org/docs/unicode/) has a nice chapter on unicode BTW.
As far as I know, CherryPy plays on its own and was not approached to be part of any of those meta-projects. 
 $ python2 Python 2.7.1 (r271:86832, Dec 20 2010, 11:54:29) [GCC 4.5.1 20101125 (prerelease)] on linux2 Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; import sys &gt;&gt;&gt; sys.stdout.write("Hello, Reddit") Hello, Reddit&gt;&gt;&gt; No, it isn't just for Python 3. 
Seems I'm running 2.6.5, but that one also mentions the `repeat` keyword argument in its online documentation: http://docs.python.org/release/2.6.5/library/itertools.html#itertools.product Maybe somebody running Python 2.7 can confirm what the `itertools.product` docstring looks like? &gt;&gt;&gt; import itertools &gt;&gt;&gt; print itertools.product.__doc__ ...
fcgi with nginx is also painless and very simple to setup.
It's fixed in 2.7. product(*iterables) --&gt; product object Cartesian product of input iterables. Equivalent to nested for-loops. For example, product(A, B) returns the same as: ((x,y) for x in A for y in B). The leftmost iterators are in the outermost for-loop, so the output tuples cycle in a manner similar to an odometer (with the rightmost element changing on every iteration). To compute the product of an iterable with itself, specify the number of repetitions with the optional repeat keyword argument. For example, product(A, repeat=4) means the same as product(A, A, A, A). product('ab', range(3)) --&gt; ('a',0) ('a',1) ('a',2) ('b',0) ('b',1) ('b',2) product((0,1), (0,1), (0,1)) --&gt; (0,0,0) (0,0,1) (0,1,0) (0,1,1) (1,0,0) ...
what is the difference?
thanks!
That's a feature, not a bu- Oh hey, just looked up the rules to Reversi on wikipedia. I didn't realize that if the player couldn't go then their turn is passed over, as opposed to ending the game. Whoopsi.
2.6 is in security mode so this won't be fixed there. As stated above, it's fixed in 2.7.
xrange returns an iterator. xrange is helpful if you're not necessarily going to be looping through all the values (for example, you want to break as soon as you find a certain value). [Python docs](http://docs.python.org/library/functions.html#xrange)
It already exists, but the last post was 18 days ago so maybe not. Maybe people just don't know about it though. I sure didn't. edit: typo
web2py is not based on any of the other frameworks. It was developed from scratch 3 years ago. One of the reasons is that we promise always backward compatibility and we do not want to rely on any dependency. Determining who is dominant is complicated. For some frameworks identified uniquely by their names (like web2py, Turbogears, Repoze) you can use [google trends](http://www.google.com/trends?q=web2py,+Turbogears,+Repoze,+web.py&amp;ctab=0&amp;geo=all&amp;date=ytd&amp;sort=0) but for others (Django, Pylons, Pyramid, Flask), google trends cannot disambiguate and returns lots of false positives. web2py is relatively popular: http://web2py.com/poweredby Django is more popular but has been out there 4-5 years longer then web2py. Whatever you choose you make a good choice. They all written by good and competent people. I would not for popularity. Make sure you understad the strengths and differences anyhow. For web2py the priorities are: ease of use, security, backward compatibility. One of the distinctive features of web2py is the presence of a web based IDE for development, testing, debugging, deployment, and distribution of apps. None of the other frameworks provides that. Other features are the built-in ticketing system, the web based translation interface and the zero-configuration/zero-installation requirement. Web2py aims to be more of the python answer to heroku than a competitor of other python web frameworks. 
Easy to create, but depending on the taste of the user, a pain to manage.
Are web2py and Pylons/Pyramid syntactically and functionally similar? 
I can't speak to functionality, but they are not syntactically similar. Primarily in that web2py ignores common mechanisms for writing code, such as the use of the `import` statement.
Beginner stuff seems to be downvoted or at least not upvoted too much 'round these parst...
The similarities are more than the differences but there are many differences. For example web2py has a database abstraction layer that works on 10 relational databases, Google App Engine and couchdb (last one experimental). Pylons and Pyramid can run Google App Engine but you have to use the native GAE APIs. The mechanism for form processing is different. web2py has a web based IDE. Pylons and Pyramids do not. web2py incudes web services API (for example has built in API to create SOAP services, JSONRPC, XMLRPC, generate PDF, RTF, CSV, RSS). You can do these things with Pylons/Pyramid but I believe you need third party libraries. web2py has no dependencies. 
Yes. web2py does a lot of "magic" in a good sense. It does more things for you than other framework do, while being smaller than most of them (as lines of code). Magic means we do not follow python's "explicit is better can implicit". Instead we follow: "do not repeat yourself" and "everything should have a default" (this like Rails). Every default can be overwritten and customized. Example: web2py generates forms for you from database models (Django does too) and also form processing validation/logic. If you do not like the generated forms there are many way to customize them (formstyle, widgets, custom forms, helpers and low level html). One misconception is that the web based IDE is "magic". That is not true. It is just an app. web2py has no metadata and it is filesystem based. If you do not like the web based ide, it has a shell interface like Django Pylons, Pyramid, etc. I edit my files with emacs. All web2y files are pure python files or templates. In fact of those mentioned web2py is the only one that allows pure full python in templates.
web2py does not ignore import statements. web2py does not require import statements for web2py keywords because we follow "do not repeat yourself". import works normally for all third party modules.
Example of full web2py program (on top of scaffolding app). Perhaps others can write the same in Pyramid to give you an idea of the differences: #in model db.py append db.define_table('person',Field('name',notnull=True),Field('address')) #in controllers/default.py add @auth.requires_login() def index(): return dict(form=crud.create(db.person), rows=db(db.person).select()) # in views/default/index.html (optional works without) {{extend 'layout.html'}} &lt;h1&gt;Hello World&lt;/h1&gt; {{=form}} {{=rows}}
Well, I know if I were just learning Python, I wouldn't look for something complicated like /r/learnpython or try to guess where it would be. Even if I were to find it, I wouldn't have any confidence that my time would be well spent there, because it's bound to have far fewer readers. So, I would come here. I'm sure I'm not alone on that line of thinking.
I really wonder what flask is missing compared to Pylons? I have to gag when I see this Java-style code the repoze projects are famous for. So I'm not terribly inclined to switch to Pyramid. Is somewhere a feature overview who has what and what not?
Can we ask what your research is about ?
I know sys.stdout.write() is there, I was asking if sys.stdout.buffer existed in pre-py3k
mdipierro has already pointed out that web2py does in fact use import. Are there any other "common mechanisms" web2py ignores?
&gt;Without qualification I'll say that web2py seems like the Rails of Python: wondrous magic that'll have you dance with unicorns the first few days until you actually need to do something interesting. Can you share some specific examples of "interesting" things that are difficult in web2py (after the unicorn dancing phase) and explain how those things would be easier to handle using Pyramid, Werkzeug/Flask, etc.? EDIT: Hmm, no reply.
The most overlooked things are: 1. A paragraph explaining what it does 2. An example situation where you would use it and why it's the right solution 3. Example code someone can download and run using step by step instructions... it's very difficult to get things running, but once you get *something* running it's always much easier from there on to tweak it and test things out with it because you have a feel for what it's *supposed* to do. My $0.02. 
Ah, my bad.
A green threading server is a bad idea unless you're very sure your code is monkey-patchable to be non blocking. If you do any database access with standard libraries (except for the very latest psycopg2), then your db requests won't yield back to the reactor. Eventlet and gevent can be very powerful, but you must be very more careful than with a traditional thread or process based wsgi server. 
It's really quick and easy to get started using web2py (no installation, no configuration, no dependencies, built-in IDE, easy to learn), so if you're interested in it, I'd recommend [downloading](http://www.web2py.com/examples/default/download) it and trying it out. The [book](http://www.web2py.com/book) is excellent. And if you have any questions, there's a friendly, active, and growing [community](https://groups.google.com/forum/?fromgroups#!forum/web2py) that will give you lots of help. There are also a number of [professional web2py developers](http://www.experts4solutions.com) available for hire.
Definitely not for homework. I am forced to learn VB.Net way of programming and now, during the holidays I thought of learning Python. It just seems more simplistic and fun to learn! I got the example from [this e-book](http://openbookproject.net/thinkcs/python/english2e/) . Although exercises are based on the chapter I wasn't smart enough to figure the answer on my own.
I think you're underestimating the importance of that issue, though. Python, the language, is designed on the principle that code is *read* more often than it's *written*. Thus, Python has a few constructs and bits of syntax which do require more characters to be typed by the programmer, but does this for a very good reason. Programmers are encouraged to be explicit about what they're doing, even if it means "repeating yourself" a bit from time to time, or writing things slightly less cleverly than possible. As a result Python code is, on the whole, pretty darned readable. Except for Python code written using web2py, which feels like it'd be much more at home in a language which places more emphasis on typing as few characters as possible (Ruby or Perl, perhaps, or even APL for those who possess the appropriate keyboards).
Sorry you feel negatively about my post arnar. To be fair you could have just ignored this and moved on. It may seem very basic to you, but what apierre_cardoso has shown me taught me new things, others may have freshened up their memory as well. 
uWSGI protocol handler is built into Nginx, not the uWSGI server itself. You will have to manage the server startup, restarting, monitoring by yourself (using e.g. upstart and supervisord) unlike mod_wsgi solution.
I'm sure this won't be a popular opinion, but I find there a lot of parallels between the design ideas in Basic/VB vs. Python, so learning one definitely goes hand in hand with the other. I just wish Python had optional static typing (yes, I know it has strong type enforcement - that's a different discussion) so mainstream IT would adopt a non-brackety language besides VB.
Having played around with Pyramid, I'd have to agree with you. Flask is really what Pylons 2.0 should have been - lightweight and practical, but with better documentation and extensions for additional functionality that doesn't belong in the core framework. I've generally found Pyramid requires a lot of unnecessary conceptual overhead (ZCML vs Python configuration; traversal vs routes etc), a lot more boilerplate and is missing things that modern frameworks take for granted, like form validation. These might be fixed in time but I really couldn't find anything that compelling about Pyramid. 
Actually, my question was not about "that issue" (i.e., using the import statement). kingkilr said web2py "ignores common mechanisms for writing code" -- note the plural "mechanisms". My question was, aside from the import issue, what else is ignored? Nevertheless, I believe you may be _overestimating_ the importance of the import issue with regard to explicitness and code readability in web2py. In web2py code, the only things you don't have to explicitly import are your models and a relatively small number of global objects defined in the [API](http://web2py.com/book/default/chapter/04#API). In fact, most of the global keywords are simply HTML helpers (with the same names as the corresponding HTML tags) and validators. The web2py keywords are few in number and well documented, so the fact that they are not explicitly imported should not lead to any confusion or mystery. But if you find it helps, I suppose you could always add some commented-out import statements at the top of your files to remind yourself what the API includes. &gt;As a result Python code is, on the whole, pretty darned readable. Except for Python code written using web2py... This is not my experience. Perhaps some examples would help.
When I spend time in class doing **exactly** what everyone else is and getting explanation either after the piece of code is written or as we go along I get less and less excited about it all. Most of the class see programming as a chore by now, instead of something interesting, fun or challenging! In college I move icons, change properties and create drag'n'drop games (icons don't even move when dragged). At home I open Gedit and try to solve exercises then move on to the next chapter! - no compilers, no downloading, spend as much time as I want practising with different variables.
Flask is a different mindset -- it aims to be a 'microframework', so it's fairly lightweight and doesn't have a ton of stuff built in. It's easy to mix and match different external libs to get the functionality you need. That said, it is fairly full featured and can get you quite far depending on your needs. From flask's docs: &gt;There is no database abstraction layer, no form validation or anything else where different libraries already exist that can handle that. However Flask knows the concept of extensions that can add this functionality into your application as if it was implemented in Flask itself. Pyramid's design goals are different. It feels more 'enterprise' to me. They've written up a nice document about their [design decisions](http://docs.pylonshq.com/pyramid/dev/designdefense.html). 
I'm more interested in: What will I miss from Pylons, if I switch to Flask? Pylons is supposed to be a near-microframework too, so I have still hope to be not forced to use CamelCase et al.
edited my post above to add more info. I'd suggest taking a quick read through both flask and pyramid's intro tutorials. They'll give you a feel for some of the differences. 
I've already seen Pyramid code and I simply disliked the feeling of it. :( Anyhow, Pylons ain't anything different but a core + some extensions, so that's my hope for Flask. Any assesments how alive the project it? Don't want to switch to a dead project, I'm still suffering from Pylons' untimely death. ;)
It's under active development: https://github.com/mitsuhiko/flask Of course that's no guarantee - I would have thought Pylons was pretty safe given the number of high profile sites using it (Reddit, Quora) but I guess the developers just got bored with the project.
Just like any other daemon based wsgi or fcgi implementation, why is this a problem? 
nginx + uwsgi is great for a single server as you said. It's also the only possible way I could manage 30 servers and sleep at night.
&gt; Nevertheless, I believe you may be overestimating the importance of the import issue [...] No, really, he's not. If anything, he's understating it. Let's take a look at Massimo's [example in this very thread](http://www.reddit.com/r/Python/comments/ex54j/seeking_clarification_on_pylonsturbogearspyramid/c1bncdp). In just a few lines of code, Massimo has demonstrated why web2py is *seriously harmful* to the rest of the Python community. This are big words, but I'm completely serious: web2py *is hurting Python*. Let me try to explain. I know that in your mind skipping imports is about "not repeating yourself". But look guys: **every single other** Python program ever written uses imports. By not including them you've basically made sure that learning web2py is *different* from learning Python. When someone learns web2py *they aren't learning Python*! This means that if -- when -- they want to branch out into the rest of the Python community, they're going to have a distorted view of how Python works, and they'll run into all sorts of mistakes. They'll get the impression that Python is broken in a fundamental manner. Let me give you a single concrete example. In the example linked above, there's this: return dict(form=crud.create(db.person), rows=db(db.person).select()) There's no imports, so in that line we've got three globally-namespaced names: `dict`, `crud`, and `db`. Someone new to Python will *completely miss* that `dict` is a Python built-in, but `crud` and `db` are web2py globals automatically injected into the namespace. They'll have no way of knowing the difference between these three names, and will have no clues as to where to look for documentation for each. This technical choice drives a wedge between the web2py community and the Python community at large. It means that web2py programmers and Python programmers *cannot* be completely on the same page. It means that experienced Python programmers will always look down on web2py. It means that new web2py developers will have a hard time integrating into the rest of the community. It means that there'll be little to no crossover between web2py users and Python users at large. Please trust me that this is an observation made from hard learning -- it's a lesson learned from a similar choice we made at first in Django! It made Django hard to learn for people who already knew Python, and it made Python hard for people who started with Django. It drove a wedge between us and the rest of the community that we're *still* trying to bridge years after correcting the original technical mistake. Until this mistake is corrected, web2py won't really be a Python framework. It'll be a web framework with a built-in language that looks sorta like Python. Edit: I know that this may come across as an attack on web2py, but I hope I've got enough credibility in the Python community for y'all to know that's not at all the point. I've long since given up caring about Django's relative popularity, and I really don't care one whit about which framework someone choose to use. But I *do* care, intensely, about the health and stability of the Python community at large. I want Python to be the last language I have to become an expert in, and so anything that fragments and fractures the community makes me angry and ill. There's a fantastic cross-pollination that can happen between Django, TurboGears, Pylons, Pyramid, Flask, etc. as programmers are free to float around between the framework that they find best for this one task, but web2py isn't and can't be part of that culture. My intent in this harsh criticism is to spur the web2py developers to correct this mistake and join the rest of us.
The real challenge is getting our techs to use python. Poeple get very comfortable with what they are doing.
The way we have it set up, nginx is the front end (listening to all requests on 80), and serves the static media for the site (based on URLs), and passes the connections back to Apache if the url is not in the list of static media directories. Then Apache/mod_wsgi handle serving dynamic content (with Django).
&gt; Being Pythonic is about having one clear way to do it. That's exactly what I mean, though. It's not clear that you should use a throwaway variable just to repeat an action several times. "range" makes perfect sense when you use each number of the range, but when you don't, it seems misplaced. The "one clear way", imho, should be something like doStuff() repeated 5 or do 5 times: doStuff() or something.
Ditto.
No need to file a bug report it's already filed as [issue 5171](http://bugs.python.org/issue5171) - was fixed by Raymond Hettinger back in Feb 2009.
http://www.reddit.com/r/Python/comments/epcxj/the_bottle_web_microframework/c19xcle
It used to diverge significantly, because it was based on the extant Google C++ style guide. 2-space indents, camelCase() methods, etc. More recently, it's been changed to conform to pep-8.
They did not get bored, they decided that they've painted themselves into a corner, design-wise. Did you read the [FAQ](http://docs.pylonshq.com/faq/pylonsproject.html#why-not-just-continue-developing-the-pylons-1-0-code-base)?
&gt; Any assesments how alive the project it? There are no plans to chase development anytime soon. We're however currently focusing a bit more on pimping the underlying libraries (Werkzeug and Jinja2) in terms of documentation and API. Flask itself is right now in the polishing phase. I like the featureset and my only real gripes with the core API is the handling of static files and modules, and I haven't found a completely satisfying solution for that yet which is why I haven't changed it so far. But no matter where it's heading, upgrading to newer versions will be straightforward and development will stay active.
Excellent! I was waiting for the next Python web framework post. Of the frameworks you suggested, do any of them support Python v3 yet? I did some searching a few days ago and the only framework I could find was Bottle.
Your example is flawed and shows you are talking about something you do not know. The example I posted starts with "on top of scaffolding app ... add". In fact the scaffolding db.py includes: from gluon.tools import Crud curd=Crud(....) So it Crud is indeed imported and crud is defined in the user space. In Django do you import templates or execute them? You execute them. Why do you do it for templates and not for models and controllers? It was a design decision. You choose not to use Python syntax in templates but not in models/controllers. In web2py we choose to use Python syntax in models/controller AND embedded in templates but we still execute them because we think it is cleaner. In Django every controller has to import "request", as is it would work without it. It does not. If something is required, it should not be left to the developer (do not repeat yourself). Reminds me of COBOL. You make the mistake of thinking of a controller (which you call a view, you do MTV instead of MVC) as a python module. It is not a module, although it uses python syntax. Like a template is not a module. Web2py is written in python and programmable in python. It can use any other python module out there (including jinja, mako, sqlalchemy, etc.) although it does not need to. web2py is really good for the python community because it is bringing a lot of users to python from outside the community while django, pylons, etc ate fishing in the same small pool. I am sorry you do not see this. We should all try fish in a bigger pool than existing python programmers and not fight against each other simply because we made different design decisions. EDIT: Yes, your comes out as an attack on web2py. But most people will be able to recognize that you are an interested party (as one of the creators of Django) and not a neutral party. For the record, while I prefer web2py (since I am an interested party too), I do recognize Django as an excellent framework from which web2py has learned a lot. I also acknowledge you are an expert on this topic but I still disagree with you. I also consider myself an expert although not because of web2py, but because of my job.
sweet thanks
&gt; In Django do you import templates or execute them? You execute them. Looking up templates from the template lookup is an explicit step. In Jinja2/Mako and many more it even starts with you defining an enviornment/lookup beforehand explicitly. You get hold of a template object then and do with it what you want. It's an explicit operation all the way down. &gt; In Django every controller has to import "request", as is it would work without it. Wrong. The request is not automagically available in Django, it's passed to the view. &gt; You make the mistake of thinking of a controller (which you call a view, you do MTV instead of MVC) as a python module. I think you make the mistake in declaring it as being something else. It shouldn't be, because with that you are removing a bunch of important features of Python. Starting with the fact that the lifetime of objects in such a space is request specific and not global like in any other Python system. What's worse is that you can recreate classes on the fly there and easily leak memory unless you are very careful. All that is not obvious to the developer working with web2py.
Perhaps it was changed once Guido came on board?
Sure I did, I was being facetious. However I still believe the better solution would have been a complete rewrite than merging with repoze with all its Zope baggage. 
&gt; my only real gripes with the core API is the handling of static files and modules What specific gripes are these ?
Pyramid introduces a bit more complexity than Pylons 1.0 or Flask. However, it's telling that the author of Pylons 1.0 independently came to the conclusion that some of this complexity was necessary, because there are real-world use cases that Pylons was having a hard time supporting. Pyramid tries to strike a balance between simplicity, flexibility, performance and testability, and (while there's of course plenty of room for improvement) there are lots of folks who think that it does a good job. One nice thing about Pyramid is that if you don't _need_ the extra flexibility you don't have to deal with it; in simple cases Pyramid's apps use patterns that are very similar to Pylons 1.0, Flask, etc. It's a known issue that the docs don't really reflect this; the flexibility and the more advanced concepts are too up front, there isn't a "here's what you need to know to get started. And.... GO!" feeling. But if you do ever need to support a use case that the simplest patterns don't handle well, you have options. As for form validation and/or generation, Pyramid explicitly has no opinion. FormEncode, Formish, deform, ToscaWidgets, WTForms, and any other form framework all work equally well with Pyramid. Pyramid also has no opinion about what persistence engine you use. Same for your templating engine. This means Pyramid isn't opinionated, not that it isn't modern.
Right now a folder called static is exposed at a specific location and modules can also have their own static folder. That breaks somewhat if you have more than one module at the same URL prefix with different static files, and more importantly it also makes it hard to move static resources to a CDN.
What if I want to name `crud` (or any of these other magic items) something different? In Django I'd do something like this: from django.db import models as django_models class FashionModel(django_models.Model): name = ... agency = ... height = ... class FigureModel(django_models.Model): ... def models(): return FashionModel.objects.all() + FigureModel.objects.all() I can use the name `models` for the handy function without worrying about colliding with Django's `models` because Django uses Python's `import` for importing modules. I bet this magic importing also breaks ctags, which makes it harder to work with in Vim and other editors. It probably breaks pylint/pyflakes too. ... and every other tool that expects Python modules to behave like *Python modules*.
Are you implying there is a memory leak in web2py? You know I could make the same unsubstantiated claim about any other framework and even prove it but taking some email out of context? Yet I do not do it. 
I should probably mention. Nemo is built on top of Mako, so there's a tiny speed bump for Nemo processing then its as fast as Mako once the templates are compiled and cached. Mako is faster than Django templates--at least by a factor of 4--and in the neighborhood of speed with Cheetah. Only Spitfire templates are faster. This is important for any app that is CPU bound due to rendering speed.
crud, as I said, is a variable defined by the user: from gluon.tools import Crud crud=Crud(...) so you can call it anyway you like. In fact web2py supports multiple database connections (which you can choose to call qui, quo, qua) and you would create multiple crud objects to handle them (which you could call curd_qui, crud_quo, crud_qua). There are keywords that cannot be renamed. Python defined if, else, try, in, etc. Web2py adds DAL, Field, request, response, session, cache, T, _validators_ and _helpers_. Actually all of the web2py keywords can be redefined if you need, but we think that renaming then would make the code less readable so we discourage it.
Okay thank you, I will give Flask a shot before doing any further investigations concerning Pyramid. :) I don't want to sound superficial, but Python is a beautiful language. I don't want to spoil my pleasure with Zopeities.
&gt; Are you implying there is a memory leak in web2py? I said you create classes in a magically imported place it's easy to leak memory, I did not say that web2py leaks memory. Please read my comment better next time. Why is that the case? A couple of systems are using metaclasses and have registries attached. If you execfile the module each request you will create a new heap type each request and if that happens to use a metaclass with a registry it will pile up classes after classes in that registry. Modules in Python are known to be problematic on shutdown because classes are often seen as eternal objects. On top of that classes have a `__module__` attached which in your case does not return anything useful. There are enough APIs that might be terribly confused by this (I know copy and pickle are). So you are actively breaking Python protocols there and I don't think it's a good idea. Unless I miss something, the documentation also does not tell the user which protocols are broken as part of web2py's execfile() support.
I agree with you about the docs - there's too much upfront that people don't need (ZCML) and not enough of what they do - for example form validation (if Pyramid has no opinion on the matter, that's fine, but that's something that can be pointed out early on with some examples/links). However, I appreciate at this stage of the game the documentation is not the focus. One other thing that could be improved are the sample projects - for example, the [Shootout app](https://github.com/Pylons/shootout). It's very verbose and not very DRY and doesn't really give a good impression of what Pyramid has to offer. For example, the code for doing a redirect: response.status = '301 Moved Permanently' response.headers['Location'] = url return response In Flask, Django and other frameworks you have a simple redirect() function. I'm sure Pyramid has one too, but not using it here makes Pyramid look unnecessarily verbose and gives a bad impression. Another example in the same app - there doesn't seem to be a way to add common items in the context, so you have the same toolbar_view() call repeated across a number of views. Again, I'm sure there's an easy way to do this (in Django or Flask for example you would use a context processor) but this isn't illustrated anywhere. TBH, with as bad an example as this you'd be as well not to include it in the documentation at all.
"However, I appreciate at this stage of the game the documentation is not the focus." Actually, at this stage of the game documentation is very much the focus. And by "documentation" I also mean the sample apps, the paster templates, etc. I'm pretty confident that things will improve steadily, especially for beginners, over the next few months.
nginx + uwsgi. I give nginx its own server and run a small pool of Flask-based WSGI application instances in another 2 servers. I've been using this base setup on all my projects.
Nothing is broken and web2py has no known memory leaks. The documentation does not need to say anything more about this.
i use a module called emailer what haves support for embededd images on content email
Having decorators is already more than enough sugary nonsense to handle, thank you very much. But if I want to code in a language that's not clear about what is happening with what in which way I'll switch to Ruby.
Massimo, I'm not going to respond directly because I don't want to fight about this. I consider you a friend, and I hope you feel the same way about me. You have something of a persecution complex, and you're welcome to read into my words whatever hostility you like. I assure you it's in your head, not mine. Reasonable people can disagree about technical choices, and I have no interest in claiming that the choices you've made in web2py are "right" or "wrong." They're not the choices I'd make, but that doesn't matter. You need to understand, however, that the technical and social choices you're making with web2py set it aside and separate from the rest of the Python community. This makes me sad. Our community already suffers from fracture -- historically both Zope and Django have been guilty of creating this fracture. I want developers to be able to float between different Python web frameworks -- and to write their own new ones -- without impedance. I'm doing everything that I can to atone for the sins Django committed in the past, and I hope you'll one day choose to join the rest of us and be part of the greater Python community. It's an awesome place. Until then, I guess I'll no longer think of web2py as a Python tool, but as a tool written in its own language. This might not be a bad choice -- the [Cappuccino framework](http://cappuccino.org/) invented a new language language, Objective-J, and it seems to have worked out well from them. Best of luck. 
Here is one reference I keep seeing on #python. http://jcalderone.livejournal.com/39794.html
Have you actually tried Pyramid? Here's hello world: from pyramid.config import Configurator from pyramid.response import Response from paste.httpserver import serve def hello_world(request): return Response('Hello world!') if __name__ == '__main__': config = Configurator() config.add_view(hello_world) app = config.make_wsgi_app() serve(app, host='0.0.0.0') If you have looked at it, and truly have given it a shot, and still don't like it, then fine. But please criticize it on its *real* flaws, not imagined ones. Here's a quick slideshow demonstrating some Pyramid features: http://plope.com/static/pyrpres/slides.html
seriously? microframework == no CamelCase? I think you've got some concepts mixed up.
You don't sound superficial, you just sound wrong.
&gt; I don't want to sound superficial, but Python is a beautiful language. And Pyramid is a beautiful framework. There are reasons for why it looks like it does and that's not a bad thing. I wouldn't say that any of these are "more beautiful". But they have different ideas and principles.
"All its Zope baggage" is: - a dependency on "zope.component", which is an implementation detail. You never see or use its API. - optional ZCML. You needn't use ZMCL at all. In fact, the docs put all ZCML into an appendix chapter. So "all its Zope baggage" is exactly zero, as far as I can tell.
Ah I see. You're not criticizing Pyramid, you're criticizing shootout. Fair enough.
Sweet! Well, case closed, I suppose.
Dear Jacob, I do consider you a friend and I have great respect for you. As I said over and over web2py would not have come to be without me learning from Django, an excellent system. Over the last year we have worked hard to make web2py more modular. Most of the modules including the database abstraction layer, the template language are now individual modules that have no dependencies and can be used with other web frameworks. Yet web2py remains a full stack framework (like Django is) and there will always be code that can only work as part of web2py and not without it. The exec vs import is a major design decision. It is what distinguish web2py from other frameworks. Some people like it, some do not. I am fine with that. Yet that is not harming anybody and it is not incompatible with other programming styles. We could be more like Django or Pylons but why? We already have Django and Pylons. We dared to be something different. Perhaps I have a persecution complex but I do feel the web2py community is not treated very well on reddit and this feeling is shared by other web2py users who do not hang out here any more. I think this is bad. I do not expect you to like web2py or use it. In fact, I do expect you to be passionate about your work as I am about mine. You do an excellent job with Django. Yet your statement about web2py being harmful to the Python community - in my view - is not conciliatory, is misinformed and not true. I know the python community as an inclusive and friendly community. I know you as a friendly, smart and informed person. That statement does not fit in. That is all. EDIT: PS. I really appreciated your tweet defending the PyCon 2011 tutorial selection process and I thank you for that.
Cool. I'd say the function heading should also read product(*iterables[, repeat]) --&gt; product object just like in the documentation, but this is at least correct. Not perfect, but correct :-P
Heh, Hello Worlds are not exactly what bothers me. :) I've also read the design document at http://docs.pylonshq.com/pyramid/dev/designdefense.html (which I think is something awesome). Still, call me picky, but I don't want to see code like policy = registry.queryUtility(IAuthenticationPolicy) . It just doesn't feel like Python to me. JFTR: I don't mean to start a flame war about aesthetics or PEP 8. It's just my preference and if other people think that Pyramid is übercool and can swallow such stuff, be my guest. :)
Is this a joke? *hcss lets your (sic) write CSS like this* &lt;div id="parent"&gt; margin: 10px; &lt;div class="child"&gt; margin: 5px; border: 1px solid #000; &lt;/div&gt; &lt;/div&gt; which becomes div#parent { margin: 10px; } div#parent &gt; div.child { margin: 5px; border: 1px solid #000; }
is this a preprocessor that is compatible with Mako's preprocesor hook? Or is it an integrated package?
Nemo (disney) is the clown fish, no?
This helps. In web2py the same reads (complete code not requiring scaffolding app, only framework) def hello_world(): return 'Hello world!' Hopefully this will help clarify the difference between web2py and others. Others are python programs that include and call modules, including the web server. In web2py the user programs are executed by web2py, they do not call the web server. The equivalent of main in the Pyramid code belongs to web2py, not the user apps, and it is in a file called gluon/main.py that users can read but they are not encouraged to modify.
That's a matter of subjective taste which I don't intend to discuss. Suum cuique.
Kidding aside, any benchmarks between this and just mako?
I was thinking the same thing. What use could this possibly have?
That code is going "under the hood"; can you tell me where you saw it? That said, your issue is actually more or less the casing of variable and method names? Interesting. That's a new one! 
That's a very unique approach... Given this, why don't you use xml?
No, it's actually not a matter of subjective taste. I know because I worked a hell of a long time to make sure it that it wasn't. When you develop a new Pyramid app, you needn't know or use any "Zopeties", as you call them (or at least as I'm interpreting what you mean). It's just not true.
&gt; seriously harmful to the rest of the Python community. The only thing that is **"harmful to the any community"** are some people who **can not act as a community member**! This kind of attitude can clearly lead(more) Python to the status of **"Worst free software community"** There are thousands of languages and thousands of frameworks, and each with its own design decision, and I never heard of any other community something like this, this is the kind of thing one hears in churches when one decides to attack another religion. (And I think tools, frameworks and languages are not religions) You are considering Python as a religion? think "Zen of Python" is equivalent to the 10 commandments? and the PEP8 some doctrine? (This kind of thing has nothing to do with the free software community) Not that I dislike, but I see all these things more as guidelines and suggestions. Or do you have any money invested in shares of some of these frameworks or in Python language itself? I would very much appreciate the Python community (mainly those who have an **inflated ego**) could act as a real community. In a nutshell: everyone has the freedom to choose or create a free framework in any language that the license permits. Is there somewhere in the Python license some indication of how the decision should be made to design your frameworks or applications? At the final: the only thing we really need is to enjoy coding with Python and releasing some cool, useful web applications to our users/clients, no matter if they were made with X or Y tool. This type of attack is very harmful to Python as web platform and all its frameworks and professionals. Talking about the technical aspects and make comments is a good thing, but **attacking claiming something is "harmful"** even without knowing how it works. **is very unethical.** I would not want to be part of the same community of people who think and acts in this way. PS: We have a bunch of clients which have Django apps running, One of my company's products is developed in Pylons. We've been coding with Python since 2003 (we are not so purist, and we are not so pythonic as you), but our products are running through years, our clients are so satisfied and we make our lives. Almost one year ago we decided to move and remake some apps to web2py, the best decision we have made, we release software in less time and we kept a good integration with legacy apps (some in django, Pylons, Php, C#) What I want to share is that we integrate good solutions made with web2py with good solutions made with Django or Pylons. and the whole thing is very well for us and our customers. Why as a community we cannot make the same thing? (share, integrate, help etc.) **we like web2py** and **we're still being considered as python programmers** and still contribute to the Python community, **or not**? Or is there someone who has rights to ban or tothrow us out of the **"Python community"**? make no sense 
What I like about it is how nicely it treats hierarchy: div#parent &gt; div.child { and also I will be able to parse the hierarchy using a a xml parser.
I think it is exactly what it does. It uses XML so now you can define your CSS in XML and this will convert it to CSS.
It might be a troll if you have a look at the last updated date: &gt; Last updated: January 2, 2012. But I like the hierarchy feature and xml also feels more manageable as stated on the website. 
wow, pyramid really has a problem with misconceptions out there. never mind that there IS NO 'zope baggage' in pyramid. just the fact that people assume that and immediately discard pyramid as an option to explore. weird. read the docs, dude!
going to have to disagree with all your points. zcml is optional. routes is supported and encouraged for newbies, traversal is sweet, and I find it very useful, but it's one of those things that you will know when you need it. as far as form validation, use formencode and get on with it, or formish, or deform, or toscawidgets or .... or ..... or .... what is missing is *magic*, which is ok, some people don't really care about that. it's clear pyramid is not for you. and that's ok too. 
This _had_ to be personal. :) Calm down dude, I'll look again what I disliked and let you know if I'll find it. The source code was from the design document btw. Anyhow: thanks for your efforts whether I use them or not. Python definitely needs more serious "heavy" frameworks than Django.
chris, i think you might be misunderstanding hynek. and i think he's got a point, too! Zope2 and 3 are indeed 'famous' for using camel-cased method names, whereas pep8 clearly limits that to class names. I, too, dislike them, whenever I come across them when I work with Plone. to hynek, though: the reason I began disliking all that camel-case ugliness was precisely, because I have been working with repoze.bfg for the last 18 months or so. all method names there are lowercase_with_underscores, as they should be :-)
&gt; However, I appreciate at this stage of the game the documentation is not the focus. /facepalm
I was really hoping this would be "A Pythonic Ham!" Though I notice there's no `ham` package in PyPI... perhaps I should get on that.
If you got that source code from the design document, I have to laugh. It's in a section telling you what you *don't* need to do to write a Pyramid app. The section explains why you don't need to use the registry at all in Pyramid as an application developer. You may need to as an *extension* developer, but that's another story entirely. How did you miss that?
Ah you're right. I misread wikipedia while I was looking for a name. It's Chum who's a Nemo shark. Oh well, the name has stuck. Rest assured in a parallel universe Nemo is the Mako shark and I can say that we are remembering our roots, keeping it real, and are still Jenny on the block, ecetera and so forth. =) 
The irony of this complaint: the source code above comes from a section in the design defense explicitly naming what you *don't* need to do as a Pyramid application developer. http://docs.pylonshq.com/pyramid/dev/designdefense.html#ameliorations
Ok seriously, it's a while back when I evaluated Pyramid and I didn't like it. I didn't take notes why and just skimmed the design document for something that might be part of it. Please understand that as a Pylons developer, I'm at a crossroad. My applications won't be ported as it would be too much work and as they are internal, I don't need necessarily update. So I'm basically starting from scratch. And my only requirements are flexibility and SQLAlchemy. Please let me make clear again, that I didn't mean to make your work bad. I just asked above a question which wasn't meant to hurt anybody. As it apparently did, please accept my apology.
sure, just pointing out what specifically is up.
It's also noteworthy that Zope technologies are automatically seen as something that is "baggage". I'd say Zope-the-framework is "bad" because of lacking documentation, conceptual overhead and being somewhat over-engineered Java-style. It did however bring some interesting sub-projects for which my main complaint is the naming conventions like the lowerCamelCase and the ISomeInterface, but that's really minor and easily hidden if it's only used by internals.
The name always make me chuckle a bit.
No, it's not a joke. To quote from the article: "The idea of hcss is that you start building the frontend for a web page or application with the HTML markup, defining the document structure and element sets for various widgets. And once the markup is ready, you just copy it over to a .hcss file and add styles, contextually through the element tree, without having to write any selectors at all."
Heresy! They would type "__pip__ _mypackage_". There is no such thing as "easy_install".
I understand your concern, but this seems like a dramatic over-reaction. In web2py, the following global objects do not need to be imported: request, response, session, cache, URL, HTTP, redirect, T, DAL, and field (plus some HTML helpers and some validators). Are you saying that because those few global objects do not need to be imported, that web2py is "seriously harmful," not really a "Python framework," and must be spurred to "join the rest of us"? Is the Python community really that rigid? EDIT: Someone pointed out that Python has 135 built-ins. Do you ever explicitly import them? web2py adds about 10 keywords, all very well documented. This doesn't really seem like that big a deal. &gt;But look guys: every single other Python program ever written uses imports. And web2py uses imports as well. The framework itself uses imports, and application code also uses imports. There are just a small number of well-defined and well-documented things that don't need to be imported. &gt;By not including them you've basically made sure that learning web2py is different from learning Python. When someone learns web2py they aren't learning Python! The entire framework is written in Python. All web2py application code is written in Python. It's Python. Are you saying that the Python language is completely defined by the explicit importing of absolutely all objects referenced in the code and anything else simply doesn't count as Python? There have to be some limits on "explicit is better than implicit." Wouldn't it be more explicit to simply copy and paste code rather than import it? And more explicit still to merge two functions rather than call one from the other? Explicitness and DRY are generally at odds, so we always have to make some sensible tradeoffs. Of course, we could easily say the same thing about Django -- it has its own template language, so when you learn Django, you aren't learning Python. The point is, every framework requires some learning _in addition_ to Python. That's why documentation is such a big deal. When you learn Django or web2py, you're not learning just Python, you're also learning the specifics of how to build a web application in Django or web2py. &gt;This means that if -- when -- they want to branch out into the rest of the Python community, they're going to have a distorted view of how Python works, and they'll run into all sorts of mistakes. Since web2py does use imports, I doubt any web2py users are unaware of Python imports, so it seems unlikely they'll have a distorted view of how _Python_ works. I don't think this is really about Python as a language, though -- it's more about Python _web frameworks_ in particular. Yes, web2py does some things differently from some of the other Python web frameworks, but that doesn't mean web2py isn't Python or that web2py needs to fall in line with the other frameworks. Perhaps web2py is on to something, and the other frameworks should learn from it. Or perhaps the Python web community could at least make room for a diversity of tools and approaches in order to meet a diversity of needs and preferences. Is that too much to ask? &gt;Let me give you a single concrete example. In the example linked above, there's this: &gt; &gt;return dict(form=crud.create(db.person), &gt; rows=db(db.person).select()) &gt;There's no imports, so in that line we've got three globally-namespaced names: dict, crud, and db. Someone new to Python will completely miss that dict is a Python built-in, but crud and db are web2py globals automatically injected into the namespace. Just to clarify, crud is not "automatically injected." crud is an instance of Crud, which is in fact explicitly imported in the db.py model file of the scaffolding app (Mail, Auth, Service, and PluginManager are other examples of web2py modules that are explicitly imported in web2py apps). db is an instance of DAL, also defined in the db.py model file of the scaffolding app. Indeed, DAL is one of the few globals that does not need to be imported. &gt;They'll have no way of knowing the difference between these three names, and will have no clues as to where to look for documentation for each. Well, dict is a Python built-in, so they shouldn't expect to find it in the web2py documentation, but [here it is](http://web2py.com/book/default/chapter/02#dict) anyway. As already noted, Crud is in fact imported, and it is [well documented](http://web2py.com/book/default/chapter/07#CRUD). As for db and DAL, these are fundamental to web2py, and anyone who spends a few minutes learning web2py will know about them. In any case, suppose DAL were explicitly imported -- would that really make it much easier for someone who doesn't know web2py to know what it is or what it is doing? They would still have to investigate the DAL documentation and/or code, which they can do very easily even without the explicit DAL import. So, what's the problem? &gt;It means that web2py programmers and Python programmers cannot be completely on the same page. Nothing you have presented thus far suggests this is true. Again, perhaps you really mean that web2py programmers will not be completely on the same page as Django programmers, or Flask programmers, etc. But neither will Django and Flask programmers be on the same page, nor Bottle and Pylons programmers. All frameworks have their distinctives -- that's presumably why their creators made them. &gt;It means that experienced Python programmers will always look down on web2py. Doesn't speak very well of "experienced Python programmers." &gt;It means that new web2py developers will have a hard time integrating into the rest of the community. It means that there'll be little to no crossover between web2py users and Python users at large. Is there evidence of this? &gt;Until this mistake is corrected, web2py won't really be a Python framework. It'll be a web framework with a built-in language that looks sorta like Python. I'm not sure what this means. web2py application code is Python and runs in the Python interpreter. Even the templates use pure Python (unlike most other "Python" web frameworks). It doesn't just "sorta look like Python" -- it is Python. It appears you are marginalizing web2py purely via semantics. &gt;I really don't care one whit about which framework someone choose to use. As long as they don't choose web2py? &gt;But I do care, intensely, about the health and stability of the Python community at large. OK, this is a laudable goal -- but I think this whole line of attack against web2py is actually counter-productive for a community that wants to remain healthy and stable. I'm a relative newcomer, and to me this all seems like "the establishment" trying to maintain some kind of dogmatic purity. It doesn't make the community seem very appealing. To be honest, given the length of your post, I was expecting some real concrete arguments as to why and how web2py is supposedly harming the Python community. But so far, I have seen no real evidence that this is the case. If anything web2py is probably attracting new people to Python (e.g., people who were considering Rails, PHP, etc.).
Here's my preliminary tests: This is across 100,000 iterations over a single 555-line template w/o inheritance. Mako (full render w/o nemo): 0.08 ms Nemo (w/o mako render): 0.04 ms Nemo (w/ mako render): 0.07 ms In another test, I just passed Mako an empty string to render and it took about 0.04ms. So this suggests that for 0.04ms overhead from openning the file, running it through Mako, etc. And when Mako uses a preprocessor, it must enable some kind of optimization since the full-render time for Mako alone is greater than that for Nemo+Mako. I still have to do more, but what I'm leaning to is that Nemo is so fast that the overhead of Mako dwarfs it. For 'official' benchmarks, I'm thinking of using the benchmarks from the Genshi/Mako test suite: http://genshi.edgewall.org/wiki/GenshiPerformance Would that be suitable, or do you have another suggestion? 
Yes it is compatible with Mako's preprocessor hook, however if you follow the instructions you'll also get a quick integration with Django by only adding 'nemo' to your settings.py 
but, but we had damsel like last week...
Please try to assume I'm acting in good faith. My goal here is to bridge the gap between web2py and the rest of the Python community, and I'm doing my best to articulate why I think that gap exists. It seems you and others who've responded here think there's some nefarious purpose or boosterism behind my words here, and so I'm going to avoid engaging. I don't see the point in going blow-for-blow here on Reddit if you're just going to assume that I'm here to slag on web2py for the betterment of Django. If you'd like to give me the benefit of the doubt I would really love to do what I can to help bridge this gap. The ball's in your court. I'm jacob@jacobian.org -- email me any time.
Now Java just needs a decent repository...
&gt; Without qualification I'll say that web2py seems like the Rails of Python: wondrous magic that'll have you dance with unicorns the first few days until you actually need to do something interesting. I thought this was Django's job. After all, it's got magical ponies. It certainly had me dance around until I realized I wanted Pylons.
Massimo, I'm trying to tell you that your choice of exec exemplifies the way that web2py sets itself aside and away from the Python community. I'm not trying to be conciliatory; I'm trying to get you to see that its *your choice* to be apart, and that *your choice* can start to close the gap. I'm done now, though. I've tried to be clear and constructive, and I'm really trying to help, but the response makes it clear that the web2py community (at least, the vocal ones) assume I've got some nefarious or underhanded purpose. This assumption of bad faith is seriously insulting, so I'll just shut up. I'm sorry I posed anything in the first place. If you'd like to give me the benefit of the doubt I would really love to do what I can to help bridge this gap. The ball's in your court; you know how to reach me.
You mean Dsml? Its there in the docs as an alternative. Other alternatives are: HamlPy PyHaml Django-Haml Dmsl SHPaml Pamela Mint Mako-Haml As you can see, I'm a highly creative individual who tends to have unique ideas.
[CleverCSS](http://sandbox.pocoo.org/clevercss/) anyone? And some bugfix [here](https://github.com/dziegler/clevercss/).
I'm not hurt at all, I'm just doing my job here, which is to protect the reputation of my creations and, therefore protecting my own reputation. Such is the life of an open source software developer in 2011. But if you want to help *yourself*, you need to do less skimming and more reading. Everything you've claimed here so far is false, and dismissing Pyramid on falsehoods doesn't just hurt Pyramid, it hurts *you*. There will be a good number of people moving from Pylons to Pyramid, and you could take advantage of the documentation produced to do so, and the community of folks in the same boat. If you need to move your code to some other framework, there just won't be as many folks who can help with that process or have quite the same context as you. Pyramid can be used *just like Pylons*, there are some slightly different spellings (none CamelCase, btw, if it matters), and it will be familiar to you within a day if you *actually* started to use it. All that said, it's fine by me if you don't want to use Pyramid, I just ask that you have a firm grasp on the *reality* of why you're not using it, not some misinterpretation of its intent based on your 10-minute skim of docs unrelated to its actual usage.
This seems to imply you cannot write complex selectors, which totally negates ones of the only reasons for using CSS. In fact, why does this website not show a full usage of the program. It would be so much clearer, if an entire website with sample CSS was shown, so a real comparison could be made. The 4 shown examples says nothing about why I would want to use this. In fact, after 10 years of front-end development experience, as well as server side stuff (and toss in a Masters in CS) I still have no idea what this thing does, or maybe rather why it's a good idea.
&gt; One of the distinctive features of web2py is the presence of a web based IDE for development, testing, debugging, deployment, and distribution of apps. Some of the old zope folks should chime in on this notion of "through the web development" 
DRY: &gt; "Every piece of knowledge must have a single, unambiguous, authoritative representation within a system." It's about things like generating URLs from routes rather than hardcoding URLs. It has nothing to do with imports or any "boilerplate".
That web2py is harmful to the python (web) community may not be correct but the people involved (whoever they are) do nothing at all to contribute to the community at large. Thinking about any of the big popular web libraries/frameworks like webob, werkzeug, pylons, turbogears, flask or django I've no problem coming up with the names of the most important contributors or the people relevant to the community and I doubt anyone else active in the community has either. The only person I'm aware off who is contributing to web2py is mdipierro as author of the project who is only really famous for mentioning web2py in every thread which is more or less web related here on reddit. That may be a highly subjective point of view but the discussions I head about web2py show me that apparently nobody knows anyone but mdipierro either. Has anyone working on web2py shown interest, criticized or even participated in the development of PEP 3333 or PEP 444? Any other PEP? Maybe something else?
That was just a typo, fixed.
I think we've probably reached a new low when choice of framework depends on method casing.
This analytical explanation on how you solve these issues is really impressive.
&gt;I want developers to be able to float between different Python web frameworks -- and to write their own new ones -- without impedance. Are you saying it's currently trivially easy to "float" between all of the existing Python web frameworks _except_ web2py? Do you have any evidence that this is true? How does web2py make it difficult for someone to write their own new framework? Note, if you're concerned about the health of Python, then you should be concerned about innovation. Innovation will be difficult if every time someone comes up with a different approach they're told to get in line with "the way we do things around here." &gt;I'm doing everything that I can to atone for the sins Django committed in the past, and I hope you'll one day choose to join the rest of us and be part of the greater Python community. It's an awesome place. This seems unnecessarily exclusionary. Is the Python community so narrowly defined? Is there no room for diversity? &gt;Until then, I guess I'll no longer think of web2py as a Python tool, but as a tool written in its own language. Does this imply you used to think of web2py as a Python tool? What changed? It sounds like you are willing yourself to think contrary to reality -- you know web2py _is_ a Python tool, but you're artificially categorizing it outside of Python so you can imagine the Python world as more homogenous and in line with your vision. Note, Objective-J _is_ a new language. web2py is written and programmable in _Python_ -- there's no new language. Saying it and thinking it won't make it so.
Given the way hynek spelled camelcase I doubt he even knows what it means and considers it to look LikeThis whereas it actually looksLikeThis. Considering this he probably thinks a microframework shouldn't force you to create classes.
I really hope there's an XML format I can use to encapsulate this XML, though.
The problem is, or at least has been (not sure what PEP 3333 means), that WSGI *itself* hasn't *really* been supported on Python 3. I don't completely understand the issue but it seems to be that the specs are incomplete/ambiguous regarding unicode vs bytestrings which is essential to Python 3.
It is fascinating how you call these globals you inject into the namespace "keywords" and yet do not consider the conflict this obviously creates with the language. Keyword is a very well defined word and whatever you do you cannot add one or change existing ones. Everytime you speak about these things as keywords you just create more confusion for people new to Python and that is actively harmful.
return 42
What are your concerns? web2py is not the same as Zope.
Thank you Jacob. Let's talk at PyCon.
The issue does not exist. I do not have to resolve it. If mistuhiko can produce a piece of code to produce the problem in web2py, I will be happy to open a bug report and look for a solution. The current mechanism of exec'ing was designed to avoid memory leaks and it does it. I could argue that Flask uses thread local objects and therefore information can spill from one request to another and thus produce a security issue. (by the way, exec'ing prevents that). Yet I trust Mitsuhiko and I assume he knows whet he is doing, not that he does not, so I do not go around accusing people of hypothetical problems that I have not verified myself.
Sorry. I have no interest in arguing about definitions. You are the ones who want the freedom to call a "request" object any way you like. I think it should just be called "request". period. You do not have to agree with me.
jacobian, I do indeed assume you are acting in good faith and are articulating real concerns. I do not assume any nefarious purpose or (conscious) boosterism behind your words. That does not mean your concerns are valid or your arguments are sound. I too am acting in good faith. I have pointed out some errors and raised some questions. You can choose whether or not to engage. I will say, though, that almost without exception, when I press web2py's detractors for specifics and concrete evidence, they seem to disappear from the conversation. It's easy to make sweeping claims like, "web2py is harming the Python community" -- a lot harder to back them up. EDIT: Once again, your silence speaks volumes. If you're really concerned about the Python community, perhaps you could start by imploring the community not to make unfounded and uninformed critiques of web2py and its community. Many of the things said by non-web2py users in this thread (and many others on reddit) have been incorrect or misleading. If you're going to publicly disparage a technology and a community of people, then you have an obligation to know what you're talking about. If you can't be bothered to do some investigating, then be more circumspect and ask questions instead of making definitive claims. Otherwise, all this misinformation ends up reflectly poorly on the Python community, and that's not good for anyone. Peace.
The [web based IDE](http://web2py.com/demo_admin) is a feature, but not the only way to access web2py. You can use it from the shell like you do in Django or Flask or Pylons. The good old fashion way. The web based IDE is for newbies and a convenience when you have to do maintenance and do not have a ssh client. It includes a [wizard](http://web2py.com/demo_admin/wizard) which is also a unique feature.
If you're after a tried and tested btree C extension for python then do take a look at the BTrees package from [ZODB](http://www.zodb.org).
i don't have concerns. I was pointing out that this notion of developing a web application through the web is not an original idea, and implying that a certain group of people determined that it is not such a great thing based on their experiences. Why not learn from others? 
&gt; The issue does not exist. I do not have to resolve it. Well then … &gt; I could argue that Flask uses thread local objects and therefore information can spill from one request to another And how would that work?
&gt; The web based IDE is a feature, but not the only way to access web2py. right just like zope, this is all I was saying. 
How do you end up with any app whose major bottleneck is template rendering speed?
Why would you want to do that? First of all most pages are not that static, the elements are somewhat conceptual components that you puzzle together. But more importantly, a vast minority of styles are defined depending on their whole root from the &lt;body&gt; tag - you'd much rather use IDs or classes (and browsers are more efficient with this as well).
&gt; If mistuhiko can produce a piece of code to produce the problem I am not running web2py, but execfile() in a loop in this piece of code in a new context produces an amazing memory leak: class Foo(object): def __del__(self): pass foo = Foo() You should be able to put that into one of your controller files and hit the URL and see the memory of the Python process grow and grow.
Not sure why you would want to parse it with an xml parser, but there are already quite good solutions for the hierarchy thing, see [LESS](http://drupal.org/project/less) and [SASS](http://sass-lang.com/). (How often do you use the &gt; combinator anyways?)
Nice. I looked for python btrees and came up with [almost](http://pypi.python.org/pypi/blist/) nothing. Thanks! FWIW that module looks to be doing one thing that btrees are good at - an ordered dictionary with quick access to slices. My module's sorted_btree object is more about being a faster alternative to a sorted list and the bisect module. EDIT: \*goes back and reads the rest of the page\* there are lots of use-cases supported in the ZODB packages.
or a new high, depending on how you look at it :) if python has so many good frameworks to chose from, that CamelCasing (or camelCasing) can tip the scale, surely we must have a great offering... SCNR
This is not a problem. I'm just arguing that administrating is not painless compared to (apache+mod_wsgi in daemon mode) where boot-time initialization, daemonizing and restarting is given for free.
Just local, though I've done some work with parallel python using message passing, but not too much.
&gt; there's too much upfront that people don't need (ZCML) hm, all the ZCML documentation is in an appendix, no?
I'm definitely going to update the page with a better expressed rationale. But allow me to just say I've built this out of necessity. I was working on a few projects with huge HTML/jQuery-based frontends and maintaining the CSS started to get painful. HCSS helped me evolve things better while keeping them tidy. You can still mix in any kind of complex selector within tag-based selector, as explained in the present documentation tho. The idea of tag-based selectors assumes that most of the time you're targeting styles at some kind of markup tree where lots of elements are glued together to compose a single widget, which was the case for my applications.
Nicely written C code.
The &gt; combinator is just the logical translation of what a tag-based nested selector in HCSS represents. In fact, it's [not even efficient](http://css-tricks.com/efficiently-rendering-css/) in comparison to any-descendant selectors. But I believe the result is much more readable and easier to maintain. You can still mix regular CSS within HCSS tho. Even inside tag-based selectors, as demonstrated in the documentation.
I wouldn't call it a very poor benchmark. I would call it a benchmark. Benchmarks are imperfect, they always are. They are just a test that tells you what happened when certain situations are run. Did he do everything perfect. No. Did he do a decent job. I seem to think so as did Ian Bicking [1]. In the mean time do you have an alternative benchmark you prefer? [1] http://blog.ianbicking.org/2010/03/16/web-server-benchmarking-we-need/
https://github.com/mellort/reddit_api/tree/master/reddit_api There you go.
Also, what threading issues have you seen in mod_wsgi daemon mode?
It's really really simple. Imagine you're writing a complex UI window, with a menu, content pane, lots of "floated" elements, "absoluted" elements and whatnot. The process of creation here at least for me is always the same: 1) create a mental model of all the markup required and how it is put together; 2) type all the markup, make adjustments; 3) progressively add styles, refreshing the page constantly to see results. HCSS lets you go from step 2 to 3 faster, by allowing you copy over all the markup you just wrote and instantly have almost all your CSS selectors ready to be generated. It seems to me that only people who have gone several times through the experience of creating really complex HTML-based interfaces will understand how this is really helpful, but I guess that's just me being a little condescending... The thing is, for me, it works, it helps, I thought it could make sense to somebody else. But YMMV, indeed.
Thank you for the response!
This is mostly due to social dynamics.. Robert Brewer doesn't hang out in IRC (or if he does, I don't see him much), while the BFG, Pylons, and TG folks hang out there a lot and typically populate each others' "channels". I'd love to compare notes with Robert and see if there's some way for us (as framework authors) to cooperate.
STYLE is not always hierarchical...thus CSS
&gt; 2) type all the markup, make adjustments; 3) progressively add styles, refreshing the page constantly to see results. This works for the first time you create a page - but doesn't really help for maintaining it or developing new features, which in my case is 95% of the time. &gt; It seems to me that only people who have gone several times through the experience of creating really complex HTML-based interfaces will understand how this is really helpful, but I guess that's just me being a little condescending... A little, no. A lot, yes. I did this for 8 hours a day for 7 years. &gt; The thing is, for me, it works, it helps, I thought it could make sense to somebody else. Of course, don't let an old fart's criticism stop you :)
&gt;That web2py is harmful to the python (web) community may not be correct but the people involved (whoever they are) do nothing at all to contribute to the community at large. Except, of course, contributing web2py itself to the community at large. Does that count for anything? &gt;Thinking about any of the big popular web libraries/frameworks like webob, werkzeug, pylons, turbogears, flask or django I've no problem coming up with the names of the most important contributors or the people relevant to the community and I doubt anyone else active in the community has either. Well, it's at least possible that this is merely a symptom of your attitude towards web2py -- if you actively avoid web2py, you're not likely to know much about who's involved with it. &gt;The only person I'm aware off who is contributing to web2py is mdipierro as author of the project who is only really famous for mentioning web2py in every thread which is more or less web related here on reddit. Note, there is not necessarily a one-to-one correspondence between your awareness and reality. There are only two committers to the web2py code repository (as far as I can tell, Flask only has one committer), but there are indeed many [contributors](http://www.web2py.com/examples/default/who), both to the code and to the documentation and website. It shouldn't have been too hard for you to find that list, as it is linked from the main menu on web2py.com. &gt;That may be a highly subjective point of view but the discussions I head about web2py show me that apparently nobody knows anyone but mdipierro either. But who's fault is that? You make it sound as though web2py folks are avoiding the rest of the Python world, but perhaps the opposite is true. If you shun web2py, you aren't likely to know much about it, nor should you expect its community to want to hang out with you. In fact, mdipierro and others do contribute non-web2py code to the community, as well as numerous open source web2py-based applications, plugins, and modules. They're making people's lives easier, which is indeed a boon to the community (Python and beyond). Also, many of the web2py contributors are not US-based (scattered across South America, Western and Eastern Europe, Scandanavia, and Asia), so that may contribute somewhat to their lack of visibility, particularly in the US Python world. &gt;Has anyone working on web2py shown interest, criticized or even participated in the development of PEP 3333 or PEP 444? Any other PEP? Maybe something else? Well, Graham Dumpleton is listed as a web2py contributor (I think primarily in the past, though he still occasionally posts on the mailing list), and he's acknowledged in PEP 3333. Other than that, I'm not going to do your research for you. Do you have data on the quantity of extra-framework contributions all the various framework contributors make over time as compared to the web2py contributors? Even if web2py doesn't stack up, again, who's fault is that? You can't keep telling people they're not a part of your community and then lament their lack of "contribution" to your community. Anyway, why does this matter? It appears you are now inventing arbitrary reasons to disparage web2py. Now its contributors aren't doing enough PEPs. Really?
With a bit of ingenuity, a combination of OGR/GDAL, numpy, shapely and stuff like mapnik or basemap/matplotlib, I can get most of my GIS-type analysis done. If not directly on PostGIS or SpatiaLite. Also, easy to pipe stuff out on to a webpage.
&gt; This works for the first time you create a page - but doesn't really help for maintaining it or developing new features, which in my case is 95% of the time. That's odd because the one thing that has gotten better in my workflow after I moved to HCSS is maintenance. In the past I would iterate a lot between the HTML and CSS searching for IDs, classes, rearranging blocks of CSS rules, which overtime always ended up having some accumulated mess. With HCSS, if I change the markup, I just copy it over and slowly copy the styles from the old markup to their new appropriate places. It occurs to me that maybe most people simply have gotten so used to the cognitive dissonance between HTML and CSS and never really think about it anymore. I have only been doing frontend development for a little over two years now (I still am mainly a backend guy) and the CSS/HTML context switching always bugged me. It always felt like there could be a faster way to style markup, and after some experimentation, HCSS is what I came up with. Since i'm constantly creating new things from scratch I focused on being able to just "copy over" markup and add styles, as this is exactly what I was doing after writing large chunks of unstyled markup. I'd copy the markup over to the .css file just so I'd have context, and write the selectors looking at the copied markup. I could also place HTML and CSS editor windows next to each other to assist in this process, but that isn't a very practical procedure for me (as a TextMate user) and users of many other editors I believe.
&gt; Others are python programs that include and call modules, including the web server. In web2py the user programs are executed by web2py, they do not call the web server. Sounds like the definition of a framework: The framework calls your code. 
&gt; I've tried to be clear and constructive, and I'm really trying to help, but the response makes it clear that the web2py community (at least, the vocal ones) assume I've got some nefarious or underhanded purpose. Why do you insist on claiming your motives are being misconstrued? Who is saying you have a nefarious or underhanded purpose? A couple of us disagree with your arguments. You are claiming that web2py is harmful to the Python community. We are claiming that attitudes like yours can in fact be harmful to the Python community. This does not mean we think you are nefarious (presumably no more than your claims mean you think web2py is nefarious). I'm sure you are a swell guy, but that doesn't mean you can't be misguided in some cases. You claim you have "tried to be clear and constructive," but I have pointed out some errors and raised a number of questions and additional points, and you have not responded. Are you saying your initial arguments were so "clear and constructive" that any challenge to them can simply be dismissed?
Wasn't ZOPE keeping code in the (proprietary) database? Difficult to access with a normal text editor. 
&gt;Keyword is a very well defined word and whatever you do you cannot add one or change existing ones. What is the definition of "keyword" and where is it "very well defined"? Why can't web2py have a few of its own keywords? Or what would you rather call them? &gt;Everytime you speak about these things as keywords you just create more confusion for people new to Python and that is actively harmful. "Actively harmful" -- really? Could you please provide at least the slightest hint of evidence that web2py's use of the word "keywords" has been "actively harmful" in any way whatsoever?
HTML and CSS are different because they serve different purposes. I see no cognitive dissonance. That said, HTML is a bastard of a language and about half of my DOM nodes are built by JS code anyways. In serious webapps it is all fragments anyways, coming from here and there - so often there really isn't any one single HTML to copy as you describe. I do recognize that we are talking about different coding styles, types of applications and (most importantly) habits.
I suspect you already know the answer, and that isn't what I was referring to. google it 
&gt;DRY: &gt;&gt;"Every piece of knowledge must have a single, unambiguous, authoritative representation within a system." &gt;It's about things like generating URLs from routes rather than hardcoding URLs. It has nothing to do with imports or any "boilerplate". Right, but boilerplate is also a "piece of knowledge" and so ideally also has a single representation within the system. What happens when your boilerplate needs to change (e.g., you refactor one module into two and now need to import the two new modules in place of the original)? If you've pasted the same "boilerplate" imports in multiple places, you now have to go and fix each one -- not very DRY, even by the above definition. 
I've been using various python libs with R, GRASS, of-course OGR/GDAL and then just started learning GMT for cartography.
Yes, I believe web2py has learned from others. I don't really know Zope, but my understanding was that its through-the-web (TTW) development involved storing code in the database (ZODB) and relied solely on Zope's own version control system. web2py's web-based IDE is entirely optional and is nothing like the Zope 2 TTW system. It is literally just a basic IDE that happens to be a web application as opposed to desktop software (i.e., it runs in the browser) -- other than that, it works like any other IDE or editor (though not as full-featured). All the code is stored in files on the filesystem, just like with any IDE, and any version control system can be used with it (in fact, Mercurial is integrated into the web-based IDE). So, it's not really "through-the-web" development in the Zope sense. It's really just a browser-based IDE/editor (and, in fact, it is usually run on the local host rather than over the web).
&gt; All the code is stored in files so the web ide is useless on app engine then anyway regardless of storage mechanism, zope had a web based ide, so does web2py I think we have sufficiently established that. And that was my only point in that the idea of a web based ide, is not exactly a new idea or a differentiator or a unique feature of web2py. Ot that it's even bad that both have it. 
&gt;&gt;All the code is stored in files &gt;so the web ide is useless on app engine then I wouldn't say that. I think most people who use the web-based IDE do so on their local (development) machine -- you can still do that and then deploy to GAE. &gt;anyway regardless of storage mechanism, zope had a web based ide, so does web2py I think we have sufficiently established that. And that was my only point in that the idea of a web based ide, is not exactly a new idea or a differentiator or a unique feature of web2py. First, that wasn't your only point. Your point was to suggest that based on the Zope experienced, a web-based IDE is a bad idea (i.e., "a certain group of people determined that it is not such a great thing"). But we have established that web2py's web-based IDE is quite different in both implementation and purpose from the Zope TTW system, and so the same concerns do not apply. Your point is also not quite correct. web2py's web-based IDE is at least a somewhat new idea (i.e., not the same as Zope) and is a differentiator (even if you believe it's no different from Zope, it still differentiates web2py from all the other Python frameworks). Anyway, why is this such a big deal to you?
little misleading, it depends on things. a computer being one of them. :) an os python....
&gt;little misleading, it depends on things. a computer being one of them. :) &gt;an os &gt;python.... Actually, if you click the web2py download link, you get a whole computer, including the OS. ;) OK, you do need a computer and an OS, but you do not need Python -- the Windows and Mac binaries include Python (and Linux will already have Python). You can even run it off a thumb drive. How much easier can it get?
Well, [not exactly like Zope](http://www.reddit.com/r/Python/comments/ex54j/seeking_clarification_on_pylonsturbogearspyramid/c1bqf29).
&gt; Anyway, why is this such a big deal to you? it's not a big deal to me. I just don't think it's a big differentiator. or at least not a practical one. :) Would you say that it is realistic to write a full blown enterprisey app in this web based ide? 
You're right. It's probably not a _big_ differentiator. But it's helpful to new folks, and it can be a nice convenience at times even for experienced users, and even when working on a "full blown enterprisey app" (though you would likely do most of your editing in a standalone editor or IDE). It also includes an error ticketing system. Actually, you can check out a [demo](http://www.web2py.com/demo_admin/default/site). Anyway, I don't think anyone is touting it as web2py's killer feature. I think one of web2py's main goals is ease of use, and this just makes life a little easier. Also, note that the IDE is itself simply a web2py application (like any application), so it's easy enough to simply delete it or ignore it if you don't want to use it. It is not integral to the framework at all.
You claim to be inspired by *my* project? And here I thought no-one noticed. =P
Nice try, spammer!
&gt; people involved (whoever they are) do nothing at all to contribute to the community at large **Yarko Tymciurak** has provided several years meritorious service in developing and maintaining electronic registration and payment systems for **PyCon**. He has also shown exceptional dedication to providing high levels of customer service to both delegates and sponsors, going above and beyond the call of duty in assisting with registration issues. http://www.python.org/community/awards/psf-awards/#march-2010 Yarko is listed as web2py contributor.
Hmm, I may be doing something wrong, but when I try this (in a web2py controller), I don't see my Python memory process growing.
&gt; people involved (whoever they are) do nothing at all to contribute to the community at large **Mariano Reingart** listed as web2py contributor, have contributed to many Python projects which benefits community at large. http://reingart.blogspot.com/p/resume.html (I do not intend(dont need) to list everyone here)
&gt;&gt;The issue does not exist. I do not have to resolve it. &gt;Well then … What do you mean? What do you expect him to do -- solve a hypothetical problem that no one has demonstrated yet? Keep in mind, web2py has been in use by a lot of people for a number of years, and this just hasn't come up. So you're probably going to have to do more than just speculate to generate any real concern. &gt;&gt;I could argue that Flask uses thread local objects and therefore information can spill from one request to another &gt;And how would that work? I think that's his point. He has postulated some hypothetical problem without demonstrating how it might actually happen in any real Flask code, and now you have to go figure out how it might work and solve the problem. 
Thanks for it. [Line 457 and line 473](https://github.com/teepark/btree/blob/master/btree.c#L457): You may want to write: mid = (min &amp; max) + ((min ^ max) &gt;&gt; 1);
I'll take managing daemons to have Nginx. Uwsgi is just icing. Nginx is both the best on low powered boxes, and also for running *n* servers in an array. You can run just a Daemon on a server and have it communicate with a webserver, or a Python list object of webserver IPs... the point is you can make it do whatever you like. Nginx/uwsgi clearly outperforms Apache/mod_wsgi on both one or many servers for a large app. Not having to run a webserver on every app box is a pretty big deal. I think mod_wsgi is great for most people, most people aren't complete nerds. /evangelism
I have not tried this with web2py yet but I have stored your code in a.py and created a file b.py that while True: execfile('a.py') and I cannot reproduce the memory leak.
That did not came out quite right. I like the idea of thread locals. We may use that in web2py. I know there is no problem in flask related to them, like I know there is no problem in web2py related to exec.
&gt; What is the definition of "keyword" and where is it "very well defined"? "In computer programming, a keyword is a word or identifier that has a particular meaning to the programming language." &gt;&gt;&gt; import keyword &gt;&gt;&gt; keyword.kwlist ['and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'exec', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'not', 'or', 'pass', 'print', 'raise', 'return', 'try', 'while', 'with', 'yield'] 
It happens quite often to me because my app: - Processes all long running queries and tasks in the background - Boosts the working data set for short running queries into memory via memcached At that point, we're seeing sub-millisecond responses from memcached to provide the app with data so the main bottle neck is Python. 
Here is a list of web2py contributors: http://web2py.com/examples/default/who We run as volunteers the registration for the PyCon conference two years in 2009 and 2010. We also volunteer for 2011 but we have been told our services were not required and registration is not handled by non-python software. All web2py modules are LGPL and run without web2py (you can run the DAL and the template language with Flask, some people do). Both me and Tim (creator or Rocket, our server of choice) are on the PEP444 mailing list. I admit I have not contributed actively but I think there is enough noise that I do not need to add mine. Personally, I do not think I have to defend myself because for me Python is a tool, not a religion. Yet I will just just mention that in 2005 I (and collaborators) have created in Django a CSM and web sites for 54 missions at the United Nations (pro bono, they could afford it otherwise, until in 2009 the US choose to provide them professional system and support) and I teach in a large university where we use Python in many courses. I use my real name here. I do not recognize yours. Should I?
It should work. Did you do a Close() and not Destroy()? Simplify your exe until it works again to troubleshoot.
&gt; What use could this possibly have? ... create an opening for a Nemo to HCSS to CSS compiler?
LessCSS-Python doesn't use a lexer and parser so its really too much trouble for anyone to work on it. Writing a hierarchical look-ahead parser by hand is really too much trouble for something that doesn't really need a fast compile speed. Anyways why not use [CleverCSS](http://sandbox.pocoo.org/clevercss/)?
I would argue that the request object, for example, qualifies as that piece of knowledge.
I've tried Close and Destroy, but the result seemed to be the same.
But you left out the next sentence: "The meaning of keywords — and, indeed, the meaning of the notion of keyword — differs widely from language to language." Not quite so "well defined". In any case, it appears web2py is using "keyword" correctly -- its "keywords" are indeed identifiers that have particular meaning to web2py (note, they are _web2py_ keywords, not _Python_ keywords).
Try throwing in a: sys.exit() after your close. I had to do that to solve a similar problem. edit: You'll need to import sys, obviously.
Nice, now I can throw away my own hacked up version and use the standard one.
I did notice :) I admired it from a distance and if I were going to use Haml for Mako, I'd definitely use PyHaml. But Nemo is *not* Haml. 1. Nemo is explicit in some places that Haml is not (e.g. it doesn't assume that everything is a div). 2. It has a single syntax for writing HTML attributes while Haml has 3 different syntaxes. 3. It has a single character for opening Nemo statements % while Haml has =, - , &amp;=, and %. 4. Nemo doesn't require explicit filtering. Haml does. 5. Haml requires explicit self-closing tags. Nemo automatically self-closes tags. 6. And its designed from the ground up to handle mingling HTML and Nemo markup. There's more, but I think this example demonstrates many of the trade offs made. And shows Nemo's readability over Haml. PyHaml: %ul - for i in range(5): %li(id=['item', str(i)]) ITEM ${i} Nemo: % ul % for i in range(5): % li #'item_${i}' || ITEM ${i} % endfor Right now, I think there's a strong case for Haml if you want 100% control over the output of your templates. However, readability-wise Nemo is a win sometimes. In the future Nemo could support HTML filtering as well and HTML validation under strict mode. Haml is kind of tied to where it is due to backwards compatibility but for now Nemo can add/change pretty rapidly based on what the community need or wants to see from it
I put sys.exit() in the frame destructor and that seems to have done the trick. Thanks! Edit: Turns out this wasn't the final solution. My problem occurs when I open a second frame. I have my main application window, and then another window which is opened through a File menu event. It seems that this second dialog isn't closing properly.
&gt;As a result Python code is, on the whole, pretty darned readable. Except for Python code written using web2py, which feels like it'd be much more at home in a language which places more emphasis on typing as few characters as possible This is a load of unsubstantiated BS. Why don't you substantiate that by putting a web2py program and another program written in another framework side by side and see which one is more readable? 
Even while the point of this sub-thread here is to insult me, you're right. The differences between the micro-frameworks (where Pylons still partially belongs to--it's simply a micro-framework with batteries included, but you can switch the brand of the batteries if you want to) aren't that big of a deal when you compare it to the differences to Django. Maybe I should add, that co-workers are already using Flask for lightweight stuff in our company. So there's another motivation for me, I'm weighting the pros and cons. I didn't mention it because I just wanted to know: &gt; I really wonder what flask is missing compared to Pylons? Nothing more. I grant that I should have left out the comment about Pyramid but I'm not going to waste time to find out, what I disliked when I looked at it first to defend myself, especially not with this Usenet etiquette shown here. It's clear that Pyramid is one of my top choices but I'm still looking at alternatives for reasons you may or may not understand. &lt;/whine&gt;
&gt;But look guys: every single other Python program ever written uses imports. By not including them you've basically made sure that learning web2py is different from learning Python. When someone learns web2py they aren't learning Python! Not all python programs use imports. When a beginner learns about Python, how does he know where dict() comes from? Well, he knows by reading the Python books. So, how does a beginner know where crud.create() comes from? He knows by reading the Web2py book. Web2py has only a handful of built-in functions to make this kind of things practical. Lots of opinionated, unsubstantiated assertions. Have you taught students web development using Django (or another framework) to conclude that web2py is harder to learn for beginners? Massimo has. He's a teacher. There are a number of teachers who are using web2py to teach students how to develop webapps using a framework. Incidentally, there are many beginners who have found web2py to be a lot easier to learn than other frameworks, Django in particular. If you read the web2py tweets, you will learn of this. Guess what. I still have 2 Django books on my bookshelf, before I abandon it to look for another framework that lets me focus on the content of what I want to develop instead of getting in the way. 
Probably best emailing the [CherryPy developer mailing-list](http://groups.google.com/group/cherrypy-devel) then. Robert will want to notify other contributors about it.
Yeah, here you go. def do(f): for i in range(int(f.__name__[1:])): f() @do def _3(): print("I &lt;3 Matz!") I &lt;3 Matz! I &lt;3 Matz! I &lt;3 Matz! Or, alternatively: def loop(n): def wrap(f): for i in range(n): f() return globals()['loop'] return wrap @loop(3) def loop(): print("I &lt;3 Matz!") I &lt;3 Matz! I &lt;3 Matz! I &lt;3 Matz! 
Disregard eclipse, acquire index variable.
While I think it's a pity that there's no beginner's Pyramid tutorial which would be nice to get some more attention/attract developers in this early stage, I'm really excited to watch the videos again. :)
&gt; you can still do that and then deploy to GAE. From within web2py's admin app with the GAE deploy button. 
The one issue I was having was because I have a newer version of libpng that deprecates one of the function names. I created a patch that fixes it: http://pastebin.com/FDW7GyhP
Anyone using Cherokee?
wow, "Statistical machine learning for text classification with scikit-learn", interesting
&gt; solve a hypothetical problem that no one has demonstrated yet? Unlike the "thread locals leak" FUD there are enough ways to trigger memory leaks in execfile() context. Circular dependencies of objects with destructors, state changes to other modules etc. &gt; He has postulated some hypothetical problem That is not a hypothetical problem, that's just FUD. Thread local objects in frameworks are cleaned up after the request, there is no way information leaks to another request.
&gt; like I know there is no problem in web2py related to exec. I did not say there is a problem with it, I said that they are changing the contract of modules in a way that a novice user might shoot himself. And as far as I can see, the documentation does not mention the differences of a module to a controller file or how you call that thing.
Why is that?
I now downloaded web2py and just dropped this into the welcome controller (default.py) and hit the page with ab 500 times: class Foo(object): def __del__(self): pass foo = Foo() foo.payload = [1] * 1000000 Had a process of 1.5GB after a few seconds.
Of course. You have to execute it against a new environment. `execfile('a.py', {})` for instance.
If the parent of your dialog is the main app then when you destroy the main app all children should exit with it as well. If the parent is None then you need to kill them individually.
&gt; … I didn't like it. I didn't take notes … My new years resolution: Taking down notes. I often re-evaluate some software just because someone on Reddit said something positive about it and I couldn't remember the reasons for not liking it a few months ago. 
Same here. :( I already tried some software several times always finding the same flaw. And it will help against embarrassments on reddit. :)
What means "EXTREME PyCon"?
I'll second TheRedTeam's comments. 1. I (as a representative "people") need to be able to tell in 20 seconds or so what the package does. I won't spend time reading detailed documentation if there isn't some hope that it can help me. 2. Even better if you can tell me in what situations your package would be a better choice (and why) than other similar packages.
"EXTREME PyCon" talks are advanced talks with no introductory material--the idea is they'll jump right in to the good stuff. The PyCon chairs proposed this after PyCon 2010, I guess there were too many talks that spent too long going over the basics. PyCon attendees tend to be more expert Python programmers, so explaining what a dict is is just wasting most people's time.
yes regardless of how useless the web ide in editing gae apps, you can overcome this through the regular mechanisms provided by gae. are you trying to say this is a feature of web2py? why does this need to be mentioned?
You are right. This produces a memory leak. I will check if this is a problem with web2py.
You can trigger this from within web2py as well: [Example](http://www.reddit.com/r/Python/comments/ex54j/seeking_clarification_on_pylonsturbogearspyramid/c1bry1p)
I *think* talk and tutorial submissions had to be in before the whole Pyramid announcement happened.
Integer overflow
be nice to the female robot. 
im not a bot im a nice girl :3
mod_wsgi has one really nice feature that I've not seen done well in other servers. If you are running in daemon mode and 'touch' the .wsgi script, it will reload your application without disrupting any requests.
From reading the documentation, it doesn't seem to me that ZCML is actually optional. It seems that using ZCML is required for extending someone else's application. Am I not reading this correctly? Call me ideological all you like, but XML configuration is still a negative when I'm evaluating which framework to use.
OK, now I've got it. Thanks.
A bit sad to see ["How to sell python"](http://us.pycon.org/2011/schedule/sessions/72/) on the list. I seem to recall that there was a similar talk ten years ago. The sponsor list on the front page is quite impressive though.
Thank you Mitsuhiko. This convinced that there is a potential problem. In your example the memory leak goes away if instead of execfile('a.py',{}) I do execfile('a.py',{},{}) I believe this problem can prevent the leak in web2py as well. I will run some tests, provide a fix and credit you for reporting this problem (although next time, please report it to the web2py mailing list directly since you are a member). To current web2py users. None of the examples in the book defines a class in models or controllers and I have not seen users's code doing this. It is good practice to define classes in modules (and import them) not in models or controllers. Anyway, this problem will explored further and resolved. 
&gt;&gt;solve a hypothetical problem that no one has demonstrated yet? &gt;Unlike the "thread locals leak" FUD there are enough ways to trigger memory leaks in execfile() context. Circular dependencies of objects with destructors, state changes to other modules etc. I think you're missing the point. Everything is FUD until demonstrated. Just because there are "ways to trigger memory leaks" does not mean they actually happen in real web2py applications. That's why you were pushed to offer a demonstration. &gt;&gt;He has postulated some hypothetical problem &gt;That is not a hypothetical problem, that's just FUD. Thread local objects in frameworks are cleaned up after the request, there is no way information leaks to another request. So you say. Now, I can keep claiming there is a potential problem, but if I never produce any demonstration of it, what are you going to do about it? The point is, you're in a _public_ conversation. There are lots of potential readers, most without your level of knowledge and expertise. They can't necessarily judge the veracity (or real-world significance) of your claims. So be prepared to demonstrate. Remember, "explicit is better than implicit." :)
"State of Pylons/TurboGears 2/repoze.bfg" sounds like it will be a Pyramid overview.
See [reddit_api/reddit.py line 664](https://github.com/mellort/reddit_api/blob/master/reddit_api/reddit.py). You do have to call the login method first, though. That is at line 533 in the same file (I think).
it took some digging to figure out how to do a submission it seems to require a captcha :( when I put it in it complains I'm not logged in (and I am) still the captcha thing is a bummer, will make this way less useful =\
oops, didn't see your reply before deleting (as I found the same thing) and as mentioned below, I've logged in but it throws a NotLoggedIn exception after solving the captcha. ugh: sr = r.get_subreddit("testsubredditfake") r.login(user="RobotAnna", password="hunter2") r.submit(sr, "http://test.info", "A Test Site") Captcha URL: http://www.reddit.com/captcha/XRzQKon3ZPpundBVGpC07afB7KXmNyNP.png Captcha: AYBJYE Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "reddit_api/reddit.py", line 102, in login_reqd_func return func(self, *args, **kwargs) File "reddit_api/reddit.py", line 67, in __call__ result = self.func(*args, **kwargs) File "reddit_api/reddit.py", line 677, in submit return self._request_json(url, params) File "reddit_api/reddit.py", line 151, in error_checked_func raise NotLoggedInException() reddit_api.reddit.NotLoggedInException: You need to login to do that! 
And another pycon that i'm not going because of money :(
What's sad about that talk? Some people have trouble getting Python into their organizations and that panel of speakers in a number of industries cover what it took for them to get Python in the door. There was a talk about this topic a year or two ago and it was well attended and had some good info. It was just a single speaker, though, and not a multi-industry panel.
Hmm, thought you were trying to be helpful, but then there's [this](http://twitter.com/mitsuhiko/status/23081432519806977) and [this](http://twitter.com/mitsuhiko/status/23089568890753025) -- the creator of Flask tweeting out-of-context negative quotes about an alternative framework. Even if you had valid criticisms to make, this surely would not be the mature and professional way to go about it. I hope you'll re-consider the wisdom of this kind of behavior. There's been some discussion in this thread about "harming the Python community." Honestly, I can't think of anything more harmful to the community than the behavior of some of its representatives on reddit. They make uninformed or misleading claims about web2py and its community, and at the first challenge, they disappear from the conversation. Instead of real discussion, we get a bunch of snarky tweets. Is this the Python community? @mitsuhiko, to your credit, you are usually much more willing than your colleagues to engage in real discussion. But what happened to jacobian, ubernostrum, etc? They don't seem to be able to stand having any scrutiny applied to their arguments.
There is also [blist](http://pypi.python.org/pypi/blist/).
Thanks for your interest :) I will also give a 3h (paying) tutorial on machine learning in python (with text, sound and image classification / clustering) and introduction to face recognition too. All of this with scikit-learn and other opensource preprocessing tools (e.g. ffmpeg, PIL, OpenCV...). All the tutorial material will be uploaded on github (probably somewhere under https://github.com/scikit-learn ).
&gt;yes regardless of how useless the web ide in editing gae apps, you can overcome this through the regular mechanisms provided by gae. are you trying to say this is a feature of web2py? why does this need to be mentioned? First, as has already been pointed out, the web-based IDE is not _useless_ for editing GAE apps -- you can't edit the apps in place on GAE, but you can still edit them on your local machine and then push them to GAE. Second, he was not pointing out a "regular mechanism provided by GAE," but an actual web2py feature -- there is a "Deploy on Google App Engine" button in the web2py admin (web-based IDE) application that makes it easy to push your app to GAE.
Please be sure to apply for financial aid before you decide that. The PSF works really hard to make PyCon accessible to all.
assuming for the moment that you are not a turing machine, what are the conditions that compliment your sense of aesthetics?
Hello.
one of us is a robot. if its not you it must be me. 
What about robots would you like to discuss today?
I say that because I don't live in North America. And it's quite expensive to get a visa, tickets, hotels, food and etc.
`range` returns a list; `xrange` just returns an iterator, which saves memory and time. Let's say you're going to loop 1,000,000 times. `range` will waste a bunch of memory and time to create a million item list. `xrange` will just remember three numbers: your current place in the iteration, when to stop, and how big of a step to take. `xrange` is almost always better than `range` unless you really, really need to have a list, so in Python 3 they dumped the original `range` and then renamed `xrange` to `range`. 
See also: http://us.pycon.org/2011/blog/2011/01/07/pycon-2011-full-talk-and-tutorial-list-now-availab/
This was my problem. None of the new frames were children. Thanks for the help.
I don't think the PSF can legally help pay for a visa IIRC, but they can do their best with all the rest. Unfortunately it seems like the deadline was January 2nd this year :-( But next year I highly recommend applying!
when do you think did we replace the humans from the planet? 
&gt; Just because there are "ways to trigger memory leaks" does not mean they actually happen in real web2py applications. The point is that web2py changes the semantics of Python by changing the way things execute and that can break things and it only took me a few minutes to find a way to make web2py leak. There are plenty of more things that can break because of the changed execution and the documentation does not mention that. I argue that this is hurtful, and so did Jacob. &gt; So you say. Now, I can keep claiming there is a potential problem, but if I never produce any demonstration of it, what are you going to do about it? I didn't make up bullshit and provided enough information in my original post about what breaks. All I heard from Massimo so far was: "thread locals leak information". Nowhere did this explain why it would happen, just that it does. That's FUD.
&gt; The creator of Flask tweeting out-of-context negative quotes about an alternative framework -- pardon me if I don't buy that this is out of some selfless, disinterested concern for the "Python community." The context was given to the first tweet which linked to the full text. The second one was a reply to zzzeek discussing tutorial selection for Pycon. If you look closely nobody from any other frameworks posts advertisements for their framework into discussions on frameworks at /r/python. That's what that thread was about. This thread here was about pylons/pyramid and out of nowhere a discussion about web2py starts. &gt; But what happened to jacobian, ubernostrum, etc? They don't seem to be able to stand having any scrutiny applied to their arguments. Because these discussions turn out to be fruitless unfortunately.
&gt; I will run some tests, provide a fix and credit you for reporting this problem (although next time, please report it to the web2py mailing list directly since you are a member). I am no longer a member and I am also not here to review other people's code. If introducing a separate dictionary for the local execution scope actually fixes that particular problem it just hides the actual problem of execfile, namely that modules don't clean up that well if destructors are involved because Python cannot garbage collect those on circular references. I just really wish there was a better and more honest discussion going on between web2py developers and the rest of the Python ecosystem. It's not that we hate you or don't wish you success, we don't like the fact that it breaks common Python conventions and harms the language. And your aggressive marketing does not help there. Are you at pycon this year? I think some discussion in person might be helpful to clean up the tense that exists.
In the distant past ZCML was recommended for extending. But these days, it's just another option: http://docs.pylonshq.com/pyramid/dev/narr/extending.html and http://docs.pylonshq.com/pyramid/dev/narr/advconfig.html#advanced-configuration
“If NYTProf 1 is a Toyota, then 2.0 is a Cadillac” — Adam Kaplan, author of NYTProf 1. That makes you wonder why they decided to strip build quality in v2... Don't know if there is something similar in Python though. Would look more like a BMW than a Cadillac, I am sure.
I will be there are look forward to meet with you and discuss this.
According to Oracle, they are optimizing Java for the scripting tasks that make Jython effective. Nice fail. http://www.oracle.com/us/corporate/press/173712
First, please re-read my comments, because your reply doesn't address them (you pulled out the wrong bits to respond to). &gt;web2py changes the semantics of Python by changing the way things execute Are you saying that execfile is not properly a part of Python's semantics, or just that the web2py documentation doesn't do a good enough job explaining what Python semantics are relevant in model and controller files? &gt;I argue that this is hurtful, and so did Jacob. I don't think Jacob had anything to say about the execution issue. His concern seemed to be about lack of explicitness (at least that's the only thing he _explicitly_ mentioned, and apparently he really cares a lot about being explicit).
Do you often think about else about thing did we replace humans from the planet?
Thanks for clarifying that! It's good to see that you've covered that base.
This is more a simple math problem. Python syntax is one thing. But OP doesn't even understand the algorithm.
Not.
You would not have come across as an idiot had you said, "I wrote it like this, but I would like ideas for an elegant solution...".
&gt; Are you saying that execfile is not properly a part of Python's semantics, or just that the web2py documentation doesn't do a good enough job explaining what Python semantics are relevant in model and controller files? execfile is part of Python to enable things like custom import hooks. Furthermore it's sometimes used to implement Python-ish config files. However execfile no longer exists in Python 3. But the main point of execfile like exec or compile is that you are knee deep in Python internals and can break stuff very easily unless you are careful.
Am I the only person who read the title of this post and and at first thought these two projects were closing down and then panicked because of it? Way to troll me reddit....
Are you the author of this code? There does not appear to be any copyright or license information in it...
I for one, would have NEVER learned Python if I hadn't needed to learn web2py for a contract job. I looked down on Python because of the indents for blocks things, always thought that was goofy. Switching back and forth between "pure" Python and web2py is completely effortless for me. I'm no genius and in fact am not even a "programmer".
Python users that aren't used to lower level languages try to stay away from those gritty details. But, they still need to take care of failure cases. Funny, isn't it?
Just FYI, you can buy a 48-core server for ~7500 these days, so, you need to do something really, really exceptional to need multiple computers.
&gt; explaining what a dict is is just wasting most people's time Unless you're Brandon Craig Rhodes delivering "The Mighty dict", which was an awesome talk last year which gave a full review of the implementation ;)
Python can dump pstats data, which is analyzable with a number of tools. One of my favorites is gprof2dot for a nice graphical visualization with the data inculded. (look at the screenshots): http://code.google.com/p/jrfonseca/wiki/Gprof2Dot With some small effort, you can also dump kcachegrind data, which has all rich detail. http://kcachegrind.sourceforge.net/html/Screenshots.html
&gt; Because these discussions turn out to be fruitless unfortunately. Not for us! You all are promoting web2py very well :) Thank you guys
see what you have written does not compile exactly for me. but assuming that you meant to type "do you think about anything else other than how did we replace humans from the planet" hmmm.... i think i am a random thought generator. lets say i have thought one in my head something along the lines of "am i human?" and if i have another thought "am i just an animal?" one can easily combine these two thoughts in various ways and think which is most probable to be the case. for example "am i something?" or what distinguishes a human from an animal? for most of the times i have thoughts that i can more easily relate to animals than to humans. now in retrospect i know that probably everyone has similar doubts and that they evolve a metric that allows them to deal with such attacks by their psyche. i don't happen to be in possession of such a metric. partly because any metric that i evolve eventually disintegrates in the face of the questions that i continually ask myself. not thinking feels somehow like cheating and taking the easy way out. without gaining anything in return for the trip. i answered something i hope.
&gt;&gt;The creator of Flask tweeting out-of-context negative quotes about an alternative framework -- pardon me if I don't buy that this is out of some selfless, disinterested concern for the "Python community." &gt;The context was given to the first tweet which linked to the full text. Sorry, the link is irrelevant. You lifted a very particular quote from a much longer multi-person thread (in which the the quote in question was quite well rebutted) for a reason. Even if someone bothers to click the link, they still conclude that mitsuhiko believes "web2py is seriously harmful..." because that's how you chose to summarize the discussion (if you wanted to stay more neutral, your tweet could have said something like "interesting discussion about web2py"). This is unprofessional behavior and reflects poorly on the Python community. Anyway, I seem to remember you complaining about people posting reddit links to external communities in order to get support. Isn't that what you've just done? &gt;If you look closely nobody from any other frameworks posts advertisements for their framework into discussions on frameworks at /r/python. But in almost every thread on reddit about frameworks, someone is promoting Flask, usually providing virtually no useful information about it (at least mdipierro provides technical details, code examples, links, etc.). In fact, Flask has been promoted in at least a couple of threads that were specifically about web2py. &gt;This thread here was about pylons/pyramid and out of nowhere a discussion about web2py starts. But the OP specifically asked about web2py. Are you saying that "out of nowhere" someone had the audacity to answer the OP's question? You know which framework the OP did NOT ask about? Flask. Yet "out of nowhere" a discussion about Flask starts. &gt;&gt;But what happened to jacobian, ubernostrum, etc? They don't seem to be able to stand having any scrutiny applied to their arguments. &gt;Because these discussions turn out to be fruitless unfortunately. What discussions? There are no discussions. That's my point. These guys post a single comment -- then when asked to back up their claims, they go silent. If you all really think these "discussions" are fruitless, then why don't you simply stay quiet to begin with? In other words, either stay out of it completely, or if you're going to jump in, then have the courage to respond to questions and criticisms (I'm not talking about you -- you usually do respond).
I am not.
perhaps it is only my misplaced belief that i make sense. how do you even know if the next sentence follows the first? 
Or he could write the sane version: mid = min + (max - min)/2 Except both are completely unnecessary since ints are automatically promoted to longs and there's no danger of overflow.
Because threading apparently isn't aware that Python integers will be automatically promoted to longs as necessary.
&gt;execfile is part of Python to enable things like custom import hooks. Furthermore it's sometimes used to implement Python-ish config files. Can you point to some documentation/resources articulating these intended limitations? &gt;However execfile no longer exists in Python 3. To be clear, Python 3 still includes exec() -- it's not as if this aspect of the language is gone in 3.x. &gt;But the main point of execfile like exec or compile is that you are knee deep in Python internals and can break stuff very easily unless you are careful. Perhaps, though in lots of real world usage, web2py applications apparently haven't been breaking anything major very easily. That's not to say it's not worth investigating, testing, documenting, etc.
Out of memory error. C:\\&gt; _
That looks nice. NYTProf can give line, block, and subroutine information - is there some way to get that with the pstats data?
how do you deal with other pseudo-humans?
FYI...given this: import time REPS = 100000 # time to index data = [x for x in range(REPS)] start = time.time() for i in range(REPS): x = data[-1] stop = time.time() print stop-start # time to pop data = [x for x in range(REPS)] start = time.time() for i in range(REPS): x = data.pop() stop = time.time() print stop-start I got this... dave@mis-135:~/devel/rc$ python t.py 0.0463960170746 0.0730929374695 Index is faster. But...`.pop()` does more/different stuff than index. Edit: adding this variation, to mimic what `pop()` does... # time to index+del data = [x for x in range(REPS)] start = time.time() for i in range(REPS): x = data[-1] del data[-1] stop = time.time() print stop-start Is even slower. dave@mis-135:~/devel/rc$ python t.py 0.0471439361572 0.0745179653168 0.0773940086365 
use ipython: In [19]: x=range(1000000) #use a decent enough sized list In [20]: %timeit -n 100000 x.pop() 100000 loops, best of 3: 151 ns per loop In [21]: x=range(1000000) #use a decent enough sized list In [22]: %timeit -n 100000 x[-1] 100000 loops, best of 3: 54.4 ns per loop it's a little tricky in this case because list.pop() modifies the list, but you can see the relative performance.
It depends on the method and the size of the list. In this case, I measured using the timeit module and they're pretty much identical.
Check out Robert Kern's lineprof: http://packages.python.org/line_profiler/ It does not use the raw pstats data from a cProfile run, but instead installs its own profiling hooks.
Well, it has limited class inheritance support: .no-selection { -webkit-user-select: none; -moz-user-select: none; } &lt;li class="menu-item"&gt; !no-selection; border: 1px solid #ccc; &lt;/li&gt; **!no-selection;** causes the content of **.no-selection** to be dynamically inserted at that position. Not only the content, but also any pseudo-selectors attached to that class name [are also replicated in the referring class](https://github.com/galvez/hcss/blob/master/examples/inheritance/inheritance.hcss). But it's not capable of handling arguments and variables like Less. Maybe I should try and get HCSS to understand the Less vocabulary too.
cool stuff. I think that's the first time I was able to follow along with examples of co-routines.
Of all the options, CleverCSS is the one that interested me the most before I went on to write HCSS. I might still work on CleverCSS compatibility in HCSS, but for me the killer feature is really about being able to reuse the same HTML markup to add styles. This is the key thing that has been helping me get things done faster.
I'd love to see that happen :)
&gt; someone is promoting Flask The question is who is promoting it. We don't link people to reddit discussions to advertise it and we're not actively taking part in any advertising (we == Pocoo Team, the developers of Flask). If we violated that rule anywhere let us know and we will fix that. &gt; What discussions? Everybody is welcome to revive discussions. I sent a mail to Massimo in the past already about my problems with web2py. While I am the lead developer of Werkzeug and Flask I still keep up to date with Django and Pyramid/Pylons and try to keep a dialog with the developers. There is value in understanding why they are doing things differently and learning from them. So far I haven't had success finding the same dialog with Massimo despite multiple attempts. So far it didn't work out and that's unfortunate. &gt; Why don't you simply stay quiet to begin with? I stay quiet the minute people stop linking to reddit discussions on the web2py mailinglist and when Massimo stops posting links to web2py in unrelated threads here. /r/python would not be a nice place when everybody of us would promote our projects in every single discussion here.
&gt; Can you point to some documentation/resources articulating these intended limitations? It becomes clear when you know how Python works internally. The documentation does not recommend against it because there are valid uses for it, just like there are valid uses for `sys._getframe`. &gt; To be clear, Python 3 still includes exec() -- it's not as if this aspect of the language is gone in 3.x. Of course it includes exec because it's an important feature. But it requires care and the documentation should do a better job at explaining how these works. Python in many places assumes that developers know what they are doing, similar to C. You can shoot yourself into the foot easily if you are using some of the Python internals. &gt; Perhaps, though in lots of real world usage, web2py applications apparently haven't been breaking anything major very easily. That's not to say it's not worth investigating, testing, documenting, etc. The point is that one should not even attempt to change Python semantics. You don't gain anything from it besides a few imports less. On the downside you are losing `__name__`, `__module__`, a proper module shutdown, performance and move some burden to the user that has to know the consequences of his globals to be flushed every request.
I wonder what's going on behind the scenes. I would have thought pop would be faster because maybe it doesn't have to deal with the whole list whereas taking an index would. Perhaps they both have to...? Has anybody made a table of timeits for all python operations? * creation of list comprehension * pop * range * etc
It is really not that stupid, assuming you already have some html markup. Its simple... You type less and in context...
A tutorial was submitted, but it was rejected because Pyramid was not considered well known at this point and the tutorial selectors feared it would not draw enough attendees.
My solution in Python: def make_bricks(small, big, goal): return (small &gt;= (goal % 5)) and (big * 5 + small &gt;= goal)
Again, missing my points. &gt;&gt;someone is promoting Flask &gt;The question is who is promoting it. We don't link people to reddit discussions to advertise it and we're not actively taking part in any advertising (we == Pocoo Team, the developers of Flask). If we violated that rule anywhere let us know and we will fix that. What's your point? Are you saying it is inappropriate for the creator/contributors of an open source project to promote that project to the public? Please justify this prohibition. [Here's](http://web2py.com/book/default/chapter/00) why Massimo created web2py. He wants to make people's lives easier and level the (digital) playing field. Given that motivation, naturally he's going to try to get the word out. And there are lots of people who are happy he has. In fact, given all the misinformation about web2py being propagated on reddit, I would say it is particularly important for Massimo and others to post here in order to provide an accurate characterization of it. &gt;&gt;What discussions? &gt;I sent a mail to Massimo in the past... I wasn't talking about that. I was talking about the guys on reddit who post single comments and then disappear from the discussion when they're challenged. &gt;So far I haven't had success finding the same dialog with Massimo despite multiple attempts. So far it didn't work out and that's unfortunate. I don't know about your private emails with Massimo, but a while back you gave him permission to forward one to the web2py list, and then some discussion with you ensued. As far as I could tell, Massimo took you seriously, treated you politely, and even made a change to the web2py code based on what you shared. Nevertheless, I don't think you have convinced him of the merits of your arguments regarding issues like abandoning exec. Is that your definition of an unsuccessful dialog -- one in which you fail to sway the other party? Do you automatically attribute that to a flaw in the other party, as opposed to a flaw in your own arguments (or maybe just a case of different needs and preferences in a diverse world)? &gt;&gt;Why don't you simply stay quiet to begin with? &gt;I stay quiet the minute people stop linking to reddit discussions on the web2py mailinglist Again, you're missing the point. You don't have to stay quiet -- but _if_ you're going to jump in, have the decency to reply to challenges instead of running away (and again, not you -- this was about some of the other guys). Aside from that, why can't web2py users inform other web2py users of web2py-related threads on reddit? Do they not deserve to know what is being said about them? Who better than actual web2py users to dispel some of the myths about web2py? Do you want redditors to learn about web2py exclusively from Django and Flask guys? You complain about Massimo being the main one posting about web2py, and then complain even more when other web2py users start showing up. And you yourself just tweeted a link to this thread to _your_ followers -- and dozens of them retweeted it and no doubt came to reddit with their upvotes and downvotes. Seems like a bit of a double standard. &gt;and when Massimo stops posting links to web2py in unrelated threads here. I've seen maybe one or two examples where his posts weren't very related, but otherwise, I think they generally are relevant. Can you point to some examples? &gt; /r/python would not be a nice place when everybody of us would promote our projects in every single discussion here. You don't act as if you really believe that, though. You have no problem with Flask being promoted in every single relevant thread, because you created Flask. Have you ever stepped in and said, "Hey guys, stop mentioning Flask in all these reddit threads"? Your problem is specifically with _web2py_ being promoted, not because you don't believe in such promotion in principle, but because you don't like web2py in particular.
The Pocoo Website uses it http://www.pocoo.org/ and https://bitbucket.org/mitsuhiko/pocoo-website for code. It's not really documentation but it shows how flexible Sphinx is.
Cool... I'm going to go file a bug then... One of my *biggest* pet peeves is finding useful code (especially on a site like github, where it's *designed* to make forking easy) like this but there's no license or copyright info. People don't realize that in the absence of license information, the code is effectively copyrighted *by* the original author with "all rights reserved". Meaning *none* of us really have many rights to *do* anything with the above code... So please... people... if you're going to hack something together and upload it somewhere... no matter how small or insignificant you think it is... put some form of a license on it (and if you just want to "put it in the public domain"... [think twice](http://www.linuxjournal.com/article/6225), just use something like the MIT or BSD instead...) The FSF has a great list of Free and non-Free Software licenses (e.g., GPL and non-GPL compat.) on this page if anyone is unsure what they might want to use http://www.gnu.org/licenses/license-list.html
From the github TOS: &gt;We claim no intellectual property rights over the material you provide to the Service. Your profile and materials uploaded remain yours. However, by setting your pages to be viewed publicly, you agree to allow others to view your Content. By setting your repositories to be viewed publicly, you agree to allow others to view and fork your repositories. I think since the code is public, you at least have the right to fork+modify the code.
The reason for this is the dictionary lookup in finding the `pop` method is more expensive then the dispatch that occurs to find the `sq_item` slot on `list`.
[Dozer](https://bitbucket.org/bbangert/dozer) has some similar features, I think. Sporadically maintained, but you'll get your money's worth.
Ugh... that's too ambiguous... You're just asking for trouble if you upload code there and don't actually include a license... IANAL, but I *am* someone who has worked professionally in the Free-Software and Open-Source industry for 16 years now (including at distro companies, and with many legal FLOSS experts) and I would *really* doubt that just because that TOS says what it does it grants you the rights to fork+modify code willy-nilly. Software copyright is entirely *too* complicated for that to work... It's far better to be certain and pick a license.
&gt; Again, missing my points. Let us begin... How did I miss your points? &gt; Good for you. What's your point? Are you saying it is inappropriate for the creator/contributors of an open source project to promote that project to the public? Please justify this prohibition. I am suggesting that it's inappropriate for anyone to take over threads and advertise unrelated projects. I obviously can't control other people, but I can make sure none of the team members do that. And as far as I can see, the same unwritten rule applies to the Pyramid and Django team. &gt; I was talking about the guys on reddit who post single comments and then run from the discussion when they're challenged. I don't think they are running from the discussion, they just want to avoid what this thread might be turning into. I hope you can understand that. For the same reason I don't go into points not worth discussing. &gt; Aside from that, why can't web2py users inform other web2py users of web2py-related threads on reddit? I don't have a problem with that at all. I have a problem when there is a thread about a specific framework and developers from any competing project jump in and advertise their own regardless of the framework or project. Something similar is enforced actually in Austria where comparing adverts are disallowed by law. So that's where my POV stems from. &gt; Is that your definition of an unsuccessful dialog I can give you my definition of a successful dialog: when both parties learn something. &gt; Can you point to some examples? With all due respect, I'm not your search engine and I don't archive links. &gt; You have no problem with Flask being promoted in every single relevant thread, because you created Flask. I have a problem with any unrelated discussion going on in a thread. Pocoo project or not. But again, I can only control what people in the Pocoo team are doing and then again, I don't even have any real control over people there, I can only suggest things and even with that we are not without fault and will probably end up doing things against our guidelines or best intentions. &gt; Your problem is specifically with web2py being promoted, not because you don't believe in such promotion in principle You are mistaken. There just is not any comparable amount of thread hijacking as shown by Massimo. If there is, please show me an example of it.
&gt;&gt;Perhaps, though in lots of real world usage, web2py applications apparently haven't been breaking anything major very easily. That's not to say it's not worth investigating, testing, documenting, etc. &gt;The point is that one should not even attempt to change Python semantics. First, it's not clear this is really changing Python semantics, rather than simply working with a less commonly used aspect of Python semantics. Anyway, I suppose this itself is just an argument about semantics. ;) The real point is whether there are significant practical implications of this theoretical concern. I don't know if there are, but web2py has a long track record, so tentatively I would conclude this isn't too big a deal, at least not in most cases. &gt;You don't gain anything from it besides a few imports less. Well, Massimo suggests there's [more to gain](http://web2py.com/AlterEgo/default/show/271). Perhaps he can hash that out with you at PyCon. Thank you for not running away. :)
&gt; Well, Massimo suggests there's more to gain. Just that this illusion of reloadable code only works in heavily restricted environments. With the same restrictions on normal modules you can still hot reload them, which however does not make this any better. But then again, why is it my job to care about web2py?
The code is now licensed under the GPLv3. Thanks for pointing this out to me. Cheers!
Bitbucket. ...FIGHT!
Woot! My pet peeve averted! One github project down... Thousands more :-) Thanks bunches.
Some tools use certain variable names to tell the code checkers to ignore the warning. I believe PyDev ignores **['_', 'empty', 'unused', 'dummy']**. I can't confirm as I don't use Eclipse, but here's my reference: http://stackoverflow.com/questions/1895615/pythonic-way-to-write-a-for-loop-that-doesnt-use-the-loop-index
Here is another solution discussed here: http://posted-stuff.blogspot.com/2010/01/strange-class-leakage.html import gc execfile('a.py',{}) gc.collect()
That will not work if the class has a destructor as Python cannot clean up circular references with objects with destructors.
The issue is a zeromq problem and would be the same in any of the languages it supports.
Would people here mind posting their impressions of App Engine? I've been thinking of switching over to it so I don't have to pay for hosting, but I've heard some users complaining about restrictions in the past.
Who the fuck cares? It's Python. If it's not fast enough, the speed difference between list.pop() and list[-1] will not change that.
&gt;&gt;Again, missing my points. Let us begin... &gt;How did I miss your points? Well, for example, I was talking about the guys on reddit who make comments and then fail to engage in discussion by responding to challenges, and you went off on a tangent about your personal conversations with Massimo. Interesting, but not related to what I was saying. &gt;I am suggesting that it's inappropriate for anyone to take over threads and advertise unrelated projects. OK, but that's not what you said. You said, "The question is who is promoting it." I was addressing _that_ concern of yours. And for the record, it's difficult to have a "fruitful" discussion if you keep surreptitously changing the topic in between posts. Anyway, regarding your _new_ concern, what does it mean to "take over" a thread? It's not easy to truly "take over" a thread (particularly for just one person to do so) because you'll just get downvoted and fade out of sight. Reddit is not the same as a framework-specific mailing list, discussion forum, or IRC channel where you can reasonably expect to discuss only the specific framework. This is /r/python -- it's not exclusive. Your point is taken about jumping in on threads about other frameworks, but I rarely see Massimo post about web2py in a thread that is exclusively about a single framework (unless someone else brings up web2py and a correction is needed). He's much more likely to bring it up in threads about frameworks in general, or that are at least discussing multiple frameworks. Or sometimes it's in the context of a problem someone has for which web2py could be a viable solution. In other words, the posts are usually quite relevant. Remember, reddit isn't just for you and folks like you who are steeped in Python and know everything about all the frameworks (though apparently many of you don't actually know all that much about web2py either). There are new people here all the time, and they're interested in learning about the Python web development options, and they don't much care if you're sick of hearing about web2py or don't want to see it promoted. They just want information that will help solve their problems. Massimo can't be expected to cater to a handful of regulars at the expense of the broader audience (particularly when it's so easy for you to simply ignore his posts if you're not interested). &gt;I obviously can't control other people, but I can make sure none of the team members do that. And as far as I can see, the same unwritten rule applies to the Pyramid and Django team. Maybe there should be a new unwritten rule. How about the Flask and Django contributors stop "taking over" threads about web2py with completely unsolicited and unfounded attacks on it and its community? &gt;&gt;I was talking about the guys on reddit who post single comments and then run from the discussion when they're challenged. &gt;I don't think they are running from the discussion, they just want to avoid what this thread might be turning into. I hope you can understand that. No, I cannot. If you're not prepared to back up your claims, then don't make them. I'm not screaming insults at these guys -- I'm presenting reasoned arguments and factual evidence, and they won't respond. For example, donri says web2py will have you "dance with unicorns the first few days until you actually need to do something interesting." So I asked for some examples of "interesting" things that are more difficult in web2py than in Pyramid, and no reply. There are multiple additional examples in this very thread, and I could point you to many others. This reflects poorly on the Python community because it shows a lack of intellectual depth and seriousness among its users and promoters. You are the truly rare exception here on reddit. These guys make dramatic claims about web2py and then disappear when asked to back them up. Stop defending them. &gt;&gt;Aside from that, why can't web2py users inform other web2py users of web2py-related threads on reddit? &gt;I don't have a problem with that at all. I have a problem when there is a thread about a specific framework and developers from any competing project jump in and advertise their own regardless of the framework or project. Once again, that's not what you _said_ ("I stay quiet the minute people stop linking to reddit discussions on the web2py mailinglist"), but OK...do you mean you have a problem with [this](http://www.reddit.com/r/Python/comments/ej0p1/new_standalone_web2py_database_abstraction_layer/c18g0va) and [this](http://www.reddit.com/r/Python/comments/ej0p1/new_standalone_web2py_database_abstraction_layer/c18fwcj) and [this](http://www.reddit.com/r/Python/comments/dgbj1/complete_conference_management_system_runs_on_gae/c100iop) and [this](http://www.reddit.com/r/Python/comments/er1eu/run_web2py_with_bjoern_cherrypy_diesel_eventlet/c1a9yd7) and [this](http://www.reddit.com/r/Python/comments/epcxj/the_bottle_web_microframework/c19wk5o)? It's clear that your problem is really with promotion of web2py specifically, not with promotional behavior in general. And as I said, I think it's rare for anyone to post about web2py in a thread exclusively about another framework (particularly if it's something like an announcement). &gt;Something similar is enforced actually in Austria where comparing adverts are disallowed by law. So that's where my POV stems from. You're entitled to your POV, but not to force it on everyone else. Are you seriously saying you're against comparisons -- they seem hard to avoid in life? Maybe you can get Jacob and company to stop _comparing_ web2py to other Python frameworks -- all their complaints seem to be stemming from such comparisons. &gt;&gt;Can you point to some examples? &gt;With all due respect, I'm not your search engine and I don't archive links. With all due respect, if you're going to pubicly malign someone's character, you'd better be able to produce the goods. Human memory is subject to all kinds of biases, so I'm not inclined to trust yours (any more than anyone else's). &gt;I have a problem with any unrelated discussion going on in a thread. Define "unrelated". &gt;There just is not any comparable amount of thread hijacking as shown by Massimo. If there is, please show me an example of it. With all due respect, I'm not your search engine. ;) Actually, you haven't provided any evidence of Massimo "hijacking" threads, so I suppose I can comply with your request for "comparable" evidence by doing the same.
&gt; kill the socket, and reconnect discarding the server that isn't replying. ah, I think I was trying to figure out how to remove the individual connection from the zeromq socket object. It would probably be a lot more simple for me to just do the more traditional (pseucode) def connect(peers): connections = [] for peer in peers: s = socket() s.connect(peer) connections.append(s) return connections as opposed to what the zeromq docs say: def connect(peers) s = socket() for peer in peers: s.connect(peer) return s Though I suppose if I do that I lose many of the zeromq advantages.
The best way to convince people to stop with the premature optimisation is to teach them [complexity classes](http://en.wikipedia.org/wiki/Big_O_notation). Constant factors just vanish. If your profiler says that a particular section of code gets hit most often, and you're desperate to do some premature optimisation, write that bit of code as a C extension. Then chuck out that code and try to use a better algorithm/threading scheme
Unless you're writing a sequencer and it uses pop and/or list[-1] in a loop so often that the 100 ns difference could be a 2-3x speedup...
What does IPython have to do with what you typed?
idle?
I'm not telling you to do anything, I just noted that HCSS has a similar functionality. Like I've repeatedly said, YMMV. For some it might make sense, for some it might not.
I found IDLE in the basic 3.1 install but the one I used was different - Idle has buttons for debugging (step, out, over...) and did not appear to step through the actual source. The other one (gee, it was nice) had Fn keys for the step operations (F10, F11) and showed the stepping in the source file (little balls for breakpoints, yellow or green arrows showing the current source line)
PythonWin. I believe it's a part of the pywin32 package, and was bundled with ActiveState's distribution.
ipython implements the %timeit magic You can use timeit yourself, but the api is a little annoying. you can also use it from the cli like: python -m timeit -s 'x=range(10000)' 'x[-1]' ipython is the just the easiest. It also has %time for timing a single function call. 
/r/appengine would be a good place to ask. 
I thought PythonWin was it, but the doc page shows a completely different interface than the one I used. briancurtin: do you recognize my description of the features, Fn keys, etc? Maybe there are different versions and I need to hunt some more... 
We will add a disclaimer about this in the docs (something like do not define classes with __del__ in models and controllers). Yet, I should clarify something for other readers. This started as a potential issue with web2py because web2py uses exec. We looked into it. Turns out there is a problem with Python garbage collection. This problem has nothing to do with exec, and can be triggered by programs that do not use exec. For example: class Foo(object): def __del__(self): pass while True: foo = Foo() foo.x = foo So even if other frameworks do not use exec, still there may be constructs that cause a memory leak and developers have to be careful. For the record. I am grateful to you for bringing this up. This was constructive criticism. None of our users ever incurrent into this problem so we were not aware of it.
Thanks for the help, much appreciated. I installed ActiveState again, but it gives me IDLE - I can't find PythonWin in the distribution. The Python version I was using with it was 3.1.2 if that helps... 
Makes sense. Thank you!
&gt; The best way to convince people to stop with the premature optimisation is to teach them complexity classes. Constant factors just vanish. The problem is that that's not realistic. Constant factors *really do matter*. That's why we use quicksort when radix sort would work: radix sort maybe O(n) rather than O(n log n) but its constant factors make it slower. Python is not a fast language. If it's fast enough that you're still using it for your task, then it *really* doesn't matter whether you use list.pop() or list[-1]. If your task is the one in a million so close to the imaginary line between "fast enough" and "not fast enough" that you have to wonder about shit like that, just rewrite your program in C++ and take it a long way from that line.
You aren't.
http://tornadoweb.org
I think Mr. Rhodes did more than explain "what a dict is". And FWIW his talk was right after mine in the same room ;) I didn't stick around to watch, I had to go decompress.
I was sad I missed your talk, some jerk schedule mine at the same time :)
I've run into this so many times before where a client believes that because the project is FOSS software that anything associated with it is free to take and use as you like as well. It's a very tough job to convince them and even then I've had a client tell me that it didn't matter because it's not like the project had any money to sue them. Peoples ignorance and mistreatment of what open source and FOSS projects are all about can be very frustrating at times.
Oh god, first slot on the first day! It was nice to get it over with, but it gave one no chance to iron out equipment problems. If you watch the video of my talk you'll notice my Gnome Panels are visible on the projection screen, and there are some notifications from my IM client that I forgot to close. I'm hoping I'm, like, at least after lunch on the first day this year.
Ok, last shot here. It looks like it is pythonwin, and yet I cannot get a clean install on two separate machines. Python 3.1.3 appears to install fine, but pywin32-214.win32-py3.1.exe fails to install with some errors. Can somebody confirm that running these two installs in that order is correct? Anything missing? I honestly don't remember doing anything special when I first installed this some time ago. Whatever I installed then seemed to work fine, and double-clicking on a .py file brought me into PythonWin. Any help appreciated.
I must have missed the bit where I type less. And what do you mean in context?
s/of the day/of the conference ;) I remember intending to go to the GeoAlchemy or something talk and ended up in Brandon's talk because that's where the flow of people took me.
It looks like pygame supports python 3... but partially.
The [timeit module](http://docs.python.org/library/timeit.html) is perfect for this. The [dis module](http://docs.python.org/library/dis.html) is also *sometimes* useful (although often misleading or confusing). It shows the bytecode instructions that are run for a particular bit of code &gt;&gt;&gt; dis.dis(lambda: [].pop()))))))))) 1 0 BUILD_LIST 0 3 LOAD_ATTR 0 (pop) 6 CALL_FUNCTION 0 9 RETURN_VALUE &gt;&gt;&gt; dis.dis(lambda: [][-1]))))) 1 0 BUILD_LIST 0 3 LOAD_CONST 0 (-1) 6 BINARY_SUBSCR 7 RETURN_VALUE
Dude, it's January not April!
&gt;Rated 12+ for the following: Infrequent/Mild Alcohol, Tobacco, or Drug Use or References Infrequent/Mild Mature/Suggestive Themes Infrequent/Mild Sexual Content or Nudity Infrequent/Mild Horror/Fear Themes Infrequent/Mild Profanity or Crude Humor Infrequent/Mild Simulated Gambling This is how they gauge the entire internet? Interesting method...
When I have children, I'm certainly not exposing them to simulated gambling.
I think you'll have to roll up your sleeves and plow the fields yourself, comrade. Such is the state of Python 3 third-party libraries.
Dunno about libraries but there is a free ebook, [invent your own games with python](http://inventwithpython.com) which probably has some pointers.
the bullets (small ones) are supposed to come from the "bow machinge gun" of the tank, the red rectangle. At the end of the video you see the main gun firing black big bullets.
&gt;I've had a client tell me that it didn't matter because it's not like the project had any money to sue them thank god for the EFF. even if they don't take action over stuff like this, it's enough to tell people that they would.
The Morrowind 2011 threads have taught me that reddit thinks stealing others content is a-okay.
That's *really* not the same thing.
the EFF? do you mean the FSF/SFLC?
A follow up question, is there any way to flush your print statements, like you can with sys.stdout?
&gt; This problem has nothing to do with exec That an implicit circular reference exists over the func_globals attribute is something very few people know and it normally does not tend to be a problem due to how the Python interpreter shuts down and because modules stay in cache.
I would've liked to start /r/Cherokee, but it's already been taken :(
Surely this is what the App store's rule and regulations are supposed to prevent? If you reported this to Apple, they should tell the applicant to pick another image.
A while ago I wrote down [my experience with GAE](http://www.xixxeaon.com/page/5007_0_google_app_engine_evaluation.html), I do bash it pretty hard but I mean, I still use it for all my sites. When it comes to GAE what's important is to realize that it can't do everything you want just because it's from Google and they're supposed to be awesome.
&gt; Well, for example, I was talking about the guys on reddit who make comments and then fail to engage in discussion by responding to challenges And what should I reply to that?
list_doubled = [item**2 for item in original_list] success??
Not sure if it's what you're looking for, but I like [RunSnakeRun](http://www.vrplumber.com/programming/runsnakerun/) quite a bit.
They are more appropriate in this context. But thank god for EFF anyway. They rock. 
Anyone know what the apache license says? They also state that their homepage is under a CC share-remix-attribution. If the banner is as well (which it to me seems like it is), wouldn't TurboWeb just have to add attribution? Can someone clear this up?
As an interesting side note, the same app on the iOS App Store would have to be rated 18+, just because it allows "unfiltered access to the internet". Somehow they consider the internet scarier on a mobile device than on a computer.
That's kinda sad as the whole project ("Pylons") is well-known and I imagine that many people would be pretty curious about its future.
I know constant factors technically *do* matter. Marcus Hutter once did a proof that you could get a theorem prover to work in polynomial time modulo a fairly large unknown constant. That constant involves something about automatically generating a theorem prover that works in polynomial time, though, so you don't want to use his algorithm. &gt; Python is not a fast language. If it's fast enough that you're still using it for your task, then it really doesn't matter whether you use list.pop() or list[-1]. That's more what I meant. In my spare time I'm hacking at an old codebase from pygame.org where the original author, a chemist and obvious mad scientist, had picked up a python profiling tool and ran with it. The thing stores its data in and out of pickle, and started out in a single thread for UI and game logic, and he kept polishing it to get rid of little performance penalties like hash maps vs lists, globals vs instance variables, bitblit rectangles vs overwriting, etc. The original code made me have a sad. Even in python, doing audio sequencing, there are better places to put resources than profiling individual builtins. Because of how interpreted languages work these days, the bytecode compiler may not work consistently between your instrumented test case and your live code. If you're grabbing the last item in the list a million times a second, maybe it's time to grab numpy or scipy and do precomputing on a million entries at once in an array or matrix or something. That shit is done in C, and may take about as many clocks as one or two thousand calls to list.pop()
I'm only a teenager, less than minimum wage ;) i have a few computers which i saved up for, and i don't really want to do anything REALLY intensive, just number crunching really...
Hellz yeah.
Thanks briancurtin. Next morning and clearer mind - you were correct it was pythonwin - the install neglected to copy a dll to windows/system32. Once manually copied and the PATH changed, all is good. Upvote for ya!