Nice :) Suggestion: use slicing instead of "del" (shorter and faster) Please forgive my inability to reddit format. phrase = [] for arg in sys.argv: phrase.append(arg) del phrase[0] is equivalent to: phrase = sys.argv[1:] . and: for count in range(int(droprange)): del phrase[0] is equivalent to: phrase = phrase[int(droprange):] . furthermore: for word in phrase: output.append(word) is equivalent to: output = phrase[:] but in this case, you only really need: output = phrase
Best suggestion: Do both.
Or tox, built on pip/easy_install and virtualenv, plus using the new distribute package.
&gt; No, you can write a program that is interactive Oh sure. You *can* do that. The point however is that python provides this functionality for free for all of your code. 
I'll work on it! I'm still learning Python, so it'll teach some useful things to know! EDIT: Fixed derpy language
Oh nice, I didn't even think about using slices. I wasn't sure how well it'd work since it has to drop the first 30% I also used Python2 because I'm not sure how prevalent 3 is yet. It's the default in my distribution, but that doesn't mean anything.
&gt; Ruby always seemed more like an actual programming language to me, I guess because it can be compiled. Even python kinda walks the line. The same could be done with Python, but how does that have anything to do with what is or is not a programming language?
Interactive as in I can enter a command, see the results, and then decide which command to enter next, rather than editing and rerunning a script. The plain Python shell is pretty basic, but it means the tools are there to build a much better shell, namely IPython (or bpython or dreampie, if you prefer). Honestly, ask anyone who does scientific computing with IPython, R or Matlab if they'd consider using a language without an interactive command prompt. What would you suggest instead?
Thanks for golfing my code, it's teaching me a lot! PS - Responses like this and the others that have given code suggestions are why reddit is great. This is a novelty script, but it's still getting serious responses and help!
Do you really want to use FORTRAN or mat-lab? really?
Awesome! You're off to a great start. When I say wrap it in a function, you'll want your function to return results instead of printing them, and then have a separate bit that takes input from the user and prints the results. Outline: def wadsworth(phrase): # do stuff return simplified if __name__ == '__main__': print wadsworth(sys.argv[1:]) You can google the `if __name__ == '__main__'` trick, but in short, it only gets executed if you run the file from the command line, not if you import it from somewhere.
Well it seems to me that certain features in ruby make it more geared towards development then a general purpose language like python. Now I like python, I like the philosophy, and I like the syntax of it. But on this subbreddit, that's apparently like walking in a lane bryant and loudly decrying "Your fat!" and having everyone get silent and give you the stink eye.
 n/i*i+1 is ((n/i)*i)+1. The / is integer division so you're losing any remainder, and ending up with the greatest multiple of i less than n (plus 1).
If I am doing exploratory work I will write a script it is very convenient, write save and rerun is trivial plus I have a record of things for later use. About the only thing I use the interpreter for is for very short test cases. You are contradicting the opening argument, that python is the only choice by offering other choices. Python is not the sole tool to do the job, there might be other reasons to use python. Claiming you like python because of the terminal is fine, but that is not everything there is to interactive programming.
No and no, I just do not support that argument that python is the only tool to do scientific computing. It is like saying scientific computing began in 1991.
I've never understood the "actual programming language" argument. Either your code does what it's supposed to in an acceptable amount of time, or it doesn't, regardless of language. The only thing I care about is accomplishing a task.
What is the difference between this and tdaemon?
&gt; Well it seems to me that certain features in ruby make it more geared towards development then a general purpose language like python. Like what? These types of comments come up but rarely see support, plus the sentence barely makes sense. How can a programming language not be geared towards software development, or less geared towards development than another one? What else is it used for?
The original point was that Python spans a wider range of use cases than most, perhaps all, other languages. I don't think I've said anything to contradict that. I use saved scripts, modules and packages as well, but I wouldn't give up my interactive shell. IPython keeps a record of all the commands I've entered, and I can save a subset of them as a script to reuse. And even when I run a script, I often do it from inside IPython, because I can debug uncaught exceptions. Seriously, if all you've tried is the &gt;&gt;&gt; shell, you're missing out.
Here's a very quick fix (it's not going to make what you've done super pythonic or anything, but you should see some more optimal times): instead of generating the Sieve every time, generate the sieve once, and pass the sieve to the isPrime function. Then you aren't regenerating the Sieve every time. Edit: I've always liked this implementation of the Sieve. def sieve(end): '''Using the sieve to find all primes up to a given number ''' if end &lt; 2: return [] lng = ((end/2)-1+end%2) sieve = [True]*(lng+1) for i in range(int(end**0.5) &gt;&gt; 1): if not sieve[i]: continue for j in range( (i*(i + 3) &lt;&lt; 1) + 3, lng, (i &lt;&lt; 1) + 3): sieve[j] = False primes = [2] primes.extend([(i &lt;&lt; 1) + 3 for i in range(lng) if sieve[i]]) return primes 
Huh, I was working off of urllib3 and such. I wasn't really sure of a convention of it being blessed, but that does make sense. I've been trying to think of a more original name that still encapsulates the idea. I'll definitely change the name when I can find something decent.
I discussed the Sieve of Eratosthenes at [my blog](http://programmingpraxis.com/2009/02/19/sieve-of-eratosthenes/). The comments give versions in several languages, including Python. You should be able to sieve the primes less than a million in less than a second. Phil
You haven't really shown that python spans a wider range of use cases. You have just touted the terminal and now IPython. It sounds as though you haven't used a compiled language with a debugger. The claim that python spans a wider range is not correct. The main article primarily talks about perl, ruby and python. All three of which 'span the wider range of uses' mentioned above. Or, if you have the license, matlab also spans these cases. Plus the original statement by Howardula contains a list of tasks, that can definitely be performed by c, c++, java and more.
I'm very confused by your post. What would "geared towards development" mean if not a general purpose language? I am also curious what Ruby features you're referring to make Ruby "more geared towards development". Maybe you meant web development? That statement would make a lot more sense in that case.
&gt;Guido recognized his initial mistake and made floating point division the default in Python 3 You know, I've never actually spent much time looking into Python 3, but this is almost enough to make me pull my finger out and make the switch. I love Python 2.7 but this has been one of my pet hates.
Ruby has the potential to span the same range, but the tools &amp; community for scientific computing aren't there, as far as I know. Perl lacks an interactive mode, and I wouldn't really want to use it to build a larger system, although it is clearly possible. C, C++ and Java all have their strengths, as does the .NET platform, but as far as I know none of them have the same sort of interactive ability. A debugger is also a very useful tool, but it's not a substitute for a proper interactive shell. The main alternatives to Python for the sort of interactive programming I'm talking about are R and Matlab. But they're more specific, without the general programming tools that are prevalent in Python. Shall we call this discussion off? I'm clearly not going to persuade you of the importance of an interactive shell, and I'm not about to admit that it magically doesn't matter.
Yes, but is that treated any differently by the stepwise-slice operator (or whatever that three parameter slice is called) than simply "overrunning" the array? Messing around with the command line interpreter I didn't find any results that were different between the two; they returned the same slices. Intuitively the :: would be faster (but of course, what's intuitively faster is often not the case especially in python!)
Obligatory self-pimping: http://pypi.python.org/pypi/PyZen/
While I have python installed, and I use it. I would not decide to use it for a project based on the fact it has an interactive shell. You have some good arguments in your post about why python is better. They are much better arguments than the incorrect argument that python does something the other languages cannot.
Continuing on what is said here, good ways to use the sieve would be to check if a number is prime: s = sieve(x) isprime = x == s[-1] Also, to get the `n`th prime, check that the list from your sieve has at least `n` numbers (if it doesn't, pick a higher limit) and then return the number at that index: s = sieve(2000) # 303 primes in the list p = s[199] # p is now the 200th prime
Ruby does just fine as an IT programming language as well. I work with tools written in both quite often. When it comes down to it, both can accomplish the job the same, and with comparable speed, so it comes down to whatever the programmer prefers to write in. Myself, I prefer Python, just because I can write it much faster, and if I need to pseudocode something first, I can go from pseudocode to Python *very* easily. Also, Python's standard library is extremely convenient, and the dir() and help() functions on the interpreter are extremely handy.
OK, but for the sort of things I do, an interactive shell is pretty much a requirement, and I can't see myself using any language without one. I haven't asserted that Python does anything other languages can't. The argument is that no one language can do such a range of things. If you're a serious programmer, it's not an issue, because you'll learn several languages anyway. But for scientists, if you can get by with just one programming language, great.
I guess I'm in the minority here in preferring integer division (when dividing two integers). I may be biased since I came from a C/embedded background but the pre-3.x behavior always seemed more natual. That being said, while I like python strong typing, I don't know where I would draw the line. I enjoy '5'\*5 == '55555' but Lua's '5'\*5 == '25' squigs me out a bit. For division, type(int(x) / int(y)) == int just feels safer on some level. It also means I have little bombs waiting for me when I convert some of my libraries to Python 3 in the not too distant future...
2to3 will catch your "little bombs" and turn them into `//`, which means integer division in Python 3.
There's also the issue of maintainability. There's an argument to be made for declarative static typing that it helps in the development of large projects by making idiot proof contracts for data types. I personally think that the benefit (being able to use dumber developers on a project) is not worth the cost (annoying language syntax), but others disagree.
For some reason 2to3 doesn't catch this for me. When I run it on: x = 5 y = 3 z = x / y print z assert z == 1 The only change it makes is to the print function. 
Tell him how to redirect the output to a file. &gt; your_script.bat &gt; output.txt
Thankyou very much! I'll look into this more on the weekend. I did try hplip, both from repositories and the site, and neither worked :(
Maybe some just think the notion that ruby is more compilable and this is means it's more of an actual programming language is goofy.
You mean siv[2*i::i] . Yes it is the same.
Would a decorator work here?
Make your own file-like object and overwrite `sys.stdout` to it. For example: import sys import StringIO class DoubleFile(object): def __init__(self, file): self.file = file self.buffer = StringIO.StringIO() def write(self, bytes): self.file.write(bytes) self.buffer.write(bytes) def getvalue(self): return self.buffer.getvalue() sys.stdout = DoubleFile(sys.stdout) print 'Hello world' print sys.stdout.getvalue()
I use Ruby for short little scripts because it handles `exec`ing well and has much less annoying regex support. I use Python for things over 200 lines because the lack of monkey-patching, explicitly-filename modules, docstrings, and named function args make it more maintainable.
Can you try using "tee"? It splits the output so you can have it print to screen as well as a file, for example. 
I have it *almost* working! I need to convert the input into a list and then I can post the fixed version. 
I can Google "single exit point" and get c2.com/cgi/wiki?SingleFunctionExitPoint as the first result just as well as you can. Is this supposed to be convincing? Do you really have any reasons for believing this voodoo nonsense? Or are we just having an internet argument where you refuse to be wrong? I've given you two high-profile, highly-used examples of software that extensively utilize the very practice you say is utterly verboten. You give me some 10 year old FAQ page from a small consultancy company that probably doesn't even exist anymore.
Nope, I don't take any computer sciences courses (as much as I'd like to!), but I'm they weren't offered at my school :S
I thought about that, but I wasn't sure how to set an appropriate upper limit for the sieve depending on the input for getPrime()? Like, I'd need to know ahead of time what the requested prime was to be able to set the upper limit? 
One way to get around that is to change the order in which you're doing things. Consider adding a number to your sieve (increasing your upper limit by 1). You would have to make sure that it's prime, right? And how do you do that? You have to check whether it's a multiple of the primes you've found so far. So, instead of applying each filter, one by one, to the entire list, why not apply all filters to each number, one by one? A feature of Python that is absolutely perfect for this is generator functions, due to its lazy nature.
That's not what they're saying. They're saying that no other tool has such a vast range of applications.
import easeofuse
Hmm, I guess I was wrong about that. Anyway, you can use `//` even in Python 2, so starting to use it now is always a good practice.
You don't have to mess with `sys.stdout` if you're willing to write `print &gt;&gt;my_double_file, "Hello World"` instead. (Or the hella classier `print("Hello World", file=my_double_file)` in Python 3.)
You're converting a float64 constant to float128. Try float128(10.)**25. The other uses might be problems inside numpy, e.g. In: (log10(float128(10.)**25) - float128(25.))/float128(25.) Out: 6.9388939039072283775e-20 Quad precision shouldn't be necessary to solve the friedmann equation in normal circumstances, however, why do you think roundoff error is a problem for you?
Thanks, I was worried I might be doing something dumb like that. I'm not really worried about rounding errors messing up the results. I'm just using this as a sandbox to play around with arrays and approximations in Python.
You're better off sticking to double precision, then. Even single precision should be fine, provided you choose the right integration variable.
I never even considered trying float32. I basically re-did a program I half-remember writing in Fortran years ago and went with doubles from the start because that's what I used then. Could be interesting to see how different integration methods work with the lower precision. Thanks for the suggestion.
Not sure why you've been downvoted? Yes, a decorator could help in this situation. I think you may have been downvoted because people either don't know what a decorator is or that they think that decorators are too complex for the OP.
&gt; Do you really have any reasons for believing this voodoo nonsense? That's not the question. The question is whether you can find an counterargument to a well-established principle of computer science. Your having resorted to of rhetoric like "voodoo science" suggests not. &gt; You give me some 10 year old FAQ page from a small consultancy company that probably doesn't even exist anymore. On the basis of that stellar argument, Einstein's Theory of Relativity ought to have expired by now. No? Maybe you need to learn principles of debate. The fact that something is widely practiced is not an argument in its favor. Science is not a popularity contest, it is a scheme where useful ideas prevail over useless ones, but not right away, and not when people try to argue for ideas based on popularity. 
A handy module for something like this is `fileinput`. See [the documentation here](http://docs.python.org/library/fileinput.html), but the basic usage is simple enough: import fileinput for line in fileinput.input(): process(line)
&gt; But I'm not sure how to generate the appropriate 'colors' required. Assuming a white background, you would like the colors to fade toward white as their significance declined. So treat each of the RGB color components separately. A function f(w,c,v) can be used to move each of the RGB color components **c** toward **w** (255 in this case) as its argument **v** declines from 1 to 0: * f(w,c,v) = (c - w) * v + w Where: * w = the saturation color, white (255) in this example * c = color to be modified * v = modification factor, 0 &lt;= v &lt;= 1 For a 50 % reduction in saturation, a given RGB color {192,170,128} will change like this: * R = f(255,192,0.5) = 223.5 * G = f(255,170,0.5) = 212.5 * B = f(255,128,0.5) = 191.5 
Here's my version: def wadsworth(text): start = int(len(text) * .30) first_space = text.find(" ", start) if first_space != -1: start = first_space + 1 return text[start:] if __name__ == "__main__": import fileinput print wadsworth(''.join(fileinput.input()))
Uparroẃ for you. 
Pass the z-value to c, and then setup a colour map. from matplotlib import mpl plt.scatter(x, y, c = z, cmap = mpl.cm.jet) Also, you mention that it's a large file, but I would really try and avoid constant hitting of plt.scatter.
Ooh! This could quite possibly be the best thing ever. Have raised an issue due to the rather weak Auth, though :) Documentation is shaping up well, too - that will make or break this project, honestly.
looks interesting... but is this now a orm extension or an admin gui extension or an auth extension or a rest extension? i prefer flask over django, because it does *not* do everything. i can put pieces together one by one. can i use the auth and admin stuff from this extension with other orms, like sqlalchemy?
You may like this project as well : https://github.com/mynyml/watchr It's code with Ruby, but it can run test on every language. The point I like is it may run only the test file corresponding to the file you've just modified, if you set the configuration nicely. Worth a try.
I guess this is more like "django type stuff" for people who use Flask, but don't want to re-implement this stuff.
Ruby and Python have [very close](http://viewsourcecode.org/why/hackety.org/2008/05/05/sneakingRubyThroughGoogleAppEngine.html) semantics. Both are quite dynamic, and to run fast they need JITs, not compilers.
The stackframe manipulation isn't too evil. It just tells that the namedtuple class definition should be looked up in the module that calls `collections.namedtuple`, rather than in the `collections` module. 
&gt;...you can only do this with Python. That is an incorrect statement. Your statement is incorrect too. Just because you personally can only do that with python does not mean python is the only tool with such a vast range of applications.
Thanks for bringing this up, your comments on GH were helpful. Will be fixing this today! EDIT: this is fixed. now uses similar approach to django's auth app.
Looks like it's an admin that relies on peewee, wtforms, and wtforms-pewee. I'm currently working on an SQLAlchemy / WTForms admin interface that takes a similar approach, as far as registering models, using a sensible default but allowing the model admin to be overridden, etc. - though mine doesn't look *nearly* as good as this one - I suck at css and just applied [fluid960gs](https://github.com/bauhouse/fluid960gs) to it so it wouldn't be black text on a white page. (:
flask-peewee is BSD licensed so you should be able to leverage some of Charles' work here. It goes without saying I would heap the largest rewards on someone who can produce a compelling alternative to the Django-admin tool for all of us using SQLAlchemy.
Very nice, but I must pick a nit. You may want to reconsider red submit buttons. If any button is red, it should be a cancel/reset/back button.
&gt; flask-peewee is BSD licensed so you should be able to leverage some of Charles' work here. It goes without saying I would heap the largest rewards on someone who can produce a compelling alternative to the Django-admin tool for all of us using SQLAlchemy. Since everything of mine gets released BSD as well that works for me! I'll try to get it cleaned up (it's just an internal app right now) and on either github or bitbucket, I'd planned on releasing it as a flask extension eventually but hadn't realized there was that much demand.
Python seems (or at least when I first started using it 7 years ago) to have a richer Eco-system for Unix system scripting. Python's consistency and readability is not to be underestimated also.
I have a script that pretty much does this. I have a data file that can be quite large. I can post it and the results if you want. I use two color patterns. Standard blue to red, and also a strict Blue &gt; Green &gt; Red (like gnuplot). 
Is it bad that [this](http://3.bp.blogspot.com/_20O0OD-wMuc/TCbmi8BzabI/AAAAAAAAAPg/rcOWD5cyQ0I/s400/lyle_beaker.gif) was the first thing that I thought of when I read the title?
It looks like it's just aclone of the new Google apps design.
If you know how many "buckets" you want to group your values in (e.g., 1 color for top 10%, another for top 20%, ...) you might define a sorted list of (percentile, color) and use the bisect module to find the color.
You're saying that fileinput works for stdin? If that's the case, I'll give it a try.
&gt; Yes, a decorator could help in this situation. How?
If he's using 3+ he can decorate print after overloading it so that it redirects to an output. If using 2.7 and below then I'd say it'd be an annoying job of replacing the print statement lines with a function that outputs to a text file instead. I can't quite tell if the OP has a .bat file, a .py file or a compiled .py&gt;exe file, but yeah a decorator could help. Why do you not think so?
&gt; If he's using 3+ he can decorate print after overloading it so that it redirects to an output. What for and with what he would decorate the overloaded print? &gt; If using 2.7 and below then I'd say it'd be an annoying job of replacing the print statement lines with a function that outputs to a text file instead. And how a decorator would help? &gt; I can't quite tell if the OP has a .bat file, a .py file or a compiled .py&gt;exe file but yeah a decorator could help. What. How any of that is relevant to decorators? &gt; Why do you not think so? I would gladly begin to think so if you would explain how a decorator could help. Until then it seems that in fact it is you and the thread starter who "don't know what a decorator is", but want to appear knowledgeable.
Ahh this again. If he's using 3+ then print is a function and not a statement, therefore he can just create his own custom version of print, decorate it and he doesn't have to mess with the rest of his code that he's already written. Let me explain: @redirect def print(*args) #usual print code This way all he has to do is create the redirect function to print to an output. If you learnt to read, then I said in 2.7 this would be hard and he probably would have to go through and change the lines that use the print statement (because print is not a function in 2.7 and below) to his custom function that both prints and outputs to a text file. I was mentioning the uncertainty of what the OP actually had because in the OP he said that he has a batch file, then said it was a .py file converted to exe. Then said he would take the advice off someone about using a class someone posted. A decorator could help in a single case, which is the 3+ version of Python, not in the others, which I didn't say it would. You're a fucking dick btw. 
What does `redirect()` do and what is a `#usual print code`? If you override print, then you do it along the lines of: def print(*args): # format args into a string # dump it to the file # dump it to the stdout I for the life of me can't see how a decorator can fit into the picture. Though I can kind of imagine how someone who has only a vague notion of what decorators are and how they are used could get an idea that maybe they are applicable here somehow. That's not a reason to share this valuable insight, though. &gt; You're a fucking dick btw. Thank you, if people like you tell me that then I must be doing something right.
Sorry, but those slides are basically meaningless unless you already know and understand most of what they say anyway, and the constant sock/foot/shoe thing is just annoying.
Thanks for the help, this is exactly what I was looking for. Agreed, I was worried about memory usage but it seems that is preferable to the huge time calling plt.scatter 1M times takes.
but it has all the buzzwords we look for. :)
OP: Did you get it down to 1 line as he mentioned in the extra credit? If so what did you use? Mine: open(to_file, 'w').write(open(from_file).read())
This is just a guess - you have 2 columns in pointxy which can be null, x and y, and one which is a primary key and can't be null. This would mean that the engine would expect to be able to create an instance of that object with 1 parameter, the primary key, leaving the others null. Does adding 'nullable=False' to those Columns help at all?
Have you read through [this](http://www.doughellmann.com/PyMOTW/csv/index.html)? If you absolutely need a list of tuples, you could do something like: flist= [tuple(row) for row in csv.reader(open(filename, 'rU'))] 
Thanks a lot! This is a really good resource
For your usage, I think you can get away with with open('file.csv') as csv: for line in csv:` flist.append(csv.split(', ')) word, value = csv.split(', ') # if you want to act imediately as a follow up, here is what your code is doing: for the index of each letter in row let row be the tuple (row) append row to the list
 import csv f = "path\to\file" data = csv.reader(open(f)) li = [] for line in data: li.append(tuple(line)) For a non-in-line version of what he put.
1. Copy the file pointer for stdout (`fp = sys.stdout`) 2. Create a fake file object with method `write()` that writes to `fp` and to your file 3. exchange `sys.stdout` and the fake file object 
What you said is the truth, but it can make duplicated codes e.g.: print&gt;&gt;dobule, 'Hello', print&gt;&gt;dobule, 'world' If you want to redirect printed strings to the file object explicitly but without duplication, you can define a context manager like: import contextlib import sys @contextlib.contextmanager def redirect(file): o = sys.stdout sys.stdout = file yield sys.stdout = o with redirect(DoubleFile(sys.stdout)): print 'Hello', print 'world'
No problem. Do take a look at the links I gave as examples - I'm not sure how Django's does it, but MD5/SHA-1 are history.
Your head is in the cloud.
There's no way this is web scale.
They suggest nginx, gunicorn, and gevent. For people new to python, or those coming from a apache/php background, who are wondering 'huh'? **Nginx** is just an (very quick) HTTP server. In your python web app, it serves a few purposes: * It takes care of sending the client any static files, ones that the python code shouldn't be worrying about anyway. (background images, etc). * It caches output from your python application. If the user were to ask for the same resource twice, the cached result would be sent back on the second request. This keeps your python application from being overwhelmed with requests. It also means you don't have to worry about the 'simplest case' cache, though other thoughtful caching in the application can be a good idea. **Gunicorn and Gevent** are, in this context, working together. Gunicorn is another HTTP server, in this case one that spawns a number of workers to deal with incoming requests. Gevent is a library which provides Gunicorn with workers that don't block while waiting for stuff. So, here's what you should keep in mind when deploying your app: * Your application will run slower than fetching a cached response. * Cached responses also help with DOS attacks. * Static files should be served by a 'vanilla' (read:fast) http server. * Running more than one process is good. I'm skipping a lot of details here (because I don't feel like I have a good enough understanding of the topic to not get something wrong). tl;dr: The authors (Tarek Ziadé and Benoît Chesneau) suggesting running your python web application behind Nginx, and Gunicorn+Gevent, because it solves a lot of problems. 
life is too short for that much xml
I think I skipped that one.
Anyone curious how Nginx and Gunicorn+Gevent would fare compared to Cherokee and uWSGI? Ignoring Apache and MOD_WSGI, we have: * Lighttpd, Cherokee, and Nginx can serve as a front end / proxy server. * Gunicorn, uWSGI, CherryPy, Twisted, Tornado, Gevent, etc. can serve as the WGSI server. (Not to mention setups like Gunicorn + Gevent or other combinations). No one can say there's not a lot of choice for their next Python web application deployment! 
Have you tried [virtualenvwrapper](http://pypi.python.org/pypi/virtualenvwrapper)? Now you can just type 'workon' to list environments or 'workon project' to activate environment 'project', as well as many other great additions to virtualenv.
Nice oxymoron you've managed to sneak in the title there.
You can always convert a list to tuple: &gt;&gt;&gt; a = [1,2,3] &gt;&gt;&gt; a [1, 2, 3] &gt;&gt;&gt; b = tuple(a) &gt;&gt;&gt; b (1, 2, 3)
Of course I'm dumb. I create all these extra surfaces and blit from them freely. Turns out beyond just the creating the scaled frame, where I was focused the last couple of days, I just had another blit going on, that I didn't even realize. Thanks for the help. 
Welp, I've gotten it figure out, thanks for the help guys. Of course it was my fault. I create all these extra surfaces and blit from them freely. Turns out beyond just the creating the scaled frame, where I was focused the last couple of days, I just had another blit going on, that I didn't even realize.
Mmm, this is *relevant* to my interests. The idea is awesome, but I think the way it is currently is setup is a little bit inflexible, especially because of the focus on hostnames. But, on the other hand, that's also a neat thing, being automatic and stuff. I think I need some more time to think about this. ;)
&gt; Anyone curious how Nginx and Gunicorn+Gevent would fare compared to Cherokee and uWSGI? with a bare-balls benchmark, you'd probably get better numbers with cherokee/uWSGI as they are both very fast. uWSGI can also be used with nginx (there's a module for it). How bout running some tests and reporting back? Once you throw in template rendering and database access, though, those raw numbers aren't going to be as big of a deal. Personally, I prefer Gunicorn because it's super easy to set up and configure, and has a good feature set. It's fantastic that we have a lot of options! WSGI makes it really easy to switch technologies based on your needs :) 
Am I missing something? According to the wealth of detailed information here, gunicorn+gevent does little better than the tried and true apache+mod_wsgi, so why is the advice not nginx+apache/mod_wsgi? Is it just to be different or hip? It certainly can't be for the tiny performance gain over a battle tested stack?
Just be aware that CSV files with escaped or quoted commas may not be parses properly. I usually just add the extra line to create a CSV from the file handle.
Call me pedantic, but I find it very unpythonic to use an explicit loop to create a new list from an old list when a list comprehension can adequately express your intention. li = [tuple(row) for row in data] says exactly what you mean and provides a good opportunity for an optimizer to understand your intention and speed it up. List comprehensions are, to me, one of the most useful language features of Python. I am a mathematician by training though, so that may color my opinion.
Agreed, the slides don't have enough information. Was there a video recording of this?
It's sort of like stdin, but if there are command line arguments, it treats them as file names and reads them in instead of stdin. It's an easy way to make a flexible command line utility.
CSV files can look like, "blah","bla, blah","blah" so you shouldn't split on ",". Parsing CSV with splits reminds me of using regexs for HTML. Use a real CSV parser.
Not entirely. Nginx is an exceptionally bad dynamic content cache, I would go with Varnish if you are looking to cache dynamic content. On a website I help run, I use nginx as a load balancer and static asset cache from my php servers. To prevent DoS requests, its probably smarter to limit the amount of connections/requests per second that a client can perform. We serve approximately 100 or so million requests per day for static content, and between 1 and 2 million requests for dynamic content. Gunicorn is not only just a http server. Its also process manager. It basically creates a socket, and passes it to all the workers, whom accept connections from it on a first come-first serve basis. Gevent is technically not an http server either, but rather a library that allows python to cooperatively multitask while waiting on IO, this implemention is transparent to the programmer, as it performs all the cooperation in a clever way using green threads, to switch between coroutines, as opposed to the traditional callback based asynchronous programming paradigm (Twisted, Tornado,...) Gevent however provides a wsgi server built in which will act as an httpd. Gevent can be run on it's own, completely independent from gunicorn.
Correct me if I'm wrong, but isn't lighthttpd a dying project?
You mean `f = "path/to/file"`. Using \ makes the parser confused when you have `\n` or `\t`, etc. and /, though more common to see in Unix, also works in Windows as `C:/whatever`, though it looks weird. Remember kids, always use slash, not backslash, for file paths, even on junky old Windows!
That's good advice for someone who knows what they're doing. "Don't reinvent the wheel" etc. But look at this dude's code: he clearly is very new to Python, very new to how the for-loops work, etc. It's better for someone just starting out to do something simple that they understand completely than to use a tool that is more capable but which they can't understand.
Partly to be hip, but also because nginx/gunicorn is more tolerant of users who don't bother trying to configure/tune their systems properly. Apache/mod_wsgi suffers from the problem that Apache systems are generally setup for static file handling and PHP. Running Python web applications requires a different sort of configuration to make them run well and not blow out memory usage etc. Luckily the majority of people never have sites which get enough traffic to really cause a problem and they live on totally ignorant of the fact that their Apache/mod_wsgi configuration is crap and not well suited to fat dynamic Python web applications.
Other people on the page have solved the problem of how to do what you want, so let's look more closely at what your code does and why that doesn't work: for row in f: for i in range(len(row)): row=tuple(row) flist.append(row) So, the first thing you do is look at the line in `f`. That's a good start! But immediately after that you have another for-loop. Let's say you had a sample file like: abc, def ghi, jkl What will happen? First `row` is set to `"abc, def\n"`, because that's the first line of the file. (Notice the slash n, which means "end of line.") Next `i` will be set to something. What? Well, you asked for a range of the length of the row. In other words, `i` is going to be set to zero first, then increasing numbers up to (but not including) 9, which is the length of the row. Do you want that? No. That's not what you were trying to do. Begin long digression: As a general rule, in Python, if you're tempted to do `for i in range(len(whatever))`, take a step back and think about what's going on. That's almost always the wrong choice for Python—even though it's a natural choice for many other languages, like C++ and Java. For example, sometimes new Python programmers do this: items = [ "one", "two", "three"] for i in range(len(items)): print l[i] # Or print(l[i]) if you're using Python 3. This works. So, it's not completely wrong, but it's not the Python way. The Python way is much simpler: items = [ "one", "two", "three"] for item in items: print item # Or print(item) if you're using Python 3. Much simpler! But, you may ask, "What if I really need the index!?" `range` is probably still the wrong choice. Instead try using `enumerate` instead. It will return the index and the value at the same time. For example: items = [ "one", "two", "three"] for index, item in enumerate(items): print item, "is item number", index This will output: one is item number 0 two is item number 1 three is item number 2 Again, this code is much simpler and more "Pythonic." OK, long digression aside, what about your code? After going to all the trouble of getting `i` to be equal to numbers 0 through 8, do you ever use it? No. It's not used. Instead you have `row=tuple(row)`. Since we haven't changed the value of row, all we're going to do is execute this line and the next 9 times in a row! If we drop into the console, we can do a test of how this will work: &gt;&gt;&gt; tuple("xyz") ('x', 'y', 'z') Hmm, doesn't look like what you want! If we did it to our test input, we'd get `('a', 'b', 'c', ',', ' ', 'd', 'e', 'f', '\n')`, which is not what we wanted! And since this is followed by an `append`, we're going to end up appending this same junk 9 times in a row, followed by a junky version of "ghi, jkl" nine times in a row. As other people have pointed out, the easy way to split a string is using the `.split` method. Or you can use the CSV module and it will split stuff for you. But what if we wanted to split this manually for some reason? Well, we'd want to look through the string to find the comma, then make two sub-strings, one from the front half and one from the back. It would look something like this: for index, character in enumerate(row): if character == ",": splitting_point = index first = row[:splitting_point] # The brackets and colon are how Python does "slices" of lists, strings, etc. # Learn about this if you haven't already! second = row[splitting_point + 1:] #Plus one to skip the comma. t = (first, second) flist.append(t) break #This means "quit doing this for-loop, I'm done with it now" If this were your inner loop, it would have done what you wanted. Hope that clears things up!
My one lined approach: (lambda s:(lambda r:s.stdout.write(r[r.find(' ',int(0.3*len(r)))+1:]+'\n'))(' '.join(s.argv)))(__import__('sys')) `$ python wades.py "This shit is bananas!"`
Considering that the correct version is as easy as [this](http://www.reddit.com/r/Python/comments/l0q4e/how_do_you_import_a_csv_file_as_a_list_of_tuples/c2otpxg) then I don't think it's any simpler to do string splitting.
It's definitely roflscale. 
Gevent monkey-patches the I/O and Socket modules in Python to mostly make those modules asynchronous without code changes but your application can still block. If you use PIL or another C library (maybe mysqldb) it will freeze ALL connections on the single thread if it blocks inside of those modules. I might be wrong about that detail, someone jump in and 'splain if so. Generally speaking I normally choose to stick with standard Python (no Gevent) for normal web apps. If there is something that needs an insane amount of connections I will use a small stripped Python app with Gevent or NodeJS or similar.
&gt; Well, we'd want to look through the string to find the comma, then make two sub-strings, one from the front half and one from the back. It looks like you want row.split(maxsplit=1). Iterating over a large string can be ridiculously slow. I think you may also run into problems with 4 byte Unicode characters.
Hi, i love to hear that it could be useful to you. You are right that the implementation is not very customizable. The idea was to make a very simple implementation and then add hooks or something to extend the behaviour. The good news is that it is only 200 LOC ;) Drop me an email if your are interested or have a proposal.
Gunicorn *is* an http server, as far as I can tell. You don't need to use Gevent with Gunicorn, but it seems to be the recommended way to go. By default, Gunicorn will use sync workers. From [this](http://www.go2linux.org/linux/2011/04/nginx-varnish-compared-nginx-941) comparison, it looks as though nginx is not a bad dynamic content cache compared to varnish+nginx. Probably different for every deployment/app/configuration. Why do you say it's exceptionally bad? Not doubting you, just curious. 
Maybe! Though the redmine site looks like it's still pretty active. http://redmine.lighttpd.net/projects/lighttpd
This little teasing made me smile ... and the (imagined) furious downvotes too.
When I say "simple" I don't mean lines of code, I mean "easy to understand how it works." Using the csv module is simple to do but multiple_cat isn't going to learn how to solve future problems by just being handed an answer like that.
Gunicorn is an http server, yes. With gunicorn you have a choice of workers. The simplest one is the synchronous server, which is a straightforward prefork server model. It's very simple, easy to reason about, and good for CPU-intensive loads. If you use the gevent or eventlet workers, then they monkeypatch the Python socket and other modules to do cooperative multi-tasking; that's a good use if you can stream the result or if you're requesting or proxying to slow servers. Consider a facebook login or the like -- if facebook takes a bit of time, then the sync server would block an entire worker. But a gevent/eventlet worker would yield while waiting for other requests to execute. A combination of these methods can yield very good performance, and if you default to sync workers you can switch to the gevent/eventlet workers when you an reason about them and be confident they'll perform correctly.
*Just to make sure the information's available on the multiple submissions of this* [Jason Scott just updated with two tweets](https://twitter.com/#!/textfiles): &gt; Mark Pilgrim is alive/annoyed we called the police. Please stand down and give the man privacy and space, and thanks everyone for caring. --- &gt; The communication was specifically verified, it was him, and that's that. That was the single hardest decision I've had to make this year.
You're right about gunicorn being an http server when its using synchronous workers, but with all other workers, gunicorn just servers as a process manager. I've corrected myself, above. Nginx lacks the fine grained control that varnish provides with their VCL scripting language. A simple use case: You're hosting a simple blog, using a default install of nginx with all the modules, (excluding third party.) For this example, there are no logins, and anonymous comments. 1. You submit your entry, nginx proxies your request to python when you load the article for the first time. 2. The article is cached by nginx for let's say 1 hour. 3. A user posts the comment. 4. Python has no way to tell nginx that the article has changed, and to purge its cache. 5. User refreshes their page, but their comment will not appear for another hour as nginx is still serving (a now stale) cached page. There is a third party module for nginx that allows you to PURGE stuff from its cache, however. There are plenty more use cases where varnish accelerates at dynamic content caching (bear in mind, varnish was created to do exactly this). Varnish also comes with a plethora of tools: varnishtop, varnishstat, varnishlog, varnishreplay, ... which provides a lot of information as to what is going on inside varnish. Nginx was not designed to be a highly configurable caching proxy, but rather just an http/mail proxy/load balancer, and static content server. 
Asynchronous workers really shine when you're looking to keep a whole lot of connections open at once (comet, websockets, ...), or where you're performing blocking IO within a worker thread that could otherwise be performed asynchronously.
So long and thanks for all the dives…
Always seemed like overkill to me. I just always put the env in a dir called "env" in the root of a given project, so the command is always "source env/bin/activate" for me -- quite easy and painless. Thanks to OP, I decided to put `test -f env/bin/activate &amp;&amp; source env/bin/activate` in my shell startup script, since I tend to cd into a project directory and then start screen, which launches a new shell anyway -- now the environment will automatically be loaded. :-)
So that's why I was having a WTF reaction! Perhaps a better illustration is this: with open(file_name, 'rb') as f: reader = csv.reader(f) for row_number, row in enumerate(reader): print row_number + 1, " | ".join(row)
Awesome info, thanks! Edit: nginx does have http://wiki.nginx.org/NginxHttpProxyModule#proxy_cache_bypass, but it feels like a bit of a cludge. So varnish sits in front of the wsgi server, but behind the static file server / load balancer? Gotta do some research for our next deployment. :D
Maybe I'm missing something here (this is the first time I've ever used a decorator), but what's wrong with this: a = [] def redirect(fn): def wrapped(s): a.append(s) fn(s) return wrapped p = print @redirect def print(s): p(s) print("hello") Edit: I realize this may be over-complicating things a bit, but it is possible. a = [] p = print def print(*args): s = ' '.join(args) a.append(s) p(s) This seems like the better solution here.
I ended up writing [my own script](https://github.com/zachwill/wadsworth_constant/blob/master/wadsworth.py) for this, as well.
It was uselesspython.com and it seems to have gone offline. Here's a link to the wayback archive, though many of the scripts are unavailable. http://web.archive.org/web/20100213102932/http://www.uselesspython.com/
Also checkout [meinheld](https://github.com/mopemope/meinheld) as an alternative to gevent. It scored higher on benchmarks, and has a gunicorn worker.
What I'd find more interesting is resources on how to write applications in order to take advantage of all this async stuff. How do I make sure that, for instance, that socket based I/O wont block the rest of the process?
No! Of course, I agree. That's how I *would* do it but I remember when I was learning this, comprehensions were sometimes uncomprehensible. I put it there to explicitly say what flyingfox was.
It's just the preferred way to say to someone they need to change that section of code. The preferred method is usually either: r"path" or "path\\to\\file"
If you want integrated Python version management too, I've been using [pybrew](https://github.com/utahta/pythonbrew) to great success. I have `pyenv` aliased to `pybrew venv`, so I just type in `pyenv use proj` to activate the relevant virtual environment.
Over-complicating things "a bit", yes =) If you are going to reimplement print anyway, there's not a single reason to put the necessary functionality anywhere else. It would have had some merit if you could use some generic decorator, like for example one that dumps arguments of a function (but you can't, the print function has important named arguments so even your second implementation is incorrect (not to mention that you forgot to call `str` on the arguments)), or one that dumps the return value of a function (but print doesn't return a value!), or one that redirects sys.stdout for the duration of a function call (which would be utterly pointless and slow when you can _just_ redirect sys.stdout).
I think, the main idea behind making print to a function is to solve your kind of problem. If you use the print function, you can override the builtin one, and intercept what is beeng printed.
Also orders of magnitude more cumbersome
Also see: http://wiki.python.org/moin/LocalUserGroups
Ehh, what if a kid wants to do some 3D voxel printing?
That's where some of this is from, but that list includes a bunch of out of date or inexistent groups. The spreadsheet is also pulled from search engine results for Python user groups, and I think another such out of date list (although I can't remember which one). I don't know where the info in the spreadsheet will live, but it'll likely replace the one you linked in some form.
we don't accept strings of characters that don't make sense... there's nothing to do with ruby.
The % operator doesn't do what you probably think it does. By the way, what do you think it does? http://docs.python.org/reference/expressions.html#binary-arithmetic-operations
% is the 'remainder' operation, so if i = 10, then i / 5 = 2, and i % 5 = 0, and if i = 11, then i / 5 = 2, and i % 5 = 1
 &gt;&gt;&gt; [ x % 5 for x in xrange(10) ] [0, 1, 2, 3, 4, 0, 1, 2, 3, 4] x % y is the modulus operator, which returns the remainder of x divided by y.
I hope I am interpreting you right in the sense that you don't understand the [modulo operator (%)](http://en.wikipedia.org/wiki/Modulo_operation). It divides the first integer by the second, caring only for full-integer (noting after the decimal point). Then it returns the rest which it couldn't divide anymore: 23 % 5 = 3 because 23 - 3 = 5 * 4 9 % 3 = 0 because 9 - 0 = 3 * 3
I see. I didn't realize % could be used as a mathematical operator, since it has primarily been used as a indication of what variables to stuff into a 'print' statement so far. Thanks!
That printing thing is a freaky consequence of percent formatting expressions in strings and making something easy to remember. You learned the wrong thing first. Any object can implement the .\_\_mod\_\_ method and do something with its arguments. str objects try to make a new string to return. Integers do math and return modulus value.
Exactly. And how to tie it in with a db. Looks like the twisted book covers this.
Short answer: yes. Longer answer: the % operator gives you the remainder between two values so, yes.
range(0,200,5)
This, and `.format` is much better for this purpose anyway.
Yeah, you'll see this in all languages that permit operator overloading -- eventually, the operator will be used/abused to mean two different things in different contexts. Take `+` for example, which can mean * integer addition (an associative, commutative operator) or * floating point addition (a non-associative/approximately-associative, commutative operator) or * string concatenation (an associative, non-commutative operator). You'll run into this tricky situation in mathematics too, of course, as the assignment of operator names to functions is at its root an arbitrary convention. Just be aware of it. :)
Yeah, but still kind of new. Beware.
...when "x" is an int object.
in some languages it also lets you concatenate lists, and do some other stuff that the plus sign probably was never conceptually meant to do.
beware of what? honest question - i've been using str.format all over the place and not had any issues.
Isn't this what \_\_str\_\_ or \_\_repr\_\_ does?
Beware of old versions of python that don't implement it. If you need your code to be compatible with various distributions, you can't use all the latest python features. 
As it turns out, it is a programming problem, as the OP only knew about % as a formatting operator for strings, not modulus. Also, the sky is not falling.
...when "x" is a number. It also works on floats, decimals, and complex numbers: &gt;&gt;&gt; for i in 5, 5.4, Decimal('5.33'), 5 + 3J: ... print i, i % 2, type(i % 2) 5 1 &lt;type 'int'&gt; 5.4 1.4 &lt;type 'float'&gt; 5.33 1.33 &lt;class 'decimal.Decimal'&gt; (5+3j) (1+3j) &lt;type 'complex'&gt; 
Upvote for doing the job of lazy/smug/headsUpArses programming teachers everywhere.
It was only introduced in Python 2.5 or so. And 2.6 requires numbering the positions!
BTW, quite a few other languages (such as C) use % as the modulus operator, so it's good to know generally. The use of '%' in strings is also basically from C, which some other languages use also (but the details can vary greatly among those languages, so be wary).
I know what I'm doing with my 7yr old next weekend! Thanks for the discount. Looks like an excellent title.
Again, it might be that I'm trained as a mathematician, but list comprehensions look like they came directly from Set Theory and I felt very comfortable when I hit them. For example, in mathematics we might define a set by saying "set of f of x such that x in K and x divides M". I would write: {f(x): x∊K ⋀ x∣M} In Python I would write [f(x) for x in K if M%x == 0] I thought the language construct was genius. I can almost do a 1:1 mapping from how I communicate mathematically and how I code in Python.
But I already bought Invent with Python! I like it, it's a good introductory text, but I'm still trying to convince the kids that making your own games with Python is more fun than Portal 2. So far, I'm losing that battle.
I have fixed the issue. In my Python script, I'm using OpenCV to display these frames as well as record them using ffmpeg. There is a conflict when trying to run the ffmpeg command and display them on the screen using OpenCV. 
So what was your fix?
Are you a mathematician by any chance?
Awesome. Thanks!
Have them take a look at [Light-Bot](http://armorgames.com/play/2205/light-bot) and [Light-Bot 2](http://armorgames.com/play/6061/light-bot-20). These are really simple but fun programming games. (I've been trying to think of some way to make a programming game that is as approachable yet still teaches programming, but haven't been able to make much progress.)
&gt; I am trying to learn python right now Check out [r/learnpython](http://www.reddit.com/r/learnpython).
Python's operator overloading is a powerful tool in the right hands though. :) This is probably a bit above the level of the OP though, the best thing for him to know is that operators can mean different things based on the types of objects you're applying them to. Personally I believe the LPTHW book is a broken method of teaching, I found that Mark Lutz' Learning Python (4th ed) is the best intro to Python (if a bit long, but that's due to the detail at which it is taught.)
I'll keep an eye on it, but just for starters, /r/python has a much more helpful sidebar for getting started with python. 
Just by the way, you can reduce your assignments, by applying the int() function to the raw_input() functions. Like so number = int(raw_input('enter number to count to --&gt;')) Also, a for loop would be a better option for a problem like this (using returns in your def statement would help as well.) def count(number, divisor): numbers = [] for x in range(number+1): if x % divisor == 0: numbers.append(x) return numbers Then print it out with something like this if you want to print each item (without printing it still wrapped in a list.) for item in numbers: print item, I'm not going to go over what the % operator does as several other posters have given a good explanation, I just wanted to give you some general tips (I'm probably going to be told there are better ways to do this [and there are] but I felt that this was a better way to explain it to a beginner than something like a list comprehension or something.) 
Removing everything that used OpenCV. This was part of the script: from opencv.cv import * from opencv.highgui import * capture = cvCreateCameraCapture(0) #where the conflict occurs I'm going to have to find another way to display the same video stream that I'm capturing and saving to file.
Its called How to think like a computer scientist http://openbookproject.net/thinkcs/python/english2e/
Maybe it was [Think Python - How to Think Like a Computer Scientist](http://greenteapress.com/thinkpython/thinkpython.html) ... if not I can still recommend it...
That's great, but why? 
Maybe this forum isn't the best place to post a commercial advertisement. Just saying.
What did he say, I'm freaking curious now...
Not something I could do myself, but the site looks like an easy way to find jobs, awesome!
I usually just load it into the Gimp.
To the people repeatedly reporting this as spam: give it up. Dude wrote a book and he's cutting out his profits to give you a better price on the print version. The online version(s) have always been free. This is relevant news to the Python community, and other books have been allowed to make the same type of announcements.
Maybe [Python scripting for computational science](http://www.amazon.com/Python-Scripting-Computational-Science-Engineering/dp/3642219624)?
This is it! Thanks a lot!
There used to be a website that would show you the individual frames of a GIF. I couldn't find it so I made a google search with "imagemagick extract gif frames". Here is what I found: convert image.gif image_%d.gif This converts all frames as image_1.gif, image_2.gif, etc. I'm so happy that I didn't have to reinvent the wheel.
We've done Light-bot, but it just didn't hold their attention and I didn't really like it much as a programming teaching tool. The lack of a conditional statement meant that the light bot language was not Turing complete and ensured recursion always becomes an infinite loop. Light-bot is really a puzzle game to see if you could combine the instructions in such a way as to fit into the very small programming space. As an occasional embedded systems developer I understand the sentiment, but this constraint really isn't a great starting point for introducing software development. Especially when you take away something like recursion which is one of the principal tools of compact coding.
Guess I'll have to wait a week or two then buy this book. Any preference as to where or how?
1) myFile will only store the filename. To get at the data inside of it, first you have to open it, then read it. 2) split takes a character as it's parameter. What character do you want to split your string around? What character represents a break between words?
\n indicates a space, right? If so that's what I want to use. And I need to do a f.open(/path/to/file) then f.read(/path/to/file) I'm a beginner at this, thank you for your help!
I wouldn't call writing a 40 line script "reinventing the wheel". Kudos to the OP for scratching his own itch and posting the code. I'm also glad you posted a technique using imagemagick to accomplish the same task, but maybe don't be so negative about it next time.
\n is a newline character. ' ' is a space I would say do this f = open('path\to\file\') This creates a file object that is referenced by the name f. Then I would use either an f.readline() or f.readlines() method to iterate through the lines in the file. 
Sure, but you could use hooks in virtualenvwrapper to do everything you're doing now automatically. It really depends on if you want to extend the functionality of what a virtualenv means or not. For example, my postactivate hook cd to the project directory, changes my PS1 to put my project root as /, and sets up some aliases such as using "quit" or "exit" instead of "deactivate". Likewise, deactivate hook reverts PS1 and puts me back to my home. Of course this is unique to my workflow, and you could do this without virtualenvwrapper, but it makes it a bit neater.
Damn, I was gonna buy it tomorrow. Guess I'll have to wait a week to buy it and just read the online version! ;)
Sure it's still good to know both systems for now depending on your target. In case anyone is unfamiliar with the new string formatting, here's a quick example: class N(object): def __init__(self, x): self.x = x def __format__(self, fmt): formatted = format(self.x) if fmt == '0': formatted = format(self.x, '.0f') elif fmt == '1': formatted = format(self.x, '.1f') return formatted &gt;&gt;&gt; from collections import namedtuple &gt;&gt;&gt; t = namedtuple('T', 'a b c')._make(map(N, (3.14, 2.72, 1.62))) &gt;&gt;&gt; '{t.a:0}, {t.b:1}, {t.c}'.format(t=t) '3, 2.7, 1.62' 
I wouldn't worry about old versions. Life is too short to write shittier code just in case you need to support an obsolete interpreter someday. If it works in your version of Python and up, good enough.
Mmm, I like http://gun.io/philosophy/
Here's a simple solution def wordCounter(file): numWords = 0 lines = [] for line in file: lines.append(line) for line in lines: for word in line.split(' '): numWords += 1 return numWords Then you can run your code something like this for the prompt. myFile = open(raw_input("Enter a file path: ")) print wordCounter(myFile)
 def wordCounter(): filename = raw_input("Filename:") words = 0 with file(filename) as f: for line in f: words += len(line.split()) return words
 #!/usr/bin/env python # -*- coding: utf-8 -*- import re path = raw_input('Enter a file path:') with open(path) as f: data = f.read() words = len(re.split('\s+',data)) print(words) 
We're helpful in /r/lp, I promise.
I was just thinking it would be awesome to be able to place bounties for features of OS projects. Anyone know if there are other sites that do this?
The user who wrote the entry this article links it is called Rich. Is this R1CH, the wizard from team liquid?
http://norvig.com/spell-correct.html
That's exactly what this site is! They're free bounties for Open Source projects. http://gun.io
You can also buy the book without entering the discount code, if that's what you mean. Or if you get it on Amazon, it qualifies for free shipping.
You can also buy the book without entering the discount code, if that's what you mean. Or if you get it on Amazon, it qualifies for free shipping.
Using a regex is overkill, considering [`str.split`](http://docs.python.org/library/stdtypes.html#str.split) splits on multiple whitespace anyway. It also strips whitespace from the start and end of the file. &gt;&gt;&gt; text = ' Autumn \nby Emily Dickinson' &gt;&gt;&gt; print text Autumn by Emily Dickinson &gt;&gt;&gt; text.split() ['Autumn', 'by', 'Emily', 'Dickinson'] 
Why the two (well, three actually) for loops? A) If you build up `lines` only to turn around and loop through it, why not just do the stuff in the second loop the first time without building up `lines` first. B) `text = file.read()` will get you the whole text of the file in one pass. Then you can split it and count it. The whole thing is a one-liner: `num_words = len(file.read().split())`
The preferred version is to use `open` instead of `file` directly. In Python 3, they dropped `file` and only left `open` to encourage this.
Nitpick: You use `raw_input` (Python 2) and print as a function (Python 3) in the same code. 
`myFile` is the name of the file, not the contents of the file. To obtain the contents, you need to `open` `myFile` and `read` it. Unless the file is ginormous, you don't need to read it line-by-line; you can read it in a single swoop. Your choice to use [`str.split`](http://docs.python.org/library/stdtypes.html#str.split) is good. It splits the text on runs of whitespace (including the newline characters) and produces a list of words. Then just ask for the `len` of the list. 
I don't know why he deleted that, it just said something like "upvoted for explaining modulo". 
I'm not sure of the "Pythonic" way to do it, but the "Perlish" way to do it is to "slurp" the file into an array, split it, and return the "length" of the array. With that in mind, here's my "Perlish" way to do it... input_file = open("preamble.txt") # open the file slurp = input_file.read().rstrip() # store in a string, strip trailing whitespace words = slurp.split() # split the string on whitespace print "The Preamble contains", len(words), "words."; print print slurp print print words This doesn't remove punctuation characters from the text, but that could be done with regular expressions.
Yes, true. It seems I'm in a limbo between the versions.
Thanks! Didn't know that. I always use the Regex module and didn't even consider the alternative.
It can be a one-liner I think, but there's a few issues with your version: A line break should also count [newlines] as a word boundary (unless the preceding character is a '-', I guess), so perhaps: num_words = len(file.read().replace('\n', ' ').replace('- ', '-').split(' ')) There's a potential problem with that version too: If the sequence '- ' occurs legitimately in some other context, like an inserted sentence (A - B - C), actually no wait: That works since '- C' is then errornously contracted to '-C', but that doesn't skew the word count, *if we don't count free-standing '-'s as 'words'*, which seems reasonable anyway. So perhaps: num_words = len(filter(lambda x: x != '-' and x != '', file.read().replace('\n', ' ').replace('- ', '-').split(' '))) Edit: Clarification. Missing word marked with square brackets.
Yep, just tested it. Generated [510 word, five paragraph lorem ipsum sample](http://www.lipsum.com/feed/html), and ran the following: Python 2.7.1+ (r271:86832, Apr 11 2011, 18:05:24) [GCC 4.5.2] on linux2 Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; print len(filter(lambda x: x != '-' and x != '', open('lipsum.txt').read().replace('\n', ' ').replace('- ', '-').split(' '))) 510 &gt;&gt;&gt; Edit: I introduced some artificial line breaks preceded by '-'s and verified that it yields 510 with those modifications as well as free '-'s and superfluous spaces (although clumsy punctuation isn't handled). It would need some modification to handle unicode.. The following should be even more stable: num_words = len(filter(lambda x: x != '-' and x != '' and x not in string.punctuation, file.read().replace('\n', ' ').replace('- ', '-').split(' '))) Since that handles free standing punctuation marks (and white space like tabs) in concordance with the current C locale. Or more concisely: num_words = len(filter(lambda x: x not in string.punctuation + '- ', file.read().replace('\n', ' ').replace('- ', '-').split(' '))) 
Ah. thank you Mr. Headpuncher
If you are using 2.7 then trades' version is hardly applicable, even if you do `from __future__ import print_function` you'll still have to go all over your script and fix all calls. I personally would go with wrapping sys.stdout, like [this](http://www.answermysearches.com/python-how-to-print-to-screen-and-a-file-at-the-same-time/52/).
doh, i lost :(
Here is a simpler example: &gt;&gt;&gt; a = 1 &gt;&gt;&gt; b = 'text' &gt;&gt;&gt; class C: value = 'value of class C' &gt;&gt;&gt; '{1} - {0} - {x} - {2} - {3.value}'.format( a, b, 0.43, C, x='foo' ) 'text - 1 - foo - 0.43 - value of class C' It is also possible to add formatting specifiers.
I remember this longtime back, I donated money. It's a nicely written book from what I had read. 
I wanted to show `__format__` and the built-in `format`. Usually all of the attention is on `str.format`, with the curly brace notation and the standard format specification mini-language. But the new system can be extended any way you want with your own mini-language per class, and even your own custom [string.Formatter](http://docs.python.org/py3k/library/string#string-formatting). 
I would like to see numpy and scipy integration somewhere in the future, just have no time yet :-( If you would like to help, you are more than welcome.
See http://www.slideshare.net/Stiivi/cubes-7781602 for more information, not "too enterprisy" :-)
Coming soon, I will publish them on the blog: http://blog.databrewery.org/
Storing the scripts on a different drive than where Python is installed shouldn't be an issue as long as you're passing the correct full path. Say you have a script in `D:\dev\exercise.py`, you should just type `C:\Python27\python.exe D:\dev\exercise.py` and it'll run it. Does that not work for you? --- As for the path issue, without being administrator you can't make a system-wide Path change, but you can still do something that will make it easier for you. Create a file called `dev.bat` (or something) and put the following two lines in it: set Path=C:\Python27;%Path% cmd Now, rather than starting up `cmd` directly, run `dev.bat` to put `C:\Python27` on your path. Now you should be able to run `python D:\dev\exercise.py`.
You can set a user path. System Properties &gt; Advanced &gt; Environmental Variables The top half of the screen is specific user variables. You should be able to add Python to the path here.
That is fine if you happen to be a on a box with imagemagick installed. The point of what I did was to be able to put it on my home web server and be able to quickly view it from anywhere, and as technomalogical said, I would hardly call this reinventing the wheel. 
When creating an OAuth provider in Piston, it is necessary to facilitate the persistent requirements of OAuth. Piston uses the Django DB which is fine at low volume, but at high volume, it becomes a bottleneck. I have created a Redis-backed OAuth cache for the Piston OAuth datastore which caches Tokens and Consumers in Redis. It does away with the Django DB entirely for Nonces. WOohoo! No DB hits at all! Use it by setting: OAUTH_DATA_STORE = 'path.to.store.RedisDataStore' In your `settings.py`
Have you tried [homebrew](http://mxcl.github.com/homebrew/) ? 
Not the best way but you could use something like Vmware and set an windows environment. 
According to the the PyGame FAQ, it mostly works with Python 3: (http://www.pygame.org/wiki/FrequentlyAskedQuestions#Does Pygame work with Python 3?)
Completely agree with you Graham and with parent, except for the "hip" part. Since one of the authors/presenters (Benoit) is the developer of gunicorn it's more like he's eating his own dogfood.
Hmm, I saw the developer announce that it worked with PyPy in September, however it would appear that it doesn't work with PyPy's nightly builds at this point in time. All one needs to do to reproduce the problem is: #!/usr/bin/env python from werkzeug.testapp import test_app from werkzeug.serving import run_simple if __name__ == '__main__': run_simple('localhost', 8000, test_app, ssl_context='adhoc') Note that this tiny test script *does* work with vanilla Python 2.7.1. 
Using a stand-alone or module function to split a string using a regex reminds me of Perl, LOL. Did you come from Perl, perhaps? I don't want to be a jerk, but reading the documentation for [Python's built-in types](http://docs.python.org/library/stdtypes.html) can take you far in life. :-) Aside: I do think it's unfortunate that the docs for built-ins are buried in the docs for the standard library, making them hard to notice in the first place and find again later without a bookmark. 
I use pygame quite successfully with python 3.1
This. This I want. Post a link if you find one.
Nice what are you going to do to make it faster? (I am curious about the specifics)
I clicked this thread looking for a comment like this. Thanks. I wondered if pygame worked with 3+
These bounty things are always grossly underpriced. It would be nice to have a site like this which a moderator creates a market evaluation for each job and doesn't approve unless the poster is willing to pay a reasonable amount. Open source projects can always be added later at a discount.
The source code for several simple Pygame games [is here](http://inventwithpython.com/blog/category/games/), if you want some example programs to read through.
It doesn't look like there's a binary package, so you'll need to compile it from source. There's some instructions for compiling on OS X [here](http://pygame.org/wiki/MacCompile), and notes from someone who got it working on 3.1 [here](http://programming.itcarlow.ie/pygame.html).
Please be more specific... By "extract the text from the generated data" do you mean get the HTML source of the "https://email.***.ac.uk..." link? If so you can just do another web request using mechanize (or cURL if you need more authentication options). By "base href" do you mean just get the *right_main.php* string? Or what? You can probably achieve whatever you hope to accomplish by [.split()](http://docs.python.org/library/stdtypes.html#str.split)
I think creating a python.bat on the system or any other folder that's already on his path will work too. 
Not a completely bad idea; 1. [`Virtualbox`](https://www.virtualbox.org/) is free 2. Just about any [mainstream Linux](http://www.ubuntu.com/download/ubuntu/download) will work with it
 print "this is the {var1} {var2}".format(var1='new', var2='syntax')
 v1=why v2=that echo "$v1 is $v2?"
http://www.python.org/dev/peps/pep-3101/
See "Changes in string formatting" http://www.ibm.com/developerworks/linux/library/l-python3-1/
 print "Sweet {var1} i love the {var2}!".format(var1='jegus', var2='PEP') Edit: Aw, you switched your link from the [PEP](http://www.python.org/dev/peps/pep-3101/) documentation!
There is a branch on bitbucket (super rough as of now, might eat your cat!):https://bitbucket.org/fijal/hack2 I would be interested in more benchmarks. Kill generators (they're nonsense that abuses iterencode), use StringBuilder, stare at traces and do few hacks in short. Also improve re handling in places. 
My first language was Python. My first 'big' piece of code was writing an HTML scraper for fictionpress.com so I could save stories, using regex. I learned about the .split() built in months afterwards, because I was watching the Google Introduction to Python series. Honestly, regex was something that people knew about and so suggested, and it seemed to solve the problem. Why use something new when you know you have something that works? 
Can you confirm on a Mac? 
That's a really good idea for a class situation. If I were the OP I'd want to be working in an environment as close to the instructor's as possible. Hopefully the class is challenging enough without having to deal with inconsistencies between platforms.
Most program I write make extensive use of regular expressions, so this way of approaching a problem is not at all out of the ordinary. It just happens to appear in a very short program. And, as it happens, the intrinsic "split" shown above cannot handle a regular expression, so it's rather inflexible -- it does one thing very well, and nothing else. The only way it can be coerced into splitting a string on any arbitrary whitespace (as in the above example) is to not give it an argument -- there are no arguments that will produce the same behavior, and no way to control the outcome. The rest of the time, it splits on a provided string and has no interpretation ability. So, for a student, it seems my approach had merit. 
I just started teaching myself Python today and that was actually one of the first things I learned about. Go go Google U!
Is using locals() frowned upon? E.g. &gt;&gt;&gt; a = 1 &gt;&gt;&gt; b = 2 &gt;&gt;&gt; 'a is "{a}", b is "{b}"'.format(**locals()) 'a is "1", b is "2"'
Because my self esteem is linked to my web site traffic. :) And more importantly than getting more copies sold, it would bring larger awareness to this free book, which would get people into programming, which would develop cognitive thinking skills, and make people more intelligent and computer savvy. That, and if people put money for a printed copy they're probably more likely to be invested in actually reading it, as opposed to letting a PDF file sit on their hard drive.
Pretty much every language (that I know) has some variation of this. http://en.wikipedia.org/wiki/Printf
I love just reading through the PEPs.
&gt; Thank you, right-wing Republicans, for patrolling Reddit downvoting any comment faintly critical of the Glorious Holy United States Empire. Not everything is about politics or America. I'm European and I downvoted you because your comment is unhelpful and out of topic. I assume most people had the same reason.
 class E: def __getitem__(self,key): return eval(key) print "You can get %(8-6)s %(''.join(reversed(list('revelc'))))s with this stuff"%E() 
Is StringBuilder a public API?
**tl;dr** "if i % 5 == 0" means "if the remainder of an integer division of i by 5 is zero"
Not really. It can be quite handy (i.e. in Django you can use it to pass all local variables from the view to the template)
This is slightly off-topic, but just a comment on your web site... &gt;The book and the programs are open source, and are available under a Creative Commons Attribution-Noncommercial-Share Alike license, meaning they are free to copy and distribute. CC-BY-NC-SA is a fine license for your purposes, but it's not open source. To avoid confusion, could I request you reword this part? eg maybe just "are free to copy and distribute under a Creative Commons..." etc. Anyhow, I applaud your use of a community-friendly license and wish you well.
If this is a math comprehension problem, how would you say it should be comprehended?
&gt; OP has absolutely no concept of modulus, True. &gt;or else it would have occurred to OP that that's what the program is doing. That also may be true. 
** is very powerful, used ~~~wisely~~~ carefully.
`string.split()` with no options counts all whitespace (spaces, tabs, newlines) as delimiters then eliminates empty cells: &gt;&gt;&gt; "the quick\tbrown \t\n fox".split() ['the', 'quick', 'brown', 'fox']
Just be careful you don't use it in a situation where user input could get into it somehow. For personal use scripts though, it's fine.
My favorite use of 3k-style formating: &gt;&gt;&gt; from datetime import datetime &gt;&gt;&gt; print 'It is {0:%H:%M}'.format(datetime.now()) It is 18:58 
Yeah, look at the refined version in my own reply to myself instead of that one, and remove the final parameter from split so that the statement reads: num_words = len(filter(lambda x: x not in string.punctuation + '- ', file.read().replace('\n', ' ').replace('- ', '-').split())) As you say, there's no need for the split param.
Yes, but some language ecosystems don't encourage using it like the Python community does. I.E., a lot of C++'ers will use `iomanip`, Java people will use `StringBuilder`, etc. Most of the time these are considered better alternatives for one reason or another (usually performance), but I always liked the fact that it was the encouraged way to do things in Python.
Don't use it in performance-critical situations; it causes some Pythons to switch from fast slots-like local variables to slow dict-like local variables. (This is definitely true in IronPython and I recall it being true in CPython, but I don't have a citation handy for any of this.)
Confirmed, I have Pygame working with 3.2 on Windows and Linux
This is one of my favorite python features. I use it for all kinds of templating. In fact, I have never learned how to use either the dedicated tempate libraries or the built-in template strings because I find the % dictionary formatting to be so intuitive to use. I don't like the python3 version of this nearly as much, since one can't specify formatting for the arguments (or, such specifications are harder to make).
That's actually my least-favourite use of 3k-style formatting. `datetime` objects would have been the perfect showcase for 'a class that provides custom formatting glyphs': print 'It is {0:H}{0:M} and {0:S} seconds'.format(datetime.now()) but instead we got the old-style formatting strings in a thin new-style formatting wrapper.
Must be because I'm watching Family Guy, but 'blew' and 'mind' should really be replaced with 'grinds' and 'gears'
That is a significantly less featured way of string formatting, and ignores the biggest feature which the author noted, which is the ability to use names and a dict to format the string so that it is immediately clear inline what is going to be printed. printf is significantly less descriptive.
Yes, pygame works fine on OS X and any version from 2.5-3.2. My only caveat is that currently fullscreened games are broken in Lion due to pygame using a deprecated API call.
How does this look? (hopefully it pasted correctly...) #!/usr/bin/env python2 import sys import fileinput def wadsworth(): original = [] if len(sys.argv) == 1: original = raw_input("Wadsworth this: ").split(' ') else: original = sys.argv[1:] drop = int(len(original)-len(original)*.70) if drop % 2 != 0: drop = drop + 1 output = ' '.join(original[drop:]) return output if __name__ == '__main__': print wadsworth()
**While very interesting, the code above is VERY DANGEROUS.** Aside from educational purposes do not use.
I just submitted a drastically improved version with a simple redis row cache that can be used anywhere you want.
There is a big discussion on this at The Django Book (templating chapter), and Stack Overflow. The problem is by getting in the habit of passing locals(), you are 1. Straining the framework to push a bunch of useless data around 1. Potentially passing around insecure data To save you a bunch of reading, it's a bad practice to use locals(), and just use this or something very similar: class MyStruct(object): pass def my_view(request, id): c = MyStruct() c.customer = .. c.invoice = .. c.date = .. return render_to_response('xxx,html',c.__dict__) It basically creates an empty object to act as a dictionary which is good for the parsing and your template tags. **Edit**: Redditor below is smart: http://www.reddit.com/r/Python/comments/l3d6c/print_this_just_var1s_my_var2s_var1blew_var2mind/c2pkc3s
Can people please start explaining why/how something is dangerous or linking to a rel article? I've heard so many people say "X is reeeeally bad! Stay away!" but never understood why or if they were even right.
Google University? As in, just Googling stuff? Or is there such a thing?
Whoever wrote that pep clearly hadn't seen [this](http://xkcd.com/927/)
Why use an object there instead of a dict?
var = "this" "Is there a %{"way " + "to"} do %{var}"?
Googling "eval is evil" might give some hints.
&gt; I don't like the python3 version of this nearly as much, since one can't specify formatting for the arguments The Python 3 syntax is superior in every way. And, yes you can [specify any kind of formatting you want](http://docs.python.org/library/string.html#format-string-syntax)
http://code.google.com/edu/languages/google-python-class/
That's why they created Python 3
&gt; I personally would go with wrapping sys.stdout I agree. That was just an excuse to try out decorators. Sorry for any confusion/wasting time.
I downvoted you for failing to be of any use at all in this thread. Yes, it's a math comprehension problem, but he didn't know that when he asked.
I also want to point out that it's easy to test your code by doing something like: cat filename | python mapper.py | sort | python reduce.py Check out [dumbo](https://github.com/klbostee/dumbo/wiki) as a neat way to make all this more "pythonic".
B... but... then I can't do this: bar = {'var1': 'like', 'var2': 'cows'} print "I %(var1)s %(var2)s!" % bar Which seems nicer than this: bar = {'var1': 'like', 'var2': 'cows'} print "I {0[var1]} {0[var2]}!".format(bar) 
Ah yes, forgot about the good 'ol double-star. Still not quite as obvious, IMO.
wouldn't it have just been easier to say 23 / 5 = 4 r 3 9 / 3 = 3 r 0 ie, modulo finds the remainder of a division, your way confuses me
Wow, I find it weird they used % for that, I recall str.format can handle nesting {}'s, I use it in a project of mine.
Better, and way longer to type than a simple '%' :( For something that I use so often, it sure sucks.
Because class E is using eval() without sanitizing the input to that. So, if the input did contain something that allowed a user input or something that a malicious user could get access to, they could execute arbitrary code on your computer. 
I would have picked your post up for an uppie, but stopped right there when I realized you didn't even explain the math problem. Your rant is an OKAY introduction to the explanation, albeit inflammatory, but it is not the introduction to an explanation, nope. This is why chairface, for instance, says that you brought nothing to this thread, which is a prime reason for downvoting, according to retiquette. That said, have a good day.
You could just concatenate them if you really want to, but embedding code (a la Ruby, PHP) inside of strings is a pain for internationalization.
3 fewer characters?
Yes, but that's not a language issue.
Since you're into making things short, I can't resist making the whole thing "as short as possible": from __future__ import print_function try: range = xrange input = raw_input except NameError: pass number = int(input('Max: ')) divisor = int(input('Div: ')) [print(i) for i in range(number) if not i % divisor] Code will work on both python2.6 upwards and 3.0 upwards. Little explanation on the list comprehension(what's inside the []), it simply translates to: for i in range(number): if not i % divisor: print(i) That is exactly the same order if you change ``print(i)`` to be at the beginning in the generator expression, or to be the most nested expression in the regular form. Also, this would NOT work with python2's print statement(you know, ``print "text"``), because that'd be a statement(like a = "text") instead of an expression(almost everything else!). That's why I use the future import. Finally, I guess you could avoid storing a list of Nones in memory by just using a generator expression instead of the list comprehension and iterating over it. Not that it matters if you go to 20, but seriously, it's just stupid to keep [None, None, None] in memory. from __future__ import print_function try: range = xrange input = raw_input except NameError: pass number = int(input('Max: ')) divisor = int(input('Div: ')) for x in (print(i) for i in range(number) if not i % divisor): pass There, I'm done. PS: I just read the first sentence of my post and LOL'd.
They present technical arguments so well! Also are very informative.
This is an excellent resource for learning how to use Python in conjunction with Hadoop Streaming. I referred to this side numerous times when I did a lot of distributed computing research work in grad school. One thing that I'd like to point out is that there are some potential bugs where large MapReduce jobs will fail if you are using Hadoop Streaming. So, if you are doing something super-large, I would recommend sticking with writing your mapper/reducer in Java. 
I haven't looked, but have you tried installing it through macports? You'll have to reinstall python3 also, but it's probable the easiest way.
this is kinda icky, mrjob from Yelp is much much much nicer! https://github.com/Yelp/mrjob
yes, that notation looks nice. but of course you'd have to add that the result of the operator is only 4 or 3, not the rest.
Actually you should use a namedtuple for that stuff. Exactly what they are made for. http://docs.python.org/library/collections.html#collections.namedtuple
That works on Python 2.7. I didn't know.
Yes, although it's pypy only. from __pypy__.builders import StringBuilder
 import re r = re.compile("#{([^}]*)}") def I(string): def eval_str_match(m): return str(eval(m.group(1))) return r.sub(eval_str_match,string) then from I import I print I("this is the #{var1} #{var2}")
I personally hate print style with a passion(if you don't need formating and you usually don't). Unneeded place holders and placing variables away from where they go in the string(leading to higher likelehood of confusion if you have lots of variables). Personally I think ruby gets this right but if you concatenate strings and str(obj) at least you don't have to look over half a line for your variable.
xrange returns a generator rather than a full list, and only returns items when you request them. If you don't actually need the items returned by range then its the better option.
you can access the data using properties of the link object. the base href will be link.base_url and the text will be link.text
code you see is just hypothetical (not optimized). xrange and range can be used (almost) interchangeably. xrange makes an iterable object, but doesn't create any of the elements until they are needed. hopefully you never actually use: for n in len(range(x)) as this wouldn't do anything except iterate over x (one element), and might just throw an error. so, yes you should typically use xrange in a loop or in a comprehension. most programs don't need large lists and so it would make little difference.
If you're using python 2, use xrange when the count is large. When it's small, or you need a materialized list, use range. If you're using python 3, use range. I don't know what code you're reading, but Everyone knows this.
I think what he actually sees is: for n in range(len(x)) Although enumerate(x) is often neater for this.
Maybe your tests are taking too long to run then? ;)
&gt; for n in len(range(x)) You probably meant &gt; for n in range(len(x)) and that's still pretty bad. If you need all indexes of x, and x isn't an iterator, then &gt; for i, x_item in enumerate(x): is usually better in the legibility front.
That looks great! You could make it even more reusable by taking sys.argv and raw_input stuff out of the function, and letting your function take an argument of a list of words. Something like: def wadsworth(original): drop = int(len(original)-len(original)*.70) if drop % 2 != 0: drop = drop + 1 output = ' '.join(original[drop:]) return output if __name__ == '__main__': if len(sys.argv) == 1: text = raw_input("Wadsworth this: ").split(' ') else: text = sys.argv[1:] print wadworth(text) Then the person using your function (future you?) can get their list of words wherever they want to, whether it''s from user input, a file, the internet, or a random phrase generator. 
Yes.
enumerate outputs pairs, if you are right then the 2 examples he gives are the same thing (as far as range/xrange go). i would also expect (haven't tried) that: for n in xrange(len(x)) would be quicker than: for n, m in enumerate(x): if you only were going to use n. i think this because you only have to do 1 assignment per loop.
[PEP 255](http://www.python.org/dev/peps/pep-0255/)
No, but you _can_ do var = "this" var2 = "way " + "to" "Is there a %(var2)s do %(var)s" % locals() Don't, though.
Learn a better editor? :)
No, you shouldn't be using xrange() because it doesn't exist in Python 3 (which you should be using). In Python 3 range() has all the efficiency benefits that xrange() was originally created for.
Python3 says use it and has range() do what xrange() did out of the box.
For some reason the Python topics are getting dumper and dumper every day. 
Dump truck.
If you're only using n, it's quicker. But I think there in most situations, you want to have m as well.
2to3 makes this a non-issue.
OK, a few things here. Bottom line: YES, you should be using xrange, not range. In python 3, for instance, range is actually changed to be xrange. So use xrange not range. But, if you find yourself using xrange a lot, you may want to rethink your design patterns. As other have pointed out, use enumerate(x) which gives you the thing, and its index in the list. Also, common (mis)use of an index is to iterate over multiple lists. Do so by zipping them all up in one list: for a,b,c in zip(aList,bList,cList): doSomething(a,b,c) 
Are you suggesting it does not matter how verbose the syntax of a language is, because you can config your editor to insert snippets for everything?
I was curious about that, so I tried it out. I had a data structure handy, a list of lists with ~9100 four element lists in it. I wrote a quick snippet to iterate through the structure, summing up one element from the individual lists. Three approaches were used: enumerate(), xrange(), and range(). From 100 separate runs, enumerate had a fast run of 0.002852 sec; xrange was 0.003206 sec, and range was 0.003235 sec. So enumerate, in this contrived test, was faster by 0.000354 sec, or about 11%. Then, on a hunch, because this was a highly contrived example after all, I eliminated the explicit loop altogether and coded it using the sum() of a list comprehension: 0.001952 sec, or about 39% faster.
If you're writing code where xrange makes a difference to you over range, you probably know all about it and use it, but chances are, you don't have any numbers big enough to care. You probably have bigger fish to fry than freeing up a few bytes of memory :)
Or use ``itertools.izip`` if the lists are long, which creates an iterator rather than a list.
I think this is a good topic for [r/learnpython](http://www.reddit.com/r/learnpython). Check that out.
Neat. I see no Django though so it's not of a lot of use to me.
`eval()`/`exec` is not dangerous when used appropriately. Here's `exec` used in the middle of one of the most common Python libaries (and with no sanitizing): http://code.google.com/p/micheles/source/browse/decorator/src/decorator.py#153
&gt; (which you should be using) Not really. But I think the actual answer to the question has been said enough so I have nothing really substantial to add for the OP.
&gt;I don't know what code you're reading, but Everyone knows this. You ruined perfectly decent advice by being an asshole. Good job.
Unless you actually want a list of numbers, yes. Why bother allocating a full list if you're just discarding it?
This solution is like using an anvil to drive a nail. Just use a hammer (there's two in your tool box!)
This. It will probably make no noticeable difference unless you're doing a range() of millions in some performance-critical loop, or if you have barely any memory to spare (c'mon, 8GB is $50!). If it's not *actually* causing you any problem, it's pointless to worry about.
Yes. I have 2.7 and 3.2 simultaneously installed. First, install python2.7 using apt. I am not sure but you may need to change the symlink in /usr/bin back to python2.6. Next you are going to have to "reinstall" pip and virtualenv. Rename the symlinks in /usr/bin to pip26 and virtualenv26. Now, reinstall pip explicitly typing "python27" on the command line instead of just "python". Then reinstall virtualenv from pip Now if you want python26 to be your default python distrobution, rename the appropriate of the symlinks in /usr/bin to "whatever27". Finally change the "whatever26" links back to their normal names. Hope that helps.
&gt;Next you are going to have to "reinstall" pip and virtualenv. Rename the symlinks in /usr/bin to pip26 and virtualenv26. Now, reinstall pip explicitly typing "python27" on the command line instead of just "python". Then reinstall virtualenv from pip How do I reinstall pip and virtualenv so they're using python2.7
Yes, you just have to add -p /usr/bin/pythonXX parameter when creating new env (replace XX with python version eg. 2.7)
and is it possible to change the python version to an already set virtualenv?
Unless you care about Python 3, where `xrange` doesn't exist and `range` is an iterator. I'd say use `range` for compatibility, if the performance of an iterator is that important you should be using Python. (edit: sometimes an iterator can make a big difference, but it would be pretty rare for the distinction between `range` and `xrange` to be noticeable.)
Thank you, it always felt like there had to be a less awkward way built into Python. How is it that I've never seen this before? EDIT: Furthermore, you sometimes otherwise end up with a disaster like: for x in zip(the_list, range(len(the_list))): 
Exactly what I was looking for. Thanks dude.
You want 2.6 and 2.7 to both live inside that virtualenv or you want another virtualenv with 2.7 or you want to swap out 2.6 for 2.7 inside of that virtualenv? Just making a new virtualenv with virtualenv -p /usr/bin/python2.7 and then using pip freeze to reinstall your packages is probably the easiest thing.
Wasn't what i was looking for, however I've used split() in another area. Thanks for the extra info though. :)
nice.
Make sure you install them using `python27`, instead of just `python`
Most likely not easily. Not sure, but probably a lot harder if you used `--no-site-packages`, as it copies the standard library from it's normal location. Best chance is to make a new virtualenv with your new version of python, and then copy any requisite libraries manually.
Yeah, you're probably right. Maybe you could tell me what I'm missing here: ~/python/projects/foo$ mkvirtualenv -p /usr/local/bin/python2.7 --no-site-packages --distribute --prompt=\(foo\) foo (foo)~/python/projects/foo$ python --version Python 2.6.5 I'm really nor sure what am I missing here 
2to3 will change xrange() to range() and either leave range() alone (when used directly in loops) or change it to list(range()) (if assigned to a variable) so compatibility isn't a problem. As for which to choose in Python 2, I previously tended to use range unless there's likely to be a large range, because the setup cost for a generator can be higher. BUUUUT I just microbenchmarked this and it turns out that there is no cost. I guess that setup cost only applies to generator comprehensions?
Just instead of using "python" use the explicit version. As per pip's website directions: curl https://raw.github.com/pypa/pip/master/contrib/get-pip.py | python2.7 
No.
that looks right to me and works here: dallas-office-desktop% mkvirtualenv -p /usr/bin/python2.7 --no-site-packages --distribute --prompt=\(foo\) foo Running virtualenv with interpreter /usr/bin/python2.7 New python executable in foo/bin/python2.7 Also creating executable in foo/bin/python ... blah blah (foo)dallas-office-desktop% which python /home/dallas/Projects/foo/bin/python (foo)dallas-office-desktop% python -V Python 2.7.0+ 
Nice overreaction. I'm obviously not saying that people who don't know this do not exist. I am saying that code that does something else is too bad to use as a reference. Python experts know those rules, and wouldn't write anything different to be looked at. Use something written by an expert, not whatever you're looking at.
Good :)
&gt; If you don't actually need the items returned by range then its the better option. It's not, as it's less readable and slower than `range`. The only point is memory pressure for *huge* lists.
And more generally use `itertools` a lot, there's much fun stuff in there.
Because `xrange` is less clear and is at best the same speed, sometimes slower.
It does matter, and it's frustrating when something is too verbose, but snippets or autocompletion (like Ctrl-P in vim which I use in this case) is a good workaround.
Make sure you read the [CPython implementation details](http://docs.python.org/library/functions.html#xrange) in the docs. Ironically it won't work for really large numbers while range will.
don't suggest things about Python3, general things will be change by using 2to3, and newbie won't touch more complex things about Python3 compatbility or they shouldn't care about them.
xrange is no less clear than range, and I find it very hard to believe that it's slower. Logically, it makes no sense. Practically, it still doesn't make any sense. Admittedly, though, I haven't done any tests myself and it is possible that they have optimised the shit out of range, to the extent that it can compete with xrange for speed. But there's no way it should - allocating a list, iterating through that list to set all the numbers, and then iterating through once more time for your actual iteration should really be slower than just incrementing one int in memory.
I start almost every script with: import itertools as it import operator as op
it's weird now "yolk -l" returns: Django - 1.3.1 - active Python - 2.7 - active development (/usr/local/lib/python2.7/lib-dynload) distribute - 0.6.19 - active pip - 1.0.2 - active wsgiref - 0.1.2 - active development (/usr/local/lib/python2.7) yolk - 0.4.1 - active but "which python" points to ~/Envs/foo/bin/python and "python -V" shows 2.6.5 too.
&gt;and then copy any requisite libraries manually. Or use pip freeze to create requirements and install those.
just curious, try: /usr/bin/python2.7 -V
 pip freeze &gt; packages.txt (activate new virtualenv) pip install -r /path/to/packages.txt Didn't even think of that.
How in the world is `xrange` less readable than `range`?
thats awesome, ( still learning programming ) Got any more for even just general python.?
Python 2.7 
i agree with you
http://coffeeghost.net/pybat/python_cheatsheet.png
A related issue with dictionaries: Suppose mydict is a dictionary and you want to do something for every item in that dictionary. you can do either for key in mydict.keys(): or for key in mydict: The first one makes a list and then iterates over it (like range). The second just uses the dictionary as a generator, and gives the same result. Of course in this example the easier to type option is also the better performance one so hopefully people are going to use it anyway.
In most cases you should prefer `xrange` than `range`. The interface of `xrange` is highly compatible to `range` including its indexing operation (unfortunately it doesn’t support slicing operation, but you wouldn’t need this). Always `range` works hungrily, but `xrange` internally only store its `start`, `stop` and `step`.
yolk recently stopped working nicely for me but I haven't looked into it to see why that might be. I have the same issue with yolk so it's not just you but I don't have any other help for you.
seconded on dumbo. if you need a bit more performance check out [pydoop](http://pydoop.sourceforge.net/docs/installation.html) it uses the pipes interface.
sweet exacly what i was looking for ! checking out your blog its pretty nice :) ( added you to my rss feed ! )
I'm going to be rightfully crucified for this, but here it goes: def wordcounter(fname) import commands return int(commands.getoutput("wc -w "+fname).split()[0]) 
Why is this the "new" syntax? I find it to be much uglier when doing things without named variables, and also the old % syntax matches what most database packages (that I've worked with) use. I guess it's shorter for simple named vars like your example.. but also I hate how it ties the ".format together, so you can't break it across two lines.. I like doing SomeFunction("Test: %s %s" % (1, 2))
This is a little library for those wanting to give their app a web ui - basically spawning a small http server and interacting through ajax. I'm using it for a pet project of mine, and I thought I'd package it up for those who'd find it useful :)
Use Beautiful Soup. It is meant for this. Here's the section in their documentation on [entity conversion](http://www.crummy.com/software/BeautifulSoup/documentation.html#Entity%20Conversion).
Can you explain what exactly is happening here? I'm confused about how the contents inside %() are ending up passed to eval. Isn't __getitem__ what is called when you try to say.. a = E() a[4] wouldn't it be called on 4? edit: formatting 
&gt; and also the old % syntax matches what most database packages (that I've worked with) use. Most *Python* database packages perhaps... but question marks are much more popular as SQL parameters in other languages, in my experience. I also think using %s for SQL parameters was a fundamentally bad idea because it could be confused with the % operator in a way that would lead to SQL injection vulnerabilities. &gt; I guess it's shorter for simple named vars like your example.. but also I hate how it ties the ".format together, so you can't break it across two lines.. I think this looks fine: blah("foo {0} {1}".format( 'a', 'b')) My one complaint is having to re-number the 0 and 1 whenever you change things around, but I think that was addressed in 3.1 or some other recent release that I don't have yet (you can just do {}).
I was having no luck with BeautifulSoup for this step. ended up using HTMLParser.unescape(data) Now I am having another issue... :(
Are you working on URLs? Have you looked up the urlparse module? http://docs.python.org/library/urlparse.html
If you're writing things that are HTML into the DB, I would use BeautifulSoup with the entity conversion. Then make sure you're escaping the resulting string when you put it into MySQL; that will take care of '&amp;' and ' " ' that appear in the html.
&gt; the &amp; tag seems to be causing an issue... Give an example of "the &amp; tag". Don't require us to try to imagine the problem. Do you mean "\&amp;amp;" or the general case, the large family of tags that represent character entities?
Sorry for being unclear on the it. HTML Entitys. I did not know the proper word till just now. But I have that working... not running into an issue with my logic.... 
&gt; Sorry for being unclear on the it [sic]. HTML Entitys [sic]. I did not know the proper word till just now. But I have that working... not [sic] running into an issue with my logic.... Is there any chance you could take a little more time while typing? 
kind of neat, you may want to consider making it a package with setup.py and throw it up on pipi. 
thanks
Is there any chance *you* could be a little less of a douche?
So illiterates are the new folk heroes? Thanks for the update.
Sorry Guys, When I get working on something, I have a hard time focusing on anything else. Thanks a lot for the help! The crawler is running right now! I will be back and more focused the next time I need some help.
As a counterpoint, NO, you should *not* be using xrange. "range" did *not* get changed to xrange in Python 3, xrange was eliminated and range changed to a generator. xrange is *not* a generator! It is it's own quirky object, and has been essentially deprecated for a while. If you know you are making short lists of numbers, use range. If you suspect you need to make a large list of numbers to count through, consider a while loop (but use xrange if it seems appropriate). Prefer enumerate() over all other options when it fits, and get to know the itertools module. Historical note, xrange used to *not* handle long ints at all, which made it blow up in certain areas where it was substituted for range. That's been hacked around for a while now, but it is still not quite semantically the same as range in regards to how it deals with the int-&gt;long transition, AFAIK.
Lighthill's use is in no way appropriate.
use scrapy. http://scrapy.org
&gt; Because xrange is less clear and is at best the same speed, sometimes slower. ?? &gt;&gt;&gt; t = timeit.Timer(stmt="r = xrange(100)") &gt;&gt;&gt; t.timeit() 0.48369407653808594 &gt;&gt;&gt; t = timeit.Timer(stmt="r = range(100)") &gt;&gt;&gt; t.timeit() 3.3541569709777832 If by "slower" you mean "much faster" then you are correct.
I've included a setup.py and I'll put it up on pypi soon :)
Or if you want to write code that's compatible w/ both you can always do: try: xrange except: xrange = range in your module.
Yeah you're right actually, it actually bugs me that python db libraries don't use the ?var format like everyone else. And.. I guess you're right, that doesn't look too bad.. honestly I just really liked something about the % notation, but I guess I have no reason to hang on to it.
I liked it too. :-) I'm kind of sad to see it go, but that's life I guess...
&gt;If you need all indexes of x, and x isn't an iterator, then &gt;&gt;for i, x_item in enumerate(x): I respectfully disagree about your assessment of the readability of that statement, which appears distinctly non-pythonic to me. I read the corrected statement &gt;for n in range(len(x)) As "Make an iterator over the range of the length of x", which is very clean, and very pythonic, where when I read the enumerate statement as, "make an iterator over ????". That is to say, I have not used enumerate. My experience (which is... nontrivial) suggests that by virtue of the common usage of range(len(array)) it is easier to read the enumerate. If it makes no difference in performance (as *should* be the case in python3, correct if wrong), then the more common would be easier to read. Please explain why you feel the enumerate readability is better than the range(len()) readability. I may change my position on this if you can articulate a reason.
I do it the other way around. I use Python 2.7 day to day, but I got rid of list-range and use `range` as the name for iterator-range. 
Or use Python 3 where `zip` is the `izip` version.
Python 3 `range` also its own weird object, not a normal generator. Behold: Python 3.2 (r32:88452, Feb 20 2011, 11:12:31) [GCC 4.2.1 (Apple Inc. build 5664)] on darwin Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; r = range(3, 6) &gt;&gt;&gt; 4 in r True &gt;&gt;&gt; 3 in r True 
Ah, TIL. Thanks for that.
&gt; which appears distinctly non-pythonic to me. Sigh. One thing I don't actually like about the python community is saying things are "pythonic". It's an ego-stroke, basically saying, "I'm a zen master and I understand the zen, contemplate the koans and maybe one day you will be as cool as me". When in actuality, it would be much better to say, "x is better than y because..." so that other people can learn. Saying things are "pythonic" is basically an appeal-to-authority argument (even if you're right). But, in this case, you're definitely wrong. for i,v in enumerate(lst) is idiomatic python. The count is 98 to 0 in the standard library: (the \b is to filter out the 7 cases of "in length" in comments) /usr/lib/python2.7 23:33:47 $ find . -name '*.py' | xargs grep "in len\b" | wc -l 0 /usr/lib/python2.7 23:34:11 $ find . -name '*.py' | xargs grep "in enumerate\b" | wc -l 98 In my opinion, the enumerate case is better because it doesn't force the thing being iterated over to have a length. You can enumerate something that doesn't provide a length operator, such as a file object (which exposes an enumerator over its lines). In fact, you can use the enumerate form to iterate infinite "lists" (such as those produced by generators that never exit). Rephrasing the argument as an application of duck-typing: The enumerate form doesn't place an arbitrary, unnecessary restriction (having a length) on the thing being enumerated. So, more things will "look like a duck" here. 
This microbenchmark is uselessly nonsensical, and you should be ashamed.
Agree with enumerate being significantly more "pythonic" than range(len(x)), but you grepped for "in len" rather than "in range". As for the question two posts above, I'm not sure it's needed to articulate a reason to use enumerate in this situation other than "this is the specific problem enumerate exists to solve."
While if you iterate over elements in the list: &gt;&gt;&gt; t = timeit.Timer(setup="r = xrange(100)", stmt="for x in r: pass") &gt;&gt;&gt; t.timeit() 2.2928810119628906 &gt;&gt;&gt; t = timeit.Timer(setup="r = range(100)", stmt="for x in r: pass") &gt;&gt;&gt; t.timeit() 2.1900179386138916 &gt;&gt;&gt; 
Being able to write: for lineno, line in enumerate(open(filename, "U"), 1): ... is so very, very nice.
I see it as a showcase for reusing existing syntax (in this case the long-standing strftime syntax) instead of making a new one.
I haven't used it, but I think Python Brew was created for use cases like this: [Python Brew](https://github.com/utahta/pythonbrew)
It's been around since at least Python 1.4: http://docs.python.org/release/1.4/lib/node11.html &gt;&gt;&gt; count = 2 &gt;&gt;&gt; language = 'Python' &gt;&gt;&gt; print '%(language)s has %(count)03d quote types.' % vars() Python has 002 quote types. &gt;&gt;&gt; 
Great exploration of the issue. I sometimes envy the elegance of blocks, but there's too much junk that comes along with it.
I read that as "make an iterator over a new list of things that are not "x", but are probably supposed to represent indexes into x." ---- The first problem is that the length is probably unnecessary. In &gt; for n in range(len(source)): The author is probably going to use "n" to dereference source, source[n], and never use "n" for anything else. He is probably thinking in another language, and porting that to Python syntax. We should of course prefer &gt; for item in source: The second problem is that, though we don't know what the source is, IF it is something generated, as more and more things in Python are, then there's not even a len() for that type. TypeError! The third problem is that the "len" was unnecessary. We only need the count up to this point. Incrementing a number is cheap, and you get it as you need it, but counting ahead of time is possibly costly and probably unnecessary, and we have to change it to "xrange" just to avoid creating a new materialized list. If we "break" early, all that extra up-front counting (in len or range) was for naught. In 3, some of these costs fall away IF the collection has a constant-time len(). So, given "for item in source", it is at least possible that the user absolutely needs a current index of the item they're working on. We can ask Python to give that to us as it iterates the items of source. It costs one tuple pass, and one increment per item, as you need it. &gt; for i, item in enumerate(source): Any iterable could be there, whether it has len() or not. Finally, enumerate() is in \_\_builtins\_\_ and has been in Python since 2.3, so there's no reason to avoid it for compatibility or import cost. | enumerate(iterable[, start]) -&gt; iterator for index, value of iterable | | Return an enumerate object. iterable must be another object that supports | iteration. The enumerate object yields pairs containing a count (from | start, which defaults to zero) and a value yielded by the iterable argument. | enumerate is useful for obtaining an indexed list: | (0, seq[0]), (1, seq[1]), (2, seq[2]), ... 
However! range() allocates a list with 100 elements in it straight up. xrange() is a generator which keeps a very small amount of state - basically, what the last number it chucked out was, how much to increment it by, and when to terminate. This is very useful if you're dealing with large ranges, or possibly a multi-threaded program with lots of medium-sized ranges.
Absolutely. I was elaborating on masklinn's remark that the benchmark was "uselessly nonsensical." See also http://stackoverflow.com/questions/135041/should-you-always-favor-xrange-over-range And for old-fogie points: http://code.activestate.com/lists/python-list/254484/ where in 2002 I wrote "Replace the innermost 'xrange' with a 'range' (which is faster than xrange unless N is rather large, and 'range' is the standard idiom)".
Consider range(200, 300) vs. xrange(200, 300). The first makes all of the integer objects once. The last make the integer objects when needed. Now iterate through them. Iteration is faster for range() because it just incref and returns, while in xrange() it has to create a new integer object. Overall they should be about the same performance, unless you want to do multiple iterations. If you need to iterate the same list multiple times, then range wins; excepting for long lists where memory access gets to be a factor.
I used to think that blocks were just a better generalization of what we do in python with "with" or "for", but the fact that someone using a block has no idea how many times and in what conditions it's going to be called is a valid concern. In the end, it sums up to "explicit is better than implicit".
&gt; xrange is not a generator! It is it's own quirky object, and has been essentially deprecated for a while. How has it been "essentially deprecated" for a while? Obviously in Python 3 you want to just use `range` (as there is no `xrange` anyway), but unless you need to support longs, why would you not use `xrange` in Python 2?
`range` really won't work very well there either. If you're reaching into long territory, you would be creating a list with a billion elements, which will probably consume most/all of your memory.
If you understand the function your block is being passed to, then you understand how many times and in what conditions it's going to be called. I don't see how that's any different than defining an inner function in Python and passing it somewhere. How many times will this block be called? [1,2,3].each {|n| print n} How many times will printme be called? def each(xs, f): for x in xs: f(x) def printme(x): print(x) each([1,2,3], printme) I don't get what the issue is about "no idea how many times / in what conditions it is going to be called" is all about. Any language where functions are first class, and can have arbitrary side effects, needs to "worry" about this.
Not necessarily. You can get into long territory quite easily if you're using a non-zero start value. Using xrange to loop over a range of hexadecimal serial numbers for example.
wow GIL Removal? that would be amazing if it paid off. Keep up the stellar work guys. 
&gt; So Ruby's flexibility comes at a price: when you pass a block to a method, you need to know what that method does in order to know how it affects your local control flow. Naming conventions can help reduce that complexity (such as the .each convention for iteration), but it does move control flow into the domain of programming conventions rather than the language definition. &gt; On the other hand, Python's choice of explicit control flow comes at a price in flexibility: callback programming looks starkly different to ordinary programming as you have to construct explicit closures in order to pass chunks of code around. This is pretty much how every comparison of Ruby and Python ends up - Ruby is focused on the ease of initial code creation, while Python is more interested in maintenance. Hence, why I use Ruby for all my one-off sysadmin scripts but Python for anything I expect someone else to deal with.
Good point, I hadn't considered that.
I don't know enough about Python to help you, which is why I'm here to begin with. I just wanted to say that I've been using the same method to learn. I cobbled together enough knowledge of Python to create a simple auto-login tool for Cisco routers and switches using [pexpect](http://www.noah.org/wiki/pexpect). After doing this I identified a bunch of ways I could improve it. For instance, using the built in ssh module instead of coding the login handshake by hand.
Oops, you're right... it looks like range(len is slightly more common in the std lib (106-98). I'll let my wrong post stand as a badge of shame. 
Nice, I've tried the guides and tutorials but just doing something because it helps just works. I've still gotta lot to learn, like installing cool modules, messing with tKinter and maybe mess around with http. Let me know how it goes and if you want to share you're code i'll be happy to read it, I don't work with switches much but reading through loads of sample code really helps me understand the different ways to write and use Python. And Redditor to Redditor, I'm proud of you dude! :)
It also has other nifty list-like features, like: &gt;&gt;&gt; r = range(3, 6) &gt;&gt;&gt; r[1] 4 &gt;&gt;&gt; r[1:3] range(4, 6) &gt;&gt;&gt; list(reversed(r)) [5, 4, 3] &gt;&gt;&gt; len(r)) 3 &gt;&gt;&gt; r.count(3) 1 &gt;&gt;&gt; r.index(5) 2
Using a decorator is more appropriate. http://www.zopyx.de/blog/a-python-decorator-for-measuring-the-execution-time-of-methods 
As in I believe Guido stated years ago that he wished he hadn't made it, and that people would prefer range. And that he'd remove it in Python3000, which he did. I say "essentially" because obviously it couldn't be removed in Python2. Granted, that was possibly before xrange() (and range()) were fixed to properly handle long arguments. It's just an oddball object and occasionally causes problem for people who don't understand how it works, though I suppose the same can be said for range() in Python2.
I'm really looking forward to pypy's future.
And just what was the problem? That I didn't have a loop do something with each item so I didn't compare access time of a list vs. the next item in xrange? &gt;&gt;&gt; s = 'r = xrange(100000)\na = 0\nfor x in r: a+= x' &gt;&gt;&gt; t = timeit.Timer(stmt=s) &gt;&gt;&gt; t.timeit(1000) 19.010586977005005 &gt;&gt;&gt; s = 'r = range(100000)\na = 0\nfor x in r: a+= x' &gt;&gt;&gt; t = timeit.Timer(stmt=s) &gt;&gt;&gt; t.timeit(1000) 22.278388977050781 Why don't you write us a microbenchmark that supports what you're saying? Cry us a river, but you're going to have a lot of trouble dodging the fact that range doesn't beat xrange except under some possibly exotic conditions which is contrary to your assertion that xrange "is at best the same speed, sometimes slower." At best xrange is faster than range, in fact xrange is almost always faster than range.
Instead of using "yes" and "no" to represent boolean state, use the values True and False (not strings, btw). It will simplify your conditionals a bit, since then you can just say "if paused:", etc. Also, you can drop the parenthesis around the conditional in your if statements. This is common in other languages, but unnecessary in Python. The pipe character that you use sometimes in conditionals is actually a "bitwise or" operator. It happens to work pretty much the same in cases where you compare expressions that evaluate to True and False (since these are actually aliases for 1 and 0), but what you probably wanted is the "logical or" operator, which can be expressed with the "or" keyword. Example: "if task == "create" or task == "c":" edit, some general advice: You may want to consider trying to separate out your code into sections that handle just one aspect of your program. Consider separating out the parts that read to/from the log file, the parts that handle user input, and the parts that do the actual calculation/book-keeping. Your program may grow in complexity, and you'll be happier if you start to decouple the functionality in your code now.
It's a bug when you need to install an installer to install an installer to install an installer, and that installer depends on the first installer. That's a circular dependency that needs to be broken by a binary installer of all the necessary packages.
No. I'm a *nix user first, but I want my software to work on Mac, Windows, and Linux. I can't ensure that if I can't test Python packages on Windows.
Concurrent GC? That would be _fantastic_. I started playing around with some gamin code in PyGame, but stopped when I noticed that the game paused for a few frames every 10 seconds or so. Just not acceptable in a game, and at the time, the only way to work around it was to disable the GC and rely on refcounting alone for reclaiming memory. *bleh*
Hmm, that's a good point, but if we followed that logic all the way through wouldn't we end up using static typing and whatnot?
Step 1) Install Virtualbox Step 2) Install Ubuntu in Virtualbox Step 3) Profit!!
Programming in Python on a Windows system is like extolling the virtues of free expression with Joseph Goebbels. 
&gt; Advice? Run the program in a shell and record the error messages. Chances are you're missing an essential driver that wasn't caught during installation. After visiting the VPython site, I think this is very likely to be true -- visit there yourself and make sure you have all the essential drivers and resources. 
The standard library is kind of terrible, anyway, and much of it in 2 hasn't changed since it was first written. enumerate() didn't appear until 2.3, so even places where it fits are never updated. It's the Early Adopter Problem.
refcounting is not there even in pypy, gc.disable does not do much. Another issue is that cpyext (the CPython compatibility layer) is slow and allocates a lot of memory. Not much to do besides not using pygame.
Thanks dpm1661! So it would be created = True not "True"? The pipe is from PHP and the like but i'll be sure to use "or" until i need otherwise :) Separating code out is my next goal, I define a few basic functions just to save lines but i'm looking to make it as complete and flexible as possible. Do you have any advice about databases and python? I'm just thinking that if i could use a database then i could look at better reporting by querying the db instead of using python or bash to manipulate a logfile to get the results. Even graphing time of a specific task.log. Thanks again!! 
It never fails that some dork will respond with this.
But if you do `x = range(5)` what do you get? `[0, 1, 2, 3, 4]` or `&lt;enumeratable 0x2812872832 blah blah ... &gt;`? 
Dork, checking in.
Break the main loop up a bit. Perhaps a `def create_task()`, `def pause()`, `def unhandled_virgin()`, `def unhandled()`. Ideally, every function/code block should fit into an 80x24 terminal (this is only a rule of thumb!), especially in a powerful language like Python. * Use [`bool`](http://docs.python.org/library/constants.html#)s (`True`, `False`) instead of "yes"/"no" - this is more efficient, and lets you use syntactic shortcuts like "`if virginTask:`" or "`if not virginTask:`", instead "`if virginTask == "yes":`" or "`if virginTask == "no":`". * Use contains instead of or-chains; so instead of "`elif (task == "quit") | (task == "exit") | (task == "q"):`, you can use "`elif task in ("quit", "exit", "q"):`" - this is shorter and easier to extend (and programatically at least as quick). * You don't need to cast to string for prints - "`print foo`" is the same as "`print str(foo)`". * I'm not sure if it helps you current code, but Python's new `with` keyword lets you safely open and close files in a block; so [](http://) with open(file, "r") as file_h: blah(file_h) # now that we've exited the block, the file handle is automatically closed # Edit: * Also, you can use methods like `.lower()` and `.strip()` to "clean" your input; this makes the computer not-so-stupid when users answer `Yes` (capital "y") or `" yes "` (leading/trailing spaces). * Glueing strings together with +s is unsafe - you can easily throw a `TypeError` if one of the items is not a string. A safer way is to use the formatting methods - either `"%s %s %s" % (1, 2, 3)`, or `"{0} {1} {2}".format(1,2,3)`, depending on your version of python (I believe 2.7 supports both? If so, use the second - it's future-friendly). * Oh, and you should move the timestamp prepender to `logTask`, so that you don't have to do it manually every time. If you still want to retain the ability to logTask without prepending a timestamp (but have it do it automatically), you can use keyword arguments; [](http://) def logTask(loggin, timestamp=None): if timestamp == None: loggin = datetime.datetime.now().strftime("%Y-%m-%d_%H:%M:%S")) + loggin # blah logTask("this entry will be timestamped") logTask("this entry will have a custom timestamp", timestamp="[Custom Timestamp]") I realise using `None` is a bit misleading, but I didn't want to use a string (in case you later wanted to pre-stamp with *that exact string*. 
I find the whole idea of STM really fascinating. I hope they write a white paper after all this. I'd definitely read it.
PyPy is everything that is right about software. Keep up the good work :D
HAH, this could also be called "How to add a directory to windows path" 
In python 3: &gt;&gt;&gt; range(5) range(0, 5) &gt;&gt;&gt; type(range(5)) &lt;class 'range'&gt; 
Unless of course you intend at any point for your code to run places outside of your control. I've been contributing to some open source project recently and all my code needs to be backwards compatible to 2.4 since that is the default version in the oldest RHEL version in common use. I'd much prefer 2.7 as that is what I code, but when you start coding like you live on an island then you quickly isolate yourself from others who may be interested in using and/or contributing to your code. 
Its only a math problem if you already know that "%" is the modulo operator. If you however first learned about the mod operator in string operations it's function is not entirely clear. It is non-obvious that the operator's function is dependent on the context... Also, you are being an incredibly ass by assuming that everyone downvoting you is a "right-wing Republican".
When you're working with boolean values, you don't need to explicitly check if it's equal to true. Simply 'if (created):' should work fine. But you are correct, if you were typing it out verbosely you would use True instead of "True", since the " denote a string. For databases, look into sqlite3 first. There's no real setup necessary like many other databases. Read PEP-8, specifically about docstrings. Use them to format your function documentation instead of using single line (#) comments.
use cpython, after you are comfortable with the language you will know which flavor you need and why. 
Agreed. Use CPython unless you already know why a different interpreter is better for your application.
This sounds rather exciting. PyPy can only get better and strengthen Python as a whole.
Thanks. I am trying to setup my home computer to edit python with my existing Visual Studio as found [here](http://pytools.codeplex.com/wikipage?title=Installation%20-%20details&amp;referringTitle=Home) As you can see in Step 1, they recommend: &gt; For a minimal Python install, you can grab CPython from www.Python.org or IronPython from http://ironpython.codeplex.com. &gt;**However, we recommend installing one of the main Distros – see below.** &gt;Whether installed before or after PTVS, PTVS will pick up your Python Interpreter location automatically. You can further configure this from inside VS. &gt;**In general we recommend installing a full Python environment (interpreter + libraries) using one of the main distros.** Which one is main Distro?
CPython. Alternative implementations are for specific uses, for the most part. The big #2 behind CPython is PyPy, which is the fastest (or very close) and most up-to-date implementation.
the one from python.org but the scope of your question just grew outside my comfort zone by throwing visual studio into the mix. That's like trying to learn how to drive by driving a fully loaded dump truck. IMO
Repeating my question I asked above, so I can install python ASA I decide :) Thanks. I am trying to setup my home computer to edit python with my existing Visual Studio as found [here](http://pytools.codeplex.com/wikipage?title=Installation%20-%20details&amp;referringTitle=Home) As you can see in Step 1, they recommend: &gt; For a minimal Python install, you can grab CPython from www.Python.org or IronPython from http://ironpython.codeplex.com. &gt;**However, we recommend installing one of the main Distros – see below.** &gt;Whether installed before or after PTVS, PTVS will pick up your Python Interpreter location automatically. You can further configure this from inside VS. &gt;**In general we recommend installing a full Python environment (interpreter + libraries) using one of the main distros.** Which one is main Distro?
I don't use VS, so I don't know.
The fact that you never tried both doesn't mean that they are the same. You've never tried a lot of things, most of which are different in most respects!
Well, let's look at it more carefully... &gt;&gt;&gt; t = timeit.Timer(setup="r = xrange(10)", stmt="for x in r: pass") &gt;&gt;&gt; t.timeit() 0.17686780238682331 &gt;&gt;&gt; t = timeit.Timer(setup="r = range(10)", stmt="for x in r: pass") &gt;&gt;&gt; t.timeit() 0.1772999737244163 for a list of 10 items, xrange wins &gt;&gt;&gt; t = timeit.Timer(setup="r = xrange(100)", stmt="for x in r: pass") &gt;&gt;&gt; t.timeit() 1.248768004456895 &gt;&gt;&gt; t = timeit.Timer(setup="r = range(100)", stmt="for x in r: pass") &gt;&gt;&gt; t.timeit() 1.2102231197913405 For a list of 100 items, range wins &gt;&gt;&gt; t = timeit.Timer(setup="r = xrange(10000)", stmt="for x in r: pass") &gt;&gt;&gt; t.timeit() 141.0493076187974 &gt;&gt;&gt; t = timeit.Timer(setup="r = range(10000)", stmt="for x in r: pass") &gt;&gt;&gt; t.timeit() 147.8161718104907 For a list of 10000 items, xrange wins again. I continue to maintain that &gt; xrange [...] is at best the same speed, sometimes slower. is false.
try import gc; gc.disable()
If there's a donation link for concurrent GC and/or STM, I will definitely pitch in.
If you're contributing to projects with hard requirements, of course, you have to follow those requirements. But why would you be proactive in dumbing down your code? If you're starting a new project, set the minimum version of Python to whatever you're comfortable using at that time. (For example, if you're starting a project today, you might consider doing it with 3.2 as a minimum, but if it turns out you need a 2 only library, then you might make 2.6 or 2.7 the minimum.) If you're joining an old project, _then_ you need to follow their standards. But not beforehand.
Python is distributed from python.org as the CPython flavour. Since you are using Visual Studio, you may prefer using IronPython which has been developed by Microsoft and integrates better in their environment. Note that there is nothing preventing you from installing both, one of the design features of Python is that multiple versions will happily co-exist on the one system. Note that [Enthought](http://www.enthought.com) and [ActiveState](http://www.activestate.com) have Windows python distributions that contains some extra stuff you may be interested in - saves trying to find it yourself &amp; adding it to the raw Python.org install. 
The current donation looks like all 105k is going towards py3k on PyPy which doesn't really interest me. GC, STM, Embedding, Perf are all more important.
In fairness, Python *is* fairly easy in Ubuntu.
If you save the .py to the Python Directory, you can use the command "python Whatever.py" without the quotes and the file Whatever.py being the name of the actual python file name is. Changing the environment variable, as stated by metl_lord, would be a more permanent solution.
&gt; The fact that you never tried both ... Are you serious? Don't you know who I am? Of course I've tried both. I've written best-sellers for Apple, Windows and Linux machines. Maybe you should do some fact checking before making up your mind and offering an uninformed opinion. 
Except that only works for whole methods, IbeeX's works for any block of code.
That page links to another that answers your question: [http://pytools.codeplex.com/wikipage?title=Getting%20interpreters%20%26%20libraries%20-%20details](http://pytools.codeplex.com/wikipage?title=Getting%20interpreters%20%26%20libraries%20-%20details). They're talking about EPD and ActivePython. Those will install a CPython interpreter, which is what you probably want unless you need to use .NET. 
I did. Which is why I said this in my previous post: &gt; the only way to work around it was to disable the GC and rely on refcounting alone for reclaiming memory It sucks. Suddeenly I have manually do a large chunk of the memory managment again.No thank you, I'd rather switch to Lua, which has an incremental garbage collector.
Sorry, I was s bit vague. I tried this on CPython, not PyPy. About two years ago, before PyPy had risen up as a serious contender. And yeah, PyPy will obviously need a working PyGame (or something like it) before one can write cool PyPY games, but compared to all the other stuff that needs to fall in place, that is _really_ not hard. 
One question from the link you posted. What is difference between Python Distribution and Python interpreter? Edit: I assume that interpreter is basic python itself and distribution is python+libraries+extra stuff. Am I correct to say that? e.g. CPython directly downloaded from python.org will base basic python interpreter. Whereas python downloaded from [ActiveState](http://www.activestate.com/) will have python+all libraries+other stuff
I am under impression that the ActiveState Python is not free? (or may be I am just confusing *free* with *OpenSource*)
&gt;Break the main loop up a bit. This is really great advice for a novice programer. There's a lot of tendency to make huge monolithic programs when logically they should broken down into much smaller chunks. It really helps when you're going from seeing a program as a linear series of steps to something where code paths are more complex. It also helps to learn where to anticipate the inevitable expansion of features.
I think he means that you never tried extolling the virtues of free expression with Joseph Goebbels. I don't think you're quite that old ;)
Well, I was being hypothetical, and FWIW I was born while he was still alive. :)
Agreed. xrange() is also faster if you know the search range but it's likely the search doesn't take the full range.
I don't think that's an issue. If you want to time only a part of a method, extract it into its own method, or time the methods that block of code calls. If the code you're interested in doesn't call other methods, you can profile the whole method and subtract the time taken by other methods it calls. If you have a method that has two blocks of code neither of which calls other methods, both of which take significant time, and you want to know how much time each takes, then decorators won't help (unless you extract each block to its own method). But that's a situation so rare I'd be surprised if you could find an example. (I hope that wasn't too much of a straw man argument.)
[ActivePython](http://docs.activestate.com/activepython/2.7) additionally installs the PyWin32 extensions for the Win32 API and a package manager named PyPM. Enthought's [EPD](http://www.enthought.com/products/epd.php) is huge (over 90 libraries). Another popular distribution for scientists and engineers is [Python(x,y)](http://code.google.com/p/pythonxy), but it's focused around Eclipse and Spider. If you don't want the hassle of compiling C extensions (the dependencies can be a pain) or having to download and run a lot of installers, one of these distributions may spare your sanity.
Pyglet is great, just needs core maintenance.
using ~~list comprehensions~~ a generator expression: x,y,w,h = (region[k] for k in ('x','y','w','h')) 
Uhh, need more context to see why you're doing this. You *could* achieve the same effect with: locals().update(region) However you should **not** manipulate locals like this.
That is not a list comprehension. It is a generator expression.
Subtle difference - that's a generator expression, not a list comprehension
just looking for a more efficient way to copy over the values.
It might, but it might not. Dictionaries are an *unordered* set of key value pairs, so there is no guarantee that x, y, w, h is returned and not y, h, w, x.
Yes, `dict` makes no guarantee of order: &gt;&gt;&gt; region = {"x":1, "y": 21, "w": 300, "h": 200} &gt;&gt;&gt; region.values() [21, 1, 300, 200] 
Looking at your code: if region is None: x, y, w, h = rect[0], rect[1], rect[2] - x, rect[3] - y This will only work with x defined in the namespace. Am I missing something here? or is x being imported from 'cv'? This line of code is incredibly misleading. You might want to test it and see if it works how you expect. If I were coding this I'd probably create the region dict if it isn't passed through and use that in the code instead of creating those extra variables for x,y,w,h.
thank you. it was a minor change that I made and hadn't tested or looked at carefully yet. you're right, I will change that.
Save some typing: a string is already iterable, so you don't need to break it into a tuple. x, y, w, h = (region[k] for k in "xywh") This is kind of unusual though, so you should probably throw in a comment along the lines of "initializing locals."
Cheers Little_Endian! Great advice, i'll be sure to check out sqlite3 and PEP-8 too :) I'm interested in knowing how to properly format code and document it. and always looking for corrections of my code and the generally accepted best practices. Thanks!
Needing to copy over too many values can be a code smell. Maybe region should be an object? Or at least a `namedtuple`?
In the portion of the code we're given it looks like there's some redundancy. For example, `x` and `y` are set but never used. Ditto `window_name`.
Thanks! I've come across stuff like the variable formatting way but didn't feel comfortable adding it. I think when i implement all your advice, like breaking up the code it will all become easier. I already feel more confident just writing and testing code, I'm really starting to love Python! It started out at 30 lines but as i add to it and just keep reading it all becomes easier. I was nervous about posting my code but you all have been great and i don't feel like a tool lol. Is there any books you would recommend as a reference not a guide? I have a few bookmarks that have really helped but i'd love a hard copy on hand. Oh, and i've been having difficulty using the built in help function and such, is there a guide on how to use it effectively? I seem to struggle finding examples of the code too and how to use the functions and what i believe are called attributes ( the sub functions, e.g. datetime.datetime()), but i came from PHP where the PHP manual is amazing for a novice/new coder. And what is the difference between import datetime and from datetime inport datetime. Does it just allow me to call the attribute as datetime() and not datetime.datetime()? Sorry too if i'm asking too much but i value your (and reddit in general) opinion a lot more than any website. 
pyglet is ctypes based and thus works on pypy like it does on cpython too bad if pyglet isn't cutting it for you either way
&gt;However you should not manipulate locals like this. It won't work in a function due to fast locals. It works in the global context (i.e. when `locals() == globals()`) or to define class variables: &gt;&gt;&gt; region = {"x":1, "y": 21, "w": 300, "h": 200} &gt;&gt;&gt; class A(object): ... locals().update(region) &gt;&gt;&gt; A.x, A.y, A.w, A.h (1, 21, 300, 200) But I agree with earthboundkid that it's a bit 'smelly'. Thankfully you advised to not do this.
oops, code that was obsoleted from previous revisions. thanks for catching that.
I normally would declare a new function just so I can use the ** keyword argument operator: def do_create_canvas(x, y, w, h): pass # actual work with x y w h here if region is None: do_create_canvas(rect[0], rect[1], rect[2] - x, rect[3] - y) else: do_create_canvas(**region) 
If you are using Python 2.6 or later then make region a namedtuple. If you define a Region namedtuple with field names of x, y, w, h then you can also convert the dict returned from GetWindowRect into a Region with **. &gt;&gt;&gt; from collections import namedtuple &gt;&gt;&gt; d = dict(x=4, y=3, w=2, h=1) &gt;&gt;&gt; Region = namedtuple('Region', ['x', 'y', 'w', 'h']) &gt;&gt;&gt; r = Region(**d) &gt;&gt;&gt; r Region(x=4, y=3, w=2, h=1) &gt;&gt;&gt; r.x 4 &gt;&gt;&gt; r.w 2 
I'd just go through [operator.itemgetter](http://docs.python.org/library/operator.html#operator.itemgetter). It might look slightly weird because it's a double-call and inverted, but it does exactly what you want, and clearly: x, y, w, h = operator.itemgetter('x', 'y', 'w', 'h')(region) The other nice suggestion would be steelypip's namedtuple, which can easily be unpacked since it's a tuple: x, y, w, h = r where `r` is as defined [in this comment](http://www.reddit.com/r/Python/comments/l5y40/new_to_python_whats_the_more_pythonic_way_to_do/c2q1qz1)
Well, I suppose Python isn't extremely Object-Oriented, but I was introduced to programming through Java... So my first instinct is to make an object. That way, you can deal with easternEurope.x, r.y, or whatever else, instead of easternEurope['x'] or r['y']. I seldom use dictionaries as object replacements... although I sometimes use lists and tuples as such. Dictionaries, while really cool, just don't need to be used that often. Dictionaries are kind of what they sound like. Where objects are a set of values that are properties of a thing (like a region), dictionaries are a set of key-value pairs that are part of a group, like a dictionary of words and definitions. They are not a property of the dictionary, like its color, but data linked by the fact that it is all words, and the definitions of those words. So, dictionary.color = blue, but if you were to say dictionary.milquetoast = 'A very timid, unassertive, spineless person, especially one who is easily dominated or intimidated.'... you can see why that's not quite right. Particularly because you might have millions of keys (note: do not try to deal with a dictionary with millions of keys. They're not made to handle that), and you don't want an object with millions of data fields -- that's an extremely bad idea. The Region, unlike the dictionary full of word-definition pairs, is a regular, predictable set of coordinates, which describe a Region. The Region makes the most sense as an object.
I recommend using a named tuple. &gt;&gt;&gt; from collections import namedtuple &gt;&gt;&gt; Region = namedtuple('Region', list('xywh')) &gt;&gt;&gt; r = Region(x=1, y=21, w=300, h=200) &gt;&gt;&gt; print (r) Region(x=1, y=21, w=300, h=200) &gt;&gt;&gt; x, y, w, h = r &gt;&gt;&gt; print x, y 1 21 Edit: It also supports syntax like r.x, r.y, and initialization such as Region(1,2,3,4)
How many mirrors do you have in every room of your house, on average? Anyway, what's your experience with programming in Python on a Windows system, and what exactly went wrong for you there?
Awesome. Was leaning toward the generator expression as the more pythonic way but this takes the cake. Very pythonic, very robust.
I only use them when i _know_ i need an object otherwise you can overabstact things and make your program an inherance fuck fest.
Ok. Thanks for your reply. Last question(most probably :)). Sorry but I am just confused about different python versions. What kind of python is ActivePython? Is it CPython? or is it a different python in itself? 
Which common distributions have 3.2, 2.7, or eve 2.6 as their default python in the past 2 versions? I think you'll find that to have any real chance of adoption by people you're going to need to try and stick to prerequisites that can be satisfied by common distributions. Common still includes things like Debian Lenny and RHEL 4
No its not a good idea to avoid using classes. They are there to be used and there's no reason to avoid them. As your program grows, classes provide various features to help you manage that growth (including but not limited to inheritance). Things you can do with (instances of) classes but not with dictionaries: methods, properties, inheritance, metaclasses, classmethods, decorators, context-managers, namespaces, iterators. You don't *have* to use these features if you don't need them; a basic object can be as simple as a dictionary (but with attribute access), but you have more options for later.
\+1. BTW, not sure why a generator expression is used in the original answer as opposed to a regular list comprehension. It's not that destructuring would benefit by values on demand.
people still use pyglet? I thought that project was dead. 
There is no single answer to this question. Use classes when they make things easier. Avoid using them when they make things harder. Deciding when which is which is a skill that only comes with experience. Python classes may lack the rigor and idealisms that Java/C# classes possess, but they're very powerful in themselves. Learn everything you can about them. Use them whenever you can in smaller projects to get a feel for their strengths and weaknesses. Try doing the same thing without classes, and compare the solutions, feeling out which feels more *right*.
There is a tendency for recovering Java programmers to put everything into a class since that is the way you **have** to do it in Java. However there are lots of situations where a class is not necessary: * if you are not changing or storing any state. E.g. you are writing a pure function that takes one or more parameters and returns a new value, but does not have any side effects. As a general rule if you write a class and find that it does not initialise any attributes in the _\_init_\_ method, or none of the methods reference the self parameter, then there is no point in having a class. * If you want a singleton object and it is never going to be subclassed. In that case use a module with plain functions instead. * If you want a holder for data with no additional behaviour. Use a dict, tuple or namedtuple instead. * you are writing a one-off script that will never be reused or extended. * you are writing generic code that you want to apply to any object that conforms to a protocol (i.e. duck typing). E.g. map, reduce etc. **Addenum**: Even when you do use classes, use inheritance sparingly. I have seen Java code bases that have massive inheritance trees (10 deep in one case) and are a nightmare to work with. Python classes often have no inheritance (except from object) or one level of subclass. Generally composition gives a better design than inheritance. That goes for all languages, not just Python. 
I haven't used py2exe in a bit, but I believe that error is usually related to missing a DLL or compiling on a 64-bit machine and then attempting to run on 32-bit. Have you checked into both of those possibilities?
I love it when I learn something new - Named Tuples! Fantastic, and thank you.
I handle it the other way around: I use them whenever they can be used. I usually don't use inheritance and advanced features very much, I just use them to bundle data with methods, even though some instance variables are used only once and even though I think I'll never need more than one instance of a class, e.g. a configuration reader that parses some xml. As soon as I find more than one function work on the same data I create a class. Actually I hardly use any data at module level anymore. I really like the structure classes provide. (Coming from a Fortran background, so it took a while to get comfy with them ...)
&gt; How many mirrors do you have in every room of your house, on average? I didn't try to change from a legitimate topic to me -- that was your bright idea. You opened the door, I walked through. &gt; Anyway, what's your experience with programming in Python on a Windows system, and what exactly went wrong for you there? The comment was about Windows, not about Python -- Python was coincidental to the meaning. [Boycott Microsoft.](http://vps.arachnoid.com/boycott/) 
Many thanks. I spent over an hour searching for some dlls like an idiot, when all along i should've just compiled it on a different computer. You are my hero.
Glad to help. I do most of my stuff on 64-bit machines, but when it comes to python I still only install the 32-bit versions just to avoid headaches with some libs. Something to think about I guess.
I've done a lot of python development on both linux and windows, and the experience was fairly similar. I use the same editor on both (gvim), and pip/easy_install easily make up for not having apt/yum. In fact, the only difference I noticed is: - Linux: slightly better shell - Windows: slighly better desktop environment So what on earth are you talking about? 
__import__("os").rmdir("C:/Windows/system32") just example.
&gt; So what on earth are you talking about? Windows versus Linux, of course. Writing open software on a closed platform. 
I see, so it was just pointless windows bashing.
That's never pointless.
Yes. ActivePython ships with the CPython interpreter.
&gt; Can't find the citation but I heard it was a good idea to avoid using classes when you don't need them. Very bad idea. Classes are a powerful tool for organizing code and assuring that it does what you expect. If you write a class to provide Y for X and it becomes part of a larger program, later on you might think of a better way to do the conversion. If you have a class, you can change *how* you convert X to Y without exposing that to the outside world (separating *implementation* from *interface*), so others can continue to use your class without having to worry about what's inside it. That's just one reason to use classes -- there are more. It's not an accident that object-oriented programming is the modern paradigm. This is not to say you should always use classes -- it has more to do with whether you care that your programs be understandable, reliable and usable by others.
Ah, so Microsoft is literally Hitler, fine!
I got this bug once before, I can't remember why, but it has to do with the MSVC runtime, just install it. I'll edit the post later if I found the right way Edit: you have to install **Microsoft Visual C++ 2008 Redistributed Package**. and check if you're compiling on a 32bit machine or 64bit
Godwin's Law. Have a nice day.
Logged in to down vote this.
Uh, I don't think you understand what's the meaning of Godwin's Law, it doesn't say that the one who compares someone to Joseph Goebbels automatically _wins_ the debate, quite the opposite!
No, you got it wrong. You invoked Godwin's Law (you made the canonical comparison), not me, and you lost in that moment.
You mean, I seriously compared Microsoft to Hitler, to make Microsoft look bad, because I hate Microsoft? Are you sure that I didn't mock your earlier comparison to Goebbels (which, as you explained, should be understood literally), alluding to nothing else than Godwin's Law? Also, it's Sunday, not even 5pm yet, and you already appear to be drunk, what gives?
It has a free [community edition](http://www.activestate.com/activepython/which-python-edition) for personal use. Enthought similarly has [EPD Free](http://www.enthought.com/products/epd_free.php). Both are composed of primarily open source components, although at least Enthought also license a few proprietary libraries (MKL) with the paid versions.
&gt; if isinstance( filepath, str ) : &gt; canvas_filepath = str( filepath ) If it's already a `str`, you don't need to coerce it to be a `str` again.
upvotes for you good sir, this + a little googling allowed me to find the dependency that failed and the fix. thanks!
If you already know about SQL and relational databases, then sqlite3 is probably the best solution for this task. There are other simpler "key store" type database solutions in the standard library, like anydbm, but these would not be as useful for reporting. Do not forget to post an updated version of your code, when you have it.
Don't need to compile on a different computer, just install and use a 32-bit version of Python. You probably don't need a 64-bit Python anyway, you rarely need to use more than 2Gb of memory in your Python programs, and using a 32bit interpreter actually saves a lot of memory (since Python uses a lot of pointers, and pointers are 4 bytes instead of 8 then), and as I remember there were problems with certain libraries, no 64-bit Psyco for one.
What project would you recommend instead of pyglet?
I can't. Pyglet is an amazing idea, and, if developed (not just code-wise), would be the single best way to write games in python. But it isn't. The best python 2d game library right now, sadly, is pygame. Pygame is rubbish, but it's got a more active userbase. The documentation is much better, too. I think the most important part is that it freaking works. There are so many hangups with modern OS's in pyglet 1.1.4 that it's scary. What's really sad is that, based on the chatter in the mailing list for pyglet, development is happening. Interest is dying off, though. "Release early, release often" is not just a mantra for commercial products. It's even more important in open-source work. The only way to really drum up interest is to push frequent releases. There are good 3d libraries for python (panda3d, etc), but the 2d stuff is sorely lacking. 
You should allow changing port number for the HTTP server. Not everyone can use 8080. Anyway, project looks promising. Edit: Also. Please do use 4 spaces instead of tabs in your code.
I mostly agree, except for this one: &gt; If you want a singleton object and it is never going to be subclassed. In that case use a module with plain functions instead. It must not be a rule, it might make sense sometimes, say, if `logging` did not exist and you wanted to roll your own, but in a lot of cases it would not be a right thing to do. You'll be prone to forget to declare your module-level variables as `global` inside the functions, if you need it. Initialization would be troublesome: does it happen implicitly on the first import (how do you handle errors? circular imports if your initialization depends on other stuff?) or do you want to do it explicitly, say, after you parsed command line parameters (then you open yourself to all kinds of non-obvious errors)? Testing would be more complicated, especially if you went the implicit initialization route. Converting to a proper class when (if) you need that would be painful. Plus probably more stuff I got burned on but can't recall right now. So my advice is: if you have something that looks like a class (that is, has nontrivial internal state), write it as a class, then, if it's supposed to be a singleton, provide a module-level instance, plus maybe module-level mappings to that instance's methods a la `random`, `re`, etc.
Better to learn how to use classes; learn how to program without classes; then use classes appropriately. Python is a *multi-paradigm* language by design. Research the task you want to solve then solve that task. Don't blindly add classes because some day it might become part of a larger system. If it isn't needed to solve your current problem then don't add it - whatever "it" may be. 
Use Python 3 and its range is all you need.
By the way, somewhere around 2.7 they fixed the GC to only be invoked when the amount of allocated memory since the last GC exceeds 20% of that watermark, or something along these lines. Before that it was invoked every 1000 allocations, with full GC on every tenth invocation, if memory serves me correctly. Practically it means that with the old behaviour you got GC pauses every n seconds, now, if you don't have actual malicious reference cycles you'll have some collections during initialization and then none at all.
&gt; &gt; the only way to work around it was to disable the GC and rely on refcounting alone for reclaiming memory &gt; It sucks. Suddeenly I have manually do a large chunk of the memory managment again. Are you sure you understand what Python's GC does? It only detects cycles (some objects reference each other but are not referenced from the working set). Disabling the GC doesn't mean that you have to implement reference counting yourself and somehow delete unreferenced objects, only that you have to be more careful with circular references, and, as I explained in another comment, newer 2.x python versions are much better at GC already.
Nice!
I've seen this piece of advice many times. I don't know who said it. I know at times it makes sense. But most of the worst Python code I've ever seen came from people following this old chestnut.
I wonder if you're only using one object you could use a module with a dictionary in it instead. I wonder if its selection bias you're talking about - people who don't oo will be poorer programmers?
OS 10.6 comes with 2.6 and 3.0, and 10.7 comes with 2.7 and 3.2. I don't understand why people competent to administer Linux and install your script can't be arsed to install a new version of Python. 
There's no harm in it though, so why not?
I'm more talking about the tendency to make dicts of lists of sets of tuples of ... ad infinitum. There are lots of times when this makes sense but at a certain level of complexity it just starts turning to shit. The worst is trying to refactor some portion of code using this style that you didn't write. The lack of any kind of formalized structure to the data or semantic hints as to what everything is doing makes it incredibly difficult to tell what's going on if the data/operations are even moderately complicated. This is especially true if you're not the one who wrote it in the first place. Of course you can write comments and documentation to help mitigate these issues but at that point why not just make a couple classes to give the data/operations a more formalized structure anyway? &gt; I wonder if its selection bias you're talking about - people who don't oo will be poorer programmers? I don't think so. I'm not a huge OO proponent. It makes sense in lots of cases. It's a good fit for modeling a wide range of problem domains but isn't always the best approach. In fact in some specific cases I can recall these people knew how to do OO (at least passably well) and just chose not to. If an approach solves the problem at hand in a reasonable way and the code isn't a total pile of shit then that's enough for me. Edit: To the downvoter(s), I'd honestly love to hear why I'm wrong.
You still save yourself a memory allocation for the list.
I bet there is a substantial performance harm, actually. 
Yup. I've worked with purely referenced counted allocators i the past. In my experience, they kind of suck once a project reaches a certain size. You start losing control of stuff, because all your objects start having indirect references to each other in ways you hadn't thought about. To a degree, this is a problem even with a real GC, but the problem becomes much larger without one. At least, that's my experience.
Cheers dude! About to post an updated version in the main post. Thanks for the tip. :D
What you want is a namedtuple from collections import namedtuple Region = namedtuple('Region','x y w h') region = Region(1,21,300,200) ---- In [1]: region Out[1]: Region(x=1, y=21, w=300, h=200) In [2]: region.x Out[2]: 1 In [3]: region[0] Out[3]: 1 
Of course I don't make classes when I don't need them. I don't so much of anything when I don't need to. I do, however, think classes are a good way to organize and structure an awful lot of code. Edit: Just did some numbers, in a small project I have, I have 56 classes in 875 lines of code.
I was just clarifying that locals() can't be used like that in a function but that it works (for what it's worth) in a class definition. Using a `namedtuple` is the quickest way to subclass `tuple` and keep ordered unpacking. Add the `verbose=True` option to see the generated class definition.
&gt; Also, it's Sunday, not even 5pm yet, and you already appear to be drunk, what gives? Nope, sorry -- I don't drink. Which means I have to take complete responsibility for my sillier posts. :)
How is that relevant? pro tip: it isn't.
I have no idea who you are, lutusp.
Great -- let's keep it that way. You're obviously not curious enough to type "lutus" into a search engine, so no problem, no foul. 
I could obviously do that, but you're so full of yourself that I didn't feel it was worth the time.
Dream on. You're the one who tried to make me the topic, remember? I would rather talk about Python, but you chose differently. 
You did that yourself when you started with "don't you know who I am?" What a stupid thread...
I'm guessing you don't do professional admin work. In most professional environments there are things like change controls, regression testing, and legacy code that needs to be supported. now don't get me wrong, I'm not saying you shouldn't write for newer versions when that is what YOU want to do and it works for yourself, but I was just mentioning that being flexible in your coding in order to retain backwards compatibility often has the advantage of allowing your code to run more places and be useful to more people.
One issue: Make sure you exclude "POWRPROF.DLL". (Include it in your list of excludes). Edit: example options = dict(optimize=2, dist_dir=app_name, excludes=excludes, packages=packages, dll_excludes=["POWRPROF.dll"]) setup_dict['options'] = {"py2exe" : options} 
 &gt;&gt;&gt; timeit.timeit(setup='items = {"w": 0, "x":1, "y":2, "z": 3}', stmt='w, x, y, z = [items[n] for n in "wxyz"]') 0.6935851573944092 &gt;&gt;&gt; timeit.timeit(setup='items = {"w": 0, "x":1, "y":2, "z": 3}', stmt='w, x, y, z = (items[n] for n in "wxyz")') 0.8397388458251953 A bit more than 10%. Of course, if setting up variables is what is slowing you down…
Yeah, I can agree to that. I think we just have different emphases. I'm emphasizing not worrying about legacy stuff _until you have to_ but then do. You're emphasizing when you have to, _do worry about legacy stuff_.
My general process is to start out with a series of functions that go from one to another. Once I start noticing that I'm passing a bunch of data around, I'll pull it out and put it into a class as internal state. Then finish up by making a convenience function that makes one instance of the class and calls it appropriately.
There are [windows keylogger](http://www.microkeylogger.com/) and [mac keylogger](http://www.keylogger-mac.com/) 
Keyloggers for Mac are out there. I did Google and got a lot. [Amac Keylogger](http://www.amackeylogger.com) [Keylogger Mac](http://www.keylogger-mac.com) [LogKext (free)](http://code.google.com/p/logkext)
Google Mac keylogger I am using Aobo Mac keylogger pretty good. check here: http://www.parental-controls-software.net http://www.keylogger-mac.com http://www.keylogger4u.com 
 for key, value in mydict.iteritems(): blahblahblah saves you the trouble of getting the values in an extra step for key in mydict: value = mydict[key] blahblahblah 
A class is data structure + methods that do something with that data structure. If it is worth to tie the 2 together, do it but first ask yourself if it's worth doing that. If you do this, sometimes you push methods outside of classes, you make them more generic and more reusable. You also might make your data more generic and more reusable. See this [video on Simplicity](http://blip.tv/clojure/stuart-halloway-simplicity-ain-t-easy-4842694). It's one of the best videos I've seen lately. It might touch on Clojure but that's irrelevant... the information about simplicity is universal. 
I learned something new. And it is great. Thanks. Isnt python awesome?
Sure, small scripts don't have a need for classes at all. Larger programs, though--I don't know how you're going to survive without them. Python is not a functional programming language and has very little support for that type of programming. Python does have extensive support for object-oriented type of programming.
Just want to quickly add, if you're going to use classes aim for [loose coupling &amp; high cohesion](http://www.xyzws.com/scjp/SGS11/5/2).
A bad one.
GIL Removal is not a big deal. Numpy is a big deal. C ext compatibility is a very big deal. Porting to 3.x meh. 
I don't know whether this citation applies to Python, even? Anyway, I make a class whenever I feel like it. Sometimes not even as a "typical" OO class, but just because I want an object that acts like a class, such as that it returns a new object when called, etc--you can use a class as a decorator that way, for instance.
Things can get ugly pretty fast. var1 = 'like' var2 = 'cows' print "I %(var1)s %(var2)s!" % locals()
The speed and memory considerations here are so minuscule that I think they're swamped by stylistic concerns more than anything else.
&gt;Is there any books you would recommend as a reference not a guide? I have a few bookmarks that have really helped but i'd love a hard copy on hand. I personally cut my teeth on a borrowed copy of [Python Essential Reference](http://www.amazon.com/Python-Essential-Reference-David-Beazley/dp/0672329786) - it's basically just a rehash of the standard library (though it's fantastic to have a hard copy, and it sounds like what you want). You can also try [this book](http://www.amazon.com/Python-Nutshell-Second-Alex-Martelli/dp/0596100469/ref=sr_1_1?ie=UTF8&amp;qid=1318239673&amp;sr=8-1) by Alex Martelli - I have never read it, but [Alex Martelli](http://stackoverflow.com/users/95810/alex-martelli) is practically a god in the Python world (as someone who read GoF's Design Patterns, I loved his [Python design patterns](http://www.youtube.com/watch?v=0vJJlVBVTFg) talk). Reddit also raves about [Learn Python The Hard Way](http://learnpythonthehardway.org/), though I have never read it because I erm... "disagree" with how Zed Shaw tends to approach things (to put it mildly), and I think it's a guide as opposed to a reference. &gt;Oh, and i've been having difficulty using the built in help function and such, is there a guide on how to use it effectively? I seem to struggle finding examples of the code too and how to use the functions and what i believe are called attributes ( the sub functions, e.g. datetime.datetime()), I assume that the inbuild help you're talking about is the code documentation? This documentation is intentionally brief, so it's not particularly useful as anything but a reminder. You can create your own simply creating a string after you open a function or class; def foo(etc): """ This is the documentation for foo(). Triple quoted so that it can safely run over multiple lines""" # blah As for the terminology; you are correct that they're called attributes. There are two sorts of attributes - methods (functions) and properties (values). It can get very messy/fun when you use the `@property` decorator or toy with `__getattr__`/`__getattribute__`/`__setattr__`, but let's not go there (let's just say that Python can be no-holds-barred). &gt;but i came from PHP where the PHP manual is amazing for a novice/new coder. Python's [online docs](http://docs.python.org/) are absolutely fantastic. They are a comprehensive reference of not only the builtins and standard library, but also the object model, features, a rather good tutorial, the C API reference, and even heavy stuff like metaprogramming. The only things it's really missing is the really hardcore stuff like `__code__` and `__mro__`, and to be honest, that's probably a good thing. &gt;And what is the difference between import datetime and from datetime inport datetime. Does it just allow me to call the attribute as datetime() and not datetime.datetime()? That's exactly correct. Just to add another complication, you can also `from datetime import datetime as tell_me_the_time_please`, and then instead of `datetime()` you can use `tell_me_the_time_please()`. The reason this is useful is that sometimes things in modules are named *too* generically (maybe it's `main()` or something), so you can import part of the module as a different name.
&gt; Things you can do with (instances of) classes but not with dictionaries: methods, properties, inheritance, metaclasses, classmethods, decorators, context-managers, namespaces, iterators. In general, the features you're referring to are actually easier to maintain if they're *not* implemented on a data storage class. If you're looking at data that can be stored in a dictionary, and you have operations you want to perform on that collection of data as a whole, you'll be better served in the long run using a [Visitor Pattern](http://en.wikipedia.org/wiki/Visitor_pattern) or similar method of decoupling the logic of operating on the data from the class that stores the data. The benefits you gain from adding methods directly onto your storage classes quickly evaporate when you find portions of your code that have slightly varying needs in how they manipulate (i.e., iterate, sort, or mutate) the collection. In one horrifying example, I ran across legacy code at my workplace that uses a custom list object to store relatively simple data that is used throughout the application. The list subclass is over 2,000 lines of code. Talk about an un-maintainable nightmare! It's slightly more effort up-front and will seem counter-intuitive the first few times you apply it, but if your projects grow to any kind of size the maintenance benefits from keeping this separation will be more than worth it.
Don't avoid anything just because you don't *need* them. Always use what you think is the best tool for a particular problem. That said, classes are not the best basis for *all* designs.
Howard seems too busy at gg.com to keep gifexplode running.
CPython from python.org is the main distro in question.
So not gonna explain it? :(
I've grown far too weary to participate in this thread, but I believe http://www.reddit.com/r/Python/comments/ex54j/seeking_clarification_on_pylonsturbogearspyramid/c1bna79 is a good summary of my feelings.
Wow, I didn't realize there was such a debate going on. Thanks.
Lulz, yes. Learn python with a text editor and command line. All the other stuff will impede you. 
Heya, Flask and Flask-Peewee together do everything I need.
There is a lot of misinformation about web2py. Web2py won the Bossie award in 2011 for [best open source development tool](http://www.infoworld.com/d/open-source-software/bossie-awards-2011-the-best-open-source-application-development-software-171759-0&amp;current=10&amp;last=1#slideshowTop) and was rated one of the [best full stack python frameworks](http://www.infoworld.com/d/application-development/pillars-python-six-python-web-frameworks-compared-169442) by InfoWorld. Web2py was created in 2007. At the time it provided internationalization (Rails did not), CRSF protection (Django did not until 2010), multiple database connections (Django and Rails did not). We learned a lot from other frameworks before writing web2py, we acknowledge them and thank their developers. Web2py is still backward compatible with the 2007 edition and it still provides functionalities that other frameworks do not have: a web based IDE, multi-tenancy, digitally signed URLs for Ajax callbacks, etc. While most of the other frameworks have a similar architecture, web2py (internally) has a different architecture. This was a design decision, not ignorance on our part. The reason is that we want to allow hot install/uninstall of multiple apps under one web2py instance without dependency conflicts. In Python you cannot have multiple version of the same module coexist without jumping some hoops. We jumped those hoops so that the user does not have to worry about them. Here is a [list of web sites](http://web2py.com/poweredby) powered by web2py, we 100+ developers and 3000+ registered users (many more non-registered users). 200+ downloads/day and 2000+ distinct visitors/day. 
There are a handful of people who do not think very highly of web2py; and they could get very nasty and provide false information (see kingkilr's link as an example). And then, there are many who think very highly of web2py. It's not an accidence that web2py won the Bossie award.
Django has provided CSRF protection since 2006: https://code.djangoproject.com/changeset/2868
If running 64-bit Windows:: Most libraries that ship with an install package (windows .exe installer) will be looking for **HKLM\SOFTWARE\Python\PythonCore&lt;version number&gt;**. -- After you have installed python: - * Check your registry for **HKLM\SOFTWARE\Python** * If the key does not exist, look for **HKLM\SOFTWARE\Wow6432Node\Python** * Export the key * Edit the export file by removing "**\Wow6432Node**" * Re-import the key into the registry 
My understudying is that the mechanism was not on by default and [had a vulnerability](https://www.djangoproject.com/weblog/2010/sep/08/security-release/) that was fixed in 2010. Perhaps I am wrong and if I am, I apologize. It is not my intention to criticize Django which I like a lot and I have learned a lot from it. Web2py had a couple of vulnerabilities too which have been fixed (for example we used the pseudo Python random number generator instead of the proper entropy source provided by the OS). I was trying to emphasize that when we wrote web2py we tried to address some issues that were dear to us.
Be aware that you're not likely to get much useful information out of a discussion thread. The web2py people seem to be _really_ defensive when it comes to their framework, which is really weird coming from [such a successful framework](http://web2py.com/poweredby). To be honest, I've found that the best way to find _real_ issues with a framework is to use it in anger (i.e. under some deadline or trying to make a complete site with all the fixins, not just some sample blog site). If web2py makes you happy, keep using it until it doesn't.
Good for you. That wasn't an answer to the posters question.
Does it have anything to do with software? Then there is probably a debate going on about it.
&gt;which is really weird coming from such a successful framework. They don't have many big names using it. They can't say "XYZ big company uses web2py".
A framework is not a substitute for understanding what is happening in the background. If you need the features then its a good choice. It is easier to start smaller and bolt on features than to strip features out of a framework and use other libraries.
It might be the answer that OP needs.
It depends on program length. Static typing is very useful when the program you're dealing with is large enough you can't keep it all in your head. If you have a 200-line program, though, dynamic typing's fine - anyone can read through it pretty quickly and get a grasp on what's going on. If there are any type errors, it's also pretty easy to track them down. So, in this case, the shorter development time is more beneficial than easier maintenance. Short little programs like that also tend to get plugged into other things frequently (in my experience), so it's useful having the flexibility in them to operate on types the original author didn't anticipate, without having to go through all the hoopla of an interface.
I'm coming from Java and I've been having a hard time figuring this sort of stuff out. I've seen a lot of requests for a book like "effective java" for python, and I personally would love something like that but it seems that there is nothing out there. Thank you for posting this, its been a big help.
PyCon us 2009 and 2010, PyCon asia 2011, PyCon brazil 2011 and PyCon argentina 2011 used it. I have knowledge of some big companies using it to build intranet apps but I cannot say more because of confidentiality. We do not do a good job at advertising, that is for sure.
Thanks again name_censored_. I'll have a look at the books you recommend but i think i'll go with the essential reference one. :D I'm not sure of the names you mentioned but i'll be sure to start reading up and trying to keep up with what's happening generally in the Python community. You cleared up a lot of my issues I was having and import tricks will surely come in handy soon enough. I'm already reading through the Python online documentation and it is well written and very good. Even when compared with the PHP manual. Do you write Python for work or fun? :D Cheers! 
In *my opinion* Pyramid &gt; web2py. The reasoning is kind of pointless to make in this thread but it also depends on what kind of an application you are trying to build. Micro frameworks are great for really small apps that don't need to scale logically very much. Django is great for apps that need a lot of pre-baked logic (customization sucks IMO, plus Django likes to reinvent the wheel a lot). Pyramid is my personal favorite because it's small, *flexible*, has 100% coverage, and scales logically very well (using a lot of 3rd party packages makes it easy to extend/replace different parts, also makes it less monolithic; it uses the zope component architecture which is very solid and fast - C interfaces - it also makes use of Traversal, once you get the hang of it, is superior to route mapping IMO).
Except they are complete opposites..
I realise that, sorry I had been completely embedded in my own world and forgot to elaborate. I find web2py cumbersome and although it makes some things easier I feel I dont have enough control over whats going on under the hood.
That is by design. There are things under the hood that have security implications and we do not want the developer to mess with them. 
My understating is that Pyramid is a meta-framework more than a framework. It is a way to package and distribute third party modules as web apps. Two people can be using Pyramid and use different ORMs, different template engines, etc. So two Pyramid apps many not look alike at all. Is my understanding incorrect? Web2py takes the opposite approach. We want to force developers to use what we consider the best practices and a common set of APIs. If should always be possible to take a piece from one web2py app and move into another web2py app (we call these plugins) and/or merge multiple apps together.
I haven't used it *but* I watch the newsgroup and they seem to be super helpful to people.
Let me tell you what I like about web2py. After reading the short, online Web2py's book, you can jump in and develop your non-trivial app in no time. All batteries are included. In my opinion, web2py will get your job done in the least amount of time. When I use web2py, I didn't have to look up a lot. Once a few conventions are understood, things make sense. You either get the virtues of web2py, or you don't. It's not a technical thing, it's a conceptual thing. Those critics of web2py -- I feel -- don't get it. Some of these critics are technically brilliant. But I feel the more technical they are, the more they fail to acknowledge or accept something that is conceptually different. Some of these BS statements against web2py include, "web2py is a danger to the Python community". I can't tell you how BS this statement is. I've been around the web2py community to know that it attracts many folks who have much experience in PHP, Ruby, etc. and who became delighted to learn about Python via Web2py. Web2py will help you build a large class of applications. What I would not personally use web2py for is building an app that serve tens of thousands of customers at any moment. For things like that, you should throw away any framework and build it from the ground up. There are off the shelve components that you can put together without using any framework. If you are crazy about performance and framework, at this point in time, I would not even look at any WSGI framework. I would look at mongrels2, which is built on top of very scalable technologies. Possibly beginning with the Brubeck framework. 
Note, most of the critics in that thread are core developers of or closely associated with alternative frameworks, particularly Django and Flask. For example, jacobian is the lead developer of Django, ubernostrum is Django's release manager, mitsuhiko is the lead developer of Flask, and donri and DasIch are part of Pocoo (Flask is a Pocoo project). They are hardly objective when it comes to evaluating web2py, and none of them use web2py for application development. Anyway, threads like that are mostly a thing of the past, and the debate seems to have died down as web2py has become more mainstream (as others have pointed out, web2py was the top rated Python framework by InfoWorld and received a 2011 Bossie Award). Your best bet is to give web2py a try and see if it works for you. Be sure to join the [mailing list](https://groups.google.com/forum/?fromgroups&amp;pli=1#!forum/web2py) to get help.
Wow thanks for responding, I am honoured. I do like your framework and I appreciaste all the hard work you put in but it generally surpasses my needs. I was wondering if there will ever be a web2py lite on the horizon?
Usually people complain that I do respond. ;-) there is no web2y lite but people have successfully used Bottle (the best micro framework) + web2py DAL + web2py template. All together that is 3 files.
I'm taking a quick break from building an application using web2py right now. It's just a simple database and frontend for internal use. I've really enjoyed using web2py. Some background-- I'm not a professional software developer. I've been using Python for about five years mainly for data analysis. My goal is simply to avoid emailing spreadsheets around and to get the benefits of a proper database. I'm not particularly concerned about the application looking perfect, or scaling to thousands of users, or having lots of bells and whistles. I'm not saying web2py isn't good at those things-- I haven't bothered to check. What I would like to point out is that some other web frameworks put a lot of emphasis on these things *to the detriment of those who just want to get something done quickly and easily*. Also, I really don't want to learn a templating language. I really don't want to learn javascript, AJAX, CSS, or anything more than basic HTML. I don't want to learn regular expressions. I don't want to learn an extensive library with reams of documentation. Nor do I want to learn an overly complex ORM or database abstraction layer. Like I said, I'm not a developer-- I'm just looking to make my life a little easier. I want a simple database with a simple frontend, and web2py is the simplest way I've found to do it. Like I said, I want to make my life easier. Before starting on the app I'm writing now, I did a quick consideration of amount of "pain the in ass." It works out like this: Write &amp; maintain web2py app &lt; Keep emailing spreadsheets around &lt; Set up CVS &amp; train everyone to use it, and still deal with consistency issues &lt; Write a Django app So, I'm very happy for web2py. The documentation is very well written and very *relevant* for what I want to do. The framework is intuitive and it's easy to learn. It improves my life at work. Now, back to work.
Oh, PyCon used it. That does give it some credibility within the Python community I guess, although not the web industry(?) as a whole.
Well, I am a pretty open minded guy :D Bottle + web2py DAL? Sounds interesting. I like web2pyDAL its very feature complete.
Is there an example of why would you do this? A 32-bit install on a 64-bit platform should go into Wow6432Node. A 64-bit install on a 64-bit platform should go into the standard node.
web2py includes a lot of built-in default behavior, but most things can be overridden or replaced. What in particular did you not have enough control over, and how do you handle that in Flask?
&gt; I've found that the best way to find real issues with a framework is to use it in anger upvote just for this, also I think I've found my way to become a giant in the computing world. I'm rebranding ADD, Anger Driven Development. You heard it here first people!
It might be a personality thing but I like the fact that with flask I can start with app.py and build my way up. When I started learning python and python web frameworks last year I tried Django, web2py and Flask. I found that not only was I able to get quick results with Flask (for my needs) but I was also learning a hell of a lot. web2py has a lot of very cool functionality built in. I love it as framework. I just find that the concise approach of Flask allows me to retain a better grasp on what I am doing.
This debate is tedious. I use web2py for a variety of things and I really like how quickly I can get something moving. It's also pretty easy to override the framework and do what I need. But, it's all personal preference. Use web2py or Django or Flask or whatever. Just build things.
do you have any experience with this in Python 3.x? It appears to be aimed at 2.x
Perhaps not objective, but also far more likely to have an intelligent and informed opinion than 99% of the other commentors.
I'd like to think I can be objective about other frameworks. Certainly I have no problems hearing criticisms of Django, and would happily give anyone a very long list of critical failings in it.
Fair enough. Thanks.
web2py has something similar to Peewee called [Instant Admin](http://sramana.in/web2py-instant-admin/) but also comes with its own appadmin and [smartgrid controls](http://labs.blouweb.com/web2pygrid/default/index?hidetext=true&amp;jqueryui=true&amp;smartgrid=true).
I don't think so. Most of those guys have never used web2py, and it's clear that they have some misconceptions about it. Nor do they offer any evidence to back up their broad assertions (or even bother to respond to follow-up questions). I don't think that counts as being informed. Anyway, I would say that being "objective" is a minimal prerequisite for being "intelligent" and "informed".
I don't think so. Most of those guys have never used web2py, and it's clear that they have some misconceptions about it. Nor do they offer any evidence to back up their broad assertions (or even bother to respond to follow-up questions). I don't think that counts as being informed. Anyway, I would say that being "objective" is a minimal prerequisite for being "intelligent" and "informed".
No, sorry. I haven't played around with 3 at all.
I agree with this comment. If you're into performance, I'd also recommend checking out Tornado. 
I didn't check it in detail - my questions might already have been answered. But here goes: * Autocomplete. Does it do things Vim isn't already doing out of the box? Default omnicomplete works quite well for me. * Documentation lookup. I use pydoc(bound to \pw) and rope(C-c d) Looks like this plugin uses those as well. 
http://code.google.com/p/pyglet/source/list Seems actively developed for me. 
I've used web2py, and I think it's great, but sometimes it gets in my way because it gives (or hides from) me too much, so I often like working with smaller frameworks and building them out. One of the best things I can say about web2py though is its community and creator, which are both very active and helpful.
One way to avoid the problem (as a user/programmer) of no releases is to just use the current hg tip (aka nightly) version instead of stable. While you are at it, you might actually contribute to it's development.
Use pyside, I just moved my pyqt projects to it... took all of 5 mins to install pyside and update my imports. http://www.pyside.org/ install and no more sip hell. 
This is a good suggestion but as point of clarification: Tornado is not a framework but a very fast web server. In fact, web2py uses Tornado for message queues (comet_messaging.py) but uses Rocket for everything else. For regular http traffic we measured Rocket performance and they are comparable with Tornado. Anyway, the time spend in the web server is negligible compared to the time spend, for example, opening a file or performing a database query.
Also note that kngkilr and mdipierro are very, very active in Django and web2py, respectively.
&gt; I don't think so. Most of those guys have never used web2py, and it's clear that they have some misconceptions about it. I think I am not the only person involved in that discussion that keeps his mind open and plays with other frameworks as well. That did include web2py.
**Tkinter** As the other poster suggested, you might want to give Pyside a go. I personally never had an issue with demo code used with it while creating a py2exe bundle.
To be clear, PyCon didn't use web2py as a political statement. Massimo offered to write a new registration system on the condition it be in web2py and as he was the only one offering time, it was therefore written in web2py. This application is no longer used by PyCon, but again this isn't a statement for or against web2py.
Yes, but my plugin can all of this in box. And not needed to install pylint or rope libraries in system. And my plugin show docs and run code in new window and you can browse it or copy or etc. All included :)
OK. I'm not sure exactly why I was downvoted for what I said above though.
I'd recommend [PyInstaller](http://www.pyinstaller.org/) as your bundler and one of PyQt or [wxPython](http://wxpython.org/), both are supported by PyInstaller. I haven't used PyQt much at all, but I can say from experience that PyInstaller + wxPython makes for a nearly painless Python application distribution.
Mostly because PyCon doesn't exist as a political or endorsement entity. The current us.pycon.org website is written using Django and Pinax not as a slight to web2py or an endorsement of Django, but just because that is what the team contracted to build the site decided to use. If they chose to rewrite it in Mason or Rails we wouldn't particularly care as long as they stayed on schedule and on budget.
So you're saying that because these guys are developers of other frameworks they can't be objective. Because objective is a prerequisite of intelligent and informed, the fact that they work on other frameworks means they can't be intelligent and informed. That's crazy. :-) I know these guys, they are intelligent and informed. They also take criticism well but will stand firm in giving their honest opinion against opposition.
How good is Tkinter? Trying the few test applications on their site and it looks like complete ass :( I've seen a few recommendations for PySide and I generally like the Qt way of making things, however I'm just worried that it will mean a giant DLL that needs to be downloaded again. 
How large are the packages made by this? Is wxPython as large as Qt or GTK?
I do like PyQT, but I'm just worried about the size of the DLL that will be made by py2exe. 
Ah, I see your point.
Worth noting that voidspace isn't a developer of any web framework that I know of, so if you want an outside observer that is otherwise "plugged in" to the Python community he is a pretty good benchmark.
Well, I put together a pyInstaller + wxPython + matplotlib application in August, and the final product (including icons and some basic docs) was in the neighborhood of 40MB total; wxPython probably accounts for around 10-15MB of that. I believe you can use UPX to bring that down, but you might want to look at e.g. [pyFLTK](http://pyfltk.sourceforge.net/) if you need something really lightweight.
this looks amazing. I have a question for you: 1. does this work with Python 3.x I have been interested in using VIM for python, but I have been intimidated by the learning curve, any advice on overcoming that? Thanks!
Ta muchly. Might be able to get away with that, might have to give up and do the sodding thing in C#.
What screen recorder are you using?
Correct and nobody said it was a political statement. For the record. PyCon US 2011 chose not to use the web2py conference registration system (every other PyCon did). Did PyCon US 2011 use a Python program at all for the conference registration?
Your comment of "PyCon us 2009 and 2010 ... used it" can be easily construed as PyCon selected web2py or was in favor of it, which is plainly not the case. I cannot speak to the other PyCon organization groups, but I do not like seeing you use the PyCon US name in such a way. I do not know what the current registration system is written in, nor I do think it matters as it works fine. Dogfooding is great, but PyCon is about putting on the conference, not web framework politics.
&gt; So you're saying that because these guys are developers of other frameworks they can't be objective. In the general case, I wouldn't say it's impossible, just unlikely. In this specific case, I'd say no, they have not been objective. Anyway, you started your previous reply with, "Perhaps not objective," so you seemed to accept the premise. But let's ask "these guys" themselves. In another thread, when discussing Pylons, ubernostrum was up front about his own lack of objectivity due to his position -- here's the quote: "Disclaimer: I work for the company which originally developed Django, and I'm the release manager for the project and author of a book on Django. *Take my opinions with much salt.*" [emphasis added] &gt;the fact that they work on other frameworks means they can't be intelligent and informed. I'm not saying they can't be informed at all or have anything intelligent to say, just that the particular judgments that are influenced by bias are by definition not accurate. &gt;I know these guys, they are intelligent and informed. I'm quite sure they are about many things. Not about all things. They're human, right? &gt;They also take criticism well They weren't taking criticism, they were giving it. I guess they don't take criticism of their criticism very well, though, because in many cases they simply disappear when challenged (mitsuhiko excepted).
He asked who used it and I said PyCon used it. There is nothing wrong with what I said. You did not answer my question. PyCon US choose not to use web2py registration in 2011. Was the registration used as a replacement written in Python?
to be fair, having a logo or phrase at the bottom of *any* website that says "built using XYZ!" is an endorsement, and Pycon 2012's site is no exception. Reddit.com OTOH does not have a "Built with Pylons / Mako / SQLAlchemy" phrase at the bottom, nor does Python.org have a "Built with Mako" phrase, even though these are both currently the case - no endorsement :).
He seems to be giving his opinion about other people, not frameworks.
I did answer the question, I do not know what it was written in. I think it was a CGI script, so conceivably it could have been any language. This is what made CTE comfortable and it works fine on our end.
wxPython + PyInstaller seems to be the least painful thing so far. Not sure if I can get away with a 7MB file but I doubt anything's going to get smaller than that without looking like ass.
Sorry, but false information is quite harsh. Where did you see it? I clicked the link.
Yeah, but using locals() in general is gross. :)
You do not like me saying that web2py is proud to have built the PyCon registration website for 2009 and 2010 (pro bono) and the code is open source and available [here](http://code.google.com/p/conf2py/)?
Yes, I do not like you using the PyCon name in a situation where is looks like PyCon is providing an endorsement of web2py without direct signoff from the PyCon organizers committee and the PSF trademarks committee (PyCon is a trademark owned by the PSF).
&gt;Massimo offered to write a new registration system on the condition it be in web2py You're making it sound like using web2py was some kind of ultimatum. It wasn't a "condition" -- he was offering his assistance, and web2py is obviously what he would be most expert in using, as he created it. Did you expect him to do it in Django? Apparently no one in the vast Django universe was gracious enough to volunteer their time to create a registration system. Massimo stepped in to help, and you find it necessary to go out of your way to make sure everyone knows web2py didn't have to win some bidding process in order to be selected for PyCon? Nice.
&gt;Your comment of "PyCon us 2009 and 2010 ... used it" can be easily construed as PyCon selected web2py or was in favor of it, which is plainly not the case. Well, presumably if PyCon US had any serious concerns about web2py as a framework, they would not have allowed their registration system to be implemented with it. Anyway, were there any framework related problems with the system? If not, can we conclude that web2py successfully deployed the PyCon US registration system for two years (even if it was by virtue of nobody else caring enough to pitch in)?
Right! Why would PyCon use a proven python based registration system (used already twice) when they could have it done in any other language? Who cares.
It was stated several times during that discussion that integration with the existing Django codebase would have been preferable however it wasn't a blocking issue and we were happy for the help, and indeed a very nice registration system was delivered. Like I said, the use or disuse of web2py and conf2py has nothing to do with the tech, in fact that that is my whole point.
Tornado is both an HTTP server as well as a web framework.
The lack of an endorsement is not a rejection, it is simply a lack of endorsement. While is doesn't apply in a legal sense I think the intent of the Python license applies: &gt; This License Agreement does not grant permission to use PSF trademarks or trade name in a trademark sense to endorse or promote products or services of Licensee, or any third party.
I presume you are asking rhetorically however the answer is simple, CTE provides better integration with the rest of the conference process such as housing and interaction with the conference center staff. CTE is contracted to provide PyCon and PSF with a set of services, how they choose the implement those services is up to them and is irrelevant.
 def min(a,b): return (b,a)[a &lt; b] def min(a,b): if(a &lt; b): return a return b Just two possibilities. 
I'm not sure how up-to-date [this decision tool](http://www.awaretek.com/toolkits.html) is, but it might be marginally helpful to you.
The system used in 2009 and 2010 was called web2conf. It was written in two weeks and was a bit of crap. It was constantly modified while in production and never patched for two years. It met all the specs and used google checkout level 2 notifications (which means it implemented a basic accounting system). There were two problems with it: 1) users had to login into google to pay. 2) the organizers did not like to export in csv and instead programmed the system to send emails to an external accounting program when a visitor paid registration. In a few cases people paid but card was cancelled and google notified the program to cancel registration. The web2conf program was always in sync with google checkout (did not miss one notification) but the external accounting program (relying on emails) was not and that cause problems reconciling the accounts. I am not sure everybody was fully aware about the csv export. In 2010 we re-rewrote the program completely (conf2py) and that is what everybody else has been using since but PyCon US. In 2011 PyCon US did not have a registration software and contracted a third party company that uses a CGI script for individual registration and phone for corporate ones.
&gt;Mostly because PyCon doesn't exist as a political or endorsement entity. What are you talking about? There's nothing political here, nor does this involve any endorsement. This is a discussion about where web2py has been used, and the PyCon site happens to be one of those places. Are you saying that is somehow confidential information and not to be revealed in public? If so, has the policy changed, because the [current PyCon US site](http://us.pycon.org/2012/) clearly states at the bottom who built it using what? Taze_T_Schnitzel, you got downvoted because coderanger doesn't like web2py, not because of his supposed high-minded concerns about politics. &gt;The current us.pycon.org website is written using Django and Pinax not as a slight to web2py or an endorsement of Django, but just because that is what the team contracted to build the site decided to use. Also, isn't someone who works at the company that built the new site related to one of the PyCon organizers?
CTE did an excellent job. The people at CTE are professionals. I agree they use used whatever worked best fror them. I am not sure they have anything to do with this discussion. 
CTE provided the registration system last year and will presumably do so again this year.
At one point in the past, you reported that you didn't use web2py but were critiquing based on the source code. Perhaps you have "played" with it since then, but have you used it extensively (or at all) for real web development? I ask because many many people do use it professionally to build and maintain real-world applications and are quite happy with it. You (and others) tend to express hypothetical concerns based on your intuition, but the fact is, lots of people are getting along quite well with web2py, and have been doing so for years. It is, of course, fine if web2py is not to *your* taste, but you have made statements that it ought not be to anyone's taste. That does not reflect a very open mind.
And it's a very nice, very simple and quite complete web framework.
Built-in `min` can take variable arguments, iterable and `key` function as well.
Funny. My statement above was an exact quote from the [Eldarion blog](http://eldarion.com/blog/2011/03/08/eldarion-pycon-2011). I just replaced "Eldarion" with "web2py", "this year" with "2009 and 2010", changed the link to te source code and added the "(pro bono)". I guess you are allowed to brag about PyCon if you get paid by it and not if you do it pro bono. Is this the message you want to sent to Python developers around the world? Are you trying to tell them not to do anything for free for the PSF because their work will be used but not acknowledged? This is not community building. This has noting to do with license agreement. This is called slavery and you should be ashed of yourself. I am not using the name PyCon to endorse any product. I am a university professor and never made any money out of the conference registration software. And you know it. Stop putting words in my mouth. 
min and max are defined in the file bltinmodule.c of the python source code in a function called min_max. Line 1338 in the 2.7.2 release.
I don't see how that applies at all in this situation. No one is using the PSF trademarks or trade name to endorse or promote anything, and that license agreement doesn't apply here anyway.
PyCon US never used conf2py. PyCon US used web2conf which no longer exists because I think it was crap (even if mostly I wrote it). web2py was just registration. conf2py is the new complete conference management system which includes registration.
Yes -- didn't want to overwhelm a student.
This a question of context. You were asked "Why does web2py not have more customer success stories given its overall prevalence?" and you cited PyCon as such a success story. This is different from just stating a fact that conf2py was used by PyCon. If you would like PyCon to provide you with a customer story thats fine, but that request has to go through the channels I've mentioned.
This a question of context. You were asked "Why does web2py not have more customer success stories given its overall prevalence?" and you cited PyCon as such a success story. This is different from just stating a fact that conf2py was used by PyCon. If you would like PyCon to provide you with a customer story thats fine, but that request has to go through the channels I've mentioned.
From the tornado web2 site: "Tornado is an open source version of the scalable, non-blocking web server and tools that power FriendFeed". I guess it depends on where you set the bar, what tools you expect to have to qualify it as a framework. Anyway, this is a semantic discussion not a meaningful one.
Well, you could always [look at the source](http://svn.python.org/view/python/branches/release27-maint/Python/bltinmodule.c?view=markup#l1337). More important: why do you think you'd need your own `min`?
My mistake, I apologize for any misrepresentation of your software.
This would only return the min of two numbers though, while the min function is capable of returning the minimum of a list.
No problem. And actually thanks for the "very nice registration system" compliment.
This is the nearly same implementation of built-in `min` in pure Python: def min(*args, **kwargs): if not args: raise TypeError('min expected 1 arguments, got 0') elif len(args) == 1: iterable = iter(args[0]) else: iterable = args key = None for k, v in kwargs.iteritems(): if k != 'key': raise TypeError('min() got an unexpected keyword argument') elif not callable(v): raise TypeError(str(type(v).__name__) + ' object is not callable') key = v first = True for item in iterable: if key is None: val = item else: val = key(item) if first or minval &gt; val: minval = val minitem = item first = False if first: raise ValueError('min() arg got an empty sequence') return minitem See [CPython’s implementation][1] also. [1]: http://hg.python.org/cpython/file/de17b0cf1a20/Python/bltinmodule.c#l1260
AKA vimtutor.
Thanks for clarifying this. In fact PyCon 2009, 2010, 2011, 2012 has posted footers on different pages stating "powered by Django... by Pinax... by web2py..." etc. and I think that is perfectly fine for me, and Eldarion, and others to mention our work.
Are you saying Eldarion got special permission from PyCon to make that statement on their blog? Anyway, nobody needs to get PyCon's permission for reporting a "success story" here. It is a fact that web2py was used for registration, and that fact is not subject to any confidentiality agreement, is it? You are being petty here. It's clear that you have a specific problem with web2py, not a general concern about unofficial "endorsements". [Here](http://www.reddit.com/r/Python/comments/dgbj1/complete_conference_management_system_runs_on_gae/c100iop) you mentioned that the Eldarion code was being used for PyCon (in an unrelated thread about web2py's general conf2py conference management system). Did you get permission from PSF to make that "endorsement"? In fact, the PyCon 2009 and 2010 registration pages themselves said "web2py powered" in the footer. Why was that allowed?
Yes -- I posted this only to pique the curiosity of a student, not to overwhelm him with detail.
I've replaced min() with similar functionality many times. Most recently I needed to calculate the min, max, and avg of a list of floats. It was more time-efficient to combine them into one pass, even though it was in python instead of using the C-implemented built-ins + numpy for avg. Though replacing min() with the same purpose and semantics would be a bit silly.
I'm a bit skeptical. This looks like a big melting pot of already existing plugins for python, this lower the configurability and that's not really what I'm looking for in vim. But I guess some people will be very happy with it. Anyway check out pyflake on the fly syntax check, I really prefer it over having pylint running at each save (not really checking exactly the same things).
I think it's enough of a framework to be compared to web2py, especially when there are many projects in which I can use them interchangeably. One point you mention above though about time spent in the server: Tornado spends less time "in the server" yes, but it also performs operations asynchronously, which is where its real performance gains come into play. In addition, you can get better performance even while using the database by using an async database driver. That being said, I don't think performance is why someone would pick web2py to begin with, and I don't think it needs to be a major concern of the project given it can easily be just as performant as other WSGI frameworks.
My main problem with your posts, for the record, has always been a recurring pattern of: * You say something like "web2py is the only framework which has/does X, or was the first to have/do X". * Someone points out that this is factually incorrect. * You respond by trying to hand-wave it away with some sort of technicality because the other framework didn't meet *your* personal definition of doing this thing (which, of course, is always set up to make sure only web2py fits the definition). This is dishonest. This is why you, and web2py, have the particular reputation you do. If you wish to change that reputation, change the behavior.
For just windows you can check out IronPython. It won't work on linux/mac though as far as I can tell.
Who are you trying to reply to?
I think it's to irahul.
Mono!
First of all. What I stated was not factually incorrect. Isn't it true that CRSF was broken until 2010? Do you still have to insert {% csrf_token %} to enable it? In web2py the crsf_token was inserted automatically since 2007 and did not use cookies this did not have the same vulnerability. We saw a problem we addressed it. I am not the one being dishonest. In fact I have no problem admitting that some things are better in Django. For example, what you call admin is better in Django; Django handles many2many better than web2py; Django has more users, more applications written and more success stories. I have stated repeatedly that Django and its community were a model for me and web2py took inspiration from them. I have been anything but respectful of the work of the Django developers and the creators of other framework. I specifically respect your and your work. I also have no problem admitting that occasionally I have made incorrect statements (that is why I try to stick to things I know, like web2py) and when I have, I have admitted it, corrected my statement and apologized. You instead seem to have a problem admitting that anything web2py is good. You nitpick on my language and made a personal offensive remark that I do not think I deserve. That is very bad and divisive for the Python community. Why can't we have a normal conversation like adults? I tell you what I think. You tell me what you think. If any of us says something wrong the other corrects and some times we will agree to disagree, without need of accusing each other of being dishonest. I do not know what reputation I have that you talk about. I know that spreading rumors about somebody else is a form of bullying. If I have said anything that upset you I apologize. I wish you would do the same. 
I never quite understood why classes were implemented the way they were. I much prefer using functions, closures and namedtuples (or something like a named tuple). It obviates the need for self everywhere and you get real encapsulation. 
All right, then, I'll propose something and ask if you'll agree to it. Here goes: Any time you claim web2py has a feature, I will search your bug tracker. If there are any open reports, of any sort whatsoever, regarding that feature, you will accept as true the statement that web2py does not have the stated feature. If there are any closed reports, you will accept as true the statement that web2py did not have the feature until all bug reports related to it were closed. Since your entire argument seems to boil down to "Django's CSRF system had a bug, therefore Django did not have a CSRF system", I hope you'll accept this standard for any and all future discussions of web2py. Or, on an actually serious note, perhaps you'll accept the fact that you really and truly are being dishonest in the ways you portray web2py versus other frameworks. It's quite possible that you are entirely unaware of this, or that you have a belief system in which you can interpret your statements as true and non-contradictory, but this is not a system which the rest of the world shares with you, and your reputation has suffered mightily for it.
&gt; Perhaps you have "played" with it since then, but have you used it extensively (or at all) for real web development? I would not trust any project on it, so "real"? no. &gt; That does not reflect a very open mind. “If you open your mind too much your brain will fall out.”
I have had good luck using [pyfltk](http://http://pyfltk.sourceforge.net/) as a GUI toolkit and [pyinstaller](http://www.pyinstaller.org/) to package it. The pyfltk GUI is simplistic, but simple is what I need at this point.
Since python doesn't provide a GUI implementation, and you are using py2exe to bundle the python interpreter along with the deliverable, size is always going to be a concern. With Python, this is your best bet. PyQT/pyside looks good and works on all major platforms.
Please tell me more about this documentation lookup.
[Ah ha!](http://www.vim.org/scripts/script.php?script_id=910) Installed, and very nice.
ffmpeg
I was seriously looking for something exactly like this a few weeks ago. Thanks!
You may disable auto pylint checking and run it manualy. And I agree with you about melting pot, but: 1. I rewrite this plugins (include last libraries, fix errors, auto include paths, add help). Its realy new plugins; 2. I always has be installed rope, pylint and some python tools and plugins for vim, but now I create one useful powerful plugin (by me). I find it hard to write, I still do not know much English. Sorry.
Hmmm I will take a closer look at this. Instant Admin looks pretty tidy. Thanks.
You welcome.
This not have support python 3.x :( Maybe in future.
As a module grows in complexity, don't you think it helps to use classes to group state variables and functions? You can get by with them separate -- as long as you can avoid a rat's nest of `global` declarations. But I think OOP helps with code reuse, readability, and maintenance. Mandatory `self` is the price paid for not having to declare variables.
Modules provide their own aggregation of functions, which is nice. I am not 100% against OO, I just find pythons OO clunky. That upvars are a much nicer way to manage state within a class. I am not not so much into code reuse through inheritance. Actually 103% against it. As long as you keep your modules small, the pure functional approach is ok having methods distinct from data. The nice side effects (ha!) of that is that one is much less likely to have a soup of internal vars in their somewhat transparent data structures. By having external data, it is now elevated to a protocol. The api becomes less important. Thinking of salads of nouns and verbs. Below is an example of how to create 'classes' w/o ever having to type the class keyword or self. The named tuple at that is eventually returned is a class. But this style feels more lightweight to me. ---- import sqlite3 from contextlib import contextmanager from collections import namedtuple def mk_dao(database,create=False): conn = sqlite3.connect(database) @contextmanager def _trx(): try: c = conn.cursor() yield c finally: conn.commit() c.close() @contextmanager def _c(): try: c = conn.cursor() yield c finally: c.close() if create: with _trx() as t: t.execute(""" create table point ( id string, dimension int, value int); """) dao = namedtuple('Dao','get_points') def _insert_origin(): with _trx() as t: for p in [ ('origin', 0, 0), ('origin', 1, 0), ('origin', 2, 0) ]: t.execute('insert into point values (?,?,?)', p) _insert_origin() def get_points(): with _c() as c: c.execute("select * from point") return list(c) return dao(get_points) 
Conveniently! It combine with many plugins' function.
These are all terribly elementary, but great for those just getting into the language.
If you're doing it properly, an HTML entity should not cause problems with MySQL. Needless to say, that doesn't solve the problem at hand. There's a nice function you can snatch from friendfeed's tornado, called tornado.escape.xhtml_unescape found here: http://www.tornadoweb.org/documentation/_modules/tornado/escape.html#xhtml_unescape
best comment evar.
I think my main problem is I want to use it for coding python, but setting it up to work with Python 3.x seems like a huge pain. If i just wanted a text editor I would use notepad++ or something similar, but I have heard a lot of good things about VIM, just need to find a way to get it working for me. I will give it a shot just messing around with it though. Thanks.
Well keep up the good work, and maybe someday I will use it if it when it supports 3.x
Hello again reddit. Im update this plugin and make it more customizable. Also I add rope and python-mode vim help files. See readme on github: https://github.com/klen/python-mode/blob/master/README.rst and type :help PythonMode in your VIM
I agree, [/r/learnpython](http://www.reddit.com/r/learnpython/) would be more interested in this.
Could you explain the process of moving from PyQT to PySide? I'm interested in this to get around the license restrictions.
:-)
I'm happy you have a 'lightweight' (seems heavy to me, but it's readable enough) style that works for you. To my eyes the following is simpler -- and not clunky: import sqlite3 from contextlib import contextmanager class Dao(object): def __init__(self, database, create=False): self._conn = sqlite3.connect(database) if create: with self._c() as c: c.execute(""" create table point( id string, dimension int, value int);""") with self._c() as c: #insert origin points = [('origin', 0, 0), ('origin', 1, 0), ('origin', 2, 0)] for p in points: c.execute('insert into point values (?,?,?)', p) @contextmanager def _c(self, commit=True): try: c = self._conn.cursor() yield c finally: if commit: self._conn.commit() c.close() @property def points(self): with self._c(commit=False) as c: c.execute('select * from point') return list(c) 
Unfortunately, Nokia is in the process of abandoning PySide
You quote me as saying "Django's CSRF system had a bug, therefore Django did not have a CSRF *system*". No! I said "Django's CSRF system had a vulnerability [...] therefore Django did not have a CSRF *protection*". What you quoted me saying is not correct but what I actually said is correct. Your accusation of me being dishonest is based on you misquoting me. If I claim a security feature in web2py and you discover a open ticket reporting that it is broken, you would be correct in claiming that I do not have that security protection. We can agree on that. If I claim a different feature, for example web2py has a web based IDE, and you find a bug report suggesting, for example, that a button does not display correctly, you would not be correct saying web2py does not have a web based IDE. Anything else I said is incorrect?
I'll be sure to cross-post :) In the future there will be some more challenging problems - but for now I'm trying to make it more appealing to the masses.
Didn't know mono had WPF bindings. &gt;.&gt;
It also depends how complicated your UI is and whether or not you need really complex widgets. Also, be sure to import the **ttk** module (**tkinter.ttk** in Python 3) after importing the base tkinter module. Ttk adds skinable, closer-to-native implementations of a bunch of the base widgets, with identical names to the ones in the base tkinter module. This should solve 80-90% of your "looks like complete ass" issues.
I've found the easiest distribution (by far) to use on Windows is [ActivePython](http://www.activestate.com/activepython/downloads). One limitation: no pre-compiled database drivers for the 64-bit version without a commercial license. Use their package manager (pypm) to install modules that rely on system libraries (database drivers, lxml, etc.) *except* for PIL. To get PIL working properly with all the necessary font and image format support use [this](http://www.lfd.uci.edu/~gohlke/pythonlibs/) version instead. Install everything else via pip and you *should* be okay. This is at least enough to get a basic Django development setup.
If you're willing to do it in C#, you're pretty much stuck on a single platform (Windows), right? If that's the case, you might want to look at the GUI classes in pywin32. Mark Hammond's excellent (though dated) [Python Programming on Win32](http://shop.oreilly.com/product/9781565926219.do) spends part of chapter 20 on the MFC wrappers provided by pywin32. (**edit:** [all of chapter 20 can be found on O'Reilly's site](http://oreilly.com/catalog/pythonwin32/chapter/ch20.html))Since the MFC DLLs ship with windows, your resulting app will be much smaller. However, remember that this will limit you to a single platform (which may be ok for your usecase).
See my reply above to see if **pywin.mfc** meets your criteria.
In general, I don't think folks were deliberately providing false information, but just in that one thread, there was plenty of false information about web2py (and a lot more false information in other threads). Some examples of incorrect statements about web2py: claiming web2py is not written in Python; mistakenly thinking web2py's web-based IDE works like Zope's old (problematic) "through-the-web" development; claiming that particular variables are injected in the global namespace, when they are not (which was central to the general point being made); saying mdipierro is the only developer of web2py; claiming web2py contributers don't contribute to the community at large. There are also overstatements, such as: web2py ignores "common mechanisms" of writing code (without providing examples of such mechanisms upon request); web2py ignores the use of the import statement (it does not); re-definition of the term DRY to exclude how web2py uses it. And then there are completely unsupported empirical claims, such as: web2py developers will have a "distorted view of how Python works"; referring to web2py "keywords" creates confusion and is "actively harmful"; web2py makes it difficult to do "interesting things" (without providing any examples upon request).
Some 32-bit library installers are hard coded to look in HKLM\Software\Python to determine the version of python. If you have 32-bit python installed, the installer will have a hard time checking version. -- I run 32-bit python on a 64-bit system because I ran into some library incompatibilities. I've only been using python for about 6 months, so if I'm way off base here, please enlighten me. 
Ah I think I know what you're talking about now, and I think it's setuptools/easy_install that does the hard-coding. That sucks.
I've tried to add as much information such as what you're asking to http://getpython3.com/ - included there are links (see resources) to places where people have voted for packages and trackers that list packages that don't have Python 3 support. Note that the Python Sprints project: http://pythonsprints.com/ will help fund development sprints (up to 300$ US) and that includes porting libraries to Python 3
Oh wow. That is an excellent thing to do. Suprisingly, I looked through my site-packages and found that most everything that I use is up to date. One package that I really like which has not been ported is uncertainties http://pypi.python.org/pypi/uncertainties/1.7.4 . This requires using python3 capable numpy though (and knowledge of error analysis/statistics could help).
This is an easy map/reduce operation. Since you're measuring web access logs, the data is already distributed to multiple machines, making it trivial to parallelize. (I'm assuming you have more than one web server. If not, you could cut the data up into chunks yourself.) Write a short program to process a subset of the data and output a dict object summarizing the stats of that subset. Then write a second short program to read the intermediate output from all of the runs of the first program and add the results together to get a dict (or Counter) with the entire set of stats.
Thanks, that's a useful resource. If you're interested in adding it, I have a [freely editable spreadsheet](https://docs.google.com/spreadsheet/ccc?key=0AqIElKUDQl8tdC1lR29XZFlxZUxOU1VlZ1JRQ3ZRanc&amp;authkey=CPLS9KMF&amp;hl=en_GB#gid=0) for manually tracking Python 3 support. It covers fewer packages than the automatic tools, but can store a bit more information for each package.
Good call. I've got numpy installed for Python 3, so I might give it a shot.
There is a difference between mistaken and dishonest. As in this case, I think mdipierro is always willing to correct the record when he makes a mistake. Why do you attribute this to dishonesty? There have been many misstatements about web2py by your Django buddies, but I'm sure you don't attribute them to dishonesty. In fact, in this case, I don't even think there was a mistake -- the vulnerability meant the protection wasn't actually there. Is there some nuance about that? Sure. But in the context of what he was communicating, it wasn't really relevant to bring up all the details. Chill out a bit. Anyway, you claim there is a recurring pattern -- can you offer other examples? I ask because you yourself exhibit a recurring pattern of showing up and making personal attacks against mdipierro without providing any evidence (e.g., [here](http://www.reddit.com/r/Python/comments/ddkal/django_vs_web2py_what_do_you_use_and_why/c0zp278) and [here](http://www.reddit.com/r/Python/comments/epcxj/the_bottle_web_microframework/c19xtva)). Seems strange that the release manager for one framework is so obsessed with harassing the creator of an alternative framework. I don't think I've seen him doing anything remotely like that to you or anyone else. p.s., You might want to consider your own reputation as well.
&gt;It's quite possible that you are entirely unaware of this If you believe this, then perhaps you could stop with the accusations of dishonesty.
Do you know if the community will continue work on this?
Best reason it's time for 2.7: it makes the "it's time for Python 3.x" effort easier.
This is the guide I used http://developer.qt.nokia.com/wiki/Differences_Between_PySide_and_PyQt Mainly you will be removing pyqt and sip from your Python install. Then you run the installer for PySide. You will also need to modify your setup.py scripts to not ask for sip anymore. 
if you are just wanting to display frames using opencv, calling cvCreateCameraCapture seems like the wrong thing to do..
Awesome! This will most likely be part of my next requirement file.
 &gt;&gt;&gt;{i for i in [1,2,3,1,1,1,]} set([1, 2, 3]) Love it. 
Can't you just use standard Forms and GUI widgets?
Porting xlrd (http://pypi.python.org/pypi/xlrd/0.7.1) and xlwt (http://pypi.python.org/pypi/xlwt/0.7.2) would likely help folks who depend on using Excel data in Python (to the extent anyone cares about that ;-) ). 
This module is posted at least 4-5 times per month in /r/Python. Every time, people just point out that you can do relatively the same with `httplib2`. At which supporters point out that the author has a [response](http://docs.python-requests.org/en/latest/community/faq/#why-not-httplib2) to this criticism. Can we please stop posting this module? It is neither new nor interesting. No interesting discussion has taken place surrounding this module. I admit, it is convenient, but really, just stop. 
Alright, I made the changes you suggested :) You can pass the constructor a number of options now. You can also drop in your own HTTP server if necessary now, rather than just subclassing BaseHTTPRequestHandler. See the bottom of the readme for the options :)
I haven't tried them, but have a look at http://packages.python.org/xlrd3/ and http://packages.python.org/xlwt3/ . They say development stopped in March, but I get the impression they're basically working.
Indeed, I really want to avoid locking myself to Windows, too.
Cool, I'll check out ttk!
Definitely considered this, however I'd still need C# :C
That might not work out. Continued interest in improving the "old" Python might dissuade people from switching over. I emphasize I am not taking a position on this issue.
Pyramid is an "unopinionated" framework. While most of your comment is accurate, saying "it is a way to distribute third party modules as web apps" is completely false. It is a way to build a completely custom web app while letting the framework handle interfacing with WSGI and mapping URLs onto your code. It also has tons of (optional) features for handling auth, sessions, templating, etc just as any other framework does. It doesn't enforce a particular ORM or schema on the user, however there is nothing stopping someone from creating a set of plugins that depend on a particular interface. Saying web2py wants to force developers to conform to a set of "best practices and a common set of APIs" is fine, Pyramid explicitly chooses not to do that at the level of the framework.
nice!
In my experience porting and writing about porting, it definitely works out. This is thinking like a library developer or other producer of consumed code. If you want to get your project to 3.x, the way there is 2.7. Sure, you could go from 2.5 to 3.2, but you'll find it easier if you bring yourself up to speed on the 2 branch, get solid there, then make the jump. --- As for the second part, no one is improving the old Python itself - that ship has sailed, and 2.7 is the end of the line in terms of new feature releases. We're only releasing bug fixes on the 2.7 line from here on out. As for tools built on the older versions, they'll keep coming along, but we're really starting to see a lot more people installing 3.x, and I suspect the transition to libraries supporting 3.x will continue to rise as it has over recent times. The release of 3.2 [doubled the number of monthly installers downloaded from python.org](http://i.imgur.com/SLFDL.png) (and has remained relatively steady), and month after month we're still seeing a very steady rise in [the number of 3.x packages available on PyPI](http://dev.pocoo.org/~gbrandl/py3). Edit: Just to clarify, I only charted the Windows installers since that's how you would get Python on Windows. On Macs you'd likely use the pre-installed version, and on Linux you'd likely get it from your distribution's package manager, so there aren't great ways to include those platforms. The chart isn't meant to be some be-all-end-all display of Python's use or anything, just a simple chart.
 import functools def min(*args): return functools.reduce(lambda a, b: a if a &lt; b else b, args)
What in the...
Neato, that chose wxPython, which is what I was veering towards anyway :)
Wicked. I'm pretty sure I'll go with wxPython :) Do you by any chance know what it looks like in KDE? I know Qt apps look a bit rubbish in Gnome, and GTK apps look a bit rubbish in KDE. wxPython looks perfect in Gnome, but I didn't know about KDE?
Why not just stick with 2.x and just make life easier so we don't have to port code? Just sayin...
2.x is dead.
Set comprehension. It's easier to see when you add the angle brackets in the markup: &gt;&gt;&gt; {i for i in [1,2,3,1,1,1,]} set([1, 2, 3])
That line number is pretty elite, if I do say so myself.
I would also include the Airplane Design Series by Jan Roskam. As far as laying out a step by step approach to design, Roskam can't be beat. He guides you though everything from preliminary weight sizing to final cost analysis.
Where are the comments?
And another update. Now python-mode not required plugin-helpers before install.
I'm speechless. I really can't comment on the brilliance of the PyPy developers.
They're at the bottom of the post for me, can you not see them?
Nope! Ironpython can spawn GUI's on it's own through .net
I dunno!
you said what I was thinking, but more politely. :)
I dunno!
fixed, thanks, it was escaped in the RES live preview 
The response is usually about httplib*2*, which isn't included in the standard library, to which I do disagree. But whatever floats your boat :)
The Python 3 Wall of Shame might be a good resource: http://python3wos.appspot.com/
From the wall of shame, small-ish code bases: http://pypi.python.org/pypi/xlrd http://pypi.python.org/pypi/pymongo 
I've always used tooltip.php :/
Been a while since I tried it but basically a wxPython app'll look as good/bad as any other GTK app (unless you're using wxX11 instead of wxGTK). There are some KDE themes that help to clean it up a bit like [Oxygen Gtk](http://kde-look.org/content/show.php/?content=136216). Tough to get a great native look on every platform without going native on every platform, though. :)
&gt;Do you write Python for work or fun? :D Both :). I do a lot of scripting at work (\*sh if it's short, Python if I can, PHP if I must), but more often than not I'm updating someone else's code or there's some platform limitation - so when I'm at home and I can write my code my way, I do. 
The trouble with automatic tools like the wall of shame is that they don't know about ports released as separate packages: http://pypi.python.org/pypi/xlrd3 http://pypi.python.org/pypi/pymongo3 Admittedly, I don't know how well these work (they're not maintained by the same people behind the originals), but they do at least exist.
Shit, I meant I'd still need the user to have .Net installed. Not sure why I wrote C#
Ah, good point. Anyone else really not like having the 3.x compatible packages marked with a 3? I'd much rather have a setup.py file [with](http://python3porting.com/2to3.html#distribution-section): import sys from distutils.core import setup if sys.version &lt; '3': package_dir = {'': 'src2'} else: package_dir = {'': 'src3'} setup(name='foo', version='1.0', package_dir = package_dir, ) but if the python 3.x compatible project is not maintained by the original authors I can see why they'd go down the 2 distributions route. 
Cool :) I don't code much at work, bash and python to automate my own tasks, PHP for the web. I have no grand idea's, no thoughts on what to do next, I've though about looking at the web side of Python or pyGame. Do you have any projects you fell you learned a lot from? Also, what are the things you find make coding (python mainly but generally) easier. Code snippets or useful functions, pluggins or add-ons for your editor, a blog or site you like to read? Sorry again dude, I'm trying not to ask too much . . . :)
In certain respects you are correct - it isn't a "meta framework" any more than Pylons was. Yes, it's a bit more flexible than Django, web2py, &amp;c... in the sense that you choose your own data modeling layer, which templating to use, etc... But those two examples are actually the only major areas where developer selection happens. Everything else is standard and recommended. Two Pyramid apps (minus choice of data modeling and templating) will look remarkably the same, actually. I can see the reasoning behind wanting to homogenize the toolset (it's also completely up to the developer of what they want to use, that's the great thing about the Python community) but I can't help but feel that homogenizing it rather than making it extensible/pluggable (in the context of our discussion, web2py vs pyramid here) is "not pythonic". With Pyramid, you can homogenize your stack (I've been using the same base configs, auth controllers, base models, &amp;c...) so that you can reuse it easily with the added bonus that six months down the road if you feel like using a different templating engine, or ORM, or web request middleware, you can change over to that without having to completely switch frameworks. As it stands this conversation is moving more towards description of preferences, which I suppose makes it kind of moot - since people will like what web2py has to offer and others will like what pyramid has to offer...
I think the most common route for official ports is to have one codebase, and have setup.py run 2to3 in the build step. I've done a few packages like this. The &lt;package&gt;3 is used when the person doing the port can't or doesn't get it accepted upstream. I agree that it's not ideal, but at least it's fairly predictable. Hopefully in time, they'll be merged back into the original packages (e.g. there was virtualenv3 and virtualenv5 before virtualenv itself supported Python 3).
It’s time for Python 3.2
I wouldn't consider myself a part of the PySide community at all. You could start here in your quest for answers though! http://www.pyside.org/2011/08/pyside-project-future/
3.[0-1] is dead!
thanks for the lecturing, I'll look at how to use map/reduce (for Python) then.
In this context my style doesn't look too bad. ;) That said, I should revisit classes in Python. @property is particularly nice (and available since python 2.4). I started using Python heavily under 1.6.2 and haven't spent enough time coming up to speed with the new tools. There also seems to be a lack of mid to advanced condensed documentation. My favorite tools are * triple quote * namedtuple * closures * function splat, destructing assignment, *args, **kwargs * list comprehensions, generator expressions, generators * itertools * decorators * frame hacks * creating DSLs (class based operator overloading) What code bases do you like?
I love python
I completely agree with you and this a matter of preference. I can see myself using Pyramid for some projects.
Well, the majority of windows users have it, but I can see how it would be a problem for everyone else. Have you considered just doing a locally hosted webpage?
Counter will work fine as long as the total number of unique keys is relatively small.. and by small I mean a few hundred thousand is still pretty small. If you want to find the top 10 urls or browsers, the list of unique items should easily fit in memory. Failing that, the easiest thing to do would be to use the built in support for sqllite and just store the data there. someone even posted a sqllite backed dictionary recently.
I would really appreciate SymPy being ported to Python 3, their Git repo has had some work done in that area using 2to3 tool, and there have been few import issues, so if you guys can go through that and fix it that would be awesome and appreciated.
thanks, though I'm afraid the number of unique key is beyond this scale. sqlite is easy to use, maybe it's a good choice before I have to search a map/reduce solution.
http://www.cosc.canterbury.ac.nz/greg.ewing/python_gui/
Oh, well you totally can! I've written apps like that before. :)
Remember that failure is always an option, and that it's never too late to panic.
If someone has found the ability to execute arbitrary code on your computer, this exploit is rather pointless, and should be one of the least of your concerns... Considering they're executing arbitrary code on your computer, and that is dangerous in itself. Also, a similar link was posted a few weeks ago, relevant discussion is in the comments: http://www.reddit.com/r/Python/comments/ks3fm/infect_pyc_files/ 
Ugh, parenthesis around the if-expression? 
You could also use it to hide a backdoor inside a .pyc file on a developer's computer and then have it executed on a production server when the developer deploys the code. Depends on how deployment is done, of course.
You know what they say about taste. Yes?
proofs that python can manipulate files. how is this news?
It looks like they've had a GSoC student this summer who's [done most of the work](http://code.google.com/p/sympy/issues/detail?id=1262#c30) - it missed the 0.7.1 release, but it will hopefully be out soon.
COOL! 
I'm learning python. Thought this was really cool :(
Unfortunately the client wants a "proper" GUI app :/
&gt;I have no grand idea's, no thoughts on what to do next, I've though about looking at the web side of Python or pyGame. Do you have any projects you fell you learned a lot from? I made my own project, and I over-engineered the crap out of it (took months, but I learnt a lot). Never released it, and subsequently lost most of the source code (always make backups!). In retrospect, I wish I'd contributed to an existing project - I had to (and still have to) unlearn a lot of bad habits. I suppose the best advice would be to think about things that need automation or Python projects that need features/bugs - basically, work out what problems you already have that can be solved with Python, and solve them. &gt;Also, what are the things you find make coding (python mainly but generally) easier. Code snippets or useful functions, pluggins or add-ons for your editor, a blog or site you like to read? I use g/vim+yakuake, so [exhuberant ctags](http://ctags.sourceforge.net/), [pydiction](http://www.vim.org/scripts/script.php?script_id=850) and `:syntax on`. Apart from YCombinator and all the Python/programming subreddits there aren't many Python-related blogs or forums I freqent. Code snippets... lets see, there's lots of very little things, almost all of which are used to write fewer lines (because I'm lazy). One I used today; `[A,B][True]` returns B, because it's equivalent to `[A,B][int(True)]`, which is `[A,B][1]`. It's practically useless, *except* if you're coding to Python 2.4 (which is what CentOS 5 ships), *and* you're trying to have a conditional in a lambda (2.4 doesn't support conditionals in lambdas). In this case, it's useful for eg, `lambda x:[A,B][x == 3]` in lieu of writing a 5-line function. Or Exceptions as GOTOs (for busting out of nested loops), which is try: for x in foo: for y in bar: if something: raise Exception except Exception: pass *But*, because `else` after a `for` statement executes *if and only if* `break` was not called, this can be rewritten as; for x in foo: for y in bar: if something: break else: continue # next 'x' break The second one is "safer" (if you legitimately throw the Exception you're using to bust out of the loop, you'll have a very difficult bug to track), but the first is simpler, and doesn't have as many indent levels. Or; fake one-line ['`any`'](http://docs.python.org/library/functions.html#any) (again, compatibility); bool([x for x in blah if conditional(x)]) (Because `bool(mylist)` is equivalent to `len(mylist) != 0`). It really comes down to little patterns and idioms like that - anything else bigger is too specific to bother sharing (and anyway, big things get put in modules and then you forget/don't care how they're implemented). PS. `import antigravity` 
It's the *same* virus. Note how the method of infection, and the action upon infection are identical. Both viruses write "You have been exploited". So if they discovered a "novel" Python virus they found it on GitHub (or Reddit). Note how the number of infections is given as 0-49. I think we can safely translate that to 0.
./setup.py should be mandatory there
I work in a team of 6 and we often have to do a few similar tasks quite often. We also want to be notified of changes to our git repos, easily look up build results and no doubt overcome other inconveniences that get in the way of us getting quality work done. As we're often not all in the same physical location we run an IRC server to make working together a bit easier and adding a worker bot to make a few things easier seemed like a reasonable idea. I was inspired to do this after reading about github's hubot, which they use to do everything from unlock the front door to deploy the current master branch code to github's production servers.
It is cool! It may be a bit of a theoretical exercise, and I doubt we'll see this in the wild any time soon, but it is a nice proof of concept. Given that we're seeing python in more and more places, and that this virus can potentially be completely platform independent, I feel it is a good idea to keep an eye on this. Also, for someone who's learning Python, I suggest looking deeper into this virus. It'll teach you a lot about how Python works.
&gt; this exploit is rather pointless As a proof-of-concept virus, yes. However, it does have some merits. First of all, Python is platform-independent. It is present on many operating systems, including a large number of different Linux distributions. Mac OSX has it installed by default. I believe the Dropbox clients are written in Python, but I don't know if they are susceptible to .pyc infections. (They're probably compiled to .exe's) Regardless, the merits of this virus (as a proof-of-concept) are that it greatly increases the potential range of different platforms it could infect. It is, presumably, also easier to write virusses in Python than it would be in C/C++, making this a more accessible form of attack for less advanced virus writers. Virus writers would still need some kind of privilege-escalating exploit to do real damage, but given that Python is so wide-spread, I wouldn't dismiss this as pointless. One potential attack vector I can think of could for instance be a development/staging machine (which is often much less secure than a live one, and where the developer usually has root access) with some kind of virtualenv Python project on it. An attacker with developer-level privileges could easily escalate privileges in such a situation. 
A computer language with full access to the system can be used to make a virus? When did this happen?
On the side bar there is dive into Python 3. I have to speak from my own experience however. I started on the road of Python 3, I though this is the way of the future, why go with the older version? Well let me tell you why, because almost nothing works with python 3 unless you can fix it or write it yourself. Thankfully my code hadn't gotten so in depth i couldn't switch to python 2.7. So far my code works exactly the same, I know there are differences, but I haven't worked with them enough to run into any problems. Also more libraries and frameworks work with 2.7, especially if you are trying something like the web design, i would go with 2 instead of 3. just my two cents though.
I'm somewhat amazed that this works. I mean, I get why Python doesn't notice that the .py source code and the .pyc file don't match anymore. Apparently it checks if the timestamp of the .py file is newer than the .pyc file and only recompiles if that is the case. It does however have access to the source file at runtime, so it should be possible to come up with a more rigid check, right?
Wicked!
Use an embedded browser window they'll never be the wiser, plus it'll likely look more integrated then other suggestions. But definately poke around with tktinker etc! Also, I've had good experiences with GTK on windows (except on laptops when trackpad scroll sometims breaks)
I also forgot to mention my python app + pyside code with py2exe comes in at 14mb.
Most VCS's are set up to ignore .pyc files for this reason, I believe. Additionally, most packaging methods will perform a clean pre-compile upon installation. It should thus already serve as a major red flag if .pyc files are distributed.
There's a couple of projects already out there: * [Skulpt](http://www.skulpt.org/) runs in the browser (i.e. in javascript) to translate and run Python code. * [Pyjamas](http://pyjs.org/) is an app framework which allows you to write in Python, and compiles client-side parts to javascript (like GWT for Python). I don't know of anything serious using either of them, but you might want to have a play with them.
Thanks. That really helped a lot. I wanted to learn python with the intention of making very dynamic website with apps and modules. I never programmed in python before, but I do have a vast experience with php, java, js and some other languages, so I thought why not give it a try. Research in the past few hours lead me to the same conclusion, Python 3 i just not fully web ready yet. Beside that, a great deal of very powerful frameworks like django and pylons are still not being developed for python 3, so I think I'll just go with python 2.* and use django. Maybe later when I know python enough I'll remake the site from the scratch and create my own framework for it... Also, would you happen to know if MySQL is better to use with django then SQLite? So far that's the only question stopping me from starting the project. There seem to be some disadvantages to the both and unfortunately I'm not allowed to install PostgreSQL on a shared server...
No. Python - stdlib = useless
Python semantics is too different from javascript, either you end up with a very very slow and huge interpreter or incompatible semantics but the same syntax which only confuses people.
My problem when I tried this was that I could not find a library to connect me to MSsql with Python3. So I cobbled something together using Bottle.py and SQLITE. depending on what you want to use it for I would us MySQL connections so they are more secure, as it appears SQLITE Dbs are just open for the looking.
http://wiki.python.org/moin/WebBrowserProgramming
I am ashamed to admit that my own deployments don't always follow this rule, but as of tomorrow they will.
The simplest possible way to write something that vaguely works like `min()` is: def mymin(tocheck): minval = None for cur in tocheck: if minval is None or cur &lt; minval: minval = cur return minval That obviously has no error checking etc, and doesn't function like the builtin in many cases, but that's the basic idea. Far less helpfully (mostly looked this up out of curiosity): [here is PyPy's implementation of min/max](https://github.com/pypy/pypy/blob/master/pypy/module/__builtin__/functional.py#L141) (it's not Python, but rather RPython, a restricted subset of Python)
You should check out http://sourceforge.net/projects/supybot/ and https://github.com/sbp/phenny they are very well done and you could probably extend them to do what you need.
what would be the point of compiling to pyc if you essentially were recompiling on runtime to see if the newly compiled version matches the previously compiled version?
Any rigid check involves costs. Checking timestamps is one of the cheapest constant time methods to determine if a file has become dirty. Any "examine the contents" check becomes proportional to the size of of the file and is time expensive for a loader processing hundreds of files.
As I said: &gt; I get why Python doesn't notice that the .py source code and the .pyc file don't match anymore. Whereas recompiling every time would be overkill, solely relying on timestaps seems like underachieving to me. Suppose I accidentally rsynced a directory of .py files with older backups (i.e. in the wrong direction). Then the modification times of the .py files would still be before those of the existing .pyc files, which I had purposefully excluded from my backup. Now my code project looks one way and acts another. If each .pyc file just included a hash of the .py file it was generated from, this occurrence could easily be avoided - and with negligible overhead.
Cheers. I got similar sizes with PyInstaller. Think I'll go with wxPython as it looks prettier under Gnome, and also pyside is a pain to install on Arch (have to compile it from source, it takes ages). It irritates me that they don't do a binary package on PyPi.
Take a look at: http://getpython3.com/ for more resources.
Your scenario works just fine. The pyc files do not store a checksum (that would require reading the .py file to generate the checksum to test against) but they do store the exact timestamp of the original file. If the timestamps do not match exactly, whether it's less or greater, the pyc file is considered invalid. There's no realistic scenario where a stale pyc file will be used without your knowledge.
&gt; There's no realistic scenario where a stale pyc file will be used without your knowledge. Yeah there is and I just explained it: Incremental backups synchronize timestamps.
Cool, I'm trying to go down that path with the task logger, there's lots of stuff I want to try but I don't want to loose my motivation to sit down and code after fucking up once too many time. I'm really enjoying python and it's easy to write and it seems perfect. I am disappointed that I never tried sooner :( As to backups, I've just started using Git and even more recently implemented it instead of SVN at work so it's all good. Hardest part is remembering to commit before you go and fuck up the working code lol A lot of the stuff you just said didn't mean much to me. I've heard all the terms before but I don't understand them fully but i now know what to aim for next. Looking in to the more of the complex (complex to me lol) stuff like lambdas (what are they and why do you use them btw? :S) and exception catching. And I apologies once again but if you have the time could you check out my updated code [http://pastebin.com/Es5BBtvy](http://pastebin.com/Es5BBtvy) and tell me what you think? I've updated it since this one but as of now i haven't got access to it. I've already learned some neat tricks like enumerate() and I really like the if x in ("X", "x", "ex"): and "Started - {0} at {1} \n".format(task, time) stuff :D To sum it up, I think I've fallen in love with Python :) You've been awesome too dude, So once again thanks.
If you're thinking of the django route, check this videos series out: http://gettingstartedwithdjango.com/resources/gigantuan.html After watching a few of these vids, I'm still unsure of switching from a php framework to Django, but I'll just continue learning about it until I reach a final decision
Ok. I'm going to detail my understanding of your scenario and you can tell me where I've got it wrong. I'm going to simplify the "last modified" to just a date, but in reality last modified times are accurate down to milliseconds or better on most platforms. You have a backup done on Oct 8th. You modify your .py file on Oct 9th. The associated pyc file is invalidated and regenerated because it no longer matches the Oct 9th py file. Inside the new pyc file, a field is automatically added that says it's associated with a py file that was modified on Oct 9th. We're good so far, right? You go to do another backup on Oct 10th and have it the wrong way around. Rsync reverted your py file back to Oct 8th. It would also apply either an Oct 8th timestamp (from the original file) or an Oct 10th timestamp (if it's using the current date of when you ran the rsync), so unless you're doing something bizzare, there's no way it will keep the Oct 9th date the py file had when you manually modified it. In either of those cases, since the timestamp on the py file has changed, the pyc file's internal field that says it was generated from a copy of whatever.py which was last modified on Oct 9th becomes false. Python can see that whatever.py is now either Oct 8th or Oct 10th. The pyc is invalidated, and regenerated from the reverted py file. As far as I can see, your scenario works just fine.
Here at Symantec Security Response we have discovered github and reddit ... I don't understand why pedantic crap like this gets posted on reddit. The pyc virus was a proof of concept ...
Why is it the wrong thing to do? Do yo know of any other methods where I can display frames using OpenCV? Edit: At the time, without doing any ffmpeg stuff, cvCreateCameraCapture worked.
&gt;lambdas (what are they and why do you use them btw? :S) and exception catching. Lambdas are easy, they are just functions that you can write very quickly. So these two are exactly equivalent: foo = lambda a,b : a + b def foo(a,b): return a+b They're useful if you don't need/want to assign names to a function (I don't *need* the `foo =`, but I can't leave it out of the function definition), or you just want a function quickly. But, they're nothing you can't already do with a function. Exception catching is also fairly easy - you just put a `try: ` to open and then an `except Exception` to catch it. You can use it to protect "unsafe" code, like, try: answer = raw_input("Please give a whole number:") answer = int(answer) except ValueError: print "No, you have to give a number" If, say, the user answers "a", then python will try `answer = int("a")` - obviously, that won't work. Python's behaviour when you do something unexpected is to raise an Exception, in this case, a `ValueError` (particular types of Exception represent different issues). If you don't want your program to crash just because the user can't follow directions, you would catch this Exception and "cleanly" handle it (eg, ask again, or tell the user off). You can also raise Exceptions yourself, with `raise Exception` (eg, `raise TypeError`, raise `IndexError`, etc). &gt;could you check out my updated code http://pastebin.com/Es5BBtvy and tell me what you think? This one's miles better - the main block is nice and compact, and if I wanted to add my own answer, it would be very obvious how to do it (just a new `elif` block and a new function). I don't think there's a much better way of doing it than what you've already done :) &gt;and I really like the [...] &gt; "Started - {0} at {1} \n".format(task, time) Just FYI, you can also do keywords in formats - so "Started - {mytask} at {mytime}\n".format(mytask=task, mytime=time) Not that you need to, but it's a nice feature.
It's probably nifty and all but I will admit that I'm struggling at understanding when I would need such a service. I'm not picking at the achievement it represents, just its usefulness. I mean, when I need to code, I do have my computer (work or at home), with everything I need. Could someone provide a solid use case for such service for themselves?
Instead of trying to compile or interpret all of Python (a huge project, and already done according to other replies), perhaps you could do something more like Coffeescript: a very light frosting of syntax sugar, making it a little easier to write and read Javascript. Unlike Coffeescript, whose syntax sugaring looks sort of like (Scala, Ruby, or...), you'd provide syntax sugaring that looks like Python. As long as the Javascript isn't too far below the Pythonish surface, it should be easy to use Javascript libraries and frameworks. This is an advantage claimed by Coffeescript. 
 "Started - {mytask} at {mytime}\n".format(mytask=task, mytime=time) I love this, it may not be necessary but its nice. :D And str.split()!!! Fucking hell! I was searching everywhere for a way to break a string into a list with the string in a format of chunks of three chars separated with a space to process in a for loop. I was looking at using len() and xrange() to iterate in threes but I just couldn't figure it out lol it was late but it's no excuse. Then i found the str.split()! Wow lol Thanks dude, Seriously, your explanations are clear and easy to follow :D Best lessons ever lol What is the difference between catching the exceptions and using if-else statements, similar to what you wrote before? I assume exceptions are easier to use for broader catches like the numerical value you mentioned, but why choose one over the other? Thanks for you patience dude, I'm off to read up on whatever i can and try improve the way my code actually logs the data :D Enjoy the rest of your day/night Mr name_censored_
I'm not 100% sure this will work for everything, but I tested it on a few things (including itself) and it worked. Enjoy! 
cvCreateFileCapture? 
i dont think ive ever heard (or at least paid attention to and remembered) about sets in python. i better go do some research. maybe it has something to do with me totally fucking up ubuntu when i tried to uninstall python 2.6 so i could put 2.7 on, then reverting back to 2.6 and trying to re-install every python based program that it decided to remove along with python 2.6.
both linode and slicehost give you browser-based console access. 
&gt;And str.split()!!! Fucking hell! I was searching everywhere for a way to break a string into a list with the string in a format of chunks of three chars separated with a space to process in a for loop. I was looking at using len() and xrange() to iterate in threes but I just couldn't figure it out lol it was late but it's no excuse. Then i found the str.split()! Wow lol It's amazing how much is built-in. I've probably spent hours implementing things, only to realise Python has a builtin or something in the standard library for it. It's a good move on your part to want a good reference, to avoid exactly this :) &gt;What is the difference between catching the exceptions and using if-else statements, similar to what you wrote before? I assume exceptions are easier to use for broader catches like the numerical value you mentioned, but why choose one over the other? It's mainly a philosophical choice - you can choose either ["Look Before You Leap" or "It's Easier To Ask Forgiveness Than Permission"](http://www4.ncsu.edu/~kaltofen/courses/Languages/PythonExamples/python-lectures/_build/html/lectures/four.html). Having said that, exceptions are generally a better choice because of Python's [Duck Typing](http://en.wikipedia.org/wiki/Duck_typing) ("If It Looks Like A Duck, And It Quacks Like A Duck.."). So for example, I was saying earlier you should use bools, so if not VirginTask: instead of if VirginTask == "no" One of the reasons this is a good idea is that I can use anything that's *like* `True` or `False` (0 is *like* `False`, 1 is *like* `True` - and in fact, practically everything in python can be reduced to either `True` or `False`). (It may not be useful in most cases, but sometimes you don't have as much control over other variables as you might like - eg, third party modules). Coming back to LBYL vs EAFTP, you would be better off saying # EAFTP try: if VirginTask: foo() except TypeError: blah() Rather than # LBYL if type(VirginTask) != bool: blah() else: foo() Because `VirginTask` doesn't have to be exactly equal to `True` or `False`, it can just be something that's *like* `True` or *like* `False`. This applies not only to booleans, but everything. Another example might be a list `my_mystery_type=["a","b","c"]` vs. a dictionary which just *happens* to have numbers as keys `my_mystery_type={0:"a", 1:"b", 2:"c", "foo":"bar"}` - in either case I can say `my_mystery_object[1]` to get "b" (but the list cannot hold "foo":"bar", so maybe that's why I used a dict). Of course, on the flip side of the coin, maybe you *do* want to make sure it is exactly "`True`" or "`False`" (often happens) - in which case, you are better off with the LBYL approach. Or, maybe EAFTP is unnecessary, and LBYL is easier/shorter - if so, use LBYL. It basically comes down to taking it case-by-case.
This is still my favorite Python quine: http://codepad.org/BXyEUKWE
By that logic why not just stick to 1.x and bury our heads in the sand? Advancements in a language are a good thing.
Thanks, i'll have a look.
Ok cool, I'll try validate some inputs and see what I can ome up with. I've still got a lot to read up on too, I'm glad i've got a goal to focus on and keep adding to. You rock btw, iif you're ever stuck for work, teach. It's a gift lol :) Thanks a lot dude, this post is a great reference, you've helped me cover so much already. I feel more confident about trying new/different approaches. I don't know if you'll be happy or sad but I have no more questions (:( I have a lot to learn/read and i think you've been a bigger help than i could have ever asked for. Thanks for the time and patience :D
&gt; ...we only have single-dimension arrays thus far I do not understand this development approach. Single-dimensional arrays are a special case of multidimensional arrays; why write a bunch of specialized code only to have to go back and generalize it? 
Most of the code really is general. For example all of the dtype and ufunc code is completely general, as is our approach to JIT compiling expressions. The only thing that isn't general is the array access API code. So, yes, we do have to generalize it, no doubt. However, it was also significantly easier to simplify our implementation of those APIs in order to test and prove that our approach worked. EDIT: Also if anyone has questions about anything related to this, feel free to ask them.
I decided to go with ffmpeg because I also needed sound. Does OpenCV support any sound input?
Awesome news! I'd still like to know how they plan to keep PyPy's NumPy up-to-date with regular NumPy. I'd hate to see it lagging months behind waiting for code to be ported. Also this might have been a good opportunity to fix any syntactical issues or annoyances with NumPy (like the `numpy.bool_` thing mentioned) even at the expense of compatibility. Or even redesign the whole thing from scratch. But I suppose this is the only practical way. 
This is probably talking way in the future, but any idea how soon stuff like PyQt and Matplotlib can support PyPy?
PyQt your best bet is through PySide, I don't know much about it. And I don't know enough about Matplotlib to answer the question of "Why it doesn't work?" much less how we make it work :
Much as I'd love to redesign the whole thing (and lord knows I love redesigning things), the whole point is compatibility with people's existing code (and domain knowledge).
I don't know anything about the innards of PyPy, but will the new NumPy support be embedded deeply in it, or will the vectorization support, etc. be generic? So, for example, could someone implement their own array library for PyPy in the future and still get the same performance as PyPy-NumPy?
Not sure, I need to learn more about vectorization algorithms. To my knowledge the key is having only a single branch (the exit condition), and most Python loops actually have two: the looping branch itself, as well as the "signal counter" (the countdown to handle any signals the process has received). I think in theory if you solve that problem, and teach the JIT about looping conditions in the right way you can have generic vectorization of any loop. But I'm not an expert. (I did file a bug against GCC's vectorizer though!)
I guess it's a question of the status of CPython API support in PyPy? BTW does PyPy have a native API so people can write PyPy-only extensions?
Is matplotlib mostly C code then? No, PyPy doesn't have it's own C API, Python is our API at this point :)
I think this has been the only update in over a year. Really wish Py3k support was ready, but some of the other new features seem interesting (like better animation support).
A simple wrapper could be created around simple redis hash commands http://redis.io/commands#hash HICRBY
Yes please!
You just want to be able to run a python program from any directory? as in $python foo.py You should be able to do that automatically if you installed python using apt-get, I believe
Most of matplotlib is Python code, but there are (at least) two essential extensions, written in C++: * matplotlib.ft2font: From the source code: "A python interface to freetype2". I think this could be rewritten to use ctypes. * matplotlib._path: path methods (13 methods exposed), which depend on agg (Antigrain). The cpp files for these two are around 4k lines (total). That includes the boilterplate code to bind with CPython. Several of the backends depend on agg for rendering too. 
It sounds like ctypes probably makes the most sense, not sure how binding to C++ works, you need to write your own C binding for it I guess (SWIG?)?
Exactly. To avoid using the CPython API directly, usually people use SWIG or Boost.Python for C++ extensions, but matplotlib uses [PyCXX](http://cxx.sourceforge.net/). I think most of it is hand-written. The code seems easy to follow, so the dependency on agg is what worries me.
I have never liked either bots. Their implementation is convoluted. Supoy uses up way too much CPU time and memory for an IRC bot. I ended up writing my own in twisted. Worked out really well.
Add a "#!/usr/bin/python" to the beginning of the file and make it executable "chmod +x filename". Invoke with ./filename Hope this helps
Agg is a gigantic pile of heavily templated C++. It would be better to leave matplotlib._path in C++ and interface to that via some sort of PyPy-ctypes mechanism. Trying to interface to Agg directly from PyPy is probably never going to happen.
I agree. These two modules (ft2font and _path) of course depend on numpy too. If we use ctypes, we would only need to know how to interface PyPy's numpy with the ctypes module and we would be set.
Cool. Matplotlib is quickly becoming a very powerful framework to produce high quality graphics. I really hope they keep working on 3D support.
this. OP, you probably didn't even install python yourself, but it was already installed on the system (it is necessary for so many things). What have you tried that didn't work?
For the TL;DR crowd, here's the meat: :x = weakref.ref(obj, @) def report_destruction(obj): print("{} is being destroyed".format(obj)) `:` means "this statement is followed by a local use only name." `@` means "the thing I define on the next line." Another example: :sorted_list = sorted(original_list, key=@) def normalize_item(item): item = item.strip() item = item.lower() … return item And the classic: def counter(): x = 0 :return @ def increment(): nonlocal x x += 1 return x What do you all think?
wow, all that junk is between web2py and writing a django app? I have only used django, and I am happy to have found it. in my inexperienced opinion, php, drupal and other non python options are even more of a PIA than django. Anyways, I will look into web2py if you think it is that much easier than django. It would be nice to be able to make ugly personal tools more quickly. 