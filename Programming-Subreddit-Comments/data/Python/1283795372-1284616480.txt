Yes, logging supports multi-threaded use without special effort from the developer, and has done since the outset. You can log to a single file from multiple threads in the same process, because the logging package uses threading locks under the hood to serialize access to the file. You can't do that so easily with processes because Python doesn't have a means (in the stdlib) of synchronizing multiple processes. Of course, you can use queues like multiprocessing does to communicate between your multiple processes, but it's a little more work than just instantiating a threading lock. I took some trouble over the threading support and haven't found any actual bugs in the threading logic for a long time, but I'm always interested in potential problems in this area. A few times people have reported what looked like threading bugs in the logging package, which on inspection turned out to be threading logic problems in the using applications. Getting threading right is hard :-( If you are using multiple processes to run your web site (say with mod-wsgi daemon mode) then you would configure your web application logging with a SocketHandler, sending events to a separate process which also runs as a daemon, sets up a socket listener to receive events (from your mod-wsgi daemons) and then writes those to a file (you can specify this in your configuration for this separate process). An example for this separate process is Gabriel Genellina's [LoggingWebMonitor](http://code.activestate.com/recipes/577025-loggingwebmonitor-a-central-logging-server-and-mon/), which even lets you see recent events passing through the system via its own web page. Even if it doesn't do exactly what you want, it can be the basis of code for a process which does meet your needs.
Creating html documentation for scripts I make
Here is a simple mock up of what I want to do: http://imgur.com/HgP6f
It also does not need to be exactly like that mock up. It could be as simple as 6 to 8 buttons that do everything from opening the file when the button is clicked (a dialog box opens to chose which file to open), to the actual encoding of the text. Like this: [open file] [save file] [encode] [decode] [Help] [Quit]
For Python 2.5, on Win32, it is usually located under: C:\Python25\Tools\scripts\pydoc C:\Python25\Tools\scripts\pydocgui.pyw Notice that `pydoc` does not have a `.py` extension, thus even if that path is in your %PATH%, you cannot call it directly. You'll need to do (for example): &gt; python pydoc --help From the said location (unless that dir is in your PATH). Hope it helps a little.
`python.exe -m pydoc -w subprocess` will create subprocess.html in your current directory, so just substitute `subprocess` with your module name and it'll generate what it can. I've never used it myself so I don't have any tips, but take a look at the output of the above command and compare it to the subprocess module code to see how they got that output. Further down the road I'd look into Sphinx, as suggested in another comment thread. It's not auto-generating, but it's much nicer.
In web2py you could do this: import re def textile_markup(text,tag=None,attr={}): ctext = re.sub('\s+',' ',text.strip()) if tag==None: ctext attr['text'] = ctext return { 'br': '\n\n', 'h1': '# %(text)s\n\n', 'h2': '## %(text)s\n\n', 'h3': '### %(text)s\n\n', 'h4': '#### %(text)s\n\n', 'p': '%(text)s\n\n', 'b' or 'strong': '*%(text)s*', 'em' or 'i': "_%(text)s_", 'tt' or 'code': '@%(text)s@', 'blockquote': '\n\nbq. %(text)s\n', 'a': '"%(text)s""%(_href)s', 'img': '!%(_src)s(image)!', 'tr': '\n%(text)s|', 'td': '| %(text)s ', 'th': '|_. %(text)s ', 'li': '* %(text)s\n' }.get(tag,text) % attr def html2textile(html): return TAG(html).flatten(textile_markup) Not as complete as yours but works in most of the cases. TAG is a web2py helper that parses HTML into an object representation. flatten is a method to serialize the content. web2py provides default markmin and markdown serializers but not textile (the one above). To be honest, I have not even tried to run it but you get the idea.
I did manage to get pydoc to run, but I think it was trying to read documentation rather than write it. I should definitely look into putting linux on my system again.
&gt; an overhauled GIL implementation that reduces contention Awesome! One more reason to switch to py3k. Numpy's been converted, just let me know when scipy and matplotlib are there.
Have you seen [coverage.py](http://nedbatchelder.com/code/coverage/)?
Interesting. It's possible to get to the string program via `format_test`, so with some restructuring, the config tests could generate a unique function name instead. But, how do you handle testing for the existence of a function, and if the interface is correct? For instance, strerror_r could have [two different return types](http://manpages.ubuntu.com/manpages/jaunty/man3/strerror.3.html). And on a related note, I've been planning on some time using clang to parse headers, which would be way faster than the whole generating an executable approach. Not sure how that'd interact well with cross compiling though.
&gt; only cause ... no other ... logging package You're "pretty sure", based on what evidence? I'm not sure what data you're basing that somewhat snide comment on, because I don't get that feeling from the questions, comments and suggestions I receive. Obviously as you're a member of the pocoo team along with Logbook developers Georg and Armin you'd tend to see things the same way they do - fair enough - but how do you extrapolate from that? You encountered many issues with the logging package? Did you bring them up on c.l.py or bugs.python.org? What response did you get? If you did post there I must have missed that, as I'm usually quite reasonable at following up things posted there. As for your comment on LoggerAdapter, I don't quite follow how it falls short for your use case, so please feel free to describe your problem in more detail. 
Yes and it had import errors when I tried to use it which is why I was unable to (much to my dismay).
anecdotal "evidence" from communication with people that used logging only cause they lacked time/initiative to write a more useful logging package the issues i encountered where all directly related to the core design of the package, there is no point in going around and cry or waste python contributor time about something that cannot be fixed - we all got better things to do logadapter is practically a decorator for a single logger logbook processors operate on all loggers within the context the issues i have with logging stem part from utterly poor performance, part form the lack of support for extended context control/extension logbook solves them rather elegant and finally gets me something to implement the missing bits to make logs a lot more useful
I thought the purpose of textile was to generate xhtml. What would be the purpose of converting html to textile?
The registry is just painful if you want to create loggers on a temporary basis. And that is often the case if you have factory functions for things using loggers, if you are unittesting and much more.
You decided to start your own project due to an import error? coverage.py is a fairly active project with a receptive maintainer, and [a bug tracker](http://bitbucket.org/ned/coveragepy/issues?status=new&amp;status=open), so the issue could be fixed.
What you cannot do however is to have thread-specific log processors or handlers. Which is exactly what you want in a web application where you don't know what subsystems might log.
&gt; anecdotal "evidence" Sure, I have my anecdotal "evidence" too :-) LoggerAdapter is one way to provide the contextual information, subclassing Logger might be another, and there might be other ways which I can't think of as you haven't elaborated on your use case. As far as poor performance goes, this comes up from time to time. I posted on the [Python Wiki](http://wiki.python.org/moin/LoggingPackage) some response to comments about performance showing that in very rough benchmarks I did, logging overhead was of the order of **microseconds**, and I invited people to contribute more data. I'm not at all complacent about performance. I don't think you did contribute any hard data, but if you would like to provide more information, I can see if the performance problem you encountered is an unavoidable overhead, or something you're doing or not doing ... it's hard to improve performance when you just have anecdotal "evidence" to go on :-( I completely understand you wanting to use Logbook, as it's part of the Pocoo family; if you want any real help rather than just sniping then I'll try to do what I can.
&gt; just painful But it's possible to do - for example Python's unittest for logging does something like this, and I have been thinking about adding a context manager for Python3. Unit testing is an important use case but actual production use cases are just as, if not more, important. Logging does not require you to create brand new loggers for factories (like SQLA connection factories ... this has come up before, and I don't believe there is a need to create completely new loggers for each connection, though SQLA's approach might have predated LoggerAdapter; I certainly never received any suggestions or questions from Mike Bayer about this at the time).
can someone please elaborate, why using the gpl licensed pyqt would be a problem for commercial software? if i write a program with gui, that uses the unmodified pyqt module to use the unmodified qt library (both i deliver as unchanged source and with license), that program with gui still is my own work under my own license and not a derivative work of pyqt oder qt. or not?
There's nothing stopping you accessing thread local data in Loggers, Handlers, Formatters and Filters. Even if you don't want to subclass Logger or the built-in handler classes, custom Filters and Formatters can be readily created. A user-defined [Filter](http://docs.python.org/dev/library/logging.html#filter-objects) on a logger or handler can be used to add additional information to the LogRecord; the docs specifically say that "If deemed appropriate, the record may be modified in-place by this method." Using a Filter certainly allows arbitrary data, including thread local data such as a web request remote user or IP, to be added to the LogRecord. You can then format this using an appropriate format string or a custom Formatter class. I've added an example to the Python [in-development docs](http://docs.python.org/dev/library/logging.html#using-filters-to-impart-contextual-information).
I'll be submitting the bug right away: $ coverage run tests.py Traceback (most recent call last): File "tests.py", line 9, in &lt;module&gt; import my_module File "my_module.py", line 12, in &lt;module&gt; from collections import OrderedDict 
Good question. You could for example use WYSIWYG editor like tinymce or fckeditor to output html - and then make textile from it. That source then is better indexable for fulltext etc. That at least few use cases for this.
Cool didnt see this. If your code would work that would be nice, but it doesnt support nested UL's among things, but its nice to have support for the tags you mentioned :]
I've kept searching and learning. This is what I have been able to do: From here http://tkinter.unpy.net/wiki/tkFileDialog I copied their example and modified it to this http://imgur.com/MoySM It is still rough, but its getting there. The basic layout is there. I need to code the buttons "ENCODE" and "DECODE". I will work on that now.
I wish there were regularly updated blogs that would keep people up to date on NumPy/SciPy/Matplotlib development; pouring over mailing lists or bug trackers just isn't fun :(
sorry, but I solved it with using python2.6 in virtualenv. so now, Flask is not installed on 2.4 site-packages. Thanks. 
Why Linux only?
&gt; â€¢numerous improvements to the unittest module But still no parameterized tests?! E.g. * [nose](http://somethingaboutorange.com/mrl/projects/nose/0.11.2/writing_tests.html#test-generators) * [GoogleTest](http://code.google.com/p/googletest/wiki/AdvancedGuide#Value_Parameterized_Tests) * [JUnit](http://www.mkyong.com/unittest/junit-4-tutorial-6-parameterized-test/) * [NUnit](http://www.nunit.org/index.php?p=parameterizedTests&amp;r=2.5) * [MbUnit (old)](http://weblogs.asp.net/rosherove/archive/2006/09/25/The-future-of-unit-testing-tools-_2D00_-MbUnit_2C00_-NUnit_2C00_-NMock-and-FIT.aspx) * [Pex](http://research.microsoft.com/en-us/um/redmond/projects/pex/wiki/parameterized%20unit%20testing.html) (This is an interesting combination of parameterized testing and automatic test generation.)
Yes, it does violate the PEP8, which is really meant for code intended for inclusion into the standard library, which presumably would never be subject to major refactoring. I think that the traditional convention represents a C++ bias, where memory management is critical and therefore explicit. A reasonable compromise would be to lower-case classes as well. Afterall, they can be used as namespaces, similar to modules, which are lowercase because of filesystem concerns. class globals: answer = 42 question = None [Here](http://google-styleguide.googlecode.com/svn/trunk/pyguide.html) is another style guide, very similar to PEP8, but more extensive. Aside from the function-name part, I like it.
Besides the fact that the libs required are pretty linux specific, I doubt requiring the use of Cygwin and recompiling said libs under that environment for Windows can be counted as "Windows ready!" in the truest sense...
&gt; But, how do you handle testing for the existence of a function, and if the interface is correct? If it fails to compile, that's your first hint, otherwise you run the tests and see what it's returning. &gt; using clang to parse headers Or GCC's `-fsyntax-only'?
What does it do? 
Whatever it does, it's doing it now.
Simply quick WYSIWYG formula generation through [Latex](http://en.wikipedia.org/wiki/LaTeX). Useful if you're used to using something like openoffice and want to quickly insert formulae. You can litterally just drag and drop the generated image you see onto the dekstop or into the document. I use Lyx to take all my course notes in class already but this will make things a bit more "teacher compliant" for me in the long run.
There is an open issue for that and there were a few different ideas tossed around. Another idea that was tossed around was to implement it as a plugin in unittest2. I'm partial to the NUnit style and I implemented most of a patch to do it that way, but there were a few quirks I didn't figure out in the time I spent on it. Maybe I'll take another look and revive it.
I see it requires PyGTK... how hard would it be to make a CLI version? it looks like I could run jpeg.py and pass in files...
nice.
Making a CLI version would be quite easy, for the reason you mentioned. Feel free to fork and submit pull requests :)
I may. or I may just use jpeg.py because I mostly need to process jpegs. but this is cool because I was recently looking for something like this :D either way, I'm watching the project!
There are many problems using plain Python logging to files with multiprocessing. The files are corrupted almost immediately. If you use a rotating log handler, you may very well have multiple log files being populated at the same time in a random order. I've solved this problem over a year ago using a streaming multiprocessing log which I have posted [here](http://stackoverflow.com/questions/641420/how-should-i-log-while-using-multiprocessing-in-python/894284#894284). I really wish something like this would be added to the standard logging library.
I considered doing this myself but I was going to use utidylib to fix the HTML deformations before parsing it.
And py.test. Realize that whatever goes into stdlib unittest will become the golden "standard", so there's quite a bit of debate (and bikeshedding) which has to happen before something large like that is added.
Here is the latest: http://imgur.com/vQ9VN - This GUI still needs a text area that shows what document will be encoded/decoded, and another text area of where such file will be saved. This is the code up to this point: import Tkinter, Tkconstants, tkFileDialog class TkFileDialogExample(Tkinter.Frame): def __init__(self, root): Tkinter.Frame.__init__(self, root) # options for buttons button_opt = {'fill': Tkconstants.BOTH, 'padx': 5, 'pady': 5} Tkinter.Button(self, text='Open File', command=self.askopenfile).pack(**button_opt) Tkinter.Button(self, text='Save File', command=self.asksaveasfile).pack(**button_opt) Tkinter.Button(self, text="ENCODE", command=self.encode).pack(**button_opt) # Added This button to encode the text file Tkinter.Button(self, text="DECODE", command=self.decode).pack(**button_opt) # Added this button to decode the text file Tkinter.Button(self, text="QUIT", command=self.quit).pack(**button_opt) # define options for opening or saving a file self.file_opt = options = {} options['defaultextension'] = '' # couldn't figure out how this works options['filetypes'] = [('all files', '.*'), ('text files', '.txt')] options['initialdir'] = 'C:\\' options['initialfile'] = 'myfile.txt' options['parent'] = root options['title'] = 'This is a title' # defining options for opening a directory self.dir_opt = options = {} options['initialdir'] = 'C:\\' options['mustexist'] = False options['parent'] = root options['title'] = 'This is a title' def askopenfile(self): """Returns an opened file in read mode.""" return tkFileDialog.askopenfile(mode='r', **self.file_opt) def asksaveasfile(self): """Returns an opened file in write mode.""" return tkFileDialog.asksaveasfile(mode='w', **self.file_opt) #function to encode the text def encode(self): pass #function to decode the text (turn it into readable text again). def decode(self): pass #function to quit program def quitbtn(self): pass #Function that says how to encode and decode text. Includes loop and dictionary def encrypt_it(self): pass for variable_containing_text_file_as_list use dictionary to turn every character into the secret code dictionary{ "a":"1", "b":"1", and so on} if __name__=='__main__': root = Tkinter.Tk() TkFileDialogExample(root).pack() root.mainloop() ################################ 
If you used the Windows installer, there should be Start menu entries to "module docs", which is the documentation server (the equivalent of 'pydoc -g' on the command line) and also the Python manuals in Windows Help format.
&gt; The easiest way to find out the structure of an object is looking at its declaration. Its _declaration_?! This is Python - there _are_ no declarations in the language...
What I did in the end, in fact. The stuff around it was incredibly crummy and I don't even know why I wrote that in the first place.
So, why I choose MongoDB as the backend? 1. It's more easy to play with Python dict, no serialization and deserialization like we using memcached, and it is very fast too. 2. I also want to use MongoDB to store the traffics log, it will be very large as the traffic increased, redis and memcached are not suit for this. 
Please see [this post](http://plumberjack.blogspot.com/2010/09/using-logging-with-multiprocessing.html) which uses the same basic mechanism as in your post but in a more generic way (i.e. not tied to RotatingFileHandler as in your example, but using rotating files to show that it works with them). From the post I can add the QueueHandler to logging.handlers for Python 3.2, and the class should be copy-pastable into user code for earlier Python versions. Comments welcome.
No uWSGI or mod_wsgi?
What about this, wouldn't it be easier to extend it? http://bitbucket.org/haypo/hachoir/wiki/Home
Have you considered using html5lib for that? At very least, it is based on WHATWG HTML5's parser spec that all browsers will eventually followed. 
Did you mean there isn't one written in Python? I use [exiftool](http://www.sno.phy.queensu.ca/~phil/exiftool/). It is F/OSS and cross platform.
&gt; will eventually followed. Keyword being eventually. The majority of the web is not HTML5 and won't be for a long time. I'm sure that utidylib would allow me to do the same thing though.
Exiftool is good, but it won't do PSD and doesn't have a GUI.
&gt; The majority of the web is not HTML5 and won't be for a long time. I'm talking about *the parser used by the browser* here, not the whole web. It is meant to be standardized way to parse *any* HTML by browsers, not just HTML5 (so all browsers will see broken HTML the same way). It's not all futuristic, though. [Firefox 4](http://ajaxian.com/archives/html-5-parser-lands-in-gecko) already switched. [WebKit](http://webkit.org/blog/1273/the-html5-parsing-algorithm/) has it enabled in nightly build. [Opera](http://www.opera.com/docs/specs/presto25/) has partially implemented it in Opera 10.5. Don't get me wrong, I don't have any grudge against uTidyLib, it's just that I feel if there's already a standardized way to parse broken HTML, using it would be less problematic in a long run.
Yes, I'd already seen the Joel article, and read how there was really Apps Hungarian and Systems Hungarian. I use a very loose variant of it myself, such as g_ticksCounter for globals (whenever I absolutely have to use them). However, the typing is indeed a nightmare, particularly when trying to refactor using enumerated types or classes and having to go back and inspect all the variables names again for type matching. Horrible idea. That said, my main issue with hungarian, in general, is legibility. Yes, it can be easily parsed with experience, but variable names shouldn't require a decoder to figure out, particularly if you are working on someone else's code.
My personal reason is because I want to use it on computers up to THREE YEARS OLD!!! pyglet requires working opengl (So good fucking luck targeting linux), and some of the basic features (text, for example) require opengl extensions which aren't available on mobile versions of reasonably powerful video cards. PyGame will run (slowly) pretty much anywhere. (I've written both pyglet and pygame games, I've written (sadly out of date) tutorials for pyglet back when it was new, I like both APIs, so this isn't just a whiny pygame user who doesn't want to learn another API. But pygame works on both of my development boxes, pyglet does not.)
This is all great but it has a slight disadvantage: You have to know about every logger which is or may be used while handling the request. Unless you are responsible for the entire software stack you cannot easily use this technique, which again brings us to the advantages of using a stack.
Thank you, Captain Obvious. _Obviously_ that's not what I meant. Maybe "definition" would have been clearer, but it's equally misleading. Next time I'll be sure to cater to the language trolls and just say "that there place where you done defined its structure".
This is a lot of code for something Logbook already offers not just for different processes but even across a network using ZeroMQ. http://packages.python.org/Logbook/api/queues.html It should prove quite easy to extend this to other systems like redis, rabbitmq or whatever else people might be already using for other similar things in their applications.
If you're OK with closed-source software, we use PrinceXML with Python to generate letters, reports, forms, etc. It's HTML/XML + CSS = PDF.
Have you tried reportlab? I don't think it uses latex, but I've heard good things about it.
I've made this module available as a Python package (so you can 'pip install' it) at Github: http://github.com/srid/readability#readme
&gt; This is a lot of code I'm not sure you understood the post fully - it's mostly commented demo code, the only "new" thing is the QueueHandler which I plan to add to Python 3.2, and the while loop in listener_process(). Adding support for lots of handlers is not a big deal in Python logging either - you just can't have those handlers in the core package because of the external dependencies.
&gt; Another idea that was tossed around was to implement it as a plugin in unittest There is already [a prototype of that](http://www.voidspace.org.uk/python/weblog/arch_d7_2010_07_24.shtml).
Do you know if Sphinx is good for making printed books and PDFs? I'd like to write a technical book on programming using Latex, but would I be better off going with Sphinx?
Having just written a thesis in Sphinx that was processed through latex to get PDF, yes!
Have you looked at [Jinja](http://jinja.pocoo.org/)? I've used this to create some simple LaTeX templates for automatic generation of reports from a Python program.
so you just got a job ?
downvoted. it is well known around here that DiP3 is NOT intended for total newbies like OP
gosh that page is painful to read
I've had a lot of success with this too. (I'm using Jinja for both web templates and LaTeX templates, so have two separate Jinja environments.) The process looks like this: * user submits a form to request a report * parse the form and create a Jinja context (pulling in whatever data is needed) * create a temp directory * generate the LaTeX code by applying a Jinja template * custom template helper funcs might write out images to the temp directory for embedding in the output * write the LaTeX output to a file in the temp directory * run pdflatex on the LaTeX file to generate the PDF * do something useful with the PDF (i.e., serve it up to the user) * wipe away the temp directory It seems to perform well enough, even with all that extra writing to disk and spawning an external process.
That's pretty much how I've set it up as well, and it works nicely. Not sure how it would hold up when serving many users simultaneously though (hammering the disk and whatnot).
Oh...well I'm a total newbie and I'm using it at the moment...
I would recommend that you move to HTML based reports, as there are heaps of libraries to do this naturally, and PDF export is available (see pytechd's comment). HTML is as cross platform as you are going to get, and can be served on the web for access after generating. If there is a specific reason to go with Latex, then disregard this comment.
you have ZERO programming experience ?
That's fine and probably the best reason for sticking with latex. You didn't specify that in your post, so I wasn't sure if you were just throwing the wrong tool at the wrong job or if there was a reason (general report generation would not have been a reason).
Unless you can find it in someone's PPA or backports, you're going to need to compile it yourself.
In general, there aren't Linux binaries for most things in the way that they exist for Windows. The exception is proprietary software like some drivers or Adobe's flash player. Different distros handle things differently, but most have a package management system that installs pre-compiled binaries, but that is handled at the distro level. If the matplotlib package isn't working you should probably at least let whoever maintains the package know that it isn't working. After that, you can wait until they fix it, try to fix it yourself, or compile from scratch. You shouldn't need to compile its dependencies.
Well I have been having some luck lately in finding third party Debian packages for different software, so I hoped some kind soul was making Matplotlib ones. Anway, Matplotlib seems to be rather heavily developed, so things are constantly breaking and being fixed. Filing a bug report would probably just be a waste of time. Generally I try to avoid installing from source since it takes more time, occasionally breaks stuff and because things get out of sync with the rest of the distro (like the package manager). I may just have to bite the bullet though.
openSUSE has them in the devel:languages:python repository.
What file types are you trying to scrub? I have some python that will rip all info from all mp3s tag variants and a PSD parser/converter (although that's in C).
C'mon, many of us have been running OpenGL apps on mid-range computers for 10 years now, not three. :) But yes, it sounds like you have legitimate reasons for using pygame. It's just a real shame that these things mean new programmers end up starting with this ancient technology and then getting frustrated when they can't render more than 30fps in 1024x768, dumping pygame for XNA or Unity or some other well-known system with good performance, not realising that the problem is with the backwards compatibility rather than with Python or its multimedia support.
Yep. Nothing at all.
Are videos of this years djangocon going up on blip? Despite the title many of the things here aren't related to scale at all and are just good practice for any django dev team. (Continuous Integration, Testing, setting up a new dev environment etc).
My problem is that OpenGL works, but not some OpenGL extensions that pyglet REQUIRES to render text. I don't have the code here, but I think it was framebuffer objects (GL\_EXT\_framebuffer\_object) that was fucking me over. The open source driver for my card (and the legacy/whatever driver on windows) dropped support for my laptop's mobile card, so while it can play reasonably modern games just fine, it can't display TEXT in pyglet because there's no fallback for text rendering. (I could write my own text rendering, but pyglet didn't add THAT much over pygame that I was willing to spend the time to do that. For 2D games, pygame is "good enough" and it works reasonably well. Sound issues aside...)
 This book: [Open ERP for Retail and Industrial Management](http://www.amazon.com/Open-ERP-Retail-Industrial-Management/dp/2960087607/ref=sr_1_2?ie=UTF8&amp;s=books&amp;qid=1283951966&amp;sr=8-2), was created using Sphinx. I made all the sphinx customizations to have a better book layout. And I also had to post process the tex document (with a python script) to change some little things that Sphinx doesn't handle like the percentage of figures on one page. 
http://pastebin.com/ is a good place for posting code. You paste your code into it, and it gives you a link you can use to share the code with others in a nice setting (with syntax highlighting, etc.). It's better than just posting code into a comment box.
Thanks for the tip. here is the link: http://pastebin.com/GunjfSrG
Who really uses Python 3.x in production? Not anyone involved with web development and mathematics stuff which requires numpy etc. Also it is a lot of code compared to the 1-2 lines you need to setup an handler and another 2-3 lines for a subscriber if you use logbook. Logbook has no more dependencies than logging if you don't need a handler which requires one. However that is not really a problem of logging but of the totally stupid idea to put so much stuff in the stdlib which effectively not only kills those projects but nearly all outside projects doing similar things.
You could subclass Thread and add an abort attribute. Also I think you have to add the keyword 'global' inside the method where you use the variable. 
It has an equation editor, but it's not LaTeX at all.
Just a quick comment on your use of `global`: Writing `global abort, lock` at the global level doesn't do anything useful. `global` is used inside a _local_ scope to indicate that you're using an existing global var OR that you want to create the specified vars in the global scope. In other words, (disregarding any other issues) you need to write `global abort` in `foo`, because that's where you're assigning to the global `abort`. You don't need to specify `lock` because you never assign to `lock`.
LaTeX is not yet another PDF producer, it's a typesetting system. It takes care about all the things like letter spacing, ligatures, various symbols and (probably most important) page layout. You'd have to do all these things by yourself in case you choose some pdf producing library. So don't expect outstanding documents, unless you want to spend a good share of time reinventing LaTeX in python. Everybody can produce pdfs nowadays, but producing good pdfs is a whole different story. So if you can guarantee the LaTeX environment across your targets, the very manual approach is the best.
Research daemonic threads. If your app exits (really, all threads that are not marked daemonic exit) and all that is left are daemonic threads, they're all nuked. In recent Pythons, making a daemonic thread is as simple as: thr = Thread(target=worker, args=(foo,)) thr.daemon = True thr.start() Now if all non-daemonic threads exit, thr will automagically disappear. This is useful for workers in any app.
I'd create a threading.Event and pass it into your threads. http://docs.python.org/library/threading.html#event-objects 
The MP3 tag ripper would be very useful, if you could add that to the code it'd be great!!
rlayton recommended HTML. You say you need something that can do equations. Why not just do all the equations as gifs and then stick with html? I tried to learn how to make my own gifs with maplotlib+TeX, but finally realized this is just as good and easier. http://www.codecogs.com/latex/eqneditor.php
Most likely, it's not a huge deal if the code runs for one iteration more when the `abort` is set due to a race condition, so the lock isn't really necessary. It'll make the code a little slower, but it's good practice. It's a trade-off. You could define Bar as a class that has a method `__call__` and a field `abort`. That way you can pass an instance of Bar to the Thread's `target` parameter, Bar can check its `self.abort` to see if it needs to exit, and the rest of your application can set a non-global variable to stop the thread.
Also note that the lock is redundant in CPython (and probably everywhere else) due to the interpreter lock. Neither thread can run to assign that value while the other thread is running and doing just that.
Another option would have been: class MyThread(threading.thead): def __init__(self): threading.Thread.__init__(self) self.abort = False def run(self): # same code as bar here, but checking self.abort And then your code that wants the thread to abort does self.somethread.abort = True Using an explicit Thread subclass isn't quite as terse as using the target option to threading.Thread, but I think it's cleaner in cases like this where you want to add your own member variables to the thread. Of course the version with the global works too, once you get your global syntax right.
&gt; Who really uses Python 3.x in production? It may have escaped your notice that new features can't be added to Python 2.x; since 2.7 is now in maintenance mode and there are no plans currently to release a 2.8, I can't add it to 2.x. However, the QueueHandler added to 3.2 will be usable copy-pasted into user code - not ideal, but the only way to support multiple Python releases while complying with Python maintenance procedures. Many projects (e.g. Django) adopt this approach with e.g. simplejson. &gt; Also it is a lot of code Not compared to all the code which was written for Logbook, replicating already existing and widely used functionality ;-) It's like the "Knights who say NIH" ;-) Seriously, I'm generally in favour of choice - it's great for Web frameworks, say - but I'm not sure whether it's ideal for infrastructure services like logging. It's usually a big headache when you have to integrate multiple third party libraries, each of which internally uses a different way of doing some low-level common functionality (like logging) and drags in different dependencies for performing the same functions. This kind of thing does crop up in the real world, even in the subset of it which is web development, but it should be avoided if possible. &gt; Logbook has no more dependencies than logging I wasn't commenting on Logbook's dependencies, just saying why Python logging doesn't come with handlers for every conceivable destination for logging messages. For example, adding a unit-testable ZeroMQ handler to the stdlib, while easy to do, would require Python's build infrastructure (buildbots, individual developer machines etc.) to have ZeroMQ and pyzmq installed. And so on. &gt; the totally stupid idea to put so much stuff in the stdlib ISTM you're sharing a can of Kool-Aid with Armin - presumably sour grape flavour ;-) - but in my experience most people regard "batteries included" as a Good Thing. I can't speak for the state of other packages but Python logging is far from dead; it is under active maintenance, gets periodic enhancements, and issues posted on the bug tracker and comp.lang.python get (for the most part) fairly quick responses and resolutions.
It seems there are no alternatives. I've used this approach once, but it was a sever environment and we just created a templates' a queue. Then there was a separate python daemon to process them. Let me ask you a question: do you really need to regenerate a report every time? Could you create a pdf form (probably with LaTeX) and fill it later (probably with reportlab)?
From the title, I thought this was in r/webgames Not dissipointed, upvote.
Use this power only for evil. Never for good. Seriously though, try at all costs to avoid going this much overboard.
what do you mean by "painful"? color?
Should be online at one point yes.
You've already got a system that works -- stick with it. Shelling out to `pdflatex` (via `os.system('pdflatex foo.tex')` is fine. No need to feel guilty. :) Maybe checking the return value from running that command would be a good idea though. The only other optimization you *might* make is (as mentioned here by others) to try out [Jinja2](http://jinja.pocoo.org/2/) for templating. 
huh? isn't that obvious ? 
I don't understand what you are buying here by making abort a list. I think it would work just fine if it were a boolean.
Ah, yes. I see. Thanks.
Reads well... But Needs more &lt;blink&gt; tag for the "draw the line" parts 
TIL: The post goes to great lengths to describe how to implement an alternative modulo for better performance and then tells you it's a silly idea and you should be using native libraries in the first place.
Nitpick: uppercase sigma is not an "e" even if it looks vaguely similar, so the logo doesn't make sense.
It can also useful to make decorator classes. class MyDec(object): __init__(self, *args, **kwargs): # initialize the decorator __call__(self, fn): def func(*args, **kwargs): # do stuff return func @MyDec(True) def foo(): pass Equivalent to MyDec(True)(foo)() I've used a decorator like this for function memoization
hehe. everybody is agreeing with upvotes but removing all those logger.debug(...) statements is going to be difficult right? :D
So, I'm going back the the drawing board. Seems I got ahead of myself by trying to set the GUI up first. I'll go ahead and work my functions to open, read, and save a file, and then tie that function to a button event. Fear not, progress is being made.
I'm pretty sure manage.py shouldn't be in your url. Should call it like http://ipaddress:8000 What operating system are you on?
Awesome! good work my friend. Check this out: http://www.reddit.com/r/Python/comments/cvc9u/i_finally_completed_my_first_web_project_using/ I also started like that, and eventually got the hang of it. Django is awesome, It allows you to focus on your value add, not on recreating the wheel. Keep us updated! 
This sounds like a neat implementation, but it seems like yet another overly-complicated reinvention of the overly-complicated library module. Adding complexity to a logging framework just seems like a Really Bad Idea. Oh, the database went away mysteriously? Let me go check the logs... that failed to be written to the database because it was gone. It's a neat idea and all, but I don't think it really pans for real-world logging needs. Most logging cases I have seen need to absolutely, positively work every time without any chance of being screwed up. This much complexity doesn't exactly fit the bill.
Are you sure the Django Python 3 port is complete? If you're new to Python, you'll find 2.x still has better documentation and framework support. By the way, no need to be using Apache or MySQL to start with, especially when you have such a tiny amount of RAM. Try the built in dev server with sqlite.
 # enable/disable debug logging __DEBUG__ = True #change to false to disable logging if __DEBUG__ : # import / config your logger here else: class logging: def debug(self,msg): return logger = logging() # if __DEBUG == True then debug messages will be logged # otherwise debug messages are ignored. logger.debug("some debug message") 
sorry for the downvotes, but you know if this kind of submissions were allowed, r/python will be rampant with noob questions and people can not find anything new and interesting anymore.
&gt; reinvention of the overly-complicated library module. Why do you say it's overly-complicated? It's actually not all that complicated. You can set up logging in 2-3 lines for the simpler cases. It does a lot, which takes a fair amount of explaining, and perhaps that's why it seems complicated to you. Under the hood, there aren't that many moving parts. I don't know how involved your use cases are, but Python logging has been designed so as to be useful even in complex scenarios while being easy to set up for casual use. &gt; need to absolutely, positively work every time Python logging is designed to never raise exceptions when configured for production, so logging exceptions should never crash your app even if they are caused by developer error such as format-string/argument mismatches. Since it's just software, of course there could be bugs - but I've reason to believe that Python logging is pretty reliable. If you have specific information to the contrary, please share.
This: if __DEBUG__ == true: is much more nicely stated as this: if __DEBUG__: Also, 'true' should be 'True'. 
If the reports amount to hundreds of pages and performance is an issue then plain TeX may be a viable, albeit uncomfortable option. For graphing you could use PSTricks.
scribd? seriously? 
http://www.markus-gattol.name/ws/faq.html --&gt; Why the pink? :-)
This is probably a cop out way to do it, but in order to install Python 3 on my computer, I installed [Homebrew](http://mxcl.github.com/homebrew/) and used it to install Python 3 as a separate installation from Python 2.x: brew install python3 Obviously there's a way to do that manually, but this is easier for me. Then when you want to run something in Python 3.x (like a setup.py script) you just preface it with "python3" in the terminal instead of "python". You should know that Beautiful Soup 3.1 (the one compatible by Python 3.x) is not very good, and the creator has described it as a "failed experiment". So you might not be able to get done what you want to get done (at least not easily). Anyway, I'm sure someone more technical will come around in a few minutes and give you a better solution, but I just wanted to let you know how I did it.
So, let me get this straight. There's a CSRF bug in the CSRF prevention middleware... that can only be realistically exploited via CSRF? It's pointless to modify your own cookies to "exploit" your own session, as no one else could without machine access (or via an XSS/CSRF hole somewhere else). This seems to be a security issue that's only present if you have *other* holes in your code. Don't get me wrong, I'll be upgrading my sites ASAP, but I think this might be a little more trivial than it may seem. Feel free to correct me if I've got this all wrong.
Very cool, Sir.. Have an upvote :-)
It's good practice to do so anyway, so that code doesn't assume what VM it is running on. [Jython does not have the GIL](http://stackoverflow.com/questions/1120354/does-jython-have-the-gil), nor does [IronPython](http://wiki.python.org/moin/IronPython) (any others in "probably everywhere else"?). Also, I/O and other operations happen [outside the GIL](http://wiki.python.org/moin/GlobalInterpreterLock), which means that threads might actually *work* in certain circumstances.
too much space
Fixed, thanks.
I've had no luck searching for examples of developing a tipfy app test-driven. Anyone got a link?
&gt; You can set up logging in 2-3 lines for the simpler cases. Which is 2-3 lines too many. &gt; ... Python logging has been designed so as to be useful even in complex scenarios while being easy to set up for casual use. I have found it to be neither. Simple cases still require too much setup, especially when trying to log across multiple modules. For anything complex, I need to re-implement some part separately or write my own handlers. This is Not The Zen Of Python. &gt; Python logging is designed to never raise exceptions when configured for production, so logging exceptions should never crash your app even if they are caused by developer error such as format-string/argument mismatches. This is a design choice. I would not call it an advantage or a disadvantage, it is simply a design choice. And one that I would not make.
You do not need to change your PYTHONPATH as long as you do not have any custom modules installed in non-standard locations. Simply invoking a particular interpreter (e.g., "/usr/local/bin/python3") will invoke that installation's python framework, libraries, etc. The reason that you cannot use Beautiful Soup is because you have not installed it under Python 3, and it is not available under that installation. You will have to manage the two installations separately. So you need to run "python3 setup.py install" for Beautiful Soup to be available to your Python 3. In any case, to set the PYTHONPATH in OS X, you have to add a line like: export PYTHONPATH=&lt;/path/to/dir&gt;:$PYTHONPATH in your ".bashrc". 
What do you mean the logo doesn't make sense? How does it need to make sense? It spells out latexyt in symbols used by latex - what's not to get? Sheesh.
No, it's equivalent to def foo(): pass foo = MyDec(True)(foo) Also, speaking of these 'decorator classes', why would you possibly need separate __init__ when every particular 'decorator object' is only called once?
I think I stumbled on the same post when I set up my jinja environment for LaTeX :) I'm using that syntax except instead of '[=' and '=]' I went with '[[' and ']]'. I use the following replacements for escaping: '#': '\\#', '$': '\\$', '%': '\\%', '&amp;': '\\&amp;', '~': '\\~', '_': '\\_', '^': '\\^', '\\': '$\\backslash$', '{': '\\{', '}': '\\}', # These two aren't necessary in "math mode", only in "text mode". # should we always apply them? does it hurt? '&lt;': '$&lt;$', '&gt;': '$&gt;$',
There is a bunch of similar stuff around, and I'm a little bit suspicious about it. Yeah, you can do something like this with 'advanced' functional features, and it's kinda cool and concise, but it's not standardized. 
&gt; Which is 2-3 lines too many. Right, so how many lines did you expect to have to use? One of the 2-3 is the import statement: import logging logging.basicConfig(...) # This line is optional logging.error(...) &gt; I have found it to be neither ... Simple cases still require too much setup Tell you what, give me more specifics and I'll try and come up with a recipe. You can post them on comp.lang.python if you like. &gt; I need to re-implement some part separately or write my own handlers Which parts did you need to re-implement, and why? As for handlers - there's a good many handlers shipped in the box, but you'd have to write your own for certain situations where external package dependencies or narrow platform specificity or "too specialised" preclude inclusion in the stdlib. The Zen of Python doesn't say that Python and the stdlib should do all the work for a developer and figure out what they want without them specifying what that is :-) If you tell me the scenarios that you think are too hard to set up / common handlers that you think are missing, I'll try and see if I can suggest some way to make things better. &gt; it is simply a design choice. And one that I would not make. Ok, so would you let your application crash because you made a mistake in your logging setup or a logging call? That may be fine in some scenarios but is definitely not in others. Any way, logging gives you a choice: you can allow it to raise exceptions and handle them yourself, or swallow exceptions because the application has to keep going despite the error. How you configure exception handling for production typically depends on your confidence level in the running code, test coverage, importance of the application keeping running - all factors which differ across users, applications and environments.
There are fewer jobs, but fewer candidates, so it balances out. You'll be happier with your work using Python than PHP. You'll work with smarter people. I've done both, I know from experience. I've used a lot of languages, I thought PHP would be good to shift to because of the jobs, but I learned the hard way that this isn't how you want to go about planning your career. It's most important to do what you like. This won't apply to a contractor as much as it would to an employee, but in interviewing with Python companies I've heard that they often hire people who don't know Python and then train them. They have that hard a time finding Python developers. It's a good position to be in if you know Python. 
Ahh, yes.. Ofc.. Thanks !
It spells out `latsxyt`. If you read it as symbols, you'd even get `lat(sum)xyt`, which makes even less sense. It's using the Greek sigma like faux cyrillics (or the heavy metal umlaut) except that kind of usage clashes heavily with `LaTeX`: the "x" in "LaTeX" is not a Latin "x" but the Greek "xi" character, which is why it's not pronounced like the rubber. As I said, I'm nitpicking, but that doesn't make the logo less silly.
I'm at DjangoCon right now and there are plenty of people here that are hiring Django devs. Obviously this is a self-selecting group, but the mindshare for Python web development is growing fast.
PHP is nearly ubiquitous on hosting sites but there are many that support Python/Django. At worst you could get a VPS for ~$30-50 a month for a decent plan. I would guess that any customer who is unwilling to pay even $30-50 a month for hosting is going to be extremely problematic in other respects and should be avoided. Do you agree? For companies who do their own hosting and have a policy of only using PHP, then I understand there's nothing you can do. In this case, yeah, if you stick to Python you'd have to avoid these customers, which was sort of what my original questions were about -- are there enough other customers to stay afloat?
Sorry to state the obvious but location is everything: if you can have face-to-face meetings with your clients, you are head and shoulders above any offshore developer, so don't worry too much about them if you are in a tech hot spot. Anyway, if you are going to do freelance web development, you will have to learn some PHP. There will be times when you will have to fix or tweak pre-existing sites instead of rewriting the whole thing. It doesn't have to be your main development platform, though, but in this case you may end up responsible for keeping your client's infrastructure up (and hopefully earn an appropriate retainer fee for it). 
There are more PHP jobs, but everyone and their dog is a PHP developer these days, so the ratio is probably quite similar and the competition (in terms of pricing) may be much higher with PHP than with Python. It's probably not economically feasible to provide Python services exclusively unless you already have a foothold in that niche but the overall sophistication of the jobs may be quite a bit higher. If you want to keep on catering to run-of-the-mill clients who have a shared hosting account with some cheap ISP and want you to fix their website, Python isn't going to be of much use to you. From my experience, the problem with PHP is rarely the language itself but the kind of code you have to work with and the quality of the libraries that are available. PHP's `*ahem*` _amateur-friendliness_ tends to lead to a lot of bad, incomplete or buggy reinventions of various wheels and it tends to be really difficult to pick out the decent ones among the vast amount of shoddy ones. No matter which language you pick, you'll have to focus on a niche unless you want to compete by pricing (which you won't be able to unless you move to rural Asia).
&gt; You have to know about every logger which is or may be used No you don't - just the handlers, which *you* (as the application developer) control. So I don't see what the disadvantage is.
I did freelance Python Web development in Portland for a year or so and got by pretty well, so it's definitely possible. I'd say, push for using Python on new sites or rewrites of existing sites. Sometimes, the client won't even know much or care too much about platforms, so you can choose whatever you want. I wouldn't worry about future developers being able to maintain a Python based site either. I think there are enough eager Python developers these days that that's not a big concern. It's not either/or, though. PHP can be unpleasant, but if it pays the bills... well, you gotta do what you gotta do. That said, if you can specialize in Python, you might set yourself apart and end up in a better position down the line.
If you're comparing to bargain basement PHP hosting, it's pretty easy to find similarly priced Python hosting options these days. WebFaction comes to mind, and I think they're much better than your average PHP host. There are also cheaper VPS options you can use to get your foot in the door and then scale up if needed. I've heard good things about Linode and Slicehost, but I've never tried them myself. I agree that clients that don't want to pay for decent hosting are probably going to be problematic, unless they're one-person operations, and in that case, I might just go with a basic WordPress site anyway.
&gt; I would guess that any customer who is unwilling to pay even $30-50 a month for hosting is going to be extremely problematic in other respects and should be avoided. Someone just starting a business that sees $5/mo. hosting vs. $30+ might not like it, especially when they don't understand the difference between PHP and Python. If this is an issue with multiple clients, maybe look into getting a VPS for yourself and hosting for clients at a much more reasonable price.
There are more PHP jobs out there, but when you look closely so many of them are not jobs you want. They are from clients with little money or common sense. I've steered clear of PHP work for years now for exactly that reason and it's worked out for me. The fact that someone is interested in using Python means they are more likely to be a good client to work with.
Unless you really need the equation-layout capabilities of LaTex, you're better off with rst2pdf. LaTex is a heavy dependency and making custom layouts (classes and styles) is hard.
Man, I forgot about that site. Thanks for posting.
Now I think about it, it reStructuredText is not a suitable means of holding your content (for example, if your reports have a lot of dynamic content), then you might as well use ReportLab directly. It's a very robust and nice-to-work-with reporting library with comprehensive PDF-writing features.
It would allow elevation of a partial DB injection attack to potentially become an arbitrary CSRF issue. So yes, not a gigantic issue unless there is something else very wrong with your code.
I used to develop proof-of-concept applications for the DoD and have built apps in every language du jour (c, c++, python, perl, java, vb, ada, asp, php, coldfusion, ruby, pascal, etc) using various db engines (postgres, mysql, oracle pl/sql, ms sql server, titanium, dbase, etc) but I am not an expert at any. My advice, focus on the craft and data more than the language and storage. Once you learn the principles, you'll start to see that, primarily, only the syntax changes. 
Yes once you get your foot in the door. 
If you're starting out from a basis of tech-savvy/amateur then at least initially the kinds of contracts you are able to go for are at the smaller scale. I think you'll get a lot of mileage out of being able to do whizzy things with Wordpress. Python is a nicer choice for bigger, more complex projects but PHP and Wordpress will be a quick win for you in the short term.
it's better now; after years you were finally the one to trick me into opening my .css again :-)
Not just Wordpress. Drupal is really nice for doing things in a quick and "whizzy" way. If the client's desired featureset is somewhere within the abundance of contributed Drupal modules, it's like shooting fish in a barrel with a specially-designed fish-barrel-mounted cannon.
Works fine for me.
wow all those languages
I am a free lancer who uses mostly Python. What you lose in web development you gain in infrastructure. That is, Python is widely used for controlling hosting systems, provisioning, virtual hosting technology APIâ€™s, network stuff, system administration scripts, APIâ€™s, queueing, daemons, etc.... If you are well versed in systems stuff, particularly Linux/Unix, then you can get work in that end. I find it was more fun and way the fuck easier since you are not stuck in browser compatibility hell.
It's actually an XSS issue. I'm not sure what it elevates since you do need to set the cookie, but there might be something. Edit: sites that modify cookies through document.cookie without encoding user input (for ;= and whitespace) are the ones at risk, I think. That bug in the CSRF protection escalates a specific XSS vulnerability into full DOM scripting.
I have decent familiarity with half a dozen or so languages and I agree and disagree with your answer. I agree that a lot of it is just syntax. Okay, so in Perl you prefix scalar variables with $. In Python you need whitespace. Whatever. But most of it is just the same old loops, conditional logic, objects, etc etc, each dressed up a little different. On the other hand, there is more than just syntax. Each language has its own flow, its own feel. Java and C are totally at odds with one another, or at least (IMHO) good code in Java and good code in C should probably look very different even if they do the same thing. I've written Python that did its job, and then gone back later with more knowledge and rewritten it in a way that did not change the input/output of the code but made it much easier to read and more in tune with the language. The syntax is easy, but the feel of the language takes longer and requires practice. I assume frameworks compound the problem, for example not only do you get comfortable with Python syntax and flow, but also Django syntax and flow, making twice the problem if you later switch to (say) PHP/Zend.
Would you please give specific examples of the type of work you mean, like what a particular job looks like? When I think of freelance web stuff I think of writing a website from top to bottom, or writing a particular back-end app. But it sounds like you are talking about something that is almost IT contracting rather than web development.
What sort of niches do you think Python is well suited for?
What he said.
For Denver Colorado, the number of openly labeled Python contracts has slowly increased from a dozen to two dozen. Generally every single one of these contracts were super specialized ( scientific laboratory, robotics automation, or infrastructure automation, very large data set ETL, etc ) so the pay is much better but you will be fighting PhD's to get the contract. Meanwhile PHP contracts are usually mostly stupid simple and you will be fighting people who read a book once on PHP. I could juggle 2 contracts at once each paying 45-65$/hour for 40 a week while a python job might have a set cost. Also don't worry to much about offshore PHP competition, any company using off shore shops is usually a client you didn't want anyway.
Well, _Python_ web development is a niche, to start with.
Python is becoming/is very broad and general. That being said I personally see python get used a lot in CLI apps, server apps, and web apps. Generally anything running in the background (not a lot of GUI apps it seems though). But when it comes to the web Python is only well suited for highly interactive websites. Building a brochure-ware type site (you know, about, contact, our location and services for a dental office) in Python would be overkill when you factor in maintenance, upgrades, training, and server costs. On a side note, I'm a professional PHP developer and I consider any PHP developer without at least a basic understanding of Python putting themselves at a disadvantage these days. Many of the web apps I work on use Python-powered daemons to do my heavy lifting.
I agree. IMHO it pretty much depends on what type of customers you are going for, where you live, what your background is and who you might already have contact to. PHP is fairly easy to pick up and with previous python and programming knowledge it will be easier for you to recognize many of those ugly PHP practices that are all over the web and avoid them. In the beginning of your freelance career it might be easier and more efficient for you to approach local businesses or people you already know for jobs. And most of them probably will have a php/mysql website running on a shared webspace that just needs to be extended or tweaked in some way. At least that is what I experienced after going freelance. While most of those jobs were ultimate shitty in retrospect yet somehow paid the bills, some of those early encounters have - after getting to know each other and building up trust - turned into very long lasting and rewarding work relationships.
Oh wow. Wow. &gt; but in interviewing with Python companies I've heard that they often hire people who don't know Python and then train them. This makes me really happy that I chose Python.
You could also get a half-decent VPS yourself and offer to host them for a fraction and offer paid support. Hosting can be a good way to build up a regular income and establish a long-term relationship. YMMV, though: many redditors have warned against hosting clients yourself because it can be more trouble than it's worth. Also, either approach requires you to have a working knowledge of Linux server administration (i.e. securing and maintaining it without a GUI).
- high-load http redirector - a twisted daemon - massive parallel crawler for traversing domain trees - scrapy, which is twisted too. - parsers for various formats, from xml\json to some specific EDI - pyparsing for the rescue - control panels for this stuff - micro-web frameworks, web.py in my case. these are projects I did as a contractor\freelancer. freelancing isn't just about web, it's about solving problems. 
&gt; If this is an issue with multiple clients, maybe look into getting a VPS for yourself and hosting for clients at a much more reasonable price. FTFC (from the fucking comment) :).
Nope. /doesn't want competition
Eh. Sorry. I guess it's getting a bit close to bedtime for me.
I agree about each language having its own flow and feel but neither matter, if one doesn't understand the principles of programming and software architecture. One could easily get wrapped in the mindset of doing things the Pythonic way and write crappy code because they continuously reinvent the wheel. Learning the flow and feel will come with each project but so will one's ability to write lasting apps as long an effort is made to understand first then code. 
not always beneficial, I find myself running to google for a refresher if it has been more than a few months since I last used a particular language
PHP is annoying. PHP programmers are infuriating. I'm currently doing maintenance on a project where the source files number in the hundreds, archived versions are mixed in with current versions, and the source file extensions run the gamut of .php, .inc, .inc.php, .php.inc, .html, .html.inc, and .inc.html. Of course, inside these files is an unstructured mess of html, css (inline, &lt;style&gt; tags, and separate .css sheets), javascript, php, and inline sql built with php string concatenation and unsanitized superglobal variables that are stringly typed. Some of the files don't even have matching start and close tags, since the elements will be spread across multiple files. Oh and just for good measure, there's html in the database (also with inline styles), the version of phpMyAdmin they run is old, the OS they run is old, and there are multiple copies of the same database on the server. They have a SVN repository but clearly have never used it, so the same project appears about fifteen times. They apparently didn't know how to use tar, so the duplicate projects aren't even in archive files. On top of this, phpMyAdmin is installed as a subdirectory of the main project, so phpMyAdmin is also duplicated about fifteen times. And then there's PHP the language. It, too, is a festering ball of shit, but I won't go into the details there since by modern calculations 8% of the Internet consists of articles about why PHP is terrible. \* edit - for the record, while I loathe working with PHP, I'm glad I know it. It's a low barrier to entry and it gave me opportunities to learn about Linux system administration and break into open source development that I might not have had otherwise.
Only if you can manage to be better than at least the bottom third of python developers.
PHP is for people who don't want to learn how to program. As a result they get paid less even if they have more jobs to choose from. If you don't mind doing PHP then do both as a freelancer. Use the PHP jobs to pad out the time between the fewer more exciting Python jobs.
Well let me share my experience with you. About 2.5 years ago (summer 2008) I was halfway through a summer semester and decided to randomly browse through Craigslist software jobs. I would always search for Python just to see if I could find anything, almost always it would just be something like 'C++/Java/C#/PHP dev wanted, Python would be nice to have' or something similar (I mean one of those languages, not all 4 ;P). So at the time I was taking a web course and I was using Python/Django for my project so I was all primed on it, and then I randomly came across a posting for a web application developer, using Python and PHP. When I read the description it was clear I would get to ACTUALLY use Python for a non trivial amount of work, so I immediately shot them an email, and they brought me in for an interview. For the interview I wore my nicest white suit, he basically sat me down, we talked about school, about projects I'd worked on in the past, and finally he left me alone to work on the Python Challenge. Luckily I'd gone through most of it a few years earlier so I still remembered how to solve most of the problems. But he wanted me to do each one in Python and PHP. And I've used PHP in the past but my PHP-fu isn't nearly as strong as my Python, so when it came time to do one that involved parsing a huge block of text I couldn't figure out how to do multiline strings with PHP's &gt;&gt; &lt;&lt; or whatever operators. Ultimately I finished the Python ones and not many of the PHP ones, but they called me back and said they wanted to bring me in anyways and that I was the best candidate for the job. Within the first few weeks I did a small amount of PHP maintenance for some of their existing sites, but also started building some new projects from scratch in Python/Twisted/PyAMF (basically server side for hosting RPC to flash clients). From that point forward I was the 'Python' guy, and about 6 months later my boss came over to my desk (at this point we were still doing a lot in PHP and Java) and said 'So we're switching over to all Python for all new projects moving forward', to which I was overjoyed, but it also made me the resident expert in the office since I've been using Python since 2003 and everyone else had maybe 6 months at best experience. So having these PHP and Java guys switch over was good and bad, each person brought their coding style with them, which resulted in lots of not-so-good code. The Java guys thought they had to turn everything into dozens of little classes that stacked and composed over one another unnecessarily, and the PHP guys just thought we didn't need any structure at all and put large amounts of code where ever they pleased. Over the course of two years those guys were all let go until I was the only one left, and now I just work with my boss and we continue to do Python. Nowadays I don't build backends for flash clients, I build Python/Django/AppEngine RPC hosts for iPhone apps, either written in Objective C or HTML5. I work full time for a decent rate, I get to work only in the language that I love, and work on interesting projects. So I guess my point is that a good Python job is hard to come upon, but when you stumble across one you just LEAP at it. Like if you enter the job market, depending on where you live, chances are you WON'T find that 'dream Python job', but you should find something to tide you over and at least get some experience and contacts under your belt, but always be mindful of the job lists until something really cool does come along, and then leap on that thing like a lion on a bucking wildebeest. Feel free to ask me any other questions if you have any, and good luck finding something ;)
That clarifies things a bit. Still, it seems like you'd have to have something else poorly coded (and probably just as easy to exploit) in order for this to even be vulnerable.
Truthfully, there is a learning curve with anything, but with experience, the transition between frameworks/languages becomes much smoother. At the very least, being able to move between frameworks is essential. In the last few years, I've had to work with a lot of frameworks, though I've been able to keep the languages to php and python. Being able to step into a new workflow and adapt quickly is a pretty important thing for a freelancer. It really helps to open up options for new clientele.
You just made me very depressed about my life.
&gt; often hire people who don't know Python and then train them For any programming language it is better to hire a smart person who doesn't know the language over a stupid person who knows the language. Sure you pay for a couple days to teach the syntax, but that is trivial - you will spend far longer than that teaching all of your problem domain to the new guy. You will also face some time where he doesn't know the standard library well, and so doesn't make the best choices, but you should have an expert doing code reviews of his work anyway, so those problems can be caught early.
I don't know about viability, all I can say is that Python won't stain your soul with evil like PHP will. Turn away from the dark side, young padawan, before it destroys you!
Yes and no with regards to the teaching of the syntax. Learning to write syntactically correct code is fairly trivial. However, learning to write it idiomatically takes far longer. Java styled in Python ain't all that pretty or useful : )
Why does the logo have to be serious?
Yes, also more profitable.
why? You're not the one in the office at 8PM working on this shit. P.S. I just discovered the project's glossary page. It's a 1200 line flat html file with navigation done entirely with anchor links. Each letter of the alphabet has its own section. Within that section is an anchor for that letter, and a link pointing to the anchors for every other letter in the alphabet. Again, written out entirely in HTML, even though it's a PHP project. It also seems the person that wrote it didn't understand that a carriage return inside of a &lt;p&gt; tag doesn't actually render a carriage return, because each content block appears on a single line. So far the longest one I've noticed is 1400 characters wide. Anyone know how to find the longest line in a file in Vim (or perhaps at the command line)? I'll tell you the length of the longest line if you know how to identify it. In one of the other files I saw an array written out with every letter of the alphabet because the author clearly didn't understand what ascii was and never bothered discovering the `chr()` function. The array of Roman numerals written out as strings was pretty funny too, especially since the author didn't bother to turn it into a function (the first index is a 0, so that you can do $romans[5] and get 'V' in return). At least he stopped at 15. \* edit - wait the glossarry gets better. There are links all over the glossary pointing to different keywords. It looks like someone did a search and replace operation in a text editor and replaced (nearly) every instance of every keyword with a link to its respective anchor. There are 673 links in this document, all pointing to itself. There's an occasional miss or typo, so it looks manual to me. It's the most amazing thing I've ever seen.
&gt; Building a brochure-ware type site (you know, about, contact, our location and services for a dental office) in Python would be overkill The problem is deployment. Once you have a simple multi site deployment strategy, it's easier and faster to throw these together with Python. Not to mention the free admin CMS that comes with Django leads to quite a few referrals.
It can do *anything* badly.
Here's an interesting question: What's your goal? * Do you just find playing around with making GUIs fun? * Do you want to make some kind of specific Python GUI program eventually? * Do you lose interest making command-line programs? If yes, then I guess sticking with GUI programming will be ok. Having said that, if you don't have any of those goals (and you don't need the GUI to keep yourself interested)... going with a pure command line app will probably help you focus on the learning part more. BTW, was there something that motivated you to want to start learning to program? ... long way down the road kind of thing... for example, may you wanted to make games? wanted to make a specific program? want to do scientific apps? webapps? os design? :)
Do you find playing around with making GUIs fun? - It is fun, yes. Nothing like making something out of nothing. Do you want to make some kind of specific Python GUI program eventually? - My goals in programming demand great GUI knowledge. I'm not particular to Python. Python just makes things easier for me (if compared to C ++). Do you lose interest making command line programs? - No. I find them very useful, as I'm an Ubuntu geek myself (can work the terminal pretty well). I've always been attracted to fixing things, to finding the *right* way to solve problems. I used to work as a car mechanic (to satisfy that need), but just found out that programming is what I enjoy doing (even if I suck at it). For me programming is like a key to many doors. My ultimate goal is to create a private foundation to finance science globally. Knowing programming, let's me create software to finance such goals. Software requires a low investment in terms of money, low overhead, and the ability to create a product that will make a difference. Big goals require big sacrifices. But I enjoy beating down giants.
I need you to need to understand the difference between a programmer who is versed in web related technologies and a web designer. You do not want to become a web designer. The closest thing to polite that I can say about a web designer is that they are "Graphic artists who are in over their head but don't know it." As a sysadmin, web designers are almost the bane of my existence. They are the Realtors of the internet. Secondly do not limit yourself. The things that you say you don't want to learn are petty. I don't mean that to insult YOU, I mean they are petty things. You're learning to remember a semi-colon at the end of each line. You're learning to use parens in a certain case instead of braces or brackets. You will learn other things when you pick up a new language, that will help you understand other things in python. Knowing both increases your hireability. A lot of people who would be hiring you don't know POP from IMAP. What they know is their competitors site uses Jadu, or their neighbors kid says that he uses Django for his blog and it's great. It doesn't matter that they want you to set them up with a steaming pile of shit. What matters is that you are good enough with steaming piles of shit to give them what they want to pay you for. When you're lucky enough to run into someone that KNOWS that they don't know wtf they're talking about, they'll leave the technical side to you, and just tell you what they want for an end product. Be flexible. Python is great, it's my second favorite interpreted language. You want to do web work? Learn PHP. Learn Perl. Improve your python. Once you have the basics of programming down, switching between languages is a breeze. You'll have the occasional glace at the docs for syntax issues and that's that. Also I fucking hate your average die-hard PHP programmer. But I'm a hater.
Your problem with PHP is less a language problem than a problem with the developers of the code you're maintaining. It's true that the low barrier to entry reinforces bad habits for young developers, but PHP is a maturing language that is quite capable of producing maintainable code.
"Multiline strings" via "whatever operators" are "here documents". This proves to me without a doubt that you get paid more than me.
Correct. Whoever is doing the hiring isn't doing a good job. In the last two places I've done PHP, everything was very structured, and if you didn't adhere, you were the odd man out looked down upon. OO, Framework, repositories, etc - managers are becoming more and more aware it's not a matter of just putting out code that works ASAP anymore, it's about putting out code that's readable, easy to maintain and modify/update.
ecosystem is a language feature. PHP has a bad ecosystem.
True, but PHP does pay the bills when you live in an area where no one uses Python for a hundred miles in every direction...
I concur about the hosting environment. For example, we have servers that run CentOS, and wouldn't be able to run Django because they use Python 2.4, and if you know anything about that flavor of Linux, upgrading to 2.6 is no simple task, since these distros are built that way on purpose, so that they are stable.
There may be an easier way, but since this _is_ /r/python; pipe your file contents into this: python -c "import sys; print reduce(lambda a, b: max(a, len(b)), sys.stdin, 0)"
I agree, based on my own research into the different categories of web professional, that web designer is not at all what I'm shooting for. It is just not a good fit for me. I understand your comment about "petty" but you misunderstand my position. In fact I have gone down that road many times already and have at some point gotten some understanding of a bunch of languages, the level of understanding you get from a thick book and some exercises or Project Euler problems. The basic syntax and vocabulary but no real depth. So, I am fully aware of how similar the syntax is between most major languages. It is because of this familiarity that I am hesitant to spend time repeating this exercise with PHP. Could I? Easily, I'm sure. But I have so much more important stuff that I need to learn, the higher level stuff that requires fluency in a core language as a starting off point, that I'd rather focus on that. But if it turned out that Python was practically useless for web work, then I'd be willing to shift gears into PHP now to save trouble later. Pardon the analogy -- I hate analogies -- but it's like someone deciding whether they should learn Spanish or French. Both languages are very similar and differ in ways that are ultimately trivial. Does it really matter whether you say madre or mÃ¨re for "mother"? No. But the reality is that each language opens up very different doors, and that being the case it's best to determine at the start which will serve the student's needs before he spends his time on one or the other. And sure, knowing one makes it easier to learn the other, but if the student's goal is ultimately to live in Mexico City or Montreal, why not get it right at the beginning? Anyway the answers to this post have been very encouraging. It sounds like Python work is definitely out there, and building a set of skills around Python is a totally reasonable thing for a web freelancer to do. I'm sure at some point I'll browse through the PHP documentation, but right now it's not a priority.
&gt;managers are becoming more and more aware there have always been good and bad managers, I just happen to have shitty ones for a mixture of reasons. Books like The Mythical Man month have been espousing good management practices for decades. PHP is cheap, easily deployable, portable, and easy to learn. It has its place and I wouldn't say that it should never be used, because in a number of cases it is the best solution, but don't claim that it's a good language when it's clearly a piece of shit. Loop over the file names in a directory: &lt;?php if ($handle = opendir('.')) { while (false !== ($file = readdir($handle))) { if ($file != "." &amp;&amp; $file != "..") { echo "$file\n"; } } closedir($handle); } ?&gt; Please. That's just retarded. If you want to be accessible, don't make users strip out `.` and `..`. If you have a file handle object, make it accessible in your `foreach` construct. That's the whole reason it's there; to iterate through collections. get_class vs gettype? Oh fuck off. Or how bout the fact that `preg_match` returns an integer 0 or 1 if a regex match is found? What? Return a fucking boolean then. If you've got two values, return a boolean. What's so fucking complicated about that? Oh right, because if an error occurred, `preg_match` returns false. Wait, what? If an error occurred, raise a fucking exception, that's what they're there for! Examples like this are all over the language. These distinctions are terrible for both inexperienced programmers and experienced programmers. They make inexperienced programmers thing that programming involves the wrote memorization of countless random rules, and that they should always have the reference on hand. They make experienced programmers frustrated, because they can't learn one thing and deduce patterns about the language and apply what they've learned throughout. Of course, it is possible to know all this stuff. It is possible to be a good PHP programmer. But PHP is not designed in a way that enforces regularity and good habits, because the language itself is so randomly structured, its naming conventions so randomly chosen, its failure mechanisms so inconsistent, and its object-orientation so obviously bolted on and leaving more to be desired. [Falcon](http://en.wikipedia.org/wiki/Falcon_(programming_language\)) looks like it could be a promising replacement for PHP, but whether it picks up any traction is yet to be seen. I personally loathe the way php is embedded in html, but I think it's an extremely effective mechanism for turning front end developers into back end developers, and Falcon is the only other language I've seen that promises such a feature while offering a clear, language-native path towards cleaner and more maintainable programming styles. OK. Rant over. Zemo out.
1395 characters was the longest, so I'm a liar, but not by much. (and thank you.)
I agree with you about PHP having it's numerous faults, but when it's all you have to work with and the only other choices around your area are Java or .NET, I'll stick with PHP thanks. Just like anything though, it's how you decide to use it. I find watercolors to be an absolutely terrible medium to work with; however, I've seen artists do amazing, almost photo-realistic paintings with it. You can choose to quickly and sloppily throw colors on a canvas and make something that looks like a picture for a quick buck, or you can take your time and draw upon methods you've learned and create something worthwhile. You could probably even create a pretty good replica of Michaelangelo's *David* with a pile of shit if you tried hard enough... :)
Loop over the file names in a directory: $iterator = new DirectoryIterator(dirname(__FILE__)); foreach ($iterator as $fileinfo) { if ($fileinfo-&gt;isFile()) { echo $fileinfo-&gt;getFilename() . "\n"; } } This is an example of the [Standard PHP Library](http://www.php.net/manual/en/book.spl.php), which corrects many PHP idiosyncrasies. Moreover, [PHP 5.3](http://php.net/releases/5_3_0.php) adds some advanced programming features that other languages take for granted. As for your other complaints, PHP relies on the conventions of its underlying libraries, which has the unfortunate but understandable consequence of inconsistent signatures and return values. This is a weakness, but easily solved using the facade pattern. There are several PHP [libraries](http://framework.zend.com/) and [frameworks](http://www.symfony-project.org/) that make PHP consistent, maintainable, and still easy to learn.
.NET is the opposite extreme; it's *too* structured.
I've deployed a Django 1.2 app on CentOS (py2.4 and all). What's the problem? Other than CentOS being a pile of shit, it does work...
Came here to say this. WebFaction starts at $10/month for shared Django hosting. Also, the deal with VPS's is not so much how much they cost, rather that you have to administer them. Going slightly up market, Media Temple will host Django in a "grid container" for $20/month - http://mediatemple.net/webhosting/gs/features/containers.php
I am doing this for myself and a few web dev friends.
[How to Think Like a Computer Scientist](http://openbookproject.net/thinkcs/python/english2e/) is a good (and not to mention free) beginner's introduction to programming book; it focuses on Python and doesn't assume you already know another programming language. Also, I keep Python Essential Reference (4th edition) near my desk at all times, and would recommend it to anyone who uses Python often. 
While I agree with you with the shitfest that is PHP, using another language will not make for better programmers. I'm working on a Django/Python project right now and it's a chamber of horrors: 1) views over 800 lines long, almost everything in a single app, with no methods in the models 2) weird and incomprehensible variable names 3) try...except blocks everywhere there has been a bug, rather than fixing the bug 4) inline styles in the templates rather than external stylesheets and classes 5) copy-and-pasted JavaScript in the templates rather than external JS files 6) 10,000 line modules (I shit you not) 7) (and I probably don't need to point this out) not a single unit or doc test in sight 8) A crappy schema which looks like it was designed by 2 year olds at kindergarden using crayons, requiring multiple joins for no reason whatsoever on tables never used. No, that's insulting to 2 year olds who have at least some innate grasp of logic. This crap was written a couple of years ago by amateurs who hadn't a clue. I've begged to do a rewrite but never given the time, management just want to pile on the features in order to sell to clients and give in to all client requests with no idea whether it's doable or not (latest request - "can we store business rules in the database" ?) It's a festering pile of steaming shit that has sucked the life out of the new developers. Moral: PHP can (against its limitations) be written well. Python can be written badly. Your problem isn't PHP, it's poor developers and shitty management.
You can have a separate Python2.6 install that doesn't touch the system install, compile mod_wsgi to use the 2.6 install and use virtualenv.
You've just made me better appreciate my work-life. Yeesh.
I think it's better written as `max(len(line) for line in open("filepath"))`. Things written using `reduce` are always more confusing than they need to be.
On the other hand, I'll take a guy who code Java in Python over a guy who does thousands copy-paste to simulate loop and array any day :-)
This is why I love working on my projects ALONE. I know it's a loaded statement, and not doable in a lot of situations, but the project I'm on now I'm the only developer (currently) so I can have really tight control of code structure and project layout. Other developers always screw things up ;P
I would love to be in that position, but projects like that are very rare - almost all the work I've done the last few years has been maintaining something done by others, apart from my own open source stuff and trivial side-projects. Ideally, I'd like to either do my own startup, or else work directly for customers (not other contractors). It's pretty much my own fear and laziness, preferring a secure job over the risk of going it alone, so I can only blame myself for ending up with projects I hate.
`&gt;&lt;)))Â°&gt;` More seriously: a logo doesn't have to be serious, but this smells more like an honest mistake than intention. I'm not a designer, but even I know that stylistic choices that are indistinguishable from slip-ups are bad.
Yeah that ridiculous heredoc syntax, the parser just wouldn't accept it, probably didn't like the few thousand lines of random ASCII sitting inside it. I am so thankful I don't have to work in PHP. 
I've been thinking about taking a "web programming" approach to document generation for a while now - with models, views and all that, ending in a templating engine =&gt; latex, compile, and serve up. Let us know how you progress!
Note: BeautifulSoup has no python 3.x version (afaik) and the main developer has said he no longer enjoys working on it, and is not planning to port it. Look to google for the full details.
er... I'm spanish and I don't understand french. There are just a few words that are similar, but just because we share latin roots. Nothing else! :) Nothing to do with your original question, though. In that sense, I've just tasted PHP recently... and I prefer Python without doubt. Cleaner, concise and versatile. Good for the web, great for that and even for stand-alone applications (I've used Python with Pyglet for games). 
No PyCharm ? I am disappoint.
No PyCharm?
Doesn't even seem like a fair comparison without pycharm - I've used several of those and none come close to pycharm.
It seems more likely to me that you want it to be a mistake so that you can feel better about yourself. A capsig looks like an E, and is a symbol commonly used in latex documents, and so is a sensible choice for the logo.
Wow, another Python magazine. Anybody else remember pyzine from about 10 years ago? 
I work in recruitment. Here's the deal: - there are less python jobs - they pay more - you might have to move - you have to look a little harder - you can still apply for php jobs (and you'll be on top of the pile) In short, because there are fewer jobs and fewer programmers available, finding each other is harder. Both parties are more motivated to want to keep each other. This means that wage may be higher, and that you may be expected to take on more responsibility. But more and borader webdev experience is always a plus for any webdev job apply for. So if you can't find a python; it's not like it would be hard for you to get a php job. You already have experience with that, and knowledge or work experience with python would suggest there is a bigger chance that you know what you are doing. So it will easier to get an interview for a PHP job. Off course, the interview itself will always be crucial.
PythonWin ftw. Or maybe IDLE. Edit: Not anymore. I didn't know about PyCharm. Downloaded it and it is now my #1 choice. In my experience, anything from JetBrains is pure gold. 
I was hoping this would be a magazine about Python for the Commodore PET. I'm disappointed now.
I expect tinypy could be coaxed into a C128, MAYBE a C64, but a PET? You are dreaming, friend :-)
Me too :)
Anybody remember Python Magazine from last year? 
My point was that even though Spanish and French are about equally difficult for an English speaker to learn, they really are different and they serve different purposes. The student really should figure out which one suits his goals before beginning to learn. This was to counter the idea that it doesn't matter whether you learn Python or PHP because programming is programming. This is why I hate analogies by the way, but it's not your fault, I asked for it.
Well, at least we won't charge you for it ;-)
Eclipse + pydev is missing as well : /
Is IDLE still actively developed? I'd forgotten about it, but it's a cool little editor/ide. Does it make use of the recent ttk changes?
&gt; It may have escaped your notice that new features can't be added to Python 2.x; since 2.7 is now in maintenance mode and there are no plans currently to release a 2.8, I can't add it to 2.x. I am aware of the state of the 2.x series, nevertheless that complicates things for developers even if it's just copy and paste there is also stuff like testing or changes to that code(either by the developer himself or changes to the code in the documentation) to be considered. &gt;Not compared to all the code which was written for Logbook, replicating already existing and widely used functionality ;-) It's like the "Knights who say NIH" ;-) Logbook's design varies greatly so we have to reimplement the handlers logging already has, however we already have more to offer than logging in that regard. Logging's problems when it comes to testing or let's say the problems with testing stuff in the stdlib may be of great concern for you as a developer of a library in the stdlib but as a user I don't care and these are the people we have to focus on. &gt; ISTM you're sharing a can of Kool-Aid with Armin - presumably sour grape flavour ;-) - but in my experience most people regard "batteries included" as a Good Thing. That very much depends on who you ask. Newbies prefer it because they have one central place where they can find almost everything they need and it is great if you start. However the more experienced you get the more frustrated you get with it. How many implementations of configuration systems are there using ini formatted files? Every WSGI library has implementations of nearly everything from datastructures found in the cgi module to functions for url parsing because the stdlib ones are unusable. Then there are modules which don't follow PEP 8 and have very bad design in general.
Can't argue with that :)
Umm...it's mentioned in OP's submission and [in the article](http://www.infoworld.com/d/developer-world/infoworld-review-nine-fine-python-development-tools-374?page=0,5#python_ide5) 
Oops, I'm as blind as I can be!
&gt; nevertheless that complicates things for developers You're overstating the case here, at least for this specific thing (QueueHandler). If you really needed it you would add it once in a utility module and have it available for all your projects from then on. It's tiny compared to the work of writing any (non-trivial) application or library. &gt; however we already have more to offer than logging in that regard [handlers] Sure, but it's relatively easy to create such handlers; the heavy lifting is done by libnotify, pyzmq or whatever. I'm not disparaging the work you've done on these handlers, and the convenience they represent, just pointing out that it's hardly rocket science. Of course, the handlers in the logging package were also (for the most part) straightforward to write. &gt; as a user I don't care and these are the people we have to focus on I'm just pointing out why the stdlib can't include handlers for everything under the sun. Nobody's saying you have to care, but in answer to a problem "I need to log to a ZeroMQ socket" (or whatever else) there are several approaches. Other equally valid approaches would be to write handlers made available on PyPI for these systems, based on stdlib logging (as others have done), or submit patches with such handlers for consideration (as others have done, and the handlers have been added to stdlib). Some people are good at collaborating (e.g. see [this post](http://x264dev.multimedia.cx/?p=185) which describes an instance of how collaboration should work), others prefer to fork or plough their own furrow because the idea of collaborating is anathema to them. Of course they collaborate with people who work with them on their own projects (as they are then In Charge) but they find it harder to work collaboratively where other people make some of the technical decisions. When I say "other people" I am excluding people who are friends or &gt; Newbies prefer it Perhaps, but it has value which is not only for newbies. The point is, things are standardised where it makes sense to do so and the benefits of doing this outweighs the benefits of multiple competing but incompatible implementations. &gt; How many implementations of configuration systems are there using ini formatted files? Not sure what you're point is, here. As far as I know, having ConfigParser in the stdlib has not harmed complementary or alternative systems such as ConfigObj, and people use whichever version they want to. Of course if you use three different third-party packages, say one uses ConfigObj for configuration and and one uses ConfigParser, and a third uses say cfgparse.py, then you have two additional dependencies to worry about. That's an argument for not having too many competing systems for a basic, infrastructure-level activity: working with text configuration files. &gt; Every WSGI library has implementations of nearly everything from datastructures found in the cgi module to functions for url parsing because the stdlib ones are unusable Yeah, but perhaps no-one really engaged with Python core to improve the stdlib version before developing their own versions. There are many WSGI platforms out there and Werkzeug is a very good one, but (say) WebOb and Django have solved many of the same problems, and effort has been duplicated, because collaboration is hard. &gt; Then there are modules which don't follow PEP 8 and have very bad design in general. Well, these things do happen. But if you look at a recent addition to stdlib - argparse - Steven Bethard tried really hard to extend and improve the existing module - optparse - but found that (a) the design had been too opinionated [by assuming, "you'll never need to do X"] and (b) the original maintainer of the package was not able or willing to work on it any more. Only after trying to "collaborate with upstream", and failing through no fault of his own, did he re-implement the functionality he thought was needed in argparse. The same situation does not apply to stdlib logging, which has an active maintainer who is willing to deal with feature requests and bug fixes in reasonable-to-good timeframes. Yet, despite much arm-waving and sniping about the design of the logging package, Armin has never proposed any concrete improvements because he has a "no point. It's broken by design" mentality towards a lot of software he (or someone else in Pocoo) didn't write. Whereas Georg, for example, made a request for a change to stdlib logging because it would help in one of his projects. I thought the change made sense and it is now implemented in stdlib. 
Is Boa Constructor still in development? I remember following the project for 2 full years. Buggy as hell and basically no updates. WingIDE: can't type strings or comments in Japanese, Chinese or Russian. I need that very often at work. Seriously? This happens to many IDEs. Komodo last time I tried as well. Komodo: huge memory consumption, core-dumped/froze occasionally (Windows, Mac and Linux versions) which is not acceptable for this kind of application. Sadly had to stop using it and I paid the full price. Eclipse + pydev was also buggy and slow last time I tried. Eclipse is too slow for my liking in any case. Right now I'm developing with Vim mainly, except when I need multilanguage support, in which case I use JEdit (infuriates me to no end with the auto-tabulation). Sometimes I run stuff in IDLE when I'm not in my computer. Sadly, I can say I've tried ALL of these editors and then some. Still very inconvenienced almost on a daily basis, having to open and close files under different editors. This is taboo but I will say it: I've been developing in Python for years and I still miss brackets VERY MUCH. Sometimes I just can't control which editor and configuration I'm using (ssh connection, limited Virtual machines, what have you, ...) and I have to move files around for minimal changes. I have a friend who's blind and cannot use some standard accessibility tools because of the lack of brackets. Make it a standard option FFS! an utility to convert to tabs and back, and everybody's happy.
Proposing to change the entire design of a library is in nearly every case pointless especially if you break backwards compatibility in major parts of the API which is even more so the case if said library is in the stdlib. Not to mention the fact that this forces you to carry a lot of baggage around, those are all things you don't have to worry about if you start from scratch. That doesn't mean we are not open to contribute to other projects or contributions by others, if you look at logbook's issue tracker you will see that every pull request which has been made so far has been accepted.
wow you need Japanese, Russian and Chinese support (in 1 file?) for your work, do tell!
Everyone here is going on about PyCharm so I went and tried it. What gives? Is it better on non-Mac platforms or something? It's horrendously un-native down to the dialogs and it's as slow as treacle. It took about 30 seconds of watching the typing lag behind my fingers for it to get trashed. I didn't even get to find out what features it had.
&gt; Proposing to change the entire design of a library is in nearly every case pointless I wasn't suggesting that. From previous discussions with Armin, it's pretty clear to me that he doesn't like logging's design for *aesthetic* reasons. IOW it's not that you can't do some particular thing X with logging, it's that he thinks it should be done completely differently. The reason I say that is that he has never said, "I need to do X, and I can't do that with logging the way it is at the moment" for any functional and specific X. If I use someone else's package and it seems like it doesn't do something I need, I first of all ask them how to do *that specific thing*. Instead, Armin will make some comment like "it has global state! That's bad! I can't use that!" which, ultimately, is an aesthetic judgement - after all, he's not so bothered by the shared state of sys.modules that he forgoes the use of Python altogether ;-) &gt; That doesn't mean we are not open to contribute to other projects or contributions by others Like I said, some people find it easy to collaborate with other people working on their own projects, but not so easy to collaborate with other people on the other people's project. Of course people are free to work on whatever they want to, but ISTM that the Logbook developers' time could be better spent on any number of other useful things if they want to help the Python and web development community in general. As I've said, I believe in having choice of multiple implementations for many things is good, but for infrastructure level things it's a disservice to the community to promote too much choice, especially using general comments about performance and thread-safety without any corroboration/substantiation. Imagine if in one country you had multiple implementations of electrical plugs and sockets :-(
&gt; it's as slow as treacle. I just tried it on Windows; it's quite slow there too, on both my netbook &amp; main development machine. I installed it because of all the laudatory praise, but I can't be bothered with something that is this slow.
The same phenomena occurs in natural languages. There is far more differences between natural languages than just vocabulary. There are certain constructs that are common in one language, yet are rarely used in another (and by extension, more difficult for those speaking the language to understand). Consider the subjunctive in Spanish versus english: english has a subjunctive tense, but it is rarely used by english speakers, and is difficult for them to understand. Higher order functions are used commonly in many functional languages, yet python programmers tend to avoid them and use other constructs (list comprehensions, etc). Naturally, they have to think a bit longer when they see one of these "rare" constructs in use. You're referring to what is formally known as semantics (if syntax is what a program looks like, semantics is what the program means). And you are correct, many languages are semantically very different on top of the obvious syntactic differences. The more programming languages you learn, the more semantic concepts you will be able to understand. 
Check recent Python-dev archives. IDLE had a massive thread dedicated to it and its future.
&gt;...never given the time, management just want... Programmers, just doing their best in a hopeless situation not of their making?
For those of us who work on Unicode and related projects, let alone the i18n/l10n industry, this kind of support is needed.
I had such high hopes for boa back in the day. It just came so close to doing so much. But it always seemed just a few bugs away from being viable for anything I was doing. At least on my system back then. 
http://docs.python.org/library/fileinput.html ctrl+f "Optional in-place filtering"
Yea, but that's not free... for people that only do python stuff now and then would it really be worth the $50? I'm using SPE right now, it's been pretty darn good imho. 
Works as expected for me: $ cat bar.txt abc def ghi $ python foo.py ab zz bar.txt This is printed to the command line... $ cat bar.txt zzc def ghi I suspect your code is different than what you posted. Also, for search/replace within text files, use `sed`. 
for WingIDE, just select another font, the default font can't handle Chinese, that's all.
I never even heard of it.....weird
No one still uses vim for python? What a pity!
This isn't a comparison. It is 9 separate blog entries on the editors.
I can only assume that this module is very old, because that smells like a total misfeature.
Well, to be fair, this was about IDEs; which vim is not. I think most everyone winds up falling back on vim/emacs/Notepad++ or the like when the IDEs come up short, and they almost always seem to do so where Python is concerned.
True. Following the Python philosophy, that should have been implemented as a separate method.
I'd never even heard about it until today, it really seems useless now that we have the "with" statement. The "in-place filtering" option is interesting but it's not like you couldn't implement it yourself in a few lines without giving up sys.stdout. To the OP: Your code is doing exactly what it's supposed to be doing :)
You said "analize" `*giggles*`
Right, I've always said that my development environment is BASH and my editor is vim. It's not an integrated environment I suppose, but it works quite well for me... (my dev environment is more or less tmux, bash, python, vim)
It looks quite good in the demo video. Is it really worth the $50/$100? And do you have to purchase it for Windows and Linux (and each machine) separately (that would be a deal breaker for me as I often work from different computers in either Win or Linux)? EDIT: Just tried the Linux trial (with Sun JRE) and it's atrocious. It feels incredibly non-native (like a Windows program, really), the font rendering is terribly aliased and the default bindings are not helping (my Alt key is a bit wonky). Plus, it has infinite trailing whitespace, so the arrow keys don't work as expected. Kate already comes with syntax highlighting and auto-indentation so the actual IDE features (i.e. integration, auto-complete and refactoring) are the main selling points but the look and feel is a real deal breaker for me. This is Eclipse all over again. Maybe I'd give it another go if I would do most of my coding on Windows machines, but on Linux this just feels all wrong.
ok, correcting ;-)
This isn't an answer to your question, but two things about your shebang line stood out to me: 1. You are using the full path to the python interpreter, which is not portable, so it is often recommended to use this instead: #!/usr/bin/env python 2. The space following the bang generally indicates that the author has been mislead by a somewhat common [myth](http://www.in-ulm.de/~mascheck/various/shebang/#blankrequired) that some systems require this.
Dynamic typing makes it harder for editors to help you edit it. Python's dynamic name resolution makes it even harder (Hey, even a "rename" operation is not safe).
I do my dev on linux, I work nearly exclusively with django. Yes the ui is a bit clunky and takes some getting used to. But for django dev atleast it has a ton of really really useful features. For example in a view, you can press a button in the side bar to view the associated template, this one feature has saved me scrolling up and down thousands of times with other editors. The autocompletion and auto module sensing (no idea what the real name is) is some of the best I've seen in a python ide. Type in a function, press alt+enter and it'll automatically add the import module to your code. But yes the infinite white space aggravates me too.
What about vim, Emacs? Not sure about vim, but with a bit of massaging, Emacs should be able to fill most of your requirements.
I thought about it (well, about vim -- for some reason emacs feels wrong), but I really prefer GUI-based editors and the benefits of switching from Kate seem really limited for those two (at least I'm not aware of any big ones).
Though I'm not a particular vim fan, I do indeed prefer a plain text editor, emacs in my case, for python programming. The IDEs are just too fat to bother with most of the time and python is simple enough to not require them. 
I agree about the auto-_anything_, but that doesn't outweigh the bad parts. Also, I prefer Pylons with Mako, so Django support isn't exactly a selling point.
vim is my one and everything
Exactly. I actually wonder if IDEs aren't just a form of automation that's only needed when the environment in question erects artificial barriers. It would be nice to get consistently working Intellisense-style type-ahead dialogues for example. But the only reason that's really necessary is because dynamic programming is sufficiently difficult under statically typed languages, that repetition is the way to go rather than elegance. Seriously, I think I'm on to something there. Every IDE style feature I can think of in Visual Studio for example, is an outgrowth of something which has simply gotten so repetitive or complicated, that a tool is needed to help mere mortals get work done. Another great example: Ever tried to put together a SOAP-based web service without an IDE? It sucks. With an IDE though, it's trivial. Hmm... maybe the fact that there is no "killer IDE" for Python should be taken more as an index of Python's overall elegance.
&gt; Make it a standard option FFS! an utility to convert to tabs and back, and everybody's happy. Actually, I agree. I really do like indentation better most of the time, but it would be killer to be able to set a bracket option on a given .py file (allowing it for the one file when it gets loaded) and possibly even at the process level (requiring it for all files that get loaded).
doesn't work for Japanese, will try with Chinese 
I agree, but it also does a certain subset of those things very well.
No geany?
Wait, there are people who use something else? What a pity!
Geany's wonderful for quick and little Python projects but I don't think you could call it an IDE. A step above Notepad++ but a step below other things. As for me, well, [MonoDevelop has a Python plugin](http://www.youtube.com/watch?v=vW-lNuoSNv0) so I'll try that...
&gt;Optional in-place filtering: if the keyword argument inplace=1 is passed to fileinput.input() or to the FileInput constructor, the file is moved to a backup file and standard output is directed to the input file (if a file of the same name as the backup file already exists, it will be replaced silently). This makes it possible to write a filter that rewrites its input file in place. If the backup parameter is given (typically as backup='.&lt;some extension&gt;'), it specifies the extension for the backup file, and the backup file remains around; by default, the extension is '.bak' and it is deleted when the output file is closed. In-place filtering is disabled when standard input is read. Ohhhhh, thank you!
It works fine, it's the fact that fileinput takes over sys.stdout.write(line) that was confusing me. See [here](http://docs.python.org/library/fileinput.html). I wish I could have used *sed* in this case, believe me. 
I'll keep this in mind, thanks. 
+1 I tried Pydev... but it just didn't compare to a good vim+virtualenv+git workflow
Oddly, I used Komodo, NetBeans, Eclipse, etc etc, and I love them, but I mysteriously find myself always editing in vim. What's more, I always exclaim "hell yes" when it doesn't try to play smart by inserting a second quote when I write one and botch the entire thing (yes, I know you can disable it). The tools are all great in theory, so I have no idea why I use vim more in practice.
I can post some screen shot for Chinese words if you needed. and I think CJK(Chinese, Japanese, and Korean) may follow the same rules. 
I don't doubt you. With MS Mincho or MS Gothic, quite standard Jap fonts, I only see squares on either Windows or Mac. I didn't have access to my Linux machine today. On Mac (X11 XQuartz) it doesn't even let me try. I need something consistent across platforms, and the closest thing I got is JEdit (which insists in pissing me off with stuff like auto-tab, and takes forever to launch).
I do. I'm working in computational linguistics.
*I* tried it on Windows machines earlier today, since I was on-site &amp; don't have a linux/bsd box with X. It took a long time to load, the look &amp; feel was weird, and and it took time to catch up with my typing constantly. 
emacs is most definitely an IDE.
sorry for my broken English and good lucky:) My Linux box can show Chinese correctly (with almost any Font). Windows Machine must select a Chinese Font(simhei, simeson, etc,) don't know MAC.
â€œAllow placement of caret after end of lineâ€ was the first thing I unchecked in preferences â€” surely you didn't just assume that that wasn't configurable? :) Look-and-feel is fine for me on Mac, haven't seen it on Linux (are Java apps still â€œugly by defaultâ€ on Linux? I recall having to tweak some JVM setting to get passable font rendering in Eclipse on Gentoo some years back, but it was OK after that). I say give it a second chance; I like the code analysis, debugger and test runner so much that I'd have to be doing some pretty worthless stuff for $50/$100 to be even remotely an issue. :)
See: http://www.doughellmann.com/PyMOTW/fileinput/ Also, reading the source may have answered your questions. 
I also came here to say something about Vim.
Well-said. 
Also a tiling window manager is considered part of my development environment.
This is a start, although, my main complaint with the standard library is that I have to go hunt down this little snippet for every script I write: logging.basicConfig( level=logging.DEBUG, format="%(asctime)s %(levelname)5.5s [%(module)s] %(message)s", datefmt="%Y-%m-%d %H:%M:%S %Z") I just want to pepper logging messages throughout my code to verify the control flow, notify users of events and to compute post run statistics. Sometimes, I will use optparse or argparse to set the logging level, but nothing more complicated than that. If I write a daemon, this still works, because I will just wrap this with supervisord or even upstart and collect stderr into a file. If he cuts out all the weird pushing and popping, this library will be great. However, I don't have a better idea of how to implement the handlers right now. - my 2 cents
You seem to have drawn the short straw with the project that you're working on . I'm not sure how anything you described is PHP programmer specific though, just poor programmer specific - I've seen bad code written in both languages. Your project sounds like a nightmare though... sad that poor programmers are given such free reign over projects that others will have to maintain.
Ian Bicking is working on this awesome project that allows Python developers to stop worrying about server architecture and just worry about building an app. It's was inspired by app engine, but doesn't force you to use an API. It currently support single nodes, but he's thinking about how to support rapid deployment of multiple app server nodes and database nodes. If you have the expertise, lend a hand!
Thanks for posting this. Learned a few things from the first issue. Looking forward to their next. 
It's not brackets, but pindent.py, which comes in the Python Tools subdirectory, allows you to program (or ship code) in a way that protects against whitespace munging. http://www.koders.com/python/fid66946EDA1E4704E4DE82C3385E16309B10C0C683.aspx?s=md5 
 logging.error() That is not thread safe unless you call basicConfig(). So the basicConfig line is not optional.
If you are referring to the fact that there was no locking in basicConfig(), that's been rectified at least in the Py3K branch. Or did you mean something else? My comment should perhaps have mentioned that the line was optional for very simple usage - it thought it was clear from the context that I was talking about the simplest case. The documentation certainly makes clear that logging.error etc. are convenience methods for simple scripts and casual usage. In general, logging configuration should be done before starting threads; as threads can log messages immediately when they start, if one doesn't do this, messages might be lost if one hasn't configured any handlers. And when configuring (before starting threads), you either call basicConfig() to configure or do it some other way - in which case you would never call basicConfig(). To cause unexpected behaviour of basicConfig(), you would have to call basicConfig() from multiple threads and, in a narrow window on non-GIL platforms (on versions without the locking in basicConfig), this could result in adding a handler twice to the root logger. However IIUC in the presence of the GIL this is more a theoretical problem than a practical one. If you think I have missed some other aspect of logging's thread-safety, which might affect the community in general, please do tell me what I've missed. In fact, if you have seen a thread-safety bug with logging, why not file a bug report? I'll investigate further and fix as soon as I can.
The [docs](http://docs.python.org/distutils/setupscript.html) seem reasonably clear; you may need to give more information about the problem you're having.
I completely disagree with you. In Python I often wish I could easily rename a variable that's being accessed from multiple places safely. Search&amp;Replace isn't safe. Manual work is repetitive. Languages that allow more static analysis are not less elegant in general (Though C# and Java may be), but they do allow editors to be more helpful, and that's a *good* thing.
Well, Eclipse's font rendering is okay. PyCharm OTOH is full of stars... err.. pixels. My main gripe is that it looks and feels like a bloated Windows app, which is completely out of place on Linux (even with Sun's JVM it felt sluggish and took _seconds_ to "initialize" the project). Good to know it's configurable, though. The only "killer features" it offers compared to my current solution (Kate + shell + dolphin) are the code analysis and refactoring. I do wonder, though, how it copes with remote filesystems via SSH.
it depends on if you want to do the animation yourself or not. check out nodebox, the aggdraw module and there are a few others.
either nodebox / python processing / pyQt / pyCairo 
Personally, for getting pixels on the screen with the minimal amount of fuss I find [PyGame](http://www.pygame.org/) to be quite handy. 
What about pygame?
pygame or [pyglet](http://www.pyglet.org/).
a very impressive newcomer: http://www.cityinabottle.org/nodebox/
I thought about this, but I didn't want to install too many things for a simple "block" class. I will have a gander 
cheers will do!
I will look into those if Pygame doesn't go my way :)
Too many things? Pygame is ONE thing.
The def statement defines a function, while the class statement defines a class of objects, which hold data and function that act on the data. You should learn about object-oriented programming for this to make more sense.
I second pyglet.
*def* makes functions. *class* makes classes. Don't bother creating new types unless you know you need OOP to keep things organized.
Well, maybe they don't **have** to get less elegant, but generally are because of sloppy design. I'm having trouble bringing to mind a single statically typed language that doesn't require the developer to have an IDE to be productive. Haskell maybe? Except I don't know anyone who's actually productive in that language. I hear your pain about difficulties in dealing with Python, but is that pain worse than the pain created by using a statically typed language? Here's another neat trick I wish I could perform in Python editors/IDEs which I haven't seen yet. Hover over a member in Visual Studio, then click 'Find All References". Good stuff. 
The built in [turtle](http://docs.python.org/library/turtle.html) module is the simplest graphics package available, but it may be too limiting for your needs. [PyGLet](http://www.pyglet.org/) is a lightweight, platform independent OpenGL wrapper that is quick to learn and use. It has built in support for sprites and animation which sounds more suitable for you.
Vpython is pretty simple. 
It seems like the *simplest* thing to do is to use NodeBox 1.9.4. The code-eval-debug cycle seems to be the shortest since an editor is built-in for you. It has a lot of cool plug-ins but uses its own internal copy of Python 2.5. I don't really understand NodeBox 2.0 beta. It is conceptually different, possibly even easier than coding directly. Could someone with experience with NodeBox, PyGame, and pyglet comment on the comparative strengths of all 3?
Hm. I guess I'll give it another shot, but I think I looked at it and had trouble seeing how to do multiple .py files. Second glance seems to be more complete....
How do go about installing it? I am not used to compiling things from source.. Edit: Using Ubuntu and found this [thread](http://ubuntuforums.org/archive/index.php/t-318411.html)
[Code Like a Pythonista: Idiomatic Python](http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html)
If your multiple files are individual modules, see the modules= keyword argument; for packages, see the packages= keyword argument.
Python is not Java, C++, Perl, Visual Basic, Ruby, etc.
Go through [CodingBat Python](http://codingbat.com/python). Great learning experience.
That one is a good read. I would also recommend: * [Intermediate and Advanced Software Carpentry in Python](http://ivory.idyll.org/articles/advanced-swc/) * [Python Best Practices](http://www.fantascienza.net/leonardo/ar/python_best_practices.html) I find it very helpful to read the other projects' code (especially of modules I use)--I end up picking up good ideas and approaches from them. 
Never heard of this site, thanks so much!
Not entirely what I was looking for, but thanks for the terse advice none the less.
Thanks for pointing me to a useful site :)! The code looks functional and ok. So the website does allow to import your own modules, right (since you're using BioPython)?
But I really would love intellisense within vim. I don't even care if it isn't perfect. Hell, I don't care if I have to type the class name, as long as I then get a listing of the methods I could call.
Well, for Python, I think there's a way to do this. Hmm.. here you go: http://blog.dispatched.ch/2009/05/24/vim-as-python-ide/ I haven't tried it, but it seems to be worth a spin.
I'm pretty sure he basically means if you're coming into the language as an experienced programmer, don't bring the ideas from those languages over to python. I've seen a lot of Python where you can tell the authors primary language was lisp because they have list comprehensions upon list comprehensions embedded with lambdas and all sorts of funky stuff.
Almost every tip I can think of can be boiled down to understanding what's in your Python's /lib directory. pdb, distutils, re, tkinter, pydoc, etc. are all pure gold. It's described as 'batteries included' for a reason. Understand what that means and you'll be much more effective.
You can use all kinds of clever introspection tricks that are a lot of fun to write. *Try not to.*
[How to think like a Pythonista](http://python.net/crew/mwh/hacks/objectthink.html)
Well, here's a specific pitfall to avoid: a common mistake people new to Python make is initializing default members with a list, i.e.: class Foo: def __init__(self, A=[]): self.A = A The list that A is initialized to is only instantiated once, so the list is actually shared between all instances of Foo. Instead, set the default to None and add: if A is None: A = [] [edit: formatting]
Off the top of my head: * learn and love ipython * zip(*a_2d_array) transposes an array * don't reinvent what's in the lib unless you need to * When you suspect there's a better way to do it in python, there probably is. Take the time to figure it out if you can.
[pip installs python](http://guide.python-distribute.org/installation.html). Get distribute and pip (see above link). With pip you can install packages and their dependencies from PyPI with a simple shell command. No manual downloading, extracting or compiling needed.
That's actually a fairly good advice. I would say that 80% of bad Python code I have seen is due to people trying to do things the same way as another language, only translating syntax. In general this should be an advice for anyone learning their second language - that the syntax difference is not the only difference, and in fact is the *least* important difference
That is pretty cool, I like the approach, but it seems if you know python, some of the solutions leave something to be desired
Or shorter and thus easier to read: A = A or [] Must be good style as it is used quite a bit in the Django source.
&gt;I've seen a lot of Python where you can tell the authors primary language was lisp because they have list comprehensions upon list comprehensions embedded with lambdas and all sorts of funky stuff. *Raises hand sheepishly*
Hm. OK....what about icons and the like? EDIT: Wait, is setup.py just for modules? This is a full application.... EDIT EDIT: Oh, scripts. Gotcha. Python terminology is t3h diff3r3nt. EDIT EDIT EDIT: Found icons, too. Thanks very much &gt;.&lt;
Don't forget about *args and **kwargs, they can be immensely helpful.
I got : NameError: name 'A' is not define
&gt; Haskell maybe? Except I don't know anyone who's actually productive in that language. I am :-) And plenty of people are.. See submissions to http://hackage.haskell.org/packages/archive/pkg-list.html &gt; I hear your pain about difficulties in dealing with Python, but is that pain worse than the pain created by using a statically typed language? Some things are fun in Python. In implicitly typed languages like Haskell, the static typing actually helps you and saves you from writing code, rather than standing in your way. All in all, I feel Haskell is less painful than Python for non-trivial programs. &gt; I wish I could perform in Python editors/IDEs which I haven't seen yet. The thing is I think this is *inherent*. Python just doesn't allow static analysis like this, and this won't change without getting rid of some of Python's dynamism. I really don't think that dynamism is very useful in practice too. When have you last used __getattr__ in a meaningful way (And not to work around some clunky attribute access syntax)?
Utility Mill looks like an amazing place, but if you wanted to do transcription between DNA and RNA, couldn't you just use the replace() method of the string object to replace 'A' with 'U'?
You need to set the default argument for A to None.
helpful when necessary, annoying when not..., sucks when you look at some source, wondering wtf some method takes, and you see: def foo(self, *args, **kwargs) fffffffuuuuuuuuu...now I gotta read your source, and If i find the *, ** bs unwarranted, I'll find you..
&gt; Or GCC's `-fsyntax-only'? Well that only says whether or not there was a syntax error. What I'm looking for is to answer "in this header, what are the types to a function called strerror", which I don't believe "-fsyntax-only" will give me. There is a tool called [gcc-xml](http://www.gccxml.org/HTML/Index.html) which accomplishes something similar.
I find A = A if A else list() to be more readable.
import this
Vim + Eclipse + Pydev...I use Vim for writing the code, and eclipse for debugging it. I tend to really like eclipse for debugging python. The only thing it misses is "Step backwards", but then there are no IDEs for python that support that feature, to my knowledge. Alternatively, you could get the python debugger for VIM...I just like eclipse for debugging, and I am used to it. I am used to VIM for writing the code, not debugging it. Right tool for the right job. Also, nice thing about learning eclipse is it works on all platforms exactly the same way, and it has plugins for almost every language (all major ones anyway).
If it's well-written code the docstring should explain everything. If it's poorly written then you'll just get screwed on something else.
big old list of stuff: default arguments are created at function creation, not at function invocation. strings are iterable, but return strings rather than characters. this means it is possible to infinitely* recurse through strings. if you want to tell the difference between a string and a list, use isinstance with BaseString (not str or unicode). this is really the only time to use isinstance. Avoid it like the plague never catch every exception, if you need to catch most of them, use StandardError and not Exception. Catching StopIteration, GeneratorExit, KeyboardInterrupt and SystemExit are bad, and using StandardError avoid this. (Also Using signals like control-c and threads can be a headache) follow pep8. some of the standard library is terrible, but some third party libraries come to the rescue. avoid using +=, use .append() when adding to lists. (stylistic) tuple packing/unpacking is awesome. zip(*zip(range(10),range(10))) is neat. avoid reduce and lambda. a while loop is a good idea. avoid exceptions for control flow where possible, prefer .get(key, default) over catching IndexError decorators are good. avoid type hierarchies, they are unnecessary for the most part. don't forget to use class Foo(object): and not class Foo: in python 2, new style classes are lovely. don't make classes for things, use built in tuples or lists where necessary. i.e. don't go making a class for a deck of cards when a list of tuples will suffice. it means you get to keep all the useful list methods and itertool functions, rather than having to re-expose them over and over again. understand descriptors and how staticmethod/classmethod/method binding works. it's neat *and* cool. timsort is lovely and worth looking up to see some of the care that has been poured lovingly into python. if you can, learn python 3. if you're making serious production software, python 2 is ok, but the unicode handling improvements amongst other things makes python 3 very attractive. things worth learning: enumerate() is your friend, as is the key argument to sort,sorted list comprehensions are nice, but generator comprehensions are awesome. in general: stop writing so much code. python is somewhere between functional, oo and procedural with a heavy emphasis on appropriate idioms for things. if something feels awkward, don't do it. elegance is worth it. good python is crisp, and somewhat declarative in nature. good python code is where it is obvious what is happening. seriously: if you're coming from java: stop making classes all the god damn fucking time. learn to love functions avoid threads. threading is terrible. slices are neat too: for example, if you need to iterate through an array in pairs, you can write a while loop with an explicit index, i, and use a[i] and a[i+1] or you can do for first,second in zip(array,array[1:]) try: import turtle and play around :D finally, python should be fun. don't get too bogged down in style or semantics. learning is a matter of patience and effort. pick small tasks you can finish in a weekend, and pick things that will be fun to play with and something you'll want to fiddle with and toy around with. (I find things with graphics and/or sound make for good experimentation) and get other people to look over your code. this is how you will pick up a lot of style and knowledge about python.
I know Eclipse from my Java days, but it's always been too bloated for my taste. Is PyDev less sluggish than the Java mode?
This thread on stackoverflow is full win: http://stackoverflow.com/questions/101268/hidden-features-of-python
I of course agree with that.
This is rad! Thanks a lot!
Cheers for taking the time to write this out, some great tips! Much appreciated!
&gt; this is really the only time to use isinstance. Avoid it like the plague I'm going to disagree with that. isinstance can be very useful. I was recently working with parsing simple Excel files. The nicest interface represents sheets as dicts of {(row, column): value}, with value being the corresponding Python type. That requires the client to use isinstance, but avoids any complex logic for telling the client a cell's type.
actually i'll give you that one but stick with the general 'avoid it like the plague sentiment'. I meant with the example to say: 'when you need to differentiate between a number of builtin types for specific actions', and I think yours is a case thereof. if you're using it on your own classes, then you could likely just add a number of methods and avoid instanceof (unless you need multiple dispatch I guess and don't fancy the double dispatch pattern) 
Great list. &gt;avoid threads. threading is terrible. Can you expand on this? If I'm going to be using multiple independent HTTP requests, I'll probably use several threads.
Awesome!
Beware! This is true for all referenced objects, not just lists! So, any class instances, dicts, etc will also be shared!
Threads are fine for IO bound programs, such as http requests, but for anything cpu bound it will dramatically impact the performance. The GIL giveth, but man does it also taketh.
The collections module is worth careful study (defaultdict is probably most useful), as is itertools, and operator. 
Actually, yes. I realized that after I coded it up. Oh well, it was good to try out something with BioPython. I feel like I'd need more Biology knowledge to do anything more complicated. I didn't understand most of the tutorial.
In addition to all of the standard library, it has about 20 3rd party Python libraries available (most of the popular ones should be there e.g, PIL, Numpy, etc). See http://utilitymill.com/help#imports For anything else I use this hackish technique: Say I found a Python module called Foo I want to use. I paste the source of Foo.py into the code text area. And if I want to call Foo.do_awesome(), I'm now calling just do_awsome() since Foo is no longer being imported. Obviously this get harder for multi-module libraries. But just email me and I'll usually add a new library within a couple days so you can then import it normally.
The thing I enjoy most about python is being able to experiment interactively. I find that's a very good way to understand some existing code and it is the best way to figure things out for a new problem. Just run `python` and start playing around in the interpreter. In addition to that, here are some more basics: Jump to the debugger from any place in your code: import pdb; pdb.set_trace(); Use the debugger when you need to step through some code or watch execution (type `?` for help). Start an interactive shell from any place in your code with all the current variables in scope: import code; code.interact(local=locals()); Use the `code.interact` shell when your code has run and done some set up, and you want to experiment with the result. I often just put this in the `if __name__ == "__main__"` part of a script. Use `dir()`, `help()`, `obj.__doc__`, and the `inspect` module on any object to learn more about the object. With those you can often avoid looking up documentation. If you like this experimental approach try these tools: [bpython](http://bpython-interpreter.org), [ipython](http://ipython.scipy.org/moin/), [reinteract](http://www.reinteract.org/trac/), [see](http://github.com/inky/see).
&gt; Must be good style as it is used quite a bit in the Django source. Oh boy. This is a *very* tenuous statement.
&gt; learn and love ipython Skip ipython. "Learn" (read "use") bpython. You'll thank them when you have to sit there debugging some stupid bug for whether it's an ipython bug or a code bug.
Eval / exec. Don't use it. Really. No don't.
Why does this require isinstance?
Wasn't to be taken very seriously.
I hoped as much :).
Do you think the source of Django lacks in quality or were you just pointing out that it is unimportant?
Yeah, one of the biggest embarassments looking back at my own early python code was that it was mostly rewrites of perl code - so there was lots of `if re.search("\.jpg", path)` that should have been `if path.endswith(".jpg")`. "Idioms matter"...
To be perfectly fair, I haven't sufficiently looked over the source to be conversant, I've just learned a bit of django over the last 2 or 3 months. Just as I was learning it though, the same nagging thought kept popping into my head at different times that it does some nasty nasty things that I can't imagine are implemented pythonically (to help myself sleep at night I just consider django to be its own language that happens to support python ;). Don't get me wrong though, I like django a lot actually, it's my first web framework, but it's probably a really bad place to go for stylistic tips. Or at least that's what I've heard around the water cooler.
I guess it depends on the context of using http requests: if it is a bunch of related http requests, really you want to use pipelining rather than threading to have multiple connections. I've personally had some success with pycurl, but you'll likely want to wrap it. But it is a great http library. if on the other hand it is a bunch of unrelated tasks, personally I prefer spawning off processes (they're cheap, and provide an easy way to avoid memory leaks/resource leaks). multiprocessing is a drop in replacement for thread in python, and I would advocate it. meanwhile, threading messes with signal handling, the locking isn't great (although i/o heavy threads work reasonably well) so: processes: cheap (on linux anyway), resource and memory cleanup is pretty easy, simple model to program for. threads: messes with signal handling, forced sequential execution (with i/o background tasks), and more effort to avoid resource leaks. use mutliprocessing 
edit: replied to wrong post! but yeah, don't be afraid to optimize for fun, do code review of your code and other peoples, and don't try to write large software from the outset. a friend of mine has been learning some python using projecteuler to spur things. it might be interesting for you, but you might have more interest in writing something using pygame or pyglet
for example: if you wanted to implement addition or multiplication with excel semantics rather than python semantics: i.e in this case, "aaa" * 4 is an error and "a" + "b" is an error. this is the case where the default data types don't have the semantics you want. your options are to wrap them, or write functions with explicit typechecks with a third party library, it is easier to sprinkle some isinstance code to shim things in.
* Get in the habit of sticking ```from __future__ import division``` at the top of your scripts (unless you use Python 3). * Skip all the other GUI toolkits and just use PyQt4/PySide. Most people seem to end up using it eventually. * Get 64 bit Windows binaries of popular packages from here: http://www.lfd.uci.edu/~gohlke/pythonlibs/. * Use the builtin ```logging``` package instead of ```print``` statements for debugging.
Sounds like a case for a parser to me.
Learn how to use pdb. 
I think we've all gone through a phase like that print "\n".join(x.rstrip() for x in (lambda y: y(y,3,3))\ (lambda x,n,w: ["%s/%s\\%s"%(" "*j, " "*(2*i)," "*j)\ for (i,j) in zip(xrange(0,w),xrange(w-1,0,-1))]+\ ["%s"%("-"*w*2)] if n == 0 else ["%s%s%s"%(" "*(w*2**\ (n-1)), l, " "*(w*2**(n-1))) for l in x(x,n-1,w)]+\ ["%s%s"%(l,l) for l in x(x,n-1,w)])) which, for the lazy, prints this: /\ / \ ------ /\ /\ / \ / \ ------------ /\ /\ / \ / \ ------ ------ /\ /\ /\ /\ / \ / \ / \ / \ ------------------------ /\ /\ / \ / \ ------ ------ /\ /\ /\ /\ / \ / \ / \ / \ ------------ ------------ /\ /\ /\ /\ / \ / \ / \ / \ ------ ------ ------ ------ /\ /\ /\ /\ /\ /\ /\ /\ / \ / \ / \ / \ / \ / \ / \ / \ ------------------------------------------------ bonus points, change the 3,3 to other numbers
don't try to write clever code
I like to keep a console open and use it to reference the api. very helpful : &gt;&gt;help(wx.Frame) etc.
Can you give some concrete examples? What kind of nasty things? I like Django a lot too, even though it should be much more customizable and has some other shortcomings, but alas.
Well, using nested subclasses for (meta) configuration is the first thing that comes to mind. That's something I'd probably get killed for suggesting in my own code.
I think this is really practical, and also pythonic. Why else would you be able to define classes in classes (and for that matter, methods/classes in methods)? Maybe the one who would kill you carries the mindset of a Java/C/whatever programmer.
Ah, makes a lot of sense when you put it that way. Multiprocessing feels more pythonic, and it's very much the "unix way" of doing things (letting a piece of the system designed to handle multiple concurrent tasks do it, rather than building it directly into your tool). Thanks.
`A = A if A is not None else []` is more precise and thus better in general IMO. And shorter is not always easier to read. That's just silly.
Sounds more like `A` wasn't in the parameter list. Whether or not it has a default value is irrelevant.
I think `list()` looks weird and isn't more readable than `[]`. Also, if you're going to recommend a general one-liner, I personally think this is preferable: `A = A if A is not None else []`
It's true for all *mutable* objects.
From what I've read, nested classes are useless in python. So the answer to "why you're able to" is simply because there's no reason to specifically disallow something; classes are objects after all. In any case, I'll have to go back over some django code to refresh my memory, there were quite a few other things that gave me the same feeling.
Not always, but in this case. I never liked the inline if statement, I think it is really clumsy syntax decision to not have the "if" in front like: A = if A is not None then A else [] 
Learn the python way of doing things. Don't theorize too much on design patterns concepts.
Python's got a something called The Python Standard Library, learn it, dont fucking reinvent!
Couldn't agree more. It may feel great now, but you pretty much *will* regret it. Don't be afraid of making your code more verbose.
Great list. I would like to add a caveat to this one though: &gt; or you can do for first,second in zip(array,array[1:]) This is convenient, but can consume a large amount of memory. Both zip() and array[1:] create new arrays, and zip() in particular will also create a tuple for each corresponding element in array. The caveat is: use this construct only for smaller arrays.
That works for me.
Seconding [bpython](http://bpython-interpreter.org/). Interactive rewind and saving is invaluable.
threads cause nasty, nasty errors- like, segfaulting python nasty. and async libs win most of the benchmarks I've seen- look at twisted or tornado.
to echo: import pdb;pdb.set_trace() is grrreat.
defaultdict is really nice!
Just want to give a +1 for QUIT MAKING CLASSES FOR EVERY DAMN THING 
What do you mean by a parser?
I've looked at quite a bit of Django code. I don't think it lacks in quality, but it does some *extremely magical* things that your average code should try to avoid. They are a framework, and the API is more important than the nuts and bolts. A lot of that magic makes things really easy for the end-user, but it's pretty nasty under the hood IMO. Also, it has a fair amount of contributors and from what I can tell, is not very strict on style, so it's a bit inconsistent. But that is true for the Python stdlib as well; so it goes. 
This makes a new list if you pass it an empty one. I try to avoid the "must be one line!" mentality myself and go with: if A is None: A = [] 
There are some reasons to dislike threads on principle, but some very specific ones to dislike them when using CPython. It is implemented really bad. [Mindblowing Python GIL](http://blip.tv/file/2232410) is worth the watch to understand the challenges and pitfalls of threading in Python. multiprocessing is a fantastic replacement, but it does have limitations if you want to share a lot of memory, since you have to emulate that with message passing. 
fix the lower 'a' (make it an 'A') and you get an upvote.
The Django declarative model definition is a DSL, not Python. If one devises an useful and comprehensive DSL for a specific domain, one also gets to re-define Python syntax sugar to better fit the DSL. The Meta classes are read and turned into Options classes when the declarative model is evaluated. The Meta class is nothing more but a container of values that allows arbitrary syntax inside its definition. Dict literals only allow expressions.
&gt; shorter and thus easier to read: here's the shortest code for a wiki: http://c2.com/cgi/wiki?SigWik &lt;s&gt;Really short and easy to read. &lt;/s&gt; I hope you understand how wrong that statement was. In other news - using "A = A or []" has a bug because certain objects can evaluate as false. http://stackoverflow.com/questions/1452489/evaluation-of-boolean-expressions-in-python
What in god's name is this? What would this be in Perl? my a; Or something similar?
[pyx](http://pyx.sourceforge.net/) is a good python (la)tex integration module; it's especially suited for graph generation but can work with text just as well. for example, [it's very easy](http://pyx.sourceforge.net/examples/text/marker.html) to execute latex source code and insert markers whose positions will be reported back.
What about WingIDE, It's my favorite Python IDE. It lacks:1) code completion on demand, but it's code completion automatically makes me happy. 2)Refactoring, at least I don't know how to do this by WingIDE. 
This. I absolutely hate using ORMs in Python, because whenever something breaks (and it inevitably will), then I always gotta get deep into the spaghetti magic land to fix it.
Nice stuff. This can be really useful when debugging code you're not familiar with.
&gt; In other news - using "A = A or []" has a bug because certain objects can evaluate as false. It doesn't have a bug because you expect None (default value) or a list as input.
Well, Python devs usually integrate features only if they see good reason for it, hence the very long discussions about each PEP. Also, they are not useless. For example just recently I had this in a method: def mymethod(): class Failed(Exception): pass try: # raise Failed('error message') anywhere expect Failed: # handle error message I think here it is a good solution, and defining the Failed class outside of the method when it is only used temporarily just for the sake of it seems wrong. Edit: why specifically do you think that the nested settings class in Django's models is a bad idea? I think it is a neat way to separate model settings and your own model code.
I like this version, but I am a little on the fence: I usually prefer what is easier to read, and one line, if it is not more complicated than it's alternative, is easier to read.
WingIDE looks pretty good (Linux look and feel, responsive, code highlighting for other formats than Python). I'm sold if it allows you to rename variables in scope (e.g. all occurrences of arguments or properties) -- I couldn't figure out how to do that yet. The price tag is a bit hefty, though. USD 295 for a dual OS license? I hope it lets me install the Windows version on a USB stick.
Use izip and islice for large lists.
The argument would be that if I pass in a different object that acts like a list, the program shouldn't replace my empty list with a list of its own if my custom list-like object is "empty" too. However, in this case, it's a bit over-constructed -- the "evaluates as false" issue is bigger for other types, but probably less-so for default lists.
I just started on a new app. argparse gives me pretty much what i need for a good command line UI. * subcommands (svn style: prog subcommand opts) * mutually exclusive option groups * fine grained control option prefix etc. So I just though I should share :-)
Way to go! * Easy use * Positional arguments * Easy to port existing code from previous standard libraries which did the same thing
I found it to be useable. You could give it a try, Eclipse does integrate better with the Gnome look and feel now.
If you do check on Emacs, start here: http://github.com/gabrielelanaro/emacs-for-python .
(Java programmer here) I had to use python to get extensions the other day. It seems like there was a better library. Maybe os.utils? (On phone; can't check) 
Great module. It's available for 2.6 as a standalone module (even packaged in Debian, if that's what floats your boat).
It should be easier to write it in python.
I much prefer ipython to bpython, but that would be a fine choice as well.
wrong link: http://docs.python.org/library/argparse.html
Just so you know, it's been an independent module long before it got into the stdlib. You can get it for previous versions quite trivially.
Yup! And you might be interested in this too - http://micheles.googlecode.com/hg/plac/doc/plac.html "Technically plac is just a simple wrapper over argparse which hides most of its complexity by using a declarative interface: the argument parser is inferred rather than written down by imperatively. Still, plac is surprisingly scalable upwards, even without using the underlying argparse. I have been using Python for 8 years and in my experience it is extremely unlikely that you will ever need to go beyond the features provided by the declarative interface of plac: they should be more than enough for 99.9% of the use cases."
I recently stumbled upon this: http://infinitemonkeycorps.net/docs/pph/ After coding Python in a full time job for over a year now I thought that I should have started with this link right from the beginning. Its a goldmine of important links and best practices!
 à² à²  à²  à²  ------ à² à²  à² à²  à²  à²  à²  à²  ------------ à² à²  à² à²  à²  à²  à²  à²  ------ ------ à² à²  à² à²  à² à²  à² à²  à²  à²  à²  à²  à²  à²  à²  à²  ------------------------ à² à²  à² à²  à²  à²  à²  à²  ------ ------ à² à²  à² à²  à² à²  à² à²  à²  à²  à²  à²  à²  à²  à²  à²  ------------ ------------ à² à²  à² à²  à² à²  à² à²  à²  à²  à²  à²  à²  à²  à²  à²  ------ ------ ------ ------ 
itertools to the rescue: izip and islice.
i have been researching web2py myself, as a first programming language to learn. PHP just does not seem logical enough for me to grasp it. seems to scale l, as it seems that Amazon is also using it http://blackent.careers.adicio.com/careers/jobsearch/detail?jobId=28547335&amp;viewType=main&amp;networkView=main
Specifically, on Ubuntu 10.04, for example, it's # apt-get install python-argparse
I think I'll definately be looking into it for my next project then. I've been doing PHP for years and have wanted to do python for web dev, but it doesn't seem as intuitive as php...which I think web2py addresses.
&gt; The GIL giveth, but man does it also taketh. The GIL does not really taketh. It more takes your CPU bound applications round the back of the bike sheds and rapeth them. :-(
&gt; For any programming language it is better to hire a smart person who doesn't know the language over a stupid person who knows the language. You should never hire stupid people. And I completely agree about your comment when it comes to systems like e.g. Pylon. But it takes a long time to get reasonably good at a language - months at least....
I agree with nearly every complaint you say - but if you only need numbers from 1 to 15, a table of Roman numerals is a better idea than writing a general program, because you can do it in one minute and don't even have to test it - and I'd say that's true even if you're anticipating twice as many numbers. 
Same here. I'm using it for all my libraries now. It is loads better than optparse :)
Scrapy looks pretty over designed, but I guess it depends how complex your scraping is. lxml can parse html (even the crappy tag soup you find out there) and let's you pretend it's xml, so you can run xpaths with regexs over it. curl is probably the best you're going to get for fetching data from the web, it's does the job pretty well. I'd reccomend you make sure you're using Python 3 for the unicode support. I'd reccomend playing with these things in a script before using scrapy, given that it's at version 0.10 you are probably going to have to fix it as you use it, so knowing what the low level stuff does will matter.
One bit is a rather small space in which to store a question...
Mechanize + Beautifulsoup
I believe os.path.splitext is what you need.
pyquery ! http://makeyjl.blogspot.com/2010/01/pyquery-jquery-like-library-for-python.html
I'm out and can't look it up but we have sonmething that actually gets the extension for you. Then when you get it this way you have access to other stuff. Like I said...I'm a noob but there's a better way to get this that doesn't involve splicing or splitting.
I love [lxml.html](http://codespeak.net/lxml/lxmlhtml.html), which, besides being fast, comes with the [lxml.cssselect](http://codespeak.net/lxml/dev/cssselect.html) module. (And Mechanize.)
That's the combo I use, too. Pretty awesome.
Geany might be worth taking a look at. It doesn't fulfill all of your requirements (like refactoring), but it's very usable (and has on-demand auto completion).
Unless you're creating a web spider Scrapy is not the way to go. Mechanize is much better for simple scraping.
Thx all!
Mechanize + lxml
some guys talk smart in this thread http://www.reddit.com/r/programming/comments/d5e4p/what_do_you_think_about_learning_web2py_as_a/
Having used Mechanize, i can attest that it is gorgeous.
I use Mechanize in both Perl and Ruby forms. Its a wonderful piece of software. BeautifulSoup is also completely fantastic. Even using urllib to grab the pages has worked reasonably well for me.
Have used BS a bit. Lately http://code.google.com/p/html5lib/ hit the shelf, and has since become my weapon of choice.
lxml is by far the best way to do it.
we *already* have a tree structure. a parser is for creating one from a stream. we have a problem of providing a function foo that works differently for each of the built in types, we can't add methods to the classes. we can't wrap them easily unless the library supports it, so we are forced to use isinstance to get type dispatch. 
BeautifulSoup is a joy to write code with. You feel like you can do anything in **just one line.** But man is it a pain to administer. It leaks memory at a phenomenal rate. (I've got several BS based applications. The most visible of them is the bugbot in #archlinux-bugs.) Each BS app uses 10% of the ram in my Slice. And that was after applying all the known leak-containment tricks. Great for quickly whipping up a one shot scraper. Not so good for services.
I agree that there are 2 bugs: 1. An empty list is replaced by a new one. 2. A list-like object that evaluates to false (using \_\_bool\_\_ or \_\_nonzero\_\_) will give the same wrong results. Here's code that shows the 1st bug in python 2.6: def append_one(A=None): A = A or [] A.append(1) def append_one_works(A=None): if A is None: A = [] A.append(1) x = [] append_one(x) print 'omg this should not be an empty list:', x append_one_works(x) print 'and now this is better:', x and the second bug: def append_one(A=None): A = A or [] A.append(1) class Strange(list): def __nonzero__(self): return False x = Strange([1,2,3]) append_one(x) print 'x was untouched because it was a strange list:', x 
I wrote xpdb a while back: http://bazaar.launchpad.net/~eyal-lotem%2Blaunchpad/xpdb/main/download/head%3A/pdb.py-20080831114746-n6gugpnbynznhu0d-1/xpdb.py It's a pdb fork that fixes a bunch of annoyances (things like "s=5" killing your post-mortem) and bugs (inability to "up" through generators in post-mortem). It also adds some features (Ability to "ignore" files or functions, so when you step through your code you don't have to step through each and every library function). 
httplib2 + lxml
Wow. That's discouraging. I'm using it in a new server project. If it leaks memory that bad I'll have to rewrite my scraping code to use a different lib. 
A warning to anyone wanting to use BeautifulSoup: It's no longer being actively developed and can choke on some slightly bad markup. Use html5lib with BeautifulSoup as the format as shown in their [documentation.](http://code.google.com/p/html5lib/wiki/UserDocumentation)
That's amazing. Having never used it, I could see that being useful with Python 3's annotations for help strings in the generated help.
Do we really need command line tools? I had worked for a company where we wrote network applications on Linux. Most colleagues put all the configurations into a ini file. None of them have ever considered adding command line options to control the behavior of the program.
Yes, we do need them. Configuration files are good for something that needs to be configured once or rarely, but that isn't always the case. Sometimes an application needs to do different things based on criteria that can only really be understood by the human operator. For example, it's easier to add --verbose to get some debugging information than it is to locate, open, and edit a config file, only to open and edit it again once you're done debugging.
Shameless self-plug, but here is some information on how to get vim up and running as an amazing python IDE: http://sontek.net/Python-with-a-modular-IDE-\(Vim\) and http://github.com/sontek/dotfiles/
i think the big problem for people who are looking for the perfect IDE with Python is they are used to languages like C, C#, or Java that have header files, class per file, and complicated compiling procedures that really need an IDE to help you. Python is so simple and easy to manage that you really can just manage it with an editor without the need for an IDE to give you any behind the scenes magic. Vim gives you every point you outlined.
Capitalization issue? Could also be some weirdness about backslashes in the paths, if the server runs Windows.
Sounds somewhat like a space-in-path issue. I'm installing 2.7 on this system now and will poke around a little. Will update if I come up with something. Cheers,
the spidering part you should write yourself, it's pretty fun and not a ton of code, imho beautifulsoup is the "best" for pulling data out of html, but if you are scraping stuff in the wild, it'll choke on all sorts of stuff like: &lt;a href=""foo"&gt; or a lot of people do shit in javascript functions like: '&lt;a href="fo' + 'o"&gt;' So, though I'm pretty diehard python, I would seriously consider using node.js and jquery !!
is HTML5Lib any better than BS on memory use?
Linux server. The initial state is grabbed from listdir. I had it spit out the results and the dorectory names were correct.
You might be right. I forgot that Linux wants you to whack spaces when using *cd*. Though it would be rather odd if Python didn't handle this.
Replying to myself. Here's what I did. I made a directory on the C:\ drive named Reddit and filled it with some directories... C:\reddit C:\reddit\dir two C:\reddit\dir two\another Caps Spaces Directory C:\reddit\dir two\subdir2 C:\reddit\dir1 C:\reddit\dir1\Caps Name Spaces Directory C:\reddit\dir1\subdir one Next, I wrote the following script to os.walk() through the directory, pull a list of stuff together, then pass that to os.chdir()... for root, path, files in os.walk('C:\\reddit'): print "os.chdir() will now change to --&gt; ", root os.chdir(root) print "os.chdir now thinks that it is in --&gt; ", os.getcwd() It seemed to return everything OK for me on this end: os.chdir() will now change to --&gt; C:\reddit os.chdir now thinks that it is in --&gt; C:\reddit os.chdir() will now change to --&gt; C:\reddit\dir two os.chdir now thinks that it is in --&gt; C:\reddit\dir two os.chdir() will now change to --&gt; C:\reddit\dir two\another Caps Spaces Directory os.chdir now thinks that it is in --&gt; C:\reddit\dir two\another Caps Spaces Directory (etc...) I can't find an issue with os.chdir, but I may have read your original post wrong. Think it would be possible to post a snippit of what you're code does so that someone brighter than I can take a look? ;)
Keep in mind BeautifulSoup is no longer developed. If you are doing XML/HTML parsing, even the BeautifulSoup developers agree you should be using XPath with lxml. BeautifulSoup is really only good for fixing broken XML.
Protip: if you're using the value of an XML element (like &lt;foo&gt;bar&lt;/foo&gt;, and you're trying to extract "bar"), use foo.string.strip() instead of plain old foo.string Because the .string property is a "NavigableString", which means it contains the entire parse tree, not just the string itself. This should help you with your memory problems. I used to write scraping scripts all the time for work.
Hmmm, this could be very useful. Thanks! I might have to retrain a bunch of people at work on how to use html5lib after learning it myself. We have a whole team of people who scrape sites using BeautifulSoup now.
Mechanize! It makes life with a cludgy CMS both worthwhile and possible.
I find this to be a great tool: http://zesty.ca/scrape/
In python 2.7 on windows7 (don't wanna reboot to test nix for you) chdir fails with unicode, walk handles it fine. &gt;&gt;&gt; import os &gt;&gt;&gt; os.chdir(r'c:\code\htdocs\Â¢Â¢Â¢') Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; WindowsError: [Error 2] The system cannot find the file specified: 'c:\\code\\htdocs\\\x9b\x9b\x9b' &gt;&gt;&gt; os.walk(r'c:\code\htdocs\Â¢Â¢Â¢') &lt;generator object walk at 0x01773AF8&gt; edit: stackoverflow also has a good method of limiting how deep os.walk will go: http://stackoverflow.com/questions/229186/os-walk-without-digging-into-directories-below/234329#234329
Or use the python-oriented methods of `easy_install` or `pip install`
I seldom need to debug any python program. Unit test should make sure it works in most cases. And adding 1 or 2 lines of log often could conceal the problem when it doesn't work as expected.
I've used BeautifulSoup for a bunch of one-off scrapes. Really good for taking a document, finding the parts that you want, and mutating them.
I wrote/tested the script on OS X and ran it on a Linux machine.
Can't agree more
Absolutely. I've found it to be better on every dimension I looked at in head-to-head comparisons with BeautifulSoup.
I've developed several things with scrapy and I like it quite a lot. If you're just scraping one page, you are probably better off with mechanize et al, but I find scrapy easiest for things that follow links and scrape that content. It's pretty easy once you get used to it. I've used for it three or four scrapers now.
If you want to use Emacs with python, you may find this blog post useful: http://pedrokroger.net/blog/2010/07/configuring-emacs-as-a-python-ide-2/
I did this to automate a process in a 10 year old (ish) monstrosity of ASP that passes for a ticket system or something. The easiest solution may generally be to threaten the provider with a golf club until they give you something machine-readable but they aren't always handy.
i had to do javabats (what codingbat was called before they renamed to codingbat because they added python support) for school, and they really do help for learning a language, i would recommend them to anyone. It provides instant feedback and kinda reinforces the important of unit testing as well for basic stuff.
I've just been going through these recently to help me pick up Python. Anything else similar to this?
Also: Mutable objects for _class attributes_ are a PITA! By all means, for mutable objects use _instance attributes_.
But it has a completely different meaning: if not A: A = [] also sets A to [] if it already is a list, but empty. Whereas, if A is None: A = [] only sets A to [] if it is None.
I'm doing a lot of web scraping for work, and we use http://scrapy.org/ It's based on Twisted and it's awesome.
I've been using pyquery and eventlet - both of which are excellent.
Pycharm has been ticking all my boxes so far - it's hands down the best python IDE I've used.
Are the directories symbolic links?
Nope.
http://learnpythonthehardway.org/
The last time I did a scraping project I rocked BeautifulSoup but I heard from some [friends](http://mobify.me/) who actually do this for a living that lxml is the tits. Soup was really simple just to hack together some code that worked but I'm not sure if I would be stoked to be using it over the long term.
Do all the dirs have the execute bit set? 
Stupid question most likely, but you're either 1) using absolute path to the chdir, or 2) chdir'ing back out of the node you were in, correct? If you want to run it down, intercept the exception and output os.getcwd() when it occurs...
1. No 2. Yes (well, was, prior to fix), but not until a directory was finished
For owner, yes. Although now that I think of it, I feel like a goddamn moron for having not noticed it before: the script was running as nobody. Sigh. Sometimes, even after 10 years, we all wonder how to do not-greater-than. So to speak.
I can get them all but the "brick" question. I'm fully self-taught, so I don't feel *too* bad, but dang! Can some people post their solutions to it?
Instead of asking for the interface, you would try to compile it with the known interfaces. It's not like your program is going to be able to use `strerror` correctly if it's interface is int strerror(int,const double*,double*); But for me, portability is so essential that special-casing for any small number of vendors is pretty much a waste of time.
I solved it, it's tricky, but I figured it out. Posting code would be spoilers, but I'll give you a hint that you can solve the problem using the modulo operator (`%`), integer division and one or two `if`-statements. I was working on the [Lucky Sum problem](http://codingbat.com/prob/p107863), which is of course rather easy to solve with just three `if`-statements, but then I got thinking if I could do it in one line. Preferably something elegant of course, not just translating the `if`s to ternary operators :-) So I came up with this: def lucky_sum(*v): return sum(iter(iter(v).next, 13)) Using the (kinda obscure) "sentinel" variant of the `iter` function, it works when I type it into my own Python interpreter, but the website gives me `Error:'iter' is not defined`, is the Python that gets compiled on the website a neutered version or something? Makes sense cause running arbitrary Python code sounds like security problems waiting to happen, though I don't understand why blocking `iter` would secure anything. I can't find anything in the site's help/FAQ either. In fact, it doesn't even say what version of Python it's running. Maybe that could be it? Some older version of Python doesn't have the `iter` function?
*addition:* a bit of playing around shows me that the Python version must be **2.6**: it supports `str.format` (at least 2.6) but doesn't support `dict.viewkeys` (so it's not 2.7).
 def make_bricks(small, big, goal): if(goal%5 == 0): if(goal/5 &lt;= big): return True else: if(goal-(5*big) &lt;= small): return True else: return False else: if(goal/5 &lt; big): if(goal - ( 5 * (goal/5) ) &lt;= small): return True else: return False else: if(goal-(5*big) &lt;= small): return True else: return False 
Here's my version: def make_bricks(small, big, goal): bigs = min(goal / 5, big) rem = goal - (5 * bigs) smalls = min(rem, small) return smalls + 5 * bigs == goal *edit*: removed superfluous "if big:...else: big = 0" from around line 1 (as min(0, ...) = 0)
I went with a recursive solution: def make_bricks(small, big, goal): if goal == 0: return True elif big and goal &gt;= 5: return make_bricks(small, big-1, goal-5) elif small: return make_bricks(small-1, big, goal-1) else: return False
Some of the provided solutions are pretty stupid: def array123(nums): # Note: iterate with length-2, so can use i+1 and i+2 in the loop for i in range(len(nums)-2): if nums[i]==1 and nums[i+1]==2 and nums[i+2]==3: return True return False err, no: def array123(nums): return (1,2,3) in zip(nums, nums[1:], nums[2:]) 
I was pointing more at the unicode bit than the windows bit... I just wanted you to know my environment. Did you test with unicode?
http://www.pyschools.com
 def make_bricks(small, big, goal): big = min(big, goal // 5) return 5 * big + small &gt;= goal
It also doesn't support generators - I get an error saying "Yield statements are not allowed". I also got an error when I tried to create an auxiliary function starting with \_. It said variables starting with \_ aren't allowed, weirdly. Neat site, but unfortunately with enough restrictions (particularly in key areas like iter and generators) you end up teaching a language superficially similar to (but definitely not) Python.
Yes, some of the solutions seem to avoid idiomatic python. For example, def count_hi(str): sum = 0 ## Loop to length-1 and access index i and i+1 ## in the loop. for i in range(len(str)-1): if str[i:i+2] == 'hi': sum = sum + 1 return sum would be much better expressed as: def count_hi(str): return str.count("hi")
urllib, urllib2 (superior to mechanize if you need tricky behaviors, cookies, proxies, etc) And BeautifulSoup for HTML parsing. Works fine.
Unfortunately I can't say. As I've used both mostly to deal with smallish HTML fragments I didn't run into memory problems and wasn't aware there were any. Sorry. I quickly googled the topic and found that indeed, BS [seems to behave erratic][1] when low on memory. If by any chance you find out more, could you keep me updated please? I'd be interested in this as well. I have a scraping pet-project in mind but unfortunately I currently have no time to start working on it yet. [1]: http://taylanpince.com/blog/posts/beautiful-soup-and-memory-issues/
Problem Return the number of even ints in the given array. Their solution: def count_evens(nums): count = 0 for num in nums: if num % 2 == 0: count = count + 1 return count My solution: def count_evens(nums): return len([x for x in nums if x%2==0]) List comprehensions. Fuck Yeah!
If you are starting out new with Python, you should know that nobody cares that you are new and starting out with Python and no one cares what framework you are using, and if you ask what framework you should be using, all you will get is just a biased opinion on the best framework.
No, but there isn't any unicode in any of the directory names.
Awhile ago I wrote something to grab imgages from /r/pics if it were a direct image link or imgur page link. It works as is and I've grabbed at least a gig of images I believe (what a way to notice all the reposts) but I never got around to finishing the options to keep digging down the pages until running out of next links or the ability to set a time for to (ie every x hours). I wanted to do that before releasing it but I think the timed re-checking option may be unnecessary. So maybe I'll chuck it on bitbucket later today. Anyway, I just used beautifulsoup to grab things by certain classes, download them and then generate thumbs with PIL, zip everything up and ftp it to my home server. Those options are something most people don't want and I should make them optional. But really, it's pretty easy for anyone to replicate it. You just need to take a bit of time to learn beautifulsoup for parsing the html, imo. I'm also using it in a link crawler which will just rip links from pages, chuck them in a db and then revisit every so often keeping stats on whether it fail to contact the link and some other stats. I plan on releasing that too but I'd like to convert it to using postgres rather than mysql and maybe a separate little gui app to view the db data in some basic useful forms.
you can't replace properly quoted CSV with null-terminated records unless you know exactly what data you're working with. anyways, good article.
def make_bricks(small, big, goal): return goal - min(goal//5, big)*5 &lt;= small
If I ever have a kid, I'm gonna call him or her Postgre.
| `lineterminator = struct.pack('B', 0)` That's a fairly verbose way to say `chr(0)`. 
Looks cool - and I may actually use it in production when it has import support. :)
Can't wait!
+1
So... I'm assuming this is something Heroku-like. Is there any actual description though? It's only the barest of descriptions at the moment.
[This post](http://groups.google.com/group/beautifulsoup/browse_thread/thread/b58b38a158ee0754) (see the reply from the author of BS) suggests that it's still alive and well, just not *actively* developed at the moment. 
Showing off the code along with all the software versions would turn a simple guessing into a scientific guessing. 
Webdriver, selectorgadget and lxml. I like webdriver because it provides a well-designed, standard API for several browsers, and it appears to be well supported and unlikely to be abandoned since it is part of Selenium project (a big project) and actively developed by Google. Additionally, I used to use mechanize: it's simple and straightforward. However, it doesn't have a robust javascript engine, and might have issues with SSL. Simply stated, it's not a complete webbrowser like firefox, chrome, IE, webkit or whatever else you might think of. Webdriver is meant to control the aforementioned modern browsers. So, I know that using webdriver I will always be able to scrape any webpage that can be accessed using firefox. I've had issues with mechanize in the past because a page had javascript or encryption (I forget which) which mechanize couldn't handle. I figure it's best practice to use the more robust, more capable framework which I know can handle whatever I throw at it: webdriver. If someone wants to write a mechanize backend for webdriver so that I can take advantage of inmemory, easy headless browsing when possible that'd be great. But, I personally wouldn't use mechanize as a general tool for screen scraping because of the aforementioned reasons. Selectorgadget makes screenscraping an absolute breeze. Try it, you will be stunned.
 def string_times(str, n): result = "" for i in range(n): # range(n) is [0, 1, 2, .... n-1] result = result + str # could use += here return result ... def str_times(str,n): return str*n 
v3.0.8.1 of BeautifulSoup was released April 9, 2010. 
The code is nothing like what I described in my post. It was an earlier version that I'm asking about. I'm not sure what there is to show, though. blah = os.listdir('.') for dir in blah: if not os.path.isdir(dir): continue os.chdir(dir) That's what it was doing. chdir() worked on three out of 364 directories. All the directories had the same permissions, owner, and group at the time.
I also had weird errors using reduce for list-2, even if the same code would work quite nicely in IDLE.
[ob-xkcd](http://www.xkcd.com/37/)
Good luck!
hmm, ass-python *\*creates another new web framework, calls it ass-python\**
Yep, we're basically aiming for "Heroku for Python". There's some more info at the discussions on [Hacker News](http://news.ycombinator.com/item?id=1686418) and [Forrst](http://forr.st/~XTn) (if you have a Forrst account).
Maybe I'm being too much of a geek, but I think they should have named it Scrapy 0.A Seems like a step back to go from 0.9 to 0.10
So is this a stable ponies live in. Or stable, as in Solid Like a Rock?
Does it have to be one or the other?
No. In fact "goes both ways" is my personal motto.
I'm guessing it has something to do with how output is buffered. &lt;strike&gt;Maybe try adding a `sys.stdout.flush()` in there somewhere.&lt;/strike&gt;
You're basically switching it from a mode where it flushes output on every newline (the default when stdout is a tty) to a mode where it only flushes when the output buffer is full.
Looking forward to it. Do you have any deadlines? October? November? (talking about the beta release here)
emacs is not an IDE it's just a very complete text editor.
For my fellow language nerds, [Slava Pestov's article on escape analysis in Factor](http://factor-language.blogspot.com/2008/08/algorithm-for-escape-analysis.html).
Hopefully we'll be looking for beta users within a few weeks. As for the official launch: we have no idea. It will depend on the beta users and what they tell us they need.
You missed a chance to call it Taliban.
OMG, this is yet another thing we ended up redoing in Python because we didn't bother trying to find an acceptable existing alternative.
Yes. [This explains how](http://web2py.com/book/default/chapter/12#How-to-Distribute-your-Applications-as-Binaries). The license allows it explicitly as long as you bundle with it an official web2py binary and you state that clearly in the license of your product. Your app (bundled with web2py) can be closed source. If you modify the web2py source and then make a new binary, you have to release your modifications according to the GPL2 license.
Ahh fantastic! Thank you.
SQLite was practically made for this type of situation
Actually the GPL license prevents that as far as I know. You would have to GPL the whole project.
I am not very familiar with SQLite, but let me tell you a couple reasons against it: 1) it has been very difficult to migrate from excel, access and even conventional MySQL db to SQLite. 2) Performance has been a terrible issue from my recent attempts in using it (I am working with a 300000 rows, 10 columns file). Given that SQLite is my best option, can anyone point me towards a good migration tool, and provide me some tips for increased performance? Thanks. I losing all my hair over this.
Sorry for the tone. Let me clarify. * You really should ask this specific question from people who intimately understand the GPL license; I am only going on what I have heard and read about the GPL. * mdipierro is the main? developer of web2py ... and the link is on the web2py page ... that is all true. However, you can't change the GPL license rules; it means the same thing to everyone. So even, if the web2py page says one thing, the GPL license may say another. * Technically, mdipierro can make up licensing rules he wants. All web2py code is owned by him and he can change the license at any time. However, web2py specifically says it is GPL, which has certain rules even he cannot change (unless he decides on a different license).
The GPL prevents. The web2py license no because it includes an exception to GPL. Here it is in a nutshell: web2py source is covered by GPL2. This extends to derivative frameworks but not to web2py applications since they are executed by the framework not linked (as long as you do not include in your app source from the framework but why would you). web2py binary (as provided by us) are the subject of the exception which says that in practice they are dual licensed as freeware. So if you bundle your app (which is not a derivative of the framework since it is only executed by it) with a web2py binary (freeware), there is no piece in the loop which is subject to the GPL. Anyway. If I say he can do, he can do it. ;-)
It still has occasional bug updates, but it's no longer being "actively" developed. He goes into detail [on this site.](http://www.crummy.com/software/BeautifulSoup/3.1-problems.html) &gt; To summarize, Beautiful Soup is a hobby that I don't really enjoy and that's similar to the work I do all day. It's competing against other hobbies and committments I have, hobbies and committments that are more enjoyable and significantly different from my day job. So when I say you can do some of the work yourself, I'm not being snarky. That's a legitimate option for getting this code written faster.
So, you make a special copy that is non-GPL that he can use? Yeah, that would work. &gt; Anyway. If I say he can do, he can do it. ;-) Yeah, I noted as such in my reply -- which you probably missed while typing your reply. :) As the only copyright holder you can pick any license or conditions you want. (The only thing that would cause a problem is if you called it GPL and then the actual license had different conditions... which I thought was the case until you mentioned the non-GPL binary.) TLDR: Yes, zurtri, you can do what the instructions say at that link without any worries from anyone; there's no GPL problems here.
Your tone is fine and you are correct about 1,2,3. I am not changing the GPL license. I am just saying hat web2py is dual-licensed: source is GPL, binaries are freeware. This is stated in a slightly more verbose language in [the license](http://web2py.com/book/default/chapter/01#License). The web2py license always included what we call "Commercial Exception" since 2007. Anyway, anybody who is not sure and needs legal protection can ask me for a signed statement and I will provide that by email or fax.
we both type fast... LOL
Was going to write my own. I currently have used the following libraries: * PyTidyLib to cleanup the html; lxml chokes on some pages, so I ran the page through this first - http://countergram.com/open-source/pytidylib * lxml to parse it and extract data (using xpath) - http://codespeak.net/lxml/ When I say, I was planning to write my own... I meant an automated crawler and data extraction system with certain features.
Glad it resolved out well. Sorry, for the attitude/tone I took. I'm a little surprised the solution came out so quickly. :)
Hang on a sec; you have a single table with 10 columns and 300,000 rows? Thats it? Why are you using SQL? Why are you not just using BerkelyDB?
&gt; I will provide that by email or fax. You are a complete legend. Kudos.
ahn.. because.. i .. am ... a complete noob? I kind of assumed mysql to be the best way to deal with this. The statistical softwares we use on the lab are easy to connect to mysql, besides I have a little familiarity with SQL. I really need to study more about all of this. I have never worked with large databases of any sort. Just guide me to the literature to get me started.....
http://docs.python.org/library/persistence.html ^ Read all of that.
&gt; I am working with a 300000 rows, 10 columns file [Redis](http://code.google.com/p/redis/) would be a pretty good option. It's one of those No-SQL Key-Value store things, but if you want something fast and light, you can't do much better, especially since you don't have any relational data anyways. [This client library](http://github.com/andymccurdy/redis-py/) is pretty solid, for the Python side of it. And if you need a Windows build, [there's one maintained by the ServiceStack guys](http://code.google.com/p/servicestack/wiki/RedisWindowsDownload).
Unlike others, pyglet is a pure Python package (no compiled modules).
1. Take a look [here](http://docs.python.org/library/profile.html) or do a google search on python profiling. Sqlite should not have a dramatic performance cost vs Mysql, profiling the application is a good way of seeing exactly where things get expensive, time wise. 2. [Here](http://www.sqlite.org/cvstrac/wiki?p=ConverterTools) are a list of conversion tools for mysql -&gt; sqlite. 3. Good luck! 
The Python here is very unidiomatic. Having done JavaBat for a class, I can say it really feels like the solutions are pretty much translated versions. That's fine, if you just want to learn syntax and not idioms or the stdlib -- which I think is the point of CodingBat. By the way, the guy who created this (and JavaBat) is [Nick Parlante](http://www-cs-faculty.stanford.edu/%7enick/), a professor at Stanford who apparently also developed the materials for [Google's Python Class](http://code.google.com/edu/languages/google-python-class/index.html). Other texts of his (e.g., an intro on pointers in C I read) are really fairly good. Maybe his specialty is just pedagogy and not Python proper. Not that that's a bad thing -- just something to think about when winding up criticisms.
try inserting all 300,000 rows using one transaction; http://www.sqlite.org/faq.html#q19 
does web2py support py2exe?
[Introduction to Polymodel](http://code.google.com/appengine/docs/python/datastore/polymodelclass.html)
Even if he's got objects, he could pickle the data structures and store them in Redis. The main issue he has pointed out is portability in a single file, how does Redis solve this?
Why are people even considering using web2py...
[Flask](http://flask.pocoo.org/).
I use web2py for a big project but it lacks some crucial features (I am mainly a Rails dev). The main missing features are: environment settings, proper testing, big ecosystem (plugins are not so easy and tested as in Django or Rails). But it has also some nice advantages as built in authentication, authorization (although it forces some url and views but you can always customize). It has intregrated hg support and editor (not so useful but a nice addition). 
I use it because it is well done, complete with a friendly, helpful community. the real question is *why are you trolling so early in the morning ?* 
He's the author of Flask, the only worthwhile python micro-framework. It's a legitimate question, why the hell would you use web2py?
&gt; I use it because it is well done In what sense? There are so many things so incredible broken by design in that framework that I just cannot overlook things. I am not claiming that any other framework has a perfect design, far from it, but web2py leads the bad design decisions competition. The fact that it uses eval internally for execution its modules and controllers breaks so many assumptions that it makes the code hard to understand. For example if you declare the current time in web2py for a table default you do "default=datetime.utcnow()" at table definition time. That breaks any kind of deferred execution because the time would then be off. In combination with the fact that web2py tries to stay backwards compatible it means there is no room for performance optimizations at all. If you would ever deploy a really large application on web2py you would get so terrible burned in the process, that you might even want to consider ditching Python because of the bad experience you made. But Python can do so much better than that. For me web2py is to Python what PHP is to dynamic languages. Setting a real bad example. &gt; complete with a friendly, helpful community. That might be true. &gt; the real question is why are you trolling so early in the morning ?
Because it has a lot of very nice features and a very small code base without a bunch of external dependencies. And because you can develop an application very easily and very quickly.
I first read the headline as the problem being that people could easily identify good apps, etc and Django trying to "fix" that
&gt; For example if you declare the current time in web2py for a table default you do "default=datetime.utcnow()" at table definition time. You are kidding me. Seriously, WTF ?
Yes, it could be understanded that way. I've just got this title from official djangopackages website.
Given a real choice, I'd go with Flask. Given a choice between Django and web2py, I'd go with Django, no question.While I disagree with some design decisions in Django, it's written by people who know Python and know what they are doing. It has a proven track-record of large-scale deployments and a large community. If you are new to Python, Django is a good place to start; there is plenty of open source code for you to learn from. As for web2py ? 1) non-PEP8 code. Seriously, learn [PEP8](http://www.python.org/dev/peps/pep-0008/). 2) magic imports and use of eval(). This makes your code hard to understand and debug. It also encourages bad practice. 3) Lack of documentation, outside of a single book. 4) Lack of big success stories and large-scale deployments. OK, neither does Flask; but Flask has only been around a few months. Given the time web2py has been around, where are the big web2py sites ? 5) Through the web editing of Python code. This is such a bad idea I cannot begin to tell you how bad it is. We tried it once with Zope, and it was a clusterfuck; Zope devs dropped it as soon as they could. 6) It's not just mitsuhiko; none of the top Python developers have anything good to say about web2py. Enthusiasts tend to be Python newbies who like web2py more than Django cause they get to type less. That should tell you something. If you like the "magic" of web2py then you will probably be happier learning Rails; it's better documented, has the community and success stories, and will get you going faster. If you like Python because it tries to eschew magic in the cause of maintainability, then go with Django, Flask/Werkzeug or Pylons.
&gt; go with Django, Flask/Werkzeug or Pylons. This.
[CherryPy](http://www.cherrypy.org).
&gt; 1) non-PEP8 code. Seriously, learn PEP8. I agree. &gt; 2) magic imports and use of eval(). This makes your code hard to understand and debug. It also encourages bad practice. you can consider it a trade-off betweeb simplicity, fragility/reliability and speed. I don't like it much but it is not a absurd decision. &gt; 3) Lack of documentation, outside of a single book. Since the release of the book, I didn't find any lack. The community is also very helpful. &gt; 4) Lack of big success stories and large-scale deployments. OK, neither does Flask; but Flask has only been around a few months. Given the time web2py has been around, where are the big web2py sites ? An absence of proof is not the proof of absence. But you have a point. That's a valid question but which proves nothing. Some big site may use web2py and not say it. &gt; 5) Through the web editing of Python code. This is such a bad idea I cannot begin to tell you how bad it is. We tried it once with Zope, and it was a clusterfuck; Zope devs dropped it as soon as they could. You can ignore this feature, no ? &gt; 6) It's not just mitsuhiko; none of the top Python developers have anything good to say about web2py. Enthusiasts tend to be Python newbies who like web2py more than Django cause they get to type less. That should tell you something. I had the impression that web2py founder is not liked but I never read a bad comment about web2py from a top python dev. Beside I am more interested in what people have to say, that what they are. Thank you for detailing why you don't like web2py, that's more interesting than the blind bashing. 
Points 1), 2) and 5) are features an experienced Python developer will ignore or work around. However, we are talking about someone new to Python. It's in everyone's interest that newbies learn best practices first. You have to know the rules, and why they exist, before you can bend or break them. Just because you can ignore through-the-web editing (to give one example) does not mean newbies will; they will consider it a cool feature, and shoot themselves in the foot because of it. Better that newbies learn to use source control and put their Python code in files, so others don't suffer from their mistakes. 
I don't get this... I'm not experienced with stuff like that but very interested as I have to create objects and move them to a DB in my app. And my (maybe naive) way to do it would be like this. How else would you do this?
7 upvotes and no discussion? Would like to know more.
The way Django or SQLAlchemy do it. Make it a callable called when an instance is created. In SQLAlchemy for example: date_created = Column(DateTime, default=datetime.utcnow) 
op, the creator of web2py goes under the handle mdipierro or something around here. and reddit is known for its passionate hate toward web2py. don't bother asking their opinion on web2py. look elsewhere. as far as i'm concerned, i would go with django, because of the community, the resources, the books, the conferences, the groups, etc.
flask, the decorators abuser...
ah i came to make sure this is the most upboated.
Care to elaborate ?
Still, thank you for posting the link, this is definitely one for my bookmarks :)
I use Bottle [http://bottle.paws.de/] Same concept I guess, do the bare minimum and then get the hell out of my way. 
Nice one!
I see this thread has been hijacked by Flask. Flask is a good micro framework but it is not as complete in terms of features as Django or web2py. Let me dispute your points one by one: 1) About pep8: http://web2py.com/book/default/chapter/01#Elements-of-Style also consider that [Google does not follow Pep8](http://google-styleguide.googlecode.com/svn/trunk/pyguide.html) 2) You call them "magic import" I call the the main distintion between web2py and all the other Python frameworks. Python follows "explicit is better then implicit" and this results in very verbose code (see Django) while web2py wants to be more like Rails and follow DRY. In web2py everything has a default behavior (which can the over overridden). We think of this as one of its main features. Example. In Django you have define routes for every app, in web2py every controller action has a default route. In web2py every model has a default web based administrative interface, and every controller function has a generic view. 3) The book is free online (537 pages): http://web2py.com/book 4) http://tenthrow.com http://eden.sahanafoundation.org/ (there is more but consider that web2py is 4 years younger the Django. Where was Django 4years ago?) 5) web2py has a file structure very similar to Django's one and you do not have to use the web based IDE if you do not want to. It is optional: http://gluonframework.wordpress.com/ 6) I am not responding to this because it is not my custom to put my words in other people's mouth. It is true that "Python newbies ... like web2py more than Django cause they get to type less". That is the point. ;-) 
You are missing the point. First of all mitsuhiko made up this example, it is not in the book, we do "default=request.now". Anyway... playing along. It is not that "default=datetime.utcnow()" is executed once and therefore the time is that of table definition. The code "default=datetime.utcnow()" would still be executed at every http request and therefore the default is always the time of the current request. In all the other Python frameworks there is one place where tables are defined (executed once) and then there are actions (executed when requests arrive). In web2py models (table definitions) are run at every request. This has minimal overhead but allows us to do all kind of things that you cannot do in other frameworks: real time automatic migrations, request dependent databases and table, specify field default without having to define callback functions. 
one word to rule them all : GAE
If your point is that users should go with the system that has the most documentation than users should be using J2EE, ASP and PHP. Without making any web2py specific comment, I tend to go with the software that requires the minimal amount of documentation (assuming documentation is available anyway).
I've done mostly scripting in python, love the language, just not familiar with which frameworks do what and django and web2py are the two that I read about... somewhere. 
web2py does not link apps, it executes them. web2py binaries are built with py2exe. If you modify web2py you can run py2exe (we include a setup_win.py script for py2exe) and get a new framework but you cannot distribute that because of the GPL license. If you just want to bytecode compile your apps, bundle with the framework (binary or source) and distribute that, you do not need py2exe.
this site should have SimpleBackend for registration
Neat, this seems like a skeleton framework similar to Pylons/Flask/Bottle that others mentioned? 
web2py is backward compatible since 2007 and it is our mission not to break user's code. web2py is more concerned about needs of users of the framework than needs of developers and make choices accordingly, in particular we spend lot of time to add features and make them easy to use. web2py supports migrations, web2py has a (optional) web based IDE. web2py has built-in ticketing system. web2py has a database abstraction layer that works with Google App Engine out of the box and supports features like ListProperty and Polymodel (without you having to learn the GAE API). Flask has been mentioned. If you need something really barebone Flask is excellent and it is faster than web2py and Django (not easier) but once you get to more complex apps you benefit from a full stack framework like web2py or Django. For example, the web2py web based IDE (admin) has a one click "pack" applications and one click "install" a packed application. If you really need a micro framework, than Bottle is the best. It is the only contained in one single python file.
You can basically mix and match stuff you need. Pull in Mako for templating and SQLAlchemy if you need an ORM and you're done. (Or, of course, whatever you think is best. It's like Pylons in the power it gives you - talking of which, check out Pylons too). It's pretty damn easy to use. Although so far I've only been using it to write web-based GUIs for some small personal projects, you can run it under Apache if you need to scale. Disclaimer: I don't know what I'm talking about.
Looking over Flask and Pylons now... thanks for mentioning some more things for me to look at :)
At this point Flask is great for quick prototypes. Once you start using sub-modules it gets a little squirrelly. Plus they need to work on the template loader. I don't to be forced to have my templates with my code. Other than that it's an excellent mini-framework (It's to big to be micro IMHO)
Oh now that looks neat too... 
Redis is disk-backed and you can tell it when you want it to save (it also saves automatically, depending on how you setup the conf). When you want to move it, you save, shut down the Redis server and grab the data file. As long as the conf is pointing at that file, Redis will read in all of the values when it starts up again.
Second vote for bottle, as in "I used it and it was good". I haven't tried Flask yet, although I read about it and it does look good (and very similar to bottle). I'm using Flask for my next simple project (generate a PDF from some URL values).
Someone mentioned you are the web2py dev - just wanted to say kudos to your project and thanks for the reply :)
"Students: A new module for tabular data w/ excel+json+yaml+csv support" If you say so :)
&gt; First of all mitsuhiko made up this example, it is not in the book I took that from the very first documentation you had. It was just using date.today instead of datetime.utcnow.
Thanks. You may want to watch these video: [new web2py features](http://vimeo.com/13485916) and [Django polls tutorial in web2py](http://vimeo.com/6507384) 
&gt; Plus they need to work on the template loader. I don't to be forced to have my templates with my code. The Jinja2 dependency will stay because that way extensions can depend on one templating system being present. Nobody forces you to use templates though if you don't want them. Pylons has a default dependency on mako as well which I doubt anyone wants to rip out, even if one wants to use Jinja2.
The pushing and popping is not weird at all, you usually use the handlers as contextmanagers instead of pushing and popping them on the stack yourself.
Reddit uses pylons, any words about that?
lol... with reddit going down every week or so I'm not sure about that ;) I kid! I kid! 
&gt; web2py tries to stay backwards compatible it means there is no room for performance optimizations at all 1) web2py does not tries. It stays backward compatible. 2) It is called top-down design: we keep the user API fixed, optimize under the hood. we do this over and over, and web2py got faster over time. Anyway speed is not our major concern. In most apps the database is the bottle neck. We are concerned with making web development easy, instead.
Could be. Anyway, as I said, there is nothing wrong with it form a logical point of view, "default=request.now" is faster.
&gt; You call them "magic import" I call the the main distintion between web2py and all the other Python frameworks. Python follows "explicit is better then implicit" You do realize Django used to have implicit imports and specifically decided to drop them because they were a pain right? &gt; and this results in very verbose code (see Django) No. Imports do not result in "very verbose code", unless you build java-style paths and only import the toplevel without aliasing. &gt; In web2py everything has a default behavior (which can the over overridden). We think of this as one of its main features. Example. In Django you have define routes for every app, in web2py every controller action has a default route. That has nothing to do with imports. &gt; In web2py every model has a default web based administrative interface, and every controller function has a generic view. That still has nothing to do with imports.
What Flask needs really are some larger use cases - in particular using modules. It's a bit of a chicken and egg situation - people need to use the framework more to find the pain points and push it forward. I'd still use Django for certain cases - the Django admin for example is a big win and difficult to replicate in more open-ended frameworks - and Flask for projects requiring a bit more customization, or where I wouldn't need most of Django anyway (such as an API service). Best tool for the job, as always.
The company I work for uses Tornado which communicates with the front end using JSON. For that purpose, Tornado is wonderful because nothing gets in my (I'm on the Tornado side) way; it's all very pure Python, and I understand the event-driven architecture very well at this point (though that is the aspect that will actually cause us some trouble). I haven't really felt that anything we've used is botched. I don't really know what else I could need... I just want some of the libraries we use, a web stack, and the Python language. :) They started on Pylons way before I started working there and switched to Tornado. I don't know if they ever looked at Django.
I used "very verbose" in a relative sense (relative to web2py). Not in absolute sense. The Django code is very clean. Anyway, I apologize of that sounded offensive. I did not know Django had implicit imports therefore I do not know how it was done but now I understand better some of the criticism. The fact it did not work well in the Django design does not mean they do not work well in the web2py design.
&gt; "Python newbies ... like web2py more than Django cause they get to type less". That is the point. ;-) and the cause of much pain. Having explicit imports, and the cost of a few minutes of typing, means that I now have a module that's much easier to read and maintain. Where does this function come from ? It's at the top of the file, in the imports, unless it's a standard Python builtin. That one line of code, "verbose" as it may be, may save hours of frustration. In terms of teaching a newbie - once they learn how Python imports work, then they can apply what they have learned consistently. No "if it's in this folder or that folder it will be imported automatically". It just works. EDIT: you are wondering why the hostility to web2py. I can't speak for others, but it seems that web2py is repeating the mistakes of the past and yet being pushed as a Good Thing for new developers to learn. In the past we had Zope, a very "magical" framework, with acquisition and through-the-web coding and other such goodies. All great ideas, and very convenient at first, but over time made for an unmaintainable nightmare. People who understood Python very well just could not get Zope because of this magic. Django made this mistake again with implicit imports, before the "magic removal" phase, at which everyone rejoiced (and, to be fair, so did Zope 3). Yet web2py is making that mistake again.
I had been using PyDev, and I would have continued suggesting it. I like Eclipse; I find it to be responsive, well integrated with Windows and Linux desktops, and powerful (maybe overly so). However, the latest PyDev has autocompletion forced upon you. After using it for about five minutes, I found it completely unusable. If you get near the end of a line and what you're typing looks like something PyDev thinks you want, hitting Enter autocompletes rather than entering a new line. A new line is what I want about 99.9% of the time. Apparently, this "feature" can't be disabled, and the docs suggest pressing Ctrl-Enter to get a new line. So now PyDev is worthless with the exception of debugging and source control. I've switched to [Scite](http://www.scintilla.org/SciTE.html) and a command prompt. I haven't found another Python IDE I like.
This is a philosophical difference, not a technical one. Where does "def" comes from? Why do I need to know where it is defined? All you need to know to use it is that it is the part of the Python language. In web2py we expose a few extra keywords (objects). The list is small and [they are documented](http://www.web2py.com/book/default/chapter/04#API) Rails does the same. In Rails controllers you do use objects that are not Ruby keywords nor they are imported explicitly. A framework does not need to be a library of Python modules.
You seem to imply that web2py's web-based IDE does not put "Python code in files" -- you are incorrect. All web2py code is in fact stored in files on the filesystem, just like Django or any other framework. The web2py IDE simply operates on those files through a browser interface -- otherwise, it works like any desktop IDE (albeit not as feature-packed). Newbies will not be side-stepping any best practices by using the web2py web-based IDE.
I'm now working helping to migrate the whole web environment of three important Brazilian companies to web2py (Moving some modules from Java, .Net, PHP, Django and Pylons to web2py) Government companies are using web2py (including the prefecture of a big city in Brazil, and the government of a great state here ) The second largest Brazilian state-company is adopting web2py for internal applications And I am coaching teams from other companies. So, Why they even considering using web2py? - They have good Python developers - They love and trust in Python language And because web2py is the best for their needs. - Rapid development - Easy learning - Fast delivery of functional products - Easy integration with legacy products through Py libraries and webservices (all made easy) - Receptivity to change at any time - The best template system that makes lives of designers and information architects much easier - Ultimately: Return On Investment (ROI: that is what really matters ) - Much more points to list here.... While that question consider only technical issues, the real stakeholders are also concerned about issues of business values. That's also a point why I chose web2py as main web platform for my company and personal projects. I and my clients Like to focus more on the product idea than in architecture issues (for the later we trust in web2py core developers, and the rapid evolution of this framework which is a good reality!) I'd like to thank Massimo and all people in web2py staff. (Which I have contributed in some ways, but certainly I intend to contribute even more) Do not feed the trolls! At Last: "one word to rule them all : GAE" Web2py runs very well on GAE \o/ 
&gt; All you need to know to use it is that it is the part of the Python language Exactly. Learn Python, that's all you should need. Anything else, learn the API. &gt; Rails does the same. In Rails controllers you do use objects that are not Ruby keywords nor they are imported explicitly. That doesn't mean it's a good thing. &gt; A framework does not need to be a library of Python modules. Why not ? Again, it's a set of APIs to learn.
Here... http://www.sqlite.org/cvstrac/wiki?p=SqliteCompetitors
I use Flask for fun and mini-projects, and django for anything decently sized (I've also recently been getting into Pylons a bit here and there). Flask is great as a micro-framework, but I'm already pretty invested in django. I have a great library of apps (third-party and self-written) that I've customized to all play nicely with each other, so throwing together a new project that includes registration, social networking, blogging, a wiki, comments, shopping cart, voting, tagging, and on-site search takes literally under 60 seconds. A few more minutes of playing with permissions/admin and the client has a full CMS at their fingertips. I just cannot get that with any other framework that I know of today. Django's don't repeat yourself philosophy from the ground-up with any code that you write on top of it is just so invaluable to me. Most of the time the only things I have to work on for a new project are the front-end and any very specific apps that only pertain to that site. That's not to say other frameworks are just as capable at being as plug-and-play as django apps, but they either simply aren't or I haven't spent enough time working with them. In addition, if I eventually settled down and were to exclusively work on a single site for a living I might opt for something a tad more flexible than django (hence my recent interest in Pylons).
&gt; All web2py code is in fact stored in files on the filesystem So I can actually write to files on the server through the browser ? Amazing. Can I do, like, os.system calls too ?
&gt; That has nothing to do with imports. &gt; That still has nothing to do with imports. Note, he was not addressing only the issue of "magic import" but the more general conflict between "explicit is better than implicit" and DRY (don't repeat yourself). The examples he cites show some places web2py has made the tradeoff in favor of DRY (where Django has opted for "explicit is better than implicit"). web2py has some nice defaults so you can avoid repeating yourself. But they can all be overridden. And if you really want everything explicit (even at the expense of DRY), you can do so -- it's just not always necessary.
What about Twisted?
Regarding the http://eden.sahanafoundation.org/ example, check out the [Sahana Eden demo](http://test.eden.sahanafoundation.org/eden/) (which is the actual Sahana Eden application built with web2py) and their [Why web2py? FAQ](http://eden.sahanafoundation.org/wiki/FrequentlyAskedQuestionsWeb2Py). Also, check out http://radbox.me/.
I've been programming in python since 2002. I've checked out all of the frameworks listed except for Flask &amp; Bottle. In my final analysis, it was web2py vs. Django. I chose web2py because, from a user's perspective, it is semantically more consistent than Django and misses nothing in terms of completeness. I'm doing a lot of heavy-duty db, mixed media, and other stuff with web2py over the last 2+ years and I have yet to want. My web development productivity has soared over my previous productivity and getting better all the time as I get more proficient. I keep accurate account of where my time is spent, and I already thought of myself as very productive. With web2py I joke to people that I am like Spiderman and have super web powers! I have reliable data that shows that I can do in 3 months what 3 guys can do in 18 months with php or Ruby. The two commercial web2py sites that I have built have *never* ever ever failed for any reason once deployed. My clients never called me to fix my code. Not even once. My code is much easier for me to understand when I come back to it after a long absence. The documentation is now excellent, online, and free after three major revisions by Massimo and others. From the start I never used through-the-web editing with web2py except to try it - I go direct. Programming in web2py is a joy. And so is working with Massimo and the web2py community. I have no worries about where we're going. Having worked with top-top-notch people at a prestigious R&amp;D lab during a long stint in my career, I can say confidently that Massimo is a top technical guru and academic of high integrity. I've spoken with other people who will say the same. Like anything else that is a work in progress, web2py needs improvement in places. But none of them have been critical or show stoppers to me or others that I know. Performance, reliability and security have all been good. I don't consider anything in web2py to be "magic". There is nothing wrong with eval in templating and other aspects of web2py. It's all quite logically organized under the hood and gives the python/web2py user huge leverage in terms of developing powerful, feature-rich, robust, scalable, extensible websites. On top of that, it's just soooooo much fun to use :-) And when I've gotten stuck on something, the web2py community has been quick to respond with answers. I like that a lot! The web2py conference is coming. All in due time seÃ±ores. In the meantime, I for one, have a backlog of websites I'm drooling to get my hands on with web2py. A number of web2py detractors here seem to be blowing smoke for reasons unknown to me. I can say, as a satisfied user, I would rather fight than switch. web2py is for me.
Well I guess it totally depends on what your purpose is. If the purpose is to learn web development, the low level http stuff, building up a framework right from scratch and learning python along the way, then flask, werkzeug is the way to go.(flask has very good documentation too) On the other hand if the agenda is not to waste time, be more productive, and have a functional site, with extremely good support from the community and good docs,and extremely good and easy portability without any hassles of deployment be it GAE or anything else, then web2py is the way to go. (yeah I love flask but web2py makes me 1000 times more productive..!).. and yeah ask yourself a question--&gt; would you use Ubuntu or Arch Linux.. if you like Ubuntu .. use web2py and if it is arch linux .. use pylons !
Where does Zope fit in to the discussion?
hey Bruno estÃ¡s-me a citar :) hey Bruno you're quoting me :) Btw nice article on that brazilian mag about web2py.
Thank you for the link! Thanks to it that I found the tool that I used for migrating the db.
&gt; Having explicit imports, and the cost of a few minutes of typing, means that I now have a module that's much easier to read and maintain. Where does this function come from ? It's at the top of the file, in the imports, unless it's a standard Python builtin. That one line of code, "verbose" as it may be, may save hours of frustration. While this is a valid issue, it really does not apply to web2py. web2py simply does not have a large body of mysterious hidden tricks working magically behind the scenes. It automatically executes files in the controllers folder (just the controller for the current request) and the models folder -- that's only 2 places, easy enough to remember (if you don't want something automatically executed, then put it in the modules folder and import it explicitly). It also exposes a relatively small number of extra objects, which are well documented and also easy to remember (most are simply validators or HTML helpers with the same names as the corresponding HTML tags). That's it -- no big mysteries or hours spent in frustration. Of course, if you really feel the need to be completely explicit, nothing is stopping you from adding comments at the top of all your files reminding yourself of what web2py is doing implicitly. But after you type the exact same thing for the thousandth time, you'll realize this is a waste of time and that it's a lot easier to simply remember the small number of things that are happening implicitly (again, all of which are well documented). Note, it seems that most people who complain about some of web2py's design decisions have not actually used web2py. Instead, they rely on over-generalized heuristics (e.g., "explicit is ALWAYS better than implicit") without considering the nuances of implementation. For example, just because Zope's "magic" became an "unmaintainable nightmare" does not mean web2py is making the same mistakes. The details are different, and they matter.
when i first saw this post on reddit, i thought you were trollin' for massimo. now i realize that you were not. sorry about that.
@mitsuhiko: you're out of touch, buddy. There's nothing broken in the web2py design. It works great. I have production code I developed 2 years ago that's still going strong without me having made a single change in all that time. That production code has taken in tens-of-thousands of dollars of orders for my customer (I should have told them I was using Django or Flask and then charged them more - hmmm, good idea, maybe next time =)
&gt; &gt; A framework does not need to be a library of Python modules. &gt; Why not ? Again, it's a set of APIs to learn. In my view a framework should should be more than a set of API to learn. It should provide structure, scaffolding applications, enforce a workflow. More important it should provide a way to build apps in a consistent manner so that other users can read them and install them easily without having to deal with dependencies and conflicts. This is not always possible but in web2py we put lots of efforts towards this goal. We jump some hoops so that users do not have too. Some people prefer to work with more constraints, some with less. There is not size fits all.
If the purpose is to learn APIs and learn python, then use werkzeug ,flask. But if you want to build a web application, please use web2py. And the best advantage , you can deploy your site to GAE by changing no codes. :-).. !
Pylons is a wonderful framework with bad documentation...If you want to use pylons try using their old version pylons 0.9.7.. which has a beautiful book written by james gardener .. which will teach you a lot about web development too!
really nice
Interesting mr justfornow. Half of the comments you ever posted to date are on web2py related threads, against web2py. Of course it is also true that more than half of my comments are on web2py related threads.
&gt; If you like the "magic" of web2py then you will probably be happier learning Rails; it's better documented, has the community and success stories, and will get you going faster. It's almost inconceivable that Rails "will get you going faster." In fact, I doubt that any framework could get you going faster than web2py. I also question whether Rails is "better documented." It may have *more* documentation, but in terms of quickly learning and getting a solid grasp of the entire development and deployment process, I don't think it's *better* than web2py. The web2py [book](http://www.web2py.com/book/) is really outstanding and quite comprehensive. I think web2py is actually easier to learn and use and therefore doesn't need quite as much documentation (though the book is 500+ pages). Also, the web2py community (though considerably smaller than the Rails community) is incredibly helpful. When I was starting out, I posted the same question to the Rails and web2py lists, and the web2py community provided a lot more responses more quickly and with more detail. I'm not knocking Rails in any way but just want to point out that the web2py community will be a great resource for anyone picking up the framework. Although it's not huge, it's growing steadily and is very active and supportive.
@noddyxoi thank you for reading the article! next issue of the mag is on the way. Yes I quoted you! Sorry for missing your name there. 
Nice. Would have been even cooler if it was for the whole Python ecosystem. SMT please.
&gt;&gt; All you need to know to use it is that it is the part of the Python language &gt; Exactly. Learn Python, that's all you should need. Anything else, learn the API. I don't get it. In web2py, in addition to Python, all you need to learn is the web2py API, as you suggest. It's just that once you've learned the web2py API, you don't have to import a bunch of modules in order to use it -- it's all there for you. So what's the problem?
We have a massive app all in Django. Sometimes it's annoying, but most of the time it works just fine. We don't use admin or much contrib stuff.
Zope used to be the cool kid on the block, but not anymore. So most of its users are serious professionals with maybe little time for advocacy. If you're looking for a new style web framework that benefits from its Zope inheritance, take a look at repoze.bfg
Well there wasn't one until yesterday :)
Thanks! I hope to roll it out in the next weeks. 
I prefer Pylons mostly because it fits in better with the Python philosophy of "explicit is better than implicit". Pylons is 100% magic free. Pylons also ships with mature, well tested, widely used Python libraries: Mako, Beaker, Routes, SQLAlchemy, WebOb and Paster. If you want, you can swap any of those libraries with your own. And the best part? Pylons is purely WSGI, which means you can drop any piece of WSGI middleware into your Pylons project and expect it to "just work" (example: lots of people use repoze.what and repoze.who for authentication and authorization).
&gt; There are so many things so incredible broken by design in that framework that I just cannot overlook things. I am not claiming that any other framework has a perfect design, far from it, but web2py leads the bad design decisions competition. I've seen you make similar claims elsewhere, but I never see any compelling argumentation to back it up. Usually just some vague proclamations that "such-and-such is bad". I'm not saying that to dismiss you -- I'm really interested to learn -- but I just don't have enough to go on to evaluate the validity of your concerns. &gt; The fact that it uses eval internally for execution its modules and controllers Note, *models* are executed in web2py, not *modules* (they are imported). &gt; breaks so many assumptions that it makes the code hard to understand. Well, how many assumptions does it break, or is that just hyperbole? How is the code hard to understand? Are you talking about the framework code (of concern to the framework devs) or the application code (of concern to the framework users)? &gt; In combination with the fact that web2py tries to stay backwards compatible it means there is no room for performance optimizations at all. Backward compatibility clearly means that the old API keeps working, not that the implementation of the API stays exactly the same (nor does it prevent additions to the API). So saying there is no room for optimizations *at all* is quite extreme and misleading. It is these kinds of statements that make me think your analysis of web2py is not entirely objective. It's worth pointing out that different web framework users have different needs. web2py meets a legitimate set of needs very well and has many happy and productive users as a result. Does that mean web2py is for everybody? No (though no reason it shouldn't have very broad appeal). Does that mean there's no room for some diversity of frameworks to satisfy different preferences? No. Does that mean web2py "leads the bad design decisions competition"? Well, that seems unnecessarily provocative.
I'd say the point is to have a standard and be strict to it. It gives another level of readability to Python and somehow when you import a library, you already know if you are dealing with a function or class. Take for example handling unicode in Python, there is no standard how library should deal with it, resulting in total chaos. Some libraries expect unicode, some transform to unicode, some never heard of it. And then add the encoding fun on top if it. Standards.
Woa, what a vivid discussion. As someone who also have to make a choice of which web framework to use in the near future I'm first of all thanksful to all the great developers creating those frameworks. I wish I was as skillfull and persistent to create stuff like that. In case you get frustrated by too many critics and discussions, remember there're heaps of people appreciating your work a lot!
He created it IIRC.
No, you misunderstood. I like Jinja2, I just think the default loader for Flask is a bit too rigid. I know I can add a custom loader for each module/app but it would be nice to be able to default a Django style, TEMPLATE\_DIRS configuration value. Also, it would be nice to have Django's select\_template(). I'm excited to see Flask grow, hopefully in a extremely modular fashion. For instance I made a [flask-auth extension](http://github.com/ericmoritz/flask-auth) that uses a config value to define the backend. It comes with mongoengine support built-in, but it would be awesome to have SQLAlchemy backend for instance. Using this pattern, it doesn't matter if you have NoSQL, SQL, flat file, LDAP, whatever. Ideally I'd like to see someone take on a generic Django admin alternative in the same fashion. It could be fashioned in such a way that doesn't care about where the data is coming from, it just wants needs something than will produce a list of items and a WTForm to do the administration.
To edit app files via the web based IDE (admin) you must be web2py administrator. Web2py administrator has the same privileges as the user running web2py. That means you can do as much damage through admin as you could have done when you setup admin from the shell. No more, no less. Admin access is password protected and only allowed from localhost or from https using secure cookies. admin can be completely disabled in production. 
I've been using Bottle for web-enabling some internal projects and it's been perfect for that. If I ever need to create a larger website with logins, forms, etc I'd have to consider a larger framework like Django or web2py. You mentioned : &gt; My web development productivity has improved by more than 5X over my previous productivity Just curious, what previous language or framework are you comparing to? 
This is a very partisan issue and everybody here is very passionate. Most of the python frameworks are quite good.Try to a few of them and decide for yourself, do not let impressed but those who talk louder. 
Upvoted for dispensing with the illusion of knowledge.
Following PEP-8 gives undoubtly a great additional value to readability of code and makes it therefore easier to understand code written by others. This cannot be overvalued! Sorry, there's no way I can understand people not following the PEP-8 if not for the unfortunate exception for consitency in projects not following PEP-8. And it's not difficult at all to create this useful habit. (I've changed from pure CamelCase to Python naming conventions for functions and methods and now find it much more readable.)
PEP-8 may or may not be overvalued in the ways that you say, but just like you can't force others to relax about PEP8, they can't force a project to follow it. Its a community standard. No no one has to use it in their work on large projects, and no one else has to agree that its totally fine that they don't. Opinion, bitching, and arguing are how community standards work, so this is all just part of the process. To give some actually constructive criticism: the best parts of your post were where you illuminated some cases of deviating from PEP-8 having distinct advantages. About the Win32 bits, I hadn't considered it, and you're totally correct.
I'm sorry, but magical imports and hackish eval() statements everywhere just violate way too many core Pythonic principles that I just can't ever see myself using web2py seriously. My philosophy has always been that black magic is awesome so long as that magic disappears the moment you want to see what's actually happening. Transparency is key. Having no idea what modules are actually available to me in any given file is not my idea of transparency. Neither is completely breaking all IDE interoperability in the name of saving a few lines of import statements. It looks like you've put a nice amount of work into web2py, and it's shaping up quite nicely, but it's evident from reading this thread that I'm not alone is sharing many deep-seeded disagreements with your design decisions.
If some one could praise web2py in such a fervid tone, I guess it's worth trying.
I agree that the point of a standard is to be strict about it, but you can't apply a standard to someone who has not chosen to accept it as their own. A third-party library is outside of the radar of what PEP-8 is a true standard for. For example, web2py apparently doesn't follow PEP-8, but I'm not aware of that being a goal of theirs in the first place. For that reason, PEP-8 comments make no sense. Good point about unicode/bytes/etc. Thankfully I mostly deal with math/numerical stuff and get to skip out on that party for the most part.
Flask has only been around a few months but it's a tiny wrapper over top of the excellent werkzeug libraries that have been around for a long time.
Use it and you would know!.. by the way looks like you have not had a look at bottle
Sometimes I envy web programmers because they only need to choose a framework and just adhere to it. But my job job often required me to work simultaneously with a bunch of frameworks and different languages. So although I considered myself a good programmer, I'm not an expert in any area.
For other people reading... "magical imports and hackish eval" translates into this web2py source code more or less: context = {'variable','value'} exec(code) in context where "context" is [clearly defined here](http://web2py.com/book/default/chapter/04#API) and code is user's application code. To me being able to do this is the single most important feature of Python. Every other python expressions can be translated in Java or Visual Basic almost line by line. It allows us, for example, to make sure that every http request executes the most recent code without having the restart the server (even when not using the built-in web server but using apache for example). Edit: besides, is the template language of Django or Jinja Pythonic, they invented their own language? web2py is the only framework to allows pure python code in templates
Don't just look at flask, also look at werkzeug, the libraries flask is built on. I do all my python web development in werkzeug and it's fantastic. Flask is a great way to start but know that once it gets too limiting for you it's absurdly simple to keep moving forward with the lower level werkzeug libraries.
&gt; reddit is known for its passionate hate toward web2py Really? I'm a python developer who's been on reddit for years and never noticed that. Maybe it's just that web2py isn't as popular as you want it to be among python users (especially those that are more experienced) and you just notice the bad reviews more, it's called confirmation bias.
Google does not follow Pep8 http://google-styleguide.googlecode.com/svn/trunk/pyguide.html
&gt; Changing WaitForSingleObject to wait\_for\_single\_object gains absolutely nothing. Very true. Still, if no other style guide or previous style is already there (as it is with the Win32 API), I don't see any point in not using PEP 8. Using camel-case for method names just because 'it looks better' â€“ even if used consistently â€“ is still a bad idea. You gain nothing except reduced readability.
Okay, here's the thing: it may not matter for _your_ code what standard you adhere to. It will however matter for other people's code. In most situations your code will not be perfectly isolated. You're going to use external libraries and possibly other people will use your code as well. It makes sense to have thin wrapper libraries stick to the style of whatever it is they are wrapping. If I want a low-level OpenGL library, it's helpful if the library sticks to the same naming conventions the C++ equivalent does. If your code is not just a wrapper, though, it's helpful if it adheres to a set of rules most people will find useful. And for Python we are infinitely lucky to have a very dominant convention, which is PEP 8. If you've ever written PHP code, you'll see the advantage of having homogeneous naming styles, not just within the same library but across the whole lot of them. Nobody is forcing you to adhere to common guidelines, but nobody wants to have to memorize an entirely different set of conventions for each included library (just think what Pylons code would look like, Django would probably pose less problems). __tl;dr__ PEP 8 is not the be-all end-all to code formatting and variable naming (context matters!), but aiming to adhere to the status quo is a very good idea if you write code that has even the remotest chance to be used by other programmers in different projects. If you go against conventions, you'll surprise your fellow programmers -- and it's usually a terrible idea to do so unless you have a very good reason to. EDIT: Regarding your Win32 example: yes, it's a good idea to stick to Win32's naming conventions rather than PEP 8 if you write a Python wrapper. But it's probably also a good idea to stick to PEP 8 if you're going to write a high-level wrapper on top of _that_ (think faÃ§ade pattern).
You shouldn't _ever_ need to use actual python code in templates. It's the equivalent of in-line SQL statements in modern web development. It encourages sloppy spaghetti code with poor caching and designer-unfriendly templates. Forcing separation of templates from business logic is a good thing.
I understand but I think you overstate the case especially when you say stuff like: &gt; If someone wants to make the next great web framework use ALL CAPS, go right ahead, it'll probably still be cool. The result might be cool, but it's not cool to rob signifiers like variable naming conventions of all their meaning. The main takeaway to me from pep8 is consistency. If you hack on pywin32, keep their conventions. If you hack on ALLCAPS web framework, keep theirs(although, only pywin32 has an actual reason for its choices, all-caps web framework has none, 'knowing when the style guide doesn't apply' shouldn't mean 'gratuitously flaunting good practices')
Looks great. In case the website authors are here: dict((i, data[i]) for i in xrange(len(data))) is equivalent to dict(enumerate(data))
Also, since I just saw this the other day...[pep8.py](http://pypi.python.org/pypi/pep8/) may be of interest to those looking to keep their code compliant in svn/hg/git hooks.
Not a chance. PEP8 looks the way I want my code to look.
To see a a new library written today (i.e. not a library like unittest which was added to the standard lib before pep-8 was written, based on a comparison of published dates), which doesn't abide by pep-8 at all, is definitely telling about that library. Nobody is guiltier than I am of coming from a Java/Perl background and dragging all those useless ways of thinking into my early Python code. Not being aware of pep-8 leaves the smell of suspicion that the code you're seeing is borne of a lingering php/java/perl mindset.
The codebase is open source, it'd be great if someone style'd it up for Python and deployed it!
ah, shut up. those i'm talking about know what i'm saying. i have seen the creator of web2py posts bashed for no reason whatsoever. for now, i'm putting you on ignore. i don't want to waste my time or participate in your petty arguments.
Also see Disco: http://discoproject.org/
This is why Flask appeals to me. I like my system doing exactly what I tell it to, and only that. web2py follows the 80% rule very well. It will work for you 80% of the time, but if you ever need that extra 20% out of the framework, your kinda screwed.
old engineering proverb: the good thing about standards is that there are many to choose from.
The quick version? Use web2py if you like web2py, use Django if you like Python. web2py is written in a very unique style. Whether I like it or not is mostly irrelevant, but it isn't related to the greater Python ecosystem really.
This is cool... 1.10 is what I really want though.. I guess I need to wait a bit ? Surely the gobject introspection should help here?
&gt; You gain nothing except reduced readability. If that is the main argument in favor of PEP8... they loose me already. Mind you, I follow PEP8 in my work, but readability is subjective, and at least I do not consider `lower_case_with_underscores` better than `PascalCase` and `camelCase`, nor an easy to follow standard: is it `num_errors` or `numerrors` (nobody seems to agree on when/where to use underscores).
The Django template system for example does not allow recursion (and correct me if I am wrong). I think that is important to generate recursive menu structures or nested tables which may have a recursive structure. I have used python code in templates to generate maps, PDF, processing.js code. I do not think that code belonged to the controller and I could not have done with the limitations of other non-Turing-complete template systems.
IMHO, you should always attempt to conform to PEP8 unless there's a very good reason not to. As an example, *"wrapping an external API"* qualifies as a "very good reason" but *"I'm just used to camelcase"* does not. Having style consistency across codebases is a good thing and makes it that much easier when someone has to work with your code or you have to work with theirs. If I was hiring a Python programmer and their code didn't follow PEP8 I would likely think twice before hiring them.
Defining your own template tags (custom functions) or filters would accomplish all of that while still separating your templates from business logic.
Disco is more powerful but significantly less light-weight
So you end up generating recursive menus by concatenating html strings in a Python function? Is that good programming? In web2py you can define html functions: {{def maketree(tree):}} &lt;ul&gt; {{for item in tree:}} &lt;li&gt; {{if isinstance(item,list):}} {{maketree(item)}} {{else:}} {{=item}} {{pass}} &lt;/li&gt; {{pass}} &lt;/ul&gt; {{return}} {{maketree([1,2,[3,4,[5,6,7]]])}} As you can see there is no string concatenation. You can also do itwith HTML helpers: {{def maketree(tree): return tree if not isinstance(tree,list) else LU(*[LI(maketree(item)) for item in tree])}} {{=maketree([1,2,[3,4,[5,6,7]]])}} Now show me how you do this in Django or Jinja without concatenating strings and let's see what is cleaner code.
But takes me about 0.05 seconds longer to read
I look at PEP-8 as a very solid *guideline* to follow. I try to stick to it as much as possible, and prefer to read code that sticks to it as well. Granted C++ doesn't have a style guide per se, however there are common idioms that you find people adhere to. For instance, most people indent their code, it's completely unnecessary, but just about everyone does it. At the end of the day all I really care about is consistency. As long as there is some form of convention I can decipher, I'm happy. 
If in django you pass to your template a context variable called foo, where foo = [1,2,[3,4,[5,6,7]]] Then to do what you asked you just write this in your template: &lt;ul&gt; {{ foo|unordered_list }} &lt;/ul&gt; Where unordered_list is a built-in template filter. Obviously it's over-simplified because I didn't have to write it myself, but you get the general idea. Edit: Jinja has its own recursive tag: &lt;ul class="sitemap"&gt; {%- for item in sitemap recursive %} &lt;li&gt;&lt;a href="{{ item.href|e }}"&gt;{{ item.title }}&lt;/a&gt; {%- if item.children -%} &lt;ul class="submenu"&gt;{{ loop(item.children) }}&lt;/ul&gt; {%- endif %}&lt;/li&gt; {%- endfor %} &lt;/ul&gt;
&gt; I'm sorry, but magical imports and hackish eval() statements everywhere... It's important to note that not all eval() statements are "hackish". If that was the case, then presumably eval() wouldn't exist in the Python language. Can exec() and eval() be misused in hackish ways? Yes (and perhaps they often are). Does that mean that web2py's use of exec() is "hackish"? Of course not. Just because exec() is often inappropriate or dangerous does not mean it always is. If you have concerns about web2py's specific use of exec(), you should explain in more detail. Seriously, I'd be interested to know the specific problems you are concerned about (without resorting to the simple mantra that "exec is always bad"). Also, you say "hackish eval() statements everywhere" -- what do you mean by "everywhere"? Note, web2py users are not encouraged (and certainly not required) to use exec/eval in their own code -- exec is simply used by the framework itself in order to set up a prepared environment for each request. It's not that magical or mysterious (though it is helpful). &gt; just violate way too many core Pythonic principles that I just can't ever see myself using web2py seriously. Can you enumerate some of these core Pythonic principles? Are they hard-and-fast rules never to be violated under any circumstances, or merely guidelines meant to *guide* you without restricting you from doing the right thing in a particular context? &gt; Transparency is key. Having no idea what modules are actually available to me in any given file is not my idea of transparency. Good point, but not relevant to web2py. With web2py, you will certainly always know exactly what modules are available to you in any given file -- the answer is whatever modules you explicitly import, plus the models, the requested controller, and the small number of API globals. Easy. If you can't remember this, write yourself a note at the top of your file. &gt; Neither is completely breaking all IDE interoperability in the name of saving a few lines of import statements. As far as I know, web2py works fine with a number of IDEs (may require some setup). 
Well, the reason behind the disclaimer is: Programmers: Master | Professional | Advanced | Knowledgeable | Amateur | Novice | &lt;--- Me Derp
Use pylons by all means but use version 1.0. The docs are on the [site](http://pylonshq.com/docs/en/1.0/) and they are quite good.
But why go through the hassle of writing custom template tags when you can just use Python directly? Your proposed custom template tag alternative is not separating "business logic" -- it's just a workaround to enable additional *presentation* functionality not readily available in the template system. I'm not saying it's necessarily a bad idea to have a separate template language or to write custom template tag functions, just that it's also OK to use Python directly. Note, web2py is an MVC framework that does a good job of promoting proper MVC design, so it does not "encourage sloppy spaghetti code" as you fear.
I think this is a good and fair example of the differences in the template languages. I will refrain from commenting and let other users decide what looks more appealing to them. In the end it is a aesthetic matter. 
I concur. And like I said, I always enjoy seeing competition and you've really done a great job with web2py, it's just not for me. To each their own!
Twisted isn't a web framework, it is an async network server framework.
&gt; The quick version? Use web2py if you like web2py, use Django if you like Python. If you like Python, there's no reason you shouldn't use web2py -- you'll be doing everything in Python, and you can be just as Pythonic as you like. &gt; web2py is written in a very unique style. I'm not sure the style is quite as unique as it's made out to be. There are some unique elements, but the framework as a whole is not completely alien to the Python world. It probably has far more similarities than differences with other Python frameworks. &gt; Whether I like it or not is mostly irrelevant, but it isn't related to the greater Python ecosystem really. Not quite sure what this is supposed to mean. It's not clear what "Python ecosystem" connections other frameworks can make that web2py cannot. Unless you mean that Django itself has its own large ecosystem (i.e., existing apps, plugins, etc.) -- but that's not the *Python* ecosystem and doesn't apply to some of the other Python frameworks being discussed.
Thanks for pointing that out! I just updated it.
&gt; Google does not follow Pep8 I don't think the google style guide diverges from PEP8 anywhere significant (or anywhere at all).
If you want embedded, yet fully functional database, try [Firebird DB](http://www.firebirdsql.org). Firebird has python interface through [kinterbasdb](http://www.firebirdsql.org/index.php?op=devel&amp;sub=python). I see your edit. It might be worth considering firebird still if you are expecting concurrent writes to your DB. 
I find it helpful if you don't like PEP-8 to think that the language requires it or else you get a syntax error. But if you hate it that much, then don't use it and don't bitch that other people are bitching at you to use it. If you are a lone programmer I don't see why this is a problem, but good luck programming Python with a team, OP.
Is it me, or are the project websites not among the information?
They use Python mostly internally (You Tube, Google Groups, internal tools, etc.), so it does not matter because know one else will see it.
Even between frameworks like Django, TurboGears, and Flask there is a lot more cross-talk and cross-pollination of ideas than between web2py and anywhere else. You can write in a "normal" style in web2py, but that isn't what the documentation uses and it isn't what the rest of the web2py community uses so you will be somewhat more on your own should you choose to do so. It is like saying you can write a C++ application using nothing but C. This is technically true, and there will always be a few places where it is wise to use plain C, but you probably don't want to go too far on that spectrum or there was no reason to use C++ in the first place.
It just seems like too much magic. Why not just add the handler to the logger? Its much more explicit: log = Logger("foo") log.push_handler(FooHandler(magic=False)) This obviously makes passing around a global configuration more challenging, but, at the same time, is much less magical. The current implementation uses a bunch of magic to use object proxies that essentially implement a registry. If you don't believe me, please see the mess of globals and thread locals here: http://github.com/mitsuhiko/logbook/blob/master/logbook/base.py Don't get me wrong: this is a very cool library. Perhaps a "ConfigurableHandler" would warm me up little bit. Something that would take a dictionary argument and build a handler that does what needs to be done. 
Look at the GAE SDK. Anyway, I am not making any statement here other than some reputable sources do not follow it.
Isn't that usually the trade-off?
Nifty. `plac` can be an agile alternative to `argparse` in many cases. One change I'd like: `'option'/'positional'` could be `plac.option/plac.positional`. But either way, I'd bind a shorter variable first in my own programs, maybe `o/p`. When I need actions, subparsers, or `nargs`, I will use `argparse`. `nargs` is useful more often than you might think, as there is a big difference between `nargs='+'` and `nargs='*'`. &gt; Required options are generally considered bad form. There is *definitely* room for disagreement with that. For example: mv --target-directory dir [files] In this case, it's not quite required, since `mv` is sometimes used to rename a single file, but I hope you see my point: It's hard to remember whether the directory comes first or last amongst the positional arguments. (Maybe that's a bigger problem for `ln`.) When you use flags for required arguments, order does not matter. We should be calling these "positional" and "flagged" arguments to avoid this debate. Anyway, very cool.
The second one? I think you need to repeat the experiment :)
PEP-8 is useful for folks whom have absolutely no clue how one might write idiomatic Python code, and as such it's an excellent read for new programmers and old programmers who are coming to Python from another language. I think when people bitch about "non-PEP8" code, much of the time they're really bitching about non-idiomatic code. I think bitching about that is a reasonable thing, because if a developer never internalizes the idioms for a language, it's unlikely he's going to be able to write really good code in that language. It's also a sign that he may not have actually *read* any good code in that language.
&gt; Advanced users can implement their own annotation objects. Ok. So I can use class constructors instead of tuples if I want. Great! Also, kudos for `plac.Interpreter`.
&gt; If I was hiring a Python programmer and their code didn't follow PEP8 I would likely think twice before hiring them. A little harsh, don't you think? Maybe just some programming guidelines for whatever codebase you have would be better. I might be a C programmer at heart, but I can conform to Java's normal capitalization (no IDE helping me) or Python's, but it's a little harsh to disqualify a programmer just because he does a coding style you don't like.
I'm curious as to why nobody mentioned TurboGears yet. I've a small project running which I build in my spare time, and TG seems awesome. I say this, coming from a PHP background, and when I first checked out TG I was blown away by the way things "just worked". On the other hand, I feel that TG has quite a steep learning curve, and for my use this was probably not the smartest choice because of that. I code only sporadically on the project and it is the only python web-project I am working on. So getting to know the whole framework is difficult as the framework are evolving faster than I can keep up with... Now, that I see that TG was only mentioned as a side-note in one post, this is beginning to worry me... Should I start learning something else? Is TG really not that good? Or is it just because it's a lesser known framwork?
web2py encourages PEP-8 and follows it in most places except in a limited context where it makes sense to deviate (see [here](http://web2py.com/book/default/chapter/01#Elements-of-Style)). Remember: &gt;But most importantly: know when to be inconsistent -- sometimes the style guide just doesn't apply.
*Q*: What is the first section heading in PEP-8 (after the intro)? *A*: *A Foolish Consistency is the Hobgoblin of Little Minds*
I agree. That's why I said "think twice", not "exclude". :-) FWIW, I was a Java programmer first so I do know the pain of switching to PEP8 (\_and\_I\_detest\_underscores\_!\_!\_!\_) but I did it anyway.
I Think it is because TurboGears are merging with Pylons http://turbogears.org/2.0/docs/main/TGandPylons.html
If it is a project for yourself then do whatever you want. However if you want people to use your project then do it right in the PEP-8 way because the consitency makes it much easier on everyone. The worst aspect of PHP is not only not remembering a method but the format you have to type it in because it could be camelCase, under_scores or anything else.
Do not underestimate yourself... cherrypy+mako+sqlalchemy qualifies for above Knowledgeeble at least.
It's the little victories that keep me going! Was able to successfully make a button do something. I know this sounds simple, but understanding this took me a while. Thanks everyone for the help.
Don't forget to try out Tornado as well. It has enough convenience features that makes it a legit micro-framework, beyond just a fast web server. Also, it solves OAuth problems for you.
Ok, so how do you bundle it in an exe though?
You probably meant "Explicit is better than implicit" =)
TurboGear is pretty much Pylons with added libraries. When researching on TurboGear, you'll mostly be reading Pylons documentation.
&gt; Having explicit imports, and the cost of a few minutes of typing, means that I now have a module that's much easier to read and maintain. Where does this function come from ? It's at the top of the file, in the imports, unless it's a standard Python builtin. That one line of code, "verbose" as it may be, may save hours of frustration. print functionname.__module__ Seeing the import doesn't necessarily save you frustration. Problems with paths have had me explicitly loading modules from a location I didn't expect them to be. This is handy for that: print modulename.__file__ BTW, you've also dropped 5 of his six points, so I'll just pull them across my flow as conceded. ;-) Edit: In reading some more of the replies, I'm definitely against a bunch of eval()'s all over my code, so until that's addressed I'm awarding the point to you. FWIW, I'm not familiar with either framework, so I haven't taken sides, I just don't feel that all your points are philosophically compatible with my opinions on how stuff should be coded. Some are valid, some are valid but I disagree with, some I consider trivial, some I don't have an opinion on but were addressed by mdipierro.
&gt; but once you get to more complex apps you benefit from a full stack framework like web2py or Django Really? From my experience, full stack framework only get in the way as the app getting more and more complex. I think full stack framework only good for a situation when you need a rather large web app up and running within a few days.
I'd have to dig into the docs a bit more, but I know you can embed resources in py2exe exes. Although, considering his original goal was to bundle all of MySQL, I think he could probably have an extra file or two to support Redis and just zip it all up, or make an installer.
&gt; Here's in your face: I'm a "top Python developer" I think "top Python developer" in the context of *this thread* refers to core developer or recognized contributors of Python community as a whole (e.g. mitsuhiko, ianb, etc.) &gt; A number of web2py detractors here seem to be blowing smoke for reasons unknown to me. I can say, as a satisfied user, I would rather fight than switch. web2py is for me. Apart from encouraging ("subjectively") bad coding style, there're also [this](http://groups.google.com/group/web2py/browse_thread/thread/39816e2ae01044f7/923e9031fd47b43b), [this](http://groups.google.com/group/web2py/browse_thread/thread/850abda80db3de47/266d3ce5fb7bcdad), [this](http://groups.google.com/group/web2py/browse_thread/thread/ad4d137f6a4dbab7/d098bbbfde62eabd) or recently, [this](http://groups.google.com/group/web2py/browse_thread/thread/63b6ff585b405c77/75d795d225bab019). You do realize Reddit hate this sort of thing, right?
I use the right tool for the job (it's not django). If I need to do a quick "alpha" I use the framework that gets me to completion as quickly as possible (time IS IS IS IS money money money DAMINT DAMNIT DAMINT!!!!!!!!!) sorry...echo in the room or something. But then it totally depends on your approach. I notice a lot of people completely ignore this and get right into I like "x" framework because it is more pythonic or does "y" easier. This is completely not helpful to a decision of which framework to use. In choosing a framework, one needs to understand what their approach to web development will be. My approach is: had a designer build a UI with photoshop, slice it and build an html template. I then go in and javascript it up so it is smooth like a baby's bottom. Finally (LAST STEP), I go into a web2py and build a DB and a few controllers to get the app functioning. I chose "x" framework because it lets me do less typing (every character typed is money lost, during alpha). Once the application gets enough traffic, I will move to something dictated by the salability demanded by the specific application at the particular moment, and by my budget at the time. Let me be clear here: if my web application gets popular enough to require optimization, I will make a decision as to which engineering decisions to make then and there. If I ever get to the point of needing optimization, though, and web2py can't handle it, I will go with pylons. Reddit chose it, and if it is good enough for them, it is good enough for my app (tried &amp; true?). But then by that point I will probably have an army of engineers, so extra typing should not be a problem, no? ;P Django's approach, and this is THE MAIN DISTINCTION, is build the server side code first, and then build the UI. Don't argue, this is what it is built for, and it is not a weakness, it is simply a design decision. One that works for many many sites, and is very much needed. Don't believe me? Just read the introduction to Django in any book and it's history/reson d'etre (purpose of being made). I choose not to use Django because that is not my approach. Simple. In conclusion, choose the framework that saves you time, not the one that others say will scale...they don't know what they are talking about...as you cannot predict how exactly you will need to scale--plus the web application is the last thing needing scaling, usually the DB (cache) is far ahead of the web app. More importantly, though, 99% of apps developed wont need that sale, so you are just spinning your wheels if you go with something that will scale really well right up front. DIAGRAM: Scalability Vs. Time taken to build formula scale = y time to code (any framework) = x y = x^2
debuggers are crucial mainly for threaded apps, but still very helpful for non-threaded if you know how to use them since you'll always hit environmental issues or package bugs from time to time that make things go bonkers for seemingly no reason.
You seem to be pretty good at ascii diagrams though!
@iamtotalcrap So which framework will you choose? (and why?)
"bloated" is a relative term. For me it is not bloated. Though, as I said, I use vim for coding. If I had to use eclipse, I wouldn't find it bloated...I guess...I just like vim's commands more...and that's why I use it for writing. I like eclipse for pydev's debug...that's why I use it. During debug...I don't concern myself with "bloat"...Note also, I am using a 10" netbook with 2gig of ram. I am very much concerned with efficient use of screen space and speed. I am very utilitarian in my approach...I use the right tool for the job...and I am not a fanboy of any particular tool...I subscribe to the "starship troopers" tools approach. I will use a tool for a job until I find something that does it better, and then I will use that tool for that particular job. I do not mind at all mixing tools.
oh well now i'm changing my mind, you seem like a perfectly rational person. no persecution complex at all. i'm still trying to figure out which petty argument belongs to me, but i guess it must be even more petty than your complaint that internet commentors don't like your favorite python web framework. oh and web2py sucks
You should've seen the "Look of Disapproval ejaculates onto a troll's face" I did a few weeks back...
Huh?
Exactly.
Well, I've already tried django for a few days so I need to download web2py and try it too, but I'll probably go with web2py based on what was posted here because it is apparently built with ease being the first priority which is what I want in a mega-framework. If I want lower level I'll probably use something like Bottle or Pylons... I guess we'll see though :)
Exactly what? I was offering a compliment on your diagram and then you respond with some nonsense that looks rather nasty. Perhaps I'm getting too old for the internet.
lol.. thanks for the good points, but you may want to lay off the caffeine ;)
Not caffine...better...it's a belgian beer...all 750ml... I follow the balmer curve... http://xkcd.com/323/
It was meant to be humourous.
Roger that.
Good thing the points people are making here are not foolish, but reasonable.
Pretty much the only thing wrong with PEP8 is the underscore_names thing. Other than that it's just good style.
&gt;Even between frameworks like Django, TurboGears, and Flask there is a lot more cross-talk and cross-pollination of ideas than between web2py and anywhere else. OK, I see what you're getting at. Perhaps you should have said "Python community" instead of "Python ecosystem". &gt; You can write in a "normal" style in web2py, but that isn't what the documentation uses and it isn't what the rest of the web2py community uses so you will be somewhat more on your own should you choose to do so. I'm not under the impression that this is actually the case. Can you provide some examples of how the web2py documentation/community deviates from "normal" Python style (aside from the fact that web2py doesn't require you to explicitly import your models or all the web2py framework objects)? Note, in my original reply, I wasn't trying to argue that web2py is completely in the Python mainstream -- just that your original post seemed somewhat overstated.
I second that. module &gt; project &gt; universe I remember (though I cannot find a reference) reading that Guido uses 4-space indentation for public code and 2-space for Google code (or vice versa) for obvious reasons. That might have been before Google imposed a corporate standard. The point is, even Guido recognized that rules are meant to be broken. I would certainly follow whatever standard my employer wants, but I don't buy the argument that following the standard makes your code more readable. For example, x = MyClass() y = my_class_factory() versus x = MyClass() y = MyClassFactory() or x = my_class() y = my_class_factory() The 1st version follows PEP-8 and is *less* readable. The real problem is that my code uses stdlib code all over the place, and I do not want to rebind everything from stdlib. I prefer upper-case for both classes and functions, but that leads to odd-looking code. My compromise is to use lower-case for *everything*. Stdlib class references are rare, so they are hardly noticed. Besides, built-in types use lower-case already (e.g. `dict` and `list`).
This may be a dumb question, but what exactly is the advantage of using ActivePython rather than just installing vanilla Python?
Mmmm... love belgian beer :)
[vim plugin](http://www.vim.org/scripts/script.php?script_id=3160) for it as well
Use enumerate more!
This also looks good, but the allure of single-file libraries can't be overstated...
You linked to [this](http://groups.google.com/group/web2py/browse_thread/thread/39816e2ae01044f7/923e9031fd47b43b) but conveniently failed to link to Massimo's apologetic follow-ups [here](http://groups.google.com/group/web2py/msg/e542e8dd052a4510) (which is part of the very thread you linked to) and [here](http://groups.google.com/group/web2py/browse_thread/thread/39816e2ae01044f7/923e9031fd47b43b) (which is part of the reddit thread referenced in the link). The other three links you provide are all perfectly reasonable and innocent -- merely informing the web2py community of reddit threads that are directly relevant to the web2py community (but not requesting that web2py users comment or vote). Are you suggesting it is inappropriate for one web2py community member to inform others about a relevant reddit post? Two of those three reddit posts mentioned web2py right in the title. The fact that some web2py users followed the links and decided to contribute just speaks to their passion about web2py -- there's nothing inappropriate going on. It's also worth noting that the first three links are a year or more old. Since being subjected to attitudes like yours, I think Massimo has generally refrained from posting reddit links to the web2py list. The link posted today was posted by another user, and in fact, Massimo replied with [this](http://groups.google.com/group/web2py/msg/dcfea5dd47de4ee3). It seems you are contributing heavily to the smoke blowing here. 
hmm.. looks like I should have a look at it again... no doubt pylons is one of the best frameworks out there! [EDIT- just had a look at it, no the docs still are for 0.9.7, just had a look at the quickwiki...did not go through the entire docs....pylons has to go a long way in term of documentation...]
This seems very cool and I would love to use it. On Windows XP, when I run 'example.py' using python 2.6.5.14, it hangs and on interrupt, gives me the trace below. Any suggestions? Thanks in advance. Traceback (most recent call last): File "C:\Downloads\example.py", line 28, in &lt;module&gt; results = s.run_server(password="changeme") File "C:\Downloads\mincemeat.py", line 224, in run_server asyncore.loop() File "D:\Python26\lib\asyncore.py", line 202, in loop poll_fun(timeout, map) File "D:\Python26\lib\asyncore.py", line 132, in poll r, w, e = select.select(r, w, e, timeout)
Calm down and read my comment again, I only answered the question, not trying to add any smoke or trying to flame Massimo. The OP asked for a reason (of why web2py and Massimo being hate here), I answered him with a link to the trigger. Also, I think if the user is asked for an opinion on Reddit, he want an opinion of Reddit community, not web2py's. If it's the latter case, it make more sense to post in web2py mailing list. "Informing the community" only add bias in this case, even if the community acts on its own. My $0.02.
What about the thousands of Googlers who see that code?
Oops. Fixed now.
&gt;C# isn't bound by law to be written the same by everyone around the world. True. There is no official coding standard from Microsoft regarding how C# should be formatted. However, you'll see that the vast majority of the C# code out there is formatted exactly the same, thanks to Visual Studio defaults. The same applies to Java code. Both Eclipse and Netbeans conform to Sun's (now Oracle's) formatting recommendations, and many java projects end up following them because that's the defaults the tools came with. Python doesn't have the same level of tool support as Java or .Net. PEP8 is an attempt to create a substitute for the sort of default coding style that would normally be enforced by an IDE.
&gt; OK, so I'm not a top Python developer by your definition. But what matters is actual end-user experiences. Bottom line, it makes me more productive. As another said here, time=$. I try to keep my $ away from where my mouth is, but it's hard to adhere to that policy with web2py. &gt; Apart from encouraging ("subjectively") bad coding style, there're also this, this, this or recently, this. You do realize Reddit hate this sort of thing, right? Then, check out [this](http://groups.google.com/group/web2py/browse_thread/thread/63b6ff585b405c77/8afcaa0152a496c8#8afcaa0152a496c8)
Most of my web development work prior had been with an MVC web framework of my own construction, which ended looking surprisingly like web2py. With it, I was able to crank out sites quickly. When I looked at ROR it was still too early and I had some serious work to do, so I didn't use it. Much later, I tried Zope and Plone for a very simple project but abandoned ship quickly - yuck! Never actually used Django because one of their "top developers" pointed out the semantic inconsistencies. Found web2py and never looked back. I like python and prefer to program in one language. Since I already have to program in too many languages, eliminating even one language is a good thing (as long as it isn't python).
example.py is supposed to hang until a client connects to do the work. run "mincemeat.py -p changeme localhost" in a different terminal and everything should run smoothly.
... so they're not terrible?
good list
Godammit ! now I have to figure out how that shit works......
Why does it have to turn into this all the time. Why does technical discussion have to turn into a personal one? Honestly I do not care if you like me. Yet I do care about reddit as a community. I like most of its members and their interesting posts. I even like Mitsuhiko although he used to hang around the web2py IRC channel for the sole purpose of turning away new users. What I do not like are things that are not true or quotes taken out of context. Look at what Hannity did last week to Obama. Do not do the same thing. [Here is an important post on the topic](http://groups.google.com/group/web2py/msg/e542e8dd052a4510) in which I ask users of the web2py mailing list if I should report web2py related news and they said yes. Some redditor asked a question to web2py users and it is my job to make sure web2py users know about the question. Should we not work to increase the reddit community or do you want to keep it closed to the current members? By the way did you notice this was a thread about web2py and Django and it was hijacked by Flask. I did that once and the same people who did it this time complained with me than. Isn't that ironic?
octopy is a similar implementation: http://code.google.com/p/octopy/
I can't find the resource (I believe it was a talk), but I am pretty sure Google does that to easily distinguish Google Python code from external sources. They do follow PEP8 otherwise.
&gt; ... so throwing together a new project that includes registration, social networking, blogging, a wiki, comments, shopping cart, voting, tagging, and on-site search **takes literally under 60 seconds**. I believe you because I use Django as well. This is touted as Django's killer feature, and I'm inclined to agree. In my experience, no other Python web framework come even close to this level of application modularity. The thing is, and I'm sure you're aware of this, you need a pretty good understanding of Django's philosophy and you have to *follow* it, otherwise the applications you build won't be modular at all.
I agree. I'm finding that much of my time is spent developing the front end first, outside of web2py. I do that with jQuery and CSS styling. My interfaces are animated and liquid, so are complex. My web2py code development goes much much faster, by comparison. web2py makes AJAX hookup between the two very straight forward. 
Thanks for the reply. I'll have to check out web2py soon. 
Note that octopy doesn't have any fault tolerance, hasn't been developed since April 2008, and doesn't contain any licensing information.
If I know this would be taken as personal attack, then I wouldn't bother posting. My apologize. I owe you a beer if you happen to come to Bangkok. &gt; What I do not like are things that are not true or quotes taken out of context. Look at what Hannity did last week to Obama. Do not do the same thing. I'm not sure which one is this you are referring to; if it's about the link, then linking to the whole thread would be suffice as a context, isn't it? &gt; Some redditor asked a question to web2py users and it is my job to make sure web2py users know about the question. Should we not work to increase the reddit community or do you want to keep it closed to the current members? Yes, that's a good thing. However, it's not a good sign when someone registered Reddit just to advocate web2py. That add nothing to the community, worsen the image of web2py itself, and in some case is discourage by the Redditquette: "Send out IMs, tweets, or any other sort of message asking people to vote for your submission -- or comply when other people ask you. A link should get points for being good, not because the submitter is part of a voting clique." If you do care about Reddit as a community, then I think the middle ground of this is to put a notice refraining web2py users from registering here just to post about web2py along with the link. Not after.
The weirdness of imports is high on the list, and really gluon.import_all in general. There is also heavy duplication between gluon.sql and gluon.dal. web2py is really aimed at being a DSL for web apps in my mind. That doesn't mean it is bad at what it does, but it isn't trying to adhere to "Python standards", instead it does what is best for its very narrow target environment. Again, this is fine, but it means that you should use web2py because you like web2py itself, not because you love Python in general.
Use an underscore in the same place you would change case: numErrors =&gt; num_errors.
What code are you talking about?
Sure, PEP 8 was intended for the stdlib. But who cares about the original intentions? It has lived on to become a de facto guideline for all Python code, and that's a great thing. The more people adhering to it, the more consistent and pleasant reading Python code will be. I see no downside to this whatsoever. If you want to express yourself, arbitrary syntax quirks are a pretty pointless way to do it. Get on board and write code that is easy for others to deal with.
I'd say a factory is a special case. It's a function that is intended to behave like a class for the purposes of constructing objects, and therefore I think it is perfectly reasonable to make an exception to the rule and use your second example, making it appear to be a class name. PEP8 is not to be blindly followed without exception.
Actually, you should read *my* comment again, because I did not say that you were *trying* to add smoke or flame Massimo. Rather, I merely pointed out that the *effect* of your response was to mislead the reader (intentional or not). I'm sure you *intended* your response to be an objective analysis -- but it wasn't. It was misleading, and I took some time to help clear the smoke. If you wanted to dispassionately report the facts without making any judgments, you could have said something like: "In the past, Massimo posted a few reddit threads to the web2py list, and a bunch of web2py users then commented on those threads. Although it does not appear that Massimo had any bad intentions (as indicated [here](http://groups.google.com/group/web2py/msg/e542e8dd052a4510), [here](http://groups.google.com/group/web2py/browse_thread/thread/39816e2ae01044f7/923e9031fd47b43b), and [here](http://groups.google.com/group/web2py/msg/dcfea5dd47de4ee3)), I think some reddit users frown upon that kind of activity and took it out on web2py. I'm not saying I agree, just that that is what happened. In any case, Massimo doesn't seem to have done that in over a year." Instead, you provided links that appear to make Massimo and the web2py community look bad, and then said "Reddit hate this sort of thing," with no further qualification or explanation. As I'm sure any reader would, I assumed you shared the "hate this sort of thing" attitude (particularly given that the first half of your sentence was a disparaging remark about encouraging bad coding style). In fact, my assumption was right, as proven by your follow-up: &gt;Also, I think if the user is asked for an opinion on Reddit, he want an opinion of Reddit community, not web2py's...."Informing the community" only add bias in this case, even if the community acts on its own. So, I interpreted your response accurately -- you think those posts were inappropriate, and you were letting everyone know it. You probably think your opinion is justified, but this certainly does not qualify as "only answering the question," as you suggest. Now, regarding your claim that "Informing the community only add bias," I think you're both misconstruing the purpose of reddit and expecting too much of it. First, unless the OP is explicitly asking for a vote or some kind of quantitative sample, I don't see any reason why the *number* of commenters/comments must be proportional to the size of the community. If someone wants to know about Django and web2py, presumably they want *equal* (not proportional) amounts of information about each framework. If Django has 10 times as many users as web2py, you don't necessarily want 10 times as many responses from Django users -- that would be like deciding to read 10 pages of the Django documentation but only 1 page of the web2py documentation. Instead, you want a lot of Django *and* web2py users to respond, with as much detail as possible. In fact, I would argue that because web2py is the lesser known framework, it is actually more important for web2py users to show up and contribute to the discussion. Many web2py users have used Django (and other frameworks), but relatively fewer Django users have used web2py. As a result, there is lots of misinformation about web2py, and someone needs to correct that misinformation (this thread is a case in point). Many web2py users are also in the unique position of being able to directly compare the two frameworks based on personal experience with both. Of course, in some cases, at least some rough quantitative assessment is of interest. But in those cases, even a *failure* to inform a given community could lead to bias. For example, suppose that Flask users are over-represented on reddit relative to their real-world numbers and web2py users are under-represented. If neither community is informed of a given reddit post, then reddit has a built-in bias in favor of Flask (this is just an example -- I'm not suggesting it does). The point is, if your goal is to get a representative sample of responses from each community, reddit ain't for you. And as I pointed out already, even if web2py users occasionally show up in somewhat disproportionate numbers, that still tells us something -- it tells us that web2py has an active community of users that are jazzed about web2py and eager to share their enthusiasm. This is useful to know.
&gt;However, it's not a good sign when someone registered Reddit just to advocate web2py. That add nothing to the community... Sorry, but could you please provide some justification for this draconian norm you are trying to impose? Why on earth would it be inappropriate for a web2py user to register at reddit just to comment about web2py? Suppose I'm a web2py user who is not a registered reddit user. I become aware of a reddit thread relevant to web2py, and I want to share my knowledge. Shouldn't the reddit community *want* me to register and join in the discussion if I have something useful to contribute? How does that "add nothing to the community"? If I were posting a question on reddit and some nice web2py users were good enough to take their time to register on reddit and provide me with some information, I'd be grateful. Who cares if a given web2py user only makes reddit posts that are related to web2py? As long as those posts are useful in some way, the reddit community is benefiting. Why the mandate for intra-user diversity in posting topics? Also, note that your Redditquette quote is not relevant in this context. The quote you cite recommends against sending messages asking people to **vote** for your own submission. I'm not aware of any cases where a message has been posted to the web2py list requesting this kind of activity, and no one is advocating this behavior. 
On the other hand, there is [nevow](http://divmod.org/trac/wiki/DivmodNevow), which is an actual asynchronous web framework built upon Twisted.
&gt;The weirdness of imports is high on the list, and really gluon.import_all in general. OK, got it -- this has been covered &gt;There is also heavy duplication between gluon.sql and gluon.dal. As far as I know, gluon.dal is an experimental re-write of gluon.sql, not a duplication. I believe the framework currently uses gluon.sql, though you can explicitly import and use gluon.dal (though not generally recommended because it is still being worked on). So let's scratch that off the list of "abnormalities" (though perhaps dal.py should include a comment explaining its current status). &gt;web2py is really aimed at being a DSL for web apps in my mind. That doesn't mean it is bad at what it does, but it isn't trying to adhere to "Python standards", instead it does what is best for its very narrow target environment. I'm not sure I get this. Yes, web2py is designed primarily for the development of web applications (though apparently it can also be used to [control home automation systems and robots](http://groups.google.com/group/web2py/browse_frm/thread/c8b1970c7ec50b42/)), but aren't all the Python web frameworks? Isn't that why we call them *web* frameworks? I don't get how web2py is aimed at being a DSL any more so than any other framework, and I'm still not seeing the specific deviations from "Python standards" (other than the import issue noted above). And are you saying that "web apps" is a "narrow target environment," or that web2py has chosen to focus on a narrow aspect of web app development (in which case, how so -- i.e., how does it differ from, say, Django in that regard)? Thanks.
Oh I completely agree. And django still has some way to go to be more developer-friendly with their modularity of apps. Hell even their contrib.auth included app right now isn't nearly flexible enough, so I always end up monkey-patching any django update myself. But if you know what you're doing and you're willing to put in that extra effort to develop your code "correctly," the payoff is huge.
Thanks ! It works great, exactly as described in your documentation :-) Somehow I read it as either run example.py, or run mincemeat.py. My bad. That'll teach me for pulling too many all-nighters. Again, thanks for creating and sharing some very cool Python code - this will come in way handy for several different problems we want to express using the MapReduce paradigm. 
Could you please give an example where you used web2py and it came in way , that you were not able to go that 20% ahead... Would be great to know!
uhm, fnmatch on files should do a better job than glob on root+pattern
I somehow didn't know about either module. For simple examples like the above (which are typically all I've ever needed), surely os.path.splitext is more efficient. fnmatch looks nicer, though.
i suppose the following does pretty good: import os import fnmatch def rglob(file_pattern, walk_root='.'): for root, dirs, files in os.walk(walk_root): for item in fnmatch.filter(files, file_pattern): yield os.path.join(root, item) 
One problem is that you don't have control of all loggers. A library that supports logging will create its own logger instances, but you want your handler to receive their log entries as well. This can work with logging when all loggers inherit from the same root, but now add threads in the mix -- e.g. you want to handle log entries in one thread differently.
I was expecting a reference to hard liquor, blood pressure tablets or the patience of a saint instead of this, but I certainly recognise the pattern so I guess you're right.
Though since a factory behaves differently it's good to know it's a factory.
Let me pimp PyFilesystem... from fs.osfs import OSFS for text_file in OSFS('.').walkfiles(wildcard="*.txt"): print text_file
&gt; doesn't contain any licensing information. From the page: &gt; Code license: New BSD License The source package should contain the license file just to be redundantly explicit, but I really hate it when every source file is cluttered with a page-long copyright notice and license at the top. I'm sure Eben Moglen recommends that, but it doesn't really seem necessary for any practical purpose. Maybe it's a little extra ammunition if you intend on suing infringers.
&gt; I even like Mitsuhiko although he used to hang around the web2py IRC channel for the sole purpose of turning away new users. Slow down buddy. If you recall I went to your mailinglist explaining in a lengthy mail *why* I don't like web2py. That was my attempt of valid criticism and every single point in that mail was turned down because you thought it was either invalid or can't be fixed because of backwards compatibility if I remember correctly. I was on your IRC Channel *once* and trying to figure out why people like web2py. For the same reason I was in the Sahana IRC channel today and asked them why they went with web2py and how there experiences were. And that mainly because of my continued amazement that people see value in web2py. I just don't get it. &gt; By the way did you notice this was a thread about web2py and Django and it was hijacked by Flask. How was it hijacked by Flask? Someone brought up Flask, the someone else did to and in a subdiscussion was mentioned a few times. Nowhere did any of the Flask developers endorse Flask here. However I do remember that you used to (still do?) send links to any framework discussion to the mailinglist to encourage people to bring web2py into play. It also used to be the case that whenever there was a discussion about anything Python beginner or Python web related on reddit you chimed in and pointed people to web2py. So please don't accuse others of hijacking threads when this is exactly what you used to do (and maybe still do, stopped reading pyddit posts about web stuff). Saying that I have no problem with you personally would be wrong, because of your aggressive marketing, but my main point of criticism is not you as a person, but the abysmal quality of the code and the horrible design decisions in web2py.
&gt; Sorry, but could you please provide some justification for this draconian norm you are trying to impose? Why on earth would it be inappropriate for a web2py user to register at reddit just to comment about web2py? Because there is a much higher number of users on reddit endorsing than there are users actively endorsing django. But if you compare actual users that percentages are totally off. I don't know anyone in the django project that would go down to this level to join a random website to defend django. The core developers are very careful to stay away from such discussions and people close to the development try to do that as well. In fact I only remember me, Alex, Eric Florenzano and Mike Malone to ever discuss web2py, mainly because of our puzzlement and the cheap early marketing on reddit. The rest just sees web2py as some obscure not worth discussing in the hope it just silently stops to exist. &gt; I'm not aware of any cases where a message has been posted to the web2py list requesting this kind of activity, and no one is advocating this behavior. [very close](http://groups.google.com/group/web2py/browse_thread/thread/39816e2ae01044f7/923e9031fd47b43b) though. And between "comment on this thread" and "vote on this thread" there is not too much difference, is there?
This is awesome. Thank you.
Last update, unless anyone wants something specific run. After 1000 runs with 10000 txt files and 10000 gifs in the folder, here's the benchmark data for selecting txt files: Mean times (lowest to highest): 0.571212545872 fnmatch 0.573820468426 re 0.575973806381 regex 0.589467546463 glob 1.18652337384 fs 1.78959922075 py Standard deviation of times (lowest to highest): 0.004101934 re 0.004779786 glob 0.006003937 fnmatch 0.006627980 regex 0.007518412 fs 0.009220249 py Fnmatch, re, regex, and glob are practically the same in terms of time, with re and glob being the least variant, followed by fnmatch and regex. **Notes** Speed isn't everything; see the conversation below, but willm's fs surely wins for beauty, modular features, etc. Using trunk of pyfilesystem per willm's suggestion. My functions use re/regex: import re # regex def rglob(file_pattern, walk_root='.'): rex = re.compile(file_pattern) for root, dirs, files in os.walk(walk_root): for item in files: if rex.match(item): yield os.path.join(root, item) rglob('.*\.txt$') edit: updates, comments, variance, formatting
Not that much better: http://www.reddit.com/r/Python/comments/de2xp/dae_need_this_in_a_lot_of_projects/c0zj813
That would make sense, there is an overhead in the additional functionality of PyFilesystem. In real terms it is negligible though. You re is not quite equivalent to a filename match. You may want to use the fnmatch module which can compile a wildcard in to an equivalent re. If you aren't using the FS trunk, I would be interested in knowing if your benchmark changes with the lastest code.
Yeah; plus speed here is not what is necessarily important. In terms of beautiful code, yours wins for sure. So your the author of pyfilesystem? Great to meet you; it's a really well done package. It's in my head to use on a few projects when I get to them. Btw, why is re not equivalent? 
Hope you find find it useful. More info here... http://willmcgugan.com/2010/6/20/pyfilesystem-03-released/ Your re matches "crazyfile.txt.jpg", whereas *.txt would not...
I'll test the trunk once I get to the office. Ahh, I'll add the $ ;)
&gt; I was on your IRC Channel once and trying to figure out why people like web2py. For the same reason I was in the Sahana IRC channel today and asked them why they went with web2py and how there experiences were. And that mainly because of my continued amazement that people see value in web2py. I just don't get it. No you do not. I do not frequent the Flask IRC channel or the Django IRC channel and intimidate other users with my provocative questions. I jump-in in reddit discussions when web2py is mentioned and something incorrect is stated.
Yup, good advice, but the thing is that nobody seems to agree *when* there is a need of separating words, or when you can just leave them together. Example: why `os.path.abspath()` is not `abs_path()`? Because you can just read it and not be confused about what it is, and you saved one keypress... sure, but... Good luck working with people that has English as a half-baked-second language (like me). Thats the good thing of Pascal/mixed/Case, its easier to follow: new word? -&gt; change case.
Thanks for all of the responses. This post got way more discussion than I was expecting, and you all bring up some good points. More PEP-8 for all!
You just made my morning: Fuse support!? Did you have this pre-0.3? I was planning to hack together something to make that work.
&gt; No you do not. I do not frequent the Flask IRC channel or the Django IRC channel and intimidate other users with my provocative questions. /whois mitsuhiko * [mitsuhiko] (~mitsuhiko@ubuntu/member/mitsuhiko): Armin Ronacher * [mitsuhiko] #pocoo #alfajor #python-dev ##c++ ##C ##OpenGL #blendercoders #blender ##pyhosting #macdev #ubuntuusers #django #bitbucket ##apple #trac #boost #reddit #django-cms #python.de #future-ll #github #pocoo-soc #pylons #vim #xapian @#pocoo-botfun ##java #commonjs #dominionpython #D ##javascript #colloquy #grml #pdxpython #mercurial #sqlalchemy #python-babel #ubuntuusers-webteam #ubuntuusers-team #django-dev #lincolnloop #discorporate #python-graz #django-social #djangocon #moin #python #mootools #jquery As you can see, I frequent most framework channels and multiple times did I recommend pylons or Django to other people. At the same time I also pointed people to Werkzeug when appropriate. I do not "intimidate other users with my provocative questions". I log every channel I participate in for personal reference, so if you can point me to a date and time (or something I can grep for) where i was intimidating other users, I can paste the text in question here for others to judge.
I agree with what you say and in fact that was the intention. You do not owe me a beer but I hope to visit Bangkok one day (it is on my todo list). The problem with quoting a thread in this case is that since the web2py list is a relatively small community (~2000) users, a thread does not always provide sufficient context. Moreover people do not always read the entire thread but just the message you point them to. I will continue to post links to web2py related news (reddit and non-reddit) since my users asked me to do so, but I will always add a disclaimer to my post of some kind. I will not explicitly ask members of my list to join reddit or any other online discussion site because it is none of my business.
&gt; I frequent most framework channels and multiple times did I recommend pylons or Django to other people. At the same time I also pointed people to Werkzeug when appropriate. I rest my case.
Fuse support went in at 0.3 Still somewhat experimental, but it looks solid so far.
Well, I didn't say the quickwiki tutorial was updated. I said Pylons 1.0 is documented, the link is: http://pylonshq.com/docs/en/1.0/ . The wiki still has older information, but that's not where you should look....if you're looking for the latest docs. Which are, at http://pylonshq.com/docs/en/1.0/ . Did I mention you need to click http://pylonshq.com/docs/en/1.0/ and not the old crap on the wiki ?
Yes it indeed is updated ..thanks for pointing that out!.. would you also know if there is a pdf format of the docs.. 0.9.7 had one... so this might also have one.. please let me know!..[EDIT-found it! the pdf of those docs are here.. just in case someone wants to know.. http://pylonshq.com/download/1.0/Pylons.pdf]!!! Thanks !
I love mechanize but I hate trying to understand it: The documentation is inadequate. Has anybody found or posted a collection of mecanize resources? Or any automatically generated docs? 
[Eric](http://eric-ide.python-projects.org/) looks worth trying out. [Komodo Edit](http://www.activestate.com/komodo-edit) is good. It appears that version 6 should be released soon (6.0.0c1 is currently available).
I like most of the advice in PEP-8, except for the bit about limiting code width to 80 characters. I haven't done that since the mid-80's and I have never had a problem. I typically limit myself to 120 characters, and even that I consider conservative. 
&gt;Because there is a much higher number of users on reddit endorsing than there are users actively endorsing django. Why do you assume this fact is non-informative to the reddit community? It may be an indicator that people who really try web2py and use it tend to love it and want to talk about it. And as I have already pointed out, because web2py is the lesser known framework, it is actually more important for web2py users to contribute in order to provide accurate information about the framework -- otherwise, it's left up to the web2py detractors, who naturally tend to mischaracterize web2py (and its community). &gt;But if you compare actual users that percentages are totally off. Yes, but why should the percentages be "on"? We're not talking about voting or statistical sampling here -- we're talking about providing information and opinions relevant to a posted topic. The more information, the better (I know *you* don't want to see more information about web2py, but I don't see why your desires should dictate the activities of web2py users). &gt;I don't know anyone in the django project that would go down to this level to join a random website to defend django. There are a lot of Django users (I'm assuming you don't know them all), so it's certainly possible that some of them have registered on reddit specifically to endorse/defend Django, even without your knowledge. Of course, even if such Django users exist, you still haven't explained what would be wrong with that. If a Django user becomes aware of a relevant reddit post and believes they have something to contribute, why shouldn't they sign up and join in? What's the downside? &gt;The core developers are very careful to stay away from such discussions and people close to the development try to do that as well. But we're not talking about web2py core developers. You are claiming that it is inappropriate for general members of the web2py community to (a) be informed of relevant reddit posts, and (b) subsequently join reddit in order to contribute their views (even if they do so of their own accord, without it having been suggested to them). True, Massimo (web2py core developer) does a fair amount of posting himself, but that is a separate issue. And as far as I can tell, Massimo's current practice is to post in various forums (such as reddit) only to (a) address a question directly relevant to web2py (such as this thread), or (b) correct misinformation about web2py (also in this thread). I can't imagine anyone would criticize a Django core developer for doing the same. Perhaps the Django core doesn't want (or more likely, need) to engage in such activity, but it certainly wouldn't be inappropriate for them to do so. And in light of your comment above, I don't understand why it's OK for the creator of an alternative web framework (Flask) to go out of his way to actively disparage web2py? If it's inappropriate for a core developer to advocate his own framework, surely it is even more inappropriate for a core developer to disparage an alternative framework. Is *that* something a Django core developer would do? Note, I'm not talking about your offering constructive criticism directly to web2py -- I'm talking about completely unsolicited anti-endorsements in public forums, often with a mean-spirited tone. For example, why did you think it was OK to enter this thread uninvited with "Why are people even considering using web2py..." (and then follow up with "web2py leads the bad design decisions competition")? The clear implication (particularly given the "even") is that you don't think it should be considered. Note, I actually have no problem with your posting this comment -- it's your opinion, you are entitled to it, and the reddit community deserves to hear different viewpoints. What I don't understand is an etiquette system that apparently makes this OK but prohibits Massimo from mentioning web2py (but not disparaging any other frameworks) in various forums where it is clearly relevant. Indeed, as far as I can tell, Massimo has always been quite gracious and good-natured, even in the face of attacks on his character. I suppose you think Massimo's advocacy is bad not because informing the public about a FOSS project is inherently wrong, but because you think web2py itself is bad and therefore should not exist in the public domain. And you probably think your own behavior is appropriate because you are doing a public service by helping rid the world of "bad" software. But that's not an appropriate basis for a general etiquette system. We can't say that advocating for a framework is OK as long as mitsuhiko likes the framework, and disparaging a framework is OK as long as he doesn't like it. The point is, I think you're holding the web2py community to a somewhat different standard because *you* don't want to hear from them. &gt;In fact I only remember me, Alex, Eric Florenzano and Mike Malone to ever discuss web2py, mainly because of our puzzlement and the cheap early marketing on reddit. The rest just sees web2py as some obscure not worth discussing in the hope it just silently stops to exist. This makes my point about the importance of web2py users contributing to reddit -- otherwise, it is left to people who are "puzzled" and want web2py to stop existing (surely not a recipe for objective analysis). &gt;very close though. And between "comment on this thread" and "vote on this thread" there is not too much difference, is there? First, there is an important difference between "comment on this thread" and "vote on this *particular* comment/post". The former invites people who might have something relevant to contribute to the conversation to do so (in whatever way they choose), and the latter invites people who might not otherwise be interested to "help out" with a vote. But the example you cite didn't even ask users to comment on the particular thread -- it was a general call for web2py users to contribute to discussions relevant to web2py, as explained [here](http://groups.google.com/group/web2py/msg/e542e8dd052a4510) (furthermore, this has already been pointed out to you). 
for completeness you might want to compare to py.path import py for p in py.path.local().visit('*.txt'): print p.basename *edit* note that py.path has programmer efficiency more in mind than cpu efficiency
Will do.
&gt;Nowhere did any of the Flask developers endorse Flask here. Even worse, the very creator of Flask (you) posted an [unsolicited top-level comment](http://www.reddit.com/r/Python/comments/ddkal/django_vs_web2py_what_do_you_use_and_why/c0zewaf) disparaging an alternative framework (i.e., web2py). See further comment [here](http://www.reddit.com/r/Python/comments/ddkal/django_vs_web2py_what_do_you_use_and_why/c0zjnp2). [Note, *I* don't actually think the fact that you posted is inappropriate (though there are problems with the content of your post, as I [noted](http://www.reddit.com/r/Python/comments/ddkal/django_vs_web2py_what_do_you_use_and_why/c0zfsaz)), but *you* should consider it inappropriate by your own standards.]
&gt; I don't get it. In web2py, in addition to Python, all you need to learn is the web2py API, as you suggest. No. Learning the API of a Python library or framework would be learning functions and classes. Here you also have to learn the magic web2py performs which goes *against* what you learned of Python in the first place.
Then I really don't get it. Yes, technically there are other things to learn about web2py besides the API, but that's true of every framework, including Django. More important, there's really no difference between learning what you call "magic" in web2py and the alternative approach in Django. For example, in web2py, you learn that your models are automatically executed -- in Django, you learn where and how you need to import them. In both cases, you have to learn how the framework works and how to use it to build web applications, not just the API. If anything, this learning is easier with web2py, so I don't get your point.
&gt; I'm not talking about your offering constructive criticism directly [...] -- I'm talking about completely unsolicited anti-endorsements in public forums, often with a mean-spirited tone. That's just the way Armin is, I guess, and there's not much anyone can do about it. He's a very clever chap, and has created some good software which is (deservedly) well received. But he's so clever that from where he is, a lot of other people's work seems to him "broken by design" and he can't understand many of their (in his view) dumb design decisions. And because he's passionate about good design, he can't refrain from venting. I'm the maintainer of Python's stdlib logging package, and I've been on the receiving end of his bile too. He's never (as far as I remember) given any *specific*, *constructive* criticism about the functionality of logging, but he believes it's so unredeemably awful that he's even created an alternative logging library and promotes its use over stdlib logging. Perhaps there's nothing wrong with that (I certainly am not complacent about stdlib logging), but his relentless boosterism can be a bit off-putting. Not only does he routinely and unashamedly call his own work 'awesome' when it would be more appropriate to let *independent* users speak of its qualities, he also (less forgivably, in my view) resorts to presenting opinion as if it were fact, and telling half-truths about stdlib logging's performance and thread-safety, without responding to invitations to substantiate his claims or file bug reports if he's found problems. Still, the industry's not exactly short of clever, self-promoting people who could do with going to charm school ;-) &gt; far as I can tell, Massimo has always been quite gracious and good-natured, even in the face of attacks on his character. Agreed. From what I can see - whereas Armin is perhaps best described as [Ãœbermensch](http://en.wikipedia.org/wiki/%C3%9Cbermensch), Massimo seems to me to be more akin to [Mensch](http://en.wikipedia.org/wiki/Mensch).
Keep in mind that fnmatch is implemented using regexes (that are compiled and cached). And the glob module uses fnmatch. The biggest win that can be had here is probably by using `fnmatch.filter()`. In [this test](http://github.com/mackstann/htpicker/blob/master/experiments/fnmatch_vs_regex.py) it is much faster than plain fnmatch, or glob, or regexes.
There are three frameworks actively developed by Zope community: http://zope2.zope.org http://grok.zope.org http://bluebream.zope.org
PEP-8 needs to be amended to fix it's advice on sorting imports. &gt; Imports should be grouped in the following order: &gt; &gt; 1. standard library imports &gt; 2. related third party imports &gt; 3. local application/library specific imports This should read: &gt; Imports should be sorted alphabetically. Then I can finally get that "PEP-8 or die!" tattoo. 
With all due respect, but you have been doing a disservice to the Python community in general, since you have been bad-mouthing about Web2py everywhere for the last several years. Let me explain a few things for you. If I remember correctly, one of the reasons you badmouth about web2py is because sometimes Massimo made comparisons to Django that you and some others felt he was being negative about Django. Well, you are an author of a framework. And you have been proudly badmouthing everywhere about another framework with all of your "analysis" of why web2py is bad. From a personal perspective, you are below Massimo. "But Python can do so much better than that. For me web2py is to Python what PHP is to dynamic languages. Setting a real bad example." This is completely bullsh*t. Who gives you the authority to make such statements? You are a student (literally, the last I checked) who is criticizing a professor for "bad design". Have some humbleness, will you. With respect to Web2py.... I have 2 django books and I started with Django.... but just couldn't go through with it, before I got to web2py. There are many criteria that constitute what a "good" design is. I don't have the time to explain everything. And Web2py is by no means perfect. But it works for many people, including me. 
I'm not sure I understand the reason for alphabetic sorting. What makes you want that? I've always used the PEP-8 way to separate what's Python's, what's someone else's, and what's mine, and I like to have that separation/definition.
Let me get this straight -- you frequent dozens of IRC channels and "when appropriate" point people to your own framework?
&gt; This obviously makes passing around a global configuration more challenging...
flushes are slow, adding them will only slow down your output. I suspect redbo has the correct answer.
Alphabetical sorting for efficiency. I find it's easier to find an import in a list of imports when it's alphabetical. I know the name of the import, so I can scan down the list alphabetically. Efficiency because you can write an extension for your IDE/text editor that implements automatic alphabetical sorting of imports. I have one for my editor so that when I want to import a library I just write it inline in the code, then a keyboard shortcut will automagically shuttle that import to the top of the file and put it in the right place. It's a nice little feature. It also feels weird sorting imports into "my stuff, their stuff, those other guys stuff". 
Be warned, their solutions sometimes suck http://codingbat.com/prob/p170842 Their solution: def double_char(str): result = "" for i in range(len(str)): result += str[i] + str[i] return result While producing the desired result it is wrong in almost every conceivable way. def double_char(s): # you can directly iterate over strings, so you don't need to do array indexing return ''.join('%s%s' % (X, X) for X in s)
you're kidding right? find -name '*.txt'
I pick some limit around 100 mostly because after that 3way merges make me cry.
What, no love for web.py? Especially on reddit?
I guess I can see the efficiency standpoint, but I guess I'd combine that with the PEP-8 organization, making each section sorted. I think the general separation helps readability. Rather than scanning all 15 lines of imports, if I want to know what third party libraries some code uses, I know I can skip the first block since it would be stdlib stuff. (yeah, yeah, I know you are likely to know the dependencies up front, but pretend you don't)
Yeah, I feel like I must be missing something important here...
Kind of annoying in windows... even if I have gnuwin32 installed windows has it's own thing called 'find'. Also, I can never remember the parameters to do a grep on all those files too.
In windows this is app specific.
&gt;you just notice the bad reviews more, it's called confirmation bias. That's just not true. Typically, the negative "reviews" come from people with a very firm set of beliefs of what a framework should be. These guys never use web2py. Web2py has been getting bad raps, partly because of Massimo's aggressive approach to promoting it. It's a free, open source, so I don't have problems with it. And without that, might be web2py is never known at all. This is not a criticism of Massimo, but he's not really a PR person. The name, web2py (cube2py, etc.) are examples of this. These things deserve better names in my opinion. 
gluon.import_all is not used by web2py it is there to make sure that when we build binaries, py2exe packages all modules. In fact py2exe does not know what which modules are going to be used by web2py apps which are plugged in later into the executable, yet all modules have to be made available. In the spirit of cross-pollination, I have asked people like you who have complained about it to suggest for a better solution. I have not heard any. If you have one let me know. There is a lot of overlap between sql.py and dal.py because dal.py is a rewrite of sql.py. dal is not used by web2py but shipped with it so that developers can help test it.
Now, is someone willing to show the Tkinter equivalent? :-D
Well drat. Thanks for the info.
You don't deserve downvotes, that's exactly what I thought when I first read this
This showed up just in time. I just began my first crawling project for work and this has been fun to learn.
you're reinventing the wheel, even if you wanted this to be embed on a python script you could call subprocess and parse NUL-delimited fields out of `find` edit: but I agree on the cross-platform value, I always forget about dummy-OSes
&gt;Let me get this straight -- you frequent dozens of IRC channels and "when appropriate" point people to your own framework? Not in other channels.
Python is a language, not a religion. Perceptions of what a good design changes with time and requirements and priorities. A bad design is possible with a good language; a good design is possible with a bad language. Let me give you an example. A few years ago, when Django was new and shiny and looks very promising. I thought that because of the goodness of Python, Django would become what Drupal would be. And consequently would be better (because of Python), easier to learn, faster to develop. Guess what. After years, Django continues to be heavier and heavier as it adds more features. And now, my conclusion is, there's no benefit to choose Django over Drupal. It's as difficult to learn. And when Django is as powerful as Drupal, it'll be probably more difficult to learn and work with. Now the "purists" will say, why are you comparing frameworks and CMS, or why are you comparing a Python framework to a PHP CMS. The bottom line is these things are TOOLS not religions. Given a task at hand, the one that helps you deliver the applications for it in the best way wins. It doesn't matter if it's called Python or PHP or framework or CMS. The purists don't get this. Worse, they are stuck with a set of beliefs of what constitutes "good" designs, and spits at everything that deviates from their beliefs. The truth is pragmatists, when given a task at hand, they will choose the best tool for job. "Enthusiasts tend to be Python newbies who like web2py more than Django cause they get to type less. That should tell you something." If you spit out something like this, and at the same time, call web2py not "pythonic", there's something very wrong about it. Typing less is good. But the truth underneath this is that having an easy syntax/convention to work with is the virtue of Python. Python is about readability and writability. There is a virtue in not having to worry/think about syntax to construct an idea. In fact, this is what many people including myself experience with web2py. When we use web2py, we don't have to "look things up", at least not as much as other frameworks. "If you like Python because it tries to eschew magic in the cause of maintainability, then go with Django, Flask/Werkzeug or Pylons." Anything reasonably sophisticated is magic to those who don't know it. Python eschews "magic"? Do you get the "import antigravity" joke? Web2py is not maintainable? Have you written web2py apps? Web2py is supposed to be backward compatible since 2007. Upgrade to the latest version is 1 click. What's this about maintainability? 
Sorry, I was agreeing with you, saying I must be missing something important to understand why people needed this rewritten in python.
If I want to do something in python that demands a list(['a','b'...]) of those, then I'd prefer python over parsing string output from a subprocess. Especially so if it was a very long string. e.g. you want to supply your client with a python script that resizes all the jpeg files in a directory tree using PIL.
Btw jeffus, would you say this snippet has a place in glob.py or maybe shutil.py?
**EDIT:** Just read your question more thoroughly, and I'll bet you're already using 'start &lt;filename&gt;'. You could (if you're only launching one file type into one program), use the [subprocess module](http://docs.python.org/library/subprocess.html#replacing-the-os-spawn-family), specifically using the P_NOWAIT form, and then kill the previous PID before launching the next file. Prior ramblings follow. --- That being said, if the application can handle it, you can use the start command. For example, 'start readme.txt' will launch whatever program is associated with text files, and hand readme.txt off to it. For the default notepad.exe, it will launch a new instance, for notepad++, it should open it in a new tab (not certain, never tried). I think that COM is how you would do this to get the right result every time (i.e., convince that running instance of notepad.exe to close the file it currently has open and then open readme.txt). Essentially, you start a conversation with a running program and tell it to do things. Unfortunately, COM functionality is not required of every Windows program, so it's going to be hit or miss, assuming there even is a python COM library. Stick with 'start &lt;filename&gt;' 
He's using an `iter.__length_hint__` method... that doesn't look good. It will error out on generators, for example. Perhaps try that, and if the method doesn't work, use `len(list(iter))`?
or you know, pipe it.
&gt; I'm the maintainer of Python's stdlib logging package, and I've been on the receiving end of his bile too. He's never (as far as I remember) given any specific, constructive criticism about the functionality of logging, but he believes it's so unredeemably awful that he's even created an alternative logging library and promotes its use over stdlib logging. I explained more than once that the centralized registry of loggers does not work for me. Additionally I cannot depend on a specific version of Python so it currently has to work back to 2.5, so fixes in 3.2 to logging don't work out for me at all. &gt; Not only does he routinely and unashamedly call his own work 'awesome' when it would be more appropriate to let independent users speak of its qualities Only jokingly on the #pocoo IRC channel and in unittests :) &gt; telling half-truths about stdlib logging's performance and thread-safety Where did I do that? &gt; file bug reports if he's found problems. Will improve on that.
It's funny you mention that, as I just got done doing something very similar. There are two distinct steps -- one is to get the file list, the other is to resize the files. You can pipe the output of find to the python script, and read stdin from the python script. No long strings in memory is necessary. It would essentially amount to: find ./ -name '*.jpg' | python resizer.py Taking it one step further, you can do poor-mans parallel processing of the images by 'find'ing all the files, splitting the output to, say, 4 different files, and start 4 different parallel python processes. It sounds harder than it is, what it amounts to is: find ./ -name '*.jpg' &gt; files.txt wc -l files.txt # get number of lines in the file split -l 5000 files.txt tmp/ # assuming there are 20000 lines, this will split it into 4 files for i in `ls -1 tmp/`; do echo $i; (( cat tmp/$i | python resizer.py )&amp;); done and bam, instant parallelization. You could even write them up nicer if you were going to give it to a client.
In Mac OS X this is the default behavior - you can use the "open" command line tool for this: "open foo.html" -&gt; open foo.html in your default browser You can use subprocess module to run this command. You will have to implement this for each OS in a different way.
I think debian/ubuntu provides a "default-webbrowser" alias too.
Wow, I never noticed `difflib` before. Thanks!
I just gave Komodo IDE a try and it seems to fulfil most of my requirements -- even remote files (which I couldn't find support for in WingIDE), plus the license allows installing it on multiple OSes. I think Komodo Edit is good enough for my purposes, even. Although the git integration sure would be nice (though not worth $295 by itself). I don't think either version offers any refactoring (e.g. method/function extraction or variable/property renaming), though. While Eric seems quite powerful for the price (or lack of), the UI feels cluttered and unpolished (e.g. the file opening dialog allows browsing remote file systems, but opening a remote file fails with an error; the default file filter seems to be set to "batch files", clearing it doesn't result in the filter being disabled; the context menu is full of options that could have been hidden in one of the application menus; etc). Eric is probably a good choice if you can make use of the many unique features it offers, but to me it feels like using a swiss army knife when all I want is a fork. Also, I couldn't find any extraction/renaming functionality in Eric either, although at least it did highlight appearances of the selected variable within the context.
I know things can be done in bash scripts. I like making them myself as well. The problems start when things become long and complex. Your example in python: from rglob import rglob import resizer for picture_path in rglob('*.jpg'): resizer.resize(picture_path) In my opinion - this is something even the client can read and modify.
Perhaps some form of sorting could improve this a bit.
&gt;&gt;Let me get this straight -- you frequent dozens of IRC channels and "when appropriate" point people to your own framework? &gt;Not in other channels. OK, then you should be more careful in your writing. Still, it's an odd policy -- when you're in "other" channels and forums, you apparently shy away from promoting awareness of your own projects, but you're happy to disparage other projects. Maybe try the opposite for a while.
But if I do len(list(iter)) am not unrolling the whole generator?
&gt; does not work for me That's criticism, but it's neither *specific* nor *constructive*. For example, I've explained numerous ways in which you can get e.g. request-related information such as client IP into logs, even using a vanilla 2.4 Python (when thread locals were introduced), yet you seem oblivious. I can only conclude that your objections are aesthetic and not really functional. When you refer to fixes in 3.2 I assume you're referring to the lock acquisition in basicConfig. I stated on another Reddit post (relating to logbook) that this would only ever cause problems if you called basicConfig in multiple threads on a non-GIL platform - a perverse thing to do in any case. If I'm wrong please point out where. In terms of other additions to 3.2, if you mean QueueHandler, then that's not a fix but additional functionality, and you could have written a QueueHandler yourself and supported ZeroMQ, multiprocessing and plain queues using stdlib logging, all in 2.5. Obviously stuff in stdlib is there to be subclassed, and the logging.Handler class is readily sub-classable, but you've perhaps not tried because "logging is broken by design" so it can't be worth wasting your precious time on ;-) &gt; Only jokingly on the #pocoo IRC channel and in unittests :) And in the logbook documentation ("too cool for stdlib" etc.) and in slides you've presented at conferences ("Logging is not cool enough. But logbook is teh shit" etc.) &gt; Where did I do that? In logbook documentation: "Logbookâ€™s logging calls will be very cheap and provide a great performance improvement over the standard libraryâ€™s logging module." "Will be very cheap"? Right now logbook 0.2 seems around 10% slower in simple (non-scientific) tests that I did, and yet you boast about future performance. For shame! I'm sure you can go faster if you implement critical portions in C, and no doubt I could do the same for stdlib logging it was really necessary. You've never addressed the fact that when logging to file, stdlib logging calls are only a few **microseconds**. This is peanuts when compared with network latency, database access etc. in a typical web application request cycle. You've never brought up performance as a serious issue, say by showing some profiler output which shows that logging is a bottleneck in practice. Your logbook slides: "Why not logging? Not really suited for web applications. Unittesting is a pain. Logger registry causes problems when libraries start logging. Can't delete loggers." Logging works fine for me and others in Web applications, including putting request-specific stuff in logs. So you're stating an opinion as if it were fact. Unittesting could be a little better, but you haven't ever asked for any support with this, and not explained what you've tried and why it hasn't worked. Python stdlib unit tests cover logging too, where logging state needs to be restored on teardown. You haven't explained how libraries starting logging leads to problems; I haven't attended any of your talks and am just going by the slides. Perhaps you can expand on this a little more, and I will see if there is a fix for any problem you report. While it's true you can't delete loggers once created, you haven't explained why this is really a problem in practice. More logbook slides: "Why does nobody like logging? Bad default configuration for applications. Useless default configuration for libraries. Sometimes libraries call basicConfig. logging.warn() and friends are not threadsafe" You state an opinion ("nobody likes logging") as if it were fact. You mention bad/useless default configuration without ever having made a bug report, so what exactly is bad and/or useless, and aren't these more opinions dressed as fact? Libraries aren't supposed to do any logging config other than adding a NullHandler to their top-level logger, but if some third-party developer decides to go against this, how is that stdlib logging's fault? If the documentation isn't clear, please file a report saying where the problem is. On logging.warn() and friends not being thread safe, it's more FUD, and no bug report to show. Why are they unsafe? Is it the lock/release in basicConfig()? Why would you call basicConfig from multiple threads, when that's clearly not right? Even if you did, on CPython, given the GIL, when does this become a problem in practice? If you have uncovered other thread safety problems in logging, which is used by software which is in very wide use in the community (e.g. SQLAlchemy), shouldn't you report this saying where the logic error is which you've uncovered and which is leading to the lack of safety? What's the worst case scenario which would result from any thread safety lapse? &gt; Will improve on that. Well, you can start now by explaining/reporting why logging.warn() and friends are not thread-safe.
I don't think the policy is that odd. It's how I like other people to be I guess. I don't ever want to hear endorsements about people of their own stuff, but I am somewhat fine when I go into their development IRC channel. There I am expecting to hear that. I don't want to hear about django in #pylons for instance though, that's not what I came for. &gt; but you're happy to disparage other projects. And I encourage anyone to do the same if they have some reasons to do so. If someone would have told me earlier for some libraries I am/was using that they have certain issues, it would have solved me a lot of time and trouble.
&gt;&gt; you just notice the bad reviews more, it's called confirmation bias. &gt; That's just not true Well the part you quoted is true, it's how human brains work. But I assume you mean that there actually is a general reddit bias against web2py. I might be wrong but I honestly hadn't noticed any kind of bias against web2py and I read about python frameworks on reddit all the time. I happen to not like web2py as it's not in the style that I prefer, I suppose I have a pretty firm set of beliefs as to what a framework should be but only because I've used so many (and written so many) but if other people do want to use it I don't care. There are 3 different kinds of "bad" reviews I suppose. 1. I don't like the style/the way it organizes code/apps/etc or the conventions chosen 2. I think the framework is poorly made and/or buggy or a bad architecture 3. I'm uninformed but have some kind of ideological bias You guys seem to be saying that 3 is rampant but I haven't noticed it. Maybe that's because I don't care about web2py that much. It seems there is more of number 1 and a little of number 2 and 3
_difflib_ is cool, but it falls over if you want to compare files that are around 100 MB, as you need to read the files into memory. It does an in memory comparison of the files.
&gt; That's criticism, but it's neither specific nor constructive. I send you a mail today. Feel free to ask back if you need more. &gt; When you refer to fixes in 3.2 I assume you're referring to the lock acquisition in basicConfig. I stated on another Reddit post (relating to logbook) that this would only ever cause problems if you called basicConfig in multiple threads on a non-GIL platform - a perverse thing to do in any case. Or any method calling into basicConfig() such as logging.warning, logging.error etc. &gt; Handler class is readily sub-classable, but you've perhaps not tried because "logging is broken by design" so it can't be worth wasting your precious time on ;-) I wrote a couple of custom handlers for logging, Flask has one, there is a handler on pypi that logs to twitter, I wrote on that logs to trac and I even started a project on github that adds additional functionality to logging. So don't tell me I haven't tried. &gt; And in the logbook documentation ("too cool for stdlib" etc.) and in slides you've presented at conferences ("Logging is not cool enough. But logbook is teh shit" etc.) The first one should be taken that I don't like the stdlib in general, that has nothing to do with logging in there. I don't like the concept of a standard library for libraries that might change behavior over time such as logging currently does. Logging would be a library I would not keep in a standard library. The "Logging is not cool enough" on that screenshot was probably something that was not supposed to go on a slide on a presentation. But it was supposed to be taken as a joke. Just some other examples from the unittests that has similar humour: "Never gonna give you up", "Aha!", "Moar!", "Pure hate!", "Wuuu", "still awesome", "puzzled". Please don't hate me for failing at being funny. &gt; "Will be very cheap"? Right now logbook 0.2 seems around 10% slower in simple (non-scientific) tests that I did, and yet you boast about future performance. For shame! Performance of either logging or logbook is hard to measure because it depends a lot on the setup. Logbook becomes slower when you have a deeply nested stack and has a general overhead in terms of function calls and because it's using new-style string formatting. I am probably going to remove that from the documentation despite the fact that for the tests I have, logbook is in fact faster than logging from the stdlib. &gt; More logbook slides: "Why does nobody like logging? Bad default configuration for applications. Useless default configuration for libraries. Sometimes libraries call basicConfig. logging.warn() and friends are not threadsafe" None of these things here are wrong. The default configuration of logging is to not do logging. I don't know why that's the case, but there is probably a reason for it. Still it means that the defaults are something you have to change which is why not enough people use logging. &gt; You state an opinion ("nobody likes logging") as if it were fact. You mention bad/useless default configuration without ever having made a bug report, so what exactly is bad and/or useless, and aren't these more opinions dressed as fact? The bad default configuration is something that I have no problem with because I had my own wrapper module around logging that set it up like I wanted. For instance see how Flask uses logging currently. And I am perfectly fine with that, no issues at all besides the fact that this setup only works for *my* application and not a library my application might be using. That still goes to its dedicated logger setup. The "nobody likes logging" came from discussions with many people to find out why so few people are using logging. Unfortunately I can't point you to my blog right now because it's still offline, but I had an article on there why I encouraged people to use logging more and I got all kinds of bad replies there that logging was slow, to hard to use and often misused. &gt; Libraries aren't supposed to do any logging config other than adding a NullHandler to their top-level logger, but if some third-party developer decides to go against this, how is that stdlib logging's fault? I don't know a setup of logging that would work out for me. But maybe you do and could share. Say I am a library called by anyone and use three or five loggers without any handlers. Now in the same Python process are two different web applications, each independently but using the same library. How can each of these applications have their own log where all logging messages from that library are redirected to the correct one of these application's log files (the correct one is the one where all calls were issued by the same handling thread) including additional information such as current IP and HTTP request method. I tried, I failed. &gt; On logging.warn() and friends not being thread safe, it's more FUD, and no bug report to show. I will file bug reports for these if you want me to. It just means more work for me which I so far postponed. &gt; Well, you can start now by explaining/reporting why logging.warn() and friends are not thread-safe. Because it's not locking. Simple answer. Proof by experiment: http://paste.pocoo.org/show/262601/ Results: mitsuhiko@nausicaa:/tmp$ python test.py Handlers found: [&lt;logging.StreamHandler object at 0x100638f90&gt;, &lt;logging.StreamHandler object at 0x100654150&gt;]
May just be me, but that doesn't seem very Pythonic.
upboat
What I was thinking about but didn't make a good attempt at saying are two things: 1. Someone has already done it better 2. Someone has already done it faster 3. Abstraction goes further than the language, and taking advantage of things already done for you is usually much more pleasant. take your example vs the find alternative (I replaced your 'resizer' with a simple print): josh-bc-work:tmp$ time python yourscript.py &gt; /dev/null real 0m1.242s user 0m0.711s sys 0m0.526s josh-bc-work:tmp$ time find ./ -name '*.jpg' &gt; /dev/null real 0m0.086s user 0m0.027s sys 0m0.059s Wow, faster much? If your point is code re-use, then reuse it! I guarantee others have already solved this problem, as it's a standard language feature in many programming languages (and there is already a library, as is pointed out by willm). &gt; DAE need this in a lot of projects? I think the answer is no. Don't get me wrong, I think it's great that you're making stuff with the idea of sharing it with the community, and you should keep doing that, but pick and choose what you share. Doing stuff like this does help your understanding of how many higher-level frameworks and libraries work, and this could be a part of a larger library (such as pyfilesystem), but just doesn't seem like something noteworthy. We all know there are ways to put together code in a way to get what you want, and there are frameworks out there that have already done many common tasks, but what you posted has already been done many many times. There are essentially two kinds of posts that are worthwhile: 1. When you create a framework/library that makes an otherwise tedious task very easy (such as PyFilesystem) 2. When you analyze different options already available (many times as a core part of the language), provide analysis of those options, and make a suggestion of what to use when. (such as jeffus did) At any rate, this isn't an argument I'm going to win (and I didn't want to make it an argument in the first place), I just wanted to point out that there are other, better options depending on what you actually want to do.
Yes... you are, but that's the only way to find the length of a generator. And the progress bar *must* know how long it has to go to give an accurate length, right?
&gt;I don't ever want to hear endorsements about people of their own stuff. When you created Flask, you must have told *somebody* about it, right? Open source software is written to be shared, so the creator always has to do something to establish awareness. The issue at hand is exactly what manner of awareness promotion is appropriate. Opinions on that will differ. Your problem is that you don't seem to believe opinions on that should differ. It's fine if *you* don't ever want to suggest your own projects in any public forum outside your own IRCs and mailing lists (a little weird, but OK). It's not fine to harass *other people* who don't share your opinion regarding this severe restriction. Do your thing, and let others be. Note, your attitude about software promotion parallels your attitude about software design. You have strong opinions about software design, and you seem to think any deviation from your opinion gives you license to drive the deviants out of existence. Chill out a bit. Just because *you* don't understand why some people like something doesn't mean you have to eliminate that thing. &gt;&gt;but you're happy to disparage other projects. &gt;And I encourage anyone to do the same if they have some reasons to do so. But when is there a good reason to be rude? No one is saying you can't contribute some polite critiques -- but that's not what you do. May I recommend the following -- the next time you type out a post about web2py, before submitting, replace every occurrence of "web2py" with "Flask", and imagine it was written by Massimo. Then ask yourself if you would consider the post to be a polite and appropriate way of communicating criticism. This will help if you actually want people to listen to you instead of simply dismiss you as an arrogant ranter. I suspect you often have valuable insights to contribute, but your presentation makes it very hard to take you seriously.
&gt; I remember (though I cannot find a reference) reading that Guido uses 4-space indentation for public code and 2-space for Google code (or vice versa) for obvious reasons. That might have been before Google imposed a corporate standard. The point is, even Guido recognized that rules are meant to be broken. Google always had a 2 space indentation rule. Guido just followed that.
They have Python for longer than PEP8 I suppose. Some of their public stuff does use PEP 8.
No, it's not just an "aesthetic matter". Who in their right mind would inject exec/eval with anything containing user input AND THEN attempt to feed it to us like it's anything but a horrible shortcut? You might take a look at RestrictedPython. Also, 'tainting'.
&gt; When you created Flask, you must have told somebody about it, right? On my twitter feed and on a mailinglist if I remember correctly. And something very similar with an April's fool joke where I made fun of the way how people advertise open source software. But certainly not by actively stepping into every discussion on reddit and throwing in "use Flask" :) &gt; You have strong opinions about software design, and you seem to think any deviation from your opinion gives you license to drive the deviants out of existence. I respect people with strong opinions when there can be a dialog. I am open to criticism on my projects and just wish Massimo would be too. That just does not seem to be the case. &gt; This will help if you actually want people to listen to you instead of simply dismiss you as an arrogant ranter. I don't have myself under control when it comes to web2py, I give you that.
I had not started using 'start &lt;filename&gt;' yet. Instead, I had given up in despair. Thanks for this information! It gives me some leads to investigate.
A number of comments here have criticized web2py for some apparent deviations from "normal" Python style. Everyone seems to know "Explicit is better than implicit," but may I call attention to one of the lesser quoted [Zen of Python](http://www.python.org/dev/peps/pep-0020/) aphorisms: "Although practicality beats purity."
Thanks. I'm going to look into the subprocess module to see what I can work out. The program is Maya, and I'm on Windows XP. Any call to open its native, binary, *.mb files spawns a new Maya. I'd like to give the user options from certain places, like in our versioner or build tools to launch the original Maya file from the exported one. I can do it now, but it always makes a spawns a new Maya to load the file into, and it's a pretty heavy application. It can fill up RAM pretty quickly launching a handful of them in a busy editing session making small changes to many files quickly. There may be a way to communicate through Maya directly and tell it to run a MEL script or plugin that handles figuring out what to load. I'll look into that, too. Thanks again!
First published PEP that describes a WSGI-like implementation for Python3.
If not, something like it. I can run an html file from the command line and Firefox will handle opening it up.
Yes, but some generators do know how long they will be. I need to think this a bit more. In any case, for most situations unrolling the generator is not terrible (but not very nice either).
You have been misled. In web2py exec is not used for user input. It is used to execute application code. Think of it like this... you have the hardware layer, the os layer, the interpreter layer (python), and the application layer (executed by python). While all other frameworks are linked to the web applications via import, i.e. the web app and the framework belong to the same layer interpreted by python. In web2py the framework and the applications are two distinct layers (the framework executes the application). This is is by design. This allows hot swap and plug and play of applications and their components. This allows meta-programming techniques (code that writes other code at runtime). This already allows web2py to do lots of cool thing and will allow to do more in the future. I am not going to say more because most people have not yet grasped the basics of the idea. Most people have not even tried it. I know RestrictedPython but this has nothing to do with it. We have no interest in restricting what executed applications can do (compatibly with the permissions granted to the user running the framework).
Really? Generators that know how long they are? Can you give me an example? I mean, I don't see how you can get the length out of even a simple function with a predetermined length such as def f(): for x in range(10): yield x The length is predetermined, but I don't see how it could be found by the computer without running the code...
Great to see some movement on this, Armin, Jesse, and I spent a lot of time at DjangoCon discussing issues in this space, I'm super relieved to see Armin and Chris have taken the issue by the horns.
There's a whole lot of bad "reviews" because these "reviewers" don't like Massimo or his style. Period. Difference in style, organization and conventions does not mean bad design. So #1 isn't justified. There's no concrete evidence for #2 against web2py in terms of "poorly made" or "buggy". In terms of "architecture", the reasons against web2py are very vague. The most important thing to note here is when you "review" something, perhaps it is expected that you review from the perspective of the users; not the perspective of a designer; especially when *users* ask for your opinions. Things that users care about, IMO are: + How easy is it to learn? + How easy is it to deploy? + How quickly can you use it to build apps? + How easy is it to upgrade to newer versions? + How flexible is it to build a variety of different applications? + What are the useful features it provides? + How stable is it? How scalable is it? + How much backward compatibility is it? The bad "reviews" hardly touched upon these. They have been about "good" designs, which are really subjective and restrictive to groupthink. As a user, what I care about is if web2py performs well in all of those dimensions. And indeed, there is no evidence that web2py is worse than other frameworks with respect to those dimensions. In fact, it excels in some. It's okay for you not to care about web2py; but when you make statements about it, such statements need to be fair and accurate. Otherwise, it's a disservice to the community. 
&gt;I might be wrong but I honestly hadn't noticed any kind of bias against web2py and I read about python frameworks on reddit all the time. You are very wrong. Armin -- the author of Flask -- has been attacking web2py for years, and the framework police at reddit never called him out on that. Massimo -- the author of web2py -- compared web2py and django (and he can be biased sometime, but still tries to compare not put down django) and people have been all over him.
No, a generator would never know how long it is, however some *iterators* do, for example `iter([1, 2, 3])`.
What always irritates me is that most discussion of new ideas of programming are often related to WEB and as I am not a WEB programmer, I can hardly use them in my own work however amazing they are.
Not sure what exactly you mean by "currently running instance", but generally what the user would expect is the same behavior as when double-clicking the file in the OSs file browser: On win32: os.startfile() On freedesktop compliant Linux desktops (GNOME, KDE, others) subprocess.Popen('xdg-open' ...) On darwin (os x): subprocess.Popen('open' ...) 
Well, some programs if you try to run them again just take you to the already-running instance of the program. Maya - the program I'm working with here - launches a new instance of itself which is entirely separate from the first one. I just wanted it to use the open one instead of opening up a whole second Maya. Say I double-click a Maya file, and I don't have Maya open. Maya will open and the file will open in it. That's normal. If I then double-click the same file, or another Maya file, it doesn't open in the current Maya. It opens a second copy of Maya up and opens the file in there. I'd like to be able to decide to have it instead try to open in the current Maya. I'll look into startfile and see if that does it. Thanks!
This is not a discussion of a new idea of programming. This is a new interface between Python and web servers because the preexisting one (WSGI) is considered broken on Python 3.
If you're not a WEB programmer, there's probably no reason you should care about this, it's just a way of describing a standard environment.
Needs better web service support too.
That PEP's from July though?
Perhaps that's when they started working on it? Or even last worked on it. Or maybe the discussions we had were orthogonal to the content but just were an impetus for a push forward (or even none of the above).
Well, the updated date is today, and I know jnoller was talking about this on python-dev today. Apparently the 3.2 release might wait for the new wsgi/web3. So I hope it is indeed still active.
I like it
generally speaking, no - JavaScript is the only language that runs in the browser there are options but they are non-standard. [skulpt](http://www.skulpt.org/) is one, also running IronPython in a Silverlight applet should be possible
&gt;I respect people with strong opinions when there can be a dialog. I am open to criticism on my projects and just wish Massimo would be too. That just does not seem to be the case. I've seen some exchanges between you and Massimo, including an extended discussion on the web2py mailing list. As far as I can tell, he has always been very open to engaging you in dialog and soliciting further details from you, and in a quite respectful and decent way (and he made at least one change in web2py as a result of your feedback). I don't know whether you are truly open to criticism, but from what I've seen, Massimo surely is. He regularly solicits feedback and ideas. Perhaps you think he's not open to criticism because you have failed to convince him of the merits of your positions on some issues. But failure to be convinced is not the same as lacking openness to criticism. Indeed, every time you fail to convince Massimo, by definition he has failed to convince you, but you wouldn't count that as a lack of openness on your part.
Am still waiting for you to point out that 20% you were talking about!.. 
If you get to try some of the frameworks mentioned and want to share with us your finding (what you chose to evaluate, why, what you discovered), it will be appreciated. Whatever you find we can learn from it.
&gt; unrolling the generator is not terrible Yes, it is pretty terrible. It defeats the entire purpose of using a generator in the first place.
http://www.diveintopython.org