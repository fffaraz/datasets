I strongly dislike the `subprocess.Popen` APIs; they are so unintuitive that I have to read the docs every time I want to use them.
Really, that's extremely sad to hear. 
&gt; Sorry, but how does that make any sense? It makes a lot of sense and is very useful. True is just a different name for "1" and False is just a different name for "0" in Python with a type information attached for a better repr. &gt; Addition on booleans is not something generally defined/common It is in Python. There is no such thing as "generally" in computer science. This is not math or theory, it's about if something is useful in practice. Bools that are useful for integer math are.
Why is that a WTF?
&gt; I was going to say, why don't you use types.NoneType You cannot create instances of NoneType objects.
The answer is quite simply backwards compatibility. 1 and 0 was used instead of True and False previously and code depended on the ability to perform numerical operations on those. [Item in HISTORY file](http://hg.python.org/cpython/file/31b18a0242ca/Misc/HISTORY#l5227)
The Python one has the advantage that it works with all iterable types without having to monkeypatch things.
Never. str.upper won't work on unicode strings, x.upper() will.
Not trying to be an ass, but this is just an example showing that the CLT appears to hold (in very specific circumstances, especially since there are no true random number generators). This is by no means a proof. Other than that, the code looks okay. 
A wave file will generate a soundwave frequency with a time axis. Any program which can convert that data to a numpy array?
"True or True" is True, and "True or False" is also True, but "1 + 1" is 2 (not 1), and "1 + 0" is 1. I'd say it's a pretty long stretch to say addition and "logical or" are related. For me, they're two different operators, acting on different, unrelated types.
I don't see how that's useful in any way. I've never (even a single time) done any arithmetic with booleans (I have roughly 10-12 years programming experience, of which something like 3 years with python). But, even if there is a case where this is useful and makes sense, I will still argue that general concepts in programming language come from theories in mathematics and computer-science, and that that is very necessary, to ensure the concepts we use make sense and have some degree of self-consistency. I would thus consider it more useful if my compiler/interpreter would give me an error if I were to try to add two booleans, rather than silently assume that "True" is the same thing as "1", and "False" is the same thing as "0" -- likely I didn't mean to do that, and there is some error in my code. If I want to add 1 and 0, that's what I do, I won't use a type I view as completely unrelated instead.
Do I have one? No, but that could make another interesting project.
&gt; I don't see how that's useful in any way. I've never (even a single time) done any arithmetic with booleans. Other people have, I do. For the rest: all I can say to that is that it has to be consistent with the general rules of the language. If you have a language like Java that raises exceptions left and right, sure. Python does not do that and encourages compact code. In that context math with bools is useful and it does not have any negative side effects.
I might be missing something, but I think it's a very BAD idea... Make your interfaces simple and uniform, e.g. return lists (or whatever is the most natural/efficient type). Someone who needs a tuple can TRIVIALLY do. result = tuple( generate_minor_triad( start)) at the point of call.
If you're not testing for the exact same image, you may want to look at SIFT or ORB key point matching, that is a much faster and more efficient way than comparing pixel by pixel in a screen.
I would agree with this if returnType weren't set to a default value. Eventually we could have return types as string, or something similar.
It's a bad idea to keep a library like that as then the library could be out of date. You should _never_ package 3rd party libraries in your software. Having people use easy_install (or similar) or even distributing an egg file with the package may be a better idea.
It's a WTF from theoretical standpoint. Basically you always look at the set of objects you have and the operations to perform on these objects. Suich an operation has typed inputs and typed outputs, its like "a natural number plus another natural number equals a natural number". Furthermore, since programming languages were initially invented and heavily shaped by mathematically influenced people, the boolean in programming languages is inspired by the mathematical boolean. This boolean has objects True and False (or however you name them) and operations such as and (of type "Boolean and Boolean results in Boolean") or not (of type "not Boolean results in Boolean"). The operations might be very minimal (just an and) or very practical (just about everything you want). Numbers are (for simplicity) inspired by the whole numbers, that is, zero, positive numbers and negative numbers. Thus, the objects are 0, sequences of digits and a minus sign followed by a sequence of digits. Operations are things like addition (A number plus a number results in a number) or multiplication (A number multiplied by a number is another number), and so on. Whatever you need. Given this foundation, strict typing mentalities (I am not implying anything bad or good here) argue that there is no operation "A boolean plus a boolean results in a number". It could be defined, but it would be very akward, because this operation would do a lot of things at once, and thus, there is the danger that you need to define dozens and dozens of operations to get all the things you want (the same problem exists with the basic operations of a type. You can get away with saying "nand is the only true boolean operation" and be done with it, or you can try to hunt down every single possible boolean operation peopel might ever need and define it, which is a lot of work). As such, a strong typing mentality would rather define a function "toInt" of type "toInt of a boolean is a number", and write "toInt(True) + toInt(False) == 2" (anyone thinking how much like haskell this looks?). This is a cleaner approach, because you can easily define toInt, and implement all the other operations based on this. In case you are wondering why there is such a fuzz about it: Basically, "True + False == 2" does the same thing as "toInt(True) + toInt(False) == 2". Python just hides the conversion from boolean to integer, making it an implicit conversion (opposed to the explicit conversion in the second version). However, consider C and expressions where you mix signed and unsigned integers. This opens the gates to hell, because this produces incredibly convoluted expressions which require tons and tons of context to understand due to exactly these implicit conversions. Something like "5 + x &lt; y - 3" cannot be understood without context.In order to understand this simple expression you suddenly need to look at (excluding over- and underflows): - the type 5 and 3 are parsed as - the variable type of x - the conversion rules in order to determine the result type of the expression "5 + x" - the type of y - the conversion rules in order to determine the result type of the expression "y - 5" - the conversion rules in order to realize how to compare the resulting types. That is a boatload of context, compared to something like "5 + toInt(x) &lt; y + 5". Here, the most context you will need is the toInt-function of x, in case you need to reason about it. However, the comparision mode and the boundaries are clear, if you know the integer type of the language. 
I suggest everyone in this thread go and read PEP285: http://www.python.org/dev/peps/pep-0285/
...but they are related. logical OR works like binary addition, and logical AND is multiplication
What if they upgrade your library to add a function I do not need, break backward compatibility and breaks my code? I only deliver code that works and it cannot depend on what third party do. I monitor updated dependencies and ship them only after I have tested them.
You can easily freeze your dependancy to a specific version of a lib.
The project's page has the full documentation http://packages.python.org/Flask-MongoAlchemy/
When trying to install, I'm getting an import error on `find_packages`: Traceback (most recent call last): File "setup.py", line 7, in &lt;module&gt; from distutils.core import setup , find_packages ImportError: cannot import name find_packages I've never seen that before, what does find_packages actually do and where does it come from?
Almost all of the "wtf" things in most programming languages are directly related to backward compatibility. Code that was written for previous versions of a language need to keep working, especially within major versions. Is this something they could have fixed in, say, python 3? Perhaps. Would it be worth the effort? It's hard to say. I can say that there are some hackish scenarios that make this useful. For instance, when doing weight testing for a bag of conditions, one can just sum the result of a number of function calls that return boolean values: weight = sum(map(lambda v: v(), bag_o_tests)) It's hackish, and there are arguably "better" ways to do it, but backwards compatibility doesn't just mean that "good" code has to keep working. It usually also means that "bad" code has to keep working, too.
I'm really interested in this kind of thing and want to learn more about Python, so I'll probably look into it. I'm also taking a class this semester on sonic user interfaces, maybe I'll be able to apply some of that to this.
You might want JS for this, there a re quite a few libraries that'll allow something like that. If you find something in py tho, let me know! 
you should be ashamed
Speak for yourself. I use python in windows all the time. Sometimes you just don't have a choice. Yes, the python-ing is better in linux/unix, but it ain't bad in Windows, either!
I wrote a really simple example that will do this. http://pastebin.com/8ZaC4SXH You can run it like so: $ ./get-tts-mp3.py --lang ko --sent "이명진 기자" Retrieving .mp3 for sentence: 이명진 기자 Saved to file: 이명진_기자.mp3
Try it with a sudo. This was implemented by another user - but I will open an issue about this. Thanks.
How about a newer version is already installed by the user and break my app? I like to package my app so that I do not care what the user has installed already and I do not want to ask them to do extra work. Of course it depends on the size of the library. I am making this point for a non-standard, one file, python module.
No, if a package requires root permissions to be imported something is wrong.
This is a concept you learn in a discrete mathematics course. AND and OR are functionally * and +, respectively. If false is 0 and true is anything but 0, think about the following conditions - bool1 &amp;&amp; bool2 The resulting statement is only true when both bools are true. 1*1 = 1 or 10*3 = 30 etc... The statement is false when any single value is false. 1*0 = 0 or 5*0 = 0 - bool1 || bool2 The statement is true when either of the bools are true. 1+1 = 2 or 1+0 = 1 etc... This is false only when both bools are false. 0+0 = 0 
thats a more pythonic way. i just replied what i could come up at that time.
The error comes across when trying to write to /Library/Python/2.7/site-packages. An issue has been created, so I'll have someone look at it. If you think you know, you can propose a solution [here](https://github.com/prezjordan/Melopy/issues/14).
thanks.
Please read the traceback I posted (it's only three lines...) The bug you linked to doesn't appear to be related to the one I'm experiencing. If you weren't the one that wrote the install script, you should contact whoever did write it and ask them to get rid of the references to `find_packages`
Will do, in the meantime - the examples will still work even if you don't run setup.py install. That's just for testing. You can still use the library to its full functionality
I don't. Having CPython set the standard for all other interpreters to be compared to frees implementation developers from the trouble of making language decisions. The PyPy developers (and also the Jython, IronPython, and Cython developers) get to spend their time making their implementation work right, and perform well, instead of nitpicking language details like the CPython developers do.
There's an excellent RSA module. Unfortunately, it's GPL. But, it gets the job done. http://stuvel.eu/rsa
Who ever said anything about making language decisions? The main version of Python needs to have JIT compiling...
That's a pretty naive position to take. Developers rarely have control over what platforms their code will be deployed to when it's not server-side code. Heck, within some organizations you can't even choose your server environment. Sometimes packaging everything up into an executable is just a great way to send your software through the red tape faster. When faced with the choice between writing for sub-optimal deployment environments that I have no control over, and sacking groceries, I'll write some Windows software. It pays better, and is generally more rewarding. 
Thanks for posting this, i have discover the slide [wsgi on python 3 from mitsuhiko](http://www.slideshare.net/mitsuhiko/wsgi-on-python-3) and this is really great ! 
Here is the full talk (45m video) http://www.youtube.com/watch?v=AYjPIMe0BhA
There are too many exposed options with odd interactions. I had to transition from the old popen to the new subprocess and wasted an entire day trying to get some relatively simple stuff implemented. I reviewed dozens of web pages - none describing exactly how to run a process, catch all the output as well as the return code.
How does this handle i/o buffers? The subprocess module is quite broken (in my opinion). Poll won't respond until you clean out the buffer. So whole concept of poll/communicate is useless.
I meant to use "they" as a non-gendered pronoun :)
Looks interesting, thanks.
[virtualenv](http://pypi.python.org/pypi/virtualenv). Just use it, it will save the world someday.
interesting but very biased (openly so) Aspen.IO : http://blag.whit537.org/2011/08/aspen-marching-to-different-drummer.html CherryPy deserves a lot more love too (IMHO)
Django is out? Most people I know who do Python professionally right now are using Django... (Personally, it's not really my thing... but to say it's out when it's used *everywhere* is pretty silly...)
This is a C stdio issue, the only way around it is pexpect on POSIX. I've had unworkaroundable issues with all Windows versions including winpexpect.
how do you solve the problem with extensions that are not provided compiled for your version? cygwin ?
Except it only works on ASCII-encoded bytestrings. I instead recommend [LEPL](http://www.acooke.org/lepl/) which, other than being a complete parser, includes [many standard matchers for things like quoted strings](http://www.acooke.org/lepl/matchers.html#more).
"micro-framework"
What is this "lolcat" command he piped the output of cowsay to? Did it make it all rainbow-pretty? WHERE DO I GET IT?!
Hey, I'm the author of beets. That one-song-at-a-time thing should not be happening. Feel free to get in touch via email (my email's on the beets homepage) and we can sort that out.
&gt;In that context math with bools is useful and it does not have any negative side effects. Except when you unintentionally use math with bools. If you don't know about this feature, then good luck finding that bug. The worst bugs are the ones that still compile and run.
It's naive to think that one OS is better because it allows the user to be free? Funny, but I thought freedom was a good thing. Besides which, if you're working somewhere that persecutes you for using the right tool for the job, why would you work there? Sacking groceries might be more rewarding than *that*. And certainly more rewarding than being chained to your software--in more ways than one.
You can lift the code from https://github.com/coderanger/pychef/blob/master/chef/rsa.py Just a very basic wrapper but it works for me.
Not to be a troll, but isn't that 13 lines of code to create what is essentially global variables? Don't you have a better way to pass these dependencies around to only the classes that need them? I understand that sometimes there are cross-cutting dependencies ("aspects") that are needed in a number of classes, and it can be tedious to pass those dependencies to every class, but there are ways to mitigate that tedium (worst case scenario: use a IoC framework like guice. That shouldn't be necessary though!). 
Why are ORMs out? Because it's a wiki-style program or because they are considered too heavy weight now?
there are no more pressing questions than this.
Why would you do that by accident? I mean seriously. I can make up a whole lot of scenarios where features of languages shoot you in the foot, but I never, ever had a problem with bools as integers in Python, Javascript, C, or C++. How would that even work by accident? I mean, what typo would create a situation where you do math with booleans that would hide a bug or make debugging hard?
He explains in the 45 min. talk that the web apps that he has developed for his telco job, ORMs are not needed or wanted. If he does need to use databases he prefers to use bare SQL statements. He also said SQLAlchemy would work for all if needed. This whole battle is seeing through his rose colored glasses but he is very open about the biases in his talk.
But you cannot get the output as a string but only get the exit code with check_call :)
&gt;The software is licensed under the Apache License, Version 2.0 
Nice talk. I'm really curious to know why he didn't include Webob + Routes, which is what I am using. Perhaps it's too much like glue and not a unified framework. RoutesMiddleware and webob.Request(environ) makes things so easy and simple for me.
https://github.com/kennethreitz/lolcat.git That took me about 30 seconds poking around the envoy author's github repository... 
no Tornado?
You don't need to use count+1 because I specifically start it at 1 in the call to enumerate(), this matches what your original code did (initialise it to 0 then increment before use, so in the inner block count starts at 1) You *could* use count+1 and just call enumerate(iterable), however this will work slower as the bytecode will have to find the current value of count and increment it each iteration, rather than just let enumerate start at 1 and set count to the value. The issue with timestr is real though ;)
Nice! Looks like he changed the license in a recent release. :)
Thanks to you and the OP or I wouldn't have found about LEPL!
pycogent handles ascii and prettier trees.
Ah I tried that and didn't find it! Where did you find it at? edit: oh it's actually another project of his.. haha. Alright n/m, and ty! :D
I think you want [`audiolab`](http://www.ar.media.kyoto-u.ac.jp/members/david/softwares/audiolab/sphinx/index.html)`.wavread`
Without even NumPy, this is going to be tearjerkingly slow. Here's an [alternate implementation/tutorial](http://deeplearning.net/tutorial/mlp.html) using NumPy and Theano.
That is not good, the book shouldn't suggest actually uploading example distribution to a real repository.
I don't see why pyramid is in the mega framework category. Here is the first app in the documentation: https://docs.pylonsproject.org/projects/pyramid/1.2/narr/firstapp.html#firstapp-chapter Also, I can follow the idea of trying to boil down the framework to the bare necessities but raw SQL seems a bit unrealistic when the sqlalchemy's sql layer is right there.
He is doing little web services, occasionally developing a form for them. He has an existing database(s) to query. ORM = Not useful Admin backend = Not useful If you just want to expose some database stuff as JSON over HTTP then a micro-framework is a pretty good idea. You don't have to learn/fight with the framework. Of course, django is much easier if you have a large newspaper website or whatever.
I agree with using sqlalchemy over raw sql. However, by having the framework not do any sql magic, it makes it that much easier to bring sqlalchemy in. Granted, you can ignore almost any feature you want to in a framework, but it's cleaner not to have in there in the first place. For example, you can use raw sql in sqlalchemy, but if all you're doing is raw sql, sqlalchemy may not be something you want to deal with.
`multiprocessing` is a standard library module - it has been on 3.x for years.
Wow! Great find. 
Glad to be of service :)
I'll look into it, thanks. 
Pyramid actually has no dependency at all on SQLAlchemy, FWIW. The "Also, ..." above was a separate thought entirely.
In Ruby it also works with all currently iterable types without monkeypatch.
Is CherryPy really still a **micro**framework?
I don't need nor want that. What is wrong with the subprocess module?
So everyone who wants to *run* a Python app should have to use virtualenv? I don't quite see how him using virtualenv helps him with what he wants to address.
oh that's awesome. cheers.
I was actually replying to the "Also, ..." portion of your thought. I'm pretty new to Python - actually, my last real programming was in 2003 under PHP and in Perl prior to that. I ended up working other areas and I'm currently getting back into programming some personal projects with Python. So I don't have any real opinion on Pyramid. I'm currently do a project with Flask and SQLAlchemy. I'm liking what I'm seeing. I will say that for someone getting into the language and relearning programming in general, a large framework like Django can be somewhat intimidating. For instance, I got the first iteration of my app going in flask using raw sql. Now that the proof of concept is working, I'm learning how to use sqlalchemy for managing the database. I can learn the components in individual steps. Flask was simple enough I was able to learn how to use it rather quickly. Once I had an ok handle on that, I am able to move towards learning the sqlalchemy db layer. When I did some attempts with Django before, it throws the web framework and db layer at you all at once. I liked how Flask stays out of my way. It creates an http server and routes the requests to my code. Pyramid may do the same, and from the video, it looks like Bottle takes it even further. 
Tornado is not wsgi compliant and it is not a micro framework.
Bad blood against GPL? 
I think it has to do because you can't make a proprietary application with the GPL. Some people in the Python community seem not to like it.
There is a problem that logging across remote (cloud) servers happens blocking I/O which can be a critical performance issue for some applications. It should implement asynchronous non-blocking logging facilities, and so I patched: &lt;https://github.com/sampsyo/loglet/pull/2&gt;. Thanks.
You work around the encoding issues by encoding to UTF8, using shlex and decoding back to unicode again. A little annoying but it does work.
see openhatch.org. it helps beginners start working on open source projects.
Where is the script?
Thats sort of the point of the GPL. You can make a commercial freedom application, if that is not enough for some people, well the GPL is in place to tell them fuck off rightfully.
[Bottle](http://bottlepy.org) is definitely easy to get into.
Only for the ASCII subset of UTF-8. &gt;&gt;&gt; len(u'€') 1 &gt;&gt;&gt; len(u'€'.encode('utf-8')) 3 There is no reliable way to work with encoded bytestrings without knowing the encoding, and shlex simply assumes ASCII.
just went through the code. i really like the way bottle handles things. for a long time django user, it's really refreshing to see that much done with a clear concise code. good job.
I've dabbled in Django, but it strikes me as a big framework for big sites. Bottle would probably drown in Django-style code, but likewise a Django user would struggle with a Bottle-sized site.
Then *why* include django? That was my point... 
well I think slide 21 pretty much sums it up. "Who's out? mega-frameworks: django, grok, pyramid......" so in a presentation that advertises itself as a survey of micro-frameworks, mega-frameworks are out by definition. pyramid is not a mega-framework, but it seems the author has some bias against zope-like tech. Not really a surprise though since most would rather reinvent the wheel rather than learn from it and leverage the good bits. 
&gt; Tornado is not wsgi compliant So? Working with Tornado's web server is much simpler than working with a wsgi-compliant framework. &gt; and it is not a micro framework. If the "framework" portion of Tornado isn't a micro-framework, neither is web.py, upon which Tornado is based.
I submitted the link and your git gist to /r/math, hope you don't mind: http://www.reddit.com/r/math/comments/jv9qd/a_beautiful_interactive_javascript_demo_and/
FWIW: If you have feedback of any sorts for Flask: we're listening and more than willing to discuss things :)
I don't mind at all - thanks!
Writing something using your wrapper, and it's working nicely \o/ https://gist.github.com/1176640 Jumping between pypy 1.5 and python 2.7 without issue. Performance seems perfectly reasonable (I've not compared it to PyOpenCL, but I can't imagine there is a noticeable amount of extra overhead)
Per mitsuhiko's comment, it seems like you'd have to add in a couple of other functions on the stack to accomodate unicode characters (e.g. having to do a lambda foo: foo.upper() as the first argument to map, which defeats most/all of the optimization), so this may break down/slow down in practice. But I'd forgotten this blog post, so thanks for the reminder
Actually Jacob and I both prefer to use pip+virtualenv now over buildout. You can obviously use buildout, but pip+virtualenv is a far nicer experience. 
Everything he has said here makes perfect sense. In order to correctly parse C++ code you basically need a full C++ compiler. What's more, you need the compiler to be the same compiler as the compiler you are actually using (due to differences in different C++ compiler parsing). This is one of the reasons I really approve of the approach that boost::python takes to python binding: It uses the built-in C++ knowledge of the type system and code structure that the compiler itself uses to bootstrap the binding code.
Check out the date of the last commit http://hg.python.org/cpython/file/2.7/Lib/shlex.py
This is definitely the way to learn SQLAlchemy. Start with the basics like having it manage your connections and write your own SQL. Then graduate to using the expression engine, then onto the fullblown ORM.
But building your import module, packaging, etc become a huge pain. I much prefer either ctypes or Cython/Pyrex myself.
You misspelled WSGI-- oh wait.
Having recently used SWIG, I was very much interested in the idea of being able to write a single definition file that produces bindings for a variety of languages. The first problem I encountered was that SWIG doesn't handle callbacks, but the library I was wrapping used callbacks. I figured this out, but it required some Python-specific typemaps. "No problem," I thought, "at least I can just write the callback stuff for each language, and SWIG will take care of the rest." However when I got to looking at Java and dealing with representing callbacks in listener objects, I went and learned a little about JNI and realized it wouldn't be so hard to just write the wrapper directly in JNI. Then I looked at other languages, and realized the number of corner cases I'd have to handle with SWIG for each language, and sort of threw up my hands... I also realized it might have been less work to use ctypes in the first place for Python. So in the end I have a SWIG binding which is Python-specific and a Java binding, and haven't really gotten around to thinking about other languages because I'm scared off by the idea of having to learn the ins and outs of _n_ runtime engines. I still think a multi-language binding generator is a great idea and would be immensely beneficial. However, SWIG doesn't go far enough, as it's too tied to C types. Higher-level languages require higher-level types. For instance, in a sort of Haskell-inspired way, in my SWIG binding I defined a "maybeFloat" typemap for functions that took a pointer to a float, where the pointer could be NULL. Then I just had to define a typemap that translated Python numbers to float and passed in its address, or translated `None` to NULL, or threw an exception otherwise. If higher-level typemaps like this can be used to describe the semantics of a C function _beyond the C semantics_ but instead cover the semantics of the target language, then perhaps this approach could work. The lack of callback support was a show-stopper for me, though, in terms of using SWIG for multiple languages.
I agree with the ctypes approach - you provide the linkage info by defining the interface between the library and python, you make it work. No huge expectations that the binding between one extremely complex system (C++) and another very complex system (python) should be easy or magical. If it's hard, it's hard, and you don't get to turn your problem into someone else's (and then complain that free software doesn't have any support for simple things like reading your mind :)
pyramid mailing list :]
If you were to write a new SWIG today, would it be a good idea to use clang instead of a custom parser?
I'd give http://careers.stackoverflow.com/ a try. You can view their answers to questions, if they are a Stack Exchange contributor, and get an idea about their abilities and communication skills.
If I might make a suggestion: Have a look at alternative deployment solutions. I had a closer look at buildout myself, but found Chef and Puppet much easier to use, even though I'm not the biggest Ruby fan. There is a great tutorial on [chef and django](http://www.opscode.com/blog/2011/05/23/deploy-django-cms-with-chef/) from opscode.
If it's a Python job, use the [Python Job Board](http://www.python.org/community/jobs/howto/). Be sure to follow the instructions there to ensure it gets posted promptly.
Would Faust work? http://faust.grame.fr/
It's mostly a marketing term, not as much a technical term. So sure. Why not.
No, it assumes 8 bit characters. Since non-ascii codepoints always have the high bit set when encoded as utf8 bytes and none of them are special characters to shlex (eg none are whitespace, quotes etc) you can do exactly as I said. (I do do it.)
Love this project. If you're on Windows, give it a shot.
&gt; I want my URLs to be organized like GAE, web.py and Tornado. http://flask.pocoo.org/docs/patterns/lazyloading/ &gt; I want my URLs to be mapped to their own classes like GAE, web.py and Tornado. http://flask.pocoo.org/docs/views/ &gt; If all of these are possible with Flask then ignore this comment :) Nothing ever gets ignored :)
I love C++, I really do. I think C++ is an amazing language. That being said, C++ is a horrible thing to use in a library. If I would want to write a library in C++ I would do it like zmq does and provide a C API from it. As such I would write a tool that automatically generates a C API/ABI from a C++ API and then automatically generate Python bindings for that via ctypes. And yes, clang would be the tool of choice for both parts.
10 hours ago?
Well, okay, I agree then that it does make sense. I'm still somewhat sceptical as for the practical use, though. A priori I would consider it much more useful if the compiler/interpreter would throw an exception when you do arithmetic with booleans, as I'm pretty sure 100% of the time I do arithmetic with booleans, I'm just doing it by accident. But I guess if other people find it useful...
Yep, seems like still under development so I don't get the "released in 1999" part. 
If you're an IronPython or other .Net language user, you should definitely check this out. while other glue libraries have been available, they've been flaky / not optimized. this is a "native" port of the libs to .Net.
If you actually look at the file log, you can see the last commit that actually affected functionality was in 2007. 
python-mode
I've created base buildout template for me (https://github.com/onjin/django-buildout-template). For new project I use it as base and edit for project specifics.
I wonder if the refactoring of NumPy and SciPy will help with getting them running on PyPy?
It would also be great if they get cython working on pypy. Then, we'll have JIT and still be able to code highly CPU intensive code in cython.
Aside from your desire to have classes-with-get-and-post-methods-on-them, this appears to be a simple change: @app.route('/login', methods=['GET']) def login_get(): show_the_login_form() @app.route('/login', methods=['POST']) def login_post(): do_the_login() Right?
www.odesk.com
I haven't looked at it yet, so I can't really comment, but it depends how it's structured. For example say there's an ArrayAdd function that does the pairwise addition of two arrays, that's not particularly useful for us, because we need to be able to introspect those types of operations properly, so for example ``numpy.sin(a + b) / c`` actually only allocates one final result array, no temporaries, and generates specialized machine code for that. On an exciting note, I merged dtype support into the PyPy numpy implementation today :)
"awesome" as in the source code is awesome ?
So I'm still a bit confused about the preferred method for interfacing with a C library. I have a fairly large Fortran library that also has an automatically generated C interface that I want to write a Python interface to, and probably rearrange everything to make it object oriented. Assuming I have no previous experience with any of these options but I can write C and Python, should I be doing this with an extension module in C (or Cython?), with ctypes, with SWIG, or with something else? And would the answer be different if I wanted to be able to use that module with PyPy in the future?
Epic post!!!!
Yes, but it still looks confusing. If you do this with classes, it looks clean. Well, it looks clean to me :)
That's surprising, Tornado can even be used as WSGI container([example](http://flask.pocoo.org/docs/deploying/others/)) and it's fairly easy to read Tornado's [source code](https://github.com/facebook/tornado). I would say *tornado.web* is fairly micro.
http://rguillebert.blogspot.com/ He's behind schedule (it's a google summer of code project), so I'm not sure if he'll be continuing with it, but I hope so.
So, I am not saying that this will definitely solve your problem, but you might take a look at f2py, which automatically generates and builds an extension module for Python directly from the Fortran sources. I have used it successfully in the past myself; in fact, when I did more scientific coding in Python I used it routinely to let me mix Python and Fortran code. Edit: f2py comes automatically as part of [numpy](http://numpy.scipy.org/)
It would be nice if they implemented the UI designer too, then it would be perfect!
You could do this yourself in a matter of minutes.
ctypes seems to be the preferred method these days. Bindings that rely on parsing header filers, like SWIG, holds the promise of doing much more work for you, giving you more time to sip Piña Coladas, but it rarely seems to work out that way in practice. Learning how to use ctypes is very easy, there is no black magic going on as all you're essentially doing is rewriting the same information that already exists in the C headers, but using a simple Python syntax. 
Is this an attempt at some sort of joke?
They were simply fans of Monty Python.
Also, you can't dynamically link to C++ API.
Building is a pain, particularly on Windows where you don't have a packager to deal with Boost for you, because Boost is an asshole. It's one of those problems you just need to solve once, though. (And take good notes.) I had a much better time of things after I decided to ditch bjam and use waf.
thank you for your replies! I was wondering which are the pros and cons of virtualenv+pip versus buildout... are there use cases when the last one is better? or it is just a matter of new versus old approach?
It works in safari contrary to the alert box
Its memory usage (540m in my Chrome) is almost the same as for full-featured (overbloated, Java-powered) IDE like PyCharm.
One of Flask's philosophies is also that it's helpful to use common sense :) Even before the introduction of the view class, getting routing to classes and per-method callbacks was less than 8 lines of code. You just have to use the tools provided appropriately.
Regarding writing libraries and plugins in C++.. I do like C++ for giving me features that save me time while developing. Foremost the STL (yay std::vector&lt;T&gt; and algorithms). I really don't want to implement and maintain these basic data structures myself, like you see in so many C programs. Another thing I love is being able to define interfaces via abstract classes. If I screw something up while i.e. doing heavy refactoring the compile just tells me. A real time saver. But what drives me nuts is when you compile a C++ plugin and the proprietary host program, written at least partly in C++ as well, crashes randomly all of the sudden. The reason: STL implementation/version mismatches. This happens even if you're using a C API provided by this C++ host. Debugging these issues is a nightmare, require deep knowledge and determination. Many of my colleagues aren't even C++ coders and it would be virtually impossible for them to handle these situation, let alone within a reasonable amount of time. I'm sure one can work around all these issues. Boost.org's unholy trend to have header only libraries is one way to solve this issue and make compile times binary sizes explode. The question is if it's worth the hassle. These days I still write i.e. python modules in C++ when I hit a bottleneck, since the code just flows out of my fingers. But when I know something will be used outside of my machine I rather sit down I learn how to write yet another C implementation of a basic data structure, knowing that my code will work just fine for the next 10 years.
Which is why a plugin API should limit itself to the C ABI. It's not hard to design a proper one :)
...This happens even if you're using a C API provided by this C++ host... Example: Matlab
Having a proper C API solves the issues for good, if the source of all parties is available. Then it be compiled with the same compiler or compatible compiler version. But this is the case for C++ API's as well. The main advantage of a proper C API, one that can be used via an C-FFI, is that it makes your stuff accessible for virtually all languages out there.
So does it run the python code server side or client side ?
Or better yet, PyPI should have a way to test/fake uploading packages, if it doesn't already. Of course as with everything, someone needs to actually implement it but just braindumping here.
Oh, I know. Let's go in a subreddit and insult them for negative karma!
What is it...?
Can you diagram the program? I find that 99% of my problems can be solved by looking to see what module acts as a 'control' module, and what modules can be further encapsulated. It sounds like you have a many-to-many relationship with your classes and this is causing confusion as to data flow. Maybe if we could take a look at the architecture we could help? As a side note, 'override' is a terrible name for that variable because it doesn't say anything about what you're overriding.
"survey the landscape to see what's best for **me**" Interesting to hear about what he's doing with HTTP. Right tool for the job at hand. 
I tried the exact same code using Python 3.2.1 with httplib2 0.6 and I didn't receive any errors. I tried to download 'http://www.reddit.com' without decoding the URL to bytes. Please attach a log which shows the exact errors you are receiving.
this kinds of questions I think are best asked on a python user list, or on stack overflow, but just to give you a tip for simple stuff urllib.request.urlopen is easier to use than httplib2. See also is request works on python 3 http://pypi.python.org/pypi/requests/0.6.1
But did you input the 'http://reddit.com' in the h.request function itself, or did you say something like URL = 'http://reddit.com' and then h.request(URL)? In any case, here's the entire code (at the bottom is the error as well): http://pastebin.com/7XZJrr5J FWIW, I'm using httplib2 0.7.1
I tried that as well, got the similar error message. DiveIntoPython3 said it was better to use httplib2. Also, I have already posted this on StackOverflow
If you're doing IronPython, you could do all of the GUI work in a C# project and import it from IronPython. Additionally, you could take the generated C# file and manually convert it to Python with relative ease if you want to take it and run with it from Python. For the most part you just have to switch stuff like `this.lbl = new System.Windows.Forms.Label();` to `self.lbl = System.Windows.Forms.Label()`, correct `float` literals, change up arrays from `new int[]{1,2,3}` to a `list`, etc. It's actually pretty easy - the necessary changes stick out like a sore thumb when you try to execute.
link?
I think urllib.request.urlretrieve does exactly what you want (and works with strings). If you keep getting that error, you should post the code you use to extract the url from the .JAD
Why is "Run" always greyed out?
First, here's a little snippet for parsing these JAD files: def jad_to_dict(lines): return dict(line.split(': ', 1) for line in lines if line) Note that files in Python are line iterators: with open('opera.jad') as file: jad = jad_to_dict(file) Now you can read it like a dict: jad['MIDlet-Jar-URL'] Next, I suggest you use urllib to get the JAR: from urllib.request import urlretrieve urlretrieve(jad['MIDlet-Jar-URL'], 'game.jar')
Its good to see you guys trying!
for django .. djangogigs.com
Hope that we as a community are able to pick this up. Have been doing some pyside and qml stuff and I feel this is one of the best frameworks for UI development on the python side as of now. I would hate to see this go waste at this juncture.
This is true, however, AFAIK urllib.request.urlretrievev is only for Python 2.x, or am I wrong?
Sorry: http://stackoverflow.com/questions/7243750/download-file-from-web-in-python-3
No, urlretrieve is very useful, why would they remove it?
Nokia is slated to end after this year.
Why does it want my google acc. ?
I'm also getting no errors, and I'm pretty sure you should indeed be using a string for the url, *not* a bytes object. Could it be that you're misattributing the cause of the error? Eg. the data that will come back will be a bytes object - could the error actually be attempting to pass **this** through to somewhere that expects a string? 
I'm also getting no errors, and I'm pretty sure you should indeed be using a string for the url, *not* a bytes object. Could it be that you're misattributing the cause of the error? Eg. the data that will come back will be a bytes object - could the error actually be attempting to pass **this** through to somewhere that expects a string? Could you post the full call stack of the exception you get?
Just continue using pyQt == GPL
These look excellent. I've just started getting into these packages so this is well timed for me. In particular, I have found the official matplotlib documentation a little confusing, whereas this looks much more thorough.
I found the matplotlib documentation to be pretty poor when you're getting started, but good once you have your head wrapped around a a few things.
I like [the page listing pros and cons of using C, Matlab, Python and so on when it comes to scientific computation.](http://scipy-lectures.github.com/intro/intro.html#why-python)
Don't know, but it isn't happening.
I use it as a base framework to build full blown web applications.
It's unclear from the documentation (and also because I don't know much about Scrapy), but is this distributed as in able to be distributed across multiple machines, or just multiple cores and processes? 
Web services that need to scale. I wrote one on an event-based micro-framework that scaled to hundreds of millions of hits per day on just a few machines. I didn't need an ORM, templating, or sessions. 
The var URL must be a str, not a byte. When you read a file, use the encoding parameter to get the good charset to decode. import httplib2 def read_from_jad(file,key): with open(file, encoding="utf-8") as file: for line in file: if line.startswith(key): return line.split(":",1)[1].strip() return "" def downloadFile(URL=None): h = httplib2.Http(".cache") resp, content = h.request(URL, "GET") #print(resp['content-type']) =&gt; the good encoding is here # you can use a regex to extract the charset return content.decode('utf-8') URL = read_from_jad('opera.jad',"MIDlet-Info-URL") + \ read_from_jad('opera.jad',"MIDlet-Jar-URL") print(URL) print(type(downloadFile(URL))) 
I'll be there, and speaking.
No thanks, not a fan.
Exactly the same code gave me the error I said. However, I've solved the problem using urllib.request.urlretrieve
Start with Eli Bendersky's [Pygame tutorial series](http://eli.thegreenplace.net/2008/12/13/writing-a-game-in-python-with-pygame-part-i/). Once you're done with that, check out my list of [Pygame bookmarks](http://www.delicious.com/bcorfman/pygame).
Thanks! I've already started reading [Beginning Game Development with Python and Pygame](http://www.amazon.com/Beginning-Game-Development-Python-Pygame/dp/1590598725), but those look interesting too.
You mean "generic functions" or "multiple dispatch"? 
Damn didn't realize that was going to be such a long talk. But it's a great discussion of frameworks I wouldn't look at otherwise.
 The error on your pastebin is about the type of URL. &gt;&gt;&gt; URL = "" &gt;&gt;&gt; URL = URL.encode('utf-8') &gt;&gt;&gt; type(URL) &lt;class 'bytes'&gt; The code i post before just works 
That's an OK book, as you can see from the reviews, mostly because he never develops a real game. You might find [this page](http://www.wiley.com/WileyCDA/WileyTitle/productCd-0470068221,descCd-DOWNLOAD.html) for [Game Programming: The L Line](http://www.amazon.com/Game-Programming-Line-Express-Learning/dp/0470068221) to be helpful too -- it has a series of PowerPoint slides that give a Pygame tutorial as well.
Using x**.5 will be slower than using sqrt(x), granted the difference will be quite small and if you are only doing a few calculations you will not notice a difference. 
To further clarify... the math.sqrt() function uses an optimized (read C) version of the square root function. This will only be noticeable when the function is iterated a few thousand times or if you are using very large numbers. That being said it also takes longer to transverse the math library namespace, so using &gt;from math import sqrt &gt;sqrt(x) will probably be faster than x**5, but &gt;import math &gt;math.sqrt(x) will probably be slower.
I assumed you were correct, because otherwise what's the point of math.sqrt()? But I tried the two and got a surprising result: ~ % python -m timeit -s 'from math import sqrt' 'sqrt(1000000)' 10000000 loops, best of 3: 0.126 usec per loop ~ % python -m timeit '1000000**0.5' 10000000 loops, best of 3: 0.025 usec per loop And even if we "level" the playing field by making the operator example do a function name lookup for each iteration, it's still faster: ~ % python -m timeit -s 'x=1000000;pow=x.__pow__' 'pow(0.5)' 10000000 loops, best of 3: 0.108 usec per loop (although obviously in reality you would just use the operator directly and benefit from its name-lookup time savings as well) edit: and how could I forget! `pow()` is a built-in function too! That's the fastest yet: ~ % python -m timeit -s 'pow(1000000, 0.5)' 100000000 loops, best of 3: 0.0162 usec per loop [Here](http://ubuntuforums.org/showthread.php?t=1444549) is some further discussion.
Just out of curiosity what do you think those things are? I've been working with matplotlib for quite a while and find that the documentation is good at telling me the options associated with things I already know how to do; however, I've never found it great at telling me things I don't know I don't know or easy to search for information on how to do something in particular. For those areas I spend most of my time carefully dissecting the (numerous excellent) examples to accomplish these tasks. 
Happy Reddit Birthday!
Very interesting, your post got me thinking... I found an old [stackoverflow article](http://stackoverflow.com/questions/327002/which-is-faster-in-python-x-5-or-math-sqrtx) that seems to confirm your findings. It also seems to depend on python version and OS.
Thanks, I was indeed trying to optimize since the function is called a lot of times, so you have all been very helpful!
Yeah, I'm doing the R vs Python/Numpy loop in my head for a class I'm taking on big data analysis for Atmo Sciences. I love and have experience with them both, but... yeah. Anything but MATLAB.
good subjective overview... knowing werkzeug and flask pretty well, made me want to take a closer look at bottle and pesto. especially the app.get() app.post() decorators are a good idea imho.
Not a fan of what? The license? AFAIK, the APIs are the same?
Sorry for the lack and unclear documentation didn't had time to improve it. With these scrapy's components (scheduler, item pipeline) the crawling and parsing can be done using many processes either in same host or different one, and the result scraped is pushed to redis in order to be consumed by multiple workers. [1] http://scrapy.org/
Thanks for that!
Thanks to this talk, pesto made its way onto my list of things to look into, eventually.
woot!
There's another possible reason for having different functions for the same mathematical operation beyond performance: accuracy. I'm too tired/lazy to actually give it a lot of thought or check for myself, but math.sqrt(), although slower, *might* have better convergence properties. Like I said, I'm not about to check, but I thought I'd raise the possibility, as I learned the hard way that not all algorithms are created equal.
These are great! Thank you for sharing those bookmarks. So much great stuff. I'm going to try PyGame out this weekend and give this a shot.
[math.hypot](http://docs.python.org/py3k/library/math.html#math.hypot) will do what you want, it computes the length of a vector from the origin.
As reading on PyPy's blog, most of the time the underlying C implement of some function like math.sqrt is slow because of the libary call. http://morepypy.blogspot.com/2011/08/pypy-is-faster-than-c-again-string.html I don't really sure this affected here, but sqrt should faster than pow/** (pow and ** should be the same) if you try PyPy or psyco which are using JIT.
Well, Dvorak maps 1-1 to the regular keyboard layout, so it would be pretty trivial to ingest a key log and convert it
There's discussion here about optimization and shaving about 0.1 usec per use of **0.5 over sqrt. 1) Seriously? You'd need to be calling this ten million times to shave a second off your execution time. If you're doing that much math and care about speed Python probably isn't the best choice. 2) What's the harm of importing math and calling sqrt? Seems more readable to me than **0.5. I read sqrt and think "oh, the code is performing a square root". I read **0.5 and think... shit, what is this doing? Think about the person who's going to be reading your code next instead of the machine that's going to be interpreting your code. Come back later if you really need to work on the execution speed and I *bet* that this time savings isn't going to be the first place you find an opportunity to optimize.
I'm not sure I completely understand, but how about: while True: try: subprocess.check_call(["python", "read_process_insert.py"]) except CalledProcessError: continue else: break
Timings on my machine: alex@alex-gaynor-laptop:~/projects/pypy$ python -S -mtimeit -s "x = 1231.0" "x ** .5" 10000000 loops, best of 3: 0.156 usec per loop alex@alex-gaynor-laptop:~/projects/pypy$ python -S -mtimeit -s "x = 1231.0" -s "from math import sqrt" "sqrt(x)" 10000000 loops, best of 3: 0.0642 usec per loop alex@alex-gaynor-laptop:~/projects/pypy$ alex@alex-gaynor-laptop:~/projects/pypy$ alex@alex-gaynor-laptop:~/projects/pypy$ ./pypy-c -S -mtimeit -s "x = 1231.0" "x ** .5" 10000000 loops, best of 3: 0.0915 usec per loop alex@alex-gaynor-laptop:~/projects/pypy$ ./pypy-c -S -mtimeit -s "x = 1231.0" -s "from math import sqrt" "sqrt(x)" 100000000 loops, best of 3: 0.00763 usec per loop 
It will also be more stable for large and small vectors.
The timings aren't valid for ``10000**0.5`` it is being constant folded: &gt;&gt;&gt; dis.dis(lambda: 100000**0.5) 1 0 LOAD_CONST 3 (316.22776601683796) 3 RETURN_VALUE 
You COULD do this, but our IronPython projects include an IronPython WPF project which has a designer and xaml support in the box. :-)
We did. If you install the IronPython support you get an IronPython WPF project type with a designer and full-fledged xaml support.
&gt; If you're doing that much math and care about speed NumPy is the best choice for Python. FTFY
Ah! Good catch.
Good point about code readability, but I don't think it's helpful to question the OP's wisdom in asking the quesiton. It should be accepted as first principles that a) the question pertains to python; and b) the question seeks to identify the differences between these two ways of performing the operation (accuracy, speed, portability are at least some of the factors).
It's interesting that you bring in pypy. I looked at it from the opposite direction (i.e. manual static typing instead of JITd code). In Cython using the `**` operator can massively boot performance (200-300 times or more). If you cdef the operands, Cython translates the operation to a call to C `pow`. Python's `__pow__` for float objects also uses libm `pow`, but of course it's buried behind all of the dynamic type checking of arguments and special case handling. The same applies to math.sqrt and math.pow. So if you think you might want to compile your code for a performance boost -- adding just a few cdefs -- then using the `**` operator might save you some time down the road. 
Click "New Window" under file on IDLE and put your code there. then run it. IDLE processes code 1 line at a time in most cases. It makes it easy to work out little bits of your code and make sure there is no problems.
Thanks. Glad to know that it is supposed to work that way. I was dreading trying to trouble shoot a setup issue.
I'm pretty sure it's the license.
The API is pretty much the same. Furthermore PyQt's more complete (e.g. AxWidget, by the way: awesome) and more mature. Also, I think it's a very fair license (don't forget that there are many years of work in it). The only issue with PyQt is that it's a one man show and therefore a bit risky if you have to rely on long term support.
I hope someone buys Qt from Nokia and continues MeeGo. Samsung? HTC? Intel? Anyone?
Really? I'm going to have to go digging for this. Thanks! Your work is very much appreciated. :)
You'd be best off avoiding the sqrt all together. If you're comparing this to another number, you should just square the other number instead.
Score one for the cross VM nature of ctypes!
It can be done the way you want: http://flask.pocoo.org/docs/views/#method-based-dispatching 
As has already been shown by other posters, sqrt is noticeably faster than \*\*, and many would also argue that it is more readable. That kind of leads to the question of why one would want to avoid sqrt. Why is this a goal for you? Is it because you know sqrt is slow? Is it because the math module said something mean? By the way, if you're writing e.g. a game and want stuff to to be reasonably fast, it's quite often possible to avoid the use of sqrt by simply doing calculations on distance squared. Say you're going to trigger an explosion that deals damage to everybody within a five meter radius. The obvious way to check if somebody is within radius would be: sqrt(dx*dx + dy*dy) &lt; 5 but the fast way would be (dx*dx + dy*dy) &lt; 5*5 Hope this helps.
Michael Foord's [Mock](http://www.voidspace.org.uk/python/mock/) library is the best in my experience. We use it actively on a few dozen projects within our company. It's frequently updated with new features and Michael is very receptive to feedback from users.
Ahh, I see. Thanks. :)
Well put ;)
Please refrain from posting programming-related questions here. This reddit is intended for Python-related news and articles. The correct place to post questions like this is r/learnpython. **EDIT**: After talking to the other mods, I take back my previous comment. Asking questions about Python is perfectly fine for this reddit. Sorry for the confusion! :)
So knew this was going to be the list-resize allocator. Presumably from the last time this was discussed in /r/python.
HP?
I for one would just be too lazy to write the line that imports sqrt. Easier to just write **0.5 instead.
As usual, the most precious resources and relevant factors are not the optimization and execution speed of your code (unless you are doing very heavy number lifting, which I guessed is not the case). Trying to shave off some milliseconds of execution time is a frivolous gain compared to the serious negative effects of doing this. By studying the question you are loosing precious time that could be better used advancing the project and, secondly, by using the "**" notation you are lowering the readability of your code. These things are much more important than CPU cycles.
I second that
You could try using the atexit module, which allows you to register a function that is called when your script exits. The documentation is here http://docs.python.org/library/atexit.html
I find this very interesting. But I wonder if there aren't some existing libraries for parsing dates and other quantitative information from text. It seems like a very common task. Does anyone know any projects or research on this topic?
The research task targeting dates goes back to the MUC-7 conference and remains a target for the CoNLL 2003 task. Both of these are well-established tasks in the Natural Language Processing (NLP) field. I widely used tool is the Stanford Named Entity Recognition system, it is not state-of-the-art research-wise but should work nicely. It is a part of the [Stanford CoreNLP tools](http://nlp.stanford.edu/software/corenlp.shtml). Although I hack tons of Python and am a Ph.D. student in NLP I am not too friendly towards NLTK ([old comment on the NLTK book by me](http://eli.thegreenplace.net/2009/08/28/book-review-natural-language-processing-with-python-by-bird-klein-loper/#comment-200763)). Still, I am **heavily** biased towards research so don't let me destroy any good application ideas. ;)
I should have added that I do end up using a library called [parsedatetime](http://code.google.com/p/parsedatetime/) once I have my DATE chunks. In order for parsedatetime to work right I need to only send it date/time related text, and it would bomb if I sent it the message body of the email I'm analyzing.
The question was "am I missing something?" Technically it appears that the math comes out the same and is faster. The thing that the OP is now missing is readability. I'd also note that I was commenting on the comments w.r.t. the discussion of optimization. I'm still unclear on why the OP sees the removing "import math" as a benefit.
disappointed T_T
I like mocker: http://labix.org/mocker
On PyPy ``__pow__`` also becomes a call to the stdlib ``pow`` function, on the other hand ``sqrt`` will become a single ASM instruction ``SQRTSD`` (plus a few to check for negatives and other error cases), very efficient :)
While this may not be enlightening, it does illustrate the problem with these microbench marks. Using sqrt: `real 0m36.668s` `user 0m0.000s` `sys 0m0.015s` Using **: `real 0m41.301s` `user 0m0.000s` `sys 0m0.000s` This is using cygwin, and time. 
This is very interesting, thank you. I'm just getting confortable with the language so I mainly write little games, and performance is much more of an issue in Python than in compiled languages when these little games get scaled up a bit. Long story short: I tought that the less you import in a Python program the better, am I wrong?
That looks like a great idea, but maybe you should start some post, because it feels really empty for now.
From another comment i replied to: "Long story short: I tought that the less you import in a Python program the better, am I wrong?"
Neat, thanks... does anybody know how well this compares to PyCharm? thanks.
I am wondering if this works with express version, or older verions, I have a copy of VS 2008. . . Also I wonder if VS runs on linux as I started python because of its cross platform capabilities.... I guess I will stop wondering out loud and go take a look!
Thanks, parsedatetime looks very useful.
Thanks, that CoNLL benchmark is exactly what I imagined must be out there.
Now you're starting to get it: if the extent of your commenting was &gt; it appears that the math comes out the same and is faster [with method x as opposed to y] ... then it could be said that you were making a helpful contribution. Questioning the the OP's purpose or choice of language is counterproductive, though. As to the point about reducing the number of imports, well I can understand that it shouldn't make that big of a difference - especially in a core Python library. But, in theory, relying on an outside library for your code could lead to runtime differences across platforms, or even breakage if the api's change. Of course, core api's *never* change in Python, though. 
I know it's C, but this article may be of some interest: http://www.beyond3d.com/content/articles/8/
thanks but it seems to do the opposite of what I'm looking for
I am wondering the same thing (about express version), but I'm away from my Windows machine for the next week. Please let me know when you find out.
Long story short: In a way but not in the way you think. If you have use for a function, import it and use it. Always. Don't re-implement it and don't try to use something almost as good that has other uses as well. Use the best tool for each job. Python has a huge library and it's meant to be used. That's what «Batteries included» means. However, you should avoid importing things you _don't_ actually need. The normal way to do that is to write e.g. this at the top of your file: from pointy import * Why is this bad? Let me count the ways: * When using «from x import», you're actually making stuff part of **your modules public interface**. That's right, if your module, called «shiny», has «from math import *» at the top, that means that any other module in all of your program can use «shiny.sqrt» as an alias for «math.sqrt». How's that for a leaky interface? (There are ways to stop this leakage, but the easiest way is simply not use from X import \*) * Because with the above import, every single item in the «pointy» module is suddenly copied into your module's global namespace. This can easily be hundreds of items, and you have no overview of what they are. A future Python version might add a bunch of new stuff, causing a name clash with your code, and unfortunate new bugs. * Because if you do a bunch of «from X import *», then how are you going to figure out from which module the do\_something\_clever()-function comes from? You'll have to resort to ugly hacks like calling «print do\_something\_clever.\_\_module\_\_» to figure it out, which is _annoying_. What do you do instead? That depends on the situation. If you're going to use a large subset of the library in a few specific functions, use: def my_fun(): from math import * y=sqrt(x) If you're going to use a large subset of the library sparingly throughout the entire file, use: import math y=math.sqrt(x) If you're going to use a small subset of the library in a huge number of places throughout your entire module, use: from math import sqrt, sin, cos, atan y=sqrt(x) Also note that «from X import Y; Y()» is ever so slightly faster than «import X; X.Y()», but this will almost never matter in real life. Avoid premature optimization. Hope this helps and have fun. Also, about performance. The usual way to handle that is to offload heavy computations to fast libraries. If you're looking to blit stuff to the screen, use OpenGL through pygame. If you're trying to compute stuff, figure out how to express it as vector operations and use NumPy.
works with the visual studio shell (free)
VS itself does not run on Linux - it's Microsoft's main development environment for creating Microsoft software. The tool listed here is effectively a plugin to Visual Studio, and in order to use it you'll need the professional version, or if you use VS Express, you'll need what they call the [integrated shell](http://www.microsoft.com/download/en/details.aspx?id=115).
Hey, I've just gotten around to looking at this. Have created a fork.
I am just trying to find a decent compiler that is cross platform compatible, and isn't a pain to set up like Eric. . . I have used Visual Studios in the past and I tend to like the features they offer.
OK, what operating system. if a *nix then you could write a shell script, which checks for failure e.g. #!/bin/sh echo "Starting my app" python my_script.py || (echo "Script crashed, relaunch"; ./$0) Basically if python exits with a non-zero return code, then the bash script will be re-run itself. Also, make sure you mark the script as executable EDIT: ALTHOUGH, this will start multiple instances of bash. So if crashes happen alot you could fork bomb your system EDIT2: A better way, if you call the bash script "app_launcher_bash_script.sh" #!/bin/sh echo "Starting my app" python my_script.py || (echo "Script crashed, relaunch"; source app_launcher_bash_script.sh) This avoids the potential fork bomb
Also networkx is not part of matplotlib, although they are used together sometimes.
Excuse my ignorance. Is this "Microsoft Python" as in you can use Python to make stuff that runs primarily (or exclusively) on Windows and would typically be different from what we consider Python (different modules, extensions). Or is it "an IDE for Python programmers by Microsoft", which let's you write nice (mostly platform independent) Python code, which will run on any standard Python interpreter.
Visual Studio is just the environment that provides access and features around the Microsoft C/C++/C#/etc compilers, which you can use without VS. If you're just looking for a cross-platform *Python* IDE, Komodo or Wing are good choices.
I tried and like komodo, however it would do a wierd thing and stop allowing me to run my scripts after changing code, testing, stopping over and over again. I am currently using Wing but there are a few things that drive me crazy and/or I would like to see: *Custom syntax highlighting *Code Folding *code completion (or whatever it is called) otherwise Wing is the one for me so far, I will keep dreaming and looking though.
Just get Pycharm. It runs on everything and has all the features you'd want. It's free for open source devs but yeah if you're it costs a little money but I think it's well worth it.
Never used PyCharm, but Visual Studio is probably the best IDE I've ever used... And I usually avoid Microsoft software.
It's just an addon for Visual Studio to help you write Python code in it (CPython or IronPython, IIRC): it adds a debugger, code completition, wizards, etc.
The latter. I believe you can use it with both CPython and IronPython (which is a standard-compliant Python implementation that runs on the .NET virtual machine, and also very handily lacks a certain "feature" of CPython known as the Global Interpreter Lock). Ninja-edit: looks like it supports Jython and PyPy too. Pretty sweet. And IPython support. If it didn't only run on Windows I might consider it.
Beginner problems should certainly go in /r/learnpython. I don't know why general Python programming questions would go there or otherwise be frowned upon here.
I use both and PyCharm is a better IDE than VS. Visual Studio with a bunch of add ons can get close though.
Yea, we have a system - www.metaconfig.com Written in Python, using its own DSL, which we are told is a lot easier to learn than Puppets. You can e-mail me if you need some more documentation (or if you have any questions) as not everything is up on the site, yet: janus@lindau.dk 
Sounds pretty good. A shame, it requires Windows. My most recent experience with VS dates back to the time when people wondered about 16bit (Windows 3.11) DLLs on Windows "New Technology" 3.5.
Oh, I'll give it a shot then. Thanks! :)
Does anyone else find twisted too fat and complicated for general use? I much prefer just using asyncore or simply using sockets and select.
Maybe i could convince them I am an open source dev. . . my current code is up on github. . . I don't exactly have a community though. . . It says the price for the license is only for 1 year increments? that's not so nice for me. EDIT: I realize I was looking at the academic license not the personal one.
I find twisted to be slim enough if you include only the modules you need, but the fact that it's still not 3.x comaptible irks me.
The size of the open source project doesn't matter. Of course if you upload it and ask the same day they'll probably assume you aren't really participating to open source. But if you code has been on github for awhile and shows some sort of activity I can't see why they'd complain.
It's interesting that pypy jumps right into using SSE instructions. Is that configurable in the build? I compile with gcc 4.5.3. I get the x87 `fsqrt` unless I tell gcc to use SSE instructions with `-march=pentium4 -mfpmath=sse`. Then I get `sqrtsd`.
I know they are working the 3.x side....but still annoying.
PyPy's floating point support in the JIT only uses XMM registers, we never use x87.
It takes a while to get used to, but once you do it's pretty nice.
I mock Perl all the time. Oh, THAT kind of mocking, sorry ;)
Yes. You're correct. I will be making a post very soon explaining what the general post should and shouldn't be. The community is still very young and in the thought process atm. I am hoping some will understand its purpose and start posting.
It's OK. Pacifiers are very cheap if you need one. I am currently alone working on the community and I've got a 3 pack.
I recently wrote a [small project](http://github.com/spladug/harold) in twisted. I found different parts of the library to have very different styles and levels of documentation. For example, the IRC client was a breeze to use, but the Jabber client is very minimalistic and lightly documented. Overall, though, I appreciated using twisted and enjoy working on code built on it.
And it does not yet support IPv6!
I second the other person's response. My thought process is usually: 1) Make something work in a readable way. Don't even write for other people, write for yourself six months from now. I can't count the number of times I've gone back and said "what the hell was I doing here?" 2) Is there some case where speed is a problem? If so use some instrumentation and find out where the core problems are and address them. I find people try to squeeze out performance by doing something less-than-readable way before they have to. [The Perils of Pre-Optimization](http://geekswithblogs.net/geekusconlivus/archive/2007/02/15/106411.aspx). I've even had people bring me code to review and when I suggested re-factoring something into a function they'd tell me that the cost of adding another function the stack wasn't worth it. Shortly after their computation they were making a call to a remote database... As to the import question, don't hesitate to import something from a core library. As someone else mentioned it's entirely possible a core-library will change between Python versions but that's also true of builtins. Read [PEP-8's](http://www.python.org/dev/peps/pep-0008/) section on imports. I find always importing modules (and not functions) leads to more readable code. import math math.sqrt(foo) vs. from math import sqrt sqrt(foo) The math.sqrt call makes it very clear that you're calling it from another library vs. calling a function defined in your module. This also keeps your module's global space cleaner.
No. I've written a simple HTTP proxy in asyncore, and I've written more complicated stuff in Twisted, and I'd take the Twisted version hands down. Even with just the networking core it runs laps around asyncore. Having a library of working components is just icing on the productivity cake.
I installed PTVS in VS2010 Ultimate today for use at work and I really enjoy it. I don't see it replacing Sublime Text 2 for my general Python programming, but I can see myself using it for the projects where I have a lot of .Net and Python interop.
Can someone explain to me about the usage of threads.deferToThread() here? As I understand, it is using a python thread, and aside from the file IO of reading that file, you are still running in the the python interpreter and subject to the GIL, thus not gaining anything by wrapping it in a deferred? (In fact maybe slowing things down because of the threading?) Given my limited understanding of event-driven programming, I thought the main benefits were non-blocking IO tasks (file, http etc), essentially not waiting on things that do not happen in the python interpreter...
I find that Twisted has spoiled me wrt. asynchronous coding. Deferreds and inlineCallbacks are so awesome.
&gt; As I understand, it is using a python thread, and aside from the file IO of reading that file, you are still running in the the python interpreter and subject to the GIL Yes. If you didn't, you'd block the reactor thread, preventing anything else from happening. &gt; thus not gaining anything by wrapping it in a deferred? (In fact maybe slowing things down because of the threading?) Deferreds are just for making wiring asynchronous events and resulting callbacks/errbacks easier to deal with. Nothing in `Deferred` itself makes stuff asynchronous. The overhead of switching between threads is negligible compared to doing I/O. (And Twisted takes care of pooling threads for you.) 
I think the way twisted uses callbacks (and "errbacks" for error handling") really goes against the grain of the Python language. Whenever I read code that relies heavily on callbacks/errbacks, I find myself wishing twisted ran on stackless python, with microthreads / cooperative scheduling instead of callbacks.
&gt; Yes. If you didn't, you'd block the reactor thread, preventing anything else from happening. I get that, but when the thread is spawned, doesn't the GIL prevent Twisted from doing anything while it is working anyway? I understand you need the thread/deferred combo to have twisted continue to function properly, but it seems in this case that you are negating the benefits of event driven programming
Use the right tool for the job.
A lot of people like Python. A lot of people like Java. Having a preference for nearly any language is perfectly valid, but to say one is objectively better is pretty stupid and simplistic. There are very few languages that deserve be called outright "bad". PHP is the only one I can think of off the top of my head.
Your friend is uninformed and biased. Python is a great language, and Java is too, but they're best suited for completely different things. Java gets a lot of hype and love from larger software development projects, but a lot of programmers don't ever touch huge software projects. Python is also (typically) easier to learn, and both are extremely well documented (though python is kind of famous for it). There isn't much you can't do in both languages, but I do most of my scripting in Python, and if I were doing the same things in Java it would easily double my code size, and doing it "correctly" would be a lot more time consuming. 
Not sure if trolling or... ... yeah, trolling.
installed vs shell and ptvs yesterday after the /. story and only tested a little. i do not like the editor. you can place the cursor anywhere in the empty area, this does not help with the tab formatting. also felt like i have to delete a lot of spaces and fix indentation a lot in general. a little more autocompletion would be nice, otherwise i can stick with vim/gedit/editplus. intellisense (datatype detection, help texts, ...) works really well! putting breakpoints in my code and seeing and exploring the whole stack is also really cool. should save me a few debug-prints in the future and probably speeds up debugging. so... really cool for free and oss licensed, but we'll see where and if it fits in my dev environment. linux desktop may be a bit of an issue. ;)
You should use filepath for file I/O in Twisted: http://twistedmatrix.com/documents/10.1.0/api/twisted.python.filepath.FilePath.html
No, the GIL only prevents concurrently doing work. The thread wouldn't be doing anything for most of its lifetime. But it's really rare that you're forced to use deferToThread in Twisted. Using file/read/open is not the Twisted way of manipulating files; the author should be using [FilePath](http://twistedmatrix.com/documents/10.1.0/api/twisted.python.filepath.FilePath.html).
ya, python is bad. You know It's bad. just last week, It murdered a rock, Injured a stone, Hospitalized a brick. It’s so mean, It made medicine sick.
You [can't](http://dabeaz.blogspot.com/2010/01/python-gil-visualized.html) use threads for CPU intensive work. You can use them for IO. 
the GIL is a performance optimization for Python that only allows one thread to touch Python objects at a time. In real life, it's not a significant issue because using async IO for concurrent IO and multiple processes for parallellism is better anyway.
He's not your friend then.
Saying that processes are better for parallelism is a way too broad and (thus) false generalization. They're good for a whole bunch of things (and easier to use), but they're not well-suited as thread replacement for all cases where one would normally use threads. [1] Saying it's not a significant issue in real-life is not accurate either, while the GIL was an optimization that speeds up multi-threaded code on single-core machines, it's actually a pessimization on multi-core systems, and can make code running quickly on a single-core machine many times slower on a multi-core machine. [2] On embedded systems and other kind of systems that run on battery, the overhead added through the "busy-looping" when trying to aquire the GIL might also put a significant drain on battery-life, though I've never seen any hard data on that thus far. If you have various kinds of real-time requirements (respond to a message in so-and-so-many milliseconds, for instance), GIL contention might also become a serious source of latency overhead. [1] There are many discussions on this that go into detail (the discussion is largely dependent on which platform you're on), like http://stackoverflow.com/questions/807506/threads-vs-processes-in-linux http://www.programmerinterview.com/index.php/operating-systems/thread-vs-process/ etc (just a few results from the top of google, you'll find plenty more -- it's a rather fundamental discussion) IMHO, the big takeaway is "threads are faster to create and destroy, have less overhead, and faster data-sharing", so if you want to either have a lot of threads, you want to destroy and create them quickly, or sharing data between them is a critical bottleneck in your application, threads will be better suited. For cases where you have data-parallelism, or pre-spawning worker pools is an option to mitigate the startup overhead cost, processes might be a better choice. [2] http://blip.tv/carlfk/mindblowing-python-gil-2243379 http://blip.tv/pycon-us-videos-2009-2010-2011/pycon-2010-understanding-the-python-gil-82-3273690 *edit: added a few links &amp; remarks *edit2: note also that you don't actually need to use async I/O to do concurrent I/O, since the GIL is released when CPython waits for I/O, as placidified already said. Doing I/O asynchronous can be a good choice for various other reasons, though.
I don't mean to be rude but this appears quite complex as compared to gevent (or eventlet).
I think you are not where you think you are. 
Okay. Having taken a look at it, and by your description, it *feels* like you're essentially using it as a logger with some advanced validation. This isn't terribly bad on it's own. In fact, python's logging module uses singletons (http://www.python.org/dev/peps/pep-0282/). I don't know enough about Twisted to help with specifics, though. I will say it helps to provide callback methods which accept event data. I am of the opinion that the user shouldn't query the source of an event for what changed when the source can provide that information. It reminds me too much of PIC interrupts, where you only have one ISR and you have to go check bits to see what changed. But don't fix it if it isn't broken :)
Regarding moving the cursor anywhere: When you do this if there's no white space there already VS will put you in "virtual whitespace" w/ the column at the auto indent offset (assuming you have smart indent turned on which is the default). It won't actually insert any whitespace characters until you start typing something so it just moving the cursor shouldn't mess w/ your file. If you have any specific cases of the auto-indentation being wrong I'd love to hear about them so we can fix them. Edit: And you can also disable virtual space: http://blogs.msdn.com/b/zainnab/archive/2010/02/28/understanding-virtual-space-vstipedit0023.aspx
&gt; "threads are faster to create and destroy, have less overhead, and faster data-sharing" and the drawbacks of threads are? :)
It's somewhat easier to mess up with threads. They share filehandles, all data, and various other things from their context, like the current working directory (Speaking from a unix POV here, I have little/no experience with windows), so if you do something wrong in one thread, the rest will very likely go down as well. So they might not be so well-suited if you're building an architecture where you want reliability, like a webserver, where one request handler does not affect the rest in any way. With modern operating systems, the overhead for creating a new process is not that important anymore, usually, since there are a bunch of optimizations applied (like COW), but if you spawn them fast, it might still matter. What really matters a lot in practice IME, however, is the overhead of data-sharing, which can really kill your performance (Even with threads it's not necessarily trivially solved, and one has to be very careful.) But on the other hand, if you're building the kind of application where throughput and latency of data-sharing is non-critical, using processes will encourage you to do it in an arguably "better" way, like through serializing your data through a FIFO or something like that -- which you can then later on more easily extend to actually work over several computers, if you want to parallellize that way.
Often, lots of things (threads) want to obtain the GIL. However, only one thing can have the GIL at a time, so they all have to wait for each other to finish with the GIL before they can do work. This implies that, often, only one thing is doing work at a time. As for why they "want" the GIL: Python uses the GIL (Global Interpreter Lock) to make sure that two things (threads) aren't changing the same variable at the same time. If they were allowed to do that, bad things could happen. edit: to expound upon the last point, Python only has one GIL per process and it uses it for all variables. So, if thread A wants to change variable X, and thread B wants to change variable Y, each one still needs to obtain the GIL to make their changes, even though it would be perfectly safe for them to make their changes without hurting each other. This is the big complaint with the GIL. It would be possible to do object/variable level locks instead (i.e. one lock for variable X and a different lock for variable Y) but it would require an extensive rewrite of some of the Python internals, and comes with its own host of issues.
its so if you have a function that isn't easily transferred to an event driven style of program you can still use it with twisted. 
I agree greenlets/microthreads are much more pythonic 
Yeah. See eventlet and gevent for nice apis build upon greenlets.
awesome answer. My simplistic answer is that scaling with threads is limited by design to one machine. So, once you surpass diminishing return on threads you have no other choice but to go with processes. So why not just start with processes if scaling is a concern since the api's in python are nearly identical and then the GIL in regards to multiple cores doesn't matter as much. 
Imagine a classroom of kids (threads), they all play games (using the cpu to do stuff). However, they also all need to have this one super cool toy (GIL) to play for at least a part of their game. The problem is that there is only one of these toys in the room (process) and only one kid can play with it. The rule is that unless a kid put the toy down, no one else can have it. Now there are some rules for the kid that is using the toy: * Once a kid put the toy down, he may only get it back by grabbing it while its on the ground again. So he must wait for the kid with the toy to put it back down. * When he plays the part of his game that doesn't need the toy, he needs to put it down first. (I/O, C Extensions function that don't use object available to Python threads, like some of Numpy's heavy functions) * Every once in a while, he must put it down for a little bit. If after that, nobody picks it up, the same kid can take it again. So, what this means is that only one kid can play a game at a time, except when he's at a part of his game where he does not need the toy. (Only one thread can execute python code at a time. When a thread does I/O, another thread may work on their python code). So overall, if there is more kids in the room, there won't be more kids playing a game at a time, unless their games has lots of parts that do not require the toy. (Adding threads wont make the application run faster unless you do lots of IO, which would, without thread, just block the whole application)
You are posting to /r/python. I think you can guess what the response would be. ;)
It's when most five year olds want a new toy but they don't know why, and they can't come up with a justification as to why mom should give them a new one. Most of them don't know that their current toys actually work just fine.
thanks I was only inclined to stick w/ python-only ways but I will give this a shot
 sys.version '2.7.2 (default, Aug 5 2011, 17:30:24) \n[GCC 4.2.1 (Based on Apple Inc. build 5658) (LLVM build)]' On the server. No idea why they would use the apple version of it.
Probably because they are running OS X Server. Which seems strange since they "don't support safari".
My point exactly, who the hell buys those servers instead of using linux.
He's right. All the cool people use INTERCAL.
I don't understand Twisted at all when eventlet (or gevent) exist. They are simply better in all ways.
Scumbag redditor : says bashing languages is stupid, bashes php
The problem is that coroutines are less readable, despite the fact that they *look* more readable.
Because it's easier to write confusing code when using coroutines. Besides, you can totally use greenlets with Twisted if you want. See [Corotwine](https://launchpad.net/corotwine).
I'm going to have to say that is patently false. Co-routines as implemented by greenlet make writing code incredibly easy. You don't have to have callbacks everywhere that is confusing to write and read.
Also launchpad? Really? I will write off any project using Bazaar. Sorry to say.
PHP really is an exception. It's by far the most bungled, poorly thrown-together programming language I know of.
Why?
I'd not try to catch this exception.
Well, in general you do have a choice (not necessarily talking about python here). You can use threads, and then additionally build your application so that it can scale over multiple machines. But that design would only be advantageous over using processes in hypothetical cases where you can partition your workload so that each work-unit requires lot of IPC or so (hence threads) but the work-units themselves don't require much IPC between them (hence it allows you to distribute it over a network) -- but it might happen in some cases. It's just a bit more work to implement it this way, since you have to do twice the work (once implement the in-workload parallelism with threads, once implement the between-workload parallelism over the different nodes) -- whereas with processes, you just have to implement a mechanism for the processes to share the data necessary to be shared between them, and then you can just throw as many processes on each node as you need to max out its cores (You might also want to group processes that do more IPC with eachother onto one node, if your application allows that, unless you have data-level parallelism and it doesn't matter.) In practice, what I tend to do, is that I write the actual computation kernel in something like C (using pthreads) or OpenCL (you get threading and good autovectorization automatically) and then wrap it up using python (using cython, pyopencl or just calling it as subprocess in some cases) with twisted/etc (I know a lot of people prefer other frameworks, but twisted is what I already know, tradition yada yada) for the IPC between the nodes. (I also sometimes use erlang, it also lends itself very well for this purpose.) That way the actual computations stay in C-land where I can do them fast and efficiently, with full control over all the details (where do I allocate memory? How much? How often do I need to synchronize threads?) but I can do the networking, management etc conveniently in python. For instance the python-part will then set up a network between the nodes that need to share data, maybe connect to a "provider-node" that will supply them with new tasks etc, and then start up the C kernels and feed them with data, re-starting them should they crash for any reason. As case-study (if you're having doubts doing all this pays off in real-life :), we did this on one project where I and some other physicists/mathematicians from my university wanted to implement, test and extend a numerical model for surface friction, which required a lot of FLOPS and *tons* of IPC (each thread had to synchronize eachother with *all* the other threads in its simulation after each integration timestep, and all of the threads were working off the same data buffer inside a single simulation). Mostly some of the other guys where then responsible to write the C part (C++ in this case, actually), and I and some other implemented the framework around it, as described above, additionally having a "data-collection"-node in python, which collected and visualized the low-frequency data results in real-time (the visualization was actually done using pygame with a bunch of custom plotting "widgets"). We had then 4 nodes running with different input parameters (so running 4 simulations simultaneously), each with 64 cores and 256 gigabyte of memory, all maxed out nicely, chewing through the desired parameter-space.
Why ? Would you have some examples ? I always found the contrary to be true. I especially don't like that you can't have meaningful tracebacks in regular twisted code (outside of debugging mode I mean). I don't like much inlineCallbacks either in twisted, though (they sometimes give wrong traceback, and if someone forgot one yield somewhere, it can be tricky to debug them as well).
Interesting, but how will this affect the 'author' of the code?
An agonising, brain bleeding, concussion inducing, ball breaking learning curve. Yesterday I conquered validating arrays of form fields using pyramid_simpleform (based on FormEncode). It only took 3hrs. Which is nothing compared to how long it took to connect multiple databases in a single view - 2 weeks.
I suggest you use a process supervisor like [runit](http://smarden.org/runit/) or [supervisord](http://supervisord.org/).
Depends on the author. The community is only serving as a launch pad for announcements on code being worked on now. It will in no way attempt to enforce any agreements on any parties for any reason. If you're an author and your currently working on something and you don't mind sharing it and you're willing to collaborate over it *or* you're looking to work on fresh code and ideas with developers that are willing to collaborate, well, this is what the community hopes to target. 
Basically, the "GIL" is "LI5" backwards.
the gil is like a colouring book shared between kids in a classroom. it is easier to let them have it one at a time than to get two or three draw in the book at the same time. drawing at the same time is hard because you don't want someone else's crayon getting all over your picture &amp; vice-versa you can make elaborate rules over who can draw on which page at which time, but it's harder for the kids to follow and they make more mistakes
disabled virtual space: feels a lot better! i have not used VS in a while in general. is it or ptvs supposed to suggest keywords, common code constructs or closing braces? - for example: just typed "class User(" ... it does not place a ")" virtually at the end of the line automatically (which would be actually printed on return) and does not suggest "object" ... i am not sure it is supposed to do that, but it would be nice. - then autoindentation issue: continued typing last example "class User(object):&lt;return&gt;" and the cursor was placed at column 1 in the new line, no indent. - again autocomplete/suggest: typed "&lt;tab&gt;def \_\_" ... it *could* suggest "\_\_init\_\_", "\_\_str\_\_" etc now. - continued: "&lt;tab&gt;def \_\_init\_\_(" ... it *could* suggest "self" and the closing brace now. - indentation: continued "&lt;tab&gt;def \_\_init\_\_(self):&lt;return&gt;" ... again at col 1 instead of 9 (having configured 4 space for each tab) My settings: Text Editor - Python - General (enabled, all others disabled): * auto list members * parameter information * apply cut or copy ... * line numebrs * enable single click... * navigation bar Text Editor - Python - Tabs: * smart * size 4 * indent: 4 * insert spaces Text Editor - Python - Advanced: * member completion ... * {}[]().,:;+-*/%&amp;|^~=&lt;&gt;#'"\ * enter commits * enter outlining... * fill paragraph: 80 * paste removes... EDIT: had to escape some double _
Actually the size matter. They are (or were when I asked for the license) interested in open source projects with large and active communities.
I mean, If a piece of code is improved by taking a suggestion, should the suggester be listed in the 'AUTHOR' file? Can you simply credit 'r/CollaborativePython' or should the individual be given credit? The 'community' may not enforce anything (I don't think a subreddit could anyway), but maybe some sort of disclaimer clarifying what to expect might be in order?
&gt; For example, the IRC client was a breeze to use, but the Jabber client is very minimalistic and lightly documented. Check out [Wokkel](http://wokkel.ik.nu/). It's built on Twisted, and it's quite nice to use.
I use it to handle my blog ([source code here](https://bitbucket.org/smalone/but-stephen-blog/src) if you're curious). Microframeworks are easier to get started with than larger ones, and if your application is only going to be small (like a blog or cheap interface site) you only need basic functionality.
https://github.com/kennethreitz/lolcat The ascii art looks like a dog.
We've all done it. I did this one the long way: reduce(lambda x,y:x+y, (num_letters(x) for x in range(1,1001))) instead of just: sum(num_letters(x) for x in range(1,1001)) 
I agree, people bring this up all the time, as have I. It looks a little ass-backwards.
Great answer
The Pyramid docs are excellent and I'd say they rival Django's for completeness. However, I'd like to really hammer the point: Examples. Lots and lots of examples. And learning when the hell to shut up (I mean affectionately). As, primarily, a PHP dev (ducks the rotten tomatoes) who has done work in Django and making Python web spiders (Scrapy) I find the biggest problem with a lot Python-related docs is the drought of examples and excessive amounts of technical theory. The SQLAlchemy docs are a classic example of this. I want to know how to do something but have to wade through 3-5000 words of deep, technical implementation details that I'm completely uninterested in. Even the tutorials feel the need to drag you through mountains of dry text to do the simplest thing. Pyramid and Flask are great in that they have lots of clear examples with less filler and theory packed between. So in summary: 1. Pyramid docs are great, keep it up. 2. Please rescue us(me) from SQLAlchemy by beefing up the SQLAlchemy usage in Pyramid's docs. 3. Examples are awesome - oh and check out StackOverflow for inspiration on examples. e.g: [Pyramid: Changing database per view...](http://stackoverflow.com/questions/7050579/pyramid-changing-database-per-view-accessing-multiple-databases-per-view) &lt;-- that almost killed me.
Everything with I/O in twisted should use twisted libraries, because twisted will do it asynchronously for you, and give you a deferred. otherwise the I/O call will block, and wreak havok on the reactor. For example, you have to use a twisted version of any database adapter you want to use.
This was also posted in /r/programming: http://www.reddit.com/r/programming/comments/k0q6s/pyjector_inject_a_python_terminal_into_any/
rpy and/or rpy2 could be very nice for you. You can call R from Python.
Albert is the discriminating Python hacker to watch. This guy is on fire.
The cowsay?
Invent with python was really a pretty decent resource. I focused on Python3, so it was perfect for me. He kind of eases you in and teaches you basic techniques as well as some game design logic. This book really helped some of the concepts click for me. I am also working on pygame, I feel like I am making some progress and would be willing to help answer question for you ( If I am able).
It actually looks like a lot of Wokkel has been integrated into twisted trunk and I use several of its classes; it's definitely an improvement, but also the source of the differing styles. My main beef with it is that the documentation was so lacking on specifics that I had to dig through the library to understand how I should structure my code.
&gt;but I can do the networking, management etc conveniently in python. Right, IPC and network management was always the issue for me and thus I would avoid processes and threads and just accept the drawbacks. However, as of late zeromq has been super for making it possible to do ipc between processes. Thus, a network of processes to do the work is more of an attractive option. 
Don't know if this is your code but there are several spelling errors. def EncrpytWithAES def DecrpytWithAES Etc etc...
Hazards of a spelling mistake copy/pasted multiple times :) Fixed these instances in the post. Thanks for letting me know!
Ooooo.... I'm in need of something like this (encryption), glad to point out. I was presuming it was an IDE code completion thing to be honest.
It's only $49 today for a personal license (half off for back to school) http://www.jetbrains.com/pycharm/buy/index.jsp
Well I hope the sale lasts a while, I may be able to swing that in a week or two. Thanks for pointing that out, they weren't having the sale last night.
Importantly so far attempts to use other locking systems have resulting in much worse performance when you are not benefiting from the lack of GIL
think they only posted that a few hours ago, and looks like it's good through sept. http://blog.jetbrains.com/pycharm/2011/09/back-to-school-sale-pycharm-and-youtrack-up-to-50-off/
Are you using it for work? Education? What? 99$ for a tool you use all day every day is... a bargain in my opinion.
How does it compare to Eclipse + pydev?
That's one of the best and unbiased language comparisons I've every seen.
Is there any form of prevention against malicious code? i.e. import subprocess; subprocess.Popen('sudo rm -rf /').communicate() 
What could this library be used for? Can someone give an example? If you "inject" a "python terminal" into an application what does that give you. 
For key generation, you might want to mention os.urandom() and Crypto.Random. For OFB mode, it is CRITICAL that you should never use the same IV more than once! If you use the same IV to encrypt Plaintext1 and Plaintext2, then an attacker can xor the ciphertexts together, which will produce Plaintext1 xor Plaintext2. From this, it's usually pretty easy to recover large chunks of plaintext. You should probably also think about data integrity: OFB output is malleable. (Specifically, an attacker who can xor stuff into the ciphertext will create corresponding changes in the plaintext when it's decrypted.) 
pity those who blindly follow
This is a very wrong way to approach programming. Your first priority is not performing "micro optimizations" that may or may not help. You first need to make sure that your code works well, is easily readable/maintainable, has good design, etc... If you see that you have a problem with performance, then (and only then!) do you start optimizing the slow parts. Usually, your start up performance is not that big of an issue. Eventually you will want to learn how to [profile your python code](http://docs.python.org/library/profile.html) and you won't need to optimize code that hardly takes up any of your running time. The rule of thumb for performance is to only spend time on improving it where you will be spending the large chunk of your code. That import line is only going to happen once at the beginning and that's it. 
YES! PLEASE HP! I want some sweet MeeGo devices for cheap!
This doesn't implement AES in python; it uses PyCrypto, which does its heavy lifting in C.
The ability to script actions in the application.
As someone who is familiar with all the languages described, I couldn't agree more. 
That is completely left up to the source author. I do agree about the disclaimer and I am writing one up. If you would like to offer more thoughts you feel may benefit us all, I'd appreciate hearing you out. 
I use it for learning. I have a bitbucket account that I keep all my work in. I have the bitbucket plugin for PyCharm and I check my stuff in and out with it. Very neat.
Or: don't use unicode.decode. It's also gone in Python 3. It makes no sense at all to decode what isn't encoded.
I saw a video about it from a PyCon and I was very impressed, I may give it a chance. Currently using PyScripter and liking it a lot, but wouldn't mind something with the best feature ever, code folding! Other than that though, PyCharm looked very nice.
I agree with you, but my = key is the same as my + key. Maybe a typo could appear from there?
And it generally is more for hackwards (typo intentional) compatibility than good programming compatibility. Code that is utilising bugs and/or fringe case uses is what makes things hard.
I'm stuck using Python 2 because of library dependencies. The problem is that I have strings that are encoded differently than they think they are. I ran into the same issue when I was using Ruby for this project (see [this SO post](http://stackoverflow.com/questions/2349920/ruby-string-encoding) for background). So, if I'll have a unicode string that isn't actually unicode: &gt;&gt;&gt; snippet u'r she befriends Sh\xc5\x8dta Kazehaya, a very popular boy in her class.' &gt;&gt;&gt; print snippet ta Kazehaya, a very popular boy in her class. &gt;&gt;&gt; e befriends ShÅ If that same respresentation was in a normal Python string, it would be fine: &gt;&gt;&gt; print 'r she befriends Sh\xc5\x8dta Kazehaya, a very popular boy in her class.' r she befriends Shōta Kazehaya, a very popular boy in her class. But it's not, and attempting to convert it to a string using `str` gives a `UnicodeEncodeError`. I did find a solution, however: &gt;&gt;&gt; snippet.encode('latin-1').decode('utf-8') u'r she befriends Sh\u014dta Kazehaya, a very popular boy in her class.' &gt;&gt;&gt; print 'r she befriends Sh\xc5\x8dta Kazehaya, a very popular boy in her class.' r she befriends Shōta Kazehaya, a very popular boy in her class. which, curiously enough, uses `unicode.decode`!
Nice tool overall. Seems a bit stalled from the github repo logs. Would love to see more documentation on use cases and examples.
I hate Unicode EVERY time. For some reason I just don't get how to work with it :(
lo siento. Estamos no hay hablamos espanol aqui. Although, [google translate](http://translate.google.com/translate?sl=auto&amp;tl=en&amp;js=n&amp;prev=_t&amp;hl=en&amp;ie=UTF-8&amp;layout=2&amp;eotf=1&amp;u=http%3A%2F%2Fblog.manuelviera.es%2F2011%2F09%2Fgunicorn%2F&amp;act=url) actually does it quite well.
Yes, don't run it.
No this uses str.decode. I've done this trick before in other langs and usually in similar stituations as this (to fix decoding errors). u'Sh\u014dta'.encode('latin1') returns a str, and then you str.decode that back into a unicode object. Just think of unicode.encode as unicode.to_charset, and str.decode as str.to_unicode. Honestly the names are really confusing at first.
I wish more language comparisons were done in this style. Great read without the frivolous flame-baiting.
In my experience pydev compares to pycharm like gimp does to photoshop.
I will have to give it a try, I am very skeptical of you statement, especially given that I find eclipse to be more intuitive than netbeans or visual studio.
Hmm, you seem a little confused about what's happening there. (No shame, unicode is hard.) The right way looks like this: # Get content (made of bytes) from the ANN page you're scraping bytes = '\xc5\x8d' # That's a UTF-8 encoded string, and those two bytes decode to a single # character. We can decode it to a unicode string using `decode` unicode_char = bytes.decode('utf-8') # Verify it's the right character import unicodedata; unicodedata.name(unicode_char) # To write it out to e.g. a new file, it has to be converted back to bytes unicode_char.encode('utf-8') And this is what you apparently did instead: # Get bytes from the ANN page you're scraping bytes = '\xc5\x8d' # Erroneously decode it as a latin1 string, which leaves the two bytes as # separate characters unicode_string = bytes.decode('latin_1') # Hack around the problem by encoding it back to latin1 then decoding it, # correctly, as UTF-8 bytes_again = unicode_string.encode('latin_1') unicode_char = bytes_again.decode('utf-8') unicodedata.name(unicode_char) As donri said, `unicode.decode` generally doesn't make sense. You use `str.decode` to convert normal strings (made of bytes) into unicode strings (made of code points). You use `unicode.encode` to convert those magical code points back into bytes.
Yup. It has a few bumps but a good resource.
My guess is the auto indent might not be playing well w/ the disabled virtual space. I'll have to look into that more and see how C# ends up behaving, but I'm pretty sure those simple cases work w/ virtual space enabled. We don't currently do anything to auto-insert closing braces or providing completions on keywords, potential method names, or parameter names. Personally I don't like the auto inserting closing braces but we could certainly look at adding something like that and making it optional. Please open one or more features that cover these on pytools.codeplex.com - I don't think we have any of these covered in the issue tracker today.
If you use the Boost libraries then iterating a loop is not for (std::vector&lt;long&gt;::const_iterator i = data.begin(); i != data.end(); ++i) { std::cout &lt;&lt; *i &lt;&lt; std::endl; } but BOOST_FOREACH(long const i, data) { std::cout &lt;&lt; i &lt;&lt; std::endl; } When C++11 becomes more prevalent, then even without Boost you will eventually* see people writing code that looks like the following: for(long const i : data) { std::cout &lt;&lt; i &lt;&lt; std::endl; } Also, memory management in C++ is very rarely a big deal at all. 99% of the time there are only four kinds of cases that you need to worry about: * objects that come into existence and die within the same scope, which is the most common case and requires that you do nothing but declare the object in your code * objects for which you need to allocate memory but which die immediate when they leave scope, which you can take care of by just putting the pointer inside boost::scoped_ptr or boost::scoped_array to manage the deletion for you automatically (even in the presence of exceptions) * objects that come into existence in one scope and die in another but only exist in once place at any moment --- such when a function creates an object for you and returns it, so that your local scope has just taken over responsibility for the object --- for which there is either std::auto_ptr or the upcoming move semantics in C++11 (or the Boost.Move library in the meantime) * objects that are shared --- that is, which are referenced in multiple places simultaneously --- for which you can just use boost::smart_ptr Working directly with allocating and delete pointers is something that you only do when working at a particularly low level in C++, and only for long enough to build and test a higher-lever abstraction for users (starting with your self!) that will free them from the low-level details. Personally, if anything Python has often felt like a *less* safe language because unlike C++ it doesn't have a static typing system that allows me to guarantee that entire classes of bugs (such as spelling errors) will never be made in running code. For example, in C++ you can use "const" references to restrict users from mutating your data in certain circumstances. For example, you can see this in my loop variables in the examples above, which I labeled "const" to prevent myself from mutating them accidentally. Furthermore, the conception that many people have that C++ is faster than a language like Python *because* it is less safe is completely wrong. The real reason it is faster is because the static analysis can do huge amounts of inlining and other optimization that turns very high-level abstract code into very efficient code that is close (or perhaps even better) than what you would have written at a low level. It is for this reason that in C++, unlike Python, you rarely have to pay a lot for using using very high-level abstractions. [ASIDE: Fortunately, much of what I have said here will grow increasingly less true over time as the PyPy project continues to kick ass with their JIT tracing compiler. :-) The same applies to JavaScript interpreters. In fact, if anything JITs have the potential to result in code *faster* than any static optimizer can come up with because they have access to the actual run-time state of the code when making their optimizations.] It is certainly true that writing code in C++ can require somewhat more thought and attention than writing the same code in Python and is less "safe" in the sense of allowing for things like segmentation faults to happen, but this notion that C++ is both ridiculously more cumbersome and (more importantly) ridiculously less safe compared to Python is FUD that drives me crazy because I see it scaring people away from C++ to the point where they refuse to even *consider* using it or letting it be used in their projects as a matter of principle. This is not to say that C++ doesn't have downsides (such as horrendous error messages when doing non-trivial things with templates!) or that I think it should be used in all or even most circumstances, however the perception that many people have of C++ really bugs me at times because it goes past pragmatic awareness of its limitations into principled paranoia that forbids its use in any but the most unavoidably low-level programming situations.
You mean PyCharm attacks users' freedoms just as much as Photoshop does? Wow, better stay away from it.
Without even using PyCharm, I can say conclusively: Stay on Eclipse. It won't restrict you, you will remain free to use, modify, and redistribute your software. There is no feature more necessary than freedom.
$99 and all of your freedom as a user.
&gt; Today only, you can throw away your freedoms as a user for only $49!
Whatever editor/IDE I use, I can distribute my code how ever I please. So you statement does confuses me. 
 (1) BOOST definitely simplifies C++. I really do like what BOOST does. Unfortunately, deployment and installation of BOOST can be quite a palaver. (2) You are absolutely right regarding the major performance advantage of C++, as given by *speed*, coming from its static typing. However, the other aspect of performance is *memory* usage, and in the case of the simulator that I was discussing, *this* was the limiting issue. I did not mind waiting a week for results instead of a few hours. What did make a difference, though, with C++, is that I could run several simulations in parallel on the same machine, and each simulation was two orders of magnitude larger. (3) C++ allowed me to gain this huge advantage in memory footprint by allowing me to finely manage the memory space. At the begining of the simulation, I allocated a large hunk of memory on the heap, which I kept till the end of the run. All objects were created in this generic "scratch memory", and smart pointers (cast to the appropriate type) tracked them through their life cycle. Memory was freed instantly when objects were destroyed. This fine-grained "close-to-the-metal" custom manual garbage collection did make memory management a major programming issue during the development of the simulator. But it also allowed for a fantastically small memory footprint relative to the Python code. (4) I actually like C++. It is my "go-to" language for performance (speed/memory) critical tasks, just as Python is my go-to language for most everything else. Moreover, I actually enjoy programming C++. However, at the same time, I do not think that the notion that C++ is both more cumbersome as well as less safe than Python is either ridiculous nor FUD: C++ *is* more cumbersome and *is* less safe. Was it Stroustroup that said something like it is very difficult to shoot yourself in the foot with C++, but when you do you end up blowing your whole leg off? This does not change the fact that I still like C++ *and* that it is still a very, very, very, very, very useful language, to the point that I would think it is almost an indispensible skill to have for high-performance scientific computing. (5) C++ has its warts. Nonetheless, I do not think that these should be reasons to scare people away from C++ or to refuse to even consider using it on principle. People who adopt this attitude are doing themselves a terrible diservice and their projects will suffer from it. I think C++ --- warts and all --- belongs in every scientific programmers toolkit. Programmers who avoid it on principle have some basic priority/logic issues that would not to be addressed before I trust any program they write, whether or not it was in Python or C++. 
He seems to have a lot of PyCharm hate. Responded to 3 different posts with almost the same argument. Maybe a committer on pydev?
Maybe. I will try pycharm tomorrow, but I have to admit, I find pydev to be nearly perfect.
Everyone's mileage will vary. I'm a vim guy, but a few devs at work love PyCharm. When I was stuck in Java world, I loved their IntelliJ. Whatever gets the job done.
@jeetsukumaran: "However, at the same time, I do not think that the notion that C++ is both more cumbersome as well as less safe than Python is either ridiculous nor FUD: C++ is more cumbersome and is less safe." To be clear, I also agree wholeheartedly with this statement. What I consider to be FUD is the notion that "C++ is both *ridiculously* [emphasis mine] more cumbersome and (more importantly) *ridiculously* [emphasis mine] less safe compared to Python." That is to say, I don't mind people saying that Python is safer and more concise than C++ as a general rule, I just get concerned at the extent to which this difference is often blown up to the point where people without experience using C++ walk away with the wrong impression and are scared away from using it as a consequence.
I mean, the software you purchased. In the bad case, PyCharm, in the good case, PyDev. PyDev's license allows you to use, modify, and redistribute it. PyCharm restricts you in all three cases.
I've been working with VS2010 and it's perfect!
Also see this: http://eli.thegreenplace.net/2010/06/25/aes-encryption-of-files-in-python-with-pycrypto/
The GIL has one huge advantage: it eliminates the need to make C extensions reentrant. However it effectively eliminates a use case of big-data pipelined processing. If the pieces of the results of one stage are very large, the serialization in IPC approaches quickly eats up any efficiency gained from the concurrency. When only one stage of the pipeline needs the access at any given time, the actor model's shared-nothing approach could work well by allowing the runtime to move PyObjects from one interpreter to another. Has anyone implemented this? Has anyone tried and failed?
I doubt it is exactly what you are looking for, but [Stackless Python](http://www.stackless.com/)'s microthreads with channels for messageing comes close.
more like the perspective of a cook.
You and me both.
you should advise your friend to have a nice hot cup of shut the fuck up:) and then tell him his face is a bad language. That's right, take the moral high ground in this debate. 
I'll be the first to admit that my understanding of unicode is fuzzy. I keep reading things about it and just failing to get a clear picture. That being said, I don't think I did what you say I did. ANN encodes their pages with UTF-8, and sends the proper headers to say so. They don't, however, include a `&lt;meta&gt;` tag to incidate the UTF-8ness, and so scrapers tend to assume that it's latin-1. So, I give PyQuery (and thus, lxml) a URL. It returns to me a Python unicode string with those bytes that I showed above. So, in your example, I'm not ever receiving `'\xc5\x8d'`; I get `u'\xc5\x8d'`. Thus the hacking. If I misunderstood what you were saying, please correct me. I'd rather do things right.
Apologies, I didn't necessarily mean "you". Some part of your code went through the above process: it took some UTF-8 bytes and erroneously treated them as Latin-1. If your scraper is not reading the content-type header, your scraper is broken. The meta tag is entirely optional.
It's a good resource (also referenced in the post)
You could use librsvg with Cairo. I guess the last example on [this page](http://cairographics.org/pyrsvg/) does what you need (EDIT: just change SVGSurface to PDFSurface). If you already use ReportLab for something else, try [this library](http://www.dinu-gherman.net/tmp/svglib-README.html). If neither of those produce good results for your files, another option is to use [Inkscape](http://inkscape.org/) to convert the file via command-line (I use it to convert SVG to EPS). It uses Cairo too (without librsvg as far as I know).
Why the hate?
I hate equally all those who attack freedom.
May I ask how this is attacking freedom?
[PyX](http://pyx.sourceforge.net) can write PDF files directly, but you would need to construct the graphics using PyX methods. PyX is not a converter -&gt; it cannot read your SVG graphics you already created.
PyCharm restricts the freedom of its users to use, modify, and redistribute their property (namely, PyCharm) in any way they wish.
No, but you could build this with PyPy. CPython unfortunately does not support multiple interpreters in a single process.
I may have implemented something similar to what you're getting at. If I understood correctly you want to pass large blocks of data between two processes (to benefit from parallelism) one producing the data the other consuming. However, the cost of multiprocessing.Queue pickling your object (or however you are passing data between the two) is causing you to lose the benefits of parallelism. I have implemented something thast does this using threads. Essentially I made a custom Queue class in C (lets call it myQueue), myQueue is a simple FIFO which can be written/read to from a C function and a python function, which implements it's own locking mechanism independent of the python interpreter. Then by writing two C extension functions, which simply put/gets data from myQueue in a while loop and then doing some data processing or IO. Whilst doing their work these functions would release the GIL (using the PY_BLOCK_THREADS and PY_UNBLOCK_THREADS macros), so that they could utilise more than one core. I then wrapped my producer/consumer functions with threading.Thread, and called .start() and everything was good. Apologies, I'm not a computer scientist, just a lowly physicist so I don't fully understand some of your fancy big words, so maybe I'm way off the mark.
I've been using phantomjs (or pyphnatomjs) to render web pages to PDF via webkit - that should work fine with SVG. Check out the rendering example here: http://code.google.com/p/phantomjs/wiki/QuickStart
And this is a problem because...?
We use PrinceXML; it's not open source, though. Personal use is free, I think. It's basically XML/HTML/SVG/CSS -&gt; PDF. It's an external library, but really easy to pipe to/from to generate PDFs.
I didn't believe you when you said PyScripter wouldn't support folding, but, sure enough, it does not appear to. How odd...
This certainly looks interesting! Didn't know about PyX before. Thank you.
Yeah it's a big turn off for me since I use PyQT4 a lot and obviously it can contain huge classes that only really need to be touched once in a blue moon, so it'd be nice to hide it.
It's just I know attribution can be a prickly subject; Should the author of a project-post head it with how contributions will be credited and what license it's under; and will the disclaimer cover what will be assumed if there is no such header? Thanks.
From what I understand, Jython doesn't suffer from interpreter lock when using threads, but I don't have any personal experience with it. EDIT: [S.O.](http://stackoverflow.com/questions/1120354/does-jython-have-the-gil) post.
No, you're encoding the unicode string and then decoding that encoding, which is exactly the right thing to do and what I was going to suggest.
The meta tag or for that matter XML declarations and such are problematic anyway and only work in certain situations by accident. It's a classic paradox.
A "unicode" string is a sequence of "characters in the abstract" sort of like metadata. A "bytestring" is a concrete serialization as binary data of that information. It is important to understand that things like "utf-8" are *not* unicode, they're standards for representing characters that are capable of covering all or most of the unicode "database". People often seem to think that UTF-8 and unicode are one and the same and to be compared to ASCII which is something else entirely, but it's ASCII and UTF-8 that are similar. Unicode information can be *encoded* in an "encoding" (charset) with ``unicode.encode`` which results in a sequence of bytes represented in the ``str`` type; these in turn can be *decoded* according to the specification of that encoding, with ``str.decode`` back into ``unicode`` objects. I find this example helpful for understanding the above: &gt;&gt;&gt; len(u'€') 1 &gt;&gt;&gt; len('€') 3 This is not a bug, it's not wrong. In UTF-8 (the encoding my terminal emulator uses) the euro sign requires three bytes, but as a *character* it is a single one. Similarly: &gt;&gt;&gt; u'€' u'\u20ac' &gt;&gt;&gt; '€'.decode('utf-8') u'\u20ac' &gt;&gt;&gt; u'€'.encode('utf-8') '\xe2\x82\xac' &gt;&gt;&gt; '€' '\xe2\x82\xac' Note though that the default encoding of source code files in Python 2 is ASCII. When the Python parser reads a string literal, even if it is a unicode literal, it will still be "encoded" as bytes in the source file and Python must decode it from the file to create the unicode representation in memory. This is why you need a comment like ``# encoding=utf-8`` if you embed string literals like ``u'€'``, although you can stick with ASCII if you use unicode "escape" sequences like in ``u'\u20ac'``. The reason people are confused by unicode is because other people have tried hard to make sure you don't have to think about it (until you do!), for example in how UTF-8 is a superset of ASCII and backwards-compatible with it. This is *by design* and could just as well have been differently - ASCII is just another standard and nothing special in itself.
Would you buy a car, for example, whose dealer told you that you weren't allowed to open the hood or bring the car to a mechanic ever?
Yeah, Jython has some good properties, GILlessness being one of them. However the lack of so many useful C extensions is a deal breaker for a lot of my use cases.
Doesn't each thread in CPython have it's own interpreter?
I'm not sure I follow you. It sounds like you're just pushing your processing down into a C module. Any python code would still lack concurrency, due to the GIL.
Yeah, the thing against C++ has bugged me a bit, and reading your post, I think I realized what analogy I'd like more: C++ is more a kitchen on a farm, maybe it is a bit of an older kitchen, but still, thanks to the new cupboard boost, it is not far away from the modern kitchens like python is. However, the big advantage would be that you can just create a pie in a different shape than you want, or with differently cut apples and so on, if you invest a bit more effort.
i *really* love the /usr/local/bin/ipdb script... shaves off a lot of repetitive work... its become an essential part of my toolkit, thanks!
its No, not by default. There is support for sub-interpreters in the Python/C API, but it's rarely used and probably has some sharp edges.
What made you implement the player behaviour like that? I feel a truly random game would be far better off. Or: For the first 50 games, or so, the players choose random, then from then on, it chooses from what gave them the most wins. I'll have a play with this, although I am *quite* lazy.
This competition is, in fact, how I learned Python.
I took a quick look on PyCharm for a while (last month) and I found it is a very good IDE for Python. But, feature-wise, it's not comparable to PyDev, every feature Pycharm has, PyDev has to, plus the ability to install more than that. And last, Pydev+Eclipse is free, Python tools + VS is free, why bother using PyCharm ?
No, I truly mean os.urandom(). There is no such function as os.random() in Python as far as I know. (At least, there isn't one in 2.7, and there isn't one in 3.2). Also, I did mean /dev/urandom, not /dev/random. If you're worried about an attacker who can attack your operating system's cryptographic PRNG, then you still won't want to generate keys with /dev/urandom: instead, you'll want to take a cryptographic PRNG of your own and periodically re-seed it with bits from /dev/random if any are available. Otherwise, you'll leave yourself open to DOS attacks from entropy.
PyQt4 (QPrinter, QPainter, QtSvg etc).
no, but separate python processes communicating via zeromq may get you what you are after.
It isn't, because state is shared between coroutines.
That's pretty good. Since the program ends up with a collection of objects that emit SVG fragments on a .render() I could easily change it to make the equivalent calls via PyX.
Oh you've just blown my mind! Overloading the &gt; operator! Didn't think of that!!
Thanks, I hadn't thought about Cairo. When writing the script I used Inkscape to view the results but for some reason it never occurred to me to convert via the command line. For now, this is the perfect solution. Just drop it in the makefile and be done. I'll have to revisit this in a month or so, then I'll try either Cairo or wobsta's [idea](http://www.reddit.com/r/Python/comments/k25kg/how_best_to_create_pdf_files_from_python/c2gyua3).
Here's mine: http://pastebin.com/YuRkZrWT
Also, you can change in your preferences how many items appear on a page. Kind of redundant.
I've used Matplotlib for an in-house application that generates a PDF report with some text and plots. My application used matplotlib to generate all the plots so it made sense for me to use it for writing the PDF. I haven't delved into fine-tuning the formatting so my report is very basic looking. 
PyCharm is currently on sales for $49. It's very affordable.
&gt;In the bad case, PyCharm, in the good case, PyDev. PyDev's license allows you to use, modify, and redistribute it. PyCharm restricts you in all three cases. WTF are you talking about? PyCharm doesn't restrict on how you distribute your code. Am I missing something? Why is your comment so vague?
Not *your* code, but PyCharm. PyCharm is your property, why are you restricted from using it/modifying it/redistributing it?
id try it, but school has also started. I'll see....
Ok, now I understand what you are bitching about. I understand your point but a lot of people just don't care about all those freedom on a tool. PyCharm isn't open source and it doesn't stated that it is. So people who bought this tool know that and I'm guessing they don't give a flying fuck about those freedom that you seem to care so much about. I'm guessing people who bought PyCharm just want to use the tool to write code and get the job done. No more and no less. You shouldn't care too much about how people spend their money. I'm pretty sure people who bought PyCharm know what they can and can't do with it.
I care about people who are oppressed. People who are stopped from doing things they should be able to do. Just as I'd rise up over people losing their civil liberties, I rise up over people losing their liberties in this case. Businesses should not be held less accountable than governments. And I don't care that it's open source or not--I care that it's *free*. See the difference: http://gnu.org/philosophy/open-source-misses-the-point.html EDIT: And the fact that people don't care doesn't lessen how much they need to know about it. Maybe one day, someone will be intelligent enough to see the need for this. Until the day these companies decide to really strongly enforce their licenses, I'm not sure anyone will....and then, it will be too late.
Some people prefer it that way, others prefer to know what happens under the hood and to be able to tinker with the engine. As such, there are options for them too. Not everyone wants to know how, or wants to change the way that their car works. As long as it works, they're happy. If they're unhappy with their dealer, simply choose another dealer. I'm one of those people that prefers to have something that just works. If I ever feel the need to customise my IDE, I know that there are plenty of options out there, but for now I'm happy with just coding my own projects, not the tools I use to help me code.
But it's not so simple as "If you want to know what happens under the hood, use this." If you are ever out of town, or in a foreign country, and your car breaks, you are simply ruined. In fact, if you are *in* town and your car breaks, you might be in trouble if you can't get a tow truck. If you can't even get your oil changed at another place, you are definitely not going to buy that car. And you have to realize that using the software is already locking you in. I'm sure PyCharm has its own project files, its own ways of doing autocomplete. You'll be the same as people who are wronged by Photoshop, who refuse to switch to freer options even then because they're used to the functionality--an argument similar to "I'll stay in jail because the clothes fit me well."
Ah, I see what you mean. Sorry, my mistake.
That's very helpful, thanks!
Cool. Would be cooler if it was updated to Python 2.7 and 3.2.
I third that
&gt; If you are ever out of town, or in a foreign country, and your car breaks, you are simply ruined. In what context would you relate this to PyCharm? Where I live, there are road side assistance services available of which I am a member of one. &gt;And you have to realize that using the software is already locking you in. I'm sure PyCharm has its own project files, its own ways of doing autocomplete. I really don't see a problem with the way PyCharm does things. It works for me and it seems to work for everyone else that uses it. PyCharm doesn't store code in a proprietary format so I can quite easily change from one system to another. Sure I might need to re-create project containers but such a task wouldn't be *that* difficult. Come to think of it, no development environment that I have seen has stored code in a proprietary format. I gather that the reason for this is that it can't: it would break the ability to deploy it, or developers would avoid it like the plague. I'd presume that the people behind JetBrains and therefore PyCharm aren't fools, so are well aware of what [competition they are up against](http://wingware.blogspot.com/2011/03/python-ide-panel-at-pycon.html). It is in their best interest to not annoy customers who are well within their right to move onto another product. &gt; You'll be the same as people who are wronged by Photoshop I use Photoshop on a regular basis and find it much, much more powerful than any of the 'free' alternatives available. I don't feel wronged by it. It's fantastic, does everything I need it to and I seldom have a problem with it. In fact, it's been the free alternatives which I've had more trouble with either because they don't support features I need, frequently crash on my system, perform poorly or are poorly supported. One particular project in particular (of which the name now escapes me), while useful, became counter productive when I found problems with it: options to correct issues I found were to either file a bug report and hope that someone else fixes it (that's if the bug report filed was considered 'severe' enough) or learn that particular language and system to fix it myself, of which I had neither the time or expertise. This is certainly not an option for a number production environments. It might be true that some environments thrive off the ability to be able to rip apart and rebuild a project to their needs, but not everyone can sustain this model. I really can't waste my time fixing my tools when time needs to be spent on the project itself. Photoshop is more or less considered the de facto standard so Adobe must be doing something right. This is true for many other commercial, proprietary tools too. Don't get me wrong, open source code is fantastic and I use a number of (well maintained) open source tools on a regular basis, but it certainly isn't the end all and be all. If it was, we would have seen Linux become the mainstream for consumer systems a long time ago. Linux is certainly more popular for servers (perhaps because it can be customised to very specific needs), but Windows (and Mac OS to a lesser degree) has a foothold on consumer markets for a reason: it's supported commercially and users don't need to screw with it to get it to work, which I've found with a couple of *nix distributions but to their credit: are improving. &gt; "I'll stay in jail because the clothes fit me well." Incarceration isn't by choice, my studies in criminal justice have certainly taught me that. Being imprisoned prevents people from making then acting upon the decision to do what they want (within reason). Using a proprietary product doesn't stop me from moving to another one if I'm unhappy with it.
i'm unemployed, how do i get started with this? i read through and did examples with like 7 chapters of Learn Python the Hard Way, am I ready for this?
I just checked mine in Chrome. Climbing up to 1 GB for that tab alone. Dear god. (15.0.865.0 dev channel, under 64-bit Linux). Sure, I've got 6 GB of physical RAM, but that's a little extreme.
For me it's the little things that distinguish Pycharm over Eclipse. Things like conditional breakpoints, automatic doc string formatting. Being able to split the file over 2 windows and have your edits affect both so you don't have to worry about synchronising saves. Hitting run or debug defaults to the last script you ran rather than the last one you edited, so if you're working on a module you don't have to keep telling it to run the main script. Options to refactor code that are much smarter than just find/replace. The list goes on. The code hints in Pycharm are awesome for beginners too. I picked up a stack of best-practice ideas. Things like using 'is' instead of == to compare booleans, redundant brackets in expressions, better ways to concatenate strings. Also don't forget the Pycharm licence entitles you to a year's worth of updates, so you're not just buying the current version, but any upgrades they put in for the next 12 months.
&gt;CC-BY-NC-SA So, Python is built through huge efforts and released for commercial use. The knowledge, too, shared freely without bias against commercial use. But you come along and collect this knowledge from other people, then lock it up? What an asshole. Completely against the spirit of Free Culture. 
This is interesting...thanks!
&gt; In what context? If PyCharm breaks, and the developers aren't immediately available? Or they've disappeared? or you're without Internet? &gt; I really don't see a problem Of course you don't; it's the only thing you use, because you're used to it! That's why you won't change, even if it does break. And of course PyCharm won't piss people off--yet. They probably don't have the user base for that. &gt; I use Photoshop Of course you do! You don't care about being free, so why not throw yourself into solitary confinement? My guess is that you found "they don't support features [you] need" after having used Photoshop, and having used those features. Likely that you either didn't need those features, or they exist in another form in the free alternatives--you just don't want to learn them because solitary confinement is what you're used to! &gt; Photoshop is...considered the de facto standard By whom? The ISO hasn't ruled on it--or maybe my search abilities are failing me. I think you're mistaking the general public with people who have brains--Photoshop has become the "standard" because of the former, not the latter. They simply marketed better and proselytized their followers better. &gt; open source I don't care about that--I only care that I'm free to do with it what I will. &gt; If it was, we would have seen Linux *GNU/Linux* &gt; become the mainstream Ah, you're once again confusing the general public for people with brains. Don't get me wrong, democracy is fantastic and I vote on a regular basis, but it certainly isn't the end-all-be-all. &gt; Incarceration isn't by choice So why are you choosing to remove freedoms from yourself? Is that not very similar? Even if you decide one day to move out of the jail, all of your belongings that you created or purchased in jail will be locked up there still.
For me, freedom as a user is just to use the software i want, as long as it gets the job done and can improve my productivity. opensource/proprietary war is just nonsense, if the software that fits your needs is proprietary, well, just use it!
I love them for properly defining things like len() as 'cardinality' rather than 'size of array' and x%y as 'modulo' rather than the all too common 'modulus' (I nearly lost my job over fiercely correcting a colleague over this who insisted on calling it modulus) Up voted and bookmarked!
&gt; I only care that I'm free to do with it what I will. Good luck with that. Please refrain from trying to shove your beliefs down everyone else's throat. 
It's certainly not just a belief--I am pretty sure that everyone wants to be free. There remain only people who are too ignorant or too stubborn to act on it.
You have a point--"open source" is not a strong enough term to win any war. Free software, however, is the only sort I'll use. And is there any way that nonfree software could meet your needs if your needs ever include keeping the software running or adding a feature (two things which are bound to happen)?
My clarity might have been unclear... I meant contributing to wxPython to help it support multiprocessing. Last time I tried, wxPython won't run event handlers on secondary threads.
is there a 2.7 by chance? or coming soon? :)
anyone have some input on how pycharm and pydev stack up against wingIDE?
i graduated, but work has also started
I have been using PQR since Python 2.0 - one of my favourite features is the colour coding so I can see instantly which version a particular feature was introduced in. It is a shame it has not been updated past 2.6 - here's hoping that Richard Gruet or someone else can find the time to update it. 
Your story reminds me of [this](http://xkcd.com/386/).
Basically the license permits someone to print this collection on a card and sell it, or copy it into an app and putting it in the app store for 3.99 $. The author is protecting his effort of gathering the knowledge, not the knowledge itself. That's fine.
Copying is not theft. CC-BY is the only good CC license.
What is this supposed to mean?: http://snag.gy/LYilX.jpg 
IMO you're doing it wrong. I suggest you create a module for the client and a module for the server then initialize what needs initializing in the main module. If you insist you can postpone initializing the client inside a function or the 'if __name__ == '__main__':' construction. Like so: if __name__ == '__main__': server = Server.ClientLog() #and the other client = Client.ClientConnection(). 
I'm confused, are you saying that PyCharm is better? Pydev+Eclipse or Aptana has conditional breakpoints, file splitting (editing same file in two windows), code re factoring through PyLint and hitting debug/run runs the last file by default, not the last one you edited.
What do you mean by re-initiating the modules and calling constructors again? The only way this should happen is if you defined code without enclosing it inside a function or a class. So instead of doing what you are doing in `init.py` (as an aside, I would rename `init.py` to maybe states.py, to avoid confusion with `__init__.py`), try to do this: Edit: oh I see, you really meant `__init__.py`. Yeah, don't put code you run there, you can just put whatever I put in the states.py file in there, but keeping things separated can be beneficial. # Filename: states.py server = None client = None Yes, that's it. Initialize these variables with a separate method that you will call during the startup of your application: from Main import states def initializeStates(): states.server = Server.ClientLog() states.client = Client.ClientConnect() Then during the start of your application you basically call `initializeStates()`, and then elsewhere you should be able to import them directly. &gt;&gt;&gt; from Main import starter &gt;&gt;&gt; from Main import states &gt;&gt;&gt; print states.server None &gt;&gt;&gt; starter.initalizeState() &gt;&gt;&gt; print states.server &lt;Main.server.Server object at 0xdd5d10&gt; 
What parent poster meant here is probably: if __name__ == '__main__': server = Server.ClientLog() #and the other client = Client.ClientConnection(). And in your inline example you probably should enclose your code fragments in backticks (\`), so they will be escaped like so: `if __name__ == '__main__':` While your example will work if the poster were to run that file directly, he will still need an initialization method also.
Talking about on Reddit! 
Fascinating.
Could be the title of a porno.
kesako? never heard of it...
I do a jinja2 -&gt; PyQt4 webkit -&gt; Qprinter -&gt; Produces beautiful pdfs
well i liked pycharm too... but went back to old tools after my trial period ended and to be honest i'm not missing much. it made things easier but nothing i didn't have through hard experience with Windows.
interesting concept. i have tried (and failed) once injecting vim into a PyQt widget. Qt allows you to get the underlying Windows handle of your main app window. But in my case it didn't work. whatever I tried. i even went far as making a regular window using ctype. i simply couldn't inject Vim into it :( gave up.
Good explanation and article but there has been a pure Python implementation for at least two years: http://code.google.com/p/fin2py/ Mind that none of the implementations deals with singularities in the covariance matrix which will cause numerical trouble. Fin2py includes a Cholesky decomposition algorithm that can be used to identify non-positive definite covariance matrices (that is not supposed to happen but it does happen when the covariance is computed with assets that are not traded on the same set of days).
[Here is an online app](http://web2py.com/stocks) that uses some of this (under development) 
Thanks for pointing this out ... great resource.
Thanks for yours. You have much better explanations. I will point my students to it.
I recently began learning python...I cannot begin to tell you how helpful this is to me, thanks a lot man
heads up, pure python means pypy can eat it up. So always see if pypy makes for a good fit.
debugblind is right. What you're actually wanting to do should be done in the "python" way. Namely, create the classes in individual files like debugblind suggests, and import them into your main runtime application and initialize them there. That way you're working with the instantiated objects and pass them around if you need to. You're experiencing one of the "mental shifts" that comes when switching from one language (where there was an obvious way of solving a problem) to another language, where you solve the problem in a different way. It'll kind of "click" once you get it. 
 &gt;&gt;&gt; oct(65) '0101' Help on built-in function oct in module __builtin__: oct(...) oct(number) -&gt; string Return the octal representation of an integer or long integer. Go read up on octal numbers. 
leading '0' means octal leading '0b means binary leading 0x means hexadecimal. what is there not to understand.
aka base 8.
I thought "O" (as in the letter O) was octal. i didn't realize any leading zero turned it into octal. it appears that's what is going on. thanks.
i understand octal numbers, i feel dumb for not seeing it right away. but i guess what i'm saying is that a leading zero automatically turning a number into octal doesn't make sense to me. I would think it should be Ox0101, right? I know about oct() bin() int() etc, didn't realize that leading 0 was all it took. thanks.
Turns out, everyone is [correct](http://docs.python.org/reference/lexical_analysis.html#integer-and-long-integer-literals)! You can type 0o11 but 011 will yield the same result. Also this shows that just 0 is interpreted as decimal notation :p
It's a convention that goes back to the C days.
&gt; How is it obvious that a simple leading 0 (ZERO not the letter O) turns a number into octal? doesn't seem right to me. Tradition. It's been like that since like forever. It's not obvious that 40 % 60 is 40, now is it? 40% of 60 is 24. And yet, that's what the '%' operator does, because that's what every language ever has always done. (note: significant use of hyperbole. Don't take 'always' and 'forever' literally)
Developers got stupid and decided to use zero as a prefix that means "the following number will be considered octal, instead of decimal." The stupid is fixed in Python 3.0. http://docs.python.org/py3k/whatsnew/3.0.html
Score! Developed by my school. 
thank you for not giving me shit for not knowing this. haha.
yeah, i get it. but at least the % is an operator that comes from C. Does C also use leading zeros to mean octal? 
so it seems. i didn't know that! Thanks for pointing that out, at least it helps my ocd a bit because that means python is consistent with its C implementation. ty.
For the following things. &gt;&gt;&gt; int(011) #this is the real WTF. What if I read this from a file? (ans: i think this is a special case w/ keyboard input) 9 &gt;&gt;&gt; str(011) #OK NOW I'M FREAKED OUT '9' both are first interpreted as octal numbers, and then run though the respective functions, so int(011) is equivalent of. a = 011 int(a) since a = 9, int(a) = 9. I think you meant int("011") which is 11. I'm not sure what your trying to do with str(011).
 $ cat test.c &amp;&amp; gcc test.c &amp;&amp; echo Running: &amp;&amp; ./a.out #include &lt;stdio.h&gt; int main(int argc, char **argv) { printf("%d\n",011); return 0; } Running: 9 
Yes.
would like to know too
Octal used to be a lot more common. 
it's java app under Mac and Linux ?
The difficulty of intra-package imports when scripts are invoked directly is very irritating. The only solutions are fiddling with sys.path which feels very wrong.
I'm pretty sure 0 is interpreted in base 13, for luck. 
Don't rely on this behaviour, though, because in Python 3, 011==11. For future proof octal literals, use 0o11 (i.e. zero, lower-case o)
It's not obvious, but is fairly standard in the world of computing.
No worries! There are a million little finicky details in programming. Array indices tend to start at zero, not one. C-style blocks don't end in a semicolon, unless they're do while blocks. Yada yada yada.
&gt; CPython unfortunately does not support multiple interpreters in a single process. It [does](http://docs.python.org/c-api/init.html#sub-interpreter-support), sort of, though I'd recommend going the PyPy route (as you mentioned) over having to write a c extension to manage this in a sane and maintainable manner. It's worth mentioning that the OP's need for C extensions might prevent them from using PyPy, unless they worked around it using something like [execnet](http://codespeak.net/execnet/). 
[execnet](http://codespeak.net/execnet/) provides a shared-nothing model that supports (many) different processes, even between different interpreters (e.g., PyPy and CPython.) However, if I remember correctly, it does use serialized message passing.
As I understand it, Notch, creator of Minecraft. Uses Perlin noise along with a few other methods to generate the expansive worlds used in the game.
:-) 
Two things to note about Flask, one doesn't have to touch werkzeug directly to return a not found, just do `from flask import abort`, then do `abort(404)`. Also, since by default Flask just uses werkzeug's Rule and Map classes for routing, one can explicitly state what type of data to allow for a route, such as `@app.route('/&lt;string:name&gt;/')` or `@app.route('/&lt;int:object_id&gt;/')` Other than that, great talk. Thanks for sharing! :D
Nice python perlin noise library: http://pypi.python.org/pypi/noise/
The approach you are taking is called 'polluting the global namespace'. In other words, you have executable code that is not wrapped in a function or class. Because ``server`` and ``client`` are both in the global namespace of your Main module, they will get executed whenever an import is done.
ಠ_ಠ no. I don't think that that class provides asynchronous file IO... 
Not exactly intuitively obvious what's going on.
and there you go. thanks.
that's how i'd expect to use it. thanks!
so it seems, indeed. learn something new everyday, right?
Examples, please. Do you mean running a script that imports things from a library that's not in `sys.path`?
Import supports complex setups poorly. Import is simple. 
This is a good resource: http://www.amazon.com/Paul-Wilmott-Quantitative-Finance-Set/dp/0470018704
I've just purchased a license for WingIDE. I absolutely love it. Here's my blog post about it: http://www.roguecode.net/2011/09/wingware-ide.html They have a free version, btw.
I want to feel like I am included.
Your attitude is shit.
The free version, which I've been using for a while, is pretty basic. It lacks the autocompletion and source assistant that he raves about. It has an editor with syntax coloring, and a debugger that lets you set break points and (at a break) inspect all the stack variables. I've been using it while writing some basic PyQt4 code and it is pretty useful, but the paid version is probably worth the money for a professional, as opposed to a hobbyist. Oh, and, all versions use X windows on Mac OS X, which makes it rather ugly. Supposedly a mac-native UI is in the works.
&gt; Oh, and, all versions use X windows on Mac OS X, which makes it rather ugly. Supposedly a mac-native UI is in the works. Maybe, from http://wingware.com/pipermail/wingide-users/2011-August/009148.html: &gt; ... get Wing running on Qt...
Example: src/ c1/ m1.py m2.py &lt;- uses code from ./m3.py as expected m3.py c2/ m1.py p1/ c1/ m1.py m1.py &lt;- wants to import code from ../c1/m1.py m2.py &lt;- uses code from ./m1.py, ./c1/m1.py as expected p2/ m1.py &lt;- wants to import code from ../c1/m3.py
Your attitude is shit. You're bad at interacting with people, and you don't give a fuck about it. You don't need to get butthurt about it, I'm just telling you the truth.
Dude, I pointed out that shitty code is shit and you responded with a personal attack, what further reaction did you expect?
whoosh
btw, javascript does the same thing. Try typing 010 in firebug or chrome's webkit inspector.
Notice the last digit is not the same? It's just showing that floating points have a limit in representing decimal numbers.
So Nokia is going to stop funding PySide development. And the PySide team is looking for the community to join in its development. Is this something worth posting to this subreddit?
But even then, you get only one page at a time.
your page is too fucking crammed up
Stackoverflow is a better place for this kind of question.
kinda need to know which color is which stock...
The Cython user list would be even better. AFAIK, If you want objects from one Cython extension to be available to another, I think you need to make a .pxd file which provides declarations of functions and classes defined in A.a (in your case).
In Ruby, you'd write (to be exactly equivalent) puts items.map(&amp;:to_s).join(',') Though join, actually already calls the to_s method (which python should do, but doesn't), so it's actually just puts items.join(',') I've seen this reason cited frequently for people wanting to switch to Ruby (or discard Python out of hand), but it's always seemed pretty weak. The only solid reason I've seen to switch from Python to Ruby is Rails.
Indeed! &gt;&gt;&gt; def upper1(): ... return map(str.upper, ['spam', 'eggs']) ... &gt;&gt;&gt; def upper2(): ... return [x.upper for x in ['spam', 'eggs']] ... &gt;&gt;&gt; &gt;&gt;&gt; from dis import dis &gt;&gt;&gt; dis(upper1) 2 0 LOAD_GLOBAL 0 (map) 3 LOAD_GLOBAL 1 (str) 6 LOAD_ATTR 2 (upper) 9 LOAD_CONST 1 ('spam') 12 LOAD_CONST 2 ('eggs') 15 BUILD_LIST 2 18 CALL_FUNCTION 2 21 RETURN_VALUE &gt;&gt;&gt; dis(upper2) 2 0 BUILD_LIST 0 3 DUP_TOP 4 STORE_FAST 0 (_[1]) 7 LOAD_CONST 1 ('spam') 10 LOAD_CONST 2 ('eggs') 13 BUILD_LIST 2 16 GET_ITER &gt;&gt; 17 FOR_ITER 16 (to 36) 20 STORE_FAST 1 (x) 23 LOAD_FAST 0 (_[1]) 26 LOAD_FAST 1 (x) 29 LOAD_ATTR 0 (upper) 32 LIST_APPEND 33 JUMP_ABSOLUTE 17 &gt;&gt; 36 DELETE_FAST 0 (_[1]) 39 RETURN_VALUE &gt;&gt;&gt; 
As bryancole stated, what you need is a file named a.pxd in the same directory as a.pyx. It should contain the required prototype declarations. Then in 'b' you can use `from my_module.A cimport a`. Note: you'll still need a regular import to access Python objects. Also, regarding circular imports, note that cimport needs to be run at the module level; it's better to refactor anyway. As to the setup.py, other than the custom `build_ext` for Cython it's just a standard setup. You've defined 2 sub-packages A &amp; B. The following is a bare bones setup that I think should work for your example: from distutils.core import setup from distutils.extension import Extension from Cython.Distutils import build_ext module_a = Extension('my_module.A.a', sources=['my_module/A/a.pyx']) module_b = Extension('my_module.B.b', sources=['my_module/B/b.pyx']) setup(name='my_module', packages=['my_module', 'my_module.A', 'my_module.B'], cmdclass={'build_ext': build_ext}, ext_modules=[module_a, module_b]) 
I'm trying Stackoverflow right now, and I'll try the Cython list if neither Reddit nor SO pan out. I forgot to add it, but I do have pxd files available, but it simply isn't picking up the imports.
asciidoc
Yes, you're right. I'm not really sure how to solve that as I can't control the CSS without paying wordpress.com $30 USD per year. I don't like hosting wordpress myself as I always get lazy on updates (even though their semi-automatic). If you have a solution I'll jump on it.
Have you read [Joel on Unicode](http://www.joelonsoftware.com/articles/Unicode.html)? It's a good introduction to what Unicode is all about.
Just because free software is easier to contribute to doesn't mean it survives or gets new features. You seem to be under the impression that free software is ever-lasting and ever-growing, whereas proprietary software is not. Software needs developer time to survive and grow. How it gets that time (by throwing money at it or having enthusiasts volunteer) doesn't matter from the software's perspective. So yes, there are ways that nonfree software could meet someone's needs if those needs included keeping the software running or adding new features.
I'm not getting why installing `src` (or installing packages from `src`) to somewhere into `sys.path` is wrong. Why have a path and absolute imports? Consider that someone wants to use the packages in his own Python script way outside the main source tree without access to relative imports.
But even then, your script does the same thing. Other than that though, great work on actually *coding* something cool, it's nice to see an example like this on /r/Python. Next: Code a GUI, selectable subreddit. If you want help with GUI stuff (Oh god I love coding GUI Stuff) then ask!
Absolutely. Our community would like to highlight projects where the author or team are actively looking to collaborate. A sort of job-board for projects that need or would like some help now. You can say *"Join PySide in all of it's glory on Github"* and be welcoming in that way but it is preferred if possible to say as an example *"Working on a new library that targets goal X for PySide"*.
I can see your concern and it is valid. At the risk of adding to many hurdles to a post, do you think it will be harmful if 'attribution' is not mentioned at all (something for author and contributor to figure out)? 
Dear sir, perhaps you can help with my configuration of Eclipse and Pydev then? I am running into a couple of issues I can't seem to solve. * Can't find compiler to run modules on Ubuntu when telling it to use Python3 * Can't seem to just open a .py file and run it, has to be a project first? * Indent guides Otherwise I am sold on this wonderful product
I like the initial table. I like that the right side has both redundant lines *and* stuff which is not about imports and has nothing even remotely similar (ability-wise) on the left side. I also like that the left side crams C and C++ together (as if they were the same language) and then claims there are no namespace (in C++? really?) Seriously, if you're going to compare C to Python, don't claim C++ is involved. That'd be a good first step. I also like that the article claims the solution to all import woes are to use absolute import by default and make relative import explicit, links to PEP328 (which is *precisely* about that) in the footer and proceeds to completely ignore it, and ask for it anyway.
what were your old tools?
How does it stack up against pycharm ?
I like the look and layout of Wing IDE 101 (the free version) under Ubuntu using the system GTK+ look, blends right in and looks perfect, but I'd love some autocomplete and that sexy Source Assistant. But those options cost money. Precious, rare money. That makes it hard to truly consider for a non-pro like myself, especially when PyDev is out there for free. I wanted to play with the Wing IDE Pro trial, but it crashed for some reason on startup the second I told it to use the native GTK.
yeah, everyone's giving you crap, especially when you're being friendly, I don't get it.
That is very hypothetical: "if your needs ever include keeping the software running"... When it's only 99$, and there are other options out there that have other features, and "free" ones like eclipse or emacs... then if you really needed one weird thing on your IDE that PyCharm wouldn't implement, you could always make it yourself. If someone gave you an iPad would you refuse to use it because it's not running "free" software? If yes, then your position is religious in nature and there's no possible way to come to agreement on this.
jsTree will do this http://www.jstree.com/
People always tell me that I'm being religious and irrational. I have yet to see that--what indication did I give you? Perhaps I've evaluated the use of the iPad, and found it to be insufficient for overcoming the lack of freedom. In fact, that's exactly what has happened, and what will continue to happen. The difference here is, I actually consider freedom a factor--and, generally, the biggest factor--in my software choices.
And note that Pypy has integrated stackless support.
With the "Back to school" promotion, PyCharm is currently $49 (for all of september). Just saying.
No, you misunderstand. With Free Software, you don't have to wait around to see the new features. The whole point is, you can add them yourself or hire someone to add them. I suppose my final statement above was too broad--my point was, there was no way one could choose nonfree software if they expected to have the software for a long while. Eventually, the manufacturer would go out of business or stop supporting the product, and it would become unusable. I know people who are *still* using Debian Etch--and that's been unsupported for a long time. They can do that because they are allowed to change the software themselves, they aren't at the mercy of some external being.
&gt; if your needs ever include keeping the software running The vast majority of commercial software don't come with a time bomb. Jetbrain's licenses are lifetime, and entitle the buyer to a year of free updates.
Ah, but updates to come from *Jetbrain*, not the user. If Jetbrain ever disappears? Goes out of business? Or even revokes their license? (I'm not sure they can do that, but I can't imagine it would be out of their reach) It doesn't matter if software comes with a time bomb, but it does matter that when it breaks (which it always does), the user should be able to fix it on their own. Which is why I only buy cars that don't have locks on the hood, and I only buy software that allows me to remain free.
If a native OSX UI was in the works, I might try it. Having to use X11 on OSX...blech. I am using PyCharm. Really like it. 
The given approach is probably possible with a tool like http://pypi.python.org/pypi/import_file/ (the author even echoes the sentiment: "fixing sys.path just feels wrong"). 
&gt; Ah, but updates to come from Jetbrain, not the user. If Jetbrain ever disappears? Goes out of business? The software has no reason *not* to keep on trucking. &gt; Or even revokes their license? (I'm not sure they can do that, but I can't imagine it would be out of their reach) For individual licenses, as far as I know they can't do that. &gt; Which is why I only buy cars that don't have locks on the hood, and I only buy software that allows me to remain free. And that's your right, but spreading FUD and going on about mostly irrelevant rants is not going to help your cause.
Rereading your previous comment, I don't think I misunderstood it but that you miswrote what you meant. People and corporations _can_ choose non-free software if they expect to have it for a long time. There are _a lot_ of schools and business that still run Windows XP since 2001 (10 years). In fact, it's so widely used that MS had to continue support until 2014, even though MS considers it a legacy operating system. You're right about the manufacturer eventually going out of business or stop supporting the product, but that's not a big issue for non-free software because software evolves (both free and non-free). That's to say if one product dies, a new one is usually born from it. Debian etch is a bad example because it's only from 2007 (it's not very old). The reason why it's unsupported so soon is because Debian is still growing and evolving. Before ending, I'd like you to know that I'm a free software supporter—I've even seriously considered interning at the FSF. However, I'm also rational. Based on your comment history, I don't think you are and I think it's because of fanaticism.
It brings attention. It brings people to the light. People like you, who refuse to see light? I can only hope that I've put good ideas in your head. Besides, I think we could use a little fear. We're giving ourselves over to companies we don't control at all--why isn't everyone scared as hell?
&gt; It brings attention. Contrary to what you seem to think, not all attention is good attention. &gt; It brings people to the light. Yeah... no. &gt; People like you, who refuse to see light? I can only hope that I've put good ideas in your head. Especially not when you're condescending and insulting. &gt; Besides, I think we could use a little fear. We're giving ourselves over to companies we don't control at all--why isn't everyone scared as hell? Your self-righteous rants would probably hold more weight if you at least somewhat [put your money where your mouth is](https://github.com/MarkTraceur) now would it not? RMS at least tries hard to be consistent, I can respect that. Your in-your-face behavior? Nope. Even less so when you're harrumping in places where it's pretty much irrelevant: pycharm does not lock code in, if it's ever lost users can just switch to a different editor or IDE.
What about my comments has been irrational? I find freedom to be the most important factor in choosing software, and I have noticed that *everyone* else simply ignores it. The fact that I'm the only person on Reddit who wants to be free isn't irrational. In fact, I tend to question others' rationality more than my own--who wouldn't want to be free? I don't mean timeframe, though, when I talk of people expecting software to run a long time. I mean to say that they should expect multiple generations of software to go by without having to lose their software. People are still on XP, by the way, because it is nonfree. Had it been free, the updates would have been free (since they were modified works), and that would have made the upgrades go far more quickly. Schools and businesses, instead of buying 20 copies for each room, could buy one copy for their entire organization. Consequently, I'd say Debian is a bad example because anyone who uses it automatically gets upgrades--because the users and developers came together to work out a way to do that. And if one product dies only to usher in another, why should the users be forced to switch? Why can't they continue using their property? *Even* if it breaks. Back to the car analogy--just because a car factory goes out of business, doesn't mean I should be unable to change my oil.
What in-your-face? I'm talking to people who are making a mistake and buying nonfree software. I'm telling them to be careful, to consider being free instead of trapped. Not trapped into using the software, but trapped into using exactly that software without modification. Without freedom to do with it what they will. And what do you mean about putting my money where my mouth is? I have a GitHub page mostly because it was suggested to me as a career move--I have been slowly moving to Gitorious for about a week now. Admittedly, it's very slow. Attention is not all good, but for those people who are reading, I imagine they see me talking about freedom, and you talking about buying into a corporate dictatorship. I can't see how I'm the bad guy. And I certainly didn't insult you--you have refused, in this conversation and (very likely) in others to see the truth, that freedom is important, and that it is lost when nonfree software is used.
&gt; What in-your-face? I'm talking to people who are making a mistake and buying nonfree software. Exactly that. &gt; I'm telling them to be careful, to consider being free instead of trapped. Ha ha. &gt; And what do you mean about putting my money where my mouth is? I have a GitHub page mostly because it was suggested to me as a career move Yep. And github is nonfree, so you're a self-righteous asshole who has no problem using nonfree stuff when you consider it to your advantage. And I'm pretty damn sure you're using nonfree hardware all over. &gt; I imagine they see me talking about freedom, and you talking about buying into a corporate dictatorship. That's definitely only in your imagination. You're "that guy" in the tube, the one ranting and raving about sinners burning in lakes of fire, warning about end times and calling for repentance (then going home and masturbating to shemale porn). You're ranting and raving at people who never asked for your input (and are not interested in your heavy-handed and mostly generic and irrelevant rhetoric), asserting you and your cause are infallible, and breaking your own rules on the side. Meh.
I'd like relative file system imports. I would **not** like absolute imports. Namespaces in C++ are great and you're right that it wasn't fair not to mention them. I'll edit that to "namespacing by default in python" vs "optional namespacing in c++". Though you should note I did mention it wasn't an exhaustive list precisely because there are many details which aren't relevant to the issue I wanted to discuss. It's not a C++ vs Python post. PEP328 - I was complaining about its relative imports syntax and mechanics.
What if `src` isn't a package? The folder structure might just be an effort to organize the code of an app and not to help someone &gt;use the packages in his own Python script way outside the main source tree edit - I'll elaborate on why installing `src` into sys.path is wrong. It just isn't what you wanted to do. If you want to access a list of 10 python files from 10 folders in your project folder structure. Does it make sense to now add 10 empty __init__.py files? Does it make sense to add 10 items to sys.path in every one such script? Importing a specific file is a clear action which should be a one-liner in a modern language.
Parallel Python is quite nice for parallel computation, but it's extremely fragile if you use complex (even if picklable) objects. In the end I had to go back to multiprocessing as I was getting hard to debug errors every time I used pp.
&gt; I would not like absolute imports. Absolute imports != absolute filesystem imports. Absolute imports in the context of Python are imports rooted directly in sys.path rather than relative to the current module. &gt; I'll edit that to "namespacing by default in python" vs "optional namespacing in c++". Way I see it, it's about as optional as using packages in Python: if you restricted youself to modules on sys.path, most of your issues would go away. But I guess that's a 10% thing. &gt; It's not a C++ vs Python post. Then you might just want to rethink the idea of starting with a comparison between C++ and Python which takes all of the room above the fold and then some on pretty much any screen under 27"
But standard Python multiprocessing still uses pickling anyways. From the [docs](http://docs.python.org/library/multiprocessing.html#all-platforms): &gt; Picklability &gt; Ensure that the arguments to the methods of proxies are picklable But yes, the pp errors are nearly useless especially when using when submitting a job to PBS which hides all stdout until the end of the job (unless in interactive mode)
I install tens of Python packages for many of my Python programming projects. To install, the packaging software `pip` does a combination of adding package source directories to `sys.path` and moving packages to existing directories on `sys.path`. Automatically. Someone, somewhere just created a bunch of mostly empty `__init__.py` files and setup configs to enable that to happen. Using the existing, well-known Python package protocols lets you organize your code fine *and* help someone down the road. That someone is likely you.
I have, although it's been a while. Probably should read it again, now that I'm dealing with it.
Yes, but the difference is that in pp you have to send a list of all your imports when you submit a job (unless your objects in the module are self contained), because the workers have no knowledge of the caller's environment. And this breaks with a lot of modules, especially for non-trivial objects.
Ah, good point. Luckily, my project is just a lot of file parsing.
I am unfortunately only fighting the battles, I have yet to win the war. I use GitHub, but I'm migrating. I use nonfree drivers, but it's getting much better. I have Adobe's Flash plugin, but I steer away from sites that use it. The difference, for me, is that I am being a hypocrite. I think compared to people who look at the situation, throw their hands up and remain unfree are far worse off than I. I think even if those people are ignorant of their situation, they deserve to be informed--and software companies are certainly not doing their part. And now, you've compared me to a religious fanatic who has sexually deviant fantasies. I'm sure you've won the public over now, since I've obviously been shown to be a disgusting human being. Oh, wait, I don't do *any* of that stuff. At all. I'm the fellow who talks to his neighbors about not drinking too much, and has a glass of wine sometimes at dinner to please his wife.
&gt; I am unfortunately only fighting the battles And you're proving not to be very good at it. &gt; I use nonfree drivers, but it's getting much better. I have Adobe's Flash plugin, but I steer away from sites that use it. Right. You're a gigantic hypocrite. Fix that, and then you'll have the right to be "holier than you". RMS walks the walks, I can respect that. You don't. &gt; I think compared to people who look at the situation, throw their hands up and remain unfree are far worse off than I. And you're wrong (again). And most people don't bother throwing their hands up, because they don't care. At all. They don't have the desire, the knowledge, the reason or the ability to care. &gt; you've compared me to a religious fanatic Which you are indubitably. &gt; who has sexually deviant fantasies. It is telling that you consider shemale porn "deviant". &gt; I'm sure you've won the public over now, since I've obviously been shown to be a disgusting human being. What the hell are you talking about now? &gt; Oh, wait, I don't do any of that stuff. At all. I think you're missing the concept of analogies. &gt; I'm the fellow who talks to his neighbors about not drinking too much Except you're screaming at him with a megaphone while he's enjoying a light beer with his son watching a game of football at 10PM. &gt; and has a glass of wine sometimes at dinner to please his wife. Except the whine is half vodka.
I'm doing my best. I don't really have the money to buy another computer right now, but I assure you that I will purchase freer hardware. I'm not religious at all. I used the term "deviant" to capture the tone *you* were using. I wonder who the one with the hate is, in this situation. You appear to be deeply offended by what I'm saying. Is it that you do not like freedom? I am very confused by you.
If anyone could give me feedback on whether this works on Linux, I'd appreciate that very much. My ArchLinux install has been giving me some problems. Also, FWIW this is coded in Python 3. While extracting JAR URL from JAD file can probably be accomplished in less than 10 lines of coded, I've added some "features" to the program :)
Assuming you're on windows, use py2exe. Not sure about Linux :/
You can treat the .so file as package data. package_data = { '': ['_extension.so'] }, So, build it with your external make tool and just refer to the result. The problem is if you want to package this up for other people to install as then you would need to supply many different versions of the binary objects for the different Python versions and ucs2/ucs4 build variants of those versions.
I basically live in Wing IDE at work - for managing complex projects I have not found anything that matches it. The debugger alone is worth the price of admission...
There's [pyinstaller](http://www.pyinstaller.org/) that builds for Windows, Linux, and Mac OS X.
Use PEP8 as code style guideline!
I use cherrypy to communicate between a Python backend service and a Rails frontend.
I've been having some issues compiling/linking on some platforms, but now I have it working on at least OS X, OpenSUSE, and Ubuntu with Python2.x. If you have any issues please let me know!
Lets say you're developing a game, e.g. EVE Online, and you know your code will never be imported as a package. You just want a clean way to organize your code into folders. What then?
1. I understand what absolute imports and absolute file system import are. I'm not sure I understand what your first point is. 2. Yeah, it's just an odd urge I get from time to time to divide python programs into folders which aren't already in sys.path. I could add them to sys.path, it just feels [wrong](http://www.reddit.com/r/Python/comments/k3neb/import_complex_or_complicated/c2hgajb) to me. 3. I'll try to make the post more obvious about that.
_print_ ams a function in Python 3. Ams not a bad idea really to just use it as functions in Python 2. 
AFAIK ActiveState Python (the commercial version) comes with a package manager that uses pre-built binaries, but I think all they do is fetch the packages from PyPI and build them on their server cluster so all the package manager has to do is pick the right one.
have you thought of using CPack? meshes well with CMake...
Chances are the host app imports the Python sources as a package! Then you've forced yourself to add a single value, the source directory, to the app's internal `sys.path`. That's what you're supposed to do when jealously guarding your source: ugly tricks. And to make the pseudo-packages into real packages. You're making the number of `__init__.py` files into a stupidly big deal.
Programming language choice is most likely not a major factor in the profitability of a website (assuming it's not a ridiculously inappropriate choice); so you wind up with different websites running on whatever pet language their founders were a fan of. Frankly, what does Digg have to do with the question? There are tons of popular websites (far more popular than Digg or reddit), and they all run on varying technology stacks. If there was a "silver bullet", then most websites would use it, but [there isn't](http://en.wikipedia.org/wiki/No_Silver_Bullet).
It's content that drives a successful website. If a programmer is doing his job right, no-one can tell what the site is written in. Would Digg still of hit the shit if they used Python? More than likely. Would Digg run better if it used Python. Depends!
I agree with the choice of language being that what the founders preferred. So why should people choose Python instead of other programming languages? &gt; what does Digg have to do with the question? There are tons of popular websites (far more popular than Digg or reddit) Far more popular than Digg or Reddit, and in the same category? Such as what? Doesn't Reddit primarily run on Python? Which programming language do you recommend? And why? 
&gt; Would Digg still of hit the shit if they used Python? More than likely. You mean that positively or negatively? If the latter then you're saying if Digg switched to Python would be a bad thing.
No, he's saying Digg sucks regardless of implementation language.
As to be expected on reddit. So then you guys don't think it would be better to use Python vs all other programming languages?
noFuckingTypingLikeThis for methods, please. else, congrats man! that is exciting.
It seems like you're basically asking "what makes Python good?", in /r/Python, which is a bit ridiculous. Read the wikipedia article for Python and form your own opinion. There is no objective way to argue for one programming language over another. &gt; Far more popular than Digg or Reddit, and in the same category? Such as what? Doesn't Reddit primarily run on Python? What does "category" have to do with it? Websites, regardless of "category", largely deal with many of the same problems, so the matter of tool/language choice applies pretty similarly to any website. &gt; Which programming language do you recommend? And why? Python, because I like it. That's why I subscribe to /r/Python. Other people might give all kinds of detailed and rational explanations for why Python's great, but I find that irrational personal taste tends to trump all that stuff. I like Python because I just like it. You may or may not like it. Find whatever it is you do like, and pursue it.
troll
&gt; What does "category" have to do with it? Websites, regardless of "category", largely deal with many of the same problems, so the matter of tool/language choice applies pretty similarly to any website. Hmm I thought Python was chosen because it was most suitable for the needs of Reddit. So you're basically saying every site could run on Python. Is Python faster than other programming languages? Yeah I ask here, because you are the supposed "experts" or more knowledgeable than average about Python. Right now, I'm not being convinced about whether Python gives enough advantages over all other languages.
I may ask hard questions. However, I'm not a troll. And I'm really trying to make up my mind whether Python is better and worth choosing instead of all other programming languages.
&gt; Hmm I thought Python was chosen because it was most suitable for the needs of Reddit. It was probably more a matter of Python being most suitable to the personalities and preferences of Reddit's developers. They could have built the same website with any number of different languages. &gt; So you're basically saying every site could run on Python. Nearly. &gt; Is Python faster than other programming languages? It is faster than some and slower than others. It's not particularly fast, compared to the fastest languages. And for most websites, that's not a problem. &gt; Right now, I'm not being convinced about whether Python gives enough advantages over all other languages. That's for you to investigate and decide for yourself. /r/Python is not a cheerleading or sales team, and I don't think anyone is going to be upset if you decide to use another language. Use whatever you like.
It's not really a hard question. It's a naive question that leads people to think you're intentionally being provocative. Digg and Python are utterly unrelated.
I mean that in the sense that no matter *if* they used Python, they would have still turned to shit as it was admin decisions, content and terrible userbase that made the site what it is today. Not the language they programmed it in. Overall Digg wasn't too buggy, it was up pretty much all the time, too.
Sorry, it's hard to tell if this whole thread isn't just trolling on your part. I think Python is beautiful and use it frequently, but there are reasons to use different tools for different jobs. For example, it's not really fast enough for CPU-intensive work - I'd never write an FPS game engine in Python.
probably yes. I know pnoise from other project minetest by celeron55. An opensource game based on minecraft.
I don't try to be provocative. I try to get answers to questions. Not utterly unrelated depending on the context though. Thanks for responding though.
Alright, isn't it advantageous to use Python instead of a mix-match of programming languages for a site?
Yeah I mean specifically for a site.
He uses some other algorithms too, I'm not sure which though. Hopefully one day he will open source that section of his code as it is very interesting.
Mozilla serves out 200+ million requests per day with Django. Yes, Python can be used to run pretty much any web site.
Cross post this to /r/CollaborativePython and we could help you write a GUI.
Alright thanks, that's a good example. Which version of Python should be used? 2.0? And would it be easy to upgrade to newer versions?
I am glad. One day I may even move to Python 3 then.
I wish I could care about this but I honestly don't. :( Using python to produce deliverables requires using py2exe and py2app. These 2 should have been part of a standard install a long time ago. Nobody cared. Also, investing years in coding with wxPython (which Guido endorsed as the best alternative to Tk) leaves the would be 3.x switcher with even more bitterness. 
Main fix in 3.2.2 over 3.2.1 is this, which the linked blog fails to mention (and instead gives "what's new in 3.2 list"): http://bugs.python.org/issue12576 
1) All these modules you named are 3rd party modules, so their maintainers are to blame for not making them python3 ready. Many others did their homework or are doing it right now. 2) py2app is mac only, so it hardly belongs in the python core.
I wouldn't have worded it the way GP did, but the reality is that py2exe and py2app are pretty big and many people have developed a personal dependency towards them Some key packages and utilities remain in Python 2 world exclusively and if they don't make the jump spontaneously, then someone will better fund it or other alternatives might eat Python 3's lunch.
Hello, I copypaste the release notes to get traffic on my blog.
Yes, but that's true for any language. Python, Ruby and even Node.JS belong in the same category in this case. The differences are mostly superficial. Heck, you could even toss Java Servlets and the .NET platform in there if you want. Language choice mostly boils down to aesthetics these days. Pick a language that fits your brain. Some people even use Haskell for web programming, though I wouldn't recommend that unless you're really into mathematics and functional theory. I don't think Python is superior to Ruby or vice versa. I just like Python and dislike Ruby. That's why I'm here.
Okay, and an other question: If you hire someone to program for you... how do companies keep control over their code, or that it doesn't get stolen, copied or abused somehow by the programmer?
I could give a shit, but I don't.
I don't either.
Undiluted release notes from [python.org](http://python.org) here: [Python 3.2.2](http://www.python.org/getit/releases/3.2.2/)
1) I know they are 3rd party, as I said before, I believe the functionality of the libs involved in distribution should have been part of standard library. Regarding wxPython, this is no micro module that someone cooked up in an afternoon. Porting it to 3.x branch is a **HUGE** effort and it rests (to my knowledge) mainly on the shoulders of ONE man. It is heavily affected by the changes in the C API not just few cosmetic changes here and there. All I'm saying is that it is not a matter of homework but a matter of volume and priorities. 2) functionality of py2app belongs in the python core. The module producing deliverables should take only one setup.py and produce a .app, .exe or a linux binary depending on the platform where it is run. 
I agree. Python's a great language to develop on. It's just that generally only other Python users can benefit from it without resorting to methods which feel both hacky and bloated. My preferred choice is to go: *.py -&gt; py2exe which leaves me with a gianormous folder with a single executable. Don't even get me started on using PyQt along with py2exe. There needs to be a better method of converting .py modules/applications into standalone executables. 
&gt; My preferred choice is to go: *.py -&gt; py2exe which leaves me with a gianormous folder with a single executable. aren't you using a zip embedded in the exe? My distributions have only the appname.exe, few Microsoft DLLs and the "images" folder. Some of the apps also have a config file or some sqlite database but nothing gianormous. :)
Gianormous being 6mb for a script which continually prints "Hello world" is a bit excessive, though.
Any programmer who you hire will feel comfortable copying the code to wherever it is they need it, and they'll be completely justified in doing so. It's not really something you should be concerned about. Theft or abuse is controlled by a combination of professional integrity, concern about their reputation, and your ability to sue the crap out of them.
If you're starting from scratch, I would recommend 2.7. It's the last major release in the 2.x branch, and most future Python development will be on 3.x, but many libraries are not available yet for 3.x and 2.7 will continue to be supported for a very long time.
Okay so if you want to build the next Amazon, you must hire programmers to help out. They could copy the code. The only counter-measure you would have is to trust on their integrity not to abuse/copy the code or sue them if you find out, right? There are no other safety mechanisms? 
I'm responding as if you're interested in why people would want the source material rather than your blog post. Your post offers no additional information on the release, no in-depth highlight of a single issue. Just a link to some podcast you made. People who actually use this technology need to read the source announcement anyway, because we can't trust your (or anyone else's) repackaging over the canonical source notes. We need links to actual bugs fixed, so (for example) I can know if I can take out my hacks to get around a certain issue. This is included in the source material I linked, and omitted from your blog post. Add value with your post, don't just repackage, advertise your other stuff, and publish.
I may not completely understand your problem. It sounds like you have python bindings for native python calls to your c-library. In other words, you can do an import some_package from within python and that will be your compiled c-package. If you have a project folder area where all of the python modules are, you should be able to setup PYTHONPATH to include multiple folders. On Linux, it's separated with a ':'. I believe windows is a ';'. Then, after you update your shell's environment, you should be able to just call 'import xyz'. You may also be interested in using the [site package](http://docs.python.org/library/site.html) to statically or dynamically import a package (provided you have a sense where it is in your python code). This is not preferred, though, unless you have a set path and it's relative.
Oh, I see what you mean now and I agree. I never could understand huge size when similar functionality fitted in much much lower sizes. Just look at lua. I know lua is not python but still... I don't understand how the remaining functionality could take up so much. 
Thanks a lot!
I suppose it's because of literally all the libraries that each module imports and imported as well. Just look into that libraries.zip folder when you make it, import a library or three and you'll see that's all there. There are methods to *explicitly* import those that you only need. But even then I think you only save a small portion.
distutils isn't made to build large C++ projects, so there is no need to change your existing build to distutils. The only C++ you should let distutils compile is small stubs. distutils isn't really a tool that should do complex autoconfiguration either. The most "detection" it should do is fail to build if the headers are missing, and give a README explaining where to find the non-python dependencies. I suggest packaging the C++ project according to the practices of your platform and your target (I don't even know if it is end users or developers) and separate from the python modules. Then document that the installation is in two steps, C++ then Python. There are ways to orchestrate inter-language projects with buildout (which has rules for eggs, and "cmmi" extensions for ./configure &amp;&amp; make &amp;&amp; make install tarballs), but that may be outside your comfort zone.
Yup, like this one. Just wish there were lots more tutorials/examples.
I disagree. I care about pip and stdeb, which are my preferred ways of distributing Python code on Linux. I don't want these projects to be tied to the Python release cycle, which is slow precisely because Python ships so many things in a single project already. Conversely, I don't think the binary-stuffing approach of py2exe is any good or that it should go anywhere near the common platform; rather that it should be left to people who actually like the approach.
1+
Suggest it to speed.pypy.org :D
Woohoo for stable ABI! I'm tired of having to upgrade my modules along with Python.
great talks
Given, it will work written as a "function", or you can do `from __future__ import print_function`. However, this is a bad idea, since this is a trivial case for 2to3 to fix on its own.
While I'm very glad that Python 3 is moving forward, being primarily a web developer, I'll be more glad when the libs, modules, and frameworks catch up. The Core team is going an awesome job though.
good idea.
I think Kamaelia comes close. http://www.kamaelia.org/Home.html From Kamaelia website. "In Kamaelia you build systems from simple components that talk to each other. " it is developed by BBC research.
If you are trying to get a recommendation for a business decision you might be barking the wrong tree here ;) You won't find as many python developers as for example php or java... On the other hand any good programmer with a bit of flexibility should be able to pick up on python very fast... You might also find that developers who favor python as their tool of choice share a certain mindset different from developers who are favouring other tools ;) (no judgment intended...) Developers can create "bad" or "good" code regardless of programming language. I would rather have good code in an "unfavourable" programming language than bad code in a "favourable" language. So you might want to focus your question on how to find "good" developers. It is far more important than the choice of programming language... Best case you find developers that have a track record in successfuly building something similar to what you are planning...
How do you suggest it be improved?
Try this link better: http://interactive.blockdiag.com/ At the bottom you'll find quick links to other tools (i.e. sequence diagram tool) He keeps his open source repos here: https://bitbucket.org/tk0miya/ Kudos to the author!
If you already have a cluster with a queuing system it most likely has MPI installed. In that case, I would use [mpi4py][1] for parallel computing. One advantage of using mpi4py is that if you are doing your calculations on a cluster that has a high speed low latency network such as InfiniBand your interprocessor communication will use that network as opposed to the much slower ethernet network. Another thing you can do is communication between multiple different programs with MPI. This means that you can write one program in python and another in C and have them communicate over MPI. This can be a very straightforward way to gain performance. You could have a server written in python and a number of workers written in c. In most MPI environments you can run these types of jobs. They are called MPMD (multiple program multiple data) MPI jobs. An example of how to run one would be like so (at least with OpenMPI this works): mpirun -n 1 server.py : -n 8 worker.exe This would start up 1 server and 8 workers. They would both belong to the same MPI_COMM_WORLD and can communicate over MPI. For some types of problems this could allow you to do much of the complicated development in python and the number crunching in c. [1]: http://mpi4py.scipy.org/
Right. It's exactly the same as hiring anyone to produce anything of value.
I have a small GUI app that needs to reach my clients. Most of them are doctors with minimal computer knowledge and the platform they use is Windows XP and 7 with few of them having Macs. What alternatives do I have to the py2exe/py2app combo? cx_freeze? I'm not planning on forcing everyone to setup a full python environment so that they could open my little GUI. I admit my ignorance. Maybe I'm missing a very simple and sensible solution. If you know one, please point it out. 
Thats so cool! :D http://interactive.blockdiag.com/?src=ewogIEEgLT4gQiAtPiBDOwogICAgICAgQiAtPiBEIC0-IEUgLT4gRQogICAgICAgICAgICBEIC0-IEYgICAgRSAtPiBGIC0-IEcgLT4gRCAtPiBaIC0-IEEKICAgICAgICAgICAgRCAtPiBHICAgICAgICAgRiAtPiBHIC0-IEIKICAgICAgICAgICAgRCAtPiBBIC0-WiAtPiBBIC0-IEMKCn0 My awesome diagram 
hmmm, google cache maybe? http://webcache.googleusercontent.com/search?q=cache:YUNVS2N-2EMJ:python.net/~goodger/projects/pycon/2007/idiomatic/handout.html+%22Coding+like+a+Pythonista%22&amp;cd=1&amp;hl=pl&amp;ct=clnk&amp;gl=pl
I like and use cherrypy. I love its flexibility. With full-blown frameworks like django, things go great until you want to go against the grain. With cherrypy, you've got a lot of freedom in your design; everything from choosing your database back-end (or not using a database at all), to your choice of templating engine (or not using one at all). cherrypy's strength is also its weakness: lots of common components that are cheap or free in other frameworks, like authentication, will take some extra work on your part. cherrypy shines with smaller sites, especially web apps offering an API.
Found the same solution after running through Python .org's pages and forum posts and whatnot.. Sometimes the most obvious solutions seem to come the last.. 
This is probably the closest thing to what I wanted, but it seems un-pythonic and prone to errors. Is there a better way? (Also, I'd have to have custom code for various platforms)
Not quite what I wanted. I'm not interested in how to redistribute python code as an exe...what I'm interested in is how to include prebuilt pyd files in a distutils package or installer that is pythonic.
I already am, but CPack doesn't install to the built-in python directories in the way that python expects it to. I'd have to figure it out by hand, and all the websites say "To install a python package, use distutils." I can't use distutils because I have built C++ modules.
Yep, this works perfectly. My problem isn't "how do I get it to build/run" its "How do I install that package using distutils or any other package manager so that it goes to the place it is supposed to without using PYTHONPATH"
The problem is that there isn't really a C++ part separate from the python part. Its a python codebase that builds compiled python modules as output targets. It generates a bunch of packages with some .py files and some .pyd files. Everything on the web says "To redistribute a python package, use distutils. To redistribute a python package that has native code, use distutils to build the native code" and thats not what I want. I want to redistribute a python package that uses native code that was built with CMake.
[I'm the author.] It looks like python.net is down right now. I expect it will come back up before long. If not, I'll find another home for that article &amp; the rest of my stuff.
First of all you should give some description that explains *what this program does* and *why it is useful* for someone. "It downloads the JAR file based on the JAD file provided." Very informative... What is a JAD file? I had to go to wikipedia to figure it out. So give an example that makes clear what your script does.
http://webcache.googleusercontent.com/search?q=cache:http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html&amp;hl=en&amp;strip=1
you are. Try doing a pong in pygame/pyglet before the competition to learn the basics (if you want more challenge do a tetris). Take a look at the possible themes and think what game you will do. And last but not less important, create an account at the site and read the rules and test the skeleton code (and the uploader after the competition has began). If you do all that you will be on equal footing to most people.
It's on scribed http://www.scribd.com/doc/2345945/Idiomatic-Python
Just a quick note about the section "Testing for Truth Values". It recommends the expression if items: ... over the more explicit if len(items) != 0: ... To each his own, but I think the former can be dangerous, especially if *items* is not a standard python collection, but some object from an external (possibly your own) module, even more so if *items* is not a collection at all. The semantics of *items*' __nonzero__ method might change and will possibly break your code. 
I love this sort of thing - so thumbs up. Small thing - I would a direct link to my "results" - and also a radical measure, eg. "59 % east coast", or maybe a 2% east coast, 1% west coast, 97% vanilla ice.
WingIDE needs X-11 on a Mac. Sorry, not me.
If you look here: http://wiki.wingware.com/FeatureRequests You will see the following is planned: "Native OS X GUI, reorderable tabs, and various other GUI issues (requires port to a new GUI framework; in progress)"
Then someone has broken their API backwards compatibility and should document it accordingly with an upgrade path.
They work for what you want. They just shouldn't be part of the batteries included.
"PLANNED"...is "VAPORWARE" until it happens. I am glad they are doing it though. WingIDE has a lot of stuff in it. Edit: That might sound harsher than I meant it to so bear that in mind.
I personally prefer Mako because it's just enough and nothing more, but it's good to see more options entering as a 3k option, Jinja was one I used on occasion for 2.6/2.7 applications.
Just used cherrypy in a simple web demo we needed recently: https://github.com/ingenuitas/SimpleCV/blob/master/SimpleCV/examples/cloudcam/cloudcam.py 
is PyCharm on Linux/Mac a java app ?
lucky you !
arrgh crap, i don't want it then
Why not just pass your object from main into a function or class from B? #in module B ... def use_wonderfull_object(wobject): wobject.superMethod(self.bar) 
I actually needed something like this recently, I ended up just generating graphviz files and using the graphviz program to render things. I like this better.
so... the main code would look like: import A # not from...* uniqueObj = A.wonderfulness() import B B.rememberThis(uniqueObj) and B would have uniqueObj = None # create a B-global def rememberThis(handle) global uniqueObj uniqueObj = handle hmmm tedious but could work...
In main instead of B.rememberThis(uniqueObj) You could simply do B.uniqueObj = uniqueObj (maybe you should see if there is a way to avoid that module global... Or put your "globals" into a seperate module so you can use them from anywhere....) 
Thanks for the reply and a great tutorial!
Newbie here. What's the advantage over textmate or sublime text?
*Disclaimer: I'm a Python beginner and have only used the trial versions of these (other than Wing 101). Offering this anyway for what it's worth.* I really liked the free Wing 101 as a beginner's, no-frills IDE. It has **no** autocompletion or source assistant, just syntax coloring and smart indentations. On Ubuntu, Wing looked dead sexy. Until I grabbed the full trial for the commercial IDE ... it starts out looking terrible (no native, very blocky, difficult to read widget text). Telling it to use my system's GTK2 just crashes it. In default "ugly" mode it was very distracting, but the source assistant is lovely. The code autocompletion is fairly potent, better than Komodo from what I saw. I still need to spend time with it. PyCharm under Ubuntu has one serious problem right off the bat, font rendering. It looks so thin and odd, regardless of setting, something PyDev (also a Java-based IDE) does not do. That aside, it's incredible. The refactoring is top-notch, the little shortcuts are quite useful, and the autocomplete features appear to be more powerful than Wing IDE's. I don't like using Java-based IDEs due to the startup time and lagginess of the interface on my system (in Windows and Linux), but PyCharm is very good, especially on Windows where the font rendering is normal. (I have nothing against Java, otherwise.) On the other hand, Wing IDE has been around for a long time and is built by a Python-only team. They're obviously passionate about the language. I'd love for a Python expert that has used them both to chime in.
I'd suggest you look at [cherrypy](http://www.cherrypy.org/wiki/CherryPyTutorial) or maybe [bottle](http://bottlepy.org/docs/dev/). Both good libraries/frameworks to get started creating web apps in python
I want to like PyCharm, but on OSX it (and everything else that JetBrains makes) has a weird habit of hiding the mouse cursor behind menus when using full screen zoom. I filed a bug on phpStorm, they let the bug sit for a while before making a single change to confirm that it was a problem with the entire platform, and a few months later it was closed without comment.
I started off building webapps on a friends VPS on which I installed Tornado. As a beginner, the documentation for Tornado is OK. There is also Django which IMO has great documentation. I've never had a question about the Django framework which I didn't have answered directly from their docs. I should probably add that most of my questions were also pretty beginner-ish.
Well, you'd only be able to distribute the code to systems where the compiled binaries are valid then... but you would just need to include the binaries and move them to the right locations... http://docs.python.org/release/2.5.1/dist/module-distutils.fileutil.html
Goodness. I just tested this: junk_A.py: class thing(): def __init__(self): self.member = 99 junk_B.py: def look(): return handle.member junk_main.py: import junk_A singularResource = junk_A.thing() import junk_B junk_B.handle = singularResource print junk_B.look() When I run junk_main it prints 99. So the main code can inject names into modules just by assignment. I'm sure there must be some reason this is a bad idea...
Everyone seems to be raging about PEP8 violations. I don't disagree with some of the complaints but I think they're mostly superficial, especially for your first program in Python. If you're worried about it just run pep8.py or pylint and it'll show you line by line what to fix. Here are some tips that are hopefully more logic related. elif "N" or "n" or "no" in yorn: return False probably doesn't do what you expect it to. When the program gets to this line it will always return False, because the value of "N" is True. It's evaluated like elif ("N") or ("n") or ("no" in yorn): What you want is: elif yorn in ["N", "n", "no"]: or maybe elif yorn.lower() in ["no", "n"]: to also catch NO, nO, etc. You also spend a lot of effort parsing sys.argv. This is tedious boilerplate code that Python happens to have 3 modules to solve for you (and they'll give you a nice output you probably wouldn't want to put the effort into making). If you're using Python 3 the best choice will be [`argparse`](http://docs.python.org/dev/library/argparse.html). On line 40, you name your variable `file` which is fine, but just realize you're overwriting a built-in name for the scope of that function. The built-in `file` is a type object you can use to do `isintance(my_file, file)`. Your `find_url` function could be rewritten to better take advantage of python's strengths. I have two possibilities for you: def find_url(jad_filename): with open(jad_filename) as jad: info = jar = None for line in jad: key, value = line.split(":", 1) if key == "MIDlet-Info-URL": info = value.strip() elif key == "MIDlet-Jar-URL": jar = value.strip() if info and jar: return info + jar alternatively, you could parse the file into a python dictionary with some generator comprehensions, and then just pull out the values you need: def parse_jad(jad_filename, separator=": "): with open(jad_filename) as jad: return dict(line.strip().split(separator, 1) for line in jad.readlines()) def find_url(jad_filename): headers = parse_jad(jad_filename) return "{MIDlet-Info-URL}{MIDlet-Jar-URL}".format(**headers) Just a disclaimer that these function aren't very defensive and will throw exceptions for unexpected input. Finally, it's always nice to wrap a script in a if name == "__main__": main() with the logic in `main()`. This is nice because maybe you'll want to use this script as a module later to borrow some functions from. Overall, your code is perfectly fine, just not embracing all the freebies you get from Python, which is totally expected if you're new to the language.
I think of the metaclass like a function that mutates a given class. If M is your metaclass, then M(old_A) = new_A. By the time you get to B, the action of M (printing foo + the class name) has already been applied. You can inspect that B indeed has a metaclass of foo by inspecting ``B.__metaclass__`` (at least in Py 2.x.. I really haven't delved into 3 yet). If you want to apply your print statement everytime a class is created, you would override the ``__init__`` or ``__new__`` method of your metaclass.
Yeah /r/django is a good starting point for you. 
Try PyDev, I find it's a lot faster (after initial start) and nicer than both. Not to mention it's open source and you'll be right at home if you've used eclipse before. On the other hand, plain text editors like Geany and Notepad++ do a pretty damn good job in a language like python too.
Is it worth brining Komodo into the fight? As a full time Python dev I have used all 3 quite extensively and I often switch back and forth from Komodo to WingIDE. PyCharm's laggy UI always bothered me. 
did you search for this monitor problem on the internets? I never had any problems with my mbp, so maybe it is just your laptop that is broken.
Yep, define a __new__ method on the metaclass (make it actually an object) and things are going to work fine. But nice, I didn't know you could use a function for a metaclass :)
The visual is good, but the graph drawing algorithm is not as good as that of Graphviz.
Django has the largest and most active developer community, so I recommend you start there. However, if you just want to play around with seeing how Python can spit out some html, I would suggest looking at bottle.
Cant really go wrong with Django. For something different, you could also try Pylons (now Pyramid)
Is your omission of PyDev accidental?
[Archive.org](http://wayback.archive.org/web/*/http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html) 
What you're describing is a Singleton. You should avoid using them though, they make testing hard and complicate things. Using dependency injection works out better in the long run. 
I see no problem with that. For instance, I usually create an ``environment.py`` in my modules, and then import it like this: import proj.environment as env Then I have access to a "global" environment module whose state is preserved across my entire project. This is not an uncommon idea either, a lot of mainstream projects do it. Fabric and zope are two that come to mind.
The Django documentation is the best I've ever seen, for anything. Seriously, it's fantastic. The main problem with it is that then you expect everything else to be of the same quality.
With respect to your PyCharm appearance issues, the problem is probably related to how Java desktop applications are drawn. PyCharm is a [Swing](http://en.wikipedia.org/wiki/Swing_java)-based user interface. Swing will basically draw everything from scratch on any platform while applying a look-and-feel to make it appear native. On Linux, PyCharm would use the GTK+ look-and-feel, which is good, but not perfect. It isn't, however, using actual GTK+ engines to do any drawing (which is why things look good, but not quite great) to the best of my knowledge. On Windows, Sun/Oracle probably spent a bit more time making the Windows look-and-feel a little better just based on market share. PyDev, on the other hand, uses [SWT](http://en.wikipedia.org/wiki/Standard_Widget_Toolkit), a toolkit which utilizes native components for all drawing. Eclipse-based applications will generally look far closer to native (if you can even tell the difference) than Swing applications generally speaking.
I'm also a PyDev fan. I'm not familiar with WingIDE, but I did the trial of PyCharm. PyCharm is pretty neat and has some features I'd be interested to see in PyDev, but I didn't feel it was $99 better than PyDev. I suspect I'd feel pretty much the same about WingIDE.
aha! i was having such a big problem with python3.2.1/urllib for some reason not retrieving data from sites when it worked with 3.2.0. I also love how i thought it was a bug and asked the #python irc channel if they thought it was too, and they thought i was a dumbass :&lt;
never used pycharm, but i use wingIDE every day and i find it great. lots of neat tools, VCS integration, source assistant, all great.
How is this related to python? Are they using python in their course?
Thanks. I verified that making it a class and overriding `__new__` works, but I don't understand why. From the interpreter's standpoint, they should both be considered callable objects and nothing more. Python 3 eliminates the `__metaclass__` attribute in favor of a slightly more elaborate system. See [PEP 3115](http://www.python.org/dev/peps/pep-3115/).
Thanks, it does work. But I don't understand why. Shouldn't they both be considered simply as callable objects? The rule I linked to in the Python documentation &gt; Otherwise, if there is at least one base class, its metaclass is used. should apply regardless of what kind of object the metaclass is.
What freedom does it restrict that you want?
The freedom to use in any circumstance, the freedom to study and modify, the freedom to distribute original or modified copies.
"use in any circumstance" - what does that mean? I hear the freedom argument a lot but I haven't really understood it. 
Python web stuff is mostly WSGI these days, so I would read up on that a little. If you use any of the numerous tools or frameworks others have mentioned, they'll probably use WSGI at some point, either to code some of the logic or to run the site. That said, I personally like [flask](http://flask.pocoo.org/) and wrote my personal site in it (plus sqlalchemy cause I wanted to be able to write pages as blog posts). Used tornado to host it, which went /okay/ because I started getting 500 errors (oops just checked and I'm getting 'mysql server has gone away' so it wasn't a tornado thing like I had though).
I don't think he's offended, he's just tired of people bringing religion into computing when they aren't following their own rules. :) That's how I feel anyway... they have closed source phones and chose to run hardware that's not free and then tell other people to be free. I think there's lots of parallels in the protestant christian community, where lots of the preachers drive expensive cars and have huge houses.
So how do I know what the right locations are when the only documentation says "Use distutils to do it" 
[It's back up now](http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html)
The only technical way I can think of to prevent copying is to just make the effort of copying so slow and cumbersome by tying up their development environment so tight they can't actually do their work effectively. I don't know the specifics of how you'd do it (it would vary depending on the environment), but they'd never get *anything* done. Edit: I should add that if you were to try going down this route, the only programmers you'd get would be the bottom of the barrel because no-one else would put up with such an environment.
DRM-free, for example. Without any clauses about what hardware to use, and so on. Check http://gnu.org/philosophy for more comprehensive resources on the topic.
You're creating class A with a metaclass of `type`. So `type.__new__`is what creates class B. You need to actually subclass `type` and override `__new__`. Edit: I overlooked your final question: &gt;&gt;&gt; mcls = type('mcls', (type,), {}) &gt;&gt;&gt; cls = mcls('cls', (), {}) &gt;&gt;&gt; cls.__class__ &lt;class '__main__.mcls'&gt; &gt;&gt;&gt; self = cls() &gt;&gt;&gt; self.__class__ &lt;class '__main__.cls'&gt; 
DRM free what... you can't play your drm free content on an iPad? Why are you telling me to go to gnu.org? You don't have your own reasons for why that device doesn't let you do what you want? Why did I bother responding to you if you're just going to refer me to your religious text? You're clearly just being a troll about the whole free thing. Thanks a lot
1+
If I understand what you're saying, the metaclass of the definition I provided for `A` is `foo`, but the metaclass of the class *returned* by this definition for `A` is actually just plain old `type`. This would mean that `B` inherits `type` as its metaclass. The problem is that I called type(name, bases, classdict) which translates to type.__new__(type, name, bases, classdict) and I guess the first argument to `__new__` is used as the metaclass for the returned class. That makes perfect sense now, but I wish it were clearly documented on the language reference page. I looked all over for information on precise metaclass and `__new__` semantics and didn't find this. Thank you.
What kind of site? I've had good luck with Flask, Bottle, Django, and Web2Py. They each have strengths.
I hear Reddit is built on Pylons: http://pylonsproject.org/
You don't inherit the metaclass *keyword* but actually the subclass of type that constructed the base class. In your case it is simply "type". As a general rule, if you want inheritance, use a class. This applies to metaclasses as well. Note that it isn't either enough to just rewrite your code to a type subclass, you have to actually pass your subclass to ``type.__new__``: class foo(type): def __new__(mcls, name, bases, classdict): # this is not enough: cls = type(name, bases, classdict) # this works: cls = super().__new__(mcls, name, bases, classdict) # which is just a decoupled version of this: cls = type.__new__(foo, name, bases, classdict) print('foo ' + name) return cls class A(metaclass = foo): pass class B(A): pass ``__new__`` is (for all objects) special-cased as a classmethod meaning it takes the class as the first argument. The ``type`` class sets this as the metaclass for classes it creates. That class must itself be a subclass of "type" (or be "type" itself). The form you used, ``type(name, bases, classdict)``, is really just a shorthand for ``type.__new__(type, name, bases, classdict)`` - so you see how "type" becomes the inherited metaclass.
That sounds like what is happening. Thank you for the education and insight!
I recommend you use web2py it's one of the easiest places to start for a newbie. I know, I started w/ it a few months ago. 
You might be right. I might be naive. I think that we, the programmers, should use our superpowers for good and make the life of those not blessed with this gift just a little bit better. This involves deliverables like standalone apps. Maybe the world is not like this, maybe the programming languages should make only **my life** easier. 
I use wingide at work and I love it. I'm a pure vim guy but wing is about the only commercial app I feel is worth buying.
They recommend Python to code the assessment tasks with. I haven't seen the course material myself yet but I presume that they will use code examples written in Python seeing that they recommend it.
Django is pretty amazing. DRY (Don't Repeat Yourself)!!! Run the tutorials and you'll see why: https://docs.djangoproject.com/en/dev/intro/tutorial01/
Reddit is also built on a very simple web framework called [web.py](http://webpy.org/). Google App Engine's webapp framework is based on it.
I've only ever built one web-app and it was for a small hobby project. I found web2py a very useful learning tool with some great tutorials and excellent documentation. I am not a web developer, so I have no idea as to its suitability for large scale projects, but I certainly found it useful for learning and easy to get into.
I abandoned Komodo for PyCharm because of the lack of automated refactoring in Komodo. PyCharm's killer feature seems to be its code intelligence and integration with Django.
Or webpy! I love flask for various reasons but I think webpy is actually a little more user-friendly for a beginner. And it has nice db wrapping.
So it's basically [graphviz](http://www.graphviz.org/) as a web app?
I thought the same after having worked with Eclipse (which is a bit sluggish IMO), but PyCharm is actually pretty snappy. It just takes rather long to boot up. I'm doing all of my Python work inside an Ubuntu VM these days, so I just leave PyCharm running all the time and I haven't had any problems with it. The only thing that takes a long time (~ 1 minute) is when you add new virtualenvs and it has to go through all the binaries and site packages to parse the packages. This is on a 2.4 GHz / 4 GB RAM Windows 7 notebook, by the way. So your desktop experience might be even better. I originally picked Komodo IDE because it isn't Java-based (IIRC), but after watching their demo at the PyCon IDE panel, I was instantly sold on PyCharm.
Would you mind giving examples of both so I understand the above better, goodger? Much appreciated! 
I can't recommend [Pyramid](https://pylonsproject.org/docs/pyramid.html) (the next iteration of Pylons) enough. The documentation is excellent, and it's incredibly flexible (seems to pride itself on letting you choose the bits and pieces that makeup your [MVC](http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller) solution. The community was/is extremely responsive to any problems I encountered (irc channel). You might find, as I did, that webdev in Python is a bit more work than just firing up a PHP page. My first stab at it was with Django, but I was completely overwhelmed by the scope of a python web app framework. Stick through it, grind through the documentation and the final solutions you come up with are really worthwhile. Django or Pyramid are excellent mountains to climb, just having a lot more fun the second time around with Pyramid.
Yes, that is exactly it, thank you. I originally thought the first parameter to (the unbound version of) `__new__` was superfluous. I figured it was there in case you wanted to do something fancy, like reuse the same function code for multiple classes' `__new__` methods. It didn't occur to me that it also had the semantics of setting the metaclass of the resulting type. That was not documented anywhere, although I suppose it's subtly implied by the way classes are instances of their metaclass.
The reason I asked the question in the first place was because I like both IDEs. I've been using Wing for a while, and I really enjoy it. But recently I came upon Pycharm and it's pretty slick. They both have a similar feature set. The fact that it runs on java is a bit of a turn off, and the forced loading of a skeleton is annoying, but it has some great features. I'm leaning towards Wing, but I was hoping to get some more opinions. Right now, I think I'll be going for Wing.
The answer for protection against stealing is pretty straightforward: the law is there to protect you and contracts can cover what isn't already covered by copyright law. As for protecting against abuse: that's what code reviews are for. Lastly you have to ask yourself how likely such behaviour is in the first place. We're dealing with paid professionals here, not 15 year old script kiddies. They have a reputation to loose and their income depends on doing their job good enough to stay in business. They may copy a few lines for other projects or implement things the same way again, but that's simply part of the learning process and them adapting to different styles.
Can you say a little more about what the site needs to be? I assume it's something more than just static pages, since you wouldn't need python for that. I personally have some experience with Django, which I find *amazing*, but it may be way too much for you at this point.
Hilarious idea, but not quite accurate. I can guarantee I've never used 'homies', 'muthafuckin', or 'compton' in any of my tweets, much less most of the other words it found, lol.
Just FYI: * the standard naming style is lowercase with underscores for everything except classes (upper camelcase) and "constants" (uppercase with underscores), though of course practicality beats purity (PEP 8 and all that) * `from X import *` is frowned upon because it pollutes the package namespace, try `from X import Y, Z` or even just `import X` (or `import X.Y.Z as W` for deeply nested modules) * it's generally a good idea to wrap most of your code in functions; this means it won't be executed at import time but rather whenever you want -- it may also solve your particular problem (in other words: think in verbs rather than nouns; Python is not Java) Carry on.
ridiculously redundant. if len(items) != 0: should be this, if you insist on checking length: if len(items): because 0 always evaluates to False. 
right. :) will be great to make own wrappers for minecraft :) i wanna create one in python 
Seconding Flask. The Flask [Tutorial](http://flask.pocoo.org/docs/tutorial/) is one of the best written intro tutorial I've ever used for a web framework.
Our practice showed that it's too powerful. As a result, often those people who write html/css and don't understand python don't understand errors or pieces of code, so you either need not to let them write mako or waste your time helping fight with errors (or they do things slow). Mako is powerful, too powerful. edit: and of course "don't write pieces of code (even small, that can fail) in mako" doesn't work. there's always someone who is lazy.
Yeah I found flask to be easier to jump into than Django. The getting started tutorials are ok as well.
Turn recipes into .gv and render them in svg before breakfast.
[(slidenotes)](http://www.slideshare.net/r1chardj0n3s/web-microframework-battle) tl;dr Bottle wins for his use case, but he says he would use Flask or Django for a site [with real users](http://www.youtube.com/watch?v=AYjPIMe0BhA&amp;feature=player_profilepage#t=2657s). 
for me : Pycharm &gt; wingIDE (specially on osx with x11) wingIDE's UI is ugly as hell PyCharm is like all JetBrains products : stable, robust, usefull, (using IntelliJ Idea and the Python plugin is almost the same) If I had to buy one it'd be PyCharm
hm... automatic downloading and loading of source code off the internet. not sure what to think of that.
Not accidental. I wanted to compare these two commercial apps, due to the fact that to have them, you must pay money. It's not the same to compare free and open-source apps, because you can use them, delete them, and try them again at will with no cost to you.
I've been bitten by various import related problems. I've hacked around and got things working. I now can say with confidence that most of my problems were caused by poor design, poor structure, poor encapsulation, poor understanding of testing. import is fine. The problem was with me. 
Version 0.4 Released: 08/30/2011 * Fix for unicode errors when program exits using sys.exit() * Stop blank expression appearing when breakpoint hit * Store expressions in OrderedDict to maintain the order the user entered them * Don't allow same expression to be entered twice * Store filter regular expressions (for locals, globals...) in config so that they are reloaded * Allow Enter to be pressed to confirm filter expressions (same as pressing Search button) * Display breakpoints sorted by filename and line number * Fix crash when editor emits save message during shutdown * Make exception trapping work when Variables shelf not open * Add config to ignore SystemExit when trapping exceptions * Add partial translations for Greek, Japanese, Latvian, and Russian
He's not really clear I find. I couldn't watch the whole thing because it was too much of "yeah right, it's a bit like this, a bit like that".
Right, thanks for explaining.
I haven't tried it myself but I've heard good stuff about it, try Flask.
Okay, thanks.
I have used the google for you. http://ubuntuforums.org/showthread.php?t=1121501
Actually, I neglected to thank you for your comment. I found the comparison of Wing and PyCharm quite interesting.
Came here to say this. Web2py has the best documentation I have seen for Python web frameworks. It's very easy to get something up and running quickly.
Thanks for explaining.
*It's a trap!*
Just posting to give the link: http://web2py.com/
http://www.infoworld.com/d/application-development/pillars-python-six-python-web-frameworks-compared-169442
How would you compare Pycharm to WingIDE?
If its mostly static pages maybe have a look at something like blogofile
On Windows, Wing &gt; Pycharm Pycharm is slow loading and a bit unwieldy. It's feature set is nice, but it takes so long to open, and even load a project. Wing loads and opens projects in a snap.
The idea is awesome. But security part is...........
well I have not used the trial version of WingIDE just the 101 version. In both cases both were very easy to setup on both linux and windows. For instance on linux I have python3.2 installed, both Pycharm and wing were able to auto detect that for me, where as Eclipse and Pydev I had to do some searching for compiler location and settings tweaking to get it to work. For me I liked Pycharm over Wing for a couple of reasons: * customizable syntax highlighting * code completion (I'm a novice and it helps a lot) So far Wing101 is my favorite because it is free and a breeze to set up. I am currently testing Eclipse and Pydev to see how they work out for me.
I'm pretty sure the paid version of Wing has the two features that you mentioned Pycharm having, but Wing101 (the free one) doesn't have them. Do you get the debugger going in Pydev? Last time I tried it, it kept telling me to download psyco. How's it working for you?
as my development includes HTML &amp; Javascript, pycharm shines with highlighting / refactoring / jumping support in Javascript. Usual Java-suckage applies. Jetbrains and Wingguys are both avid supporters of Python, regularly present on PyCon, Jetbrains additionally on European Python conferences (Europython, pycon Germany)
fcking nice job dude.!!! i can browse reddit while i'm working.. \../ rock'on
Thanks! That's why I made it. For work ;)
If you're website isn't too complex/dynamic, you can check out [Hyde](http://ringce.com/hyde). It's a static site generator. I use it for my own website.
Why did you have HTML/CSS people who aren't Python programmers creating Mako directives ? I've shared dynamic templates written in Mako, JSP, php, HTML::Mason etc (all of which offer full programming directives within templates) with HTML developers for well over ten years and never had any issues - they stick to those aspects of the page which they know and hand off to developers for dynamic aspects. Additionally, I've also had great success with non-Python programmers using Mako &lt;%def&gt;, &lt;%include&gt;, &lt;%inherit&gt; and &lt;%block&gt; tags without any assistance. If you had "lazy" programmers who were....guessing how to write Python and then writing syntax errors? not sure how that works...that's an organizational issue. Don't these same people write javascript/jQuery as well ? Why no issues there ? If you use a restrictive template language, then these same programmers take their broken code and move it deep into a controller somewhere, producing content via concatenating HTML tags together in a Python module, just as broken but far less readable/accessible - how is that any better ?
I agree that stuff is pretty slick in PyCharm, a few of my coworkers use it and love it. Personally though, all that code re-factoring stuff just isn't for me. It always leaves me with an uneasy "did it really do that right?" feeling every time. I never found it doing anything wrong, but it seems just too easy for me to screw things up.
I ran into this the other day (in Javascript) and it took me ~~a while~~ forever to work out what was going on. 
This is my first time seeing the article and it looks great. Should provide me with some solid insight as I further learn Python and how to write it in a "Pythonic" way.
Java doesn't support multiple class definitions in the same compilation unit. Perhaps they should be inner classes? :)
As a Python programmer I have to say thank you. I'm gonna put my i lied face on and code tomorrow :D
I am by no means an expert, but it appears to be that the debugger works fine for me. pydev debugger: starting but beyond that I have no idea how to use a debugger. I just read the error messages printed to the console and figure things out from there. Also yes, i t does appear that the paid version of Wing does have those features. I would really like to stick with free, so I am forging ahead with eclipse and Pydev, and so far so good. By the way, how is the library port project going? I still feel a little overwhelmed by the prospect, but I am learning more by the day and will be able to join you soon I hope!
You are missing abstract classes in the Java version, and some decorators will be nicer for python. Awesome work! pd: Where is the code?!
python...? Edit: Ahh.. I was getting confused about the Java comment until I saw the option to change langauge at the top. Well spotted.
Working on it now! So far Pydev seems to be pretty comprehensive, plus it is free. All three (pycharm and Wing paid versions) all have similar features. I suppose it all boils down to personal preference and monetary availability.
I'm cleaning up the code at the moment.. My plan is to allow others to contribute templates for the different syntax. 
Thanks. Don't know much Java. hehe. I'll try to come up with something a bit more syntactically correct. (or you could send me a quick mockup? ;)
At least you need an abstract class for the SubredditAbstract, the PostAbstract, CommentAbstract, etc... A class definition with less than 10 lines of code, IS NOT JAVA
Great job ares623! Goodbye productivity! Seriously, good job on your first site (with Flask)! \o/
and aspen.io didn't really get a fair shot with the type of app he was creating (a wiki). Also, he didn't take into account any ORM of any kind.
Holy fuck this is cool.
Both have trials for trying them out. And you won't have pay for neither one, should you find PyDev technically superior.
Oh man this idea is awesome
Haha - maybe when I get home from work. I can see this evolving into a full IDE with the sub-reddits selectable from a tree view down the left-hand side, and the various options as icons within the IDE on a horizontal toolbar (rather than within the editor canvas).
Hmm.. Most of the responses seem to recommend a web framework of some sort. But, I suspect for some people who have done some programming (e.g. C, C++, javascript), but never web development, there might be some disconnect here. I'm also planning to use python for my next project, and I've never done anything in python before, but I am familiar with PHP and PHP frameworks such as cake and zend. Some of the reasons to use a web framework in PHP are: * There is usually some kind of HTML templating support. That is, you can write some of your website in a mix of PHP and HTML. So, you can include markup and content outputted by your PHP code in your web page. This makes dynamic content such as showing your shopping basket very easy. * The framework takes the HTTP request, looks at the URL and applies rules to figure out which part of your code to run. This is sometimes called routing. For example, You might have the following URL 'http://xxxx.com/user/add?name=steve'... and the router might 'dispatch' that to a function called 'add()' in the class 'User'. * The framework usually provides some features to handle session state. The idea here is that, perhaps you want the user to login then you want to be able to tie the next HTTP request to that login state, so you can remember who you is talking to you. You can ask the web framework to do this. Usually it will do it with cookies, but some frameworks will figure out other ways to do it if the user has cookies disabled. They'll also handle storing the session on your disk, so that if you restart your webserver, your state wont get flushed (and so your users won't get logged off). * Usually frameworks includes internationalization/localization support, so you can handle multiple languages. * Usually the frameworks will implement the model-view-controller UI model, which can take a bit of getting used to. The framework's model implementation hooks into your data model (probably a database) to help you drive the UI from your database. For example, there's might be helper functions to automatically spit out an HTML table of users based on an SQL query of the users in the database. After a career in Java, Perl, and C, I found PHP particularly unfulfilling, and the frameworks to be unsophisticated and well.. not very good. I hear good things about python though. 
Nice work - do I get to file the first bug report? Self post links seem to be broken. Still, very cool and I love to see people doing stuff like this.
Thanks. Can you explain further your bug/screenshot? Glad you like it!
I love how it works for sub-reddits! http://r.doqdoq.com/r/Python/comments/k6enr/a_website_that_lets_you_browse_reddit_like_youre/ 
This is an amazing site. Keep up the good work
I agree it is subtle. I figured it out because I had to when I wanted to set the metaclass of a subclass, without "triggering" it for the parent class.
yeah. But I think it was good comparison for the type of job he was looking to do. I actually learned a lot from the video.
came here to say the same, found about web2py about a year ago here in reddit, just one question, what does your server need to run the python web app ?
Massive upvotes for including Molokai scheme. I couldn't code without it!
Never mind - it was the post submission that was broken, not your app. I had to look the article up in the normal reddit website to find it again, and noticed the link was crap there.
Finally Python... I remember a C# version a long long time ago. But if all you code at work is python, suddenly reading C# all day long is kind of suspicious ;) Thanks!
people are going to lose jobs over this! Awesome idea man and great of you to finish it!! Btw, xpost this to r/programming!
Well, Sublime does have some code completion (Ctrl+Space being default hotkey for Windows). The biggest thing I miss in Sublime from a full-fledged IDE (most of my recent programming experience is C# in VS) is proper refactoring (and all I ever used it for was safely renaming variables).
I had a look at it, next time I refresh the proxy from my job catalogued it as "Games". Real shame cuz what little I saw seemed reaallyyy coool.
I just break an HTML page into mako templates myself. Mako runs lighter (in my experience) than any other tempting engine, so it's power is just right for me, given its footprint.
Suggestion: If you automatically show the image when you mouseover, it might cause problems for people depending on the nature of the image. food for thought.
Yeah. That was the main inspiration, but it seems to be down now. I remember people requesting it but for different languages, so I made this. 
identifiers such as "reddit.com" can't have dots in the name.
Great idea!! I'm learning Flask too, are you going to open source it? I think I could learn a few things from it :)
There's an option to disable image previews. I'll probably add a NSFW filter though.
For the subreddits? Yeah. I had to make some compromise to make reading not so difficult. The goal wasn't to have "compileable" code, but something that looks like it at a glance (from a boss, maybe?).
Cool
Which, therefore, should be just if items: because things with length 0 should always evaluate to False (?)
That is sexyness. Really great work.
None of the classes are declared Public so this should compile, but NOT recommended. Unfortunately I've been handed code like this. [Quote found from coderanch](http://www.coderanch.com/t/404755/java/java/public-class-own-file) *If no class is public, a .java file can have any number of classes, and the .java file can have any name.* *If one class is public (maybe among other classes with default access), the .java file's name must be the same as the public class's name.*
&gt; Which, therefore, should be just Of course. I was pointing out the redundancy in Nimbal's approach. &gt; because things with length 0 should always evaluate to False (?) So long as the object has `__len__` or `__nonzero__`, this works. Quote: If a class defines neither __len__() nor __nonzero__(), all its instances are considered true. Source: http://docs.python.org/reference/datamodel.html?highlight=__gt__#object.__nonzero__ 
This. Is. Awesome
I didn't take a peak but is it loading the image on mouseOver? If so, not as bad...but if it is pre-loading some images, that person's net traffic just loaded a bunch of nsfw images...
~~filter~~ decorator
I'm using the [imgPreview](http://james.padolsey.com/demos/imgPreview/full/) library for the image previews.. I don't know enough Javascript to determine if the library preloads all the images without hovering on them. I assumed it didn't since there's a little loading animation when hovering. Not sure, though. 
Hehe. Thanks. Do you think it's on topic there? I was going to post it there but hesitated as I thought it would be off topic.
good idea! thanks!
Absolutely do not hesitate. Lot of people out there want to read reddit while coding.
Do I need to run everything through command prompt like the tutorial says? Or can I write my code individually through a python shell.
Do you have any simple tutorials and/or well-written texts on MPI? I'm still relatively new to this cluster computing game but haven't gotten my teeth into MPI just yet.
Just xposted. hehe. http://redd.it/k6rwp
Not taking into account the ORM/data access layer was kind of bizarre to me, but maybe that's down to the type of work I find myself primarily doing. One of the primary reasons I refuse to learn web2py and am currently learning Pyramid after using Django for the last couple years is SQLAlchemy.
http://inventwithpython.com has a book for total beginners. The last few chapters go into Pygame. The blog also has several simple games with complete source code: http://inventwithpython.com/blog/category/games/ Also there is [Top 10 Pygame Tutorials](http://inventwithpython.com/blog/2010/09/01/the-top-10-pygame-tutorials/)
Upvoted, just for you.
it will be once your code is ready :D again great job.
The target audience is the people who know what JAD file is and who need a program like this. 
Hey, you should add a checkbox like "add random code to each post" kind of thing, so that it's even more obfuscated.
It does preload before you hover over them. On the [documentation page](http://james.padolsey.com/javascript/new-jquery-plugin-imgpreview/ "imgPreview plugin documentation") it says &gt;preloadImages – This setting must be a Boolean value (true/false). This setting dictates whether or not the plugin will preload the images before the user hovers over any particular link. This is recommended and is set to true by default – if you have a lot (&gt;30) of links to images on a single page then it’s advisable to disable this feature. :) Thought I'd save you the trouble.
by the way, the reddit user mdipierro, is the creator of web2py.
Or you can check out [PlantUML](http://plantuml.sourceforge.net/). Been using it for a while, really like it.
Couldn't you just show the specific hints that made your script choose west or east instead of showing a completely unrelated generic list of words? A nice project, that list is confusing as-is though.
*fucking* 
You can write code in whatever editor you want. The tutorial only makes you use the console for creating files and starting the development server.
you could try something like LEPL(http://www.acooke.org/lepl/). Also recommend this book:http://www.amazon.com/Natural-Language-Processing-Python-Steven/dp/0596516495 and this articles: http://www.randomhacks.net/articles/2009/12/28/interesting-python-libraries-for-natural-language-processing http://www.cloudera.com/blog/2010/03/natural-language-processing-with-hadoop-and-python/ also this: http://www.nltk.org/ the nltk is a very powerfull set of tools for natural language processing. hope it helps
absolutely loving it! reminds me of another redditor who creates a reddit UI looks like MS Office. would you mind open sourcing it? I'm just beginning learning webdev and really curious how you achieved this.
Get to f'ing work slackers... That's why they pay you money you know? To do work... "haha boss man. you're paying me to do jack shit". Wow, you must be so proud. I give up. America is doomed.
I regularly work in html, javascript, bash, php, actionscript and python. I've been using IntelliJ Ultimate (which has 99% of PyCharm's functionality provided as a plugin) and I really think it was worth the $250 I paid for the personal license. I can't compare PyCharm vs. Wing, but for polyglot development I've found the JetBrains' IDEs to be excellent and generally faster and easier to use than Eclipse.
I was too lazy to teach myself about MPI and I instead took a class on it. It seemed intimidating because most of the C/FORTRAN API requires so many arguments. Just the most basic send has 6 arguments. It turns out that MPI isn't so complicated once you have a little bit of experience with it. A google search turned up this document: ftp://math.usfca.edu/pub/MPI/mpi.guide.ps I read through the first chapter and it gives a pretty good overview of how to use the API. Unfortunately MPI can be a good bit of work to setup. I personally like to use OpenMPI as it is easy to build and install. In general to build a MPI executable you have to use wrappers around the compilers installed on your system. So to compile a c program you have to use mpicc instead of gcc. If you have any more questions about MPI programming or getting it setup I'd be glad to help. I do a good bit of MPI programming and debugging as well as cluster system administration so I should be able to help out if you get stuck anywhere along the way.
Am I the only one who wants to submit a bunch of links, which, when viewed on this site in Python, would be a useful script of some sort? Code generation via reddit!
Natural Language! thanks! I finding a lot of information using this keywords, exciting topic! However I am not finding information about Spanish parsing, but I am sure this has to exist. Thanks again!
Nice job!! Finally a person that uses his powers for niceness instead of evil.
I think learning python is very useful, but it really depends upon your reason for learning. It's my go-to language because the syntax just makes sense and months later you can go back to code and glance at it to know what you were doing. However, much of learning python is learning the standard library that comes with python. It's learning the pitfalls as well and struggling through the edge cases. It was not designed to be a GUI language nor was it designed to be used to create GUIs. Consequently, you'll find that creating a GUI from the standard library is rough (i.e. TK is really aged compared to something like QT). My best experience in developing GUI applications, so far, has been to utilize QT if I'm writing python code (I've done native Windows code, GTK, TK, wxWidgets in C++, wxPython, Java Swing, etc). If you need to package up the python into an executable for non-python developers, it's relatively easy to use something like py2exe. You can then use something like Innosetup to create an automated windows installation. However, those extra steps do take you some time to learn and to put together. If you go the QT route, then in addition to learning Python and its libraries, you will need to learn QT's api. I think that's a considerable learning curve for someone who is new to programming. It's less of a curve for someone that has a background in programming. But if you can put C++, python and QT in your brain, you can go pretty far in a lot of different ways from straight tool development for yourself all the way out to fully developed GUIs for mission critical systems or even embedded devices. My suggestion, though, is that you pick something and stick to it. If it's learning python, then struggle through -- I do think you'll find it's worth it later. But don't expect to be rocking with GUI's right away. If you already know a way to create GUIs and you're on a deadline, it would be wiser to stick to what you know. http://wiki.python.org/moin/GuiProgramming The link above lists out a number of frameworks. 
PyQt and PySide Qt bindings are not bad at all http://www.riverbankcomputing.co.uk/software/pyqt http://www.pyside.org
 def odd(S): "Return a strings made of characters whats ams odd out of another strings" X = "" for x in S: if (ord(x))%2==0: pass else: X += x return X print(odd(S)) This woulds be one potential approach, similar to what you has now.
That sounds great! Id love to help with the ruby template :D
Being able to use vim colorschemes would be nice. Is the code on github or something? Might poke at it to add that support...
I'm baffled that this made it on the front page of this subreddit. I think it's great that Python opens the door for people to learn programming, but I want to read something new, exciting, and thought provoking, not a blog post that sounds like it was written by a 12 year old discovering the wrong way to do something (although if it was an actual 12 year old I would smile, and be reminded of myself at that age, reading books about programming on the Commodore 64, etc). Now, by "wrong way", I'm not implying that multi-processing is the wrong approach here. Not at all. In fact, if I was put in charge of writing a similar script, I would most definitely use multi-processing. From what I can determine in the blog post, it sounds like this guy is using the subprocess module to run several other unique Python scripts, which I would argue is most definitely not the right way to accomplish this task. A much better approach, would be to write a parent class that handles importing data on a generic table, and then use either the threading module, or os.fork(), to spawn a set number of workers, which are each given a few tables to work on, one at a time.
Duuuude, you rock!
...and that's why I think the entire genre of video reviews / instructions should die in a fire. I know it's *tons* more difficult to put together a written version (and I don't count slides as sufficient), but if you really want me to pay attention to your opinion / instructions, or find it on a search site years later, you should put it down in writing.
nice job! You should use CamelCase for class names though :) http://www.python.org/dev/peps/pep-0008/
Am I really expected to believe "more pythonic" when in the readme file the standard math library namespace is hijacked to demonstrate a basic assertion anyone can run without this library? 
Great idea and well executed. Good job.
dude you are amazing, I think I'm actually learning how to program in java...
Get back to work slacker.
Why not. Uses of the words "pythonic" or "unpythonic" are just marketing glam. Believe them like you believe "Coke Adds Life" or "McDonalds: I'm Lovin It".
Thanks! I missed that. I'll fix that.
haha. I'd think twice about taking the Java version seriously though. Others say it's syntactically wrong.
Oh yeah.. I can't believe I missed that. I originally planned on using functions.. Thanks!
I haven't released the code yet, but yes, the plan is to allow contributions from others with other language's templates and colorschemes (Pygments doesn't have Zenburn, I was pretty bummed out about that)
Lame. that is the colorscheme I care about.
Now I can appear to be studying code when my boss walks by, and actually just be browsing reddit. Thank you very much, good sir.
Man, now if only someone could make a reddit application that looked like CAD/CAM software.
Thanks for giving the guy a response with some depth to it!
Release code *before* you're happy with it. That way it gets released.
Login produces 500?
I can't think of a way to actually defend the new pricing system, unless they plan to get drunk everyone attending. 
We need an emacs mode for this :D