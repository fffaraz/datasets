After a cursory look it appears that this is the article being reffered to: [http://qaa.ath.cx/LoseThos.html](http://qaa.ath.cx/LoseThos.html)
Wikipedia's article on [Orthogonality](http://en.wikipedia.org/wiki/Orthogonality_%28programming%29). A programmer's view on the [topic](http://brandonbyars.com/2008/07/21/orthogonality/).
Beginner here. What should I take that title to mean, really?
Python modules are compiled, but scripts aren't. There's no compilation step when you do `python main.py`, it just interprets. .pyc files are only there to speed up interpretation of modules.
Right, I guess I meant within the spectrum of "ctrl-f"--yahoo--reddit search----------------google 
For anyone a little more advanced, the "build a self-driving car" course is awesome too. I just finished week 1, it assumes a bit of programming skill but no significant math background, so far at least.
Between ctrl-f and yahoo, much closer to ctrl-f.
How does the pacing/assignments work? Is it something I can do on my own schedule? 
What I find really distracting is that these courses seem to be only available at specific dates, they started at the 20^th of February and go on for 7 weeks with home-work due dates every Wednesday and and the last week being the exam week. This doesn't seem right for the internet. I think a better model would be to start a course individually for every student whenever he/she enrolls, starting the 7 weeks cycle - in this case - from there. Is there any information about when these courses can be taken by people who missed this window? --- Other than that I find it a really good idea and a general good thing to provide these courses online, for everyone, for free. Education will be more and more an online self help kinda thing, where you learn what you are interested in and from resources that are being openly shared worldwide. Employers will have to deal with this change in the near future as well.
Submit posts about cats and Neil deGrasse Tyson. Got it. ;) Thanks again. edit: Timer's already gone, or at least decreased. It started at 9 minutes before, and my last comment was just 5 minutes ago.
I've run into problems with it before—Although I admit it may have been because of inheriting old-style classes (from some ZODB-related stuff). That being said, I agree with you—It sucks having to name the class again inside itself, and utterly defeats the DRY principle. If you *want* to specify a different class to call super() on, fine, specify it—but you shouldn't have to do so when you are doing as you say. I would like to know a bit more detail about this as well, so I'll be watching. Thanks for asking!
I've signed up, looks like fun! I started to learn how to code a few weeks ago and python seemed like a nice one to start with.
The timer is also subreddit specific AFAIR, so even when you get to post every thirty seconds in one subreddit, others might still delay you. 
I consider myself beginner-intermediate in Perl and I still found the last homework problem challenging (I submitted a solution but knew it wasn't ideal). I expect the level to go up pretty quickly in subsequent weeks.
That's a good point. Technically you could embed jquery in your bookmarklet, but for simple stuff that's obviously overkill. I have gotten so used to jquery and underscore that I sometimes forget that they're not built in.
The homework was extended to Wednesday, midnight utc
Its because the class is "live".. As in you have the option to interact with peers and the instructors. If it was started individually, it wouldn't be so much a "class". MITs open courseware is a good option for classes that are not "live".
Joined up, really excited!. Started with pyschools through this subreddit too but this looks more fun. Hope i can fit in the extra homework nexto my engineering course
You could always say type(self) but I think that can also cause issues. edit: Ignore the above, I just did some googling and for the reason that UloPe points out, you shouldn't use type(self) either.
I switched from Emacs to PyCharm about a year ago, and I wouldn't go back. I miss a few things (like org-mode, which I keep open in another window), but for actual development? Can't be beat.
yea I do as well, the last question I used round() then took the str of the return and found the decimal and printed the whole #, I am sure I cheated :)
Yeah, good luck with that.
As much as the search functionality sucks, this is a really common question asked pretty frequently on any site of programming nature. [This search for "IDE"](http://www.reddit.com/r/Python/search?q=IDE&amp;restrict_sr=on) shows some recent discussions.
For as long as I can remember, I've seen Python described as a "scripting language and a fully functioning programming language." In books and what have you.
Ah. See, this I did not know. My experience in the design of an interpreter is pretty clearly incomplete. But why would it need to be compiled if the commands are right there? Why is there any need to translate?
Well dang it, I'm glad I asked. So does this defining class stuff really only cause a problem when multiply inheriting? I'm not asking so I can use it with single inheritance, as it's clearly a broken concept. I'm just curious. Thanks!
that's not from the search engine class.
I found the decimal using find but had to use int() to convert the decimal string part back to a number to do arithmetic. :( My code also returns 3 for 3.5 when the description says the convention is to round up from 0.5. I'm sure there's some elegant solution using only the str() function that I'm just not seeing. 
Thanks Brian. Maybe we can concentrate on discussion of debuggers here, then? One note I also have is that the last survey-type discussion was almost a year ago, and my hypothesis is that a lot has changed/matured since then.
umm yea it is, 1.9 Rounding Numbers
yea, thats why I used the round 1st... just not sure what they wanted and didn't see how to do with just str unless I used an if/then.
The original author is actually Ian Bicking (prolific SOB). Ian doesn't do much of the maintenance anymore. Apparently the original name of the project was pyinstaller: http://blog.ianbicking.org/2008/10/28/pyinstall-is-dead-long-live-pip/ Meyer gave a talk on getting inside Ian's brain at pycon last year: http://blip.tv/pycon-us-videos-2009-2010-2011/pycon-2011-reverse-engineering-ian-bicking-s-brain-inside-pip-and-virtualenv-4899496
This was my logic - if you do (decimal part)-5 and check for the sign you can tell if the number should be rounded up or down. Rather crude and it won't work for the boundary case. I am too much of a python noob to have heard of round(). :D
I think thethimble meant "u'xxx'". Am I missing the joke?
If you look at the [list of opcodes](http://docs.python.org/library/dis.html#bytecodes), it's roughly equivalent to all the different kinds of nodes you'd find in the parse tree. In other words, bytecode is just a natural representation of the result of parsing, something that has to be done regardless. A pure interpreter would walk that parse tree in some depth-first order, evaluating the operator at each node, so all the bytecode is doing is serializing that list of steps. And in fact the bytecode is a more compact representation of the parse tree because it doesn't need all the parent/child pointers of a tree. So it's not really that there's an extra step of compiling to bytecode, it's that bytecode happens to be a convenient and efficient way of storing and serializing the representation of the program in memory. You'd need some in-memory representation of the program regardless, so it might as well be a form that's convenient and compact. This approach is used by almost all the modern scripting languages: PHP, Perl, Python, Ruby (since 1.9), Lua, ActionScript, probably others. They might not store or expose the bytecode, but it's there internally. (And of course python does fully expose that bytecode for use by the program, which can inspect and modify itself -- see the insanity that starts on [p58 of this talk](https://docs.google.com/viewer?url=https://ep2012.europython.eu/media/conference/slides/5-years-of-bad-ideas.pdf).) 
PyDev
&gt; One note I also have is that the last survey-type discussion was almost a year ago These threads were coming up weekly for a while. I know I've answered about my setup numerous times, and it switched from Komodo to VS2010. The threads are often titled with specific IDEs but all ask the same question of what do you use and why do you use it. I would bet that you can dig up at least 20 IDE discussions in here, many of them with 50+ responses. Anyway, my answer is Visual Studio 2010 with the Python Tools extension.
I like http://eric-ide.python-projects.org/
(Python 3) name = input("Name: ") n = int(input("Number: ")) print(str(n // 12).rjust(8, '0') + name.split(' ')[1][:5].ljust(5, 'X').upper())
I also think it is due to the relatively new area of trying to mesh traditional school and the internet. Over time it will change, but it will take a while to make the majority happy (students / schools / teachers).
Brill - thank you. Much appreciated.
&gt; As for people using "literally" to mean figuratively, there is no clear consensus position on whether that usage is acceptable or not, which is why people still fight about it. But language is driven, not by prescription, but by description -- lexicographers record how people use words, without judgment or acrimony. It's not like science or mathematics, where something might be resolved in just one way. As to the word science, it really has a formal meaning, a technical one that transcends people's choices about it. And the precise meaning is important - it keeps people from teaching Creationism as though it is science. 
To say language is "driven" by description is a mixed metaphor. But I think I get what you mean: languages go whatever way they like, and all we can do is document the changes. &gt; a formal meaning, a technical one that transcends people's choices about it Yeah, that's what a "normative concept" is. It's how you "should" be using the concept. To be precise though, it's not about the words. Japanese, for example, has two words that are both roughly equivalent to our word "science" but with different nuances (学問 is Scholarly Inquiry and 科学 is People in Lab Coats). I would argue that they split the concept up better than we do by confusing the people in lab coats with the method of inquiry. Still, I'm not going to get on a soap box and shout people down for foolishly using one word for two concepts. As long as people use the concept in the right way, the words can continue to be confused if they want.
In http://www.dalkescientific.com/writings/diary/archive/2012/01/19/concurrent.futures.html I describe using multiprocessing to do a large number of DNS lookups. That's very I/O bound. Using 50 processors for that case, on a 4 core machine, was just fine.
wow
Yep! This is the solution I got too.
I did the same. I hope it's not considered incorrect. 
I tried this but i get an error message when i run it
Awesome!
It's fine to create the config file in ~ on the first run. Tons and tons of existing apps and libraries do this already. Same for cached files. The key is to make it obvious that files go with your app.
Use for what purpose? The expect approach has a wide variety of uses, some of which may have other ways of achieving the same goal (e.g. using Fabric for remote control, or a dedicated unit test module like nose for fuzzing) while other uses may remain with pexpect... 
thanks, and sorry for my broken English.
Some of the stuff I use : * Lion &amp; Archlinux * Python 2.7 * Ipython * I chose Sublime text 2 ( sublimerope, sublimelinter, whitespacecorrector) over Vim (Google turning Vim into a modern python ide) * Flask (flask-sqlalchemy) has a nice debugger * Virtual env &amp; virtualenvwrapper * Postgresql Majority of my info comes from : * /r/python * stackoverflow (unfortunately they don't allow these kinds of questions anymore) * hackernews 
It's an assignment. You're supposed to figure it out for yourself, otherwise what's the point? 
Didn't know this function, thanks!
emacs
I used msvcrt for this, but who knows if that's the "right" way.
 * Qt4: http://www.pyside.org/ (shiny) * Gtk: http://www.pygtk.org/ (pretty barebone) * Kivy: http://kivy.org/ (probably shiny, I only used a very very early version of this) Btw: To run function as callbacks with some arguments, take a look at functools.partial or create lambda functions. button.bind(partial(show_file, 'foobar.txt')) button.bind(lambda : show_file('foobar.txt')) €dit: I see, I answered a question that you never asked. My reading comprehension is bad.
`subprocess` is great, but it's not really a substitute for pexpect. Firstly, subprocess doesn't have a good way to interact with a process that continues running. It can pipe stdin and stdout, but you can't (easily) program responses to interactive prompts. Pexpect can wait for a certain prompt, then send input to the process and let it continue. Secondly, pexpect works at a different level. It doesn't work with stdin/stdout, but rather creates a virtual terminal to run the process in. This has a couple of effects: * Programs may behave differently if they detect that stdin/stdout is in a terminal. E.g. `ls` in a terminal may produce ANSI colour codes, which are absent when you pipe its stdout with subprocess. You can examine this behaviour using pexpect. * Programs can bypass std(in/out/err) and communicate directly with the controlling terminal - some programs do this for a password prompt. Pexpect can still interact with this, whereas subprocess won't see it at all. The original author of pexpect seems to have gone quiet. I made [pexpect-u](http://pypi.python.org/pypi/pexpect-u) (u for unicode), which is compatible with Python 2.6+ and Python 3. There's [wexpect](http://sage.math.washington.edu/home/goreckc/sage/wexpect/) for Windows, but I haven't tried it.
That is awesome. :) Would you mind posting the address as I cannot for the life of me find it on udacity.com?
Yeah, I'd like an IDE, I can't get the command line to use modules either..
Well, he *did* say GUI..
&gt; Firstly, subprocess doesn't have a good way to interact with a process that continues running. It can pipe stdin and stdout, but you can't (easily) program responses to interactive prompts. True if you're using `subprocess` directly, but there are helper projects that can help you achieve this. Here's [an example](http://readthedocs.org/docs/sarge/en/latest/tutorial.html#interacting-with-child-processes) of what I mean (disclosure: I'm the maintainer of the project whose docs I linked to). &gt; [pexpect] doesn't work with stdin/stdout, but rather creates a virtual terminal to run the process in ... Programs can bypass std(in/out/err) and communicate directly with the controlling terminal Right, and this is why it works in some situations where `subprocess` doesn't. For example, both `ftp` and `ssh` write password prompts out to the terminal, so you can't use a `subprocess` based solution to interact with them. &gt; There's wexpect for Windows, but I haven't tried it. And also Geert Jansen's [winpexpect](https://bitbucket.org/geertj/winpexpect/wiki/Home) - though that's also not been updated for about a year (I haven't tried it, but it provides a platform-specific implementation subclass of a pexpect class to do the equivalent job on Windows, plus utilities to do things like finding executables).
Aptana because of the integrated debugger and HTML highlighting and autocompletion, for django development.
If you're going to store a lot of data in this way, linux desktops have some standard locations: $XDG_DATA_HOME $XDG_CONFIG_HOME $XDG_CACHE_HOME 
While I mostly use KDevelop, I came across a new (to me) IDE the other day called [Ninja IDE](http://ninja-ide.org/). It looks fairly complete and neat and is open source.
"Pexpect haters" seems a bit strong unless you're being sarcastic (can't always tell with online communication). I've never used Pexpect but I've looked at it. I definitely could use something like it but I do need Windows support (unfortunately, it's not by choice that's for sure). I'm OK with writing my own wrapper code for subprocess. I've worked on a lot of cross-platform projects and when library authors say "it should work on Windows but I've never tested it" that's code for "it's not going to work on Windows at all". Myself personally, I would love to never use Windows again but that's not possible for me right now with my current job. I read an interesting article about Maven (which I despise deeply) recently and the gist of it was yes, you can use Ant or Maven or make or whatever build tool you want but the best build will always be the one that you write that does exactly what you need. I think you could extrapolate a bit and use that same argument here. Yes, there are plenty of awesome Python libraries (my new fave is Requests) but sometimes they will fall short or just won't meed your exact needs. The great thing is that Python makes it incredibly easy to build on someone else's code or just implement your own version from scratch. Anyway, you might want to look at [this](http://www.reddit.com/r/Python/comments/pl25z/sarge_a_library_wrapping_the_subprocess_module/), the author is a redditor. Actually, I wouldn't be surprised if he comments here at some point. There are other command line wrappers out there. Please post any updates if you find something that works well. 
&gt; I can't get the command line to ~~use modules~~ run scripts FTFY?
PyScripter.
When those environmental variables don't exist they default to the following values respectively: ~/.local/share ~/.config ~/.cache
ty
Sublime Text 2 if absolutely amazing. By far my favorite editor, and I don't even know how to use it very well. By the way; any way to make Sublime not assume that everything you write should be used for autocompletion, right now every word I write is used in the autocomplete thing.
I just use the command prompt and notepad. That is all you need for Python
vim in one terminal another terminal for launching the file split screen or on different desktops with icewm in Debian.
Yes! I would like to be able to double click on it (being a script i've saved to the desktop or w/e) and have it open in a python shell. ultimately i'd rather it opens the editor, but if it will open the pyshell then you can configure it from there to open the editor instead. So opening the shell is a means to an end. 
Our race shall prevail!
How does that create a CLI for humans? I'd expect at the minimum an interface that gives you the ability to examine the response and to save responses and reply to create a script if it's going to be compared to cURL. In fact, if it's not using libcurl/pycurl it probably can't do kerberos gssapi negotiation which makes it kind of useless in my environment - another toy. 
Woops, I guess Reddit didn't like the stars I typed. Just run the program I wrote and you'll understand what I mean.
Sometimes your package manager has packages older than the current version released through pip. With pip being so easy to use - just as easy as any package manager out there IMHO - there's really no reason to use the OS package. Also, when combined with virtualenvs, you can have several versions of python packages running in different environments whereas an OS package would be fairly ubiquitous. So suppose you have several Pyramid apps running on the same box. In your blog app, you need to be able to use the cutting edge version of sqlalchemy. In another app - say your ecommerce app - you need a legacy version of sqlalchemy. Running each app in it's own virtual environment, and using pip in each of those environments, you can have the separate versions running and in use for their respective applications. tl;dr: use virtualenv and pip
The code also looks wrong, with things like: print " "spaces,"" Try adding 4 spaces in the beginning of every line (so it shows as code).
The correct place for asking questions is /r/learnpython . Would a hint near the submit box help?
The distro package manager may have older versions, but they get security updates automatically from distribution repositories. Also, if you need complex compiled packages like numpy, it's easier to get them from the distro, because they take care of compiling it for you*. Pip will always give you the latest release of a package, but you might need more things installed to compile packages, and you have to remember to update packages yourself. I use distro packages for base stuff that I just want to work reliably, and pip when I want the latest and greatest stuff. *Most mainstream distros, like Ubuntu and Fedora, ship binary packages. There are some distros that use source packages (Gentoo), but the package manager should still take care of getting the relevant files to compile it.
I thought the same [two years ago](http://www.reddit.com/r/Python/comments/977eo/) turns out self is always a reference to the original object so when a super calls another super it enters an infinte loop. crappy as hell.
One of the biggest reasons to use pip is that it will allow you to use virtualenv. Virtualenv allows you to setup multiple virtual python environments for each of your projects. This allows you to have different versions of Python packages installed for your various projects. 
np, and i didn't mean it in an sort of disdainful way; that subreddit is more inclined and better suited to help you.
This...smells wrong. You define a class with some empty, decorated getter methods, then pass that to the constructor of another class. Looking at the Java library that inspired it, it looks like they've copied the API directly (naming convention and all), and the result isn't very pythonic. A declarative command line parsing API isn't a bad idea, but I think it could be done better. In particular, I'd lose the getter methods and the decorators. As a rough sketch, imagine this: from mycmdlineparser import parseargs, option, argument class MyOptions: foo = option(default=None, abbrev='f') bar = argument() options = parseargs(MyOptions)
but you can't (easily) use virtualenv with distribution packages
hmm
Not saying you have to use pip to use virtualenv. My point was just that if you use pip (as opposed to aptitude or another system package manager), it will install to your current virtualenv.
your intention was to fail or misrepresent pip and it's fictional relationship to virtualenv. your choice. :)
Thank you!
i used if statements there to round it using %1 and then just printed it as string
you could read the docs and decide for yourself. :) or believe any random reddit schmoe like me :) it's one part api api's for using fancy nosql databases, memcache etc... basically all the stuff that we are told is what the big sites use to scale to insane ROFLSCALE levels. one part framework tools to help you build a web application that "scales" you can start with webapp/2 to handle http requests, or use pretty much any wsgi compliant web framework, though some are more useful than others. one part methodology emphasis is on designing to scale. this can be frustrating as it is premature optimization built right into the platform. If your stuff never needs to scale because it's just holding your cat pics that only you look at and manage, de-normalizing your data schema can seem a little pointless, but their nosql solution doesn't do inner joins so you do what you have to do. one part platform the win for writing your app the appengine way is a kick ass deployment platform to host your application. you don't have to worry about clustering, loadbalancing or any of that crap that the big boys pay real people $$ to do, if you designed it properly, it runs just fine on google's infrastructure, so you have instant big boy app without the pain of building your own data center and learning something. 
As a rule of thumb, use your distribution's package if you need it for applications you **use**, and use pip's package for applications you're **developing**. The reason for this is, that your distribution maintains package versions globally in such a way that all your packages are consistent with each other's versions. When developing however, you need more fine-grained control over which version you use. As a clarification, use pip even if the version you want is the same as the version your distribution provides. This gives you the freedom to change at will, without messing with your system. 
dude... seriously.
&gt; There are better tools already available. This depends very much on what is "better" for you. If all you need is an easy tool to test a REST service, httpie is good enough. If you need something else, there of course are other tools.
Yeah that's the sort of thing, have you used it ? I'm more interested in getting peoples views of the different packages available.
Nice, i'll take a look, thanks.
All you need? Yes. Most efficient way of doing it? Hardly.
I'd think that you could get VIP tickets or whatever couldn't you? I'd fire an email off to whoever runs the show and just let em know you're in trouble. Not much difference than leveraging your admin status here I wouldn't think.
I wouldn't do that unless all the money was going to the PSF. Although if it were I'd be happy to pay extra.
I don't think so. I was actually very much into it - but when they raised their prices, I've never hacked in GAE again. It's obvious, but with GAE, you're stuck with google's control of the prices.
You could just show up and say "DO YOU KNOW WHO I AM?" with increasing volume each time they prompt you for your ticket.
Can always try /r/programming....?
In theory, I have two tickets: one through my company, one that I bought myself. I haven't heard anything from the pycon people about my ticket being reimbursed, so I guess I still have both. Let me try contacting them again.
Heh, I was serious at Cloud Connect, we do have another ticket for opscode. Let me poke cb about it.
Since reddit is a sponsor, you should be able to find the logo somewhere, and point to it, and then start bleeding, and run in. Works every time. Nobody wants to touch blood anymore.
I have used pyparsing, and I really like it. I have parsed lisp-like syntax, which was like 6 lines of code, and C-like. It is really easy to try it out and get started, so you should really just try it. You'll quickly see if it wasn't what you needed
Ouch. I respect that though.
What *is* the default GUI on python?
You may hide in my backpack. You are on your own once we're inside.
It's primarily a Java IDE but not exclusively. The non-Community versions of the IDE have support for plugins. The plugins actually add the functionality of a lot of their smaller IDEs, like PyCharm. I've personally never used anything like their Ruby plugin, or the PHP plugins, but I would assume they add all the features RubyMine and PHPStorm just like the python plugin adds the features of PyCharm. I use IntelliJ IDEA for python with the python plugin installed as well. The advantage is that I don't need to switch IDEs when I do stuff in a different language, like Java.
No no, I'm not looking for special treatment. I'm just looking for someone with an extra ticket.
I'm surprised Guido gets one. :) As I said above, definitely not looking for special treatment, just someone with an extra ticket. Thanks to all of you and what you guys do!
Maybe just shut down /r/python. :) Sadly, being an alum, I don't actually have that power.
Awesome! I figured I would try and get one otherwise first. Let me know.
I'm actually the one that arranged the reddit sponsorship (or at least started that ball rolling), but then I left reddit and they're using all their tickets for the sprint.
Awesome, let me know. Happy to buy one off you.
Person he's yelling at goes on the PA and says "Does anyone know who this is? He has seem to forgotten."
The thing that makes Clojure maps useful isn't (only) that they're immutable, it's that they can be updated easily without much duplication. Normally, if you have an immutable hash and you want to update it, you make a copy of the whole thing and then change the one key/value, resulting in a new immutable object with the update applied. This is obviously inefficient. Clojure containers use a neat trick that allows that copy to share nearly every node from the original except for the one that is to be added/changed/deleted. It does this by using a tree with a wide fanout of 32 and some kind of bitmap magic to say "take all these elements from that other one except for this one branch." The change then only requires the memory for the nodes affected along the path from the root down to where it lives, which is usually a very short path with a fanout of 32. This is done for all the containers, even vectors/lists, BTW. So that is the property that makes them efficient while still being thread-safe without locks. Just being immutable on its own is necessary but not sufficient. To implement mutable dicts on top of frozendicts I fear you'd have to resort to full copying, or else completely redesign the internal details. 
Stealing that for a t-shirt in 3...2...1 Edit: [And it's ready to ship](http://i.imgur.com/ifRpN.png)
It is just more simple in my opinion. notepad and cmd prompt take .3 seconds to start up and everything runs smoothly. 
Also note: the organizing volunteers are still expected to register (and pay) themselves (or have their companies pay). We/they are welcome to apply for financial aid and would undoubtedly get their registrations comp'd – and those who need to, do apply, but most actually do pay their own way.
For some reason, that explanation in itself makes PyCon more awesome to me. Missed my chance this year, but I will definitely go next year.
Done! https://bugs.pypy.org/issue1075
PyCon is really a community event. Speakers pay their way, organizers pay their way, the program committee pays it's way, the *chair* pays his way.
&gt; would have people in such a tizzy that Python would just cease to exist I think Py3k would've been a good opportunity to do this; people were already in a tizzy anyway, and this would've been a relatively minor change.
I think it's called tk. It sucks. 
I guess it would be relatively minor if your application created one `datetime`/`DateTime` instance and you had to change it once. You import a name once and you use its contents any number of times. Modifying that "any number of times" part increases the amount of work people have to do.
Yeah but they'd have way more changes to make when migrating to Py3k anyway, and this is something ```2to3``` could handle trivially.
This is just going to go on forever, so, sorry. Report it and we'll fix it in Python 4.
A lot of drama indeed, yet, twillis1973 is right, Enzondio's initial post was partly incorrect and yet lots of upvotes for it. Either plenty of people don't understand the relationship between virtualenv and pip or it's just the Internet not being fair once again.
Thanks for the render shortcut. Never knew it existed. 
ALL HAIL
Such a boss.
&gt;ah so no lookup for valid /r/'s then, still slick. That's actually slicker. Someone might create a new subreddit between the time I open the page and the time I read your comment. 
Funnily this has been more attractive to me than using Django the traditionnal way. Thanks.
You want django. No more no lesss. No SQLAlchemy or Flask or stuff like that. Just plain and simple django. It is made for you, for several years, this is it. Django chose you. 
Nice hack, but why not just choose the best tools for the job instead of bending your favorite framework beyond recognition?
Because so many libraries haven't been ported over to Python 3, I have to confess, I haven't spent a lot of time looking at it. The tools I work with every day haven't even begun the conversion process. To be honest, 2.7 is still very strong. It's going to take years to get libraries updated, and I'm okay with that. It'll be interesting to see what libraries are moved over, and which ones are truly dead. 
Django, Django add-ons, and Pygame, for the most part. I know there's ongoing work with Django, but last I checked, we were still quite a ways away from putting out a Python 3 release. Even then, even my smallest sites are have a half-dozen libraries included. The one for my employer has enough to make me a little ill to think about upgrading.
Out of interest, what were you using, if not render? render_to_response?
I think Django has it planned for 1.5; 1.4 is in beta now, so maybe later this year. Pygame [does work with Python 3](http://www.pygame.org/wiki/FrequentlyAskedQuestions#Does%20Pygame%20work%20with%20Python%203?), apart from a few corners.
&gt; gives no way of distinguishing classes from functions if they don't obey PEP 8 True, and I'm not disagreeing with you, but you aren't much further along if you know something's a function as opposed to a class, because you still don't necessarily know how to use it. `help` is your friend here (assuming the item has a docstring), and you just need the item's name to use it, PEP-8 compliant or not. For example, `logging` (which I maintain) is not PEP 8 compliant. That's because it was written before PEP 8 (or at least when PEP 8 was very new), in the time of Python 1.5.2, and had users before it was added to Python. At the time, plenty of other stdlib modules also didn't conform to PEP 8 (e.g. `threading`), probably for similar reasons. It would have been annoying for those early users if all the method names had been changed *just* for the sake of style, and gratuitously broken all their code. Aliases could have been added, but then you would run across both the names for the same things, because not everyone would transition to the PEP 8 names; that's not an ideal situation, either. Talking of stylistic changes, a similar complaint comes up with regard to getters and setters - "how un-Pythonic!". There was quite a lot of Python code around before properties found their way into Python; before them, getters and setters were the only way a developer could keep control of the implementation while leaving the interface unchanged. Old code has a way of sticking around, as if it works, people don't need to change it; so the old interfaces have to remain too, even if something better has become available. 
That's what I thought too. Thanks for clarifying.
&gt;He is our Great Leader(TM). He is our **Dear Leader**
yeah
What's the debate around the print function? This is one of the hardest thing for me when I write in python 2 now. I can wrap my head around io vs. file, str vs bytes, etc.... but the old python 2 print makes no sense whatsoever now...
Ever compare the size of Django to the size of Flask?
Totally makes me think of [this](http://www.youtube.com/watch?v=vOAYURCY2RM#t=2m00s).
Bullshit, if there was ever a time to do some major spring cleaning it was in Python 3. Sure, it's not the end of the world that it didn't happen, but one of the reasons I like Python, is that it usually makes sense and is easy to learn/use. With that attitude, we might as well all just use assembly. I mean, why even have libraries and compilers and interpreters.
&gt; be able to add new fields to the database easily. I think it's going to be a challenge if you aren't going to use a new fangled nosql db. You could use sqlalchemy to read the schema from the db and [build the objects dynamically](http://docs.sqlalchemy.org/en/latest/orm/extensions/declarative.html#using-reflection-with-declarative) that way, at least the data constraints mostly rely on the db for data constraints. Keep in mind that sqlalchemy is more than an orm, there's not much limitation on what statements you can run against the database. I think that getting friendly error messages interpreted for the user from the database is likely impossible though. You might want to look at [formencode](http://www.formencode.org/en/latest/Validator.html) for validation(including form validation) for those cases where you need to be extra flexible and have complete control over the validation messages that go back to the client. But then you are duplicating the constraints that are in the db already. 
Hi Mark, if you email us with details of your setup, we will help you get pygame going. Mailing list for pygame is here: http://pygame.org/wiki/info Or email me directly: renesd AT gmail D0T. com I couldn't comment on the blog, or find the authors contact details. cheers,
&gt; That's an excellent point - it should have happened. As Eli points out, "it should have happened" only works until someone answers the "who wants to do it" question.
where is `ranfun` defined? It's on [line 79](https://github.com/timClicks/choices/blob/master/choices.py#L79) 
The downsides I was talking about were linked to including the file in your project (thus losing the updating feature of pip) and/or running the devel server. As for general downsides for "normal" usage. I don't know. People often talk about a) templating b) database? c) extendability. But I think the bottle supports other templating engines, it hs *some* modules and for database you can use SQLAlchemy for example (+bottle module). I would say it's a matter of taste. but maybe someone more experienced with Flask will list its benefits over bottle.
These variables are usually only set by a user who wants to move the location of the directories away from the default. Like I said, when those variables don't exist you should use the directories I mentioned: import os datadir = os.path.join(os.environ.get('XDG_DATA_HOME', os.path.expanduser('~/.local/share')), appname) configdir = os.path.join(os.environ.get('XDG_CONFIG_HOME', os.path.expanduser('~/.config')), appname) cachedir = os.path.join(os.environ.get('XDG_CACHE_HOME', os.path.expanduser('~/.cache')), appname)
Okay, I do have two tickets! Message me your details so I can get them transfered, and we can talk payment. I just want to get my Early Bird non-corp fee back :)
Sure, it's open source. And it's OK, Python is not perfect. I was mostly calling bullshit on this line: &gt;no one who's smart enough to solve the kinds of complex, real problems that developers face every day will be thrown when they see a class name with nonstandard casing I may not be "smart enough" but I am anal enough to want to make the language as uniform as possible. That's part of the appeal of Python - it really is readable (most of the time). I'd argue that it is the little things like this that matter. Someone recently mentioned on r/Python that it's absolutely ridiculous that Python has urlib and urlib2 modules and I agree with that wholeheartedly. I am half tempted to contribute to Python but the few Python "luminaries" I've spoken with were far from inviting. Also, I can barely code in C so I'm not going to be that helpful. I'll say this though, I would be deeply satisfied to help with the doc, it needs a good solid review from someone less than brilliant (like me) who can actually relate to new Python users.
Using a microframework isn't about how few lines of code you put in your files, it's about not loading into memory things you don't need, having a simple enough stack that you can effectively debug it when something goes wrong, and having a great deal of control over how your application is structured and what modules you use. From Flask's documentation: &gt; The main reason Flask is called a “microframework” is the idea to keep the core simple but extensible. There is no database abstraction layer, no form validation or anything else where different libraries already exist that can handle that. No matter how small your django project, you're going to be incurring a lot of overhead from stuff you're not using. If you later decide to add an ORM, you're pretty much stuck with Django's. Just because you're application is tiny and you're using a bunch of features doesn't mean those decisions aren't already made for you, and in some cases, doesn't even mean that your webserver isn't having to process them.
&gt; the appeal of Python - it really is readable (most of the time). I'd argue that it is the little things like this that matter. Yes, but e.g. `logger.addHandler(handler)` is not less readable than `logger.add_handler(handler)`. I don't disagree with you that more consistency would be nice to have, but there are times when it's not worth the price it commands. The comment you were responding to has a kernel of truth. For example, I work in Java, C#, C, Objective-C and C++ as well as Python - all have differing conventions in this area. As a professional you have to get used to all sorts of such conventions, and though I agree it's nothing to do with being smart enough, it *is* to do with how varied your experience is. These style problems *are* problems, but they're first world problems ;-)
Wondering if we would have needed Flask had we known Django could be used that way?
Something like this,i'm on mobile and can't check: import itertools def lone_sum(*args): elems = itertools.groupby(sorted(args)) return sum( elem for elem, count in elems if count == 1)
Didn't someone ask this about a week ago?
:O
help(set)
I like this one best so far; only a nit-picking: def lone_sum(*args): d = dict() for i in args: d[i] = (i not in d) # here return sum([i for i in d if d[i]])
assuming you think you can just sum the set of the args, i rebuke thee since you cannot count either instance of the dupe... there is a solution that is set-oriented, though: def lone_sum(*args): sargs = set(args) dargs = set([a for a in args if args.count(a) &gt; 1]) return sum(list(sargs-dargs))
It'd be garbage collected all the same, so it's not a leak.
Time is not infinite. If core devs had started fixing *every* issue in Py3k, chasing all sorts of programming unicorns, they would never have finished, and we'd have ended up like Perl. Open source is based on rough consensus and *running code*. If one really feels that PEP 8 compliance is so essential, he should go on and submit patches upon patches, while being careful to maintain backward compatibility. The fact that nobody does, in practice, speaks volumes.
 import collections def lone_sum(*args): c=collections.Counter(args) return sum(k for k,v in c.iteritems() if v==1) I think collections.Counter was added in 2.7.
The only thing that Flask has over Bottle is the development team. Bottle is one file, and one man. Flask seems to engage more developers. This has consequences. Seriously, if your app calls for a micro-framework; i.e. it doesn't need anything fancy, then Bottle is great.
Can you tell me which ORM will you likely use with Flask? Be aware of the illusion of choice.
I use SQLAlchemy, because that's what I'm used to. There aren't just a plethora of mature ORMs for choose from. For some small apps, I don't use an ORM at all. If you like Django's, there is [peewee](https://github.com/coleifer/peewee). 
Here is my solution: def lone_sum(*args): return sum([x for x in args if args.count(x) == 1]) 
Well, it doesn't let me buy them because I get stuck at the buying a ticket phase, which blocks me.
I learned Fortran from a book/pamphlet from IBM and then started helping out the other members of my class in it. I loved the short graphic description of the language of Pascal. I will look at these books and find out what "Jumpstart" is. Thanks.
oh ... the last homework problem? was unclear to me. I havent gotten there. Thanks.
If you're on something with iOS, there is now a Python for iOS - only $3. It's so nice to be able to check things like this while out and about, so I can keep moving forward with an idea.
I have more experience with Flatland, but I'll look at formencode.
lone_sum = lambda *x: sum(set(x))
i have no experience with flatland, it might be better. who knows. 
Close, but this fails in these two cases that the OP provided: &gt;lone_sum(3, 2, 3) → 2 &gt;lone_sum(3, 3, 3) → 0 OP stated: &gt;if one of the values is the same as another of the values, it does not count towards the sum.
I think you misunderstood the question
Macs need to get their shit together with a package manager. MacPorts died, Fink was never very good, and homebrew doesn't have enough packages yet. Apple's solutions like the Mac store don't handle libraries very well. At the end of the day, if you really want to say you target Macs I think you have to provide pre-compiled packages in .pkg format. A lot of OSS projects seem to have a "we'll release source, make sure it compiles and let MacPorts/homebrew handle distribution".
I don't get why he's complaining about Python itself just because no one has packaged Pygame for Python 3 for the Mac. Pygame isn't even a standard library package, the Python devs have nothing to do with how or when it's packaged. Also, how hard would it be to package it yourself? I genuinely don't know, but surely it would be a better use of time and energy than complaining about it? Also, about the print thing. IMO he seems to have picked the least annoying aspect of the 2 to 3 jump to complain about. It's a very minor issue; it's easy to remember the change when writing new code, and 2to3 has no problem converting print statements in old code. I prefer print as a function because it's more flexible; it can now be used in lambda functions or list comprehensions, for example, and it can be overridden with a custom print function if needed. And although I'll admit that adding a trailing comma was much easier than adding end="", the latter method has the advantage that it is more explicit and easier to read, which is *completely* in keeping with Python's philosophy.
 def lone_sum(*args): counts = collections.Counter(args) return sum(x for x, c in counts.items() if c == 1) *edit* just noticed maxerickson came up with the same solution before me
First of all, this doesn't look bent out of recognition to me. It's still a relatively standard django setup, but with everything unnecessary stripped out. So why not choose something else? Because you like django and projects tend to grow over time. When it does, you're already using django. You've just left out the bits you don't need. Add `DATABASES = {...}` to your settings file, and you're hooked into the ORM, and looking more like a standard django project. If you started with bottle, for instance, you'd have a more painful conversion on your hands to get it into a django project when it grows up. If you'd use a microframework anyway for a larger project, this probably doesn't interest you. That's fine, too.
That's all pretty straightforward. Though a little messy - what if three fields all had validation issues ? Letting the database constraints report on errors means you only get the error for the first field that failed, not the other two. Unless you build out some elaborate stored procedure that runs the contents of CHECK constraints on arbitrary values, then call it for a series of fields. Then you're well into some other kind of territory.
I'd like to propose that this is all preference/familiarity. I can't think of a job that is objectively more "right" with Django, Pyramid, Flask, web2py or anything else. All of these frameworks can be used to create the same kinds of apps. It's just the architectural practices you'll use will vary significantly.
 def lone_sum(*args): return sum(set(args))
Disclaimer: I've no idea what flatland-style serialization is and I didn't bother to look it up. It could be django doesn't match this requirement (their serialization is quite usable tho) Otherwise I'd say you need * Django * South (well-documented django plugin for DB migrations) * some wrapper objects around validators that support both the [validator API](https://docs.djangoproject.com/en/dev/ref/validators/) and some home-rolled API for pushing validation logic to the client. **Note** In your OP you wrote &gt; Propagate validation logic to the client(s) (one Flash and one HTML5) so data can be pre-validated if possible. but in a response you wrote &gt; But I'd like the DB to handle server-side validation if at all possible. So I can add a "CHECK" constraint with a regex and then have the ORM map that to a pretty error message. Maybe this is a pipe dream. I don't see any way to do that which doesn't involve * writing validation logic twice * an ORM which chooses to embed this logic in the database instead of keeping it as code which it runs as a pre-insert/update check I recommend not doing the former, and I know of no ORM which does the latter.
This is an excellent point. I'd still like to specify my schema once, and have it generated in all 3 places (db, mapper, validator). I may have to write this code myself.
 def lone_sum(a, b, c): nums=[a,b,c] return sum([nums[x] for x in range(0,3) if nums[x] != nums[(x-1)%3] and nums[x] != nums[(x+1)%3]]) 
Here's my terribly convoluted solution (Hillmanov's solution is the most pythonic here): def lone_sum(a, b, c): values = [a, b, c] map = {0: True, 1: True, 2: True} counter = 0 innerindex = 0 for value in values: index = values.index(value) if values.count(value) != 1: for innervalue in values: if innerindex != index and innervalue == value: map[innerindex] = False map[index] = False break innerindex = innerindex + 1 if map[index] != False: counter = counter + value return counter
I can't understand why people upvote stuff that definitely dont' belong here :( bugtrackers are for bugs, reddit is for news.
Oh of course, I just though it was humorous that a change intended to make the transition easier would end up creating extra work for you. Thanks, and keep up the good work :) I'm looking forward to be able to work with PyPy for Python 3.
flatland and [colander](http://docs.pylonsproject.org/projects/colander/en/latest/index.html) are more or less the newer way to do things form-wise in pyramid-land.
oh absolutely, constraints in the DB should be to as great a degree as possible. It's just the "reporting it to the client nicely" part is usually best performed by duplicating those rules, or more realistically presenting those rules which the user is able to break, within a Python validation system. Database constraints aren't necessarily 1&lt;-&gt;1 with the UI model presented to the user in any case.
Agh, I really liked the PyCharm trial, but the license is a little expensive.
So, I've used SQLAlchemy to get access to unique constraints - to allow an application to update, select or delete a row based on primary key or unique constraint automatically. This has actually turned out to be very useful. Does it have the ability to likewise reflect all constraints to make it easy for the application to confirm the data prior to sending it to the database and without any duplication of code?
Yeah a quick look at FormEncode showed it was much less evolved. Collander seems to have a similar feature-set (possibly fewer bugs?) but with a less clean declarative API.
No worries. It's mainly from the bother of specifying a manage script for Django in a virtualenv. 2.0 is hard-coded to look for python files, where virtualenv/buildout set it up as `bin/python`. I think I ended up having to symlink it to manage.py to get it to work. Maybe that's more of a buildout issue than a virtualenv one, I dunno. Anything that makes that process easier, I'm all for it. I don't want to waste a few hours of my time trying to remember what I did to finally launch a django development server from pycharm. :|
It's ugly, but: def lone_sum(*args): arg_set = set() removed_set = set() the_sum = 0 for arg in args: if arg in removed_set: continue elif arg in arg_set: the_sum -= arg removed_set.add(arg) else: the_sum += arg arg_set.add(arg) return the_sum
I would imagine, but it isn't very economical to buy it if you are dabbling with python as a hobby. 
If you're a student, I think you can get a 70% discount. 
Well since CHECK constraints can have any kind of SQL expression in them, that would require being able to read in the expressions used within the schema information the database can give us back for available constraints, and then parse it into Python. The format of these expressions varies significantly and would also require a parser that can reverse-engineer a constraint given in terms of postgresql, mysql, etc. into an understandable Python expression. So it's a considerably more involved task than that which the current reflection capabilities have. Generally, we've done pretty well reflecting the basics, columns, tables, datatypes, and simple constraints, though it's taken years to cover most of the bases and work around the quirks different backends represent. Reflecting things that get a lot more database specific like triggers, constraint expressions, indexes against expressions, a much bigger job. It would be nice to have someday but is currently outside the scope of what the project can handle as far as development resources.
I'm meaning less of a memory issue and more of a namespace pollution issue.
No it doesn't. This gives an answer of 3 for the input (3, 3, 3), rather than the required answer of 0. And it gives the answer 5 for the input (3, 2, 3) instead of the required 2.
When PyPy does a Python 3.3 compatible version, yes, they will need to include `u''` literals again, since they'll be part of Python 3.3. It should be completely trivial to add when they do do that, though.
No, they were added back as a no-op for compatibility. In fact, Guido's rationale for accepting it was [meh, can't hurt](https://mail.python.org/pipermail/python-dev/2012-February/116995.html). An incompatible change reverting to Python2 behaviour would have been a very hard sell.
I understand why they were added and what they do (nothing), but that's irrelevant. They are going to be part of Python 3.3, so any implementation of Python 3.3 will need to allow them.
 def index(listhere, var): return [i for i,n in enumerate(listhere) if n == var] def lone_sum(a, b, c): temp = [a,b,c] if len(index(temp,a)) &gt; 1: return sum(temp) - a*len(index(temp,a)) elif len(index(temp,b)) &gt; 1: return sum(temp) - b*len(index(temp,b)) else: return sum(temp)
yeah, and it looks like it's as easy as dropping a shortcut in. the filenames seem to get included automatically (my winscp shortcut doesn't have reference args in the target).
Very cool. I've always wanted a basic sqlite3 wrapper.
I think there's also an open source option which gets you a free license. Honestly the price is cheap for what you get. 
... what?
No, some things weren't fixed so we have stuff to break for Python 4. 
[NetworkX](http://networkx.lanl.gov/) is a decent library for representing graphical data structures, but with a dict-like interface. 
take a look at [NetworkX](http://networkx.lanl.gov/) - it's a Python library for managing graphs has algorithms for this and many other calculations.
Great, thanks!
Thanks!
Great work! And a simple conclusion: "Simple is better than complex"
Nice job. Thanks for sharing.
Already!? You're spoiling us. This will only make us harder on you next time you're late ;)
First things first; shelve should not be used for anything. Period. I agree that on the surface, it looks and behaves pretty cool. Oh my! You can store not only state, but the 'code' that uses that state too. Wow. That does sound cool. Only until you realise that you never ever need the storage of the code that uses state outside of the application that uses it. Second, a large project will quicky succumb to the inflexibility that is, shelve. The inherent key/value storage implicitly means that you either need to do a *fucktonne* of iteration or come up with some clever means of basically emulating an SQL in order to get anything meaningful done with it. /rant. Anyway, Back on topic. The sqlite3 module is decent, it's quirky, but it's decent. However, it does not provide anything out of the ordinary that would make me choose it over the MySQLdb module (not in the stdlib). The *only* reason that I could think that the sqlite3 module won out over basically any other SQL implementation is liscensing (talking out my ass on that one). Overall, sqlite3 is cool n all but it really 'aint got shit on pretty much every *other* sql library. shelve be damned. Also, I really don't see wtf you'd need with an sql library for *another* sql library that isn't basically a bunch of context managers and interators.
Let's pretend that getting both the MySQL server running and the requisite libraries for Python is an inordinate amount of work. 1. The SQLite implementation provides about (from what I've seen of it) half of what othe SQL implementations have. 2. The SQLite provides almost zero abstraction above *files* and the access to them, I'm sure an implmentation with csv files wouldn't be much different to an SQLite one. Finally, unless you're running Windows (which I had the unfortunate displeasure of installing the MySQLdb library for the other day) then a MySQL server is but a mere `pacman -S mysql; rc.d start mysqld;` away. (or whatever your package manager uses). It's extremey simple to get such an extreme amount of power. Having an sql server running for all your SQL needs, even on a personal PC, is so useful and much more maintainable than the other options it's almost a disservice to the rest of the community *not* to have it in the stdlib. Even managing those little `db` files sqlite forces you to make is more work than it has to be. Why do you even care about those files? Granting yourself a facade onto the data you're interacting with is beautiful and allows you to stop fiddling with your filesystem and the (albeit small) hoops that sqlite/shelve/etc make you jump through.
Nice work. My biggest critique would be that this simplifies the creation problem, but nothing about the interaction is simplified.
if someone wants to work on it and can write decent tests then we can have it. The [inspector](http://docs.sqlalchemy.org/en/latest/core/schema.html?highlight=inspector#sqlalchemy.engine.reflection.Inspector) API has plenty of room to add functionality like this.
The use case here is persisting some state that's slightly more complex than basic key-value stuff. Depending on MySQL is not only overkill, it also adversely impacts the portability of your script. 
If you have a program, people are not going to want to have an entire MySQL server running just to use it hell I can't think of any program on my computer that requires MySQL running, its overkill. And instead of worrying about a server, you have to worry about the server running, starting the server (probably with admin privileges too)!
Here is the Dijkstra in Python http://bazaar.launchpad.net/~mdipierro/algorithms-animator/devel/view/head:/src/csc321algorithms.py#L1238 You can also run it interactively. The program has many algorithms and a GUI
I can't access it. Mind mirroring it at http://codepad.org/ ? (or anywhere, actually.)
Worth the wait!
Thanks for the feedback. I'll definitely look into the syscall whitelisting. The reason I said not to worry about resource consumption isn't because I don't care about it but because I just hadn't implemented in the script _yet_. EDIT: After a quick Google search, I came across [this](http://chdir.org/~nico/seccomp-nurse/) which looks pretty nifty.
HI i have been working on my own sandboxing script that is a bit further along than this script and have been talking to other people about this as of late (there seems t be alot of people on IRC trying to do this atm). my script is a bit different in that its pure python and can sandbox non python programs as well while i don't recommend putting this script into production (chroot is not a security mechanism) i can point you in the right direction if you want to make your own lib and don't want to use any of the other python sandbox environments below is a list of the main issues and some minor script improvements You hard code the UID as a number: don't do this, add a user and specify a username to avoid potential clashes on other distros chattr only works on ext filesystems, meaning you cant do this on a tmpfs for example (minor but worth noting), try looking at read only bind mounts instead, they dont need to be backed by a block device and can instead use a directory as the source (you would also only have to do the setup once and then just have all instances chroot to that dir and it would allow module updates that all instances would see at the same time) socket access is not blocked (try iptables blocking by UID/GID), this includes unix sockets using abstract path names (man unix) i don't know anyone using this feature however but once again though i would note it (know your attack surface) in a similar vein, netlink can also be accessed which can be used for interesting things on modern systems this is bad because of things like http://www.exploit-db.com/exploits/17787/ which can be used to gain root (socket.socket(AF_ECONET)) you can cause the OOM killer to be invoked by eating up lots of mem and same with CPU with a loop, look into the rlimits module to limit this disk access is not throttled, sounds odd but my VPS host monitors IO per VPS and notifies you if you are doing bad things i know you mentioned ignoring resource consumption however i wanted to mention it as workarounds such as limiting script execution time to 30 seconds is not the way to do it as all an attacker has to do is launch multiple interpreters to achieve the same effect. you would need to limit the amount of running interpreters to one per IP so that an attacker would need an above average investment in resources to attack your site the script also includes a race condition if a new instance is launched before the script is launched, i haven't looked hard into how exploitable this is but i would suspect that it would allow you to create a file in between the chattr -i and the rm -rf, creating the directory based on some other factor such as PID may be a better option mkdir $CHROOT/$PID if you move the clean up code to a function then i would recommend calling it before running the chroot and after python exits
Have you looked at [RestrictedPython](http://pypi.python.org/pypi/RestrictedPython)? We used it in a school project a few years ago; I can hardly claim to be an expert, but what we did with it [is on GitHub](https://github.com/xiongchiamiov/CSTutor/tree/master/codeshell). The project was an attempt to make an online computer science tutoring application, complete with runnable, editable code snippets, which sounds roughly like what you're trying to do.
How is kivy faster than puthon for android?
What I'm trying to point out that whilst yes, you can do a few: `SELECT X FROM Y;` type statements with SQLite, I found that the features it gives you completely hamstrung compared to every other sql implementation.
On my ArchLinux install I've got the server started prior to it a user being logged in. This is what I'm trying to show: MySQL is generally overkill due to the set up costs (which I pointed out aren't *that* big on *nix), and SQLite doesn't have advanced enough features to consider it a 'production' SQL implementation. My main use cases for anything involved with SQL have included things like: &gt; Low access rate, high volume datastore &gt; Complicated queries, using SQL's built in functions (date/time) For both of these, SQLite has failed me. SQLite failed me on the first one because of the high volume *single file* that it forced me to have. An SQL server allows management *abstraction* above files, the back ups and access of the data is managed through the SQL's interface rather than through the file system. This both allows secure access (user access) and it allows for the programmer to stop thinking about *where* the files are and how he will deal with opening and closing handles on those files. SQLite failed me in the second point because of the ridiculously small library of functions available for it. My queries using SQLite were little more than giant selects with Python picking up the slack, I didn't like this due to the way it forced using tonnes of memory or a zealous use of generators to save that memory. Having a managed database interface allows for this headache to have already been dealt with. Overall, I'm not trying to force you into using a 'bigger' SQL implementation, I just want you to see that using SQLite can get hairy pretty fast and when the limitations set in it can be a nightmare in a big project to rework it for a better system due to the constraints that had already been applied to your application.
Thanks! I have looked at some Dijkstra algorithms in Python, but I haven't succeeded in implementing it yet. I'll have a look at that code, though. At least I managed to generate the graph. EDIT: I don't get it, the argument 'r' given to the function, is it the source node or the destination node?
Alan Cox: "chroot is not and never has been a security tool. People have built things based upon the properties of chroot but extended (BSD jails, Linux vserver) but they are quite different.' source http://kerneltrap.org/Linux/Abusing_chroot Check out the scraperwiki source, they already do this throught lightweight VMs IIRC If your requirements are limited, you may find pypy's sandbox acceptable: http://doc.pypy.org/en/latest/sandbox.html If you can be flexible, v8 is designed for this. 
Since you've obviously spent some time thinking about this, what recommendations do have so far about picking a sandboxing library. Do you have any opinions about http://pypi.python.org/pypi/pysandbox/ ?
I'll also recommend Restricted Python for sandboxing although that may be too granular for this usage. In our system, we want to allow users to enter code to be evaluated hundreds of thousands of times per second, and while x == 4 is OK, and specificObject.attribute == 5 is also fine, os.open(..) is not. That must hold true even if you somehow ended up getting access to "os" or "open" in your code context. RestrictedPython (note: unrelated to restricted execution that used to be part of Python) lets you manage those ACLs very nicely, though there is about 30-40% speed penalty as code like this: "foo.bar.baz == 3" gets compiled into: secure_getattr(secure_getattr(foo, "bar"), "baz") -- where secure_getattr is your gating function. 
Oh wow, okay. Thanks. I'll try to read things a bit more carefully before asking questions from now on, haha. EDIT: Finally managed to do it. Thanks again!
np ;)
Fair enough, mine was more of a knee-jerk reaction. Apologies. Although to be picky, sqlite doesn't have a real "license", because it's public domain.
As I wrote below, the issue is that writer bought hardware with Python 2.7 installed, then bought a book that talks about a different, incompatible version of Python, Python 3. This incompatibility has been all but trumpeted from the rooftops. Blaming the Python maintainers for his issues is deeply unfair.
Anyone else having problem downloading this with Instacast on the iPhone? It seems that there is something wrong with the RSS feed.
A general solution. def lone_sum(*args): numbers = set(args) for i in args: if args.count(i)&gt;1 and i in numbers: numbers.remove(i) return sum(numbers)
Cool. Is there one in America too?
I think Supybot is still maintained, that's what I used to run. 
I think riffito's links offer good general explanations. Combining different features and having them still make sense. A good example is the `for` loop - you can use `for` with numeric values, use the `range` operator on a sequence, and so on. 
I don't know about your particular situation, so this might not be terribly relevant, but I've found writing an IRC from the socket level to be an *excellent* way to learn a number of features of the language. I've tried to write one for any language I learn beyond just patching some source code, as one of the first projects in the language. I just implement whatever features I would like to know a little more about. When I was learning Ruby, I wrote an IRC bot that would tweet any mentions of my name to me. I wrote one with a web interface in python, and just a very basic one is erlang. Its really a great project for a language you aren't entirely familiar with, because there are tons of documentation on how they should work, and they touch on quite a few of the important facets that you would need to know about a programming language. 
Yeah, ok, but let's back up and ask what you really want to achieve in terms of program structure. I think that you are trying to make a nice modular program design in which, first, the main or base module creates some key resources (like this "HTTP Server" whatever that is) and then imports one or more submodules that will need to have access by name to those resources. At least, that is what I as an old-school programmer had trouble doing, when first building a Python app that was complex enough that I needed to modularize it so I could tackle it piece by piece. So key to achieving this is understanding the [module system](http://docs.python.org/tutorial/modules.html) with the crucial idea that **import modname** creates a namespace aka symbol table that can be referenced as **modname**. So **modname.foo()** is a reference to a function defined in **modname.py**. Well, you can assign into **modname** as well, thus **modname.thing = 9** assigns 9 to the variable **thing** in the **modname** namespace -- *and creates it if it didn't exist*. Ergo, **base.py** import all sorts of library stuff importantObjectInstance = library.massiveClassDef() import submodule submodule.importantObjectInstance = importantObjectInstance And code in submodule.py can refer happily to **importantObjectInstance** as a global name and it will be referring to the object created by **base.py**. 
Based on their sourceforge page, I would say yes, but I haven't tried. Perhaps you should just use supybot, it seems to be the most used one out there.
Writing an IRC bot in Twisted is a great way to learn Twisted (was the first thing I wrote), but don't bother with it if you're only interested in an IRC bot and not Twisted's programming style. It can be tough to learn.
I said first encounter. I didn't say that I've been doing it for the past hour. I've been working on this for over a week and I've done tutorials, and i know the general basics. I posted here asking for help, not to be second guessed. However, seeing how you've clearly been offended by someone who's new to this in asking for help, I'll delete the fucking post. 
No, it just irritates the fuck out of me when I see some newbie come up and go "hey guys how do I code a &lt;mildly complex thingy&gt;?". It's like the thousands of people that go "hey how do I make skyrim? I'm so 1337 I've been programming for like 3 weeks lol?" and as a programmer who's been doing this for about half his life, it gets annoying quickly. Start small. Write a program that will respond to text typed in. A local bot, of sorts. Don't expect it to be smart, just write it so things like "2d6" will result in 2 random integers between 1 and 6 being rolled. Then learn to send stuff over a network (import socket is your friend). Then merge those two together. NOW start looking at IRC.
As interesting as this issue is, you should *never* (as I'm sure OP knows) use this kind of construct outside of testing the interpreter.
Yes, yes, terribly interesting. Out of curiosity, which construct? The usage of a module (config.py) to share class instances? What would be the preferable way to accomplish this?
This. Module dependencies should almost always be acyclic. Having two modules importing each other is just asking for trouble. Anyone who finds that they need this functionality has probably done something wrong when structuring their program.
Ahh, yes. That is a good thing to mention.
more people are adopting requests, its huge win for its simplicity. 
&gt; Arrays Tuples. Python's [arrays](http://docs.python.org/library/array.html) are low-level structure mapping to the equivalent C type. * Lists are [CS (array)lists](http://en.wikipedia.org/wiki/List_\(computing\)), they're sequences of arbitrary objects, they are integer-indexed but generally iterated. Python's lists are not sparse (you can't ever skip indexes), and they are ordered (if item A is after item B, it'll stay after item B unless you move it around yourself) * Dictionaries are [CS associative arrays](http://en.wikipedia.org/wiki/Associative_array): it's a key:value collection where the value is arbitrary and the keys are non-duplicate hashable (usually immutable) objects. Python's dict does not put any ordering guarantee, so the order you get if you iterate on a dict is completely arbitrary (and may change as you add more items in the dictionary). Python's tuples are technically immutable lists (in that you can't change the tuple itself: you can't add to it, you can't pop values from it, you can't replace existing values in it, etc...). However, they're generally used as [mathematical tuples](http://en.wikipedia.org/wiki/Tuples): lightweight structures indexed positionally (rather than by name). Python also provides a bridge between tuples and more heavyweight structures in the form of [namedtuple](http://docs.python.org/library/collections.html#collections.namedtuple). Syntactically, tuples are *not* put in `()`, the actual tuple operator is `,` (the comma). `()` is a special syntactical case for the empty tuple: the empty tuple is `()`, the singleton is `1,` (parens optional, may be required to resolve ambiguities e.g. in function calls)), the pair is `1, 2` (parens optional), the triplet is `1, 2, 3`. 
Tuples (you call them arrays, but they are called tuples, as in quintuple, sextuple, octuple, etc) are intended to hold heterogenous data or data that you don't intend to mutate - or eli5, they are there to hold different types of stuff that you don't want to change. For example - an entry in a phone book is an ideal tuple, because you're likely not to change your name or address or phone number (at least not regularly) - so a tuple that contains ('john', 'smith', 123-456-789,'Abc road') fits the pattern well. you can put this in a list with other tuples that match the same pattern, and voila, you have a phone book. Lists are intended to be homogenous collections - i.e. lots of the same thing. they are also mutable, i.e. you can change them after you make them (add items, remove items, filter things in and out). Lists can happily hold heterogeneous collections (like strings AND numbers AND other stuff) but it's normally a better pattern to hold just one type of thing in them (like strings, OR numbers, or ...) If you make a tuple, then you can't add anything to it. you need to create a new tuple with the old data as a starting point. If you make a new list, then you can add or remove items from it whenever you want. Dictionaries are different from both tuples and lists - they have a key and a value. the key lets you look up the value. Think of your bank account - your bank account NUMBER is the key, and your bank account BALANCE is the value. If you tell the cashier at the bank your bank account number, they can go and look up your balance for you. You can put pretty much anything in a dictionary as a value. You can also put pretty much anything in to be used as a key, but it makes the most sense if you put in things you know about, or can search for, as the key, and stuff that you can't easily find (or changes a lot, or is complicated) as the value. For example, your bank account number won't change (so it's easy to know it) but your balance could change every day - if you asked your bank cashier to find your bank account by trying to tell them your balance, it would be a lot harder! Normally, dictionaries are used to look things up - you put in an easily memorable key for some data, and then later on you look that key up to get the data back out. 
You ought to add frozenset for completeness. And also note that while you can't access sets by index, you can iterate over their values. Tuples can certainly save a little memory compared to lists but it seems a little questionable that they would be faster to access -- they should both be O(1). Also, I tend to think of the keys as the main elements of a dict, and saying that they support duplicate values, while true, seems a tad misleading.
You're right, element access speed is mostly the same, sometimes even faster for lists, although tuple initiation is faster. I updated the table according to your other remarks.
the price increase sucks for sure, but it needs to be taken in context. if you are looking for commodity hosting like dreamhost, yeah appengine is damn expensive. If you are a start up and you need to be able to scale up fast but you don't want to blow your first round of funding on leasing a data center and hiring a team of network engineers, and instead you would rather blow the first round on actual product development, appengine is cheaper. I reckon most people bitching about the price increase are individuals with pet projects where it's questionable whether appengine is beneficial for anything other than the proverbial scalability dick swinging.(I'd love to be proven wrong on this with real #'s, what companies went out of business, who lost their jobs due to app engines prices increasing) There are plenty of companies using appengine that are actually making money and the amount of money is significant enough that the additional appengine expense is just a variable expense.
Not what I meant. Maintainers are saying "we told you so," and I don't feel it's justified. Removing u literals was a step forward, but I guess in the current state, compatibility is a step forward as well. **EDIT:** wrong PEP, no sleep for me
That happened to me. I started programming with c, and in the beginning the classes would go really slow, with the teacher repeating stuff often, just the basic concepts (variables, ifs, cycles..) all separated. That all seemed really easy, until the day I got a big work to do (at the time felt like it :p). It was a calendar generator, you had to generate the calendar given a month/year plus other stuff (like calculate the number of days left until the end of the year). When I read the assignment I was completely lost. I had no idea how to even start that, because we had never done anything like that. I agree with whats being said. Its better to show stuff working, and then adapt it to how you want to work, then hope that, by just showing some simple examples, then all of the sudden you can write complex stuff. There's a lot of things (like code organization) that you just don't see in small examples.
I'm going. It's going to be awesome. NewRelic party is a yes as well ;)
Great to hear, but in general, you should try to avoid re-inventing the wheel as much as possible. If you absolutely only need the basic workings of a particular data structure like it seems you did, then it's ok. Lesson learned: I once wrote a basic network handler that eventually required more features that I did end up writing. Unfortunately, that meant more testing and also more bugs. I then replaced that whole infrastructure with a library (in this case, twisted) and never had to worry about the networking code again.
there's a difference between programming and hacking code together. Yes, maybe someone not familiar with programming can change a program to do something slightly different, but I don't think that works as a long term strategy. There's a reason people should start from the ground up. Maybe it's not as "interesting", but you know what, maybe people that aren't interested in development shouldn't be in the field. (same applies to other jobs, like doctors being in it just for the $)
I disagree. The problem with learning from the ground up is that it removes context which is vital in learning. I could teach for loops to a student and they can learn its syntax and functionality, but without any context of when or why to use it. If they learn it through the manipulation of an existing program they have context for the learning. Most non-educators don't realize is the difference the best way to teach something and the best way to learn something, and that they are often not the same thing.
Right that is why the first thing I put is "Not array but tuples". Just to be clear. But understood what the mean. Actually Python does have array but they are more for a Numpy kind of use cases, so I don't think he wanted those. (Try ''import array'') 
At first, inevitably, they don't understand it all. But if they keep doing it, I think they will gradually build up an understanding. A personal experience, not exactly about learning to program, but still relevant: I got involved in IPython when I wanted to port it to Python 3. At first, I was just fixing errors one line at a time, with no idea what the code around them did. As the problems got more complex, I had to look at larger parts of the code. I got the port working, and realised that I knew enough to help with some other problems. After another year, I've got a pretty good idea of how the various parts fit together, but I don't claim to understand it all.
Yeah, sorry, the feeds are kinda lame. Someday I'll get them to pass the feed validators.
I'm not really worried about passing or failing validators it would just be nice if I could use them with Instacast. (RFP is the last podcast that I still download via iTunes - I would really like to ditch it for that). Are you building the feeds "by hand"? If so why not use one of the rss/atom generation libraries? (e.g. http://www.dalkescientific.com/Python/PyRSS2Gen.html)
You give me too much credit ;-) My goal with the podcast is that it is first and foremost about Python--and that, if you find Python interesting, you'll find the podcast interesting. But I don't gear the discussion to beginners at all. I'm a longtime Pythonista, and the people I interview tend to be too, and we tend to talk about whatever's on our minds. So the podcast is just as likely to talk about long-dead historical arguments, fresh debates in comp.lang.python-dev, or major trends in Python and Python projects. By the way, if you (Radicou or anybody) have questions about stuff discussed in the show, please ask! This thread is a good spot. For example, off the top of my head Nick and I talked about the "conditional operator" versus the "and/or hack", without explaining the latter. The and/or hack means rewriting this code: if conditional: value = truevalue else: value = falsevalue like so: value = conditional and truevalue or falsevalue This has the problem that if "truevalue" is itself a false value, you'll get falsevalue, like: value = conditional and [] or None After that line, value will always be None, regardless of whether conditional is considered true or false. And yep, in modern Python we prefer the special "conditional expression" syntax: value = truevalue if conditional else falsevalue
When I started my job last summer, I had a couple of weeks to learn Python and wxPython. The [Dive into python](http://www.diveintopython.net/) tutorial really helped, and although it was strange to start with a complete piece of code that I understood nothing about, I really think I grasped it faster than I would have with a traditional tutorial.
I'm going to Social Network Analysis and generating map tiles on Thursday. Wish I could've flown in earlier to do more tutorials but work wasn't willing to help out with the bill =/. Which ones are you doing?
Myself and a couple other people from the Readability/Arc90 crew will be going - we'd be glad to meet up and talk shop if anyone's interested.
Not by hand, but not using Andrew's library either. I'm using a lower-level feed generator library written by my brother: http://home.avvanta.com/~steveha/pyfeed.html And, the validators are just the easiest way to get from here to "every rss feed consumer should accept them". It's on the to-do list, honest!
I would say that they're two different skills. It's the difference between being able to do the grammar and vocab exercises in a language class, and being able to have a conversation. Because they're two separate skills, they both need to be taught. The more nebulous skill of software design might take longer, and require more practice, but that doesn't mean it can be expected to come to the student naturally.
Good for him! Implementing a game that already exists is a great way to pick up skills! It's actually a lot easier than looking at a list of requirements, or trying to implement your own idea right out of the gate.
I was impressed when I read about the various tuple optimizations. There's some statically allocated memory for tuples that allows for tuple creation without any malloc() until the statically allocated memory runs out. Just pick scan for an empty spot. PyPy has an optimization where smaller tuples have their length stored on the tuple type object, removing the need for a length int on small tuples.
Hey, if you are the real k, then Id like to wish you good luck with this years talk, your last one was pretty informative (not that Im geting any govt contracts any time soon. but still) Anyways, I was just getting into pygame and would love to be there, but can't; if only spring break was one week later :(
I'm going with my brother on Thursday. We're both students, neither one of us are CS majors or know anyone else going, and it's both our first times. I signed up for the party! Hope to see you all there!
I can't reproduce the described behavior here. Can you provide some code where this is happening?
 from PIL import Image, ImageDraw, ImageFont img = Image.new("RGB", (500,200), (255,255,255)) draw = ImageDraw.Draw(img) font = ImageFont.truetype("arial.ttf", size=50) draw.text((10,10), "Cutoff []", font=font, fill=(0,0,0)) img.show() http://i.imgur.com/yXQ5N.png
Hear, hear. This is especially interesting to me given that I'm teaching an "intro to programming" course tomorrow...to "web designer students". 
It seems we can infer this is Windows and you're using Python 2.7, but those are the kind of things you need to state explicitly and shouldn't need to be guessed. Please post the entire traceback, not just the first line. And use pastebin, so that the line breaks are correctly preserved (or you can prefix each line with 4 spaces.) This looks like an error in the Pythonwin front-end, not anything to do with the PyXMLSec script. Can you run other python scripts, or is it just this one? Please also tell us exactly how you're invoking the command. If you're using some kind of GUI, try running it from a straight command line prompt, e.g.: python encrypt2.py xml-file key-file 
You can use virtualenv on Windows, it is just a pain to setup and maintain if you want the nice build tools and everything you get mostly free on any linux distro. What about using a virtual machine on your Windows box? That's what I do. I develop mainly on Ubuntu as a guest vm on my Windows box. It's not the best of what I can get, but it does give me all the nice little unix tools I want.
This is the real Katie! Glad you enjoyed the talk :) I'm looking forward the batch of ones this year. I'm looking into teaching a 508 class at DjangoCon, so maybe I'll see you there!
Have you tried a smaller font?
i was using pythonwin which lets you put in command line args But that is the only trace back line... I can run other scrips no problem (sry about not using paste bin) 
First PyCon for me as well... I'll be flying in from Boston. I use Python mainly in a financial setting and have been using the language extensively for a year now. In fact, Python got me my latest promotion at my job! And the math lover in me adores Python's functional features and the excellent libraries (scipy, numpy,...) So, people who have been to PyCon before -- what advice would you have for a newbie like me? Also would love to meetup some [/r/Python](/r/Python) people and get together over drinks! 
Making my second PyCon. Definitely planning on sticking around for sprints and hanging with the pyramid folks while hacking on Bookie. Looking forward to it! Completely insane week.
Welcome to my entire college experience.
Bookie looking great :-)
I *used* to live less than 2 miles away (Fair Oaks and 101). I moved away six months ago. Cursed anti-serendipity!
Please ask this question in [/r/learnpython](/r/learnpython).
Hi, I'm the author of the article. That's actual a great way to put it. I wish I thought of that phrasing.
I've tried to jump into Python with several books but it just hasn't worked for me as I just got plain bored. I tried Learn Python The Hard Way but I suffered the problems outlined in this article. It teaches you some basic fundamentals, then asks you to tie them together with very little explanation of how it works or what's going on. I learn by doing and solving problems that I'm interested in by searching and asking for help when I hit walls. The problem is, I don't have any problems I need solved with raw Python. I want to learn it for web development and future scripting purposes. I just decided to dive head first into web2py. It's like jumping in a jumbo jet with a private pilot's license and my actual progress is slow as hell because I have to meticulously research every small detail but the important part is, I'm interested. It may take me a few days to create a very simple piece of my web app but instead of doing random practice bullshit from a tutorial book that is meaningless to me, I actually feel accomplished and look forward to every small and completely insignificant milestone I hit. I recently, through the help of the web2py-users Google group, set up a proper 404 error page for when my web app can't find a database entry. Stupidly simple problem that anyone who knows a bit of Python would have solved in three seconds. It took me four hours of troubleshooting at a post that by posting a snippet of my code gave me insight into places I wasn't following best practices. Is it as fast as buckling down with a book, reading it cover-to-cover and coding hours worth of practice apps from the web? No. And I'm probably missing out on some important fundamentals that I'll need to fill in later. But I don't care about any of that because in three weeks instead of walking away from disinterest, I'm going to be coding the notification system for my personal blog piece by piece teaching myself a combination of Python, web development, basic design and database structure. That's all that matters.
Spot-on. Here's another take on it. Some people can only maintain interest in learning something when they have a problem to solve which they care about. There's not a whole lot you can do with ultra-basic programming skills, especially when you're learning very compartmentalized parts of programming. You have no way to actually *do* anything for some time. By learning in what I call the *middle-down-then-back-up* approach (as opposed to ground-up), I'm starting out by doing something then taking that knowledge to the ground when I feel like I've found two sticks to rub together. Never bored and always learning something relevant. It's slower but it cuts out the mind numbing "book learning" part. When you get stuck, bury your head in documentation. If you can't figure it out, ask someone who knows and kindly ask them to explain it in a way where they're not just rewriting your code for you. Worst case, you don't understand what they said but you can still apply their suggestions to your code. Save the advice for later and do what you can to research and understand it. I started to learn PHP like this, hacking together pieces of popular web apps like Wordpress, phpBB, vBulletin, Mediawiki, phpNuke, Drupal, PostNuke, etc. I never did completely learn PHP as the deeper I got the more I realized that I just didn't like the way it worked. I know enough to survive when working with PHP, but I never could or want to write my own PHP app. Python has become quite the opposite. The more I learn the more I realize it's a language I would really like to learn. That's another advantage of my approach. You don't have to get balls-deep before you realize you're not interested.
And that's how some people learn to do awesome things, and later become the question answerers.
I had to call quite a few hotels before I got a reservation, start with the Mariott and ask for the Python Conference block rate! They might still have some availabilities. 
Do you guys do Python for like personal projects etc? Or just have a curiosity?
Yeah definitely would like to hear what people have to offer in advice for PyCon first-timers!
If he's working with Python and Pygame, the "Invent with Python" sequel has a Snake clone (and others) on it that he can look at: http://inventwithpython/pygame
&gt; long-dead historical arguments These are very interesting, do more of these. I would say that you do at least attempt to explain some of the more difficult topics and/or explain in further detail where the guest may assume knowledge of the listener. I generally follow along pretty easily so I don't mind the content (find it very enjoyable.) Could I ask you to mail me some of the badges or stuff you've got? I'm in Poland (English guy, though) and there's no chance I'd be able to make it to receive some.
Didn't the hack have to do with RoR?
One place it's often handy in the context of the `timeit` module. This executes a string, rather than a function, but often you'll want a quick script that times different function calls, and so you need a way to inject them into the namespace the timing code is running. You can do this in the setup parameter by importing from the module the function is in. Eg. &gt;&gt;&gt; timeit.Timer("testfunc(1,2,3)", "from module import testfunc") But it's also pretty common to just put a bunch of functions in a script and time them all. In that case, you do the same, but just import from `__main__`. Eg. this came up in a [recent post](http://www.reddit.com/r/Python/comments/qd21k/does_anyone_have_a_more_elegant_solution_for_this/) here, and I used this method in my [benchmarks](https://gist.github.com/1959259). It's probably not that useful in a full-fledged program, but it can be handy for quick things like this.
Silly question, have you filed a bug report with anyone? [The PIL support page](http://www.pythonware.com/products/pil/) may be helpful.
Spoke to the blog author via email, and am trying to help out. Hopefully we can get it working nicely for them! On the weekend we had a mini sprint, and ported bdist_mpkg to python 3. This is the module used to make binary installers for python on OSX. As a side benefit now other python modules can release binary installers for OSX if they want. We have put up an experimental binary package for pygame on python 3.2 on OSX as well. It's being tracked in the issue tracker here: https://bitbucket.org/pygame/pygame/issue/110/python-32-os-x-106-binary-build-needed
Excellent news. I'm especially glad to see a company help advance the state of open source both for its own interest and for the greater good. :)
Well, we can always hope that that is the case 100% of the time. the rise of the copy/paste coder insures there will be a steady stream of questions like [this](http://stackoverflow.com/questions/9566189/jquery-doesnt-work) and [this](http://stackoverflow.com/questions/9558078/installing-django-on-ubuntu-11-10) for decades to come. 
I started off as copy and modify. I don't even have a CompSci degree (associates!). That's how I began with Python. Now that I've picked up Python and I feel decent with C and PHP I can learn how code works an order of magnitude faster by looking at functioning code rather than through a book. Perhaps, though, it's because I do a lot of research while I'm attempting to modify it. Break the code ---&gt; Google the problem --&gt; Break the code --&gt; Find a really good place for documentation --&gt; break --&gt; search --&gt; break --&gt; search --&gt; "what if I try...?" --&gt; break --&gt; search --&gt; refactor ---&gt; OHHHH THAT'S NEAT --&gt; break --&gt; search. It's a never ending cycle. I learn it very, very fast. It's equally comparable to flying down to mexico to learn Spanish versus learning from a book. I don't think I could learn it any other way. I think that's because I'm very comfortable with coding and my ability to figure stuff out.
Got bored last week and started in on this :3
Cool! Thanks!
released under the GNU public licence V.2 It's a video game, since I'm currently still working on building all the things I'm going to use in it its just a locked screen at the moment, you and your girlfriend are trapped as prisoners, you move using arrow keys and run using r, you can shoot using the f key when you or your girlfriend run out of health its game over,survive for as long as possible and get a score it uses only pygame and it has no website,mailing list or code repository aside from whats in the zip file, I am interested in contributors, please message me with he link to any modifications you have made to it and bug fixes, the main bug at the moment is the collision detection, i want the walls as solid as possible
Let's see, advice from 4 pycons (and a bunch of europython before that) although I didn't register in time this year: Mainly, *actually talk to people* :-) Like any conference, the "hallway track" is where the most interesting things happen. If you're looking to get involved in an open source project, or even if you just *use* one and want advice, this is your best shot at connecting with the *people* behind it. Find the BOF-board early, and check it often. Sit up front. Go to at least one of Raymond Hettinger's sessions, he *knows* things :-) Don't even try to use your laptop in sessions; you'll only get frustrated, noone really knows how to make 802.11 work at this density.
Thanks! Top tip: invest a few minutes setting up a repository on Github or Bitbucket - you'll have something to link to that stays up to date, and it makes it obvious how to contribute changes.
I will be there, trying to decide if I should pack shorts or not. Supposed to be in the high 60's/low 70's. This will be my second PyCon, and besides a few tutorials and talks, I'm here for the hallway track, the job hunt, and to finally learn how to play Settlers of Catan :) Outside of the ride offers, what's the best method to get from San Jose airport to the hotels? I'm flying in tomorrow evening, and am registered for the party, but haven't looked at the BoF list yet.
Good news. Memory and performance improvements on the foreground, I see. That's really good news, even for humble imporvements.
6th PyCON, teaching 2 tutorials, then looking forward to chatting about analytics, ebooks, qtile, testing, etc. Also excited to head back to old stomping grounds, kill myself at 5k and play some frisbee golf...
never mind. figured it out :)
I was able to talk my boss into the tutorials. I will be doing Twisted, DevOps, Python Epiphanies, and Advanced Python.
Are there any type of get-togethers/hang-outs during the tutorial days usually? Or do people usually get together on their own for dinner/bar? 
Thanks for posting! Might want to crosspost to r/gamedev, I'm sure they'd be into it too.
I think I shall! Thanks for the heads up!
[import curses](http://i.imgur.com/28yvB.jpg)
I wouldn't mind contributing as I'm currently getting into pygame myself. You'll definitely want to set up sourceforge or github first though.
Python python-oauth2 really being OAuth 1.0 was very disappointing for me too. In fact, I suspect that it may be holding back progress because people may assume that there's no need for another oauth2 library for python as a result.
We looked at a most of the OAuth Providers a couple of months ago as well and came to the same conclusion. We're running our API on django-piston (which has been uncomfortable enough), but we're not using the OAuth feature because a) it just didn't work very well and b) we don't trust it enough to have it running in production. The fact that Piston is seeing almost no updates is worrying us as well, so we might move to another library. Any recommendations?
I think python-oauth2 is so named because it was a fork of the [oauth](http://pypi.python.org/pypi/oauth) package, which didn't have tests or documentation, and hasn't been updated in over two years. Of course, oauth has thousands of downloads on PyPI, because it grabbed the best name.
For folks curious about getting from the San Jose airport to the convention center: Light rail service is available from Mineta San Jose International Airport to the Santa Clara Convention Center. Take the Airport Flyer Bus #10 (Free Shuttle) marked "Metro Station" to 1st &amp; Metro stop. Board Light Rail marked "Mt. View" North. It will turn left on Tasman Drive. Get off at Great America. Walk to Convention Center
Give [IdleX](http://idlex.sourceforge.net) a try. 
Not OAuth specific but I've been happy with tastypie - it works and is generally extensible enough when you need to do something odd.
When I was a kid, I *did* want to learn how to program. I never seemed to have all the tools I needed, though. For example, I had a shareware compilation with a C compiler that lacked standard C headers, so I couldn't make any example code work, and I didn't know why. I also had weird stuff like an oberon compiler and an interpreted lisp system, but no documentation. This was pre-internet access at my house. I think we should focus on making our own tools better, so that our workflow will be better, and the new coders will come.
This proves it's a bug. Now it's interesting.
I feel somewhat inclined to agree with you. Based of my own experiences and interactions with people who've been trained to program vs. those who are self-taught. There's certainly some animosity between the groups. Care to elaborate on your thoughts?
Well, I don't know if animosity covers it. I would argue that many non CS people program a tool to solve a problem in another context, that is the problem is primary. While (often? sometimes?) CS people code in order to code. The code is primary, the problem can be secondary. Which can lead to elegant solutions to the wrong problem. The bigger issue that I have noted when I have hired non-degreed people is that they can be very defensive about their lack of degree, and this can lead to personal schisms that aren't necessary. 
True and I don't intent to follow it to the bitter end no matter what, but the only reliable way to see how it works out is to try.
I feel like with class based views now in Django ... it would be awesome if someone would just write some simple classes to match the Piston behavior ... ... I'm using a mix of piston, class-based views, and regular old method based views. Far and away the django-class based views are the easiest to work with .. most flexible ... and feel like the way forward. Though there aren't any base-classes to provide for an API ... the base-classes are all targeting template based views. Someone needs to take some time and bridge the gap ... and write some API-oriented base classes for inclusion into django.
Am I missing something? I am turned off when blog posts gloss over the actual mechanism that's being described. It would be better if the author said something like: with env.new(PATH = "/tmp/foo/bin", SHELL = "zsh"): # processes created here could use the modified environment # except the context manager doesn't currently override # os.environ, so no changes will be seen by subprocesses # spawned by fork+exec, subprocess, popen, etc. pass I could see it being useful if the env object could be passed in as an environment hash to be passed to execve, subprocess, etc. which kind of avoids the issue of futzing with os.environ. E.g. class Env(object): ... @property def env(self): return self._envstack[-1] or better yet subclassing dict in this context manager, and wiring `__getitem__`, at least, to `self._envstack[-1]`. I'm not sure if this implementation is as clean as a closure, though, since the env object has global state and can be called from multiple contexts depending on the application. I don't know, just looking at this it seems like it's probably not a good example for a non-trivial problem.
&gt; Nearly everyone uses Django anyway, and that's definitely where the community mostly is, so I guess Python itself doesn't really have a "choice" ? Except that this is nonsense. Beneath Django, many web frameworks are used, and beneath web development, a pletora of other things are being done with 
That one's easy, just contact their public relations department.
Works fine for me on Windows 7, Python 2.7, too.
should crosspost to [/r/django](/r/django) 
get the latest version here: http://riouxsvn.com/svn/imgurdownloader/
Why is every damn tutorial about building a blog?
This is so true.
[It was](/r/django/comments/qit61/building_a_blog_in_30_mins_with_django_screencast/), but got stuck in the spam filter.
Did you ask the matplotlib devs on github? I would check the issues list to get an idea. https://github.com/matplotlib/matplotlib/issues
I wonder this too. In the mean time, I've been downloading and testing my code against the version in the [git repository](https://github.com/matplotlib/matplotlib) which has python 3 support already. It's not as satisfying as having an actual version and I'm wouldn't build a distributable version of my code against it, but it seems to be fully functional and it's allowed me to start fixing a lot of python 3 bugs in my code, pre-final matplotlib release.
Nah, to get Unicode right you have to support the proper Unicode Character abstraction, which contains all relevant combining marks (also, doesn't leak anything about normalization). All this dynamic switching between representations only allows you to have full support for the Unicode Codepoint abstraction. As far as the ultimate goal is concerned it's a dead end, you can't add more of the same to move to the next level of abstraction, and any reasonable implementation of the proper Unicode Character String abstraction should be able to work on top of UCS-2 w/surrogates effortlessly. If anything, dealing with a "more broken" abstraction such as the latter might make implementing and switching to the real thing easier, from a social standpoint.
wat?!
I am going to test this out because sometimes for simple sites/apps it would nice to have a micro django and surely models wouldn't be hard to incorporate.
Hmm, I seem to have replied to the wrong comment. [Here](http://www.reddit.com/r/Python/comments/qerek/need_some_hintshelp_on_how_to_start_with_a_graph/c3x6gxq) is the comment linking to that code.
What else would you like to see in a tutorial besides a blog?
[django-wsgi](https://github.com/alex/django-wsgi) lets you do something similar, see test.py for examples.
Hmm.. I don't have my code at hand, but that might be the problem. Post-delete would of course not work, since the object along with the filename doesn't exist any more... 
my +1 * 20 tutorials like this don't teach you a damn thing. 
How about a single page app built with ember or backbone and foundation or bootstrap with webframework du-jour providing json endpoints, websocket end points and row level acls on the models, supports federated login, complete with a javascript build pipeline(uglify, jslint etc...) and css build pipeline(less), 100% coverage in unit tests, full integration tests using selenium and browser mob and test swarm and deploys to the cloud. Then I'll be impressed. 
It's a bad (implied) question: "Who wants to learn how to program?" It's like asking the old "Have you stopped beating your wife?" question. Ask the right question and you'll get the right answer. Try "Who wants to solve problems?", or "Who NEEDS to solve problems?". Teach people how to get things done, soft-pedal the computer sci aspects, and they'll show up and stay.
Hi, I'm the author of pygcurse. And I agree, it is very new and I haven't had much time to improve it in the last few months. But the dependency on Pygame is intentional. This way, if you want to include graphics (or use the mouse/sound/video functions that Pygame provides) you can easily add that to your program. And also Pygame works on multiple platforms, but Python's curses module only works on unix platforms, not Windows. (Though efbot has a Console module that works pretty well.) If you think of any improvements for Pygcurse, feel free to email me.
I think I get it, but I can't imagine ever making my own. I mostly do web stuff and guis though.
Just for the record, Python is more or less a prototypal language. Python calls the prototype chain, the "method resolution order" instead, but it's the same thing. Also Python gives simple syntax (like the class keyword) on top of types &amp; classes instead of requiring the constructor be a function like in js.
Django's ORM, the SQLAlchemy ORM as well as flatland and collander (Form Validation APIs) use metaclasses, but the mere mortal who is using those apis doesn't necessarily need to know that (though it might help), and you probably won't want to use them in application code.
Can someone explain why this is useful? I'm more of a scientific programmer (i.e., self taught, mostly imperative programming) and I have no idea what this construct is for. The proposed solution in no way explains how it solves the problem statement of testing your code amongst a bunch of other applications or modules. If I have: class A(object): pass o = A() o.foo = 'foo' How is : with(state(o, foo='bar')): #do something any different than: o.foo = 'bar' #do something o.foo = 'foo' 
What are they used for in ORMs?
In Python, constructors (_\_new_\_) or initializers (_\_self_\_) are functions, and classes are instantiated by applying them as functions.
Right under the hood it's prototypes, but there's syntax that makes the prototypes look (kind of) like class-style (C++/C#/Java) OOP. EDIT: I'm not sure why I spelled "under the hood" "under-the-hood" previously.
Anyone going out to dinner tonight? I will be at the hyatt by 6. Hey locals, where do you recommend for dinner? Anyone else from Austin going? Cheers, Kevin
If you only generate config, that could work. But many tools (e.g. hg) have config files that can be edited by hand as well as automatically written. If you expect users to edit it manually, it could be doing anything.
It helps if you just post the whole shebang. Your issue may be earlier in the code, or it might be in the bits you're posting now. It just makes things a bit easier than tossing guesses in the dark.
Since you had to support Windows, pygame makes nothing but sense. It's _the_ python gaming framework/package and it's a single installer containing a lot of functionality, which is always a good thing on Windows, since you don't have package managers over there. I decided to go as simple as possible in the first step and it just made sense to use curses, since I'm on Linux. I'll actually be using pygcurse for the second reason you gave. Since it's based on pygame, the bleeding through of pygame here and there acts as pointer on how to go about the next step in the evolution of the graphics output (and eventually audio). Thanks for sharing your code :D
Hmm well it's 555 lines, and uses bmps and files... I can post a zip of my project folder though, I'll upload one now. I just want to confirm this bug on other people's machines.
The Tcl folks say they get it right as well and have for a long while. I can neither confirm nor deny that rumor.
Please use the search button before submitting anything. http://www.reddit.com/r/Python/search?q=metaclasses&amp;restrict_sr=on The first result when seaching "metaclasses" is exactly what you posted.
...but go is too hard on his eyes...wtf
For the program result there isn't, that was the goal. The problem the author wanted to solve is that restoring the values manually is error prone. It's easy to forget and if the initial values change, they have to be changed everywhere else as well.
I do love programming articles that make me feel like my mind has expanded! Thank you!
I've done both, but have concerns about using python code for configs. In a large organization you'll may have different roles &amp; authorities associated with updates to each.
Thanks, gurft. Very helpful.
A hammer!
&gt; and joins perl in the small club of languages that actually have a chance in hell of getting unicode right. Don't forget about Go :-)
Everything is going to be OK.
A complementary resource: http://eli.thegreenplace.net/2011/08/14/python-metaclasses-by-example/ - Some real life examples of metaclasses in practice
I suggest starting with something visual or auditory. So that you can see or hear the process of learning happening. Also you can share the results with your friends. One of my first hobby projects was using [Markov chains](http://en.wikipedia.org/wiki/Markov_chain) to write poetry. Markov chains are a good starting point because the math is relatively simple. With basic Markov chains you could have an algorithm draw a picture, generate music or even evolve an artificial life form. Here is a python [example](http://agiliq.com/blog/2009/06/generating-pseudo-random-text-with-markov-chains-u/) of using Markov chains to generate pseudo text.
Didn't I post this like 2 months ago? Oh, [yes I did](http://www.reddit.com/r/Python/comments/ncjwk/pretty_solid_python_metaclasses_explanation_from/) Anyways, check fishdicks comments, he had a rather interesting challenge
An implementation of the audioscrobbler protocol. Thats as easy as a blog but steps it up just a slight notch - since it forces the developer of the framework to think how to actually do things besides making blogposts. 
his beef was that the guy in SO said that there's nothing more to metaclasses than class creation. And yeah he wrote a lot and got quite some heat for that...
&gt; The codepoint abstraction is the correct level. All Unicode algorithms work with it. Who or what are "all Unicode algorithms" and why do you care about them? Here's a problem: take the first six characters of a string. If you take the first six codepoints, then you might take less than six characters, strip combining marks from the last character you took, and produce an outright invalid remainder. &gt; I don't know of any language which uses a "character" abstraction like you speak of. As Rhomboid implied, "languages that get Unicode right" do not currently exist.
Dayum that's a nice colourscheme, source on that?
Descriptors are not exactly orthogonal to metaclasses, as it happens, which makes for the funniest part of it all: [Exhibit A](http://ideone.com/TmQby): override `__new__` in the metaclass with my custom Function that also implements `__set__`, it is not called, all right, consistent with the theory. [Exhibit B](http://ideone.com/PuWUL): also implement `__new__` in the class. It doesn't get called but causes the metaclasses `__new__` to be called. Checkmate, atheists!
Not much. It is allowed to have an extra comma in tuples ( (1,2) is exactly the same as (1,2,) ), and the x,y there is just a tuple. The extra comma doesn't do anything.
If I understood, this is only for rooted devices, Am I right ?
Try socket.settimeout(5)
The only reason where this would be necessary is unpacking a 1-element tuple: x, = (1,) 
I think the OP is using `_winreg.ConnectRegistry()` which does not involve a socket at all, or at least that socket is not exposed to the user. This python binding is likely just a wrapper around the Win32 API function [`RegConnectRegistry()`](http://msdn.microsoft.com/en-us/library/windows/desktop/ms724840%28v=vs.85%29.aspx) which doesn't appear to offer any way of setting the timeout. I think what you really want here is to make your script multithreaded so that a timeout doesn't block all progress. If you had, say, 25 or 50 threads (possibly a lot more) then the occasional timeout wouldn't necessarily be the end of the world. 
I'm having difficulty understanding what your point is. You implement a Function class, giving it a `__set__` method, thereby making it a data descriptor, which real pure-Python functions emphatically are **not**. What this means is that, while normal Python functions in the class can be overridden by similarly named ones in the instance, yours can not. Then you use an instance of this not-overridable-by-instance-attributes function as the `__new__` in your metaclass. (If you remove the `__set__` method from Function, I think you'll find that your 'funny' `__new__` behaves just like any normal one.) Then you make an observation about which allocators do and do not get called. You say that when you provide an allocator (`__new__`) both in the class and the metaclass, then the former does not get called. When does in not get called? The metaclass' allocator gets called when you allocate an instance of the metaclass (i.e. when you execute the class definition block or call the metaclass explicitly); the class' allocator gets called when you instantiate the class. I hope that it's obvious that the class' allocator cannot possibly be called when you are creating the class, because the class does not yet exist at that time, so it does not have a `__new__` yet. That's why `__new__` **must** be a class method (the documentation incorrectly calls it a static method, but it's close enough, you can even think of class methods as special kinds of static method) and Python spares you the hassle of having to make it so explicitly, by doing it for you implicitly. This violates the 'explicit is better than implicit' maxim, and might be the cause of your confusion. Then you conclude with a phrase which, to me, implies that you are fully aware that what you say is nonsense. Am I to conclude that this is satire, or is there a serious point in there somewhere? **TL;DR** * if your gripe is that `Cls.__new__` is not called at the time Cls is being created, then, well, duh, of course not: because Cls doesn't exist yet, so how could you possibly access its attributes before it exists * if your gripe is that `Cls.__new__` is not called when the class is instantiated, **if** `type(Cls).__new__` is a data descriptor rather than a non-data descriptor (as real Python functions would be), then, well, erm, what did you expect? Class attribute data descriptors are *not* overridden by instance attributes: so `Cls.__new__` will not override `type(Cls).__new__`, just like it says on the tin. Remember that in this case, Cls is the instance and type(Cls) is the class. (There may be some pertinent subtleties relating to the differences between `type.__getattirbute__` and `object.__getattribute__`, but I'm not going to bother with that unless I get a better understanding of what your point is.) Edit: markdown 
Unrelated, but you should have a space on each side of the "=" too, to be more legible. This is culture, not syntax.
&amp;#3232;\_&amp;#3232;
this was my suspicion. i need to learn how to do this. EDIT: You're right. I am using _winreg.ConnectRegistry then OpenKey, and QueryValueEx to check to see if a key is set. I am currently checking for errors and this is getting the job done but I would like it to run faster. 
Whatsamatta?
I have told people off for doing this, and now its me!
That's just [bpython](http://bpython-interpreter.org/), a really nice interactive shell.
More like "Wesley Chun shamelessly plugs his latest book". How tacky.
Have you tried setting the pygame.RESIZABLE flag in the initial set_mode? pygame.display.set_mode((size), flags=pygame.RESIZABLE) It sounds like you are calling set_mode more than once, I am not sure that it will work, because set_mode is a initialization function. Like you said, it is resizing the window itself, but not the drawable surface. It is also re-calling all of the init code that pygame calls. 
I tried adding that to the command and it says: TypeError: set_mode() takes no keyword arguments.
1-element tuples happen e.g., DB-API cursor results cursor.execute('SELECT foo FROM FooTable WHERE bar = ?', [45]) result, = cursor.fetchone() # errors if you change the query result = cursor.fetchone()[0] # doesn't error if you change the query Overall the OP should focus on the fact this works on **iterables**, not that it happens to work on tuples. 1-element iterables are a lot more common than 1-element tuples if len(X) == 1: my_val = X[0] else: not_len_1() ^ doesn't work on sets, generators if len(X) == 1: my_val, = X else: not_len_1() ^ works on sets, still no generators try: my_val, = X except ValueError: not_len_1() ^ works on generators too There are cases where the final example isn't ideal (you'll lose the first two values in X if it's not exactly 1 element which will rarely be ideal) so always consider what is clearest. Many times you're just going to want to cast your iterable to a list or a tuple
I'm confused by what happens when `o = Cls()` in executed. * In the first case apparently `object.__new__` is called. * In the second case, when I define `Cls.__new__`, it is **not** called, but instead `Meta.__new__` is called (with a wrong number of arguments). If defining a function changes behaviour of the system, then the changes must involve calling the function. I override a method -- all right, the base method is no longer called, but my method is. Here I override a method and as a result some third method gets called instead. This is a perversion, this is black magick. By the way, there is a second instance of the same stuff here: notice that `Function.__set__` is not called either. When I use a data descriptor on class level, all right, the instance-attribute-shadows-class-attribute behaviour is disabled, but my setter is called instead (so I could fake the old behaviour if I so wanted) -- always, even if I do "`instance.__dict__ = ...`". But when I use a data descriptor in a metaclass this doesn't happen for some reason. So existence of a `__set__` method changes the behaviour of the system without that method ever being called. This is wrong. Not to mention that all in all you simply can't predict any of this stuff. You can't say: property X holds when I do something with an instance and a class, so it must hold when I do the same thing with a class and a metaclass. Nope, this stuff is implemented in a completely different set of methods and it's anybody's guess how it would work.
Unrelated to your problem but something that helps me. When I am programming/debugging in pygame, I don't like how the game window always moves around the screen each time it is opened, so I set an environ var to allow center SDL. Not sure why I felt like sharing, but if you put this at the top of you file it will center the pygame window on your screen. import os os.putenv("SDL_VIDEO_CENTERED", "1")
I got the same error on pygame 1.9.1, looks like it does not take keyword arguments pygame.display.set_mode((size), pygame.RESIZABLE) This works, but will probably not solve your problem/bug. This allows the user to resize the window, but on my system, if the user resizes the window, your POS still outputs below the original screen size. 
I had an error. Line 33 should read: if chosen_coin &gt; how_many_fair:
Here is the corrected code: http://pastebin.com/0jB2nYD5
just saw that you had something similar in your code, I added the centered window, because the pygame window was loading mostly off my screen on my dual monitor setup with your video window pos. 
nice, but isnt device independence highly desirable?
The question reads: "Write a program that computes the fuel efficiency of a multi-leg journey. The program will first prompt for the starting odometer reading and then get information about a series of legs. For each leg, the user enters the current odometer reading and the amount of gas used (separated by a space). The user signals the end of the trip with a blank line. The program should print out the miles per gallon achieved on each leg and the total MPG for the trip."
I'm only spending 10 seconds on this. you need to slog through it like we all did when we started programming, you will be a better man or woman for the experience. ... #This section should print the average based on the TOTAL distance &amp; TOTAL fuel used during the trip print("The fuel efficiency was {0:0.1f} miles per gallon." .frmat(total_distance/total_fuel)) should be #This section should print the average based on the TOTAL distance &amp; TOTAL fuel used during the trip print("The fuel efficiency was {0:0.1f} miles per gallon." .format(total_distance/total_fuel)) you should consider using an editor or ide, that makes things like these typos glaringly obvious for you. 
What's the `eval(gallons)` line for? If you're trying to convert them to int you should just use `int()`.
Maybe that is my error.. the program works ... but I have 2 logical errors to identify ... I'm thinking about the eval and int ... 
Just a tip, never use eval unless your *really* know what you're doing. It is unsafe unless you sanitize your inputs and not needed in 95% of cases.
Ooh I learnt so much from the [decorator](http://stackoverflow.com/questions/739654/understanding-python-decorators) post about python!
PySide [1] has now finished migration from its previous standalone setup to Qt Project [2] infrastructure. Being a Qt Add-on provides PySide a permanent home and perfect alignment with Qt Frameworks. Furthermore, the project gets improved visibility, as well as a simple, carefully thought out meritocratic project structure. In addition to the wiki that is already hosted by Qt, the PySide mailing list [3] and the bug tracker [4] are also now hosted by Qt. More information on the Qt Project can be found on the project web site [2]. The PySide project now follows Qt Project's governance model [5]. The Maintainer for API Extractor, Generatorrunner, and Shiboken is Marcelo Lira. The Maintainer for the PySide component is Hugo Parente Lima. Paulo Alcantara is an Approver for PySide. All other project roles are informal. Srini Kommoori has kindly volunteered to be the webmaster and wikimaster for the project. To developers using PySide the migration is mostly transparent. PySide is still available under the same licensing terms, and the project facilities are still the mostly unchanged. Instead of having a separate Bugzilla instance, the PySide project now utilizes Qt's Jira bug tracker [4]. Also the mailing list address has changed to pyside@qt-project.org [3]. Qt Project uses Gerrit [6] for code reviews. Developers contributing code to PySide should do it using Gerrit from now on. Read-only access to the git source code repositories is still provided via Gitorious [7]. *About PySide* PySide is a Python Qt bindings project initiated by Nokia. PySide provides access to not only the complete Qt framework but also Qt Mobility, as well as to generator tools for rapidly generating Python bindings for any C++ libraries. The PySide project is a Qt Add-on, sharing the same infrastructure and governance model as the open Qt Project itself. PySide is developed in the open, with all facilities you would expect from any modern open source project such as all code in a git repository [7], and an open bug tracker [4] for reporting bugs. [1] http://www.pyside.org [2] http://qt-project.org [3] http://lists.qt-project.org/mailman/listinfo/pyside [4] https://bugreports.qt-project.org [5] http://wiki.qt-project.org/The_Qt_Governance_Model [6] http://codereview.qt-project.org [7] http://qt.gitorious.org/pyside Best regards, Matti Airas 
&gt;&gt;&gt; str(123) == '123' True Am I wrong?
You would never literally use str(123) because it's ugly and verbose. You use str() like that when you have an integer in a variable and you need to convert it to a string. You originally wrote \`123\`, which is quite different from '123' that dgsalas wrote. '123' is just a string with text inside it. It \`123\` is taking an integer (either literal or a variable) and converting it into a string. It is also deprecated. Backticks should not be used in Python and I'm guessing they've removed it completely from Python 3.
I mistook the apostrophes for the backticks for sure there. &gt;You would never literally use str(123) because it's ugly and verbose. I used the integer 123 because it's easy to image, but it could easily be a variable the stands for an integer. Why would you never use str(123) anyway? You'd suggest I guess .format(123)? Also, I understand from your post never to use backticks?, instead use int() when needed?
1. You should ask Python questions elsewhere. 2. You shouldn't ask for homework answers on Reddit. 3. Learn to use Markdown to represent source code.
PyQt and PySide have objects that could handle this for you, and are cross platform. QImage, to open the image QPainter, to paint on the image. example (I Use PyQt, Pyside syntax may be different): image = QImage("./foo.png") painter = QPainter(image) painter.drawText(0,16,"Hello World") # text offset is based off of the bottom edge del painter image.save("./foo.png") 
Gotcha, thanks a bunch.
I will buy them champagne if that will include a for-serious and non-anemic curses module (such details aren't within the linked articles' purview).
&gt; I'm confused by what happens when o = Cls() in executed. You are instantiating the class Cls. In order to do so, you need to allocate a **new** instance of that class. This means finding the most applicable `__new__` associated with the object Cls (which is a class). We are working one level higher in the instance-type-metatype hierarchy than we would normally do (so we shouldn't be too surprised if there are some differences in behaviour) but let's ignore that fact, and see what the standard attribute-lookup-through-an-instance rules suggest: 1. `obj.__dict__` 2. `type(obj).__dict__` 3. `[b.__dict__ for b in type(obj).__bases__]` 4. Caveat: data descriptors in the types essentially cancel step 1. Following this scheme would give us (always talking about new-style classes): 1. For a class with `__new__`: `Cls.__new__`. 2. For a class without `__new__` and without a custom metaclass: `type.__new__` (synonymous with `object.__new__`). 3. For a class without a `__new__` and a Metaclass which has a `__new__`: `Metaclass.__new__`. 4. Caveat: For a class with a Metaclass which has a data-descriptor `__new__`, *regardless* of whether the class has its own `__new__`: `Metaclass.__new__`. &gt; In the second case, when I define Cls.__new__, it is not called, but instead Meta.__new__ is called Because you have shadowed it with a data descriptor in the Metaclass. Either get rid of the `__set__` in your `Function` class, or implement `Metaclass.__new__` using a plain, unwrapped Python function, and `Cls.__new__` *will* be called. Note that, so far, using the standard attribute lookup rules and descriptor protocol, correctly predicts the behaviour. &gt; (with a wrong number of arguments). Well, yes, if you deliberately break things (by sticking a `__set__` in your function implementation), then you can expect things to go funny. I'm sorry, I can't be bothered to get to the bottom of exactly why you get only 2 args rather than 4: just get rid of that `__set__` and it all works just fine. &gt; If defining a function changes behaviour of the system, then the changes must involve calling the function. Why must they? The descriptor protocol explicitly contracdicts your claim. Specifically, the mere **presence** of `__set__` *and* a `__get__` turns the descriptor into a data descriptor, thus making it override any similarly named instance attribute. You might like to play with the following example. Notice that `__set__` is an integer, so it can't be called, but its presence nonetheless makes a difference. class NonDataDescriptor(object): def __get__(*args): return "NonDataDescriptor", args class DataDescriptor(NonDataDescriptor): __set__ = 3 class Class(object): def __init__(self): self.__dict__['d'] = 'instance attribute' self.__dict__['n'] = 'instance attribute' d = DataDescriptor() n = NonDataDescriptor() instance = Class() print "d -&gt;", instance.d print "n -&gt;", instance.n &gt; Here I override a method and as a result some third method gets called instead. Which third method? &gt; This is a perversion, this is black magick. Perhaps you meant "it doesn't behave exactly as I expected it to, before studying the documentation". &gt; By the way, there is a second instance of the same stuff here: notice that Function.__set__ is not called either. Why do you expect `__set__` to be called, when nothing is being set? &gt; When I use a data descriptor on class level, all right, the instance-attribute-shadows-class-attribute behaviour is disabled, but my setter is called instead (so I could fake the old behaviour if I so wanted) -- always, even if I do "instance.__dict__ = ...". But when I use a data descriptor in a metaclass this doesn't happen for some reason. I don't follow this at all. &gt; So existence of a __set__ method changes the behaviour of the system without that method ever being called. This is wrong. No, that's the descriptor protocol. It might be unfamiliar to you, you might not like it, but that does not make it wrong. &gt; Not to mention that all in all you simply can't predict any of this stuff. Speak for yourself. &gt; You can't say: property X holds when I do something with an instance and a class, so it must hold when I do the same thing with a class and a metaclass. So your gripe is that there are some fundamental differences between those objects which are supposed to act as types, and those which aren't? I'll grant you that it would be nicer if there were no differences, but 'practicality beats purity'. &gt; Nope, this stuff is implemented in a completely different set of methods and it's anybody's guess how it would work. If you can't be bothered to understand the mechanisms involved, then I suppose you'll have to guess. And, frankly, unless you're doing some pretty off-the-beaten trail stuff, there is no reason why you should bother. 
You might be interested in a node.js-less CoffeeScript continuous compiling tool which is built in Python using PyV8 to layer the coffeescript js compiler and PyYAML for some useful build configuration files. I'd fancy to call it a "pythonista way" for the matter. So far it is working pretty good, as I've been using it in a project of mine that's not worth mention now, feel free to check it out here https://github.com/leostera/Expresso 
Simple is more efficient than complex*
So you are saying you liked it before it went mainstream? I kid, I kid.
That's a full-feature movie, I think, difficult to do in 30 minutes.
&gt;If you have a variable, then str(x) makes perfect sense. Cool. I was just using 123 as a shorthand for a given integer variable, I should have made that more clear. Thanks.
All, apologies if you read it that way... that's why I led out with the disclaimer! The publishers are the ones who need to do the promo/marketing since it the release dates are coinciding. Why wouldn't anyone turn down this oppt'y? The main goal was to provide an opinion on which books I think may work for 3 different audiences. Did you think I could get away with *not* saying anything about the latest edition? The problem is that this latest book doesn't fall into any of the 3 lists, hence why it's by itself at the bottom. As I mentioned, I'm just trying to help people find the right book for them. If mine are it, that's fine, but it's also okay otherwise. Book authors don't make enough that it matters so much.
I just installed python and pygame fresh, due to some... linux problems, so I know i have the latest versions, but I'm still getting an error saying it doesn't accept keyword arguments. 
I might be a bit late to this, but I just cloned the matplotlib git and built it using "python3 setup.py install" and it refactored using 2to3 and installed perfectly. I am on OSX Lion, Python 3.2.2 and GCC4.6, also had to make sure I had the freetype font library installed. I hope this helps you.
pulling a single arg (not option) out of `optparse` is where I usually see one-element tuple extraction. (`argparse` fixes this by letting you name arguments too, but "that's new in 2.7".)
OK, I've found something truly mysterious. It's almost trivially easy to implement a Function class, which exhibits the binding behaviour expected of pure-Python functions (including its use as class or static methods): class Function(object): def __init__(self, fn): self.fn = fn def __call__(self, *args, **kwds): return self.fn(*args, **kwds) def __get__(self, obj, typ=None): return MethodType(self.fn, obj, typ) You could get `MethodType` from the `types` module or from `type(lambda :1)`, or hack one together yourself in about 15 lines of code. You can install instances of `Function` in classes or metaclasses, as simple methods, staticmethods or classmethods, and they all work in exactly the same way as normal functions do. Here comes the mystery and Black Magick: Instances of `Function` **do not behave like real functions** if you bind them to the name `__new__`. 
No offense, but this is not really a "let's do OP's homework" subreddit. For specific programming problems, try /r/learnpython. We'd be glad to help you there. Also, lemme quote Terry Pratchett: &gt; 'Multiple exclamation marks,' he went on, shaking his head, 'are a sure sign of a diseased mind.'
From what I understand, new-style signaling is a "proprietary" Riverbank extension and as such it has no chance to ever make it into PySide.
PyPy's sandboxing is very clever, although there are already live Python interpreters in various forms around the web: * [From Pythonanywhere](http://www.pythonanywhere.com/try-ipython/) - a terminal in a browser. * [Shell on Google Appengine](http://shell.appspot.com/) - mimics the interactive Python shell. * [PEREWE](http://perewe.appspot.com/) - also on Google Appengine, can run a simple script. * [Ideone](http://ideone.com/) - a pastebin that runs code. 
wtf? proprietary? i just [researched myself](http://www.pyside.org/docs/pseps/): ### Accepted PSEPs (accepted; may not be implemented yet) * 103 Support for declaring Qt meta-object properties * 106 Shiboken helper module ### Open PSEPs (under consideration) * 102 Use Python properties instead of getters and setters * 104 Decorator syntax for declaring Qt meta-object… ### Finished PSEPs (done, implemented in code repository) * 100 New-style Signals and Slots * 101 Adopt PyQt's API 2 for PySide --- so they not only implemented new-style signals and slots and PyQt’s API 2 (automatic QVariant wrapping, autoconversion between python string(list)s and QString(List)s), it also considers even more changes to the syntax (although i doubt that’ll happen)
great news then :) 
but I would be impressed if it were done in 30 minutes. :)
But is there a way to do that in Python?
Did you cross post to [r/learnpython](http://www.reddit.com/r/learnpython/new/)?
&gt; do you even understand what is the problem? I've made no secret of the fact that I don't understand what your problem is. &gt; additionally `Meta.__new__` is a data descriptor Well, it **shouldn't** be: `__new__` is meant to be a function, and those are not data descriptors. You are taking a rarely touched language feature (`__new__`), combining it with a very rarely touched language feature (metaclasses), then piling on another very rarely touched language feature (descriptors), then you insist on doing the last one wrong (functions are **not** data descriptors: `__new__` should **not** have a `__set__`), and then you take issue with the results not being clear. I'm sorry, I just don't think this a worthwhile combination to explore. &gt; &gt; I can't be bothered to get to the bottom of exactly why you get only 2 args rather than 4 &gt; Because Python uses the same name for two different methods. Instance-constructing `__new__` and class-constructing `__new__` take different number of different arguments. They do, but I don't think that's the issue: everything works if you implement `__new__` as a real function. It looks like it's related to `__new__` somehow being special-cased and only working properly when implemented as a genuine Python function. Incidentally, it goes wrong in a different way in pypy, there I get 5 args (as opposed to the 2 I get in Cython or the 4 I should be getting). 
yes you are correct, people will try ` c = [] while 1: c.append(range(1000000000000000000000000000))` To avoid infinte loops(timeout is set) and other memory alloted problem, pypy provides such facility. You can check the source code at www.github.com/kracekumar/pylive.
`&gt;&gt;&gt; 2**10**10 Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; MemoryError &gt;&gt;&gt; ` Above output is the o/p of python interpreter The same on pypy freezes my 3GB RAM. 
Why?
Running browser side, I know of [Try Python](http://www.trypython.org/), which requires Silverlight, and [Skulpt](http://www.skulpt.org/), which translates Python to javascript.
Well, in fairness, it is trying to calculate a really massive number.... It would take quite a while to do.... And use quite a lot of memory..
I'd be up for a BoF, Saturday would probably work better for me. I'm at PyCon early, helping out with the tutorials.
Interesting... 
&gt; Well, it shouldn't be: `__new__` is meant to be a function, and those are not data descriptors. Nothing should prevent me from making a data descriptor that accepts/returns a function (or an appropriately bound method). Like, I dunno, maybe I want to automatically decorate `__new__` in a class and all its descendants to log object creation or something. Of course I then should implement `__set__` properly, to store the passed value, but the problem is that my `__get__` isn't called! &gt; You are taking a rarely touched language feature But that's the point, isn't it? That's how you judge how complex/well-implemented a software system is. A simple, well-designed system features a set of orthogonal features that will work together even if you are literally the first man to try that particular combination. That's what orthogonal means, that it doesn't require any special workarounds for certain feature combinations. A complex system works when you keep to well-trodden paths where most bugs were ironed out, but as soon as you try something less usual, everything breaks down. Vim comes to mind as a more extreme example. Attribute lookup should be more or less orthogonal to metaclasses and both should be orthogonal to instance creation customization with `__new__`. But, as it happens, they all aren't, so attribute lookup for `__new__` uses its own code path, and there's a bug on that path, where a data descriptor in a metaclass fails to intercept calls to inherited "`object.__new__`" (but works properly with custom `__new__`, even if it's inherited). And that's really a bug, it's not "results not being clear" as you put it. &gt; everything works if you implement `__new__` as a real function. I'm not sure what are you talking about, everything works for me if I implement it as a pure python non-data descriptor (i.e. when I comment out `Function.__set__` in my example). Well, except the part where I might want to implement it as a data descriptor, of course.
that looks very cool!!!
The crash happens at: print('You are ' + 12*age + ' months old.') Which Python is seeing as ambiguous due to the "+." The correct usage of print() in that case would be: print('You are', 12*age, 'months old.') Which lets the print() handle the conversion and spacing automatically. Just repeat for the other lines.
Yes, any way your code is valid check for timeout, I will add the code to tests . Thanks :)
I'm game for something Saturday night. Friday is already pretty booked up with parties and the 5k is Sat morning.
What is bof?
You're doing this the wrong way around. Instead of matching all permutations against the list, you should be checking if the (current) word can be created using the provided letters. If I understood you right, this is basically what you're trying to do: letters = raw_input("Gimme some letters: ") matches = [] def all_letters_in_word(word): for letter in word: if letter not in letters: return False return True # assumes each word is on its own line with open('words.txt') as words: for word in words: word = word.strip() if all_letters_in_word(word): matches.append(word) print "Matches: %s" % ', '.join(matches) You can check for the word length too, obviously, if that's really required. Also, never read a large text file in memory if you don't have to. That's bad programming.
You cannot add an integer to a string. Make print() do the work for you: print( "You are", age, "years old.")
Just want to point out that your math is wrong for days, hours, and minutes. No reason to keep multiplying by 12. It also probably makes more sense to ask them for their birthday rather than their age, otherwise the number of minutes you print is pretty meaningless since it will assume they were born exactly 'age' years ago.
Your words are contained in a list of 19M permutations and a list of 83K dictionary words. If you want more speed try to loop for your word over the smaller list instead of the bigger one. import re, itertools,collections def answer(): #setup our lists and predetermined informations with open('6of12.txt') as txtfile: wordlist = [] #populate our wordlist to match against for line in txtfile: word = re.findall('[a-z]+', line) if len(word) == 1: wordlist.append(word[0]) #gather the info the newest round of draw something print("Please type in all the letters.") letters = input("&gt; ") print("How long does the word need to be?") length = int(input("&gt; ")) #find all permu's of the given letters #make the word contains a vowel aeiouy #if it contains a vowel match it against our wordlist #return all matchs no duplicates found = set() letter_count = collections.Counter(letters) for word in wordlist: word_count = collections.Counter(word) if len(word)==length and letter_count&amp;word_count==word_count: found.add(word) for found_word in sorted(found): print(found_word) answer() 
Thanks to everyone who answered, sorted the issue, and I learnt something new to do in Python. Also thanks to those who pointed out the 12* mistake, don't know what happened there. 
Sweet. Donated before and donated again. So excited about this particular feature.
Oh oh oh! Me! Me! Me! 
[`$ pydoc multiprocessing`](http://cdn.memegenerator.net/images/160x/20.jpg) 
multiprocessing has been [covered in PyMOTW](http://www.doughellmann.com/PyMOTW/multiprocessing/ "Python module of the week"), that should be a good start.
Webpages!? But the documentation is right there, on your machine! Why go to a remote source if you have it right there!?
Hence the insanity wolf. Grab the `pydoc` text and tear its head off.
Ha, got me. Besides, everyone knows Q&amp;A over HTTP is the way to consume documentation these days.
Well, you initialized them with floats. To get the precision you want, you need to initialize them from strings: &gt;&gt;&gt; from decimal import Decimal &gt;&gt;&gt; Decimal('1.23') Decimal('1.23') &gt;&gt;&gt; Decimal('4.56') Decimal('4.56')
They behave like floats since you instantiated them with floats. You need to create them using strings: a = Decimal('1.23') This is probably what you want, and does something very different to a = Decimal(1.23) Also, Python 2.6 and earlier cannot do the latter at all, you will get an exception - with a helpful message that would probably have saved this head scratching!
The literal `1.23` in your source is a float. The module can't change that fact -- by the time it gets the value, it's already been rounded. There is no way for the module to change the fact that the python interpreter parses `1.23` as a float. What you need to do is avoid float literals: &gt;&gt;&gt; from decimal import Decimal &gt;&gt;&gt; a = Decimal(123) / Decimal(100) &gt;&gt;&gt; b = Decimal(456) / Decimal(100) &gt;&gt;&gt; a, b, a + b (Decimal('1.23'), Decimal('4.56'), Decimal('5.79')) Edit: Or you can use strings, which allows the module to do the conversion instead of the interpreter (which would convert to float): &gt;&gt;&gt; a = Decimal('1.23') &gt;&gt;&gt; b = Decimal('4.56') &gt;&gt;&gt; a, b, a + b (Decimal('1.23'), Decimal('4.56'), Decimal('5.79')) 
Awesome, thanks. Now one more question. How do I get them to display without putting the word Decimal in front of them with the parentheses and single quotes around them?
 &gt;&gt;&gt; print a, b, a+b 1.23 4.56 5.79
The problem stems from using a string instead of the name of a variable. 'x' and x are considered two different things. x is simply a name you have attached to some data. It can be anything, a number, a string, a list, what ever. On the other hand 'x' is always just that, a string whose value is 'x'. In English this is what you want your code to say, "Set the variable y to a list, and add each letter from the variable x to the list". What you have currently is something like "Set the variable y to a list, and add each letter of the string 'x' to it". Removing the '' around x changes the meaning from "a variable which can mean anything" to "it 'x', and that's all it is".
There's no raw_input() in python3. input() is equivalent to the raw_input() in python2.
I'm in. Can I get time and location?
[https://pycon.disqus.com/](https://pycon.disqus.com/) is the new thing this year.
Take [this online course](http://www.udacity.com/overview/Course/cs373). Is very close to what you ask.
yeah skip out the funny business with the list * print ("Hello, This is a word counter") * x = input("Type in your word: ") * print(len(x))
Even if it was not free it would still be amazing. I am on the 3rd week now. May be you would like to start it after a month and follow it in a timely manner, doing the homeworks etc.
yeah, IPython 0.11 has QtConsole, and now, IPython 0.12+ has [notebook](http://ipython.org/ipython-doc/dev/interactive/htmlnotebook.html), it is worth checking too.
In addition to what others have said, there's this idea that functions like `len()` "return" a value, so you need to assign their result to a variable like this: `the_length_of_x = len(x).`
&gt;my problem is that with 12 letters there are something like 19million 8character combinations. No, there are that many permutations, but only a few hundred combinations. However, to be able to use combinations, we'd need to be able to look things up and be sure that the letters are in the same order in the place where we're looking them up. To do that, we can use sorting. However, we need a way to reconstruct the original dictionary word from the sorted letter-set once we've looked it up. It would also be nice if we could look up the words directly, instead of scanning the entire word list for each possibility. We solve both problems at once by building a dictionary (in the programming sense) mapping the sorted versions of words to the unsorted words that can be made from those letters (a list of those for each sorted version, because there could be more than one, i.e. an anagram). Then we just look up each combination of available letters, first sorting the original set before generating combinations (to ensure that everything is in the same order everywhere). from collections import defaultdict from itertools import combinations if __name__ == '__main__': with open('completelist.txt') as f: words = f.read().split() dictionary = defaultdict(list) for word in words: dictionary[sorted(word)].append(word) print "Please type in all the letters." letters = sorted(raw_input("&gt; ")) print "How long does the word need to be?" length = int(raw_input("&gt; ")) for combination in combinations(letters, length): for result in dictionary[combination]: print result To make this more reusable, you will probably want to separate out separate functions for creating the list of results (maybe actually make a `list`, or else use a generator) and for loading the dictionary. Separation of responsibilities, you know.
83k dictionary words is hardly a large text file in 2012. It's also possible to do much better than this, which isn't correct anyway (since you've missed (a) that we might have 12 specified letters of which we are supposed to use only 8; (b) that there might be duplicate letters such that a naive 'all_letters_in_word' check might fail).
We can't help you if we don't know what issues you're running into!
Great. I wasn't going crazy. Image of my results here as well: http://i.imgur.com/YfsKt.png EDIT: Also, btw: I realize that last line is not possible. Only showing it because it does not produce an error. x = "Hello" print x[:1] Works as expected, or at least, it does at the time of editing. The code in the image now produces a "You idiot" error. 
&gt; Why aren’t package not up to the task? Will, the answer is quite simple One of the most confusing parts I've read in a long time. You need to proof-read your things!
I'm feeling so stupid now: How do I fire up the Qt-console?
Can I inspect a running Qt application with this?
Assuming you've got it installed, `ipython qtconsole`
There is a fundamental imbalance which I think is common to the entire OSS landscape: users of libraries and components are, by definition, most likely to simply be *unable* to write one, because if they were, they probably would not need a library to work for them. I know it's my case: I can glue together stuff, but when it comes to building more complicated software, I'm not good enough and I know it. So of course I won't submit patches, but I'll keep requesting features (well, not me specifically, but your prototypical user).
&gt; I don't think that it's going to work out on mobile. It worked pretty well on Maemo, so I wouldn't say it's inherently bad for mobile OSs. I'd say the major problem would be trying to get people to start using it over the standard options.
It could make a difference, but not a significant one. There are many more effective ways to speed up your program, depending on what it does and how it works.
What is pypy (im new here)
It can make a significant difference if you're doing the derefence in an inner loop, which runs very often. Don't use it everywhere, your code would get unreadable, but try it in an inner loop if you have a clear hotspot where all the time is spent.
Could you maybe actually show us the code?
i have no idea how to make this work :(
Yup give me a second and i will edit it in.
len() makes iterating over every letter seem ridiculous count = 0 print ('this is a number test') x = raw_input("type your word: ") for letter in x: if letter in('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'): count += 1 print count
I'm pretty sure you can. Look at this link for details [GUI event loop support](http://ipython.org/ipython-doc/dev/interactive/reference.html#gui-support). Basically you type as %magic command and iPython will integrate itself with the eventloop.
Storing in a global is an OK short-term solution. However, as a long term suggestion, I would totally recommend storing this kind of data in a configuration file and simply load the file in when you start the program. Ideally you create a configuration object that holds all the values you want to load/save, as well as a "default" version of it to fall back on in case you don't find a save file or whatnot. This configuration object can still be global if needed, but a more elegant approach is to pass it (or small parts of it if the config object modular) to individual objects when they're created. That way an object can know how it needs to be setup without having to know about some global configuration object.
I don't agree that Python 3 is failing, but he makes an interesting argument.
There is nothing very magical or especially bad about "globals" in Python, which are essentially module-level variables (simplyifying somewhat.) Bad design practices can lead to code clutter, but there's nothing inherently wrong about globals. The only real issue (aside from code style) is that when you reference a variable, it first looks in the local namespace and then checks globals, so there's a second lookup. So sure, use globals. Also learn the profiling tools and you can do before-and-after profiles and see for yourself what performance hit they make. (Surely to be tiny over the space of a 10-15 second program.)
Get the values as local values as default parameters. It's probably smarter, too. &gt; SOME_CONSTANT_FOO = 42 &gt; &gt; def calculate(p1, p2, foo=SOME_CONSTANT_FOO): &gt; blah blah a lot &gt; 
If your code is noticeably slow, it's almost always because of algorithm design. If you are running an O(n^3) operation when an O(n^2) solution exists, any gains you get by how you reference your variables are blown out of the water.
i suppose that would have been nice, but what kind of problems would have been introduced and how would python3 be crippled compared to what it is now if they had made it so you can run python2 and 3 from the same interpreter?
No, been busy so I forgot about the post.
You _will_ lose the ability to round-trip, there's no might about it, and it is definitely worse to lose the ability to tell the difference between two strings that normalize to the same grapheme cluster. If your application needs to normalize strings (as in your example of accepting the login) then it is already easy to do so using the standard library. 
You don't need a value to be global to be shared. Pass the value in to the functions that need it. It will be easier to maintain *and* it will run faster.
Such statistics would be hard to collect. But alas, I don't know of a single person in my circle of (mostly scientific) developer friends who are using Python 3 for their daily work. Anecdotal, but troubling. There really isn't any killer reason to move. If there was something radical like "no more GIL, guys!" then maybe there'd be more incentive.
So, as someone who really has seen no compelling reason to switch (and plenty of compelling reasons, i.e. library dependencies, not to switch) -- what exactly is so great about Python 3? Dictionary and set comprehensions don't exactly strike me as groundbreaking.
i have no idea. i use django so until they fully support python 3 i see no reason to switch. not to mention debian and ubuntu are hard enough to upgrade from 2.6 to 2.7 without breaking everything. i cant imagine upgrading to 3 is any less hassle.
I hate Python 3. I haven't yet found one single reason to switch. Python was supposed to be a simple and easy to use language. Every single change I've seen from Python 2 to 3 makes it more complex and cumbersome to use. I'm not talking just about the process of migration, I'm talking about the language itself. Suppose I wanted to start from scratch, with no legacy code and dependencies to worry about. Python 3 is more complicated to use on its own. 
I use Python 3.2 on a regular basis
I use Python 3.1 on a regular basis
I use Python 3.0 on a regular basis
I use Python 2.6 on a regular basis
I use Python 2.5 on a regular basis
I use Python 2.2 on a regular basis
I use Python 2.1 on a regular basis
I use Python 1.6 on a regular basis
Anyone managed to install this on a Mac? I think I've got PySide and QT installed OK but no luck with zeromq as the homebrew formula is out of date.
Hmm, you should know that vote counts are not always reflective of actual number of votes. Also this method is also open to manipulation through downvotes (RES enhanced display is not 100% effective in mitigating this). You might consider signing up for a free account on SurveyMonkey.com or something and using that.
&gt; Also this method is also open to manipulation through downvotes I think most r/python people are honest. &gt; RES enhanced display What's that? &gt; You might consider signing up for a free account on SurveyMonkey.com The thought didn't occur to me. In any case most of these companies have ridiculously low quotas for free accounts (SurveyMonkey's is 100 responses).
I can be the one anecdote. I use it at work.
Reddit Enhancement Suite (a suite of browser plugins for Chrome/Firefox) lets you display the actual number of upvotes/downvotes in addition to the combined score, but it's not perfect. The thing is, reddit itself does systematic downvoting of popular comments in ways that I don't understand particularly well, so even if nobody downvotes, it's not an accurate way of polling.
You're one of the very few who aren't, it would seem. Put more accurately: I don't really "worry about Python 3's future", I simply *don't care*. And right now I don't have a compelling reason to use it over Python 2, but plenty of compelling reasons to *avoid* it. I suspect this is a widely applicable description.
&gt; On the other hand, ubuntu will ship Python 3 only in the default installation with the next LTS. I never use the system-installed Python interpreter anyway. Usually [EPD](http://enthought.com/products/epd.php) nowadays, and before that I compiled my own from source, usually because many of the systems I'm going to have to deploy on (compute clusters and whatnot) are still running Python 2.4 or something absurd.
[Let me google that for you](http://lmgtfy.com/?q=software+transactional+memory)
&gt; You _will_ lose the ability to round-trip, there's no might about it No, why? Nothing should prevent either a) storing the original sequence alongside with the normalized sequence for each glyph or b) normalizing sequences on the fly for the purpose of comparison (then a String would be a tree of indices in the raw bytes). &gt; and it is definitely worse to lose the ability to tell the difference between two strings that normalize to the same grapheme cluster Why? If you're concerned about the equality regarding the underlying representation, you should work with the representation, before even decoding it. If you are concerned about the mismatch between your equality and equality in, say, a database, then you _must_ surrender the ability to round-trip, you should have all strings in your DB in the same normal form. &gt; If your application needs to normalize strings (as in your example of accepting the login) then it is already easy to do so using the standard library. It still doesn't allow me to iterate over glyphs. If `s[6:]` might result in an invalid Unicode string, then the implementation is far from perfect.
Are you kidding? ;)
I wish I could up vote you 1000 times.
Using the official [guidelines](http://docs.python.org/release/3.0.1/whatsnew/3.0.html): 1) Views And Iterators Instead Of Lists * dict methods dict.keys(), dict.items() and dict.values() return “views” instead of lists. -- This means I can no longer use list methods to manipulate dictionary keys. * "map() and filter() return iterators. If you really need a list ... rewriting the code so it doesn’t need a list at all" -- How's that more consistent? Now I need to use iterator methods in some cases, list methods in other cases where I could use just list methods before. 2) Ordering Comparisons * The cmp() function should be treated as gone, and the \_\_cmp\_\_() special method is no longer supported -- Is this simpler? 3) Integers * An expression like 1/2 returns a float -- This is neutral for a newcomer, but it royally fucks up legacy code. Expect sublte bugs in migrating. 4) Text Vs. Data Instead Of Unicode Vs. 8-bit * This was a major problem in Python, if I had to pick the worse feature of Python I'd say unicode was it. However, instead of correcting the bugs, they chose to change everything. The main problem that was the distinction between "encoded" and "decoded" variables still exists. They had the oportunity to fix this shit, they didn't. 5) Removed Syntax * You can no longer write def foo(a, (b, c)): .... Use def foo(a, b_c): b, c = b_c instead. -- WTF? Why make things more complicated? 6) New formatting * A MAJOR fuck-up here. The old system was tested and approved over millions of C-language format strings. Now they invented a new formatting method whose main characteristic is that it takes five times more effort to type and read, without offering any significant advantage. 7) Build and C API Changes * Another major fuck-up. This means legacy software will no longer work. What if I have some library from a vendor that no longer exists? 8) Performance * The net result of the 3.0 generalizations is that Python 3.0 runs the pystone benchmark around 10% slower than Python 2.5 -- no comments... 
There's a site somewhere that shows how many of the libraries are ported or not, but I'm not sure which on it is.
Valid question. What happened with that? 
is this in python 3? cause i just put the following string in a python3 program i'm writing and it still runs fine: Testing «ταБЬℓσ»: 1&lt;2 &amp; 4+1&gt;3, now 20% off! (in a comment). It might also have to do with the encoding of the actual file itself, if its ascii and you put wierd characters in it, that might mess it up
&gt; Last time I checked, the Unicode standard defined Unicode equivalence, normalization forms etc. And the algorithm for those are in terms of codepoints! I see you ignored my other point anyway. &gt; What. Unicode is a locale, no? What do you mean? No, like English vs. Lithuanian vs. Japanese. &gt; A dude named André creates an account "André" on your website using his MacOS. Then he tries to login from Linux and can't. He is like, WTF, and you are like, dude, we totally got Unicode right, but you'd better avoid non-ASCII characters in your login/password, that's how right we got Unicode! What this charming tale about the brokeness of Unix unicode has to with Python escapes me.
&gt;&gt;Integers &gt;As you said, the only problem here is backwards compatibility. I do wish Python 3 had an operator for integer floor division, though. You mean like `//`?
It's a survey.
Hello fellow Arch Linux users.
Need numpy, scipy and matplotlib on Python 3... that's a bare minimum.
&gt;... plenty of reasons to *avoid* it. Such as? I use Python 3 for some very heavy-lifting code at my job. Set comprehensions and dictionary comprehensions are unbelievably useful, they let us cut out a large amount of code and definitely increased legibility. It even sped up our code by quite a bit (although it's unclear if that's due to set comprehensions or overall Python 3 interpretation performance. We haven't ever felt that there was a package we needed to use that wasn't available to us but would have been in Python 2. Overall, I've been very happy with Python 3. 
So break backwards compatibility in a minor version? Horrible idea.
thank fucking god you didn't talk about the print function
[@pycon](https://twitter.com/#!/pycon) and [#pycon](https://twitter.com/#!/search/%23pycon) on twitter are good.
If access to globals variables is your bottleneck, either (1) Python is the wrong language for your problem or (2) you are in need of an algorithmic change
The whole point of Python 3 was that they needed to break backwards compatibility -- for the sake of Unicode, iirc.
It was a backported feature.
Close but not quite. He got arrested for being on campus at MIT using their connection to download a ton of old journal articles from JSTOR. The articles were old enough to be out of copyright, but JSTOR scanned them itself and considers them under its copyright because they took the time to do the scanning. I don't know what the law says about that, but it definitely broke the TOS you click through to use JSTOR. It's hard to tell what happened in the case, but it looks like they've dropped the charges, because it would be more trouble than its worth. 
That's not what "backwards compatibility" means. What it means is that code written for 2.4 will run just fine under 2.6 or 2.7. What you're describing is called "forward compatibility" and I'm pretty sure that there're very few languages that actually support that. 
&gt; &gt; ... plenty of reasons to avoid it. &gt; Such as? Personally, I tend to avoid writing Py3K code because my Arch systems are the only ones who have it - everything else is Python 2.4-2.6.
No it has not "always" broken compatibility. For one, your `with` example is a special case of a rare *feature* doing that, creating a new keyword. In general, 2.x code not working on 2.x+n is a bug.
&gt;&gt;Views And Iterators Instead Of Lists &gt;This allows cleaner, more readable code. Much more complicated to understand. Remember, Python was meant to be a simple language, accessible for people who are not computer scientists. When I'm in the interpreter trying to find a way to do something, it's trivially easy to type s = range(2, 20, 3) for instance, and use that list to test my algorithm. If I'm forced to write a class containing an iterator method, what's the use of Python as an interpreted language anyway? I could write a class in C++ that's just as easy to understand! &gt;&gt; Ordering comparisons &gt;If you were coming to Python 3 with fresh eyes, you would definitely never think "Hm, I wish that in addition to using comparison operators there were some arcane function I could use for the same purpose." cmp() is trivially easy to understand. The problem with methods is the same I cited above, there's an overhead in creating a class. If I had to sum up my greatest concern about Python 3 is that the whole language is going towards OOP. This is bad. I remember when in the 1980s people started talking about OOP. I started studying OOP and my general feeling was WTF? Then I saw [this article](http://drdobbs.com/184408251) that pretty much summed up my feelings. OOP only makes sense in a big production environment, where there's a large team of programmers that must work together. Objects make it easier to write APIs, that's all. When I'm working alone, developing a new algorithm, object orientation is the last thing I want. I have dozens of ideas I want to test. Will this work? Let's try it. No? Hmm, how about this way? And so on. I don't want to be forced to write a class for each little idea I want to test. The strength of Python is its simplicity. For large projects Python isn't good. Dynamic variables and duck typing create lots of problems in big projects. You want the behavior of each variable cast in stone when a group of programmers must work together. Python 3 means more complexity for simple tasks but still without robustness for complex tasks. 
That works fine until you realise that different that the %s's need to be in a different order for a different language because of the grammar being different.
It actually does Unicode right. A very rare thing among programming languages. I like the function argument annotators, e.g. def f(a: int, b: int) -&gt; int: They don't actually _do_ anything (except set the function's __annotations__ attribute), but they make it really easy to implement decorators that check arguments (and it's a form of documentation, of course). Because dynamic typing and duck typing are both nice and all, but in 99% of cases I would have liked to have received an error message when I sent the wrong argument to a function. In Python 3, a function defined inside inside another function can now change that other function's variables using "nonlocal". Real closures, afaict. A _lot_ of cleanup (no old-style classes anymore, not both &lt;&gt; and != anymore, print not a keyword anymore, no `` anymore, etc, a lot of ancient cruft removed) super() without arguments. And, well, Python 2.x development is finished. All the new work in standard modules, all further improvements will happen to Python 3. See * http://docs.python.org/dev/whatsnew/3.0.html * http://docs.python.org/dev/whatsnew/3.1.html * http://docs.python.org/dev/whatsnew/3.2.html * http://docs.python.org/dev/whatsnew/3.3.html
&gt; And the algorithm for those are in terms of codepoints! Yes, and algorithms that decode UTF-8 work in terms of bytes! That doesn't mean that "bytes" is the right abstraction to give to end users, quite the opposite! &gt; I see you ignored my other point anyway. What? &gt; &gt; &gt; There's no good way you could create a data type with those, since they depend on locale. &gt; &gt; What. Unicode is a locale, no? What do you mean? &gt; No, like English vs. Lithuanian vs. Japanese. What? &gt; What this charming tale about the brokeness of Unix unicode has to with Python escapes me. What? There are two legitimate ways to represent the string "André" in Unicode -- CNF and DNF. Neither way is "broken". Different OSes (or even different applications) do it differently. If you want that André dude to be able to login from whatever browser, you have to work with the same abstraction that he does -- with glyphs.
Matplotlib should get there with 1.2 - the development version already works with Python 3, and I'm starting to use it in scientific computing.
There are two main approaches for libraries: - Have a single codebase and use [six](http://pypi.python.org/pypi/six) for compatibility. The current trend seems to be towards doing this. - Have a Python 2 codebase which [runs 2to3 during installation](http://packages.python.org/distribute/python3.html). This is a bit more awkward, because it slows down testing on Python 3, but your code can be a bit cleaner, because 2to3 handles syntax differences.
I'll look into this. I work with Qt apps at work and I've always dreamed of having something to inspect the internals of a Qt app. I'm not quite understanding from your messages how to accomplish this, but I hope to find time to sit down and understand. Would I be right in thinking I could do something like: &gt; Run Qt app &gt; Connect IPython kernal &gt; Inspect elements &gt; Emit signals via `obj.signal.emit()` via a cli? Because that final point, emitting signals on the command line, would be greatly helpful for testing and automation.
They've not exactly switched the default - I think the plan is to have both installed for a few versions while applications are transitioned to Python 3. But they're certainly heading in that direction.
20h ago
Well, MediaWiki is a long time around and is highly (and easily) extendable. On the other side it is written in PHP. Nevertheless porting to a python wiki is a future step.
Thanks for the feedback. About license: Embarrassing as it is [you are right](http://wiki.creativecommons.org/Frequently_Asked_Questions#Can_I_apply_a_Creative_Commons_license_to_software.3F) .. I thought that a permissive license is essential for a wiki. But this is not the case for software. Probably I will change it. Any thoughts? About PEP-8, function methods have to start with a capital letter because of MediaWiki. In other points I tried to be compliant but maybe I missed some points. You can propose edits (it as wiki..). A validated method is a method that solves a known and existing problem. A method that you could find implemented in Matlab, in R or in a specialized package. Additionally it should be qualitatively written. The validated methods should be something like the [notability](http://en.wikipedia.org/wiki/Wikipedia:Notability) criteria of wikipedia. Whereas the User methods can do whatever a user wants. (Edit: Format)
why don't you just calculate the function for every pixel of your canvas ? like, canvas.createAPoint(x,exp(x)) from 0 to &lt;width in pixels&gt;
Thanks, I tried your code it gives syntax error, pointing to 0. Any suggestion?
This was not actual code, just an example. I don't even know what graphics API u are working with and i didn't even do something like that ever with python. It doesn't seem you are very experienced yet, i'd suggest you learn more about the language, how to code and to get information first before u try this task. Typically, u would just look up "python graphics" and go from there. (Look up different libraries, check out the API's and examples and look up how to draw a point)
The Free Software Foundation recommends using the [Creative Commons CC0 Public Domain Waiver](https://creativecommons.org/publicdomain/zero/1.0/) for code in documentation ([source](http://labs.creativecommons.org/2011/05/27/fsf-recommends-cc0-for-code-snippets-in-documentation/)).
Round-tripping becomes impossible if two strings that are equivalent (which is what you want) are actually different codepoints. If I substitute one for the other, then I've changed the underlying sequence of codepoints but there's no way I can determine that. Or do you are propose a new API for unicode strings that lets me access the underlying codepoints? That would work but I don't understand what the advantage is for programmers. As things stand, it is trivial for a program to normalize unicode strings, and to choose what normalization form to use (as appropriate to the situation). As you would have it, the programmer would have to go back to the bytes and construct the codepoints again or make use of a whatever new API to find out what normalization has been applied, convert a string back to codepoints and then apply a different normalization. Do you have an example where slicing a unicode string results in an invalid unicode string?
&gt; He helped to found reddit No he didn't.
&gt;I want something that I can understand and use easily. ITT calling the `list` constructor is not easy. &gt;I don't want to write classes, period. But you were advocating for using `__cmp__`, which kinda requires that you do write a class. If you don't write a class, "period", then you are going to be using classes that are already written for you. In which case, whether they used `__cmp__` or the `__lt__` family of methods is **completely and utterly irrelevant to you**, because you compare instances the same way you always have: with the relational operators (`&lt;` et. al.). Your argument is nonsense. You're complaining about a change in how you do work that you don't intend to do in the first place. &gt;OK, so show me how can I declare a variable to be an integer in Python? That is obviously not the kind of explicitness that is meant. Manifest typing would be absurd in a dynamically typed language. &gt;Run out of arguments and resort to name calling, is that it? I presented several arguments. You refuse to listen to reason and switch to arbitrary standards for whatever it is that you're looking for in the language with no seeming logic behind them. I also didn't actually call you names; I called your actions names. Because your actions fully deserve them. &gt;If Python is now about a "Zen" then I'll move somewhere else. The Zen of Python is PEP 20. It is among the best known documents in Python's history. &gt;Like most Python 3 advocates Except I'm **not one**; I'm just pointing out the holes in your ridiculous anti-p3k arguments. &gt;you talk in a condescending way ROFL. &gt;implying that anyone who disagrees with you is just plain stupid. Please stop that. No, I'm explicitly stating that you, specifically, are saying stupid things, not because you disagree with me, but because you are saying stupid things. &gt;The promise that Python initially delivered was a simple yet powerful language that anyone could use. And they still can. &gt;Now they are throwing fancy words and internal details around No, **we** are throwing them around, because that's *necessary in order to discuss and properly describe what's changed*. That is **not** necessary to **use** the language. &gt;like they expect us to learn what an "iterator method" is before we start using a computer. Except **they don't**. Seriously, quit trolling.
&gt;but using unicode_literals tends to cause other problems. Such as?
I grinned.
i remember in ubuntu once i thought i couldnt do that without uninstalling python 2.7 first. of course everything that was dependant on python2.7 also got uninstalled. that sucked.
I think it would be more like: * Modify Qt app so it can run IPython kernel * Run Qt app, select the option to start the IPython kernel * Start a Qt console to connect to that kernel * Inspect elements etc. I haven't tried doing this myself, but if you're interested, ask about it on the ipython-user mailing list - I'm sure other people will know more about it.
Some interfaces require native strings, such as `__import__()`, so you then have to work out a native string wrapper to use them in Python 2.
First of all: Why not? The target of this is to create a repository of ready to run, qualitative, peer reviewed, python code. Just as wikipedia articles contain informative content for a vast variety of subjects, it would be nice to have the same for python implementation of known computational problems. A second way to see this is: imagine Matlab, R or scipy that offer thousands of math methods. The problem is that the set of methods that they offer is static (at least compared to a wiki). If you build something cool and useful on top of these tools you can not share it within the very same framework.
I see, that's an interesting goal. Please consider establishing a site-wide standard for input/output, testing, and benchmarking. Right now it seems to offer very little more than any other snippet site.
Haven't seen the presentation yet, but I'll take a guess: 1. this is a collaborate effort (hence the wiki) to document freely available code samples 2. the wiki has been tuned to make it easy to author informative articles. 3. since the code is peer reviewed, hopefully the sample will be better examples than randomly plugging "import subprocess" into a search engine.
I like this idea a lot. It would be nice to have versions attached to the articles so that someone can import foo version 123 and never have to worry about a change in the code, malicious or otherwise.
This is almost better than being there! This is exactly the information overload I was hoping for. Thanks so much for the link!
No it isn't. Compare with other projects.
The main issue is just all the imports. Everything's pretty scattered (because I don't really know the technical workings of import). Also, I've never used easy_install or anything, and someone early in the project's life implemented something (along with tests). Since I was unfamiliar with all this, it got pretty jumbled.
Guidance: Upload it to PyPI. Move it to Gitorious. Call it "Free Software". Get an IRC channel, and a mailing list, and put them in your README. If you'd like expanded explanations of any of these, let me know. I'm glad to see this, though. The current offerings for music handling are kind of crappy. I tried to use PySoX to cut, copy, and paste music files together and never got anywhere meaningful. I understand that your project is different, though :)
How does PyPI work, and why Gitorious?
BSD LICENSE ONLY TRULY FREE LICENSE
To be honest, I've implemented most of this project in a single, ~30 line function. The difference is that my monolithic function takes a weird notation and just plays it. I have no code separation whatsoever, but I only use it as a drop-in music-playing thingamajig. You're steering this toward being a general-purpose tool, so it makes sense to structure it this way.
The problem is that your proposal makes things much more complicated for programs which need to "honour" the original codepoints in a unicode string (for whatever reason) and doesn't give you much in return. What's more your proposal requires the implementation to use one normalization, and one algorithm for defining the boundaries of grapheme clusters. This is a problem for those applications which need a different algorithm, which is what gutworth was getting at when he brought up locales. There is no one-size-fits-all method for defining character boundaries, have a look at [the description of grapheme clusters here][1], in particular the section discussing Indic requirements and the example of "ch" in Slovak. I totally agree that we care about storing strings in a normalized form (such as for comparing passwords) and when one does need to do that it is a matter of `import unicodedata; unicodedata.normalize('NFC', u'Andre\N{COMBINING ACUTE ACCENT}')` [1]: http://unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries
I call it the Yedi-Console ;-). I use it in a Product-Data-Management application. It's unbelievable usefull if you've written the app and know the API in and out *and* are doing actual work with the app.
thanks.
Reddit meetup is 6:30 I think. But if you show early it probably won't matter. :)
Most important to OP's question: The linspace-function has an optional third argument, which is the number of points you want to evaluate (default is 50, I think). The more points (e.g. 10,000), the more smooth your graph looks, simple. The drawback: computation time.
I'd have to agree with this - at a glance, it's all pretty neat. A few files of code, no circular imports. You've got tests, examples, and some documentation. That's much better than most people's first open source project. As Mark mentions below, the one thing you should do is put it on PyPI. You've already got a `setup.py` file, so it should only take a few minutes. Have a look at the [tutorial for PyPI](http://wiki.python.org/moin/CheeseShopTutorial).
Yeah it's supposed to be a full-featured music toy. It's got lots of helper functions for beginners and I've been working on a comprehensive syntax. Currently I'm working on letting users define custom wave types (so in the future this can contain a full-fledged 3xOsc)
Been awhile since I've used it, but I thought httplib2 handled cookies by default? I've logged into various sites with no problems so I'm not sure what could be not working for the OP as long as he's sending the right data.
Can you post a link to the page?
Private site. :/ EDIT: And someone's downvoted everything I've said. Yay reddit userbase!
wow, spot on. but what was incorrect about "ubuntu switched to python 3(.2) as default"? isn’t that a less accurate version of what you said?
I think the main problem of a dual Python version interpreter would be increased burden for the maintainers of the Python interpreter. I think it's mostly win for users of the interpreter, though there are some drawback: * there's more to understand about how the two systems interface with each other * it will be harder to understand what's going on in a mixed application. On the other hand, it's currently harder to figure out what's going on in a library that supports 2 and 3 both. * the interpreter size would be bigger, a potential problem in very resource-constrained environments. But the win is a smoother upgrade path for applications to Python 3, one module at the time, and smaller barriers using a Python 2 library in a Python 3 app (if the library is unicode-clean), and vice versa. 
Thanks for the tip about LocalSettings.php. I took it for granted that this cannot change. About the license, having two licenses (code and documentation) would be too complex. I would like to cover both with a permissive license. I haven't made my mind yet!
Indeed, for all the worrying I do about the speed bump between Python 2 and Python 3 for any new Python 2.x code that I write, Python 3 does look like an improved language to me. Not *spectacular* improvements, but improvements definitely. 
As a user, the only difference is `pypy program.py` rather than `python program.py`. 
these are not code snippets though, PyPedia is effectively an entire software library, that happens to a focus on having excellent documentation.
The question isn't one simply of ideology, it's also one of advertising. You, by hosting your project on GitHub, are advertising non-free software (namely, GitHub). That certainly won't help people to become familiar with a different system, if you perpetuate the old one! Same with the terminology--if you advertise it as open source, you aren't giving people an indication of what they gain. Openness? But only one or two of the tenets of the OSI are anywhere near that concept. Most of them deal with freedom. Hence, "Free Software" is even a better term when talking about OSI-approved licenses.
Ah, a list, I hadn't seen this yet when I commented above. I think you can make a sound argument for 1) ; while I have no problem with iterator abstractions and making them more common in themselves, I do think it's harder to reason about this stuff (important when writing code and debugging). Gains in memory efficiency are usually not worth it, and can be argued is premature optimization. With 2), I agree it's much easier to implement a single __cmp__ than a whole host of __eq__ and friends, though I imagine some library support can mitigate that. I have no problem with 3) myself as a language feature. Neither do you. :) I think 4) is a major improvement in Python 3. Unicode is so frustrating in Python 2 because people do it wrong, and that is because it's easy to do wrong. If you do it right (which I've been doing for years) it's actually quite manageable in Python 2, though. As to 5), I never use foo(a, (b, c)), so I'm fine with that. 6) I think they brought this back in newer versions of Python 3. 7) I think that's unavoidable if you're doing a cleanup. Anyway, it's not a language misfeature, it's a portability problem. 8) Improvements in performance are a matter of time and is not a language misfeature. Sometimes cleaning up code does remove optimized but crufty paths, or faster but risky paths. 
It's good to see you got a ticket.
I guess it's default in that if you don't do anything about it, it'll be the default. I think it's probably too early to know exactly how it'll play out, but I suspect the Ubuntu tools will explicitly reference something like `/usr/bin/python3`, then if you install Python 2 that will be the `/usr/bin/python` I could be totally wrong in how that'll end up happening, but the intent seems to be more that *Canonical* moves towards Python 3, not that they force the entire user-base to do so.
About that integer division thing, it's unfortunate that Python has no way to make sure a variable belongs to the set of [integers](http://en.wikipedia.org/wiki/Integer). The new division rules only makes it harder to enforce. Sadly, even C where you **can** make sure that an integer number will always stay an integer, does it wrong. Both division and modulus operations for integer numbers in C do not follow the accepted mathematical rules. I would adopt Python 3 at once if only they had implemented a way to declare variables to belong to a certain class. Duck typing may be convenient at times, but it sucks when you are trying to implement and debug some mathematical algorithms. 
What are you trying to access on Steam?
I take it you got a ticket then?
You need to enable the legend to see the labels, e.g. legend(loc=0)
But the advertising is only an issue because of your ideological objection to Github. As far as I'm concerned, open-source and closed software can coexist peacefully, and open source projects hosted on Github are a good example of that. So I don't mind incidentally promoting something that works really well. 'Free software' has always been an awkward term, because of the dual meaning of 'free' in English. Newcomers think it means free-as-in-beer, and old hands have to explain to them about free-as-in-speech. 'Open source' is much more intuitive: it means the source code is open.
Yes and no. All else being equal, I appreciate an open source solution, but I think programmers are within their rights to keep something closed, and there are situations where it makes more sense to do so (including Github's, I expect). I care more about open formats and protocols, so that different software can communicate reliably. I wouldn't object to taking a job at Github, for example. Although, then again, it's a Ruby shop... ;-) I think 'open' conveys the right impression fairly well. If you're giving out the source code, it's implicit that you're letting them play around with it. People will assume freedom, and it's restrictions which need explaining. 'Open' also carries positive connotations about collaboration, as in 'open to suggestions' and 'an open mind'. Of course, free has positive connotations as well, but the confusion over free-as-in-beer is still a significant drawback.
There's also an issue that even if the pure Python service works, "it's Python" is a fairly poor reason to spend your time moving data from a PHP based system that also works. There are bigger problems in the world today than fully functional PHP web applications. Of course, you're free to spend your time how you like.
And there's going to be a confusion with free-as-in-beer *every single time* a new person comes across the term free software. Open source will only confuse people who don't know what source is and that's not the audience for tinkering with code.
I'm jealous. 
OK, I can see that you appreciate the rights of content producers, which is all well and good, but if you prefer open source, why use the closed-source (to use your term) solution when a good, open one is available? And I can see where those assumptions would come from in an experienced person, but using the term "open" more than "free" might bring them to forget (or maybe never establish) the most important part of the movement: freedom! And like I said before, it takes three seconds to say "free as in speech, not as in beer", but it would take more than that to actively remind people to defend their freedom.
Well like someone else said make sure httplib2 is handling cookies, also check that there isn't other post variables you're missing such values marked as hidden in the form.
So effin jealous it's untrue. There's a BoF for a popular Python window manager I use and, dammit I live in Poland ffs.
My PyCon Stalker Suite 2012 Edition: 1. [_Official PyCon videos !!_](http://pyvideo.org/category/17/pycon-us-2012) 2. [The Talks Calendar](https://us.pycon.org/2012/schedule/) 3. [Time Zone management](http://www.worldtimebuddy.com/?lid=5128581,5393015&amp;h=5128581) 4. [Online Streaming + IRC - Not reliable though.](http://streamti.me/) 5. [Live Comments catalogued by talks](https://pycon.disqus.com/) 5. [#pycon](https://twitter.com/#!/search/%23pycon) 
thanks for the link! it looks (at least part of) the tutorial sessions has been recorded this time! awesome. is there any way to download the video(for offline use) ? 
You are welcome. They are regular youtube videos and will be posted at [NextDayVideo's youtube feed](http://www.youtube.com/user/NextDayVideo/feed). I've heard that the[ Miro player automatically downloads videos](http://lifehacker.com/400157/miro-is-your-tivo-for-internet-video) from youtube feeds. You could try the link above. There really are [multiple ways to consume youtube videos](http://lifehacker.com/400630/top-10-youtube-hacks), pick one :) 
Short video of it action [here](http://www.youtube.com/watch?v=cKYObQZM7lk). I worte this thing to make the task of scripting movement and keystroke with python a little less painful. I saw a lot of questions about it on stackoverflow (while trying to figure it out myself), and the common way to do this seems to be via sendkeys,. but I couldn't get it working with 2.7. So, after much trudging through the win32api, I figured most of it out, and finally wrapped it all in this so I wouldn't have to keep looking up Key Codes. Hopefully some here will find it a little useful! 
Have you tried using urllib2? This [site](http://www.voidspace.org.uk/python/articles/urllib2.shtml) a pretty thorough covering.
Brilliant. One of those "big ideas" that could change everything even if this particular implementation doesn't take off - but much luck to this one. I'll read more later, but wanted to give you a shout of encouragement for the idea alone.
Interesting way to garner comment karma - an upvote survey. 
Good stuff. Glad to see they are up so quickly.
Good to hear.
If you have any questions, please ask. I'm the developer.
Very nice. I will be using this as my main IDE from now on. Works great with windows.
AH! You did cut/copy/paste with right click! thanks a lot ! Great job
Isn't it? Seems likethey got a really good camera crew. I mean looking at the live stream, it's almost like they were doing all the editing live.
we are :)
He was involved in reddit but did not co-found it.
$ brew install zeromq ==&gt; Downloading http://download.zeromq.org/zeromq-2.1.7.tar.gz curl: (22) The requested URL returned error: 404 Error: Failure while executing: /usr/bin/curl -f#LA Homebrew\ 0.8\ (Ruby\ 1.8.7-249;\ Mac\ OS\ X\ 10.6.8) http://download.zeromq.org/zeromq-2.1.7.tar.gz -o /Users/andybaker/Library/Caches/Homebrew/zeromq-2.1.7.tar.gz Am I doing something wrong?
Have you run `brew update` recently?
I'm like that exact guy, I'm a Python developer/sysadmin that "on the side" sets up and helps manage VPSs with clients, including managed hosting (webfaction). I'm in the UK so our hours may not match however, here's my site http://www.dapperdogstudios.com/ and other things I've written https://github.com/radiosilence/
When all the libraries I want are available on Python 3, then maybe I'll move. And maybe not, since I don't know of any real benefits that I'll see. (And before you ask: Paste, Pastescript, MySQL-python, pymongo, Twisted, BeautifulSoup...)
There's a convenient command-line program called [youtube-dl](http://rg3.github.com/youtube-dl/) (which happens to be in Python as well) that can download them easily.
Will they be available with &lt;video&gt; I'm trying to avoid flash, and sometimes my net is shitty and I can't stream so a download would be really helpful!
Ah, yeah, it probably does. I'm not the fastest typist in the world, so I sped those parts of the video up by... *quite* a bit. I don't think there's anyway to slow it down. But more or less the code in the video if you wanted to look at it: def foo(): for i in range(1,1000,100): mousePos((i,i)) time.sleep(.1) mousePress('left') def sendMail(): press('start_mail') time.sleep(.7) pressHoldRelease('ctrl','n') time.sleep(.7) typer('email@gmail.com') time.sleep(.2) press('tab') time.sleep(.2) press('tab') time.sleep(.2) press('tab') typer('Whoo Python!!') press('tab') typer('Hello World! How are ya?') time.sleep(.1) pressHoldRelease('ctrl', 'enter') 
Well, sure. But you brought that up. I'm not saying your own post is irrelevant to itself. To continue the global warming analogy -- global warming would of course be relevant the question of pollution reduction that would naturally follow on from that. It just doesn't help the OP cross a road.
I love short videos to *demonstrate* a feature, especially if it is a very *visual* feature. But that isn't the case here. However, it **is** great to have access to all those PyCon talks almost as soon as they happen. I just wish we would have slides at the same time...
I'm glad you like it. Please let me know how to improve it.
Watch in 15 minute increments. Do something in between, then go back and watch another 15 mins. Works for me.
Just curious, what do you do for work? Unless you're a rich kid or a hunter-gatherer, I'm guessing you do something for money. 
Meh. I'll switch over to 3.x when I'm goddamned ready. And I won't blog about it when I do . . . OK, maybe a couple tweets but that's it.
Karma is not Pythonic.
GNUPlot is easy! http://codeviewer.org/preview
http://pyvideo.org/category/17/pycon-us-2012
Thanks. It's a bit hard to side-step Tkinter with IDLE. ;-) If you have any suggestions for improving it, please let me know.
Thank you !
Confirmation bias. All the presentations I have attended were running on Mac :-)
Thats why i only read scripts to tv shows
Cookielib and cookiejar are your friends.
The video quality is bad. When slides are shown it's ok, but when actual code or a console is on screen, it's not readable. Hence, half of the videos are useless. I don't remember having this problem on blip.tv.
That would be awesome. IMHO wrong time to post this question. I think it would have gotten a better response during the week.
No, not really.
thanks for the feedback
As other people have stated your problem is probably that you are not sending cookies with your follow up requests. I recently had a similar issue and solved it by using the excellent [requests](http://docs.python-requests.org/) library. With requests you could do this: session = requests.session() session.post('http://yoursite.com/login', **kwargs) Your session object will then contain the cookies received from the server and you can use it to get other resources like this: response = session.get('http://yoursite.com/content.html') content = response.content You should also look at the [auth methods](http://docs.python-requests.org/en/v0.10.7/user/quickstart/#basic-authentication) included with requests.
Logic? I was asking a serious question. I find that virtually everyone's views are also a reflection of their upbringing and life experiences.
On that note, what do you do for a living? I am a software engineer at a commercial software vendor. I have no problem being paid for my work or charging our customers for our code. We are not free, but we're hardly Microsoft or Oracle. No one is locked into using our products.
"It was like it [the television] was designed by the same people who designed my thermostat, but they had a lot more screen real estate to fuck up with" --Paul Graham (YCombindator) PyCon 2012 Keynote
What's corrupt about making a living wage, if you can find a way to do it?
Thanks, that's much less distracting than the "talk" form of the talk. &gt; That does not by itself mean there's room for a new search engine, but lately when using Google search I've found myself nostalgic for the old days I think he's actually nostalgic for the *web* of the old days, before the SEO arms race, and before a deluge of content spam from content farms made meaningful search a lot harder. Good talk though, meant to be thought provoking rather than 100% solid.
All the talks I've given were running on Macs :)
Not at all, it's a fairly obscure option
Wish I saw this yesterday :-\
&gt;any real benefits No more messing around with goddamn fucking string encodings. *Hate*. Then again, I did run into something just this week. I wrote a text file on Linux without specifying an encoding - sensibly the encoding was UTF-8. I then tried to read that file on Windows without specifying an encoding and it crapped out. Apparently Python tries to read in ASCII mode by default on Windows.
"2 days ago"
wow, can't waiting for it. is there any chance to provide a torrent or something for download. YouTube has been blocked by some country.
Oh, so it is OK to charge money for your services? I mean, you know, when Mom and Dad can't help out. Just checking.
web2py has a lot of native wiki functions via an official plugin included.
For your services, yes, but charging someone for the software was never the issue. It's the unethical treatment of the customers, via removing their freedoms, to which I object. And I don't appreciate the *ad hominem* tone of your statement, by the way. If you can't support *your* argument without attacking *me*, you should maybe re-examine what you're saying!
I'm courious to why don't they use jython for android and python.net (sorry forgot the real name) and piggy back on the mono for ios?
This project looks cool, but they really need a native English speaker to get involved in proof reading blog entries (and probably documentation) before they go out. Large parts of that entry were almost entirely unreadable to me.
I don't appreciate the elitist tone of your statements either, thus this thread. Please explain how Github is exploiting its users. No one, as far as I can see, is being forced to use Github. Actually, never mind, I've spent enough of my time talking to you about this. I'm done. 
Fair enough, thank you for the civility - honestly, I don't like to start flame wars either and I hold some strong views myself. OK, so I have a few follow up questions for you: &gt;they are then unable to control the system that controls their content Sure, but no one is preventing the uses from creating their own Github clones. Isn't that like refusing to eat at a restaurant because they won't let you use their kitchen? OK, perhaps not completely, because you typically don't bring your own ingredients to a restaurant. &gt;the culture and the marketing forces behind the culture largely drive them to make that decision "independently" Are you saying that the masses can't resist Github because it's trendy and popular? I would agree with you there, but that's hardly unique to Github. Another example is the reddit "hivemind". And on that note, reddit isn't an entirely open system either. &gt;they are unable to use it in all cases I'm not sure what you mean here. Are you talking about the private repo options? Or just reiterating that the end users don't have full control of the Github service itself. 
Sorry for the english, i'm still learning it. As for documentation, we got some contributions from native speakers but the hardest part is to get them involved during the development, not just in the initial checkout. Contributions are welcome!
I think the analogy would be more like not eating at a restaurant because the waiter, before bringing your food, has you sign a contract preventing you from examining the contents of the dish, or attempting to share the recipe with your friends, or stuffing the bread in your ears. Admittedly, the last one is ridiculous, but software companies can restrict you from specific uses of their software! And while people are driven to GitHub because of marketing and social pressure, that's really not my concern. I'm sorry I drove us away from the point there :) and while Reddit isn't fully open, I give them a large amount of credit for being, in large part, free software. Maybe it's not enough, but I missed talking to people when I left! And yes, I mean that people might be restricted from some specific uses. Maybe that means no private repos, but it could also mean that GitHub takes down things when issued a DMCA notice, or if the software is somehow determined to be obscene, or if the person who wrote it is a Republican. Ridiculous things like that aren't commonplace, but they are *possible* with non-free software.
Sweet! A few questions: 1. Do you still need a machine running Xcode? 1. Is there an easier way to test code on iOS without going through a full compilation of the Python code? 1. How do you call native iOS libraries?
1. Yes, you do need a machine with Xcode even if you are just using command line tools (check http://stackoverflow.com/questions/7924085/how-to-submit-an-ios-app-without-xcode). It's also needed to do code signing, needed for publishing on the app store 2. The full compilation of Python code is needed only once, and doesn't require Xcode. Xcode is used only for compiling the boostrap (main.m), linking will all the compiled libraries (libpython, libsdl, libkivy...). When you click "run", it will just recompile main.m, and copy the whole app to the ipad. 3. You need to make a Python extension for wrapping the iOS libraries you wanna use. Cython is one of the fastest way to do it: you code in python-derivated, and it generated a C code (that's how we are doing in kivy for all the graphics part and some others classes.)
AFAICT, that's what it normally does.
Lots of people.
that is cheating. Is there a way to do this in-script?
And why do you want to do this...? There's probably a better way.
Are you planning on wrapping up some common iOS apis like GameCenter, or even try to write a generic extension that would let us call any objective-c code (sort of like [NSObject performSelector]" ? An example on how to do a simple wrapper extension as you described would be very handy I think. I'm just guessing many people will want to integrate with existing code...
&gt; Python 2.8 That's an argument about version numbering. (Since I know the road this is leading down: I'm responding to exactly what "alantrick" said)
That is sweet, I've never seen string.ascii_letters used before.
I'm going to point you to /r/learnpython
Please see [/r/learnpython](/r/learnpython).
I'm pretty sure most ruby implementations don't compile to machine code ahead of time. I think there is at least one partial implementation of python that does and wouldn't be surprised if there were ruby implementations(possibly partly incomplete) that compile ahead of time to machine code. The default ruby 1.8 - cruby doesn't compile to bytecode. I'm not sure about 1.9. The default python -cpython compiles to byecode.
I think you have to be absolutely certain to not step into "French people do this neat trick where they talk like us, aren't they *clever*?". There's a fine line in giving allowances to someone who isn't a native speaker because you have that lower line but you should also give them some latitude for not having grown up speaking English. My general rule is draw the line at when it starts getting confusing, regardless of your place of birth. If you're (unintentionally?) dropping double negatives you're getting confusing.
I gave a talk yesterday, and someone who had read the paper it was based on told me it was better than the paper. That said, yes, I could probably polish the paper to match the talk, given enough time.
What reasons exist to care?
It's not cheating. Don't expect everything to expose a native interface it's the sign of a narrow-minded programmer. You can also use os.sched_setaffinity. 
Oh, you mean processor affinity? That's done at the OS level. Windows, Linux and OS X all have facilities for doing it, but they're all completely different. What OS are you on? It'll be a couple of lines of ctypes magic, if you're lucky.
You are looking at a conference presentation that is being made available to you, on demand, for free, mere days after it took place, and complaining because it's not in the most convenient format for you. In the world of collectible card games (my hobby, when I have spare time), there's a joke that "they could put $100 bills in the booster packs, and players would complain about how they're folded". Your comment is in the same vein, and shows an incredible level of disrespect and unjustified entitlement toward someone who put in the effort to write this tutorial, and made the time, travel and financial commitment to come to the conference and actually present it.
I'll try, i need to have a python method to send an email (like ACTION_SEND in android). But i'm still not an expert on IOS, so i can't tell if a generic extension could be written. If yes, why not using python-objc or already existing project like this one?
I've seen some paper on this topic which basically said it's bad for the CPU if one core works 100% and others are idle. That it could be damaged due to uneven overheating IIRC.
I found the code input box a bit fiddly to use: Pressing ctrl key to send seems weird (easy to unintentionally trigger, particularly because ctrl+a/ctrl+e/ctrl+d type editing shortcuts on OS X). A button, plus a shortcut like shift+return would be more standard (and would be usable on an iPad!) Also focusing the input box didn't work as I expect in Chrome - had to click on the first line (or a line with text in it) - clicking in the large empty area didn't work. Aside from that, it works - the formatting of the output is nice!
For real. I think PG is full of hot air often enough but I do enjoy reading his essays and hearing what he has to say i.e. I'm not a total Paul Graham hater. However, that hummm-uhmmm quirk is extremely irritating. He'd do well by working with a speech coach.
Good point, but still it's a topic that a lot of Pyconistas find interesting. Also, he's earned plenty of good graces in the Python community by writing blog posts like this: http://paulgraham.com/pypar.html. 
Like almost everyone I know who has anything to do with a startup.
erm, I only criticized people who do believe video is superior to the written form. I don't know who has this belief, but I know some do. I also have no criticism for the speaker. He says himself that his presentation will start out slow. I did however state that having this material in written form (i.e. the slides and hand-out that I see in the video) made directly available would be more convenient.
Reliable, until it [crashes your app](https://zeromq.jira.com/sr/jira.issueviews:searchrequest-printable/temp/SearchRequest.html?jqlQuery=summary+~+assert+AND+status+in+%28Open%2C+%22In+Progress%22%2C+Reopened%29&amp;tempMax=1000). It's 2012, why it's still a problem?
Incidentally the code under dispute is a really small tweak, but I'm open to criticism on that, too. It's all a learning experience for me.
I can't pretend to know that person's experiences, but I can offer a commonly expressed opinion: the GPL can prevent you from using software. (And I don't mean because you want to make a private fork and not contribute -- I'm talking about even when all the parties involved act in good faith and just want to use vanilla unmodified code.) For a real world example, take OpenSSL which is licensed under the original BSD license -- the 4-clause version that includes a requirement to acknowledge the code in all advertising materials. This makes the license incompatible with the GPL, because the GPL requires that users be unrestricted in how they use the software. It's therefore a license violation to link the OpenSSL library with a GPL application and distribute the binaries. This problem even affects software that is MIT licensed and which should therefore be compatible with everything, such as libcurl. Linking libcurl with OpenSSL is fine, and linking a non-SSL enabled libcurl with a GPL app is also fine. But using a libcurl that's SSL enabled and linked to OpenSSL in a GPL app is not fine because the transitive closure of the licenses is not satisfied. libcurl is caught in the middle of this and has done nothing wrong, even choosing to use a license that is compatible with everything, but it still ends up having to deal with it. People see these kind of situations and just sigh and wish that everything was MIT, because then distros wouldn't need legal teams to determine if a certain package is allowed. BTW, to deal with this phenomenon there's even a "GPL + OpenSSL exception" trend: you want to choose GPL but you also want to use OpenSSL, so you explicitly write in an exception for that as an additional allowance. Or you go off and write a complete reimplementation (GnuTLS) just so you can avoid OpenSSL. 
Even the FSF [recommends using a permissive license](http://www.gnu.org/licenses/gpl-faq.html#WhatIfWorkIsShort) for short works like this.
It should be added that GPL extensions to flask will not be approved.
Sorry, 'arrogant' is a bit strong - but it is bizarre for licensing to be dictated by such a small piece of code which directly builds on large permissively licensed codebases.
I think PDFLaTeX is quite wonderful. I admire and use it in several ways. It's also "heavy": "notoriously cumbersome and highly intractable", as Horrendous Rex puts it, matches at least some of my experience. I'm in no position even to analyze competition with PDFLaTeX. I have a couple of remarks for those with more ambition: PDF is really, REALLY big, and work with it can easily become a more-than-full-time job; and Phaseit is committed to maintenance of PyPDF2 for the foreseeable future.
Several people have given reasons why they are anti-GPL. You've simply stated that you _don't care_ about those reasons. Since choice of a license is not something that can be objectively _right_ or _wrong_, continuing to argue when you've stated you don't care is not going to accomplish anything for anyone.
&gt; but you're saying that anyone using your 40-line piece of code with them must follow your license preferences. That seems a bit arrogant. Arrogant? *He wrote the fucking code, he can license it however he darn well wants.* Whether we agree with him or not.
We're in Arkansas, but anything in the CONUS would be possible if we can sell it to management.
Wait a sec.... it's FREE!? Well. I think that greatly increases the likelihood that I'll be there, work or no work. Travel costs money, but this doesn't look like it will help us fill out our training budget, unless we eat steak for every meal :)
&gt; He wrote the *** code, he can license it however he darn well wants. Let's try to keep this civil. I've already backpedalled on my wording. He wrote a 40 line glue layer* between Flask (thousands of lines) and Pystache (a couple of hundred lines). He undeniably has the right to choose the license for that. But it feels a bit... contrary to pick a less permissive license than either of the two projects it connects. *I'm not trying to belittle this - glue is very valuable - but we should see it in proportion. And it's a couple of hundred lines if you count the tests, so kudos to him for that.
One more rapid-fire comment - that appears to be last years' schedule you linked. Unfortunate, there were a couple I was really looking forward to.
My talk was on a Windows box in front of the 3 other people who care about Windows :)
Oh yes, let me be clear, I use pdflatex all the time and I think its results are fantastic. Thanks for your informed input. :)
I too missed PyCon. But saw most of the Talks videos on youtube. I am from NWA.
yes os.listdir only I meant, sorry for the confusion 
I think my rationale for using the AGPLv3 is to promote free and open source software, with the hope that others will do the same. I understand that this is naive, what I'm interested in is whether it's counter-productive.
This is a rather interesting point, thanks for bringing it to my attention :)
Thanks for updating the issue accordingly. I hadn't researched this aspect and have been operating in somewhat of a bubble in that regard.
Let's consider what happens if I want to make money selling a piece of software, and there is an open source library that I can use. There are three possibilities: A: I use the open source library, and open source my software as well. B: I use the open source library, but keep my software proprietary. (Forbidden if the library is GPLed) C: I reimplement the functionality I need from scratch, and keep my software proprietary. GPL advocates hope that people who would prefer B will be persuaded to choose A instead. But in many cases, C is the more likely outcome. On average, the open source community benefits more from B than C, because at least some companies contribute fixes and support to upstream projects. People who have a moral objection to proprietary software might still prefer C to B - they would rather the author of proprietary code had to spend time reimplementing what they'd coded. That's logically consistent, at least, but personally I'd much prefer people use my code than rewrite it. Could A (open source) still make money? Clearly there are situations where it works, like for Redhat. But could you make money from writing, say, Photoshop, if it was GPLed? I doubt enough people would buy support to pay for the coding. The GPL does allow you to sell a product, but the first person to buy it can legally flog copies for £5, so I wouldn't bet on recovering the costs. You could try selling extensions to it, but then you're competing with people who didn't have the cost of writing the core code.
To be fair, I am asking for criticism, of any nature really. My current license choice process is essentially a checklist of only one item: * Choose AGPLv3 because it feels right I appreciate that I've been both idealistic and lazy (two things often paired!) in this methodology, and if you have a different opinion I'm very receptive to hearing it -- any way you choose to term it.
Agreed. When I consult for clients and write software for them(or write a mesh on top of MIT/BSD softwares), which client owns, I stay from all GPL because it is impossible to give back sometime as is nature of the contract. Am I being selfish, yes, in this case you can say that. But, now whenever I release any code, I use MIT license, because next guy can use it any way he/she likes. So in this regard I am being totally unconditional for the person who is using it. Is it good for the software code that I released?: short term thinking may be not, but long term absolutely. In more cases than not, person using MIT code would give back to community, even if its not related to that project. 
This is the kind of argument that makes sense to me. Thanks :)
We're [using](http://ipython.org/ipython-doc/stable/development/messaging.html) it [extensively](http://ipython.org/ipython-doc/stable/development/parallel_connections.html) in IPython, and so far I'm not aware of any problems with it. That's fairly small scale, but quite a lot of people use it, and on a variety of platforms.
I just committed an ios python module into kivy-ios. Here is the API https://github.com/kivy/kivy-ios/blob/master/src/ios/ios.pyx, and an email wrapper around messageui framework: https://github.com/kivy/kivy-ios/blob/master/src/ios/ios_mail.m. Take a look at it, and contribute to extend this module :)
No HD quality videos?
Ah, sorry about that - around here (Brighton, UK) "day rate" generally covers you for 8 solid hours. So if I were to work for 4 hours, two days a month, it would be a £250 retainer :) I'm most familiar with Ubuntu Server on Linode, but other sysadmins prefer RedHat. Also, I'm rather cheap for a sysadmin because I wouldn't be able to, for instance, manage a citrix cluster or an Active Directory, as my skills are mainly focussed on web related things (PHP/Apache/nginx/WSGI/etc), however I'm pretty experienced doing those.
These are my exact reasons as well. I use BSD myself, but our end result is the same - we wrote code that anyone can use. If someone abuses it by modifying it and not contributing back, oh well. I wrote the code to help, not because of some idea that this code should be free forever.
And what was your rationale for writing the software and releasing it? Perhaps there is someone out there who will start using the GPL because of your contribution, but on the other hand there will be many more people who'd like to use your code but can't due to the license. It's still entirely up to you of course, where are your personal priorities.
I'm trying to understand why people don't like the GPL family of licenses in order to see whether I should change my mind, too.
I see things from the other side. I work for a company that does a lot of software development and makes everything open source because it believes that's the right thing (_and_ because there are vital things we want to use that are GPL). We make complicated web apps for internal use in parts of government. We can A) Choose to develop all the vital parts ourselves and keep things closed B) Be as permissive as possible, and see our competitors take our work C) Just GPL every single line we write and stop caring about licenses from there on. C is so much easier it's unreal :-)
Since they haven't posted any documentation yet, does anyone know how useful the [pyPdf](http://pybrary.net/pyPdf/) documentation is for using PyPdf2?
If you statically link OpenSSL, it certainly applies. People disagree over whether or not dynamic linking is subject to the GPL's copyleft.
I like Python, and I use it for work. I probably averaged about 20 hours per week over the past two months, and will continue to do so for another couple of months. Then, it will likely once again be only a hobby for me. My wife and I have hosted several large events, including local/regional festivals, dance competitions, and pageants. This is **completely** unrelated to python, but here's an example of an upcoming event we are organizing: [Arkmo Youth Pageant Expo](http://arkmoyouthpageantexpo.com/). I hadn't considered PyCon funding regional conferences. I'm really interested now. It might make more sense to hold something like this in NWA. The Fayetteville Town Center is big enough to do it, thought parking would be an issue...
Neither is legal if you want to distribute the resulting binary. The result of combining two works is a derived work. The licenses of both must be simultaneously satisfied, i.e. MIT+GPL = GPL because MIT is less restrictive than GPL so the MIT licensed portions can be "upgraded" to GPL and the result is 100% GPL, and thus the MIT license is said to be GPL-compatible while the OpenSSL license is said to be GPL-incompatible. The FSF maintains a list of [which licenses are and aren't GPL compatible](http://www.gnu.org/licenses/license-list.html). Edit: about dynamic linking, I don't think it's really a grey area. Most people agree on the process as the fundamental container. If two pieces of code live in the same process space, they are considered to be part of the same program. This is the interpretation of the FSF's team of lawyers. Thus an application and any library it links to, statically or dynamically, must be compatible. But two applications that exist as separate processes and only communicate over a socket do not have any license obligations. This is the reason why the Linux kernel being GPL imposes no restrictions on the license of user-land applications, as the kernel/userspace border is considered a demarcation. The only grey area, if it exists, relates to dynamic loading, i.e. where an extension module that is written by a third party and uses a defined extension API is loaded into your process at runtime. &gt; The intriciacies of these licenses and their interactions are a big grey area for me! That's a strong sign that you shouldn't be trying to impose an unconventional license into an existing ecosystem. 
Always interesting see how others organize their work. Enlighten see those custom variables (SITE, PROJECT and VAR) with names relative to the proect layout, in terms of software development and not in terms of deployment. Maybe they will be useless in the production enviroment, especially in deployments that split the project in different filesystem places, but is better to have a remain than a lack. It would be interesting then that the deployment process, if automated, take care of the Django variables. Why does it have the server logs outside the var directory?
There's DjangoCon, coming to DC labor day weekend! Also, I heard a lot about EuroPycon (sigh, if only). You should also see if your employer would pay you to take off and watch the posted PyCon talks for a few days ;)
I use buildout to create project with one of 2 environments - prod &amp; dev. Usually i store logs (nginx) at ~/logs/ and virtualenv at ~/env/ (because i usually have more than 1 django application working together as one project). project/settings.py are common for prod/dev and ./bin/django-prod and ./bin/django-dev use separated configs project/production.py and project/development.py which both import * from project.settings. One simple layout i have at github (version without nginx &amp; without uwsgi) - https://github.com/onjin/django-buildout-template
How so? If I have 8 cores, what does it matter if I suddenly lose one core? 
Looks interesting. Are you going to get that into Python3 core?
this is my current implementation. It's a little wonky tho :(
Ok, I see how it works now. Very cool, thank you. It would be good if there was a way to generate the wrappers automatically from an objective-c file, but I don't really know if anything like this already exists...
I am guessing that ThreadUrl is one of the classes shown in the IBM document. As far as I can tell from a quick scan, the "pattern" being shown is for something that runs in a bunch of threads and does something with each of the given URLs. The result ends up in a queue called out_queue that you would read to get the results. Dunno how useful that would be as the results wouldn't be in any particular order. I think that you would have to come up with your own code to do something that was actually useful. If it turns out that you just want to learn about threads in Python then you should probably skip this particular series of examples. It is pretty specific. Go back and look at it once you have the basics. 
I think it's important to note that "but the rest of your environment uses an incompatible licence" is fundamentally not an anti-GPL argument. It's a "be aware of surrounding code when you choose a licence for a project" argument -- especially in a case like this where the whole point of a small piece of code is to enable two specific pieces of existing software, neither of which use a GPL licence, to work together. It would seem logical (to me) that a bridge component should be licensed at least permissively enough to fit with the two projects it connects. My personal view is that all licences are tools and the idea of having a favourite licence is like having a favourite screwdriver -- great and understandable but a separate, emotional, issue to whether it'll work in any particular case. I agree there are a lot of people trying to kick GPL because they don't like it. That's like having an un-favourite screwdriver and I think the same argument applies. Of course, none of this is a reason not to use a particular license if it is your code and that's what you want to use, it's just something you bear in mind when choosing how to licence code. It's easy to treat licences as just a badge to stick onto software after you write it but they do do something and it's advisable to consider them as a functional part of your program with a purpose. In this case, the licence you choose may restrict who'll approve your code.
I'm glad to see this kind of post, people aren't often open to being proven wrong around here! That being said, I'm here to help you understand and, hopefully, strengthen your point. I wrote [at length](http://blog.marktraceur.info/blog/2012/why-we-need-gpl.html) about the subject, particularly why people are peeved at the GPL and its kin, and then turned to see the benefits and why we still need it around. TL;DR, the GPL is still necessary (and I wouldn't restrict its necessity to larger works) because there is a valid social wrong being perpetrated on software users, and the GPL is a helpful tool for righting that wrong.
DO NOT WANT 
So you'll need to make 2 libraries that handle that for each platform.
You might consider [OSCON](http://www.oscon.com/oscon2012). They have a Python track every year.
Sorry you're right. The full code is in the paper. I'll write up some pseudo code in a little bit. I think in the example, ThreadUrl inherit from threading.Thread, pulls an item off the queue, sends it to a worker process and prints the output. I have something working where it puts the results into a second queue and it see,s to be working. Maybe. I'll try posting the code tomorrow if I can't figure it out.
&gt; Anybody wishing to do the same while working within the community's licensing standards will now have to develop a reworked or slightly more convoluted solution to avoid stepping on your copyright. Only if they knew of his code, the exact implementation of his code, and had it in mind when developing their own code. Claiming copyright on something doesn't mean somebody can't come up with the exact same thing independently in the future.
This is really cool! Thanks for sharing.
Python vs. C - Python has excellent C bindings, using [ctypes](http://docs.python.org/library/ctypes.html), [cython](http://cython.org/), etc. You can use Python as high-level glue logic and then code your CPU-intensive operations in C. Alternatively, you can use Python for prototyping your algorithms before coding them in C. The interactive REPL makes Python more convenient for exploratory programming than C's write-compile-run cycle. Python vs. Matlab - Matlab has arguably the best syntax for matrix manipulation. It also has very mature functionality and accompanying documentation for solving numerical problems. However, Matlab and each toolbox requires separate licensing which can be extremely costly outside of academia. [Scipy](http://www.scipy.org/) and [Matplotlib](http://matplotlib.sourceforge.net/) provide similar capabilities to Matlab. For simple projects, Matlab and Python can "feel" similar in capability. However, here's the core distinction: Python is a general-purpose scripting language with excellent extensibility; Matlab is a linear algebra system with a scripting language bolted on. 
Well youtube videos aren't the hardest thing to download. If you have chrome dev tools / firebug you can just save the filestream, otherwise plenty of googlable how-tos.
While the AGPL might seem to promote free and open software, perhaps I can offer a different perspective. The copyright lobby wants to gather more and more rights for themselves. Consider what the AGPL claims for the copyright holder, that not only do they own the copyright to the software, but the product of that software as well. Imagine Adobe saying they have a claim of what a person produces using Photoshop. This is an extraordinary claim of rights for the copyright holder. 
Wow.
To be fair, the AGPL doesn't give copyrights to the owner of the original library; it just forces the modifier to also license their own work under the same terms. There is a slight difference, in that they can relicense their own work (assuming, of course, it doesn't include the original AGPL stuff), so if some side part becomes useful, they can sell proprietary licenses, for instance. Or, more commonly, they can copy+paste code from one project to another that uses a permissive license.
[Octave](http://www.gnu.org/software/octave/) is an open source alternative to Matlab. I only used it briefly and it works like Matlab as I remember it. Check out [Pytave](https://launchpad.net/pytave) as well.
This indeed is about removing the need for an ``__init__.py`` 
&gt;PDF is really, REALLY big, and work with it can easily become a more-than-full-time job Isn't that the truth! I regret not having more time to spend working on pyPdf with you. I'm glad to see it is making some excellent progress however, and wish you the best of luck going forward with PyPDF2. :)
It needs the underscore at the end removed.
We should do this.
I thought it would be a good license since it is very un-restrictive. You can use it both in commercial products and build upon it as long as you give credit. I'm not a licensing guru however, if you can tell me why it was a bad idea, I can still re-release it under some other license...
If you want it to be very unrestrictive, BSD is probably better for you. Also, this will ensure you can mix this with other software with different licenses.
Which is a valid point in this specific case, but not against the GPL in principle.
 def identify(animal): if animal.is_vertebrate(): return identify_vertebrate() else: return identify_invertebrate() def identify_vertebrate(animal): noise = animal.poke() if noise == 'moo': return 'cow' elif noise == 'woof': return 'dog' def identify_invertebrate(animal): if animal.is_multicellular(): return 'Bug!' else: if animal.is_fungus(): return 'Yeast' else: return 'Amoeba' #----------------------------------------------------------------------- print 'Flat is better than nested.' Shouldn't return identify_vertebrate() accept 'animal'?
 f.write(json.dumps(measurements)) (from "Simple is better than complex"), could be: json.dump(measurements, f)
All the PyOhio talks are recorded, just like PyCon. Have a look at [http://pyvideo.org/category/12/pyohio-2011](http://pyvideo.org/category/12/pyohio-2011) for all the talks. My favorite is the Python on the Atari talk especially as the presenter (a.k.a. me) is particularly handsome.
ZeroMQ has in interesting design, but the philosophy behind the code is scary. I am a big fan of asserts, but only in the right context, and ZeroMQ definitely doesn't use them in the right context. Asserting that malloc succeeds is stupid in a library to say the least. Their idea is that software should fail early and often and any bug should be exposed via an assert firing. Great, but every program has bugs and could you image trying to use your computer with every program dying because of asserts? How about software in your settop box, do you really want the entire GUI to exit due to an assert because ZeroMQ running in a background thread was unhappy about the return value of epoll? (I saw such an assert failure on the mailing list in the last few months). 
this is why i always feed my programs strings containing “ẞ” as the very first test. (at least i used to until python3 came along and made this a non-issue)
Thanks. Seems like I'm going to have to continue without annotations. :(
Hold on, caks; I see possibilities beside resignation. There are in fact quite a few libraries that claim to embed annotations; I recommend you start with http://libharu.org and ReportLab. Will PyPDF2 ever acquire the ability to embed annotations? I doubt it--but I'm open to discussion.
He said he was open to more general topics.
Yeah, I chose (C) partially on that basis; so I wouldn't have to think about it. Everything seemed fine until someone objected :)
"What? NO, of COURSE I'm not on Reddit right now - I'm fixing your non-unicode aware Python 2 app so that it handles Japanese! OMG it's really, really tricky!" (click... fap... click... lolcat.... click... upvote... make a joke about "Step 3: Profit."...)
This is frighteningly accurate. I actually just looked behind me. EDIT: apart from the fapping; I don't work from home.
Answer, yes.
It shouldn't, and mostly doesn't. 
I am starting to hate the PyOhio organizers. I go to grad school in Columbus, and use python for a lot of my calculation codes. Every year they schedule PyOhio to conflict with a conference that I am required to attend. I just want to go once before I graduate.
ah yes of course, I forgot about that. Demoing with the wrong python version turns out to be even less of a good idea than I originally anticipated.
For completeness, here are the same things in Python 3.2: &gt;&gt;&gt; "hello" 'hello' &gt;&gt;&gt; type("hello") &lt;class 'str'&gt; &gt;&gt;&gt; b"hello" b'hello' &gt;&gt;&gt; type(b"hello") &lt;class 'bytes'&gt; 
2.7 "has a `bytes` type". `bytes` is an alias for `str` there.
It's not an article, it's a post on a mailing list. The intended audience isn't the casual reader, or even anyone who hadn't been following the conversation.
"4 days ago"
This Pytave looks very interesting. Thanks for the link.
btw, I just realised I made a mistake in title. *do
Well, I did not know about it. I will see if I can go!
To be honest, I've just never tried out Cython before. I will look into it and maybe modify Py2D to use Cython.
Google *DID* invest creating a faster implementation of Python. They started a project named "Unladen Swallow". Unfortunately, [it didn't pan out](http://qinsb.blogspot.com/2011/03/unladen-swallow-retrospective.html). But you can't complain that they didn't try, they just backed the wrong horse. (By the way, the linked article also speculates about why Unladen Swallow failed. I would like to add that *another* reason it failed was because PyPy was so surprisingly successful that it sucked away attention that might otherwise have been available for Unladen Swallow.)
That probably still works if something blindly guesses CP1252 and/or ISO-8859-1 et al; it is still a Western European character, after all. Try one of the truly crazy examples from the presentation.
saying "usually" is a bit misleading. what you mean is "it does unless you tell it not to".
I could help but you need to split the files into more modules to make team work feasible.
defnull, is there any connection with the Waitress project and Bottle?
That wouldn't work in ISO-8859-1, only ISO-8859-15.
[Differences between zope.server and Waitress](http://docs.pylonsproject.org/projects/waitress/en/latest/differences.html)
You are making two assumptions there. The first one being that Google will benefit from a faster Python implementation enough to actually matter, the second one being that throwing (unlimited amounts of) money at PyPy will be beneficial to the project. Google has been investing in PyPy for quite some time so we can expect that the first assumption is true, although I expect that you are overestimating the actual benefit. So the question is: Why aren't they investing more? They are investing in people and there are only so many people who actually have the necessary skill to improve PyPy in a way that matters. If you start increasing the amount of money you invest, you risk attracting people who are primarily interested in the money; you also risk that your money is taken for granted by those you are investing it in, thereby creating a dependency you don't want to have long term. PyPy makes a lot of progress, the project is very active and interest in the project is rising, especially with new features like 3.x support, numpy and STM. Their crowd funding efforts also seem to be on a good path so I suppose Google - just like me - doesn't see the need on spending more money on PyPy and spends it on other projects where it is actually necessary for the existence of the project, like self-driving cars which in the long term will make any benefit Google could gain from PyPy look like a joke.
Using Waitress with `wsgiref.simple_server` as its counterpart could be better a default web server of many web frameworks for development purpose.
google did invest in pypy see http://morepypy.blogspot.com/2012/01/py3k-and-numpy-first-stage-thanks-to.html google gave 35K$ for implementing python3 i hope they will support more subprojects of pypy once that finshed
&gt;*doh! FTFY
It will work with cp1252, but fail with iso-8859-1. But it's mainly just a test for code which blindly mixes bytes and unicode in Python 2, and will blow up on anything non-ascii. € is the most obviously non-ascii character on my keyboard.
Is there any reason I shouldn't use python 3? In the past there were libraries that still hadn't been updated. Is this still true?
I thought that maybe this was Ali G's reddit account. Booyakasha!
is this supposed to work with Apache, nginx? thanks.
A typical request only takes a few seconds, most of which is network latency. No faster implementation of Python will help you there.
You can start Waitress (or any other WSGI-HTTP Server) on a local port and use mod_proxy (or whatever your main-server offers) to proxy requests to the python server.
I'm not sure the intersection of Meters fans and Python fans/users is incredibly large. . . but now that pypy's gaining so much momentum, I thought someone might appreciate this. /not-serious-python-stuff-here
Google is working on reducing time spent in the network layer too. Do you think the cumulative time spent generating the response is totally insignificant for Google? Serving billions of requests? The reductio ad absurdum would be claiming it never matters how slow your application is. Google already demonstrated with Unladen Swallow that they do care about a faster Python.
I've been using the CherryPy server in several projects, but none of the rest of CherryPy. Fortunately that one was just a single file so it made life easy. Looks like we have a new contender ...
I don't care about Windows; is there any reason I should use this over gunicorn?
To clarify, although the order of objects seems arbitrary in dictionaries and sets^1, it is also unchanging; iterating over identical (dict|set)s always returns the same items in the same order. =^1 Actually, it's ordered on key hashes.
You realize that google has more than one product, that not all of their products are network bound, that not all of the software they write are products, and that not all of the software they write even necessarily touches the network...
What? Both are web servers for wsgi apps. How do you use them together?
Waitress is the love child of Pyramid and Zope, if you'll excuse the metaphor. Chris McDonough (the driving force behind Pyramid) created Waitress to be the default web server for the upcoming Pyramid 1.3, which introduces Python 3 support.
Probably not. Incidentally, does gunicorn support Python 3?
I agree in general with one specific issue. Licenses are not just like your opinion, man. They're functioning legal documents that control what can be done with your code (and potentially code that gets swept up with it). There are situations where you can use one that doesn't do what you want it to and in that situation the choice of license *is* objectively wrong.
Yes, but in accordance with Amdahl's law, there's a serious case of diminishing returns there.
You do know that Guido van Rossum (inventor of python) works for Google right?
Thanks, I'm going to bookmark the link, I'll need it! I'm going to friend you so I can remember to let you know about my experiences with them. I've been developing a (pretty crude) PDF reader, called notorius ([link to github](https://github.com/cako/notorius)), to annotate PDF files with LaTeX formulas. However, for saving the annotations, I have to opt saving the separately (I'm using XML). So basically, I can't annotate the LaTeX source text natively on the PDF. What I want it something like this: save an annotation with the LaTeX source, natively: if you have a reader that supports reading and rendering LaTeX (like mine!), you'll be able to see them rendered; in those readers that do not render (every reader so far), you'd only see the source. For this, I need a very very basic PDF annotation: I put the page, position, and text content of the annotation, and it generates a new PDF with the added content. But so far, no cigar.
Tcl/Tk, and thus Tkinter suffers from this bug. See http://bugs.python.org/issue12342
It would probably be very easy to do so. However, the only things that would really change in main UI is the scroll bar and the status bar. I don't see that ttk supports a Menu widget. The most benefit would come with the other IDLE dialogs, like the debugger, the configuration dialog, and anything under the help menu.
Well, c would be very small on the server-side (so not play much of a role) and very large from the clients perspective (so the other stuff wouldn't matter at all) So yeah, depends on from which direction you look at the problem. But diminishing returns can still be good returns, depending on how much you care about the thing you're optimizing.
There is gedit. It seems to work well with Python.
I'm not sure what that has to do with Google investing in PyPy.
Consider checking out [Nose](http://readthedocs.org/docs/nose/en/latest/) for your unit testing needs. This [documentation](http://readthedocs.org/docs/nose/en/latest/writing_tests.html#test-functions) will show you how to write setup and teardown functions for your tests as well.
Aww, it isn't done locally. Why can't this just use one of those Javascript-based interpreters?
If Guido's the BDFL, then Doug Hellman's the RPDU (Royal Prince of Documentation and Usability).
because Flask/werkzeug needs wsgi to run?
Does it support ssh? How does it compare with [Rocket](https://launchpad.net/rocket)?
It's pretty obvious that Google would benefit from faster Python, considering it's one of their four official languages in use. For example, Youtube is mostly written in Python.
The one thing I've never figured out is how to do something as simple as u"hello" to a string variable s = "hello" (using Python 2.6). Every single command I've tried ends up giving me either an error or something else. For example, u'å' gives me u'\xe5', but unichr(ord("å")) gives me u'\x86'.
Not really sure what the point of this is; I would be much more interested if the Python was running within the context of the DOM so I could write Python scripts that manipulate/scrape web pages.
well i've had the same desire as you did i found a few solutions, like using webview from gtk, but at the end i stayed with [Requests](http://docs.python-requests.org/en/v0.10.7/index.html) it's a very good library for web, no support to javascript but a good support for cookies, sessions and even [Asynchronous Requests](http://docs.python-requests.org/en/v0.10.7/user/advanced/#asynchronous-requests) Some features: &gt;International Domains and URLs &gt;Keep-Alive &amp; Connection Pooling &gt;Sessions with Cookie Persistence &gt;Browser-style SSL Verification &gt;Basic/Digest Authentication &gt;Elegant Key/Value Cookies &gt;Automatic Decompression &gt;Unicode Response Bodies &gt;Multipart File Uploads &gt;Connection Timeouts &gt;.netrc support And most important: good documentation! i've written quite a few webscrappers and my combo is: requests and [lxml](http://lxml.de/) (xpath support) 
OMG that just came from haven to me!!! I was needing something like this to a project i'm currently developing ( a "image" creator for geometric objects. You choose an object, a circle for example, you draw it and the system calculates it's are, equation, size,etc based on a few parameters) you're a lifesaver!!!!
When Django's Unicode-handling branch was under development, one of the test cases was [this page](http://www.omniglot.com/language/phrases/hovercraft.htm).
Because they don't own it, or its direction. Compare with Go, Unladen Swallow, GAE. $35k is a pittance for accelerating one of Google's core technologies, they would save multiples of that just ob hardware
Because they don't own it, or its direction. Compare with Go, Unladen Swallow, GAE where they're happy to slap resources on it because if it works out they own it. $35k is a pittance for accelerating one of Google's core technologies, they would save multiples of that just on hardware and time saved.
I don't like that it has a sex. I guess anyone that reads this comment will have a kneejerk reaction and downvote, but my honest reaction is that propagating sex/job stereotypes in software is just unnecessary with so many other name choices. EDIT: since I see some downvotes are starting to roll in, I would request that anyone who feels compelled to downvote please offer some explanation. My expectation is that the only justification anyone can give for disapproving of my statement is something along the lines of "don't be so serious", "it's not mean to be sexist", or "it doesn't make any difference." Which all seem like pretty weak justifications to me.
Aw, I hate things that make me feel dumb. (Spend a lot of time hatin') So I installed this thing into my browser and then... what? Wherzit? Howzit? Is there magic URL that makes it appear, like chrome://settings? what? Went back to the store link and poked around; nope; complete lack of docs. Welp, Window &gt; Extensions &gt; Delete.
It's a web server, not a web framework or library. Werkzeug inclues a web server, but it's single-threaded and meant for development only. Waitress is a high performance server for production use.
Flask is a web framework. It depends on Werkzeug. Werkzeug is a utility library for HTTP and WSGI that includes a web server for development purposes. Waitress is a high performance web server that serves WSGI apps. All three projects depend on WSGI.
I don't know, you tell me. Maybe Flask isn't a web server?
Do you mean SSL? From the linked page: &gt; Waitress does not natively support SSL
Although I think the intentions are in the right place, this thing could use some actual design. 
Mechanize does suck, it doesn't parse HTML very well. There are *many* pages on the web that it will not correctly parse because of this. But, fortunately it's simple enough to dig into it and insert the nodes you need (if you're dealing with say, forms).
I think hongminhee might mean like, use waitress instead of the built-in server that comes with your framework when you're testing non-production servers?
The standard library includes more than enough exception classes.
I was using [lettuce](http://packages.python.org/lettuce/tutorial/simple.html) to write some tests today. For a 'natural language' way of writing tests, the .feature files are very useful, as even a non-developer could write tests. It could do with some more reporting options, although it does mostly appear to be a straight port of [cucumber](http://cukes.info/) which is a good move.
Jacob, I just want to thank you for what I consider to be most sensible and rational upgrade policy of any web framework I know of. Upgradibg is painless between releases and Python upgrades. Honestly, it's one of the most important reasons I continue to use Python.
&gt;the second one being that throwing (unlimited amounts of) money at PyPy will be beneficial to the project. Hear hear. &gt;self-driving cars which in the long term will make any benefit Google could gain from PyPy look like a joke. Self-driving pypy-powered cars though... now those could go *really* fast.
The work that was done with Unladen Swallow has been significant for development on PyPy too, particularly things like the benchmarking suite and data collection methods.
Darn. I missed it. The open space wasn't well advertised this year.
PyQt bindings to webkit. Google "python headless webkit" https://github.com/AdamN/python-webkit2png/ http://stackoverflow.com/questions/6025082/headless-browser-for-python-javascript-support-required https://github.com/ariya/phantomjs
What about the other reasons? Could you tell us what makes Django your choice?
"Python 3.x will be supported soon", so no it doesn't.
Had installed it long back and tried running few of the scripts provided with it. But haven't used it for anything useful till now.
Tom Christiansen has written some very cool material on unicode usage in Perl: [talks](http://training.perl.com/OSCON2011/), [cookbook](http://training.perl.com/scripts/perlunicook.html).
Yes was able to authenticate send mail using smtplib. http://www.nixtutor.com/linux/send-mail-through-gmail-with-python/ But attachment is the problem. Is there a simpler module that handles it ?
The main problem is that you will only notice this on windows. On unix, everything will be fine, as the process if fork()ed, and therefore the module does not need to be imported again. This means there are a lot of bad tutorials out that that do work under unix, but that cause a forkbomb under windows...
I haven't used it, but the mailer module you linked to makes it trivial. How much simpler can it be? &gt;&gt;&gt; message = mailer.Message() &gt;&gt;&gt; message.attach('picture.jpg')
And the reasoning is?
I'm not sure it is simple, there is the email package in the std library: http://docs.python.org/library/email-examples.html
Thank you for the clarification.
Yes mailer is good. But any way to authenticate to Gmail and send ?
It "serves" something...
Yes. Read the documentation. I put a link to it in my earlier reply. I am now putting that same link to it in this reply, here is the link: http://ginstrom.com/code/mailerdocs/mailer.mailer.Mailer-class.html You need to connect to the correct host + port and then login. Exactly like with smtplib.
I submitted this [a few weeks ago](http://www.reddit.com/r/Python/comments/nl02f/help_with_a_pylaunchy_plugin_for_google_tasks/) asking for help with packaging a PyLaunchy plugin for distribution. I didn't get very much further than that, but I figured it might be of some interest to someone anyways. You can see the code for the command-line project that I allude to in the post [here](https://bitbucket.org/urbushey/cgtasker-dev/src) which isn't quite packaged for distribution or anything but feel free to poke around in there if you're interested in an example of interacting with the Google API without the Launchy/PyLaunchy overhead. Like I said, if there's any real interest in this outside of /r/Python I'll probably scrap the PyLaunchy direction and hack it out in C#, unless someone here has some more suggestions about making the PyLaunchy/GTasky install smoother. 
Make a subclass of Exception or EnvironmentError called InfiniteLoopPreconditionError (or something more fitting) and so you can catch that error specifically in order to display a meaningful error message to the user. The choice of base class is perhaps nit-picking, but I would say derive from Exception because even though the 'error' has to deal with the OS environment, it is not really an error so much as an accident/circumstance (or so it sounds from your post).
i couldn't agree more. its the kind of stuff that makes it worth using python.
The Python website [has a poll](http://python.org/3kpoll) about packages people want to support Python 3 support. Of the top entries, Django and matplotlib are already working on it. WxPython has an ambitious [next generation project](http://wiki.wxpython.org/ProjectPhoenix) which will probably be its route to Python 3 support. [This page](http://www.lfd.uci.edu/~gohlke/pythonlibs/#pil) appears to have Python 3 sources for PIL. Pick an interesting project and have a go!
SCNR ;) import bottle app = bottle.Bottle() @app.route('/') def index(): return 'Hello World' app.run(server='waitress') (works with 0.11.dev)
How about return [i/2 for i in nums unless i % 2] 
Thanks for the description, caks. One of us here at Phaseit thinks the annotation merging you describe might be feasible for inclusion in PyPDF2, and one is skeptical. Probably the best step is for you to research libharu a bit more, and report back, as you've already planned. You certainly have us thinking, in any case.
&gt; Features: &gt; * Python 2.5 online shell ??
Yes it does unless you mess with the sequence while looping through it. This is a common beginners' mistake. To avoid it make a copy of the list and loop through the original and modify the copy however you like it. Some old numeric algorithms (usually in Fortran, C, etc.) do this on purpose. If you have to deal with those I would recommend learning the difference between arrays and linked lists to understand what is really going on. 
It seems to be the Final Phone for me, built like a truck. Also there are lots of phones which are basically the same, but very much cheaper second-hand. Like 6730c. 
I used it to write a simple script that annoy my friend by call them and hangup, pretty fun to play around, it's great back to those day (with my old N78)
Like [skulpt](http://www.skulpt.org/)?
&gt; "whore", "working girl", "slut" Wow, the fact that this is even a topic of discussion in this thread suggests that there is a problem. Why did you even mention this? It's like justifying a racist situation by telling the person to be thankful that you didn't use a racial slur. &gt; You are what you are at the time of birth. And girls are waitresses?
At the time (0.97) it had the best and most complete tutorial and most features out of the box. I was new to web development and didn't want to have anything to do with PHP, and I was already somewhat familiar with Python.
Why do people choose Wordpress and Drupal instead of Django? I'm learning python and I would like to know if Django is a good substitute for other (more popular) CMSs.
Yes I saw that subreddit later. And I thought this subreddit is/should be about python and not about noobquestions on it.
Django is not a CMS, but rather a web-framework. A web-framework does a lot of the heavy lifting involved in writing web applications. These applications can be anything, such as a CMS. Something like Wordpress is a pure CMS with tools aimed at managing and publishing content. The answer to your question is: people would choose one if it fits their needs. Something like Ruby on Rails would be more of a direct alternative to Django.
Look at the builtin library ["email"](http://docs.python.org/library/email). It will help you split apart an rfc822 email into its constituent parts.
**Thanks.** But please consider that I'm still a noob therefor I won't reallly understand if you write it like that (I don't even know if py2exe is for the python I have as there was just one py2exe download available) I got **python 3.1** and now that I installed py2exe in the directory of c:\python31 I get this error: Traceback (most recent call last): File "setup.py", line 2, in &gt;module&gt; import py2exe File "C:\Python31\lib\site-packages\py2exe\__init__.py", line 67, in &gt;module&gt; import distutils.dist, distutils.core, distutils.command, build_exe, sys ImportError: No module named build_exe 
Alright. Well hopefully it appears! It sounds like a good talk :)
caks, I've sent you a PM introducing myself. As of now, I'm the main contributor to PyPDF2 and I'd like to hear your input about annotations as well.
Can anyone recommend a good Django-based CMS? Something very easy to set up, with good defaults, and opinionated? 
It depends on the intended use. For (simpler/standalone) scripts I almost never define new exceptions, unless there is a case where I do need to make a clear distinction. As [smallyolly](http://www.reddit.com/r/Python/comments/qvh6f/raising_exception_create_your_own_or_reuse_the/c40x1b1) named it, something like: class InfiniteLoopPreconditionError(EnvironmentError): pass makes the traceback more to the point, and IMO, the code easier to read. For a Software Testing framework I develop at work, that is composed of a set of libraries plus a test-case executor (Test-Cases are Python files, but their code reads a lot like a DSL), I make use of custom exceptions (a hierarchy of them actually), because I need to have a clear separation between Python's and mine's.
I would use a dictionary of sets of tuples, like so map = { 1: set(( (1,2), (2,3) )), 2: set(( (2,4) ))} You could replace the sets with lists if ordering and duplicates are important (sets are essentially dictionaries where the key and values are the same) you could add a new coordinate to the region with map[1].add( (3,4) ) and a new region with map[3] = set( (5,6) ) If you want to get fancy you can use collections.defaultdict and make a map where every key maps to an empty set by default. Depending on how you're manipulating the map it might make your code simpler since you won't have to special case adding a new region over adding a coordinate to an existing region. 
Guido has near to nothing to do with PyPy. You should check your facts before posting snide comments.
import email email.message_from_string(string) :)
&gt; Then I thought "hmmm, a different group would also consider it sexist if this were called 'Waiter' instead, since they used the male version of the word". Except that at no time in relevant history have waitstaff jobs been considered a male job. The opposite is not true. Combine that with the fact that, relatively, waitstaff are on the low end of the wage, prestige, etc. spectrum, and there's your problem. I agree with your general idea that attributing sex to programs that are named after jobs in our society is problematic, but in light of reality-based historical perspective, a feminine sex for a program named after a job that is 1) less prestigious and 2) historically attributed to females, is particularly problematic.
Django is supposed to be the most like rails, and is probably also the most widely used. The others each have certain advantages - the most obvious category are the 'micro frameworks', such as Flask or CherryPy, which focus on the web interface, and let you pick other components for things like databases. Some have particular specialities, such as Tornado, which is designed to handle many standing connections.
Really? Kind of tough to google that one.
I would say the framework of choice is the one that you learn to use. Don't get caught up on which is better there are a lot of good ones pick one and learn. Once you learn to program making the switch to another framework will be easy. Focus, Focus, Focus and learn it. Same with editors you grow to love the one you learn.
Pyramid is what you'll think of as the "standard" framework if you happen to have just come off a massive Zope or Plone bender. Nice tech and IMHO one of the friendliest communities around. It helps that it mostly inherited its community from Zope and Plone devs, who are lovely humans. Disclaimer: I do not know Django from a duck in the corner.
none
issackelly has mentioned [Mezzanine](http://pypi.python.org/pypi/Mezzanine/) somewhere else on this thread.
Thanks
Take a look at [Review Board](http://www.review-board.org)
wrap it in &lt;pre&gt; and &lt;/pre&gt; ?
Some others have mentioned Review Board. I will check it out. Thanks.
You've got choices, isn't this nice? Do an hello world type app on each or a few of them to see which one you like.
The latest stuff is not always what you should want. In this case, stick to 2.6 &lt;= version &lt; 3 Edit: fixed
I'm sorry, I totally forgot that PyPy is completely unrelated to Python in any way... It's great we have people working on a completely independent language that owes absolutely nothing to the time and effort of Guido, and by extension Google.
Honestly, the main one I've seen used is Django. Pyramid is a very close second. But mostly Django. Enjoy :)
WOT has given your site a bad safety level, so I made sure to submit that as a mistag. Keep up the great work!
Ummmmm [bobo](http://pypi.python.org/pypi/bobo/0.2.0) is the standard, every other framework just ripped off Jim Fulton. Most kids here don't know the history. /hipster 
Because the original question said "projects like PyPy" and I assumed having the father of the language working for them was relevant information. 
Never heard of it. Why the downvotes? Why is it a joke?
This was exactly the example I was going to post, except that I couldn't work out how to get a copy of the list from inside a subclass without hitting the recursion limit on `__iter__`. :)
If you're just getting into Python, use Django until you've got justifiable reasons to want something else. It's got great docs, big community, and is very easy for beginners. 
It´s an older framework that failed to gain wider traction back in the day. I had meant to be ironic, that´s all
This. 2.7 has all the libraries and most of the good stuff from 3 (remember to import it from __future__)
Best, worst, oldest, biggest, whatever. Django is the 'standard.' I was hired to write code for a Django app, and whether it 'standardness' has any relevance for you, I would seriously question. Do you have a real question that actually has an answer that will help solve some specific problem or concern? I love Django, despite it's eccentricities, and I still can't see a purpose to answering your question one way or another.
I can second this, sort of. In my day job, I do Pylons development. The Pylons dev's moved on to merge their project with repoze.bfg to make what both groups considered a better overally product. Both Pylons and Pyramid focus on letting you do as much or as little as you want with it. The one thing they *don't* do that a project like Django does is define how your model should work. Django comes with it's own ORM and, as others have suggested, is rather RoR like. Pylons and Pyramid on the other hand, though they frequently suggest SQLAlchemy (which is awesome, btw) they really leave it up to you. I've hooked MongoDB, Redis, and CouchDB up to it through my various experiments. In the end, Pylons and Pyramid both do a good job find the right balance in setting up a web application logically. That being said, I've also played with Tornado (great for asynchronous stuff) and web.py (dead simple). I think Pylons and Pyramid cover the ground better than both of those projects, but each one has its uses and merits.
Whatever it is that is out of the ordinary about your app, can probably be distilled down to a small sandbox type of example. All that most of these frameworks give you is a way of automating a certain amount of the cruft you were going to build anyhow. But yeah, two days spent building the toy version of your complex app once with each of the major frameworks will pay off. You'll learn about the frameworks, but more importantly you'll learn about your app.
No reason. It's a good one, particularly if you already know how to program and know web stuff, and the only new thing is python. (It may even be better if you want to explore the python ecosystem). A lot of this sort of discussion hinges around personal preferences rather than any solid technical reason.
&gt; What I object to is the implication that if something serves you, then it is female. Considering there is already packages named musicbutler and tvbutler in pypi (Disclaimer: I have no knowledge about them.) , I guess waitress is just evening out the ratio.
Yeah, it took me a few tries to get it right. Then I realized that if you want something to behave like the superclass at some point, use super :) Not a bad principle to go by in general.
I finished the "Advanced Security Topics" by Paul McMillan, which talks about timing attacks and the lack of security at PyPI (The Cheese Shop).
I don't understand the question. If you mix bytes and unicode at random, you get meaningless results.
py2exe does not support Python 3. Install Python 2.7 instead.
&gt;most of the good stuff Ehh, kinda. It has some of the good stuff, so it's a lot nicer than 2.6. It's no 3.3, imho.
There really is only one answer to this: **The one which fits the problem.** Django is great in some circumstances, Pyramid in others, and sometimes nothing will fit the problem you're working on so you'll have to roll your own. Trying to force Django to do something it's not meant to do will just cause you pain. Lots and lots and lots of pain, anguish, torment... all that first-testiment stuff. You wouldn't try to hit a nail into a wall with a bus. You wouldn't try and drive a banana to work.
Why did you pull out "Please don't call malloc" as an important quote? He even says it's not vital. The talk covered much more important aspects. Unless you enable a debug flag, you are effectively just calling through to malloc. 
Distilling it down to a little example requires that you know in advance how it's going to be out of the ordinary. Often, it's going to be something that develops as the project goes on. If you've got time, playing with maybe 3-5 frameworks could be useful experience. But trying to use 20 before deciding will take ages, and leave you as confused as when you started.
And knowing Python 2.7, it won't be that hard to move to Python 3 when you do want to (which you can probably do in a year or two).
Interesting. Although a very non-standard dictionary interface, and slower than the built-in `collections.OrderedDict`, so I don't see an advantage. Doesn't accept a sequence in the constructor: &gt;&gt;&gt; d = sdict.Dict((x, x) for x in range(5)) Exception AttributeError: "'Dict' object has no attribute '__tst__'" in ignored Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; TypeError: __init__() takes exactly 1 argument (2 given) Silently converts your keys to strings: &gt;&gt;&gt; d = sdict.Dict() &gt;&gt;&gt; d[0] = 0 &gt;&gt;&gt; d.keys() ['0000000000'] &gt;&gt;&gt; type(d.keys()[0]) &lt;type 'str'&gt; Buggy when iterating over the dictionary: &gt;&gt;&gt; d = sdict.Dict() &gt;&gt;&gt; for x in range(5): d[x] = x ... &gt;&gt;&gt; for k in d: print k, d[k] ... 0 0 1 1 2 2 3 3 4 4 None Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "/Users/david/.virtualenvs/reddit/lib/python2.7/site-packages/sdict/__init__.py", line 75, in __getitem__ return self.get(key) File "/Users/david/.virtualenvs/reddit/lib/python2.7/site-packages/sdict/__init__.py", line 26, in get raise Exception('invalid key: '+str(key)) Exception: invalid key: None And in testing is significantly slower than the built-in dictionary types (Python 2.7): Time to insert 1000 keys in a dictionary, 1000 runs dict 0.109964132309 OrderedDict 1.777821064 sdict.Dict 5.30201888084 https://gist.github.com/2043869
So I found putting this in /cgi-bin print 'hello world' was easiest. How do I get it to make a CRUD admin page for me?
srsly, one of my buddies once spent 11 minutes with the Wango Tango Framework before forming an opinion, and he got fucked forever (YMMV).
HTML parsing with regexps, even as an example, is a very VERY bad idea.
All I can say is. . . wow. If pypy's performance gets much better, then what does that mean for all the C/C++ critics? Also, what does that mean for CPython? If pypy keeps chugging away and they actually succeed in eliminating the GIL, then I could see easily envision a mass exodus away from CPython. Which means what for Guido? Would he still be the BDFL? Anyway, all speculation aside, it's awesome to see palpable results from all that hard work. It's actually quite inspiring. Rock on pypy!
&gt; I think he's actually nostalgic for the web of the old days, before the SEO arms race, and before a deluge of content spam from content farms made meaningful search a lot harder. I'm not sure about PG and even though the "web of old" was a nice place (if not somewhat smallish), the "Google of old" was very good at cutting through the SEO spam if you knew some basic tricks. With today's Google, when you happen to hit a corner of the web that's still successfully SEO spammed (in some way--different than it used to be) but it is not caught by Google's anti-SEO-spam algorithms, cutting through that crap is much, *much* harder because today's Google continuously tries to second-guess your queries to mean what it thinks you "really" mean--in other words, using a "trick" to cut out shit from your query not only works less well on cutting out the shit, but also distorts your real results because Google interprets it these days as if you asked it a real question, instead of some cleverly chosen keywords to obtain exactly those results that you're aiming for. And sometimes the crap that I want to cut out is not something that Google considers SEO-spam (nor would I expect it to do so btw). Real hard to cut out specific types of sites, without completely mangling the positive results. And that's not even counting the false positives on Google's anti-SEO-spam algorithms because we hardly ever get to see those. Since a couple of months it's really gotten bad enough for me that I switched to using DuckDuckGo a significant amount of the time. I tried switching search engines before but Google was always too quick and accurate for another to really "stick". No longer the case for me.
That's a really cool graph! Out of curiosity, is there any way to statistically check if this really is exponential growth rather than quadratic? :) Because thinking about the reasons why it would be one or the other, I'd assume for one package to convert depends on a number of fixed dependencies and some social pressure maybe, and that feels like it'd cause quadratic growth, no? Or maybe I'm wrong. Either way, exponential or quadratic, this graph tells me that Python3 is going to do just fine :)
`bread[:2].toast()`
I use Python 2.8 on a regular basis.
No problem, that was pretty much the only point of that post anyhows :)
And the children.
I would use the ever-loving crap out of it.