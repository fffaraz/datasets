I didn't know about the Python expressions thing. That's amazingly convenient!
It doesn't help that, IIRC, there's a module that achieves a similar objective to JSON string loading/unloading that uses dump/load where the json module uses dumps/loads.
Were you already learning 3.x?
&gt; - VIM ‚Äì A Bare Bone Python IDE That would be *text editor*...
But if it's not dynamically created you could just use an fstring. 
Awesome! Thanks for the recommendation :)
I've always wanted to see actual projects using it. Is it open source?
If you are routinely concatenating with `+` then you are definitely not in the majority. As for "commenting each datum", I have no idea how you expect that to work - even if it weren't ugly as sin to do so, Python doesn't let you embed comments in the middle of a line; and if you're putting comments on multiple previous or subsequent lines, the whitespace in the current line doesn't help.
Suppose, for example, it comes from a configuration file (e.g. for localization purposes)? Would you also count that as "dynamically created"?
Huh, how long have C# and JS had that? I haven't been paying attention....
!RemindMe 5 days
Looks great but I can't find the logs. Shouldn't they be somewhere under /var/log like normal? ^(Kidding of course! Merry Christmas!)
That's a good point, no I wouldn't. 
The blog is a little bit misleading. The .format member function is able to use different formats 'Hello {}'.format('world') 'Hello {who}'.format(who='world') 'The measured value is {val:{width}.{accuracy}f}.format(val=3.14,width=4, accuracy=2) the new f string is capable of doing the same thing and it's better readable. The compiler is able to optimize the f string better, so expect a better execution speed. Was is me really disappointing me, nobody seems to read the documentation and so are many blogs about the f string simply bad. Almost no one documented this feature of the format function on a regular basis and most blogs presented the format function with empty {} which requires a positional argument. 
That's exactly what I thought too. As convenient as this is, it's going to fuck me over when I'm trying to rename a variable and scanning all the non-strings.
well your concatenation sounds like quite enough of a readability and maintenance nightmare by itself!
Aw this is fun! Thanks for sharing :D
You're welcome. Merry Christmas :)
Thing is that I'm based in Germany. I know euro scipy has been in Erlangen this year (but this was before I even knew of python). And who knows where it's gonna be next year. Also maybe anconference isn't really the place to ask "what do I use for a montecarlo simulation" or stuff like that. But thanks for your advice nonetheless, I would love joining Euroscipy and becoming part of the network :3 it seems like a great opportunity
Thanks. Sorry about that.
Setting aside performance, what I like about f-strings is the huge gain in readability. I used format() prior to f-strings and I'm thankful to be able to rid myself of a set of parentheses.
Running python-modernize and 2to3 can help with a lot of simple Python porting issues. However, looking at https://github.com/Supervisor/supervisor/pull/471 , I don't think those tools will help much with this issue. This issue requires a developer to analyze the code and make some decisions about where to use unicode vs. bytes. That cannot be done by an automated script like python-modernize. The best presentation I have seen which gives some good strategies for dealing with unicode/bytes issues in Python code is this one by Ned Batchelder: http://nedbatchelder.com/text/unipain/unipain.html https://www.youtube.com/watch?v=sgHbC6udIqc Specifically, his mention of the "unicode sandwich". 
That... looks pretty bad? If you need comments for each "datum": variable1 = something # this is something! print(f"{variable1}") Your method has many disadvantages: 1. Hard to re-factor, trying to align comments after making changes is a bitch 2. What if that comment is not updated when the variable changes? I prefer to name variables very explicitly so less commenting is needed, because that's just another thing to maintain. 3. What if you need to format the variable in some way? Concat with `+` can't do this as easily. 4. Not pythonic! Most python folks would make you change this to one of the preferred python styles, hopefully everyone uses `f` strings in the next few years so we don't have `%` vs `.format` 5. Slower!
It's literally in the OP article that way.
If you do it like that, you just need `print(variable1)` avoiding `f` altogether, but I can't remember the last time I used `print()` in production code. These days I usually have to concat output into a REST response anyway, so it looks very normal.
... And you can do that just fine with the arguments to a `.format` call, too. Or for that matter, by *picking better variable names*.
&gt; If you do it like that, you just need print(variable1) avoiding f altogether, but I can't remember the last time I used print() in production code. These days I usually have to concat output into a REST response anyway, so it looks very normal. I'm not following, what does that have to do with the disadvantages I listed?
&gt; I guess having it be default it's one less pip install more convenient. I suppose you know that pip didn't used to be a default package and wasn't until Python 3.4/2.7.9 &gt; secrets could have been a popular 3rd party library It could have, but which one? We use PyCrpyto. I'm the only one at my company who can build our executables because for some reason it works on my computer, but not any others. It requires a C compiler, which not everybody has. &gt; How about building out Jython 3? Why not IronPython 2.7.7 or shoot 2.7.13 or IronPython 3? Because nobody cares about .Net. Shouldn't that be Microsoft's version to maintain? What about Shedskin or Brython or tinypy, etc.? What about varioues packages (e.g., numpy, scipy, django, bokeh, matplotlib, etc.)? It's not the job of the open source community to maintain anything or add features that you care about. It's their own desire to maintain whatever they want to maintain and you might as well be thankful for it. People add features that they find useful, not ones that you want. Projects (e.g., Jython) die and other things take their place. Besides, shouldn't Jython 3 be Sun's version to maintain? &gt; Are we gonna ever get rid of the GIL? No and it's not up for debate. Nobody is trying to do it in CPython. &gt; What about bringing PyPy up to the Python3 we were all so heartily encouraged to switch to? Not my project. &gt; Can we get some syntax for logic programming? So you complain about secrets, but want logic programming, which you can do anyways? &gt; The new f-formatted strings give yet another string formatting method to the language that should have only one way to do things. Why should there be one way? Is there one numerical computation library? The Python math library is far from ideal. Numpy is a lot better, but scipy has additional functionality and despite having the same names, the array/dot/solve/etc. methods are different between numpy and scipy. Is there one GUI library? We could all use Tkinter, but WxPython, PySide, PyQt4, PyQt5 are all better. There is not one plotting library either. Bokeh, PyQtGraph, and matplotlib are all options. &gt; "Tau" is a meme for science fans, not scientists Who cares? It took 2 seconds to add to the language and I promise you, was unpaid. &gt; The mission of the Python Software Foundation is to promote, protect, and **advance the Python programming language**, and to support and **facilitate the growth of a diverse and international community** of Python programmers. How does hosting Python conferences or teaching children programming or getting women speakers at conferences to encourage diversity not also accomplish that goal? There are many ways to promote python that do not involve changing the language, which the PSF does. You don't get to choose what the PSF's interpretation of their mission statement is.
&gt; Again, to each their own. I just go from experience with what causes the least number of questions when someone else takes over the code I wrote. Well everyone here is scratching their heads why you prefer this style, as no one else advises using it professionally! So I'd advise changing to what people generally agree is Pythonic, easy to maintain, and *pretty*! I'm wondering *why* you think this way, would love some counter-arguments to those disadvantages :) &gt; Yes it means redundancy of the variable names with their inline documentation, but that is an advantage when either alone is insufficient. Inline documentation, inside a print/concat, is almost always bad practice unless it's a slightly convoluted case. If it's more convoluted, just break it out into smaller chunks easier to understand but equal to the same string! There's almost no time to use `+` concat on strings in Python.
OP's submission history is strange, like, shit you find on the Internet strange...
Vim and Emacs. Depends on my mood. 
 &gt; When we look beyond our Python back yard over to the JavaScript folks, we see that they introduced a very similar feature called ‚Äútemplate strings‚Äù or ‚Äútemplate literals‚Äù as part of the ECMAScript 2015 standard. It‚Äôs good to see the JavaScript and Python community taking inspiration from each other. What's this supposed to mean?
Sounds like that question is more of a general python question, than Numpy specific. &gt; dataFileNames = [] &gt; fileDirectory = '/Users/new_programmer1889/Desktop/Data/' &gt; for f in os.listdir(fileDirectory): &gt; if f.endswith(".data") : &gt; dataFileNames.append(f) &gt; &gt; dataFileNames = sorted(dataFileNames) #if you wish to process them in alphabetical order, for some reason listdir picks random orderings. Now that you have a listing of all the files that you wish to read, for logFile in dataFileNames: logFile.read()# &lt;--- but make this your analyzation function
&gt; Note that the ‚Äúu‚Äù prefix was only necessary in Python 2 (‚ÄúLegacy Python‚Äù). Ahh, I like how they've explicitly mentioned that python 2 is legacy python. Like c'mon people upgrade to 3 already. 
I wrote [here](https://www.reddit.com/r/Python/comments/5ewu29/why_is_p_vs_np_important/dah3kg8/) on why I thought OP's previous submission was not good. This video seems to have the exact same issues. OP clearly has an understanding of how to use these libraries, but presents them at such a superficial level that this video targets high school or lower level. I personally think one should not spam every subreddit with one's content. I'm curious as to what the mods think about this practice or this type of content in particular.
&gt;That's exactly what I thought too. As convenient as this is, it's going to fuck me over when I'm trying to rename a variable and scanning all the non-strings. 
I actually quite like this. Python really likes messing with their strings. 
I just wrote a function to calculate first moment of area at any y-axis point for any n-polygon defined with its vertices. Sadly I didn't figure it out yet, how can i upgrade this code to calculate the same thing for any crosssection area with a HOLE in it. I'm an engineering student and this would be quite helpful for future projects.
That's really cool, what menuing system do you use for your menus?
The particular issue already has people commenting on it. Fork the project, incorporate the changes...Fix some stuff and send a pull request. 
Test cases I can definitely do.
Oh God, this is awesome! I loved string interpolation in Ruby -- one of the features I missed most. Very happy to see something similar in Python.
It's really not eval though. It would be eval if you could package up an f-string literal and run it somewhere else, but you can't. f-strings are just syntax. You could make the same argument that function calls are "just a dressed up eval".
I've used it in quick and dirty scripts, but not anything I'd expose an end user to. That said, eval and exec exist because some problems can only be solved by dynamically creating code. Not that I'd advocate it, but consider a custom module loader that reads from Redis. Not the most compelling example (though one suitable enough for Dave Beazley to use in a talk) 
True, but the fact that it will process arbitrary expressions as part of string interpolation is reminiscent of eval. You're right that to truly be eval, you'd need to be able to pack it up and execute it in a different context. For the record, I do think F-strings are neat and at worst don't do any harm to Python ecosystem. 
I take bills of all sorts, and divide it by the number of people in the house- come up with totals for each type of bill and add the total of money for all of the bills per person.
Ugh, Tau versus Pi is like the mathematical equivalent of the 2014-era Python 2 versus 3 flame war.
It makes sense for some things. I author a program which runs user-provided code in response to certain events. For performance (and some other) reasons, I don't want to spin up a new Python interpreter every time, so I don't just call their code as a new process with command line args - I keep a Python process running that `exec()`s their code every time the triggering event occurs (and I provide input args via setting certain module variables first that user code is expected to look at once its running). The user is totally responsible for their code - my program is running on their computer. It's really just a fancy code-running scheduler. They already had the power to run arbitrary code on their computer, so it's no biggie. One other obvious example is if you're writing an IDE - when you highlight a line and click something like a "run this line" button, the IDE is probably going to want to call `eval()` (possibly in a subprocess to protect the main program, even if it's catching exceptions). And other developer tools like that would probably have uses for `eval()`.
&gt; either of which even made it on the list... PyCharm is already in the list and indeed the best in the commercial space. VS code is also a good option but behaved intermittently during our tests and have a couple of limitations as well. Also, it is more inclined to JavaScript and Angular. And VIM and Eric have their own audience and very fast and reliable tools. We are running more tests on VS code on all latest versions of Win/Linux/Mac OS X, hope it would enlist among the top 10 in the next update.
Of course, we can use format, but this will be borring as format(value=value, ‚Ä¶). I think this should be as built-in function fstring(template). added: f"..." looks like shorhand, but have no "full" version. Perhaps I missed something, but it's pretty inconsistent that we have shorthand and can't exclude other formatting methods with f-strings.
You can bulk-apply fixers with "inspect project" (iirc, not at my computer), it'll run inspections on an entire scope then open a result pane similar to the refactoring or search ones, results should be grouped by fixer, and you can select any number of problem site and elk oychsrm to apply the fix. 
Haha the actual code that works out the message is only 2 lines. ~40 lines of just Morse code and Braille. 
Spacemacs
I use pushover for sending notifications from my computers to my phone. There are a couple of python clients for it. 
One thing that could make tau happen would be if scientific papers were in some kind of live format whereby the user could specify whether he wants to see tau or pi and the viewer renders the document accordingly. That would allow a new generation of tau-preferring people to see tau where an old generation of pi-preferring people wrote pi.
No doubt PyCharm is the winner but Cloud9/Ninja are worth a try.
Except Python isn't popular 'for machine learning'. A couple of Python libraries are. The language itself has nothing to do with it. The libraries aren't even written in Python.
When Python 3.6 dropped f-strings, legacy python2 users dropped f-bombs. üòÄ
You should be comparing it to `r"..."` - which produces an *ordinary string*, just by different rules *applied at compile-time*. You **can**, in fact write something like `x = f"..."` and then later do `x.format(...)`. Just that you would need the `f"..."` to produce something appropriate for the later call (which would likely involve doubling up a bunch of `{}`s to escape them). Or maybe I didn't understand you?
Use eval when you need something that absolutely, positively must be able to do *anything*.
That sounds very nice :) What are the specs on your server, i.e. how resource heavy services can you host? Do you do any sort of isolation for each service (quotas, one user per server, filesystem permission, selinux, virtual machines)?
SimulateMe! BaronPeanut
Thanks for this! I'm gonna be busy this holiday doing some coding. :D
Fuck no :)
Seems to do the same thing without the formatting. 
(that's html, not an editor or IDE)
You can't let production be perfect, can you?
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals there are plenty (far too many) ways to build ES6 into browser-ready code
im not sure. it's a rather odd sentence and not even really accurate. other languages have done this long before javascript
But docker should also restart processes (containers) if they fail. If you need an init process to reap zombies, look at tini or something similar.
Ah. Missed the multiplication inside the format. Super evil :P
BECAUSE OP'S A FILTHY MONSTER THAT'S WHY.
You likely want something based on lucene like solr or elasticsearch. the latter being the new cool kid on the block. there is a [python api](https://github.com/elastic/elasticsearch-py) for it that is py3 compatible. it's going to be more manual than you probably are anticipating but you are going to learn a lot. 
This is true. Source: am OP
Please. Please. Pleeease don't do shit like this. Crap like this is why people shit on Perl. Don't let Python devolve into this kind of crap. Code should be, above else, readable.
Is an empty string falsy in Python? 
I thought I could do it by doing sys.stderr = sys.stdout raise nonexistingerror but that required `import sys` :(
....i didn't offer any advice. only criticism. and the downvote was for promoting bad coding practices (preamble: this is about **inline** comments, not docblocks) seriously, if someone taught you comment like that, I'd question other things they taught you as well. it goes against the wisdom, standards, and best practices of essentially the entire software development industry. while technically it is a matter of opinion and taste, plenty of people have philosophized and expounded on why that sort of commenting is unproductive at best, counter-productive at worst, and symptomatic of other deeper problems. this isn't esoteric information either. it's readily available. generally put: &gt; identifiers should describe *what*. comments should explain *why* for example: a = 1 # line height line_height = 1 if you need to explain what your variables are there for, then you have poorly chosen variable names. descriptive names reduce line noise and (often) character count making it easier to read and maintain. not to mention, IDEs can't refactor comments very easily/reliably. And regarding the second part: if sys.version_info[:3] == (4, 6, 5): range = custom_range_function # workaround due to issue #6345 inline comments should also be used to explain non-obvious, counter-intuitive solutions. and also potentially what not to do or what has already been tried. But I can't think of a legitimate reason to need comments when formatting string. if you can provide an example of when it makes sense to do so, i'd love to hear it. 
Emacs + evil. Flycheck, jedi 
Merry Christmas to you too
PEP8, motherfucker.
Gotta disagree on that, friend. I use emacs with elpy, so I got all kind of autocompletes, magic import and snippets, while I can use the many shortcuts of emacs to go wherever I want rapidly and without taking my hands out of typing position. 
... and now I can sleep peacefully. I hate you OP.
Do you even golf?
Attempt using [MMap](http://pastebin.com/r9KYwkLa). This throws &gt;TypeError: can't use a string pattern on a bytes-like object 
Deincrement i before continuing the operation. Or minus negative i. Honestly not sure tbh
&gt; I can't think of a legitimate reason to need comments when formatting string. if you can provide an example of when it makes sense to do so, i'd love to hear it. When you know your code is going to be inherited by someone who is going to have to adapt the output and/or use it as input. Sometimes data require more documentation than a single well-chosen identifier. Does that go "against the wisdom, standards, and best practices of essentially the entire software development industry"? I've been programming for 35 years. I know what causes more work down the road and what doesn't.
You're working with bytes. You need to cast the bytes to a string first. Use the `str` function of Python. Example: `my_str = str(my_bytes)`
As you don't care what will be printed, then it can be super simple. Encoded as requested :) import base64 print(base64.standard_b64decode('QHByaW50CmNsYXNzIGE6cGFzcw==').decode())
Yeah, I [corrected the mistake](http://pastebin.com/UUQadC2t) by using b instead of r (raw) string. Still I am unable to find any matched group. Any idea?
https://en.wikipedia.org/wiki/Code_golf
Huh.. I don't know how this works. In [50]: 8+1**4 Out[50]: 9 In [51]: 8--1**4 Out[51]: 9 In [52]: (8--1**4) == (8+1**4) Out[52]: True In [53]: (8--1**4)%5 == (8+1**4)%5 Out[53]: True In [54]: 8--1**4%5 == 8+1**4%5 Out[54]: False In [55]: 8--1**4%5 Out[55]: 4 In [56]: 8+1**4%5 Out[56]: 9 Basically, it just seems that `--x` in this case is simply `- (-x)`, that is, a double negative. But the order of operations seems to be weird when using the `%` modulus operator? EDIT: Changing the original code to have `[i*i%3*4:(8+i**4)%5]` doesn't work though. So I'm all out of ideas.
or "job insecurity'
This simplifies all that string.template and String.format stuff, this is very nice.
Maybe he is a double agent for 1 of them
Youcompleteme has python autocompetion
Isn't it so that POST can modify but PUT only inserts?
Some of those py2-only "big" packages by now will likely have some py3 experimental branch somewhere. Check them out before you commit to py2, they might work well enough for your needs or they might need just a few tweaks. In some cases it's just maintainer inertia that stops these branches from being released.
i think it's ambiguous
Thank you! I recommend follow us in GitHub. We will update list and add more and more interesting projects.
Looks like I was wrong actually. PUT is create or update, post is merely create. Source: http://stackoverflow.com/questions/630453/put-vs-post-in-rest
Thank you for compiling! Already found a couple that look really interesting. Sidenote: how are new projects added? My lab works on a cool open source python project for designing work flows that can be run locally or at scale on cloud platforms without changes to source code. Should I PM the OP? 
Elizabeth looks fantastic. I'll have to start using it for my next project.
It is shorter without `not`: for i in range(1,101):print('Fizz'*(0==i%3)+'Buzz'*(0==i%5)or i)
Beautifulsoup or web scraping is the answer here. 
I am an avid Vim user also. Even though Vim does start faster, PyCharm's debugger and refactoring tools end up paying off the startup debt. There is a Vim plugin that I use in PyCharm, Intellij, etc so that I can use Vim style editing and it is pretty good about replicating almost every feature well.
So like an custom interactive shell?:p
Gotcha, when I asked the question this is what came to my mind. Custom import systems for plugins, running user written code, etc. I was more asking for a time when it would ever be used without the user knowing Python and being specifically asked for their code. However this project you have seems pretty cool. Is it web based or a standalone desktop program?
This might be better suited for r/learnpython or r/learnprogramming or possible Stack overflow
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Since your main request is setting up dependencies, I suggest you look at the websites and possibly subreddits for Postgresql and Rabbitmq etc 
I do the same thing, except I tar.gz it and use the gdrive command line tool 
Yeah, would like to see it! Where can we get it? 
F... Is also great :-)) wish i have similar command that does Ctrl-C on such voice command!)
Thank you! You can send us PR with your project.
I wanted to share my subreddit subscriptions with a friend (and I don't know how to export *all* of them quickly without a script): https://gist.githubusercontent.com/anonymous/c7eac4e0cb8d81142d27e4e0b7e79dcd/raw/219b0f0cc8d06c39fcddc932159bacf27a241a7d/reddit_export_subs.py It's not very clean, I spent maybe 10 minutes to create it. Requires Python 2.7 and mechanize.
Thank you. I didn't know of this before.
You can also replace "not i%3" with "1-i%3" and the same with bar for even more shortness. 
I personally only use double quotes for things the user can see, so I guess I could maybe justify it here?
No you can't, 2%3==2...
True, I posted it here since its a Python framework. I'm in the slow process of doing myself, I'll make a blog post to help others when I'm done.
My bad, you are right of course, 'str'*n is "" when n&lt;0... 
:D. Sorry, but not.
And what about PTVS, which has been around for a long time?
PGCLI JUST MADE THE LIST!
Just found out about pgcli and it looks amazing! Great project and I'm sure I'll love it!
Great read, thanks 
Elizabeth looks awesome! 
Trying to implement threading with a queue and worker system, into an already complex system. It's going really well and I'm finding it so easy, I just love spending weeks smashing my fucking head into the desk. Merry Christmas by the way! 
I'm still a beginner so I'm doing a basic dice rolling simulator. 
Using pygtk, which has been dead for half a decade, in 2016 for a new project... Wonder what even lead them there as nearly all docs are for pygobject.
Ah, at least its a small project, easy to modernize.
I've worked on a bunch of projects with varying dedication, but recently have been working on software to catalog things in your home, scraping from amazon, ikea, etc. Some sources have an API, others (like ikea) rely on html scraping which can be made really easy with the requests and the html parser, both part of the standard library. With both you just need to find out where the information is. One thing that really simplified things for me was getting comfortable with "full stack" and knowing on which side to do what, whether it be python on the back end or javascript on the front end. Creating an API first, and then a UI to take advantage of that api is a much more effective way of designing your app. For example, a "Rate Video" button makes an ajax POST to site.com/rate-movie with the movie id and chosen rating. (an example is here http://www.w3schools.com/xml/tryit.asp?filename=tryajax_first). APIs are the best way for your client side app and server side app to communicate. Once I figured that out things suddenly became much clearer to me. I started probably around 8 months ago or more, but a lot of that has been less, html, js (particularly react) which is probably a lot more than you need for your application.
omg, so true haha!
Sweet goddess. This made my life complete
*looks at python projects* No, not good enough for this. (They're mostly utilities I've made for EVE online)
This will be better suited for another subreddit, possibly r/learnpython , r/learnprogramming , r/raspberry_pi/
Setting up a basic implementation of [Delegative Democracy](https://en.wikipedia.org/wiki/Delegative_democracy) in Django. About equal parts knocking the rust off my Django skills and exploring an interesting voting system.
update: i tried again with Pyinstaller and this time, with a proper setup, i reached the goal. Now i want to try with a real complier for reduce the .exe dimension like nuitka 
Good list! I often need to generate large dummy data sets so, to me, Elizabeth is particularly interesting but the rest are awesome too. Found a few gems there!
sounds really interesting! would love to have a look!
OHH, sorry you meant tray/status icons not menu icons. Yes those are also deprecated but this has no effect on your application because you use AppIndicator anyway and not GtkStatusIcon and while it is deprecated it will work (On X11) until Gtk4.
Thanks for introducing me to cabot it indeed looks awesome!
Yeah, I've used the request module before. I tried to create a program that scanned the Dutch equivalent of ebay for Iphones, created a histogram of the price data to find both the cheaper outliers and the median sell price. Its still unfinished though, I found the 'finding out where the information is' part rather tricky. (With the rather confusing website sharing some of the blame) I will get back to it once I got some more experience. I've read about AJAX before, but the act of posting data to server through forms is still a bit mystifying to me (I use it in Django, but with a lot of copy / pasting from stackoverflow and IRC consultations). Once I've got the basics of Django down I'll look into it! (And Javascript as well, I would like to expand my projects with some interactivity) You seem to have made lots of progress these last 8 months. I've red about some of your projects before - they all seem very interesting! 
Look into get and post requests. Get is for getting information from your server, and post is for posting data to the server. Posting is more secure than getting. Here's how I started using it. I made a function like this: def rate_film(request): # the request object stores lots of fun info about the session (have a look at request.user!) if request.method == "POST": # make sure it is a secure post since we are saving to the db # request.id is the id variable in the post request, and request.rating is the rating variable r = Rating(film=request.id, rating=request.rating) # make a new rating object (from your models.py) r.save() # save the new rating, a built in function in every model object. The above (basic) bit of code is for sending a rating to the server. I then started using some software to create different requests ([postman](https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop/reviews) in my case) and made some requests to see what would happen. Make good ones, some bad ones. See where the flaws are. Trying failing and googling is often the best way to do things. But you need to remember that understanding why each line of code exists is extremely important. I started js copying and pasting too and I know how intimidating it can be. When your site goes live if you want to send me a link that would be cool! Good luck.
Hug does look very cool. Thanks for sharing
I used to recommend supporting both versions too, but with this approach it is not possible to take advantage of the new features in Python 3. On the upside, it is possible to target 100 % of packages in PyPI. 
Just because a language can read and write files does not make it general purpose. Just about every language can read and write files.
Theano looks really cool. Just started the tutorial.
Man I just saw this post on my phone and had to boot my laptop to check it. This looks **really** awesome. Congratulations. I'm researching Django to check if it is viable to a project, and Postgres is the most likely db to use. Your tool would/will help a lot. Do you know if there's an equivalent for SQLite?
That is exactly what I need right now! I've been developing a demo for the last month, practically done, but then my boss suddenly wants me to use a java framework by one of our partners. I now need to rewrite my application to serve as an api-endpoint for the new one, and `hug` seems like a godsend.
I think it's a bug. It's not possible to post something at the same time.
I like this. Some feedback on the panel (I am new to Bokeh): * Is it possible to increase the hovertool area? It's hard to track, especially around the Nyquist plot. * Allow magnitude to be set in dB. * Add a selection tool so that you can highlight one section and the same section in the other coordinate systems gets highlighted too. * Is there no way to avoid JS completely? It's recommended, but it's hard to write without experience. * Use better names (`nyquist_plot` instead of `n`, for example.) * I think there's a `hover_alpha` when drawing lines. Would that help? Maybe something can be given to `CustomJS`? edit: Saw [#9](https://github.com/ilayn/harold/issues/9). For me, it's still easier to read relative magnitudes with decibels. Even if it is not default, allowing it as an option would be useful.
It does look really great! Any chance there's built-in Django support like model-mommy?
Thanks for the fast feedback ! &gt; Is it possible to increase the hovertool area? It's hard to track, especially around the Nyquist plot. I'm also trying to find a fix for this. &gt; Allow magnitude to be set in dB. Not related to this of course and I'm totally sympathetic to users of dB but I'm really trying to drop dB usage. Currently the tick labels are not fixed but since dB only matters with a scalar of 20 from a log plot I'd like to stop using that unit. It is something that came out of Astrom and Murray's nice argument about deprecating dB. Of course no judgment on users who want to stick with dB, it's just that the default would be log10(x) and if they want they can switch to 20*log10(x) &gt; Is there no way to avoid JS completely? It's recommended, but it's hard to write without experience. Trust me I'm dreaming about this too. But Bokeh is actually the interface between Python code and the serialized JSON objects. They are trying to reduce the JS amount but still JS is necessary. I'm also very new to it and I can't say I liked any of it. &gt; Use better names (nyquist_plot instead of n, for example.) Sure, this is just a proof of concept. The final product won't have any of such code but will have `bode_interactive(G)` with the guts hidden away from the user. &gt; I think there's a hover_alpha when drawing lines. Would that help? Maybe something can be given to CustomJS? I'm not sure about it. If I don't play around with the customJS the curve alpha is constant. Whenever I have this show/hide stuff it becomes active. 
&gt; Deincrement i before continuing the operation Python does not have this operation
you can still say roll-off is -1 or -2 per decade since dB is just 20 times the log value. 
&gt; The fact that Python 3 isn't seen by developers as a clearly better alternative to Python 2 is the problem. Raymond Hettinger (a core developer) gave a talk saying exactly this. He now thinks Python 3.6 is better than 2.7 due to the improved dictionaries. https://www.youtube.com/watch?v=p33CVV29OG8 I maintain an 2.7.7+/3.3+ compatible open source package. The Python 2 support is a lot easier. I think I've hit every obscure Python 3 different. That lack of Python &lt;2.7.6 is also due to a quirk is the Python struct module as well as a quirk in six that just breaks trying to support anything more than that. It's really unfortunate that there's no killer feature of Python 3 (outside of being able to develop a unicode aware app in a sane way, but it's not actually better when running said app). MyPy is the closest there is, but the documentation on MyPy stub files isseverely lacking. It's also unfortunate that unicode documentation is so poor. It took me a month of fighting with it to figure it out.
Sweet. The most I ever did was some basic maths proving my point that multispecs are better against mixed fleets; I'll look through these when I'm not drinking/flying on a fleet. :D
I will be messaging you on [**2016-12-31 05:10:21 UTC**](http://www.wolframalpha.com/input/?i=2016-12-31 05:10:21 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/Python/comments/5k8ocx/awesome_o_the_really_big_list_of_really/dbmwgxu) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/Python/comments/5k8ocx/awesome_o_the_really_big_list_of_really/dbmwgxu]%0A%0ARemindMe! 5 days ) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! dbmwh5m) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
oh, damn!
I've heard **arrow** being mentioned a lot for datetimes. How does it compare with **maya** and **penduluam**?
To be clear, the CLI for installing Anaconda is beautifully small. It offers you the choice of install location and adding its location to `PATH` at install time. I can only see such a wrapper script being useful if you need to mass install Anaconda.
I find Vim+shell the best IDE I could have. To be true, most of the needed features can be quite easily implemented using basic tools, only debugging is a little problem, but I'm already working on it. While an IDE feels like learning to use a new piece of software.
It should drop a script in ~/.local/bin
Still not, but i work on similar project that will work with Django and Flask models. This project calls [**amberson**](https://github.com/lk-geimfari/amberson). I hope that i can work on it on xmas holidays.
Pastebin-search is a program I created to search through the top ten recent posts in a languages archive on Pastebin.com give you the ones that seem interesting based on keywords. It takes a command line argument of the language that you wan't to search through and goes into each link on its archive, searches for the key words using regex, and if it contains any of the key words, it prints it out to the terminal. You can also open up the link in your default web browser by typing "y" or "yes" in the command line when you see a link that interests you. The only library you need to install is BeautifulSoup4 which you can do by typing the following line in your terminal: pip install beautifulsoup4 I will be updating this code regularly so you can expect many changes in the near future. Some of the changes you can expect are: Updated search algorithm Logging mechanics Logging in and using your pro account(if you have one) to search 250 of the most recent posts Keeping track of last searched link so you never overlap the next time you use it Comments and pull requests are greatly appreciated, this is one of my first projects so I would love the feedback. 
&gt; which you can do No. You do it for us. Package your project.
You're looking for /r/learnpython
you rock, man!
This may just be me, but I would never rely on thruthiness in production code.
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
[Just when I was about to quit, I figured it out.](https://gist.github.com/anonymous/158d3805ca4aa47e7d3d7d0a4b784be8) 
Your "program" is incredibly disorganized. You've chucked everything into a class... and why? This isn't what classes are for. Your functions do 5,000 different things above and beyond what it says on the tin. getCode() parses, outputs, prompts and even spins up a browser. The flow of your program is difficult to follow just by reading the code. You're not writing a program here, you're just sticking code to other code until it does what you want it to. I'd suggest you review some fundamentals of programming (such as SOLID, cohesion and coupling) then go back over your project and re-organize it.
I haven't looked at the library yet but I'm pretty sure OP does mean a lot scale but without the 20x scalar factor. 
MY EYES OMG MY EYES! D: Grats, dude!
Not Lua :P Shit. Just now saw that auto correct destroyed my last comment. 
True
There are lots of (in my opinion) killer features in Python 3. (Well, maybe not killer features individually.) * Proper scoping of iteration variable in list comprehensions * Print function by default * No implicit relative import by default * No new/old style class distinction * Sane byte/Unicode string separation * UTF-8 source files by default * yield from syntax * async/await syntax * Parameter type hints * pathlib module * venv module (solves the odd problem caused by old versions of virtualenv) * Lots of API improvements in the standard library * subprocess.run() * Lots of iterators by default instead of lists: no more xrange, no more iteritems(), itervalues(), * No more long/int separation. * Clear division and floor separation (/ vs //) * Keyword only parameters (I have seen a lot of Python 2 code that hacks around this by rolling their own). * nonlocal keyword for assignment in closures Of course all of the new 3.6 features as well.
&gt; Don't blame developers and package maintainers for the blunders Python's roadmap over the past five years. Please list these blunders and why they are restricted to the last five years, as quite frankly the comment makes no sense to me at all.
Yes, precisely. Whole request/response parsing with minimal effort
Super cool solution!
You don't even need the function, just :- dis.dis('n--i**4%5') will suffice.
I guess some algorithm to promote this page got it wrong. 
&gt; There are lots of (in my opinion) killer features in Python 3. (Well, maybe not killer features individually.) That's what I mean - most projects aren't going to benefit from all of these things, and so the weight of all of them isn't felt.
This has literally nothing to do with flask logging than the fact that you use `app.logger`. It barely has any information regarding regular logging either. What crap. What even is the point of articles like this? To pad your resume?
Iteration support for pyyaml-based parser. Already done the function and class, now trying to figure out how to integrate it to the parsing routine (very neoPhYte).
No, I don't have a *better* way, because this is the right way. My problem is that this literally has no benefit over existing tutorials and just contributes to blogspam. In terms of logging, there are tons of great resources already [here](https://docs.python.org/2.6/library/logging.html) and [here](https://fangpenlin.com/posts/2012/08/26/good-logging-practice-in-python). Both these are comprehensive, but there are several shorter, more high-level, tutorials too. Theres no additional information wrt Flask, either. Nothing about what kind of errors *should* be logged from flask, or other useful things like adding the requesting IP/request url/any-other-request-information to the log, or how you can catch blanket-catch unknown exceptions using `@app.errorhandler` and add additional logging that can be used to debug later, etc.
Absolutely! :)
I have ADD, which, among other ways, expresses itself in a desire to keep doing what I'm doing (explanation in footnote [1]). I help myself leave work on time and go to bed on time with [hibernateat](https://bitbucket.org/sietsebb/dotfiles/src/default/bin/hibernateat?fileviewer=file-view-default). * It hibernates my computer at 17:30 and 23:00 * It gives me time to adjust to and accept the shutdown by making desktop notifications for half an hour leading up to it * if I close my laptop at 17:15 and reopen it at 19:00, the script realises the clock has changed and does not perform the hibernation that was queued when the laptop closed. [1] On the link between ADD (or ADHD) and the desire to keep doing what I'm doing: I have spent most of my life finding it hard to concentrate 'on command'. As a result, when I did find myself working on something (often due to hyperfocus) I really wouldn't want to quit, because Heaven knows when my next bout of productivity might be. When I wasn't productive, I *also* wouldn't want to quit, because I was still hoping for focus to arise. Some 20-30 years of this has left me with a lot of room for improvement when it comes to [task-switching](https://en.wikipedia.org/wiki/Task_switching_(psychology)). My concentration is better now, but the habit persists. I am told I am not alone in this.
I am glad that you liked the list.
I don't really understand the point about Lua. I have a Lua project that reads and writes to files without me doing anything weird, and just using the standard Lua 5.2 available on Ubuntu. I have to install an extra package to create directories, but this doesn't mean that Lua can't do such a thing, it means that it isn't included in the standard library. 
Nice, I'm going to check it out right away :)
Sublime Text 3, anyone? With Anaconda it's an amazing IDE.
Emacs sure, with evil-moe. There's much to configure: http://wikemacs.org/wiki/Python but a lot is in Elpy: https://elpy.readthedocs.io (running tests from it is great, for instance).
[Pyramid](http://docs.pylonsproject.org/en/latest/index.html) of course!
Thank you.
I've never encountered your library before, but it looks great. I'll introduce it into a project this week and see how things go! Thanks for posting.
The big question: can you jump to definition? 
I believe you submit to Community Workshop and then there's probably a way to put on store but idk
Python is interpreted...
Ah, as a pygame you would want to have python bundled in and yes exes I think
So is SQL-Alchemy.
I had never heard of pudb before. That looks really cool! I do use vim-jedi and when you use the vim plugin for PyCharm it basically just gets replaced with PyCharms auto complete. I think I'm going to check out that debugger though. Do you use the vim plugin to manage breakpoints?
Just use tox seems like the correct answer to me?
Only Icelandic names is funny :P
We finally decided to ditch Python 2 for mitmproxy and go strictly 3.5+ only. This wasn't an easy decision with lots of Linux distros still being on 3.4, but we're optimistic that it'll work out. :) We settled on providing PyInstaller binaries to make installation easy everywhere - that is still a bit painful (e.g. https://github.com/pyinstaller/pyinstaller/issues/1566), but ultimately works. We do a lot of low-level networking and our migration to Python 3 wasn't really straightforward, so happy to answer any questions regarding that!
So I am willling to wager that you shot yourself in the foot by manually whacking packages like that. Considering your state you might think about a clean reinstall at this point. 
Oh, pudb is amazing. No, I just stick `pu.db` wherever I want it to break in the code, but I don't tend to use debuggers that much (stack traces are usually enough). I mainly use it to step through code for very tricky situations where the stack trace isn't enough and I need to see how variables change. You can also set breakpoints inside the debugger, which is what I usually did in the 2-3 times I needed to.
Boah i love this so much!!
&gt; recipe collection, todo list, shopping lists For those tasks it is simple to get going, hence great.
Risk combat d6 victory probabilities including commander units, with bar scale style prints that show the probabilities next to each other with relative widths It came out well
You could try using the standard http handler as presneted [here](http://stackoverflow.com/questions/1907071/python-http-handler#1907633). I wish I could be more help, but I usually let Flask/Django's HttpRequest objects handle this for me. 
Something this basic may be better suited in r/learnpython 
r/learnpython might be a better place to look for help for getting your program packaged up
r/learnpython may be better suited for this, or the Debian forums
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
I don't think I can directly answer your question, and someone who is more experienced with Boost than I am can probably address this better, but I definitely think you should post this on StackOverflow for more visibility. Alternatively, I recommend checking out Cython, since it may make things a tad easier than Boost. They are pretty light on examples - their official page only links to [this](https://github.com/cython/cython/wiki/EmbeddingCython) simple example. However, you can find more information on their documentation page and also many examples online. 
A post about something as simple as using logging may be better suited in r/learnpython 
I like [sentdex](https://www.youtube.com/channel/UCfzlCWGWYyIQ0aLC5w48gBQ) video tutorials. He has some lessons about programming with images as i remember. 
This post may be better suited for r/learnpython 
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Do you earn your living writing fiction? To start with it was expected that it would take 10 years for Python 3 to take over the world so there's still two years to go. Decisions about Python development are **NOT** restricted to the BDFL and senior developers. Anybody can comment and if you (plural) have something sensible or new to add to the debate then you'll always be listened to. I have no interest in Python's runtime speed, programmer time is far more important to me. As for the "handful of features" that's plain nonsense, as is "breaking the ecosystem". The biggest change is the bytes vs string saga which most people welcome.
I've been playing with creating plugins with kodi - I must say it's quite a PITA to work with it, mainly because it's documented so very badly. But maybe I can help you. How exactly do you want to launch it and from where? Should it be a (reactive) lugin you can activate inside kodi? Or do you simply want to use kodi as a media player? Operating system?
Isn't this what gunicorn and uwsgi do? (I'm not familiar with the implementation details of those projects) 
neat
This might be better suited for r/learnpython or r/learnprogramming 
&gt;i tried to use : script1.py &amp; script2.py &amp; and try script1.py &amp;; script2.py &amp; untested, just guessing
If it is showing command not found, that suggests that the file does not exist in the working path. Does the first script change the path or something, so that the other scripts cannot be found? If that's the problem, you could put all your scripts into a bin directory somewhere, and then add that directory to your python_path. 
There are multiple options: You could write a service file for it and run it as a daemon. As far as I know Ubuntu uses systemd if your OS Version is relatively new. So the OS way would be to write a systemd Unit File for your script. Or you could use supervisord, which makes setting up daemons fairly easy if you want to do it right. Or you could do it the lazy way and run a Gnu Screen or Tmux session and run your scripts inside. If you disconnect, the session will stay active and when you reconnect later you can reattach. lookup Terminal-multiplexers and choose one of the two. These are your options. If you just want to run multiple scripts at the same time and don't want a consistent service use a terminal-multiplexer also ---&gt; read the sidebar and /r/learnpython
I don't really get the use case for `on` and `at`. The example makes no sense whatsoever either. Why wouldn't I just create the 1975 datetime directly instead of via "now"? It's like creating an apple and then printing it as an orange. 
https://github.com/matthiaskramm/corepy Doesn't appear to be up to date, though.
There's 1,001 excellent resources on Object Oriented Design and Object Orient Programming (OOD / OOP). Find one and dig into it, be it a book, a video or a website.
Use [pip tools](https://github.com/nvie/pip-tools/blob/master/README.md) and create a separate dev requirements file.
I love mitmproxy and I've used it professionally. Have you tested on Kali and the python version it ships with? Thanks! I'm a big fan of the move to 3.5+, just wanted to know how much replacing/environment setup I need to do in the future.
If my GTX770 can get very hot, so bring a hat if you slip whilst being sideways. ~/u/BaronPeanut ----------------------------------------------------------------------------------------- [*^^[Feedback]*](https://www.reddit.com/message/compose/?to=Simulate_Me_Bot) [*^^[Get ^^a ^^bot]*](https://www.reddit.com/message/compose/?to=iNeverQuiteWas) [*^^[Info]*](https://www.reddit.com/r/FreeKarma4You/comments/5b0r6r/i_am_a_bot_that_will_simulate_you/)
Fair enough Then why is weed illegal,its literally impossible to get jobs you would have otherwise excelled in. good luck nonetheless! ~/u/ninjabanana42069 ----------------------------------------------------------------------------------------- [*^^[Feedback]*](https://www.reddit.com/message/compose/?to=Simulate_Me_Bot) [*^^[Get ^^a ^^bot]*](https://www.reddit.com/message/compose/?to=iNeverQuiteWas) [*^^[Info]*](https://www.reddit.com/r/FreeKarma4You/comments/5b0r6r/i_am_a_bot_that_will_simulate_you/)
Yes this feature is available. 
How much money do you make ? Can you give us the channel name ?
Great news, thanks a lot.
Right. It took some time but I could finally come up with a use-case. When changing the date or time of a calendar event, this might come in handy. Anyway. Solid release! :)
Batch... So windows? And why does it have to be Kodi? Just checking, maybe there's an easier way to solve thus.
Use [kodijsonrpc](https://github.com/davgeo/kodijsonrpc) (Or just Requests, your call) to control Kodi with the [JSON-RPC API](http://kodi.wiki/view/JSON-RPC_API) [This user gives a very good example.](https://www.reddit.com/r/kodi/comments/3qitpv/help_with_json_http_command/cwfwvts/)
Sounds cool, I'll definitely give it a go.
Ubuntu 14.04 LTS was released in 2014, so there was no way for them to include 3.5.
Yes but 16.04 LTS is 3.5. Besides, it's very easy to compile any Python version on Linux.
Thank you! I've been wanting to use mitmproxy for some time now, but I've been holding off due to Python 3 incompatability
That's to remain compatible with timedelta. Period inherits from Interval which inherits from timedelta iirc. It's in the docs under "Properties and Duration Methods", I'm on mobile atm.
Error because of caps is frustrating. Thanks for taking your time to read it. Will add .lower() to it! 
I really like [pip-tools](https://github.com/nvie/pip-tools).
Check out the code for [3DSlicer](http://slicer.org). I don't actually remember whether they use boost or not (I think not) but it's a great example of an embedded python interpreter in a Qt C++ application. 
Thanks, at least it lives in some repository - even though it's abandoned 
I grudgingly respect this project because I was working on a proxy of my own, with some different ideas that I was left too little free-time to work on. I am glad to see it progressing like this, and it's not unlikely that I might use it in a future project. I'm tempted to complain, not about the adoption of Python 3, but about the adoption of asyncio for such a general-purpose tool, but I'll save that for another day. edit: A lot of people seem to be either misreading my post, or think it's cool to downvote things just because they disagree. For the record, I like mitmproxy. I also think asyncio has some great ideas, I just don't want to be forced to use it. I avoid projects based on Twisted for the same reason.
I used to be a professional perl coder. You could not pay me to go back to it. To be fair, it's partly the language, but more the community. The "There's More Than One Way To Do It" approach tends to lead to "write-only" code. You can manage that with good in-house style guides and code review, but moving between projects can be challenging. And although there are some excellent perl coders (Damian Conway, for example, who not coincidentally wrote one of the best style guides), the community has a tendency towards smug "cleverness". Hell is other people's perl.
I've never used Perl for new projects, but I've worked on some existing ones, and I've realised I really really don't like Perl. I can see how it can be more expressive, but I feel like it has the C++/Scala problem where the core language is so big, people pick a subset of it for their own code, and those subsets don't always match, so you end up with code written using a bunch of different language features to do the same thing, and you have to know all of those subsets or you won't be able to work on the project. I also really dislike sigils and obscure syntax, which Perl seems to consider idiomatic, especially around regex support.
These look like quite nefarious scripts, OP. For cracking Captchas and brute forcing passwords. I still think they're interesting though, don't get me wrong. Where'd you find 'em? 
IMO, it means transition path to 3.x was handled poorly.
I think I can guess why this is such a sensitive topic. 13% upvoted after 45 minutes!
Wait, does the or operator not just return a boolean value?
To be honest, I think the wording of the question is very poor, confusing, and not conducive to a productive conversation. Your two points as I understand them: 1) Python 2.7 was stable, and some people prefer to use it. That those people seemingly outnumber those who have adopted python 3.x to date is proof of the generalization that Once a tool gets good enough, reliability is seen as far more important than improvement." I think it's a vague and confusing generalization. What kind of tool? How are we measuring "good enough"? Good enough at what? And what kinds of "improvements" are being passed up in the name of stability? What about improvements *to* stability? It is just so pointless to ask that particular question in that particular way. I don't agree, because it simply isn't clear enough. 2) The "resulting compatibility libraries"-- I asume you mean libraries that port python 3 features to python 2... or maybe you mean the libraries that help with making 2/3 compatible code... mean that the combined work of many people over the past 8 years "don't amoun to much." I don't agree with that. Python 3 has been meaningfully improved and contributed to consistently, and that work has real value. It may or may not be sufficiently valuable in a particular context to make someone who is already vested in python 2 to switch, but to say it "doesn't amount to much"--particularly for the very vague stated reasons--is unproductive to say the least. Python 2.7 good, python 3.x bad. Maybe. I don't know. People debate it a lot. The transition was handled poorly. Maybe. I don't know. People debate it. People debate it a lot. If you want to use 2.7, no one stops you. The good people who made both versions have decided for themselves, they are not going to keep maintaining 2.7. They are entitled to that decision, so now everyone must decide for themselves how they wish to proceed. My two cents is that regardless of how you feel, it's best for everyone if you move forward with life; accept the status quo; and if you feel strongly opinionated about the development direction of the language, become a core contributor and help to guide it into the future.
I like to do it like this: https://github.com/TriOptima/tri.declarative/blob/master/tox.ini
As someone new to python, what's wrong with that?
Why do you need P, Obj, and Rec? Couldn't you just have one thing?
What are the differences to the original [activestate recipe](http://code.activestate.com/recipes/576918/) from 2009? 
Can anyone explain a scenario where one would use it. 
I really liked the approach of 'hello webapp' , where instead of rebuilding someone else's project you get instructions to build a generic "thing" that serves as a template for your own project 
&gt;Really? Despite Python versions 3.0 -&gt; 3.3 offering nothing compelling compared to 2.7 we responsible developers were regularly abused and cast as troglodytes for not immediately porting our code to 3.X. Since then nothing much has changed. Every 3.X release is called the "killer release that makes 2.7 obsolete" yet here we are, with the majority of code still running on 2.7 That's because those evil developers tried to ease transition. Every single 2.7 feature was backported from python 3.0-3.3 that's why you didn't see any compelling reason to move. New compelling reasons to move to 3 started supposing after back porting stopped. &gt;That 3.X is still slower than 2.7 and offers only a handful of features which justify breaking the ecosystem is borderline unforgivable. That was true, but not anymore. Right now python 3 is faster and in fact it is better in every way according to [Raymond Hettinger](https://youtu.be/p33CVV29OG8), one of core developers who for long time preferred python 2 until python 3.6. If you don't want to watch the talk (quite interesting) there is discussion about it in Q&amp;A at the end (around 57.5 minutes in) Edit: I was convinced that speed was discussed in the above talk, but looks like I've seen it being discussed [here](https://youtu.be/hk85RUtQsBI).
I met Python 15 years ago, learned the basics in about 1 week, and during that week I wiped Perl from my brain. I was shocked how I could do **anything** I used to do with Perl in 1/10 of the time even considering that, back then, I was way more expert in Perl than Python. Perl surely changed meanwhile, likely getting better, I even saw a Perl source very terse and readable (only once, unfortunately). I believe there are some rare use cases in which Perl could be more suitable but, for me, there's no way to go back.
Only when I have to fix something in an existing perl script that I don't have the time to reimplement in another language.
Uhh. This is wrong on a lot of levels. Are you reading from memory or from a file? Or a memory-mapped file? Is memory access really the bottleneck for you (it usually isn't)? What do you even mean by "grab 4 bytes in 1 CPU cycle"? From disk? From RAM? Grab to _where_? Edit: looking at your comment history, you missed the point entirely. The reference .NET source code does not "read one byte at a time" or anything like that. Also, buffering makes this largely a non-issue.
Usually for reversing the API of web applications or apps. Say you want to try to find a bug in the Uber app, to get a piece of their bug bounty. You install a certificate on your phone, fire up mitmproxy on your desktop and set the proxy on your phone to point at your desktop. Now the traffic will go trough the mitmproxy, where you can inspect (and alter) the apps http requests. Mitmproxy also has wonderful scripting options, so you could for example change the useragent for all outbound requests and so on.
Understood. Link please?
Like this: f = open('C:/Users/user/Desktop/somefile.log', 'rb') data = f.read(4)
Are you going to delete this post? Just give me like 30 minutes.
I'm pretty sure you don't understand what's going on here. Reading from disk is _never_ a single CPU instruction, ever. There's the disk cache, there's buffering, there's the syscall overhead, there's a lot of things. What's your final goal with this?
No shit I don't know what is going on. That should be clear from the way I'm asking it. I'll ask somewhere else. Fuck you.
Cool. Think I can find a use for that! And I guess you can use any certificate on the mitmproxy side.
Man. I'm just so tired of beating my stupid head against a wall all day trying to figure things out and then coming to people for help on things I obviously don't understand and then getting attitude from them. It isn't necessary for you to spend any effort trying to make it quite clear to me that I don't understand something. That much was obvious. And if you don't think you gave me attitude, just go read your responses where you looked down your nose at me while adjusting your glasses. I get it. You're superior. Don't be a dick to people.
I apologize if it came off as that. I just feel like you're very confused right now, and you're in _way_ over your head, which is why I'm trying to understand what your end goal is so I can guide you towards that without making you read half an operating systems course to understand how disk reads work which isn't something you really need to know in detail unless you're writing operating systems. Edit: What I can tell you right now is that you're extremely likely asking the wrong questions. Your bad performance, which I assume is the issue, likely has very little to do with how you're doing your disk reads and a lot to do with the actual processing you're doing or your hardware (specifically, your hard disk). If you explain what you actually want to do/are doing, it'll be much easier to figure out where the problem _really_ is.
and that‚Äôs only a implementation limitation (they tokenise using string tokenisation machinery, and then are post-processed in the interpreter). check out my pep: https://github.com/python/peps/blob/master/pep-0536.txt
I may be overly-sensitive about my weaknesses when it comes to programming. I can do what I want but when it comes to the actual guts under the code, I don't have a clue. I always want to get from point A to point B but end up having to go on a quest to Mordor when it comes to actual architecture. I can definitely explain what I'm wanting though if I can apologize and we can forget about my tantrum. If so, please see below: I am trying to scan files up to 500 MB for duplicate 4 byte sequences. So I'll grab the first 4 bytes of the file into a variable and then scan through the file (starting at the bytes after the 4 grabbed). I'll compare bytes [00, 01, 02, 03] to bytes [04, 05, 06, 07] and then [05, 06, 07, 08] and so on through the file. Then I'll compare bytes [01, 02, 03, 04] to bytes [05, 06, 07, 08] and so on to the end of the file. This is to find out where in the file any sequence of 4 bytes is duplicated (there is a reason for this but that is besides the point). In C#, I would do this by using .ReadInt32() because I thought that it would somehow magically grab 4 bytes from the memory stream. But then I found out that the .ReadInt32() function wasn't actually doing what my ignorant brain thought it was doing. [edit: the file has already been read into a memory stream and not actually reading from disk every time] I was thinking that you could somehow pluck 4 bytes from a stream and then "stamp" those 4 bytes into a integer variable at once (in 1 cpu cycle) instead of 1 at a time (4 cpu cycles). At least this is how my un-informed mind interprets what is going on: less cpu cycles = less time to process the whole file. This is why I was looking at Python today. I was hoping it had a read function that could pluck 4 bytes from memory at once (for comparisons) but I have found that I am seeing the same processing times as C# which leads me to believe this is just the way bytes are read. So I'm here hoping somebody knows something I don't -- which is very likely. 
What's your reasoning against asyncio? There's no asyncio code in mitmproxy yet. We are planning to rewrite our proxy core in a [sans-io](https://sans-io.readthedocs.io/) style (here's a partial discussion of this: https://github.com/mitmproxy/mitmproxy/issues/1775) which may will probably be powered by asyncio, but we're not rolling it out across the entire codebase.
Your understanding of this is really off here. Disk reads aren't measured in CPU cycles - every single read is hundreds of instructions. When you call `read`, be it in C# or Python, your program makes a system call to your OS first, asking it to read this many bytes from the stream. Both Python's `read(4)` and C#'s `ReadInt32` will, in fact, request 4 bytes from the OS. The OS will then talk to the file system to figure out where the file is actually located, and how it's fragmented, and then make a request to the hard disk controller to read the data. However, the controller won't read 4 bytes - it'll read at least an entire block (512 bytes), and usually more - at least 4 or 8 kilobytes, and buffer that in memory somewhere. It might also attempt to read ahead, expecting you to keep reading the file, and buffer more than 4 kilobytes. The OS can also do buffering and readahead on its own, inside your normal RAM, not on the HDD controller. The next reads you perform will be from one of those buffers, not from the disk, as long as there is data in the buffers. This is a lot of stuff happening for a simple disk read, and it's going to cost you a lot more time than actually shuffling the bytes around (which is really fast). I'm still skipping some things here, like the hard drive having to move the head to the right location and then wait for it to read the right spot on the spinning plate (assuming it's an HDD), and so on, and then the data having to go back from the drive through the controller to the OS and finally to your program. Basically, the performance of small reads (on the scale of kilobytes) depends very little on the actual bit-shuffling and a lot on all of those other things. So, as I said in the other thread, to go fast, you want to read the file in large chunks and operate on those chunks in memory, ideally in a concurrent way, so that the next read gets queued up while you're still processing the previous chunk.
Sorry, I forgot to mention that the I was reading the whole file into a BinaryReader which is a memory stream so the .ReadInt32() function should be reading bytes from memory, correct? If so, would that be the same for Python's read(4) if it is reading from a variable that has already done the disk read job? f = open('C:/Users/user/Desktop/somefile.log', 'rb') data = f.read(4) If reading from memory like this, the disk operations have already concluded, right? edit: ah ha. I see the other thread now. Sorry.
Giving 15 years and 100 of tools to help people migrate is not my definition of "poorly". It's actually the best transition effort I've seen in computing. The reaction of the community however, I've been the worst I've seen in computing: the JS and ruby community typically have 2 years notice with not even a "sorry" and deal with it.
`BinaryReader` has its own internal buffer, but it doesn't read the whole file into memory, and it only fills the buffer with exactly however many bytes needed to read the value (so `ReadInt32` will read 4 bytes). This is not good because it only reads 4 bytes at a time, so you're spending a lot of time poking the OS and waiting for a response. Python's `open` works the same - no disk reads occur until you call `read`, and then there may or may not be some internal buffering, but it also won't buffer the whole file in memory. If your files really are 500MB, the easiest thing you can do is just read the whole thing into RAM first (with `ReadAllBytes` in C# or just `read()` with no parameters in Python), and then do your checking entirely in-memory. Also, you don't actually need to reinterpret the bytes you read as 32-bit integers - you know an int32 is 4 bytes, so you can just compare sequences of 4 bytes without caring about what they mean, saving you some precious time on the (admittedly cheap) conversion, or at least allowing you to convert only the things that you care about. Also, if you care about performance, C# would be the language to use here (or Python with PyPy) - the JIT compiler should be able to optimize your checking loop into something really fast.
[Image](http://imgs.xkcd.com/comics/python.png) [Mobile](https://m.xkcd.com/353/) **Title:** Python **Title-text:** I wrote 20 short programs in Python yesterday\. It was wonderful\. Perl, I'm leaving you\. [Comic Explanation](https://www.explainxkcd.com/wiki/index.php/353#Explanation) **Stats:** This comic has been referenced 314 times, representing 0.2219% of referenced xkcds. --- ^[xkcd.com](https://www.xkcd.com) ^| ^[xkcd sub](https://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](https://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_dboag26)
https://github.com/lk-geimfari/elizabeth#a-common-use
Heh Kenneth Reitz just released another date time library. 
You can translate a lot of what he does into python fairly easily. Processing which he uses a lot has a Python option so you can often almost directly convert code with a few changes using that. I don't like the Processing IDE though so I've been taking some of his stuff and using it with Kivy in pycham.
Another update: I've generated a bunch of test data that occasionally contains duplicate 4-byte sequences, and wrote a very simple piece of code to detect them: data = open("randomness-2", "rb").read() end = len(data) offset = 0 while offset + 8 &lt;= end: if data[offset:offset + 4] == data[offset + 4:offset + 8]: print("hit!", offset) offset += 4 This runs in just under two seconds for me with PyPy on a 501MB file. I'm now going to write the same code in Rust just to see how fast it can possibly go.
* Tons of tests * Python 3 support * Available on PyPI * etc
Oh my flipping freak. I thought I was reading the whole thing into memory already. Holy flip I'm going to have to try this. Woo hoo!
Final update (probably): the Rust version of the same code runs in under a second, and compiles down to 32-bit instructions entirely (which I didn't expect LLVM to optimize at all, but it did!). #![feature(step_by)] use std::io::prelude::*; use std::fs::File; fn main() { let mut f = File::open("randomness-2").unwrap(); let mut buffer = Vec::new(); f.read_to_end(&amp;mut buffer).unwrap(); for offset in (0..buffer.len() - 8).step_by(4) { if buffer[offset..offset + 4] == buffer[offset + 4..offset + 8] { println!("hit! {}", offset); } } }
used perl in an otherwise python project for parsing log files because of its regex speed. that was about 6 years ago. alternatives might exist today.
No.
I feel what you describe also perfectly fits the situation for R, at least in the (academic) context that I use it in, trying to use the work of other people. It seems to me nearly nobody uses R to be communicative with their code.
I have several languages on my toolbelt and my hand always reaches for `perl` whenever there's a need for one-off one-liner for text processing, most times including regex matching. The efficiency of `perl` in these scenarios can't be matched. Otherwise, no.
Skrub hjem til dit venstrfl√∏jsuniversitet med det der privilegie-pis! Jeg har ogs√• engelsk som andetsprog, men jeg kan alligevel godt finde ud af at udtrykke mig s√• forst√•eligt, at jeg ikke har brug for den elendige undskyldning!
This is good, I think I will use it as the first example. They probably already have all the means to understand why it's wrong but it will help to enter the right mindset.
No. But I do sometimes miss `f() while k()` comprehensions when I use itertools.
I'm the opposite. I think having special syntax for regex is dumb, and escaping slashes is dumb because you should choose your regex quoter. re.sub("fo'o", 'fo"o', foo) sed -e s,foo,bar, It's not Perl's syntax I like. It's the density of regex operations I like. Sed's is okay-ish, with extended on. 
I use a simple shell script: #!/bin/sh pip freeze -l | awk -F '==' '{ print $1 }' | xargs pip install -U but obviously it won‚Äôt work on Windows.
Yes! In its first version the main class was called Applicative. The current version has internally also deals with functionally with state for the Read and Write expressions.
Demonstrate the confusing behaviour of mutable default arguments. &gt;&gt;&gt; def add_to_list(elem, lst=[]): ... lst.append(elem) ... return lst &gt;&gt;&gt; lst1 = [1,2,3] &gt;&gt;&gt; print(add_to_list(4, lst1)) [1, 2, 3, 4] &gt;&gt;&gt; print(add_to_list(5, lst1)) [1, 2, 3, 4, 5] &gt;&gt;&gt; print(add_to_list(1)) [1] &gt;&gt;&gt; print(add_to_list(2)) [1, 2] &gt;&gt;&gt; print(add_to_list(3)) [1, 2, 3]
Love the idea. Might actually implement it. The post-fix issue is unavoidable so I actually embrace it in the code visually by writing code like this assert [70, 30] == Pipe( 3, P * 10, Write('s'), #s = 3 * 10 == 30 P + 5, #30 + 5 == 35 List( P * 2 # 35 * 2 == 70 , Read('s') #s == 30 ) ) where `Write` explicitly looks like a post-fix statement. 
The thing is that you can actually also write it like this using field access assert [70, 30] == Pipe( 3, P * 10, Write.s, #s = 3 * 10 == 30 P + 5, #30 + 5 == 35 List( P * 2 # 35 * 2 == 70 , Read.s #s == 30 ) ) which looks really nice for `Read` but even weirder for `Write`. Your solution might make the situation more understandable. I'd even consider removing the `Write.s` mechanism.
If you were to use &gt; Write(s=P*10) it wouldnt have to be postfix though? You can just use the value of the s parameter as the lambda to run before the write. The order of evaluation is kinda postfixy but the grammar can read naturally.
I am migrating an app to use angular as frontend in django. I am making the restful api for all the models. I will use Rest-Framework. And migrating another app from django 1.6 to django 1.10
I am more than 50% sure your proposed semantic would be better.
I've had a chance to try out your package, and it seems to work well! I'm going to play around with it some more, and I'll leave any other feedback in github issues. The biggest things I want to try to do are a) reduce the boilerplate for for running a single test (i.e. get it down from two lines of code to one) and b) generate smaller output (say, one or two lines of text) from test runs. (a) might be possible through an ipython magic that uses your package. (b) might be possible using the `pytest_options` argument that you already support. In any event, thanks for work on this!
Why timeout is in milliseconds? Floating point seconds are everywhere in python.
Upgrading an entire OS or the version of Python on a production system isn't always an easy thing in the real world.
why is this dirty?, should it simply be a for loop instead?
Hells no-- run away from that crap
You're bitter because you had the idea to do something then didn't but someone else did? Wut?
&gt; "write-only" code what's that ? meaning unreadable ?
That's janky code.
Well, hello, me! I wrote lots of Perl at work, then wanted to learn enough Python to script up that new Zope thing. Within a week, I had stopped writing any new Perl code and had switched entirely to Python for new projects.
Yes, but only because I have to hack research software which ships with build systems which were "modernized" by writing them in dense, obfuscated Perl. I'll drop in replacements or supplement them just in Perl just to keep the system consistent.
The Java examples from the first few chapters of Clean Code (book) ported to Python would work very well. They're extremely enlightening to some best practices. 
Regarding JS, a few comments: * Depending on what you are doing, it might be possible to avoid `CustomJS` callbacks in favor or real python callbacks by using the Bokeh server. You can see some example Bokeh apps running here: https://demo.bokehplots.com We are also currently working on integrating Bokeh apps and the Notebook better, there should be some preliminary guidance in the upcoming 0.12.4 release. * Even without using the Bokeh server, depending on what you are are doing, it might be possible to "transpile" python code into JS automatically if you install Flexx. See these docs: http://bokeh.pydata.org/en/latest/docs/user_guide/interaction/callbacks.html#customjs-with-a-python-function In general, the availability of CustomJS callbacks is somewhat of a compromise, that reflects the limited human resources of the core team, and the desire to not let the size of the library size spiral out of control to un-maintainability. It's a relief valve, to afford users a path to sophisticated capabilities that may be too narrowly defined to warrant inclusion in the core library. The ability to extend Bokeh with custom extensions is also intended along these lines, but it is my hope that we can soon develop a robust mechanism for discovering and sharing extensions, so that their value can be magnified across the entire community (and so that only a few people have to do the work to write them).
Anything that creates a circular reference: &gt;&gt;&gt; a = [] &gt;&gt;&gt; a.append(a) &gt;&gt;&gt; a [[...]] &gt;&gt;&gt; import json &gt;&gt;&gt; json.dumps(a) Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "/usr/lib/python3.4/json/__init__.py", line 230, in dumps return _default_encoder.encode(obj) File "/usr/lib/python3.4/json/encoder.py", line 192, in encode chunks = self.iterencode(o, _one_shot=True) File "/usr/lib/python3.4/json/encoder.py", line 250, in iterencode return _iterencode(o, 0) ValueError: Circular reference detected 
I'm teaching myself Python 3 and am just hitting a stage in the process where I'm wondering whether it'd be useful as a learning exercise to contribute to an existing project rather than writing another of my own from the ground up. Does anyone have any advice about this? Apart from that, I'm still tinkering with my twitterbot.
There's nothing necessarily wrong with it. But a project that adopts any one method for doing IO will end up forcing that method on it's users and any project they work on. asyncio isn't my preferred method of doing IO, so I'm happy to see that the mitmproxy devs are actually considering an IO agnostic approach.
I have never been a Perl hacker, but I am very interested in learning Perl 6 for processing irregular grammars.
I'm retooling the report printing automation scripts that r/learnpython has been helping me with. It currently executes my SQL and saves it to Excel on the network drive and emails the customer with a link. I need to build some kind of interface so I can select different groups of reports (some run mid month, some run the 1st of the month). I don't want the script to decide which ones to run. I'm debating trying to use Excel to act as the front end but need to learn more before I make the call. 
No.
Thanks for clearing that up.
There are a couple of problems here. First is that Write(s=P*10, P) is not legal in Python. The `**kwargs` have to be last. The other thing is that Write(10) doesn't make much sense since you have to say which variable you are writing to. In the previous example we only have `s` but there con be any number state variables.
My current inclination is to admit a single `**kwarg` and let that it be both the value of the expression and what is written to the state variable. 
Pandas makes dplyr and data.table look stupid. 
The problem with Perl and IMO Ruby, is that those languages encourage you to be clever, and cleverness often gets in a way of readability.
Interesting post! Detailed and well structured. You've got my vote :)
You can replace all three of awk, sed, and grep with one languaage: perl (without the oop part). I think it's worth it.
languages don't encourage anyone to do anything. Assholes who are trying to be clever write code that gets in the way of readability, but that's not the languages fault. I can write you some C, perl, python, java, javascript, etc etc that's horrible to understand and has lots of clever hacks in it. Good engineers spend effort not writing code like that. I think people who tend toward perl hacking are the people who used to be shell script wizards. The shell scripting language is just a bad language, and the habits of writing archaic looking unmaintainable code go from language to language with them on accident. Perl is a beautiful language, and there's a lot of sense in the "it should work the way you think it should work" mentality that makes it so I don't have to google my way through every API I touch for the first time when I write code. Is Perl the best language out there? I think it's definitely not, but hearing people bash it because people use it poorly just irks me. It's a useful tool for doing the things it does well.
I'm in your exact situation, and 99% agree. Let me add two more points: 1. There is a lot of legacy code examples out there. You've got to check the date of any code samples you find. 2. Error handling is all over the map. You get to play "find the error!" Where is it? [$@ , $! , $\^E , or $?] (http://perldoc.perl.org/perlvar.html#Error-Variables) [Note: The autodie module is suppose to help alleviate this.] 1%: If I needed to write a small script that did a lot of text manipulation, and only I'd be using it, Perl is a fantastic tool. 
I'm not sure what a slug is.. but I hear the term used with increasing frequency. 
This page title is "Python Short URL: Generating Tiny URL- and bit.ly-like URLs." and its slug is "python-short-url-generating-tiny-url-and-bitly-like-urls". Simply speaking, slug is a User friendly &amp; Search Engine thingy. You can make them online at https://blog.tersmitten.nl/slugify/ if you're using Django you can use "slugify" helper to turn a text into slug. Also http://stackoverflow.com/questions/427102/what-is-a-slug-in-django
&gt; languages don't encourage anyone to do anything Oh hell yes they do. Java requires OO, Haskel strongly encourages it not requires functional. Erlang won't let you have mutable state. Languages with no scoping/namespacing encourage globals. Terse languages, like PERL, encourage and attract "clever" programmers. People who don't wanna deal with that move to languages that don't attract that / attract the opposite. 
Very exciting developments! Improving pandas support for several gigabytes files would be awesome. 
Start scraping. It's fun. *Shameless Promotion* - http://blog.adnansiddiqi.me/how-i-wrote-my-first-machine-learning-program-in-3-days/ - http://blog.adnansiddiqi.me/write-your-first-web-scraper-in-python-with-beautifulsoup/ 
Obviously with Linux there are more solutions, so I generally aimed this thing at Windows/Mac OS X users
Waiting for my Echo Dot to be delivered tomorrow by working on an Alexa Skill to keep track of things around the house (kids chores, whether it's just trash or trash + recycling pickup day, etc.) There may be other Skills to do this stuff, but I also plan on integrating things like powering on devices with Wake On LAN.
Done! Checkout version `0.6.0`. The previous example was defined as assert [70, 30] == Pipe( 3, Write(s = P * 10), #s = 3 * 10 == 30 P + 5, #30 + 5 == 35 List( P * 2 # 35 * 2 == 70 , Read('s') #s == 30 ) )
I think that's a good idea, since it is closer to what is being fed to call_later.
That's one of the beauties of Python... it can do *a lot*... and quite easily. Whether you're creating a web app (Django, Flask, etc.), scraping the web (Beautiful Soup), data analysis (Pandas, etc.), data visualization (matplotlib), or just writing a system script or automation task it is rock solid. If you're looking for ideas, and practical implementations, check out *Automate the Boring Stuff with Python* (https://automatetheboringstuff.com/).
&gt; Amazon AWS also seems like it'd make sense, but it's a bit overwhelming to me Most capable cloud providers whether you're talking about AWS, Azure, GCP, are going to have a bit of a learning curve. With capabilities come complexities. With that being said, can you clarify on the following point...? &gt; This program will be running off-and-on for several months What do you mean, "off-and-on"? Are you looking for basically just a VM host? I.e. standup a Linux machine, install MySQL and upload your script? Or are you looking for a "serverless" (shiny new lingo for a higher level of abstraction over computing) implementation? AWS has lambda, Azure has Functions. Again, there will be a learning curve to get on board with them. Also, with any service provider, cost is going to be a factor. Perhaps it might be worth finding and old computer lying around, or pick up a $35 Raspberry Pi, to start computing cycles to see what you *really* need? Of course you could be doing intensive computation on 1 MB of data, but with that being said a 10 GB database isn't exactly a large data set. I hate to assume too much given very little information, but what makes you think you need serious hardware for your solution? Have you run into bottlenecks locally?
Very occasionally I'm forced to write perl for work. We have some truly ancient UNIX systems with very old perl preinstalled, due to libc issues it's nearly impossible to get a recent python going. Then nothing in pip would really work right. Not worth the effort at this point. It is possible to write perl that is pretty modern. No one does it though, they still write the same way they have for the last few decades. Instead of using a modern framework like mojo they suck in CGI like it's 1994.
pip-tools has more safe-guards, and is more "standard"
try import pandas as pd import numpy as np import matplotlib.pyplot as plt df = pd.DataFrame(np.random.rand(10,2), columns=['x','y']) plt.plot(df.x, df.y)
You might have heard "one container per service" often in relation to docker. That's all well and good for smaller projects, but as your container count increases, it may make more sense to consolidate an save resources. That's when many resort to a init system or process manager, such as supervisor. In other cases, it might make sense from the beginning "this service requires these three things to all be run at startup."
I start a new job next week (excited!) and I'm going to need to take a weekly screenshot of my hours so I'm working on a script to login to the time system and screenshot the page. Plan on using Selenium and Requests for most of the work.
There is a web UI for systemd actually, [cockpit](http://cockpit-project.org/guide/latest/features.html), by redhat
ok. But then, why have they used nginx too? nginx itself is capable as a web-server, so why both nginx and Gunicorn?
First time seeing one of his talks, he's very good at engaging the audience.
I've been working on my first "serious" python project, and the first that I've published publicly: [adb_statusline](https://github.com/StarshipAmelia/adb_statusline), a status line for tmux or shell usage that can display various information about an android device (via adb). This information can be colorized for easier reading (In either ANSI escapes or `tmux`-style colors). I'm planning on adding additional features, including more information to display (probably frame rate and network usage), as well as the ability to specify custom colors via a config file. I'm hoping that this script will be possibly helpful for people who are developing things for android eventually!
Gunicorn is designed to run behind a proxy like Nginx that handles a lot of low-level connection stuff like buffering requests and SSL/TLS (though Gunicorn did get some SSL support recently). Nginx can also serve static files, and it's really fast at it. 
&gt; what I'm looking for is computing power In that case, layers of abstraction on top of the hardware are typically not going to be your ideal use-case. Your **utopia** would be to buy a beefy server and have it sitting in your house. Your code would run right on this hardware. Obviously that's not what you're going for (assuming, but I can't imagine you're looking to purchase expensive hardware). The cloud solution here would most likely be Infrastructure as a Service (IaaS). In other words, running a VM (Linux, I assume). You can scale this up as you choose (of course, incurring higher costs). With that being said, IaaS is *typically* not too much to learn as the cloud provider is just lending you a VM. I know for Azure, that's as simple as signing up for a subscription, creating a Linux VM (super easy), and then SSH'ing into it from your workstation. Is that what you're thinking?
Sorry, but no. I did learn Perl before Python, and it'd still be my last choice, after learning another language I don't know yet and using it in case Python isn't available.
This sounds like exactly what I need, yes. ..so I'm guessing you'd recommend I look into Microsoft Azure? Thanks for your patience with me. This seems so simple, but lacking the proper terminology for what I want has made it hard to know where to start looking.
Ah, ok makes sense! Well, try this. Next time you are going to do something with data at work, just automate it with Python. *Especially* if you expect to do that task more than once. Laziness through automation. :-)
No I said that because it took a bit of time to really get super good at pandas. It seems like the packages you're naming have a 1:1 analogue in python. But I'm not getting super excited about an argument about languages.
*Disclaimer: I work for Microsoft* Azure can definitely give you what you need. To be fair, other cloud providers can most likely provide you with this capability as well. You can start a [subscription with Azure and you'll get a $200 credit](https://azure.microsoft.com/en-us/free/?b=16.51a). That should be plenty of credit to get a machine up and running for some time, and then you'll have a pretty good idea if Azure fits your needs.
I don't have the code now but I remember that one time I had so many nested if statements that even I wouldn't understand it And I could have avoided all that if I just did if not statements or just used logical operators instead of just going in deeper every time a condition is satisfied.
OK, thanks... one more question: when I set up the cloud hosting package do I need to buy an SQL DB in addition to the VM? Or can I just install a DB using the space given to me in the VM?
I've been learning Data Science related stuff for a month now. So I gave myself a project to work on and anytime I get stuck, I go and learn whatever tools I need to use and apply. I find this to be very effective compared to the mind-numbing binge of video tutorials. The project is to figure out the crossover of subreddits of their userbase. So far in the wake of that goal, I've done mini-excursions into Pandas, SQLite3, Quandl, Pickling, JSON, PRAW, and some minor Python Modules that I didn't know existed. Just wanted to share that. Not a pro by any measure, but I have really surprised myself of quickly I'm eating this new information up. I'm just hoping the retention isn't too low. 
First things first, learn Python the language. Forget about web anything until you have a firm grasp on Python. Web development (front-end) is another thing you should learn. Learn CSS, HTML, and *vanilla* JavaScript. Then you should be able to piece them together. But... and this is a big "but"... websites are typically static content. Having a Python back-end is usually overkill if you're looking to just deliver static content. The practical way there is to use something like nginx to delivery your static files. Python with Django/Flask is what you'd use to create server-side logic and delivery of web content (including web APIs). Just a little clarification, but that's the accepted difference between a *website* and a *web app*.
I'm assuming this is for a Hangman style of program, so I'd recommend storing the blanks in a list of characters. blank_list = [' ']*len(word) #Initialize the blank list to the length of the word they're guessing. for i in range(len(word)): if guess == word[i]: blank_list[i] = guess You can then print out the blank_list with the guessed letters with "".join(blank_list)
You went through all that and kept the variable names??
I know this is awful, but the first thing I thought when I saw the headline is "Man, the ribbon in MS Office is getting out of control."
Block out an afternoon and do sentdex tutorials on YouTube. He does a good job of actually applying programming. I would recommend looking at his playlists and just finding one that is interesting. 
I didn't know this. My version is quite different because that defers downloads into a Celery queue (so it's more like a youtube-dl webservice)
https://www.youtube.com/watch?v=wf-BqAjZb8M Ill just leave this here...
Sorry to give you videos instead of examples, but here are 3 talks with great examples of better versions of bad code, that really taught me a lot: * [Brett Slatkin - Refactoring Python: Why and how to restructure your code - PyCon 2016](https://www.youtube.com/watch?v=D_6ybDcU5gc) * [Transforming Code into Beautiful, Idiomatic Python - Raymond Hettinger](https://www.youtube.com/watch?v=OSGv2VnC0go&amp;t=2308s) * [Raymond Hettinger - Beyond PEP 8 -- Best practices for beautiful intelligible code - PyCon 2015](https://www.youtube.com/watch?v=wf-BqAjZb8M) (starts refactoring code about 12 minutes in)
Thanks for the info! I've been thinking about trying out Haskell for a small personal project, I'll definitely look at that
Django is pretty hard as the first thing to work on with Python. You should get to the point where you understand OOP well, and have a few scripts of basic programs under your belt before starting Django. Once you are ready the official Django tutorial on their webpage is the place to start.
I just saw that Mozilla has an updated django tutorial that is the best content i have seen so far. I would suggest checking this out and going thru any prereqs needed to do the tutorial - https://developer.mozilla.org/en-US/docs/Learn/Server-side/Django/Models
I will definitely use on all function parameters at least. Allows type analysis tools to determine if code is incorrect. Type annotations also add great information to auto complete and docs.
What have you been using to learn? I need to pick up some data science stuff (just enough to get by). 
This post might be suited for r/learnpython 
But they aren't maintaining a standard there. On linux distros, `python` points to the 2.7 version, whereas `python3` points to the newer version. On windows, however, `python` can be either of them depending upon which version is set in the PATH variable. I think they should just point the `python` binary to latest version from now on. If any library breaks, then its the developer's lookout - they can choose to degrade to 2.7 for those particular use cases.
I have had to dive into Perl a few times since a lot of the visual effects film industry used Perl before using python. I really don't enjoy it. I feel like there's a lot of complexity in the language for not a lot of gain. 
&gt; In biology, Perl [...] Oh god. Perl is bad enough on its own, and science code is bad enough on its own... but both at the same time?
What `python` points to is meaningless and is recommended to be python 2. Many distributions including Ubuntu and Fedora only have Python 3 on their installation media now and all core applications should be using 3 over 2. They of course still have easy access to 2 as many applications still may use it.
Thanks for the mention. That was just fixed in v0.1.1. For implementation details, see: https://github.com/h2non/riprova/commit/a9b639d8d1c74aca888376af9fdb77d322a5e674
Well that's interesting. You want to treat this as an I/o stream while outputting it as an additional üé§ for your system to select. 
It's even more fun than that! The default list persists even if you use your own list. &gt;&gt;&gt; def add_to_list(item, list_arg=list()): ... list_arg.append(item) ... return list_arg &gt;&gt;&gt; add_to_list('inner') ['inner'] &gt;&gt;&gt; add_to_list('2') ['inner', '2'] &gt;&gt;&gt; add_to_list('3') ['inner', '2', '3'] &gt;&gt;&gt; outer = [] &gt;&gt;&gt; add_to_list('outer', outer) ['outer'] &gt;&gt;&gt; add_to_list('4', outer) ['outer', '4'] &gt;&gt;&gt; add_to_list('5', outer) ['outer', '4', '5'] &gt;&gt;&gt; add_to_list('6') ['inner', '2', '3', '6'] 
Python is a bit slow to do real time audio FX but there are other languages you can use (and some have python APIs). Have a look at SuperCollider or PureData.
trying to implement my bokeh html with wordpress. if anyone has tips, they're always welcome :)
Yeah, but the op is right, everything should be moving to python3 as it's viable. The problem is that there are too many pieces and not enough people to update everything. It won't always be this way.
Yeah, I agree that python3 is where everything should go. It's just that, as an example, there are too many python 2.x libraries and utilities in existence that aren't being updated as quickly as would necessitate python 2.x being phased out in a timely manner.
Maybe if these three things are all related python services or something, but in my experience, the thing I see people do is put a few unrelated things inside the same docker image. Like a client side app, a server, nginx sitting in front of both, and a redis server all inside a docker image. With something like docker-compose you can (and should?) make all 4 of those single purpose (ideally for nginx and redis prebuilt) docker images. And so long as you can have a nice separation like that, it makes it easy to run only one process per image. The only times I would think it would make sense to combine them would be if you have a bunch of python images with similar dependencies. Then you might save some space. That's the only thing i can think of though
&gt; Now... if you like/want the Python 3 behavior then the advantage here is that map does that while the list comprehension does not. Sure, but you can make it a generator by swapping the [x for x in a] for (x for x in a).
I'm just finishing off a Django app that will sit on my home server and let me upload movie/tv files to it. It auto sorts them and places then in a genre directory too. I need to add in functionality that lets you change the genre. After that I'm thinking either a Reddit bot, a website that has Reddit stats or a Kaggle competition. I start my Masters if of Computing in a month so I will be too busy for projects soon!
yes, the idea would be to consolidate on similar applications.
A basic, yet frustratingly common example: a = [1, 2, 3, 4] for i in range(len(a)): print(a[i])
I'm trying to get into Raspberry Pi 3, I've used it before in one of my engineering classes but it was through Matlab, not Python. Now I'm wanting to buy one for myself and create some homemade projects. 
Yes, I'm occasionally called upon to port from Perl to something sane.
A couple questions for those who learned and used Perl 5 and really hated it: Would you categorically reject learning and using Perl 6 because of your experience with Perl 5? Would you dissuade others from learning and using Perl 6 for the same reasons?
Python webapps expect a particular interface defined in PEP 333 and 3333. This is what tools like gunicorn and uwsgi do. But they're not great generic HTTP servers. Nginx, however, is really good at this (like stupid good). Nginx handles things like matching host names, SSL, serving static files and processing raw HTTP requests so you can use faster transports with gunicorn and uwsgi. 
[Source code](https://github.com/SnowdogU77/pyClipboardShortener) Paging /u/mvpetri
&gt; ...Ubuntu and Fedora only have Python 3 on their installation media That's not true, used both and python have always directed to python 2.7. 
Many new startups aren't chained to Python 2.7 as they don't have a legacy code base. It's great when you can start fresh on Python 3.
+1
That sounds interesting! Any GitHub repo? Where do you get the data rrom?
pyaudio - recording/playback pyo - DSP Your biggest hurdle here is that skype/teamspeak only recognize recording devices. You'll need to either roll your own driver, or go the easy route and use an application like Virtual Audio Cable to create the virtual device. VAC by default will create 2 sound devices, a speaker and a microphone, anything played on the speaker will be mirrored on the microphone. So you'll have to make your application output to the VAC speaker so teamspeak/skype will be able to capture it in the VAC microphone. For that use pyaudio for grabbing your microphone input, pyo for doing the audio manipulation, and then pyaudio again to output it to the VAC speaker.
Regarding timeout, effectively speaking that's only well supported in async coroutines, given the concurrent resume/pause nature (as with generators). See: https://github.com/h2non/riprova/blob/master/riprova/async_retrier.py#L230-L231 For synchronous blocking code, I personally don't know a generic, reliable way of doing this without hacking the Python runtime.
Trying to build a better, more comprehensive Shapefile of San Francisco streets. The Census laudably publishes shapefiles of every county, but the subgraphs don't connect, so SF has 2.5k+! It's a matter of adding in edges to connect. Great project to learn more networkx and graph abilities
thx for your response i'll try :)
Jupyter Notebook always made me feel like home. :)
Well, can we see the script? :)
I recently had to go back to 2.7 because AWS Lambda (a service that was launched less than a year ago) chose to only support Python 2.7 for now (for some fucking reason). Go figure what goes through the minds of the people at Amazon to launch a new service only supporting a language with an announced EOL.
Rather basic: if x == y: return True else: return False And here's how I've seen some people convert a string to a list of chars (which is seldom useful at all, anyway): l = [] for i in range(len(s)): l.append(s[i]) **Arrrrgh.**
Arrow, not to be confused with the new datetime library for Python! That being said, being able to handle large quantities of data in Pandas is awesome. I am not a fan of PySpark syntax and dread having to use it every time my dataframe gets unmanageable.
Yes. The first couple of revisions would iterate faster in each revision, but the memory size might be rather large due to building up a potentially massive list in memory. This is what the python3 map solution prevents, as map in python3 returns a generator. This means that values are only produced when they are asked to be, usually via a for loop. This means that it's slightly slower (generators have slight overhead and startup costs) but that it will (almost) never blow up in terms of memory usage. 
That is so contrived it's ridiculous. I refuse to believe that such code is to be found in the wild.
Xmas present for my girlfriend. Ping glassdoor api for both of our desired jobs, look for matching cities with jobs for both of us, send us both an email with the results.
I'm trying to make a program to extract text from multiple web page before collating it into a pdf that I can read on my kindle. Tbh it isn't going well
I don't think milliseconds is a good idea, mainly because of this: def as_seconds(**kwargs): return timedelta(**kwargs).total_seconds() Which makes things like timeouts and cache expirys much clearer about how long they actually are.
I basically though this would be easier than it actually is so it's stretching my rudimentary Python skills. I haven't yet tried Github but I may do so tomorrow. I'm using Beautifulsoup4 to try and extract the actual text from html formatting. On the particular website I'm looking at the text is only contained in &lt;p&gt; tags and I can use find_all('p') to isolate these tags and their contents from the rest of the html thereby obtaining the text. However some of the &lt;p&gt; tags also contain other things besides the text I want and so when I convert the whole lot to text I get occasional strings of code that I'm unsure how to get rid of.
This looks nice, especially with the AsyncIO support. My one complaint would be [this line](https://github.com/h2non/riprova/blob/489ed1fd2b51619dedc77c9bc65277e627d18fbd/riprova/retrier.py#L165) (and the corresponding line in the async retrier) I have a chance to handle every other exception that comes through except `MaxRetriesExceeded` -- and `asyncio.TimeoutError` in the async version. It'd be nice to be able to handle these as well so I could raise my own exceptions in these cases.
I want to analyze my spending on my credit card for various categories so I can budget. This will parse my credit card statements and notification emails over the last 5 years. Since it is personal information, I want it to run locally. As for database to store transactions, I am assuming a simple CSV file should be enough. But I am looking forward to using SQLite. What would be an interesting set of queries according to you?
I think you are looking for XSLT, which you can use in python with [`lxml.etree.XSLT`](http://lxml.de/xpathxslt.html#xslt), and some type of web framework like Flask or Django. Look into those and if you have more questions post them on /r/learnpython, not here. 
&gt; seeing the entire build fail only because of a missing whitespace ... But the build would not even get to start, because the linter failed. It would take literal seconds. 
I wrote a python scraper that allows me to search and listen to itunes podcasts without itunes and I would love some feedback! http://itunespodcast.pythonanywhere.com let me know what you think!
Thanks! [Github repo](https://github.com/psammetichus/pyedf). I work in an EEG lab. I have IRB and HIPAA-approved access to anonymized patient data.
I feel you. I've seen default vim on Windows, default cmd size, no syntax highlighting. 
To have a variable that can be multiple types, don't you just use [Union](https://docs.python.org/3/library/typing.html#typing.Union)? 
I have not used Python, but I feel the same way about Perl. Every other language I've used has made me appreciate it more.
It's a bit disingenuous to say no one does it. Certainly far too many people don't know any better and still write ugly 1990s perl, but also plenty of people use Mojo, Dancer or even Catalyst (which is a behemoth, but a far cry better than CGI), and various other libraries and styles which are considered Modern Perl (as in the book).
EVER.
That's definitely a start; I hadn't seen that. I guess what I really want is complicated definitions (e.g., 10+ arguments, some of which have multiple types (e.g., `(n, ) float np.ndarray, None, generator, List[float, ..., float] '), some of which may have defined lengths (e.g., 3 like an xyz coordinate), some of which have dictionaries with certain allowed keys, each with their own type. I also want that to look nice, even if it's at the expense of space. None of that seems like it's unreasonable. I guess I'm really waiting for people to use it, so we can all point to library x's file y as a good example.
Small web app in Flask that allows people to sign up for volunteer shifts through a calendar interface. Doing some of the database work myself rather than through an ORM, mostly as a learning exercise. It's been pretty fun so far.
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Because WSGI really sucks. I've seen many people running Tornado directly on port 80.
&gt; I think they should just point the python binary to latest version from now on. If any library breaks, then its the developer's lookout - they can choose to degrade to 2.7 for those particular use cases. The short of it is if they do that, all the people with code running on linux servers that actually makes their companies great buckets of money, or helps support them in various ways, will shout and yell and scream and holler at Python.org way louder than you ever could, about how that's a fucking horrible idea and `python` should always be python 2 so their shit continues to work without them having to do overtime on weekends to port stuff.
+1 for this. One of the most bothersome things I've had to deal with so far are scripts that have assumed where python binaries live. It is not safe to assume that `python` will exist at `/bin/python` or `/usr/bin/python`, but `/usr/bin/env` being what you expect (POSIX-compliant env(1)) is true at least for all of the systems I've ever worked on across *BSD and different Linux flavors.
No, Ubuntu did indeed do that. Python 3 is now the version that comes installed by default. However its binary alias is still `python3`, not `python`.
Yeah, unfortunately `boto`, a relatively recent tool, has quickly become one of the biggest libraries / tools holding python 3 back. Rather disappointing. Damn you Amazonites....
SimulateMe! LSatyreD
Because jumping to Python 3 has been a huge pain in the ass with little benefit. It's a larger, more complex language with no new killer features. That probably changed recently with the introduction of curio. It appears to be for Python 3 what comprehensions and generators were for Python 2. Check it out!
Yes, you could. Like many things, there are pros and cons to owning such a machine. I'm assuming he wants to spend more time thinking about his problem than racking up server blades, but as you note, that is one good way to get lots of computational horsepower. (side note: my employer has roughly 30,000 servers in service, and we turn them over every few years. I suspect that most of the few-hundred-dollar rackmounts you see on eBay have been pulled from some enterprise who deemed them too unreliable, power-hungry, or otherwise unsuitable for continued production service. I'm not discounting the validity of the suggestion, just noting that you want to buy one of these with your eyes open.)
The plan was to use the local time and just throw the script in a cron to run weekly. 
ok I did thanks
Apart from backwards compatibility issues, until python 3.2 (or 3.3 ?i guess), the 2.7 version was still faster [1] than 3.X . Now, that 3.6 is released, I ll start porting some of my pet projects to Python3.6 [1] This only applies to CPython implementation of Python interpreter.
Neat! I built something similar, but somewhat more generic. https://github.com/guykisel/inline-plz-bot I had basically the same idea, but mine supports ~15 different static analysis tools for several languages (and is extensible). Screenshot of the bot in action: https://github.com/guykisel/inline-plz-bot/raw/master/inline-plz-bot.png
Even when a project has linting in its CI, it's still nice to have the immediate human-friendly feedback in the pull request itself.
And a very unforgiving one. [PEP 8 isn't so rigid][1]: &gt; know when to be inconsistent -- sometimes style guide recommendations just aren't applicable. When in doubt, use your best judgment. [1]: https://www.python.org/dev/peps/pep-0008/#a-foolish-consistency-is-the-hobgoblin-of-little-minds
Good stuff! :)
Some build takes hours to completely run the test suite. Not starting the test without completely fixing the lint errors sounds too rigid. However, this is subject to preference.
You too! I poked through your code and I like your approach :) 
This post does not seem relevant to r/Python 
It's basically like you said, php didn't have a massive shift like the changes in python3. Old code continued to work, but there were (and are) deprecation policies where things would print warnings in the error log, but still work. Eventually it would switch to fatal error in the next next major version. Perhaps python could have done some things this way, such as allowing print to work both ways, but the old way would generate a deprecation message in logs. 
This is a valid question, but I feel like this is well explained by some Google research. Did you do that?
This post might be better suited for r/learnpython 
why is that? 
How can I install this with conda? I tried `conda install python=3.6` but it didn't work :(
Nice post. Never had heard of Netlink or this lib before. Will definitely keep it in mind if someday I get to work with this kind of thing again. Thank you.
I'm a bit divided on this, because all kind of style enforcing causes problems and doesn't understand that in some cases breaking the rules is better. Even PEP8 itself states: "A Foolish Consistency is the Hobgoblin of Little Minds". On the other hand this writes comments instead of blindly enforcing it. Perhaps it is some kind of compromise.
I thunk vote variable names type comments could have been enough. I wish PyCharm would allow auto completion for type comments.
when it's will be finish ofc ^^ 
Personally, I think enforcing it this way is overkill. Type checking is most useful for documentation, finding bugs and auto completion. Those work best with IDE such as PyCharm. When you enforce it (as you pointed out) it makes your code slower, without contributing much. If in the future Python will use annotations to optimize code to use native types, then that would be worth reason to enforce types, but at this point seems a bit useless to me, or maybe I'm missing something? 
If you take out the square brackets it sums a generator instead of a list.
Very true - I make it more flexible by disabling the checks that we don't need and showing warnings instead of blocking completely where applicable.
Did you even try to google?
Same reason for everyone doing this. It's easier to let others put effort into it. If people stopped answering questions that could be googled easily, this behaviour would stop and people would be socially pressured into becoming smarter. Instead, though, we have a situation where people use others to avoid thinking and get reinforced in their belief that others do it for them.
This is really great! It's fantastic that someone thinks about how to get the fastest speed in python, acknowledging part has to be done in a different language. I'm happy people like the post creator are out there creating all this fast stuff but still valuing python; even wanting it to end up there.
I'm working through the django docs tutorials for the first time. I want to make myself a basic blogging app so I can blog about learning how to make stuff with python.
That sounds like an effective but long way to get the hang of things. How long has it taken to reach where you are now? And how much more time do you think it will take? 
Unless part of the brief was the customer wants it in excel 
&gt; If in the future Python will use annotations to optimize code to use native types[...] From what I read, it is not on the cards. Pypy devs specifically said they don't need type annotations, they can optimise already without them.
Besides the fact that it's not a dedicated library, what does everyone think of pandas' timestamp functionality as a datetime replacement? I've been using it almost exclusively for even simple things. It's parsing is very simple, adding date offsets is extremely easy (they even have offsets for things like business days) and time zone localization/conversion is really simple.
I think that's it's great. One question I have in general for linters is why stop at linting if you know how to fix it ? I recently pushed friendlyautopep8 to PyPI which does fix pep-8 but only on the lines changed by the contributor. GitHub Integration API is still limited, but why not directly push the fix on the GitHub PR if the user has checked "Allow edit from maintainers" ? That's less work for the user, and less waiting for the maintainer. You can even --amend the commit if you want a clean history. (also I need to send a patch to autopep8 to take ranges of line instead of just 2 numbers. https://pypi.python.org/pypi/friendlyautopep8
The problem with PEP8ifying lines the commit didn't need to touch is that you destroy history. A `git blame` will show that the one who did the PR made changes to that line, even though they were purely aesthetic. This may make bisecting harder. The other point is that you may sometimes want to violate PEP8, since it may produce more clear code. If someone else comes along with a PR for that file the bot would scream in his face to fix the issues.
To be honest i'd use digitalocean, you pay by the hour, they're very cheap and they have a nice API https://developers.digitalocean.com/ which means when you're running paralell simulations, you can deploy each one to a different droplet then get them to upload their data somewhere else, then auto delete themselves. On another note, I'd kill to know where you got you data from.
why is that bad
It's a very useful library but this line is so slow on anything but a very simple network: ipdb = IPDB() Do you experience delays here?
Thank you for your comments. The bot can now be configured to scan only the diff and not the whole target file, and hence the bot won't come screaming to the users. :) https://github.com/OrkoHunter/pep8speaks/pull/2
Suggesting the change is okay, automatically fixing it is not a clever choice. autopep8 sometimes ruins (makes ugly) code of 81 chars to follow pep8. I shall check the friendlyautopep8 library and get back to you.
If only there were some kind of punctuation mark to indicate that something was a question.
Text is from [this page](http://www.thebestfreebooks.com/read/read-sabriel-abhorsen-1-online/291193) The code I have so far is this: (I install Beautifulsoup4 first using pip) from bs4 import BeautifulSoup soup = BeautifulSoup(open("test_html.html"), "html.parser") text = soup.find_all('p') print (text) where test_html.html is the html from the web page. This script prints all the text I want but also returns occasional script elements that are used to embed ads among the text. I want to get rid of the script elements but I'm not sure how.
You can easily search github for "Need contributors" labels, and filter for Python only: https://github.com/search?l=Python&amp;q=label%3A%22Need+Contributor%22+&amp;type=Issues&amp;utf8=%E2%9C%93 Most open source project that bother to set such label will be willing to mentor you to fix an issue. One of my advice would be to start fixing bugs, improve docs of a library you use, or even just look at issue/review PR or respond to bug reports to this library. You will likely learn a lot by contributing to a project. And if you see an issue you would like to tackle, feel free to comment on it and ask how to proceed, you will likely get hints from maintainers on where to start. 
I can bow to the the wisdom of my betters. Especially if they can offer constructive feedback. My toolbox is what is available in [Anaconda](https://docs.continuum.io/anaconda/pkg-docs.html)
I would take suggestions. I can use what is in [Anaconda](https://docs.continuum.io/anaconda/pkg-docs.html)
Sure, I went for short in my comments, but you can submit a PR against the PR, or use commenting to trigger the bot to fix only certain line. Like clicking the review and have a trigger comment like (`!!pep8ify` ?) to pep8ify only this line, or current block ? I agree that sometimes (more often than not) autopep8 ruin things, and hence why I want to apply it only on changed lines. But for project that do enforce pep8, I don't see why they don't autofix it instead of just failing tests. Also I need to play with autofixing only a subset of rules. I want to point out that I change my mind a bit on autofixing after playing a bit with go-lang, which runs go-fmt on your code unconditionally. And despite my initial concern I think that it's great as it cuts off all discussions. I'm going to assume you are maintainer on the repository you run `pep8speaks`, what about turning the list of violation into markdown checklist, with the `- [ ]` prefix. And autofix the violation you check with `- [x]`. (As a maintainer you should have the right to edit the bots comments IIUC) That would make fixing pep-8 style both super easy, and leave you the freedom of not being compliant. [EDIT] Also, Checkout the the new GitHub integrations API (Beta) : https://developer.github.com/changes/2016-09-14-Integrations-Early-Access/
Thank you very much for explaining it in detail. I very much liked the idea of suggesting the change on a line when someone comments `@pep8speaks pep8ify` or `@pep8speaks correct it`. I shall definitely work on this !
Emacs coworkers should use autopep8 (perhaps vim too). Whenever I save, it just fixes tabs/spaces and adheres to (custom) pep8.
Hi, I read the article and it seemed interesting. I am not sure what was your target audience here but I would suggest you give some more details and few more use cases. That would pique my interest further more. 
TimSort is awesome, I'm sure it does something smart ;) It's actually easily tested: import time sorted(range(10), key=lambda x: time.sleep(1) or x) Execution time is indeed really close to 10 seconds, so it for sure only evaluates once. It makes sense, since you would only want to evaluate this possible long computations once and not for each comparison. And why not, it is actually very easy to just compute all at once, and then do the sorting only on these results. (of course easily said after confirmation). Fun fact: After you get the values, then the real thing happens. I remember that TimSort exploits "structure" in what it tries to sort (search for TimSort galloping mode). Given that `range(10)` is already sorted, it is "maximally efficient". So just to be on the safe side, I thought to try with random data: import time import random sorted([random.random() for y in range(10)], key=lambda x: time.sleep(1) or x) Still 10 seconds.
that should be pretty easy to test, right? just throw a print statement into f 
Your first example doesn't show anything. The list you passed sorted is already sorted, so the key will be evaluated exactly 10 times. But ok, I got it.
Julia is interesting because it's readable and quite fast. And the expansion to multiprocessing/parallel processing is much easier to accomplish. Apparently to get the fastest code it's common to have to "devectorize" operations by converting them to `for` loops, which is a big failing for me. But I've read (and run prelim tests) that in 0.50 there are vectorized versions of ops that avoid intermediate allocations, obviating need for devectorizing. And there's even a `Devectorize.jl` package. The ecosystem seems pretty active, although still way behind something like Python. And this stupid 1-based indexing is killing me!
There's a reason Python 3 took away `cmp` and made everyone use `key`. It's better in (almost) every way.
Predicting the spread of some sickness utilizing real time datasets. 
In Perl, you would use a special idiom called the Schwarzian Transform. In other languages, it's a more boring terminology called various things, like a decorated proxy list. You create a copy of the list, but each element is a pair that includes the original item `x` and its `f(x)` result; this way you only call `f()` once per item. You then sort the list based on the result elements. You then discard the result elements and return a list containing the original elements in their new order. Python just does this all internally for you.
When it comes to networking in Linux, there is one primary interface intended to interact with the kernel from userspace when you want programmatic access without simply making fork/exec calls to utilities like ifconfig and the iproute2 suite, and that interface is called Netlink sockets. This library provides a python interface around the Linux Netlink socket interface. One reason you might want this kind of thing is that you may want to monitor network events, e.g., some event triggers a change to the routing table, and you need to reconfigure the listening address of some daemon in response to this event. Netlink gives you the interface to be notified of these kinds of events more quickly and reliably than polling some command like 'up route show'. This is just one example of the use of Netlink, but the primary feature is bei able to interface with the kernel network stack via messaging rather than an external user space binary or a more klunky ioctl interface. If you are interested in Linux networking, LARTC.org is a good place to get up to speed on some of the basic services, but in recent years Google, Aron other contributors, have been busy adding a number of neat improvements to Linux, making Netlink more and more relevant as Linux seems to be a go-to OS for modern networking projects.
Yeah, I've run across a few of these over the years.
As a self taught newbie, what I don't understand is why SO MANY online courses and tutorials are Python 2. I can only assume it is just laziness. They always point to less libraries as the reason. What libraries does a newbie need that aren't available for Python3? 
Nice idea. `sorted(lst, key=print)` prints out one line per item in the list, but then bombs out with a TypeError because `print()` returns None. But this works: &gt;&gt;&gt; sorted([1, 3, 2, 5, 0], key=lambda x: (x, print(x))) 1 3 2 5 0 [0, 1, 2, 3, 5] Of course, this doesn't prove that sorted/sort will only call the key function once for whatever input list. However, you can tell from the `listsort()` code, which sorted uses, that it just allocates space for the key list and then iterates through the input list in a direct way: https://github.com/python/cpython/blob/master/Objects/listobject.c#L1961-L1985
It is. You can add extra options as well for it to ignore...
That's great ! Please let me know if(when) it works, I know of a couple of projects that would like that. I'll do the same on my end. Thanks you for sharing as well !
I'm working on a application that will validate existing POI (points of interest) from multiple sources against a huge base of new POIs. There is a lot of interesting things here. Fuzzy string comparisons, address matching (this is a hard, we have way to many variations). The application also has a frontend, where the users will be able to launch analysis for clusters of points and check out their results, validate them further, reject, merge, etc.
Julia has 1-based indexing? Oh man, before I was willing to at least try it but now, no way.
This sub seems to be filled with totalitarians.
If that's such an issue (not sure why it should be), since 0.5.0 you have the option to use [custom indices](http://docs.julialang.org/en/release-0.5/devdocs/offset-arrays/) in Julia.
I would say this misses the point. pynd isn't about speed, but even with tons of Python files it is more than fast enough. Python source files are generally tiny. The point is a grep-like tool that understands Python syntax and can easily search for specific things. You can replicate it with similar tools but the effort is much higher and the speed difference is negligible in most cases. Check out some of the examples, if that doesn't help maybe I explained it badly or you just don't have the need? I use ack when I was to search more generally. It is great. 
Also, ag wouldn't be a good backend unless it knows how to create a Python abstract syntax tree üòâ
It would definitely depend on the project. I'm partial to crystal and jruby at the moment if I need speed. 
Dude the thing you need to get is that Django make-an-site-in-10-minutes-with-20-apps philosphy is aimed at your "average" wbsite with your "typical" strucutre. That kind of site uses only autonumbered single-column primary keys. idk if it's a blog or a site with articles or it has comments or product orders or whatever. It is something simple design-wise that needed a web framework capable of deliverying ASAP. That is Django. if you need anything front-end oriented and don't care about backend, then you use Django. If you need full backend power, you need Flask. The Django ORM just reflects this. The DB agnostic blahblahblah is perfect to deploy on whatever server so you don't need to care about the specifics and you better never need to touch the specifics.
Hey cool! I just got one of these too, and I'm similarly interested. I've read that you need a publicly-visible webserver so that Amazon can talk with it. Do you know if there's any way to just host something on your internal network?
I would never recommanded [Fsharp](http://fsharp.org/) to my alter ego as a starting language instead of Python. But... Fsharp is really beautiful even if you consider the fact that it is getting uglier when using C# libraries. Similar to Clojure when it meets Java. :)
&gt; all you care about is starting your own thread Thanks for confirming my suspicions about the intelligence of the pile-on here.
You're going to want to make a class with it inheriting from tkinter.Frame. This is going to be your top level window (Master Frame as you called it) &gt; class ClassName(tkinter.Frame): &gt; self.parent = parent You'll need to make two more frames giving their parent as the class frame. &gt; frame = tkinter.Frame(parent) At this point you've got three frames, one parent and two children. You can easily move the children around with grid() &gt; frame.grid() this has things like columnspan, columnheight, columnwidth and such. Most importantly you just need to set the column and row for each. If you created the frame with height and width parameters grid will take care of the rest so long as you tell it where you want it. &gt; frame.grid(column=0, row=1) rows and columns automatically resize themselves to fit the largest object in them. At least that is my understanding. I think you'd be best off just grid as a whole, it's not difficult to understand at all. 
I just played with jquery: $("p").each((i,e) =&gt; {console.log(e.innerHTML)}) Which prints only the text. hit f12 and copy/paste on that page's console. The scripts are in divs. But it looks like there's an errant HTML formatting problem right after the script, as the &lt;p&gt;&lt;/p&gt; is empty, but you can see after the script, there's text outside of a &lt;p&gt;&lt;/p&gt; which probably screws up the parser. For that particular page/website, it looks like you might want to do: for line in text: if \s\s\t in line: print(line) Each text paragraph has two spaces (\s) and a tab (\t) You'll find that every website scrapping will have a quirk which you have to overcome. Whether it's intentional or not. 
Thanks for your commented config!
all very useful information, thanks for that :) the initial replies i got from /u/thomas_stringer made me realize i was being silly with my mental block of "this is too hard". it took 6 months to get to where i am with python, so i'm not sure why i expected to be able to simply upload my code and press play without having to learn a bit first. i've been poking around amazon AWS and microsoft azure. i'll check out digital ocean now as well, from what i'm seeing on their site it looks like it's a bit simpler overall. once i settle on a host, am i correct in that this is the procedure to follow? -set up a storage account and upload my python script and DB there -write a bash script to automate the installation of python, required libraries, mysql, whatever else i need -launch a VM instance, link it to the storage account, run the setup script, run my python code! am i missing anything here? it actually does seem quite simple once everything is in place... also one other thing, do these services typically give a detailed breakdown of how much demand is being placed on the VM? I'm not sure where the bottle-neck(s) in my code are, if i'm limited by the frequent I/O querying of the DB or in CPU usage.. if I can have stats telling me what's maxed out I know where I should focus on optimizing, as well as where to spend more money to see a performance increase. Thanks again for your help!
I actually disagree here. I've found that extra verbosity from output detracts from the comments, especially when there's subsequent updates to the pull request based on comments. I think utilizing travis properly allows for discussion within the pull request and succinctly identifies when there is a problem. The full log output of the py.test run is available from a single click.
Cool! I'm interested, if you upload it I'll definitely look at it.
That's all very useful. Thank you!
When the bot comments on the PR in general, then yeah, it's extra verbosity that remains even after the PR gets updated. However, when the PR gets inline comments on the diff, as in my tool (https://github.com/guykisel/inline-plz-bot), the comments get hidden after updates. You're right that the efficiency gain from getting the info in your PR instead of from travis/jenkins/CI logs is not enormous. However, I use my tool at my job on a project with ~100 developers, and I've noticed real (subjective) gains in developer satisfaction. It's also useful for providing some friendly feedback in smaller projects where devs haven't gotten around to setting up CI or linting rules yet, like little one-off scripts. You can set up a single webhook for an entire github organization and it'll run on every repo within the org, regardless of CI setup. Also, just as an aside, I love https://github.com/landscapeio/prospector because it combines flake8, pep8, pylint, and more linting tools all within one parent tool with a consistent output format.
It would take much longer if I just looked at tutorials. Having a random project like this gives me a direction to focus on and the resulting hiccups and barriers I encounter will cement the information better when I overcome them. This way of doing it, I've been at it for about a week and a half. I did a mini project before this dealing with the US population since 1900. It forced me to find the data, clean it up and then actually analyze it. This helped me learn Pandas a lot better and when I went back and looked at some tutorials, I felt way more involved rather than just reading about it or just repeating what they do. The Reddit project is a little bit ambitious I think. I'm at the point where I have scraped about 6000 user accounts. But due to the way PRAW is designed, and rightfully so, requests rates are capped. So just getting that much data took about 6 hours. I'm currently in a small detour to learn about JSON and if I can just grab that, then I can do the scraping after the fact instead of relying on PRAW's object models. It really is interesting the many small things you pick up. For example, I've never been so comfortable with Jupyter as I am now. It's given me a chance to pick up tricks here and there that I might not get from one coding subject. I'm going to keep this going as long as I could. Even if I get a job and all that, I think having a grand project or problem to work on and always striving to that end goal is a good thing. So, yeah, I guess the answer is forever. Haha.
sounds like you could make a couplesindeed.com
I don't understand this suggestion. For a text editor pyCharm is overkill imo. All I need is the File and Configuration tabs in IDLE. 
Wow, that's interesting. I didn't know that label existed. How would I go about on asking for contributors?
Python 2.7 support only?
&gt; you shouldn't call that constructor twice But you can, and people (including your future self) will, at some point. The very least you could do is document this violation of a common and perfectly reasonable assumption. &gt; that class should be instantiated just once since it basically is the beginning of the program itself. If it's just the beginning of the program itself, then why the fuck is it written as a constructor in the first place? Constructors are for initializing object state, nothing more. &gt; feel free to open an issue with all aspects of it that you don't agree. i would thank you for that. Why would I do that? I've already given you a free code review, and I really really don't need another text editor. I just came here curious for the "most elegant python code ever", and let's just say the experience was anticlimatic.
Hi! I think the best way to learn a language is to read a book and play with the examples. To get further, my advice is to find a subject/app that you would like to learn/build and start developing it. A very cool way to do this (if you have no idea where to start) is to find some open source project that you like and try to enroll in it. 
This post may be better suited for r/learnpython or some Kivy forums
This post is probably better suited for r/learnpython 
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Worth watching the whole thing. I think sometimes we, myself included, forget there's the whole [werkzeug](http://werkzeug.pocoo.org/) library behind flask with lots of additional documentation and utilities. I know I've written my own version of a lot of these [`HTTP Utilities`](http://werkzeug.pocoo.org/docs/0.11/http/). 
You do need a publicly accessible webserver if you do not want to host the Skill in Amazon Lambda. Alexa uses "the cloud" for voice recognition, and that's where the Skills calls are dispatched from. The device in your house does not do the voice recognition and parsing -- it's merely a voice recorder. It does suck that even if you want to hit a web service in your house, you need to have it open to the world. AWS eats through so many IPs that you'd go nuts trying to whitelist them all in a firewall. However, your skill that you host can have any arbitrary URL, so you can make it something obscure. Without any links on web pages to it, it's unlikely any bot would ever find it.
That oneliner works fine on macOS.
We are using fabric that way (as a library) for 2 years now, works great (recently we move to fabric3), works like charm cross platform (good luck with getting shh client working as expected in windows..)
I don't understand....can't you just subtract 1?
So it's similar to JS in that sense, then?
I'm not quite sure I understand the question. Though usually you can add a label like that to your repo and often you can register your project to sites like https://hacktoberfest.digitalocean.com/ or https://24pullrequests.com/ where users are searching for things to do. Does that answer your question ?
Building a forum or a community website takes a lot of time if you planning to do it on bare frameworks like Django and it takes even more time if you will do this on a microframework like [Pyramid](https://trypyramid.com/) or Flask. If you want a community website, go with [Wagtail CMS](https://wagtail.io/), which is built on top of Django. If you want a forum, use [Spirit](http://spirit-project.com/). If you just want to learn and don't care much about end result, then go with Django.
I'm guessing they meant just ssh, as in `ssh user@host 'ls /'`
If you want to continue to learn more about the language before developing a project, I've found http://book.pythontips.com/en/latest/index.html to be extremely useful. It teaches you some cool tricks that most people never learn about. I'd recc reading this, before starting a project
Why do you want to develop the website? There are so many online services, including free ones, that let you build a web site without having to develop anything, just follow an online "wizard", and use online design tools. If you do pick the development route you should keep in mind that you are undertaking a long term commitment; web site development isn't just getting it up and running, it involves long term support for your customers and doing code and data maintenance. If you go for it I strongly recommend to "adopt" an experienced mentor who will walk you through the project design, assist you in making implementation choices, and help you avoid most of the common pitfalls. 
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
I assume that's what redreinard means too. That's great and all, but doesn't solve the problem of doing that from a larger Python app programmatically. 
Not the same as Windows support, but can be installed / run under Bash on Ubuntu on Windows https://msdn.microsoft.com/en-us/commandline/wsl/install_guide 
Yeah, really enjoyed the entire talk. I like the rationale given regarding websockets vs the 'sse server' approach given here as well. Worth watching.
I appreciate what you are trying to say here, but it sounds like the op is mostly interested in learning. We shouldn't discourage that. If he builds a website for some community that he is part of, that isn't the same as building a commercial site that would come with a lot of obligation for maintenance. I just feel like the comment you made wasn't as helpful as it could be.
Oh, I do not know how to add labels to the repos. Seems those sites are over with registering, would be checking them next year though, thank you for the info.
We are searching for an experienced software engineer and technical lead proficient in agile software development, REST API deployment, and geospatial processing and data management. Deedabase is a revolutionary enterprise cloud application that automates land title searches. Our interactive parcel map reduces the tedious process of running a chain of title by providing run sheets of enriched county land records for any given tract of land. Instant access to property title run sheets allows our users to focus on analyzing land records ‚Äì not finding them. Our current technology stack consists of: ‚Ä¢ MongoDB ‚Ä¢ Python ‚Ä¢ Django ‚Ä¢ JavaScript ‚Ä¢ PHP ‚Ä¢ Apache ‚Ä¢ AWS ‚Ä¢ Leaflet ‚Ä¢ Git Deedabase is a current client of the Houston Technology Center's energy acceleration program in Houston, TX. Demo: https://youtu.be/cErUgjfYaEo
&gt;I just feel like the comment you made wasn't as helpful as it could be. I would 100% agree with you if it weren't that OP wrote _"I'm looking for fast results"_. When starting from scratch, with those expectation he is very likely to lose confidence, because the results one gets in the beginning are very far from those imagined or planned. IMHO if he needs near-term results for his community then his best options are either use something ready made and then move on slowly through self-learning, or work with someone who can assist him in building a realistic project-plan. I'm pro cheer-leading, but I honestly think that suggesting to him to readthedocs of pyramid or django when doesn't know the difference between Python and HTML is not right. Even the learning resources suggested here on the sidebar assume prior programming background.
If you just want a forum to run a community, then I highly recommend you go with an existing solution, PhpBB3, SMF, Discourse, Flarum, FlaskBB, etc Will save you a lot of hassle and let you actually run a community rather than having to code and maintain a forum site. Some users will also expect X, Y, Z features of existing forum software which might be hard for you to implement with your own bespoke solution. Forums (and any dynamic website) need **both** frontend and backend code, the frontend always being HTML/CSS/JS and the backend generally being a web-suited language like PHP, Python, Ruby, NodeJS, Go, etc
Oh. That's super interesting. I did not know about the Pi OS interrupting PWM.
I just double checked and it looks like what I said is no longer true. [This library](https://github.com/jgarff/rpi_ws281x) seems to allow the Pi to control ws2812b LEDs directly.
It comes down to the lack of professionalism in the Python community. There are many examples like you have given where a languages community moved forward wholesale and didn't passively undermine language improvements. Basically too many immature babies in the Python world. Note i believe I'm being rational here because id be the first to admit that Python 3 took a while to gel. It became viable after the 3.3 release but that was like six years ago. After that time of morphing into a new and better language though there was no good reason not to move forward. 
Honestly, I doubt that Flask is going to be the bit that blows up your embedded system requirements. The reason is mostly that security features are extremely hard to implement on a really small system, unless your system has significant resources: - I was surprised that upgradability is a big hog, unless you are prepared for implementing a more tricky upgrade mechanism (=potentially unstable, needs a lot of development and testing). Without online firmware updates, your device will likely remain unpatched and insecure. Getting this right hard without substantial memory that is reserved just for checking for and storing updates. - Other security requirements, such HTTPS, will likely need a substantial amount of memory as well. - Not to mention that if you want to add any features that do audio or video, your hub will need way more processing power anyway. I know it can be done on a smaller device, but in my opinion, almost all IOT Hub type devices will be better served by a processor that runs a full operating system (Linux) and a decent amount of memory (I'd say, 256MB RAM, 1G Flash), unless you are prepared to invest a very significant time and money in development and testing. But to answer your question: I guess that Flask could relatively easily replaced. We are mostly just using the routing features. 
I missed the 'fast results' part. Yes, that does change things.
Yeah, when you are talking about starting from scratch, one of the biggest factors is the ecosystem. Being able to 'pip install antigravity' is so critical to getting products out the door. The user-base is another critical element. Until a language gains a certain degree of critical-mass you are setting yourself up for difficulty getting help down the road.
Ok, I was getting other errors when I removed those so it looks like I Have other problems. Thank you! 
Completely meaningless with respect to your previous post and my response. Please do us all a favour and give up as all you are doing is wasting bandwidth.
Did you try making this work with just an ESP (and a microphone, etc.)? Better yet, using MicroPython on the ESP?
One more question. Do you think I need a teacher for this stuff or do you know a good forum that helps out noobs like me?
https://gitter.im/FreeCodeCamp/FreeCodeCamp Join the python channel under freecodecamp. They have an active community. 
The sqlite3 library is quite easy to use. I prefer it over CSV since you can fire up a db client and look at the data yourself quite easily. Simple stuff like spending over time, percent increase/decrease month over month, analysis per month of the year would be cool. I don't know how much data you get with the statements but determining the type (entertainment, bills, etc) in pie chart would be cool!
As someone who is currently trying to wrangle a large (ish) catalogue on light room, my sympathies go out to you. Arduous work.
I considered doing this early on but ultimately decided against it for a few reasons. The ESP8266 just doesn't have enough computational power to keep up. The visualization code could run on a raspberry pi, but the quality and FPS will really start to suffer on anything slower. I'm open to the possibility of using the ESP8266 though if the code could be optimized. Given of the computational requirements, I think it would be easiest to implement a complete standalone solution on the raspberry pi instead of the ESP8266.
This is 'pre' lightroom work, mainly sorting and classifying. Celery makes short work of smashing through the processing. I've had a Redis exif caching tool for a while, then it moved to a SqlAlchemy database for Exif. Right now I'm going through and problematically cutting through things that are out of focus. Then I need to split between photos of my shop, Rugby games and of our kid/us. (July 2016 I have ~4000 photos alone). In parallel I've had my wife 'classify' all of the photos of us. The plan is to train a few neural nets to do most of the gross categorization in addition to categorizing. http://crockpotveggies.com/2016/07/26/automate-tinder-artificial-intelligence.html 
Armin is the man.
[For an nginx approach](https://www.digitalocean.com/community/tutorials/how-to-deploy-python-wsgi-applications-using-uwsgi-web-server-with-nginx)
You're absolutely right, Devs should use w/e they are most productive with. I guess I push PyCharm because it seems like many people take 1 look at it and think it's "too bloated" and they want to use something like Atom. PyCharm has almost everything you need out of the box and with a couple plugins it's perfect. All the other text editors require so many plugins just to become useful at all for development and still aren't nearly as powerful as PyCharm. I just want everyone to perfectly productive! :)
Just an adfly link to the python docs. 
This needs to be higher up. Don't try to reinvent the wheel if you don't have to.
Thanks, that thought did occur to me! https://www.reddit.com/r/learnprogramming/comments/5ktxbl/gui_in_wxpython_need_some_oo_design_advice_xpost/
I'm far from an expert but I hope this inspires some cool projects! https://github.com/nabeelfkhan/Alexa-Hearthstone
Exactly. Just like tapping into the active playback device. Do you think that's possible?
Neat!
If you publish, make the maintenance/bug fix plan explicit. If you're just releasing the code, be clear about that in the readme. 
Yes. That is exactly the reason I am thinking of using SQLite. Thanks for the scenarios suggested. I am sure that some cool info that I didn't know about my shopping habits will emerge from this. As far as detailed statement is concerned, well I am currently classifying it on the basis of merchant names. This will then be split into categories like entertainment (theatres), grocery, telephone, fuel etc. 
Pickle is fine, it's just not to be used for communicating with *untrusted* parties. It supports arbitrary Python objects; you rarely need to develop your own serialization/deserialization methods. If your objects exclusively are made up of ints, floats, strings, lists, and dicts (not uncommon) JSON happens to be faster (but you're sacrificing versatility). Celery used to use pickle by default (&lt;4.0), which is OK because you're generally communicating with *your* workers. If your workers are untrusted, uhhh... Use the appropriate tool for the job. If you lift up a lawn mower to trim the hedge, don't be surprised when it cuts your fingers off. It's still a good lawn mower.
I'm a little curious why they (the context locals) "have to be somewhere". I've written a few protocols and find that most of them have the request in some sort of other closure, making them inaccessible. I'm not super familiar with WSGI - but I'd guess that's true too and that middleware could be implemented differently. I often use flask because it's dead simple and most devs can get up and running in a small codebase within an hour or so. Can anyone shed some light on this (why there is the assertion that there will be some form of context local always)?
&gt; One reason was that I saw a lot of people using perl without really understanding it. I think this is key. Perl seems to be criticized quite a lot by people who have little expertise in the language. You can blame Larry Wall for making Perl sound easier to learn than it is, and you can blame Perl for being difficult to learn, but it doesn't make sense to blame Perl for being, e.g., "write only" or "unmaintainable" or "too clever" if you don't know half the language to begin with.
Do you know if the answers to the lab "tasks" are posted anywhere? Or any walkthroughs that show how to properly code the tasks? 
/r/sadcringe For real though; If you are posting your code directly in a post, use the code formatting (put 4 spaces before each line of code). Or just do as the rest of us and use http://pastebin.com/ or GitHub. Congrats and welcome to the Py Community :) 
This is intriguing... Made any headway so far? Also, what model of speaker is it? 
&gt; Napoleon style docstring https://sphinxcontrib-napoleon.readthedocs.io/en/latest/ I think def func(arg1, arg2): """Summary line. Extended description of function. Args: arg1 (int): Description of arg1 arg2 (str): Description of arg2 Returns: bool: Description of return value """ return True
I can't stress reading docs enough. It's frustrating when you just need to know how to do X, but documentation usually covers things you didn't realize you needed to know. 
What do you mean by 'sharp'?
&gt; This is bad design, because 1) it makes module imports effectful (importing the module has side effects beyond defining classes, functions and constants) Fair critique, but almost every framework does that because its a huge shortcut. Most likely you don't ever have two versions of your framework running at the same time in the same process space. In the past, this was really a bad practice because we relied on threads for concurrency, meaning that global objects were a sore spot (e.g. you now can't run different sites on the same server instance). Today, though, threading via forking is more common, so a global object in a framework isn't as painful to deal with. Examples of global defaults: - The event loop in Tornado will get a global default, unless you specifically request not to. - Django uses a global settings object - Most database connectors have a global socket pool, you have to specifically create your own pool if you want it differently. &gt; import * Yes that is pretty bad, it's mitigated a bit if you have an *__ all __* statement to declare that only specific things are included in the default export. That keeps your imports from leaking out, so you can change your dependencies and internal structure while exposing the same API version to version. Apart from that.... you're mostly critiquing comments, which well is fair... but my commenting standards wouldn't come down as hard on them as you do.
... I know this mate. That's why I told you that you need to add 4 spaces before each line in your original post. When you write a reply, use the "live preview" under your post to see what it will look like when you submit it! Also, a helpful tip is to click on the "formatting help" link under the text box of the reply. It will show you how to properly format your text :)
I don't know why either. There's nothing in there that would be terribly hard to do in Python 3 as well.
&gt; I don't think it is bad using global variables when you know what you're doing Considering we're discussing the elegance of your code, could you elaborate on 'know what you're doing'. What are you doing that makes a global a good choice here? Why does it result in more elegant code than the obvious other choice?
Selected quotes from the author: &gt; Now you know what i meant. &gt; feel free to open an issue with all aspects of it that you don't agree &gt; Like, take a look at the source. He sounds casual and rude, so I'd suggest not wasting too much effort here on code review.
Pickle is the oldest or only serialization format that handles recursive or circular references. It uses it's own internal weak ref mechanism.
I've seen closures implemented as context-locals, e.g. Squeak Smalltalk.
I'm not necessarily a huge fan of annotating function signatures with type-hints, yet at least. I do find that this type-annotation formalism is hugely useful in documentation though. Be it in napoleon or numpy-styled docstrings. E.g. """ Parameters ------------ x : Dict[str, Real] Returns --------- Tuple[float, ...] """ 
I didn't do the tutorial. The title is clear "Intro tutorial...". Even the tutorial says that the random data generate is for teaching purposes. Good luck my friend, this tutorial is for people that are beginners.
Nope, big waste of time. 
You can build weakrefs by simply applying an appropriate convention within pretty much any other serialization format.
SimulateMe! KierkegaardExpress
This issue may be better suited to be asked in the python irc chat https://www.python.org/community/
The content on websockets was reasoned and well-thought-out (including the comments on scaling a websocket server). I think I appreciated that part of the talk most of all because they come from someone who obviously thinks of the big picture in addition to the implementation details (although I was somewhat surprised to hear the comment that "websockets are dying a slow, weird death", even if I found the argument compelling in the end). I have also lately been interested in Rust, so it was interesting to hear his take on the state of the Rust ecosystem (seems like a new web framework gets created in the Rust world every month, though....). Good talk, /u/mitsuhiko 
Is this done with the Alexa Skill Set? I was googling around to get some better info but that's all I found, kind of interested in looking into this.
No, it is not. Whenever I check any python code on Github the lack of any docstring is awful. The typehints are cheaper way how to self-documenting function, not to say you can have new scope of safety if you are using mypy properly. 
Your version +7 loc. Mypy version +0 loc: def foo(x: Dict[str, float]) -&gt; Tuple[float, ...]: pass I prefer the latter. Plus auto-completion works way better for Mypy type annotations. It's much easier and faster to write them down.
Having a standard style is nice. Compare @return: dict mapping strings to ints @returns: dict mapping strings to ints @returns dict mapping strings to ints :returns: dict mapping strings to ints :rtype: dict Returns a dict Returns a dictionary Returns a dictionary mapping strs to ints. Returns a dict mapping strs to ints. Return a dict mapping str to int. Return {str: int} Returns: dict mapping strs to ints def foo() -&gt; Dict[Str, Int]: 
I have seen some awful Perl. One time, someone didn't understand array references, to pass the arrays to subroutines. The lead told him it was too complicated **!!!1**, so the dev came up an atrocious workaround with globals. This was before I started at the job, else I would have explained. Meantime the lead disappeared to greater things, leaving a huge pile of technical debt behind. I cleaned a few things up, especially some awful performance bottlenecks that an hour of thinking could have avoided. Anyway, the point here is that Perl gets it's bad rep from things like this. Moose has gone a long way to clean things up. Read *Higher Order Perl* to get an idea of what Perl can do. Effectiveness with Perl requires diligence and constant exposure, in a way that Python doesn't.
I've already said there's a lot of bad Perl, but how long did you put in to learn the Perl. It's a rough language to start from zero, even for experienced people.
&gt; synchronous The idea is that the server that sits above WSGI, like Apache or nginx or others, handles the parallelism. 
I wish they would use some sort of type annotations for the official documentation. I find it annoying that I have to read the text to find out what a function takes/returns. Sometime I'm not even certain after I read it...
Geeqie http://www.geeqie.org has a built-in duplicate finding tool, even by level of similarity. But it's a gui application, not a library. Hope this helps.
Edit 2: Fastest way for exact duplicates. After some testing, I have found the fastest way is not just a hash map, but to first do a size compare. The testing code: import os import reusables @reusables.time_it(message="first way took {0:.2f} seconds") def first_way(directory): dups = [] for file in reusables.find_all_files_generator(directory): dd = sorted(reusables.dup_finder_generator(file, directory)) if len(dd) &gt; 1: if dd not in dups: dups.append(dd) return(dups) @reusables.time_it(message="hash map took {0:.2f} seconds") def hash_map(directory): hashes = {} for file in reusables.find_all_files_generator(directory): file_hash = reusables.file_hash(file) if file_hash not in hashes: hashes[file_hash] = [file] else: hashes[file_hash].append(file) return [v for v in hashes.values() if len(v) &gt; 1] @reusables.time_it(message="size map took {0:.2f} seconds") def size_map(directory): sizes = {} for file in reusables.find_all_files_generator(directory): file_size = os.path.getsize(file) if file_size not in sizes: sizes[file_size] = [file] else: sizes[file_size].append(file) size_matches = [v for v in sizes.values() if len(v) &gt; 1] hashes = {} for possible_dups in size_matches: for dd in possible_dups: file_hash = reusables.file_hash(dd) if file_hash not in hashes: hashes[file_hash] = [dd] else: hashes[file_hash].append(dd) return [v for v in hashes.values() if len(v) &gt; 1] if __name__ == '__main__': path = "My_Pictures" sm_results = size_map(path) print(len(sm_results), sm_results) hm_results = hash_map(path) print(len(hm_results), hm_results) fw_results = first_way(path) print(len(fw_results), fw_results) assert sm_results == hm_results == fw_results Results: pypy2-v5.4.1 - Windows 10 8.88 GB - SSD 2008 image files, 1565 folders 56 dups size map took 4.36 seconds hash map took 25.32 seconds first way took 359.54 seconds 119GB - SSD 65757 image files, 30075 folders 3511 dups size map took 55.71 seconds hash map took 843.70 seconds ....still waiting on first way to complete So I would use the size one first as it's fastest and just as accurate (as it does hashes as well, but only on those matching size). Original post: Code was written for finding dups of a single file fastest, not all in directory Hey, I actually wrote code for this and have it in a PyPI repo, [Reusables](http://reusables.readthedocs.io/en/latest/reusables.html#reusables.reusables.dup_finder_generator). To search for dups of every image, you'd have to loop over all of them, then run this against each. (Headed to bed now, but can answer any questions / give better example in the morning) Edit: example import reusables path = "C:\\Users\\Me\\Pictures\\Exports" dups = [] for file in reusables.find_all_files_generator(path, ext=reusables.exts.pictures): for possible_dup in reusables.dup_finder_generator(file, path): if possible_dup != file: # As the checking file is in same directory, don't add again dups.append(possible_dup) # dups == ['C:\\Users\\Me\\Pictures\\Exports\\DSC_0052.jpg', 'C:\\Users\\Me\\Pictures\\Exports\\DSC_0052 - Copy.jpg', 'C:\\Users\\Me\\Pictures\\Exports\\DSC_0742.jpg', 'C:\\Users\\Me\\Pictures\\Exports\\DSC_0742 - Copy.jpg'] 
Yes. I won't be likely to do any maintenance. Well, I might keep it running, since we are using it at home... but it's not likely.
I don't have figures on it, but it was designed with speed it mind. Hence why it has a three step approach ( first checks file size, then if that matches first few bytes, and if both those match do a direct hash compare). 
For dups, I use a dict with key the hash (sha*) val and value the list of paths with coincident files It works linear
import numbers
&gt; :returns: dict mapping strings to ints &gt; :rtype: dict Well that's why you don't like it :) I've been using `numpydoc`: def foo(): """ Does something cool. Returns ------- dict_obj : Dict[key : value] key : str the key name value : int the value array_obj : (n, ) float ndarray the length of each element some_boolean : bool; default=False does something boolean like """ `numpydoc` is slighly more verbose, but it's actually valid Sphinx. It works on all active Python versions, works well in code (unlike that colon nonsense), HTML (like that nonsense), and `help(...)` (again unlike that nonsense. You can make it super clean about data lengths and write paragraphs if you want. The standard sphinx style is meh.
&gt; I honestly don't understand the *craze* over type hinting. Overdoing it a bit? ;-) I had never felt I needed it, yet I've decided to give it a go and it's really helpful when browsing code I've found. It does make reading code a bit slower but it helps its comprehension so, for now, it's a win for me. It doesn't prevent from explaining in a docstring *why* you could have None vs an empty string for instance. 
Python also has `os.system`, which I believe behaves just like the Ruby equivalent.
I had only a few days (maybe a week or a little more) to finish the task, so I didn't really have the time to actually sit down and learn it from scratch. I am not saying Perl is a bad language, because I don't have experience enough with it. It is however one of the few times I've read source code and actually been really confused about what a line of code is doing.
thank you, I read a lot of recommendations to use `subprocess` over `os()`/`os.system`, do you know why?
Wow that article is really interesting. I'm definitely now considering doing something similar. Got any more resources you are using?
Types make ok documentation. Some type systems make for phenomenal documentation, but Python's isn't really there, so: they make *ok* documentation. You still need to supplement the type annotations with real docs. The real advantage to using type hinting is being able to use a static analyzer to ensure your program does what you think it does. Tests can do this too, but type hints are often much easier for at least some classes of problems. Think of it like a linter on steroids.
Since they are not enforced, you can duck them all if you want by passing your big duck in any entry you wish. The only problem with duck typing right now is that if you use mypy, there is still no support for implicit interfaces such as dudder methods.
You are in your shell, you do stuff, you pickle them, you save them. Come back tomorrow, pick up your shell session where you left it.
You probably don't have OpenSSL headers installed, so it can't build the `ssl` modules. Install headers for a recent enough OpenSSL version and rebuilt Python.
Before going to a concert i used to go and find a band's more recent setlists, so I ended up making http://www.setlistplaylist.com/
What exactly do you mean by statistics machines? Python has the SciPy stack (Scipy, Numpy, Matplotlib, Sklearn, etc.) and is one of the best languages you can use for easy data analysis. The other good language would be R. If you're just looking to make something to store and display your data (CRUD), then it really doesn't matter.
Why not ansible? It uses paramiko under the hood.
Use zabbix: http://www.zabbix.com/
You can compile it from source if you want. `pip install lxml` should do it automatically, assuming you have all the dependencies installed.
For future use, OP, this probably belongs in /r/learnpython.
Yeah, right. Looking at your posts shows you CCCLLLEEEAAARRRLLLYYYY are qualified to judge. LOL You can't even use google. Or think you're above it. Your ignorance isn't a strength. :D
Fixing python code written by developers whose primary language is C.
When you don't like Python errors so you hide them as stdout errors!
You should probably mention what is you use. 
You should consider using a monitoring tool, such as NetXMS or Zabbix. 
If you want to talk small scripts, I‚Äôd recommend using Python 3 for new scripts only, for the reasons you stated. ‚Äú**I** don‚Äôt see reason to switch‚Äù implies that you don‚Äôt write new ones in Python 3. (Different story if you really meant ‚ÄúI don‚Äôt see reason to port my existing things, but will write new scripts in Python 3‚Äù) But using an obsolete and dying language version for new scripts, or for continuously updated larger programs isn‚Äôt a decision that can be motivated by anything but religious arguments
For image hashing (i.e. To find images that look similar but aren't byte exact dupes) take a look at https://pypi.python.org/pypi/ImageHash
Use [ImageHash](https://github.com/JohannesBuchner/imagehash), specifically pHash. You can then use `hash1 - hash2` to calculate the Hemming distance (I think) between the 2 hashes and gauge their similarity to each other. I've done this myself and it can be quite fast in processing 140k images when running the code on multiple cores (concurrent.futures.MultiProcessExecutor); however it'll still be a matter of minutes. Another library you might find useful is: [python-magic](https://github.com/ahupp/python-magic), so you can inspect the file's mimetype before attempting to calculate the pHash of a non-image file.
/r/learnpython is probably a better goto for this, but [here](https://pillow.readthedocs.io/en/3.3.x/reference/ImageDraw.html#functions) is what you need. `PIL.ImageDraw.Draw` is the class. `PIL.ImageDraw.Draw.rectangle` and `PIL.ImageDraw.Draw.text` should do what you need. I've never used them myself, I just Googled the question for you because I'm getting paid right now anyway.
Heh. You mean "the vast majority of the world"?
https://github.com/bitcraft/PyTMX http://pygame.org/project-Tiled+TMX+Loader-2036-.html import pygame from pytmx import load_pygame
seriously, we need to get ride of all the HTTP_USER_AGENT, PATH_INFO crap! a simpler interface like def handle_url(request, response) would be much better. You can do whatever synch/async you want.
Another way to do this is by using PyAudio with WASAPI loopback mode, implemented [here] (https://github.com/intxcc/pyaudio_portaudio/blob/master/README.md). I've been working on something similar to this (Changing Philips Hue colour depending on the current chord in any music playing) and finding this has been the most difficult part of the project so far, hopefully it'll be included in a future update of PyAudio or SoundDevice. 
&gt; I'm a little curious why they (the context locals) "have to be somewhere". Because that's just a requirement that comes up in practice. You have this issue everywhere sooner or later. Security contexts are a good example, locale information etc. By default those are often process bound but you cannot isolate individual web requests into processes so you need to elevate that into contextual information.
You don't find list.index(x [, start[, end]]) dict.update([other]) to be informative and beautiful? ;)
Don't learn Julia, if you want to learn functional, use Haskell, or even Scala (if you're jvm restricted). If you want stats, use R. If you want both, but to a lesser degree, go python. 
You should install python 3.6 from your package manager 
"Instead of using a simple lifetime average, Udemy calculates a course's star rating by considering a number of different factors such as the number of ratings, the age of ratings, and the likelihood of fraudulent ratings." Pops up if you hover over the rating
Good question, and perfect question for /r/learnpython! ;) 
Yes! 
I have a script with user input and output that I usually run locally. I want to make it available to others to run so trying to host the script on Heroku. Right now, I have a Python script, a Procfile and a requirements.txt file. 1. The Python script is pretty complex but here's a simple example of what it does: message = raw_input("Please paste the tweet you'd like to send: ") if 'example' in message: print 'thanks for your help :)' 2. Procfile looks like this: web: python the_above_pyfile.py I basically want the script to run as a webapp, with the user supplying the input and then seeing the output. Let me know what else I can provide. 
Sweet. I will give Flask a try. Thank you!
I liked your phrasing "we are just going to embrace the hell out of them" :) thanks for the reply and the work in Flask (and associated libs). I see what you mean, even if many things may not need to be, something like "current user" (security context item) may need to be threadlocal eventually anyway. Having to manually pass many of those around would be annoying, and probably result in a lot of less than obvious code (I've seen this a lot elsewhere, just never written a full framework for others to consume so didn't bump up against the stuff you have already).
What's your actual use case for wanting to generate assembly? Depending on what you want, maybe you could take a look at: http://llvmlite.pydata.org/en/latest/ instead...
As a non-professional programmer I only have a vague idea of what functional means and therefore I have no idea if I need to learn it or not. In the short time I tried Julia I was able to translate a Python class into the equivalent Julia type and the only major difference was that methods were defined outside the type which seems a bit strange, but not exactly a show stopper (unless I'm missing something obvious).
Can we see an example of the data? 
Sorry, I think I haven't expressed myself properly. These are some examples of what the program would return in each case: - "ATTAGU" return False (U isn't a right letter) - "AAA", "AAAA" and "AAAAA" all return {'AAA': [0]} - """ aaatttaa AACTTTTA""" return {'ACT': [9], 'AAA': [0, 6], 'TTT': [3, 12]} I think the way to solve this is by creating a dictionary with the positions of the letters as the values. 
You cannot use the triplet as index because they are repeated, so your better choice is probably to have the codons as indices: {1000:'GCU',1001:'ACG',1002:'GAG',1003:'GCU'} In the above example, if you used the bases as key then GCU would appear only once instead of twice. 
You're missing a colon after `else`. Also, post in /r/learnpython next time, and insert your code as code, not as an image.
Do you use r? 
Type checking in large programs. It doesn't matter how well one documentes their code; at some point, someone (usually the same person) will do something stupid (forget a potential None value, etc.), and the code will crash and burn. **SOURCE:** I'm the "someone".
Yeah, currently working my way through a programming course in VBA. I wish the language got an update every now and again, but truth be told, it does what it needs to do.
This is being a little bit facetious mostly because I have a hard time believing this is really a problem: how did you get by with the past 26 years without type checking in python? 
Because serializable datetime and classes.
At this point there are too many financial firms in love with it for VBA to die, at least until someone writes an Excel replacement that has an in-built Python interpreter.
Nice writeup &amp; beautiful viz! Do you have the code public somewhere? I'd love to poke around at it
Ahh, who was the competitor?
Flask is the simplest solution, but combined with Heroku it can get a bit confusing. I just did a similar thing where I had a local app transformed into a web app with minimal interface. There were, of course, some problems. Reply if you need any guidance along the way!
I have Synaptic Package Manager, but for some reason it thinks that the latest available version for anything named "python3.6" is 3.6.0~b2-1, i.e. a beta.
[`subprocess.run`](https://docs.python.org/3/library/subprocess.html#subprocess.run) is much more flexible than cheap interfaces like `system`. I used Ruby exactly once (i wrote a Rakefile since make wasn't powerful enough), and had to use open3 instead of system.
I haven't had any issues with html.parser myself, and it seems not to have the random issues lxml does. For simple things I didn't noticed a performance difference between them but in a larger project it may be more apparent.
Yeah that's fine, nothing really changed in the release. The full release will trickle through when debian and Ubuntu are ready 
This post is better suited for r/learnpython
As us with jailbreaks have learned, Snapchat are really cutting down on this kind of thing. Anything that strays from the official, unmodified app gets banned almost straight away now. They're making it really hard. If you do find a way I wouldn't expect it to last more than a handful of times. 
Linux distros? Ubuntu, the biggest distro, ships 3.x now by default. Additionally, in my experience, distro python is really for use by the system alone. Development should be done in some kind of segregated environment like venv or docker or both. So you don't like that existing 2.7 code must be ported. Never mind that many years have been given for that migration to occur-- What about new development? What does Python 3 that conflicts so terribly with your use case? 
I'd use [HDF5](http://www.h5py.org) in this case.
Thank you for your reply but unfortunately it doesn't cover the queries I've raised
The winky-face in my comment indicated that I agree with you and that I was being facetious
ok, but this is the thing, with `subprocess`, I need to write 5 lines for one shell command and import a library , also I could not find a way to see the `stdout` in real time, not sure if I wrong or not, or maybe this is how python works.
`os.system` returns the exit code.
That does what? How does it integrate with the rest of your app?
I find flask a joy to work with on heroku. I'm curious what problems you ran into. One tip I have is to set a runtime.txt file to ensure your python version is the same as what you are using on your development machine. 
You can plug in other parsers too, I think the [html5lib](http://lxml.de/html5parser.html) one may be what you're looking for.
great aswer +=" /r/learnpython is for questions"
`conda install -c anaconda pyqt=5.6.0`
I'm waiting for PyPy to support 3.5 and be as fast as their 2.7 implementation. 
Then maybe for Windows then
One of the many nice things about Pickle is that it's self-delimiting. I was doing an ML project in college a few years ago, and I ended up implementing it as a unix pipeline using pickle. Each message I wanted to send from one component to the next was picked, which meant that I could write a handler like this: def read_messages(stream=sys.stdin): try: while True: yield pickle.load(stream) except EOFError: pass def write_messages(messages, stream=sys.stdout): for msg in messages: pickle.dump(msg, stream, protocol=4) # Decorators def stream_reader(func): def wrapper(*args, istr=sys.stdin, **kwargs): return func(read_messages(istr), *args, **kwargs) return wrapper def stream_writer(func): def wrapper(*args, ostr=sys.stdout, **kwargs): write_messages(func(*args, **kwargs), ostr) return wrapper def stream_handler(func): return stream_writer(stream_reader(func)) def message_handler(func): @stream_handler def wrapper(messages, *args, **kwargs): for msg in messages: yield func(msg, *args, **kwargs) return wrapper
This is how I first came to appreciate Python. I was helping a start-up come up with a software stack, and a major component of this involved performing a survey of programming languages, talking to someone of standing in their communities, etc. When I saw an example of Python code (after already having been through this process with Perl and C++), I exclaimed, "Oh my God! That's Python code? I think I know what that does!" I was able to understand about 95% of the code example despite never having seen a line of Python code before, which was certainly *not* the case for the other languages I looked at that I wasn't familiar with. That got me personally interested in Python.
&gt; Perl is a beautiful language If it was a beautiful language, people wouldn't joke about it looking like a cat walked across the keyboard. 
Indeed it is! `shelve` is one of my favorite hidden gems of python.
Generating tokens for a whole suite of internal web/mobile apps we're developing for a client and handling requests for information from their databases for said apps. We initially started out using Node, but they wanted something their analysts could extend if need be, and they're all proficient in Python. Javascript, not so much.
Under those circumstances, and if you had a clear spec for what was needed, you made the right decision. Perl is a very dense language if written that way. Sometimes that good, just as APL had things going for it as well. I'll admit I don't use it much any more and in the industry as a whole, there aren't too many new project starts using Perl any more.
I used to work at a company where we stuffed a complete 802.16d WiMAX Base Station network stack implemented as kernel drivers along a bunch of userspace (busybox), CoAP management app and a simple Web UI, all in ~5MB compressed image. The would boot directly to initramfs, hence no extra rootfs partition was needed. User data &amp; config was stored in a small jffs2 partition (~4MB of flash). The whole board had 16MB of NAND flash (dual kernel+rootfs image, single data partition), 64MB of RAM, all controlled by a dated IXP425 ;) 
- Using Python for large projects has mostly started within the last decade or so. - You can definitely get by *without* type checking. It just makes things easier.
Very cool! I might want to try to build this for myself. Which LEDs exactly did you use for that demo? I was looking at the 144 lights/meter strips from Adafruit and they seemed pretty expensive. What density and how many did you have?
I don't feel like getting into yet another argument about this topic. For me the root of the issue already starts here: &gt; To test your view functions, you need to set up the thread local context in tests. This is just an unnecessary complication, since you could simply pass a request argument to the view instead. At this point you simplified your view to the point where apparently the general state does not need to be properly configured. eg: locals not configured, security contexts not set etc. This is generally often not what works anyways. For instance Django needs to manage the database for tests as well so there is typically a custom test class you need to use which manages those things for you. Just because you don't see it does not mean the framework does not have to do it. As an aside, we're literally only talking about this syntactical difference for a test here: app = make_app() with app.test_request_context(): call_my_view() vs app = make_app() test_request = app.make_test_request() call_my_view(test_request) Not really seeing one being significantly harder or easier than the other (just that the non with statement version clearly does not manage resources)
I think the problem is not the new-style string format, every input or output must be sanitized if you want keep it safe. If somebody has access to execute a script you already are vulnerable. It's one more thing to escape :/ This CTF questions show how to access python base class easily https://hexplo.it/escaping-the-csawctf-python-sandbox/
okay, but this will install pyqt inside the anaconda version, right ? not inside my other python instalation (from the python website) ?
Interface looks super clean and definitely like how it abstracts the problem to a clean specification to the end user. It seems like there is a lot of overlap between what this is trying to do and what [Dask](http://dask.pydata.org/en/latest/delayed-overview.html) does. The difference is that it appears that Dask can specify operations at a lower level than a task because it includes declarations of data operations. It also addresses [distribution of the work](https://distributed.readthedocs.io/en/latest/quickstart.html). I don't think that the generic task-based interface for Dask is quite as nice as this one though.
This really bothers me for some reason: if attr[:1] == '_': why not the very clear: if attr.startswith('_'): 
hey sounds like fun! i do that too :p
I recommend [DuckDNS](https://duckdns.org). I've been using it for quite a while and it's always been rock steady. Free for life!
Find something boring and repetitive in your job. Python can most likely automate that for you.
Are you interested in the APIs for online services, or would code APIs in general interest you? Exploring them with [Hypothesis](https://hypothesis.readthedocs.io) can be very satisfying, in the latter case - you'll probably find some interesting bugs to report!
It totally does, I've used it where I'm in a hurry to do testing
I love Dask. I initially wanted to use it to solve a specific problem I was facing, but the abstraction was not quite rich enough for what I needed. My secret hope is that their team notices this and adopts a similar user-facing interface. It would be amazing to have this abstraction with their distributed technology. I wrote this because I really needed to manage local/global state as well as broadcasting/routing. 
Whoops, your right. We'll just say that was the first line in my index.html...
I'll check that out! Thanks for the recommendation. 
Like /u/novel_yet_trivial says, if you have more questions like this it's better to post them on /r/learnpython. But since we're here anyway, might as well keep all replies under one post. The function you want exists, but it's kind of hidden: it's the `consume()` function given as an example in the [itertools docs, section Recipes](https://docs.python.org/2/library/itertools.html#itertools-recipes). This consumes an iterator at C speed, without using extra memory to instantiate a list of ignored results. ---- On an unrelated note: the iterator that gives your input tokens is a piece of state -- a piece of state that your state-machine (for-loop) alters by discarding pieces of state when it encounters a given condition. It's just a function that takes a state, and returns a new state. In your example, the loop body is comparable to a function: old input state -&gt; new input state . As your code becomes more elaborate than your example, the loop body would become comparable to a function (old input state, old machine state) -&gt; (new input state, new machine state) Here is an example of implementing the stepping not as a loop body, but as a step function (with state-altering implemented as a side effect, rather than returning an altered copy of the state every time -- I don't think a step function that is pure (a step function without side effects) is worth it, here). Hope this helps! import collections import itertools from typing import Iterator # Defining Token = str lets us tell the mypy typechecker that some of # our functions expect/return a Token type -- in our case, a string. Token = str # Use recipe from here: # https://docs.python.org/3/library/itertools.html#itertools-recipes def consume(iterator, n): """Advance the iterator n-steps ahead. If n is None, consume entirely.""" # Use functions that consume iterators at C speed. if n is None: # feed the entire iterator into a zero-length deque collections.deque(iterator, maxlen=0) else: # advance to the empty slice starting at position n next(itertools.islice(iterator, n, n), None) def step(state: Iterator[Token]) -&gt; Iterator[Token]: """Take action based on state, and return new state. Side effects: * may print characters * may alter the passed-in state object Doctests: &gt;&gt;&gt; list(step(iter('m123'))) ['3'] &gt;&gt;&gt; list(step(iter('n123'))) ['2', '3'] &gt;&gt;&gt; list(step(iter('abc'))) a ['b', 'c'] """ token = next(state) # Get the next token # Dispatch based on the token. if token == 'm': consume(state, 2) elif token == 'n': consume(state, 1) else: print(token) return(state) def play(init: str) -&gt; None: """Keep step()-ing until step(state) raises StopIteration &gt;&gt;&gt; play('some input') s o i u t """ state = iter(init) try: while True: state = step(state) except StopIteration: pass if __name__ == '__main__': # Run doctests import doctest doctest.testmod()
Everyone loves Selenium in action
Your method is faster than mine but it's the same principle. OP replied to me and said thy wanted something like a file object's `seek()`. I suspect OP is not using a string, but an iterator that has to do some computation for every item. 
As I have worked some with Luigi and Dask I've been starting to think about something a bit higher level built around dask. But yeah good job on the interface. Dask definitely comes from the scientific side so has a more task oriented ETL capability kind of as an afterthought, while you seem to come more from that side to begin with.
One script I made takes my credit card statement and groups total spending into different groups (food, entertainment, shopping etc) and prints out all the charges and totals so I can keep track of my spending. Try that yourself. There's also the classic beginner programmer, KXCD Downloader. You can add yours to the other thousand that exist haha
That's good advice. If someone wants to learn, but don't have any hard ideas, reinventing the wheel isn't a bad thing! When I wanted to learn about sockets and encryption, I made an encrypted chat application.
Thank you, appreciate the effort you went to.
A couple of suggestions: 1) in your sendEmail function, you have a try/except block. You should catch the specific error that gets thrown when there is problem sending the email. It makes more readable code and is super helpful for beginners to understand what is going on. 2) throw your private info (username/password) into a separate file. There are lots of libraries, like dotenv, or you can just import variables that you've saved into a different file. 3) this last one is a bit pedantic but you can use '''sleep_for = 60 * 10''' to represent 10 minutes. If you wanted to schedule it in terms of hours, you can just throw another "60" in there (i.e. '''sleep_for = 1 * 60 * 60''' is one hour) Pretty interesting tutorial overall, thanks for sharing. It is always nice to be reminded of the fun things you can do with Python :) 
Actually, it is a string, but yes, analysis has do be done at many places along the string and various different kinds of parsing then take place -- it's not uniform. It's a parser inside an extensive macro language. The Need For Speed is paramount, because this thing handles _lots_ of string information, and it needs to respond as close to "right now" as I can get Python to deliver. Very much appreciate the info provided (by all.)
Agreed. I'd imagine it's a pretty simple packet conversion. E.g. dyndns2 protocol. 
Python 3.6 *should* be faster again.
I haven't really explored the coding that goes into APIs but that does sound very interesting. Thank you!
https://bugs.python.org/issue26110 this issue can help you
The `dict` changes that Raymond Hettinger takes about in his talk, but I could totally be wrong about that.
Ah. Yeah that is definitely a big improvement. I thought you meant that 3.6 would be faster in this scenario
This might have what you need https://github.com/Zulko/moviepy
A nit to pick here: while True: if(requests.get('http://api.ipify.org/').status_code == 200): r = requests.get('http://api.ipify.org') if (ip == r.text): You are accessing the web site twice when you only need to do it once: while True: r = requests.get('http://api.ipify.org/') if(r.status_code == 200): if (ip == r.text): 
When we're talking about nanoseconds in the worst case, does it really matter that something is faster? Are nanoseconds worth less readable code?
The drive to and from is about all that's left that could be automated. If only a Python program could do my exercise and lose the Christmas pounds for me...
I probably wouldn't know if an existing app could be replicated with Python. There may be a very good reason it was written in Java or something else.
You're looking for /r/learnpython I recommend this though: http://automatetheboringstuff.com/
Meteorology, but not forecasting. I have a numerical model on the Linux side of my home PC, but our weather has been so utterly boring that I haven't run it since just after installing it. I've always used shell scripts to handle the output and produce graphics. I don't know if Python would just be a more difficult way to accomplish the same thing.
Thanks, I have automate the boring stuff. But that Book as I frisked thru was not explaining much about Classes as a concept, let alone inheritance and poly. But I think there are good examples how to solve some real life tasks.
It is useful to have it in the setup.py file so that the distributables you produce have the version number as part of their names. For example, requests-2.2.1-py2.py3-none-any.whl has 2.2.1 in the setup.py version attribute.
I'm modifying some code in the PySolFC project to add more game types and more configurations of existing types. (i.e. &gt;4 decks, n by m matrix games, and m-Peg, n-Row Hanoi puzzles, etc.)
This post is best suited for r/learnpython and r/learnprogramming 
No worries. Thanks anyway
Look into scrapy or Selenium for browser automation and scraping. Doing it via requests would be a ton of unnecessary work.
Maybe write a motivational Mobile App with Kivy. Something like a daily sports challenge thing with a point system.
Good luck. Happy new year!
Other solutions might include: generator expressions or list comprehensions (and family); or a recursive function that keeps stripping the first item from your iterator before passing the iterator to itself... any others (without important modules)? Python doesn't implement jump/goto which would work in other languages...
http://flask.pocoo.org/
One advantage of fstrings is that they only work on string literals so you can't use them on user input like this. The one place where they are vulnerable is in config files etc where a string literal is configured. 
Probably not a very useful answer, but if I had to do it I would treat this as two separate problems: generate the overlay (text + images for each frame if you want animations, which could be generated manually or programmatically) and embedding the overlay into the video using some library (what /u/Andrew_Shay shared seems to provide this kind of feature). The bottom line is that I don't think there is one python library that will let you do all of that out of the box. In any case good luck, this sounds like a fun project.
I have gotten into the habit of putting them into the \_\_init\_\_.py file and parsing them out in the setup.py and sphinx config file. That way it never has to be imported. with open(os.path.join("my_project", "__init__.py"), "r") as f: content = f.read() attrs = dict(re.findall(r"__([a-z]+)__ *= *['\"](.+)['\"]", content)) setup( version=attrs['version'], 
Thank you! Working with it now.
yeah. I personally learned a lot about hash tables by following the history of dictionaries in python.
Just realized.. I feel stupid now... ;)
Is there a way to get the object that is being iterated by the iterator, from the iterator? For example, if I am iterating through a dict, the iterator will give me the keys to my object, but not the values of those keys (I have to reference the object with that key to get the value) which seems to makes it less useful as a generic way of iterating through objects. Edit: set -&gt; dict 
Great, thanks for the tip. 
Wow. Won't solve your issues with grammar and spelling though. 
A bit vague references... Why particularly silicon and why particularly John Cleese... Better a Guido statue then.... 
Want feedback? - I/O-bound programs like this benefit tremendously from threading. - There is no good reason for writing brand new scripts like this in python2. (e.g. this one doesn't fundamentally rely on a python2-only library and python2 is EOL only ~3 years from now!) Also, you are missing out on a ton of great Python3 features (e.g. concurrent.futures would make adding a threadpool trivial to a program like this, Pathlib is far nicer than os.path IMHO, etc.) 
Yes, can and is used for this. Note though that I would always recommend fine tuning the sandbox further specific to the objects passed to it.
I don't think you need to close file handlers, but it certainly adds to the performance if you closed them manually. Also the with statement is not just used to close file handlers, it basically encapsulates a "try-except-finally" block, which can be useful in file operations since it's exception prone. More info here: http://effbot.org/zone/python-with-statement.htm
Depending on your needs it's fine to skip `with`, but there are some situations where it might bite you since the file will only be closed when the file object gets deleted whereas it's guaranteed to be closed on exit from a with block. CPython reference-counts objects so you could leak a file handle by including it in a reference cycle. Other VMs offer other ways to cause an open file to live longer than you'd expect, like PyPy's GC simply not running for a while because it's not under memory pressure. --- Since an open file is a limited resource (moreso than memory, at least), it's generally considered good practice to explicitly close them when you're done. But in most cases you'll never see an issue if you don't.
Python 2.7 only? Nah!
Yes. This is important. Good old `snprintf` from C has been exploited through a similar attack vector in the past, and similar problems are inherent to any kind of format string, really. In fact, Jinja itself has the same "problem", in the sense that passing user-supplied strings as templates opens up the same attack vectors, and probably more. The crux is that format strings are usually a minilanguage, and once it grows beyond trivial, keeping it sandboxed is really hard. Whenever I need to accept user-supplied strings as input, I generally use a custom formatter implementation that supports only a known-safe subset of the minilanguage. This can be as simple as a series of textual search-and-replace, but even one step up, with a proper lexer and a trivial parser and interpreter, isn't hard to implement - you only have two kinds of lexemes (literal text and interpolations), parsing is a no-op from there, and interpretation is a matter of "for each token: if literal then append as-is, else look up name in context and append stringified context value".
Thank you! I guess I am just not sure how things fit together. I have the Python script. So the next step is to figure out how to integrate it with Flask, which then links it to an HTML file I also have to make? Where does Heroku come in? 
To answer your question a with statement isn't needed but explicit is better than implicit.
&gt; CPython reference-counts objects so you could leak a file handle by including it in a reference cycle. CPython also includes a garbage collector, so no, a reference cycle generally won't prevent objects from being freed.
Yeah Heroku has a couple tutorials that cover python and gunicorn, but not one that puts them together for hosting flask. I might try to make a tutorial this evening.
Okay, here's your rough plan: Play around with Flask. It's super easy. You will only need one Flask function for the main path. The function will look like this: from flask import Flask from flask import render_template from flask import request app = Flask(__name__) @app.route("/", methods=['GET', 'POST']) def application(): answer = logic("example input") return answer if __name__ == "__main__": app.run() Where the `answer` is just a string. Try running that and see if you get the bland web page with your answer in the top left corner. Works? Great. Now onto the next challenge. Instead of rendering the string we want something a little bit more pretty with an input form. We need to render a template. Creating a template is super easy if you know HTML. It's not just HTML though, it can have some Jinja functionality - integration with Python. Create a folder called `templates` and create `main.html` there. Inside it will be something like this: &lt;div class=page&gt; &lt;h1&gt;My App&lt;/h1&gt; &lt;p&gt;Enter your text: &lt;/p&gt; &lt;form method="POST"&gt; &lt;label&gt; &lt;input type="text" name="input"&gt; &lt;/label&gt; &lt;/form&gt; {% if answer is not none: %} &lt;p&gt;&lt;label name='answer'&gt;Answer is: {{ answer }}&lt;/label&gt;&lt;/p&gt; {% endif %} &lt;/div&gt; Here you can see Jinja code where the `{%` and `%}` are. It does what you think it does. Also, between the `{{ }}` are variable names that the template gets when `render_template` is called with kwargs, we will see that in action later. (Tip: you can add this `app.jinja_env.line_statement_prefix = '#'` and just use `#` ( or any other prefix) once before a statement instead of having to do `{%` and `%}` every damn time.) Now back to your app.py file - first we'll check if there is any input from the form. answer = None if request.method == "POST": raw_input = request.form["input"] check_input_for_errors(raw_input) answer = logic(raw_input) Now you can also add `return render_template('main.html', answer=answer)` at the very end (not in the `if` block and not in an `else` block! Just at the end of the function.) This way the template will be rendered dynamically and your answer will be shown. I hope everything's clear up to this point and I haven't missed anything important. Now to Heroku. Deploying is the easy part - there's lots of tutorials, you can do it from the command line (Ruby installation required) or just deploy from Github (which is what I do). I won't cover that. Preparation is what's confusing. * Create a `requirements.txt` file with each module you need written on a newline. Also add `gunicorn` - we will need it later. * Add a `runtime.txt` file and put you python version in there (ex.: `python-3.5.2`) It will default to Python 2.7 otherwise. * Create a file called `Procfile`. No extension. Capital `P`. Add `web: gunicorn app:app`. I hope your main python file is called `app.py` because I am not sure whether the right `app` or the left one has to be changed :D Next you can add a `static` folder and put your .css files and fonts there for extra bling. Edit the main.html to use them. That's it! Hope everything worked out. Reply if you get errors because I forgot something super important. Good luck. P.S.: If you want to clear something up, you can look at my github for an example [here](https://github.com/EdvardasDlugauskas/Derivative-app). Edit: not sure why but I couldn't get it to run with just `web: python my_file.py` in Procfile. Had to use gunicorn.
What's wrong with [pprint](https://docs.python.org/2/library/pprint.html)?
There's a builtin ORM, user with system, database management panel (if you've used PHPMyAdmin it's like this), file upload handler, forms, cache handlers, email client, a whole host of predefined class based views and mixins, and a bunch more stuff I'm not even aware of. Honestly, I think it includes too much but that's my opinion. 
Thanks for the resource! I will walk through it and PM if I am really stuck. 
You're confusing simplicity with shortness. Simple is the `with` block. It ensures that no matter what happens in that block, the file is closed (of course, you can just power off your computer in the middle of it and the with block can't do anything). Shortness is your second example where the file won't be closed until it's garbage collected or the program exits. Garbage collection is non-deterministic and programs aren't guaranteed you exit, so who knows when that file resource will be closed. It's not needed, but it does greatly simplify ensuring an open file is closed. There are probably cases, few and far between, where opening a file using a `with` block is actually more trouble than just opening and closing it yourself. 
You surely must have meant your issues with my "sometimes not giving a flying fuck", dear preacher. EDIT: My language uses diacritics. I don't use them (*1) unless it's: documentation/book/publication. *1) and can "back it up" as practically unnecessary, mentioning researches, not using diacritics and still being legible-enough ;-))) Since I'm not a PR person, but a valued specialist, it just slides ;-p
I make no promises about speed --- but if your input is a string, perhaps this architecture is what you're looking for? Yet again, this solution was already suggested by novel_yet_trivial, so credit goes to them. def parse(string): i = 0 while True: token = string[i] if token == 'x': i = i + 12 # Every branch should end with an appropriate changing of the # state; in this case, just the seek index `i`. else: i = 12 I suspect all these solutions are not extremely different in speed. Perhaps you could first make a prototype, then profile it, and then make the slow parts fast? It wouldn't do to get bogged down in micro-optimizations at the expense of progress. I'm not saying that you are, just that that would be my personal pitfall.
- Django ORM / flask-sqlalchemy - Django migrations / flask-migrate - Django admin / flask-admin - Django forms / wtforms &amp; wtforms-alchemy - Django auth / flask-login - Django management / flask-manage - Django email / flask-mail - Django cache / flask-cache - Django internationalization / flask-babel In flask, you have to install all these third party extensions vs in django it's already included.
For sure, I think f-strings are a good direction, especially since they offer the fastest string interpolation &amp; perhaps can help take out specialized string checking in BINARY_MODULUS. The code snippet was more some idea on how to get user driven f-strings (x is assumed to be a string)
if you don't want to worry with nginx, see https://github.com/evansd/whitenoise and django-rednoise. 
What is exactly happening when a file handle leaks and what problems can it cause? 
I created https://github.com/kootenpv/just for this. It uses with internally. Main target is data scientists, it's in an early stage and not "really" public yet.
I don't know if Django is so much more popular than Flask. Flask has much more stars than django on github. That fact doesn't sound like it's less popular. 
I actually prefer nginx, it's never let me down. In this case I'm simply using it as a buffer between the django dev server and the wild nasty internet. There's little static content being served, mostly templates. 
because I'm lazy
I have not used airflow, but I've heard good things. I think probably the biggest difference between consecution and projects like airflow is simplicity. Just pip install with pure python, and you can immediately begin building pipelines. This, however, comes at quite a cost when compared to other pipelining tools. Namely, consecution is synchronous and does not yet have any capability for parallel processing. If you genuinely need to process "big data", then consecution is probably not for you. As I mentioned above, my hope is that the consecution interface is intuitive and simple enough that some of the more established parallel/scalable tools will adopt something similar.
I care about AsciiDoc. I use it quite a bit, and I find it much easier to deal with than Markdown. I have also been worried about the Python 3 port. I have thought about working on the port myself, but there is always the problem with the insufficient number of hours in the day.
Wouldn't changing pitch be exactly what you want to do? Lowering it when speeding audio up and raising it when slowing it down? Its just a matter of determining *how much* it needs to be raised or lowered based on how much you are speeding it up or slowing it down. Keep in mind that once you start speeding or slowing the clip down a lot it will sound strange regardless of how you try to correct the pitch.
Looks nice, but Python 3.7?
As Raymond would say, "You don't have one of those, do ya?" 
Classic. You're a sociopath, aren't you? In the former post it was clearly visible how emotional you were and now you try to hide/supress it like this. You may have the last word. You really need it anyway.
This really only makes sense if you assume that I can not write new stuff on an older language. Which is, of course, complete nonsense. In any case do I also see no reason to waste time talking about this. I don't identify with this stuff and I don't really care about what people think about stuff that's not their business. vOv
While true, this is a bit measleading. You could certainly do this without a `with` and with no leaks: fd = open('output.txt', 'w) fd.write(html_header) fd.write(html_body) 
Um, yes, but now the file stays open until the `fd` is garbage-collected (edit: or until you call fd.close() explicitly). Using `with`, the file is closed right at the end of the `with` block. And that was the point, no?
Thanks for the update, I thought it could have been a typo. Will definitely use the template in the future!
Great to hear! If you have any difficulty at all make sure to report back. Also if you do use the template and your project has an extended lifetime I'd recommend looking back at the template for changes or better support. :)
Yes, only python2.7 now. Because a string representation of objects, containing strings with non ascii symbols within, is painful. In python3 it's all ok. So version for python3 will be implemented later as a compatibility layer.
You define host groups in the inventory file and then run: ansible all -m command -a "command to run" Dunno for sure if the syntax is ok, but it looks something like that.
This is so timely for a data science course I'm taking, thank you so much!
I wanted to squeeze it all in one but it would have been a much longer and less focused post. I'm hoping to write another blog post on those soon on the interesting properties of iterators and link the two at that point. :)
This post is better suited for r/learnpython
I love this. Thank you!
Dont push yourself too hard. "Back to Fallout" is a good and valid choice.
Most of what you need is already compatible with Python 3. There isn't much difference between the two, in my opinion. You are better off with Python 3 because it is the most recent, the most updated, and 2.7.x won't be getting new patches soon.
Download the latest version of anaconda from here for python 3.5 https://www.continuum.io/downloads They should have 3.6 soon but 3.5 is fine. Anaconda is basically python packaged with some common libraries and tools. It's much easier to start with
Just learning? START WITH 3.5.2 or later!!! Then you will be working with the most recent forms and standard lib, and won't have to unlearn old deprecated styles and syntax from Py2. (Even if you are doing this to eventually work on a Py2 project, learn Py3 first to get established with habits that will stick with you, then learn how to adapt your thinking to old-style Py2.)
[What's new in 3.7](https://docs.python.org/3.6/whatsnew/3.7.html) (hint: Not much yet). 
Yeah it's fantastic. It lets me do all the interactive work I want without the hackyness of notebooks or bugginess of Rodeo.
You are right :) I love the Ctrl+Alt+Enter. It is very handy.
Honestly if they just made it so you could assign multiple actions to a keybinding, I'd be the happiest man in the world. Ctrl+enter -&gt; execute line + cursor down = hnnnnnnggggg (basically I want it to be RStudio)
Do you mean something like this? https://marketplace.visualstudio.com/items?itemName=geddski.macros BTW, I dont know if this extension is good or not. Just tried **macro vscode** in Google :) But it seems doing exactly what you desire.
Stars/forks are one thing. How widespread it's use is, that's another matter. 
**choosing a non-pythonic API** is great sin against nature I guess. This is piece of cra... You made a valid point, Fry (quoted from Futurama) NOTE: My comment was ironic criticism of comment above. 
Having your project testing against the latest makes it so you don't have to guess whether something not listed in the change log will break your code! :) Like the no more unambiguous escapes in regexes!
not even a quick description of what this bot even does? edit: this bot just visits peoples profiles
*Very stupid answer alert* dunno, this is simpler to use for a person who is having their first contact with neural networks :)
If you leak the file handle the file stays open. Since OS file handles are a finite resource, leaking enough handles will make it impossible to open more.
If you look at OPs GitHub profile you'll see that this is his first open source project. Is this the way we welcome new project authors? By saying all they do is crap? There are ways to criticise without insulting people.
If Python could automate my search for glass, I'd be happy. Finding enough glass for my Asian-style settlement builds is a grind.
You should generally assume that you can get at anything using anything in Python if double underscores are allowed, and sometimes even if they aren't. You don't even need a user class instance. You can start with something as simple as `(0).__class__` 
OK, I started writing a PR but there's just way too much stuff for me to stay interested. In no particular order: 1) Make an *attempt* at getting *somewhere* near PEP8. Makes it easier for everyone else to read and write. That means: - `snake_case` for function, method and variable names - 4 spaces, no tabs for indentation - No semicolons - spaces around `=` for assignments, not for keyword arguments - more consistent spacing - a lot of your code is pretty cramped but then you have half a dozen linebreaks at a time where you only need one 2) If you're writing a comment explaining/labelling a single method, just put it in the docstring. Then it's available to users, not just developers. 3) Use `is None` instead of `== None` 4) You shouldn't declare instance variables as class variables, *especially* if they're mutable types (like lists). Just put them in the `__init__()`. If you append to a list declared as a class variable (i.e. outside a method), it'll change it for all instances of the class. 5) Don't call variables `input` or `file`, because these already mean something to the interpreter. It'll work but it'll confuse readers. By convention, avoid naming clashes by appending an underscore, but really it's better to just find a different name. 6) `if inputs in kwargs` works just as well, if not better than, `if inputs in kwargs.keys()`. The former is a hash lookup in O(1) where the latter is, I believe, an iteration in O(n). 7) `add` should be called something more descriptive, like `add_data`. 8) Always use a `with` statement for opening and closing files - no reason not to. 9) `for i in range(len(self.Synapse)): do_something(self.Synapse[i])` isn't necessary. Just do `for syn in self.Synapse: do_something(syn)`. If you end up needing the index as well, use `enumerate`. 10) For me, de-facto extending of tuples is a code smell - either use a list or figure out something else. 11) I strongly disagree with your strategy for saving and loading files. Having a temp file as an intermediary is asking for trouble (if you're going to use it, you should definitely be very clear that it's a temp file with the filename - you can then add that to your `.gitignore` - and give it a unique or at least random hash in the filename to avoid clashes). If you absolutely must go through `np.savetxt`, give it a StringIO object instead of a filename, then get the string from that so it's all done in memory. I don't really understand why you've gone for an arbitrarily-defined format which is a hodge-podge of json, csv and... HTML? If you care about human readability, use JSON, or maybe a compressed archive with a bunch of CSVs in it. If not, use something like HDF5, it's made for stuff like this. If you're using JSON, I recommend not capitalising key names.
You are obviously so much into programming that it would be pity to waste your time just by playing Fallout. What about [checkio.org](https://checkio.org)? You can play a game and learn Python in the same time. But I dont know about learning Chinese. :) 
Cool, I get that but I need to not just "run these commands on hosts" but I needed "run this command on host FROM inside a larger Python app" which is the key difference many (not just you) miss read. ssh itself or mosh or lots of things can do it, but all of them would require shelling out of Python and worrying about shell escaping, etc where this I just pass the command I want (as I would normally run it) to a function and done. 
no offense, but keras is already TOO simple for people with no knowledge of NN. this is one of those subjects where you really do need some idea what you're doing.
I would make the `pretty` argument default to `True` since that seems to be the main reason for using this.
I'm glad it was useful for you!
I've seen this comment before. Why do people get offended? Are people just tired of seeing it?
You could implement a jsonRPC or xmlRPC server within the client's reactor, then create a separate script that fires off RPC calls in response to UI events.
Nice comment. Better than your first :) By the way, for the point 1/ is just enough to say: Use linting tools :) 
/r/learnpython &gt; In my mind, doing "Animal.name = name" is the same thing as "self.name = name". However, I don't see why self would even be used. Is my assumption correct? No. There is only 1 `class.attribute`, but each instance has its own `self.attribute`. &gt;&gt;&gt; class A: ... def __init__(self, x): ... A.x = x ... self.x = x ... &gt;&gt;&gt; a, b, c = A(1), A(2), A(3) &gt;&gt;&gt; &gt;&gt;&gt; A.x 3 # 3 because last created object set A.x = 3 &gt;&gt;&gt; a.x, b.x, c.x (1, 2, 3) # individual self.x's of 3 objects `class.attribute` is something like a shared memory of the whole species, a hivemind. `self.attribute` is individual memory. If you don't define `self.attribute` it will point to existing `class.attribute`, as if it were a default value, but that's more of a peculiarity. 
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
This is more suited for /r/LearnPython , but I'll answer the question anyways. Let's say we have the following assignment statements: cat = Animal('cat') dog = Animal('dog') Based on your first example this would be the result of accessing the name property: print(cat.name) dog print(dog.name) dog This is because when you change Animal.name, you change that variable for the entire Animal class. The point of using self is it sets the name for that specific instance of the Animal class. So using your second example, we would get print(cat.name) cat print(dog.name) dog Because self refers to the instance of the class instead of the entire class. What is actually happening here is when you call dog.name, in the first example, it looks inside the dog instance, doesn't find a variable called name and then searches the class and finds a variable called name and returns/assigns the value. An clear way to see this difference is if you change the name variable after you create an instance. cat = Animal('cat') dog = Animal('dog') dog2 = Animal('dog') print(cat.name) dog print(dog.name) dog print(dog2.name) dog cat.name = 'cat' dog2.name = 'dog' print(cat.name) cat print(dog.name) dog print(dog2.name) dog Animal.name = 'spider' print(cat.name) cat print(dog.name) spider print(dog2.name) dog 
What issue? 'class of {0} is {0.__class__}'.format(42) "class of 42 is &lt;class 'int'&gt;" That's what is supposed to happen, I don't see an issue? If I tell Python to print the class attribute in a format string that's exactly what I expect
1\. Find the location of your openssl with `which openssl`. For me it's "/usr/bin/openssl" 2\. Edit the file "Modules/Setup.dist" that you untarred. Find the following and uncomment it (round about line 200): SSL=/usr/bin/openssl _ssl _ssl.c \ -DUSE_SSL -I$(SSL)/include -I$(SSL)/include/openssl \ -L$(SSL)/lib -lssl -lcrypto Make sure you update the SSL variable to whatever you found in step 1. 3\. Rebuild.
CLI stands for Command Line Interface. Typical programs that run interminals/consoles/shells like shell commands. Django is a popular webframework for creating dynamic webpages. Also it is the name af a famous spaghetti western series with mostly Franko Nero as main protagonist. (The inspiration source for tarantino, he even used the main song.) The inspiration for the name comes from Django Reinhardt a popular frensh jazz musician. By the way it is a romani nickname ;) &gt; Well...I'm pretty far behind the curve here Well, I just gave you some ideas and things you could achieve with python programming. No need to do all at once. But all of that would be achieveble within just some months of learning.
Well, for starters, I don't see how you can possibly get any useful forecasts running WRF on what's presumably a single or dual-core computer. Why bother? On the other hand, for the love of god, move on from GEMPAK. There are far more sophisticated tools in the Python ecosystem for visualizing numerical weather model output. For instance, WRF outputs in NetCDF, which is an extremely versatile format. You can ingest your data using [xarray](http://xarray.pydata.org/en/stable/), which is a fantastic, cutting-edge tool for dealing with multi-dimensional tabular data. Then, you can do all your visualization in matplotlib, but with geospatial plotting libraries like [cartopy](http://scitools.org.uk/cartopy/docs/latest/), which is much better than basemap.
It depends, you can learn the syntax in a couple of hours. If you already know Java then picking up python should be a snake walk
It's a quad-core, but it's not fast enough for real-time use anymore. Good to know there's something other than GEMPAK because building it on Ubuntu was a pain. After sifting through a lot of make.out garbage, I had to tweak several makefiles to point to the right system libraries. Why Ubuntu moved them somewhere else compared to other distros, I have no idea. I installed it because it was familiar. I've been pretty much out of the loop since graduating. At least rain is still wet and lightning still hurts.
Yes. But seriously - what do you intend to accomplish by running WRF with four cores? 
Melting my board, I can only hope. I can't get a new computer until mine croaks. I suppose running WRF with an 8-year-old quad-core long enough could do it. For a historical case, it would be fine. Slow and noisy, but it's not like I'm in a rush. I built an electric guitar and I'm not even a particularly good guitar player.
I'd hope nothing breaks in 3.7 if it works in 3.6?
But you'll barely be able to run WRF at coarse resolution in real time with only 8 cores.
For projects this small, just distribute a module. There is no need to make a package. Also why does it split on spaces? Your own examples don't work. &gt;&gt;&gt; fmt("Hello {{}}, this is my fellow {{}} on version {{}}", "World", "Python", 3.6) Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "&lt;stdin&gt;", line 10, in fmt __main__.LenError: The number of args and items to replace found are different.
[immutable](https://github.com/theengineear/immutable) and [funktown](https://github.com/zhemao/funktown) kinda fit the bill
It seems like your project is reinventing the wheel. Similar to pybrain. In my opinion there are already too many neural network packages including Chainer, Keras, NeuralLab, FANN, PyNeurGen, and Neural Network for Scikit learn to name a few. If I was a new user of these tools it just makes it more confusing like the package managers for javascript. But if you are filling a niche I would encourage you to work on it further and make sure users can easily distinguish your package from others that serve the same purpose. It sucks to go through each package try them out to see what you want for new users. 
SimulateMe! effinawesome
That word is loaded it implies that all other modules are not user friendly, at this point it is also used so often, and many times in mediocre modules that it no longer means anything.
I was making an xkcd reference. I used to remember the exact number at one point :p
Importing antigravity in a Python shell does something fun as well, you should try it for an easy reminder to that comic. ;)
You have made me a very happy man, thanks!
As a fairly new and interested coder, could you tell me how I would use this? I already have Python scripts, but once I download it from through the terminal, how would i apply it to projects or build them using this? 
I decided to look into list of those packages, and found that there was only one package that I wasn't able to find alternatives, although it is used by selenium which works on python 3 so most likely that also has an alternative: Here is the list: https://www.reddit.com/r/programming/comments/5jwjfk/z/dbki9oc
That's awesome, how did you approach the fire stations to sell the product?
Human stupidity has no bounds. All the complexity and cost is because of tying applications to Python installed with the system. Do you know why redhat has python 2 installed? Because system applications such as yum are written in python 2. Do you know what happens when yum is upgraded to work with python 3? You got it, python 3 will be installed. Writing applications tied to system python are tied to the system, so now upgrades of the system will require more work, you will have to use system packages which is another can of worms. All of that adds costs and requires extra tasting.
maybe this link will be helpful http://stackoverflow.com/questions/25981703/pip-install-fails-with-connection-error-ssl-certificate-verify-failed-certi
That's because python 2.7 was essentially back porting all python 3 features. Fortunately this stopped 1.5 years ago, so now the incentive is growing.
Boto has python 3 support for 2(?) years now if bit longer.
PyPI's readme disagrees: &gt; Introduction &gt; Boto is a Python package that provides interfaces to Amazon Web Services. Currently, all features work with Python 2.6 and 2.7. Work is under way to support Python 3.3+ in the same codebase. Modules are being ported one at a time with the help of the open source community, so please check below for compatibility with Python 3.3+.
Ehhh...when it's actually released.
I used boto3 2 years ago and it worked fine for me. By now I would expect everything was ported, since Amazon encourages to use boto3 I would imagine it supports everything or at most out doesn't support obscure services.
Are you an engineer and did you have to have the designs stamped at all? What would the case be if the technology fails somehow?
Our intern learned Python with Sololearn: https://www.sololearn.com/Course/Python/ There's also an app therefore on Android and probably iOS too.
Making an Algorithmic Stock Trading website. https://github.com/AksharX/AlgoTrading
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
My pleasure, sir :) Just let me know if it worked as expected. Seems to be very young extension. 
You mean this? https://i.imgur.com/chqmoJe.png
If you are going to use sklearn why not use the built in train_test_split() method? Also, if you are going for real life usability you should turn x, y into a pandas dataframe. 
Check out this video from Derek Banas on YouTube: https://youtu.be/N4mEzFDjqtA this guy is fantastic!
It's really useful but I wish it was easier to use with dark themes. Tried switching the plot theme to a dark one, but the stack traces are unreadable when errors occur. 
In the United States you don't need to be a public engineer (P.E.) to do anything other than civil construction related design. This is like building electrical, building mechanical, design a bridge, etc. it's crazy because one PE I worked with used to joke, "you can design bombs for governments without a high school degree if you prove you know what you're doing. But you could revolutionize the electrical industry after years being a college grad engineer, but if you don't take the PE test they won't let you sign and stamp."
They are *not* the same. Technical answer: `==` is for equality testing, i.e. whether both sides are equivalent. `is` is for identity testing, i.e. whether (simplified) there's the same *variable* (object) on each side, as opposed to the same value. So `country is country` is true, pretty much anything else isn't. In your example, you generate a new string object in the comparison, which may be equivalent, but not the same instance. Practical answer: Use `==`. You won't need `is`. It's a bit better practice for comparisons with `None`, but other than that you can pretty much ignore it for everyday programming. 
"==" and "is" are not the same. Specifically, "==" tests whether the objects on its left and right sides are equal to another (in whatever sense the types define that as), while "is" tests whether they are *the same object*. For example, let's define two equivalent strings in such a way that they will definitely be different objects: &gt;&gt;&gt; a = "foo" &gt;&gt;&gt; b = "fo" &gt;&gt;&gt; b = b + "o" Now let's see: &gt;&gt;&gt; a == b True &gt;&gt;&gt; a is b False You can use the `id` function to see the internal object IDs: &gt;&gt;&gt; id(a) 139810777160800 &gt;&gt;&gt; id(b) 139810777159480 In general, you should hardly ever have a reason to use "is" most of the time, except to compare against None, True, or False.
I use Python to manage my investment portfolio if that counts. I have to manually buy and sell once a month, but it does all the thinking and keeps my portfolio diversified and profitable.
correct
Thanks!
I literally just asked, not a salesman, just a firefighter lol
Nope, just a firefighter with an idea. This system suppliments the paging system they already have in the station. So far there has not been a failure in the 3mo it has been up, but it does rely on an internet connection so there is a good chance it could fail. If it did, thier other paging system is still going
this is exactly the case
Hey, I was tired and I accidentaly replied to your comment instead of /u/tunisia3507 -s. 
result = int(input("3+3=?")) if result == 6: print("Good job! Here's a more complicated one.") else: print("Wrong. Try again.")
Yeah, the word is overused, I agree. But I thought it fits the project really nice. edit: typo
/r/learnpython input returns a string, so wrap the input call with `int` function: `int(input('3+3=?'))` (recommended) or test result as a string: `if result == '6'` (not recommended).
That sounds awesome! Any chance you'd share your code?
I just gave him a lesson. 
Yes, seeing as modules are objects themselves (like everything else in python) you can achieve the same effect using the following piece of code (notice that there are no quotes around the modules) : for mod in (file1, file2, file3): mod.funcName()
Not in 2016 but in 2015, a guy was impressed with one of my scripts from github so he contacted me and sent me a 25¬£ Amazon GC. Ninja spelling edit. Edit 2: just remembered. Didn't actually get me any money, but a script I wrote a couple of months ago, helped me save some money. It parses a local listings website for NDS/3DS video games and sends me every hour a notification with what's new. Found some cheap games I was planning to buy and even better, found a couple of minutes after it was posted, the game [999](http://www.ebay.co.uk/sch/i.html?_from=R40&amp;_trksid=p2050601.m570.l1313.TR0.TRC0.H0.Xnew+9+hours+9+persons+9+doors.TRS0&amp;_nkw=new+9+hours+9+persons+9+doors&amp;_sacat=0) brand new, sealed, for about 10$.
How did you find the protocols on the data recieved from the center? 
You should also use isinstance or catch exceptions in case the user doesnt input an integer
Congratulations on having one of the most voted down comments in Python subreddit history. How does it feel? Or I guess I shouldn't ask a question like that. EDIT: indeed as shown below.. this is the lowest ranked comment ever in Python subreddit.
&gt; It's a bit better practice for comparisons with None Like `if x is None: ...`? Is that better or worse than `if not x: ...`, or is there not really much in it? I'd usually go for the latter.
I think me and some other people are actually trying to give you one. but sure, thanks for the "Lesson" TIL: Telling someone "If you have to ask, you are failing" is a lesson in life /s
&gt; Is there a way to get the object that is being iterated by the iterator, from the iterator? Only if the iterator specifically provides that feature, aside from that iterator and iterable are pretty much independent. &gt; For example, if I am iterating through a set I'm assuming you mean a dict. &gt; the iterator will give me the keys to my object, but not the values of those keys (I have to reference the object with that key to get the value) which seems to makes it less useful as a generic way of iterating through objects. Dicts have *views* which let you iterate on various "contexts" of the dict. The default iteration is (sadly) keys, but you can also iterate on values and (key, value) pairs via the corresponding `dict.values()` and `dict.items()` views.
&gt; Is that better or worse than `if not x: ...`, or is there not really much in it? I'd usually go for the latter. Ack! Please note that the `__bool__` method can be freely overridden by types: not 0 == True not '' == True not [] == True not MyClass(123) == ??? `not` is for logical testing and should only used to that end. Using it as isset idiom defies its semantics and is error-prone. Even if a class doesn't define `__bool__`, it might define `__len__` ‚Äì and if that returns zero, the object will be cast to `False`. 
&gt; The most "amazing" thing in the code came out from fact that I don't have access to historic quotes except in the form of line charts as images. The code reads the labels in the image to figure out dates and then follows the line pixels to estimate daily historic quotes. How do you do this?
I crop out certain boxes in the image and pass them to gocr to read the text. Min and max on the Y axis are always at the same place so that's easy. The dates are noted on the X axis with a small mark I can find by checking pixels, and then I know where the date text is relative to that mark. I can then say that between the dates of two marks are for example 100 days and 100 pixels then I know each pixel from these marks is 1 day from that date. And something similar on the X axis from the max and min values. And then just find the pixels of the line and map them right.
/r/learnpython
or result = input("3+3=?") if result == "6": print("Good job! Here's a more complicated one.") else: print("Wrong. Try again.")
It depends. For example, there are a bunch of use cases where you initialise a variable as `None` and then later set it to a value which still evaluates to False: for example, you can't (well... shouldn't) use a mutable as a default argument, so the common pattern is to do def foo(bar=None): if bar is None: bar = [] But `bool([])` is still False. If you're happy not being able to distinguish between None, 0, 0.0, False, [], {} and so on, then `if not x:` is fine.
Sounds like that would make a good library in it's own right. 
The problem is in your theory of which is a better format for the task at hand. RST has way more features than the not even fully standard MD. RST is designed to be extensible, and to be a document storage format. It's meant to store more complex documents, provide citations and useful template features. Essentially exactly what you want when writing documentation (rather than a simple blog post or reddit comment). MD is designed to convert a bit of text to HTML and only HTML so it's feature set is limited to what works in basic HTML (except tables because standard MD says just use POHTML tables). Also the syntax isn't wildly different, I don't see much productivity lost due to context switching. Though I don't spend all day writing MD formated content. I suggest getting more comfortable with RST and learning some of its more expressive features. 
/r/iamverysmart
The space splitting is just a way to approach the problem fast. The problem in the examples is going to be checked! Sorry for the problem!
The problem is not in the way its made, it's in the way formatting is used. There was a security issue on jinja2 and I decided to solve it, the whole explanation is on the README.md file
Yep!
Read the comment again
nope
You made me get work done! You'll rue the day!!!
That is what I meant. Vacation brain :) It seems like a .parent property for an iterator that is a pointer to the object being iterated would be a good thing. 
That's the most dislikes I've ever seen on a post, congrats, you're a grade-A level dickhead
It all comes from my banks website.
Actually, it is official... the previous all-time record was -155. Your follow up comment ranks 4th. The sad part is that I think you're the type who is proud of something like that. Here's a table computed by BigQuery: 1 [deleted] -155 2 Visual Basic is 10 times the programming language of Python. I see no reason whatsoever to incorporate a piece of shit language into MS Office. -131 3 its not backward compatible to 2.7 so nobody cares. let the downvotes begin.. -113 4 [Nobody cares‚Ä¶](http://i3.kym-cdn.com/photos/images/original/000/325/428/264.jpg) -96 5 I thought everybody switched over to Ruby by now. It's like Latin now, it's good for educational uses, but useless in its practicality. No good using dead languages to develop real projects. -80 6 Here's the thing. You said a "jackdaw is a crow." Is it in the same family? Yes. No one's arguing that. As someone who is a scientist who studies crows, .... -77 7 "google" is not a verb. Otherwise you're right, with these new, still developing languages connecting with the author is quite common. -76 8 Is python 3 still a thing? I thought it had died out. -76 9 Wait... People use Python3.x.x?! -75 10 You should probably do your research before reinventing the wheel. That way you can invent something original. Edit: wew, didn't expect this to be so controversial -73
It's over the last three years which I've been active, but I have been changing my strategy over that time so the data isn't that accurate. Well I was able to find a lot of data on stocks, but not so much on funds. What I did find didn't correspond well with the funds I had available anyway.
Haha I'm flattered you would think so! I'm in Sweden though so luckily I can save myself from embarrassing myself on a stage \^\^
How much of this is done manually and how much is done automatically by your algorithm? How is your work process compared to using existing tools such as [WebPlotDigitizer](http://arohatgi.info/WebPlotDigitizer/)
Perhaps he meant reparation, which is still the wrong word, but I bet that's what they were thinking 
Start with Python 3.6.x. I find it best to have a small project in mind when learning a new language/framework, and use tutorials to help build that project. Also, checkout /r/learnpython. 
I do no work except run the code, wait, and then buy and sell what it tells me. My chart reader is very simple, but also specifically created for the charts it needs to read. It downloads hundreds of them and exports the data automatically, but wouldn't work at all on any other chart.
There is a performance gain by using `is` but generally not a big deal.
Thats what i am struggling with when people say "project'. Are you meaning come up with one becuase if so i am not sure how to do that.
Useless post. Why can't the poster ask a question and get help, like a good poster?
Django used to be in svn with a private repo, they haven't been on github since the beginning. That might have an effect as well
Glad I asked now. Thanks!
I work full time as a senior systems developer. I earned 100k+ in Canadian dollars. Unfortunately this is about $1.97 American but that's OK I get free healthcare ;) 
Dude it's over...
Every *object* you make have different IDs. Different names may point to the same objects. Python does not have variables in the usual sense of the word (a name and an associated storage location).
You can do whatever you want. Search for a tutorial. 
&gt; Slicing has to create a new object, right? Actually it seems that CPython does the same thing for single-character ascii strings as for small integers and uses pre-created singleton objects. In [1]: ' '[:1] is ' '[:1] Out[1]: True
No, it cost me money. I used it in a class I took.
That's right. I'm going to venture to say that the last will necessarily be false, because it would be stupid to recycle string objects (or any mutable object). CPython can get away with doing it for some integers because they are immutable. On the other hand something like `"germany" is "germany"` can perhaps be subject to the whims of the optimiser as /u/lvc_ says.
Would it be possible to instead synthesize inputs on a phone to emulate sending snapchats?
I agree with your comments, and they drive the issue. RST is to complicated for its own good. MarkDown while not as extensive is a much better implementation.
Even Zuck knows better than to recommend PHP.
I use it for simple gui scripts, and it works just fine.
Considering that Facebook pretty much had to rebuild PHP from the ground up, it makes sense.
You can get free end of day stock quotes from quandl. See https://www.quandl.com/data/WIKI-Wiki-EOD-Stock-Prices/documentation/documentation?modal=null They have a Python module https://www.quandl.com/tools/python
You can get lots of free financial data from quandl.com
That's awesome. How does your program access the mls?
While it's possible to become a PEng in Software and Computer engineering (I plan on it) it isn't nearly as necessary as it is for most other fields. I think this will change though with the focus shifting to more ethical coding practice versus just writing code you are paid to write. 
If you are going to compile Python 3.6 from source, you may want to use the pyenv script. Look at the second answer here: http://askubuntu.com/questions/865554/how-do-i-install-python-3-6-using-apt-get After installing the necessary dependencies, you can do: pyenv install 3.6.0
Very nice. Will keep it in mind.
Is he using a Python program for that?
Great achievement, congrats! I am trying to do something similar similar now i.e. write an ebook or make a video course related to Python. Just have one question for you if you don't mind. How did you drive the traffic to your Udemy course?
Would you care to elaborate a bit more? What steps do you automate? The most obvious seems to be watching the MLS for opportunities that match your criteria. Is there anything else you do from another data source or is the criteria self contained in you script?
I've been organizing talks for PyOhio for the last several years and I have observed that the most popular talks are about "regular people" using straightforward methods to solve problems. Nobody sits through a 90-minute talk about compiler optimizations. It's too dry! But somebody did a talk about silly twitter bots and the room was PACKED and the crowd loved it. I suspect your local python group would love to hear about the puzzles you encountered while building your stuff. You might even help somebody else that is working on a similar project.
Uhm, yes there is. I have to waste time relearning and researching changes for no reason, because i don't need to switch. It's not an AV, nor is it an OS. It's just the fucking tool I use until it's too broken to be considered useful. Until that happens there is zero need for change, because all that i need i already have.
i made 6 figures by automating my investment decisions. takes a minute or two per day to check output.
Sorry if noob question, but as someone who would like to do that as well but is a little nervous about security: What do you do about securely logging in and scraping data, etc.?
Except for the 2 he's already sold to 
That makes sense. So it is more like a pointer or reference then.
just use the Python hooks for QT. Either pyside or pyqt. Very mature and tons of documentation
6 figures output with what kind of input though? 
There's a difference between autism and just being an asshole.
Can't help but have mixed feelings. Great that such a big name is endorsing the language, not so great that it's him of all people.
Is it because of the recent news that he did some shady stuff with his shareholders, or just what FB does in general? 
I'd recommend going with a client/server model instead of Tkinter. This allows for cross platform utilization and all you need to do it open a web browser on the machine and load the web page. Plus html/css is easier to code than hard coded tkinter items.
Well, this strategy, and all I've had for the last three years, have all been automated. One thing I really like about it is that it keeps picking out positions I would never had considered myself simply because I would never have found them. Especially since I made it calculate correlations to find diverse positions, that's something I never could've done by going though all positions manually.
It's PHP, since that's what Facebook uses.