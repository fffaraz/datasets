One thing though, will therrrp wiki be enough or will i evetually need a full blown website?
I'm in as well, but I'd need to catch myself up on pygame. I suggest we make our own subreddit to organize things.
One thing though, will therrrp wiki be enough or will i evetually need a full blown website?
I'm in! I'd like to try something 3D this time, let's see what ideas I can get from the theme ;)
I got this to work yesterday, but I fucked something up and now nothing I try works.. Anybody got an idea where to look?
I'd like to try, but I think 2-3 people per team is best
Yes, yes, and yes.
Hope you have a lot of memory.
I created [/r/pgc2013](http://www.reddit.com/r/pgc2013) for now so we can discuss and work things out, possibly divvy up members or come up with a great plan to make a game with more than 4 people. I'll send the rest of the folks who replied and showed interest a message with the same details, in case they don't see this.
Python sees bytes? 1s and 0sยน? What do you mean? ยน Well OK, it's dealt with in C for CPython so it's more like bytes (which are then Unicode-decoded) than 1s and 0s, but "\t" is still width-less and there's no concept of what code "looks like" to it.
Still waiting on a chance to setup a blank server with nginx and web2py. (Although one of the servers I run uses this exact setup, I took it over after it was already setup though)
This is good advice. I guess my initial explanation took some things for granted.
Just out of curiosity, do you have any screenshots or the like you can share ahead of your release?
IDEs are something that people must work with intimately &amp; constantly. As a programmer, it's your bread and butter. If you have to spend a week learning a new IDE before you're productive, that's a week you could have been more productive elsewhere. If the IDE fucks up and you lose a few hours of work, that sucks. Given that there's a lot of really good, established IDEs out there, you're going to need to have things polished and really sell it. Github makes sharing code great but I think people these days just assume that making code public makes it interesting. It needs to be solid &amp; compelling &amp; be actually useful to a third party.
I don't have enough time to dedicate to coding, but if someone needs someone to test on Windows, let me know. :)
I mean that indentation levels are significant to python, and uses tabstops of width 8. If you use a different tabstop to display the code, you are not reading the code the way Python does.
Thanks
I can make one anytime. Will alert you as soon as i upload to web, unless you have a different idea. Your inputs are welcome.
Sounds awesome, but kind of an inconvenient time for college students. The first/second week of classes is no time to focus on programming challenges. Disappointing I probably won't be able to participate. 
"setup.py is a ghetto"
Your version looks nice. I got sick of writing out setup scripts for all my projects so i made pde(https://pypi.python.org/pypi/pde) which is a command line tool that can ask some info and get a project directory started. Is it cool if i use some of your setup script in this project? The code itself is old and crummy its kind of shameful but it works, going to do a rewrite of it soon however.
 # todo: fix this
&gt;list(iterable) -&gt; new list initialized from iterable's items Wow. That's going to make my code simpler. Also, since dictionaries are ordered, what would the order be when they are converted into a list? Edit: Typo: I meant NOT ordered
Distutils and setuptools have recently merged. Until recently you kind of had to choose. http://mail.python.org/pipermail/distutils-sig/2013-March/020126.html
Do you do the log separation with log-route ? Any example?
Who pays for #3?
It could be largely volunteer based, similar to the linux model. Or some major python players (e.g., google) can help sponsor it, combined with volunteers. Or you can develop a system where you charge a nominal fee (say $5 - $25 to $99) to first publish something to pypi and then have a built-in donation ware system (e.g., use this tool a lot? Donate $10.), and use that money in part to manage the review system. Similar to how the chrome/apple/google play store work. Basically any time you install something via pypi, you basically have to do the full security review yourself before installing or take a leap of faith. Yes, desktop users probably don't do this, but in any sort of safe environment you have to do this step. Some crypto verification that based a cursory review could do wonders. Security hole bounties (on things that passed initial review), pip checking that installed packages haven't been red-flagged, etc. I mean what prevents people from making packages that run `commands.call(['rm', '-rf', '/', '--no-preserve-root'])` as part of the setup script (typically installed with `sudo`), or secretly add a root user, establish a TCP connection to the outside world and then join a a botnet? Crypto by itself doesn't solve these problems, but crypto plus a well-set up and moderated community can drastically reduce the problem. 
Uh.. would you mind to write the name or anything at all so we can find the IDE later on?
Short answer: The resulting list would be in whatever order the keys in the dictionary are in memory. Long answer: Dictionaries are kept in a memory block, just like any other data structure. They are fundamentally unordered because the keys are hashed on insertion and placed into a memory slot within the block based on that hash (and not the order of insertion). When a dictionary is read, it's read straight from the beginning of the memory block to the end, which is the order in which the keys would appear in the resulting list.
Dictionaries are not ordered. OrderedDict is
See also [Cartouche](https://github.com/rob-smallshire/cartouche) which does this, and has been used in production for a few years by several companies.
https://github.com/reddit/reddit/blob/master/r2/setup.py
Most Python dictionaries are not ordered -- at least not in any sort of useful, consistent way. If you need ordering, there's `OrderedDict` from the `collections` module. If you do `list(d)` for an ordinary dictionary d, you'll get a list of the keys in arbitrary order.
Well MS word can open .txt files or .rtf files just fine. Hell HTML works as well. Sounds like you could just use hg/mercurial and track changes that way. Save everything as text/html/xml files. 
While denormalization can help to work around consistency lag, a denormalized database may or may not be stored upon a consistent DBMS. Eventual consistency is more a property of *distributed* data stores (the *CAP theorem*) which do not block until all nodes are synchronized (until all data is replicated).
Know about it, thought about using it, decided it was better to use rocket+nginx. 
`pip:sphinxcontrib-napoleon` supports Google and NumPy style docstrings: Supported * (`Args`, `Returns`, `Raises`) -- Google -- http://google-styleguide.googlecode.com/svn/trunk/pyguide.html?showone=Comments#Comments * (`Args`, `Returns`, `Yields`, `Raises`) -- KhanAcademy -- https://sites.google.com/a/khanacademy.org/forge/for-developers/styleguide/python#TOC-Docstrings) * (`Parameters`, `Returns`, `Raises`) -- NumPy -- https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt#sections Not Supported * (`:param`, `:type`, `:raises`, `:returns`, `:rtype`) -- Sphinx -- http://sphinx-doc.org/markup/desc.html#info-field-lists 
For project and setup.py generators I'm really partial to https://github.com/audreyr/cookiecutter
http://cartouche.readthedocs.org/en/latest/usage.html#overview `pip:cartouche` reads `help()` readable docstrings in Google-style and generates Sphinx-style function markup (`:param:`, `:returns`, etc) for HTML/man/ePub; making it much easier to read `__doc__` strings with plaintext `help(&lt;obj&gt;)` and `print(obj.__doc__)`. Supported * (`Args:`, `Returns:`, `Yields:`, `Raises:`, `Note:` and `Warning:`) -- Cartouche * (`Args`, `Returns`, `Raises`) -- Google -- http://google-styleguide.googlecode.com/svn/trunk/pyguide.html?showone=Comments#Comments * (`Args`, `Returns`, `Yields`, `Raises`) -- KhanAcademy -- https://sites.google.com/a/khanacademy.org/forge/for-developers/styleguide/python#TOC-Docstrings) Not Supported * (`Parameters`, `Returns`, `Raises`) -- NumPy -- https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt#sections 
setuptools and distribute are merged, distutils stays independent Some facts: * distutils is in stdlib * setuptools extends distutils * distribute started as "hostile" fork of setuptools 
[Appy-pod](http://appyframework.org/pod.html) is probably what you're looking for. You can create docx documents with python code embedded in the documents. You then call a renderer that can make use of a headless open office installation to render it to any format you want.
Thanks for that correction. 
Pcode IDE. Notable features: Autocompletion Inbuilt cxfreeze Rope refactoring Support for xml, html, css syntax highlighting Project management Profiler Autopep8 formatting Plus other regular ide features like find in files etc. Code will be hosted on github
I don't know much about stem, but I have been using praw a lot lately. I recommend [reading the documentation](https://praw.readthedocs.org/en/latest/) and looking at the examples. Also, I would recommend testing it out in the interactive interpreter, in order to figure out what does what and test ideas.
This looks like a really interesting option, thanks for sharing.
It happens twice every year (since 2006), March-April and August-September. May be next one (March-April) will work better for you.
FYI, `list({"a": 1})` is equivalent to `{"a": 1}.keys()` (including ordering).
That would be the death of the python community.
 That's obviously depends on what your needs are. In the beginning I'd say it's definitely enough. You can format documentation and post screenshots. Why don't you try it out? It's free.
I will definitely give it a try
&gt;Upgrade what to what? Python 3 &gt;The problem with tabs is precisely the thing that people think are desirable about them: they can be displayed differently. As I've said before: "Tabs should never cause a problem in real code. If they do I can conclude that you're doing it wrong." Following what you have said (about how Python interprets it) the only reason they'd cause a problem for *you* is that you're running Python 2.
My setup.py for packages: [praw](https://github.com/praw-dev/praw/blob/master/setup.py), [lazysusan](https://github.com/bboe/LazySusan/blob/master/setup.py) and for modules: [extended_http_server](https://github.com/bboe/extended_http_server/blob/master/setup.py), [sqla_mixins](https://github.com/bboe/sqla_mixins/blob/master/setup.py) One thing that's a must for me is for the `setup.py` to discover the version number that is declared in the package or module itself as the `__version__` variable.
You ask this 8 hours ago, but you've had a github repository for a month. https://github.com/fortharris/Pcode Absolutely no code whatsoever. 
OP is on MacOS X not Linux. Also, its necessary on Linux when distributions like RHEL/CentOS ship with Python 2.4 in 2013. 
Don't understand setup.py. Probably never will. I thought about making pip/distuils work in the past, but it's not my problem if you don't like setuptools Anything besides making a "setup.py develop" or "setup.py install" with no C code scares me. For example, trying to support Python 2 and 3 with the same code base is a nightmare. 2to3 doesn't work, so I coded a Python code parser that works with my code thanks to a few reasonable restrictions. It's only ~400 lines of code, but it works.. http://pynastran.googlecode.com/svn/trunk/setup.py and my hack 2to3...yes there is a build_2to3.py, and no it's not newer than build_2to3_old.py. It's newer and short, but it's buggy. http://pynastran.googlecode.com/svn/trunk/licenses/build_2to3_old.py
Absolutely. You can install the homebrewed version of Python 2.7 or 3.3, but then you're going to want ipython &amp; will have to build it yourself (along with its dependencies). Then you're going to also want pretty much all the libraries that come with these Python distributions by default (they're in by default because they're the most wanted). So you _can_ build them all individually, but its going to take a lot longer than simply installing a better Python distribution that has it all included. Then there's maintenance, deploying virtual envs, ... 
I think IDLE is great for introducing people to Python, because it's so simple: nothing extra to confuse them, and you can run scripts right from the window where you write them. But for bigger projects, a more powerful tool certainly comes in useful.
It all depends on your preferences. I used to use IDLE, but then I started learning Java and using Eclipse. When I found out about PyDev, it fit a lot easier and now I use 2 languages on 1 IDE. It's great.
Python 3 and Python 2 behave exactly the same in this regard. 
Yeah, sorry, it's a global challenge so scheduling is a nightmare. In the end I usually just run it when it's convenient for me.
Big teams can work, as long as you're not all coders :-)
By all means, use it as you wish.
Whoa! Richard Jones is that you?? I made [a post here a couple weeks ago](http://www.reddit.com/r/Python/comments/1icw3h/pyllettown_an_overworld_demo_of_pokemon_redblue/) about a demo game I made using a fork of the TMX library you made for pygame (I found out about it from your PyCon presentation) to showcase pygame running on python3. Not sure if you noticed it I just wanted to say thanks so much for making that and I hope you don't mind me using it. I won't be able to participate in the challenge this year but it's alright, next time I can I defintely will!
this is nice
Note that you're just pulling the keys from the dictionary. fruits = {'apples':'delicious red fruit', 'orange':'a fruit shaped like itself'} fruit_list = list(fruits) fruit_list == fruits.keys() #True
I've seen mixed results on the PyPI. I have seen repo descriptions that successfully use the code-block directive, and others that don't. The RST renderer for the PyPI seems to be more strict than that of Github's. For me, the safest bet has been to just remove the code-block directives for the PyPI.
=D
One option is to author documents in a [lightweight markup language](https://en.wikipedia.org/wiki/Lightweight_markup_language) like [Markdown](https://en.wikipedia.org/wiki/Markdown) (e.g. Reddit, GitHub) or [reStructuredText](https://en.wikipedia.org/wiki/ReStructuredText) (e.g. [docstrings](https://docs.python.org/3/), [Sphinx](https://en.wikipedia.org/wiki/Sphinx_\(documentation_generator\)), [Read the Docs](http://read-the-docs.readthedocs.org)) that works well with version control and then generate the formats that you feel most appropriately share the information. * [`Sphinx reStructuredText Guide`](http://sphinx-doc.org/rest.html) [`.rst` -&gt; [HTML, PDF, LaTeX, ePub, ...](https://github.com/rtfd/readthedocs.org/blob/master/docs/Makefile#L17)] * [`rst2wordml`](http://docutils.sourceforge.net/sandbox/rst2wordml/readme.html) [`.rst` -&gt; `.doc`] * [pandoc](http://johnmacfarlane.net/pandoc/) ([src](https://github.com/jgm/pandoc)) [`...` &lt;-&gt; `...`]
I'm not sure I understand your comment. The examples you give as "Not Supported": &gt; (:param, :type, :raises, :returns, :rtype) are just regular reStructuredText directives that are understood by Sphinx. They work just fine even if you are using Napoleon. As inconsistent and ill-conceived as it is, you could very well have a docstring like this: """Summary Extended description. :param arg1: Argument one :type arg1: str :param arg2: Argument two :type arg2: int Returns: Description of return value. Raises: ValueError: Description of why error is raised. """
You can avoid a lot of faffing about with the `data_files` named parameter if you included a `MANIFEST.in` file with the following line: recursive-include pyNastran/gui/icons *.png That will make sure that all the PNG files in pyNastran/gui/icons and its subdirectories will be included in the package and, because `include_package_data` is set to `True`, they'll be extracted into the right spot.
Logging module makes me sad. It's extremely useful, but it's so slow that I've had to use my own a few times and got into arguments about whether or not speed matters in Python.
Very interesting, didn't know about cookiecutter looks nice.
&gt; so nobody replaces it. http://pythonhosted.org/Logbook/designdefense.html#logging-compatibility
* http://docs.python.org/2/library/logging.html * http://docs.python.org/3/library/logging.html * http://docs.python.org/2/library/logging.config.html * http://docs.python.org/3/library/logging.config.html
According to https://www.enthought.com/products/canopy/package-index/ this package is not included in the free version. You need to buy a subscription to get it. Yes, this is one of the off-putting things with EPD, they charge a subscription for otherwise freely-available packages on pypi. 
Tried creating a wiki at the time and failed miserably with the formatting so i gave it up to seek proper help on how to go about hosting on the internet. I might say that it took so long because i had to smoothen some edges about the software itself before releasing it to the public. As it stands now the project would be uploaded by the end of this week and you all can share your thoughts.
Here's what mine generally look like. I use ez_setup, which sets up setuptools if possible before your setup script runs. Python packaging is still a nightmare, but at least this method gets you something useful and portable. Distutils isn't useful. https://github.com/LimpidTech/django-contact/blob/develop/setup.py
Yep, licensing is the reason PySide exists, http://developers.slashdot.org/story/09/08/30/0823206/nokia-makes-lgpl-version-of-pyqt &gt; Nokia didn't succeed in convincing Riverbank [PyQt creators] to change its licensing terms on PyQt, and so decided to create their own LGPL'ed version of it
Install the package via pip. 'pip install pymc'
The point is that your rules do not apply to both. There's often little need to install anything other than the system Python on Linux, unlike OSX. And anyone who is doing new development on RHEL/CentOS 5 needs to be shot, frankly. RHEL/CentOS 6 ship with Python 2.6, which is supported by most major Python libraries and frameworks right now.
My setup.py looks really minimal. It just contains metadata and the convenience method of setuptools.find_packages(). For anything else I want to do, I can use other tools. This way I don't copy code around into every project that I make. Testing? I use zc.recipe.testrunner to create a bin/test script in my project. Releasing? I use zest.releaser to upload to PyPI, which also handles updating version number, creating a tag and updating a HISTORY.txt file. 
Anaconda is another Python distro, and it doesn't charge money for any otherwise freely available packages. It comes with the conda package manager: conda install pymc
Full disclosure I've submitted a similar question in other subreddits. Don't hate ;)
Here's a daemon file https://github.com/radiosilence/deb-stackscript/blob/master/templates/uwsgi_init.j2 but it might need some trimming down.
As a geology student who loves to work with python, I think that really *interacting* with the data is key for good presentation of science. However, there are still a lot of people that I work with who can't see the value in this. Many scientists don't have these skills and think they are roundly useless (anything over and above excel is "too complex"). But their viewpoint is somewhat realistic given the incentive structure of much of science: it is built so that papers (a completely static medium) are king...and the prestigious journals are often space-limited to the point that even the number of figures is limited! It's great, though, to see this changing. But it'll be slow.
I'm not sure why you employ hostile, it was just that absolutely nothing was happening with setuptools until recently.
&gt;How do you learn new programming languages? * Do a quick tutorial, preferably official one and look at few examples. * Choose a simple project I want to do in that programming language, mostly something that I already have experience with in other languages. * Use official docs to figure out how to do stuff and Google/SO if I'm stuck somewhere. Although I do 95% of my projects in python I did few in other languages without any prior experience and official docs and google is pretty much all that I used. Maybe not the best method of learning but for a few small to medium projects it was enough for me to understand basics of the language. If I wanted to be a better programmer in a new language I'd probably download a book or something and read it.
This is why I put "hostile" in quotes cause it was kinda "hostile" in relation to setuptools but probably wasn't such to the community.
&gt; `with open('README.rst') as fp:` You should make those into absolute paths at least (with `__file__`).
Sadly the state of Python game engines is pretty dire: PyGame hasn't been updated in 6 years, Pyglet 1.2 has been stuck in alpha since forever, Cocos2D python version had a minor point update last year and thats it. None of them address the packaging and distribution story (unlike, e.g. LibGDX for Java or Cocos2D-x for C++/js which come with tools to make builds for desktop and mobile). Ignafuga http://ignifuga.org/ ticks all the boxes for what you'd want (desktop/mobile deployment, debugging, etc) but is completely undocumented at this point. Kivy is well documented and does handle the platform packaging side but is not hugely suited for games (lacking 2D staples like sprite sheet animations). Personally I feel if you set out to make a game you shouldn't have to spend ages tinkering with the core engine, or invent your own package and distribution system. I personally would love to write games in python, but if you want to go beyond quaint demos distributed as source you need mature tools, and they're just not there on python at the moment. 
You can always do pip install pymc inside the EPD distribution. 
I suppose this makes me old-school, but if I'm learning a new programming language, I like to pick up two books on the subject. Now, that aside, here's what I think makes for a good tutorial. Bootstrap the tutorial with a quick introduction of the basics: types, declaring and using functions, etc. Then do a few common tasks: opening, reading, and writing to a file, for instance. Go on to a couple of short toy applications, and when doing this don't be afraid to touch on more advanced stuff without giving a full explanation. Just tell the reader that a fuller explanation of this or that point is coming down the road. Keep going back and forth between hands-on practice and explication. Maybe it's just me, but case studies of super-duper applications can be a real drag.
Thanks, I'll check it out.
You built a Python IDE with all those features, but you didn't know how to distribute your project?
Why do you want JDBC? There are native bindings for pretty much anything. Also, /r/learnpython .
To quote from the article &gt;The first argument to connect is the name of the Java driver class. The rest of the arguments are internally passed to the Java DriverManager.getConnection method. I think the devapp site may have been down when I wrote this, but here is the page for Drivers. [http://devapp.sun.com/product/jdbc/drivers](http://devapp.sun.com/product/jdbc/drivers)
Here's my experience with it. Maybe it will help you? You'd replace the jar file I'm using with your own. http://www.answermysearches.com/python-connecting-to-filemaker-via-jdbc-on-linux/2240/
That depends on the OS, but on Linux the default linkage of Numpy, SciPy, etc. is to ATLAS
Topical [quote from pydanny](http://pydanny.com/made-up-statistics.html): &gt; 95% of developers trying to create reusable Python packages have **no freaking idea** as to whether or not we should be using setuptools, distribute, or distribute2 and wish there was a **clear explanation on the front page** of PyPI as to what we should be using and how I am the 95%.
Thank you! I was wishing for this pretty hard last month. I guess it worked!
Thanks sharplikeginsu! So if the price-point was $20-40 and was very similar to github repos do you think programmers or their companies would pay for that? I know companies are spending way more in Professional Development every year. Not trying to sell to you, I'm just trying to verify the idea before I spend cash to develop the courses. Lean and Bootstrapping ftw!
I though this one was a dead horse, but **it's alive !** Keep up the good work. - A proud Babel user.
Thanks wub_wub! So do you have any problems with the currently available tutorials online? The courses I'm looking to develop will be very similar to the currently available books that are available for download. If the price-point was $20-40 and was very similar to these and github repos do you think programmers or their companies would pay for that? Not trying to sell to you, I'm just trying to verify the idea before I spend cash to develop the courses. Lean and Bootstrapping ftw!
Thanks crowseldon! So if there was a course that was a bit more in-depth than a simple tutorial, would you or your company pay $20-$40 so that you can learn it easier? Not trying to sell to you, I'm just trying to verify the idea before I spend cash to develop the courses. Lean and Bootstrapping ftw!
I get that you're doing research, happy to help. I'm not sure if I understand what you mean by 'very similar to github repos.' More concretely, what I meant is that I go to, say, [https://github.com/languages/Python](https://github.com/languages/Python), then find something that looks interesting from 'most starred|forked this week|month', then read it. Or if I realize 'I ``import requests`` a gosh-darn lot these days' I'll go find that source and read *it*. I'm not sure there's an obvious way to charge for that, specifically, since the code is all open. It's possible you could 'distill' some of that reading into more compact lessons, but it's hard to substitute the value of reading actual code full-on. You learn about how the files in the package are structured, how it's tested, how the people have chosen to use the tools of class/package/module, what packages *they* are choosing to import and depend on, how they document, what seems readable to you, what's confusing, and so on. I could see curating a list of 'great code to learn from' but the value of curation is perceived to be ``&lt;&lt;`` that of content creation.
As i package mobile apps for Harmattan, i use a make.py which use PyPackager ... :p That's package packaging package and modules aren't pythonic ! (http://khertan.net/PyPackager)
Thanks mariox19! That is extremely helpful feedback! So if I created small bite-size lessons. Such as: Intro to the basics. Common Tasks. Case Studies. Advanced Concepts. (Ruby, Python, Django) I'm thinking of a price-point of $20-$40 each. Do you think programmers, or people interested in programming would be interested? Again I'm not trying to sell to you, just trying to verify the idea before I spend the cash to develop the courses. Lean and Bootstrapping FTW!
When I need to do something I don't know how to do, I learn how to do it. If I'm curious about something, I read about it and play with it. That's pretty much it. I don't go to training, seminars, or whatever. I don't take online courses (&gt;90% of the online programming course stuff I've encountered is for beginners). I read the documentation, look up an example or two, get a POC working, and then use it for whatever I need it for. I don't feel the need to have my hand held through 20 pages of tiny condescending steps just to find out that functions can have parameters passed by value AND reference (or whatever). Just tell me that. I know how to program, I don't need to be taught what a "variable" or "hash map" or "mutex" is all over again, I just need to know how one acts in this language.
This is great news, and might be extremely timely for me since I've actually been struggling with a bug in reddit's i18n this week that's related to Babel. I didn't see anything that sounded like it would address it in the changelog, so I can have a look at the new version later if you're not sure whether it fixes it, but maybe you'll know offhand: The issue I'm having is related to strings like "20% off". Babel picks these up as including Python formatting even though I'm not formatting anything into them, since "% o" is actually a valid conversion specifier. But if I escape the % sign like "20%% off", the output will include "%%" since no formatting is being done. I had a couple of options for working around this, but they weren't very good. Do you know if this issue will still occur in the new version? Edit: I believe it's the same issue as [ticket #318 on the old site](http://babel.edgewall.org/ticket/318).
I agree with this. A lot of my learning comes from the realization that a library or framework I'm using does something that feels like magic, so I go read the code to understand how the feature in question is what implemented. I don't see much substitute for that. That said, I will add that I think a great way to implement tutorials is git repositories with branches representing progressively more complex topics. Angularjs does a very good job of providing step by step instructions with an environment you can work through yourself. It's not the same thing as learning from real, production ready code, but it's a great way to introduce people to new technologies. 
yeah, thats a totally reasonable price for good learning materials. I just bought a $30 book a couple of weeks ago and I do this on a regular basis. As long as the course is focused on not just tutorial "how-to" type stuff but also gets into best-practices, software engineering principles, and how to think about the topic domain I'd be very interested. 
&gt; Do you know if this issue will still occur in the new version? At the moment yes, but i have this on my list of things I want to fix. Unfortunately the python-format flag is currently being weirdly controlled and I am not sure yet what the best fix it. Feel free to chime in :) Essentially the problem is that it just does a regular expression match and if it hits it marks it as "python-format". Regardless of if it's python in the first place or a format string. Primarily it will require changing the extractor interface so that the extractor can yield flags.
Interesting insight. What I meant by similar to "github repo's" was to screencast and walk through step-by-step the logic behind great code in certain programming languages. Small bite-size case studies, common mistakes, documentation, etc. 20-30 mins Max. I know that to keep a P.Eng. designation you are required to do professional development. From what I've heard this would be a nice friction-less study format to supplement that development.
It does seem odd, but the things that people manage to know while not knowing other things that I assume go hand in hand never ceases to amaze me. I'm sure there are people who feel the exact same way about my knowledge strengths and weaknesses. I guess it just shows how different our minds work as far as what we retain or not, what we pick up along the way easily, etc.
Very interesting I'll check out what Angularjs is doing! Exactly the service I'm trying to provide is a vitamin for learning more and more complex topics. It's not going to replace content creation in a test environment but it will be nice content to plug into and learn.
Exactly, through my customer discovery I have noticed that people want short bite-sized lessons on specific high level concepts. 
&gt;So do you have any problems with the currently available tutorials online? Not really, for most languages there are enough good tutorials online. But as I said I focus more on official docs than tutorials. &gt; If the price-point was $20-40 and was very similar to these and github repos do you think programmers or their companies would pay for that? Why would I pay $20-40 for a tutorial that is very similar to those which are already freely available online? If it was an extensive tutorial with bunch of quality code about a topic that isn't mentioned very much in other tutorials/documentation and it's something I want/need to learn, sure I'd pay that much. Although I can't really remember searching for tutorials about some topic, I run more often in lack of documentation about some stuff (like APIs for example) than not understanding what I'm doing.
I don't think you understand what feedback means.
I use it on a daily basis. After a while of hearing about things (iPython, pandas), I check them out. I hear about things from random google searches or just reading reddit. When a new version of python/numpy/scipy is released, I look at the list of things that was added in that version and the previous versions (since I've probably forgotten) and try them out if they seem interesting. I'm slowly starting to learn some use cases for decorators (which of course no one mentions since the ones they suggest seem trivial), but they're certainly specific.
Note that we do not charge for pymc itself, but for the work that got into packaging it (like Red Hat charges its distribution). Installing pymc form sources (using pip) is actually not very practical, as it requires to have the MKL dev bits, that is a MKL license.
I see, a "guided tour through the world's great codebases." I still think personally I learn/retain more by **exploring a thing** vs **being shown a thing**, but there's certainly value in an expert talking you through something. I actually like seeing something I don't "get" because by the time I've figured it out (via documentation, asking someone on IRC, etc) it tends to stay "got". What they've done with [tour.golang.org](http://tour.golang.org/) is pretty great, and probably similar to what /u/AusIV is talking about for Angular. A format of 'screencast =&gt; interactive problem to solve' might be the best of both worlds, and for people looking for "provable professional development" being able to say "you scored a 97% on the expert python memory management course" is interesting.
I'll also be looking at creating certificates of completion. I think that is a great value prop for professional development.
hey porlov, can you expand what you mean by that? I'm learning a ton from the community here. 
That is what I have been hearing is that there is demand for best-practices with a particular programming language. High level concepts in a bite-size online course. PM me if you would like to know when the courses go live.
Appreciate the insight wub_wub! I agree that for rockstars such as yourself everything is self-taught and picked up very fast. I can see the slower learners liking this supplementary content though. 
I don't know. As a data point, I had no idea they did that, so the PR didn't penetrate my part of the 'verse.
We're a small engineering company and all mostly use Python, so we're pretty good. It's rare I need to look something up. Mostly, we have one person figure it out, mention it in a staff meeting, and if you're interested can use it on a project. I recently did some decorator-based logging of user actions for debugging and now my boss wants a session file (batch mode) option in our program. &gt; professional development such as a course Generally no, but we had 2 guys go to a scipy conference a few years ago &gt; book yes, but google and package documentation is usually enough. We buy a few books per year, but not many programming ones since we have a good stack already.
Thanks 
MKL isn't required, its possibly recommended to compile numpy with it though to use its optimised BLAS &amp; LAPACK rather than ATLAS. 
Er, I don't think you typed what you wanted to in that first paragraph there. I'm not discounting that running a better Linux distribution that comes with an up-to-date python by default is an option, however (despite your denial) my rules still apply in that situation _as well_. Your rule relies on this (certain Linux distribution being available), mine does not. And as has already been stated, Linux as a whole is irrelevant to the OP. My rules work for the OP (without changing their underlying operating system) yours does not. I don't disagree anyone running RHEL should be shot however we also have to temper that with the fact in the real world, we're not permitted to shoot idiots and recalcitrant enterprises may have only just considered RHEL 5 old enough to be "stable" and just upgraded to it. Due to the usual N-1 rule my rules should still apply, again yours does not. 
Frankly, if a company is conservative enough that they're going to be spinning up a 6-year-old OS for a new application environment (that they're presumably spending a lot of money developing!) rather than a 3-year-old one, they're not going to allow installing a third-party Python environment. Doing so would significantly increase their support liability (Red Hat can go "oh, it's your third-party Python's fault, sorry, we can't help"), as well as making system security harder due to more sources of security issues. I can't find that either Canopy or Anaconda are certified in any way by Red Hat either, which'd probably factor into the decision to ultimately reject your request to install either. We're using Red Hat for a reason! (I'll admit that ActiveState Python is an option, for $1000 per OS instance per year, and that is certified to run on RHEL5. I'd probably agree to install that if we had the licenses.)
Awesome, thanks! \o/
can pywinauto be used to work like say: start browser, go to reddit, sign on, check messages.....?
PyGame 1.9.x and Pyglet 1.1.x are quite mature and that's why they're not being updated very often. I think that's a good sign; I like that instead using tools that are 0.x and are updated every month, with severe bugs every now and then and breaking your code between updates. In the case of Pyglet 1.2, well... you're right and hopefully it will change sooner than later. But the tools we have work and are powerful enough. I've been using Pyglet 1.2 alpha1 for some time and I'm still to find anything that doesn't work or, at least, that I can't patch easily (open source rules!). Regarding packaging, I agree with you that it could be easier; but it's not an easy to fix problem any way. The truth is It needs some knowledge, but again... the tools we have work! py2exe, py2app, etc are mature and work pretty well. In Linux, if you don't want to support distro packages (ie. if you have a working setup.py, Debian/Ubuntu packaging is trivial with tools such as stdeb), just ship a tarball with al your "python only" requirements and everybody has already Python installed so it's just untar an run. It would be great to have a way to cross-build packages, but it's not the end of the world. There are some commercial games built with PyGame and Pyglet and there's no way to know they use Python; so it can be done and the results are good! EDIT: typos, ate a word; pre morning coffee post was a bad idea :) EDIT 2: some examples: - PyGame: http://unityofcommand.net/ - Pyglet: http://www.aceofspades.com/ Both are excellent games and it's not relevant that they've been built with Python.
If your target group is beginners and slow learners maybe a better idea would be making something like 'learn python the had way', offer basic stuff (text only) for free but make video tutorials, additional code, PDF downloads etc which would be a pay only feature. 
Did you port the code or use an awful thing like `six`?
Unified codebase, no six no 2to3. The glue code is self contained in a single module: https://github.com/mitsuhiko/babel/blob/master/babel/_compat.py
u cud free ur mind here:udacity.com
You should probably use a tutorial/read a book about Python 3, there's some syntax differences between 2 and 3. http://www.diveintopython3.net/ - Here's one for Python 3 from the sidebar.
You use python 3, therefore you need to write: print("Hello world!") **print()** was changed to a function in py3k.
Well, I would recommend using 3 in this day and age, but OP just needs to make sure that he is using a tutorial FOR python 3. If you can't find one that's good enough, then go ahead and use python 2.
&gt; 3 is a full replacement for 2 and 2 is thus redundant and will fall out of use in the next few years. I doubt that. With the exception of some early adopters there is no traction behind Python 3 yet. Even if more and more people would start migrating now it's still years from Python 2 dying. Before PyPI enabled the CDN I got less than 0.5% of all downloads from my packages that supported Python 3 from Python 3. (I don't have any current numbers as the download stats are no longer available due to the CDN)
.... i love python... i love the republic.... but this is MADNESS!!!!
Tab completion. Thank god. The features of the Python shell are atrocious. 
This, except i realized in time. OP: learn 2.7 it will be much better for you now and in the near to mid term at least, especially library support. When/if there is a real need to switch in the future it wont be that bad, but trying to struggle with 3 until the will be painful
2 is done with. No new stdlib functionality, nothing but security patches. 3 has so a more logical stdlib hierarchy, many scoping issues and similar strange old behavior removed. Better codec support. Distinction between text and bytes. utf8 everywhere by default.
Yeah it's stupid that that tutorial doesn't clearly say it's only valid for python 2
&gt; Better codec support Did I miss something? If anything codecs had a regression until 3.3 restored the old behavior from 2.x. In any case all of that is irrelevant for new people learning Python with was my only argument. All the resources are about Python 2 and you will need to understand Python 2 for years to come due to all the legacy code. Jumping right into Python 3 sounds like a really bad idea.
It's brutal whenever I have to use the regular Python shell instead of IPython for anything.
Trying to write "future proof" code at this point is probably a mistake. You'll be at least 20x better as a programmer in about 5 years --- whatever takes you a month to do now will probably take a day or two then. Just focus on writing correct code that does something today.
I just wanted to share with you my first Python project. It is a PEPA algebra (formal tool for performance evaluation) toolset and a library. It is still under developement but is highly usable. I know the code may be not entirely perfect but I am quite proud of it. I know scientific software is not very interesting for you but I just wanted to show that we in science also love Python :)
FWIW, tab completion was somewhat recently officially added to the REPL: &gt; Issue #5845: Enable tab-completion in the interactive interpreter by default, thanks to a new sys.\_\_interactivehook__. (http://hg.python.org/cpython/rev/d5ef330bac50)
There are plenty of tutorials for Python 3, and learning Python 3 then modifying your code to Python 2 if you need to/want to use a different package is not that big of a deal imo.
Is there a PEP out there for this?
&gt; Python 3 then modifying your code to Python 2 That argument goes both ways.
There are no changes between Python 2 and 3 regarding whitespace handling - what's your point?
I mean in the repl in general, not a 2to3 issue
&gt; anybody coming from another programming language to understand the code. why do you want a non-LanguageX person to understand LanguageX code ? or rather why do you think a non-LanguageX person should understand *your* LanguageX code ?
yeah that's the "youngin" in him heheh 
&gt; I want it to be really readable and easy for anybody coming from another programming language some dutch dude named Guido likely had the same idea a few years back.....
RTFM ?
he'd probably end up uninstalling Python
The debate about whether you should learn Python 2 "or" Python 3 is dumb. Learn both. They are only different in a few small places, and you will encounter both in the wild. Learn whatever your tutorial/book uses first then read about how the other is different. 
Yup
I know you are trying to help and I'm grateful for it but I don't regard wrapping all logging calls in an IF statement as particularly pleasant for the programmer (well, for me, mostly). If I have to write 2 lines of code to log everything, I might as well use a DIY logger. However I would be grateful to receive further advice.
&gt; I thought about making pip/distuils work in the past, but it's not my problem if you don't like setuptools This is a bad attitude, your libs need to be pip-installable.
Sorry, I'm a bit jetlagged perhaps? still not getting what you mean...
I can't always use ipython (some module issues), so sometimes I run scripts using 'python -i &lt;script&gt;' for debugging ---and this is super useful for those cases! Thanks!
I'm not against it. I just don't know how and don't want to focus on it. If someone wanted to send me a patch, I'd take it. There's just not really a need for it. I tell people how to install it with setuptools on Python 2 and Python 3. There's no reason to do it for the sake of doing it.
NICE WORK
thanks tunato
For the record, you're being down voted because it's not cool to just throw RTFM at a newbie who is trying to learn. Newbies need help and guidance, not condescending bullshit comments.
&gt; However I would be grateful to receive further advice. To do that I'd need to know more about your usage patterns / where the performance bottlenecks actually were. It's not *just* the `if` statement - there are options to speed things up if you disable features (e.g. if you don't walk the stack looking for source file/line number). The suggestion to use the `if` statement only applies if the parameters to the logging call are expensive to compute, as explained in those docs. Is that a common occurrence where you encountered slowdowns? Also, logging in 'hot' or tight loops would have an adverse impact on the execution time of the loop.
Plugins (extension modules) for a game server. The core engine was C++ but additional features were implemented in Python. While I doubt a website user could tell the difference between 100ms and 150ms on a page view, in some types of game, players will certainly notice lesser intervals than that. I remember experimenting with both `logging.disable()` and also using `__debug__` and running the interpreter with -O. As you say the expression that is logged might be expensive to compute, and might be computed even if the logging level didn't involve writing it (not sure on the internals of logging). However, in general I regard that as a design or implementation error: If your program calculates a result, you don't need to recalculate it to log it, and if it doesn't you probably don't need to log it. (Although you do have to sometimes do sanity checks to catch cheaters (hackers) - I don't know how similar that is to validating your inputs in a web app, as I don't do web).
FYI - example.com, example.net, example.org and example.edu are all reserved for use in documentation. If you're worried about people copying your examples word for word, just use them.
Just yesterday I was wondering how hard this would be. Thanks for writing this up! 
I learned Python 3.x as my first language. With a proper guide it's pretty easy to learn
Please don't do this. Just use GPGME. 
Yeah, I mention bpython, and iPython in the README https://github.com/jbisbee/python-shell-enhancement
Why not use emperor mode? UWSGI has a great process manager built in.
If you learn Python 2, you'll eventually have to learn Python 3. If you learn Python 3, you don't necessarily have to learn Python 2.
The website looks terrible on mobile
Cryptography is very hard to do properly. Writing a blog post, or consulting a blog post, on how to implement crypto in your code is like a nuclear engineer Googling "how do I efficiently cool a nuclear reactor?"
Correct. IVs have to be unique and non predictable. They're public and usually prepended to the cipher stream. Therefore using your AES key as IV makes your encryption as strong as rot13. Using another password is still bad, since it won't be unique nor unpredictable once you encrypt more than one message.
["Reusing the same IV for encryptions done with the same key lead to catastrophic cryptographic failures."](https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.blockalgo-module.html#MODE_CFB) In case you're wondering, here's what a catastrophic cryptographic failure looks like: $ echo -n xxxxxxxxxxxxxxxx &gt; test1.txt $ echo -n xxxxxxxxxxxxxxxy &gt; test2.txt $ python aesFile.py Choose encrypt(e) or decrypt(d). and 'x' to exit:e Enter password:secret Enter file path:test1.txt Choose encrypt(e) or decrypt(d). and 'x' to exit:e Enter password:secret Enter file path:test2.txt Choose encrypt(e) or decrypt(d). and 'x' to exit:x $ xxd test1.txt 0000000: 74ec 8d12 c977 8ca3 ee10 e408 4d16 5dce t....w......M.]. $ xxd test2.txt 0000000: 74ec 8d12 c977 8ca3 ee10 e408 4d16 5dcf t....w......M.]. The first block of the file is effectively XOR'd with a per-key constant, so encrypting two files with the same key is like reusing a one-time pad, and can be trivially attacked. To use CFB mode correctly, you should generate the IV using a secure RNG, and then write the IV to the beginning of the file. Note that this will increase the file size by 16 bytes. 
You're running everything as root? That sounds kind of dangerous.
I look at languages in two ways. One, for getting things done. This is how I approach a language on a professional basis, and it trumps any desire to learn a new language and apply it to a problem unless there is a compelling reason to do so. For example, I prefer Python over Ruby (I point out this divide because the two languages are often pitted as opposite sides of the same coin). I have written Ruby, and I like some of its design choices, but to move to Ruby purely to 'learn a new language' in a professional setting, without a clear motivation for doing so, would be a waste of resources and would probably impact my ability to deliver the end product--which, if scoped correctly, should be language agnostic. On the other hand, from an intellectual perspective, it's fun to learn new languages, so I do actively dive into new languages and paradigms on my free time. But ultimately that is a personal endeavor and akin more to self-education. As to how to learn a new language? My suggestion is to download an interpreter or compiler, find a primer or tutorial, and jump in. But I'm kinesthetic. 
it's been many years since I last used "RTFM". I just thought it'd be funny - in this context where OP just supplies us with a picture to tell his suffering.
If you copy and paste: def test(): print "this is a test" return "test" into the repl, it breaks. If you want to copy and paste large parts of what you just typed into the repl, you have to do it line by line. It's very interactive-unfriendly.
Any reason why tags at the top of your article are not clickable?
If you're not using Emperor, you can get that with touch-reload = %s (`%s` expands to the current configuration file.)
Sure, but I'd say it's better to be well-versed in the newer rather than the older. It's useful to know both, which I imagine most of us do (or at least can handle), but those who are just joining the Python family will be a bit more future-proof if they start with the newer.
&gt; When I next implement the code, I will be sure to generate a random IV. NO! WRONG WRONG WRONG WRONG WRONG **WRONG WRONG**! The lesson to be learned isn't "fix these specific things", it's *don't implement your own crypto*. This stuff is *hard*, and it's easy to make subtle, hard-to-notice mistakes which completely weaken your solution leaving you (and your users!) with nothing but a false sense of security. Just don't do it. Call out to a complete, mature, well-tested, well-understood solution like [GPG](http://www.gnupg.org/) (and even then, be careful to understand the security properties of the solution you're using). 
 if sys.platform == 'darwin': # different bind for OSX readline.parse_and_bind("bind ^I rl_complete") I sometimes use python on osx and was annoyed that completion didn't with "tab: complete". Thanks.
Where is all this weird optimism regarding Python 3 coming from? I mean, yeah, it's the declared future and eventually it will be what we all use. However adoption has been behind schedule, I have yet to see a company use Python 3 and none of the libraries I use have their documentation updated to Python 3. Yes, there are users (even prominent ones in the community) that force themselves to use Python 3, but overall there is a lot, lot more Python 2 and that will be around for years to come. At least currently that appears to be the case. It might change. The higher level code is the easier it is to upgrade with Python 3.3 now, assuming the libraries don't change their interface. So there is light at the end of the tunnel. But I find it very questionable to send beginners to basically unproven grounds.
That website is unreadible from mobile
Unreadible on mobile
Thanks, but there's no chance of it going into the standard library - it's a substantial amount of code, and it supports lots of not-so-Pythonic stuff for interactive convenience. As someone else has pointed out, though, the basic interactive shell has gained tab completion.
thanks for the link. I am aware of the Emperor mode but did not try. I will learn and wrote about it as well
Since I'm generating my HTML pages, I did not have enough time to write those category pages yet; need some time and I will do them.
I'm really sorry, I messed up the layout at somewhere, I will fix it. 
Use a tutorial for your version of language. It would be the same for Java &lt;7 and using String in switch or diamond operator.
Maybe so, but if you type that into the repl directly it also breaks, with the same error. The problem is in the code, not the copy-paste.
Yep, I first did it on my vagrant vm and then tried in on osx and was, "What the heck is this crap". My original post had you "uncommenting" the bind line manually and I figured if I'm going o put it up on github, I might as well put a little effort in it :) Actually I find the history between sessions to be more helpful (esp import lines) ;)
I just put it up on github and formally fixed an issue with OSX. But yes I was the OP on that post as well. This time its on github with install instructions. 
if you believe what you see on a reddit forum... then the entire internet may not be for you...i like how you tried to fit such a nice sentence into the punchline of my career? who said i had a career in programming? 
Not me, perhaps you'd like to try reading the punchline again, especially the "good move" part. Don't take stupid jokes on the internet so personally, "you" can just as easily be a generic pronoun, [not personal](http://audiour.com/playlist/fx1rur4y)
normally! but, it was a reply to my comment. you are right, though. i do get trolled very easy. I should not take things so heavily.
Nor I, it is a skill I am *slowly* acquiring through constant practice.
Hodor. 
Cheers!
The problem is with the repl. That's perfectly fine python code that works perfectly fine run as `test.py`.
Okay. Thanks. 
I was wrong - the problem is in the repll, not in the the copy-paste Thank you for the correction
&gt; Python versions 2.6, 2.7, 3.3 I don't see the option to pick version, is it there ? Also I'm interested in the course "Python for Finance" but find the fee too high, you know how I can get discount code ?
Holy shit on a stick... Please fix your site for mobile browsers...
What are you trying to do, exactly?
LOL Recently I needed to deploy an app on win32, non-tech users so I was looking to figure out a way to display to user run-time info and progress bar. in my ghetto way, I simply did this way: import webbrowser iweb = webbrowser.get(webbrowser.iexplore) iwebopen = iweb.open_new(os.path.realpath(myHTML)) The html is coded to refresh every 2 secs, with a "progress bar" via CSS. I write the user feedback lines to buffer and at points transfers content to the html file. 
oh boy
Please fix mobile site
i ended up using pyinstaller
&gt; I don't want to pollute my 'global' setup pollute ? actually this was my line of thinking back in the days before WinXP, I had this fear that software f*** up your systems (registery/dll hell) , so I was very cautious with installing software. So I never got addicted to games. 
will be waiting for this :)
It looks like applescript and automator.
I don't think "refactoring" is quite the right word for a change that's as simple as adding the following line to your supervisor config file: user=[whatever] So, note to all: it's easy to not run things as root. That's also true for every other process manager I know of. Just do it, eh.
&gt; do i need to inform the author of every library that i have used before putting the project out there? The "I'm an idiot" thing works pretty well. If you get an email, apologize and they'll let you know what to do to be compliant. I just put a copy of license for the various open source things I use. I doubt anyone cares. If I'm blatantly going to be in violation of the license, I email the person/group. They'll usually just be thrilled you're going to use it for something open source and GPL v2 vs GPL v3 vs Apache isn't something they really care about. My project is GPL v3, just because I'd heard of GPL and 3 &gt; 2.
It's more of a simplification for AHK, in certain cases.
thanks... cant seem to find my way around github. any help will be deeply appreciated.
I've been using it professionally for the past couple of years to automate systems which are otherwise impossible to automate. Very handy!
shouldn't it be "databases" ?
Which it is
Here some of my code that i use in ubuntu for accdb files. http://pastebin.com/4PUrmCmJ PD. Far as i know, this is the way that i could deal with mdb / accdb on Linux without having to pay for odbc drivers.
I agree, but I target this to a more beginner crowd, and if I mention user=[whatever], then they also need to arrange all the permissions for that user as well.. I completely agree for a production setup..
fixed now. Please take a look and tell me what do you think. Cheers
done!
fixed
It definitely takes some tweaking, but as long as you keep your thresholds high and do some basic error handling, it can work quite well. The only thing it doesn't do well is OCR...
I used sikuli to automate entering tickets in my old IT support job, out of a desire to remove the monotony of copy/paste this and copy/paste that. It led me to a promotion into a much better position that normally would have needed a CS degree that I don't have. I have fond memories of sikuli. 
it works by applying computer vision to your screen, and controlling the mouse/keyboard. so, no. also a second monitor wouldn't help.
the beta i was using last year seemed to be a fairly significant improvement over the original release. that said, it is intended for certain styles of automation where some fuzzy matching is helpful and simpler tools fail. if you just need to click on some win32-api-generated buttons all day long, there are definitely better choices.
It would interrupt workflow each time something had to be automated in the second monitor, but it's just an answer to having the browser minimized as OP asked.
On a side note, Tom Yeh is a super nice guy.
Ah good call. Added. Too bad the bar charts get messed up with missing data, so I have to temporarily disable r/learnpython on the charts until I get a week's worth of data.
most definitely.
[autoit](http://www.autoitscript.com/site/autoit/) and [autohotkey](http://www.autohotkey.com/). we had much better luck with one of them than the other, and frankly i can't remember which it was at the moment. basically you could tell it, with pure-text code, "find the window 'foo', menu item 'bar', click it. wait until a window called 'bar processing' opens, then... blah blah"
same here without the promotion :P so i changed my job :P
I don't see a license on it. Please add one.
Might be helpful to list the stuff you used to make that: d3.js is obviously being used, I'm pretty sure the filter thingy is crossfilter. http://nvd3.org/ # reusable d3 http://d3js.org/ # the original http://square.github.io/crossfilter/ # not sure if you spun this in or if its part of nvd3
Righto, the source is here: https://github.com/sloria/python-subreddit-stats. There's not much to it--the NVD3 defaults are pretty sensible. NVD3's multiBarChart with Focus provides crossfiltering. Oh, and [here](https://github.com/sloria/datasources/blob/master/scripts/rusers.py) is the script that uses BeautifulSoup to scrape the user counts.
That explains all the support tickets that go missing or never get responded to.
You might make the internals simpler by requiring a single callable: from functools import partial threadpool.enqueue(partial(foo, bar))
I love ``partial``. It's such a powerful feature.
You may already know this, but since this post is titled "For Beginners", I'll mention it anyway: You can call `sorted` on a dictionary to obtain a list of sorted keys. 
Presumably he/she means that feedback is generally in relation to something you have published. You haven't actually published anything yet (at least that's not what you're asking for comment on). So this isn't feedback you're garnering so much as, advice and/or related experience/thoughts. To be honest, it's a minor distinction.
So depending on what you are going to use "easypool" for, using threads for CPU bound tasks (such as some sort of scientific number crunching), threads are not the way to go. In general, it's best to uses *processes* for CPU bound tasks. Check [here](http://eli.thegreenplace.net/2012/01/16/python-parallelizing-cpu-bound-tasks-with-multiprocessing/) for benchmarks. The article suggests Python's multiprocessing, but I've found pprocess to be lightweight enough to replace multiprocessing. But again, this all depends on what you plan on using these threads for. I just wanted to maybe give a heads up and say congrats on your first module.
 from multiprocessing.pool import ThreadPool
Thanks for the reply. Clients should be pleased :-)
Dead horse flogging time, but that damn GIL. . .
cool!
wow, nice!
My pleasure :-)
awww
Yeah, my thoughts exactly...
 delimiter = '\t' Stop using CSV with those quotes.
 ssh_cmd = "ssh " + str(server) + " 'uptime'" ssh_cmd_list = shlex.split(ssh_cmd) what? ssh_cmd_list = ["ssh", server, "uptime"]
You need a mainloop for the async bus callbacks to work: from gi.repository import GLib GLib.MainLoop().run() or try listening to "sync-message" instead
Sikuli was what got me started as a programmer, so I've got a soft spot for it. However, when it comes to automating anything even slightly dynamic, I've found it to be very ill-suited to the task. Also, fair warning to would-be users: it is Jython, not CPython, so there are pieces of functionality missing, and often you need to check the Sikuli documentation for replacement-functionality (my favorite example of this being sys.platform, which helpfully always returns: 'java'. You need to use Env.getOS() for that.).
This isn't a guide to getting around the filter, it's an ironic rebuttal that blocks anything that isn't porn.
yeah
It kind of surprises me that multiprocessing would hit a sweet spot for people; who is it that is CPU-bound, but keeps that part of the program in Python? Every time I end up using the thread pool pattern it's because I have a lot of (disk or network) IO going on. And threads are fine for that.
This looks quite excellent; good pictures and runnable code. Now if only it had some animated visualizations!
For running tasks on multiple hosts in parallel, it is probably easiest to use fabric. `pip install fabric`, then creating a file named `fabfile.py` with the following contents: from fabric.api import env, task, run, parallel env.hosts = ['127.0.0.1', '127.0.0.2', '127.0.0.3'] @task(default=True) @parallel(pool_size=5) def uptime(): run('uptime') Then, just type `fab` to run it. http://fabric.readthedocs.org
There might have been better solutions, but +1 for trying and publishing!
I realize that particular command list shlex.split is overkill, but if uptime was replaced with something more fanciful like: 'ps aux | grep python' then it would be a more appropriate option. 
I'm not sure I understand what you mean by that. If you want to know the identity of the worker threads and give them persistent names you can use threading.local() for that.
The one thing that bothers me here is that it doesn't (at a glance) appear to be about problem solving, but rather about algorithms and data structures. This is a criticism of the title, not of the content - providing authentic contexts for these things while keeping the scope limited is hard if not frequently impossible. That said, it looks interesting and might be really useful to some. I'm currently working through Structure and Interpretation of Computer Programs myself, and while this isn't quite the same it looks like it might provide some of the same information except in a language that's slightly more relevant and/or hip these days ;)
I just started reading this a couple of days ago. I'll also be making use of [this](http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/) to learn about algorithms.
I will look into it. I've also enjoyed the recent [Coursera on Algorithms](https://class.coursera.org/algo-004/class/index).
I was trying to mean that the behaviour of the library resembles almost exactly the futures one. I don't have data about performance...
oh great that you loved it! cheers
Indeed, I am not that sure about that "outperform" because you are not taking into account that you have to write control code that would be probably less optimum of such in the standard library.
The GIL is awesome. It reminds us that threading is evil and that everyone else is doing it wrong. 
No, I want a pool of servers to work on my data. ServerA, ServerB, ServerC I have a server pool of these 3 servers and 100 function calls that need to be processed by this server pool. I don't care which server processes the data, but I only want each server processing data one piece at a time. So ServerA, ServerB, and ServerC receive all receive data to process; ServerC finishes first it immediately receives another function call to process. ServerA finishes, it immediately receives another function call to process. I want to keep this pool of servers always busy, but want to limit them to only processing one thing at a time.
Thanks for your quick reply! It looks really nice! I hope you get a lot of collaborations. I'll keep an eye!
Thanks for your quick reply! It looks really nice! I hope you get a lot of collaborations. I'll keep an eye!
&gt; outperform wat? when did I say that? I just commenting on the interface. I have no idea what the performance of either of them is like.
I was looking at the ast module and noticed that, even for small programs, the ast.dump() routine produces output that is too large to be useful. I therefore wrote a small AST viewer in QT. You need to install [PySide](http://qt-project.org/wiki/Category:LanguageBindings::PySide) to run it. Here's a [screen shot](http://i.imgur.com/po2gkT0.png). Hope you like it. 
glad you liked it.. I do have more articles on the way; hope people will like. What kind of articles would you like to see MarCialR ?
I do a lot of number crunching, statistical analysis, and machine learning. A lot of the libraries I use Python libraries (numpy, scipy, sklearn) and yes, parts are written in C, but I still get very nice performance gains by parrallelizing random forests across multiple processes instead of multiple threads.
suggest you supply screenshot(s) to the Gtthub page
It does say that it's good for 3.x, but in practise, it throws up all sorts of errors when you try and import it. I've installed it separately to both Python 2 and 3. It works fine in Python 2, but this won't be an option for this application.
The hard parts of creating an API are not the technical, mechanical problems but the decisions you have to make from a user perspective. I don't see any of this in your post. Also this is just a setup post and now people have to wait for part 2 to go any further. I think the people that see this probably won't wait around and come back. A better approach: get more than 1 post together and post them at the same time (or stick them in the same post). That way readers can be more engaged and start getting into the problem.
It seems like you could do this a lot faster and easier with the [pandas io module](http://pandas.pydata.org/pandas-docs/dev/io.html). After you get the JSON from the files: dataframe = pd.read_json(json) dataframe.to_csv('myfile.csv')
Can you post a dump or point to a pastebin of your error messages?
I went to do exactly as you had asked, and now I no longer see an error :|. I love computers haha.
Edit: I'll give your suggestion a try now Interesting dilema: It's *now* getting the eos messages out....no idea what changed, but it's still only playing the first and last song. So I guess my question now is why isn't queue blocking until the song ends?
I've been planning (for, like, 7 years now, sigh) to do this same thing with my CNC mini mill. The idea is to render out a turntable of a 3D figure from Maya, then use the alpha channel to mill away all the stuff that isn't in the silhouette, turn the material a bit on the rotary table (also CNC), and repeat with the next image.
You're welcome :-) If the problem comes back, send me a message.
You say it predates, what I interpret as perform better... but maybe you didn't want to say that
older != better, just older. I honestly have the opposite bias, so there's that.
"proof"? both python 3 and python 2 use a tabstop of 8.
There are so many complex problems that can become much simpler when you allow for a bit of random approximation. I love it.
I wish pip advocates would remember that pip is utterly useless for any project which needs compiled extensions and must deploy on platforms where a build environment is not readily available out-the-box. That means anything which isn't a web app and any platform which isn't *nix. The far greater majority of computing devices out in the world can't recompile stuff (I'm thinking phones, tablets, Windows boxes). Good luck pip installing a GUI library on any platform at all. Pip is not the solution. Setuptools may not be perfect but its the only option for all non-web-app development.
Well, it all depends, I told you I have no data, but it is easy that code that has been in a code base for a long time use to be better if it is constantly reviewed.
Have you taken the time to look up what Wheel does? Maybe you should.
Great article, serendipitously posted just as I was needing it. &lt;3 
You might have a look to this for the math of the process: http://en.wikipedia.org/wiki/Radon_transform 
No. I'm not even switching for my personal stuff, I don't see a point and I don't like the print function. Python3 zealots are approaching the annoyance level of lisper weenies.
You're not switching because you don't like the print function? 
and what? 
Among other things, yes. It's a small detail, but very annoying, and could have been easily avoided. More seriously, on one hand there's no compelling features yet, on the other hand, library support still sucks (and it's all Python core devs' fault), so no point and a lot of hassle in switching. And the argument that I should feel grateful to Python and reward it by suffering the new version just feels totally wrong.
I for one would love to see scalability tips and any deployment guide like this one. Good work.
Give them a shared Queue? http://docs.python.org/2/library/queue.html
would be nice having it in epub format.
It's just a small design decision. If it doesn't scale at some point then I would move the services to a separate module within the logical package.
There were some interesting talks at this year's pycon, particularly the ones on iteration, logging, and what's new in python 3 that could point you on a few directions. Check pyvideo.org, I believe.
Right, thanks. I realize that this is probably the case. Are there any good books or online resources to get a better background in theory and design aspects, preferably with examples in Python than in other languages? Obviously I won't be able to get to the same level as a CS-bachelor's on my own, but perhaps there's a book that would give me the best 'bang for my buck' in this regard?
give this a try, it's not Python specific but is very much CS orientated. http://cs50.tv/2012/fall/
Hmm, looks interesting. Thank you.
There is also [MIT 600](http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-00-introduction-to-computer-science-and-programming-fall-2008/) which does use Python. I have taken neither course so have no idea how they compare, though I am sure someone here could give a good indication.
.
Pick up Beazleys latest version of the Python Cookbook - great reference for improving your programming and teaching you about Python's good stuff. Also I'd pick up Data Analysis using Pandas - another excellent book which might be right up you're street.
Specific topics you should look into for a better grasp of CS are software engineering (version control, documentation, software architecture, development methodologies), algorithms and computational complexity theory, operating system theory, compiler and interpreter design, and maybe computer architecture.
im in the same boat as you. I'm getting an AS degree right now in physical science before transferring to a 4 year program for physics chem or biology (really have no idea yet) but I do some programming in my free time, since I thought i was gonna go for computer engineering and was involved in robotics through high school. Coding is fun, but I don't wanna major in it. What I've done to improve vastly is focus on computer science and not the syntax of python or javascript (the two languages Im getting comfortable with now), but instead the logic and theory behind what the languages do. I'd strongly reccomend taking CS6.00 from MIT OCW if you want to speed through (since you're familiar with python already) and just focus on the computer science theory behind it all. I know a guy at carnegie melon who is a neuroscience major who does hackathons/coding in his free time and he focused on learning comp sci before actually getting strong with any given language, and now he can pick up most languages depending on their benefit within a matter of weeks insteads of months of just messing with them. 
IME mit courses are excellent. Helped me get through my EE series but have never tried their computer science courses.q
Get *Refactoring,* by Martin Fowler. This isn't a Python book. It's a book about writing better code. There are other good books on the subject as well, and maybe someone else prefers a different title. (I think if others would make some suggestions, that would be helpful.) This is what I think you should be reading, if you haven't been reading this stuff already.
You might be interested in [The Hidden Features of Python -- Stack Overflow](http://stackoverflow.com/questions/101268/hidden-features-of-python)
I have PhD in humanities, and I've taken [MIT 601 this year](https://www.edx.org/course/mit/6-00x/introduction-computer-science/586), and it was an amazing experience, really awesome, problems were difficult and most concepts required a lot of attention, but it really teaches you a lot. You might be also interested in [EDX course on quantum computation](https://www.edx.org/course-list/allschools/computer%20science/allcourses) I'd love to take it but don't have enough time. There is also Harvard's intro to computer science on the same platform, but I didn't enjoy it as much as MIT course.
except it uses Ruby. It might just be me but when I start fiddling with Ruby my python suffers due to the similarities
I'm a physical scientist as well. Once I got comfortable with python, I started taking algorithms courses. I took the one offered on coursera. It's in Java, but it's always good to learn more languages.
Awesome! Thanks! If only there were [more accurate corpora for sentiment analysis](http://www.reddit.com/r/compsci/comments/1gpdb9/nlp_how_can_i_get_the_computer_to_understand_the/camicro). * https://en.wikipedia.org/wiki/Natural_language_processing * https://en.wikipedia.org/wiki/Computational_linguistics
In terms of code quality you might want to take a look at Flask: https://github.com/mitsuhiko/flask it's a web-framework. It's small, very well documented, well tested, and the source code is a very good example of how a good python project looks. Perhaps you could use it to get ideas about expanding in python. Also the source code for Python is good as well. The default Python interpreter CPython is written in Python and C and will give you a good look at how python actually functions
Build something in Python. Not really important what, just build something.
In my experience, iPython notebooks are far, far superior to IDLE for teaching. There's something very powerful about the way it interprets code in small chunks.
To learn algorithms, use [CLRS](https://en.wikipedia.org/wiki/Introduction_to_Algorithms). If you are creative, you can find versions online. This is not a Python book. In fact it's not an *any* language book. All examples are expressed in pseudocode, and analyzed using good ol' math. To learn design patterns, use [Design Patterns: Elements of Reusable Object-Oriented Software](https://en.wikipedia.org/wiki/Design_Patterns). Again not Python, rather cpp and smalltalk. Should be easy enough to port back and forth. Of all the resources I'm listing, this one is the *least* necessary. To *really* learn Python, basically go through [this](http://stackoverflow.com/questions/101268/hidden-features-of-python/113198#113198) and [this](http://stackoverflow.com/questions/2573135/python-progression-path-from-apprentice-to-guru) thread and make sure you understand everything. Implement some stuff using the concepts you learn. Here is another great SO answer on [decorators](http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python/1594484#1594484), and one on [generators](http://stackoverflow.com/questions/231767/the-python-yield-keyword-explained/231855#231855). Also understand how to write stuff [in a 'pythonic'](http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html) way. Then choose an open-source Python library you really like to use, and figure out how it works. Do so by pulling the code to your local box and tinkering around. Change things here and there, see how it reacts. Add things, see what breaks. Perhaps [Flask](http://flask.pocoo.org/) or [Django](https://www.djangoproject.com/) would be a good start? Or since you're a science person, something like [SciPy](http://www.scipy.org/), [Biopython](https://github.com/biopython/biopython), or [scikit-learn](http://scikit-learn.org/stable/) (a machine learning library) would be more up your alley. If you don't have time to dig into an open-source project, you could get into the habit of reading some [Python recipes](http://code.activestate.com/recipes/langs/python/) in your spare time. You'll still learn a lot. If you're *really* intent on a one-size-fits-all python-only approach, I found these searching around: * [Data Structures and Algorithms with Object-Oriented Design Patterns in Python](http://www.brpreiss.com/books/opus7/) * [Problem Solving with Algorithms and Data Structures in Python](http://interactivepython.org/courselib/static/pythonds/) * [Think Complexity](http://www.greenteapress.com/compmod/), a really neat-looking algo primer in python. On the software engineering side, [this](http://ivory.idyll.org/articles/advanced-swc/) looks super-useful. 
I would recommend finding a program you use that supports python plugins (google drive, xbmc, etc.) And trying to write a few. Most programs that support plugins have active wikis, forums, and guides to get you started. There is nothing worse trying to learn for the sake of learning. Make something useful to you.
That is simply wrong. It uses 3 different programming languages: ML, Racket and Ruby to show the difference between languages by teaching general programming techniques instead on focusing on one specific language. 
This looks very nice, can't wait to start tinkering with it! also a big thumbs up for your free ebooks!!
You should have a look at [Think Complexity](http://shop.oreilly.com/product/0636920022480.do) by Allen Downey. It's a great walkthrough of a whole range of CS concepts, like cellular automata, Turing machines and hash tables (i.e. it teaches you how Python's dictionaries actually work). I'm also self-taught, and I've been surprised at how many of these things I've managed to implement using the guidance in this book. It's definitely a book for self-motivated learners, as there's not a lot of handholding, but if you want to understand more of the computer science fundamentals, it's pretty fantastic.
I suspect that the biggest benefits to your code would probably be around design patterns, data structures, and code choice. As always, the best way to learn this stuff is by doing. Reading books is nice, but in my experience it won't really sink in until you use it and need it. Writing something object-oriented with complex inheritance hierarchy and composition of classes will teach you about the good and bad of such an approach. Similar with functional approach. Fortunately Python offers the opportunity to try both. Keep building new projects and even get involved in open source projects or at least browse code you can find on GitHub if you don't have regular programming partners. The biggest boost I ever had was when I first started working on a professional team, writing code every day, having to read, review, fix others code and having the same done to my own. Books I recommend, which will give things to think about for users of any language: [The Pragmatic Programmer](http://www.amazon.com/Pragmatic-Programmer-Journeyman-Master-ebook/dp/B000SEGEKI/ref=sr_1_1?ie=UTF8&amp;qid=1375225249&amp;sr=8-1&amp;keywords=the+programmer) [Code Complete](http://www.amazon.com/Pragmatic-Programmer-Journeyman-Master-ebook/dp/B000SEGEKI/ref=sr_1_1?ie=UTF8&amp;qid=1375225249&amp;sr=8-1&amp;keywords=the+programmer) 
What if the libraries I use are not compatible with Python 3? Should I just rewrite them all or what?
I'm curious what other neural net packages you evaluated. I'm interested in playing around with some neural nets, however without some decent documentation I'd be leary of pylearn.
Really? That's all the rules to the game? It seems like it should be possible to identify an optimal strategy using Game Theory, given how simple it is...
This isn't a complete answer, but I'm pretty sure they're both supposed to serve the same purpose. Agent, I think, is the newest implementation; I suppose HttpClientFactory can be thought of as urllib, and Agent can be thought of as urllib2. Twisted is honestly a bit of a bloated, overengineered mess in my opinion. Unless you're working with code that depends on it, I'd recommend pretty much any other asynchronous networking framework.
Check out [Software Carpentry](http://software-carpentry.org/v4/index.html). They have (free) lessons targetted specifically toward scientists wanting to round out their CS skills, including version control, unit testing, object orientation, etc., all with a focus on Python. 
One nice way to learn interesting tricks about any language, math and general problem solving is to try your hand at http://projecteuler.net/ it has some interesting problems which will give you practice at various concepts, and if you look at other people's solutions (there are plenty done in python) you might find something that could be of use to you in the future.
does pypy3 support CFFI? because if it does then I think everything on my end is ready to move over to python 3. can't wait to use all the new and shiny py3 stuff and fixes into my code bases!
I think PyQt is the best GUI framework for Python2/3 at current phase. There are all-in-one binary setups for Windows at this page: http://www.riverbankcomputing.com/software/pyqt/download5 It shouldn't be difficult to install it on Windows 7.
I wanted you to know aside from the upvote that I've actually signed up for this. I took a couple CS courses in grad school, I'm a linguist (not a doctor, dammit!) and work in tech. I actually do use Python and SQL in my job, and I touched Java the other week for the first time in a decade. Made me want to get my programming on. This course looks awesome! Thanks!
gevent http://www.gevent.org/
I've previously downloaded PyQt5 from that link, but I haven't been able to make/nmake the file to install it, as I don't have Visual Studio or similar. Is there a way I can do this without trying to find an executable? Also, you are indeed a very handsome GUI. EDIT: I'm installing MSYS at the moment, which should let me make install the PyQt5 source.
Lovely looking api - thank you for this.
I'd like to add, when you're deriding all or part of the code as being absolutely woeful - you know you've reached a higher plane of coding existence. Especially if the code you're reading is your own, from several months/years ago. 
To add to what other people have suggested: something I've found lacking in a lot of scientific computing (as opposed to Computer Science) is *testing*. A typical thing is that a code is written for a particular project, it's fiddled with till it gives the expected answer for a particular problem, and when the next project comes along the process is repeated. This is a very error prone way of doing things and guarantees you won't be able to replicate your previous projects. For every bit of code you write you should write tests, combine this with proper revision control and make sure you run the tests before you commit (to a stable branch). Have a look into topics like: test driven development, unit-testing, regression testing and automated testing. Learn to really understand the very important catch phrase "if it's not tested, it's probably broken".
I don't know off hand if the beta has it, but the final release will absolutely have cffi.
Get to it! :)
As a scientist, I agree. I have see far too many errors - and corrections/retractions of journal articles! - from simple software bugs like off-by-one errors that testing would have have probably identified.
Nope, but it's a blocker for release. 
https://github.com/nitipit/appkit/ Using html for ui 
Looks great. Does it have multilingual support?
That looks like fun. I like games that punish and reward risk.
NLTK master (https://github.com/nltk/nltk) code is fully Python 3 compatible. It is not released as NLTK3 because some of pre-built NLTK models are not Python3-compatible yet, but this is being worked on. Why are you bundling it instead of pointing users to the github repo or some alpha release (like http://nltk.org/nltk3-alpha/ )?
I've added a link to it in [Green Tree Snakes](http://greentreesnakes.readthedocs.org/en/latest/), my guide to working with ASTs.
Thanks. I'll have to experiment with that and see how it ties into eclipse. 
I'm a long time eclipse user for java and started debugging some python this week with eclipse and the pydev plugin. * download "Eclipse Standard" [http://www.eclipse.org/downloads/](http://www.eclipse.org/downloads/) * unzip * launch the eclipse binary * Menu: Help &gt; Eclipse Market Place * Search for Pydev and install * Restart Eclipse * With the source file open in eclipse double-click on the left of a line to set a breakpoint * Debug by Right-Click &gt; Debug as Python 
Buy a copy of the Python Cookbook. If you want to have literally hundreds of expert peer-reviewed examples of how to use Python to solve a problem, then the Python Cookbook is your friend. David Beazley's version is for Python 3, Alex Martelli's version is for Python 2. Both these guys are very clever and highly respected in the Python community.
How about **kivy**? &gt; "Open source Python library for rapid development of applications that make use of innovative user interfaces, such as multi-touch apps." If not, I'd highly recommend PyQt.
My life changed when someone introduced me to IPython embedding. from IPython import embed; embed() If you are at all familiar with ipython, this will drop you to an ipython shell when you hit this point in code. One better if you are using a web framework like django or flask, if you are using the dev Web server it drops you to a shell in that window allowing you to check variables etc. 
I've been coding python for ~6 years professionally. I've never used anything other than print and logging statements for debugging ... and well one other important thing... The big secret, is to use iPython ... and to code and debug predominantly in the interactive shell. So rather than coding everything in an IDE, sprinkling break-points and log-statements ... I spend 99% of my time working out my logic in the interactive shell. Once I have things working as they should, it gets pasted into vim and tested once more in the actual app before I hit commit. If you are so inclined iPython has pdb built-in with some convenience methods as well. So though you may be used to coding predominately inside an IDE ... that's not really the way to go with a language like python ... you'll be a lot better off learning iPython inside and out and pretending it's your IDE. For large applications I usually will take the time to sprinkle a modicum of logging statements at various levels (error, debug, etc). You can use pygments to format tracebacks, sql, etc for fancy colored output to your terminal session ... or html or what-have-you. These are mostly for issues encountered in production though (usually performance tweaks and the like), rather than debugging issues encountered while initially putting something together. Also ... another simple, yet effective trick with print statements is to remember that you can access most python object's attributes with \_\_dict\_\_ ... iPython has tab-completion ... but it's not always easy to go the shell-route ... especially with existing/crap code. *formatting
If you have IPython and you want to drop into a full IPython shell at a point in your code (and will have all local variables in scope etc), add this at the line you want to drop to: import IPython; IPython.embed() Otherwise, if you do want a debugging stuff like step, continue etc, you can also use import ipdb; ipdb.set_trace() which is much nicer than pdb mainly because of tab completion... Can't remember what property of my_obj you should be using? As easy as my_obj.&lt;tab&gt; 
I thought I was the only one coding this way. Thanks for your post
I just realized I never answered this. What my company or me would pay are entirely different things. My company would easily pay 400 us$ (keep in mind that there's a conversion rate in my country) for an employee course but they also don't choose them. One applies and demonstrates how it will be useful for your job. They might pay for a good or bad course. I, on the other hand, wouldn't usually pay for something unless it was something that would be really hard to learn on my own and I felt having an expert I could physically reach would ease the process. If it's just an e-course. You'll be competing with the immense variety of udacity, coursera, edx, mitx, etc (and those are renowned). That said, I purchase lots of programming books (physical) but their credentials are usually well established.
&gt; So though you may be used to coding predominately inside an IDE ... that's not really the way to go with a language like python ... you'll be a lot better off learning iPython inside and out and pretending it's your IDE. This is indeed a very different approach to development. I'll have to read up on IPython and try it out. Thanks.
Man... I have half a mind to rewrite my whole project with gevent... In the meantime it's nice to know I'm not the only one cursing at Twisted.
Wow that's fantastic. They should implement this in the standard packages so that you can do it without IPython.
I agree.
I think Kivy is more suitable for touch-screen oriented mobile platforms. For desktop app, i still prefer PyQt.
Reading all the replies in this thread, the only thing that stands out is "no you can't", but there are crazy workarounds. This should be changed. If there was an IDE like visual studio for Python, life would be glorious... so much more efficient debugging via breakpoints (for me anyway). It feels dirty littering my code with all sorts of logging statements. I don't know if this is the standard way in other languages, but when I was coding in Java I desperately wanted something that could mimic the breakpoint/debug features of VS. Closest I've found was eclipse and even that was "meh".
Also - print statements are nice but look at using a logger. Makes it much easier. 
Along those lines, ipdb. pdb except it uses ipython as the interpreter.
You can do it with pdb.
You dont need iPython. from code import interact; interact() *Use ctrl+D to exit.
Everything can pretty easily be done except for maybe the Dazzle part. You would use the gmail api to search all your emails for one containing "Mailing Contacts". You would then download the attachment. You would then convert the xls to csv (using something like [this](http://stackoverflow.com/questions/9884353/xls-to-csv-convertor)). However, you would not be able to easily import the document unless Dazzle supported it. I don't know it well enough to say.
does this work when developing applications that run in a loop, like PyQt GUIs?
There is a Microsoft-made plugin for VS that you can download [here](http://pytools.codeplex.com). I haven't personally used it, though. I use PyCharm from JetBrains, while others out there use wing. 
There's a Python plugin for VS and it looks pretty neat. 
You can use visual studio for Python. Just download the add-on.
ipdb is awesome, sadly it doesn't play well with gevent.
Thanks for your post. Yesterday I had started with watching the OCW version (just the first lecture), but then after your post signed into edX and saw that the version there was much more recent. At the very least, the video quality is much higher. Good so far.
Can you talk more about your workflow for this? I've mostly been using Django and sometimes I'll go to the shell (with manage.py shell) and mess around with my DB models or other code. The problem is that then I may want to modify a class somewhere. So I switch to my editor and change it. Since there doesn't seem to be a good way to reload things I need to exit the shell and restart it and then rerun imports and all that. IPython makes the last part a little easier (can type 'from' and hit up to get to the last couple of imports, etc) but still a pain. After doing that couple of times, I usually end up making a little script file that I run from the command-line instead just to make things easier and then delete it when I'm done. How do you handle that kind of situation? Are you modifying the class definition directly and then just getting a new instance? What if you're modifying a function? Is there an easy way to get and modify the source of the function from in ipython? How do you keep track of the various different stuff you changed to make sure it all gets back into the sourcecode?
I love you for showing me this
I like [winpdb](http://winpdb.org/about/). I don't use an IDE (emacs), but I like GUI debuggers better than straight pdb because I can visualize things a bit better. Even works on remote python processes. (To defuse a common misconception: no, *win*pdb is not just for *win*dows, it's just an unfortunate name.)
I've started using [wdb](https://github.com/Kozea/wdb) in my projects. It's really useful, especially when you use the `w` builtin, allowing one to invoke the debugger whenever `w.tf` is encountered, along with unhandled exceptions.
You would probably love ipdb
I personally like the pycharm IDE the debugging features in that are a dream. If you are coming from a visual studio background it will come easily to you! 
If you're coming from VS might want to check out any of the popular Python IDEs out there that give you project management, interactive debugging, breakpoints, watches, etc. I've used Pydev (add-on for Eclipse) and Pycharm but there are others out there worth checking out.
I just use logging, print, unit tests, and breakpoints (Eclipse debugger). Awesome question though, I see there have been a lot of answers I can get good tools from ^_^
I try to use "assert" and "raise" when I'm debugging.
From the announcement and discussion thread: https://groups.google.com/a/continuum.io/forum/#!topic/numba-users/FCektSC4sUQ &gt;Hey, &gt; &gt;In my quest to create a more expressive, more easily understood and &gt;performant numba, I've created a proposal which can be considered as &gt;somewhat of a redesign of the numba "language". It will focus far less &gt;on the CPython side of things, and instead mostly live in its own &gt;world. Objects will still be allowed, but it should be possible to &gt;write many useful numeric or other codes without it. A more &gt;sustainable approach towards NumPy support will be taken, where a &gt;subset of the NumPy API will be provided (maybe under a different &gt;namespace), making it clear what is and isn't supported efficiently. &gt;It will support data-parallel operators like map/reduce etc. &gt; &gt;The goal is ultimately to allow (near) zero-cost abstraction and write &gt;and implement nearly every component in a runtime (including complex &gt;numbers, range, etc). It will further bring optional static typing, &gt;Rust-like traits, and actual parallelism that runs unconstrained from &gt;the GIL without sacrificing any language semantics. It's actually not &gt;as ambitious as it sounds, with a few core abstractions numba can be &gt;much more powerful and easier to implement at the same time. You can &gt;read about it here: &gt; &gt; http://markflorisson88.github.io/numba-nextgen/ &gt; &gt;By default objects will not be used, and it will be easily &gt;understandable which things can run on a GPU. It combines the best &gt;things of several languages, most notably Rust, Terra, RPython and &gt;Julia. It's also influenced by parakeet, mypy and copperhead. &gt; &gt;A short overview: optional static typing, generic functions, rust-like &gt;traits, compile-time overloading, control over object representation, &gt;control over unrolling, specialization and inlining, control over &gt;memory allocation, &gt;control over type promotion, coercion and conversion, and over &gt;mutability. Different threads have different garbage collectors &gt;allowing them to run in parallel without any locking. Immutable data &gt;can be safely shared, mutable data may be borrowed. Communication &gt;happens explicitly over typed channels, or higher-level abstractions &gt;like parallel maps. Finally, different exception models may be &gt;supported (costful as well as zero-cost). &gt; &gt;There's also ideas to extract native functions from C extension &gt;modules, allowing faster calls into native (recompiled) CPython code. &gt; &gt;Feedback and suggestions are more than welcome! &gt; &gt;Mark &gt;
Could you elaborate a little on how to use these introspection methods? I don't quite follow what they mean.
its not as complex as it sounds. here's a few of the ones I use most commonly: * calling the .\_\_class\_\_() method on an object to make sure it is what its supposed to be * calling the .\_\_dict\_\_() method on an object so I can take a quick look at the values of all its attributes * putting a suspect block of code in a try/except statement and catching as many values as I can think of (that might be useful) in the exception that I expect will be raised * in the case of a bug that isn't raising an exception, I'll put in a logger set to the most verbose log level and try to log entering and returning from every method that might be responsible for the bug
First: pip install debug Then in python code: import debug
The bundled NLTK is from the NLTK master branch. It will be updated with each textblob release. It's bundled to make installation easier for users. As far as I know, NLTK3a isn't available on the PyPI.
What's with all the sleeps? I would consider using functions and dictionaries. Dictionaries are a nice way to map things together. In your case a unit name to conversion function. Or since it looks like all of your conversions are linear you could just provide the linear conversion parameters (y=m*x + b). And maybe I missed something, but it doesn't actually print the "red chart". There are probably other things I would do differently, but that doesn't make your way wrong.
I can see that test driven development ties in nicely with python's __class__() and __dict__() methods. Thanks for reminding me about starting to use that. :) 
Sorry, only English (for now).
&gt; so much more efficient debugging via breakpoints (for me anyway) The "for me anyway" is key.
If you like Gtk, then you should look at pyGobject. It's the new binding for Gobject and Gtk for Gtk3 that works with python 3. If you're leaning towards Gtk because of Glade, you should also take a look at Qt Designer.
&gt; ipdb Honestly... I've never heard of it. It looks pretty nice.. This especially has me excited: with launch_ipdb_on_exception():
WingIDE has a great debugger that will jump to the point of a crash automatically. You can then print out any needed info and jump up levels to print out the values going into a function. You can also stick a little breakpoint in your code as well as track how variables change. I don't get why more people on /r/python don't use it. PyCharm is pretty meh for debugging. http://www.wingware.com/
You, sir, just made my life a lot easier. 
As a PTVS (Python Tools for Visual Studio) user, I use breakpoints, immediate/interactive and watches extensively. My only problem is that I cannot edit the code and have the edits be applied to the current debugging instance. I wonder if this can be fixed.
There was a good video on blip.tv or youtube by Barry Warsaw (I believe) showing basic usage of pdb from the command line. I don't use pdb much. In vim, I have the following setup to run the current buffer using pdb *autocmd FileType python map &lt;buffer&gt; &lt;M-d&gt; :w&lt;CR&gt;:lcd %:h&lt;CR&gt;:!start python -m pdb "%" &lt;CR&gt;* 
pip can install requirements that are not in PyPi. For example, you could provide requirements.txt file with the correct requirements, or just instruct users to run pip install directly: pip install git+https://github.com/nltk/nltk.git#egg=nltk You can also include commit sha in url (or git tag name), like this: pip install git+https://github.com/nltk/nltk.git@34719e61b5c1d6bade1c51408927d990ad9af140#egg=nltk If I'm not mistaken, currently your package will silently overwrite installed NLTK with the bundled version, and there is no way to prevent it from doing so - this could be very annoying.
How do you handle larger projects that is split up over several source files? The current buffer might not be the program's entry point. I.e. you can't just execute a class. Do you have to switch to the buffer containing the main function first? 
Some more context, this is an excellent example of a very Pythonic lexer and parser and an implementation of the [shunting-yard algorithm](http://en.wikipedia.org/wiki/Shunting-yard_algorithm). I look forward to seeing how this will be used in [Bubbles](https://github.com/Stiivi/bubbles).
You can reload modules in ipython like such: my_module = reload(my_module) You'll need to reinstantiate any objects that have changed though. I think I recall there being a way to automatically update the code in ipython. Oh yeah, here: %load_ext autoreload %autoreload 2 But I can't remember that usually and I don't like typing it for every session.
python -mpdb script is my buddy. Surprised not to see it here...it's everywhere and enough to see what's happening. If I could list functions in other files it'd do everything I want. 
You need to compile python + qt with debugging, then you can use gdb.
The assumption is it is the main project file. To answer your second question, you could have a switch that goes to the primary python script file. The simplest approaches would be to use the same name main file name for all your projects or have some configuration file that defines what it is (I believe that's what most IDEs do.).
But if course you can. Even pdb does breakpoints and there are loads of more complex options. 
&gt;I don't get why more people on /r/python don't use it. PyCharm is pretty meh for debugging. Because JetBrains semi-regularly have sales that massively decrease the cost as a barrier to entry; contrast this with WingIDE, which I've literally never heard of going on sale (nor should it need to) Because JetBrains produce other IDEs, which provides name familiarity and reassurance to those coming in via other languages. Additionally to that, because JetBrains provide many apps, their name recognition is more widespread, and thus more likely discussed. Because Wingware seem to do nothing in the way of marketing. Because WingIDE apparently requires an X11 server on OSX. I don't think that's available by default in 10.8? Those are the reasons I cash think up, good or not. 
As the other guy said .. you can reload your imports in iPython ... which should be a lot easier than restarting and re-importing everything. Usually I try and avoid that as well and edit/subclass within iPython. A lot of times I'll try and work with a concatenated version of what's actually in the source code. When things start to get a bit longer than a couple lines ... I'll use a scratch-pad ... where I'm editing what I need for the shell and copy/pasting it back and forth. The other slightly more elegant option is to sub-class what-ever class you are working on ... allowing you to add/modify a class or class's method without much effort (super comes in handy here). ...and as far as guaranteeing everything makes it into the source code ... I use the lord jesus christs' mighty powers ... kidding I just try and do it by memory.
I prefer print statements and spending time to really get to know the code. It isn't always the best approach, but it is often *far* better than using a debugger - which tends to make it harder to see the big picture. I've known quite a few programmers that use a debugger too much and only modify code through tiny little ugly duct-tape patches because they don't get the big picture.
Fair enough. JetBrains does a good job marketing. &gt; Because WingIDE apparently requires an X11 server on OSX. Really? Weird... Do many programmers use Mac?
Thank you for the `sys.excepthook` tip, catching exceptions this way looks very handy. I modified your example to use ipdb instead since I like using tab completion. It also prints the exception beforehand: import ipdb import traceback def excepthook(ec, ei, tb): traceback.print_exception(ec, ei, tb) ipdb.pm() sys.excepthook = excepthook
I like the idea of doing a subclass in the repl. Seems like something you'd want in some cases for new functionality anyway. I think some of my difficulty with Python is sometimes it feels a bit between the extremes. In C#, you can't do too much in a repl so experimentation would usually be done in a special scratchpad like LinqPad. Then in something like Clojure, the editors usually have capabilities to easily send a code block to the repl and change things on the fly. 
When I'm using PyDev or pycharm then I do use breakpoints for my debugging. That way I don't accidentally leave debugging print statements in place as I tend to do when I'm developing using emacs/vim/st2/etc where I usually just add print statements rather than using pdb.
I'm also a newbie so feel free to pick my code apart :)
check out TK/Tinketer. v8.5+ are cross platform and not godawful to look at. Very easy to use. 
Same way you could change your accent (say if you were taught british english and you want to sound like an american). Just find someone who you admire for their fluency, and emulate them. Make it a habit, and eventually, you'll develop your own fluency. 
I think even `reload(my_module)`, without the assignment, will work. Not sure why, but it seems to in my interpreter.
&gt; JetBrains semi-regularly have sales How regularly? I'm actually testing PyCharm now and it's a clear improvement over Eclipse/PyDev for me, so considering buying itโฆ
Look, deceptive bar graphs with the bottom not set to zero.
This is a sentiment I've heard echoed several times recently about creating in Lisp's various REPLs. I guess I've been doing it for years without thinking of it this way, because I work in Maya, which has the Script Editor. I can select any code in it and hit Ctrl+Enter to run it. For a decade prior to that I was using MEL (Maya Embedded Language) in the same, integrated editor, so it's just how I've known working forever. One thing that I don't know how to do in various Python shells is go up and edit the code without just inputting every line of a class or function over again (using up arrow, of course). I'm guessing this is easy in IPython. The Script Editor in Maya allows this by default, as it's not so much a REPL as a text input box.
Also very useful for applications that mess with stdout or do interesting things with their process model that cause the standard pdb debugger to be fairly useless.
If you're comfortable in IDEs you should definitely try out [PyCharm](http://www.jetbrains.com/pycharm/). Best Python IDE currently available (not free though).
About sex?
&gt;Really? Weird... Well, v4 says it needs one. I just installed the v5 beta, which made no mention of it, and OSX didn't complain, so maybe that's not the concern it should be. &gt;Do many programmers use Mac? Anecdotal evidence from various conferences seems to favour OSX (certainly over Windows), and `homebrew` makes it an acceptable environment for a good chunk of developers. How big a market it is by comparison to *nix proper, I couldn't begin to guess.
That is a good point. I wanted to avoid having to install nltk master externally in order to keep the installation fast and easy (one command, minimal dependencies), if possible. The tradeoff--as you correctly pointed out--is that the local python is overriden. This can be remedied by using textblob in a virtualenv. I have been experimenting with alternative ways to bundle nltk. I have tried: - Putting nltk in a `textblob/text/packages/` directory. This didn't work because all the nltk imports are absolute, so `import nltk` wouldn't work. - Renaming the bundled `nltk` to `nltk3` or `textblob_nltk`. This would require fixing all the imports in nltk, which seemed like more trouble than it's worth. Any thoughts on better ways to do this? Any idea on when/if nltk3a will be on the PyPI? If users find that the bundled nltk is causing problems, I can definitely remove it. *UPDATE*: I added a branch without the bundled nltk. It can be installed with pip install git+https://github.com/nltk/nltk pip install git+https://github.com/sloria/TextBlob.git@no-bundle 
I also come from a Visual Studio background and found it hard to give up breakpoints. Using the Python plugin for VS gave me breakpoints that worked just as I expected them to. You should try it out.
So... low level git -&gt; dulwich high level git -&gt; Gittle command line tool based on the above -&gt; ??? (I might finally use git, other than with hg-git, if we get a Python based client).
How coherent does it have to be? Markov chains will generate text in the style of its training input. It'll mostly be nonsense though. Also, the more text you give it, the better your results will be.
 from celery import task [Celery](http://www.celeryproject.org/) isn't the only the only [AMQP](http://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol) based task queue for python, but its a very good one. Some pretty cool and robust solutions already exist in this problem domain.
At work I use [webtest](https://pypi.python.org/pypi/WebTest) at work. Added a few wrappers so I can do something like: ret = get('/some/endpoint', params) and it'll change the dict params into key-value pairs and send them as get parameters. Since we return JSON from our API tests are in the form of: data = ret.json assert data['foo'] == 'reddit' 
Another pdb video: http://pyvideo.org/video/644/introduction-to-pdb
Of course.
That's the video. I thought it was the Barry Warsaw dude though.
Pretty much everything I've read ends up with the same recommendation. I've scrapped the idea of running it on Windows, I spent the entire day yesterday trying to install PyQt5 on W7, to no avail. I've installed an Ubuntu 12.04 VirtualBox OS, which will suffice for my design requirements. Sorry for the nwb question, but is PyQt a standalone app, or is it the library used by the actually Qt app? Ie. do I need Qt as well as PyQt?
Try this and see if its much faster than using the count function ten times. Instead of : ------ for i in range(0,10): data[i] = pi.count(str(i)) print i, data[i] ------ Try this (syntax may be wrong) -------- for i in range(0,1000000): data[str(i)]=data[str(i)]+1 for i in range(0,10): print i, data[i] --------- 
What does WingIDE debugger do that PyCharm doesn't? I haven't used Wing in a while, I've been trialling PyCharm because it also has good JS support. I like Wing's Source Assistant far better than any of the other code popover thingoes. 
"[Deviance](http://en.wikipedia.org/wiki/Deviance_\(statistics\))" should probably be "[Deviation](http://en.wikipedia.org/wiki/Deviation_\(statistics\))" yetanothernerd is right about the "zoomed" graph, that's a misleading practice. Why not graph the +/- deviation about zero. It'll convey the same thing, no need for "zooming". I think it's silly to make something of the count for 3s and 4s being the same, but hell, why not run with it. Run your script for 0..*n* digits of pi, and plot all the times where the counts of two (or more?) numbers matched. Using that same dataset you could also plot the variance of the distribution versus the number of digits. Hopefully you'd see it smooth out the longer your pi got.
ipdb has everything from pdb plus tab complete, colors, and indentation.
I'll second this. Tkinter with ttk (Themed Tk) looks fantastic on Windows. And Tkinter is *definitely* compatible with Python 3.
This looks awesome, I especially like the integration with RabbitMQ and Redis.
I also realized that you could add a conditional even if Dazzle doesn't have an API. Basically, if an email was found and converted to csv, you could start Dazzle from the command line (look at devilishd's post). This way, your program could check every day or something and open Dazzle if there is an email letting your father know that there is a file ready. Or you could have it email/text him to notify him.
Git already is a command line tool. $ mkdir widget $ cd widget ~/widget$ git init Initialized empty Git repository in /home/gfixler/widget/.git/ ~/widget$ echo something &gt;foo ~/widget$ git add foo ~/widget$ git commit -m'Add foo with something in it' [master (root-commit) 5cde08a] Add foo with something in it 1 file changed, 1 insertion(+) create mode 100644 foo ~/widget$ echo another thing &gt;&gt;foo ~/widget$ git add --update . ~/widget$ git commit -m'Add another thing to foo' [master ae5a43e] Add another thing to foo 1 file changed, 1 insertion(+) ~/widget$ git log --oneline ae5a43e Add another thing to foo 5cde08a Add foo with something in it
Or you can read the scale, then they're "useful histograms which have a scale chosen to properly show the data" instead. 
Have you used [GitPython](https://github.com/gitpython-developers/GitPython) as well? This seems less powerful/mature.
yes
This needs a license file before anyone can do anything with it. Edit: ah listed as MIT in the setup.py. They should still make it clearer in the repo.
But if the bars don't convey useful data and you need to read the numbers instead, you might as well not bother with the bars.
Upon further investigation, it seems GitPython requires git to be installed (haven't fully verified that yet), whereas Gittle is literally a reimplementation of git in Python, so git is not required, nor used if it exists. Pretty cool.
If OP is using Python 2.x, [`xrange()`](http://docs.python.org/2/library/functions.html#xrange) is a good call.
You're right. However, when your class requires you to have bar graphs for a passing grade, you generally do it. :)
Ah good call on the Deviation. I knew something looked off.
I'm all about wxPython. I'm not going to Python 3 for GUI stuff until wxPython moves to python 3. I just like it. I think it's better than Qt etc. It's just a preference thing.
Coming from visual studio I used IDLE for a bit and never debugged there and then moved to pycharm and I debug here. This supports standards visual studio usage http://pytools.codeplex.com/
It could, but it's almost certainly going to require some support from the interpreter. Somehow we have to update the byte code and make sure any active eval loops where the code is on the modified methods see those updates appropriately. From there we "just" need to get the mapping logic for updates working so it works as expected. So it's not easy and it might not even be possible until some future Python version adds the necessary support. You could also use the debug REPL to do some of this, but it's just not the same as edit &amp; continue. 
You could run the evaluation on lots of subsets of the digits to get a feeling for the variance and maybe plot some errorbars (and even test for significance).
Open an issue ;)
Up arrow in iPython will bring back the last code-block not just the last line ... way more useful ... though still has its limitations. i.e.; when you need to change one char 10-lines up in the code-block.
Benford's law applies to series of things that grow exponentially, and only the leading digit, too.
Try this! &gt;&gt;&gt; import collections &gt;&gt;&gt; collections.Counter(pi_string) Counter({'5': 100359, '3': 100230, '4': 100230, '9': 100106, '2': 100026, '8': 99985, '0': 99959, '7': 99800, '1': 99758, '6': 99548})
No Windows support...
"Wrist-handy"?
hg?
Nice to know, thanks. The previous language I worked with (VBA, God forgive me) did this (IIRC) and so I always thought I somehow screwed up my setups.
Well, it's about as coherent as a politician is! (lolwut at that last sentence) In [6]: text = nltk.Text(nltk.corpus.inaugural.words()) In [7]: text.generate() Building ngram index... Fellow - Citizens : We will stay strong to do to the necessities of war , against all open or secret , among which the poor ; - that we are called to pass judgment upon it , sacrifice , it appears to me , I have acquired an habitual attachment to liberty and law have marched before me . I stand here today , are not just my goals , and do my utmost , as the asylum of my public trust . Your dreams , the latter have the support of a warming planet . We allowed taxes 
This is something I also use. Pretty awesome.
I use webtest too and it works great. I've had heard good things about [Slumber](https://slumber.readthedocs.org/en/v0.6.0/tutorial.html), but haven't tried it myself.
From the [Readme file] (https://github.com/thekarangoel/Projects/blob/master/README.md) * I will use Python to solve these. Why? Because I want to learn the language quickly. * I have no interest in making games, so I'm excluding those from the list below. * I'm not interested in networking, so I might skip all (or some) of them. * The projects will not be made in the order posted. * I may not be able to complete all of them. * My method of solving them may not be the best. If you do not like my algorithm(s), please add a comment for the file/commit or open an issue, and I'll try to improve. You can also [contribute](https://github.com/thekarangoel/Projects/blob/master/CONTRIBUTING.md) solutions in any language of your choice, not necessarily Python..
Pay no attention to the down vote brigade. I thought the same thing. *Edit: This comment was made at 0 points. It makes no sense now.
So basically: * It isn't as harsh in it's wording, but provides more explanation * It provides more modern reasons that it's a good idea to be &lt;80char/line * It mentions unicode specifically * `with` statements get a holla * "You shouldn't do X" statements have been replaced almost unilaterally with "You should do Y" statements.
How is this different than [IPython](http://ipython.org)?
&gt;Use a single tab per indentation level. Wow! (just kidding)
I just don't like current available git clients for Windows, that's all. Looking at dulwich + Gittle, they look very clean and small. I've would pretty much like having a small client based on those.
Yup, it is (sorry if I came out as being totally clueless). The thing is: I'm on Windows, and I think git clients still sucks for that platform. I was just musing about how neat would be to have a small client based on dulwich+Gittle.
My guess is this is a tutorial so they want to show you the subclassing approach, that way when you come to do something more advanced that requires subclassing you can look back on this tutorial.
And the Raspberry Pi users rejoiced. (seriously, I'm rejoicing.)
For unit testing, I suspect you'll want to mock your API responses to the documentation so it all runs locally then implement integration tests that make requests against the live API to alert you to changes. For Requests in particular, this is pretty simple with Mock. Patch the HTTP method Requests is using, mock out the response you want to test against, make the request with your wrapper, and test the result. I sketched out a naive example here: https://gist.github.com/RobSpectre/6132631
I think this is a great question. I would love to see some simple tkinter apps written in a procedural style. Edit: Anyone care to share what the posted code would look like procedurally?
In general, it's simpler. These features make it my first choice for prototyping/exploration: * A separate view for editing blocks of code. * Type a few characters then press Ctrl+Up to match anything in your history that starts with those characters. * Folding.
We can dream
How can I run a Django shell, or a Flask-Script shell inside DreamPie?
good to hear that. I am up to writing more about the deployment guides.. and scalability tips are coming soon.. Thanks
Reviewing the diff, this is newly added: Always use a def statement instead of assigning a lambda expression to a name. **Yes:** def f(x): return 2*x **No:** f = lambda x: 2*x The first form means that the name of the resulting function object is specifically 'f' instead of the generic '&lt;lambda&gt;'. This is more useful for tracebacks and string representations in general. The use of the assignment statement eliminates the sole benefit a lambda expression can offer over an explicit def statement (i.e. that it can be embedded inside a larger expression)
I've never used webtest and wanted to avoid another 3rd party package, but I will give it a try. Thanks for the help!
Alright, I will give webtest a try.
Awesome example. Is mock another 3rd party unit testing framework?
I admire your ambition in creating this personal project. I have to wonder what features it offers over for example, the [free version of Wing IDE](http://wingware.com/downloads/wingide-101/4.1.13-1/binaries). That IDE also has a code editing window, a separate output window, another window for displaying the stack data on an error or a breakpoint, and more. 
&gt; Gittle is literally a reimplementation of git in Python This seems like a weakness, not a strength. If the canonical git implementation gets updated (say new functionality is added), Gittle doesn't just need to update its API, it needs to build up the new functionality from scratch.
uses gtk, so support outside of linux is sketchy at best. I would love to have support for blocks of code in ipython though
This is actually very standard for GUI apps (which are usually OO) and OO in general. You should **NEVER** modify a base class directly, because that can, and usually will have globally-scoped side effects. Instead, we subclass every time we want to modify an attribute.
Did you install git bash with the install of git from git-scm.com? It gives you an admittedly old and minimalist version of a bash shell, but it does much of what I want on Win 7 at work (not enough to keep me from requesting/getting a second PC and installing Linux on it, though). You can right-click in a Windows folder and choose to pop open git bash at that point, which I use pretty often.
~~What was it?~~ It used to be LGPL 3
Correct. There are always trade-offs. In this case you'd be choosing the perks of autonomy (no dependencies outside the world of python), and losing the perks of dependency (you can no longer depend directly on the development wins of git).
It has an installer for Windows which works just fine.
Doesn't PEP8 itself recommend always using def f(x): return 2*x over def f(x): return 2*x ?
I believe it requires Qt as well. It's at least required on the Mac for Homebrew, I'm not sure about binary installers. Pyside requires it as well.
huh, never knew that second line was in there, although I've always been following it anyway. Yay for common sense I guess.
If Dazzle doesn't have any helpful features but you want to try and automate the whole shebang, this may be helpful: https://code.google.com/p/pywinauto/
&gt; Furthermore, I'd like to improve the professionalism of my code as I might like to contribute to some open source projects in the future and don't want my contributions to look n00bish. I'm surprised no one has mentioned [PEP 8](http://www.python.org/dev/peps/pep-0008/). I mean, you may have already been exposed to it, but it's still a document that is valid to review now and then. So yeah, PEP 8 is a great start if you're looking to professional-up your Python code.
You monster!
Do I use PySide or PyQt or what? I'm can't quite figure how they are related?
I like to use https://github.com/gabrielfalcao/HTTPretty 
I think what he means is, why not just create an instance configured this way, e.g. def main(): root = Tk() root.geometry('250x150+300+300') app = App(root, background = 'white') root.title('Simple') app.pack(fill = BOTH, expand = 1) root.mainloop()
&gt;Edit: Anyone care to share what the posted code would look like procedurally? http://www.reddit.com/r/Python/comments/1jhw7e/why_are_most_examples_in_written_in_oo_rather/cbeza3j
It would make so much more sense!
It isn't a testing framework, but you will have to install it in your virtualenv. All it does is provide a great mock object and monkey patch decorator - your tests still says in unitteset.
In other news, [Guido hates the PEP8 module](http://bugs.python.org/issue18472#msg193909). &gt;&gt; (The only argument against such things is of course the pep8 tool, which &gt; codifies the recommendations in this PEP. Some packages actually run the pep8 &gt; checker as part of their test suite, so if we change a recommendation and that &gt; gets pulled into pep8, then tests can break.) &gt;I hate that tool. It only covers a small part of the PEP, and is very nitpicky about the part it does support, causing people to contort their code to shut up the tool instead of learning and understanding the PEP and applying common sense.
I wish they actually meant *tab* too, instead of this 4 space nonsense that everybody insists on.
I don't get what you mean about the sole benefit of lambda expressions, can't you use the lambda the same way even if you use assignment rather then def?
Give 'eatThis' your corpus, and then use GenSentence to generate your sentence. "Queries from somewhere. This offer was found in any type of merchants shelves." "This article written by public of the management." "production and Drug Administration advised consumers that hit Source Perrier had been performed in Chicago received" "Airlines stewardess, was confronted with cyanide, and spur him to her Chicago area, authorities concluded that" After being fed source text here:http://www.aerobiologicalengineering.com/wxk116/TylenolMurders/crisis.html *edit: added some examples
How exactly is it nonsense? 
(Firstly, those aren't my notes, they are out of PEP8.) You *can* use them the same but... (As I understand it) the sole benefit of lambda function is they are *anonymous* functions: the purpose of which is to NOT bind it to a variable name. That's why the PEP says it makes no sense to use the lambda form and then simply tie it to a variable. This SO question basically shows the exact usage being discussed in the PEP, in an example. It shows you can use them both ways (defined, or anonymous) but argues the lambda is more clear. http://stackoverflow.com/questions/890128/python-lambda-why
It's an NLP question, not a python one (admittedly nltk is a good option). Generating stories is a research topic in the area of computational creativity. I have seen papers published at ICCC2012 and EvoMUSART 2013. They generate abstract characters or plots. They're nowhere near generating complete texts.
doesn't not following PEP8 in PEP8 somewhat defeat the object of the exercise?
&gt; or else configure my editor such that when editing Python files (but only Python files!) the tab key is remapped to not insert an actual tab character, which is obviously what the tab key is designed to do, but to instead insert four spaces. Which is a pain because when I'm SSHed into some random machine I often haven't bothered, or can't remember if I have bothered, to make the appropriate changes to .vimrc to take care of this. Good god man. Why aren't you synchronizing your vim configuration across your remote accounts? I mean, really, you're going to bemoan a style suggestion because you can't keep your configuration consistent? Not keeping your configuration consistent across machines comes with a ton of other headaches too. &gt; suddenly everything is a mess Your environment is a mess. &gt; Leave your editors in their default configuration and just write code which works, and become a pariah in the Python community for using tabs instead of spaces Each editor might have a different default configuration. &gt; Take extreme care to always reconfigure every editor you might ever use on every machine you might ever code on to do things "the right way" by the community and replace tabs with spaces This is literally the most trivial thing in world. You can use `git` to track your changes or just a good ol' rsync that runs on a cronjob before you wake up every morning. &gt; Be less than perfectly vigilant about the above, like a human being, and end up with chaotic mixed space/tab files Because I make mistakes, I set up my configuration so that I don't have to pay attention to it. I took some time out of my day several years ago and made sure my config was consistent across machines. And now it just is. And has been since then. And hopefully always will be. &gt; such include basic functionality like being able to configure how wide tabs look. After you just got done with a big long rant about how you find it so difficult to configure your editors across machines, you now suggest that the solution is a configuration option. Troll much?
i think &lt;C-r&gt; and type a few characters in ipython is easier to reach than &lt;C-Up&gt;
I was hoping they'd get rid of this--'When writing English, Strunk and White apply.' It gets my goose that some style guide from 1918 is dictating how to write comments in 2013. edit: Strunk and White style
I don't know much about [Tkinter](http://docs.python.org/2/library/tkinter.html). [Functional](http://docs.python.org/3/howto/functional.html) or [object-oriented](http://docs.python.org/2/library/collections.html#collections-abstract-base-classes), [standard software design patterns](https://en.wikipedia.org/wiki/Software_design_pattern#Classification_and_list) are easier to test. &gt; I just feel like sometimes that writing an extremely simple program in OO is inefficient. It can be easier to [test](http://www.reddit.com/r/Python/comments/1drv59/getting_started_with_automated_testing/c9tfxgd) specific parts of object oriented code by mocking objects than to [re-]compose functional chains. &gt; Basically, my question is, why would you create a new class to inherit the features of frame if you're only going edit the parent and the background color? It would only take a line to do that if written in a procedural manner. In the general case, an argument could be added to the constructor of `Frame` (with `**kwargs`) to support further configuration. (~[factory method pattern](https://en.wikipedia.org/wiki/Factory_method_pattern)) ... Configuration != instance state Also relevant: * [Functional programming, iterators, generators, and using IPython_nose to run tests using Nose in IPython.](http://www.reddit.com/r/IPython/comments/1eds9x/functional_programming_iterators_generators_and/c9zqmch) * [A few testing questions...](http://www.reddit.com/r/Python/comments/1iuvdr/a_few_testing_questions/cb8czsz)
&gt; Each editor might have a different default configuration. At least 99% of editors have a default configuration where pressing the "tab" key inserts a tab character. &gt; After you just got done with a big long rant about how you find it so difficult to configure your editors across machines, you now suggest that the solution is a configuration option. Troll much? I *knew* someone was going to say this. :) They're not comparable at all. It's about failure modes. Under the "thou shalt use spaces" approach, failure to lug the One True Configuration with me everywhere I go means: * A problem which affects every line of code which doesn't have zero indent (most of them) * A problem which is not immediately visible (tabs and groups of spaces look the same) * A problem which can actually *break code* - inconsistent use of spaces and tabs may result in code not running, or worse it may result in code which runs but doesn't run as expected * A problem which *follows the file* if I save changes on the misconfigured machine and then move the file elsewhere by any means Under the "just use real tabs" approach and reconfiguring your editor to make tabs look shorter if you have a problem with tabs being too large, using an unconfigured editor means: * No problem at all if my editor displays tabs shortly in its default configuration *or* if I have a screen/terminal which is wide relative to my font size *or* if I have code consisting of short lines which are not deeply nested. Otherwise... * A problem which affects deeply indented lines of code only (a minority of them) * A problem which is immediately visible (code runs off the edge of the screen) * A problem which doesn't actually break anything, just makes my life a tiny bit less convenient or pretty in some limited circumstances (I need to scroll to see/change some of the code on some of the lines) * A problem which is localised to that particular machine and isn't going to spread with the file Which of these approaches do you think is best? The one which *forces* you to customise your editor to prevent invisible, contagious serious breakage, or the one which *gives you the option* to customise your editor if you want to in order to overcome a minor, occasional problem that maybe you can just live with? &gt; Good god man. Why aren't you synchronizing your vim configuration across your remote accounts? (and in response to all your similar lines about professional class automated environment customisation) I am (now - I was driven to do it primarily by this pain with Python). But it's absurd that the community has decided upon a style guideline which basically *requires* this sort of legwork to avoid breakage when there's an alternative which would work without requiring any of it. There are people out there who aren't professional developers who shouldn't have to lug a development environment around with them everywhere they go just to write a bit of Python. It's really quite a crazy requirement when you think about it, and no other language that I know of has it. There are people who don't know what git or rsync or cron is, and there are even (shock horror!) machines out there without git installed. There are people who don't have a personal server to host a repository of their dotfiles on. Sure, they could set up a Github account, but really, should a Github account be a prerequisite to working in Python? That's pretty insane. There are people who may work on a large number of machines on a sporadic basis who don't code all the time (like sysadmins) for whom setting up this kind of environment just for Python is more trouble than it's worth. The problem of keeping a consistent environment everywhere you go isn't insurmountable, by any means, if you are determined and knowledgable. But it shouldn't *be* as big of a problem as it is in the first place. Replacing tabs with groups of spaces in a language where whitespace has meaning makes Python *more fragile than it needs to be* for *very little gain*, and that's a bad idea. It creates chores, its makes a person less mobile, it adds friction to things like experimenting with a new editor, it's one more thing newbies have to learn. If there's some genuine benefit to using spaces I'm not aware of which makes all of this stuff worthwhile in the long run, I'd love to hear it. Maybe it's a worthwhile tradeoff. But as far as I can see, it's an arbitrary decision which causes pain for no gain.
how do you set-up the syncing without it becoming a nasty mess?
If you mean "doesn't this make it harder to verify that `app` has the expected attributes now that it's no longer an instance of a subclass" (Oops, had to edit the code to reflect that): nonsense. It's still an object, and as such it is subject to inspection in all the usual ways. But generally speaking, unit testing isn't going to work terribly well for UI stuff, you really have to do functional testing anyway. It's one thing to verify that the `background == 'white'`; it's quite another to (a) ensure that this actually causes the window to appear with a white background; (b) confirm that a white background actually makes aesthetic sense; (c) and that it also makes sense from a usability standpoint.
Honestly, I've tried clients (such as github for windows) and they are generally slower than just using git bash on windows. I will occasionally use gitk to find particular commits and to cherry pick but I think that's it. I think I'm saying that the reason good clients don't exist is because nobody can think of a way to make them an improvement over git bash.
There are also [python bindings for libgit2](https://github.com/libgit2/pygit2)
Git?
I think you need to focus on other things. I also find it humorous that your edit is for "grammar".
Strunk and White has never been applicable; even in the time it was written. I think the most damning example of its intellectual bankruptcy is its claim that restrictive relative clauses must be introduced with "that" and not "which". Such a rule had never been heard of by Strunk and when White revised the book he had to go back and revise all the instances where Strunk had introduced a relative clause with "which". In reality the "rule" was suggested by Fowler as a way of simplifying the English language; E.B. White made it a diktat. It's no more legitimate than the absurd prescription against the passive construction.
Tabs are 8 characters by default because that's a Fortran field width. Python indentation is 4 spaces. Hence, use spaces. If I don't have your settings, all my code looks like shit.
&gt; If you have a choice and it makes no ultimate technical difference to the computer which way you go, you go with the option which is must robust under the expected range of user behaviour. The problem is that all-tabs in a source file also has its down-sides. Namely, you can't always horizontally align your code under certain PEP8-compliant styles. &gt; I challenge you to back this up, with a complaint equivalent in scope to mine. Name me one other programming language or technology where using any mainstream editor and failing to consistently change the settings away from the default can result in code breakage - not just in an editing experience which is less efficient than it could be or less pretty than it could be, but where shit actually breaks. Pretty much any programming language with white space significant syntax. Like Haskell. I never really misunderstood your argument. I was just accusing you of overreacting to an issue that I believe is trivially solvable. (I inferred overreaction from the amount of text you've been writing in your comments.)
Yeah, I think that part makes people take the rest of the document less seriously. For one thing, it has nothing to do with programming. For another thing, Strunk and White entirely predates linguistics as a science, and anyone who has studied some linguistics knows there are things in there that are just dumb. There are *modern* manuals of style out there that one could use instead. It's as if PEP8 encouraged you to make sure to collaborate with good team members, and then said the way to determine if someone is good for your team is to measure their skull.
&gt; Python indentation is 4 spaces. Hence, use spaces. That's circular. Python indentation is 4 spaces by convention only. &gt; If I don't have your settings, all my code looks like shit. If indentation is done with tabs, then everybody's code can look like whatever the preference of the person looking at it is.
&gt; Namely, you can't always horizontally align your code under certain PEP8-compliant styles. Can you elaborate on this? A genuine advantage of all-spaces over all-tabs could completely change my opinion. &gt; Pretty much any programming language with white space significant syntax. Like Haskell. Does Haskell also have an all-spaces community norm?
&gt; Can you elaborate on this? A genuine advantage of all-spaces over all-tabs could completely change my opinion. Sure. Check out a [real world example](https://github.com/BurntSushi/nflgame/blob/master/nflgame/game.py#L349). You can see the horizontal alignment to a particular column. If it were permissible to mix tabs and spaces, this wouldn't be a problem. But in Python, you've got to pick one. With tabs, you're cornered into a particular style (and I'm not offended by that style), but I prefer the one you see in the link. There are more examples of that alignment style throughout that file. &gt; Does Haskell also have an all-spaces community norm? You betya. It is even more vociferous than the Python community. Once in a while, I see someone argue for tabs in Python. I **never** see anyone argue for tabs in Haskell. I have outlawed tabs in almost every plain text document that I write. The only files that tabs are allowed to creep in are tab-delimited data files and Go source files, and the latter is only because of `gofmt`. Sticking to spaces guarantees no problems. Tabs have made me weep in years past.
&gt; If indentation is done with tabs, then everybody's code can look like whatever the preference of the person looking at it is. But then it won't be consistent when you have 2 people working on it and they have different preferences. You can't easily convert spaces to tabs. You can force spaces using a tab -&gt; space option since there's a standard. I can't convince my boss to add the .py extension to his python files. Programs should be editor independent he says. If I can't get him to do that, I'm never going to convince anyone to change their spacing habits.
&gt; But then it won't be consistent when you have 2 people working on it and they have different preferences. How do you mean? In the actual file, on the hard drive, each level of indentation will be exactly one tab. I'm not proposing anybody's editor actually change that. I'm proposing that people be able to configure their editor to *display* tabs differently, i.e. at different widths. A file might look different on different people's screens, but they will both be able to interpret the nesting structure identially and correctly, and so will any two Python interpreters. I think refusing to put .py on your Python files is weird and counterproductive, but I agree with your boss that programs should be editor independent. That just feels like common sense to me.
I use tabs for indentation and spaces for alignment, which works perfectly fine. The only downsides are 1) tabs mean you don't have a fixed line length and 2) people who are used to pressing tan to insert spaces fuck the whole thing up and I have to fix it. 
your example is confusing...it looks like you basically just are showing the code from the file. Are you summarizing the file somehow? Or is it just that it's able to inspect the element to preview the file? It looks really similar to IPython's `?` operator.
Dropbox. I have one .emacs file which is linked on all of my machines via a symbolic link to a file in my dropbox folder. His edge case is weird though. Who writes code they intend on committing while sshed into a random box? 
I actually think that's one of its strengths. PEP 8 allows interpretation so the pep8 tool only is concrete where the PEP is. As for having contorted code don't blame the tool ! If you actually want to bend the rules you can with the configuration file or even just one line at a time with the # noqa comment. I think that was pretty unfair of him to disrespect the writers and followers of that tool.
You have to rewrite your whole project in any framework switch. Gevent has its fault too. Monkey patch, sychronius syntax that let you think you can use any library with,... On the other hand, if you are only using Twisted for http protocol, you are using the wrong tool.
I'm really not okay with continuously seeing content from PythonHackers/PythonArticles. Reddit isn't really your blog.
Zen of Python applies even inside PEP8. Specifically &gt;Although practicality beats purity.
I'll add one more to git and dropbox: chef-solo to install all your configs from other locations.
I agree! It is the only civilized way to do code indentation! I just don't understand why nobody else can see that.
What would reddit look like if no-one posted their OC? If you don't like it, downvote and move on. 
this. and headless dropbox for servers running a special account that only shares important config directories. Or git or hg your config directories and share that repo. works too. But don't bring "ooooo, but I have to reconfigure my editor just for python files" as an argument against PEP 8. If your editor is really bad like that, it is like bringing a broomstick to a shooting and complaining when you get killed and can't shoot back.
&gt;On the other hand, if you are only using Twisted for http protocol, you are using the wrong tool. I'm not sure how to interpret this. I'm not using any other protocol other than HTTP, but I'm doing *a lot* of it in *big-ass* batches.
same with classes. I like classes, but not everything needs a class. Seen a lot of examples that use classes just..because I guess, because theya re using it for something that you could put in a simple 6 line function. No idea why would you got to somethign more complex.
Fascinating yet I'm not quite sure I understood half of it :)
Sure. The output is a little messy, since it basically indiscriminately grabs &lt;p&gt; tags, but here's an example with www.theverge.com/2013/8/1/4580718/fbi-can-remotely-activate-android-and-laptop-microphones-reports-wsj : EDIT: The output has been cleaned up a lot. Here's the new output: &gt;$ ./summarize.py http://www.theverge.com/2013/8/1/4580718/fbi-can-remotely-activate-android-and-laptop-microphones-reports-wsj FBI can remotely activate Android and laptop microphones, reports WSJ | The Verge &gt;The Wall Street Journal reports that the FBI can already remotely activate those microphones to record conversations. &gt;Remotely activated cell phone bugs predate iOS and Android &gt;What's new, according to several former anonymous officials, is a dedicated FBI group which regularly hacks into computers, using both custom and off-the-shelf surveillance software which it buys from private companies. &gt;" While that source also claims the FBI takes care to make sure that only "relevant data" gets collected, it's still a little troubling to know that such a thing is easily possible and regularly done. For reference, here was the old, ugly output: &gt;$ ./summarize.py http://www.theverge.com/2013/8/1/4580718/fbi-can-remotely-activate-android-and-laptop-microphones-reports-wsj The Big Story: This is the Moto X &gt;By Sean Hollister on August 1, 2013 09:14 pm /* &lt;! &gt;Don't miss stories Follow The Verge &gt;The Wall Street Journal reports that the FBI can already remotely activate those microphones to record conversations. &gt;Remotely activated cell phone bugs predate iOS and Android &gt;What's new, according to several former anonymous officials, is a dedicated FBI group which regularly hacks into computers, using both custom and off-the-shelf surveillance software which it buys from private companies. &gt;" While that source also claims the FBI takes care to make sure that only "relevant data" gets collected, it's still a little troubling to know that such a thing is easily possible and regularly done. &gt;about 11 hours ago 1 comments &gt;about 12 hours ago 2 comments &gt;about 14 hours ago &gt;about 15 hours ago 1 comments &gt;about 15 hours ago 12 comments &gt;Off-topic / chit-chat &gt;7 minutes ago by Bulickeill &gt;The Fringe &gt;15 minutes ago by Bulickeill &gt;Meta &gt;about 1 hour ago by DrDoppio &gt;Apple Core &gt;about 2 hours ago by Andreas Larsen 5 comments &gt;Android Army &gt;about 2 hours ago by EXAZz04 &gt;about 2 hours ago by jefflow 6 comments &gt;about 3 hours ago by Waveblade 2 comments &gt;about 3 hours ago by D Saif 11 comments &gt;about 4 hours ago by Sanjaychandra 11 comments &gt;about 5 hours ago by mrusert 17 comments &gt;All &gt;Ethics Statement - Community Guidelines Terms of Use - Privacy Policy v1.8, August 1, 2013 &gt;ยฉ 2013 Vox Media, Inc. All rights reserved.
I would really like to hear why you don't want to see it. Do you think the articles are crappy/not well written/ and pythonhackers.com is a really bad idea that I'm stealing people's time ? 
Sell it to Yahoo! for millions?
If you want flexibility, then some sort of cloud or VPS hosting is probably the best option - you'll get a complete *nix system with root access, so you can install whatever packages you want and configure them as needed. As far as cloud hosting goes, Amazon is the obvious "traditional" (in lack of a better word) choice; digitalocean seems to be quite popular too these days. For cheap VPS hosting, check out [Low end box](http://www.lowendbox.com/). You should be able to find entry-level VPS hosting for under $2/month, and many providers allow you to scale up later when the need arises.
Now add an edit box and a button that would display an alert "Hello, %s" with that edit box's contents. Now you need a thing that owns components and has event handlers, i.e. an object. (the somewhat weird thing about Python is that at least for the first part you end up in effect storing your components in the `root`'s dictionary anyway, because Python is not very proper about following OOP ideas)
You are right, a VPS gives you best flexibility. But i am more a developer and not the sysadmin guy. I don't want to care about system and security updates. So a managed hosting solution seems to be the better choice to me.
i second that. using their service for about 6 month. no issues + they have SSDs. the only problem i've ran into was inability to get more IPs
With WebFaction, the memory limit is the memory used by your processes (as determined using `ps -u username`). This includes Apache processes serving your sites, but AFAIK not databases or nginx (unless you run your own instance - the shared one is used to serve static content). While you don't get complete control as you would with a VPS, it definitely hits a sweet spot for users like me. WebFaction keeps the server updated with security patches etc. and allows you SSH access and the ability to install your own software from source, while not having to worry too much about maintaining the underlying infrastructure. I run some low-traffic Django websites, memory usage is usually around the 30MB/60MB mark per Apache process.
Managed hosting tends to be a security nightmare, especially the cheaper options. The fact alone that you share a server with other users is kind of problematic in and of itself, because it means that a simple "yes/no" access control system, or even a two-tier ("unauthorized" / "regular user" / "super user") system won't suffice. If you use, say, Debian, as your primary desktop OS, and know how to configure Apache (or nginx) to host a Python web app, then you have most of what you need already. Updates are a matter of installing apticron; if you have outgoing mail configured somewhat well, it'll check for updates once a day and send you an e-mail if there are any.
Yes, running a server is not that complicated - even if you are not a sysadmin. But running a secure server is far more complicated than simply keeping your system up to date with the latest patches! I owned a root server a few years ago. But i really don't want to waste my time with any infrastructure stuff again... just want to code some stuff and deploy it somewhere :)
&gt;Now you need a thing that owns components and has event handlers, i.e. an object. To be fair, that's not terribly complex with this approach either. You'd just need to add editbox = Entry(app) editbox.pack() def greet(): tkMessageBox.showinfo("Greetings", "Hello, " + editbox.get() Button(app, text="Greet", command=greet)).pack() (Or stick the function in a lambda). Closures can do the job of encapsulating state as well as objects in some situations (especially when their scope is very local). OTOH, I agree that structuring things as objects can make much more sense as things grow increasingly complex. Though this doesn't necessarily mean one should structure it around inheriting from the frame: composition can often be a better strategy than inheritance. &gt;the somewhat weird thing about Python is that at least for the first part you end up in effect storing your components in the root's dictionary anyway Not sure what you mean here though - root as in the Tk root object? Why would you store anything there?
I have no idea why you're being down-voted for this. I absolutely agree.
Well, that would be over $20,000 a line... I wish.
http://www.masslive.com/business-news/index.ssf/2013/03/summly_app_sold_to_yahoo_17-year-old_pro.html
it has a different philosophy: &gt; # Features &gt; &gt; ## Simple &gt; &gt; Simple means not complex. All design decisions is based on simplicity. Speed is not first priority. &gt; &gt; Kuyruk only supports RabbitMQ and will not support another message broker ever. For this reason Kuyruk tries to utilize RabbitMQ and AMQP as much as possible. &gt; &gt; ## Easy &gt; &gt; Kuyruk requires no change in client code other than adding a decorator on top of a function in order to convert it to a โtaskโ. Also, sensible defaults have been set for configuration options and can be run without configuring while developing your application. &gt; &gt; ## Robust &gt; &gt; Kuyruk is designed for long running mission critical jobs. For this reason Kuyruk sends acknowledgement only after the task is fully processed. https://kuyruk.readthedocs.org/en/latest/features.html
hi redditors, we have created kuyruk after we have got tired of celery and it's complexity. i would like to clarify some of these: * celery is too complex: it suppports many backends and for this reason it has too much abstaction in the code. * celery worker processes are getting stuck constantly: reloading mechanism is problematic and does not always work well. i have seen stuck processes 4 months old waiting for a message from connection that is already closed :) * celery wants you to write the code in a way it wants. if you wrap a function with task decorator and make it task, then you need to call it like f.apply(...) to send to the queue. at http://put.io we have replaced all celery tasks with kuyruk and running in production for 3 months. i would like to hear your comments about the design of kuyruk. i did my best to make the code readable and commented well. please read it and feel free to send pull requests.
you should put those statements about celery in a rationale, as part of your docs. :)
Closures are poor man's objects, module scope is a very poor man's object. It's better to use the tool specifically designed for the job. &gt; Not sure what you mean here though - root as in the Tk root object? Why would you store anything there? I guess I meant Frame, as in the OP. Though I think Tk would work too... Anyway, I was trying to say that due to the way Python plays fast and loose with OOP, inheriting from Frame and storing your components as `self.textbox` etc, is exactly the same as `frame = Frame(root); frame.textbox = Text(root, ...); ...`, the stuff ends up in the same dictionary.
Very cool! I just recently discovered NLTK, do you know of any good resources to get started with it?
Very, very interested in this project as I've found celery to be horribly buggy and unreliable in production use. Will definitely be trying this out.
At last!! Thanks!
Add comments maybe?
it's not python3-compatible, right? Celery is python-3.3 compatible since the latest point-release ;)
I don't mean to poo poo your creation, but I think the rationale boils down to NIH Syndrome. There are plenty of quality celery alternatives, and celery is actually pretty easy to use if you RTFM (and has much better test coverage/suppor/documentation). Honestly, the setup work with celery is about the same as this (easier, even, if you use a Redis/DB/memory backend to tinker). The only difference is that you *can* do more with celery if you *want* to (but you are in no way forced to make use of even a fraction of their feature set). &gt; celery is too complex: it suppports many backends and for this reason it has too much abstaction in the code. What specifically is the problem? Abstraction is necessary to support multiple backends, but each backend follows the same basic interface. The backends themselves are pretty damn simple as a consequence. You shouldn't even need to be mucking with those at all, though, if you read the docs. &gt; celery worker processes are getting stuck constantly: reloading mechanism is problematic and does not always work well. Never ever use auto-code reloading in production with a Python environment. I think the celery docs even point this out. It's not fool-proof, there are edge cases, weird things can happen, and it's just not worth it [in production]. Your deploy scripts should SIGHUP or go through your process supervisor to restart manually. gunicorn also follows this philosophy with their auto-reloader (don't use it in production). &gt; celery wants you to write the code in a way it wants. if you wrap a function with task decorator and make it task, then you need to call it like f.apply(...) to send to the queue. Wat? I'm not sure what you're trying to say here. Celery does X arbitrary thing, therefore it's bad? I'm all for viable alternatives, but so far you've spent this entire thread bashing celery, rather than saying what you do better. From what I can tell, you use more RAM, you are slower, your retry mechanisms are inferior, your routing features are far inferior, your monitoring tools are non-existent, and your documentation is severely lacking. I point this out not to troll, but to tell you to get your head on right and stop talking smack. Make your project compete on its own merits, not by some vague hand-wavey stuff about celery. Also, there are quite a few very capable minimalistic alternatives to celery, which you're also competing with (and who are currently superior).
Gearman (via python-gearman) is nice, as well. Huey looks like it could be a more established/polished/flexible execution of Kuyruk's ideals https://github.com/coleifer/huey
Thanks! At the moment I haven't changed my opinion - the advantage provided by spaces in being able to nicely line up multi-line code *is* an advantage for readability, but in my mind it's a very small advantage which is paid for by a very large disadvantage (as I've outlined at length above). It's not a good trade off. But I'm not discounting the possibility that there are other advantages to spaces-only which may tip the scales - although I have to say it's pretty unlikely as if they existed somebody probably would have mentioned them by now.
Thanks! I'm not sure why this is such a touchy subject, but it obviously is. For the record, I love Pythonn, it's my favourite language and I think it's well designed on the whole. I don't mean to really knock it. The spaces convention is a pain, and the bad design decision irks me because I'm sensitive to bad design choices like that, but I don't mean to imply anybody should not use Python because of this.
Some things for usability: Test how many arguments are given. If 0 arguments are given you could post a small help, with more than 1 argument (except command) you could try to summarize every link. I never heard of "bs4" and it took me a while to find out that it is "beautifulsoup4". In your shebang line point explicit to python2, some OS like Arch Linux have python3 as default. Besides that, its a nice little tool. :) In the next semester maybe I choose a Course at our university which uses NLTK to introduce natural language processing. 
CHOO-CHOO! Python 3 train is here! Does anyone care?
He's just pulling out all the things people have linked to using anchor tags and doing a sort on them. 
This has been posted like 3 times already, what gives!? D:&lt; 
It is certainly possible to do so. How exactly, depends on the structure of the text file.
I question your decision to use Pika. * It's historically been riddled with bugs. * The purely async/callback pattern makes for messy code. * No Python 3 support. * Doesn't play nice with gevent. Having done extensive work with AMQP-backed services in Python, I'd strongly recommend you look at using py-amqp and librabbitmq; both support AMQP 0.9.1, provide RabbitMQ extension support, and since they have mutually compatible APIs, would give your users the option of choosing pure Python or C depending on their performance and deployment needs. That said, you might also consider using Kombu because it does the producer/consumer work for you and you can choose which transport library to use. As an added bonus the lead developer, Ask Solem, works on RabbitMQ (and also leads the Celery project). All that said, I get the impression anything even related to Celery is out the window. I'll echo /u/gtaylor's sentiment above; it seems like there's a whole lot of NIH attitude surrounding decisions to avoid Celery when it's really the best tool for the job.
http://nltk.org/book/
Do you have experience with regular expressions? Perhaps you could describe the structure of the text file or provide a sample and we could give you a hint where to start.
Yes. We do. 
If it works as advertised, then *very* cool. It's about time someone built this :) I have to nitpick at the comment about unit tests at the end of the readme though: Clearly this is something you would want side-by-side with unit tests, not as a replacement. 
I'm a little confused as to why he used the compressed sizes of genomes for the comparison?
Learn Python The Hard Way: [PDF + Videos](https://inculcate.me/school/courses/2/) ($29) Real Python: [PDF, mobi, and epub](http://www.realpython.com/) ($16) Dive into Python [PDF, HTML, and others](http://www.diveintopython.net/) (Free) Dive into Python 3: [PDF](https://s3.amazonaws.com/github/downloads/diveintomark/diveintopython3/dive-into-python3.pdf) (Free)
Nice, seems handy. 
&gt; That's interesting. I've been meaning to look at Haskell for years, but haven't ever gotten around to it. I didn't even realise it had significant whitespace. If you haven't done functional programming before, I highly recommend it. Haskell is a good choice because there's a huge community of people who tend to be very newbie friendly. Just don't get into an argument about programming languages with them. :-) &gt; Even in non-Python contexts? I have to imagine I've probably (unintentionally) mixed spaces and tabs before in C without ever noticing... Yup. Mostly when working with collaborators that have different tab settings. For example, if you set your tabs to display as 8 spaces, then it's feasible that you could intermix tabs and spaces and not know which is which. Until I open it with my editor where tabs are set to display as 4 spaces, and the indentation as a result is completely fucked. Can't happen if you ban tabs. :-) (That doesn't happen with Python much, since things can break. But in a language like C or C++, I frequently get programs thrown at me by students where the indentation is totally messed.)
You're a bit too negative there, aren't you? Nobody really wants to write new code if an existing solution meets their need. In this case, obviously it didn't, and they're offering something simpler that worked for them. Does it have a future against Celery? We'll find that out when the developer audience with similar needs chooses one or the other (or something else that doesn't even exist yet).
&gt; Nobody really wants to write new code if an existing solution meets their need. I can't tell if you're trolling here, but this is a well-known phenomenon in tech culture and gtaylor even spelled it out for you. I'll link it, though, to make things easier on you: http://en.wikipedia.org/wiki/Not_invented_here 
You should use [xlrd](http://www.python-excel.org/) to read the xls files and, [urllib](http://docs.python.org/3.2/py-modindex.html#cap-u) to interact with the webpage. This is feasible.
Thank you!!
You are welcome.
You hit the nail on the head. Not only that, but by changing just a few words around this applies just as strongly to many other cases of NIH.
Well, `bs4` is the pip package name ;). Other than that, you're right, I'm just lazy and forget to do that stuff. I'll push it in later.
riiight..... 
it is not compatible with python3 at the moment because it depends on pika. it will be ready when pika becomes python3 compatible: https://github.com/cenkalti/kuyruk/issues/5#issuecomment-22017575
As an alternative, check out my project [Specter](http://github.com/letsgetrandy/specter/), which allows you to script this behavior. 
Lowendbox website lists all VPSs and coupon codes to save tons of $$$. Found a 128mb ram 1CPU vps on there for $1.38/mo.
&gt; I'm all for viable alternatives, but so far you've spent this entire thread bashing celery, rather than saying what you do better. From what I can tell, you use more RAM, you are slower, your retry mechanisms are inferior, your routing features are far inferior, your monitoring tools are non-existent, and your documentation is severely lacking. thanks for your comment. this is not a propaganda against celery. i have learned a lot by reading source code of celery. it is well written, tested, documented and has too much work in it. i respect that. still working on this project made me learn decorators, descriptor protocol, signals, multiprocessing and many things. therefore it made me a better programmer. i have sent a pull request to pika and contributed to an open source project. i even wrote another library for testing kuyruk processes: https://github.com/cenkalti/what you can say "you could use pexpect". then i would answer "i have tried but it did not work for me" again. from your perspective we can build every website in django, after rtfd. think about why people are building things like flask, bottle, cherry.py. ps: my english is not very well. forgive me for grammar and spelling mistakes.
&gt; Never ever use auto-code reloading in production with a Python environment. I think the celery docs even point this out. It's not fool-proof, there are edge cases, weird things can happen, and it's just not worth it [in production]. Your deploy scripts should SIGHUP or go through your process supervisor to restart manually. gunicorn also follows this philosophy with their auto-reloader (don't use it in production). however, reloading the code in production is the reality of life. in both celery and gunicorn i did not see it working reliably. for this reason kuyruk tries to avoid reloading and does not have a mechanism for it. it tries to solve this problem by restarting the worker process. you set the countdown time in config. when it reaches to zero the worker exits, then master process (or supervisord if you are using) starts it again. isn't it simpler?
&gt; Looks to me like the master command is superfluous: it can be easily be replaced with a supervisord group - it does everything that the master does: you can shutdown the workers together, you can start them together, supervisord will restart them automatically for you and so on. Also, it will do other things, like logging output configuration or worker pool. Having said that, it would appear that it goes against of the simplicity goal of kuyruk master command is not doing too much work other than starting workers. it allows me to start a 4 worker on queue x from shell quickly with the following command: kuyruk master -q '4*x' also you can set different queues by hostname in config file. it enables us to run "kuyruk master" command and run different queues on different servers. however you are right about the duplication of the feature in supervisord. please open an issue in github, then we can discuss and document the usage with supervisord. i would be happy to remove master command if it is not needed.
&gt; Anyway, what's the rationale for the MAX_LOAD feature ? When would you use it ? suppose that you are running processes other than kuyruk workers in a server. if your jobs are low priority, you can process them only when the system load is below some level by setting this config variable. for example; at put.io our torrent downloader servers can transcode mp4 when the machine is idle.
I like `rq`, but I don't like how it uses `os.fork()` for each new task. Celery supports gevent and a good deal of my applications are built around gevent, so Celery is pretty much my only choice. Celery also has a bunch of features that are useful later on, even if you don't think you need them initially. Like scheduling a task to run repeatedly at a certain interval (like a cron job).
I think you misunderstand. You *never* want to rely on auto code reloading in production. The way most of these work is by looking for changes in the filesystem. These don't always propagate correctly, leaving your deploy ineffective or botched. You really want to explicitly run whatever command you need in order to reload at deploy time in your Fabfile (or whatever you use to deploy). I (and just about everyone else with production sites) do this with celery and gunicorn. This isn't a consideration at all in a production environment. On the other hand, Kuyruk lacks code reloading for development machines (which is what celery's and gunicorn's code reloading is meant for). It's not a big deal if it messes up on a dev machine, you can just kill and restart the process and be on your merry way. That said, I don't personally even use the code reloading locally. You don't *have* to.
It's OK if you want to re-invent the wheel to learn, that's OK and commendable. Just don't go whacking on another project like you did unless you have something legitimately better. Make your pitch based on what makes Kuyruk special (aside from "it's not celery").
Honestly, it would have been cheaper to spend $2 more a month to get a little more RAM :) Not sure what the point of mentioning multi-threaded servers is, celery can do that, and I'm not sure how that specifically solved your memory problem...
Just go to https://www.dropbox.com/developers/apps, create an app if you haven't, and click on it. The resulting page will list the key and secret.
Unfortunately the jump between Webfaction basic 256mb service and the next level up is a little more than $2. It's twice the price. Writing a lightweight multi-threaded server is not hard and my version takes per worker 10mb vs celery 50mb. This is NOT a benchmark, just my use case. Ymmv. It was a tipping point to make it worth my while though. Phillip.
If you check the edit, most of it got squished by simply searching for the div with the most direct descendant &lt;p&gt; tags. The out now is just &gt;$ ./summarize.py http://www.theverge.com/2013/8/1/4580718/fbi-can-remotely-activate-android-and-laptop-microphones-reports-wsj FBI can remotely activate Android and laptop microphones, reports WSJ | The Verge &gt;The Wall Street Journal reports that the FBI can already remotely activate those microphones to record conversations. &gt;Remotely activated cell phone bugs predate iOS and Android &gt;What's new, according to several former anonymous officials, is a dedicated FBI group which regularly hacks into computers, using both custom and off-the-shelf surveillance software which it buys from private companies. &gt;" While that source also claims the FBI takes care to make sure that only "relevant data" gets collected, it's still a little troubling to know that such a thing is easily possible and regularly done.
I feel it's pretty easy to understand. I prefer to make the code self documenting, than to add comments that will quickly become out-of-date and clutter the code.
https://www.heroku.com/ It's a nice service to use, supports most languages I've hosted a bunch of sites on their free tier. My only concern is their prices escalate quite quickly (a second "dynamo" jumps the cost from zero to $34/month, which is more than a decent VPS)
raw_input() needs to be assigned to a variable. You're calling the function every time you're doing the check. e.g. newvar = raw_input('enter something: ') You're also checking for a variable x that hasn't been assigned.
Handy. I never knew about this.
even that user interface is enough to give it a try. It's also really working well for me.
Hoho, I had to learn the API *very* quickly a few months ago when I accidently trashed our lab's dropbox trying to use the same folder through my dual-boot linux/windows machine. So glad they have one.
It's seems like haml. I try to use haml. It was very bad idea. 
haml's syntax is awful, yammy's is beautiful
Good job! It would be nice if, in addition to grabbing online webpages, it could also take as input plain text and/or local html files.
This looks like slim for python. 
For local html files, the file:/// should just work. For plain text ( I'm assuming you mean a text buffer consisting of html ) you could just split out the arguments yourself: html = bs4.BeautifulSoup(requests.get(url).text) @Rotten194: Well done!
Ok, so it's make more sense to me to achieve that kind of software with pyramid+celery, or something like that. It will be simpler to maintain, simpler to scale.
Thanks for the reference. Support of just "simple arithmetic expressions" is intentional and is the goal of Expressions library. Also it is hand written to have no dependencies. Example use (and the primary reason of existence): filter by expression or create new columns using an expression in [Bubbles](http://bubbles.databrewery.org) โ the framework has multiple backends, but needs some minimal expression standard that can be executed on all of the backends without any big hassle. Similar for derived measures in [Cubes](http://cubes.databrewery.org). Sometimes having full-featured grammar might be too much overhead. Also might impose quite large burden on backend developers. On the other hand, there are still plenty of tools and libraries providing complex and more generic functionality...
So it's a django/jinja2 template preprocessor?
gee that was intense
I gave WebFaction a try. Everything looks good, but this 256 MB limit drives me crazy. I only run one small Flask application (nothing special, just 4 pages) and the 'ps' command always tells me that my current memory usage is about 150 MB. So at the moment it seems impossible to me to run more than one single python application on a WebFaction account. 30/60 MB would be ok, but this is my idle memory usage when i just have restarted Apache. Any ideas what i am doing wrong?
I would really like to get some feedback. Do you have some feature requests? Any ideas how to improve it?
Looks interesting , will check it out. Thanks for putting it up on github!
&gt;It runs as a preprocessor for actual template engine like Jinja2, Twig or Django template engine. It's the second line in the README...
why does this need to be specific to a template engine? why not render from any template into a yammy template, then from pure yammy to HTML ? that is, none of the examples made it apparent why this needs to be a preprocessor and not a postprocessor.
Why the fuck does it have a radio? Get rid of the radio! I didn't actually read far enough down the page to guarantee it has one, but from what I did read it's a reasonable guess that it does: also get rid of the kitchen sink. If this is intended to be used at command line, why does it have a menu? It would be much more useful if it allowed me to specify the snippet I want as arguments, e.g. $ python h.py accent And the result of that should be just the code printed to stdout, from where I'll copy/paste it (my way: the way I usually do copy/paste (the one you don't know)) into my normal editor, where I have my normal syntax highlighting set up already. I don't particularly need syntax highlighting from h.py. When in Rome do as the Romans do, and when on the command-line: read input from stdin (or command-line args) and write output to stdout. Preferably plain text in both cases. This would be a more useful command if I could do something like $ python h.py accent &gt;&gt; existing_code.py And give it a decent name! This is a program intended as an aide-de-memoire, and you think I'm gonna remeber "h.py"? If it was called something obvious like "code-snippet.py", or "snips-collection.py" or even "my-snippets', *then* I would remeber it. (Don't worry about the length, I have tab-completion) &gt; I call the script h and it's in my ~/bin folder (where ~/bin is in my PATH). This way I can launch PrimCom from anywhere with the "command" h. Why the scare-quotes around "command"? It's just as much a command as any other executable file in your path, like "ls" or "cp" or "python". (Hope you read this in the constructive mode it is intended, but yes I am an "old neck-beard")
This is very similar to PyJade.
Cool idea, but I get the feeling that with the mandatory whitespacing, an actual in-practice template would look fairly hideous. Any counter-examples? 
&gt;Why the fuck does it have a radio? Get rid of the radio! The radio is not a core feature but I like listening to some electronic tunes while coding so it is a useful feature for me. I have written lots of scripts in my life but in time I forget about them and I don't use them. My idea is to integrate useful functionalities in this project and thus I can launch them from one place. But if the radio bothers you, just remove it from the folder "modules". &gt;If this is intended to be used at command line, why does it have a menu? It would be much more useful if it allowed me to specify the snippet I want as arguments, e.g. $ python h.py accent It is intended to be used from the command line as an *interactive* application. If I should specify tons of switches to get the job done, I would forget those switches soon and I would stop using this application. &gt;And give it a decent name! PrimCom is fine for me. As for the launcher, feel free to create a symbolic link with a name you prefer. I have a shell script called "h" (explained in the doc.) that is one character long and it's perfect for me. In my head I have the word "help", thus I can remember "h" immediately. &gt;Why the scare-quotes around "command"? OK, removed. &gt;(Hope you read this in the constructive mode it is intended, but yes I am an "old neck-beard") Sure. Thanks for the feedback but I don't agree with everything. (Edit: reply to scare-quotes added).
*"Why the [fudge] does it have a radio? Get rid of the radio!"* Does it really matter if it has one? I guess it's a little silly, but it's hardly worth being so rude about it. If it really works, I think it's kind of cool. (Out of place, but cool nonetheless)
OK, so go to LowEndBox/ServerBear, Digital Ocean, etc and pick up a full VM with 512MB for $5/month. Still cheaper than investing the time to shave off 20-30mb of RAM. Or, you know, just read the celery docs and note that you can set it to multithreaded and/or adjust the worker count :) This seems like the worse reason to be re-inventing the wheel...
Bit unclear on it's goal, but seems like a good sign. Is Mozilla beefing up Django for a specific reason? 
Just about everything other than the Mozilla.org and a few web services at *.mozilla.org run on Django. Fred Wenzel gave a talk about Playdoh that explains some of its features. http://opensourcebridge.org/sessions/576 and slides at http://dl.dropboxusercontent.com/u/18779383/playdoh-osbridge.pdf 
Not trolling, and after close to two decades in IT I'm quite familiar with the NIH syndrome. My whole argument was that NIH is not the default behavior for most developers until they find something they don't like with the one at hand. (Also, it's more applicable to scenarios where there's code inherited or being imposed on.)
This is the first line of Gittle's requirements.txt: GitPython==0.3.2.RC1
I didn't know that! Awesome. Thanks for the info. 
Where's the fun in that?
You don't...
Much of Playdoh was more important before Django 1.5. But it's mostly about setting up a project the way our ops people expect our projects to look as well as adding things our security people require. We don't (yet) use pip for deployment, so many of the dependencies are in git submodules. Stuff like that.
D'oh forgot about bedrock. So many years with mozilla.org being under [CVS/doctor](http://www-archive.mozilla.org/contribute/writing/cvs). 
you have much to learn of the ways of the FOSS 
You can distribute eggs and .pyc files and the like, but it wouldn't be too hard to reverse engineer one. Python does not have the ability to completely obscure code, and that is on purpose. Still, you can "decompile" most machine code without too much difficulty, but a good way to make it more difficult is to enable optimizations, which Python can do when generating the .pyc files.
It's a site with a lot of history in both code and content, which is part of why I love it so much :-) 
I'd probably try using [cython](http://cython.org/) to compile your Python down to C code, then distribute your application as Python binary libraries (.pyd). Should be decently obscured. For example this proprietary Windows automation tool, [Automa](http://www.getautoma.com/), exposes a Python interface, making use of this notion.
jar files are just zip files containing java bytecode. Java bytecode is pretty easy to read and there are programs that will produce Java source from them. You can't keep secrets from people who have access to your program.
server-side code stays on the server, so the client never sees it. When you use reddit, you're seeing the results of the python code, not the source. 
I don't know, but maybe you could read [this](https://github.com/reddit) code and figure it out from there.
There are no secrets. Almost everything out there has a decompiler, and beyond that it's possible to hack around with a hex editor and reverse engineer some things.
The only secure approach you can really take with python is to run your sekret code on a server you control and distribute client code to your user. Read: make your UI a web page, and don't distribute your python.
This is the problem I'm having now as well. Pyside looks good because it doesn't have the commercial licensing restrictions that PyQt does, but I don't know how long it's going to be around now the Qt Digia is up and running. Anyone care to weigh in on this?
no.
I don't see why this is better.
No, they won't, not unless you configure your web server wrong. It seems you have a very shaky grasp on how this stuff works. I suggesst you read up on how frameworks like Flask, Django, Web2Py, etc work.
Could someone explain to me what the key insight and/or change was that allows objects that are a part of a cycle to have their finalizers run now? I tried reading [the PEP](http://www.python.org/dev/peps/pep-0442/) but I had trouble fully understanding its implications.
There's an extra bit to all objects specifying if the __del__ has been called. This guarantees that the finalizer is only called once, even if that object was resurrected as part of trying to resolve a previous cycle. This marking step is done to all objects in the cycle so that it seems atomic to Python code.
Thanks!
[Here's the more detailed "what's new" page](http://docs.python.org/3.4/whatsnew/3.4.html). 
Did you try just running SysTrayIcon.py with python itself? Does that work? Because it maybe that the version of python you're using isn't compatible with SysTrayIcon.py. It's old code... I'm not near any windows machines so I am unable to try it... I will keep note of this code though because I will need something like this in the upcoming weeks. :)
Can you pinpoint where in the code it is stopping? What version of python are you using? Any other things you can think of that might help debug it? This is bugging me, but it looks like I wont be near a windows machine for at least 3-4 days.
will do so! thanks for reminding.
Not to be mean, but I'd never use this :( The time it would take to force all of my knowledge into this format completely defeats the time it MAY save in the future--what if I need a snippet and I'm not at the office? The Google 30-60 second solution, or even going over your own blog seems to be the better way still. Also, I think the point about "get rid of the kitchen sink" is right. How can you REALLY solve this problem well? I think you just kinda made more problems. Is there a way you can take all of this knowledge I already have a nice method finding, and making it so I can't find it again? I guess that's what bookmark saving sites are for, or maybe a Chrome plugin to make notes... I'd still prefer Googling/Stack Overflowin'!
I read that as emphasis, not really rude. I used to (still do, probably) include way too much in trying to solve a problem, so much so that the problem is *solved* but not very well. Instead I'm distracted by this extra bell or that extra whistle.
Looking forward to enum support.
Its implementation is [already on PyPI](https://pypi.python.org/pypi/enum34) and it even works for Python 2. Now that the "official" enum API has been chosen, no need to wait anymore, we can use it right away and stop wondering "so, is this the *right* enum package?".
&gt;Not to be mean, but I'd never use this :( You don't have to. Here I'm trying to find a better way to organize and access my code snippets. I have tried several methods: notes in simple text files (it was the predecessor of this project); browser bookmarks (I have hundreds, impossible to find quickly what I'm looking for); mind mapping softwares, etc. They are all good but I wasn't fully satisfied with them. I was working on this thing in the past 1.5 months in my spare time and it has already helped me a lot (even during the development of this app. itself, thus "eating my own dog food" worked for me). &gt;The time it would take to force all of my knowledge into this format completely defeats the time it MAY save... If I need to look up the same thing more than twice, it is an indication that it'd be a good idea to take a note about it. Creating a new entry is done in 2 minutes. &gt;what if I need a snippet and I'm not at the office? Then use Google. I have this project in my Dropbox folder, thus I can access it at home and at my workplace. These are the two places where I code, so it's good for me. &gt;"get rid of the kitchen sink" I didn't understand this part in the previous message either. &gt;I'd still prefer Googling/Stack Overflowin'! To find the solution for a new problem, I do the same. For solving an issue for the 20th time, I prefer to look it up quickly in my own notes. Example: I use pdftk to combine PDF files into one but I always forget its syntax. And this problem comes up once in a month. With PrimCom: pc&gt; pdf (1) pdftk pc&gt; 1 ------------------------------------------------------------------------------ pdftk examples ------------------------------------------------------------------------------ # combine PDFs into one file pdftk *.pdf cat output all.pdf pc&gt; If you have a faster solution, please let me know, I will buy it.
I just tried it on a new win2k12 server instance with official python 2.7, offical win32api[1]. "official" SysTrayIcon.py[2], and some *.ico files in working directory. Running SysTrayIcon.py directly worked for me, as did your paste. "Works for me" isn't helpful, but maybe try on another box/new vm and make sure it's not something specific to that box/instance. [1] http://sourceforge.net/projects/pywin32/ [2] http://www.brunningonline.net/simon/blog/archives/SysTrayIcon.py.html
 - thread1 = Thread(target = derps(), args = (11, )) + thread1 = Thread(target = derps)
This works for me (Python 2.7 32 bit on Windows 7 64 bit): http://pastebin.com/0a0FqrYj Main thread starts, fuck thread starts and prints fuck repeatedly while main thread is inside the SysTrayIcon loop, clicking menu items works, when quit is clicked SysTrayIcon returns, main thread terminates, fuck thread notices `stop_flag` and terminates.
I didn't really look at your code, just copypasta'd it myself. Looking at it, you're doing it a bit wrong. The target argument to Thread should be a function that's called by the Thread.start method. In your example you were actually passing the result of calling the derp/s functions to the target argument. Surprisingly (to me, at least -- I'm sure there's a reason), passing target=None to Thread, which is what you were effectively doing, doesn't except (tried on windows and linux). This also means the args param to Thread wasn't actually doing anything. The target=None (maybe even "not target"?) is apparently a special-case for Thread.start. Here is a version that passes the function objects themselves as the targets and drops the unused args parameter[1]. The derps function also tries to call itself recursively, forever. This means that when the main thread exits, the thread running derps is still active, so the program won't terminate, and you will also eventually reach the system recursion limit. You need to syncronize the two theads, or even better, look for some kind of system event loop you can register callbacks in for repeating tasks. I'm not a windows guy, so I can't really be of more help on the specifics. [1] http://pastebin.com/xHdVXp8M
&gt; You can't generalize your experiences to everyone; you're not the world. I was merely responding in kind. e.g., You said, "they aren't rare." Assuming there isn't some published data set implicating the frequency of proportional fonts in programming, you're just generalizing your experiences to everyone. And you know, you're not the world! &gt; Considering the entire discussion is about the consequences of formatting choices, it's well worth taking into account the assumptions one makes. It's like chiming into a discussion about arithmetic and reminding everyone that "1 + 1 = 2" may not always be true since "1" as a symbol could feasibly correspond to a different numeral in a different context. While you may have stated a fact (e.g., spaces can't align proportional fonts), it is pedantic and irrelevant. I'm all for stating assumptions. But if we have to state all of them, we'll never get to talk about anything. More to the point, if the **discussion is about horizontal alignment to a column**, then it is patently obvious that proportional fonts don't apply to any conclusions drawn.
RealPython also includes videos. (disclaimer: I am the co-founder)
re: command line arguments, you should have a look at docopt, which makes building a CLI a magical experience.
Short answer: nope! Basically, that would only happen if you've configured your web server to do that, which is almost always considered a very serious security vulnerabity! Broadly speaking, python web apps have some code that links valid URL patterns with a particular python function in your code. If a user types in a URL that doesn't match those patterns, the web server returns a 404. So unless you set up say, a pattern for /*.py that returns the contents of a file in your code base, that won't happen. This is also why you'll often see images with URLs like /static/foo.jpg. Their web server has a pattern like /static/*.py that returns the contents of a file in /static/ on the server. But actual code is in a different server!
I'd be interested to hear whether this is a viable option for cross-platform (specifically iOS and Android) app development. How does it compare to phonegap?
Using something like http://nuitka.net/ would make decompilation non-trivial but it may have some limitations on what code you can run.
What an utterly pointless and negative comment. You bring no value to the discussion and yet you have the most votes.
Wish I could use Python 3. Doing heavy scientific computing stuff but my toolchain doesn't support it. Does NumPy even work on Python3 yet?
this isn't possible with any language whatsoever. C can be decompiled, as can all other compiled languages. you're taking the wrong approach either way.
Java source with typical comments isn't that easy to read if the programmer doesn't think like you do and you can't ask anyone about it. It would almost always be easier to reimplement something from scratch than reverse engineer it from decompiled files.
Reddit is open source. https://github.com/reddit/reddit
This is a good explanation but to be honest I have a hard time finding reasons to use the variable length syntax. Since Python has default values for formal parameters *args and **kwargs just seem like a less explicit way of doing things, at least for formal params. For passing actual parameters in my mind the syntax just seems sort of *bad*. At least for me personally I haven't come across a use case where I *need* variable arguments to accomplish something. There have always been better choices.
Say you're subclassing something but don't know what parameters you'll get at runtime. Without variadic parameters, you've got no way of correctly passing the arguments to the superclasses. (You don't even know what you'll be given!) Or say you want to implement something like the print function. Again, without variadic parameters, you're just out of luck. (Although this one is slightly better. You can wrap the whole thing in a list and then iterate, but that's ugly.) I'm sure I'm forgetting a couple of other uses, but those are the main ones.
I'm not who you responded to, but in some of my code that runs experiments, I use `eventlet` for easy parallelism when shelling out to other tools. I don't think there is any greenthread library available for Python 3 yet, but I hear that `gevent` is close. (I guess there is also supposed to be support for async IO in 3.4 in the final release, which would satiate me personally.)
There's an unofficial branch that supports python3 already: https://github.com/fantix/gevent .
General decorators need them: def the_incrementator(func): def closed(*args, **kwargs): return func(*args, **kwargs) + 1 return closed @the_incrementator def multiply(multiplicand, multiplier): return multiplicand * multiplier @the_incrementator def sum(*args): total = 0 for number in args: total += number return number In the first function (`multiply`), we have two parameters, so we could have written the `closed` function with explicit parameters too. But then, how could I also use it for my implementation of `sum`, which has a variatic parameter? When we accept all forms of arguments and simply pass them along, we allow for any interface to be decorated. **Edit:** That's just an example (two, really) of course. I don't wish to encourage the use of variatic parameters. I used them frequently in the past and later decided that keeping to a more simple interface (single object) and calling the function on each member of a collection was a less complex way of doing things.
Well they still did not fix random crash over several URLrequests I posted... That's a shame...
The mirror use case is when you need to pass a list or dict as separate positional or keyword arguments: def foobar(foo=None, bar=None): print(foo, bar) l = ['hello', 'world'] d = {'foo': 'hello', 'bar': 'world'} foobar(*l) # ('hello', 'world') foobar(**d) # ('hello', 'world') 
What is Adventurito? Why is it not explained in a comment at the beginning of the source?
Python's enums are shit. They're probably going to make it in to the "don't use" section of every style guide.
...why? I'll certainly be using them. I mean they're a little bit more "magic" than I'm used to in Python, but I can't see how to make them less verbose without adding syntax, and they're as powerful as they can be in a dynamic language.
That's probably why they are trying to IMPROVE enum.
Kivy apps aren't native either. They embed Python and their own UI. 
True, but they have a much more native feel to them.
Have you filed a bug report?
Actually there were some *really* magic enum proposals *with implementations*. (Guido rightly thought they were too magic). Example: class Color(enum.Enum): red, green, blue
Well, in python 3, it happens in definition order. In the python 2 backport (`enum34`) it does some other thing (https://pypi.python.org/pypi/enum34/0.9.11). I'd be happy with value order across the board. Also, why would `list` be faster? I'm not doubting, but `tuple` has been my go-to primarily because I figured it'd be faster. I'd love something definitive either way.
I am mad excited for something like a functional look languages head and tail to become commonplace in python.
Yep.
you have it right, but its not just android, its cross platform apps in python
Desktop apps then? I guess I'm a bit fuzzy on what cross-platform means in this context.
For inspecting an object to see what variables / functions it has, I use these methods: from pprint import pprint def print_variables_of(obj): """variables of an object""" pprint (vars(obj)) def print_callables_of(obj): """callables (functions too) of an object""" li = [] for name in dir(obj): attr = getattr(obj, name) if hasattr(attr, '__call__'): li.append(name) pprint(li)
From their [frontpage](http://kivy.org/#home) &gt;Kivy is running on Linux, Windows, MacOSX, Android and IOS. You can run the same code on all supported platforms. &gt;It can use natively most inputs protocols and devices like WM_Touch, WM_Pen, Mac OS X Trackpad and Magic Mouse, Mtdev, Linux Kernel HID, TUIO. A multi-touch mouse simulator is included. 
I was previously using WebFaction, but since some months now, I have switched to https://www.tilaa.com/ It is cheaper and I am happy with the service.
having done both, I disagree entirely. :-) Comments don't affect code readability. Reading code is of course hard work, but all of programming is. :)
&gt; Kivy is running on Linux, Windows, MacOSX, Android and IOS. You can run the same code on all supported platforms. Does it produce native look and feel on those platforms, or is it just a custom widget set that runs on all? &gt; It can use natively most inputs protocols and devices like WM_Touch, WM_Pen, Mac OS X Trackpad and Magic Mouse, Mtdev, Linux Kernel HID, TUIO. A multi-touch mouse simulator is included. I don't know what most of those things are. Is that just saying that it can implement multi-touch interfaces on different platforms? 
See also these posts on pudb: [Part 1](https://asmeurersympy.wordpress.com/2011/08/08/hacking-pudb-now-an-even-better-python-debugger/), [Part 2](http://heather.cs.ucdavis.edu/~matloff/pudb.html).
It's not aimed at native widget look and feel - it implements its own (skinnable) widget set. Though IIRC the default widget set is a heck of a lot like Android ;-)
 Python 2.7.4 (default, Apr 19 2013, 18:32:33) [GCC 4.7.3] on linux2 Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; from timeit import timeit as T &gt;&gt;&gt; x=range(10000) &gt;&gt;&gt; T(lambda:tuple(x),number=100000) 3.9424309730529785 &gt;&gt;&gt; T(lambda:list(x),number=100000) 3.974297046661377 
Got it. Thanks!
Let the constructive criticism flow! This is my first project that I want to show to the world, and I want to do it "right." A `setup.py` is coming, as is documentation.
It is _somewhat inconvenient_ to automatically-generate code in syntax of yammy and similar (with mandatory whitespaces and such)
This was enough: def greet_me(**kwargs): if kwargs is not None: for key, value in kwargs.iteritems(): print "%s == %s" %(key,value) &gt;&gt;&gt; greet_me(name="yasoob") name == yasoob
Hello there, I was wondering what was your take on [pyevolve](http://pyevolve.sourceforge.net/) and in which way your package will differ? What's your aim?
Should it be changeCode = 'yes' while changeCode == 'yes' or changeCode == 'y':
Couldn't figure out a way to set up sys.path so that DreamPie could interact with Django; PYTHONPATH seemed to be ignored. (Obviously, I can change sys.path from inside DreamPie, but I'm looking for a solution I can script once then forget.)
This came up on r/learnpython some time ago, the discussion with the tutorial link is [here](http://www.reddit.com/r/learnpython/comments/196rpj/most_comprehensive_tutorial_on_understanding_use/). I found the tutorial useful and hopefully someone else will. 
You could try http://mrbob.readthedocs.org/en/latest/
&gt; Edit: I'm going to try jinja2, thanks for the tips I think it's a good idea. It's used by Flask (which is a good web application framework) but it's independent at the same time and does a lot of things. Good luck.
Is it possible to create Android widgets?
PyOhio should clearly be held at [OhioPyle](http://en.wikipedia.org/wiki/Ohiopyle,_Pennsylvania).
Both SaltStack and Ansible support Jinja2 templates. There are also a number of recipes for zc.buildout that support Jinja2 templates.
Here's the source for random.choice: def choice(self, seq): """Choose a random element from a non-empty sequence.""" return seq[int(self.random() * len(seq))] # raises IndexError if seq is empty Without changing `random`, Enum would need to implement `__len__` and `__getitem__` for this to work. Enum *has* `__getitem__`, but it's name indexed: &gt;&gt;&gt; Color['red'] &lt;Color.red: 1&gt; So, to make this work, you would need to either change the indexing system for `Enum` or change the implementation of `random.choice`. Maybe you could make `random.choice` into a single dispatch function. Edit: The other option is to give Enum a `random` method.
Thank you again Katie for hosting young coders at PyOhio. Hopefully we can get tou to come back in the future to do it again. Sincerely, The guy who wouldnt let you paint his nails. :)
`Enum` was not really designed to behave like a sequence. It was deemed more useful to have `Color['red']` and not `Color[1]`. The latter is available with the constructor syntax - `Color(1)`, to mimic other built-in types. Your problem is solvable with just a few extra chars: &gt;&gt;&gt; random.choice(list(Color)) A good design plays well, in expected ways, with other existing language features, instead of implementing its own way to everything. Like the Unix philosophy. 
jinja2 is money, but you could also just use the new style format strings (http://www.python.org/dev/peps/pep-3101/)
More like Opyo AMIRIGHT?
The simplest way would be to use [string.Template](http://docs.python.org/2/library/string.html?highlight=template#template-strings) from the standard library.
Interesting. So you have a default set of settings and then mrbob is used to query the user for everything else.
I'd love to come back! You know, to teach Young Coders, and to get another crack at your nails! ;)
this is way better than scraping imgur for kitten pictures. 
Pyevolve author here, congratulations on the work ! Some constructive suggestions: - Implement more crossover methods, you only [have 3](https://github.com/Lucretiel/genetics/blob/master/genetics/cross.py), the same applies for mutation operators; - Be careful with the class names if you want to be taken seriously about GAs (i.e. DNABase class, [DNABinary](https://github.com/Lucretiel/genetics/blob/master/genetics/dna/binary.py), etc..), prefer using the well-known literature names for classes, like individuals, chromosomes, genotypes, phenotypes, etc - Provide methods for the user to specify initial population individuals, this is very important and is a recurrent subject with Pyevolve; - What is a ["discrete simulation"](https://github.com/Lucretiel/genetics/blob/master/genetics/simulation/discrete.py) ? - Implement fitness scaling methods; - Multi-core evaluation of individuals is also essential, many users have evaluation functions that takes a lot of processing power and time; - Be sure to use a good OO design in a way that the developer using your framework could be able to change every behavior of your algorithm, this is something always requested; - Document everything, specially algorithms you've used, if possible, citing papers and references; 
I'm the author of this project. I originally developed it for a sensitivity analysis of a high-dimensional agent-based simulation, but I've generalized it and have since used it for other tasks (such as parameter estimation of non-linear problems). If you have any suggestions/criticism, let me know!
&gt; There are a LOT of users who asked for this, and each case has a different reason, Huh! I would not have guessed ... obviously. &gt; some wants this as a performance, That seems speculative. My systems usually do better when I don't seed them with my stupid misconceptions. &gt; some as pure research, etc. *THAT* I get. In any case, thanks!
My first thought would be ease of use with respect to codebase maintenance. In spite of all its usefulness and speed, Javascript is still junk to read. If this is something you want to maintain and update over years (and I'm assuming it is), Python definitely has an advantage in maintainability.
Programming languages can be seen as tools in a toolbox; if you have to build something, you pick the right tool for the job at hand. Don't deny another language just because you prefer another, it makes you 'that negative guy', and will eventually cause them to work around you (which in turn makes you redundant). I too prefer python over JS any day of the week; but if my team suggests doing something in JS, java or .net, I'll at least give it a try. Readability, as mentioned, is in the eye of the beholder; python's tab-based code blocks aren't always as readable as they can be, so it's more a personal flavour than something you can use as an argument. Instead, things like language maturity (while javascript is rather mature, node.js by itself, is still an upcoming language), programmer knowledge (and expertise) are far better arguments to use (though the latter is somewhat situational, if you team has a vast amount of node.js experience it's completely moot). Things like library availability as you mentioned are also valid arguments.
Good luck getting any *good* IDE auto-completion and introspection in JavaScript. Python is still bad at this but JavaScript is far behind it. Still ... don't take my word for it - try some IDE first, write some javascript and see how it goes. And CoffeeScript ... is one of those things you have to buy into it or avoid it. It's going to make you write code faster but it will hurt you at debugging, not to mention having less options for introspection in IDEs ... Then again, if the rest of the team already knows JavaScript/CoffeeScript then the choice appears obvious :) 
It's really useful when you want to subclass (as another poster already showed) or when you want to pass keyword arguments to an underlying function. For example, you might want a custom plotting function that passes keyword arguments to the underlying plotting function.
Yay! I hope he's enjoying his Raspberry Pi!
The way I see is that saying that a Genetic Algorithm is a discrete simulation is the same as saying that PyPy has a Python interpreter written in Python, isn't wrong to say that but it is not precise at all because the interpreter wasn't actually written in Python but in RPython. Saying that a Genetic Algorithm is a discrete simulation is not wrong but is not precise because you have the generational and the steady-state and both are discrete simulations as far as I understand. The important thing to note and that you may be missing is that Genetic Algorithms are used mostly on other areas where people usually knows the basic of Python and how to use it, if you're expecting a user like this to look at the source-code to understand which kind of GA he is using you're doing a terrible mistake, but that is my personal opinion of course, you may have the opinion that is easy to users to read the source.
Perhaps you could have them make pictures next year using pygame?
If we have time. We're going at top speed most of the day in order to get time to play around with PyGame. It depends on how much energy the class has around 3... and how much energy I have!
Programarcadegames.com
have you considered mint? not just for html
Consider this your public invite to come back! We'll even put Sunday Mani-Pedi on the formal schedule.
Thanks! I've read a lot of opinions that seem to point to Ruby/Rails being a more optimal web-app/website language, yet it seems you're doing just fine with Python/Django. Most of the arguments point to Twitter and other sites specifically for speed and flexibility, and Google gets pushed for Python (which doesn't make too much sense to compare them). Since my focus will be on web-apps/websites, what led you to continuing with Python for your web applications over working with Ruby? It seems Ruby is the big trend, but would you say that you could do anything Ruby can do in Python, or are there actual differences between the two besides syntax?
Is there a way to indicate that a solution is unacceptable? My pet search problem is organizing a bunch of rectangles so that they don't overlap, and the distance between each pair of rectangles is minimized. If I return float('inf') in a case where there's an overlap, will that affect the behaviour of the search? Presumably, it's still useful for the search to know that distances have decreased. Or is this search not well-suited for this problem?
Thanks for sharing, and thanks for doing this! I will be having a student in my Intro CS class next year that participated in your event, and she is absolutely psyched as a result. It's also good for me to know that you did PB+J with them... I might need to get some new tricks!
Node.js is more equal to Twisted in spirit and implementation than anything else. Why anyone would want to be constrained by a **Single Threaded** SEDA based system in 2013 with all the multi-core goodness is beyond me, when I get bound it is usually I/O then CPU. Frankly after learning Erlang and porting multiple Twisted apps that didn't scale because of CPU bound behaviour, I can't in good conscious recommend Twisted or Node.js either one. Niether JavaScript nor Python "scale" in the sense of maintainability in numbers of lines of code; honestly no loosely type system does because the IDE can't reason about what is connected to what and doing impact analysis and other code quality things is a nightmare when you get past about 10k - 15k lines of code. Seeing how I usually work with multi-100k to more than 1Million lines of code on a regular basis gives me a unique perspective. I still think Python and JavaScript are great languages and have unique benefits, but when it comes to managing large code bases, they become un-wieldy quickly. 
Agreed, will be trying tomorrow!
The idea is that the `simulation` package provides the code that ties everything together- population generation, mutation, selection, combination, etc. If users want more fine-grained control, they can use all the individual components themselves. Now, the idea behind `DiscreteSimulation` is that it runs the genetic algorithm in discrete generations. With the exception of the elite selection, each generation is totally new. The future goal is to also have a `ContinuousSimulation`, in which members of the population reproduce and are killed off randomly (weighted by score), but in which there are no discrete "generations." Documentation is very near the top of my todo list. Right now I'm trying to create a more elaborate example than the one in my `README.rd` file; something similar to [this](http://math.hws.edu/eck/jsdemo/jsGeneticAlgorithm.html), as a test that everything is working.
&gt;* Implement more crossover methods, you only have 3, the same applies for mutation operators; What other operators are there? I designed the mask system so that users of the library can make more case-specific mutators and crossoverers, but I don't know of any other major ones. &gt;* Be careful with the class names if you want to be taken seriously about GAs (i.e. DNABase class, DNABinary[2] , etc..), prefer using the well-known literature names for classes, like individuals, chromosomes, genotypes, phenotypes, etc There's a fair amount of renaming I need to do (combine vs crossover, unnecessary overloading of python terms, etc). I'll be doing this as a part of that. &gt;* Provide methods for the user to specify initial population individuals, this is very important and is a recurrent subject with Pyevolve; Right now, `DNAComponent`s can implement `initial_value` and `mutate_value`, while `DNASegment`s can implement `initial_components`. I'm planning on adding the ability to initialize a population in a simulator from a generator. &gt;* What is a "discrete simulation"? A discrete simulation is a GA that runs in discrete generations. That is, with the exception of the elite carryovers, each generation is completely different, and made up of elements from the previous one. The plan is to later add a `ContinuousSimulation`, in which members are born, breed, and die, all within a single, dynamic population (obviously, more fit members breed more and live longer). &gt;* Implement fitness scaling methods; Will do. &gt;* Multi-core evaluation of individuals is also essential, many users have evaluation functions that takes a lot of processing power and time; Will do. &gt;* Be sure to use a good OO design in a way that the developer using your framework could be able to change every behavior of your algorithm, this is something always requested; This has been my design goal from the get go. For the most part I think I'm doing ok; There are some areas that need work. One area I need to figure something out in is variable length combination; right now the design of it simply wouldn't allow for it (cause it's all based on recursive `*zip` under the hood). &gt;* Document everything, specially algorithms you've used, if possible, citing papers and references; Documentation is very high on my to-do list, although I wouldn't have though to do citations. Where would be a good starting place? Most of my knowledge has come from wikipedia and [boxcar2d](http://boxcar2d.com/about.html). Thanks for all the feedback!
Most of this is common errors in all languages, if you replace Python lingo with C#, C, Java, PHP... Shows how similar the foundations are in all languages.
Python is utterly un-refactorable. How does that fit with maintainability?
&gt; Most of this is common errors in all languages There's a bit of a difference, in that many of these errors will be compile-time in many statically typed language: AttributeError, TypeError, NameError, storing the result of a `void` function/method, ... unless you're using reflection APIs these won't even reach runtime and with the rash of modern compiler providing errors which are actually worth reading (thanks Clang)... Some will also change due to API differences e.g. Java's `Map#get` (which is equivalent to `__getitem__`) will return `null` on a failed key, not raise an error; whereas Rust's `Map.find` will return an `Option` (much like Haskell's `Data.Map.lookup`) and thus the error will normally disappear as the compiler will enforce correct handling of your cases (*or* you will have a very different error) Finally some are completely false, you can't have a single equal in a boolean context, assignment is a statement and `if a = b` is a syntax error.
The single-thread thing is slightly less horrible than it sounds at first, because the heavy lifting is offloaded to library functions, many of them implemented in C; those functions *can* use multiple threads to run in parallel. The single-thread limitation "only" applies to the actual JavaScript code you write, any asynchronous function will at some point fork into a parallel thread and join back in when it injects the callback into the JS engine. Still, it means you can't really implement the performance-critical code in JavaScript if you want it to scale well, and if you do need threading, you have to step down into the realms of C and the FFI, neither of which is pretty.
Oh, and a big fat upvote for the maintainability thing. Maintainability is a big issue for dynamically-typed languages. Python is actually a tad bit worse than JavaScript and PHP, due to the significant whitespace.
That isn't BS whatsoever, and unfortunately is how a large number of programmers understand it (including myself for a long while). Strings are essentially an array of numbers that are interpreted as characters. How these numbers are interpreted depends on how they are encoded. Here you are explicitly telling Python that a bytestring is UTF-8 encoded (do you actually know that?), and so it returns a UTF-8 interpreted version of that string for you. I very highly recommend reading on Unicode and especially Unicode in Python 3. It took me a long while to completely understand as I'd always assumed (incorrectly) that all strings are ASCII unless explicitly stated otherwise. Here is an old but still very valid and widely used resource on Unicode for programmers: [The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets \(No Excuses!\)](http://www.joelonsoftware.com/articles/Unicode.html) Happy programming :)
I am shocked that "def foo(d={}) :" Didn't make the list. I've been pythoning for years and I still make that mistake one in a while. 
This might just be a 'me' thing, but Javascript is one of those languages I could write something in and not be able to explain or divine it's workings after a weekend of not looking at it. To me, maintainability is being able to look at a chunk of code, realize its workings quickly, and change it to suit your purposes or goals. Python wins IMO because steps 2 and 3 of that go a lot faster for me. 
Wrapper functions (decorators or otherwise) and functions that need to process arbitrary distinct inputs in a certain way (like templating languages, e.g. `render("template.html", id=user.id, age=user.age)` or something similar) are some common use cases.
That one isn't uncommon either: a = 'hello there',
Could you explain the problem rather than just giving an abstract line of code? In this case, do you mean that it's unexpected that 'a' will end up as a tuple containing a string rather than the string itself?
Yes. I work mostly in C++ so this one nuance of Python often escapes me when I've been in making my own references for months. 
noob programmer here , can somebody explain me linked lists like i am 5 year old ( with case of use if is possible )
It does, '=' is purely the assignment character in Python, like ':=' in Pascal.
This talk from PyCon US 2012 is a great explanation of the Unicode, UTF-8, strings, and byte strings: http://pyvideo.org/video/948/pragmatic-unicode-or-how-do-i-stop-the-pain
In case anyone missed it, chub79's code snippet has a trailing comma (,) which makes a 1-element tuple whose only element is the string "hello there" instead of what you might expect by glancing at the code which is simply the string "hello there". I have made this mistake more than once in my years of Python programming!
Sounds awesome. I wish they did more stuff like this when I was younger. 
Not gonna lie: on the quicksort front, haskell totally blows python out of the water: quicksort :: Ord a =&gt; [a] -&gt; [a] quicksort [] = [] quicksort (p:xs) = (quicksort lesser) ++ [p] ++ (quicksort greater) where lesser = filter (&lt; p) xs greater = filter (&gt;= p) xs (If we're counting lines here, it's 5 lines (6 if you include the optional function signature). Plus it's superelegant) This isn't really a fair comparison: this sort of algorithms work is FP's specialty.
Sorry for that. As denversc mentions, it's the trailing comma that makes your variable a tuple rather than a string indeed (well unless it's precisely what you want ;)). Some editors have fonts that make those hard to spot.
For simplicity and dependencies reasons I would go with this advice. Jinja2 seems overkill for config files.
I have to wonder why the author considers this to be a "fundamental data structures that every programmer should know", other than historical interest.
Consider this instead: &gt;&gt;&gt; def f(d=[]): ... d.append(1) ... print d ... &gt;&gt;&gt; f() [1] &gt;&gt;&gt; f() [1, 1] &gt;&gt;&gt; f() [1, 1, 1] &gt;&gt;&gt; f() [1, 1, 1, 1] The 'd' variable points to a mutable object that was initialized the first time the function was called. Afterwards, it's always the same instance of the list that is pointed to by the variable 'd'. It's not a new list each time the function is called. It's an issue with the scope of the function parameters and the mutability nature of the list.
I can understand why some companies would pay for such work to happen but from a hobbyist's perspective... well I can't see any.
 &gt;&gt;&gt; def word_frequency(corpus, hist={}): ... # Create a new histogram, or further populate an existing one ... for word in corpus.split(re_defined_earlier): ... if word in hist: ... hist[word] += 1 ... else: ... hist[word] = 1 ... return hist ... &gt;&gt;&gt; hist1 = word_frequency(mark_twain_quotes.txt) &gt;&gt;&gt; hist2 = word_frequency(othello.txt) &gt;&gt;&gt; hist1 == hist2 True &gt;&gt;&gt; # Well fuck. This is a pretty contrived example, but the pattern of * use a kwarg-default dict multiple times, * in a function that modifies the provided dict * those changes are still present the next time you call the function with default value has bitten me in the ass in the real world multiple times. Because you always assume that you're getting a clean slate on every run of your word_frequency function, that (if not provided) hist will be a fresh/new dict ready to play with. It won't be, it'll still be all full of leftovers, because it's literally the same dict object "by reference." The reason, of course, is that the function header line is evaluated (including default arguments) at the time the function is parsed, not when it's used. Another example that can help clear this up: &gt;&gt;&gt; def rand_square(number=random.random()) ... return number * number This is a stupid function on several levels, but in this case, the relevant problem is that it will *always return the same thing,* no matter how many times you call it. Mind you, it'll be a different thing every time you restart the interpreter, or redefine rand_square, because that's when the random.random() is being evaluated. But if you just start up a Python interpreter, define that function, and start using it, you'll get the same value every time. This is why our dict-based examples don't work. Because the dict is created during function definition, we never get a fresh one. The usual solution is to make the default value None, then test for `if hist == None:` to set it to a new, empty dict.
&gt; This can happen when code explicitly tests for whether something is a list/tuple and treats that as the definition of iterability. Yeah, don't do that. Python advocates [Duck Typing](http://en.wikipedia.org/wiki/Duck_typing) to avoid this. In this case, it's better to probe for methods: hasattr(value, '__iter__') Or use Abstract Base Classes (I prefer this, feels more expressive): isinstance(value, collections.Iterable) In order to test item return values if you're not sure of the type.
Related to the if block, I see if foo==3 or 4 All the time in /r/learnpython
Unfortunately third party libraries don't always do that correctly. Part of the reason is that strings are iterable and they're often one of the things you want to distinguish from tuples and lists.
[Linked list](http://en.wikipedia.org/wiki/Linked_list).
&gt; That seems speculative. My systems usually do better when I don't seed them with my stupid misconceptions. If you're optimizing a continuous function, a few steps with a convex optimizer can achieve a lot more improvement than any stochastic search. Think about the [Rosenbrock function](http://en.wikipedia.org/wiki/Rosenbrock_function) for example. It's quite strongly convex away from a region of comparably good solutions. Multiple random starts plus a truncated convex optimization on each should seed the population pretty well.
`AttributeError` is raised when there is no such attribute in an object, which means methods **and** properties. `IOError`: On Python 2, it also includes other I/O-related errors (eg. permissions). On Python 3, those are moved to separate exceptions.
Pycharm is great at autocomplete. Vim, emacs, sublime, etc, are good also, although you need the correct plugins. It's a myth that autocompletion doesn't work in dynamic languages - it just works differently. 
Look at the Rosenbrock plot. Convex optimizers are bad at plateaus and valleys (and local minima), but good at finding them.
[This is a free course with home work and downloads that teaches you how to understand, read and write python] (http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-00sc-introduction-to-computer-science-and-programming-spring-2011/). It's a course taught by an MIT professor as well as TA lab lectures. I just started the course in my free time it's pretty fun and doing the homework was fun. on the left you'll see "UNIT 1" which has the first chapters home work and video lectures as well as downloadable slides and notes. 
Thank you! It looks like he changed his site. [This](http://harry.me/blog/2011/07/05/neat-algorithms-harmony-search/) is the correct link.
HS can/will definitely still be useful. For a minimization problem, it's absolutely acceptable to return float('inf') in the case of an unacceptable solution. In fact, I'd argue that's probably the best way to handle it to ensure that the solution doesn't get considered.
I just understand code better than plain english
This is awesome. I'm surprised it hasn't been implemented already.
A semi-official backport of the `enum` module to earlier Pythons is https://pypi.python.org/pypi/enum34/ 
Udacity CS 101 offers streaming and downloadable videos.
it's a python 2 blog post (iterkeys vs keys) ?
Joke apps?
I did. Thank you!
Doesn't even answer the question posed in the title. 
Pedant: initialized when the function is defined. Not first called. Although for most cases, the distinction is not important 
I'm not really a fan of the namedtuple syntax either, but fortunately that's not the only way to declare an enum.
You can do a binary Enum by using their `int` Enum recipe: &gt;&gt;&gt; import enum &gt;&gt;&gt; class BinaryEnum(int, enum.Enum): ... falsy = False ... truthy = True &gt;&gt;&gt; BinaryEnum.falsy &lt;BinaryEnum.falsy: 0&gt; &gt;&gt;&gt; bool(BinaryEnum.falsy) False &gt;&gt;&gt; bool(BinaryEnum.truthy) True
You can try * [Py2Exe](http://wiki.python.org/moin/Py2Exe) * [pyinstaller](http://www.pyinstaller.org/) * [cx-freeze](http://cx-freeze.sourceforge.net/) They all can work and have different tradeoffs. Re: playing your game online, I don't think you can run it directly in-browser. There's something called [GameJS](http://gamejs.org/) that appears to be a Javascript version of the PyGame API?
I think he means having enum members 1, 2, 4, 8, etc., so that they can be masked and added meaningfully. I.e., 5 would symbolize both 4 and 1. Correct me if I'm wrong.
Well, its not really about minimizing the number of lines. The point I was trying to make is that the language lets you implement a tricky algorithm in a few lines and looks really clean. I thought that was really cool.
Py2Exe for your Windows users, and [Py2App](http://pythonhosted.org/py2app/) for your Mac users.
Quite a bit of this borders on micro-optimization. In your average application the difference in construction time for ``set()`` and ``set([])`` is completely irrelevant.
Care to explain why?
Covered in the second sentence of the article.
Yes, that should work. [This](http://stackoverflow.com/questions/1339976/c-how-to-check-if-any-flags-of-a-flag-combination-are-set) is an example of binary flags in C#, and it has the same functionality as what you just described. Why did you choose to inherit from (int, enum.Enum) instead of enum.IntEnum?
Great! Thank you for pointing me in the right direction.
Still more work on the agenda. Uses Tornado and Cython with minimal dependencies. Check it out and let us know what you think.
Try going to /usr/lib/python3/dist-packages and see if you see a folder for numpy.
For me it's usually the opposite: foo = [ 'a', 'b', 'c' 'd', ] String concatenation is nice, but not when unexpected.
I think you need a better example of something it can do.. What's the simplest real world use case for this over something like nginx or haproxy?
Or, you can use [Anaconda](http://continuum.io/downloads) and create a Python 3 environment using: $ conda create -n py3k python=3 numpy
One can understand why you'd want to type that, especially given Python's flow. I'd suggest if you're thinking like that, consider: if foo in [3,4]: 
UnicodeDecodeError :(
I think Python's readability deceives newbies, a lot of code(that newbies write) can be basically translated directly to English sentences. You would read the line in English/Pseudocode as "if foo is three or four". I suggest your fix all the time, especially if the comparison list is more than 2 items long. 
I'm with you on this...perhaps though Python was just not our first language? I've been toying around for a good 6 months (mostly just using it crudely as a sysadmin/scripting language) and I must say I've found Python's error reporting to be remarkably helpful. Nice clean backtrace, sensible errors... Nothing can possibly be worse than "Unexpected T_ENCAPSED_WHITESPACE". Jackass, just tell me I missed a semicolon or at least suggest it as a cause. 
It has, technically. AFAIK it is (or can be) implemented in pure Python using metaclasses.
Fair enough. Explicit is, after all, better than implicit. ^import ^this
The current filter example is an OpenStack authentication filter. Its simplistic but not to specific to what most people will use it for. We plan to add additional filters for API metering (rate limiting), transformations, etc. I'll also be doing a blog article in the future on building simple filters. HAProxy is a load balancer. Pyrox will most likely sit behind a load balancer in most scenarios as it will be more used to authenticate, rate limit, etc.
I just checked that location and I do indeed have that folder? However, running python3 in the terminal and trying to import numpy still gives the "no module named numpy" error. I tried going into the numpy directory, and then running the following in the terminal, but it gives the 'This is the wrong setup.py file to run.' sudo python3 setup.py install Any thoughts? Thanks!
For those of us who use Python in Visual Effects: **RuntimeError**: There was trouble in Maya. Somewhere. With something troublesome. Maybe in your code, maybe in line 3537 of this .pyc file you can't see. Also this one from any facility that runs with a linux backend and Windows frontend: **IOError**: The file exists and is readable. Just try again and it will magically work. Write all file IO functions with a three strikes rule from now on. Actually four strikes. Whisky before noon.
That's something that bugs me about Python and in my very early days of exploring Python the only thing so far I think the BDFL got wrong. "=" is "equals", the equality operator. Something else, such as ":=", should be the assignment/reference statement. That's the only thing so far Pascal has over Python, and I say this as a Pascal user for decades. :-) 
&gt; This is why our dict-based examples don't work. Because the dict is created &gt;during function definition, we never get a fresh one. The usual solution is to make &gt;the default value None, then test for if hist == None: to set it to a new, empty dict. So how do we convince the BDFL this may be one of the few mistakes he's ever made? I saw some article I didn't follow at first glance that purports to prove that this was really a stroke of genius, but if it trips up people in real life I don't see how that could possibly be. Has Guido ever defended this decision on his blog or elsewhere? Hasn't it already been established that "patterns" like the one you just outlined are language smell and should be addressed with a feature? 
I engaged in a huge battle with non-python programmers about this and they refused to ever concede that it was simple, instead insisting that at least four different types of string were a much better solution and there are lots of cases where you need to convert between ASCII and Unicode throughout your program and a string should carry around its encoding with it at all times. :-( 
I believe a pep8/linter will catch that before you run.
See part two: http://www.reddit.com/r/Python/comments/1jsqgq/29_common_beginner_python_errors_in_one_flowchart/cbi5lm9
Have you tried installing numpy using pip?
Sudo setup.py build install didnt work?
True. 
Yeah I did, but to no avail. Having said that, it was using pip-3.2 as installed by easy_install3. I'm not sure if this would have made a difference?
Hmmm I did sudo python3 setup.py install, which didn't work. I don't think I've tried sudo setup.py build install though. Thanks!
" It's long since Too Late To Change on this one. There's plenty of code built on and around this feature, and there are legitimate reasons for it from the implementation side (whether you can find legitimate reasons from the usage side, is an exercise left to the reader and his creativity). Personally, I'm ambivalent about it. It actually does make sense, just not the way people expect. And it's not like we can change it meow. anyways. But we do need to educate people about this, or they'll just keep getting surprised, and surprise makes for good birthday parties but poor coding experience. " FTFY
I have a game on the Android Play Store written in Kivy. I've not produced an iOS version because I can't justify the fee for registering with the App Store just to put up a free game, but I understand it'll Just Work.
The main delay was nobody being able to agree on the exact feature set, I believe.
If you don't want to wait until Python 3.4 is released; from collections import namedtuple def enum(*args): return namedtuple('Enum',args)(*args) Colors = enum('Red','Green','Blue') 'Red' in Colors True 'Peanuts' in Colors False PEP 435 is for folks who don't know the Python stdlib and are too lazy to google 'python enum' and want to sook about how they can't write C++ in Python. 
Is it that hard to fathom a guess? Perhaps they are working with... ... Python 2.6!
Your else statement is outside of where you've called the if statement. So to python it just appears that you've indented it for no reason. The function CoreCode ends at the time.sleep(3) line because changeCode == "yes" isn't indented. Also it's going to always prompt the user for a new code, regardless of whether they specified they wanted to, and even regardless of whether they have the right code to begin with, so it's not very secure at all. If you could tell me more about what you're trying to do I might be able to help more.
Also, the changing the code part is not going to do anything seeing as the value of the "1234" is hard coded, and not a variable. You'd want something more to the tune of "if userinput == thecode". 
It sounds like it's encroaching on nginx's niche though. I use nginx to serve static files, and to forward requests to 3 separate instances of gunicorn. Would Pyrox be a viable alternative, overkill, a potential upgrade path if I needed site-wide authentication middleware or something. The reason I like nginx is it's so dirt simple to configure.
After years of using Python daily, I've never known adjacent strings would join. I guess I've just never made this particular mistake.
Not gonna lie: Erlang's still shorter. quicksort([]) -&gt; []; quicksort([H | T]) -&gt; quicksort([X || X &lt;- T , X &lt; H]) ++ [H] ++ quicksort([X || X &lt;- T, X &gt;= H]).
Legend, thanks for that! I'll give that a go and get back to you.
I looked for two links: Docs, and Getting Started. I found neither. For this reason, I will likely not use this until they exist. GitHub wikis are *horrible* ways to do documentation. Please use Sphinx/Readthedocs. Arghlarlgh all of your projects have a wiki instead of proper docs.
I liked this article (though someone does point out set + dict comprehensions further down, I haven't learned these yet). Title is inaccurate, but these are nice tips.
also the author have no idea of the difference between a list and a tuple as expression in code a = [1,2,3] will always construct a new list while b = (1,2,3) will store the tuple on the code object
Naive question: why?
Please post this kind or content to /r/learnpython in the future (as suggested by the huge red block-letters on the post submission page...)
Tornado more or less requires you to rewrite a lot of your code if you want async, it's also very ugly and arguably unpythonic. Might as well just use NodeJS.
Out of curiosity, how does it compare to twisted? Your comment seems to describe twisted pretty accurately...
Because linked lists are ubiquitous and insanely useful?
Since when did /r/Python become /r/NotRails?
since tornado builds on twisted (or at least can use twisted, I don't know if it is the only option) this isn't that surprising 
It's more domain-specific than twisted, but other than that I don't know what to say. I prefer gevent, and it seems to be popular enough to where even PyPy is supporting it.
Read the article. It raises valid points that are by no means limited to Rails or even Ruby.
TL;DR: You should never use dynamic languages for web apps, because they're slow and bug-prone and adding tests is a pain and makes them hard to maintain, but if you really really have to, Node.js and Django are faster than Rails. Uh, yeah. WTF?
Better than VB which uses '=' for both
&gt;For this reason, I will likely not use this until they exist. I could count all the people who care on zero hands.
Everybody seems to prefer gevent... I should probably give it a whirl.
FWIW, I just installed numpy under Python 3.3.2 in my home directory (no need for sudo) using [pythonbrew](https://github.com/utahta/pythonbrew) and it seemed to work fine. $ lsb_release -ds Ubuntu 12.04.2 LTS $ curl -o ~/.pythonbrew/dists/Python-3.3.2.tar.xz http://python.org/ftp/python/3.3.2/Python-3.3.2.tar.xz $ unxz .pythonbrew/dists/Python-3.3.2.tar.xz $ pythonbrew install Python-3.3.2.tar $ pythonbrew switch 3.3.2 $ pip install numpy ... Successfully installed numpy Cleaning up... $ python Python 3.3.2 (default, Aug 7 2013, 08:02:13) [GCC 4.6.3] on linux Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; import numpy &gt;&gt;&gt; numpy.arange(15).reshape(3, 5) array([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14]]) I guess people have moved to [pyenv](https://github.com/yyuu/pyenv) these days...I'm guessing that should work similarly. 
Awesome, thanks for posting all that. I'll give it a go in the morning and post back :)
So unpythonic that is more or less the basis for the [new async module proposed for python 3.4](http://www.python.org/dev/peps/pep-3156/)? 
Whenever someone boldly writes "never", you can safely save a couple minutes of life and ignore the whole thing.
honestly, they couldn't think of a better name?
Python is not the only language in widespread use. If you want to do serious development, you absolutely need to have a notion of how linked lists work.
Thanks for sharing. One more reason to upgrade to 3. :)
I think you're missing the point.
Didn't everyone switch to pyflakes?
Ah come on man, Pandas are awesome plus it's an awesome pun on the word pandemonium! 
A getting started article is in the works, but we want to wait until a few more features have been added and we think that the underlying code is more or less stable to where it needs to be. Good pull requests are always accepted.
I think it would make more sense to compare Pyrox to Paste than Nginx. Nginx will always out perform Pyrox and have more features. We needed a Python solution that will work on Python 2.7.x and 3.x+ so we went this route. Paste, last I recall doesn't fully support Python 3.
Reasons why you might want to use `namedtuple` over writing your own class with `__slots__`: 1. namedtuple is a subclass of tuple, and can therefore be used transparently wherever a tuple would ordinarily be used, which is a lot of places -- tons of things take sequences. For example a SQL driver can return result rows of namedtuples. If the receiving code only expected a regular tuple, everything still works as the code can access fields by numerical indexing, but the user has the option of accessing fields by attribute name as well. 2. It's less typing: Foo = namedtuple('Foo', 'a b c') vs: class Bar: __slots__ = ('a', 'b', 'c') def __init__(self, a, b, c): self.a, self.b, self.c = a, b, c 3. namedtuple gives you a few extra convenience methods: `_make` for constructing from any iterable without having to use `*splat`, `_asdict` to convert to a mapping, `_replace` to get a copy with selected fields replaced, `_fields` to get access to the field names. Despite starting with underscore, these are public methods. They are named that way so that they don't clash with any potential field names. 4. Since they're really tuples at heart, they enjoy all the existing fast-path optimizations inside the interpreter that exist for dealing with tuples. For example, small tuples of less than 20 items have a special fixed-size dedicated memory allocator that is very fast. 5. As to the memory size thing that you pointed out, it's true that `Bar` requires one fewer word: &gt;&gt;&gt; Foo(1, 2, 3).__sizeof__() 24 &gt;&gt;&gt; Bar(1, 2, 3).__sizeof__() 20 This is because `Foo` is a sequence so it has a size (because a tuple is a sequence and tuples have sizes -- in fact `Foo` requires the exact same amount of memory as `tuple`): &gt;&gt;&gt; len(Foo(1, 2, 3)) 3 `Bar` is not a sequence and has no size: &gt;&gt;&gt; len(Bar(1, 2, 3)) Traceback (most recent call last): File "&lt;ipython-input-69-166460679a7d&gt;", line 1, in &lt;module&gt; len(Bar(1, 2, 3)) TypeError: object of type 'Bar' has no len() I suppose if you have no need for the sequence properties and only care about accessing attributes by name, that might be a win. But as I said earlier, tuples are highly optimized in CPython because they are used extensively internally (e.g. for positional parameters to every function call) so I wouldn't bet on there being many data structures that outperform the tuple.
Super! Thanks!
Would love to see this functionality coupled with nose.
&gt; 2. The team's project must be written in one (or more) of the following languages: Javascript, Python, Ruby or PHP. Bah... may as well call it the "Scriptacodium".
I wanted to make a little program where you type in your password and it opens up a file you can't access from anywhere else
Tornado was a great way to get the proxy plumbing working in a quick manner. Granted, Tornado has its warts, however we're only using the I/O portions of the library. I agree that utilizing futures in Tornado is obtuse and too difficult but I have no intention of ever making those part of the sytem. In reality, Tornado will be replaced eventually (Python 3.4 looks promising in this regard) because its performance profile is not quite were I want it to be for the future.
was hoping for some news on python 3.x support :(
You get one shot at making an initial announcement. Unless this one is compelling, dont expext your "now with docs" or "release 0.n+1" post to get much traction. You did better than most by not just linking to a 0.1 alpha on github.
The next release milestone will reveal more of the proxy's capabilities however I have no intention in directly competing with nginx or haproxy. While their performance is staggering, it is not something unobtainable (see uWSGI) with C/Python integrations. In the time I've spent with Python, I've really come to appriciate the language and it's capabilities. I want to capture this usability for middleware in a more performance oriented and flexable way than Paste or other WSGI middleware solutions.
isn't pylint more picky?
And used to be much slower. These days I have pyflakes hooked up to both vim and Sublime Text to scan my code as I type.
I think the unhappiness comes from Tornado's use of decorators for future/async off-loading and less about the async event loop model. 
I haven't tested it in Python 2.6, yet. But if you see no errors I'd safely assume it works. Have you tried your spam folder/label/whatever else?
I look towards others' opinions for guidance in whether or not an idea is a good one as well as a source for more ideas. I agree that you only get one "initial" announcement but consider this just as much about generating interest as it is community research :)
please advise which install approach you deem not 'madness'
See: OrderedDict implementation. It has constant time removal and reordering because the ordering algorithm is implemented using a linked list.
Shameless plug: A similar project with pluggable mailers (and tested in Python 2.6, 2.7 and pypy) https://github.com/lucuma/mailshake
Anything where fast inserts are needed without the memory cost of dynamically resized arrays is perfect for a linked list. Yes, that is a broad class of problems, hence the ubiquitousness of linked lists.
I found this reply about python 3.3 in another post: http://www.reddit.com/r/Python/comments/tfiab/virtualenv_is_an_antipattern_for_beginners/c4mngc4 Also there's this: http://docs.python.org/dev/install/pysetup.html
Very nice. Would also be cool to have the bar be red in proportion to the number of failed tests.
Did you get the sub head from requests per chance?
I'll get downvoted for his as usual, but I really can't understand why new libraries are being written targeted at 2.x rather than 3.x. There really should be no reason why this could only work with 2.x. 
most of us still work with 2.7.x
I like the looks of it! *Copying from my comment on Hacker News:* I agree with [ianstormtaylor's comment](https://news.ycombinator.com/item?id=6175292) that avoiding the "addr" abbrviation would be a good thing. To distinguish "text_body" and "html_body", what about simply "text" and "html"? That's what we use internally. Also, how does one send To: multiple addresses with this library? I think it'd be good if to_address could be a list (or their was a separate to_addresses, which could be a list). I like it how cc_addrs / bcc_addrs can be a list already, of either addresses or (email, name) tuples. Why not do the same thing from from_address and to_addresses, and get rid of from_name and to_name?
Looks nice! (Note that there's an unescape single quote inside a single-quoted string in your second example there.)
Module naming for humans.
Another shameless plug. Web2py includes something like this but more powerful: http://web2py.com/books/default/chapter/29/08/emails-and-sms
&gt; If you mean more generally, then what happens when someone has a different tabwidth then you? Then all of your tab and space mixing to get the right alignment will be totally fucked in their editor. That isn't very courteous! No, you misunderstand; the very point of this is to *not* fuck with alignment while still providing flexibility. Here is an example: dictionary = { ---&gt;'1': 'one', ---&gt;'2': ('two', 'dos'), ---&gt;'5': {'cinco': 'five', ---&gt; '6-1': '5'}, } Now, if someone uses 8-space tabs, it'll look like this: dictionary = { -------&gt;'1': 'one', -------&gt;'2': ('two', 'dos'), -------&gt;'5': {'cinco': 'five', -------&gt; '6-1': '5'}, } You see how it retains formatting but still allows the user to choose their preferred indentation level? It's an extension of the idea aligning things on the right side: foo = True bar = False foobarbaz = False &gt; I don't think anyone advocates mixing tabs and spaces in Python. Not even J_F_Sebastian. I've never met anyone who agrees with me on this format, for any language. :( This is because a) everyone else is lazy and b) I'm a bit crazy. ;) I only use this on projects I expect to be the primary author; on a team, I'd rather accept an indentation level I think looks stupid than try to force this on everyone else. As a side note, when people say "don't mix tabs and spaces", they really mean "don't mix tabs and spaces for indentation", which is something I whole-heartedly agree with. We're talking about something different, though.
People will often create libraries to solve their own problems. If you only need to support a certain version you can allow the community to submit patches to support the other version if you want. 
I know I'll be downvoted, but, serious question: What's with the trend of reinventing wheels in Python and calling it something "for humans"?
Should be using next(x) Instead of x.next()
Well, so, I'm writing a new project, and I decided to target 26, 27, and 33. Everything was going really well, and I was getting stuff done. And then I brought in msgpack, which in python 3.3 will take a unicode string and unpack it as a byte string, and suddenly several dozen tests were failing. I'm pre-alpha now and just trying to get the functionality down. I don't want to start dicking around with unicode v byte strings. So I took py33 out. I do plan to put it back in, but right now it's a pain that brings no real benefit.
* https://github.com/dbader/schedule * https://github.com/jkbr/httpie * https://github.com/kennethreitz/envoy * http://jamesmurty.com/2013/06/07/xml4h-0-2-0/ * https://altered-states.readthedocs.org/en/latest/ In short, yes. In the past, people used more humble language like "simple". I hate this new trend; I feel like it's boastful, and it implies that other packages were made in a thoughtless manner. Even my [humanize](https://pypi.python.org/pypi/humanize) package doesn't use "for humans." Please, python community, stop. We're all humans here.
Great idea. I hope lib posters take your advice. 
I would think it would be easier to run a web server and control the laptop using a web page rather than typing in commands into a Python interpreter on a phone. Then you could use any device you wanted (but probably would want authentication). Heck, you could pick up a cheap wi-fi tablet and make a dedicated control panel for your place. Also, this would port easily to a Mac if you used `osascript` commands to send Applescript to various applications such as iTunes. osascript -e 'tell app "iTunes" to return (name, artist, album) of current track'
Functions store tuples iff all of the members in the tuple are immutable literals. Otherwise, it just constructs a tuple each time.
&gt; No, you misunderstand; the very point of this is to not fuck with alignment while still providing flexibility. I didn't misunderstand at all. Every single source file I've ever seen that mixes tabs with spaces has fucked it up. If you have some miraculous brain that allows you to mix them for whatever reason you think justifies such behavior, then you're the only one I know that can do that. I would **absolutely refuse** to dedicate any considerable time to sharing a code base with people who mix tabs and spaces. Maybe **you** can get it right, but I know I sure as hell can't. And quite frankly, I'd be fucking stupid to expend the cognitive energy required to do it. &gt; As a side note, when people say "don't mix tabs and spaces", they really mean "don't mix tabs and spaces for indentation", which is something I whole-heartedly agree with. We're talking about something different, though. No we're not talking about anything different at all. Presumably, you've just been able to mix tabs with spaces without ill effects. **I never said it was impossible to mix tabs and spaces and still have it look right.** It's just fucking atrocious for any human being who doesn't want to fuss with such things. &gt; everyone else is lazy Certainly not in a bad sense. I don't want to spend my time over pointless bullshit such as getting my mixture of tabs and spaces to be just right. &gt; I'd rather accept an indentation level I think looks stupid than try to force this on everyone else. Well, that's a relief. But if I came across your code in the wild, you can bet your ass that you won't be getting any patches from me. So yes, congratulations. You have one the stupidest ways of formatting your code and you've proven that corner cases exist. Is that really all you wanted to point out? I am a TA, so you'll have to excuse my passionate language. Poorly formatted code is the bane of my existence. Do you want to guess what kinds of formatting issues are the most troublesome? I'll give you a hint: it involves the mixing of two things that should never be mixed.
Envelopes came to life as part of a larger Flask app written in Python 2.7. I just took out the code, slapped some additions, wrapped it in a package and released. I have tests and tweaks for other Pythons (2.6 and 3.x) in the pipeline. If you feel like it I encourage you to fork and hack the lib. If you don't feel like it then stay tuned :).
Can it be used independently of web2py?
That is a Python 3 thing
yes, and he does exactly that, then claiming tuple is faster when its really just a load from the code object
lol try: self.collected = json.loads( open(self.settings_path).read() ) except IOError: print "FUCK" self.collected = {}
lol was just about to post that one: File "/Users/simon/.virtualenvs/3.3/virtualenv/lib/python3.3/site-packages/pytest_sugar.py", line 51 print "FUCK" ^ SyntaxError: invalid syntax
I'm sure the author knows of this but if you wanted to get super fancy you could use [Kivy](http://kivy.org/) on the client which implements multi-platform python with the added bonus of nice/fast UI controls. Also, twisted can be baked in using what they call a recipe (i.e. plugin). As previous commenters mentioned, this could be done simpler but I actually like the extra complexity for educational purposes. Cheers
Yes. Almost every web2py component (mail, dal, template, etc.) can be used independently. We simply do not package it separately. Example: $ python &gt;&gt;&gt; from gluon.tools import Mail &gt;&gt;&gt; mail = Mail() &gt;&gt;&gt; mail.sender='me@example.com' &gt;&gt;&gt; mail.server='localhost' &gt;&gt;&gt; mail.send(to=['you@example.com'],subject='hi',message='hello') Here gluon is the folder where web2py keeps its modules.
It would be lovely if you could include this in [gluino](https://github.com/mdipierro/gluino).
Good point. we will do it.
Nice. I learned some new things. 
This post was a lot less exciting than the title made it sound. http://www.edgerton.k12.wi.us/webpages/nsveum/imageGallery/Stanley%20in%20Envelope.png
It was included in the Python 2 since v2.6.
Best hello world ever!
They're two different tools for two different goals. I use both in most project (I actually run flake8, not pyflakes) but pylint only runs from Jenkins while flake8 runs from vim. 
And yet another shameless plug: [Mailinaut](https://github.com/slapresta/mailinaut) is a library that integrates Jinja2 templating into emails. It's a very lightweight attempt at a "Flask for emails". It works with humans as well as most other mammals.
It's based on this presentation from Kenneith Reitz: http://python-for-humans.heroku.com
It'd probably make more sense to leave `to_addr` (I'm fine with the name, plus it allows an ambiguation interpretation of "address" or "addresses") and to allow it to accept a string for a single recipient, and a list for multiple recipients.
why don't you keep a bool called "explored" at each node, set it to True if it's explored. Then, you can do a check without using a set.
Not really. Pylint will scan imports and runs over the ast of the code, flakes doesn't and is much faster, but checks less.
You could do this - You would still need to record insertion order so you'd essentially be replacing a general hash table with one where the hash function is the identity, which should be slightly faster. However it would NOT be faster asymptotically, so it should only be faster by a constant factor - you'd be replacing a more intuitive solution with a slightly faster one and it's pretty much a matter of preference at that point (in python at least) 
Specify an encoding: unicode_string = "ฮฮฮฮ" packed = msgpack.packb(unicode_string, encoding="utf-8") unpacked = msgpack.unpackb(packed, encoding="utf-8") print(unpacked == unicode_string)
I know it's not unfixable, but it's one of like six hundred times this is going to bite me, and I'd rather not deal with All That Jazz just now.
Thanks a lot everyone for your comments! As I mentioned in the article Django is overkill for this but I wanted to use it for educational purposes. Do you think you can come up with Android code to connect directly to the Twisted server? It'd be a good addition to the project.
I know about Kivy but never coded with it yet, I'll definitely give it a try! You gave me the idea of using buttons on the phone labeled play/pause/stop/etc to do the same actions available for SMS too (SMS reading will be still working in the background, maybe I'll have to use threads?). Thanks for the idea!
Seems like the [OrderedSet](http://code.activestate.com/recipes/576694/) recipe would be more of an all-in-one solution. Alternatively, using the deque class in the collections module is perfectly suitable for O(1) prepends, without the need for the reordering at the end. Of course, both would require some refactoring of the original code to use the appropriate methods.
Yes, those who wanted something really simple in their editor switched over. Those that wanted more configurability, checking for style, better accuracy, good scores, and the ability to run from a CI tool learned how to integrate it into their editor and are still using it.
Sure, but '=' is thought of as assignment and '==' as comparison by most programmers thanks to the popularity of C. That could have been a frustrating thing to learn.
I use SublimeLinter in ST3. It does do pyflakes validation and pep8 style checks.
I know they were designed to do two different things but when writing code I use both for mostly the same thing (pyflakes being combined with pep8).