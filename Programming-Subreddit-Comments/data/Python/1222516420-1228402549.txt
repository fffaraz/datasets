More than about 4 MB. In practice - I've found it fine with HTML delivery, but not with files. But - again - I haven't looked at this in almost a year. 
Not in terms of casting to delegates.
I'd assume that it's fixed then. My cherrypy app serves 60+MB files on a regular basis, and I've never had a problem.
see also: http://www.techraving.com/2008/06/20/setting-up-environments-in-cherrypy/ 
Is there a way to get an attribute from "this" scope or stack frame. For example, I'd like to be able to get the value of x via something like: &gt;&gt;&gt; x = 3 &gt;&gt;&gt; getattr('x') or &gt;&gt;&gt; getattr(this, 'x') 
via: http://kmerenkov.wordpress.com/2008/09/27/new-struct_validator/ 
OK - thanks. I always wondered whether it could be that I was misusing the API for my downloads. The way I wrote it was: cherrypy.lib.static.serve_file(music_path, "application/x-download", "attachment", os.path.basename(music_path)) 
this sounds cool if I had the time to check it out
locals()
doh.
I want to teach myself python as a first language. I am looking for a recommendation of a good book to learn with. I only have one requirement for the book. It has to provide "homework" every so often. For example the book could ask you to write a program at the end of every chapter, using what you have learned so far. I have tried to teach myself python once before and the book I used did not have this. I think it would really help if I had a way to test my knowledge. Thanks!
Nope.
This is quite ignorant. 
Nah, that should work. It's the same in my app, except I'm serving files as "application/x-gzip". 
I hope this was submitted to point out the stupidity of the idea and not because it was agreed with.
It can be presumed this thing is for being laughed at.
Nice troll.
Seriously, though, why should str() fail on that? Can't it just return "\ue863", since the encoding is wrong?
Unfortunately, the submitter of the link appears to be the person who posted this screed to c.l.p., presumably seeking support for his outrage.
You could just as well say that these languages are influenced by Ruby.
It truly appears so. I stand thereby corrected.
You might look at [Game Programming, the L Line, The Express line to Learning](http://www.amazon.com/Game-Programming-Line-Express-Learning/dp/0470068221/ref=sr_1_6?ie=UTF8&amp;s=books&amp;qid=1222620572&amp;sr=1-6) You can get it used fairly cheap. You wouldn't know from the title, but it only uses Python. It has 'Practice Exams' at the end of each chapter, usually with 2 questions that ask you to augment programs in the book. 
I have some language experience, but nothing extensive. Python is my first serious effort and I've been enjoying: [Learning Python](http://www.amazon.com/Learning-Python-Help-Programmers-Mark/dp/B00007FYCH/ref=pd_sim_b_3) [Programming for Non-Programmers &amp; Building Skills in Python](http://homepage.mac.com/s_lott/books/index.html) [How to Think Like a Computer Scientist: Learning with Python](http://www.openbookproject.net/thinkcs/python/english/) [A Byte of Python](http://www.swaroopch.com/notes/Python) 
Grammar police says: "Looking for a good book with which to teach myself Python." (lol) 
see also: http://blog.appenginefan.com/2008/09/gql-queries-in-sql-part-2.html and: http://code.google.com/appengine/docs/datastore/gqlreference.html GQL is a SQL-like language for retrieving data entities from the App Engine scalable datastore. 
* [Learning Python](http://www.amazon.com/Learning-Python-Second-Mark-Lutz/dp/0596002815) * [Programming Python](http://www.amazon.com/Programming-Python-Mark-Lutz/dp/0596009259) * first read Learning Python, then Programming Python... best combination. Covers everything from basics, OOP, to threading, networking, GUI programming...etc.
I don't think that Learning Python is really good - the third edition is just too large and too verbose. Same thing goes for Programming Python, which was way too big and boring. It even has a chapter for Grail, which is dead since 9 years now. I usually recommend A Byte of Python and after that Dive into Python. How to think like a computer scientist is nice if you have never programmed before - if you did you might want to start with Dive into Python.
Because if you're working with Unicode characters that can't be represented in standard 8-bit encodings, it's been judged better to say that you should either use a genuine Unicode string or a UTF-8-encoded bytestring. Returning a string which contains an escaped representation of what the character _might_ look like in an encoding that supports it would probably mess people up even more.
effbot is an international treasure.
If you're an an experienced programmer, David Beazley's Python : The Essential Reference might do the trick. I liked it because it was succinct. Dive Into Python is decent too - Mark Pilgrim is not as verbose as most - but Beazley's text is Tesla-powered. Edit : If you're not experienced, I'd suggest the Python documentation - although in my opinion, they take too long to get to the point.
Couple of questions: Does that mean in the near future, we can run python applications at 10x the speed? Would the applications need to be modified in some way to take advantage of this? 
This isn't a core python project. This is an experiment to tie python to the v8 engine for poops and chuckles. Any limitations on this would presumably come from the pyjamas compiler (much like jython is limited to Python 2.2 syntax) Doing this makes their test program run 10 times faster than it did under raw python. The v8 engine undoubtedly helps here with VM features that the Python VM currently lacks. Note they said using cython (a fork of pyrex) makes it 100 times faster so if you're looking for a way to speed up your Python programs, perhaps look at cython. Don't forget to profile even if you're writing your own fibonacci generator (the test case they use) because faster for that case doesn't necessarily mean faster for every case. There's a lot of cool javascript stuff for "Web2.0" apps (jquery et al) so being able to call them natively from your Python app is pretty handy.
There is a lot of great online stuff at www.python.org. The online tutorial isn't bad.
can't aree with u any more. even the comment is informative. btw, Practical threaded programming with Python ( http://www.ibm.com/developerworks/aix/library/au-threadingpython/) is a good introduction for event. and it has been reddited ( http://www.reddit.com/r/Python/comments/6m7qg/ ).
Fixed in Python 3. &gt;&gt;&gt; bytes("\ue863", encoding="utf-8") b'\xee\xa1\xa3' &gt;&gt;&gt; bytes("\ue863", encoding="ASCII", errors="ignore") b'' &gt;&gt;&gt; bytes("\ue863", encoding="ASCII", errors="backslashreplace") b'\\ue863' (`str` is renamed as `bytes` in Python 3, and the `encoding` and `errors` kwargs are added.)
via: http://yannramin.com/2008/09/29/yyafl-now-has-layout-support-with-decorators/ Yann’s Blog » yyafl now has layout support, with decorators "Just finished adding in a flexible layout system to yyafl, my reimplementation of Django newforms for other Python web frameworks or WSGI adapters. Now its simple to add default layouts or render a different layout on demand."
Ah, py3k... Very nice.
The pyjs compiler only implements an approximation of the Python semantics in Javascript - and has many limitations. As an example of the former restriction it compiles 3 / 2 in Python (int division) into 3 / 2 in Javascript (float division). As an example of the second restriction - it doesn't currently handle inheritance with constructors that take arguments. A fun experiment though and Pyjamas actually looks like a very interesting project for client side Javascript.
seems to not say a lot while having a lot of text.
This project is someone's master's thesis.
Good article. In addition to the "traditional theads+locks" and queues approaches, there are at least three others worth mentioning: * "Shared Nothing" architecture (i.e. use multiple processes and pipes) * Software transactional memory * Stackless channels and tasklets 
via: http://jjinux.blogspot.com/2008/09/books-expert-python-programming.html
NetworkX can use either graphviz or matplotlib w/ scipy for drawing networks. I wonder if the author tried using matplotlib instead of graphviz. I've tinkered around with NetworkX before, but never with as large a graph (190k+ nodes, yikes). I wonder what the graph problem was about. Interesting stuff.
Multiprocessing! So now we're down to forking instead of threading, sweet.
Forking is the new threading.
see also: http://google-opensource.blogspot.com/2008/10/ipaddrpy-flexible-and-easy-python-ip.html
see also: http://www.vetta.org/2008/05/scipy-the-embarrassing-way-to-code/
via: http://groups.google.com/group/sympy/browse_thread/thread/2a4d59247d82e1aa# preliminary Mathematica like docs - sympy | Google Groups
via: http://article.gmane.org/gmane.comp.python.scientific.user/17791 Subject: [ Python(x,y) ] New release : 2.1.1 As you may already know, Python(x,y) is a free scientific-oriented Python Distribution based on Qt and Eclipse providing a self-consistent scientific development environment. 
Forking is what threading is supposed to be.
Hmm, some non idiomatic python here. get = request.GET.copy() =&gt; get = request.GET get.has_key('blah') =&gt; 'blah' in get has_key is basically deprecated regardless.
This is an incredible (if hefty) Python distribution. It's probably one of the first ones I would point a new user to, since it's got a great IDE/shell bundled with it, and a newbie doesn't have to wonder how to configure all these packages to get started with some development.
That's Forking great!
Don't thread on me!
Hold on. Let me process that remark.
I can feel it in my [fibers](http://en.wikipedia.org/wiki/Fiber_(computer_science\))
how did this get to the front page with a broken link and no comments?
Gst is the cancer killing reddit.
&gt;I can sort a list of elements of any type, right? Not in Python 3: &gt;&gt;&gt; sorted(["a", 1]) Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; TypeError: unorderable types: int() &lt; str() Cf. Python 2.6: &gt;&gt;&gt; sorted(["a", 1]) DeprecationWarning: comparing unequal types not supported in 3.x [1, 'a'] 
via: http://openopt.blogspot.com/2008/10/new-python-optimization-soft-pyomo.html new Python optimization soft: Pyomo
via: http://www.mailund.dk/index.php/2008/09/30/updating-my-newick-parser/ see also: http://evolution.genetics.washington.edu/phylip/newicktree.html The Newick tree format
see also: http://pypi.python.org/pypi/ropevim/0.2 A vim plugin for using rope python refactoring library and: http://pypi.python.org/pypi/ropemacs/0.6 An emacs mode for using rope python refactoring library
Yeah, a lot of this is out of date actually.
Anyone have a quick rundown on how this is better/different than matplotlib?
Can't I get 100% of the links on Python subreddit at http://www.reddit.com/r/Python/ ?
I came here to post that. Instead, I will upmod you and call it a day.
True. But the content there is not a subset of Python subreddit. It is another site to get more Python and somewhat related info. That is all.
I also came here to post what BridgeBum said. I follow the 80/20 rule so I'm fine with missing out on 10%.
Oh awesome, I can finally use XML in Python! Now I'm just waiting for the day when I can put a wax music cylinder in my Blu-Ray player.
lxml is nice because it is one of the fastest XML libraries for Python. http://blog.ianbicking.org/2008/03/30/python-html-parser-performance/ By the way, it also supports poorly-formed XML via its "soupparser" module.
I've always preferred [Amara](http://uche.ogbuji.net/tech/4suite/amara/) for XML processing in Python because its bindery forms first class objects out of the XML DOM. This tends to result in significantly more compact and readable code. That being said I'm all for pythonic bindings to popular libraries like the aforementioned GNOME XML/XSLT libraries and lxml has always been a champ. 
Statements are calls to object methods.. Staying along the lines of Wavicle's example.. print 4 + 10 is equivalent to.. sys.stdout.write( int(4).__add__(10).__str__() )
&gt; Not only do LCs make it obvious to the reader that "all this loop does is build a list". Sort of. Amongst the many things list comprehensions can do, one of them is building a list, but there are many other things you can do too: l = ["This","is","a","list"] c = ["So", "is", "this"] r = [l.pop() for c in "foo!"] print l,c
Of course the interesting ones on reddit are the 10% that aren't from Planet Python.
Shouldn't it be clear that semantics, not syntax, should be the point of future additions? Once they're understood and best practices have emerged, one can convert them to syntactic sugar.
They dropped the price on Amazon.
Unfortunately you'll still can't use the resulting frozen object as a key in a dict because there won't be any __hash__ function: &gt;dict[freeze(mutable_object)]=foo 
probably useful in unit testing or something.
Things I don't like about it from a quick look: 1. The design is broken. The date is 10/5/08, if you go there now, you will see that some of the content made the design break (A scroll bar pops up when there is nothing to scroll for, outside of previously mentioned content). 2. The design isn't particularly eye pleasing. 3. Some of these posts are completely irrelevant to Python. Some random picture of a guy? A recipe for pumpkin pie pizza? Opinions/Comments about 700 Billion dollar bailout? The signal/noise ratio is very high, and the most interesting topics here I have already seen on reddt.com/r/python 4. In Reddit, all content is summed up by one link, which you have to click into to read. A lot of this content is just displayed without a summary, regardless of whether you are interested in it or not. You may have a preference, but I personally prefer having content presented to me in small concise chunk and deciding whether it is interesting to me or not from the headline.
hash(frozen_object) seems to return the object id; hash() on &lt;freeze.Frozen object at 0x90bf90&gt; returns 0x90bf90. Which is pretty crap distribution wise, but it seems to work. Anyway, there's nothing stopping you adding your own \_\_hash\_\_ method?
Um, why not just use the raw Excel COM API? That's what I do. The API's not bad, and it's as fast and lean as you're going to get if you're using COM Excel. I wrote my own utilities for common functions like finding the last row on a sheet or converting between int and letter column references. Also, if you have 500K rows, you should really reconsider whether a spreadsheet is appropriate. Sounds more like you need Access or CSV...
&gt; Um, why not just use the raw Excel COM API? Can't use that on a server. (No, Windows doesn't belong on a server.) 
I don't know about you, but I just write data to CSV files and open them with Excel. The ASV.py by Laurie Tratt saved my bacon many times.
What's wrong with pyExcelerator?
Sometimes you do need to use the excel format to have more control over formatting, formula etc
Even if you are running Windows on your server, you won't want to install Microsoft Office on the server, since anything that accidentally triggers an alert box will cause the server to be stopped in its tracks.
It might be nice if help took a second parameter stating whether to hide "private" items (with leading underscore(s)). That would suppress a lot of the bog-standard double-underscored methods.
That code he mentions looks like it's written by a Java programmer: heavily over-engineered for no good reason. Clicking through to the article the code was originally written for ([Incremental Development in Python](http://homepage.mac.com/s_lott/iblog/architecture/C551260341/E20081005191603/index.html)), we see the author is a patterns-zealot. I absolutely fail to see what kind of generic problem his 'pattern' code solves. Object-oriented programming in and of itself is not a pattern. I fear that as Python attracts more mainstream programmers, we will see a steady decrease of Pythonic code.
I needed to output Excel, and also needed to do the same data analysis that Excel does so well. Why not just use Excel for both? You could even use Excel for its analysis functionality to transform your data without producing spreadsheets if you want...
still too much :( but thanks for the heads up I'd buy it in a heartbeat at $30 or $40
There's only one problem -- banking just isn't simple.
Can't we just replace bankers by Python script altogether ? I'd feel that my money is safer.
For a moment I read it as wxWanker 0.3
A lot of hedge funds and banks actually use Python in their automated trading systems, with C or even Java for time-critical sections of code.
Arg. If you are going to go to the trouble of ripping up bad java code and translating it to python, you might as well take full advantage of your position and sell stuff like the interpreter and generators. addendum: It strikes me that these kinds of articles make the problem worse. If we weren't trying to illustrate something for a blog post, we would have just written it all in a single nested for-loop and called it a day. I worry that people might get the idea that 2-liners like these make their code easier to understand. def process_files(filenames): """Process a list of files.""" for filename in filenames: process_file(filename) 
What's the point in having a https-only repository/download site ?
The title was promising, but the actual post happened to be just a comparison of two lengthy source code listings - not very interesting.
The person who wrote this post just doesn't understand how to use Python decorators and would use some RTFM.
It should at least be a 2nd level class in an abstraction hierarchy and have a ton more useful comments: class Processor: """ General purpose processor that can process lists of items. """ def process_items(self, items): """ Process a list of items. """ for item in items: self.process(item) def process(self, item): """ Override this to processes an item. """ raise Exception("Abstract method") class FilenameProcessor(Processor): """ Extension of FileProcessor for processing filenames. """ def process(self, item): """ Process an item that is a filename. """ filename = item process_file(filename) 
Not sure why this is #1 with 6 upvotes in 8 hours...
gosh, that's so easy to understand!
hmmmm... what is his work?
Except it would sort of help if the post at least gave a link to the Traits it mentioned. Googled them up, but still...
The random sequence transformations are relatively interesting, but since Python 2.4 the set type has handled duplicate removal easily: a = [2, 3, 4, 5, 6, 6, 8, 9, 10, 10] list(set(a)) [2, 3, 4, 5, 6, 8, 9, 10]
&gt; Anyhow, why would you spend so much time trying to get an API working if it's undocumented and not doing what you want, when you could just scrape it off the page with BeautifulSoup and a few lines of code. Youtube's full of shitty javascript (especially in the new comments view where you don't actually get all the comments when you ask for all of them, but pages of ~100 comments, losing the already shitty youtube theading and having to wade through pages of crap to find the one comment you wanted to see)
With a set, order is not guaranteed. 
thid is just Palin tring to disprove evolution!
Yes, the comments on YouTube are stupid-simple. Why would you want to scrape them?
To feed them inside a voice synthesizer and read them aloud. Like in "[listen to yourself](http://xkcd.com/481/)"
It's the new "Gitmo special". 
All that self-aggrandizement about the Google API leads to a script that is just one call to one routine in a loop! Would have been far easier to scrape using regular old python+urllib. And he would not have to hard-code the URLs of the videos. 
Good question, I'd like to know myself.
This is useful; it'll help me fix my own problems.
No worries: sorted(set(a))
Agreed, a set is the perfect way to reduce a finite iterable to a collection of unique values. My article has a misleading name :-( I'm really talking about merging repeated runs of entries in a (possibly infinite) sequence. So [1,2,3,1,2,3,1,2,3] would be unchanged by `uniq`, but [1,2,2,3,3,3] would reduce to [1,2,3].
It's pretty damn good, I will most definitely have a use for this in future.
You know, if you're going to write yet another Python editor, you should at least use an preexisting libraries like Rope, so your user base doesn't have to wait while you figure out how to do basic features like autocomplete. The power of open source is building on other quality code, not starting over from scratch on every project.
I'm an editor/IDE junkie. I can't help it. Anytime I read about a new or updated editor, I download it and try it out for a little bit. Unfortunately, Ulipad didn't impress me. It sounds like it has the potential to be a neat editor, but it's very basic right now. I'll stick with VIM and Komodo IDE for now.
Editors are neat when the are simple and not bloated with features we don't need, or features you will use once every 200 days. I like simple things, and this seems to be a nice editor.
It works best if you subscribe to the combined RSS feed. That eliminates problems 1, 2 and 4. As for problem 3 - well it is an aggregator of blogs by Python developers. If you are part of the Python community then you will probably appreciate a significant proportion of those posts - and if not you can just skip them in your feed reader.
Ulipad is not a very new editor now. and it do has some charming features (at least me) such as lightweight and code auto-completion, through My favirote python editor/ide is WingIDE. Wing can't run smoothly on some old PC. 
via: http://niugrad.blogspot.com/2008/10/mysql-python-api.html
sorted(set(a)) may be inefficient. It first creates the set, and then sorts it. Worse, if the original list is already sorted (but with duplicates), then set(a) may yield an iteration order that is not, forcing sorted to re-sort it. I didn't take a close look at his algorithm, so I don't know how it compares. I assumed it doesn't have that issue when the original streams are sorted. Finally, as he has pointed out [here](http://www.reddit.com/r/Python/comments/75s4z/removing_duplicates_using_itertoolsgroupby/c05rcyy), the real benefit is that his method works for infinite lists. You can't create a set from an infinite iterator. (At least not in 2.5).
I prefer Editra http://editra.org/
No way. They are saying that since Python 3.0 was called Python 3000 and there were no specific goals! And they are actually doing it? I CAN'T BELIEVE IT!
No that's ugly! Also, "self" is probably easier to type than "_".
Which works great up until the moment someone wants to use `gettext` and follows the convention of aliasing it to `_`.
I never knew that. Thats a good reason not to do it. Thanks
Reinventing sorting is always inefficient. Don't want to be a jerk, but mine still seems more elegant (to me). ;-) IIGIR his algorithm is based on the assumption that incoming streams are sorted. Somewhat limiting, isn't it? Yeah, though correct me if I'm wrong -- will you be using this infinite list streams (sorted, don't forget they must be previously sorted) or just their finite slices (in any ordering)? Case scenario if 1?
Let's make debugging harder!
If one has to resort to debugging one has already lost.
The bzr source always looked pretty neat to me. 
I don't see how this has anything to do with hierarchical datasets; it looks like standard SQL access to me.
Uh. It's gone?
Yeah.. the dude must have taken it down. Oh well. 
It'll be among them..
How about this? http://s3tools.logix.cz/s3cmd 
Yeah, this world needs another image viewer.
via: http://jessenoller.com/2008/10/11/new-project-pyjavaproperties/
1. A good site should allow RSS, AND allow surfing via the web. I find new reddits everyday, so having a couple of RSS's in a reader is pointless, I'm going to end up on the site anyway. 2. I like the design of some of the sites I use. They are more eye pleasing than a barebones RSS feed, and in some cases, work better/have more functionality. 3. Aside from the typo of "portion", why the hell would I be concerned with a pumpkin pie recipe, even "if" I'm apart of the python community? Please explain to me how that would work. "Oh, this is a Python feed, but I appreciate your pumpkin pie pizza recipe. Actually, starting today, this feed is for Python developers, but the content within doesn't matter, as long as it interests you personally." ........ 4. I ended up skipping more than half. All the good posts are already on Python subreddit. You do the math. Can you honestly tell me I would be better off?
troll
Interesting, but a couple sample images would be nice.
w00t! JS can no longer stop my spam-bot :-) thanks!! I'm joking.... ...or am I? Yes.
GPL libs? Deal breaker for most.
You can find a pile of examples under /usr/share/shoebot/examples It's pretty awesomecool looking, but i shall wait for some proper docs etc to come out before i get into it in a bigger way
[Boost.Build](http://www.boost.org/doc/tools/build/index.html)
Yeah, I thought about using bjam for my LaTeX-stuff but decided to try [cook](http://miller.emu.id.au/pmiller/software/cook/)([faster, working mirror](http://cj5.info/pmiller/software/cook/)) first. For now, I'm pretty happy with it, only the documentation sucks (it exists but is presented horribly).
Not entirely related, but if only they dumped JavaScript in favour of Python... Mozilla could do this, and Opera and Apple probably would, too, but Microsoft would still boycott it with their crappy browser. It's not that I'm not happy with the changes Mozilla is introducing to JavaScript (which is getting pretty good), other than the fact Microsoft will still never implement them, but I'm quite scared with all the utter crap that's making it (and the good things not making it) to ECMAscript 4, mostly thanks to Adobe. I don't like the fact Adobe has power over what the next JavaScript will be like, it's a company I never liked. I'd rather have the WHATWG guys handle it and kick ECMA and Adobe out of the way, I never liked them.
I don't really know what this all means, but it sounds cool. Can someone give a brief high level explanation? Edit: Is it intended as a javascript replacement?
As far as I understoon on a quick look, it's intended as an extension language for Mozilla stuff. You can write XUL-based applications and access XPCOM (yuck :) ) from Python.
I've never really understood why they couldn't have both. Why is it an either/or proposition?
I would have both. By "dump" I meant leave it for backwards compatibility, and maybe for Adobe to spoil with their crap, but standarize and focus on Python for the future. I wouldn't keep the focus on developing and evolving both, though, as they are pretty similar languages for the same purpose. It's not like you can do completely different things with JavaScript than you'd do in Python.
It's not for scripting the DOM and other client stuff, it's for writing extensions to the browser itself.
You should make this point on the list. He might change the license if you can come up with a good argument.
FWIW this project is *very* green. It is a blast to play with, but just be prepared for some bumps in getting it to run.
Sooo...he must be a perl man then?
That's all i needed to know - thanks. 
I *hated* logging until about an hour ago. This second, it's one of my favorites.
before Python 2.6, I loved simplejson. Now I just don't need it anymore.
[httplib2](http://code.google.com/p/httplib2/) is a well designed HTTP library that supports caching, authentication, HTTPS and keep-alive. It's not in the standard library, though.
I've been using urllib2 is httplib2 better?
The "es" module for EventScripts: http://python.eventscripts.com If you mean core modules, I think my favorite might be sqlite3 currently.
rdflib. ooh how I love it
**getopt** - almost simple enough that I can memorize the calls **cProfile** - my batch job was taking 3 minutes to run and I really didn't know why. Glad I turned to cProfile...I got it down to about 3 seconds. **itertools** - chain(*mylist) to flatten a list, for x,i in zip(mylist,count(0)): ... 
I find that I import random, time, and pickle a lot, so I think they're useful. urllib2 is pretty nice, but I still haven't figured out how to handle cookies with it. Regardless, it makes it ridiculously easy to make a bot to browse websites, which is great. However, it's not as helpful in Python as it would be in other languages because you can just copy and paste entire pages right into IDLE with triple quotes. I'm still not sure how to use any of the GUI modules. Has anyone here used a good GUI module for making 2D games?
today i wrote something like upgrade_rule = ET.parse(f).findtext(upgrade_tag) which had me loving cElementTree (although I didn't love it so much when I was working with it and Amazon data) BeautifulSoup is fantastic for less well formed things. subprocess for finally consolidating/superceding the sprawl of ways to do IPC and because Popen is pretty sweet.
feedparser Lets you quickly parse out, duh, RSS feeds. Very handy and easy to use. 
I love all of them equally.
antigravity
turtle
pygame, psyco and os.
[PyParsing](http://pyparsing.wikispaces.com/) I wrote a program for work recently where I had to parse a complex set of configurations. Could not have done it w/o PyParsing. 
Shapely. I had about 250 lines of code that took 8 hours to run (48 hours in PHP using the same algorithms... finding intersections in a couple hundred thousand points of GIS road data). import shapely, 15 lines of code, done in 15 minutes. no joke. also, ConfigParser. i can make .ini files that my colleagues who aren't developers can easily edit for sys admin tasks.
care to blog/link about it or something? It's hard to wrap one's head around it. Real world-examples are useful
I used it in my last project. Here's some code: import logging &lt;snip&gt; log = logging.getLogger(name="main") log.setLevel(logging.INFO) log.info("the main logger") &lt;snip&gt; self.log = logging.getLogger(name="main.some_module") self.log.info("this is info") 
numpy/pylab/scipy The more I hate MATLAB, the more I love them.
modules I use on a daily basis: Work * boto - Amazon EC2 interface * paramiko - SSH/SFTP client * cPickle - super fast serialization * xml - tons of really useful parsers and libraries School * scipy/matplotlib - math stuff and plotting * ncurses - nice for making CLI
I'm guessing that Python enabled browsers are something many of us have dreamed about for years. Not that I really hate Javascript that much, it's just crappy compared to Python (or Ruby).
I started using this a couple weeks ago. Why did you hate it? Man it saves my ass.
Have you messed with mechanize at all? urllib2, BeautifulSoup, and Mechanize are the triple threat combo for web robots.
BeautifulSoup for easy quick parsing of html. pexpect for easy automation of command-line progs. I really like the new Formatter class in the string library in 2.6
pyglet!
Switch to Python 3.0 - most of the issues with urllib2, urllib, and httplib are worked out pretty well.
What's Python?
This is exactly what I was looking for recently (actually I didn't know it existed so I was trying to recreate the wheel). I've been messing around with it, and I'm relatively new to python, and I'm unsure what the u'' around the value that it outputs refers to. I currently think it means underline, but I can't find that anywhere. For example &gt;&gt;&gt; d['entries'][0]['link'] u'http://www.woot.com/Blog/ViewEntry.aspx?Id=6148' Could someone clarify this for me? Thanks.
http://www.amk.ca/python/howto/unicode Unicode :)
this Although this may not be obvious at first unless you're Dutch.
u'some string' just means that it is a unicode string instead of a standard string if you are unsure what this means it is just so it can include non-ascii values (think values not on your keyboard) 
I guess [PIL](http://www.pythonware.com/products/pil/) is an obvious one for image manipulation. [Queue](http://www.python.org/doc/2.5.2/lib/module-Queue.html) is pretty useful for thread synchronization in the common producer/consumer configuration. I also like [wx](http://www.wxpython.org/) for GUIs. 
http://docs.python.org/library/stdtypes.html#typesseq Cheers.
zope.interface, because I like to separate documentation from source in a structured way.
I love the operator module, I find myself using it all the time.
I agree with those, except that I think `argparse` is better than `optparse`. `logging` is particularly convenient. In every module I create, I say: log = logging.getLogger(__name__) ... log.debug("Debug msgs here.") Other favs: `doctest`, `unittest`, `itertools`, `functools`, `contextlib`, `StringIO`, `inspect`, `rlcompleter`, and `ctypes`. From PYPI, in addition to `argparse`, I think `coverage` and `nose` are great. And of course `pkg_resources`, `scipy`, `wx`, and `pyqt`. How can anyone pick just one? Ok, fine. It's `doctest`.
sys is pretty badass.
optparse, hands down.
&gt; log = logging.getLogger(\__name\__) I don't think that works correctly in an imported module, i.e. \__name\__ becomes the name of the importer, not the importee. 
http://xkcd.com/353/
logging optparse BeautifulSoup (not sure if it really counts because it's not a part of the standard library yet) shutil
Liar
I didn't understand the *two* setLevel functions, and so I only used one. The logger never sent my debug or notice out the handler. I finally figured it out because I used a critical() for the first time and it was logged.
via: http://aroberge.blogspot.com/2008/10/viewing-embedded-pictures-within.html
Things from the standard library that should be builtins: **itertools, operator, functools** Standard library: **os, sys, shutil, glob** Others: **Psyco, PyParsing, PyGame, PyOpenGL** I use **re** a lot, but I wouldn't call it my favourite because it's not as powerful as PCRE.
Try super(Python, self).reddit_home() ;-)
I am personally very glad to have purchased an electronic copy of this book. If you have read more than enough beginner Python books, then maybe its time to read some more advanced Python topics that this book very well covers. What you will learn from this book * Set up a productive development environment * Customize the Python prompt and deploy setuptools * Write efficient syntax: iterators, generators, and decorators * Build arguments by design and follow the best practices for working on API * Build, release, and distribute your applications * Write an application based on several eggs * Distribute and deploy your application with zc.buildout * Build and release your packages and set up a development cycle * Manage your code with distributed version control and continuous integration * Use an iterative and incremental approach to write software * Practice Test-Driven Development * Profile and optimize your code to speed up your programs * Apply design patterns to your applications 
All of the django modules
Too bad Python 2.6 missed simplejson's recent speed boost. I'm still using simplejson with Python 2.6.
processing (multiprocessing in Python2.6)
Standards?
You are trapped here forever. Enjoy your stay!
There are a lot of things which should be builtins then. I'd rather axe a whole lot of the current builtins, leaving only the things seeing use in most, if not all publicly available modules. Leave `print` and builtin types, drop `zip`, various almost-types like `iter` and various rarely-seen exceptions (`ArithmeticError`?) into their respective modules. Most of that doesn't matter. The exceptions namely have rather unique names, but thankfully e.g. `map` is being hidden away.
 mylist = ["Item %d" % i for i in range(2, 11)] for i, x in enumerate(mylist): print "%d: %s" % (i, x) produces 0: Item 1 1: Item 2 ...
Pyglet might be a bit overkill for just 2D, being a rather thin wrapper around OpenGL using `ctypes`. There are quite a few goodies, though, so go ahead if you still got the will.
Sounds good, I'll definitely be getting it. The Python Cookbook has some advanced tricks in it, but I'm glad to see a systematic approach for intermediate Python programmers/aspiring Pythonistas like myself.
Alright, then please move all the useful functions used everywhere to a single module so I can add "from useful import *" at the top of every file. I'm all for using modules as namespaces and separating functionality, so I find os, sys, etc. pretty well as they are, but very basic utilities such as map, zip, filter, reduce, operator.*, etc.; I don't think I've written a program 5 lines or longer that didn't make heavy use of them.
You can always follow the reddit.com link in the "Other reddit communities" box.
I am just getting into python over the past few weeks. I have a lot of python books already, and recently started with "Practical django projects" -- while i find this book ok - it has some issues in the tutorial code that is faulty and for a beginner, hard to get by. I also have "python for unix and linux system adminsitration" -- this book started out strong, but went down a less-than-applicable route. I am looking for a book that is done showing me how to string text together, but has examples and tutorials that actually do something; do you ahve any recommendations? 
antigravity, of course.
You should try the Hetland book from Apress. It's good and in the back he does some projects, like how to do a simple bulletin board system and some other stuff. 
Shameless plug: http://pypi.python.org/pypi/phpserialize This version is more accurate, supports chaining, is compatible with the pickle/marshal/json API and supports more efficient operations on streams.
My very first thought when I read the headline was "What? Doesn't phpserialize already exist?"
Hey, thanks for writing that - it saved me a lot of time on a project a few months back.
Completely needless use of instantiation of (un)serializers. As far as I can tell the module could provide the functions rather than the classes as the public interface.
psycopg2 os.path sys optparse re functools commands (for when I just want to run a simple command) setuptools nose/unittest lxml subprocess (for when I need anything more complex)
I've heard great things about suds: https://fedorahosted.org/suds
Another option using ZestyParser - http://zestyparser.adamatlas.org/examples/phpserialize.py - reduces the problem to something BNF-like
Is there an ISO reference for it?
I've voted this up because I'd love to know if there's a decent SOAP module out there. I tried SOAPpy, but couldn't figure out how to make it work with the complex data types I was interested in. So now I'm using the Zolera Soap Infrastructure (ZSI). I'd say it's ok, although documentation is hard to find, and it relies on pyXML which seems to be unsupported now. I guess the world has moved on and there's not as much interest in SOAP as there used to be, but if (like me) you need to access SOAP APIs it's all a bit frustrating. 
Thank You!
"Sir, you mock me." "Sir, you test me."
I've been using soaplib (http://trac.optio.webfactional.com/) as the client side to a soap-based app and I've really liked it. It didn't seem to be able to parse a WSDL to build the interface (although it can build a WSDL on the server side). The thing I like most about it is that it has a nice serializer interface.
Actually this is quite right IMO. About 6 months ago I convinced my school to move from Java to Python for Programming 101. But I don't need a paper to tell me that Python is much simpler to learn than Java. ;-)
&gt; About 6 months ago I convinced my school to move from Java to Python for Programming 101. Good job. The students will/should be very thankful to you.
I agree that, currently, Python is a pretty good choice for starters. You can teach imperative programming, object-oriented programming with an object model that's centuries ahead of Java's, teach some concepts of functional programming, it's like a Lisp-1, it's dynamically-typed and won't nag the students with typing, yet it won't allow stupid conversions or undefined variables either, it's simple and sane, and comes with a useful standard library with all they need. Plus there's turtle and PyGame to keep their motivation up. Though to be completely happy with Python for teaching programming, I'd want tail-call elimination. I'd rather teach students the beautiful art of recursion and tail recursion, and not allow them to be spoiled with ugly looping right from the start. Students who learn looping first often have a hard time with the easiest thing of all: recursive algorithms, while I suspect students who learn recursion from the start will have no problem dealing with looping shortcuts. Tail-recursive iteration also teaches them to split their code properly into functions as small and reusable as possible.
Yep, SOAP requests with python arn't eay to handle and it's one thing that python as a batteries included all-around language is missing. I also vote for ZSI as you can create modules from WSDL descriptions on the fly -- however they are cryptic and sometimes as in my case needs to be debugged (some variable was wrong and crashed my soap request). So go for ZSI. 
Please explain how you pulled this off. Did you meet with much resistance from faculty who didn't want to give up Java? What kind of reactions have you had from students?
Headline has nothing to do with the content of the article. Short summary: make exists, while the syntax is bad, don't try to create a different make without good reason and understanding of the problem.
What's sad is that [there is already a build tool with Python extensibility](http://www.scons.org).
but what. numpy is wrost. d2 = (x-self.x[0:i])**2 + (y-self.y[0:i])**2 + (z-self.z[0:i])**2 was 35 right?
The point of the article is that you can easily start reinventing things on accident because Python makes it so easy to do things.
I don't agree with this wholeheartedly. There are problems with python as a first language. It's strictly imperative with imperative oo - functional programming is very hard in python, especially if functional programming is taken to mean something over and above "side-effects are undesirable". Lambda is broken (intentionally), function composition doesn't fit well, having a print statement instead of a print function is a mistake (I'm aware it's set to change). I'm not in favour of teaching python's smalltalk-style single dispatch object model to freshman (unless you're teaching smalltalk). About half of all student have some prior experience with programming, but unless the student has good experience of the kinds of situations where this style of OO is a good-fit, it will be difficult to understand the rationale behind things like privacy, encapsulation, and inheritance. It makes sense with smalltalk, because you have just show how the language+vm is wired up, but with python, you don't have that case-study. Python is neither a language that people will need for utility (like C or Java, which are ubiquitous, for better or worse), nor a mind-expanding language (like haskell, ml, prolog, smalltalk, lisp and co). It's just an example of a relatively small, but commonly used domain done quite well. Python gets a lot of support because it has relatively few galling design problems, especially for an imperative language. It's not true, however, that just because it does little badly wrong that it does everything right. Python is an old-style language done right. If python wasn't dynamic, there would be little to recommend it above Java. If I had complete control over a first semester of freshman, I would teach PLT Scheme, and mix HTDP with SICP. Scheme is much simpler than python. This isn't always an advantage, but in this case, it lets you pick what you what to make hard first, instead of having to cover the object model before you do anything else. This is how Sussman gets away with covering interpreters in what is basically an extended CS101 course. It's just as easy to do something else, like more data structures, a simple AI topic or more functional programming.
I'll hijack this thread with a question - I saw a type system library bolt-on for Python, and it wasn't a main, official one. It looked quite powerful. Well, anyway, what type-enforcement libraries (besides assert isinstance(..)) have people seen? 
&gt; It's strictly imperative with imperative oo But it's somewhat flexible to allow some experimentation with other programming models. Though I'm in no way saying this is not a valid claim; it's a pretty real issue of Python that needs to be considered. &gt; Lambda is broken (intentionally) Not in an essential way, just in a very pissing way. &gt; function composition doesn't fit well Can you elaborate? &gt; having a print statement instead of a print function is a mistake **Having statements** (not just print) is the mistake so many people are obsessed in making (god fucking damn Fortran). But do display = sys.stdout.write and poof, a print function. (You can, of course, write something more bearable than sys.stdout.write. I use my own Unicode input/output functions which always use unicode strings and take care of encoding.) &gt; Python is neither a language that people will need for utility (like C or Java, which are ubiquitous, for better or worse) I strongly disagree. First, because Python is already highly useful for a more or less wide set of problems, and it's gaining momentum thanks to Google. It has a lot of potential, especially if Jython and other related projects start to gain momentum as well. It may eat some of Java's share in the near future. Second, because being a commercially useful language shouldn't just be the last of your priorities: it should be a non-priority. I don't give three bits a damn what those enterprise retards use. It's even better if we don't produce professionals for unnice languages, that may give them the clue one way or another. &gt; a mind-expanding language (like haskell, ml, prolog, smalltalk, lisp and co) Compared to C, C++, Java, and everything widespread, it is fairly mind-expanding, as you'll be dealing with dynamic typing (done well), lists and dictionaries, first-class functions and classes, closures, a powerful object model, and the ability to hack it in elegant ways. I don't think it's too bad a start. &gt; Python gets a lot of support because it has relatively few galling design problems, especially for an imperative language. True. What's keeping me bitter, though, is that the few design problems it has are pretty often intentional. GvR wants to ensure you can't use it in a purely functional way because he hates functional programming. &gt; If I had complete control over a first semester of freshman, I would teach PLT Scheme, and mix HTDP with SICP. Another very attractive option for a first language, no doubt about it. My only gripe with Scheme for what it's worth for is that it doesn't come with a builtin big, nice object model where every value is an object that responds to messages dynamically and can be queried for its class or constructor. Most object systems available offer what PHP does: you have numbers, strings, symbols, boxes, cons, vectors, ports, syntax, etc. and then you have objects, so you cannot write a truly generic function or work in a truly generic way. There's Tiny-CLOS, but it's so horridly undocumented I wouldn't touch it, much less teach class over it. If only I had a Scheme with an object model like Python's (no, not CL+CLOS, that'd be kinda nasty for a first language), or if only I had a working Lisp dialect compiler for CPython (like Lython)...
Why is it sad? Sounds like he was having fun. Heaven forbid.
Python Decorator Library has accepts/returns that works well if you need type-enforcement. http://wiki.python.org/moin/PythonDecoratorLibrary#head-308f2b3507ca91800def19d813348f78db34303e
The neat thing with Python (and dynamic languages, really) is that implementation details are ridiculously easy to swap out unless one deliberately codes to prevent that.
Here's an example of some [really terrible Python code](http://golf.shinh.org/reveal.rb?Sierpinski+Fractal/MarkByers/1223081482&amp;py) for drawing a Sierpinski Fractal. The problems with this code are too numerous to mention. I'm surprised it works at all.
&gt; Its a good time to be a programmer. &gt; Its all good. &gt; Its a mess. Why aren't native Americans any good at English? (Or am I the only one to notice this stuff?) _edit: seems like he doesn't know the form `it's` at all, except for three occurrences on his blog._
He refers to the `koji` program in Fedora, but that's just a reference, not even code.
&gt; That said, [StringIO] probably won't do what you want in 3.0, as it only accepts unicode Python 3.0 has BytesIO for plain bytestrings. Both (BytesIO and StringIO) are in the new [io module](http://docs.python.org/dev/3.0/library/io.html#buffered-streams)
[Here's a cleaned up version using threads][v2]. [v2]: http://blog.brianbeck.com/post/55165808/message-queue-2
I wrote one for Ruby [years ago](http://www.aagh.net/projects/ruby-php-serialize); supports serialized objects too, either building using a user-provided class or making a Struct type from it. I also have it convert PHP arrays with incrementing integer keys into Arrays rather than Hashes. Seemed like a reasonable thing to do. Can't say I've ever actually *used* it for anything, though :)
See also: http://nick125.com/2008/10/pymtp-development.html
&gt; But it's somewhat flexible to allow some experimentation I concede this general point. I just don't think that python is quite flexible enough with regards to non-imperative models of execution. I wouldn't want to do what you do though; alter the base language too much, and you're no longer teaching python. &gt; Can you elaborate? [on disliking Python's function composition] Function composition is present, which is enough to teach about it, but it isn't common or idiomatic enough to teach about the implications of it for program design. &gt; Having statements (not just print) is the mistake so many people are obsessed in making Yes it is. It seems statements just won't die. &gt; I don't give three bits a damn what those enterprise retards use I agree on general principle, but the advantage of languages like C and Java is that, for certain domains, there are libraries available that are very helpful. This is possible in some domains for Python, but not nearly as many as for Java. &gt;the few design problems it has are pretty often intentional. Indeed. This is such a short sighted position to take. &gt; My only gripe with Scheme for what it's worth for is that it doesn't come with a builtin big, nice object model Again, agreed. If you want to teach sophisticated object models, scheme is not the way to go. &gt;If only I had a Scheme with an object model like Python's (no, not CL+CLOS, that'd be kinda nasty for a first language), or if only I had a working Lisp dialect compiler for CPython (like Lython)... It's interesting that you mention CL+CLOS as being a bad way to start. It was how I started, and I regret it for many reasons, even though I value Common Lisp and CLOS highly.
Python 2.6+ has the abc module in the standard library that provides a simple form of creating abstract base classes - it enforces construction of sub-classes must supply concrete implementations, and let's you perform magic tricks with isinstance(). zope.interface and zope.schema (extends zope.interface to allow richer descriptions of fields, e.g. "DateTime" instead of just "Attribute") is an alternate type-hierarchy to allow objects to formally declare what interfaces they provide. It doesn't do any enforcement (although it provides simple verification capabilites), but is instead more focused on providing a more fomralized way of specifiying an object's APIs. It's also interesting in that it's an object-centric classification system - two objects of the same type can provide different interfaces in Python due to it's dynamic nature, and this is accounted for in zope.interface. The zope.interface package is also sometimes used in conjunction with zope.component to allow registering, and looking-up objects by interface (aka Zope Component Architecture) which allows for dependency-injection style adapter pattern and also makes explicit an adapter objects dependencies (which is quite nice in larger Python since things can get very implicit otherwise). http://pypi.python.org/pypi/zope.interface http://pypi.python.org/pypi/zope.schema Traits is "explicitly typed attributes for Python". Although I haven't used it yet, so I can't comment too much on it: http://pypi.python.org/pypi/Traits/ Finally PyProtocols uses types to provide adaptation patterns in Python. Again I haven't really used it though, so can't comment too much on it: http://peak.telecommunity.com/PyProtocols.html 
We use Drupal at my company - I fucking hate it. I find the interface to quite irritating and counterintuitive.
I don't understand this project. Why not just work on Django?
if it makes you feel better, the internals are fucked, too. this is partly the fault of PHP, however. -- addenda: Most of the people who work on Drupal are great; I think they're doing it for the same reason I was, to get "a" project out the door. That said, I dove far deeper into Drupal's guts than I had any intention of doing, and it really soured me on Drupal's approach to having an event loop in PHP. While I still use Drupal for some things, and recommend it to people who don't really want to program, just want a CMS, I will never again try to force it to stretch a little bit outside of its targeted goals. For anything novel, I'll just use Django, especially now that it's passed the 1.0 milestone (much easier to 'sell' a project perceived as 'mature'). PHP and Perl made me a lot of money over the past decade, but now that I've survived grad school I don't really feel like I should do things which make me feel icky. There's enough work out there which challenges me to think (and any time I start to have doubts, more arrives). 
Because they want to work on Drupal?
The FAQ sums it up: "Drupy is offering a solution for the many people who love Drupal or would love Drupal but wish for an environment other than PHP. We recognize that some Drupal developers and Python developers may be uncomfortable with Drupal in Python." So you get to kill two birds with one stone: provide a version of Drupal in a real programming language, and make some developers uncomfortable. Reason enough for the port, I say! 
Because that would make them obsolete :)
Too bad this tutorial doesn't care enough about properly formatted code. `mixedCase`? Please.
drupy is pretty much one of the most stupid project ever they do various 1:1 ports from php, killing performance and thread-savety on purpose most of those pretty much defy any good practice in python to sum it up, they have no idea how to properly use python, so they just use it like php - its a epic fail
&gt;So you get to kill two birds with one stone: provide a version of Drupal in a real programming language, and make some developers uncomfortable. Meh, seems more like it combines the ease of deploying Python with the great APIs of PHP.
I've never used Zope because it has the reputation of being big and too "enterprisy". Is this still the case or are todays servers big enough? Or maybe it's just FUD? I'm a bit depressed at the moment, because I had to choose a PHP CMS.
I am currently diving into Plone3 after some brief Plone2.5 experience. It's for a job. Yes, it is still "enterprisy". But it is a breeze of fresh air. No relational databases. In fact, you never touch the database. You get introduced to cutting edge programming constructs like Adapters (interfaces are also widely employed). Documentation is getting where it should, I observe. Read "Professional Plone3 development" (it's online somewhere) and decide for yourself. Don't start alone with it, I would say.
Bruce Eckel is perhaps best known for "Thinking in Java", a excellent Java tutorial.
&gt; Python and Ruby have the enviable properties that almost no one dislikes them, and almost everyone respects them. I disagree. 
And how are the system requirements? In http://plone.org/documentation/faq/is-plone-for-me they say "you should at least have a 1GHz server with 512MB RAM to use it comfortably". It's hard to find smaller systems today, but I don't want to limit a big host on just one or two sites. How many low traffic sites (CMS, maybe some product pages) would you realize with Plone on a dedicated server with AMD Athlon 64 X2 5600+ Dual Core, 4 GB RAM, 400 GB HD? 
One thing that Zope is made for is nice load-balancing via [Zeo](http://www.zope.org/Documentation/Books/ZopeBook/2_6Edition/ZEO.stx) on several servers. I am no good source for your queestion, as I am just a plone programmer. Someone else in our team thinks about this stuff, but we only need one website. One thing zope/plone has is good community. Try the mailing lists on plone.org or the german zope community at http://dzug.org/. 
A brochure-ware style site running in Plone will require about 256 MB of RAM. This is if each Plone site is running it's own process. You can share multiple Plone sites within the same process so that you aren't consuming a complete 256 MB per site, but then they all need to be running the same version of Plone, and upgrades need to be done in lock-step. So yeah, Drupal is going to use much fewer resources for a small brochure-ware site than Plone. Work is just starting on Plone 4, and it'll be the first release where optimization is a major focus - so a Plone that requires less RAM and CPU may happen over the next few years. It would be interesting to see what kind of resources consumption Drupy gets. And you can run Plone under WSGI now, so when Drupy adds support for that, you could build a frankensite half-plone, half-drupal, half-middleware ... oh gawd :) 
Since I posted the recipe like 3 hours ago, gst must be some sort of bot?
Here's mine. I think it is like 10x slower than the built in dict, but I didn't profile it much. sentinal = object() class PyDict(object): """ A pure python implementation of dict""" __slots__ = ['__contains__', '_store', '_len', '_alter_store', '__delitem__', '__getitem__','__iter__', '__len__', '__setitem__', 'clear', 'copy', 'fromkeys', 'get', 'has_key', 'items', 'iteritems', 'iterkeys', 'itervalues', 'keys', 'pop', 'popitem', 'setdefault', 'update', 'values'] def __init__(self, __initial='', __size=32, **kw): self._store = [[] for x in xrange(__size)] self._len = 0 self.update(__initial, **kw) def update(self, __initial='', **kw): for key in kw: self[key] = kw[key] if hasattr(__initial, 'keys'): for key in __initial: self[key] = __initial[key] return for key, value in __initial: self[key] = value def _alter_store(self, i, set=sentinal, delete=False, default=sentinal): _store = self._store h = hash(i) % len(_store) current_row = _store[h] for x in xrange(len(current_row)): #does binary search make sense here? key, value = current_row[x] if key == i: if set is not sentinal: current_row[x] = (i, set) return True, set if delete: del current_row[x] return True, value if set is not sentinal: current_row.append( (i, set) ) return False, set if default is not sentinal: current_row.append( (i, default) ) return False, default return False, None def __hash__(self): raise TypeError('dict objects are unhashable') def __contains__(self): found, value = self._alter_store(i) return found def __setitem__(self, i, y): found, value = self._alter_store(i, set=y) if not found: self._len +=1 if self._len &gt; .75 * len(self._store): new = PyDict(self, _PyDict__size=len(self._store) * 2) self._store = new._store def __getitem__(self, i): found, value = self._alter_store(i) if not found: raise KeyError(i) return value def __delitem__(self, i): found, value = self._alter_store(i, delete=True) if found: self._len -= 1 else: raise KeyError(i) def __len__(self): return self._len def __iteritems__(self): for row in self._store: for t in row: yield t def __iter__(self): for t in self.__iteritems__(): yield t[0] def __str__(self): return '{%s}' % ', '.join('%s: %s' % (repr(key), repr(value)) for key, value in self.iteritems()) def __repr__(self): return str(self) def get(self, i, default=None): found, value = self._alter_store(i) if found: return value else: return default def has_key(self, i): found, value = self._alter_store(i) return found def iterkeys(self): return self.__iter__() def keys(self): return list(self.iterkeys()) def iteritems(self): return self.__iteritems__() def items(self): return list(self.iteritems()) def itervalues(self): for t in self.iteritems(): yield t[1] def values(self): return list(self.itervalues()) def pop(self, i, default=sentinal): found, value = self._alter_store(i, delete=True) if found: return value else: if default is not sentinal: return default else: raise KeyError(i) def popitem(self): for row in self._store: if row: return row.pop() raise KeyError('dictionary is empty') def setdefault(k, d=None): found, value = self._alter_store(k, default=d) return value def fromkeys(S, v): for s in S: self[s] = v def clear(): self._store = PyDict()._store def copy(): return PyDict(self)
Presumably not x == y would work without having to add the code for __ne__, though it's likely the missing __ne__ was an oversight.
This is just for fun.
What does this have to do with snakes?
There's a debate going on on the Python developers mailing list right about whether to change this in Python 3.1.
Yes, he is.
Wouldn't it be better to give an error if there were no explicitly designated **ne** operator?
I don't know for sure, but having observed its posting behaviour for the past year or so, I'd say that it's subscribed to several RSS feeds, and using relatively simple analysis, determines the appropriate subreddit, and often prepends things like "ANN: " to the reddit title of announcements of new releases.
&gt; While we’re at it lets add an easy way to run your current script. &gt; &gt; map &lt;f8&gt; :!python %&lt;cr&gt; &gt; &gt; in your .vimrc will cause F8 to run the file you currently have open. Shameless self plug: http://www.vim.org/scripts/script.php?script_id=1788 "*The Bexec plugin allows the user to execute the current buffer if it contains a script with a shebang (#!/path/to/interpreter) on the first line or if the default interpreter for the script's type is known by Bexec. The output of the script will be grabbed and displayed in a separate buffer.*"
&gt; There are cookie based solutions inspired by Rails available for Django, but I don’t like using cookies to handle such state. The "cookie-based" versions are actually "session-based"; that is, the data itself is not sent in the cookie, but is instead stored in the user's session (which is stored server-side in any of several forms). The cookie itself is only read to determine which `Session` object to retrieve and use.
Nice plug. Remember: it's not a shameless self-plug, it's a genuine informational message for folks like me.
Hey thanks for pointing that out. I updated the post.
Very nice. Was looking for something like this. 
It's written in Python, but PCREs are PCREs. You can even use them in...Perl
Oh, markov chains, is there anything they can't do? *Codes a coffee-maker* Sweet!
all the props for a short tutorial on regexes applied to "a" logfile. But what's the point of it, the net is full of much, much better intros into regexing.
earobinson@MinusOne:/media/data/downloads/downloads$ python markov_chain.py redit 3 redition reditors reditory reditate rediting redities reditous rediters reditely 
Major "Me Too" website. Still, good for them for trying.
As I understand it, it's basically meant to be a demo site showing off the platform, and the fact that a few thousand users seem to actually like it is just a nice bonus.
The comments of this story introduced me to the [total_ordering](http://code.activestate.com/recipes/576529/) decorator, which is pretty seriously awesome.
&gt; Cloud27 is a demonstration of what Pinax can do out-of-the-box but is also a rapidly growing social network in its own right with many more features to come.
I agree, and wrote an article on this topic that you might want to check out. [Python is the new BASIC](http://coffeeghost.net/2008/06/18/python-is-the-new-basic/)
created an account, to check it out, based on the "collaborate via wikis" in the linked story... Actually, this is something that a friend and I talked about a few years ago when we were talking about soc net design... I am suprised it took so long for a soc net to incorporate one. (granted; i do not have a facebook account and deleted my myspace account years ago, so this may be a feature others have already) 
sage
too bad there is not a native port to windows
the article says almost nothing, [here](http://sagedread.com/graphics/blender/blender_programming1/) is the second part, at least have some code... however it is .blend :P not readable. I have a friend who does 3D animation and was very impressed by Blender compared to 3DMax I hope this guy starts posting something useful. EDIT: it seems there's a more complete tutorial for an FPS game * [Part 1](http://sagedread.com/graphics/blender3d-graphics/how-to-make-an-fps-game/) * [Part 2](http://sagedread.com/graphics/blender3d-graphics/how-to-make-an-fps-game-part-2/) * [Part 3](http://sagedread.com/graphics/blender3d-graphics/how-to-make-an-fps-game-part-3/) * [Part 4](http://sagedread.com/graphics/blender3d-graphics/how-to-make-an-fps-game-part-4/) * [Part 5](http://sagedread.com/graphics/blender3d-graphics/how-to-make-an-fps-game-part-5/) * [Part 6](http://sagedread.com/graphics/blender3d-graphics/how-to-make-an-fps-game-part-6/)
The online notebook thing is pretty cool though.
Be aware that the coverage library described only gives you statement coverage.
Sorry for my ignorance but what else is there? I'd like to see a good article about using unit tests, pylint, etc.
http://en.wikipedia.org/wiki/Code_coverage#Coverage_criteria
Thanks! But doesn't statement coverage imply all the others? EDIT: on consideration it probably doesn't imply condition coverage, is that right?
Yeah, x = True y = x or epic_fail() Could show 100% coverage, but `epic_fail()` is never called.
via: http://groups.google.com/group/comp.lang.python.announce/browse_thread/thread/53a9c0e25d92476e/7547da32d8d89bc5?show_docid=7547da32d8d89bc5 ANN: Kamaelia 0.6.0, Axon 1.6.0 - New Release 
Bad example, because if epic_fail() is never called that will show up in statement coverage, right?
Does [figleaf](http://darcs.idyll.org/~t/projects/figleaf/doc/) work better for coverage?
Yes, but this is a false positive. Epic_fail should not be called - it indicates a hardware problem. However we may have to handle the situation where it is called. One engineer I worked with got the following information from hardware enginneers: "It is possible in theory for a bit in one sensor to stick one time in a million, and since life is involved we need to detect that situation and get outside help if it happens. We do not have any way to create hardware where this will happen and we are not even sure it can happen in the real world". Given the above you cannot get proper code coverage of the full system (you can of course test parts in software simulation, but not the full system. Anyone who has done real software knows that real world bugs still happen after software simulation) 
I would not be so sure about that claim, esp for large scale problems, see: http://leon.bottou.org/projects/sgd and for the theory: http://leon.bottou.org/papers/bottou-bousquet-2008 Anyway thanks for the link. It's always nice to have numpy friendly bindings to state of the art machine learning libraries :)
BTW gst, I forgot to ask, how do you do to post so many links to relevant material on reddit? Are you a full time human feed reader?
I can't tell if Drupal is really better cause I don't know much about Drupal, but I can tell that Plone is bloated. They have been trying to change their old model (toward zope3) for years, but what is started is usually never finished, cause nobody feels like rewriting the old stuff that worked with the new model. So you have at least 2 different ways to do anything and it's a huge mess and very unpythonic. Also it's really slow. In my opinion Plone is getting old and is in a dead-end, cause there just is too much code that need rewriting and nobody doing it. Oh and I don't like zope3 that much either, the zodb (zope object database) is nice enough, even if it has the disadvantage of not being a standard like sql. But all those interfaces sounds very unpythonic to me.
Both `easy_install` (which people love to hate) and `pyinstall` (which is ideal for reproducible installs) can take a URL of a package and install it for you. And `pyinstall` can also do neat tricks like pulling an SVN repository or even a specific rev of a repo and find a `setup.py` to install from.
For me it looks like the examples are ridiculously short for making any kinds of claims. To begin to make any kind of comparison I can imagine you'd probably want 1-10k of java at least, and perhaps a java guru doing the java and a python guru doing the python at the same time from the one functional spec. I'm not putting my hand up to organize it though :)
s/Keven/Kevin/ :P
Any in-place sorting algorithm will do...
I liked how one of the comments noted the good pythonic style of the code.
Err, not exactly. `4 bytes/integer * 1e6 integers == 4 MB `. That is, the integers alone occupy 4 MB of RAM. Sorting 4 MB of integers in-place will use 4 MB of memory, not 2 MB.
easy_install doesn't allow for a buildext option from the command-line AFAIK? Buildout lets you install more than just Python code though - which is very useful :) pyinstall does look quite promising though. It let's you install packages flat which is nice sometimes (although collective.recipe.omlette symlinks out a flat view of a set of eggs for Buildout as well). I also like that pyinstall's package-version specification format is Buildout-compatible - especially since I like to have a few VirtualEnv's "on-the-side" and might want to include a working set of packages from pyinstall in a Buildout. Perhaps a Buildout recipe for installing/controlling pyinstall might be interesting ... 
For installing just PIL from Buildout, chrism made a setuptools-compatible version of PIL: http://thread.gmane.org/gmane.comp.web.zope.devel/13995/focus=13999 For Mac OS X users, there is a Buildout config sample for also pre-making the libjpeg and zlib dependencies - useful if you aren't using a Ports of Fink version of Python. http://plone.org/support/forums/general#nabble-td337007 
In python, that would be 12 bytes per int as there is 8 bytes per object overhead, and if they were in a list, an extra 4 bytes. Total 16mb for a list of a million ints (for python 2.5, not sure if py3k works differently). edit: using the array module would remove these overheads.
I dunno, I almost called him out for not using a `main` function, but… you know…
You could also just do a bitwise radix sort, if you really want to talk about minimal ram requirements. And it's O(n) too ;)
It only uses 4MB of if you load all of them at once. Of course this is covered in the second sentence of TFA.
Google knows that already, why not ask? Or [better yet](http://www.reddit.com/r/Python/comments/6wnmb/save_me_from_gst/c052leu).
&gt; Taking up the challenge, I leared something about buffered I/O. No, no, that doesn't cover it :)
Argh... third :) 
:) But given that, I'm not sure whether you're arguing with me or with haoest. If you're arguing with me, what if you don't have 4MB of memory? Let's say that you need to sort 8TB of data, and your machine has 2GB of user-memory available? That's why this would be an important exercise, and it's why haoest's comment that any in-place sorting algorithm will work can't be correct
Since the linked site doesn't take comments: You should check out bcfg2 at bcfg2.org. It is written in python. Bcfg2 takes a different approach than cfengine and puppet. Instead of writing code to do something, you write an xml specification of how you want the system to look. Bcfg2 checks the target system against the specification and installs any packages, files, or services that do not match. Then it reports if anything wasn't able to be installed correctly. With the others, there is not an integrated way of verifying that your changes got deployed properly. We're using it to deploy and manage about 175 Ubuntu workstations and 2 Ubuntu servers. We are able to specify that particular computers or groups of computers should get one configuration file or package while others get something completely different. There is active development, and the developers are receptive of bug reports and patches.
How about mmap and in-place sort?
I love the *spirit* of doctests. Trying hard to make easily testable and regression-resistant code is awesome. Yet, I feel it falls down in the same ways. Noble effort, but not a replacement for full unit tests.
That gets pretty close, actually, although it does have the downside that since the OS is managing it for you, you don't get to pick the upper limit on your real memory usage. The block-cache and page-cache may grow as large as they *can* grow, which may be larger than you *want* them to grow, but that sort of happens with the block-cache anyway in the method given However, that's "cheating" in the sense that it's still internally swapping out to disk, the userland program is just not the one doing that work, sort of like the answer "just get an intern to do it".
Doctests aren't meant to replace unit tests. There's a [whole section in the doctest documentation](http://www.python.org/doc/2.5.2/lib/doctest-soapbox.html) about that.
He's doing it wrong: &gt; Writing test infrastructure becomes harder Pull the test infrastructure out of the doctest and into the module itself. If *you* want custom convenience setup code, chances are that your users would like some assistance when they're playing around with your library in the interactive interpreter. It gives them an example of how to set up things to use your library from scratch. You may even want to make the classes/methods public, making the library as a whole easier to use. &gt; A more fundamental reason why I dislike doctests is that tests are code, and code works better in a .py file than a .txt file Don't put them in a .txt file then, unless you're writing an executable tutorial. Put them in the docstrings of the classes or methods that you're demonstrating how to use, and keep them short. No more than 3-4 tests per comment. &gt; For instance, it would help if there were a way to easily reset all state during a long doctest, so that different parts of the same file could be independent. Don't write long doctests. If you need to reset state, put it in a separate comment. &gt; And then it would be good if there were also then a convenient way to put names on these independent sections. That's why you attach them to methods... &gt; Is it because there's no obvious home for helper functions, because a doctest is not a module? The "obvious home" is inside the module under test, as a standalone function. That said, you'll usually need *both* unittest and doctest tests for comprehensive coverage. A doctest's first purpose is *explanatory*: it's intended to let users of a library know how to use it, and is executable only as a way of ensuring it doesn't become out-of-sync with the code. You typically don't get or want 100% coverage with doctests; if you need that, write unittests. Also, doctests work much better when you program in a functional, side-effect free style. You can get pretty close to 100% coverage with this, because you need the unittests to validate state and side-effects, and if you have no state, you don't need them much. And it makes the code so much clearer and more reliable anyway...
opps.. i ment to ask. whats a good place to host python sites. specifically the reddit code? i have a domain
Exactly. I typically use doctests inside docstrings for functions which have no side-effects. Doctests do not test the code; they test the documentation. Any critic of that does not understand the importance of correct documentation. They also show exactly how to use a function; i.e. they are "literate". Because doctests are (often) easy to write, people actually write them, so documentation becomes more reliable. This is one of the great strengths of Python.
I was disagreeing with the assertion that the integers occupy 4MB of RAM. They only take up as much RAM as you want them to; of course, you know that. :) From the original reply it seemed like you were saying "That's impossible it is already 4MB!". I can see now that you were not making such an absurd statement. I probably just missed that you had mentioned "in-place" in your reply.
I agree. Doctests are fantastic for ensuring that your comments don't lie (and tools like epydoc make them look very pretty...). They're no **substitute** for regular unit tests, although of course with nose et al you can automatically include doctests in your unit-test runs.
Oh a popularity contest! Although this list is of most interest mainly to Zope folks, Python's heaviest users of packages. Good to see zope.interface right at the top - I suppose this is probably because it's shared by both zope and twisted. As a public service reminder, I'd like to take this opportunity point out that you can install all your packages in a cache'd location, so that when you install multiple apps from the same framework, they can all use the cache and don't need to pound PyPI! In your ~/.buildout/default.cfg put: [buildout] # egg cache location eggs-directory = /Users/kteague/buildouts/shared/eggs # download cache (*.tar.gz parts) download-cache = /Users/kteague/buildouts/shared/cache # always unzip eggs, yes please! unzip = true 
I'm not someone who can tell you which way is more pythonic. That said, I think his code is easier to read and understand. Barring some large efficiency problems, I'd choose his way over yours. Of course, a decent part of my problem is a failure to understand both the re module and the whole lambda concept. Whenever I use either, I spend as much time re-reading docs and/or code samples as I do coding. 
Much more pythonic verison, but why not use: artists.setdefault(artist, []).append(song)
&gt; for line in fp.readlines(): Wouldn't that be better as `for line in fp`? `readlines` returns a list rather than a generator, so it seems like a waste of memory…
This looks like Perl code. (courtesy of the comments on the article) my $db; while ( &lt;&gt; ) { if ( m/^\d+\. (.+?) - (.+)$/gi ) { push @{$db-&gt;{$1}}, $2; } } foreach (sort { @{$db-&gt;{$b}} &lt;=&gt; @{$db-&gt;{$a}} } keys %{$db}) { print @{$db-&gt;{$_}} . " $_ [ @{$db-&gt;{$_}} ]\n"; }
&gt; the reality is that it causes the same pattern to be compiled to DFA on every iteration, which is just a rookie mistake in code where performance matters. Not true. If the string is a constant, the Python interpreter can see that its the same and it doesn't need to be recompiled. You just made a premature optimization. Profile first, then optimize if necessary.
&gt; If what you said were true, compile_many() should take less time, not over twice the amount. Sorry, but why? &gt; How certain of this are you? Check the source: re.py. &gt; If it's actually caching the DFA at a module level, then there is still performance penalty for the lookup. Yes, this is true, but that's not what you said. Notice that the lookup cost is independent of how complicated the regular expression is. For a small number of applications of the regular expression explicitly telling Python to compile it may actually be slower than letting Python do its thing. By optimizing your code prematurely you are often removing possibilities for dynamic optimizers like psyco to optimize for you. Psyco can optimize your code a lot better than you, if you allow it to. You should always profile first before optimizing. Now you can downvote me again. :-P
I wasn't saying that you're wrong about the performance. I'm saying that your reason is wrong. I'm saying that optimizing code based on reasoning that is wrong, is also wrong. You've admitted that. So I'm happy. This is the one sentence that I really didn't like: &gt; As for the re change: I moved the regex outside the loop -- again for performance reasons. You shouldn't be doing anything in this script for performance reasons. If you did it for readability then fine, but then you should state that first. And bear in mind that some people may disagree, and that's OK. There is no "right" way. 
"Microsoft search is great. They pay me to write that."
A multipart MIME message, you mean.
wow i thought this video was lost forever. 0.4 is ancient now ! 
This is going to sound ungrateful no matter how I write it, but the quality sucks! 
having a problem with self is really nitpicking. I neither love it or hate it.
I propose that dynamically adding methods to a class at runtime be named "Eckel Poking". :)
There are no excuses being made in this argument. Further, the customer is in no way right when they take a decade-old product and nitpick on language design issues that are good compromises. Python's use of 'self' as an explicit argument is a slight syntactic trick that *extremely cleverly* glues together the bound/unbound programming experience. Having programmed in many OOP languages where 'this'/'self' are implicit, I have to say that I greatly prefer Python's way of doing it. It answers the following questions very elegantly: ##How did self get defined locally in my method? Explicit: you specified it as an argument, ether via *instance*.meth(args) or *class*.method(*instance*, args). Implicit: I put it there for you automatically because you called a class instance method. ##So how do I specify 'self' myself? Explicit: you pass it as an argument. Implicit: you use a language construct such as *method*.apply(*instance*, args). ##How do I pass around bound methods (or more general: closures) for callbacks? Explicit: Evaluating *instance*.method results in a bound method that calls method(*instance*, args). Notice how this syntax applies to normal invocations too... ( *instance*.method(args) &lt;=&gt; (*instance*.method)(args) ) == method(*instance*, args) Implicit: You'll typically have to store 'self' on your own in a closure and use the language construct from above to call the method using it.
I've found Python's self makes the language simpler and the way objects work more evident, which are two very valuable reasons to keep it. "self"-less languages such as Javascript run into all sorts of problems with "this" like things. The this parameter of the apply method is an example, but the real problem comes when you want to extract a bound method from an object and pass it to some higher-order function. In Javascript, if you store obj.method somewhere, you get an unbound method, and an unbound method without even a self argument to specify, which is even worse than a Python unbound method. You have to wrap it in a λ-expression or use apply.
First thing I looked at (picked at random) gives bad advice. The preferred method for checking presence of a key in a dictionary is `if key in dict` not `if dict.has_key(key)`. This preference is enforced in Python 3.0: `has_key` has been removed from the `dict` class. Having said that the introduction does state that there may be errors.
I get """ The page you are trying to view cannot be shown because it uses an invalid or unsupported form of compression. The page you are trying to view cannot be shown because it uses an invalid or unsupported form of compression. * Please contact the web site owners to inform them of this problem. """
[idem](http://www.thehazeltree.org/grimoire/apprentice/Files.html#id8) &gt; The &lt;&lt;PythonModule posixfile&gt;&gt; module provides an object that acts like Python’s standard file objects, but adds some extra methods. One of the extra methods is lock(mode, len, start, whence). mode is a string specifying whether you want a read or write lock, or to give up an already- acquired lock. &gt; Deprecated since release 1.5. The locking operation that this module provides is done better and more portably by the fcntl.lockf() call. it might still be a good source of ideas, but you need to double-check the solutions.
Not that good of a site. I just took a cursory glance at the section dealing with files and there was a lot of questionable advice. Most of the hints involved reading the whole file in to memory. They don't mention the 'with' statement way of iterating over lines in a file, which has been around since Python 2.5 (from __future__ import with_statement). Additionally they list some caveats with the shutils.copy() function that pertain to Python 1.4 or 1.5! Ancient!
Neat idea, but the 1MB limit kinda kills it. 1MB is about half a photo nowadays...
Not bad, but old.
It would be amazing if they could increase that or even allow you to pay for the increase would be amazing....
I am on a project that builds a website in Plone3. I am no uberprogrammer but certainly no dumbass either. It still hurts and was fighting the framework for hours last night. I expect all of this to become better in the next year, but now is too soon if you have doubts....
For a company so invested in Python, I wonder why Android currently does not support it. Heres hoping someone at Google gets er done!
&gt; Guido van Rossum &gt; Guido van &gt; Guido
I would like to know how Python functions. What are some good books on the implementation of Python? Thanks
I worked with Zope3 for well over a year. I left that job feeling I didn't really understand it. I wish you luck and hope your experience with Plone3 doesn't make you hate your vocation.
I know what you mean. I was trying Plone3. Two weeks later and I didn't have anything useful to show, and it reminded me way too much of Sharepoint. I gave up and have decided to just use Joomla -- already much further in 3 days.
if explicit self bothers you that much, you may have some mental issues that you need to sort out. It really isn't that big of a deal.
What a horrible web interface this moderator.appspot site has... gratuitous ajax-driven navigational nightmare. 
Basic guess: Python isn't the most used language at google, Java also is used quite a lot, Java is pretty much the "standard" mobile environment (as far as there's anything standard there) unless you want to go with C/C++ and manufacturer-specific APIs (which are anything but standard). It therefore makes a lot of sense sense to initially provide at least a Java system, and additional programming APIs/languages would only detract from making the platform work correctly in the first place (and would add to the support workload). So a single programming language completely makes sense, and that it be Java more than makes sense for a mobile platform (unless you're apple of course)
Downmoding because I am fed up with the issue. And TFA: 1. "The name "self" is not enforced by the compiler but it's necessary to declare it as the first parameter of your method or Python will consider your method to be a function." - the author either doesn't know what he talks about or tries to be understood by java programmers. Method is just a function. Missing self makes it (n - 1)-ary function instead of an n-ary. As missing any other argument is. 2. "when you declare a function with n parameters, you should invoke it with n parameters" - you DO call python methods with the same number of arguments there are in its declaration. It is only printed somewhere else. If "dot notation" syntactic sugar (obj.f(arg)) is that confusing, perhaps we should remove it and leave just (cls.f(obj, arg))? 0. The problem with self-haters is the same as with parentheses-in-lisp-haters - you really can't get over it, don't use the language. These are parts of their languages' core designs, accept it.
Webfaction are fantastic.
I wish I could have the 6 months of my life wasted on Zope back. 
well, our plone3 still uses zope2.10, but of course we use a lot of zope3 concepts already. it's a big mess sometimes, when I try to find the actual implementation of method X that gets executed...
Does this fill some other niche than SCons?
Yeah, it uses *decorators*. SCons doesn't use decorators. Also, SCons wasn't written by a famous person. So that's two niches right there.
Does Scons fill some other niche than make?
First python subreddit LOL, thanks. That was good.
It's Python based which means its syntax is a million times better than make's. I have never used it but I would love to replace the big ant/make mess that comprises the build system at my company.
Not a lot of concrete information in this blog post. For those looking to get in to Python web frameworks, I have a little of my own advice: 1. Read through the introductory material for each framework and then skim the rest to get a good idea of what they have to offer. 2. Use virtualenv for isolation and play with different versions. 3. (response to this article) Don't forget TurboGears 4. *Do* forget ZOPE. 5. Pick one. Learn it well. Build some apps. 6. Congratulations, you are now able to make a more informed decision and pick your personal preference.
Hey, I'm a rookie Python programmer and I'd like to make a set or list of all two character strings containing letters and '/'. I'd like to use regular expressions to do this but haven't been able to figure out how. Any suggestions? Thanks in advance. EDIT: Hey sorry for any confusion. Basically I want to make a list: ['aa','ab','ac',...,'ZY','ZZ'] without typing all of that in. Thanks for your help.
your statement of the problem is a bit unclear (if you are in fact asking for how to produce every possible two character string that's something else). But this should at least show you what I think you are asking for. import re print "starting" test_string = "aaa aaa/ a/ f/ fffs /f a/f ff/" print test_string test_re = re.compile('[a-zA-Z/]{2}') f = re.findall(test_re,test_string) print f You will probably need to tweak the regex to get it to do _exactly_ what you want. 
odd question. this is probably not what you want. import string def G(): for n in string.ascii_lowercase: for m in string.ascii_lowercase: yield (n, m) g = [str.join("", n)+"/" for n in G()] assert "zz/" in g 
My vote goes for Django and against Zope.
... Literally.
&gt; Python is an imperative language, Really? Wikipedia doesn't seem to think so: &gt; Python supports multiple programming paradigms (primarily object oriented, imperative, and functional) and &gt; Python is a general-purpose, high-level programming language.[2] 
It was meant to be more an intro, though I felt I provided enough information to demonstrate the differences between the three. What would you recommend I cover for a followup? As for your tips, that's basically what I did :). Some of my colleagues recommended TurboGears as well, but I just don't think I have the time to get to that... Thank you for the feedback though! [Also, I forgot that my reddit name is different here, I wrote the article.]
Don't get me wrong, the post was not bad -- actually I'll have to check out your blog later when I get home. When I saw the easy to digest 'good' vs 'bad' points about each, I was maybe expecting more than a comparison between how easy they were to use. As you say, the *are* all great. The differences between web.py, Pylons, and Django stem more from their underlying philosophy than how good their documentation is or how hard they are to set up different environments. At the end of the day, they all have a learning curve since no documentation is perfect. For the record, I love Pylons the most. I use it mostly for work, speaking of which... I should do some while I am here...
What was the method used to convert the outline of the country into a horizontal line? 
Of course, Wikipedia is always right!
I see you are lazy:) in that case, let's go to Python's own website: &gt; Python is a dynamic object-oriented programming language 
Thanks, I appreciate the tips. My company is more .NET oriented, so I didn't want to dive too deep in python. Of course this is one of the more popular posts on the blog... Maybe I'll go back at some point and go deeper and add some code examples.
pg;dr
Citation needed!
You get the garlic, I'll get the stakes
If they don't, there's still Jython... and the 2.5 beta came out today.
I found this about six hours before gst. You're slippin', dude... but I didn't post it because there's really no information there. I wonder when they're going to say something on jython.org.
Just a few weeks ago I drawn up a draft for an oldskool-fashioned, Python-powered learning machine. However, I didn't dare suggest going Python all the way down, instead providing low-level wrappers at a reasonable level, with the hardware and the kernel interfaced with old-fashioned C modules. Userspace would however be pure python, with minimal built-in modules. Everything apart from the built-in interpreter would need to be coded by the user or imported from removable media. In fact, the system could be locked down and burned into a ROM for all intents and purposes as all changing data (and modules) is supposed to live on removable media. What a coincidence!
I once tried implementing software 3D rendering in Python + SDL (pygame). Python is just too slow for implementing an operating system, unless they use a lot of C-libraries or other trickery. Good luck, though, Python as a language is pretty good.
Instead of voting you down, I'm just going to, you know, talk about this. The current implementation of python may be slow (I'm not really sure), but python is a high level language with multiple implementations (CPython, PyPy, Jython). I've only used CPython but PyPy's "secret goal is to be faster-than-C which is nonsense." Ah, I just noticed you wrote _software_ 3D rendering. Yeah, I've never heard that Mesa with software rendering is fast and that is most likely in C!
I followed the instructions for Vim, but I'm getting the error "E117: Unknown function: pysmell#Complete"
Zope of 2008 is not the same as the zope of yester years. Zope people have progressed tremendously in terms of re usability, WSGI support (repoze.org), solid code base and packaging their libraries to be available outside their ecosystem (almost all zope libraries are available as python eggs). Yes. Django, Pylons, web.py are excellent choices if you are mostly dealing with CRUD apps. But, if you want to step into other, significant problem domains such as fine grained security, workflow modeling and non-relational data models, Zope is very much a contender. Django is going where Zope2 was going in circa 2000. Zope is just an umbrella *platform* now supporting many different development paradigms * Zope3 - components and reuse. the parent framework * Grok - convention over configuration * Repoze - WSGI flavored zope libraries * repoze.bfg - Zope without ZODB and with custom object traversal(eg: routes). One reason why so many people diss zope is because they hear that it is bad and they keep propagating the myth without understanding the spread and depth of the project. It is not going to be easy evaluating Zope like you did with web.py. Zope- the umbrella, shelters so many hundreds of packages that it can be daunting to make a snap decision. I would suggest grok and repoze.bfg to start with. Good luck. 
I see that often, `avoid zope` advice comes with absolutely no evidence. But, I can give an example of how Zope code is equal or better than code from other frameworks. http://code.google.com/p/grokpaste/source/browse/trunk/src/grokpaste/app.py That's a whole paste bin application written using Grok, the zope based web framework. Compare that code with any other framework. Do you see any code that is not pythonic in this? On the contrary, you will see that there is no Object-Relation back-and-forth that goes on in CRUD based web frameworks. 
I'm sorry but I have to ask, I don't quite understand this line in the doc: 2. The pysmell package in the PYTHONPATH that Vim uses: `python import pysmell` should work. Where am I doing this import? I don't get it .. Otherwise excited to try this out tomorrow :) 
In any python script, or the interactive python interpreted (open Terminal, run `python`) Basically python must be able to `import pysmell`
Ah ok that makes sense thank you, I was reading it TOTALLY wrong and it was messing with my head. Thanks :)
I've been wanting to try out a new version for a while now, since the latest official release (0.6) is &gt; 1 year old. This build is somewhat outdated (September '08), but I haven't been able to find any newer ones anywhere.
Dear python developers (of which I am one): please document the modules and utilities you've created with a few more words than "Grab It Here." A link to a source repository is, sadly, *not* always the answer. It will lead to frustration in cases such as this where the project is potentially cool.
In this vein, the most useful Python function I never knew about is enumerate, which makes iterating over lists where you want access to the list indexes trivial: a = ("blah","bloo","blee") for i,st in enumerate(a): print "%s is the %d'th element" % (st, i)
Nice. But please bring in a better code highlighting method. It was a bit difficult to read.
Yeah enumerate's great. Also, `(a, b) == zip(*zip(a, b))` (well not exactly as `zip` returns a list of tuples instead of a tuple of lists, but close enough)
Thanks! Please report tracebacks on Google Code - PySmell is by no means complete.
Are you referring to the blog post, or to PySmell itself? PySmell has documentation in a README, and github displays that README. I guess I could put that in Google code as well.
I did. I tried on my desktop where i have a ~/.vim/plugin/ directory (No 's') and it worked fine. I'll have to try my laptop again later.
Jython is slower than CPython and Pypy is vaporware that has been going on for years and we have yet to see where the fuck is the fast, real world implementation. Also, Pypy goal has misled a lot of people : they don't target faster than hand written C, they are targeting faster than the C (Python implementation) which ain't the same thing. They believe they can do a tad better than CPython which isn't spectacular considering the fact that the new generation of Javascript interpreters are faster than CPython, and so are good Smalltalk implementations.
Dear reddit commentors - please read module documentation before whining on reddit.
I owe you a beer.
What's with the dark background and black text? Hard to read, but looks interesting Edit: Haha! I'm amused. The next link on reddit was your site as well and I saw the new design. Both pages within 2 minutes apart .. kinda messed with me for a second :)
It's a similar concept to JSON, a protocol for sending data to Javascript clients.
This would be a security hole if logs are being generated from user input.
[citation](http://www.reddit.com/r/Python/comments/7aaoe/the_y_combinator_in_python/c063qui)
Possibly. The code uses repr() to generate textual representations of the Python objects being logged, so they should be properly quoted. Do you know of an edge case that could be exploited?
It only takes one user class using %s or string concatenation instead of %r in a \_\_repr\_\_ method and you're wide open. Python builtins are probably going to be OK, but its not something I'd like to rely on. It wouldn't be obvious to a new programmer down the line that merely writing some debug code like "def \_\_repr\_\_(self): return "MyClass: data=" + str(self.data)" he'd be opening up a security hole. 
Awesome. Thanks for the clarifications.
There any reason why you couldn't just log in CSV format, and then define the first field of a row to be the function name and the rest to be arguments? It's trivial to go from this to evalling functions: for row in csv.reader(open('logfile.txt')): getattr(logvocabulary, row[0])(*row[1:]) This solves the security problem, and gives you a logfile that you can parse and use from other languages. You can solve the state problem by making logvocabulary an object with methods instead of a module with functions. I'm very skeptical of using language mechanisms in any sort of persistent data after seeing numerous clusterfucks (some my own fault) caused by eg. Java Serialization as a communications protocol or ECMAScript code as a means of storing user data.
I've released 0.7.1, which fixes a nasty textmate bug and adds some better error reporting.
&gt; As for why it's not used in industry... it's not a "safe" language ah yes, that's likely the main reason. I guess that's why Java becomes so "mainstream". thanks for the clarification.
I briefly used virtualenv, or appengine-monkey rather. Offcourse it was my first attempt at getting a google app going. I managed to destroy most paths in my standard install on the machine I was working on with the relative path fixing stuff. :(
Hope it helps!
&gt;JIT to CLI I just thought of a very good name for that project...
I resisted the urge to add a "This article appears to contradict itself" to the wikipedia article. &gt; ...using limited computational power...The algorithm is computationally expensive... On top of that, it is a misnomer - this is a method or technique, not an algorithm.
Any plans on including something tackling BDD in Python? I've been playing with a little-known framework called pyspec (modelled after RSpec), but it's not ready for the test runner in Django as of yet. I'm a little uncomfortable with the organization of testing in Django. Has anyone run into this problem? Does anyone doctest views?
It has been tried at least three times.
http://gitorious.org/projects/django-sqlalchemy seems to be alive and kicking.
My recommendation: install Python so you can write the JVM and environment-hacking code in something other than Windows' batch-file language. This is not as silly as it sounds. :-)
Man, blanks in paths get my goat every time.
I love Python and all, but nothing on this list couldn't be applied to the granddaddy ORM, Hibernate. I know it's passe to admit that you use Java these days, but the planet is bigger than Python. :)
just use pylons instead.
how about putting it in a couple sentences ?????? not everything that's as obvious to you as it is to other y'know ?
Two things: * Standard \*nix directories don't come with spaces. Users have to create those. * *nix shell escaping actually works. Windows shell escaping is a nightmare.
Considering it is inspired by Hibernate I am not surprised.
I don't think it's a bad thing when the design of any piece of software begs/borrows/steals good ideas from another. I've never used Hibernate, but Check out SQL Expressions ( http://www.sqlalchemy.org/docs/04/sqlexpression.html ) for an example of a feature that sqlalchemy has that I doubt Hibernate does, because it relies on operator overloading to do some pretty cool tricks to generate RDBMS-specific SQL in a readable and concise way.
We've bundled Tomcat with the freely downloadable demo of our software for years, and it took years for the Tomcat startup.bat script to get to the point where we rarely get complaints about them. (Why it's more than a one-liner is not clear to me, but that's another issue.)
The problem is that you won't be able to use the django admin interface, or other apps that rely on Django's ORM. The tight coupling is the reason that the admin interface is so good, but at the same time it precludes the use of clearly superior components (and I agree SQLAlchemy is better)
The string was surrounded by quotes. That works just fine in unix. 
Meanwhile [the sqlalchemy branch](http://code.djangoproject.com/browser/django/branches/sqlalchemy) is dead since two years. I think there was also an sqlalchemy2 branch or something, but maybe my memory is failing me.
I use unittests for testing django views. The djano.test module has two helpful classes, Client and TestCase. You inherit from TestCase to write your unit tests, and Client is helpful for posting, and getting status codes from responses.
Django's ORM is fairly simpler and easier to learn. However, SQLAlchemy is definitely more flexible.
Yeah we're still working on it. It's not an easy task but certainly doable and something that will allow you to continue to use the Django Admin.
with....a herring
SA's designer looks to Hibernate for cues on how to solve Hard Problems, so there's definitely a debt there. But Python's dynamic nature makes doing all kinds of things easier than you can do them in Hibernate. Pretty much the whole Query API, for instance.
django-sqlalchemy *is* the sqlalchemy branch. It's just developed outside and will be merged when ready.
No, it's not. [django-sqlalchemy](http://blog.michaeltrier.com/2008/3/21/django-sqlalchemy) was created around December 2007/early 2008 and the sqlalchemy branch is dead since 2006. They also decided to go a different route for their integration than the one of the sqlalchemy branch.
It also depends how much you're even bothered by the admin tools (or by some other apps that are dependent on Django's ORM). Not everybody uses those. If you aren't using them, you can just use SQL Alchemy to create your models (in models.py or whatever) &amp; set up your session, and you should be good to go.
When I read "better Python", no statements, tail call elimination and fixed outer scope variable resolution (without nonlocal) suddenly came to my mind.
Which would then not be Python any more.
Why not? Because a little change in semantics that's fully backwards compatible, an optimization that's fully backwards compatible, and a change in semantics that could very well be implemented on a multi-expressionified lambda instead of an expressionified def to keep it backwards compatible? None of this would change what's good from Python (everything else from the semantics to the core language and syntax, from the object model to the standard library) or make it remotely incompatible with existing code; it'd change what's simply not good from Python. Python 3000 underwent far more significant changes, many of which are backwards incompatible. What I'm saying could very well be just Python 3.1.
1: Oh, but C:\Documents and settings\user\My Documents is so much easier than /home/user! Windows is so much easier to use! 2: Microsoft's usual retardation. The fuck up design and try to solve fuck up with more fuck up. See how it went: 1. We'll choose / for parameters. This is bad if you're going to copy UNIX (just some 30 years behind), but oh well. 2. We'll make COMMAND.COM accept dir/p like dir /p because it's so much easier on the user! I mean, you save like, one keystroke! Nevermind parsing will be forever fucked. 3. We'll get this awesome feature called directories! Oh but COMMAND.COM is stupid! We can't use / now! Bah, look at \, it's just like /, only uh... more easy! Nevermind it'll fuck everything up and make a C programmer's life worse. 4. Let's implement CreateProcess. But since COMMAND.COM is fucked and we still love that, let's make processes get the whole commandline instead of separate parameters. I mean, what could go wrong? 5. I know! Let's put spaces in directory names, this way users can write "my internet for my aunt.txt"! It's so much easier now! 6. Wait, we need to quote that! OH fuck, there's no concept of parameters because processes get the whole command line! Who would have thought that was a bad idea? And it goes on and on and on... It's simply Microsoft's style.
Seconded. Pylons and SQLAlchemy share a similar philosophy on doing things (let the developer choose etc.,)
I thought it was a twitter daemon :-)
Those would indeed be nice, but no-statements, for example, would mean that 3.0 code wouldn't run under 3.1. Python 3000 is deliberately incompatible and that won't happen again in the foreseeable future.
No-statements would be completely backwards compatible. Just like in any version of Python you can do: f(x) even though it's an expression (the result of which is simply discarded), in a supposedly statement-free Python 3.1 you'd be able to do: if x == 5: y = 3 else: y = 5 as you would in previous versions, even though it's now an expression, while the following would also be allowable: y = if x == 5: 3 else: 5 As for the scoping issue, there's a way to make that backwards compatible too! If you make every Python statement an expression (i.e. the sane thing to be), you'll end up with two function constructors: def and lambda. def can stay as it is, with the nonlocal semantics of Python 3000 for backwards compatibility and the people used to them, while lambda, which used to be one-expression, can be made to support several expressions and use different semantics on scope resolution (for example: take the outer variable if it exists; make it local if it doesn't). For example, the following would print 5 and fail (and y would stay unmodified): x = y = 5 def f(): print(x) y += 1 f() print(y) while the following would print 5 and 6: x = y = 5 f = lambda: print(x) y += 1 f() print(y) It can be argued that def f is different from f = lambda beacuse def f sets f.\_\_name\_\_, which helps in tracebacks, but the Python bytecode compiler can very well special-case &lt;variable&gt; = &lt;lambda&gt; and set the new function object's \_\_name\_\_ as well, so it's not really a valid excluse not to like it either. (And of course, a multi-line lambda should also support docstrings.)
Or you could go: y = 3 if x == 5 else 5 And I don't quite understand what you are doing in the second one :)
My feelings exactly. I'd even use the Django ORM for a non-web app because it is really simple and straightforward :) After browsing the SQLAlchemy documentation, I have two reactions: first, SQLAlchemy looks a lot more powerful/flexible, second, even though SQLAlchemy *is* more powerful, it isn't obvious to me what benefit you get from using SQLAlchemy over writing an adapter for the generic SQL interface - in my case python-MySQLdb. This way you have *total* control over the SQL that gets executed, and SQL is a pretty nice language anyway, so it isn't a drag.
SQLAlchemy doesn't remove any capability to create the exact SQL you want. It provides the functionality to map any completely hand-constructed SQL to higher level ORM functionality, in fact. There's many, many advantages which may not be apparent from just a browse of the documentation. You never hear people who actually *use* SQLAlchemy complaining that there's no benefit, for example. It's a paradigm that gives back the more it's embraced. 
Thanks, that was quite enlightening! Yes, I've often wanted if-expressions. If def is an expression then it's possible to say f = def g(): print 3 Is that right?
"No-statements" is a misleading title for this proposal; it implies that all existing statements are illegal. On the contrary, I believe Wiseman1024 is proposing that all existing statements are _promoted_ to expressions and can be used wherever expressions are called for.
&gt; y = 3 if x == 5 else 5 This syntax (`A if TEST else B`) is handy for simple cases like the one you describe. But because `A`, `TEST`, and `B` must all be expressions, you are limited in what kind of Python code you can fit in those positions. If all statements (print, def, assignments, and sequences of these) were to behave also as expressions, this constraint is removed. 
Sure, but because `def` already binds a name in the current scope your particular example isn't all that different from saying, simply, `def g()`. More useful is something like this: f = lambda: print 3 return True …which is also currently impossible not because `lambda` isn't an expression (it is) but because it can only contain a single expression in its body. Here I've used an indented scope to give `lambda` the ability to accept an arbitrary block of Python. Of course, this example is also vacuous (as you could simply say `def f(): …`) but consider that you can now toss complex, multi-statement functions around: map((lambda(x): print(x) a.append(x)), range(10)) This example (where each entry is printed before appended to some list) points up the place where this good idea bumps up against Python's block indentation syntax. How do we indicate where `lambda` ends and the next argument to `map` begins? 
This'd be a lot better example if it used [BeautifulSoup](http://crummy.com/software/BeautifulSoup) instead of regexes. 
What's wrong with lambda?
&gt; How do we indicate where lambda ends and the next argument to map begins? Simply following Python's syntax. If blocks start with Python's INDENT token, they end with Python's DEDENT token. Just like this: map(lambda x: print(x) a.append(x) , range(10)) I think this is far better than what we have right now, because well, we have nothing. Of course, since lambda is an expression, we could use parens to clarify it (but they shouldn't be necessary): map((lambda x: print(x) a.append(x) ), range(10)) As for all the statements I'd convert to expressions, I'd make if, for, while, with and assignments return the last inner expression evaluated, and assignments would incidentally work like they do in C. lambda returns the new anonymous closure, of course, but the result of lambda should follow the same rule, which means you could have written your first example as simply: f = lambda: print(3) True This is consistent with the current behaviour of lambda and backwards-compatible. def would stay as it is (i.e. if there's no return it returns None) for backwards compatibility.
Yes, I agree with that. This should be called promoting statements to expressions ("no statements" is just the effect I'd want to achieve). In fact, I've never understood why do we have statements. They're like the poor cousins of expressions, because they are almost like expressions, just they aren't and can't be used like them. You first build a flexible language where expressions can go anywhere, then go and restrict some forms "just cuz" (or rather, "just because of Fortran, Pascal, C, and the horde of crappy languages that followed this line"). Besides, statements are useless clutter in the language. Having both expressions and statements is like making right-handed and left-handed hammers, and, to make matters worse, the left-handed ones are made of plastic. Edit: Better wording.
Note: I love that my icon for this post is my Beer RSS icon. That rules.
Pretty cool. Very impractical. While it looks nice, I think that creating a class that wraps around dozens of lambdas might be a bit worse than using a single inline lambda.
Do functional programmers actually understand that garbage, or do they just like writing things that no one else easily understands? def chain(funcs, value): for func in reversed(funcs): value = func(value) return value And no, that's not perfectly equivalent, but that's a feature, not a bug.
Avoind? How do I do that?
So if you're such a 'wiseman' why don't you just do it and post the patches? Oh I'm sorry, you're a functional programmer. You only come up with the ideas - actual implementation is for lesser minds, yes?
More verbose, and it only matters to the interpreter—it doesn't tell the human anything. See also braces + indentation (braces for the compiler, indentation for the human) vs. indentation only (indentation indicating scope to both the compiler and the human). Compare: halves = map(lambda x: x / 2, numbers) to: halves = map(X / 2, numbers) A better question would be “what's wrong with list comprehensions/generator expressions?”. My answer is that if there's some function or method that requires a callable and not an iterable, `X` would still be helpful there and would still save the `lambda x: ` prefix. You might then argue that the “`from x import X`” statement offsets those savings, and I would agree; however, I think something like `X` would be a nice thing for somebody (not necessarily the Python maintainers) to include in their language. 
Python intentionally breaks it's lambdas, but I don't think this solution is workable.
I agree with everything but one: The import overhead is not an issue. It can probably be useful in your code more than once. Also, it can be part of a larger library of utilities. 
I agree that it's fun, but why are lambdas of all things to be avoided? If anything, you should use them *more*. And we should ask Guido to make them decent.
&gt; Oh I'm sorry, you're a functional programmer. You only come up with the ideas - actual implementation is for lesser minds, yes? Yes, exactly :D . On a more serious reply, I can do C if it really needs to be done, but I don't have enough time to pick up CPython and modify it like that, and more importantly, Guido would not accept my patches. IIRC somebody had already implemented or explained in detail how to implement tail-call elimination on CPython, but Guido disliked it. &gt; if you're such a 'wiseman' Actually, my stupid nickname comes from a long time ago, and not from "wise man" but from a Sailor Moon character (or even worse, as I took it after reading a lemon fanfic where he was mentioned). As you can see, it's not particularly pedant or cocky; all the contrary, I'm willing to admit it came from a stupid bishoujo anime. So shut up, thanks. I have enough of what I deserve every time I remember where did it come from.
It seems utterly convoluted to go `twitter -&gt; email -&gt; python` given that Twitters API is so absurdly simple. Even if it's supposed to be the "beginning of something much bigger" (from the comments), going though email just isn't the right way..
Should be "its".
Rebinding names in outer scopes when the same name is used in inner scopes is definitely backwards incompatible. As it happens I think nonlocal is a very good solution. 
It'd be backwards incompatible if it happened everywhere. But I said it shouldn't happen in def (or class), but in lambda, once it's extended to support several expressions, and statements are turned to expressions. Since lambda did not previously allow assignment, the way assignment is handled within lambda could very well differ from the way it does in def. This would keep backwards-compatibility (defs and single-expression lambdas without assignments) while offering new and improved semantics within the expanded lambda.
yeah, those won't happen either. Guido (and I happen to agree with him) thinks it would make for less readable code. There is nothing you could do with a multi-line lambda that you can't do with a named function.
There's nothing you could do with Python that you can't do with assembly, either. Let's abandon Python. As for readability, which is simpler and easier to read of the following? "Flat is better than nested" code: def UselessName(x, y): while ... return abc... return sorted(lst, cmp=UselessName) "We got over Fortran" code: sorted(lst, cmp=lambda x, y: while ... abc... ) Which version is easier to read and to follow, which one does not feature spaghetti code, and which one doesn't introduce useless symbols that weight on the reader?
Yeah you're right. The second one is ugly as heck. Doesn't that kinda defeat your argument though?
PyPy translated to C is less than twice as slow as CPython *currently* (without the JIT which is making real progress). That makes it about the same speed as Ruby... For a few specific benchmarks PyPy is already faster than CPython - mainly garbage collection related benchmarks as PyPy has a better GC. The goal of PyPy is to be substantially faster than CPython, and PyPy is very much not vapourware. RPython (a static subset of Python) can be compiled to *very* efficient C using PyPy - and might be suitable for the core of an operating system based on Python. The PyPy JIT is based on similar techniques to those used in TraceMonkey, which is a tracing JIT and theoretically more advanced than V8 (and benchmarks do put TraceMonkey in Firefox 2.1 faster than V8).
&gt; There is nothing you could do with a multi-line lambda that you can't do with a named function. I agree. However, as I think about it, the only reason that people want something as perverse as having only expressions instead of statements is that they want to be able to do Rubyesque blocks, because they are more readable in some contexts. So, instead of breaking the whole dang language for them how about we add a new keyword that works like this: &gt;&gt;&gt; lst = [1, 2 , 3] &gt;&gt;&gt; map(block, lst) ... block(x): #Failing to start this line with ... #the block keyword would be a SyntaxError, ... #since block was used before. ... print "blah" ... return x * 2 ... blah blah blah [2, 4, 6] Which will be equivalent to: &gt;&gt;&gt; def block(x): ... print "blah" ... return x * 2 ... &gt;&gt;&gt; lst = [1, 2 , 3] &gt;&gt;&gt; map(block, lst) blah blah blah [2, 4, 6] Similarly, `sorted`: &gt;&gt;&gt; sorted(lst, key=block) ... block(x): ... print "blah" ... return -x ... blah blah blah [3, 2, 1] So, I do think there can be readability advantages to putting the function body after the call, but yeah, removing all statements is dumb and making a multiline lambda that fits inside of existing expressions is a fool's errand. 
Yeah, so instead of using WSGI it uses the crappy mod_python.
Yeah, but it got a release out of the door :) (haha, yes, me again)
&gt; Ok, so what problem does a hacker’s framework solve that a framework like Django doesn’t? According to some of the Pylons developers, their framework is geared to solve 80/20 problems. Most people—80% of people–want to build blogs, and CMS-type applications. And for that 80%, Django works just great. Of course, the other 20% is where Pylons comes in to play as a “hacker’s framework.” ... ... ... &gt; In this article we dive into building an AJAX blog using Pylons.
I don't get it....what exactly does that script do ????? &lt;python newbie/&gt;
It serves up that site based on some templates and markdown content. The only things that make it note-worthy are the facts that it can be tracked with Git (and thus branched, cloned, and reverted) and is implemented in 100 lines.
thanks, but it does NOT listen to http right ?
No... it's implemented on top of Apache and mod_python publisher. A [basic Python web server](http://fragments.turtlemeat.com/pythonwebserver.php) isn't that difficult though...
If you don't want to use the Apple build of Python, but can't be bothered making your own, MacPorts has packages for every version and also has packages for all the common libraries. Easy.
The second one is the better version. Firstly, you're not polluting the namespace with crap symbols, and you have to keep one less symbol in mind. Second, you don't alter the read flow: you can read the code from top to bottom and understand what it does without going backwards for a reference. Third, it's more compact, and fitting more lines of code in a screen is one of the reasons commonly used to defend Python's indentation-sensitive syntax.
&gt; the only reason that people want something as perverse as having only expressions What!? The "perverse" thing is to have expressions and statements, an expression's poor cousin which is just like expressions but isn't; left-handed hammers into the language, etc. If you think this is perverse, go back to assembly; you'll like it, as it has no expressions, everything is a nice statement. Alternatively, try the original Fortran, that's where the design wart you like probably came from. &gt; they want to be able to do Rubyesque blocks Nope, I simply want lambda-esque lambdas. Also, the syntax you propose is needlessly complicated, look at my other posts for a suggestion on simply fixing lambda (and def). &gt; removing all statements is dumb Why. No question sign because I don't expect a sound reply though; you will probably say you like statements just cuz (nicer/prettier/cuter/whatever), and I'll probably reply you should use assembly again. &gt; making a multiline lambda that fits inside of existing expressions is a fool's errand. Why, again.
FWIW, I really like this proposal. Thumbs up.
&gt; The "perverse" thing is to have expressions and statements `x = for i in range(10):` is perverse to the spirit of currently existing Python. &gt; If you think this is perverse, go back to assembly; you'll like it, as it has no expressions, everything is a nice statement. Alternatively, try the original Fortran, that's where the design wart you like probably came from. Strawman burgers with a side of name-calling fries? Yum. &gt;Nope, I simply want lambda-esque lambdas. To do what? Please give examples of things that look nicer with "lambda-esque lambdas." Your previous `sorted` example fell flat, because it butchered the indentation—as all multi-line lambdas will do by design. &gt; Also, the syntax you propose is needlessly complicated, look at my other posts for a suggestion on simply fixing lambda (and def). Maybe. It could definitely be improved. &gt; Why. No question sign because I don't expect a sound reply though; you will probably say you like statements just cuz (nicer/prettier/cuter/whatever), and I'll probably reply you should use assembly again. Because if you remove statements it's not Python. Do you even like Python syntax? If not, I don't see the point of your making proposals for Python. If so, you should realize that making everything an expression would gut Python. &gt;&gt; making a multiline lambda that fits inside of existing expressions is a fool's errand. &gt; &gt; Why, again. If nothing else, because [Guido has promised to reject all multiline lambda proposals][1]. In a broader sense, because his criticism are correct. [1]: http://www.artima.com/weblogs/viewpost.jsp?thread=147358 
Maybe it could be slightly improved: &gt;&gt;&gt; sorted(lst, key=def(x)): ... print "blah" ... return -x ... blah blah blah [3, 2, 1] Bear in mind, this would have to be very limited in where it could appear, because you couldn't use it in the expression at the start of a for-loop, for example, without causing chaos. Also, having two anonymous `def`s in one expression would need to be a syntax error.
Only problem with that is the way MacPorts' Python doesn't include the full standard library, so that you go to use some module that's part of Python and discover it's missing and you've got more packages to track down...
Dang it. I was hoping for a Python scripting component for the [Open Scripting Architecture](http://developer.apple.com/documentation/AppleScript/Conceptual/AppleScriptX/Concepts/osa.html), so you could call AppleScript events directly from Python. Maybe I need to write it myself sometime.
Try [this][1]. Or you can use [appscript][2]. [1]: http://developer.apple.com/documentation/Cocoa/Conceptual/RubyPythonCocoa/Articles/UsingScriptingBridge.html#//apple_ref/doc/uid/TP40005424 [2]: http://appscript.sourceforge.net/
The Python header on Sub-Reddit obsures the first entry. Problem started with the introduction on new toolbar at top.
I would upvote this... but it's obscured by the image! Aaah!
I just sent an e-mail to them using feedback :)
fix it!!!
as a workaround why doesn't the owner of this sub-reddit just upload a smaller version of the image.
What was the outcome of the 'shouldn't the logo point to reddit.com' post?
\[Python] is a user-created subreddit, so direct-messaging one of [the moderators](http://www.reddit.com/r/Python/about/moderators/) may be more effective than emailing the Reddit admins.
I would like that too
&gt; I can use Vim to post to my blog! YAY! &gt; It also means no comments can be left by users. Which also means you don't have to worry about spam comments!
This is now the top story in /r/Python and therefore blocked out by the header.
The commenter is right, if you really need this, use the Borg pattern, not Singleton.
But this only happened after the layout switch, so the Reddit admins should check out what's causing this. I still say the new menu bar caused more harm than good. 
Irony!
Inevitable!
Badly written custom CSS.
While our dear moderator is at it, restore the Reddit link in the header. It's ticking me off, because there's no other link in such an obvious place.
Kill this bullshit with fire. Here's the "singleton pattern" for Python: variable = value (Do it in module scope. The value can be an object. Like a class. Or an instance of a class you rebind when instancing. Or whatever!) And please, *please*, ***please*** stop fucking with Python. Design patterns crap doesn't belong here. That's for toy object-oriented/obsessed languages such as Java. If you keep following a particular type of pattern in Python, you're doing it wrong because you're failing to generalize it properly. Python allows this because it has lexical scoping and first-class functions (albeit with a shitty syntax - not the indentation, but the lack of a multiline lambda that forces you to use def). If you keep trying so hard to turn Python into Java, I'll stop writing Python and move to uh... Common Lisp (fugly Lisp-2 though) or some Lisp-1 variant, and not because of the language, which I generally like (except for the stupidity of having statements and the lack of tail call elimination), but because of *the community*, whose stubborn **hatred of functional programming** and good abstraction features and their numerous **closet Java lovers** are getting out of hand. Sometimes my bullshit filter gets overloaded.
Although, to me at least, it seems like Pylons is a lot harder to get going with. Requiring a lot of manual tweaking just to get started and getting a basic framework up. Any tips on that? I would love to use Pylons in theory, but Django just seems so much easier.
There is no right answer to this. At least any that I can write in a comment box :p However, If I may hazard a "rule of thumb".. go with django if you are new to python and you are trying to build a CMS/CRUD heavy application which mostly involves putting data in and taking it out. Django is easy on the newbies and has excellent user stories for CRUD/CMS apps. Any thing more complicated and/or has a strong requirement for loose coupling, consider other python frameworks like pylons. 
Hi, I'm BioGeek, the one who created the Python subreddit, and hence moderator. The redditor responsible for our custom CSS is [sebastianavina](http://www.reddit.com/user/sebastianavina/) however. I'm no CSS wizard, so I sent him a message asking to look into it. In the meantime, I'll see if I can temprarily solve the problem by uploading a smaller version of the image or somesuch. I'm not sure when sebastianavina will see his message, so if someone with enough CSS knowledge is around, send me a personal message, and I'll grant you administrator access. Edit: uploaded a smaller logo (looks ugly like hell now), but there are still some problems with the tabs hanging over the title/first submission. Maybe I'll restoreto the default CSS as a temporary fallback. Edit 2: Someone volunteerd to fix the CSS problems. Stay tuned... Edit 3: [nevare](http://www.reddit.com/user/nevare) fixed the remaing CSS problems. Thanks for that! I hope sebastianavina can restore the CSS back to something that resembled his design.
&gt; I'll grant you administrator access. IT'S A TRAP!11
[did so, but unfortunatly it didn't worked out quite right](http://www.reddit.com/r/Python/comments/7ch3q/fix_the_python_header_on_subredit/c06agxc)
yeah the problem is that the css use absolute positionning.
&gt; and fitting more lines of code in a screen is one of the reasons commonly used to defend Python's indentation-sensitive syntax ????? Have you confused Python and Perl? Alternatively, can you give one example on the web of someone praising Python for being vertically shorter?
ok it's not perfect yet but at least you can see everything. I'll do something nicer now.
OK. Thanks for fixing things so quickly.
It looks good under firefox and opera but not perfect under konqueror (and so probably not perfect under chrome and safari but I couldn't try), I couldn't try ie either I don't have it at home. To make it work under everything the most simple for me would be to start back from the default css. But if sebastianavina cares to fix it the way it is, it's ok with me. For now I only changed a few lines and I have a backup of the old css if someone wants it. Anyway that's for tomorrow it's time to go to sleep here.
Several of them here: http://www.google.com/search?hl=en&amp;q=python+%22fit+more+code%22&amp;btnG=Google+Search&amp;aq=f&amp;oq=
50 hits, and of the top 5, only one was actually talking about that being an advantage of Python. Python is all about readability. Sometimes that means keep it short, but many times, it does not. The indent-dedent thing was stolen from the ABC language and wasn't meant to be "shorter" but to get rid of wars about K&amp;R brace style vs. whatever while also keeping it both easy for newbs and readable. 
This is a cool trick, but it isn't new: http://zesty.ca/python/thunk.html implemented the same thing a year ago *without using lambda*. I like erezsh's version better on account of not having ugly nested defs.
True, although there might be a problem with Martelli's version of Borg, since it only works with classic classes, which are gone in Python 3. I dunno, I don't see why you don't just put `the_instance = MyClass()` in your original module, and then anywhere else just write, `from module import the_instance`. 
You know your favorite language is doomed when talk starts about implementing patterns in it. 
Been using this one at worky all morning. Oh RenderMan, I love you ever so much... Now if only I knew what I was doing with `__getattr__` and pickling, I'd be set.
Will you please stop greenspunning and implement a mini-Lisp at once?
Okay, I don't think I need to tell why I'm asking this. While Python supports functional programming to a reasonable extent, there's a widespread stubborn hatred of functional programming and anything related to it in the Python community (probably starting with the BDFL), and any proposals for extending Python into something more useful for functional programming (without taking out any of the other ways to use Python, of course, that's the good thing about multi-paradigm languages) is received with ruthless hostility and perceived as an attack against Python. The Python community is generally a good one (especially compared to others), yet this generalized hatred for functional programming and anything related to it seriously turns me off. While Python is currently my overall favourite programming language (considering the quality of the standard and non-standard libraries, support, and features), I'm currently considering putting my effort and time investments somewhere less hostile to functional programming. Hostility to functional programming is a form of hostility to abstraction, theoretical correctness and cleanliness. I hope I'm wrong, but this seems like pulling the PHP way. Consistently meeting proposals such as tail call elimination with nothing short of "that's liek difficult to understand d00d ha ha no freaking way" doesn't say much about the health of this community; in fact it looks like something straight out of the average PHP documentation comment.
&gt;that's the good thing about multi-paradigm languages I don't think the BDFL is interested in creating a multi-paradigm language. He's much more interested in a 'one obvious consistent Pythonic way of doing everything' language, and that one way historically hasn't been functional.
Well I am not really part of the Python community, but I am a redditter and this gives me a bit of exposure I suppose. From my point of view the biggest issue is the way Function Programming zealots approach the table. There is a pre-existing assumption that everything functional is good and everything imperative is bad. Obviously this is absurd, yet in so many functional-programming articles that flow through reddit there seems to be a subconscious bias toward this line of thinking. Viewing it from a pragmatic point of view functional programming hasn't really delivered for me. Recently there was a mario-brothers clone written in Haskell (I think) that was hailed as a major achievement. I don't want to be negative towards the authors of that, but it really doesn't seem like a fantastic achievement. In reality it seems to reveal how ill suited purely functional programming is for real world projects. Of course to swing the other direction and disregard everything functional as academic bluster which is not useful at all in the 'real world' is equally absurd. The fact is that there are a huge amount of things I have taken from functional programming. I program in C++ primarily, although I experiment around with D and it's functional features are the most appealing reason for me to do so. 
Then instead of getting the best possible language in its domain, he'll get the most Pythonic language, for an arbitrary and sometimes bizarre definition of Pythonic.
I see lots of functional programming in python. in fact more than in many other OOP equipped languages. I think its due to the clear namespaces. in php people tend to use classes or objects as a kind of namespace. in python I usually see modules filled with useful functions. haven't noticed any hostility.
Functional programming is not about using functions instead of classes; it's about a general collection of features and abstractions. You can read about the most common ones here: http://en.wikipedia.org/wiki/Functional_programming
While functional programming is undoubtedly purer (which is a criterion of good) and academically correct (which is another criterion of good), and it's more useful for specifying and reasoning over procedures and abstractions, I agree that it's weak for real-world projects (in spite of considering it a superior programming technique). That's why I want a good multi-paradigm programming language. Build the skeleton, the I/O and (as much as I hate this word) the glue on an imperative framework, then implement the application logic in a nice, provable, correct functional manner, and share a powerful object system such as Python's across them. This is my vision of how a real-world application in Python's domains should be built.
&gt; Recently there was a mario-brothers clone written in Haskell (I think) that was hailed as a major achievement. When I saw that, I didn't think, "Wow, somebody wrote something with Haskell!", I thought, "Wow, somebody wrote a Mario-brothers clone, and happened to use Haskell." As the Haskell community grows, more and more useful, "real-world" projects will spring up. These achievements are not amazing because Haskell is such a hard thing to program in, but because they prove that Haskell **can** be used to do things that many assume would be hard to do, because they are hard to do in most languages, but aren't hard to do in Haskell.
Purer is a criterion of good? You lost me there.
You would like to know why people hate functional programming.. I would like to know what the hell is wrong with python programmers that they feel the need to constantly attack PHP. It truly makes no sense whatsoever. No other group of programmers (other than python coders) attack any other language, they way they do to PHP. The only conclusion I can come to is it's because of jealously. Python coders wish more people used python instead of PHP.. The best part is, despite my having asked/commented in logical way.. I already know this reply will be modded -20 within an hour, which does nothing but proving my point.
There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you're Dutch. 
I think it's because we've all used PHP and when we think back on it, we think, "Sheez, why did I waste time on that?" There's a bit of shame at how bad our PHP code was mixed in with the conviction that you can't possibly write good code in PHP (since I didn't, QED). Plus, just as a matter of fact, PHP is a very poorly "designed" (to use the term loosely) language. Which gives us an element of fact to hang our hate on.
Don't you know? At the Pearly Gates St. Peter's job is to turn away those who can't write a factorial function that doesn't use variables. Being pure is a matter of grave importance for your soul!
You know, I've coded in VB.NET before, I think it sucks and wouldn't use it, but.. I also never talk about it. I don't like it, I move on and learned something I did like instead. Seems like the same thing happens in the Postgre community as well (now that I think about it most python users are postgre coders), and they never stop railing against mysql.. I never hear mysql users attacking postgre, or complaning about how it's far more complicated and more difficult to set up or learn.. Why the dwelling and hate? Also, saying you can't write good code in PHP is just false. 
&gt;Also, saying you can't write good code in PHP is just false. I think you need to attend to my argument more clearly: 1. I tried to write good code in PHP. 2. I failed. 3. Therefore, no one can write good code in PHP. ##QED ∴ It's logically indisputable. 
I think it's largely in part that no one is going to defend PHP. If you bash perl in a python group, you're going to get replies claiming perl has it's place. You have to be stupid to defend PHP.
I like PHP. I like Python. Both have their place. PHP is good for rapid development. Python is good for well organized development. I can bang out a PHP site quite a bit faster than I can a python site with identical capability.
 Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren't special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you're Dutch. Now is better than never. Although never is often better than *right* now. If the implementation is hard to explain, it's a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea -- let's do more of those! 
&gt; ...more and more useful, "real-world" projects will spring up. &gt; These achievements [...] prove that Haskell can be used to do things that many assume would be hard to do, because they are hard to do in most languages, but aren't hard to do in Haskell. You're talking as if the future has already come. And no, writing a Mario clone isn't particularly hard in most high-level imperative languages.
Can't fight that logic.
Besides lack of support for tail calls, which is the only example you give, what makes you think that python doesn't support functional programming? What proposals do you refer to that have been shot down? My POV: Python spports FP just fine as long as it doesn't conflict with python itself. Remember that Python has: * list comprehensions * generators * coroutines * filter map and reduce built-in * real first-class functions with closures (albeit those can be a bit quirky) All of those things point to no fundamental language bias against FP.
"Hostility to functional programming is a form of hostility to abstraction, theoretical correctness and cleanliness" I don't think the community or the BDFL are hostile to these things, more generally conservate and hostile to certain coding styles. The Python way is to prefer easy digestability over things like proper lambdas, and reduce. Lambda is crippled to stop people writing ugly code. Reading the occasional blog post with ugly Ruby code makes it easier to understand why this choice was made. I would personally prefer more support for functional programming, but I sort of understand the logic of not accepting functional features without carefully judging the trade-offs with the 'pythonic' way.
I note that he's using `getopt` for option parsing. Is there any reason to use that instead of the higher-level `optparse`? * `optparse`'s syntax is declarative and clearer (even if more verbose) * `optparse` is more flexible (the iteration and the pair of boolean tests could have been replaced by a `store_const` option with a `const` of `logging.ERROR` and a `default` of `logging.INFO`) * `optparse` gives a `-h`/`--help` switch essentially for free, especially if a useful `help` kwarg is provided for the various options * `optparse`'s option access is much clearer (e.g. using the `store_const` above he could have something along the lines of `log.setLevel(opts.verbosity)` instead of the 9 lines he uses to process arguments and set verbosity. edit: his main could be rewritten thus with optparse: from optparse import OptionParser parser = OptionParser() parser.add_option('-v', '--verbose', dest='verbosity', action="store_const", const=logging.ERROR, default=logging.INFO, help="Logs everything") if __name__ == '__main__': options, args = parser.parse_args() log.setLevel(options.verbosity) # do processing 
its not subconscious at all. The creator of Clojure calls OOP the "spaghetti code of the 90/2000s".
I agree it's not, but many would assume it would be harder to do in Haskell, because games are inherently very stateful. My point was that it's not, as that clone demonstrated.
&gt; Beautiful is better than ugly. &gt; Simple is better than complex. &gt; Flat is better than nested. &gt; Readability counts. &gt; If the implementation is easy to explain, it may be a good idea. And functional programming helps with all of these goals, especially if (*gasp*) you optimize tail calls! Recursion is *beautiful*.
You need a single page with a form on it that a user fills out and it returns a thank you message. It might need to scale to a million users in a few days. What would you build it in? You would need a very, very good reason not to say php. (And I say that as someone who hates php).
See also: [notes written up by the primary author of the model system](http://code.djangoproject.com/wiki/DevModelCreation).
Another great resource, it doesn't appear to have been updated since qs-rf, so it ignores some of the inheritance stuff. Still a great resource though.
Well, mostly there seems to be resistance to turning Python into Scheme, because, well, if you like Scheme it's already there for you to use (I'd make a joke here about how a future revision of Scheme should turn non-tail-recursive functions into a compiler error, but I'm afraid somebody would actually think that's a good idea). Oh, and for the record: I'm against tail elimination in Python simply because it seems inevitably to lead to people writing obfuscated, hard-to-read code simply for the sake of having a tail-recursive function, and Python is, well, not about that: it's about clear, readable code. But as others have pointed out, one of the biggest problems, to me as a Python programmer, is the zeal with which FP folks approach this; it's not a case of "we want the ability to do more FP stuff in Python", it's "FP should be the one and only way in which programmers are allowed to write code". You yourself are leaning that way with your straw-man "hostility to abstraction" swipe (hint: OOP is also abstraction. It's _different_ abstraction than FP, but it's abstraction nonetheless). Meanwhile I'm quite happy to take advantage of closures, comprehensions, coroutines, function composition and all the other things Python lets me do, without thinking that has to be the _only_ way I think about or write code. So maybe the problem is in yourself and not in Python :)
It is. It'll always yield better results and be the easiest to modify (which happens both while you work on a project for the first time, and when you maintain it), and the easiest to understand and reason over it once it has been written, because it's as close to perfection as possible (as abstract and generalized as possible, as simple as possible, as minimal as possible).
And he's right, in the proper context. The problem is not OOP, it's inheritance. When you abuse an inheritance system (something which is like saying "hello" in Java), you end up with code that's very difficult to follow and maintain. You have to keep jumping from one module to another to get a glimpse of an implementation. It becomes like a puzzle, where you code everything so that it fits with functions inherited from 5 classes ago.
Don't languages that have more than one way to do something appeal to more people and thus service more requirements and applications in the long run? 
Have you checked out F#, or should I call it OCaml.NET? It does both OO, imperative, and functional. I like the multi-paradigm languages, although they are harder to learn as there is more than one way to do anything. 
Sounds like you just described F# or Scala
You mean values, not variables.
Besides tail call elimination, which could be added but and it's not being rejected because it can't be done, but because it's deliberately unwanted, I have: - Guido's stubborn quest to make lambda useless by not accepting statements inside it, or by not making statements expressions. He even wanted to remove it at one point, but he saw it was pressing too hard. - The closures are pretty real, but the way scopes are handled is inconvenient. It could have been fixed in so many numerous ways so long ago, but it was always an nth-priority. The chosen solution, nonlocal, is acceptable but suboptimal. Expanding lambda into a def with better semantics would have been much, much better, and even more backwards-compatible, since it wouldn't require the introduction of a new keyword. - The "flat is better than nested" philosophy is keeping the language from becoming more expressive. In particular, it still has statements. They need to die. I've been talking somewhere else in Reddit about how we could have Python be fully backwards-compatible while turning its current statements (a design wart from the age of Fortran) into expressions. There are countless advantages to that, which is basically lifting a limitation, but I've seen the community even wants an arbitrary limitation to stay just so that you cannot write more flexible code. - filter, map and reduce? You're pointing out a weak spot, not a strong one. First of all, Guido actively discourages their use in most cases, and he's moving reduce out of __builtins__ (he also expressed his dislike of it many times). - More importantly, Python ships with an extensive standard library to handle text in many ways, lots of class utilities, lots of pretty much everything, and almost no FP-related utilities in comparison. The FP utilities have been neglected since ever. Where are promises, futures, foldr, foreach/repeat/other functional loop constructs, scanl/r, flip, prog1, progn, conses, memoizators...?
Python is also my favorite language and what I miss the most from functionnal programming are - tail call optimisation (I think I heared people didn't wanted it ... but maybe it was just never implemented ?) - more powerfull lambdas - implicit return of the last executed line (it makes you feel you are in a functionnal language) The last two points are solved in ruby, but they didn't implement tail call optimisation either.
I know, the Zen of Python. &gt; Beautiful is better than ugly. Yay, an argument for functional programming. &gt; Explicit is better than implicit. Yay, an argument against Perl. &gt; Simple is better than complex. &gt; Complex is better than complicated. Yay, unless Guido thinks Fortran is simple and Scheme is complex. If so, I suggest he tries assembly, he'll find it the simplest language ever. &gt; **Flat is better than nested.** Bingo. This is a fundamental flaw of Python's philosophy. This is so wrong I don't know where to start. This is an argument against abstraction, against flexibility, against expressivity, and against anything that's good in a programming language. I'm starting to think I should take my previous suggestion seriously, and write Python about the wonderful language assembly which has no nestable elements. &gt; Sparse is better than dense. More arguments against Perl. &gt; Readability counts. An argument for functional programming and nesting without requiring you to jump when reading code. &gt; Special cases aren't special enough to break the rules. Okay, at least he got this right: he doesn't want Perl. &gt; Although practicality beats purity. Meh. Only to a certain minimal extent. And it's disgusting and shameful when it does. It shouldn't be written here, it may spoil people. &gt; Errors should never pass silently. Yes, please. &gt; Unless explicitly silenced. You mean, like PHP's @ ? (j/k) &gt; In the face of ambiguity, refuse the temptation to guess. Of course. I think I fully agree with Python's syntax philosophy (except for the little bit where less powerful cousins of expressions exist for no reason, serving only as a left-handed hammer since you already had expressions and they were much better). &gt; There should be one-- and preferably only one --obvious way to do it. I used to think this is a good idea, but I'm seeing it leads to "Pythonic", and "Pythonic" leads to a sub-optimal language. &gt; Although that way may not be obvious at first unless you're Dutch. I'm not worried if it's not obvious. I'm worried that it's not good. &gt; Now is better than never. &gt; Although never is often better than *right* now. Agreed. &gt; If the implementation is hard to explain, it's a bad idea. &gt; If the implementation is easy to explain, it may be a good idea. Yes! And if the explanation *is* the implementation, you've achieved Satori. In other words, you're programming functionally. Now let's pay proper attention to FP, please. &gt; Namespaces are one honking great idea -- let's do more of those! Yes, but don't lose the focus: it's **lexical closures** the number one honking great idea.
From my other post: &gt; There should be one-- and preferably only one --obvious way to do it. I used to think this is a good idea, but I'm seeing it leads to "Pythonic", and "Pythonic" leads to a sub-optimal language. &gt; Although that way may not be obvious at first unless you're Dutch. I'm not worried if it's not obvious. I'm worried that it's not good.
&gt; Well, mostly there seems to be resistance to turning Python into Scheme, because, well, if you like Scheme it's already there for you to use Scheme doesn't have Python's object system, syntax, standard or third-party libraries. &gt; (I'd make a joke here about how a future revision of Scheme should turn non-tail-recursive functions into a compiler error, but I'm afraid somebody would actually think that's a good idea). Fuck! I'm writing an SFRI for this tomorrow! :) &gt; I'm against tail elimination in Python simply because it seems inevitably to lead to people writing obfuscated, hard-to-read code simply for the sake of having a tail-recursive function, and Python is, well, not about that: it's about clear, readable code. I'm against iterative loops in Python simply because it seems inevitably to lead to people writing obfuscated, hard-to-read code simply for the sake of writing it imperatively, and Python is, well, not about that: it's about clear, readable code. As for the approach of FP people, I don't think so. They might sound a bit arrogant sometimes, but it's no ill intention: it's actually confidence, developed from the broad understanding that functional programming grants you about how you should do things. Regardless, every proposal or comment I've read from the FP folks (including my posts, since I'm probably included in that group) is about extending Python so that it also allows a functional approach, not about "let's take Guido's favourite feature out huh huh". How would any of what I suggest hurt anything that has been done in Python so far? And OOP is an abstraction, of course it is, and I like it, and I miss it when I'm using Scheme. Abstractions are a honking great idea -- let's do more of those! &gt; Meanwhile I'm quite happy to take advantage of closures, comprehensions, coroutines, function composition and all the other things Python lets me do, without thinking that has to be the only way I think about or write code. So maybe the problem is in yourself and not in Python :) If I weren't doing this, would you think I'd even bother to use Python? The only reason why I'm sticking to it is because it's the closest language to my ideal multi-paradigm programming language with a good first and third-party library and support. If Python and Scheme were breeds of dogs, I'd have them mate and create the best, cutest, smartest dog ever. Think of crossing a Python with this: http://lispers.org/ . Bah, simply adding a bit of the lovely secret alien technology to the current Python would make it absolutely lovable.
This is exactly what I've been looking for.
&gt; I don't think the community or the BDFL are hostile to these things, more generally conservate and hostile to certain coding styles. Which is exactly what I've said. &gt; Lambda is crippled to stop people writing ugly code. Okay. Then let's cripple classes, inheritance, operator overloading, if-elif sequences, list comprehensions, regular expressions, string manipulation, template languages, and pretty much everything too.
&gt; No language can be perfect for everyone. I tried to make Ruby perfect for me, but maybe it's not perfect for you. The perfect language for Guido van Rossum is probably Python. — [Matz](http://www.artima.com/intv/rubyP.html)
This goes back to my point: if you don't like the pythonic style, don't use Python. I guess what you want is for someone to take the Python library and to adapt it to work with a Lisp-like language or something. But if that's the goal, why not just use Clojure which has the whole Java library? 
cute
&gt; (as abstract and generalized as possible, as simple as possible, as minimal as possible). I think that that works against the goal of being "as readable as possible," which is Python's goal. Even now that I know what the Y combinator does, it still makes no sense to me when I read it. Guido similarly has moved `reduce` into a library, because he thinks it kills readability. And that is the goal. Not speed (try C or C++), not purity (try Haskell), not flexibility (try Lisp), not chunky bacon (try Ruby). All languages are optimized for different things, but you don't seem to want what Python is offering. Which is fine, but try something else, yeah?
&gt; I would like to know what the hell is wrong with python programmers that they feel the need to constantly attack PHP. I'm a long-time PHP user, and I know of its strengths and relative strengths. I still think one can write acceptable code with it, provided you build a good framework to interface the standard library. What I'm attacking, though, is that the language seems to be designed by inexperienced programmers who are in no position to design a programming language and keep coming up with crap and have little idea of how to implement a proper language and standard library, and what's even worse, a horde of PHP "programmers" who write the worst pieces of shit my poor eyes have ever seen, making use of every single bad practice I can think of with whatever PHP gives them. To make matters worse, this horde of Pretty Horrible Programmers is actively encouraged to keep working this way. &gt; No other group of programmers (other than python coders) attack any other language, they way they do to PHP. I attack Java more than I attack PHP. I enjoy writing PHP more than I enjoy writing Java. It's just that I know how PHP is the butt end of jokes here, and I wanted to show how some Python programmers are gravitating towards what they supposedly loathe. &gt; The only conclusion I can come to is it's because of jealously. Python coders wish more people used python instead of PHP.. Yes, but please, not the idiots who use includes like functions, work in the global scope, constantly enter and exit PHP in the middle of anything, don't indent code, do all sorts of crap with extract and variable variables, completely misunderstand the type system (especially the concepts of truth and existence), write PHP like they write C, and so on.
&gt; I think that that works against the goal of being "as readable as possible," Aren't you confusing readability with experience reading? After reading SICP and working with Scheme for a while, I find tail-recursive functions as easy to read and understand than loops (actually, easier in some cases, more difficult in others). I definitely find decorators implemented with closures far easier to read than those implemented as functors (a class with \_\_call\_\_). I find lambda easier to read than def Lulz() [...several lines below...] Lulz. I definitely find closures easier to read than the stunts you have to pull to avoid it. I seem to find every functional programming feature I get used with easy to read once I get used with it. Pretty often, the impression that imperative code is easier to read is just prejudice and trauma from having suffered a Fotran-derived language. I suffered it myself, but I'm getting cured. And I'd like to ask people who learnt to program with Scheme first what they find easier. &gt; All languages are optimized for different things, but you don't seem to want what Python is offering. I love what Python is offering! That's why I'm using it. I just want it to be even better by pursuing its goals even better.
&gt;don't indent code I doubt you'd get far in python if you don't indent.. ;)
I have, but I'd rather take OCaml for now, at least until we get an F# compiler that doesn't depend on either .NET or Mono.
&gt;Which is exactly what I've said. To be clear, I'm saying they're not hostile to "abstraction, theoretical correctness and cleanliness" per se, but the possibility of features enabling those things leading to unpythonic code. &gt;Okay. Then let's cripple... I'd prefer proper lambdas, but if I kinda squint, I can see Guido's logic in forbidding them, since named functions accomplish the same thing. To make the distinction clear, though perhaps it is a small distinction: Python is not especially hostile to functional ideas - but it is hostile to the kind of hard-to-decifer code that the functional style can produce, especially if there is a fairly straightforward alternative. Again, I'd like Python to be more functional for certain situations, and is the reason I'm sniffing around other languages. But I think 'hatred' is far too strong a word to describe the Python attitude to functional programming. In this light, Guido's rational for removing reduce seems reasonable (though arguable), "almost every time I see a reduce() call with a non-trivial function argument, I need to grab pen and paper to diagram what's actually being fed into that function before I understand what the reduce() is supposed to do" http://www.artima.com/weblogs/viewpost.jsp?thread=98196 Edit: on further reflection, and reading your other replies, I pretty much agree with you. The fear of introducing functional concepts in the python community is exaggerated. However, this natural conservatism may be part of what has made Python the otherwise great language and community it generally is.
I'm seriously considering writing a Lisp compiler for CPython myself. (A Lisp-1 with proper tail recursion, of course.) Something like Lython or Psyche, updated for today's Python. I think those were awesome ideas, and I'm saddened to find they're abandoned. If only I had more time. I have to choose between doing what I want to get done, or doing what I'd like to have to do what I want to get done. I'm also considering moving to Clojure once it's a bit more mature, or perhaps making a wilder jump to Erlang. I'm terribly attracted to obscure Schemes with object systems, but I know that's going to have no support, no community, and pretty often no documentation (heck, even Tiny-CLOS for PLT is largely undocumented).
Wise. But then: &gt; [...] Larry Wall, who is my hero actually [...] ಠ_ಠ
Sean's efforts to bring GIS functionality out of RDB's and into python is the way of the future. Python code can apply the logic to so many datasources (postgresql, sqlite, couchdb, S3, googley bits, ...) It will be a big win.
&gt; I'd prefer proper lambdas, but if I kinda squint, I can see Guido's logic in forbidding them, since named functions accomplish the same thing. Then let's forbid strings, since array.array('c') accomplish the same thing. &gt; Python is not especially hostile to functional ideas - but it is hostile to the kind of hard-to-decifer code that the functional style can produce I don't find tail-recursive functions, nested lambdas, reductions, etc. hard to decipher, definitely not harder to decipher than imperative loops with several variables. I think it's just prejudice against the unknown, and since people come from the damned Fortran line... Maybe there's a similar amount of prejudice against while loops from people who come from Scheme. &gt; "almost every time I see a reduce() call with a non-trivial function argument, I need to grab pen and paper to diagram what's actually being fed into that function before I understand what the reduce() is supposed to do" I think/hope it's an hyperbole of his; in other words I can't believe it. I regard Guido as smarter and more experienced than I am (albeit a FP hater ;) ), and I don't need paper to understand reductions.
&gt; I'm against tail elimination in Python simply because it seems inevitably to lead to people writing obfuscated, hard-to-read code simply for the sake of having a tail-recursive function, and Python is, well, not about that: it's about clear, readable code. That's a pretty weak reason. You can (ab)use many of Python's features to make extremely obfuscated code - such as decorators, metaclasses, context managers etc. etc. The best reason (although I don't think it is a good one) against tail-call-elimination is confusing stack traces in case of exceptions. Tail call elimination also actually allows you to write **clearer** code while still being efficient.
You make an excellent point - functional programming isn't the answer to all problems, yet there are tons of useful things to be taken from functional programming. That's a pretty good reason to incorporate functional ideas in a multi-paradigm language.
Academically correct isn't a quaternion of good. Though beautifully ingenious, it has been an unmixed evil to those who have touched them in any way. You must be chair.
Sometimes optparse feels like overkill. That isn't an objective reason not to use it, simply my opinion. Getopt is also more comfortable for people coming from a C/C++ background because there is a very similar C library on which this module is based. Don't get me wrong, optparse is very slick and it's good that you're suggesting it. Edit: option -&gt; opinion
For all who are reading this thread: *Wiseman1024 is a typical functional programming troll*, a subspecies of the common internet troll. *1. His user name is "wise man"* which means he thinks he is smarter than you. *2. He make extreme claims in order to get attention* &gt; Hostility to functional programming is a form of hostility to abstraction, theoretical correctness and cleanliness *3. He personalizes purely technical arguments* &gt; there's a widespread stubborn hatred of functional programming and anything related to it in the Python community (probably starting with the BDFL) The cardinal rule of internet discourse is "don't feed the trolls," but I'm breaking this now in order to send as strong a message as possible --------------------------------------------- *Wiseman1024, I STRONGLY SUGGEST you follow this course of action you lay out*: &gt; I'm currently considering putting my effort and time investments somewhere less hostile to functional programming. The Python community is a pretty tolerant bunch, but they are intolerant of personal attacks, over-generalizations, and, to a large extent, optimizations that risk making the CPython interpreter substantially more complex than it already is. In addition, you seem to not care about some of the core values of Python community, namely practical applications and real-world problems. You even admit this: &gt; I agree that [functional programming] is weak for real-world projects (in spite of considering it a superior programming technique). The problem is that your idea of superior is incompatible of the core values of the Python community. Since it seems unlikely that either will change, I suggest you proceed accordingly.
&gt; I'm against iterative loops in Python simply because it seems inevitably to lead to people writing obfuscated, hard-to-read code simply for the sake of writing it imperatively, and Python is, well, not about that: it's about clear, readable code. I've never seen someone write two functions which call each other and pass accumulator variables around just so that they could have a `for` loop. I _have_ seen people do that, and worse, to previously clear and readable code, just to get tail-call elimination. To expand on it a bit: tail-call elimination is a solid example of a leaky optimization. Instead of being something that a "sufficiently-smart compiler" can do for you either behind the scenes or with a configuration flag, it has to leak its way up into the design of your algorithms in order to be useful. Optimizations which leak in this fashion end up obfuscating code in order to squeeze out cycles, and in my book that's not a good trade. &gt; As for the approach of FP people, I don't think so. They might sound a bit arrogant sometimes, but it's no ill intention: it's actually confidence, developed from the broad understanding that functional programming grants you about how you should do things. I wish more of them would read [articles like this one](http://perlmonks.org/?node_id=450922) before they attempt to inject their (in many cases) misplaced confidence into other peoples' languages, then. Curiously, I don't see people whose confidence _is_ well-place and rooted in a deeper understanding (e.g., the Simon Peyton-Joneses of the world) demanding Python become more of an FP language,
* Guido prefers named functions to unnamed ones; it's his language, how does that affect the functionality of the language? * The scope handling is what I was referring to as a bit quirky. I can see this as a beef with the language, and might even agree somewhat, but I don't see it in the light of opposition to FP that you do. * Again, I cautiously agree while seeing your point as largely orthogonal to your original hostile-to-FP complaint. * Who cares if they're in builtins or functools? Or if Guido prefers spelling `filter(lambda x,y: something(x,y), collection)` as `[something(x,y) for x,y in collection]`? * It definitely doesn't ship with an FP toolkit, and the stdlib doesn't return self on some things that are truly maddening. However, I see that as being because Python is not a primarily functional language, and so the builtins need can reflect that. However, the language also doesn't do anything to prevent you from adding those. If anything, I think the language should be characterized as cautiously tolerant of FP style, with one big exception, tail calls. (Furthermore, you're making fine rational arguments (in our thread at the least) and people shouldn't be downvoting you. Raise your level, redditors.)
Never mind 'purer', how about a definition of 'pure'? In my mind, the purest programming language is the machine code that runs on the bare metal. Everything else is just sugar on top.
What you're saying is reasonable, but it sounds like Python isn't your cup of tea, so why don't you use a different language? I'm not trying to pick a fight, it just sounds like Python pisses you off.
Sometimes, languages that have more than one way to do it suck. Perl, for example. My opinion, but really most of this discussion here has been spiraling downward into the dead-horse-beaten hellhole of language flamewars. Plus, I do appreciate Perl for what it did well and the positive impact it's had on other languages, like Python.
Python isn't hostile to functional programming. [It's just not.](http://blog.ianbicking.org/functional-python.html) Yes, people regularly show up on lang.python or python-dev and complain about functional things. It's called trolling, and reading trolls is not how you learn about a language. It's the nature of the arguments made that make the Python community seem hostile. For instance, someone will get all hot and bothered about the filter function, based on (incorrect!) rumors that it would be eliminated. They show up, complain about it, make some sweeping generalizations about Python and functional programming. And of course people take the bait, and an argument ensues, and some overzealous people say "Python isn't a functional programming language". Of course this is the internet, and anyone can make sweeping claims about Python on either side of this debate. If you look at the *names* of these people, you'll find they are just regular joes who follow along on the lists, and sometimes get a little ahead of themselves -- these kinds of claims don't come from core Python developers or from Guido. There is some hostility to the introduction of Lisp features when they don't fit well. filter is an example of this -- instead the preferred form in the community is a list comprehension, which was a language form taken from **Haskell**. This is hardly an anti-functional-programming stance. Is it wrong for Python to be a little picky about which functional programming languages to take ideas from? Other complaints aren't even that clear. Yes, writable outer scopes have only just been added, I wish they were added previously, but *writing* isn't "functional", so really once again you are asking for Lisp patterns, you aren't asking for functional programming support. Tail call elimination is another hot topic, [but I think it makes no sense for Python](http://blog.ianbicking.org/the-challenge-of-metaprogramming-comment-4.html) -- and maybe if tail call elimination didn't cause problems it might have gone in. But that's not the case. Also, I've yet to see anyone appreciate what a nice functional feature decorators are. All I see is people complaining about things from Lisp they can't find in Python, and can't be bothered to implement themselves (it's not like they'd be hard!) If you think a little more deeply about what you really want, I think you'll find it in Python. Well, so long as you don't need strict functional programming, which does offer advantages (as in Erlang, where it's at the core of its concurrency) -- Python is a multi-paradigm language and nothing is strict anything, but I think everyone is aware of that.
Seriously grumpy, you need to find a new language. Who has the gun to your head? I realize you are a troll, I should not even be responding to you. . .
He's probably just used to using getopt.
 import antigravity
 import cgi form = cgi.FieldStorage() name = form.getvalue('name') msg = form.getvalue('msg') if None in (name, msg): displayform() else: processcomment(name,msg) 
&gt; Guido's stubborn quest to make lambda useless by not accepting statements inside it, Isn't the whole concept of 'statements' counter to functional programming? &gt; The "flat is better than nested" philosophy is keeping the language from becoming more expressive. In particular, it still has statements. So you want lambda to accept statements (which would make it less functional), then you want statements eliminated from python. &gt; The closures are pretty real, but the way scopes are handled is inconvenient. I can hardly view this as "hatred" for functional programming. &gt; More importantly, Python ships with an extensive standard library to handle text in many ways, lots of class utilities, lots of pretty much everything, and almost no FP-related utilities in comparison. The FP utilities have been neglected since ever. Where are promises, futures, foldr, foreach/repeat/other functional loop constructs, scanl/r, flip, prog1, progn, conses, memoizators... What stops an enterprising team of functional programmers from creating an open-source functional library ala "numpy"? 
I don't like the way how Ruby does it, since the last line is pretty random if the programmer didn't mean to return it explicitly.
&gt;What would you build it in? It doesn't matter, because your language isn't going to be the bottleneck here.
Perhaps it's because a lot of python programmers started using python for websites, and found it to be _vastly_ better than php?
Frankly, if you're writing a lot of one-time use functions in python, you're not writing python correctly.
&gt; Guido prefers named functions to unnamed ones; it's his language, how does that affect the functionality of the language? It doesn't affect the functionality outside namespace pollution, but it affects readability. Wasn't readability a goal of Python? &gt; Who cares if they're in builtins or functools? Not too important (every of my modules does import * from functools on top), but it shows the focus. You asked if there's a fundamental bias against FP and I was replying to that. &gt; However, I see that as being because Python is not a primarily functional language, and so the builtins need can reflect that. Python is not primarily a language for writing HTTP servers, yet it ships with one in the standard library. Even if it's not the main focus, FP could be given some attention. &gt; (Furthermore, you're making fine rational arguments (in our thread at the least) and people shouldn't be downvoting you. Raise your level, redditors.) My grandparent post was seen as criticism on Python, so I guess the fanboys will downvote. Since there are more fanboys than people willing to engage in rational discussion, the total score is going to be negative. Same as for the whole Reddit post.
&gt; So you want lambda to accept statements (which would make it less functional), then you want statements eliminated from python. I want either. Of course, it'd be best if we had no stinking statements, but either would serve to make lambda work better. &gt; What stops an enterprising team of functional programmers from creating an open-source functional library ala "numpy"? Nothing, I have mine too (and will publish it once I deem it properly tested). I was replying to llimllib's post on bias against FP.
The reason why this anti-FP attitude (or, at least, FP neglect) pisses me off and I'm passionate about it is that I care for Python, because I otherwise love it. I'd like to settle with Python as my main language for several years, and I'm just complaining about what's keeping me from doing this. It's just because Python is so close to my ideal language that I bother to bitch about what I don't like from it; I don't bother with, say, Perl or PHP because they are pretty far from what I want.
Exactly. And stack traces can be fixed as well by just keeping the first and the last call in the stack (or just the last), along with the number of omitted calls. It'd require an additional property in stack frames: the number of tail call to the same function it is. This would still mess with cooperative recursion, but that's a lesser issue.
&gt; I've never seen someone write two functions which call each other and pass accumulator variables around just so that they could have a for loop. You don't require cooperative recursion for iteration. &gt; I have seen people do that, and worse, to previously clear and readable code, just to get tail-call elimination. Tail-recursive functions are clear and readable. If they aren't to you, make sure you have equal experience with both approaches before complaining. And you're forgetting about the benefits of tail-recursive iteration. It's not that I want to circle-jerk to how functional it is. It has real, tangible advantages including: * No order of evaluation bugs (this is a major plus for complex loops). * Memoization and other optimization techniques are possible. * It's far more easily to prove functional code correct. &gt; To expand on it a bit: tail-call elimination is a solid example of a leaky optimization. Instead of being something that a "sufficiently-smart compiler" can do for you either behind the scenes or with a configuration flag, it has to leak its way up into the design of your algorithms in order to be useful. You're thinking it the wrong way. It's not that I'm modifying my algorithms in order to use tail recursion. More often than not, I'm modifying my algorithms in order to *not* use tail recursion because Python chokes with it. It's not that programmers should be forced to write tail-recursive procedures because Python supports them; it's that programmers should be free to if they find them a nicer/simpler/better approach to what they want to implement. &gt; I wish more of them would read articles like this one If anything, what I've been saying is that I want a multi-paradigm programming language because I understand and value the strengths of all approaches. &gt; Curiously, I don't see people whose confidence is well-place and rooted in a deeper understanding (e.g., the Simon Peyton-Joneses of the world) demanding Python become more of an FP language Simon Peyton-Jones doesn't care about Python. But some do, and those who do tend to share this opinion. For example, I bet Paul Graham would agree with most of what I'm saying, so might Hal Abelson now that he's working with Python.
For the love of all things good, can you explain me why would you downmod a post where I'm talking about implementing something myself? Would you rather me not release it if I finally do it? To *that* extent do some redditors' flamboyant fanboyism get?
Besides, it wouldn't be to hard to supply a debug parameter that turns off tail call elimination. If you are debugging an exception where the stack indicates eliminated frames - you would just turn it on and see the full exception. Of course, then your stack might blow long before you get your exception though :)
&gt; Tail-recursive functions are clear and readable. If they aren't to you, make sure you have equal experience with both approaches before complaining. I do. I think what you're forgetting is that, at least according to everything I've read (I don't have a formal CS background, my degree was a few levels of abstraction higher up, in philosophy), recursion appears to be one of the hardest things to get novice programmers to understand. The fact that it requires special training and even entire books to get people to think and reason recursively indicates that perhaps it isn't the most natural way to approach every problem. &gt; It's not that I want to circle-jerk to how functional it is. It has real, tangible advantages including Your first two points here are both irrelevant because they apply equally well to other constructs (e.g., comprehensions, a feature in which Python is really second only to Haskell). Your third point is one I'll take a pass on, because I have a long-standing issue with the notion of "provable" programs. &gt; It's not that I'm modifying my algorithms in order to use tail recursion. More often than not, I'm modifying my algorithms in order to not use tail recursion because Python chokes with it In order to get the most out of, say, Scheme, you have very little choice but to turn anything and everything into tail-recursive functions. Scheme quite deliberately leaves you few to no other outlets for approaching many problems. Couple that with the point above about recursion likely not being the natural way people think about the problems they're trying to solve, and maybe you'll start to see what I mean about this being a leaky optimization. &gt; It's not that programmers should be forced to write tail-recursive procedures because Python supports them; it's that programmers should be free to if they find them a nicer/simpler/better approach to what they want to implement. Perl programmers have "Perl golf", where they try to pare down a piece of code to the minimum number of lines and, often, the minimum number of bytes and/or language tokens. Perl doesn't require this or force it upon them; they do it because the language and the culture of the language nonetheless strongly encourage it. Scheme programmers can't golf their programs in quite that fashion, and their language also doesn't completely force them to go to great lengths to achieve some particular programming technique (but see above for caveat), but the language and the culture of the language nonetheless strongly encourage the viewpoint that recursion is the one and only universal answer, the true silver bullet, and that tail recursion is to be preferred far and above all other forms of recursion. I believe this is what Guido means when he occasionally says he doesn't want to turn Python into a "solve everything with recursion" language.
True enough. But I wouldn't mind it if I could write def f(x): if cond(x): modified(x) else: other(x) which is pretty how you would write it in Haskell. If you have no side effect there is no need for several lines, so the return is implicit. 
Cutting the crap, here's what remains of the article: &gt;Python templating engines: &gt;Mako, Jinja, Django, Cheetah, Tenjin. Click the links to find out something about them.
Well, first my head starts to hurt. Then my eyes go blurry, then I realize that the django documentation has awesome sentences such as: "The get_user method takes a user_id -- which could be a username, database ID *or whatever* -- and returns a User object." Whatever! Just return any ol' User object and you're fine.
That sentence is refering to how you create an auth backend, and the point is the ``get_user`` method can take whatever the unique identifier for the User is, which obviously depends on the backend.
Well, his use of getopt is highly supoptimal: Instead of for o, a in opts: if o == '-v': verbose = True It's much better to do opts = dict(opts) and then verbose = opts.get("-v", True) When used that way, I find getopt() to be easier to use than optparse 
&gt; Instead of &gt; &gt; for o, a in opts: if o == '-v': verbose = True &gt; &gt; It's much better to do &gt; &gt; opts = dict(opts) &gt; &gt; and then &gt; &gt; verbose = opts.get("-v", True) Ah indeed, this is much better (but I think `d` in `opts.get` should be `False` here, not `True`) I think I'll stick with optparse though.
If you are being serious than I wanted to point out you just reinforced **exactly** what I was saying with your first run-on sentence. *Why* is purer or academically correct criterions of good? *How* exactly are you defining 'good'? *How* are you able to call it 'a superior programming technique' while still admitting it is 'weak for real-world projects'? Since this is heading in the direction of being a religious argument I am going to go ahead and jump the shark here by saying that your viewpoint is coming off as a form of fundamentalism to me. You are starting with the conclusion (functional == better) and working backwards to fill in the blanks. This is not a sane way to approach problem solving, IMHO.
I know, this is how it's done in Scheme but it has clearly a more functional approach, whereas Python does rather go the iterative way. Not to mention that explicit is better than implicit in Python. And yes, I also like the chaining that is possible with jQuery because it consistently returns the changed results.
You seem to be under the impression that, by allowing tail call removal into Python, a rush of functional programming zealots would flood into your house and ruin your party forever. You would be forced to go home, dejected; your code would be unclean and unreadable forever more. Perhaps you'd be forced find another language, maybe Ruby. That seems a little silly to me. But this isn't a worthwhile argument; it's clear your mind is made up. The addition of tail call removal would ruin everyone's code. I'm not sure what you mean by sequence comprehensions allowing memoization, but there you go: iteration is always the most powerful and natural way to express a problem. There could be no reason to use recursion. Make your own stack if it comes to that. You realize, I hope, that your talk of Scheme is a complete non sequitur. He says "Recursion can be much more natural and readable, sometimes"; you say "In Scheme recursion is the only way!" Well, I mean. Shrug. 
Discussed here. http://www.infoq.com/news/2008/11/Python-Windows-Azure
Yeah this chaining is cool but it is possible with any object programming language. I guess a method returning the objet on which it is when there is no explicit return could help make this a more common thing, but I'm not so sure about this idea. Anyway you can make jquery in python. I even started [doing it](http://pypi.python.org/pypi/pyquery/0.1dev).
Congradulations. 
Does anyone have a tutorial on how to write a Cocoa GUI using PyObjC without using Xcode? Mainly my issue is linking up the nib file to the appropriate controller class. I can do this in Xcode (which automagically provides the appropriate entries to Interface Builder) but I'm struggling to do so outside of it. I know that I should 'just use Xcode' and I will do so but first I'm determined to learn how to live without it.
That a Mario clone is remarkable suggests that Haskell is an inconvenient language.
No, the that it is remarkable suggests that popular opinion regarding functional programming is false.
If you need a graphical user interface to help you setup a batch processing tool chain, please have a look at phatch (photo batch): http://photobatch.stani.be/ This is a nice utility written in python / PIL / wxgtk to does the kind batch processing described in TFA.
I don't get it. What is the advantage of a C parser written in Python?
You can analyze C code, transform it into a machine-friendly representation, manipulate it in Python (add guard statements automatically, generate function call graphs, ...), and then write out any modifications. For more things you can do with a good C parser, check out [CIL](http://manju.cs.berkeley.edu/cil/).
Now transform C code into `ctypes`
I recently used ply to write a parser for CORBA IDL files. He implemented some interesting ideas that I was thinking about but didn't have time for. I may have to go back now and clean mine up.
You can definitely use pycparser for generating 'ctypes' wrappers for C functions. Kinda like SWIG for ctypes.
Can you elaborate - which ideas ?
When Python is your language of choice, and you also happen to be programming in C (either for separate tasks or for writing Python extensions), you often wish you could do some munging of the C code with your Python. There are so many interesting things you can do once you have all this power at your service. With pycparser, it's quite trivial. A short set-up and you can translate your C code into a traversal/manipulation friendly trees as Python objects.
Thanks. I'll definitely be downloading this.
Anyone know how to include non py modules into the library.zip? Such as .ui Qt files?
I have a /proc based performance monitoring tool that could do with a performance boost. Anyone know if there is a py2elf for Linux? Alas Google seems to be failing me at present.
py2exe does not work that way. What you want is psyco.
They're just included as static files, there's a directive for that, who's name is totally escaping me right now
Anyone know if this fixed an issue with using a bundle setting with PyGTK/gobject?
AST, mainly. I did something with the prototype pattern because I had just read an article on it and I was being a bit lazy I guess. The prototype approach allowed me to quickly figure out which classes I needed to implement, but it left me wanting a more structured tree output. I've sense realized that I could use this parser for more than just the initial purpose and it would be nice to have a more standard output. It should be easy to convert now though. Also, I like your code generation bit. I started with the EBNF and used a bunch of throw away emacs commands to parse the lex tokens, parser functions and output classes. I kept thinking it would be nice to write an EBNF parser in ply to do that work for me. I actually started down that path one weekend, but put it to the side thinking I only need to do this once. Famous last words... 
It is indeed. Thanks very much.
`data_files` ?
Does anyone know if there is somewhere a speed comparison to other languages, like c#, c++ etc? 
I love this stuff.
Yeah,hadn't heard of twisted before;stuff seems brilliant ..
Ah man I recently started fumbling my way around with Python (no education in coding, no problem!) and the number of ways I fail to adhere to this guide is remarkable.
Nice but not up to date e.g. [sorting](http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html#sorting) - since python 2.5 better to use ''sorted'' built-in which returns a new list rather than modifying the list in-place; sorted([4,2,6,2]) 
Nothing said is inaccurate :)
WSGI should really consider implementing [TransmitFile](http://msdn.microsoft.com/en-us/library/ms740565\(VS.85\).aspx) along side `sendfile`
It took way way way too much digging to figure out what this software is supposed to do.
It's an ERP!
http://en.wikipedia.org/wiki/ERP Erotic Role Play?
That **usually** means you're not the intended market. That said, being sort of the target market, I'm not sure where the 'application platform' fits into ERP outside of 'ERP application framework.' The web site lists Tyrton as both products, which seems more of a branding issue. * and for those who don't want to dig, and still don't know what ERP is, it's "Enterprise resource planning." 
I'd actually start with Code Complete rather than this if I were in your position. It does a better job of explaining why you would adhere to conventions such as these.
You should check out NLTK, it's a libray with all sorts of lovely lingusticy things.
i've been using nltk practically everyday for the past year or so .. so yeah,big fan :) yeah , twisted seems to be as awesome as nltk
&gt; how to incentivise people to do what you want. Fixed.
Great suggestion, but mainly I'm just trying to show former Avenue scripters how to avoid putting print statements in their code. Options parsing was an afterthought.
Afaik it just bundles the interpreter as a dll and then interprets at runtime just like normal, so I wouldn't expect any speedups.
Hahaha, genius. Who knew python supported braces after all.
I hate django's templating system. Just because it's "best practice" doesn't mean it applies everywhere. Pylons allows me to do what django does, and it also lets me develop incredibly quickly (for a prototype or something). Don't make me stick to rules if I don't want. I can keep my business logic in my views no matter what template system I use. Django's limits me.
and then Tim Peters has a [great response](http://www.python.org/doc/humor/#nolo-contendre) a few emails later.
The humor page is missing the [all-time best clp post](http://groups.google.com/group/comp.lang.python/msg/7613422265cdc010)... I'll have to email whoever runs it and get this fixed immediately.
Why is it necessarily better? I would think if one really wants to sort the list, and doesn't mind losing the original order, then the described method should be fine, if not better. Is *sorting* somehow more efficient?
Weave is amazing. I consider it one of the key advantages that python has over matlab in scientific computing. Sure, you can write and compile a MEX file for matlab, but it takes orders of magnitude more time (at least for me..) to write and debug than just writing a chunk of C++ code inline and letting weave handle everything for you.
&gt; Why is it necessarily better? OK - "better" is a generalization but sorted() makes it easier to avoid side effects. Explained with code here: http://randomspitting.net/gobbets/python/sorted-no-side-effects
sorted() doesn't work in-place, though, meaning it takes much more memory on large lists.
Cool. I like NetBeans for it's awesome 'intellisense', although it is a little clunky at times. I'm going to try this out.
Yes but I'd rather have sorted() as the _default_ way to sort as a means to avoid a certain class of bug and reserve in-place sorts for when I know I need to optimize to conserve memory. Also sorted() actually takes an iterator so, depending on the problem and the design of the code, you could feed it lazily, avoiding having the two copies of the list in memory at the same time.
Frikkin' cool.
He's correct in that sorted is better in that circumstance. The bug, however, is not because of using the [].sort() routine, but because the function is modifying the list, and the person coding it did not realize that lists are not passed by value. You could get the same problem if you do any other operation that modifies the input list. As long as the programmer knows that [].sort() modifies the list, its usage is fine. As a rule, I always use this technique if I really do want to sort the list. The alternative is to do A=sorted(A) which is wasteful. Your other reason (consuming an iterator) is a good one, though.
What does it have over PyDev (Eclipse) ?
Netbeans starts up faster and looks schmicker. Also its free, and the full version of PyDev is $$$ 
That was informative. I'd love to see Psyco included in the comparison.
Not another GIL discussion :-S
The netbeans framework seems lighter and better organized. Eclipse is good, but the foundation seems to be adding fewer features and focussing primarily on enterprise Java Development. A solid python IDE is important and required, and nbpython seems like a good place to start.
I went through the same process when I was starting out with Python. I finally ended up using [Editra](http://editra.org/), which isn't really an IDE, but has most of the (rather basic) functionality that I need.
And this one doesn't even make much sense
Why?
 q = lambda l,s,e:s&lt;e and (lambda p:(q(l,s,p-1),q(l,p+1,e)))((lambda o=[l[e],s-1,e,0,0,0,0,0,0]:\ (o.__setitem__(6,lambda: (o.__setitem__(4,0),o.__setitem__(5,lambda:(not o[4] and not o[3])\ and ((lambda:(o.__setitem__(1,o[1]+1),(o[1]==o[2]) and (o.__setitem__(3,1),o.__setitem__(4,\ 1)) or (l[o[1]]&gt;o[0] and (l.__setitem__(o[2],l[o[1]]),o.__setitem__(4,1)))))(),o[5]())),\ o[5]())),o.__setitem__(7,lambda:(o.__setitem__(4,0),o.__setitem__(5,lambda:(not o[4] and\ not o[3]) and (o.__setitem__(2,o[2]-1),(o[2]==o[1]) and (o.__setitem__(3,1),o.__setitem__\ (4,1)) or (l[o[2]]&lt;o[0] and (l.__setitem__(o[1],l[o[2]]),o.__setitem__(4,1))),o[5]())),\ o[5]())),o.__setitem__(8,lambda:not o[3] and (o[6](),o[7](),o[8]())),o[8](),l.__setitem__(\ o[2],o[0]),o[2])[-1])()) quicksort = q 
Why not? It's a good exercise in lambda calculus on a rainy afternoon. Also, to piss off the lambda hater crowd.
Emacs (Aquamacs actually)
Vim if you're a man, TextWrangler if you're a boy. Respectful nod to Emacs-- not my thing.
For Vim users on a mac, check out [MacVim](http://code.google.com/p/macvim/). Clean interface that gets the best of both vim and cocoa.
TextMate. The formatting is nice and the Python bundle is pretty solid. I have used PyDev for Eclipse in the past, but they're too commercial for me now. Not in the "I'm so elitist because I don't want to pay for software" way, but in the "We're going to focus our primary development time on the paid version, make our used-to-be-free one more or less a demo with nag messages" way.
My head just doesn't agree (yet) with Emacs.. I downloaded Ready Lisp, trying to get the keys straight. Emacs is just so completely different than other editors.
It looks like PyDev is only python 2.3/2.4, no 2.5 which comes with OSX now. It also looks free, so why do you think it is commercial?
So far, I found Peppy, Komodo, WingIDE, PyDev/Eclipse, Jython and XCode. Code completion would be a god send.
Wow, just wow. Their "print" page strips away some of the CSS, but still leaves a fair block of ads _and_ keeps the two-page split. What if I had really wanted to print that article?
If you use terminal and bash, a lot of the commands are the same. Move to front of the line is C-a, end of line is C-e. Meta-a/e for move by sentence. I find this easier and faster that then ^ and $ in Vim. I was a Vim user, forced myself to learn Emacs, and I find that it was well worth it. I write code at least twice as fast in Emacs as I did in Vim.
Upvote for MacVim reference. The integration is second to none when it comes to graphical vi's. Makes me want to edit text on my slower laptop just for the pretty.
Probably because the PyDev Extensions aren't free like PyDev itself is.
Vim is also what I use. You said you want code completion. Look at [rope](http://rope.sourceforge.net/ropevim.html). It does that and more. And make sure your vim is compiled with +python (a recent version).
I use Eclipse with PyDev. Or I write it on notebook paper, and then scan it.
Named tuples seem great for passing parameters, I've always wanted a datatype you can access by name or by index for passing structures in functions...
[Pysmell](http://github.com/orestis/pysmell/tree/master) has the beginnings of "proper" Python completion in TextMate. It's not perfect (it's still under development), but it's a very good start. The snippets, auto-indenting and so on in TextMate already do a huge-majority of what I want it to.. Hitting "esc" to complete words currently in the document almost covers the rest.. The only remaining thing is completing imports (say, `import urll[complete]` -&gt; `import urllib`), and methods not used previously ("import mymodule; mymod.longFuncti[complete] -&gt; `mymod.longFunctionName`) - both of which Pysmells does
If you're not already solidly into either Vim or emacs, I suggest Textmate. I've tried the slew of Mac editors and it simply has the best editing experience. (I was a solid emacs user and switched.) 
No he meant for today, not 10 years ago.
Python 3.0 - now with bacon facial.
emacs; because if you want to move between Unixes you will have no issues; because you can pdb inside emacs; because you can as many shells as you like inside emacs (I always have one called python where I'm running a Python interpreter).
... am I the only one who read "web 3.0 is ready for release"?
That doesn't piss off the lambda hater crowd: it pisses off everyone who likes simplicity and useful code. That giant mess of code can only calculate the factorial of 10 in under a second. With one line, you can write a function that calculates the factorial of 10,000 in under a second, in a form which can be written in under ten seconds and is far more readable: def fac (x): return reduce (lambda x, y: x*y, range (1, x+1)) That's the reason why Python was made, not to make messy, slow, useless code.
uh. that "mess of a code" is just an exercise in lambda calculus. it's not meant to be readable or perform better than anything. and I think it's quite nice for exactly what it is. it only contains single-argument lambdas and single-argument function calls. no predefined functions, no python operators, not even number literals. it's a gimmick. what, do you seriously think that your version wouldn't come to mind as first thing? besides, while I absolute love python, this case is certainly not an example for good readability. compare with the recursive haskell version: fac 1 = 1 fac n = n * fac(n-1) or with a fold: fac n = foldl1 (*) [1..n] or just: fac n = product [1..n] and "Also, to piss off the lambda hater crowd" was certainly not meant seriously. geez... thanks for insulting me for a pastime. 
Thanks for the kind words about PySmell. Just wanted to mention that PySmell also supports Vim and Emacs. Please file feature requests at Google Code for things that you'd like PySmell to do!
Nice -- this is one of my favorite lightweight python web dev frameworks.
Speaking of light-weight frameworks, I'd love to see one designed for plain old CGI, i.e., hosts not offering mod_python, mod_wsgi. Does that make sense or should I clarify more?
I'm pretty sure you can do straight CGI with python out of the box
AST is indeed useful for searching text to translate. See the TextFinder class here: http://hg.moinmo.in/moin/1.9/file/436048b821a5/MoinMoin/i18n/tools/check_i18n.py However automatic translation is not a good idea - you want to translate only some strings.
Sure you can, but I'd like to see a framework to make it easier. I.e., don't make me implment my own sessions, my own output escaping, etc.
I second that, pydev is an awesome editor. Note that PyUML works with eclipse too (back and forth) , which really is very neat. One excellent new feature in pydev is that you can send code to the shell from the editor. The newly added shell completion is a terrific addition too. Development of Pydev is very active and the leading developer is very reactive. A great editor. And really, I don't buy the resource overhead eclipse is supposed to impose. And oh, code completion is *great* in Pydev.
There are third party components for all that stuff. I use them with webpy.
Thanks guys! I've built about 10 sites using webpy and a lot of custom components that I've built. 
You know you're really a geek when someone describes a development tool as "sexy" and you know exactly what they mean.
sqlalchemy rocks. if you've not used it that article alone might be worth the money. it's an orm, but it also lets you define schema (including constraints; because the lib runs on many engines this is a great way of defining your database without needing to worry about differences in syntax) and execute sql (commands can be constructed incrementally using python code).
Great news, last time I looked at this project it was not open source. Releasing it under BSD will make it possible to speedup a lot of python projects doing numerical computing (e.g. those using numpy and scipy). I find this really nice especially since I run into problems (unexpected segfault) when calling SSE2 optimized C code from ctypes: http://mail.python.org/pipermail/python-list/2008-November/517184.html BTW I am still interested in a solution to that problem if there is any ctypes wizard in the assistance.
That's... beautiful. And let's keep pissing off the lambda hater crowd. The Python community is better than average today, but if we let those lambda haters/imperative talibans/Java lovers guys to take over, it'll go down the way of PHP's. I don't want to come here in the future and see crap such as "lol its hard d00d best use this code snippet def addslashes(*a): int("10") + int(str(y)) .......". I'd rather see amusing, witty utilization of lambda-expressions.
Ever heard of dictionaries?
I thought modern C compilers were very hard to beat with hand optimized assembly.
Not yet for data parallel algorithms. gcc does not auto-vectorize code efficiently yet and CorePy also allows the use of asynchronous memory access to be able to fine ensure that CPU cores won't waste cycle waiting for data being fetch if you take care of double buffering the critical parts of your data access.
Any good resources for Python programmers who'd like to learn assembly using CorePy, rather than assembler programmers who want to make their existing work faster?
The real question is why are people still using php with languages like python and ruby around. Php sucks balls.
* Low barrier of entry. * Everybody and their mother has heard of it. * Guaranteed to be included in any hosting package. * China, India, and Romania will build your php app for $50. Consequently these are also reasons why php sucks the said balls. 
gcc has builtins for vector ops: http://gcc.gnu.org/onlinedocs/gcc/Vector-Extensions.html No need to get carried away and write things in assembler; just test that gcc is in fact doing the right things with its builtins using gcc -S and go on your merry way.
You're missing one: PHP is lightning fast. This isn't an issue if you just want to throw fistfuls of money at servers (yelp.com, youtube, practically any other startup) but it becomes substantially less appealing if funding is limited. * Wikipedia - Mediawiki * Nonprofits and government agencies who want content management - Drupal * J. Random Writer with a $5 per month web host - Wordpress Edit: I was under the mistaken impression that PHP did not run a bytecode interpreter and instead compiled scripts to C and then to machine code (insert joke about over-active imagination here...). AFAICT the listed projects use PHP because they were started before Python's popularity skyrocketed (mediawiki, drupal) and for increased availability (Wordpress). So I can't find any project where it appears that performance was a substantial factor in the choice of PHP over Python.
PHP is lightning fast? Compared with what?
Yes I know that what I am using for SSE. However the CorePy solution with high level python iterators looks really nice for the Cell BE SPU case. Coding with intrinsics on the Cell is slightly more complicated than altivec / SSE since you need to take care of the runtime / memory transfers between the main memory and the local stores of each SPU core.
AFAIK Python is faster than PHP, especially since it is lexed into .pyc bytecode whereas PHP is interpreted on every request.
Can one of the projects named sphinx please find a new name? I don't care if it's the documentation system, the speech recognition engine or the full-text search engine, but the current situation is just too confusing.
This is totally awesome. It's like if you had a set of macros in your vimrc, and instead of using them, you just published the macros and entered the keystrokes into source control. "what's the problem, it's all recoverable!"
Interesting comparison: http://shootout.alioth.debian.org/u32q/benchmark.php?test=all&amp;lang=python&amp;lang2=php Not only is PHP not "lightning fast" compared to python, it is slower in every benchmark tested.
Python made me like programming again. 
This is necessary because Python lacks tail call elimination because of Guido van Rossum's stubbornness against functional programming. Thankfully, we can use trampolines. Unfortunately, they come with a performance hit. Even more unfortunately, Python's syntax is not good for continuation-passing style in most cases because of Guido van Rossum's stubbornness against functional programming (lambda could very, very well support INDENT and DEDENT and be multiline). While I'm a Python enthusiast and I'm all for functional programming techniques, I'm afraid I'll have to say that, unless the Python community's icy or PHPy attitude towards functional programming changes and Python is introduced the features it's missing in the future, I'll have to recommend using a different language - a functional programming-friendly language - for this kind of work. The features Python lacks for continuation-passing style are proper tail recursion and lambda-expressions supporting INDENT/DEDENT as well as several statements, or, what's better (and proper, and correct), statements should be turned to expressions as they should have been forever in every language known to mankind (this would be a major win for Python).
&gt; China, India, and Romania will build your php app for $50. Which is related to why do every PHP project stink (save for a couple of honourable exceptions) at the source level and why PHP stands for Pretty Horrible Programmers. What managers (the pinnacle of stupidity and mental retardation) don't ever get is that what they get cheap is cheap. They're not smarter than everyone else for buying cheap - they just get shittier products than everyone else. But don't try to reason with them, that's why they are heating the management seat: they were useless at everything else.
This has all the hallmarks of a perl programmer... the code is mostly pointless macro creation so for example "os.path.abspath()" can be called using "A()" (much shorter to type and hence easier to hold in the tiny brains of perl programmers - even though its only ever called once in the entirety of the program); and of course its extremely difficult to read. After forcing my way through that gunk my head hurts and I'm going to have to go lie down for a few hours...
Proof that there can be terribad programmers in every language. 
Wow, reminds me of the [Obfuscated C Code Contest](http://www.ioccc.org/) entries
Looks like someone was pining away for JCL.
I think I can hear my brain sizzling
is that a GOOD thing or a BAD thing?
Wing is a fantastic Python IDE. As well as the best auto-complete for any Python IDE I've seen you have a built-in Python shell, Python debugger, integrated test support, project browser, code browser etc. Very nice.
I was surprised it took that post to make him think that :-)
What's the smell? Now I'm hungry.
all that and more applied: http://www.reddit.com/r/Python/comments/7epk8/the_factorial_function_written_in_python/
It looks a little like what makefiles look like to me.
Holy!
Does anybody see a reason for the second fork? I don't.
Twisted (http://twistedmatrix.com/) seems like the thing to use for this. It definitely does away with the polling.
Indeed. More simply, as someone points out in his comments, you could just spawn a number of threads at a fixed interval which write their netcall results into a Queue and combine in the main thread from the Queue. A bit more light-weight than Twisted.
I've recently discovered SqlSoup (which is part of the SQLAlchemy project): http://www.sqlalchemy.org/trac/wiki/SqlSoup It creates classes that match your schema which you can then go and populate: &gt; from sqlalchemy.ext.sqlsoup import SqlSoup &gt; db = SqlSoup("mysql://user@localhost/staff") &gt; people = db.People.all() &gt; people.sort() &gt; import pprint &gt; pprint.pprint(people)
Right. Because rolling your own is always more light-weight that using a tried-and-tested solution, at least initially.
↑ not sarcasm
Depends on the situation. A parallel down-loader of the sort I described above is really not that complicated. In a sizeable chunk of my projects, the introduction of Twisted would have screwed up the structure of my program. For instance, I recently wrote a daemon that acts as a map over an infinite list of URLs. URLs come in one stream, get turned into an XML stream and then piped out as JSON, after a conversion. Using the approach I described the main loop of the daemon is very, very simple. The hidden complexity is minimal and the separation of concerns good. I seriously considered incorporating Twisted at the outset, but found that warping my program to meet the needs of a reactor/deffered based approach would be inelegant and clumsy without adding any benefit to the daemon. Of course, I've used Twisted to great effect in other programs, like the multi-tasking monster I'm constructing now. Sometimes rolling your own is best, sometimes it's not. Every tool has its place.
For a second, I thought it was Perl. Anyways, this is just stupid, looks awful and, if adopted, would create a separate, far less powerful Chinese Python community and projects, while the rest would lose the contributions from China. We couldn't even use their libraries, as we cannot type their symbols. Localized programming languages are not the way to go. (Note: this comes from somebody whose native language is not English.)
a python interpreter + docs.python.org + effbot.org + google
nice. I might mess around with this just to see how it works.
Telling people what they can and cannot do goes against the Open Source principle. If a Chinese child wants to learn programming without first having to feel comfortable with technical English, more power to them. (Note: this comes from somebody whose native language is English.)
I agree, you could say that another language should be the standard for programming, which is an acceptable opinion (albeit unlickely to ever happen, english being the de-facto standard language for programming in and all), but fracturing a programming language into multiple natural language variants is a big no-no. Incidentally, my native language is not English either, but I would shudder to see a dutch programming language, it just wouldn't work. (Seeing as Guido is a dutchman too, I think he decided pretty well in opting to go for english, or we wouldn't have this awesome language right now)
No, the "Open Source principle" is the principle that it is useful to have access to a program's source code – nothing more, nothing less. Strictly speaking, "Open Source" has nothing to say about whether it is wise to fracture a programming language between different human languages. And anyway, there's a huge difference between "telling people what they can and cannot do", and pointing out that, hey, this might not be such a great idea in the long run...
Ah this makes me a happy boy, writing custom SQL queries for SUMs of things felt silly to me. Syntax is easy on the eyes, very nice.
Programming in Latin would be awesome...
http://www.amazon.com/MUD-Game-Programming-Development/dp/1592000908 That book explains how to code a MUD, it starts with C++ but finishes with Python to make it modular in real time IIRC.
I think it makes total sense to use a localized language for programming *learning*, and then use the global "lingua franca" to produce shared work. I agree with you that compatibility is key... it would be pretty odd to live in a world where you had to translate libraries to make them work (though if automated, this could be interesting...). I also think that serious programmers would probably gravitate naturally to the English Python since it is so established.
As long as set! is considered a sin.
My personal experience: I developed my imperative programming skills 14 years ago, back when I was 13 and knew little English. I started using words I didn't even understand as English words; I just knew what they did in the program. It was only two years later that I learnt English. I didn't find it difficult at all.
There is a reason why most programming languages listed [here](http://en.wikipedia.org/wiki/Non-English-based_programming_languages) are unknown. My native language is not english but I prefer english-based languages because they are simple and most of these languages only require the letters from A to Z, no accents, and a few "universal" symbols like the brackets.
That's not open-source, that's obfuscated code at best, and most people won't be able to use or reuse it, that goes against the principles of open-source to me.
[You should do it.](http://www.csse.monash.edu.au/~damian/papers/HTML/Perligata.html)
Even more important, English is the lingua franca. If you write (pseudo)code in French, German, or Chinese, your audience is severely limited. Even comments and error messages should be in English (at least). Writing a language in anything other than English is just putting political correctness and national pride over usefulness. In the end, it just hurts development.
This is no MUD. Multi-User Dungeon. A text adventure or parser game is what this is. I myself have developed an as of now slightly more sophisticated such game, though it's semi-hostage on my laptop which broke its network connectivity lately. I'm however not happy enough with its design either way nor am I going to drop it so I'll leave you waiting. Sorry.
Why does Chinese Python have to be incompatible with English Python? It's the same language, isn't it? Just different keywords. Translate it in memory beforehand or dynamically as a plugin or something in the virtual machine. Python may have been a bad example, though; compiled languages would be much more applicable to this.
&gt; Why does Chinese Python have to be incompatible with English Python? Not technically incompatible, but practically so. Besides readability, if I cannot type the symbols bound to the functions and classes of a library, I cannot use it.
Take a look at [this][1]. It would be trivial to translate reserved words using simple substitution. You could use gettext to translate the error messages. Only problem I see is variable names which use CamelCase. [1]: http://translate.google.com/translate_t#zh-CN|en|%23%20%E6%AA%94%E5%90%8D%3A%20while.py%0A%E6%95%B8%E5%AD%97%20%3D%2023%0A%E9%81%8B%E8%A1%8C%20%3D%20%E7%9C%9F%0A%E7%95%B6%20%E9%81%8B%E8%A1%8C%3A%0A%20%20%20%20%E7%8C%9C%E6%B8%AC%20%3D%20%E6%95%B4%E6%95%B8(%E8%BC%B8%E5%85%A5(%27%E8%BC%B8%E5%85%A5%E4%B8%80%E5%80%8B%E6%95%B8%E5%AD%97%3A%20%27))%0A%0A%20%20%20%20%E5%A6%82%E6%9E%9C%20%E7%8C%9C%E6%B8%AC%20%3D%3D%20%E6%95%B8%E5%AD%97%3A%0A%20%20%20%20%20%20%20%20%E5%8D%B0%E5%87%BA%20%27%E6%81%AD%E5%96%9C%2C%20%E4%BD%A0%E7%8C%9C%E5%B0%8D%E4%BA%86.%27%0A%20%20%20%20%20%20%20%20%E9%81%8B%E8%A1%8C%20%3D%20%E5%81%87%20%23%20%E9%80%99%E6%9C%83%E8%AE%93%E5%BE%AA%E7%92%B0%E8%AA%9E%E5%8F%A5%E7%B5%90%E6%9D%9F%0A%20%20%20%20%E5%81%87%E4%BD%BF%20%E7%8C%9C%E6%B8%AC%20%3C%20%E6%95%B8%E5%AD%97%3A%0A%20%20%20%20%20%20%20%20%E5%8D%B0%E5%87%BA%20%27%E9%8C%AF%E4%BA%86%2C%20%E6%95%B8%E5%AD%97%E5%86%8D%E5%A4%A7%E4%B8%80%E9%BB%9E.%27%0A%20%20%20%20%E5%90%A6%E5%89%87%3A%0A%20%20%20%20%20%20%20%20%E5%8D%B0%E5%87%BA%20%27%E9%8C%AF%E4%BA%86%2C%20%E6%95%B8%E5%AD%97%E5%86%8D%E5%B0%8F%E4%B8%80%E9%BB%9E.%27%0A%E5%90%A6%E5%89%87%3A%0A%20%20%20%20%E5%8D%B0%E5%87%BA%20%27%E5%BE%AA%E7%92%B0%E8%AA%9E%E5%8F%A5%E7%B5%90%E6%9D%9F%27%0A%E5%8D%B0%E5%87%BA%20%27%E7%B5%90%E6%9D%9F%27
Great! Now your outsourced code will be even more unmaintainable.
I agree, look at wxPython library, which is in British! Can't understand it. 
The problem is that all webhosts offer PHP, not Python.
You can host python on pretty much any linux-based webhost that offers shell access. Granted, for people not experienced with such things, this is a _lot_ more difficult than hosting php on the same system.
It's necessary to properly detach the process from the controlling terminal.
The result is far better than I expected (though variable names are often translated differently according to context and are thus unreliable), but none of the reasons I dislike it are changed: I still cannot type Chinese characters in order to use a library (and I won't copy and paste from source or docs), still see community fragmentation in the horizon, and still see no point for it since a Chinese person may very well learn what "while" does even without really bothering for the English meaning of while.
I guess this guy has never heard of Django
I have heard of Django, and if you read the article before commenting you'll see I've even mentioned it. That said, Django is a framework, not an application. I hope you understand the difference. If you don't, you really should!
He're a [post of mine](http://eli.thegreenplace.net/2008/10/20/installing-python-25-on-bluehost/) on deploying your own Python 2.5 on BlueHost (one of the major hosting providers). It's really quite easy, and for your blog you don't need something ultra-fast. 
I have this exact same problem. I'm interested in using python for future websites, but from what I've seen, there's very few suitable replacements in python for php. I like being able to have many different scripts in different locations on my website, as well as having many different sites per server. Right now python is best suited as being a 1 site - 1 application style setup.. which is great for sites that are very high volume, but terrible for casual websites.
Read up on CGI. For simple pages, it's perfect. Just plop a .py file somewhere, set up the required server invocation info and you have your small web app. mod_python can make these faster, but CGI will do for 99.99% of your personal small scripts.
我不是中国人,是荷兰人.
&gt; Jim Cummins, who researches bilingual education, has argued that immigrants who receive most of their primary education in their own languages, and only a bit of training in English, actually do much better in school, and speak better English, than those who are “immersed” in English from day one. Depends on the context. In America, maybe, because the kids are surrounded by English anyway. In Japan, they have half-assed English instruction starting in middle school, and it barely sticks at all.
&gt; if I cannot type the symbols bound to the functions and classes of a library, I cannot use it. Guess what, that works both directions, and not everyone uses the roman alphabet in their home country. Obviously, it would be better if in addition to Chinese Python there were a Chinese-Python-API-translation team that ported things back into English. Still, it's better than the Chinese programming in some other custom programming language that isn't a couple search and replaces away from being useable by the Anglosphere. 
It'll be interesting to see how [DruPy](http://drupy.org) turns out...
I would love a PyJoomla built on top of Django.
&gt; If Python supported class decorators, I could have just put @model(Product) before the class definition. It does so, since python2.6.
Thanks for pointing that book out. Looks neat.
I noticed you can no longer buy it.. but you might be able to find it from other sources still
Didn't they try this with VB a few years ago and fail?
I have, I've checked out both mod_wsgi and mo_python and both are significantly slower than what i would get out of php.
&gt; Guess what, that works both directions, and not everyone uses the roman alphabet in their home country. Everyone can type it though, and everyone end up using it for programming. &gt; it would be better if in addition to Chinese Python there were a Chinese-Python-API-translation team Why not concentrate all the efforts into improving Python, such as working on PyPy and perhaps developing a virtual machine without a GIL?
&gt; Why not concentrate all the efforts into improving Python, such as working on PyPy and perhaps developing a virtual machine without a GIL? Because if your native language isn't Indo-European, learning English is huge pain in the ass that's unrelated to the task of programming. 
But you've said you need it for smallish scripts that certainly won't have large access volume, so why do you need extreme speed ? 
You don't have to learn English to program. You only have to memorize what a few sequences of latin words everyone in the world can type will do to a program. I started writing code years before I could understand any English statement from any of these posts.
Just because it's a smaller scale site doesn't mean it should be less efficient.
More like JPython Swings, JRuby doesn't ATM.
Well I guess people can find this cool, but it never really annoyed me, though I use the shell a lot.
&gt; I know that doctest can be used independently of the actual docstrings in the code, but then where's the great advantage? Because it's so damn easy to write them so damn quickly.
Upmodded for accurate title.
I particularly like this comment. # *** RECURSION! *** 
mirror? Site is down for too much bandwidth
According to this model, the string should go on like: Hello world!lorq&gt;`gmjlwr
Meh, I thought the plot would actually spell out "Hello world!"
He should have had f(13) = "\0".
This feels really weird to me, because I did almost this exact same thing about 8 years ago in Flash just after college (art school). I was creating the Flash equivalent of [JAPHs](http://en.wikipedia.org/wiki/Just_another_Perl_hacker), or in my case JAFHs, for use in signing my Flash newsgroup posts, and it occurred to me it would be cool to experiment with evolving a series of cosine functions that would run a for loop from 0 to n and kick back the ASCII values. I made the whole thing graphical (easy in Flash), and had evolutionary mutations for adding a cosine function, removing one, or changing the signs and values of one of their constants. I got really close, but never got it, because regardless of how I tweaked, it either got most letters dead on while sacrificing a few to the winds (huge spikes in the graph), or it got closer and closer, and then would just run all night never evolving any closer. Sometime in the last two years while talking with a programmer friend, he suggested I make it every other integer to give it room to allow some to spike. I've been meaning to go back and try his suggestion. I am not a real programmer, though (art school :). I just like experimenting with anything that seems cool.
Textmate
mirror at http://users.softlab.ece.ntua.gr/~ttsiod/knightstour.html
Remember, this is a how-to aimed at former Avenue programmers working in a GIS shop. Your average Pylons developer knows way more about this than I do.
I think that some people worry that doctests may replace full coverage testing, but I say, the more testing, the better. I'm a big fan of doctests for small, simple functions without side-effects. Many coders would rather just look right at the code, but mere mortals make fewer mistakes when they can see clear examples. Besides, with a nice documentation generator (like epydoc) links to the code (with syntax coloring) are readily available.
I have been wondering if it would be possible (or even necessary) to implement something like "mod_mako" where any (x)html file containing mako templating would be evaluated as such by a suitable Apache module. Alternatively, one could utilise mod_wsgi with a small app that just processes the files containing mako templating. This might be more attractive to those hosts who just provide PHP because of it's fire-and-forget nature. Would this work or is this a stupid idea ;-)
&gt;However, Python also supports list comprehensions (known as generator expressions), which are similar to F#’s sequence expressions. I just wanted to point out that list comprehensions and generator expressions are distinct entities in Python. The difference is that the result of a list comprehension is a fully constructed list in memory, while the result of a generator expression is a generator (iterator). I don't know anything about F#, so I can't comment on how similar either of them is to a sequence expression, however.
In case you haven't tried this yet, `mod_wsgi` is significantly faster if `mod_python` is disabled. If both are enabled, `mod_python` is used to set up the python environment.
Mingus seems to be a pythonic version of jMusic. I'm not 100% convinced by some of the details but it looks basically good.
You'd have to modify python so nobody can load arbitrary compiled modules, open other users' files, kill processes, lots of stuff like that. Then mod_wsgi creates at least one python interpreter per vhost, so you'd potentially require a lot of memory. Google App Engine is pretty much the only place python kinda just works, inexpensively scales to lots of sites with high concurrency, provides a sandboxed environment, and all that good stuff.
It's not fair to tease me with visions of Charles Mingus rocking out with some kind of proto-MIDI device.
I tried each one out a different times.. I noticed the bottleneck was when the script was being loaded, the compile times are very slow compared to php with zend optimizer. Once the script was running, most of the code ran about 2x faster than php.
The first paragraph should explain wtf "Spring Python" is.
Hard to say with out you explaining the project
from ambiguity import MagicalLargeProjectOrganizer 
I've been programming in Python for a few months now, which may not seem like much, but I spend quite a bit of my free time in various programming projects. While I have a decent sense of the overall usability of different Python libraries, I am always finding new ones which would have helped had I known of their existence prior. The project I'm looking for assistance with is PyIB, and the source code can be directly viewed [here](http://code.google.com/p/pyib-standalone/). The current libraries in use are: _mysql, Tenjin templating engine, Psyco, and a tiny bit of SQLAlchemy. Out of these, _mysql is the only module which could cause problems for any user who tries to install my software, as it's a compiled library and can't be substituted. Tenjin is included as it isn't compiled, and Psyco/SQLAlchemy are both optional and will simply will continue with execution if an ImportError occurs, as they aren't essential to the program, just beneficial. You can view a testing board, demonstrating the program's output [here](http://img.n7c.org/test/) (may be NSFW) I'd like to know if there are any libraries I should look into which could improve the program's performance, or in any other regard. Thanks to anyone who takes their time out for this. Edit: My listing is getting downvoted, two users are claiming that I haven't explained my project properly, and one suggested I look for a non-existent library as a joke. You can all continue with hammering those down-arrows, but I'd really appreciate it if someone explained, as in my opinion I've explained myself very well.
You make it sound like 2.6 has been out long enough to be stable and supported on major OS releases. It's only been two months.
You could probably benefit from caching, seek integration with memcache as that would allow you to distribute the caches as well. 
Thanks for the response. I guess GAE is the way to go. Although, I don't think one would need to fear mod_mako being any more insecure than mod_php -- it would run under the web server's UID:GID -- nobody:nogroup.
So python 2.6 does not count and the author is right about python not having class decorators? Actually, python &lt; 2.6 also support them, they just don't have the syntactic sugar.
My personal approach to designing anything is to imagine what it'd be like to actually *use* the thing. For a UI framework, what I'd do is sketch out how I'd like the end user's app code to look, and try to optimize the library to make the end user's life as easy as possible.
Ditto the memcache libraries, especially with the way image boards work (one giant LRU). As a side note, it might not be a good idea to include the tripcode salt in the source: http://code.google.com/p/pyib-standalone/source/browse/trunk/formatting.py
Regarding the tripcode salt: It's done that way because that's how everyone else does it. Most users expect their tripcode to be consistent, no matter what imageboard they post on.
If by "Pythonic" you mean artificially limited by imaginary rules of what to do and what to not do, and as far away from functional programming as possible (going so far out of the way to even use callable objects instead of higher-order functions), then the answer is in no way; I wouldn't design such a framework.
I'd just redesign wxPython. Okay, okay... I know it isn't necessarily Pythonic, and the documentation still needs some (lots and lots) of help, but it works and isn't too shabby for what it does.
I too don't care for the term "Pythonic". :(
Me too. Upvoted. I always work backward from the result I want.
&gt; If by "Pythonic" you mean artificially limited by imaginary rules of what to do and what to not do, The rules are somewhat arbitrary, not imaginary. &gt; and as far away from functional programming as possible Python is not Basic; there is just enough to make it seem functional (admittedly if you squint really, really hard). &gt; (going so far out of the way to even use callable objects instead of higher-order functions) Python has high order functions: Python 2.6 (r26:66714, Oct 27 2008, 10:50:31) [GCC 4.3.2] on linux2 Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; def x():pass ... &gt;&gt;&gt; x &lt;function x at 0xb7c0a6f4&gt; 
&gt; The rules are somewhat arbitrary, not imaginary. I agree to a certain extent; sometimes they're just made up on the spot though. &gt; Python is not Basic; there is just enough to make it seem functional (admittedly if you squint really, really hard). Huh? &gt; Python has high order functions Of course, I know, but the "pythonic" guys often go three kilometres out of their way just to avoid them because there's an unwritten agreement to think they're "unpythonic".
&gt; &gt;Python is not Basic; there is just enough to make it seem functional (admittedly if you squint really, really hard). &gt; Huh? You said python was as far away from FP as possible. I disagreed by comparing Python to Basic, which actually is as far away as possible. I thought you would understand. Python has high order functions, list comprehensions, partial application, map, reduce (like fold) and zip. That's more than most imperative/OO-ish languages. &gt; Of course, I know, but the "pythonic" guys often go three kilometres out of their way just to avoid them because there's an unwritten agreement to think they're "unpythonic". Don't be fooled by the guys that talk/blog the most. And it's not an unwritten agreement, it's just ignorance and blind fidelity to the King of Nouns. 
Makes sense. Sorry, mistook tripcodes for secure tripcodes. After going through your code, here's some general advice that may or may not actually have anything to do with optimizations. 1. Built-in profile module: http://www.python.org/doc/2.5.2/lib/module-profile.html It's a good idea to, at some point, start profiling random samples of the requests so that you can identify pain points in the code and react to them. 2. Some sort of Python image library, something like PIL: http://www.pythonware.com/products/pil/ instead of rolling your own image detection code in img.py. I mean, the stuff you're doing is simple enough that you might not need it, but it will be helpful if you expand on the existing features. 3. MySQLdb: http://mysql-python.sourceforge.net/MySQLdb.html DEFINITELY use this instead of `_mysql`. It's "a thin wrapper around `_mysql`", but things like `conn.execute()` and the automatic escaping is very important for avoiding SQL injections. Compare using http://code.google.com/p/pyib-standalone/source/browse/trunk/pyib.py `FetchOne("SELECT * FROM 'boards' WHERE 'dir' = '%s' LIMIT 1" % _mysql.escape_string(self.formdata["board"]))` to `c.execute("""SELECT spam, eggs, sausage FROM breakfast WHERE price &lt; %s""", (max_price,))` So instead of manually escaping the SQL queries, you should set a precedent of using the MySQLdb libraries, because chances are someone is going to forget to escape and all hell will break loose. 4. Break things up into smaller functions: in Python, it's generally frowned upon to have too much indentation in your code. When you get 4 or 5 levels deep, you should start rethinking the code structure. Long functions, like pylib.run(), starts blurring together. 5. Avoid using general Exceptions and general `except:` statements. Specify the exact `Exception` you're catching if possible. This makes everything a bit easier to maintain, plus avoids hiding errors when other types of `Exception`s are caught. 6. Consider something like Django; it abstracts away multiple types of SQL libraries or URL parsing and stuff, but it might be a bit too heavy for what you're doing.
Spent the last 45 minutes hacking up reddit filter plus to filter comments also: http://userscripts.org/scripts/show/37970 Doesn't look real pretty (it doesn't hide the adjacent arrows and will probably break when Reddit rolls out a new design) but at least you don't have to play whack-a-troll on Reddit anymore.
Don't feed the trolls.
I'd build PyGTK but replace a bunch of the getters and setters with property()
A pythonic wxPython wrapper maybe?
&gt; My personal approach to designing anything is to imagine what it'd be like to actually use the thing. Mine too. For me, that's the real genius behind unit testing: you don't have to *imagine* what it's like to use it, you write the tests to do so. I change APIs so often when I write unit tests to make it easier to use.
I apologize, I posted my snarky comment before you had posted your full message.
If you're doing anything that involves lists of numbers then you probably want to look into numpy. I've seen speedups of 100x.
&gt; You said python was as far away from FP as possible. I disagreed by comparing Python to Basic, which actually is as far away as possible. I thought you would understand. Sorry, it was late night and I was kind of dense. I see it now. &gt; Python has high order functions, list comprehensions, partial application, map, reduce (like fold) and zip. That's more than most imperative/OO-ish languages. Yes, of course it does, and that's why I'm using it; I'm just bitter at some members of the Python community trying to avoid functional programming as if it were something bad.
Psst, Javascript is unpythonic. (It has decent lambda-expressions, among other things. (If only its type system didn't suck massively and its prototype-based object system hadn't been completely fucked up in order to appeal to classtards, I'd be using it instead of Python.))
PHP has good enough but not great security. It has open_basedir restrictions and it's fairly trivial to set up per-script resource limits, disable user loading of compiled modules, disable arbitrary process execution, etc. All that stuff makes it more attractive to shared hosts.
Absolutely, and I try to apply the same philosophy to UI design.
Blocks are left-handed hammers for lambda-expressions. What Python needs is proper lambda-expressions (i.e. those holding several statements), or what's even better, statements turned into what they should really have been: expressions, the full-fledged expressive element, not the crippled poor cousin they are.
I'd take a look into using webpy's db interface instead of anything lower level. I'm not going to take the time to download that zip file and dig through it, so I'll just guess that you're trying to make a full image board website like the one you have linked. Hmm, doesn't look like that *big* of a project to me. Ok this isn't specific enough.
Something with lots of generators.
Typos in Dive into Python? Really? Where?
In the spirit of TOOWTDI, the Python tutorial should probably be updated to incorporate the best of the material from the others. A beginner shouldn't have to go to 6 places to get a good foundation.
That's my favored way of doing projects too. I always write the code that would use my framework/library first, and then write the framework/library itself. That way, any changes to the use code are done as a last resort.
Yep, no harm in a bit of breach of copyright, as long as it is for the betterment of all.
Erm no offense, but it looks like you are totally reinventing the wheel, why not use a framework like Django or TurboGears?
Finally!
Just nonlocal alone makes it worth switching, and ubiquitous Unicode strings do as well. Other fixes and improvements are welcome, of course; notably getting rid of the print statement (one statement finally dead and turned to expression; ~7 to go, please kill them all). I can live without the new (2.6) string formatting system though (what was ever wrong with str.\_\_mod\_\_?).
I'm definitely using it for new code where possible because I've gone through hell for unicode problems...