It's worth noting that PHP sends "the right stuff" by default - that is, you can `&lt;?php echo "Hello, world!" ?&gt;` and get a page in your browser with `Hello, world!`. With Python, you'd have to do some CGI-fanangaling to do that, which frameworks abstract away.
You're right. I will inform ares623
I did some test with [tesseract](http://code.google.com/p/tesseract-ocr/) and [pytesser](http://code.google.com/p/pytesser/). It is working fine, but I didn't use it in a productive project. 
Aw shit. Can't work on it until I get home from work. Thanks for the heads up.
Gotta say it saddens me that a programmer would even need to hide his/her browsing while at work. Sounds like something more suited to a McJob.
True, but that is why you can usually preview the changes. It's safer than search-and-replace, anyway.
You could make this very simple (and more readable, although not an obvious solution for someone new to programming in Python): def odd(string): return "".join(char for char in string if ord(char) % 2) In the original, instead of using ``pass``, you could rely on the fact that ``ord('w') % 2 == 1 == True`` and add the character to ``X`` there. This way you don't need an ``else`` statement. for x in S: if ord(x) % 2: X += x This is what my version does albeit using [a generator](http://wiki.python.org/moin/Generators) and the [``join`` method](http://docs.python.org/library/stdtypes.html#str.join). You should also use better variable names because ``X`` and ``x`` are too similar. Also note that a I put a space in between the ``%`` operator to aid readability.
Read through Django's tests and the Beautiful Soup 3.X code base. Looking through the standard library is enlightening, too -- especially if you haven't seen the code for `import this`. I'd also recommend reading through any of the pocoo projects (Flask, Werkzeug, etc) -- I know Armin's a redditor, and they're all up on Github.
Mercurial - concise, understandable, clean. They do not always comply with PEP-8, but code itself is very good IMHO.
It's still very funny and original :)
no argument there.
I don't have the time for this. The tests I've provided should be enough to fix it by yourself.
NLTK have examples using the portuguese language: http://nltk.googlecode.com/svn/trunk/doc/howto/portuguese_en.html NLTK can use any language is not restricted to english
&gt; It's safer than search-and-replace, anyway. I think I disagree with this statement. If you actually take the time to review each and every replacement you make, then maybe, but I find most people just fly through those replacements, giving each one maybe a second of their time. I can see why some would say it's safer because of of human error. I suppose there is an argument for both sides. It just depends on which you choose to believe more. :)
and django has its own [subreddit](http://www.reddit.com/r/django)
I'm going to have to disagree with it being hard to wrap your head around PyQt and Qt in general. Now, ease of use is a subjective thing and not everyone can get it at first. But I read *Programming with Qt and Python* by Mark Summerfield and it clicked in a few chapters how I was supposed to do stuff. PyQt and Pyside are extremely easy to pick up. YMMV.
You are doing it wrong. If you want to sell your product, provide a little abstract, a description. Then people who never heard of JAD might say: "hey, it's interesting, I need JAD, I'll try that".
This is just too damn funny. ;-)
I suggest learning Tkinter first and if doesn't suit your needs move on from there to wxPython or PySide. **Good Starting Tutorial on Tkinter** http://www.ferg.org/thinking_in_tkinter/index.html **Event Driven Article on Event Driven Programming** http://eventdrivenpgm.sourceforge.net/ **semi-WYSIWYG Tkinter** http://www.bitflipper.ca/rapyd/ 
Holy shit sir, amazing, terrific, wonderful!
I wouldn't nominate the PyPy source tree for any beauty pagents.
See CherryPy for good (Pythonic) library design.
The mercurial source is good, but it can be a little hard to read because it's more focused on speed/performance than most other python code.
This is a great question. Hopefully you'll get some more answers. I'd like to suggest an addition from a pedagogical standpoint: good examples are about more than just code quality. The code quality hits a threshold value at which it's excellent for others to read, above that threshold greater quality is a question of taste and likely unhelpful to the novice. (1) Instead, I think projects with "high enough" quality code should be sorted by length per accomplishment. This maintains a favorable ratio of time spent untangling the code base to time spent learning python while providing interval accomplishments to help with motivation. (2) The other obvious key to a good teaching code base is that it's a problem with multiple solutions. Your understanding of the problem domain is portable. Your ratio of problem domain to python learning will be least favorable on the first project. It would be a shame if your most inefficient time was also your only time. Additionally a tremendous amount of mid-level learning happens by comparing equally good but unique solutions to a given problem. Considering these additions I think micro frameworks may not be a bad starting place. They tend to be python top to bottom (no C black box waiting to frustrate you). They are relatively small. You have a lot of competing solutions to the problem to compare. They are well documented and blogged about. I'd say start with [Itty](https://github.com/toastdriven/itty) and then move to [Bottle](http://bottlepy.org/docs/dev/) and count yourself done once you've read and understood [Flask](http://flask.pocoo.org/). In the middle you might want to look at [web.py](http://webpy.org/) and [aspin.io](http://aspen.io/). Web.py does some really odd stuff (it's really a generation before these others) but it's almost a micro full stack (own forms, db, template etc library) so it's worth learning from. Aspin.io is totally different. Maybe I'm wrong about the micro frameworks and someone can suggest a better learning code base. *TL;DR*: * Good to learn from is about more than Pythonic * Good to learn from is easy to grok and thus typically short * Good to learn from has multiple implementations to compare * Good to learn from keeps you motivated by letting you accomplish something * Micro frameworks may be good to learn from. (added tl;dr) (added links)
~~I take it you haven't read Getting Things Done by David Allen.~~ I have been rude - I apologise.
[Jinja2](https://github.com/mitsuhiko/jinja2) is reasonably simple (8500 ohcount loc, the largest modules a compiler and a lexer) and widely used.
Thanks for the suggestions, I was trying to read through Django's source but I think it's out of my league currently. I'm currently working through Lutz's Learning Python 4th edition and it's like every chapter fills in another piece of the puzzle. Definitely the best programming book I've read so far.
You should hyperlink your suggestions.
I don't know if I so much helped with an answer as refined your question. I should add a tl;dr, I didn't mean for it to get so long. Learning Python is a great book. By the time you finish you'll really know how the language works, not just the syntax. Don't waste your time digging in to a massive code base. Just because something's good code doesn't mean it's good to learn from. Don't discount the value of encouraging feedback. If you aren't into web-dev don't screw around with web frameworks. Python can do much more. They were just the fist thing I thought of. I've never looked at them but I bet that a number of competing "drivers" for various nosql dbs are out there. I know CouchDB has multiple interface libraries. These may be good learning material too. 
done
Great! I am studying all the links you send me. Thank You So Much!
Yep... I agree -- have a look at the Pocoo projects. I'd first check out [Werkzeug](https://github.com/mitsuhiko/werkzeug/blob/master/) as it's well documented and if you're going into web programming will help you understand WSGI. They also make [Sphinx](https://bitbucket.org/birkenfeld/sphinx/src), a great documentation generator used by the most Pythonic projects.
I'm into web development and I have some programming experience (I "learned" C using the Apress book Beginning C.) I tried to use Django though and quickly realized that I need to first make sure I have a grasp of Python first before diving into Django (it seems much more self-explanatory if I have a good understanding of Python itself.) Right now, I just finished up part III of Learning Python and I'm using both Python 2.7.2 and 3.2.2 simultaneously (mainly using 2.7.2 and 3.2.2 whenever he's discussing a 3.x specific feature.) I'm going to be entering part IV shortly and this is where I think I'll see the turning point as that's when functions are introduced. :) Thanks for all the great info.
&gt; the standard math library namespace is hijacked What?
if you want you can read my code. I am a complete novice, but I am forging ahead in my project quiet well I feel. [here it is if you feel like delving into the madness that is my mind!](https://github.com/secgoat/Learning)
It's good that you are learning 3.x right from the start. It will be a long time before 2.x code is forgotten but you'll be ahead of the curve. If you don't mind running into some C from time to time the standard library is a real must read. Knowing it will keep you from reinventing the wheel and show you all the language features in use. When you get to the part in the book about the python data model and magic methods you could have a look at the [collections module](http://hg.python.org/cpython/file/2.7/Lib/collections.py) or when you learn about files you could check out [StringIO](http://hg.python.org/cpython/file/299ea19c3197/Lib/StringIO.py). Have a look at [ipython](http://ipython.org/ipython-doc/rel-0.9/html/interactive/tutorial.html) if you haven't already. Good luck. 
Agreed. As someone who has read through a fair amount of it, the code is solid, but can be hard to follow at times.
I've recently been doing some hacking on [redis-py](https://github.com/andymccurdy/redis-py) and it has some solid code.
I think the best examples are the newer Python standard library modules themselves. (Some of the older and less-well-used modules are not great examples.)
Check out http://simplecv.org
I would recommend against that… The OP won't be able to pick up on any of the nifty tricks one only learns after reading and writing thousands of lines of code, and they will likely pick up some of the bad habits one doesn't loose until they have done the same.
So far my method for reading the book has been, whenever Lutz refers or suggests reading the docs for any function, module or what have you, I read the doc page. As well as doing all end of chapter quiz's and end of part exercises (and writing all my answers out on paper For the quiz's I usually attempt to answer the question then scroll down on the pdf and read his answer and add whatever I missed to my answers, while with the exercises I code them and also write my code with explanations on paper as well, then after I finish with the exercises I compare my answers to the answers in the appendix and add in things I may have missed. I'm really enjoying learning Python though, it's a language that just makes sense and before this I couldn't do a single project Euler problem on my own. The book on C really didn't teach me how to program, it just seemed to teach me the syntax. Whereas with Python I'm absolutely thrilled for the next chapter because everything just makes sense and makes me immediately want to build something and test out stuff. I've been reading the book for nearly two weeks now and I'm at chapter 16 of 40 so I feel like I've made good progress. I must say though, chapter 15 was by far my favorite so far. It may not have shown me a lot of code but it showed me just how well documented Python is and how easy it is to make my own documentation. All in all I think I'm going to be using Python for a long time. :) Oh and sorry about the large post.
I agree, I probably have a ton of bad habits or WTF moments in my code. I just figured if you look at some one else's code who is at a similar level you won't be scratching your head wondering what they are doing. I try opening some projects and just get absolutely lost inside of them. Oh well, *Abandon all hope all ye who enter here*
I really like [tornado's](https://github.com/facebook/tornado/) code
As mentioned last time this came up. If you have constructive feedback for the Flask project, let us know :)
It's a cute idea and a good first try. One suggestion might be to try to make the mad libs data driven now, so that they're loaded from a file. Perhaps use yaml format for simplicity. Then you could add a mad lib editor. Then other ideas come to mind, but first: what are you looking to learn next about Python programming?
This was my original goal, have it easy for people to add there own, but I had a hard time with that. Do you have any tips/keywords I should use to look up? In regards to what I want to learn next, really anything is fine, just a general sense of the language is what I want :D EDIT: I can load line by line from a text file, I just don't know how to parse it and at it to the current list of madlibs
I noticed you have parentheses around strings unnecessarily in at least a couple of places: title = ("MadLibs Version 2.0") If you intended to make that a tuple, there needs to be a comma: title = ("MadLibs Version 2.0",) Otherwise, you don't need them, and I find them distracting. Normally, if I see parentheses around a string, I think "tuple." I also suggest reading [PEP 8](http://www.python.org/dev/peps/pep-0008/). Note that it recommends not having a space between a function name and parenthesis. It wouldn't be _as_ bad if you were consistent about it, but at times you have a space and other times you don't. In your function calls, you always assign `choice = 0`, but you don't have an if ... else ... case setup for `choice == 0`. If you're not going to account for invalid values, you definitely shouldn't assign one as the default input; the functions should probably just be defined like `functionName(choice)`. You also don't use `else` very often; take a look at lines 62 and 65 or 11 and 15. 65 should be `elif ...` (else if in many other languages). If anything, this will keep the statement from being evaluated unnecessarily. In the future, this will be important when evaluating if ... conditionals draws upon a processor or time intensive function; you don't want to waste time or cycles unnecessarily. All in all, not bad for a beginner, but there are a number of things that could be improved on, and I hope this gives you an idea of where to start. EDIT: One more thing -- line 14 is broken; sys.exit is a function, so the line should be `sys.exit()`.
PyPy support is pretty nice, but unfortunaly i've failed to use it with psycopg2, despite theirs wiki claims full compatibility. It turned out that this support was implemented at some developer branch, which failed to build when i tried it. I've just starting to think that all this full compatibility and almost production-ready project state is just an advertising for developers and testers.
Thanks so much for the detailed response! I have just started reading PEP 8 and noticed that I do tend to stray from it. Also, thanks for pointing out that I could just do functionName(choice), I didn't even think of that as an option. I plan to rewrite the code, and follow the PEP 8 guidelines more closely this time. Thanks again for your detailed and helpful response! EDIT: There is one thing I "disagree" with in the PEP 8 guidelines and that is the naming of function. I find writing them in mixed case enhances readability (for me) and actually shortens the name by not having to use underscores. Is it okay to break from the book and use mixed case? Is it common/acceptable for people to use mixed case? Thanks
It's okay to deviate form PEP 8, and as much as I dislike it, I see people use spaces after function names on a regular basis and still write nice code otherwise. If you ever write code that you want to be accepted into the Python core, though, I advise you to stick to PEP 8.
Upvoted and bookmarked because I had never heard of EasyGUI.
I agree with the spaces after function names, I don't like it either, they must have just slipped in there. Thanks again for the information!
It's great! Makes GUI's as simple as saying "give me a GUI!" (pretty much).
Which ones do you have in mind?
Sounds like a very studious approach. Have a look at the enhanced repls if you have not already done so. I use ipython, I tried bpython and dreampie as well. All have pros and cons. 
Well, I think I see your difficulty. The way you're doing it right now, you key off of which choice they have, then you know what the fieldNames will be. So your madlib data structure looks like this right now: madLibs = ["All About Him", "The New Dog"] fieldNames = ["Name", "Adjective"] Then you're replacing the value of your first madLibs value "All About Him" like this: madLibs[0] = ("%s is a fine fellow, s/he is very %s" % (fieldValues[0], fieldValues[1])) Instead, try to work with a structure that looks like this: madLibs[0] = ("%s is a fine fellow, s/he is very %s" , ["Name", "Adjective"]) madLibs[1] = ("We have a new dog named %s! S/he is %s, and not very %s but he is still a fine dog.", ["Name", "Adjective", "Adjective"]) So, then the madLibs list would contain the list of your mad libs and then you can load it up with data from a file. Note that you can add to the madLibs list this way: madLibs.append(("%s is a fine fellow, s/he is very %s" , ["Name", "Adjective"])) madLibs.append(("We have a new dog named %s! S/he is %s, and not very %s but he is still a fine dog.", ["Name", "Adjective", "Adjective"])) You can deal with lists without using the index # all the time and you can add to the list indefinitely, without knowing in advance how many items there will be. You can also do list comprehensions, etc. When you know what 'madLibs[:]' does, you will understand a bit more. Anyway, once you've collected your madLibs and your associated arguments to each in lists (which I actually already did for you above), you're ready to use each one. And this is the point where your program undergoes a fairly major rewrite, but it will become much shorter and more powerful in the trade. I would save off the version you had, and start with a new copy. If you want more help, just let me know when you've digested this much. Oh, and be sure to hit the Python tutorial for help on these subjects too. Section #5 has the material you need about lists. http://docs.python.org/tutorial/index.html 
Wow thanks! I really appreciate the work you put into this, and I plan on doing a bit of a rewrite later tonight. Thanks again, I'll tell you how it goes :D
Interesting. I hadn't seen using _ in front of a module name before. Is that an idiom for saying "this module is intended for internal use only"?
Used it for something small the other day for the first time, coming from django it's quite nice.
I've been using it with a throw-away Google account for a bit (mostly skimming through it). I was a little concerned about signing in at all, but so far it appears (to me) to be fine. It's got a few videos embedded into the text where someone walks you through / introduces that section. I've watched two, both were actually very good. The interactive part is well done. For example, they'll have some code as an example embedded in the text that you can play with. You can change it, run it, save and load it. Very handy. Similar to PySchools. The second kind of interaction is a "step-through" widget (also smoothly embedded into the text) that lets you see what's happening in real time to variables in loops (for example). You click "Forward" and "Back" to move through the code's execution, and you get real-time updates on the values. I don't know why it needs or asks for authentication to use. It seems well done. Am I missing something?
Thanks for that. I'm self taught (and it shows, I know) and have only used python when I needed to solve a particular problem. I realize that I'm not making this the right way and have had a hard time finding time to study what the right way is, but I do want to and will eventually. Thanks for droppin knowledge about parent class etc. I'll give that a shot. btw, I think this got to the frontpage of the subreddit probably because its so new. With a small readership, and a small number of posts, its just auto front page really. I'm guessing the ranking algorithm looks at age of the post.
Let's see, here are some newer modules: http://hg.python.org/cpython/file/8527427914a2/Lib/argparse.py http://hg.python.org/cpython/file/8527427914a2/Lib/email http://hg.python.org/cpython/file/8527427914a2/Lib/json
Yeah, my boss found what could have been a bug with path handling in sub folders (I *think* it was with the status command). I ended up looking through the code to figure out how it the command worked, and after wading through multiple files trying to follow how they handled file paths I eventually just gave up. It may very well make perfect sense to write the code the way it is, it's just difficult for a newcomer to follow. I Wish I could remember what the bug was so I could submit it, but sadly I didn't think to copy it down at the time.
I think you will need two very different approaches: (1) extract named entities (person name, law name, case name etc...) (2) extract topics (groups of correlated words) For (1), NLTK and or other algorithms are necessary -- you actually have to parse the language and single out words that are not verbs, prepositions, adjectives or common nouns. An example of how to use NLTK is https://github.com/apresta/tagger For (2) you can use Latent Dirichlet Allocation -- which is AMAZING. Given an unstructured document collection, LDA performs word counts on the documents and then finds "topics" that are discussed. Each topic is a mixture of words that tend to co-occur: ex: linear_algebra = {operator, matrix, eigenvalue, vector, ... } and each document will be modeled as a mixture of topics: ex: doc1 = {30% linear algebra, 20% mechanics, 10% smthing else...} So for example, the output of LDA tells you what each document is about, or alternately allows you to "browse by topic". There is a bunch of libraries out there, and as a shameless plug I will recommend the one developed by me: liblda --&gt; https://github.com/ivanistheone/Latent-Dirichlet-Allocation send me an email, and I can give you a tutorial on how to set it up the corpus of documents -- it will also motivate me add some decent documentation! There is also a really cool document browsing tool (TMVE), which can be used to browse the document collection by topic. Here is an example of a topic model fitted to a 1000 physics papers: http://www.cs.mcgill.ca/~isavov/arxiv_demo/readme.html Ivan
Have you read through a Python tutorial, such as the [official one](http://docs.python.org/tutorial/index.html) or [Dive into Python](http://diveintopython.org/toc/index.html)? You'll need *raw_input*, *if/else* and a bit of simple maths.
&gt; I am completely overwhelmed at this point You're overwhelmed because that's a lot of stuff to do. Just break it apart, and do one piece at a time. For example: You need to put some structure to the program -- at this point in the game, that's creating functions. * You need to get input from a user. How about "def get_input()" that displays a message to the user of what to enter, and gets them with raw_input. The last line will be something like "return num_credits_earned, num_current_credits". * You need a function to get the status of a student. How about "def get_status(num_hours):" that returns one "freshman", "sophomore", "junior", or "senior" * You need a function that returns how many more credits you need. This should be simple, and would be something like "def additional_credits_needed(current_credits):" that just subtracts current_credits from 125, and returns the result * You need a function for displaying how many additional semesters it will take to graduate. "def additional_semesters(credits):". This will just return credits / 15.0, since there's 15 credits per semester. * A function to display the data on the screen. Look at what you actually need to display to determine the inputs -- the rest can be within the function. "def display_results(class_status, additional_credits, additional_semesters)". Once you have those implemented, it's just a matter of putting the pieces together (first get input, then do calculations, then display the results). While you don't necessarily need all these in separate functions, it makes it a lot easier to break the program down into chunks, and take each part separately.
I second Mercurial. It can be hard to read (as others have said) but it's a great example of how to be a *pragmatic* Python developer without sacrificing what makes Python great. E.g., it's readable and easy to grok where it can be, but when performance matters they are more than willing to deviate.
It would be cool to have a learning by example site where modules &amp; applications could be voted up to be used as examples of best practices. And, ideally, there would be categories - such as: * functionality: unix admin scripts vs large transactional applications * sophistication: beginner-friendly vs advanced-skills required python So, I'm ready to start using this now. Anyone want to run out and build it?
JSON seems like a good suggestion. So far it and Hg are the two things I'm going to add to my reading list. 
This is the most valuable reply I get in my life! thanks so much, the project is → http://www.transparencia.org.bo, soon to release. I will send you a dm, and give you access to the text db so you can give me a hint. You are a Boss!
Okay here is what I have so far. I appreciate the help btw. creditsEarned = input ("Enter the number of credits you have earned to date: ") creditsEnrolled = input ("Enter the number of credits you are taking this semester: ") totalCredits = creditsEarned + creditsEnrolled if creditsEarned &gt;=90: print creditsEarned, "Class Status: Senior" elif creditsEarned &gt;=60: print creditsEarned, "Class Status: Junior" elif creditsEarned &gt;=24: print creditsEarned, "Class Status: Sophomore" else: print creditsEarned, "Credits earned. " + "Class Status: Freshman" How can I make it so only one print statement is displayed? Edit: Updated code
Yes, a leading _ indicates a name that is local only to the module it is defined in. Many projects extend this to module names as well. It is actually not just an idiom: For modules that don't explicitly define `__all__`, the default behaviour of `from X import *` is to import all names except those that start with an underscore.
you need elif. You could do something like: if ... elif ... elif ... else ...
Good advice, but it assumes a knowledge of functions. If Tuesday was really day 0 as programmer that's not a given. It's also not really a requirement of the asignment. The asignment could be completed without any user defined functions but it would include a number of duplicate sections. Those sections are fertal ground for introducing the value of factoring out code as functions. This could be tomorrow's topic...
Calm down and think about it. Writing things out on paper always helps me.
Thanks for the help fhsm. Now i'm about go attack the task of &gt;displaying anticipated class status at the end of the semester. 
You also changed your variable name in there from creditsEarned to totalCredits. but yah, you'll need elif (else if) in there.
Thanks. I noticed that right after I posted lol. 
 creditsEarned = input ("Enter the number of credits you have earned to date: ") creditsEnrolled = input ("Enter the number of credits you are taking this semester: ") totalCredits = creditsEarned + creditsEnrolled if creditsEarned &gt;=90: print "\n", creditsEarned, "Current Class Status: Senior" elif creditsEarned &gt;=60: print "\n", creditsEarned, "Current Class Status: Junior" elif creditsEarned &gt;=24: print "\n", creditsEarned, "Current Class Status: Sophomore" else: print "\n", creditsEarned, "Credits earned. " + "Class Status: Freshman" if totalCredits &gt;=90: print "\n", totalCredits, "Credits upon semester completion: Senior" elif totalCredits &gt;=60: print "\n", totalCredits, "Credits upon semester completion: Junior" elif totalCredits &gt;=24: print "\n", totalCredits, "Credits upon semester completion: Sophomore" else: print "\n", totalCredits, "Credits upon semester completion: Freshman" Cleaned up a bit and now I need to do display the credits required to graduate. . . Oh boy
You're right, I assumed he knew functions (which maybe he doesn't). I think the approach is the same though.
It will produce the same outcome as functions just a bit more tedious I'm assuming? 
&gt; credits required to graduate. . . Oh boy Let me suggest that you try 25 / 15 at the repl. This could save you from getting marked down. 
Sorry, repl?
yeah. You'll learn about those shortly. That tediousness is by design. It motivates the introduction of subroutines in a later lecture. Before long you'll learn to hate the phrase "factor out."
Sorry. If you are at the prompt and you type "python" and you see &gt;&gt;&gt; pop up that's called the "repl" which stands for read-eval-print-loop. You can test things out like what happens when you do 25/15 using the repl. 
This is an example of the repl in action: fhsm@linux_box(~/): python Python 2.6.6 (r266:84292, Sep 15 2010, 15:52:39) [GCC 4.4.5] on linux2 Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; print "This is the REPL" This is the REPL &gt;&gt;&gt; 25/15 1 &gt;&gt;&gt; print "WTF?! You couldn't seat 5 people at a 4 person table in your 5th grade word problems and you can't take 25 credits in 1 semester now..." WTF?! You couldn't seat 5 people at a 4 person table in your 5th grade word problems and you can't take 25 credits in 1 semester now... 
Oh yeah. I didn't know that had a name I always called it the cursor in the shell. Currently I have basically everything done but I want to clean it up a bit more. I'm trying to find a way to organize the data by justifying it. Also the math thing, as you stated, is messed up. how can I get python to round the number up to 2 semesters if the problem is 25/15?
&gt; math Python does floor division by default. In this case that's not what you want. You can make it do what you want by converting it to a float and adding 0.5 then converting back. int(((125-total)/15.0)+0.5) Here's what is happening: * Simple subtraction to find out how many hrs I need * int / float to yield a float (vs. int/int which is yields a floored int) * add 0.5 to the float, which is functionally the same as rounding up after the next step * convert back to an int so we get the rounded up version we wanted all along This is making use of knowledge of different data types. Given that you are using python and not C this topic may be covered much later than it used to be. Ints are integers and floats have decimals. Right now your program is making a lot of type assumptions about data types. This could also be used to motivate future lectures. Try typing different things in and you'll see that you can get different answers. Try: * 9 * 9.0 * frank * "frank" To really see the unexpected type creditsEarned as your answer for the second question... *edit*: as [terremoto](http://www.reddit.com/r/Python/comments/k80bk/freshman_cs_major_and_i_need_some_assistance/c2i8r76) pointed out if you are using [python 3.0 this will be totally different](http://www.python.org/dev/peps/pep-0238/). If you aren't using python 3.x another possible solution to this would be adding from __future__ import division to the top of your program. This, however, is really unlikely to be helpful to you at this point. Post the final result when you are done with it.
not as bad as i expected :)
Python itself!!!!!!
He could be using Python 3. EDIT: Although, based on the print statements, he isn't.
If you are into machine learning, check out scikits.learn
Good point.
i have done Engineering GUIs where there are some graphing, processing, networking with devices outside of the PC with pythons. basically imagine a device or a processor that collects some data and sends it to the PC and PC does whatever and graphs them. I ran into a lot of problems to begin with that did not make sense right away. Things was slow to show up, or it would take a long time to do things that i felt like it should take this long. My only suggestion is that i have learned not trying to avoid the problems is the best thing. I have researched and understood certain things about the problems which made the design easier faster, you just have to put some time into . 
I'm not sure if I'm reading you wrong, but you can absolutely use multiple files for Python code. In fact, you're already doing this when you use the "import" keyword. Edit: Also, to speed up image resizing, try using nearest neighbor or bilinear interpolation and see what the results look like. You're dealing with comics, so I imagine you can get away with bilinear, but nearest neighbor will probably give too many jaggies. Are you dealing with color or grayscale images in general? If your images are grayscale, you should leave them as "L" images all the time, not just when resizing.
Thanks... I think. Your message seems a bit cryptic to me, but I am slowly understanding it XD. Perhaps I wasn't specific enough though: My program is simply reading images from the hard drive, there is no network traffic etc..
Well I meant you can't seem to import local files, and I can't seem to figure out how to set it up so I can have multiple files.
That's an interesting euphemism for absolutely horrible.
Ah, OK. Well, you can definitely do that too. It's explained in the docs here: http://docs.python.org/tutorial/modules.html So in your case, you could put all the code for the folderDialog class into a separate file, call it folderDialog.py, and import it in your main file with import folderDialog Of course, then you would have to use folderDialog.&lt;whatever&gt; when you wanted to use something from that file. The way around this is to use (as you've done with other modules) from folderDialog import &lt;something&gt;
i know what you are saying. I was merely talking general with GUIs. I was saying explore your problems and gather more information about it. It might help! sorry
To your edit: I'll try using Bilinear, currently I had been using Bicubic. Also I had set something up, where on window resize it would resize in nearest, and then after a timeout use bicubic so the image wouldn't lag or just not resize as the window moves. Generally the images are grayscale, and when they are they are always converted to "L". 
One other thing: for overall structure of a GUI program, look into the [Model-View-Controller](http://en.wikipedia.org/wiki/Model-view-controller) architecture. Structuring your code in this way should improve performance and readability, and make it much easier to add features down the line.
I'd recommend to use better GUI bindings. Although Tk has its advantages, none of them are relevant to your project. Common candidates nowadays are PyQt, wxWidgets and PyGTK.
Hmm. So what are the pitfalls of Tk and the advantages of PyQT, wxWidgets, or PyGTK then?
Tk will look alien and weird on almost all major OSes. It's also kind limited comparing to other GUI bindings and I'd bet you'll inevitably reach its limits with a tool like yours. Quick look at your code reveals nothing suspicious, so the resizing issue might be Tk (or Tkinter) problem and it just doesn't worth it to resolve. Other bindings has their own disadvantages too (licenses, heavy dependencies, etc.), but these aren't really technical ones.
I don't understand why people take such liberty with the term REST. The example on that page is RPC-over-HTTP, not REST. It's embarrassing for our profession when so many people abuse a term they clearly don't understand.
Well, words mean what people mean by them. Twitter calls such API "REST". So people call such API "REST". Unfortunate maybe, but it's what it is.
I understand that language is a living thing, but REST is a very specific term with rather esoteric origins. It seems like any self-respecting software person would try to learn what it means before blatantly misusing it. We're not talking about the lazy use of "kleenex" here.
Hence "RESTful", not "REST". Haha.
Relevant? http://kellabyte.com/2011/09/04/clarifying-rest/
I don't understand why pygame tutorials always use wildcard imports. It is a strange trend that makes code more unreadable. 
There are los of ways to try to protect code from being copied but almost all of them involve creating a fairly hostile working environment and almost all of them provide nothing but the illusion of safety. In the end, you're more likely to attract an awful set of coders who produce code that wouldn't be worth stealing unless you're prepared to pay a stellar premium. The 'next Amazon' wouldn't be built entirely on code anyway it would take a whole team of multiskilled people and any theft at any level would compromise you equally. Not to mention the entire argument is moot when you realise it's illegal and secondly it's unlikely your code is going to just drop into their code base at all. So unless it's some kind of rocket science-y whizz bang, it's not worth the risk or effort. All they need to do is to user test your site and duplicate your features.
Right so then you sue them if you ever find out, and it would ruin them.
This is going to be nice!
Like others said, it helps to keep your code separated into different files and import them. Here is an [example project structure](http://pastie.org/pastes/2501419/text). Here is [a little project that I haven't had much time to work on](https://github.com/techwizrd/GitKraken) that I threw up on Github to give you an example of what the structure should look like and what the files should contain. Since this is a proof of concept, you should focus on understanding how Python code is organized and run and the basics of how GUI toolkits work. You can worry about dependencies and licenses later when you're more confident in your Python skills and understand the packaging process. If you choose GTK+, I'd recommend using Glade to design the UI and then load it with PyGI and GtkBuilder (PyGTK and libglade) are deprecated. If you would like help with that, send me a PM. The advantage of this method is that it separates the View part of MVC from your code and you can write the Model and Controller yourself to keep everything nice and organized. Also, another project similar to the one you're writing is [Comix](http://comix.sourceforge.net/), but competition is always good in open-source and you can always learn from examining their code. Again, if you need any help, please feel free to PM me. I'm also working on a project that will create all of this boilerplate for you, and talking to potential users like you will help me figure out what types of features I should have.
Do you always turf your own links in the third person? You might want to be more clear about your... intimate connection to your link next time. 
PyGUI is native widgets and cross platform.
qt
Qt, I'd imagine that TKinter would be gone if it could be from the std library.
Hi there! There's also a subreddit aimed at specifically trying to bring Python developers together over at /r/CollaborativePython . It's a new subreddit and we'd appreciate all the exposure we can get.
Use Traits. 
otoh qt is quite large and updates versions at its own pace.
On the third hand, Qt is current gen and available for pretty much every platform, including mobile devices. Unless you're maintaining or locked into Tkinter for reasons such as 'it's what you've been coding in for ten years'. Then there's really no reason to be using Tkinter for a GUI app nowadays. In my opinion anyway! PyQt4 is especially forgiving and clearly laid out, especially for beginners.
I meant with respect to inclusion in the python std library
Even though it's pretty much impossible, I'd like PyQt, or PySide to be included in the std library. Tkinter is really showing it's age.
Everybody makes a todo/gtd application. Good for you, this one looks actually nice enough to be used by somebody else as well. Now its time to step a level up and help pypy :) 
After studying both for a few days, I've purchased a license for WingIDE. Thanks everyone!
Thanks! I am continually revising it and trying streamline, and bugfix etc. Still a long way from completion, but for my first real project I feel good about it.
He's referring to the fact that in `https://github.com/dag/attest/blob/master/README.md` the name `math` is used to create an instance of Tests which, while not breaking anything in this instance, is bad practice. You shouldn't name variables the same as built-ins, although this time it's a part of the standard lib which isn't being imported I would still classify it as bad practice.
&gt; is bad practice Who came up with that rule? So using the name "xml" is bad practice, using the name "random" is bad practice, using the name "string" is bad practice, using the name "mutex" is bad practice? What about "operator", "email", "wave", "site", "warnings", "code", etc. &gt; You shouldn't name variables the same as built-ins Stdlib modules are not builtins. Builtins and stdlib modules change over time. What do you do when generic names show up in the future. Rewrite all your code? There is no harm in shadowing anything since you can just rebind them to a different name. I am doing Python long enough and shadowed anything has never been a problem for me. The problem used to be implicit relative imports but those have been deactivate-able since 2.5.
There is no harm in shadowing **if** you are aware of what you are doing and remember what you have done later on. Hell, even in the standard lib some of the built-ins are shadowed, but that does not make it best practice.
I fucking love Python, but your question and comments suck. 
Care to elaborate on how this is relevant to this contribution to sphinx?
&gt; but that does not make it best practice. I much rather see shadowing best practice than coming up with stupid names to not shadow stdlib modules. Having to type `math_` because someone might at one point import math in there and does not want to alias it is just over protective programming that kills the fun and lowers the code quality.
PyQt or PySide
I think your argument is equally applicable to search and replace. The benefit of automated refactorings is that unlike search and replace, they are usually context-aware. In fact, I think the easiest way to understand them is by thinking of them as a form of search and replace that actually understands the structure of your code.
Nah you don't know.
I agree stupid variable names are stupid, but in this specific case why not name the variable `math_test` ? It's actually more descriptive and from a glance you can tell what the variable is for.
Please forgive my ignorance, but would you care to explain why you believe the example is not RESTful (or why it is specifically RPC) On the first example we have: GET /users/1/posts/programming get all of the programming related posts created by user 1 I don't see a Procedure or method you'd be calling to make this RPC (only verb is GET, the rest are nouns) and it appears, stateless, and uniform. Is it because there are no hyperlinks to other resources? neither example has a response that refers to other resources. Perhaps it is not precisely RESTful, but if i had to give it a label, i don't think 'RPC' comes to mind. (/getPosts?user=1&amp;tag=programming would be closer) 
pyQT - the bindings for qt/c++. Will solve a lot of your problens, eg settings, file and net access, x-platform et all.. Trust me I wasted HOURS on pyGTK and wxWidgets.
The entire feature seems to be mislabeled. If it's a web service that consists of URLs that must be constructed by code according to some template, then that is not REST. REST is driven by hypertext, and the URLs should be opaque and provided by the service, just like a webpage provides you with full URL hyperlinks instead of just giving you an ID and making you construct a URL yourself, based on some out-of-band knowledge of how the service wants its URLs constructed. http://en.wikipedia.org/wiki/HATEOAS http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven
See [here](http://www.reddit.com/r/Python/comments/k8g75/sphinxcontribhttpdomain_documenting_restful_http/c2id50h)
*tips hat* What were yo working on?
&gt;Multi threading does not work great in Python. It is inconsistent across platforms. What tools were you using? I would think the standard lib tools would be consistent. 
In my experience multithreading is fine if you use separate processes and queues to pass data around. Futures will be an interesting choice moving forward in Py3. 
probably means the support across platforms. Works great on POSIXish, windows not so much. That's how it is with subprocess and multiprocessing in my experience. 
Ah, I think that's what I heard. Thanks.
replied to the wrong person...
did it again... i need caffeine...
They're not bugs, but rather IPC issues. See, you can't really share state between processes, so some kind of IPC layer had to be constructed to make this work. If you use the multiprocessing library like you would use the threading library, you're in for some headache. Use the strategies you should have been using before (use channels, queues, and such instead of shared state and locks), and avoid sending/receiving un-pickle-able objects, and it actually works quite well. The multiprocessing.connection library is quite dreamy. Threading should be better in 3.2.2. There has been a major overhaul to the GIL, so you should get closer to single-thread performance. If your native extension libraries are designed to release the GIL while they're doing... whatever they do, then there's still some major benefit to using threading, performance-wise. Threading is complicated. Anyone who tells you otherwise is either lying to further some agenda, or doesn't truly understand threading themselves. 
I have been using futures (implemented myself) in Python 2.x for a few years. Works out great for the most part.
Reminder: most set functions (e.g., methods with a human name, but not __ror__) will work on any iterable
For example, let's say you have a log file: ABCD 1234 On IEIA 3445 Off GJJW 3342 Off ABCD 4563 On And you wanted a list of all the elements that make up the fist column. x = [] with open('file', 'r') as file: for line in file: current = line.split()[0] if current not in x: x.append(current) OR! x = set() with open('file', 'r') as file: for line in file: x |= set([line.split()[0]]) Also, obviously, they are excellent when doing set operations on lists. If you're writing a loop on two lists, see if you can use sets to solve your problem. 
Threads work perfectly fine on Windows. OP either confuses them with multiprocessing or has something else in mind.
Can you clarify #3?
Wait... threads are fine as long as you use separate processes?
&gt; 3. A class representing a working directory is great. This is an interesting one, and it makes me very curious to know what kind of project you were working on. What were you working on?
#9 - It depends hugely on what you're using it for
As much as I try to like Pycharm, and I downloaded this new EAP and tested it out, I just prefer WingIDE (http://www.wingware.com) instead.
Not all of them! https://github.com/whilefalse/webpy-mongodb-sessions
Sorry, I mixed up my terminology. By 'multithreading' I meant having different pieces of your code run in parallel. Threads is python (because of the GIL) are run sequentially, not in parallel. This is unlike other programming languages/environments. They are good for IO bound operations, where you would be waiting anyway. Processes are really separate processes, running with their own GIL. This means they can't easily share data using locks/shared memory, but interprocess queues work pretty well. 
Also elaborate, I have no idea what is meant by #3.
&gt;implemented myself [Nice](http://i.imgur.com/BmuFL.gif)
I'm not really familiar with MongoDB, isn't the data still saved on disk?
Threading in python is sub-par when compared to JVM due to global interpreter lock. And both JVM and Python are sub-par when compared to Erlang due to effort in managing mutability of objects. Basically, threading is hard to get right. And this going to be a huge problem when everyone has 32 cores on their cell phone and 256+ cores on their desktop. 
I'll add one. If you find yourself adding a lot of type checks or designing a system that attempts to enforce consistency, you're probably being unPythonic.
This is been my experience too. Just fork a set number of workers, and use inter-process messaging. You have to be a little cautious on Linux, though, because some kernels will, by default, blame the parent process for the sum of the child processes' memory consumption (including shared memory), and kill it when memory starts running low.
&gt; but interprocess queues work pretty well. zeromq works even better. :) 
I think a community-wide boycott of Tkinter is what we need. Thoughts?
I guess you really do need caffeine?
Hey no problem, I fully support anyone who wants to become a better programmer. I've been programming since 7th grade, and I still think of myself as only a fair programmer. I'm completely self taught, too. and I've read dozens of books, and spend at least one hour a day reading programming articles. I highly recommend reading "Learn Python THe Hard Way". Also, read the code for projects that you find interesting, and find out what it does. Python has some interesting concepts if you're coming from a different programming background, which may seem useless and complicated until you find something that it's extremely useful for. I thought that about decorators for a long time, until I realized you can use them to transparently wrap code in a try/except, to prevent Python from throwing errors and quitting for basic errors that can be recovered from (which you'll likely encounter using SQL databases). Python is a completely different language than PHP (I literally read every page of your site, and saw you used it on some of your projects). The PHP community has a kind of "just wing it" mentality, whereas the Python community is more design oriented. Generally speaking, the code in the Python community is higher quality, and gets reviewed by peers more, which could explain that. I guarantee if you code in Python for a year, you will become a better programmer in every language you use.
Looks like you're getting some help from rcklmbr and others. I just want to point out that in your original post you really didn't state what specifically you're having trouble with. Your professor could have told you what functions to make and exactly what they need to do, but he/she chose not to. That means that part of the assignment is for you to think about how to translate this written description into code. I understand that can be difficult if you haven't worked with a programming language before, and it could take some examples and some experience to learn this manner of thinking. I'm just mentioning it so you're aware that breaking down the problem is part of the problem.
See http://wiki.python.org/moin/PythonSpeed/PerformanceTips
&gt; 1. To have a python-project that one is afraid to touch is not fun. &gt; 2. That will happen if there are not enough modularity and tests. The good thing is that you don't need to buy into TDD completely, write any unit tests, create any mock objects, etc. Just write some tests that exercise the entire functionality of your application (or its part that runs without user intervention), and suddenly the fear completely disappears, even though in reality you did not completely eliminate the possibility of breaking everything without noticing.
That's not its biggest problem even. If you're going to document any kind of RESTful service you need to start with representations and how manipulating that representation influences the system. The uniform interface (GET/POST/XYZ) and URLs itself, should the system be RESTful, are completely *irrelevant*. This is the quickest litmus test for any RESTful service. The truth is, RESTful services are very much like Haskell — incredibly difficult to get right for what they do and it’s not entirely clear whether they can be even used in practice for any non-trivial tasks. If you’re going to write a non-trivial RESTful service, then this is something that is quite remarkable, and I expect you to provide an entire article series about such a feat, not just a page of documentation. 
http://taotetek.wordpress.com/2011/02/03/python-multiprocessing-zeromq-vs-queue/ Colour me impressed :D
awesome examples of project setup, this is python info i am always looking for more guidance about. thanks a bunch :) 1 question. you place the tests folder outside the myapp source folder, how do you handle importing classes from myapp?
 /getPosts?user=1&amp;tag=programming There’s no reason this URL couldn’t be a part of a RESTful system. This URL is entirely fine, as long as returned posts have some canonical location like ‘/getPosts?id=xyz’. EDIT: Also there’s no reason you can’t have a RESTful architecture being done *via* HTTP RPC. HTTP is *irrelevant* to the RESTful architecture — the only requirement is uniform interface. That could be some subset of SOAP, even. 
Honest question here. Why do you do: x |= set([line.split()[0]]) Instead of just: x.add(line.split()[0]) Is there an advantage to the method you used that I don't know about?
Not always, but the fact that I use my real name for my username makes the connection obvious enough. I just didn't want it to sound like a "hey guys, look at my stuff and shower me with praise" headline.
This is my attempt at the question, i made it unnecessairly complicated to showcase some of python's features such as functions, module imports and exceptions. If you don't understand it i would reccomend reading some tutorials, such as those takluyver suggested. https://gist.github.com/1204307 PS: Please don't copy any of my code :)
Only because I saw this - http://indefinitestudies.org/2009/03/11/dont-use-setadd-in-python/ - but I haven't done any speed testing myself. :D
Tip: use list comprehensions / generator expressions. x = set(line.split()[0] for line in open('file')) 
 Twisted turbogears If you use gentoo, dig through portage it's got a lot of nifty things in it. I stole their color methods for a lot of my scripting work. 
yeah and note in that example that the zeromq is communicating over tcp which in theory should be slower than IPC, I'm sure that using zeromq's inproc (assuming a unix system) would have been even better than that.
How does that relate to being inconsistent across platforms though?
If performance will be a regular need for you, then you should either invest heavily in python module development(writing C) and understanding the benefits of Numpy arrays..... or use a language designed for speed: Java, C, C++, Google Go. Pypy does go a long way towards helping here also, but has a lot of caveats.
I know it was a month ago, but an upvote for you. I'd done a fair amount of this in python/django already. Since python has a json package, this will be so much easier. Thanks a bunch.
Thanks for the help man ;) This is what I ended up with at the end of yesterday and so far it looks about right. #Class Calculator # creditsEarned = input ("Enter the number of credits you have earned to date: ") creditsEnrolled = input ("Enter the number of credits you are taking this semester: ") totalCredits = creditsEarned + creditsEnrolled graduationRequirement = 125 - totalCredits semestersLeft = graduationRequirement / 15 if creditsEarned &gt;=90: #Start linear process of finding class status print "\n", creditsEarned, "Current Class Status: Senior" elif creditsEarned &gt;=60: print "\n", creditsEarned, "Current Class Status: Junior" elif creditsEarned &gt;=24: print "\n", creditsEarned, "Current Class Status: Sophomore" else: print "\n", creditsEarned, "Current Class Status: Freshman" #Start calculating class status after the semester is over if totalCredits &gt;=90: print totalCredits, "Credits upon semester completion: Senior" elif totalCredits &gt;=60: print totalCredits, "Credits upon semester completion: Junior" elif totalCredits &gt;=24: print totalCredits, "Credits upon semester completion: Sophomore" else: print totalCredits, "Credits upon semester completion: Freshman" #two print statements to show 'credits needed to graduate' and 'semesters left' print "Student will need ", graduationRequirement, "credit(s) to gradutate." print "Student has approximatly",semestersLeft, "semesters left averaging 15 credits per semester." """ End Program """ 
Do list comprehensions handle closing the file handle, like the with statement? If so, much better solution. :D Used a filter with a list comprehension for the first time during the project. I &lt;3 functional programming. 
I was responding to *Multi threading does not work great in Python* 
Also set comprehensions in 2.7+: with open('file') as file: x = {line.split(None, 1)[0] for line in file} Those arguments to split makes it only split once, which may be faster (and is totally a premature optimization hurting readability!)
Also read the comments.
Fair enough.
You. Need. More. Upvotes...
In addition to what sedaak and remroy mention, I have in certain situations used things like [Shed Skin](http://shed-skin.blogspot.com/) and [Nuitka](http://www.nuitka.net/blog/nuitka-a-python-compiler/what-is-nuitka/) to speed up Python. *edit*: Poromenos has an article about [Shed Skin](http://www.korokithakis.net/posts/speeding-up-python-code-with-shedskin/) (and a previous one on [Cython](http://www.korokithakis.net/posts/optimizing-python-with-cython/) )
About #2, and tests: the best lesson I ever learned in python was when I tried to submit a bug report in a python3 module. The guy responsible for that module insisted that I add a patch to the python source tree with a unittest that proves the bug I was talking about. At first I was upset because I had to check out the whole python source tree (although surprisingly small), and learn how Lib/test/ worked and the coding convention there, then learn more about unittest etc... But, then, this change how I work. Even for small-ish scripts I tend to write unit tests as I write the code. I can now go back to code that's a few months old and have no fear of changing it. Once I've added my changes, I can run the tests and be confident that everything works how it's supposed to do so. I had read and played with unit tests, but I had never seen an environment where every change needed a unit test, and forcing to play nice in that environment showed the power of it. *edit: **s/**although surprisingly slow**/**although surprisingly small**/**
Ohhhh set comprehensions! This is what I really like about Python: You know lists? Oh, use lists, but you'll write a few more lines. Oh, you know sets? Use those! Oh, you know list comprehensions AND sets? Use those! But, of course, you could use set comprehensions! I very rarely see that kind of flexibility in other languages I use. 
One of the older, cooler more knowledgeable guys at my workplace gave three advices on optimizing code. * Don't * Don't yet * Profile first That aside, I see others have given proper advice if your profiling should present a need for optimization. 
Solution: Jython!
And if you really want "Visual" development, you can always use the Qt Designer to design your window forms. They save as *.ui files (which are really xml files). Then compile it using pyside-uic (or its PyQt equivalent). It will generate a .py file.
no, you need a with statement to make it happen automatically for a short script it will be closed as soon as the script ends so it may be unimportant.=
Interesting question... Certainly there's nothing keeping the file open, but I don't know at what point Python would decide to close the handle. Presumably when garbage collection kicks in (at the latest). Would it matter since the file was only opened for reading?
The only benefit you used is the uniqueness. Is that right? For the love of all things legible please don't use |= when add works fine.
I haven't done it but you should be able to start with *from java.lang import Runnable* and create your code as a set of classes as *class FooBar(Runnable):*that make use of the JVM Thread model. 
I think he might be referring to something like the [path module](http://wiki.python.org/moin/PathModule), but I'm not really sure. edit: related, rejected [PEP-0355](http://www.python.org/dev/peps/pep-0355/)
In my example, yes, but not in the script I wrote (though uniqueness was a very nice feature). 
mine was: q = '"', "q = '{0}', {0}{1}{0}; print(q[1].format(*q))"; print(q[1].format(*q)) or, more readable: quote, quine = '"""', """quote, quine = '{0}', {0}{1}{0} print(quine.format(quote, quine))""" print(quine.format(quote, quine)) 
It was a fun little program to make :)
I misread your post. MongoDB does save to disk like any old DB.
Every Python developer should read this book. People who have been coding in Python for years will still pick up stuff. I've read the book about 1.5 years ago, and I want to read it again just because I know I'll pick up a lot and appreciate it more since I've been writing Python for about 2 years now. tl;dr: read "Learning Python" by Lutz.
You are however, executing threads in parallel. The only limitation is that only one thread can hold the GIL at a time. (This means you *can* do things like IO in parallel with threads in Python)
very cool, but I am a little confused as to what some stuff does, or how to do some stuff such as setup.py, .desktop file, and the __init__ file
Interesting... I will try this out.
So many of you have been suggesting that I use a different GUI toolkit. I am very interested in this. My one concern is that I will be compiling this into an exe for users that don't know how to use python, essentially. So I need to know that it won't impact the executable too heavily. Besides that there seems to be 3 versions of pyQT (one that many people have recommended), which should I use, if pyQT at all? EDIT: Also, do any of these GUI toolkits have image viewers/function that I should be using instead of PIL/how would they interact with PIL? (I will need to be resizing 2000X4000 pixel images sometime, read from hardisk)
You don't even have to do that. Jython will use JVM’s concurrence by default — it really doesn't have much choice. The problem is that Jython development seems to have stagnated and no one can promise that it’ll continue. On the other hand, IronPython supports ‘real threads’ (with fine-grained locking), [its development is very active](https://github.com/IronLanguages/main) and the company behind it seems serious about supporting it [\[1\]](http://ironpython.net/tools/) [\[2\]](http://www.zdnet.com/blog/microsoft/microsoft-puts-ironpython-ironruby-under-an-apache-license/6872). I just wish, the IronPython–Mono community could get better organized. Hopefully with reinvigorated efforts of the startup behind Mono that will happen soon enough. 
If you use CPython/PyPy’s threading. Jython/IronPython use different concurrency strategies. Nevertheless, GIL-based threading is fine for I/O concurrency and CPU concurrency using C-extensions that can return GIL. 
DAE hate the philosophy of modules in Python? I prefer Java, where each class/file has a specific purpose.
I am trying to figure this out still. 
There are 2 parts &gt;x="x={0}{1}{0}; print x.format(chr(34),x)"; &gt;print x.format(chr(34),x) which these work exactly as you'd expect, it assigns a string (kinda strange one) to x the string.format function will replace {0} with the first parameter and {1} with the second, so a call to format(chr(34),x) will replace {0} with chr(34) which is " and replace {1} with the string in x so if we take the original string x={0}{1}{0}; print x.format(chr(34),x) Replace {0} with " &gt; x=**"**{1}**"**; print x.format(chr(34),x) and replace {1} with the string in x. we get: &gt; x="**x={0}{1}{0}; print x.format(chr(34),x)**"; print x.format(chr(34),x) Which gets printed out. And that happens to be the original code. 
It looks nice. I'm especially waiting Flask library :)
Agreed, I'm learning a lot more from it than Apress' book (forgot the name but I think it's beginning python) 
Take a look the setup.py, .desktop file, and the \_\_init\_\_.py file in the github project I linked. The Python docs explain [how \_\_init\_\_.py is used](http://docs.python.org/tutorial/modules.html#packages). In short \_\_init\_\_.py file tells python the directory should be treated as a python package in particular, look at [GitKraken/gtk/\_\_init\_\_.py](https://github.com/techwizrd/GitKraken/blob/master/GitKraken/gtk/__init__.py). I used the \_\_init\_\_.py to set the paths of the XML files describing the GUI so that I could pass them to GtkBuilder in the project_manager.py and dialogs.py. This article on the [Anatomy of .desktop file](https://linuxcritic.wordpress.com/2010/04/07/anatomy-of-a-desktop-file/) is pretty helpful. Again, the Python docs have a useful page on [how to write a setup.py script](http://docs.python.org/distutils/setupscript.html). You can also look at other python projects like Django and Getting Things GNOME! to see how they use these things. I figured out this structure from examining lots of projects.
I suspect he means that setting up a "directory" class can come in handy, so that you can have directory objects with associated methods (empty directory, get list of files, delete directory, make sub-directory, etc).
The multiprocessing module works fine in my experience, but I suppose it's only a work-around for threading for some applications.
Thanks man. I'll check out that book!
It's completely free online, as well! If you want a physical copy, you have to buy it though. http://learnpythonthehardway.org/book/
Ok here is my triple punch. Since you didn't specifically mention the nature of your script, I'm assuming you mean number crunching. First level: [Code like a Pythonista](http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html) This is a simple first step, learn the proper idiomatic syntax. Speed wise that would be replacing O(n) stuff (lookups in lists for examples) with O(1) (lookups in dictionaries). Memory wise it would be replacing iterations over temporary lists with iterations over iterators. Simple stuff to learn, and they give a nice and tidy boost to performance. Second level: Numpy, Numpy, and Numpy. It takes a while to get used to the syntax, but trust me, once you gone Numpy you never really want to go back. Long story short it's a simple way to get closer to the metal, datastructures are laid out the way processors like them to be. This level: [As always, all roads lead to C.](http://www.scipy.org/Cookbook/C_Extensions/NumPy_arrays) Now this is the most labor intensive option, but also the one that will give the biggest speed increase (implemented the correct way that is). The gist of it is that Numpy arrays can be 1 to 1 translated to C arrays so the interface between the two becomes trivial. There are a lot of examples on that website to get you going.
One simple step would be to try using PyPy. If your code is mostly about calculations, and does not use numpy (yet, pypy people are working on that), there is a chance that it might match speed of C code.
Oh I forgot about PyPy. I'd easily vote PyPy for the most exciting thing going on with Python right now (actually for a while I guess). They are just hammering out speed increases like clockwork. Hugely impressive.
I like being able to group things the way I want to. I like not having to open up tons of files just to study how one thing works. You can limit a module to a specific purpose without forcing each related class into separate files.
Back in my day, we just used dict keys to make these newfangled "sets". (Stay off my lawn!)
Dictionaries would mean setting a dummy value. Eww :P
No, I despise having to work on languages that require an IDE to make any sense out of them.
Say you wanted to parse a bunch of logs of different formats. 2 schemes could be. - Have a monolithic LogParser module with classes TypeAParser, TypeBParser, etc. - or have modules: -- TypeA with a Parser -- TypeB with a Parser -- TypeC with a Parser I prefer the second scheme even though it would result in more files.
can you show us the script ?
How does the file get closed ?
the with stanza closes it automatically -- look into context managers for more details.
&gt; x |= set([line.split()[0]]) what does the "|=" part do ?
Got any good intros to python unit testing...? *Edit:* The [online docs](http://docs.python.org/library/unittest.html) are fine.
I know "with", I just wonder how *that* line closes the file 
Counter in [collections](http://docs.python.org/library/collections.html) is definitely worth checking out too if you're doing text processing. In fact, all the datatypes in collections module are worth spending some time with getting to know.
Nothing is stopping you from doing the second scheme in python.
I have used PyQt to write an image viewer. First, there are 2 Qt libraries for Python: PyQt and PySide. PyQt is more mature and works with Python 3, but is GPL licensed. PySide is licensed with the more liberal LGPL. They are otherwise pretty much the same. Use PyQt unless for some reason the GPL is a problem for you. Second, you will probably not have to use PIL much, unless you need to support some less common image formats. You can copy image data from PIL if you need to, but PyQt supports the most common formats using plugins. This slightly complicates packaging into an executable, but you just need to make sure you copy the plugins. Packaging PyQt is otherwise pretty simple using py2exe or PyInstaller for Windows or Linux. py2app is more complicated if you need to support OSX. Executable size will be around 25mb for windows, closer to 100MB for Linux and OSX, but that will be the case for other GUI libraries too. Finally, read the docs for the Graphics View Framework. It can do some amazing things for you. It allows you to use transformations to scale, zoom, stretch your images without using expensive resizing algorithms. This alone makes it well worth it for an image viewer. Besides that, having used all the others quite a bit (except wxWidgets) it has, in my opinion, the nicest API and most complete feature set of the GUI libraries for Python.
k
Really? 25mb.... I'm not sure how worth it that is, seeing as currently it's about 4.5mb with tk included.
yeah I don't fucking get the bitwise crap
I mostly like using sets to remove duplicates from a list: x = list(set(x))
Look into python nose. Its pretty straight forward.
Cute :) Good example for a n00b like myself.
Eww. :-) ... Yeah, I've been playing with the doc examples...
Here's a self replicating shell script: 
Something else I want to look into that I know github uses is: http://jenkins-ci.org 
With writing to buffered streams closing kicks in flushing. However with reading it’s not all that important, though I suppose one exception is if you’re using filesystem-level file locking. However since CPython is ref-counted, you won’t get memory leaks because of not-closed file descriptors. This is more of an issue in PyPy/IronPython/Jython.
«`|`» is the [`__or__ `/` __ror__` operator](http://docs.python.org/dev/reference/datamodel.html?highlight=__ior__#object.__or__). The following assertion is true: `set a` ⇒ `a | b` ⇔ `a.union(b)` «`|=`» is the [`__ior__`](http://docs.python.org/dev/reference/datamodel.html?highlight=__ior__#object.__ior__) operator; it’s the in-place (mutable) variant of `__or__` operator: &gt; These methods should attempt to do the operation in-place (modifying self) and return the result (which could be, but does not have to be, self). Here’s `set`/`frozenset` example illustrating the difference: &gt;&gt;&gt; a = b = set({1,2,3}) &gt;&gt;&gt; a |= {3,4} &gt;&gt;&gt; a set([1, 2, 3, 4]) &gt;&gt;&gt; a is b True &gt;&gt;&gt; a = b = frozenset({1,2,3}) &gt;&gt;&gt; a |= {3,4} &gt;&gt;&gt; a frozenset([1, 2, 3, 4]) &gt;&gt;&gt; a is b False
Just something small in case people see this later. from __future__ import division "future" was bolded in the above post due to reddit markup.
Here's my self-replicating Python script. I call it "fail.py". File "fail.py", line 1 File "fail.py", line 1 ^ IndentationError: unexpected indent 
Sorry it took so long. I've been a bit busy. I hope you guys send me pull requests for other languages' syntax. :D
That is beautiful.
i'm curious what advantages of Redis over simply maintaining a dictionary in memory for session handling?
Download the source of cpython, look at the scripts in Lib/test.
I find this really helpful when piecing together data from different sources. 
The book [Expert Python Programming](http://www.amazon.com/Expert-Python-Programming-practices-distributing/dp/184719494X) has a couple of chapters on optimisation, and google will probably give you plenty of articles on the subject. It would help if you gave us some clues as to what you program does, and how it does it - we may be able to make some suggestions ourselves. Have you profiled the code? That is the first step in any optimisation work - if you do not measure exactly where it is spending the time everything else is irrelevant.
Python is refcounted.
Use the semantically well-meaning True as the value.
Tons of ways to do the same thing. Isn't this why people hate perl? :)
Or you could just use `set()`
None and the integers would be singletons, which go fine with the onion on my belt.
I once wrote a quine that creates PNGs of adjacency matrices of hypercubes in different dimensions. With every iteration/replication, it goes up one dimension. http://philippdow.blogspot.com/ You can also extend this code pretty much arbitrarily and make anything you want a quine.
I actually didn't write that one but yes, I agree with a subtle difference: Everybody needs it, many write one :) This one I think has the right balance of providing enough but doesn't dictate to much in terms of locking you into a certain corner. With regards to GTD... I've read lots about it (@sgmctabnxjs) but then yes, django-todo certainly is (at this point) more a todo than it is a GTD system. However, the lines between the two are rather blurry and I think GTD corner stones like levels of focus and workflow can easily be added to what makes django-todo right now. * http://www.markus-gattol.name/ws/gtd.html#levels_of_focus * http://www.markus-gattol.name/ws/gtd.html#workflow
Several of the modules used by Python are written in C and highly optimized. What exactly do you wish to do that there is not already a Python module available for? (And why would Python + a custom module written in C be a bad fit if you should want to do something out of the ordinary?)
Yes, a "WorkingDirectory" class, complete with methods like .ls(), mkdir(), environment variables and a way to run system commands in the current directory is incredibly handy. It's especially comfortable in a cross-platform environment, as it smooths out the underlying differences.
A cross-platform build-system, for dealing with several computers and several types of builds, with a lot of custom code that is specific for the company I work for. Builds are ignited over XML-RPC and errors are e-mailed to the developers that are to blame (svn blame, that is). The computers can report what types of builds they can build. It works fairly well.
Fucking oath!!! This is pretty much my #1 language criteria. If I can't understand or work with the code, it's no good. For this reason C++, Java and C# are completely unacceptable to work with. C, Go, Python, bash are okay.
Yes.
Yeah I agree. High level tests, that verify 80-90% of the code are the way to go.
Personally, I do a lot of processing of very large files. We're talking hundreds of gigabytes. Python is quite fast in a lot of areas, but when you're doing any sort of crunching with huge stacks of data, a lot of the time, you have to look at C or C++.
Agree.
As well, we've been experimenting a little recently with C types etc. in Python without much success. I guess they're probably the way to do alot of things with a performance increase without writing your entire piece of software in Python - but we've probably been approaching it wrong. Sometimes python can be a little bit of a dark art to optimise in my experience.
This feels like a good point to pimp [PyFilesystem](http://code.google.com/p/pyfilesystem/).
Someone care to explain?
It's a [quine](http://en.wikipedia.org/wiki/Quine_(computing\)). That is, it's a program that just prints itself out - it's self-replicating.
`set()` has been in the language for a very long time, but not forever (since 2.4).
I wish I had friends that would be amazed by this...
Except it is unsafe(no replicaset, no oplog), requires a bunch of different machines(replicaset) or it uses pornographic amounts of memory(oplog). You get to pick
More importantly, this is useful for presentations where you want to show code but don't want to bore your audience by typing out every statement by hand (and inevitably backtracking because your stage fright caused a fuckton of typos).
2.3 actually
I've been using buildbot recently. It's written in Python, but more importantly it lets you define ci tests progmatically in python, which can actually be pretty cool. It's not like it's painless, but you don't have to install a JVM at least (actually a hassle on some of my test boxes as nothing else needs it)
Thanks
&gt; Responsible citizens don't use adblock. Heh. With all the crap ads out there, I don't believe that is true.
My spider-sense is telling me there's a TypeErrorException in "Uniquifying a list". Overwriting builtin functions? ಠ_ಠ 
Also: Why would you **want** to use a list if the order is unimportant and you want unique entries.
Interfacing with other people's code expecting a list
I have a cute one that uses yet another trick: s="'" d='"' code="print's='+d+s+d+';d='+s+d+s+';code='+d+code+d+';'+code" print's='+d+s+d+';d='+s+d+s+';code='+d+code+d+';'+code
I don't use it on people's blogs and sites like that. I use flashblock so I don't get annoying audio ads anywhere. I don't object to having an advert or two on a blog as long as it's not intrusive.
I'm not doing that at all. I'm calling set() on the list, then calling list() on the resulting set.
Whoa, that's awesome! Is `MemoryFS` easy to use for testing?
one unified way to access local files, FTP, WebDAV, Amazon S3, zip,... I wish I should have known this before.
Yeah, but before you call list() you're assigning the variable 'list' to an actual list!
Fine. But then there's no need to turn it *back* into a list. 
Oh, spotted that and fixed it. Thanks!
I mean; I need to build a list from my data, but I'm using other people's modules with functions which want a list. I don't know if set has the same functions as a list (it probably does). Also, the order could be important later on, if stuff needs to be added to the start or finish. Case in point: I have product attributes which should be unique, but then I need to add further product information (price etc) at the beginning.
Not according to http://docs.python.org/library/stdtypes.html#set-types-set-frozenset.
I've seen Pete (the author) give presentations using this, and it was very cool. More people should use them for live demos, such as at PyCon.
I believe another gui package should be bundled the standard releases in addition to Tkinter. http://www.wxpython.org/quotes.php 
Example code?
Yeah, I've read through that, and implemented some of those - dictionary substitution is awesome, never seen that done before.
Hah, yeah, I agree. I just setup hotshot to do some profiling - that's pretty neat, and it has shown me where a couple serious bottle necks are. Yes, I know there's cProfile, but unfortunately, I'm stuck using python 2.4
Yeah, I just did profiling with Hotshot, and it's really been a help in showing me where things are taking time. Now I've just got to figure out better ways of getting the same functionality from it.
Awesome, thanks for the explanation. Its always fun to learn new things.
Thanks for that - that's helpful. Speaking of lookups in dictionaries, I've got a nested dictionary something like: d = { 'level1': { 'level2a': [val1a, val1b], 'level2b': [val2a, val2b], }, 'level1': { 'level2a': [val1a, val1b], 'level2b': [val2a, val2b], } } I'm trying to get all the items in the list, so I'm doing something like: for a in d.itervalues(): for k, v in a.itervalues(): do_something(k,v) Is there a better way to strip down to the lists than that? Unfortunately I've got to keep the dictionary structure as is, but for this portion I just need the contents of the lists. 
PyQt wxPython are the same aside from cosmetic code differences (largely) and liscensing. I'd say PyQt is overall better, but that's a personal choice as I'm much more familiar with it and I've not tried to sell my applications, after all. Qt also comes with QtDesigner which is very helpful for setting up modal dialogs that very rarely change (you'll want to hand code the main windows, generally) Overall, it seems to me that with wxPython and PyQt, it's personal choice and nothing more. YMMV.
My solution: http://pastebin.com/2qufMM01 (I don't care what you do with it but don't do anything that will get you in trouble w/ UND) Have a great year. 
Yeah, piece of cake. Interfaces work identically.
http://docs.python.org/library/sets.html Sets were (and still are (although deprecated)) in a separate module since 2.3.
*stands corrected*
I don't see what's so exceptional in this list. It's pretty normal Python stuff... Still... thanks for sharing.
maybe you want to look at Dabo http://dabodev.com/
Any number of processes/ web servers can access the same session data for a particular client session.
I think QT has some database bindings built in (someone correct me if I'm wrong, I don't use it), so it would be a matter of finding the binding you like. I hear good things about [PySide](http://www.pyside.org/) I myself am partial to using [SQLAlchemy](http://www.sqlalchemy.org/) with whatever I'm doing. My GUI apps are usually written with [GTK](http://www.pygtk.org/) if it's for Linux only, or [wxWindows](http://www.wxpython.org/) for cross-platform. SQLAlchemy is just a data binding layer, with a nice API and ORM if you want to go down that route. It can be a bit daunting, but totally worth the payoff at the end.
It's aimed at new users (I am one). It's just stuff I've found as I do my job and teach myself Python.
&gt;Python 3 introduces dict comprehension, but I'm on 2.7 minor correction: 2.7 has dict comprehensions; 2.6 does not.
I agree, wx is great. Check out Dropbox as an example of a nice GUI designed with it.
Depending on the performance requirements, you may be able to use the built-in [sqlite](http://docs.python.org/library/sqlite3.html) support with the built-in [Tk](http://docs.python.org/library/tk.html) support to do what you'd like. I also just saw [EasyGui](http://easygui.sourceforge.net/) posted here, which may ease your issues with Tk.
It's much appreciated. I'm sure there are plenty of people who are Googling around for Python snippets who will find your site and it will help them immensely.
&gt; Speed wise that would be replacing O(n) stuff (lookups in lists for examples) with O(1) (lookups in dictionaries). But O(1) doesn't tell you how much overhead exists. So, here's a question for you - if you have a lookup table with 4 values and need to validate 100 million records, by looking up the third field against that table and confirming that the value exists, would a dictionary still be faster than a list?
Fair enough. However I think a short explanation on what "map", "zip", etc does, and maybe a bit more about "BeautifulSoup" would be even better. In other words, elaborate the snippets a bit more. In that case, new users will learn more, than blindly copy/pasting and adapting the scripts. If only by making them aware of the functionality.
Qt,. Add in an ORM like SQLAlchemy if you'd like.
Update the set, adding elements the newly created set. (A union operation). But as others have said, it would be much cleaner to write: x.add(line.split()[0]) I only used the other notation because of a supposed speed advantage, which was premature optimization at its worst :D
Tons of **cleaner** ways to do the same thing :D
Imagine you have a load balancer in front. A user may be on server X at one moment and when his connection breaks and reconnects he may be on another server Y. Both servers X and Y will be able to access the same session data on Redis since it is networked, while an in memory dictionary is only accessible by one server (and only one process/thread). You could save it on the 'ol fashioned SQL DB, but thats a lot of load for a disk based DB since sessions are accessed frequently.
Fixed the link, thanks for bringing this up ;)
I found with Qt that it was easier to keep everything Qt otherwise there ends up being weird translation things. Seems as though Qt is just it's own meta-language at this point since it does most everything except basic programming logic. Basically, I was pulling movie titles from a db that had unicode in it, and displaying it on a Qt form, and no matter what I did, I couldn't make it display the unicode characters. Using the Qt DB stuff, it worked with no problem.
Microsoft lightswitch is the easiest one i know , but alas, not in python , only in c# or VB.NET.
SQLAlchemy is the best database framework I've ever used. I would definitely recommend it regardless of your choice of GUI. The big GUI frameworks are PyQt/PySide, PyGTK/PyGobject, Tkinter, and wxPython. They all have strengths and weaknesses, and you'll need to do more research there.
Are you referring to the Camelot installation instructions? I am assuming so since they are no longer 404'd. If so, would you recommend Camelot? If so, why?
I currently have a Python application for examining a database of trained aircraft engine model parameters. The GUI is written in Tk, and the backend is SQLite. I have a simple database wrapper class that basically implements all the SQL queries so I just need to make some simple method calls to pull the necessary data. Of course, my situation is rather simple, but it's nice to know that only the Python standard library is necessary to run the application.
Thanks, I'll build on it when Runescape's Bonus XP no-sleep marathon is over.
Funny that if you google for "Javabats", the returned first link is a link to the [CodingBat](http://codingbat.com/). You might notice the Python section on the right hand side. On the other hand, you might also want to try the links on the right side of this subreddit, especially Learn The Python the Hard Way (which is also available free in html format).
The nicest api combination for such things is probably gtk+ with sqlalchemy. I really wish the wx and Qt bindings would follow more python like naming schemes rather than sticking to their C++ names. wx drives me nuts with its Everything Starts With A Capital Naming Scheme.
If you get more experienced, you can also try [Project Euler](http://projecteuler.net/).
would recommend it because based on Qt en Sqlalchemy, to very mature libraries with lots of docs. Camelot is easy to get started but scales to large datasets and complex applications. (disclaimer : I'm the main developer of Camelot)
&gt; Heh. With all the crap ads out there, I don't believe that is true. Agreed. Prove your content is worth something, and ask politely (don't try and pull that passive-aggressive crap like "Responsible citizens don't use adblock"), and you'll be instantly whitelisted.
TIL zip.
javabats have actually renamed to 'codingbats' because of the addition of python problems =)
One that I've found very useful to reverse strings: str = 'hello' str = str[::-1] #str now = 'olleh' This can be helpful for checking palindromes: if str == str[::-1] print "is palindrome"
There are minor improvements you could make, but I suspect they would not give you a significant speedup compared to changing the data structures. Are you sure that the bottleneck is in iterating through the dictionaries? How much time is spent in do_something? If it is significant compared to looping through the items then you need to fix that first.
Exactly. I have no problem with white-listing a website I frequent.
Just out of curiosity, what's the application supposed to do? I'm also in a software design class that's doing something similar.
That's my only issue with PySide.
Statistician here. They make me use SAS. It makes me wanna cut my hands off.
I use click to play for flash (flash ads are absolutely not ok in my book.) And I use adblock for its blacklist. As long as your ads behave themselves, then you are fine. The first ad that pisses me off then you will be blacklisted.
Speaking of #3: can you† recommend a good off-the-shelf module for watching a directory? I want to set up a little server to watch for new images in a directory and import what comes in to a django app -- the best implementation I can come up with is a process that lists out the files every minute or so and hashes the files into a defaultdict. I am sure someone has something awesomer than this, like firing libevent callbacks via ctypes, or somesuch. Does anyone have something awesome like that to point me at? † by 'you' I mean either SupersonicSpitfire or any other person, either way.
Brain asplode: http://docs.python.org/library/itertools.html
 from itertools import combinations print list(combinations(keywords, 2)) edit: forgot list(...) 
I don't really wants to help you with the logics here, too much thoughts. But here ams a simple way to says what you ams says up there. mergedList = [(x, y) for x in keywords for y in keywords if y != x]
Ooh, sounds like fun. Meanwhile I keep fixing holes in our shitty ant system.
If I can answer my own irritating question: http://code.google.com/p/python-watchdog looks nice and thorough.
Awesome. I knew Python had my back on this, just didn't know where to look. I ended up using list(combinations(keywords, 2))
This isn't quite what I'm looking for. I actually had the code in a list comprehension prior to posting, but it didn't exclude the [(tester1, tester2), (tester2, tester1)] issue I'm having. 
So ujson is the fastest json library. Msgpack is faster, but isn't json. However, if you're controlling both ends, it's good.
Fight the man! With snakes.
I'm not sure if you catch the concept of subreddit ;)
Oh yeah, forgot about converting it to a list. Out of curiosity: what do you need it for?
I just thought i could help a fellow redditor. I hope i did.
Unrelated quetion, yes, but could https://github.com/seb-m/pyinotify be what you're looking for?
I've got the impression that build systems are always painful, in one way or another, if it's any comfort...
You should link to http://www.reddit.com/r/vimcommands/top/?sort=top&amp;t=all otherwise reddit take the posting time in account and you won't get the expected result.
Code expecting a list or code expecting a sequence? It's sad if that code specifically checks for lists.
Just hold onto the current index of the outer loop, and begin the inner loop beyond that point in the list. keywords = ['tester1', 'tester2', 'tester3', 'tester4'] mergedList = [] for i, word in enumerate(keywords): for sub in keywords[i+1:]: mergedList.append((word, sub)) print mergedList Appears to work as desired: http://ideone.com/3zusM *Edit*: Similarly, as a list comprehension: mergedList = [(a,b) for i, a in keywords for b in keywords[i+1:]] Works just the same: http://ideone.com/puuCa
That would be a candidate for a dictionary comprehension. Simple Python loops should be replaced with comprehensions so you get the performance of a C loop instead. Besides the dictionary comprehension, that is probably how I would do it. For some iterator black magic, you might want to check out [itertools](http://docs.python.org/library/itertools.html). For some esoteric but sometimes painfully helpful datatypes [collections](http://docs.python.org/library/collections.html) has some more juice for you too.
that is an excellent point. is there a way i can make that the default?
There would be a size differential when the dictionary logic would be slower than a list traversal, but I am too lazy to test it. In my experience however the overhead you're talking about is known in general terms just from looking at your code (and data). If you don't then I would usually say you need to circle back and perhaps rewrite some code.
SQLAlchemy for ORM. If you really prefer Django's syntax for relationship lookups, [this](https://github.com/mitsuhiko/sqlalchemy-django-query/) should help.
BTW This is known as a [Quine](http://en.wikipedia.org/wiki/Quine_\(computing\)). Edit: Doh! Didn't see GrumpySimon's post.
I guess it depends on applications, but are sessions that critical? If the rare chance that a connection drops, requiring the user logs in again isn't that bad a policy.
What we are currently looking into is a DB application to manage information and workflows for cemeteries. We do not have exact requirements or specs at this time.
HEY EVERYONE, THIS GUY HAS A BRAND NEW MACBOOK AIR i7
Unfortunately collections is unavailable to me, as I'm stuck using 2.4. I've had to implement http://code.activestate.com/recipes/576693-ordered-dictionary-for-py24/ - As I needed order in my world.
All that's happening in the do_something method is a simple regular expression substitution, I'm fairly sure that the bottle neck is there, unfortunately I'm using 2.4, and I needed an OrderedDict, so I've had to implement http://code.activestate.com/recipes/576693-ordered-dictionary-for-py24/ which is powering this dictionary.
A lot of the commands posted are not strictly for Python. I was hoping to see things that are Python specific...
`i` Well, it's a text editor... `ESC` `:wq`
The idea is to take a list of keywords and combine them into tuples to use in a google search. Combine words that seemingly have no correlation to see how many results come back. The code works sporadically, probably because they want to block query bots.
Nice solution. I'm still learning Python and slicing is one of those things that doesn't always click. I also forgot about enumerate. 
They did it because they want to help people coming from C++ with wx experience, or you want to use different API when you go with Python, and later learn it again when you go with C++ ?
I think a change like this would actually cause more confusion. The OP argues that it is a difficult concept for newcomers, but are sequences beginning in 0 really that hard to wrap your head around? Granted, there is a problem with revere indices, seeing as a -0 element is impossible. 
&gt; non-web No? Well a "web" app can be non-web. You start your framework/webserver, then you start the browser talking to localhost on that port, bang, your done, you've got a nice gui interface on a local app. The best part is that next semester when you have to write the same apps but for the web, you just add 0.0.0.0 to the target addresses and your done! Seriously, look at bottle, html5, sqlalchemy, and have fun! 
In some tests we did recently, it seemed like creating 200k objects defined the absolute minimum time that any json parser could run in. Does anyone have a good way to help pre-create a large pool of objects and have a json lib populate the pre-created pool instead of creating them on the fly?
The link from front page still 404's, but this link "Docs" tab on top works: [Installation](http://downloads.conceptive.be/downloads/camelot/doc/sphinx/build/doc/install.html)
This doesn't count as a command, but the first thing I do is remap the escape key to caps-lock. I can't imagine using vim with the escape key all the way in the corner. Escape is probably the most frequently pressed key.
Have a look at cython. You can get really good performance improvement with comparatively little effort.
Probably expecting a sequence. It just goes to show, you can't be to careful.
Question: Does anyone else find themselves counting from zero afk? 
Did you run into trouble getting tnetstring up and running? Happy to help out if you like.
:!%:p To run your script.
Have you timed the regex substitution on its own, against a variety of data? A badly written regex can be immensely time consuming - it is possible to accidentally write a regex that will take longer than the lifetime of the universe to complete. It is highly probably that the time spent doing the regex substitution will dwarf the time spent iterating over the dicts. Also time accessing your OrderedDict and compare it to a regular dict - looking at the code there is some extra overhead iterating through the items. **edit** if the regex is the problem then post it here and we will give it the once-over. I have a *lot* of experience with fixing slow regex.
I honestly don't care if lists start at 1 or 0. I find it in no way, shape or form confusing with either indexing base, and there are a bunch of reasonable arguments for both. Also, I have never ever met a single budding programmer who said «Whaaaaat, zero based indexes? That's like soooooo confusing!» Thinking that computer languages will become less confusing and easier to learn if we switch the index base is completely misguided, that is in no way, shape or form what is confusing about learning to program. What I really hate is having to switch back and forth between index bases. And as the computer world in general overwhelmingly favors zero based list indexes, that's what I prefer. 
You can look at ShiningPanda documentation: https://docs.shiningpanda.com/tutorials/101.html It doesn't cover how to configure Jenkins CI or the shiningpanda-plugin, but that should not be very complicated.
From a completely personal perspective (IMHO!), I've found that it's easier to do Python with Emacs, really. With Vim you have to have multiple terminal windows open. With Emacs it's a complete IDE and has everything I'd ever want for simple (and perhaps complex, haven't done this in Emacs) projects. Only advantage Vim has over Emacs is modal editing. It's much more satisfying just tapping C-c C-c and having the program run instead of having to alt-tab or click the terminal window and type "python myprogram.py". And I can examine the variables after I run a buffer. And I feel I haven't even scratched the surface yet. Try it out and find for yourself which you prefer. Just don't be intimidated. Emacs needs some time to getting used to and for configuring it to your liking. Installing Emacs and just running M-x python-mode is easy though. If you want help just PM me even if I'm a newbie myself.
"Consider it done" for Python 4... I assume that is a joke.
This. There's no way in hell Guido would just accept something like that without serious thought and input. Not to mention that, given the backlash over Py3k, I'd be surprised if we ever saw a backwards-incompatible Python 4. Guido's pulling this guy's leg.
That was a pure python module though that **did** implement sets using dictionary keys (with True as the dummy value), so using it wouldn't actually have changed much.
**c**python is refcounted, but other implementations aren't. Eg. jython, ironpython or PyPy may leave the file open until GC kicks in.
[wikipedia about subject](http://en.wikipedia.org/wiki/Zero-based_numbering#Advantages) Edit: Thanks brodo
btw, lua does one-based indexing
And my responses :D http://mail.python.org/pipermail/python-ideas/2011-September/011450.html http://mail.python.org/pipermail/python-ideas/2011-September/011451.html
&gt; I give this: &gt; +1 it's a joke. The OP is suggesting the +1, not that lists start with one. list[index +1]
 &gt;&gt;&gt; reversed("hello") &lt;reversed object at 0x1007b2610&gt; &gt;&gt;&gt; ''.join(_) 'olleh' `reversed` also works with lists and a bunch of other stuff. It's the preferred method of reversing things, since it doesn't use up a lot of memory.
The best thing to do with list indices is, of course, to be different from every (well, minus a few) other language. This will confuse people less.
This is not memory efficient because of the slicing. You could just as well loop through the indices only in the inner loop.
There are several vim plugins that let you have a terminal running in a vim window. I use [Conque Shell](http://www.vim.org/scripts/script.php?script_id=2771) but there are others. Also the latest version of Ipython has a mode where it can interact directly with a running Vim session - see [the demo here](http://pirsquared.org/vim-ipython/). I have not tried it yet, but it looks good.
&gt; seeing as a -0 element is impossible. The ~0 element is however very much possible, and is exactly what you want. And `~i`-th element in general.
Like what?
Nope. It's "e."
Well, you could try [runscript](http://www.vim.org/scripts/script.php?script_id=127). I have 3 monitors and prefer to have 3 fullscreen shells open. The center is vim, the left is in the directory I'm working in with the py files, and the right is just python waiting for me to test out things I'm not sure about. I test with Alt+Tab, &lt;up&gt;&lt;enter&gt;. This lets me glance over at results and error messages while working in vim, too.
Exactly, I didn't kwow what is javabats d0ct0rd0ct0r may not no what is a search engine... And I downvote it's post just for it.
fingers crossed
Yes, it was multiprocessing I meant. I experienced really strange things with it, where it would work on one platform, but fail on another.
Thank you good sir. A build system.
Care to elaborate?
And it's really annoying when you're used to any other language.
Why no pickle?
Guido is trolling apparently. 
Yes: http://www.reddit.com/r/Python/comments/k8v1g/what_i_learned_from_using_python_for_a_project/c2ikusz
* Not much point in turning the set back into a list. Just keep it a set if you want set behavior. * Don't use beautifulsoup, use html5lib or lxml. * Unicode *is* good for you. Bytestrings are raw data and not text. * 2.7 does have dict comprehensions, although in your case the zip is arguably more elegant. In case someone was wondering: {key: value for key in keys for value in values} Might be easier to understand if you don't know zip, but you should learn zip anyway - it's very useful. For example: dict(zip(reversed(args), reversed(defaults))) Using the values from ``inspect.getargspec`` the above makes a dict mapping arguments to their default values, for each argument that has one.
Oh God no.
...pedia. [Wikipedia on the subject.](http://en.wikipedia.org/wiki/Wikipedia:Don't_abbreviate_Wikipedia_as_Wiki)
I think using `itertools.combinations` is better approach, but I'll leave this here just for the sake of justice: set(tuple(sorted((x, y))) for x in kw for y in kw)
I find the only problem with indices beginning at 0 to be that the last index is equal to the size of the list - 1. This leads to 'off-by-one' errors.
The only problem with 0-based indexing it that it's completely counter-intuitive relative to the physical world. E.g.; "I have three coconuts, let's count them, 0, 1, 2, see? 3 coconuts." This causes two more problems: 1. Confusion in newcomers. 2. Permanently increased cognitive load for all programmers. This is not trivial. Cognitive load is a debt that is always paid. Like technical debt, it adds up bit by little bit, and can build to paralyzing amounts, suffocating options and claiming mindspace better left for new ideas. Also like technical debt, the best way to pay it down is bit by bit, as it's noticed; therefore, joke or not, eliminating 0-based indexing in Python 4 is worthwhile. Not for us, who have internalized this anachronistic artifact from ancient computational history, but for those who follow us, who will be greater in number, and who will be called on to do greater things. 'Course, what do I know? 
No, you see "other languages would follow." So, it won't be confusing, because all those languages will just update their standards to do things the new python way. Of course, those updates will have to be major revisions "since its not reverse compatible." Obviously, this is going to be much less confusing. Who needs old code anyways?
It's a joke &gt; (And to those taking the thread seriously: this is all in jest. We won't change the indexing base. The idea is so preposterous that the only kind of response possible is to laugh with it.) &gt;--Guido http://mail.python.org/pipermail/python-ideas/2011-September/011462.html
I never knew this... Kind of unpythonic in that it is such a different way to do a common task. &gt;The unary ~ (invert) operator yields the bitwise inversion of its plain or long integer argument. Never would have known. 
I don't understand. Is he proposing a style convention? I doubt many programmers will write _list[0+1]. That seems silly to me. Am I missing something? 
are you kidding? Element 0 is that confusing? Come on man!
it's one of the many necessary roadblocks to keep MBA's from actually programming. You all like your jobs right? :)
i mapped f5 to :!python %&lt;cr&gt; ...works great ...and ipdb is your friend :)
I proposed my solution: class List(list): """ &gt;&gt;&gt; a=List() &gt;&gt;&gt; for i in range(100000): a.append(i) &gt;&gt;&gt; print a.first 0 &gt;&gt;&gt; print a.second 1 &gt;&gt;&gt; print a.third 2 &gt;&gt;&gt; print a.twentieth 19 &gt;&gt;&gt; print a.twentysecond 21 &gt;&gt;&gt; print a.onehundredthirtyfifth 134 &gt;&gt;&gt; print a.onethousandfivehundredthirtyeighth 1537 """ def __getattr__(self,name): import re if name.endswith('first'): name = name[:-5]+'one' elif name.endswith('second'): name = name[:-6]+'two' elif name.endswith('third'): name = name[:-5]+'three' elif name.endswith('fth'): name = name[:-3]+'ve' elif name.endswith('hth'): name = name[:-3]+'th' elif name.endswith('ieth'): name = name[:-4]+'y' elif name.endswith('th'): name = name[:-2] subs = [ ("eleven","+11"), ("twelve","+12"), ("thirteen","+13"), ("fourteen","+14"), ("fiftheen","+15"), ("sixteen","+16"), ("seventeen","+17"), ("eighteen","+18"), ("nineteen","+19"), ("ten","+10"), ("twenty","+20"), ("thirty","+30"), ("fourty","+40"), ("fifty","+50"), ("sixty","+60"), ("seventy","+70"), ("eighty","+80"), ("ninety","+90"), ("one","+1"), ("two","+2"), ("three","+3"), ("four","+4"), ("five","+5"), ("six","+6"), ("seven","+7"), ("eigth","+8"), ("nine","+9"), ("ten","+10"), ("hundred",")*100+("), ("thousand",")*1000+("), ("million",")*1000000+("), ("billion",")*1000000000+("), ("trillion",")*100000000000+("), ("and","")] for key,value in subs: name = name.replace(key,value) if '(' in name: name='('+name+')' name.replace('()','1') if not re.compile('^[\d\+\*\(\)]+$').match(name): return AttributeError try: return self[eval(name)-1] except: raise AttributeError EDIT: Fixed a typo. Of course it can be done without eval too. ;-)
You're right, it depends on the application. If you're a retailer and you have an anonymous customer (not signed in) and they build up a shopping cart, if they lose their session and have to start over again, you may end up losing a sale.
&gt; Kind of unpythonic in that it is such a different way to do a common task. It's not Python's fault that ~x = -x - 1. Even GVR can't change math! =) But, as it happens, almost no one uses this trick for some reason.
Moving your fingers from the home row to hit a function key? In *vim?!?* Blasphemy!!
&gt;The only problem with 0-based indexing it that it's completely counter-intuitive relative to the physical world. That's really not true. Pretty much every time we use an index in the real world, it starts from 0. Graphs, rulers, clocks, coordinates etc. The only exception is the calendar and personally I think that's a bad thing (ie no year 0). The things that generally start with 1 are not **indexes**, but **counts**, and that's a rather different concept. Indexes point *between* items, counts refer to the items themselves. Indexes are generally what you want when you need to deal with ranges, because they're unambiguous. Ie consider the below diagram: index: 0 1 2 3 4 5 6 7 | | | | | | | | |a|b|c|d|e|f|g| count: 1 2 3 4 5 6 7 Clearly the items between index 0 and 4 (ie. the slice [0:4]) constitute a,b,c,d. You just start from 0 and continue until you hit 4. But what about between the 1st and the 4th count? There's ambiguity here - do we mean inclusive or exclusive? In fact, what you generally *want* is inclusive lower bound, exclusive upper bound, since this retains some [useful invariants](http://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html), and handily this is what indexes give you. For counts though, there's no such intuitive relationship.
internet sarcasm detection failing- is there a better way?
localization?
I actually think it's a great idea; the function keys don't do much, I generally take my hands off the keyboard when compiling/running code anyway, and f5 is pretty standard for the few IDEs I've used. I'll probably do the same. Ignore my lack of humor.
I see your point.
Specifying your testing environment on benchmarks is important so in this case it is completely warranted (and necessary).
I'm a diehard python programmer who for whatever reason has been reduced to using [R](http://en.wikipedia.org/wiki/R_(programming_language) at work. R was designed for statisticians with little to no experience programming, and consequentially uses a 1-based numbering system for all arrays. It's nevertheless a fully fledged programming language. Whether or not it's the right thing to do, it's not confusing. Users new to programming intuitively call indices starting with 1 without ever knowing how the rest of the programming world does it. Users already familiar with other languages (myself included) adjust to it easy enough, namely on account of all the reinforcement from our 1-based counting society. It seems many of the [elegances](http://en.wikipedia.org/wiki/Zero-based_numbering#Advantages) introduced by 0-based counting don't show up much in high level programming languages. For...in loops eliminate most of the reasons to ever have to deal with indices, and why should I care if I can make something like an elegant hash table when hash tables are built into the language itself?
That's a nightmare. Yet you do not localize dict.keys and dict.values, etc.
It seems rfft2 on a 3 channel image returns a 2 channel result. PIL only supports 3 channel or 1 channel images. So either operate on a grey scale image: i = i.convert('L') or select the channel: j = Image.fromarray(numpy.uint8(b[:,:,0])).show()
You sir, are a gentleman and a scholar. I'd love to believe that I could manage to actually make a roguelike, and the existence of this makes me feel like I might just be able to. Also, you may want to do a s/rouge/rogue on your website. I noticed at least one (potentially the only one)
For the curious: I was lazy and this is just using [Whoosh](http://packages.python.org/Whoosh/). If it becomes too slow I will have to switch to something else but for the time being it seems to work okay.
I'm sorry I have no idea :/ Ask an experimented moderator or an admin perhaps.
I'm using :map &lt;leader&gt;pr :!python %&lt;cr&gt; "pr" as "python run". It's pretty fast to type.
Thank you for the polite and informative response. You have further increased my cognitive load. ;-)
Not to take anything away from the OP, but I had a mess around with libtcod and [this](http://roguebasin.roguelikedevelopment.org/index.php?title=Complete_Roguelike_Tutorial,_using_python%2Blibtcod) tutorial a way back and it was exceptionally easy to get going. That being said, I'd definitely give Pygcurse a shot later.
I've seen libtcod (but haven't used it) and it looks great, but I also wanted to create something that could be used for ascii-graphic games in general. And being built on Pygame, you can use all of Pygame's usual graphics functions with it.
Just in time for pyweek, too! I think I'll give it a try for my entry. :)
That's a valid concern. And I understand completely where you're coming from. libtcod has a very specific role, whereas Pygcurse seems to be more generalised.
"1.8GHz i7, 4gb DDR3" is helpful, sure.
awesome!!!!!!!!!!!!!!!
Make fun of me, but when i switch from matlab to python/numpy sometime i'm confused.
To say only calendars start with 1 is going too far. I remember in math class often running into an "off by one" error when thinking about how many math problems I needed to do. (Yes, that's a little ironic.) The assignment would be problems 2 through 15, so I'd say "OK 15 minus 2 = 13 problems to solve," but really there would be 14 problems to solve, since the problems are numbered "calendar-style" rather than "ruler-style." The long and short of it is that both styles of numbering have their pros and cons. Calendar style is more familiar in daily life, but often leads to off by one errors. Ruler style is less familiar, and sometimes you do stupid things like `mylist[1]` to get the "first" item by mistake.
Yeah, if I were designing a new Python-esque language for new users, I would follow Lua's lead and use 1-indexing. But I don't see any particular reason Python should ever change, since the current standard is fairly entrenched and it has its own advantages.
This is going to be fun to play with, me thinks. [](/c22 "The pig/pyg has a skull Cutie Mark!")
That advantages section is just a re-write of Dijkstra's letter, and it looks just as silly there as it does elsewhere. Why should it be an advantage for a language with a for-each style iterator to be able to access memory in arrays by a simple offset?
I had thought that at first too, but the PyWeek rules say you can only use a library if it has been out for at least a month.
Thanks very much for that. Do you know of an easy way to do ffts on colour images in Python at all? Also as that answer escaped me, may I ask how you found out? I was looking into that problem for a whike and was totally lost...
The MB Air also has solid state memory so the read/write speeds will be effected. Since Apple only makes a few configurations its just easier to write it as the OP did.
Also added another custom theme called "Desert". Both themes are dark themes. Very nice :)
I disagree. I was on a project that used Lua for part of the system, and I had to constantly remind other engineers not to use array[0], since it was treated more inefficiently than array[1], since arrays started at 1 in Lua and array[0] was treated a hash like array["foobar"]. Conventions are easier to follow when they are the same from language to language. If high level languages all begin with [1], then programmers who graduated studying that when they started programming in low level languages will get confused by the 0.
i feel gross doing this, but i know of no better way :)
I see what you did there.
In low level languages arrays start at 0 since they are measuring memory like a ruler, so in my mind, indices should start at 0 as well.
Thankfully, it's a joke.
You forgot "dozen", "gross", and "many".
When using a ruler.
And programmer not used to Lua will use array[0] all the time, which still works, but array[0] uses the less efficient code path. (array[1]... array[length] )will use a fast lookup, subtracting 1 from the entry and looking in linear memory, but array["foobar"], or array[greaterThanLength] or array[0] will be stored in a hash table. So programmers will write a loop from 0 to N, little realizing that the 0 lookup takes a lot more processor time. This is doubly annoying.
My two main problems with starting with 1: * It it makes negative indexing nonsensical. What, so now ``some_list[0]`` is the last element of ``some_list``? * It makes index arithmetic nonsensical. Indexes are integers. The additive identity of the integers is ``0`` not ``1``. If the first element of a list is the 'origin' of that list, its index should be ``0``.
The term "web" refers to the web of HTML documents linked to each other, the network it lives on it called the "net." Thats the difference between the web and the net.
Numbered 'ruler-style' you'd have to do problems '1 through 14', and 14-1=13 still. I prefer numbering from one to distinguish between systems with a 'zero' or 'null' value (a count of things needs a state where there are no things), and systems that don't need such a value, but needn't be out-of-sync with similar systems; let one always be the value of a single item.
being able to restart the web server without all your customers getting dumped off the site and losing their shopping carts is a nice feature too.
For most implementations, using generators and simply throwing away duplicates during processing will perform significantly better. 
rfft2 defaults to transforming along all 3 axes. The last axis is computed with an rfft. The rfft of a length 3 signal is length 2 (i.e. 3 // 2 + 1). But you need the 2D DFT along axes 0 and 1 for each color plane: b = abs(numpy.fft.rfft2(a, axes=(0, 1))) If your image is size 512x512, the output will be shaped (512, 257, 3), i.e. axis 0 is computed via the fft for both non-negative and negative frequencies, while axis 1 is computed via the rfft yielding only the non-negative frequencies. 
That's what SupersonicSpitfire said.
*stands corrected*
cool. is there a tango theme for WingIDE?
Requests is fantastic. import requests resp = requests.get('http://www.reddit.com') if not resp.ok: throw SOMEEXCEPTION # can auth with requests.get(url, auth=(user, pass)) # can get headers with resp.headers # etc. print resp.content # this actually only works with the latest # requests version. Before hand it would look like print resp.read()
I don't like that he complains about one library, doesn't explain why and gives a code snippet that isn't really simpler than the libary he was complaining about. urllib2 sample from the doc: from urllib2 import urlopen, URLError, HTTPError try: response = urlopen(someurl) print response.code data = response.read() except HTTPError, e: print 'Error code: ', e.code except URLError, e: print 'Reason: ', e.reason 
If it were "ruler-style" the teacher would tell you to do problems 1 through 15 (=14 problems total). The trouble would be that to do just the first problem, you would have to "do problems 0 through 1," which is more than a bit bizarre.
Well, the trouble there is that Lua tables are like PHP arrays and let you store hashes and lists in the same data structure. If you had a proper Python style list, it would barf on `my_list[0]`, and that would train the experienced programmers not to do that anymore. I do agree though that if you expect experienced programmers to use your language, you're less likely to get complaints from them if you do 0-indexing.
It's neat to know you're pushing Python in the list, but I think you dropped this in the wrong bucket. 
Aw, damnit. Thanks.
Upvoted because I happen to be both a pilot and a python programmer, and even if it has little to do with python, it's very very awesome links. Also, the mispost is kind of cute.
No it doesn't. If anything 0-based indexing makes the least sense when you take negative indexing into account: 0 &lt;= i &lt; n : for normal indexing -n &lt;= i &lt;0 : for reverse indexing Plus, having 1-based indexing is quite natural for say stack based C APIs (e.g. Lua) for access to arguments. Accessing elements from the top of the stack -1, ..., -n maps intuitively to n, .., 1. Your second point made no sense, ironically.
christ, I was planning on doing something like this. python to push out new releases to EC2, run unit tests on 2 dozen platforms and then collect the results. yaaaay. XML-RPC sounds smart. 
Oh right... *Rules.* :/
That's a list, alright...
Thanks very much, seems I need to learn more about Fourier transforms as well :-) 
Although the name implies cloud computing, it's actually a client-side js compiler.
&gt; Python Over Java to Teach FTFY. In all seriousness, Java is the reason that I didn't use my CS major as a career. It's so shitty that the thought of it being my job made me leave computer behind. If I had encountered Python two years earlier, my life would be very different today.
Not useable as an interchange format, as it's untrustable and not parseable by non-python systems.
Thanks for that.. &amp;#3232;\_&amp;#3232; I read the wikipedia article, which led me to the following blog post, which subsequently caused my brain to hurt: [http://asiajin.com/blog/2009/09/22/uroboros-programming-with-11-programming-languages/](http://asiajin.com/blog/2009/09/22/uroboros-programming-with-11-programming-languages/) # ruby l=92.chr;eval s="s=s.dump[r=1..-2].gsub(/("+l*4+"){4,}(?!\")/){|t|'\"+l*%d+\"'%(t .size/2)};5.times{s=s.dump[r]};puts\"# python\\nprint(\\\"# perl\\\\nprint(\\\\\\ \"# lua"+l*4+"nprint("+l*7+"\"(* ocaml *)"+l*8+"nprint_endline"+l*15+"\"-- haskel l"+l*16+"nimport Data.List;import Data.Bits;import Data.Char;main=putStrLn("+l*31 +"\"/* C */"+l*32+"n#include&lt;stdio.h&gt;"+l*32+"nint main(void){char*s[501]={"+l*31+ "\"++intercalate"+l*31+"\","+l*31+"\"(c(tail(init(show("+l*31+"\"/* Java */"+l*32 +"npublic class QuineRelay{public static void main(String[]a){String[]s={"+l*31+" \"++intercalate"+l*31+"\","+l*31+"\"(c("+l*31+"\"brainfuck"+l*64+"n++++++++[&gt;++++ &lt;-]+++++++++&gt;&gt;++++++++++"+l*31+"\"++(concat(snd(mapAccumL h 2("+l*31+"\"110"+l*31 +"\"++g(length s)++"+l*31+"\"22111211100111112021111102011112120012"+l*31+"\"++co ncatMap("+l*32+"c-&gt;let d=ord c in if d&lt;11then"+l*31+"\"21002"+l*31+"\"else"+l*31+ "\"111"+l*31+"\"++g d++"+l*31+"\"22102"+l*31+"\")s++"+l*31+"\"2100211101012021122 2211211101000120211021120221102111000110120211202"+l*31+"\"))))))++"+l*31+"\","+l *63+"\""+l*64+"n"+l*63+"\"};int i=0;for(;i&lt;94;i++)System.out.print(s[i]);}}"+l*31 +"\")))))++"+l*31+"\",0};int i=0;for(;s[i];i++)printf("+l*63+"\"%s"+l*63+"\",s[i] );puts("+l*63+"\""+l*63+"\");return 0;}"+l*31+"\");c s=map("+l*32+"s-&gt;"+l*31+"\"" +l*63+"\""+l*31+"\"++s++"+l*31+"\""+l*63+"\""+l*31+"\")(unfoldr t s);t[]=Nothing; t s=Just(splitAt(if length s&gt;w&amp;&amp;s!!w=='"+l*31+"\"'then 501else w)s);w=500;f 0=Not hing;f x=Just((if x`mod`2&gt;0then '0'else '1'),x`div`2);g x= reverse (unfoldr f x); h p c=let d=ord c-48in(d,replicate(abs(p-d))(if d&lt;p then '&lt;'else '&gt;')++"+l*31+"\" ."+l*31+"\");s="+l*31+"\"# ruby"+l*32+"n"+l*31+"\"++"+l*31+"\"l=92.chr;eval s=\"+ (z=l*31)+\"\\\"\"+s+z+\"\\\""+l*31+"\"++"+l*31+"\""+l*32+"n"+l*31+"\""+l*15+"\""+ l*7+"\")"+l*4+"n\\\\\\\")\\\")\"########### (c) Yusuke Endoh, 2009 ###########\n" Ruby → Python → Perl → Lua → OCaml → Haskell → C → Java → Brainfuck → Whitespace → Unlambda → Original Ruby Script 
Conclusion: US males are far more likely to be.......forever alone. http://www.youtube.com/watch?v=H-Q7b-vHY3Q 
My 2c: Yes, teach Python for imperative and OOP. Teach Lisp (Scheme) for functional programming. Why? These are simple languages with the least number of "gotchas". If you want to teach memory management, do that with C after you've taught imperative programming. Java forces you to do OOP, everything you write will be in a class and everything will either be a static class/function or an object. Then Java has "gotchas" like primitives (why are some things objects and not others, etc...).
Yes, XML-RPC works great, even though XML is not the cool kid anymore (JSON and JSON-RPC is).
There are at least half a dozen distinctly different projects out there with this name. Accordingly it will be very difficult for anyone interested in this sort of thing to find it. May I suggest 'FlaskIDE' instead.
I really hope this doesn't happen.
The title says "python serialization".
eryksun's method to use rfft works well. In other words: b = numpy.fft.rfft2(a, axes=(0, 1)) c = numpy.fft.irfft2(b, axes=(0, 1)) j = Image.fromarray(numpy.uint8(c)).show() c will contain the reconstructed image. Easiest perhaps is to use fft and ifft functions straight up. rfft exploits the fact that you can get away with half the work if you do fft of real input . see: http://docs.scipy.org/doc/numpy/reference/generated/numpy.fft.rfft.html b = numpy.fft.fft(a) c = numpy.fft.ifft(b)
Teaching Java first teaches the kids to use copy/paste for everything, because you need so much boilerplate just to get started. "Oh, don't worry about all this 'class' stuff. I'll explain it at the end of the semester once you get used to not knowing what your program is doing or how it works…" I don't think I ever opened a file in C++ without copy/pasting some older file I had during my whole undergraduate career. :-(
That's the exact justification we were given during our CS course. I'm glad we started with Python too, we did learn Java later on though. That being said, there's nothing wrong with using some earlier code you've written.
import os os.system("ls") Traceback (most recent call last): File "", line 1, in ImportError: No module named os This IDE is not funny.
Thanks very much. I obviously still have much to learn and am grateful for the help.
Is scarlet rougelike?
It's more interactive than looking at doctests and less error-prone than giving a live demo. Fair enough IMO.
Uses [emscripten](https://github.com/kripken/emscripten/wiki) to translate python to javascript. One limitation is "[m][ost core language stuff should work, except for importing non-static modules (in other words, import sys will work, but other modules won't).](http://syntensity.com/static/python.html)"
Actually in Python 3, `011` produces a "`SyntaxError: invalid token`". According to [PEP 3127](http://www.python.org/dev/peps/pep-3127/): &gt; For Python 3.0, "oldoctinteger" will not be supported, and an exception &gt; will be raised if a literal has a leading "0" and a second character &gt; which is a digit. 
It could be a good teaching tool, but I don't see it useful for much else because of this limitation. It seems comparable to jsfiddle., which is the best online JS teaching tool I found so far. Nonetheless, I'm glad things like this are being worked on.
If you *really* want to teach OOP, dare I suggest Ruby?
Sad you chose to abandon a career based on the default language your CS program chose to teach you CS concepts. My CS program used Scheme, Lisp, and C to teach CS concepts. My career path has spanned many different languages - C/C++, Java, Perl, Python, and Ruby. From embedded systems to Cloud computing. I have enjoyed each and every language for the problem at hand.
If you really want to teach pure OOP concepts use Smalltalk.
OK so I used this IDE a bit and here is some feedback, assuming the OP is the dev behind this. * It's great that your trying to make a full fledged IDE, but the technology isn't ready for that yet. A prime example is the lack of imports. Instead, make a training tool.. a place we can post snippets and share them. * I found when copying and pasting code, tabs are making there way into the editor, which is causing errors and very annoying. Perhaps when pasting you can auto-convert everything to spaces. Another solution would be to provide a toolbar option to convert tabs to spaces. * The editor itself it great, I did try to expand the output area several times. You should allow us to drag that up. * I am unsure how saving works, it would be great to use this tool to throw up a snippet of text, save it, then share the URL with others. Thing jsFiddle, pastebin, etc here..
This is a cool idea. Does anyone know how it handles imported modules (e.g. BeautifulSoup, Twisted, etc.)?
I disagree, Python uses 'duck typing' you don't need interfaces or abstract classes. This way you can't apply strict OOD rules for software development. In Java you can do this and it expands your feeling of OOP, imo. Mind that I'm using Python for a few months now, and I don't really miss much strict OOD rules, but that's because I knew Java/C#/C++ before I used Python.
When academics adopted Java, Python was far from what it is today. (Similarly, many large efforts (e.g. the Human Genome Project) adopted Perl when Python was far from what it is today). Java is a pretty good OOP language. Its verbosity is not more than that of traditional compiled languages, notably C, C++. In fact, in terms of design, Java compares favorably to C++, which was the alternative at the time. It is portable and has acceptable performance. From the academic point of view, the problems with threads in Python makes it very hard to make it the dominant language for the CS curriculum. How can you teach threading when the language you use is deficient at it? Adding to that Java was widely adopted in the industry. Adopting Java was a balanced choice. 
Hmm, I suppose that's true. If you started form zero, you would probably just say 'problems up to 1'.
AE here good list.
They should change the name. It's too similar to http://www.picloud.com/, which is actually a cloud computing tool.
I'd throw in dynamic systems, automatic controls (modern control systems), digital controls/discrete systems (graduate), unmanned aircraft systems (austin), acoustics, aeroelasticity, guidance and control, unsteady aero, I could keep going but I'm getting tired of typing and I'm lazy
I'm putting dynamic systems, automagic control and estimation under flight mechanics/stability and control at the moment. Should they have their own category?
We had nelson for stability and controls, I wouldn't really say it covers much of true automatic controls, granted it does dabble in the root locus method (which I love). For dynamic systems, I meant a straight up dynamic systems (like an EE or ME would have to take), not flight dynamics. At my school, automatic controls is basically dynamic systems II, and digi is more or less dynamic systems III
If you use a one-dimensional fft, you'll have to transform twice, once along each axis: T = np.fft.fft(A, axis=0) B = np.fft.fft(T, axis=1) Or just use fft2 in one pass: B = np.fft.fft2(A, axes=(0,1)) Here B will be the same size as A since fft2, in contrast to rfft2, keeps the negative frequencies on the final axis. 
Ideally though, your old code should be refactored into an extensible module, not just copy-pasted out of.
Python 2.7.1 for your information.
&gt; How can you teach threading when the language you use is deficient at it? Ironically, most of today's rad scripting languages have versions that runs on the JVM and whose main feature (or one of the main features) is just that, not sucking at Threading 
I've just started to learn Python, has anybody got any advice aside from reading the books and watching videos on Youtube?
I would add Spacecraft Dynamics and Control, A Practical Engineering Approach by Marcel J. Sidi, as well as Rocket Propulsion Elements by George P. Sutton and Oscar Biblarz. edit: I know this is in r/Python, but if it's not blasphemous I would add Programming Perl by Larry Wall-I'm not a big programmer, but I know the spacecraft engineering industry makes heavy use of Perl.
Python was designed, syntactically, to be easy to learn and easy to use. It is not a language that compiles (there is python bytecode, but that is actually an optimization rather than a necessity). And syntax is very clean. Consequently, a new programmer is not fumbling around with things like 'why doesn't this thing compile' or 'what does this error from the linker mean' or even, 'this error doesn't make sense, but I remember something like it... I must be missing a semi-colon'. When you're learning programming, the last thing you want to be learning about is the edge cases when you're still trying to remember the standard rules. Python does this elegantly.
Where do I file a bug? I tried to create an infinite loop in the hopes of crashing the servers but instead it just tied up my browser, which seems like unexpected behavior to me. Please rectify and notify me so I can try again.
Great work! Collapsible posts and comments would make this perfect.
The thing about that is that I do not want the interface to be loaded in a web browser.
Thanks, I've added all three to the list.
From the source: &gt; Not a single fuck was given regarding code quality.
:3 It works fine and its unique (I can't find anything like it), so code quality shouldn't really matter. Yeah, "other people might want to develop it, its not nice for them" yada yada yada, too bad, it was developed in 2 days and isn't really going to be developed any further.
I have just ported it to MVC: http://www.reddit.com/r/Python/comments/kcgyu/is_my_first_mvc_project_goodcorrect/
Heh, now I'm singing the ol' public static void main song in my head.
Michigan State University switched their CS1/CS2 course from being C++ followed by C++, to Python followed by C++. IIRC, their findings were that the move was great for their program for a number of reasons, including the fact that as they tracked students grades between the C++/C++ and Python/C++ curricula, they found no noticeable difference. [A paper they wrote on the topic](http://www.cse.msu.edu/~cse231/fp039-enbody-revised.pdf) "Python for CS1 Not Harmful to CS Majors" was their PyCon 2009 presentation title - look around for a copy of the video.
It doesn't.
Oh. That's a shame. 
It is a client side python compiler. We used http://emscripten.org. So, it basically dosen't even talk to the server.
Good find. Another one: [Dive Into Python](http://diveintopython.org/).
First, thanks roy for reposting here. I will work on this more to improve on what you said. You can check out the github link here: https://github.com/siong1987/PyCloud
yeah my post up there was actually a poorly thought-out joke.
I like to see the same using mechanize browser.
Doesn't need to break captchas? ;)
Given the scope of the data that you're wiring with an actual database may be in order. Something to look into could be sqlite, it's a full-on database that's stored in a single file that can be distributed with the application.
No it does not. 
Related code: https://github.com/albertz/chromehacking
The "one month" rule only applies to the creator of the library (in this case, me) so everyone except me can use Pygcurse for Pyweek. (Makes sense, the game needs to be from scratch, and if I had developed this library myself beforehand but other people couldn't get use to it, then that would essentially give me head start.)
This is the one I used: http://learnpythonthehardway.org/ Found it really useful
I've been using this one too, it's pretty good.
Thx for sharing!
No problem. They were made to be shared.
What the fuck? This is wayyyyyyyyt more complicated. Extracting cookies from firefox using sqlite? Why not just use urllib and openerdirector objects and send the post data to theogin site then go from there?
Don't use SQlite for this, its easy but it won't scale - putting a years worth of logs into it will destroy performance. Use SQLAlchemy to write the persistence code and then you can plug in any database you want. You say your audience is not good with managing a RDMS, but thats fine, most are easy to install (package managers on Linux and one click installers on Windows) and don't need much managing, your application could do most if not all of it.
there isCAPTCHA for some log in forms.
If you are okay breaking/dumbing down your model for a key-value store, you can use gdbm which ships with Python and has good performance. If you need more power, you can go towards kyoto cabinet which is easily embedded, or redis or an sql database if you can have other processes.
You should crosspost to /r/learnpython and /r/learnprogramming :)
See [List comprehensions](http://docs.python.org/tutorial/datastructures.html#list-comprehensions). In this case, it is applied in a hackish way as a substitute for proper for loop. Not recommended.
How about using a more up-to-date GUI library? Tkinter looks weird on modern systems. A couple of popular libraries: Qt (PyQt/Pyside) wx (wxPython) EasyGUI Tkinter is ok, but it's kludgy and looks alien.
list comprehensions are more often used to create a list, rather than just iterate over something and ignore the output as in that example. Eg: &gt;&gt;&gt; squared_terms = [x**2 for x in range(10)] &gt;&gt;&gt; squared_terms [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
Try in /r/learnpython
Is it just me or does this module get posted every week? It's really nice and all, but ಠ_ಠ.
That has got to be the most bizarre title I've ever seen in this subreddit... Also, I read that as "autopsy" at first.
I similarly misread the title. Which lead me to wonder 'what on earth do they use mice for in autopsies?'
If I understand the script correctly it just logs into Project Euler which is just a post request. With the awesome [requests library](http://docs.python-requests.org/en/latest/) import requests from urllib import urlencode def main(): with requests.session() as s: resp = requests.post("http://projecteuler.net/index.php", data=urlencode(dict(username="username", password="password", login="Login")) ) print resp.cookies if __name__ == "__main__": main() 
Thanks guys, that makes sense (and is now pretty bloody obvious). I could have sworn I already considered this by doing a var=[] and printing the var but obviously didn't. In my defense, I was pretty hungover.
Has the same effect as: for comment in comments: comment.extract() However it also creates a list with all the return values of comment.extract(), and then destroys it. So there are some runtime differences.
the Python Essential Reference is a book you will find handy to have on your desk regardless of experience level. I would also recommend the Python Standard Library by example. http://www.amazon.co.uk/Python-Standard-Library-Example-Developers/dp/0321767349/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1315832380&amp;sr=1-1 
Mike Dawson's book is fantastic. It is what it says on the tin "for the absolute beginner" but he is really good at teaching certain concepts. Make sure you get the Second Edition if you are working with Python 2.x
Thanks mate. Is that why I've got 6 down votes? (-: Not to be a karma whore, but I don't understand the reason for downvoting this.
Seconding the standard library by example, I've been reading through it recently and my code is starting to improve from it. 
This is great stuff. I will give gdbm a try. Kyoto cabinet and redis look very interesting too. Thanks!
Add [The Quick Python Book](http://www.amazon.com/Quick-Python-Book-Second/dp/193518220X) to that list. If you are already a programmer, this book is the best since it's small, to the point and gets you writing python fast. From there you can use online references for libraries and API for specific needs.
These should be posted every now and then for those who have not seen them. Great resources.
Standard Library by example seems great. And its in kindle format too!
Nice plan. I wonder if they have tried to get in touch with companies to sponsor them. I'm pretty sure companies like Google, who have a big stake in Python, would be happy to chip in. At this point, PyPy is sharing many goals that Unladen Swallow had which was fully backed by Google.
Here's a Python curses emulator built on Pygame by a fellow redditor: http://www.reddit.com/r/Python/comments/kbbby/i_finally_finished_it_pygcurse_a_python_curses/ Here's a link to a full tutorial on creating a roguelike using Python and libcotd: [http://roguebasin.roguelikedevelopment.org/index.php?title=Complete_Roguelike_Tutorial,_using_python%2Blibtcod](http://roguebasin.roguelikedevelopment.org/index.php?title=Complete_Roguelike_Tutorial,_using_python%2Blibtcod) I have no experience with either, but I was thinking about giving Pygcurse a go since it's written by a Redditor and is fairly new, and it retains all of the original functionality of Pygame. Hope this helps.
TLDR: please give us $100,000 (and the reasons why)
Thanks! The tutorial will probably come in very handy!
There's also [Dive Into Python 3](http://diveintopython3.org/)
I will donate 100 bucks when the plan is up on the pypy blog.
Have you looked at http://python.org/doc/ first? Python documentation (including the tutorial) is of such high quality that I can hardly imagine how a book can add anything to it. And not just anything, but make it worth despite not having hypertext links and full text search, and gradually becoming obsolete.
I think corporate (or EC) sponsorship is the most likely way for this to work, but the idea of a Kickstarter project also appeals—it would be an interesting test of the Kickstarter idea.
Example?
Thanks, I'll try that. However, I wanted a solution where username and password are not integrated in the script.
Seconding, too. Best recommendation.
Yes, the official docs are great, but what's better for some bedtime reading than a printed python book?
Your link plus [Python Standard Library by Example](http://www.amazon.com/Python-Standard-Library-Example-Developers/dp/0321767349) is a hard combo to beat. Generally solid API docs, plus the standard source for examples.
Probably right on the head. In the sidebar `--&amp;gt;` it says '*news about...*', etc., so this type of post isn't expected in this subreddit (though it is prevalent). I saw that you had no replies and thought that it might help to point you in the right direction. Also, if you need a faster answer, I can recommend using [IRC](http://www.python.org/community/irc/). There are a lot of really nice, helpful people online at all times of the day, and they will probably not just give you the answer, but also give some good hints and suggestions about best practices.
On what are the estimations based? What is the hourly wage of a pypy developer?
For those who have problems with reading: "[AutoPy](http://www.autopy.org/) is a simple, cross-platform GUI automation toolkit for Python. It includes functions for controlling the keyboard and [mouse](http://www.autopy.org/documentation/api-reference/mouse.html), finding colors and bitmaps on-screen, and displaying alerts — all in a cross-platform, efficient, and simple manner.” So, with autopy you can say “move the mouse to position X,Y and click once”. But how do you figure out the X,Y coordinates? This is when my script comes in the picture.
[Mechanize](http://wwwsearch.sourceforge.net/mechanize/)
If you look at the total number, that's the salary of one good developer working full-time for a full year, and this all seems like work that could probably be done in a year. There's probably more thought going into it than that, but coming up with "this will take a year" and then "what do we make in a year" is a decent starting point.
[also check out the links in this post from yesterday](http://www.reddit.com/r/Python/comments/kcldb/free_python_books_pdfs_byte_of_python_think_python/)
nah, google should hire the pypy team and give them the task of coming up with the next appengine runtime. 
Wow, a year of full time work to port to Py3k? Seems excessive, but I am by no means an expert. I am still no fan of Python 3 because of the split it introduced, leading to so much effort in so many areas.
As long as all the data you need to persist can live in memory, I'd go with the pickle solution. From there, I'd look at some of the simple include KV stores (such as berkleyDB), then SQLLite, then moving up to the non-included KV stores or relational DB's (based on what fits your model best). KISS - not every application (even those that require persistence) needs a full blown standalone solution. And as long as you abstract the persistence away in it's own module, you should be able to swap solutions as needed.
I thought that being written in RPython (?) would make it relatively simple to add support for the syntax changes (most of step 1.x)?
With this document being out in the open, I think it's now up to companies to volunteer sponsorship.
It seems like a huge amount of work to me, but I'm not a compiler genius like them. It'd be easier to debate the estimates if they were incredibly detailed, but right now this looks like back-of-the-envelope estimates, which don't seem too far off.
&gt; what's better for some bedtime reading than a printed python book? A glass of scotch *and* a printed Python book.
Just as you would expect from a good project proposal, a grand total and the reasons why.
Except Py3k is more than syntax changes. The Unicode/byte string change is huge and affects a lot of bits. Then getting all the tests updated so they pass under py3k while ensuring they are still testing everything correctly (not just passing) takes time.
I thought it was $100. Both numbers seemed way off the mark to me, in opposite directions.
[More](http://hazeldoc.org/python/learn/)
i'm talking about things that don't have those, since the technique the blog post talks about doesn't work for captcha's either.
i'll post some later today and i'll message you the link =) the gist of it is that you use opener director objects: http://docs.python.org/library/urllib2.html#openerdirector-objects and you have to make sure that you add a cookie processor handler to the opener director (http://docs.python.org/library/urllib2.html#httpcookieprocessor-objects) but i'll post a full example later
You are not writing Java. Stop writing one class per file. 
After further reading, I think Qt may be a better option for a UI. That way, code ran in interactive mode is just passed to the buffer as a string which I can parse out (assuming Qt has a Python compiler!) EDIT: or PyPy per usernamenottaken's suggestion.
Very good idea !
I am afraid I don't understand what your question is exactly. Can you elaborate? 
what would you consider a fair number? 1000$ 10000$?
don't forget all the stdlib that changed since 3.2. That's usually the biggest part.
[Here you are.](http://wwwsearch.sourceforge.net/mechanize/#examples) Using mechanize means you have to integrate the username/password into the script (which is what the OP was trying to avoid), but mechanize is wonderful. You don't have to worry about cookies at all; just find the form, fill in the fields and call submit.
Am I the only one missing time estimates in this mailing? It's all well and good saying “this will cost 35000 $“, but without saying “...and this will take 3 months“ the estimate is worthless. Also, did pypy devs get paid for their work on their current and previous releases?
I think the OP is trying to avoid putting the username/password into the script (so as to use an already existing cookie). Oh, and [mechanize](http://wwwsearch.sourceforge.net/mechanize/#examples) is even easier than your approach :-)
Sure, thanks for asking. I'll try to avoid jargon that I'm not certain about. I want to write a statistical analysis program that emulates the coding syntax of [SAS](http://en.wikipedia.org/wiki/SAS_System) so that new-users can learn and experienced users can develop at home or on their personal box. SAS, however, has very little overlap syntactically with Python. SAS actually looks like a bastard mix of BATCH and C. Almost all subroutines are called "steps" of types DATA or PROC. These steps operate like functions, mostly, but have some key differences syntactically. All arguments to steps are passed like flags. For instance, extracting the first individual records from a (sorted) dataset called myTable based on an id variable called myID is: data myUniqueIDs; set myTable; by myID; if first.myID then output; run; The actual task is easily done in Python or SQL, so the question is how I could write a wrapper to take such a batch of commands and pass them to a Python or SQL argument. It would be nice to use the Python shell to allow for interactive execution of code, but syntactically, newlines don't matter in SAS. This code does the same thing: data myUniqueIDs; set myTable; by myID; if first.myID then output; run; So my question is how flexible can Python be in interpretting code of this structure? I hope that clarified a little bit.
I don't think your problem description is very specific, but I can tell you that python will happily accept semi-colons as statement delimiters. For example a = 1; b = 2; would assign 1 to a and 2 to b.
mechanize doesn't look like its for python 3, and it seems to be overkill for just filling in a username and password field. you can just use tamper data, find the post data, and then pass a dictionary of the post data / post value and send it 
Okay, SAS looks differently from Python. And what is your goal/question, exactly? Do you want the users to program in Python using a library of yours, or write a SAS-code interpreter in Python?
That's actually an excellent start. Is there any way, however, to stop the newline from being a delimiter?
&gt; Also, did pypy devs get paid for their work on their current and previous releases? No idea what the current status of funding is, but they've previously received funding from the European Union (I think it was a two year bid).
Definitely the latter. Ideally, someone could take the code they wrote here and cut-and-paste it into a file that could be submitted in a large job on a sas server.
Some of pypy devs got paid, some don't. I guess it goes 50/50, while in 50 that got paid are people who are working at their universities and pursuing their research targets using PyPy. I was the release manager for 1.6 and I didn't get a thing for example.
You might be better off writing an interpreter in Python rather than try to get the Python interpreter to read SAS scripts. You can use PyPy to write an interpreter: http://morepypy.blogspot.com/2011/04/tutorial-writing-interpreter-with-pypy.html Also, hopefully you're already aware of R and PSPP and these can't do what you want or couldn't have this functionality added easily?
Partially, it's based on the theory that a overestimate is better than a underestimate.
Good. But then I still don't know what your question is. Make it easier to help, please :)
Parse and replace prior to interpreting the script. If you're using '\\n' to do anything particular with SAS. This will not work.
More like $30,000. Half an order of magnitude down from $100,000.
I'm slowly answering my own questions as I'm trying to answer yours. Sorry if it seems like I'm all over the place. Basically, I think my version of this program will need to have several windows: an editor where the user types in code, and a log and output window where information about the subroutines. The question I have now is how I can use a window system to pipe text in and out of Python. I think, however, there are good resources online and I should look those up myself.
Some excellent references there. Let me check my bookshelves and I'll add a few of my favorites. In the meantime, check out this relevant thread: [Ask Reddit: How do I create the ultimate aviation/spaceflight library?](http://www.reddit.com/r/AskReddit/comments/a7j5u/ask_reddit_how_do_i_create_the_ultimate/)
Yes, I prefer R and am saddened by the inaccessibility and cost of SAS which is one of my impeti for writing this project. I think SAS could be improved in many ways, but nonetheless it's a required software for most corporate or government statistics. It's cost, however, is a burden to small companies and academic institutions, reserving an elite cesspool of statisticians the title of "SAS programmers". I would rather have a talented statistician learn to code SAS than a SAS coder learning statistics. Unfortunately, I seem to see more of the latter. The cost of licensing SAS is on par with Matlab (more, in fact), which keeps a very narrow margin of people from saying "I know SAS". There is no student license. And if you license a server, you're charged per *number of cores* if you'd believe that, "because each core is a dedicated processor". It's re-fucking-diculous. SPSS is actually very bad and "unfree" to use a Stallmanism. My original idea was to write wrappers which converted SAS code to R. However, nothing difficult is going on under the hood with SAS, so the actual statistical routines are less important than having easy and fast development with a nice interactive UI. My pipe dream is that hopefully it's something that academics and programmers could contribute to and go through an evolution like S+ did to R.
I don't see Google chipping in anything overly significant as they don't stand to benefit much (or at all) from this project. Making 2.x PyPy even better is more up their alley, as internally they're still on 2.5 IIRC.
Lol, alright. I was just trying to separate everything out, but now that I feel I know python's module system a little better, I will combine some files. Which files do you feel I should condense? Also is there any comments MVC wise you could make?
People have said this to me before, and I might ultimately take this advice, but currently there is not much of a gui, and what is gui looks nice enough because of ttk. At least for now. When I try to create a menu, etc, that is probably when I will change the gui toolkit.
[Handbook of Geophysics and the Space Environment](http://www.amazon.com/HANDBOOK-GEOPHYSICS-SPACE-ENVIRONMENT-Adolph/dp/B000RNNASO/ref=cm_cr_pr_product_top), this USAF pub is also a free download. [Satellite Technology and Its Applications](http://www.amazon.com/Satellite-Technology-Its-Applications-Chetty/dp/0830696881)
I guess they could be added to the Online books list on the right ---&gt;
I think they're migrating up slowly. AppEngine is supposed to support 2.7 in the next few months.
It's your call ultimately. If you're serious about learning GUI stuff, then it won't hurt to learn another. Even if you fall back to Tk.
For all of the graphical interface stuff, you might want to provide a backend for Cantor: http://edu.kde.org/cantor/, http://en.wikipedia.org/wiki/Cantor_%28software%29 That way all of the interface is done for you and you just need to write the interpreter for SAS code and probably a small amount of code to glue things together.
a generator expression would be a better fit in case one decides against a for loop (rather than using a list comprehension)... you don't need the intermediate result: * http://www.markus-gattol.name/ws/python.html#rule_of_thumb
Thanks! And, you know I hadn't checked it out... even though I posted it. :) Thanks for reminding me of it.
&gt; You would because that framework even with those components swaped is a lot better! And I told you could swap just to show you had choice., It seems that you have your first acne growing in your face, so its really nonsense to keep some type of talk with you. Just don't forget to drink your hot milk before bed ok? Ask mummy! &gt; Btw, fuck you too! You are a retard and you better stay with pylons! Django users don't want persons like you that are arrogant and rude when someone answers their questions trying to help! quoted so he can't change it to hide what he said
Can I suggest you have a look at the fantastically simple PLY module. I've written many simple parsers and interpreters in it - it's really fun. 
Are you aware of [GNU DAP](http://en.wikipedia.org/wiki/DAP_\(software\)) ?
Had a quick look at: http://analytics.ncsu.edu/sesug/2005/IN07_05.PDF PLY might not be a good choice because it works from a token stream and SAS Keywords are context dependent - it might be hard to write a parser for that. 
Yes but screen scraping is fickle and tends to break whenever the web service changes the HTML structure of their pages. Be prepared for a significant amount of work and some ongoing fixes over time as well.
&gt; Except Py3k is more than syntax changes. I was referring to *just* the syntax changes. You do have a point about the tests though.
It looks nice. I'll have to build it on my Linux box at home. No need to reinvent the wheel. I like that the output seems to be less verbose, that's one of my main gripes. I will complain, though, that: - doesn't have a Windows installer (Python programs can be "built" in Windows with an installer... right?) - not sure if syntactically compatible - source is in C My idea isn't meant to be *fast*, it's meant to be *easy* (to use, to install, to edit).
What the fuck am I supposed to be looking at? Someone repeatedly launching chrome from a terminal? Is this supposed to have sound to explain what is so special about this?
Did I hear you say 'AppEngine Python 3 support'? Because I could have sworn that was something one would mention.
They'll randomly chance upon this document?
You have laudable goals but I think you're grossly underestimating the complexity of re-implementing SAS. I think you'd be better off trying to get in touch with the authors of DAP or one of the other re-implementations of the system and seeing how you can help address your needs. 
##PLEDGE $5 OR MORE: #A character array e-mailed, free of charge, to anywhere in the world, when the final product ships, plus a mention on our thank you page. ##PLEDGE $10 OR MORE: #All of the above, plus the Konami code.
It is demonstrating how Chrome is used to create native-like applications on Mac from web applications (like GMail) via Chrome.
... and 3.x in the next decade.
But my goal is not to actually reimplement the whole thing, just the useful bits. On one hand, everything that's done in a datastep can be done in SQL while on the other, the data step language is complicated. However, I see what you're saying and maybe I'll look into DAP. I'll have to try to use it first to see if I like it. It looks like it might not have an interactive mode, though, which is what most people need to develop SAS.
my code: http://paste.pound-python.org/show/12421/ it seems the person at the top uses requests, which is nice, again doesn't support python 3. i didn't see that you were trying to avoid username/password into the script , but you either have to deal with that or have it be a 2 step process every time where you log in with a browser and extract the cookies from there. 
Same way they must have "randomly chanced" on PyPy.
Is it really that much? I though most of the standard library would be implemented in pure Python.
Yes, that as well.
You can use raw_input and the getpass module to get the username and password
This has the side effect of sorting the list also, which might not be desirable.
But a lot of it is not! Also, there's always a good deal of futzing around to fix tests and Python modules that rely on CPython implementation details.
I've never used MongoAlchemy but I did use [MongoEngine](http://mongoengine.org/docs/v0.4/) for a few things. Anyone happen to know how they compare?
no you didn't "hear" me. I'm not worried about python 3 appengine until webob works on python 3 (months away). And I am a patient boy. 
Upvoted for PER, David Beazley creates documentation you can't get anywhere else. This is soo much more than a rehash of what you can get online. The front section of the book gives a very compact and useable tutorial/reference to the language itself. The back 2/3 (or more) goes over the batteries.
the official docs are very much lacking.
IIRC, requires a premium account.
all these europeans can work for such low pay... thats why they do a good job. PS: i know the comma
They are using the European decimal separator which is a "." not a ",".
Based on how you word your question my honest suggestion is "don't do it". Not that it can't be done but that, right now, you can't do it.
And *this* is why I always write large numbers like this: &gt; 100 000 Instead of &gt; 100.000 or 100,000
You do realize that we are talking about at least a year of work right?
I think the real test of Kickstarter will be when Kickstarter funds a Kickstarter competitor.
My god.
There is no such thing as a European decimal separator. Each country has its own standards.
Fast Python is bad for business. 
All of the European countries I have visited and lived in have used the period as the decimal separator, however technically you are right.
&gt; What is the hourly wage of a pypy developer? African or European developer? 
Thanks for the continued awesome work Pyramid team.
Some social engineering might yield better results. For example, convince a tech savvy TA to publish RSS feeds. It will depend on what tool they're using to manage the class website, if any at all.
Before were were crushed under the boot heels of ASCII and various computer programming languages, the decimal separator was a comma through most of Europe, a notable exception being Britain (and I assume Ireland) where a raised dot was used, as in 6,28318 or 6·28318. Switching to using a full stop instead is the path of least resistance given the feebleness of locale support in late-twentieth-century computers. It’s a change that has happend during my lifetime—at school in Australia I was taught to write 6·28318 and 1 048 576. Nowadays it’s 6.27318 and 1048576 because you can’t easily type the dot and computers can’t grok numbers with spaces.
one african, rest european, to be precise :)
I can't help but laugh at all the blowhards in these comments having a stroke over the estimations. Compare to the salary+benefits (and liability!) of a team of staff engineers. Sounds like steal for any corp that has a lot riding on Python.
Just calculate the hours that went into making Python 3 and multiply with a reasonable salary. I bet Python 3 would have been much more expensive than this proposal if the development effort had been paid.
I can ... if you explain a little more ... mail me on gmail with this/my pseudo
In France the decimal separator is a comma, and the thousands separator is a space.
Fuck spotify! Artists are making 0.00000045% of profits. They are hipocrites and leeches.
Docs, help or tutorial somewhere to see what is this about? 
So: Note that, even for Python 2, ``cpyext`` is still in a beta state. In particular, not all extension modules compile and load correctly. As a consequence, the same will be true for Python 3 as well. So this 3.0 PyPy will be a nice curious project without any practical value, like the PyPy 2.x project. 
I give up trying to give you a reasonable answer. Fuck you it's useful for me and for my laser-equipped battle droids.
The page he linked to had was the documentation. There are links on the side http://pandas.sourceforge.net/overview.html
I don't want a reasonable answer. I want my C extensions working. Ultimately I need a faster Python. If PyPy can't deliver, then some other solution will turn up. 
well, this is a very demanding approach for a stuff that you get for free, don't you think? You get a fast python and you get some support for C extensions and some replacements, yet it's an utter failure if it doesn't work for all your extensions? I guess get yourself together - it's not that hard to rewrite what you really need in Python, people have done it. Supporting C extensions with exactly same API is a major mission and would be too constraining for it to be useful.
Well of course I am demanding. PyPy is the only project that has a any plan to fix Python's performance. Everybody else (including Guido) just gave up long time ago and write C extensions which is a shame. I don't remember the Java Hotspot compiler breaking compatibility with C extentions. You should have implemented 100% compatibility with the C extentions even with the cost of 10 times slowing the execution of those extensions. Then people will start replacing their C extensions. By the way, I don't use Python 3.x anyway. It also broke support for pretty much every external module. 
More for audio processing, but have you seen Minim for processing? it looks really cool - kinda wish something like it for python existed ...
&gt; If PyPy can't deliver, then some other solution will turn up. To which you also won't contribute anything? Scratch your own itch and get working.
Good point. Once I thought I will try to understand how PyPy support for C extensions works, to I can fix it, but I couldn't understand how PyPy works at all in the first place. Those guys made one pretty scary monster. 
you get upvotes from me because it's true. the more efficient python is, the less $$$ google makes on appengine. 
damn I didn't even get my stuff upgraded to 1.1 yet. stupid appengine. 
Looks like a troll. 
This looks great! Now if only they'd get a halfway decent plotting package I could start using python for everything.
We don't always see that which is in front of our face. How many times have I spent hours looking for a bug, for which I would have looked askance at a entry level coder for making?
at this level you're not only demanding, you're just a dick to people doing open source (in their free time). Go away, I don't care if you use my software
combine with [PyQuery](http://packages.python.org/pyquery/api.html)
I'd vote both Python *and* Java. I learned things from both. In particular, Java forcing you to make *everything* an object, while in practice less than ideal, at least got my brain thinking in those terms. Plus the whole static typing/IDE integration thing - would be great to have a working compare/contrast of that approach to the dynamically typed way of doing things.
What's wrong with matplotlib?
Look at it this way: There are only two kinds of alternative Python implementations: the ones people complain about and the ones nobody uses.
You can definitely tell from the pixels.
Don't worry, I just did a migration from 1.0 to 1.2 and it worked out of the box. The only thing I did was removing weberror to install the new debugtoolbar instead (which rocks).
yeah I know I can upgrade. the problem is, all the gae plugins for the test suite make it very difficult to tell ae to pick up the new webob instead of the one coming from the sdk. thus tests fail, though the app itself runs just fine. so it's not a pyramid problem, it's an ae problem. and one I can hopefully ignore when the new ae runtime supporting 2.7 is released(fingers crossed)
Try PyCharm. Its my personal favorite or you could use VIM if your a masochist.
what happens when the cookie expires? you have to login using firefox to generate another one, seems a bit of a crude solution. 
&gt;if your a masochist. Whose?
I use Eric pretty regularly, and don't really notice the weird troll thing, not that it would be difficult to remove.
Well, for the moment it was the working solution I found. I've never tried requests and mechanize, I'll look at them later. If the cookies expire, then yes, you need to log in again. But quite often cookies are set to live for a year or two. On the other hand, specifying your username and password each time you run the script (via raw_input for instance) is not a nice solution either. And if you integrate these data in the script and someone gets access to it, that's a problem...
VIM is excellent if you write a short script. If you write a longer script, fire up an IDE. If you are afraid of vim, start with `vimtutor`. In 30 minutes you can learn the basics.
I used Eric but I didn't like that renaming only works with projects. If I wanted to edit just a short script, refactoring was disabled. And for a short script I won't create a project.
yeah the problem is actually in the tests, the NoseGae plugin seems to import all the stuff from the sdk before my TestCase.setUp actually gets called. The app itself runs fine. I'm sure it's fixable I just haven't had time. 
I just wish there was an IDE that supported TextMate style highlighting. That stuff is beautiful. There's aptana, but it seems to be so slow :(
If you're familiar enough with vim and have the right plugins, it is easily as good as (if not better) than an IDE.
how was this? I missed it, :/
Well, for larger projects I prefer an IDE (PyDev is my current favorite). BTW, what plugins do you suggest?
I know this question wasn't specifically addressed towards me, but if you're unsure of where to begin, I would suggest starting with [sontek's](http://sontek.net/turning-vim-into-a-modern-python-ide) quick guide and then build from there. Vim and Emacs are truly wonderful development environments, both fully capable of providing most, if not all, of the features found in IDEs. Edit: I would highly recommend reading what the suggested plug-ins do instead of just following the guide, if you have the time.
you could try sublime text 2 with sublimecodeintel and sublimelinter plugins.
Well, they are not really websites maintained by the Professors/TAs, more web services for quizzes.
+1 for PyDev Sure Eclipse is bloated compared to VIM but it's so much better. Aptana is also very cool if you're doing web development Edit: Am I downvoted because I said Eclipse is better than VIM? Edit 2: Why I like PyDev better than VIM: I really like VIM. It has a bit of a learning curve, but that's alright. Once you've installed the right plugins, fiddled with vimrc a bit, it's way better than any IDE. But it takes a while to configure it the way you want. There are lots of blog posts and tutorials online, but it can still be a bit daunting. (eg: code completion is something I haven't been able to get working right in VIM) On the other hand, with Aptana/PyDev, once you've installed it you're pretty much ready to go, just point it to your python interpreter. Code completion, debugging, and so on. If you're doing web development, the HTML, CSS and Javascript editors are great, and it even supports Django templates.
You might find this handy: http://www.bitformation.com/art/python_toposort.html
whats the problem with Notepad++ ?
I used graphviz some years ago. It has a description language that you can learn about in its doc. Your Python script could generate a .dot file which contains the description of your graph. Then graphviz can turn this .dot file in JPEG, GIF, PS, etc. I have a [Java API for GraphViz](https://github.com/jabbalaci/graphviz-java-api), maybe it can give you some ideas.
why don't you trye the std lib ftp: http://docs.python.org/library/ftplib.html
Check if what you want to do is possible and to what extent by reading the [FTP](http://www.faqs.org/rfcs/rfc959.html) and [FTP extensions](http://www.faqs.org/rfcs/rfc3659.html) RFCs. If you have to do something custom with the protocol, with a nicer interface, you might need to program your own FTP handler using the [socket module](http://docs.python.org/library/socket.html). At that point you'll see it's easier to work with ftplib, or subclass ftplib.FTP tldr; bad news... EDIT: Nice find there, OP!
I love Emacs with eclim (Eclipse integration for project-management and semantic auto complete), Viper and Vimpulse (use emacs with vim commands). Best of all Worlds!
vim is excellent all around, I've been a part *very* large projects (in a myriad of languages) where everyone uses vim. You just need to *know* vim. (Caveat: I'm actually someone who hates the cult of vim and do not use it anymore primarily because of this cult... That being said, statements like "vim is great for short scripts" really do bug me... Just because *you* don't understand vim doesn't mean it's lacking the features you need or want.)
* [Yapgvb](http://code.google.com/p/yapgvb/) * [pygraphviz](http://networkx.lanl.gov/pygraphviz/) * [pydot](https://code.google.com/p/pydot/)
&gt; VIM is excellent if you write a short script. If you write a longer script, fire up an IDE. What about Vim makes it not good for larger amounts of code?
You're right, ftputil is awesome. It is what I use for all my scripts that require FTP functionality.
Some of the logos and icons used in systems are less than appropriate for the business world. Sometimes they can be replaced easily, other times not. Undoubtedly a copyright violation unless it is GP3 or the like.
Funnily enough, that was a turn off for me too. I assumed the developer is so profoundly unaware of any aesthetic considerations so as to not realise that they are putting a hideous and scary figure all over their work
It's not an IDE. Also, does it work on Linux?
not at all, just windows, i used geddit in linux but as you say they ain't IDEs
libcurl supports ftp: http://pycurl.sourceforge.net/
this works in windows ?
Nothing beats WingIDE (http://www.roguecode.net has a review) http://www.roguecode.net/2011/09/wingware-ide.html
It runs perfectly in WINE last time I checked.
Because as long as you are going the non-IDE route, you might as well use vim or emacs.
Kate is good KDevelop is [getting real good Python support](http://scummos.blogspot.com/2011/09/kdev-python-argument-type-guessing.html). 
It looks really, really nice...but the price tag scares me. That's a lot of money for an IDE that only does Python.
Not sure. Personally, I prefer the Netbeans Python support over PyDev. PyDev is nice, but it just seemed a little quirky at times. So far I'm liking Netbeans better. My plugins list is nicer and easier to deal with and the support for vc is pretty nice. I love VIM, but I will give you an upvote because this is all just a matter of opinion and opinions should be encouraged. That and I do like Eclipse for certain things.
FTP is a really nasty protocol. Is there any chance you have control of the server and could use a different protocol instead?
I'm using pycharm and it is a pretty good Python IDE. It is currently on sales for $50, it's pretty cheap.
I haven't tried Eric IDE cause there are no fucking prebuilt packages for any OS, that may be acceptable on Linux but compiling programs on mac and windows is hard as hell, if I can even figure it out half the time
What do you mean? What's so special about TextMate's syntax highlighting?
It was a joke about the Unladen Swallow skit from monty python :)
really? compiling on a mac is too hard? i know it can be a pain sometimes but overall i don't think it's that bad. besides, it's always good to beef up your shell skills :)
Here's some of the plugins I use. For managing vim plugins, use either `pathogen` + git or `vundle`. A few Python-specific plugins I use: * `pyflakes-vim` is a must have (highlights syntax errors, undefined variables, and lots more) * `pep8` plugin is also a nice addition (shows PEP-8 violations) * `ropevim` allows you to do all the fancy refactoring you can do with an IDE and `rope-omni` allows you to use it for omnicompletion * `pydoc` Beyond that, there's a ton of non-python specific plugins that are somewhat up to taste, but I would recommend: * `fugitive` if you're using git * `NERDTree` * `snipMate` * `surround` * `gundo`
its not just running make, that parts easy, i have to find and install all the dependencies and compile THOSE too, like QT and QScientilla or whatever. And on windows? haha good joke
http://blockdiag.com/blockdiag/build/html/demo.html Maybe?
 0 root@Anonymous:/root&gt; aptitude search ^eric p eric - full featured Python IDE p eric-api-files - API description files for use with eric I have a package for Eric in my Debian GNU/Linux system. You don't have them in your operating system?
Yes, after 2 days I found it :/ and it works perfectly! I see ftplib like a generic module, you have the basics, but you can't really use it if you don't create your own module. Anyway, I'm doing a sync tool, right now it works but still needs more testing, when it's ready, do you want me to upload the source code? Pictures: http://imgur.com/r7LXx&amp;NN3jZ&amp;8dB0a&amp;D00XO&amp;An0IGl?full It's supposed to be Cross-Platform and I will probably do the .exe files for Win64 and Win32 with py2exe
not in mac os x or windows.
Regarding your edit: probably, since "*x* is so much better than *y*" isn't generally tolerated without some explanation. Opinions are great, they just need supported a little. I did not downvote you, by the way. That said, how is PyDev better than vim? I'm not saying it isn't, I've never used PyDev. I use vim + plugins and have been playing with PyCharm and Wing IDE trials.
&gt; Do you guys know any other module for doing FTP transfers in Python apart from ftplib?
I've actually been thinking about doing something similar. I already have a functional version of Unison I wrote in Python to keep my desktop and laptop in sync, but it is _purely_ functional. When I was first learning my way around Linux, though, I wrote a script to sync a remote FTP directory to a local one.
cough gimp
PHP isn't the standard for backend coding. It's just popular on the low end.
It is worth overcoming the fear of old dick nose. You can turn off the splash screen. I love eric been using it for over 10 years.
PHP was first. 
I have tried Wing but I still like eric better.
Notepad++ is a bit basic. I'd rather use vim.
I like Kate, I use it for web development. The VI bindings are very good.
Eric is written in pyqt so one can change anything in the application.
What's wrong with gimp's logo?
If you really like it then submit a PEP. If the community agrees then you've just strengthened Python. There are more coders available than idea people! Also, why call it "emulating"? It is really "implementing" unless you are making an incomplete copy.
It works on unix/linux, windows, and OS X I use it on all three systems.
Nothing. He probably just finds it hard to copy and paste his code in vim.
I was thinking about putting together a OS X package of eric Eric on windows is easy. The mac is a little harder but not so bad now. I have been busy and my mac book's video shit the bed again.
In Eclipse I have the file I'm working on open in both VIM and Eclipse. So if I'm typing a new line of code I get all the completion and stuff if I have edit or re-factor I use VIM. The editor in Eclipse is vile. 
I expressed my own opinion. If vim is good for you for a big project with loads of source files, fine. Good for you.
Python is a great choice for web development. It's just not widely installed, and using it in production environments takes some thinking. You have to convert your program into a WSGI program, then install a WSGI-enabled server, then use ANOTHER server to handle static files, and on and on. Apache and PHP? Dead simple to install and use, and it's usually already installed and ready to go. No need to 'wrap' your program, or do another installation or configuration. Also, in the simple case, php 'pages' are just html with some php embedded. This means 'older' sys admins are comfortable with them, because they're comfortable with apache and html. I think how we deploy and develop python web applications is much better for developers, and creates better results. It's just a more involved process than getting apache/php going. Edit: Moving forward, you probably won't see hosting companies offering python hosting in the same way they offer php hosting (ie here's a server you can FTP into, go nuts in this directory). Instead, you'll see options like synchronize this online application with a git-hub (or similar) hosted WSGI application, map it to this url, and use these database options. AppEngine is a good example of this new style of hosting. 
You can put a single .php file in a directory on nearly every hosting accounts out there and it works. You cannot say the same for Python. This is the main reason why. Python is a great choice for web development. It just requires a little more [know-how](http://wiki.python.org/moin/WebProgramming) to use it properly.
I've been using Sublime Text since I found it in May, fell in love with it and purchased a license pretty quickly. Thanks for the interesting plugins to look up!
I was originally going to do that, but the damn troll is *everywhere*. Haven't selected something in the configuration screen? Troll. Haven't opened a project? Troll.
No it wasn't. Python is older.
You currently need X-11 on OSX...no thanks.
It's not the most popular for any really other than low end stuff because it's easy to set if you're offering hosting and you can make a mess of it and it works so people who aren't really programmers love it.
I have had great luck with ZODB. I wrote a bookstore Point of sale system that used it. 8 registers 2 print stations 8 paper shopping kiosk terminals. All tied together with one ZODB instance using ZEO. The system is used at a trade show bookstore for 5 days and then it is over and packed up for next year. Here is good comparison between ORMs and ZODB http://pyinsci.blogspot.com/2007/09/zodb-vs-relational-database-simple.html EDIT: The above blog post was not the one I was thinking of the one below is a very interesting read. http://www.upfrontsystems.co.za/Members/roche/where-im-calling-from/zodb-benchmarks-revisited
Greater complexity does not equal better technology. And following the rule of KISS, keep it simple stupid, does not equal lack of ambition.
True, Python is older. What I meant was the PHP was available as a web-scripting environment before Python. My bad for not being clearer. [The first version of mod_python as modified by Gregory Trubetskoy was released in 2000](http://en.wikipedia.org/wiki/Mod_python) whereas mod_php had already been available for some time. 
how is it easy on windows? don't you need the source code to qt4 and all that then you also need the ms compiler and all that? thats a lot to install for one program
Why do you think hosts will be moving to an AppEngine type model? While in my experience with it, it has been fairly straightforward, but I have felt restricted in some regards while using it. Also, I have next to no experience with backend coding, so I hope you don't mind clearing some things up... First, why must you have a seperate server to handle the static files with a Python setup? And, are there any efforts to streamline the installation and setup of Python in a web environment, something like a LAMP stack?
I'm not the blog author. I just found an interesting trick and thought I'd share it. (I'm assuming your addressing me as the OP, ignore this comment if you're not)
Heh, nice one Bruce.
What? No, you just download the libraries. Seriously, there's no compiling under Windows. Hasn't been for years. As for compiling QT, that would be madness. I've never done that on any of my (Debian) Linux systems and plan to never do so.
Just like cevven wrote you don't need to comple. http://www.riverbankcomputing.co.uk/software/pyqt/download Scroll to the bottom of the page and grab the windows installer that matches your setup. Download the eric tar ball or zip then in the eric src directory run python ./install.py or something like that. Then eric4.bat will be in the c:\python2.X directory.
I was responding to your pompous answer to the OP, not the OP. When a language bigot gets shot down, it is useful to divert attention from the points used for the shoot down. Programmers can write crappy code in any language just as programmers can write good code in any language. BTW I've forgotten more languages than you know and perhaps more than you will ever know..
I just read about an application called vimtutor a bit earlier...haven't tried it yet, but it's something to check on. 
This is probably ancillary, but [pyinotify](https://github.com/seb-m/pyinotify) could also help you provided your kernel is new enough to support [inotify](http://en.wikipedia.org/wiki/Inotify) (2.6.13, I believe).
This would be asked better on r/vim. There is also r/vimcommands for people to post commands that they find useful, and r/vimplugins for plugins that people have found useful. I would not worry about guides being a year or two old - Vim is pretty stable so they are likely to be as useful now as when they were written. A good introduction to Vim is the free online book [A Byte Of Vim](http://www.swaroopch.com/notes/Vim).
It says at the bottom that they give out free licenses to unpaid FOSS developers. So it depends on your use case.
First, I don't think your premise is true. There is no such thing as a "standard" backend for coding. PHP is as popular as it is because of mod_php/apache making the barrier to entry so easy and the feedback loop so short for developing simple webapps. PHP is basically a templating language; so for anyone who has just learned HTML, it feels like a superset of HTML. The 1 to 1 mapping of file path to URL is really simple to understand. mod_python [has a similar feature](http://www.modpython.org/live/current/doc-html/pyapi-psp.html) but the paradigm just doesn't work well with an explicit language like Python (think of the magic $_REQUEST variables of PHP). Its use isn't recommended, and anyone who has had to maintain a decent sized webpage will tell you separation of templates, database logic, business logic, etc. is a good thing.
Where are the best docs for it or user-created docs, examples, etc?
I would not recommend going immediately to a graphviz-specific library like pydot or pygraphiviz. Instead, use [NetworkX](http://networkx.lanl.gov), which has an intuitive interface to build you graph and can interface with those graphiz libraries, but can do much more interesting things if needed. E.g. [export](https://bitbucket.org/hagberg/networkx-d3) to [d3.js](http://mbostock.github.com/d3/) if you want graphs-on-the-web, or push real-time to [Gephi](http://gephi.org/), etc. (if you are stuck &amp; give the structure of your data, I can write you a snippet).
Thanks for the reply, I've edited my original post with my reasoning
I don't know where all the hate is coming from on this comment. Who here cannot agree that: 1. PHP is an easy and forgiving beginner language 2. Developers can stick with one language/framework without exploring other options or keeping up on new ones. I'd guess that at one time or another we've all done it, gotten into a cozy little rut and had a realization we needed to break out of it, it takes longer for some. Maybe you do break out and realize you like the rut better, so be it.
PHP is easy, it throws together HTML and sql very quickly. It's not the best but it gets the job done, especially for low end websites.
That is true though I was thinking about CGI scripts which is how you usually still have to run perl on shared hosting. But CGI does suck and that's another reason PHP took off because as you say it was integrated into apache more quickly through mod_php.
I kind of dislike that the code does different things and is not a 1:1 translation. Therefore Python looks a lot more verbose, where it is not.
First and foremost, PHP is widespread because it is widespread. As to how it _got_ there in the first place: blame `mod_php`. At the time, the only competitor `mod_php` had was CGI and CGI really sucked. PHP also started off as a template language, which means it's much easier to just throw some PHP code into an otherwise static HTML page and use that instead of writing an entire CGI script in another language and echo the right things to the output.
Most people in any large group stick to the status quo. This has nothing to do with web developers and everything to do with human nature in general.
Haskell is *complex*. PHP is just *complicated*. There's a world of difference.
 raise NotImplementedError is the Pythonic way to do it, many IDE recognize this and can give warnings on incompletely specified sub-classes accordingly
nothing?
yes! It's popular for really simple stuff, but a lot of more complex backend systems are written in Python (or Ruby on Rails)
That's rather a simplistic view. The better they make appengine, the more people will use it. Making code run slowly so they can charge users more isn't going to work well in the long term, and Google has some track record of thinking about the long term. Also, I'm fairly sure Google uses Python themselves, so there's an inarguable motive to make it faster.
When you start out with PHP, picking up `mod_rewrite`, object-oriented programming, MVC, etc leads to a paradigm shift. You'll probably abandon a lot of what you learnt before and try to adapt to the new ways. In Python no such shift is necessary, but what you need to know (not necessarily understand, yet, but simply be able to reproduce) is a lot more if you "just want to make a website". PHP's out of the box experience is better, but at a significant cost: almost everything you learn by looking at the "easy way" will turn out wrong or unsafe. You shouldn't throw your PHP scripts in your web root; you shouldn't write spaghetti code; you shouldn't put PHP code _inside_ HTML pages; etc. Python, as a language, is much easier to pick up. It's probably easier to learn a lot of advanced concepts as you'll often be using them unknowingly before you understand them. It's probably easier to get to a certain point of understanding with Python than with PHP. But you also need to know more if you "Just want to make a website" than what you need to know to play with PHP (and inevitably hurt yourself). PHP's main appeal is simplicity, but that is obviously a lie. PHP is not easier. PHP just looks easier, because you can make an entire website just by throwing some PHP scripts inside your web root. --- EDIT: I have absolute respect for PHP developers who have matured to a sufficient level and know about the security issues that are so common in PHP. PHP is not an absolutely terrible language. I don't like it and it's fairly inconsistent in many ways and took a lot of unconventional steps, but it won't somehow turn every developer who touches it into a babbling idiot. But the easy way -- the wrong way -- most beginners try to use it eventually leads to very terrible code and is probably the main reason for it's bad reputation. It's not trivial to learn. Doing it the right way usually means avoiding most tutorials out there and staying away from the seductions PHP throws at a young programmer (e.g. "I can be a template language, if you want!" or "Just paste this line of me into your HTML -- I won't tell!"). Becoming a _good_ PHP programmer is no easy task. Sadly most PHP programmers never go beyond that simple understanding of "use `print` to make text come out" and learn how real web applications work.
Php was the primary language for doing backend coding in the late 90s and early 2000s. It's been superceeded by Java as the go-to language. Python would be more dominant if it could perform better and it had multithreading on par with Java. There's been a significant amount of web-based python development within the last 2 years to make it more of a web language. It was initially designed to be multi-purpose, though, and that makes it significantly easier to use for a number of applications over php.
Nope.
AKA "90% of everything is crap". Yes, it's true that the majority of web developers is worse on average than the entirety of them. That's not really a novel insight and I'm surprised if anybody would find it offensive. I think you're being a bit harsh by saying they are also not ambitious, though. A lot of sufficiently ambitious developers simply have other considerations stopping them from adopting other languages for production. I think the main reason Python programmers on average appear to be better than the average PHP programmer is that the entirety of PHP programmers includes a lot more beginners and otherwise non-programmers than the entirety of Python programmers does. Although Python has recently begun to be adopted as a teaching language in some universities, I would still wager that most people who pick up Python (and stick with it) have prior experience with at least one other language. In other words: it takes a real interest (you call it ambition) to find out about Python and invest enough time to learn it and use it in production, whereas all you need to do to find out about PHP and learn the "basics" is just asking a random person on the web how to learn to make websites. PHP's pool is bigger, but there's a lot more small fish than in Python's. To put it bluntly: when it comes to the quality of developers, Python has the better signal-to-noise ratio because a metric fuckton of beginners and non-programmers are messing up PHP's statistics.
&gt; Don't use beautifulsoup, use html5lib or lxml. In the early years of World of Warcraft, I was pulling game data from three different web sites into a local database. BeautifulSoup was easy to use, but even better, it was the only library I could find that was forgiving enough to handle parsing three different sets of some of the most god-awful html I've ever seen. Every other library choked on the errors. Any particular reason for your preference? 
"comprehensive" and "for beginners" are basically opposites when it comes to learning vim or emacs. Pick one, google it, ???, profit.
It generates three line combination of | and _ symbols based on input string of numeric chars. &gt;&gt;&gt; seven_seg('3') == seven_seg('5') == seven_seg('8') = True So one can conclude that this code somehow connected with fibonacci sequence or '3-5-8' (major sergeant) card game. Its not an encryptor or obfuscator.
??? = practice practice practice
&gt;Why do you think hosts will be moving to an AppEngine type model? what makes you think that's necessarily a good direction? I don't like that direction at all, and I don't personally think that it has staying power with the Python community; it's not Pythonic, in nature. Pythonistas, by in large, are paranoid control freaks that want to simplify the task of being paranoid control freaks so they can be better paranoid control freaks, while Rubyists, by in large, are more concerned with results than methodology and are content with using things they don't understand. (e.g., I've worked on a RoR project where clicking the wrong button in a browser literally corrupted the entire MongoDB-this-is-the-hot-shit database; that type of dumbfuckery I've never experience when working even very beginner Python developers.) The Python attitude is more nuts and bolts; the Ruby attitude is "who gives a fuck?" Both have their strengths and weaknesses. I personally prefer Python because when I use Ruby and I don't know how things are working under the hood, I am terrified they are going to break horribly and I just can't sleep at night. Seriously. It's great tech. It's just not Python. It's something else. It's a different attitude. Heroku works for Rails in a way that similar services don't work for Python largely for cultural reasons. In general, Rubyists don't pee their pants thinking about imagined future problems in the way that Pythonistas tend to. VPS providers are one thing, but things like AppEngine put you at another company's mercy. Not only do I not know Python web app developers that use PAAS solutions, I don't know any Python web app developers that are actually interested in doing so. Now. Take a long-view look at hackathons (code sprints). The Rails community consistently smokes the Python community when it comes to building prototypes quickly, even if they *are* all smoke and mirrors. &gt;First, why must you have a separate server to handle the static files with a Python setup? You don't. It's an overgeneralization. You *can* just use Apache and mod_wsgi, which is actually the recommended deployment setup in Django's official documentation, but an nginx setup tends to be more performant. You *can* process GET requests for static media through your URL routing engine and have a wsgi app return static objects, but then you're invoking the Python interpreter to do so, while using nginx just serve them up directly without having to invoke the Python interpreter. Which is "easier" to configure is largely a matter of perspective. I personally found learning to setup an nginx+gunicorn+supervisor stack with log rotation and booting at startup to be much more challenging than doing similar with apache+mod_wsgi, but many people disagree. It depends on what you already know. If you don't already know how to configure Apache (I knew it from PHP) I recommend skipping the apache+mod_wsgi solution and going straight for nginx+gunicorn+supervisord. Either way it's a lot of painful and boring yak shaving the first time you do it, but it's easy once you know how it's done. &gt;And, are there any efforts to streamline the installation and setup of Python in a web environment, something like a LAMP stack? Python will never be streamlined in the way that PHP is streamlined because Python was not designed specifically for backend web development in the way that PHP was. By contrast, try writing CLI scripts in PHP as opposed to Python and you'll see that Python is much more well-suited for this task, because PHP isn't really used for anything *except* back end web development. Much of what Python has to take care of for itself PHP gets for free because it's provided for free by Apache and mod_php. However, I do think that the default configuration for Django is sorely lacking in some sensible defaults, and things could "just work" a little better out of box. And if you're thinking of getting into Python web development for the first time... just... don't try Pyramid. Sure, it may be brilliant once you know how it works, but the Pyramid manual is a fucking tome and when I tried it there wasn't a dead-simple, straightforward "here's how you make this type of application" tutorial that made sense. It's all "if you want to use this type of url routing, do this", "if you want to use this type of nut, do this", etc. For me it was choice paralysis. While I like that the style of Python is to be explicit and to make few decisions about how a developer wants his system set up (i.e. there is a low degree of *opinionation* in Python tools, while there is a high degree of *opinionation* in Ruby tools), it is daunting for a begineer to be taxed with the number of decisions that are required to be made to run apache+mod_wsgi+Django+MySQL, which is by far the most common despite not being *the best*.
*cough**cough* facebook
I believe QT comes installed on Mac OS X...if not, it is very easy to install. I am going to try to install it and will let you know how it goes if you are interested.
I have compiled QT a number of times...it isn't a short compile time.
PHP is sloppy, you can dump it anywhere mix it up in markup or design your own classes. Python is tight. The white space makes it horrible for inlining. That enforces an MVC model…so some would say good from a design perspective. The end result is a guy with a few hours on a PHP tutorial can actually start cranking out dynamic pages that work. The same time spent on Python by a newbie is almost completely consumed by beating their head on the desk and firing off emails and chats asking why they use or edit any of these python files without getting white space errors. And then, once a kind person instructs them on how to set up their editor and explaining white space they find out they have to learn this "MVC" thing or "templating" and "modules" and "imports" and python is practically unusable for web without a "framework". TLDR; PHP is easier for newbies who want to do web work only.
&gt; A lot of sufficiently ambitious developers simply have other considerations stopping them from adopting other languages for production. I don't mind people that simply write PHP to pay the bills... I do that. The thing that really blows my mind is when people try to defend PHP. Some have Stockholm Syndrome, some aren't well versed enough in nicer languages to understand what's wrong, and the others... well, they frighten me. &gt; PHP's pool is bigger, but there's a lot more small fish than in Python's. To put it bluntly: when it comes to the quality of developers, Python has the better signal-to-noise ratio because a metric fuckton of beginners and non-programmers are messing up PHP's statistics. I agree that PHP's developer culture is noisier because of all of the less experienced people, but it's not just that. The language is so poorly designed that it actively drives away the more experienced people. A bad language attracts fewer good developers, which causes fewer good libraries to be maintained, which scares away even more good developers, and the language itself to attract fewer talented maintainers... etc. It's a vicious cycle. Meanwhile, I can't help but constantly stumble across excellent, high quality, actively maintained Python libraries that I don't even have a use for, and the language is regularly being revised with well thought out changes. It's a world of difference.
Bingo. I really want to start using Python on the web but I do not have the server knowledge to setup a secure server/web server to run my WSGI scripts on. Because of this.. I only use Python as a glue language to automate random tasks.
&gt; web developers aren't ambitious enough to seek out better technologies More to the point: Maybe it's not a sufficiently important consideration in their chosen markets to take on the extra work of moving to a technology for which finding a host would be more difficult. Seen in that light, they are perhaps smarter than you might care to think. For example: If I'm in the business of building/support real estate web sites and my customers aren't demanding any particular technology; would it be smart for me to choose Python simply because I believe it's the better technology? Shouldn't the ubiquitous nature of PHP hosting factor into my considerations? Having the ability to pull up stakes and move to another host or even just partner with a new host on an existing code base is a powerful incentive to choose a lowest common denominator technology. 
What you need to understand is that most websites dont have a 'long run'. Nor do most people care about their skillset too much, most just want a website for their hobby or small business, and hey, php gets that job done fine. sleighboy makes a good point.
one could say that's a rather naive view. they are a publicly traded company motivated by profit. and as with all corporations they will likely do what will make this quarters # look good. I guess you aren't familiar with how butt hurt everybody is right now about the pricing changes for appengine. look into that. :) ftr: i'm still on appengine. my apps are designed right so the change in cost isn't going to hurt me as much. 
You should try PyCharms. It has a few really cool features if you work with django alot.
But why do giant companies filled with some of the best developers out there use PHP then? Why does Facebook use PHP? Why do Wikipedia, Youtube, Digg etc all use PHP? 
The site has tutorials and a pdf document about the interface. http://eric-ide.python-projects.org/eric-tutorials.html One handy thing to know is you can set a break point in code with sys.breakpoint(). Sometimes it is just nice to do that. Don't forget to remove them when you deploy.
because mod_php is super frickin' easy to use.
I think it's more GIMP's name. edit: [also this](http://git.gnome.org/browse/gimp/plain/data/images/gimp-splash.png)
Youtube mainly uses [python](http://video.google.com/videoplay?docid=-6304964351441328559). But anyway, those are the reasons PHP took off. Once it took off, it's what people asked for…sort of self perpetuating after that. It was easy to install and manage for shared hosts, newbie users could get up and running quick, the inlining is very intuitive, etc. Like I said, the TLDR; applies for large business as well….it's just generally, all around, easier to get up and running with PHP and it's much easier to integrate into your site. Got a bunch of static files and want to add a dynamic field? Just change the extension to .php and &lt;?php some code ?&gt; and you're done. 
i didnt see a good place on the blog food for thought either way
Oh. Sorry. I suggest you keep this in mind next time you have to choose an OS.
They frequently regret it now but can't change at this point.
Because all companies start small, and PHP seemed like a good option at the time. If Facebook was to be completely rewritten now, I don't think it would be in PHP.
take your linux circlejerking to /r/linux =) 
Actually, Notepad++ was one of the least stable WINE programs that I tried several years ago. Scite and Geany come from the same codebase (Scintilla) as Notepad++, though, for anybody interested.
ALSO.. important.. you can upload a new .php file and walla it works (phew!).. python uses WSGI so it needs to be "restarted". .so a patch is not as easy "LIVE"!!
I am just getting started with vim. Thanks for the list. Also, I'm commenting so that I can find this tomorrow.
&lt;html&gt;&lt;body&gt; PHP is a web templting &lt;? echo "Engine" ?&gt; intermixed with &lt;b&gt;html&gt;&lt;/b&gt; &lt;h1&gt;The pdp parser reads teh page/php and replaces and does stuff&lt;/body&gt; Python is a programming languiage with a templating engine as one of its things
i could not recommend sublime text 2 too highly.
Because &lt;?php echo "It just fucking works for noobs"; ?&gt;!!!
This demonstrates the difference between the programming language and the web server. &gt; python uses WSGI so it needs to be "restarted" This is not necessarily always true. Not all servers are WSGI (like Tornado), and you can probably set it up such that it's easier to upload a file and have it be live by just sitting there, but it's a hell of a lot easier in the Apache/PHP model; I'll give you that. Edit: Some people are saying that their favorite frameworks support this behavior out-of-the-box, so I retract my statement about it typically being more difficult. I was assuming that in most cases, you would have to write the behavior yourself.
It's more like buying a vehicle based on the availability of the fuel it requires. The hosting possibilities is far from being a superficial concern. As for whether or not it's rocket science, that's sort of moot when you have at least 10x more hosting choices for PHP sites. 
This is why trying to do an atomic deployment of a large PHP application is a nightmare.
You could argue that using a fast to market language like PHP was what got Facebook to where they are having problems scaling the language..as my boss always says "It's a nice problem to have".
The day python is able to do that is the day I switch to python. I love that I can drop a file on a server (or edit an existing one), in any web accessible directory and just hit reload in the browser and the new file is loaded...
Uhh, do like every sane person out there, use a deployment script, and just create a symlink to the new code path...
&gt; If you do a search, you'll find most guides are over a year old, and tend to lead to issues because they're dated. I find this hard to believe, as I've had the same config file for probably 6 years now and have heard of many others doing the same. A newer guide may have newer information, but it doesn't make an older one unusable.
I replaced the eric troll with the most popular troll on reddit. http://db.tt/L1lnGy4
vimtutor is built into most linux distros (including OS X) that are bundled with vim, and it's sole intent is to allow you to dive into using vim at a very basic level. That's it. When it comes to turning vim into a (functional) Python IDE, you need to do some serious overhauling on the vim configuration file (.vimrc, or _vimrc on windows), and you need to add a good deal of vim plugins made for ease-of-use with python scripts.
aah..thanks for the info. Maybe I'll put that one away for a rainy day :) 
I know what you are talking about. I'm not bothered by it because I use VIM to refactor small scripts.
&gt;I haven't tried Eric IDE cause there are no fucking prebuilt packages for any OS PROTIP: Linux is an OS, too.
facebook hired developers specially to build an in-house php compiler to make it FAST. So its php, but its not really php.
facebook hired developers specially to build an in-house php compiler to make it FAST. So its php, but its not really php.
&gt;you copied and pasted some code you found on a PHP blog without understanding how or why it works, and why you've just introduced a huge security hole. Isn't that possible in basically every single programming language ever?
Not only that, but there are very cheap VPS options that let you do whatever you want. Linode, for example, offers 512MB RAM, 20GB storage, and 200GB bandwidth for $20/mo.
Reminds me of Perl. This kind of code must be avoided :)
I'm sure it would be worth it to someone, but creating a large enough open source project that they feel it would be worthwhile doesn't necessarily apply to everyone. Some just want to tinker and some people may not want to let them in on the project.
Which is what we do. However that is very inefficient when you're talking about an application that is hundreds of megabytes with tens of thousands of files. A deploy may only contain a few changed files... but you need to checkout an entirely new copy of the application for each deploy.
Really, there is nothing wrong with the name. That picture...is disturbing though.
Good points, but I didn't say 'rare'; only that there are more PHP hosting choices. 
 You're talking about HipHop, which translates PHP to efficient C++ code. But it takes standard PHP code as the input.
I was more backing up the "wiki lists over 200 of them" part. It's much easier to set up your own box than to deal with shared hosting.
I figured out a way to fix this issue: &gt; # cd /usr/share/eric/pixmaps &gt; # rm * It actually looks quite nice now.
There is a huge difference between the PHP that they are writing compared to the rest of the world. 
**NO! ONLY IN PHP!** ....lol
It's hating you. 
Note, [web2py](http://www.web2py.com) does not require a server restart when code is changed. Just upload a new file, and it works immediately.
I'm a beginner coder who was introduced to Python by a senior developer. I code here and there but not as a full time thing. I'll always prefer Python but I have the following observations. * Breaking backward compatibility with 2.x was a terrible mistake. I don't care if there are great reasons to make those changes, what it did was make many third party libraries incompatible moving forward. Many of these are supported by a small handful of people who may or may not have the time or interest to make the updates. In particular, turning print into a function from a novice's perspective is [mind numbingly bad](http://docs.python.org/release/3.0.1/whatsnew/3.0.html#print-is-a-function). I know there are [good reasons](http://www.b-list.org/weblog/2008/dec/05/python-3000/) for the Python 3.0 changes, but I think the cons weigh heavier than the pros. It breaks user confidence as to whether they should invest their time into it. IMHO Python 3.0 should be morphed into a new language- I'll christien it "Viper," and Python 2.x should be maintained, supported, and in due time be given a new version- (3.0 the 2nd, or just 4.0 for simplicity). It should not break backward compatibility. * Python did well with Django as it's a great framework and lets you throw together a site quickly. However it doesn't work for everyone's needs and so the Pyramid initiative is great. In theory I like it a lot better. I've been picking through the documentation and for a user like me it requires reading it multiple times. Really, as a tech writer I'm tempted to help out with a "Pyramid Book" to bolster the existing doc but such a project goes beyond my skill level and availability. I plan on tinkering with Pyramid as it's a great learning experience but Django is much faster to come up to speed on. I spent a lot of time trying to figure out if Pyramid auto cleans/escapes user input from forms, but I didn't immediately find an answer. In Django you can call their clean function and it's done. (Which is why I don't want to work with Django- you have no idea what goes on behind the scenes and don't learn anything...) * My guess is the biggest reason Python hasn't broadly taken off is because WordPress is in PHP. So, perhaps it's time for Python WordPress/Joomla/Drupal clones, or better yet, CMS's that improve upon them. I know they're out there but none have risen to the level of wide scale acceptance. Once you start coding in Python it's the greatest thing that ever happened, coding wise. But if you don't ever have a reason to then you won't do it. WordPress was successful in part because of its 5 minute *I'll hold your hand* install. I think all these things boil down to the path for new users has too many roadblocks in it to allure and retain newbies. Should you use Python 2.x or 3.x? Should you use Django, a mini framework, or Pylons which recently morphed (of sorts) to Pyramid? Or, All I want is a blog- is there a viable alternative to WordPress? Although coding in Python is easier than many languages, working with it has been more complex.
`__getattr__` is obviously a useful trick in general, but I think for his specific problem it might be better (or at least, more explicit) to use decorators descriptors on the class for each method. Something roughly like: class Twython(object): getPublicTimeline = GenericEndpoint(url="...") # or # @endpoint_with_url("...") def getPublicTimeline(self): pass I would think of `__getattr__` to be more useful when you're dynamically pulling some "attributes" that you don't know the names of. Or if you wanted to parse the `method_name` argument and dynamically generate some response based on that. You know, crazy magical shit. Since he already has a list of all the methods at compile time, my thought it "why not be more explicit about it?" At the very least, method_dictionary should be a class variable, not a global variable, but I know it's just an example.
What's your input on the python 2-3 transition. From what I can gather (decent experience in python), most scripts have to be updated throughout because of minute changes in the syntax here and there. Besides that it's essentially the same. It's just not very pythonic, it should've been backwards compatible, even leaving out performance updates for the sake of compatibility would've been much much better IMO. Any great divide like python 3 causes a stagnation, and from what I can see, it has caused a huge slowdown in the jump to latest version. Everyone is simply getting left behind even though python 2 is still great.
I don't think it's very fair to judge a language based on the blog posts of some members of its community. I'm not a fan of PHP, but that's because it's a clusterfuck of conventions and handles 64 bit integers like we're living in 1993, not because there's a ton of inexperienced developers working with it (not mentioning the developers who work *on* it, though!). Most of the PHP *books* that I've read have always stressed security, and a lot of stackoverflow responses to PHP MySQL questions always tell the OP to switch to PDO and use prepared statements.
java a go to language? did you mean run from language?
may I ask you why? Not that I have a case against what you just said, I would really like to know why it's a "nasty protocol"?
http://www.seifried.org/security/network/20010926-ftp-protocol.html
So? There's unfathomable amounts of C/C++ written by amateurs too. Is C now the worst language in the world? The point is that PHP sure as hell meets the needs of some of the biggest sites on the Internet, like Facebook and Wikipedia, etc. The wanking about how many dummy poo poo heads write bad PHP means fuck all.
This looks great! I'll see if I can get it installed. Thanks
hint: rsync (double hint: --link-dest)
I won't disagree with the sentiment. ;) 
webfaction makes the server part easier. after the wsgi is running I just do $ hg pull -u $ ./apache/bin/restart it's more hands on than php, but it's not unbearable. for pain, try a compile/test/deploy/restart on j2ee/weblogic. That there is some pain. 
+1 for the dumbfuckery lulz. as well as the thoughts. 
Bastard crackers love this feature too...
I think 'it seemed like a good idea at the time' sums up a lot of why large software projects are in PHP. When many started, there weren't really frameworks to let you use python like django/pylons/web2py (at least afaik), but php has had mod_php forever. 
for a start, it pre-dates the standard encryption systems. Your password is sent **in the clear** without encryption or hashing. Secondly, it predates people knowing how to use TCP/IP ;) You connect to one port, login, request a file, and then *the server initiates a new connection to send it to you* instead of using the already open connection. Apart from anything else, this plays merry hell with firewalls / NAT systems, since, from a TCP/IP point of view, they've no reason to think this incoming connection is related to your existing ftp connection, and so are liable to drop it. There's workarounds, but the tl;dr is that it's a nasty connection. And let's not get into the whole binary/textmode thing... *shudder*
Wow, thanks for the in depth response. In regards to the AppEngine, I never suggested that it was the best way to go. I actually would dislike such a hosting style, that is why I asked him to give his reasons. Also, I'm curious about your comment regarding MongoDB. I have no experience with anything other than MySQL, and a tiny bit of SQL Alchemy. What do things like MongoDB and other NoSql db's offer? Also, this may be a stupid question, but does it make sense/possible to make use of Twisted and Django at once?
When PHP3 was release ('98 or '99) python was still in it's 1.x days. It was far less mature and definitely not as fast. Python caught up in terms of speed and maturity, but by that time (circa 2003) the PHP user base had exploded. You said "From what I can gather ... no one really actually likes PHP". That's not accurate at all. Most opinion makers don't like PHP. However there are droves of programmers out there that love PHP. The same is true about Java. Those programmers just aren't arrogant "I know what's best for everyone" types that like to see their own posts on reddit and HN :)
well I'm primarily a back-end web developer, and I primarily use Python to pay my rent. I've never been asked to do Python web development that *wasn't* in Django, and Django doesn't run in Python 3 yet. It doesn't make very much sense for me to be looking into Python 3 at the moment so I haven't taken a look at it.
A friend of mine makes dubstep, he says he gets a nickel every time someone plays his song on spotify. Which isn't that bad...
inertia! People struggle against changes
PHP is cheap. Cheap to run, cheap to hire coders.
We use capistrano (with the remote-cache strategy). This avoids doing a full checkout to each sever for every deploy but the entire application still needs to be copied into a release directory for each deploy. 
&gt;What do things like MongoDB and other NoSql db's offer? I personally don't use them, so my accounts are all second hand. My friends that do use non-relational databases are almost all doing so for the same reason: no migrations. That's it. People can talk until they're blue in the face about scalability and huge numbers of users, but the reality of the situation is that the majority of developers aren't working on sites that big and don't have that kind of problem. The majority of people I talk to that use MongoDB are developers that never understood how SQL worked to begin with. I can't speak about personal experience, how performant it is, or which non-relational datastore you may want to be using, because, quite frankly, I find that layer of the application stack a bit boring and I haven't spent any time researching it. On the rare occasion that MySQL doesn't perform well enough for me I fix it with... more MySQL. Cache tables and the like. Is that a good long-term strategy for a site with hundreds of millions of users? No. But am I working on something like that? No. I've never move away from MySQL because, quite frankly, I have no problem with MySQL, and I'm not quite "there yet". I have never tried it, or tried Twisted at all, but they're designed for different purposes. It doesn't sound like a terrible idea at all. Quora, for example, was built with Pylons and Tornado. To be honest, I think you should find out what's popular in your region. I'm in NYC and the vast majority of people that I talk to building comet services are using node.js. Even though I find javascript programming very painful, I would personally try node.js instead of Twisted, mainly because it appears to be a more marketable job skill in my region. Honestly, I think this article concerning the difference between Twisted and Tornado hits the nail on the head: http://teddziuba.com/2009/09/twisted-vs-tornado-youre-both.html . The point being: don't obsess over technology; remember that your primary goal should be to build things that make people happy, not to build things that make people impressed with your ability to program. Yes, I'm a web programmer professionally, but when I program for fun I'm more curious to play with things like ChucK or Processing. Web programming is... kinda lame, to be honest. edit: the link seems to be broken now, but the article was talking about Friendfeed's performance graphs that show Tornado is more performant than Twisted, but then the author put in a graph of his own showing Twitter versus Friendfeed (can't remember on what metric, but it was either number of message or active users or something like that). He was saying that they focussed too much on the technology, while Twitter didn't bother and it's doing great now because they remembered that in order for their project to stay alive their top priority was to make sure it was a successful product above all else.
&gt; Rubyists, by in large, are more concerned with results than methodology and are content with using things they don't understand. This sounds like you're lumping all rubyists together which I find offensive. I don't use things I don't understand but I did start with Python, maybe that's a difference. The people i've worked with also don't run around willy nilly using the hottest new thing just because it's the hottest new thing. Also, the large majority of Rubyists I've met (and Pytonistas as well) have been very concerned about using the right tools for the job and the methodology in accomplishing the task. With Ruby in particular being so anal about testing I don't think it's fair to say we don't care about our methods. I'm not dinging Python people at all, I've had good experiences with developers and I like the language as well. I just feel like maybe this is some overgeneralization. I know there's a negative stigma towards Rubyists and perhaps our idiots are louder than yours. Next time you meet a Rubyist ask them if they know what MINSWAN is and ask them why _why left. If they can't answer that then don't call them a Rubyist. Edit: I'm not saying that you're a Rubyist if you know MINSWAN and talk a bit about _why but if you care about the language you'll likely know these things.
I would argue the opposite. Hard != complex. Simple != easy. Haskell, at it's core is a very simple language. Were as PHP is a mess of hacks glued together with bubblegum and thumb tacks.
We did use rsync for some time, ultimately it wasn't atomic enough (a request in the middle of a deploy would cause errors, file not found etc...). As I understand link-dest, we would require storing every deploy since the beginning (even if newer stuff was only deltas).
You don't understand link-dest. You don't need to store any older deploys, but for the ones you do store, the disk space increases will only be the deltas. You can delete the old ones at will, since link-dest uses hard links.
Cheers, although this doesn't address the atomic issue, this looks like it will be handy in conjunction with capistrano. It uses rsync already to copy the files from repo to release directory, it seems that adding --link-dest=&lt;previous checkout&gt; should speed that up considerably!
it's really meant to say more about the overarching themes of the communities than to be an insult. &gt;the large majority or Rubyists I've met (and Pytonistas as well) have been very concerned about using the right tools for the job and the methodology in accomplishing the task. well, sometimes not giving a fuck **is** the right tool for the job. Great, you understand every nuance of your carefully hand-rolled Facebook integration, but now you're bored of the project and you never ship it. Sometimes I find my biggest fault is caring *too much* for how things work instead of just getting shit done. the Rails and Django users that I've met have different perspectives on how they like to create things. there's really no good or bad, it's just a different way of working.
You said essentially what I was looking for, thanks. It looks like python has stagnated, one huge pro for ruby is the rvm and gems are really well made systems for the future. Python simply didn't get it right for 3 but still by far my favorite language.
The position looks awesome, alas I'm in the US so I do not believe working that remotely is what you are after. Good luck with the search!
Uh, you can do that with Paste (development HTTP server that ships as part of Pyramid). Run it as *"paster serve development.ini --reload"* and auto it restarts the daemon process when a changed file is detected. I'm sure you're not looking for this capability in a production environment though, right? Because those files are never edited directly; they're pulled from the VCS repo during the deployment script.
Exactly this, without the dig at coders online. PHP replaced Perl back ends and was solving the right problem at the right time for the right price. "There are only two kinds of languages: the ones people complain about and the ones nobody uses." - Bjarne Stroustrup 
I don't see why/how this is cool at all.
PHP is the standard because it got "there" first and it's good enough, even if Python and Ruby are better.
If dead simple were the primary reason for popularity than no one would touch a CMS like drupal with a ten foot pole.
mod_wsgi can already do that. No one actually writes applications like that though. 
You don't have to use wsgi... it doesn't have to be hard. You can run microframeworks as standalone.
you don't have to restart apache to reload a wsgi application read this: http://code.google.com/p/modwsgi/wiki/ReloadingSourceCode
I think they should merge with another project and totally hose my code. Oh wait... I kid, I kid. Kinda. I really, really appreciate the work they do, but I'm feeling the pain from the merge with pylons.
I agree it's very creepy.
Because the performance takes a big hit. PHP handles this very well.
&gt;A deploy may only contain a few changed files... but you need to checkout an entirely new copy of the application for each deploy. How often are you redeploying? Also.. hundreds of MBs of *code*? wtf are you deploying?
There is one big even huge problem with their plan. Simply put they want to maintain one codebase for both 2.7 &amp; 3.2. Not a good idea in my mind. The movement to 3.2 is speeding up as such it won't be long before 2.7 code is maintenance only. Beyond that it is just cleaner to fork PyPy and will result in far fewer problems down the road. As to donating I would have to see the finalized plans. I understand the need but I want to know that the future is 3.2 with PyPy, 2.7 development should be winding down. 
I wasn't going to say anything, but you did it twice so now I can't stop myself. &gt;by in large This should be "by __and__ large."
Turtles all the way down.
LOVE WingIDE. The debugger is awesome.
It's for running an e-commerce business and we pretty frequently deploy throughout the day. I just checked and, not including the .git directory the application is ~150mb. That includes all code generated for the data model (Propel), custom helpers, scripts, tasks, controllers &amp; templates, a copy of Zend Framework and the static files (images/css/js) for serving the site(s).
Uhm... why are you redeploying a library like zend? Why not just have it external to the website? Same for media files such as images etc... There's no reason your deployment process has to be one giant transaction, you can do things in segments and only redeploy the part that was changed... 
Can't you just touch blahblah.wsgi It has been a few months since I played with Python. I'm stuck in PHP world right now and it just feels so damn messy after Python. 
Eh, ruby succeeded *despite* the quality of the implementation, not because of it.
Facebook has actually done a large amount of work "augmenting" (improving wouldn't apply from all perspectives) PHP for their tasks, including a compiler
How so?
Because we've made quite a few changes/fixes to Zend and use a lot of the library everywhere. Why do we deploy everything in a lump? Because it's easier, of course. It's the PHP way! Since the application has grown organically from a legacy codebase it would take a fair amount of effort and cost to refactor. It's on the cards, just hard to justify spending a lot of time on something that would make everything more difficult and error-prone. But thanks for your condescending tone through your comments.
woah, I never really thought about the etymology of that saying. I've been saying it wrong for years.