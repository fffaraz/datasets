I too use ST2.
Please clarify what you mean when you say "robust" and "mature". Robust is highly subjective, and doesn't make a big difference if robust means there are lots of features that OP isn't likely to use. As for maturity, The Django project was actually started before SQLAlchemy IIRC. SQLObject was around then, but the Django founders didn't think it fit their needs well enough and so rolled an ORM that fit their framework.
Please qualify "robust". It's a highly subjective term that doesn't specifically represent any specific advantages.
If your main interest is with SciPy, have you tried [Spyder](http://code.google.com/p/spyderlib/)? If you're on windows you can try [Python(x,y)](http://code.google.com/p/pythonxy/) which comes with a full python environment as well as Spyder. Spyder is nice with matplotlib and the variable inspector; especially if you're coming form a Matlab background. 
I apologize if I have offended you. 
Seconded. [python.vim](http://www.vim.org/scripts/script.php?script_id=790)
various cases: * supports two types of table declaration: classic sqlalchemy, declarative api * clear seperation of db api and database dialect * better comparison, filtering, and aggregation api * more better sql generation * auto table detection from within code. some I can think of.
I just donated $50 toward python3 support. It would be fantastic if everyone else considered the same.
Looks interesting. I'll give it a download. Thanks!
I've used Notepad++ before. Then I switched over to Eclipse with PyDev. I may switch over to something a bit lighter though, like Sublime Text 2.
I'm worried by how often I hear talk of Python 4. I'm handling 3 just fine, but I hope we as a community aren't building in obsolescence for the sake of a release schedule.
 ro·bust/rōˈbəst/ Adjective: (of a person, animal, or plant) Strong and healthy; vigorous. (of an object) Sturdy in construction. Not one of those points makes it clear that SQLAlchemy is more "Sturdy in construction" than the Django project. And most of your points are still highly subjective. Better API? That depends on the user and the use case. And the features you mention like auto table detection, multiple types of table declaration are nifty but those thing may be meaningless for the OP's project. (not to mention they violate two parts of the zen of python: explicit is better than implicit and there should be one and preferably only one obvious way to do it). I love SQLAlchemy - but if I'm building a Django application and using a SQL data store I'm going with what's built in. You give up a ton of Django's features when you use a separate ORM. If I just needed to connect to a SQL database though? I use SQLAlchemy. Here's what I tell people when I'm defending SQLAlchemy: SQLAlchemy's best feature is that it gets out of the way when you just want to interact with the database. I would't go out on the internet and make unfounded remarks that somehow it's code is better than some other project that has completely different goals.
Emacs
yes. the python core developer effort is very conservative. there are many *many* optimizations available for cpython but they prefer to err on the side of simplicity. not sure if good or bad.
it's kinda ridiculous. pypy gives speed ups of 3-4x, surely it's worth more than 1 developer's salary for 2-3 months... the savings to their fleet of python programs, and the 10+ millions they're scraping out of this fantastic language the contribution is very disappointing. still nice, but disappointing. lots of money in the right places goes a long way.
that guy is awesome.
Yeah, python-mode in Emacs is really decent. Nice navigation, easy execution and debugging, and it even has nice touches like highlighting the current line when you're in the debugger.
My evolution: I feel very uncomfortable with unittest after I got used to PEP8; I found doctest is interesting, and started to use it in small projects, sadly I realized it will pollute source code; so I searched around and switched to nose since it obeys PEP8. However, soon I met py.test, which handles assert a == b statement very well without using some function like assert_equal() 
With [pyflakes.vim][1]. [1]: http://www.vim.org/scripts/script.php?script_id=2441
Vim + pythoncomplete + supertab + syntastic Additionally [set a few variables](http://www.reddit.com/r/programming/comments/9wlb7/proggitors_do_you_like_the_idea_of_indented/c0esam1) in your vimrc.
i use vim for python, and all the rest...
i use vim for python, and all the rest...
I use TextMate all the time for Python: I don't actually use any add-ons apart from the stock Python mode, and can't say I feel I'm missing anything. I've tried all sort before (vim - still my default editor in the terminal, emacs, komodo, wing, ...), but the simplicity of TextMate, plus its suitability to other languages I tend to work on at the same time (HTML, CSS, JavaScript) means I always come back to it.
The unittest module is what happens when you let Java programmers near Python.
There is also [python mode](https://github.com/klen/python-mode)
another sublime text 2 user here
Robust is a codeword for complicated.
Why? I also like to have 2 space indents, 4 spaces are too much.
Honestly, half of me still hopes that Python 3 never happens. From what I've seen of people's (Guido's) ideas, P4 is supposed to include such groundbreaking and user-intuitive syntax as starting arrays at [1] instead of [0]. Smart. Intuitive. Easily adapted. Anyway, don't get your hopes up about Pn being better or smarter or bolder or more reasonable than Pn-1 because that shit isn't going to happen. It's just going to go from smart language with no real unicode support to moronic language with unicode. And then it'll become our generation's dead language. Edit: Srs, I think COBOL supports unicode natively. 
nobody cares about pep8 fuck you
True. And I think python-mode will even try to figure it out for you, overriding the default indentation width with one that it detects in the file. But I'm pretty sure he'd rather have 4 spaces everywhere anyway.
Those speed ups are for CPU-bound Python code. A lot of their code is probably IO bound rather than CPU bound, so language changes would have little effect. And any serious computation they do probably drops into compiled code already, so the speed up would be much less dramatic. That's not to say there's no use in a faster Python - Google sponsored unladen swallow, so clearly they have some interest. But I doubt the advantage is as huge as you suggest.
PyCharm, from JetBrains, dammit. Why do people insist on using inferior tools? PyCharm is obviously the best thing out there for working with Python. 
Agreed, as a full IDE it is the best i have tried. There are those who will swear by light weight ones, but really its about productivity and making programming easier.
You're probably right. But $35k is still a good sum to get started with, and if they like the project, they may contribute again. There are also most likely other companies which can benefit from PyPy, and Google's contribution may encourage them to chip in as well.
wait until you start using vi mode on the shell. you'll confuse the hell out of people as you whisk around the line doing magicks.
why vi over vim?
PEP-8 is a style guide. That is it. Sure it would look prettier if everything in the standard lib conformed to PEP-8. But "fixing" it would be a whole lot of work for, at the most, some cosmetic benefit. And honestly I don't find it to be that big of a deal. Any non-trivial project is going to include some 3rd party libraries and most likely at least some that violate PEP-8 anyway. For example, many C++ bindings choose the coding style of the underlying library over PEP-8 because it's more useful to keep the Python API as close as possible to the C++ API than it is to try to conform to PEP-8. The best you can do is try to use a consistent style in **your** code and just let everything else be. And it's nowhere near as bad as something like C++ where if you're using N different libraries I can virtually guarantee you'll have N + 1 different styles going on in your code. Are you fairly new to programming (like less than 5 years)? I feel like this is something that noobies get hung up on, whereas more experienced programmers have just learned to deal with it and accept it as a fact of life that you're going to have a bunch of different styles going on in your project if you include 3rd party code. Unless you're using Java, those guys really did a great job of enforcing a "one true style" throughout the entire community.
SciTE
C makes up a good portion of Python, but most of the normal Python distribution is written in Python, at least according to sloccount against the current head: Totals grouped by language (dominant language first): python: 378283 (51.65%) ansic: 330138 (45.07%) sh: 11493 (1.57%) asm: 10846 (1.48%) objc: 775 (0.11%) cpp: 432 (0.06%) exp: 416 (0.06%) xml: 73 (0.01%) But it's probably true that Guido spends a lot of time in C.
`vim` user here, but I can hazard a guess that stiggz chooses `vi` -- for proliferation reasons. `vi` is *everywhere*, where as `vim` is only *almost everywhere*, and for many OS's requires installation. I've never seen an OS that didn't have `vi` by default. Well, there is that one vendor, but that's another flame war.
yeah, i know that vi is everywhere. particularly with linux though, vim is a few keystrokes away and has some pretty fantastic benefits (it is improved..). even if it does require a simple install for mac, is there nothing compelling enough to install it? unless working with a lot of barebones systems instead of on his own box.
vim. i do bioinformatics. if i leave something running, i can ssh in from my phone, check its status and if i see that i had a typo or bug, i can go in and edit the file to fix it because doing everything requires virtually just the keyboard and no silly button combinations. edit: by "just the keyboard," i meant single strokes.
Same here. Four spaces seems too... spacey.
there was recent discussion about "accelerate major versioning" similar to firefox's change of tact. it got shot down for the terrible backlash it would create in the community after the dive in popularity python has taken due to python3.
Geany http://www.geany.org/
Today I realized why the editor is called IDLE. Slowpoke...
I was thinking of that, but no, I think there needs to be a setting for how many characters you have to type before the autocomplete kicks in, you know, like how nearly ALL other editors have? Other than that though, PyScripter is pretty much the best editor I found on Windows. I even went as far to set it up in Wine on my Arch install just to have access to it.
**Edit**: See exchange below. This is likely related to environment. ————— Except the moment I start using ÆØÅ, its debugger craps itself. That's kind of a problem since they are necessary in my language (and no, I'm not going to use 80s style meta-ligatures like AE). Added bonus: They completely disregard the ticket I've opened on it around August/September. They've even done a full release since and still have not fixed it. 
Really now? I sometimes use Ä and Ö in .py files, but the only "problem" I've noticed is that then I need to declare the file's encoding in the beginning. The debugger sure works fine even with those characters in there. 
Probably because I invoked MS... even though I invoked it in the name of not starting a flame war :-)
I'm quite fond of Kate.
Django's ORM is bit simpler/easier to learn than SQLAlchemy because there are less parts to it. You might also want to look at [peewee](http://charlesleifer.com/docs/peewee/) if you're looking for something simple. SQLAlchemy is more of a toolkit rather than a library you just import and use, and I think that makes it a lot more powerful. You'll need to spend a little more time learning your way around SQLAlchemy. But the beauty of SQLAlchemy is that every layer of it is exposed. So when you need to, you can make it work exactly as you want it to. [This blog post](http://lucumr.pocoo.org/2011/7/19/sqlachemy-and-you/) is a good read and gets more technical on the matter.
The best one I have come across is jedit. 
&gt; (+ emacs 1) FTFY
I [wrote a blog post about this](http://jmoiron.net/blog/about-sqlalchemy-and-djangos-orm/) quite a long time ago, and as mentioned in other comments [armin wrote one of superior detail](http://lucumr.pocoo.org/2011/7/19/sqlachemy-and-you/) a few years later. As I try to get across (perhaps unsuccessfully) in my blog, Django's ORM *feels* like it was designed for object persistence, whereas SQLAlchemy feels like it is designed to interact with databases. If you have a blank slate and some objects you need saving, DjangoORM will make a lot of fairly safe decisions for you, and get you off the ground quickly (especially if you are not experienced). These decisions, some of which stray into "requirements" territory, end up being an albatross if you have specific needs that make them a bad idea or have an existing database you want to model and interact with. In the end, it's up to you; they're both mature and respected libraries.
Kate/KDevelop. Simple and doesn't get in my way. And has a terminal at the bottom.
I like gedit or kate and I just ALT+TAB between that and my terminal window where I execute. I also really love the python shell. It's a super quick and dirty way of getting something simple working. Then you can copy your history to a text editor and crop out the parts that don't contribute to your solution. I'm going to have to try out a lot of these other suggestions :)
Can you substantiate that Python has taken a dive in popularity with a citation?
Am I missing somthing: [http://stackoverflow.com/questions/3355998/reason-for-low-pylint-ratings-of-python-standard-library-code](http://stackoverflow.com/questions/3355998/reason-for-low-pylint-ratings-of-python-standard-library-code)? I love the "magic" features of Python. I recently started playing with actionscript and it's a pain to **override** functions and declare them properly so that they can be overridden.
Real programmers use a magnetized needle and a steady hand.
It's a great editor all around.
Why are they still doing that class with Python 2?
I am apparently the only person on Reddit who uses notepad++. Maybe I should check out some of the others, but I have to say I prefer it over emacs.
right now, sublime with sublimelinter and some other stuff added on. 
SQLAlchemy's first release was in February, 2006, roughly the same time Django was first made available. The two products are pretty much the same age. I started writing SQLAlchemy well before Django ever put up their "Coming Soon!" page. This website we're posting on has also used SQLAlchemy core (not ORM) for their database access for at least three or four years. There's a general consensus that between the two products, SQLAlchemy is the more "robust" product: * Django couldn't reasonably do "aggregations" until version 1.1 in 2009. These are very common SQL functions like `max()`, `min()`, `count()` etc. SQLAlchemy has always supported flexible usage of aggregates just like any other column expression, recognizing these are an extremely basic and essential feature of relational databases. * Django couldn't talk to more than one database until version 1.2, just two years ago in 2010. I've written a [blog post](http://techspot.zzzeek.org/2012/01/11/django-style-database-routers-in-sqlalchemy/) contrasting SQLAlchemy's approach to multi-database configuration. SQLAlchemy has always been neutral of multiple databases since version 0.1 in 2006. * Django doesn't have a built-in notion of an identity map, or a unit of work. I recently read the source code to Johnny-Cache and noted that it appears to build some semblance of an identity map so that query caching could reasonably be integrated with the Django ORM in a transactional context. These are hard features to write and took the SQLAlchemy project many years to get right, and it's tested by hundreds of tests (SQLAlchemy has over 3000 unit tests now). There's a ton of maturity in our unit of work that nobody else has, and our identity map is at the core of the ORM's design. A lot of people seem to think SQLAlchemy's approach comes at the price of ease of learning/usage, which is something I've spent many years to correct, including dozens of reworkings of the documentation as well as major API improvements. Early releases had some excess verbosity which is for several years now a thing of the past. I fully believe that users who seek to interact with the relational database fully will find SQLAlchemy the easier system to learn and use, since it maps more directly to relational database concepts. I also have a Reddit post from a few weeks ago detailing an example of this: http://www.reddit.com/r/Python/comments/olech/is_django_considered_pythonic_now/c3ijtk9 
Vim / sublime 2
I expect it takes a while for a company as large as Google to migrate.
Try pycharm
I like ST2 with Sublime Linter (and Terminal but that's more agnostic).
[Here is a comparison of the programming features](http://en.wikipedia.org/wiki/Comparison_of_text_editors#Programming_features) of dozens of text editors. When I was choosing an editor, I tested several free ones (and a few trial version of paid ones) and chose the text editor that I preferred. I work with OS X and Linux, but do the actual coding of my major projects on OS X. I ended up choosing [TextWrangler](http://www.barebones.com/products/textwrangler/). I really enjoy working with it for a variety of uses.
I know the idea, but it's just that why couldn't either IDE handle everything in terms of directories? You open a directory and start editing files in it. That's your "project" right there. If the directory (or any subdir) contains a file that ends in .py, it's _probably_ a Python source file. A directory called "src" is likely to contain source code. *.java are _prooobably_ Java source files. Same thing with HTML, CSS, whatever. If there's a file called "pom.xml", it means the project is bloated and "enterprisey", and so on. You get the idea. The IDE could just keep track of settings "attached" to any full directory path that was opened at some point, and re-load the settings when the same path is opened again. Or maybe there's something I don't know of, that forces them to make everything a "project". 
&gt; multiple types of table declaration are nifty but those thing may be meaningless for the OP's project. (not to mention they violate two parts of the zen of python: explicit is better than implicit and there should be one and preferably only one obvious way to do it). It appears there's a misunderstanding here. SQLAlchemy has only one way of declaring a table within each API. In the Core, that is the `Table` construct. The ORM, which is an entirely separate library from the Core, offers the declarative configurational system that accepts components of this `Table` construct, and creates the `Table` for you. Classical mappings are no longer recommended for normal usage. In both cases, everything about this `Table` is entirely explicit, so I've no idea how you can even attempt to suggest SQLAlchemy has some kind of "implicit" behavior. And there is most certainly one obvious, recommended, documented way to do it in modern SQLAlchemy. A good read of our current documentation will make that clear. 
I was excited until I read "30 day free trial for windows!" at which point I closed the website and moved on.
I care :-(
Vi
In my office, 1x PyDev 1x PyCharm 8x Emacs.
Actually, you don't need either. If you aren't interested in database portability and are interested in running complex, analytical queries - then you may be better off with just DBI. There are simply fewer moving parts to have to understand. Especially if you already understand SQL. If you're interested in database portability and are running analytical queries, then SQL Alchemy's Core + DBI seems like the next step up. More stuff to learn than DBI, but simplifies the portability. Still not using an ORM. 
The way I try to think of it is, Django's ORM was designed for web applications, and SQLAlchemy was designed for databases. So if you're just making a webapp, Django's ORM has a lot of stuff built in that has, strictly speaking, nothing to do with a database, but that is extremely useful for web apps, in order to allow it to integrate with forms, the auto-admin, to do pre-validation, etc. (stuff like help_text, editable, verbose_name, validators, choices, ModelForms), that you would have to do yourself in SQLAlchemy or use a third-party library. SQLAlchemy on the other hand is objectively better at interacting with a database. It can do queries that Django can not without falling back to raw (Django's documentation even refers to using OR in a query as 'advanced' and forces you to use this Q construct--SQLAlchemy frankly laughs at this kind of thing). It supports a much richer abstraction of database types(it can via its API for example create Enum fields, it can create custom checked exceptions, and much more. In Django for example if you want a PositiveIntegerField, great, they've made that for you with the requisite constraint, if you want an integer between 1 and 22, you are out of luck getting this into your DDL through the model API), you're now into creating your own type territory. As you use it I think you will find it's better in many little ways that one appreciates--an example I came across recently--I was dismayed to find that if you create a BooleanField in Django using a SQLite database, it does not create a check constraint to ensure the value is actually 1 or 0, sqlite having no natural boolean field, yet on conversion to Python it does raise an exception if the value is not 1 or 0. I tested this on sqlalchemy and found it does the Right Thing. Again if you consider Django's ORM as being for web apps you can see why they might prefer validation logic in the application layer because the ORM is there as a component of a larger system that you are expected to be using. So I would say, if your project is a web application with modest query needs, just using Django's ORM is probably good enough, otherwise you should always choose SA, it's the kind of library that not only solves the need it addresses but recommends the language it's written in--when I think about a language other than Python for some project involving a database my first thought is always, 'but what would replace SQLAlchemy?'
While typing Eric in the comment above, the Idle editor naturally appeared in my mind. :-)
&gt; However, soon I met py.test, which handles assert a == b statement very well without using some function like assert_equal() Also you don't need to wrap your tests in silly class wrappers ;-) and go through setUp()/tearDown() contortions... 
Disappointed that this isn't more popular.
I like Sublime Text 2, but there are many other good editors too.
Having pylint on F1 in python-mode is nice (though I keep meaning to sit down and try [pyflakes + flymake](http://www.ymer.org/amir/2010/01/28/pyflakes-flymake-for-python-programming-in-emacs/) for "no click" syntax checking...) The other win of emacs is that you not only can you have have a python-subprocess buffer to dynamically throw code at... you can use [PyMacs](http://pymacs.progiciels-bpi.ca/index.html) to write emacs extensions in Python instead of elisp. (After all, you can only use elisp code in emacs, you can use python code everywhere, so you'll eventually be better at python than elisp - or you started out that way :-)
You mean the sample bias that even most glorious app ever, if it's MacOS only, just isn't going to be that popular overall? :-) Alternatively, any editor thread is mostly going to bring out emacs and vi people, with occasional singleton responses from other users - because it's kind of distinctive among the vi and emacs communities that an editor actually *is* something you should be opinionated about - for everyone else it's Just A Thing...
you know what, sqlalchemy sucks. Are you happy now?
that does make sense. if I am pretty sure I won't be changing my tables anytime soon, raw sql and fine tuning queries by hand is definitely a way to go. But most apps that are being developed right now have a changing table schema, and might require quick change of queries, so ORM removes good amount of boilerplate and repetition, and from within an app, give enough abstraction to write with constructs of that particular language the app is in.
Thanks, bookmarked. 
Thanks, updated the content with ctypes also for the completeness.
Butterflies 
Yeah, smart quotes are the little death.
Drag a folder into the PyCharm app icon - it will just open the folder. *sound of wind chimes*
I just need to wait for a while. A good bro of mine is donating a hard drive he doesn't need yet to the noble cause of me.
Several projects already do this. Of course, in general it's not that useful because it requires your user to have some browser extension installed (although the IronPython one uses Silverlight which they *may* have already installed). http://pyxpcomext.mozdev.org/ http://ironpython.net/browser/
wtf - I haven't used SWIG since 2005. ctypes is far better.
did you even try to search for a thread on this topic? Somebody posted this exact same question about three days before you posted yours - and I am willing to venture a guess the python IDE/editor landscape hasn't changed much since then.
I've tried it, but Vim is not for me. In the past I was a happy emacs user, but I've come to learn that I simply prefer more "GUI-oriented" applications (and I know this is an unpopular opinion), even if they do to some extent inhibit productivity — and overall it's more important to me that I feel good in an environment than that I put out lines of code faster.
I really like the looks of this. I'll definitely take it for a trial run!
Either ill-written or ill-informed. I can't tell which.
&gt; it's more important to me that I feel good in an environment I agree, this is easily the most important thing. I love vim, but it's not for everyone. Good luck with Coda or whatever you settle on.
Yep it's as non-pythonic as it gets. Same goes for the logging module.
Well of course it does, because everything is horrible. It'd be more accurate to say that SQLAlchemy is simply an order of a magnitude more terrible than the alternatives.
&gt; I know the idea, but it's just that why couldn't either IDE handle everything in terms of directories? &gt; You open a directory and start editing files in it. That's your "project" right there. That *is* pretty much how it works. It then just calls that directory a project, and puts all its project-stuff in a subdirectory of that.
Thanks. I'll look at py.test and nose. I don't like doctest because it's a new language on its own. That is one thing I really like about unittest, it is just python. Don't use Django, but I started using unittest when contributing small patches to python 3 (nothing complicated, dumb bugs, I just happened to hit the right corner cases). 
&gt; That is pretty much how it works. It then just calls that directory a project, and puts all its project-stuff in a subdirectory of that. Well now that you mention it, I did find a menu item called "Open Directory..", and it did behave like that. So.. problem solved, I guess. But this must be a new thing. Before, we had to go through a project wizard whenever we wanted to edit any source files. 
I actually like SQLAlchemy very, very much. I just don't appreciate hyperbole. In my career I've only heard people use "robust" when they were trying to make something sound good but didn't feel like taking the time to explain what was so good about it. I guess it's a pet peeve but at this point I refuse to accept that anything is good because it's been described as "robust". 
Pretty much every Mac coder I know uses Textmate, and for some reason everyone in the startup community thinks it's cool to use a Mac or something for development, even though Linux computers are closer to their deploy environments and about 1000 bucks cheaper. Then again, I'm also using a Mac for coding. :P
I was talking to some folks, also in the startup community actually, and mentioned exactly what you said. They countered that with all the configuration and shit that you have to deal with building your software, the last thing you want to have to deal with is your operating system.
Because all software should be free, and programmers don't have to eat because they already have plenty of bytes.
Don't take that indictment *too* strongly. The Django ORM is still my go-to.
I'm mostly pretty pleased with this, but I've got a single notable beef; the description tab of the package should take precedence over the licensing and development status. Also, my address bar doesn't change to reflect which tab I'm viewing, which makes it awkward to share a link to the description. Kind of a twofer issue, there.
Not to mention how it helps with refactoring and navigating around your codebase. Invaluable. 
[unittest2](http://pypi.python.org/pypi/unittest2)
I think given the spirit of python the IDE should be free. There are plenty of IDEs that do multiple languages including python and I can justify paying for one of those.
I hate small fonts of bootstrap. 
Please add the name of the current package to the title of a package's page. If I open up multiple packages in different tabs, there is no telling which each one is. Otherwise, looks good :) Bookmarked
Mike, thanks for your devotion and hard work building sqlalchemy over so many years. It's a great service to the Python community.
The description tab corresponds to the long_description in setup.py. It accepts Restructured text as well. 
I use [IdleX](http://idlex.sourceforge.net) for my Python development. It fixes several problems with the standard IDLE distribution.
spinning disk. Forgot to mention it was their static (I believe) build for linux. May be related to that as well.
Since you are using IDLE you can rewrite the exception handler code. Presently IDLE truncates tracebacks to exclude internal code. See the "cleanup_traceback" and "print_exception" functions in run.py. This assumes you are using the subprocess to run code. If you're not using a subprocess, then you can modify the "showtraceback" method of ModifiedInterpreter in PyShell.py. 
Thanks, I'll have this in my next deploy.
I upvoted before even looking at the page yet. I'm glad this exists.
Will you provide a PyPI compatible xmlrpc interface ? (http://wiki.python.org/moin/PyPiXmlRpc) Who is paying the hosting and how long would it be maintained ? How is it updated with the info of packages posted on PyPI ? Is there any delay for mirroring ?
I'm in the startup community myself and we all have macs. Definitely good hardware and OS, but sometimes things require extra steps even with configuration (see for example configuring MySQLdb for Python -- you need the Python from python.org, and if your MySQL architecture doesn't match up, you have to do some 'lipo' to make the package not throw an import error -- we've seen similar things for some other packages as well). It would be nice to have the development environments match up exactly.
I Agree about the address bar and which tab you're viewing. I'll get that fixed. I'm neutral on Description or Info being first, I'll take a look and see which way looks best. Thanks!
This is quite true. I have the advantage of being able to use SQLite instead of MySQL while developing. I do wish Apple would support us a bit better by having good resources for posix development like they do for objective-c dev.
Something similar to [Pythonpackages](http://pythonpackages.com/) ? 
THANK YOU! I can finally get rid of the last bit of Perl that uses SOAP:Lite just for this purpose and bring it back to our core python code. I never got around to implementing this in python, and now I don't have to :) YAAAH!
Tornado is nowhere near abandon-ware. There are [many commits by the dev team at least weekly](https://github.com/facebook/tornado/commits/master) to improve and extend the server.
I use tabs the way they were always meant to be used, because I'm actually good enough at using tabs to use them that way. I have my editor configured to render them as 2-space indent because that's what I find most aesthetically pleasing. Everyone who looks at my code is free to render tabs as 4 spaces or 8 or 3 or 5 or 1 or \pi for all I care. That's *exactly why* I'm using the tabs.
It's kind of an inconclusive essay without much "food for thought." Maybe better stated, it doesn't really provide any new ideas beyond sometimes exceptions are bad and sometimes they are good. I think a good point to bring up is that with exceptions, you often have to pass the definitions up the chain of imports, whereas with return values, the coder just knows what to return, saving useless imports. Unfortunately, everyone else reading that code wont know what the magic numbers mean. Another issue not considered in your essay is the idea of reraising exceptions. def x(url, data): y = data[0] url += y return urllib2.urlopen(url).read()[0] can return either IndexErrors or urllib2.URLErrors. The url errors are obvious, but wrapping the others makes it much clearer what is going wrong. def x(url, data): y = data[0] url += y try: return urllib2.urlopen(url).read()[0] except IndexError as e: type, value, trace = sys.exec_info() raise EmptyResponse....
1.0 is released. See google code site for list of updates.
Regardless of how configurable the PHP one is, this seems like a pretty bad idea in general. You're adding a whole new language dependency in your environment just for this one little library.
You're not the first to complain; I've changed it to a stock white theme
fun that you don't call me out for calling its complete lack of error handling malicious ;)
I looked at the github site with the source code, but it's probably also on PyPI. Go to www.pymysql.org, click on Downloads on the right site of the page, download PyMySQL-0.5.tar.gz and unpack it somewhere. In the package is a PyMySQL-0.5 directory and within that a pymysql directory. Copy the pymysql directory to a location in your PYTHONPATH, most likely just to your cgi-bin directory where your cgi script lives.
Says it's better than twisted.plugin but why is it better than an entry point declared in setup.py?
Now. Squeeeel [like a pigee boy!](http://imgur.com/a/5Aimi). EWEEeeee weeee weee weeee. You like a little pigplay don't you Gr
well definately not https://twitter.com/#!/gvanrossum since he recently stopped using twitter.
Hey I've never seen stallion before, that's pretty cool. Honestly the same data that exists on PyPI exists on Crate, I'm just mirroring PyPI but backed by S3/CloudFront/(Soon to Be EC2)/Gondor with a lot of work done to sort of reboot the experience of discovering, evaluating, and ultimately installing packages. I might end up eventually adding XMLRPC, you make a great point not just about stallion, but there are many tools designed to work with the XMLRPC interface and it would be nice to allow them to just work too. So consider me now in favor of adding the XMLRPC api, even if I detest it ;)
Cool. I wrote something similar a while back (no idea if it still works): http://flask.pocoo.org/snippets/18/.
No one looks ashamed. If someone should be ashamed of the slow transition to Python 3 that should be Guido. 
What kind of commit and journaling are you using with mongo? And how fas is your fast? Lots of people use relational databases because the DB already exists, because they want ACID, because they want joins or because its prescribed. You might like this rant too: http://williamedwardscoder.tumblr.com/post/16399069781/google-moresql-is-real
Once it gets to 50% of those 200 packages, it automatically changes to 'wall of superpowers'. Either way, I wouldn't take the name too seriously.
Hehe, I think you've heard of MongoDB awhile ago (maybe that humorous video on YouTube...). MongoDB is a completely different use case, there are some situations where it is unsuitable, dealing with important data is one of them, although it's much better than it was in the past. For the (comparatively) important data, we require that two nodes confirm writes, so if one node dies after confirming (and before disk is touched) the other will (hopefully) succeed (and yes, if both die then the "confirmed" write fails silently). You can enable things like journaling to reduce the risk of data loss, but it results in reduced performance, and even with all the data protection flips switched on I wouldn't trust it as much as I would an ACID compliant SQL database. It absolutely isn't a "one size fits all" database, and it's important to develop to it's strengths. It's generally pretty awesome for websites (social networking, forums, other misc web apps). Personally, the thing I like about it most is that it's more enjoyable to develop for than SQL-databases, dealing with JSON-esque data structures instead of rows wrapped in an ORM is so much nicer. I probably wouldn't recommend that you migrate since it doesn't seem suitable, but I've heard some great things about using MongoDB as a sort of caching layer to greatly reduce database load and increase page render times (think query-able JSON memcache).
&gt; I'm not sure I see the benefit in asynchronous database interaction. If you're using an ACID RDBMS somewhere busy, would you see the point in something that so dramatically improved performance? if you look at the moreSQL article I linked to, you'll see 10gen commenting you can infer that coalescing and reordering statements to a classic RDBMS gives you close to mongo performance; in the end, its all about how quickly can you write to disk. I wouldn't be surprised if fractal trees run rings around mongodb.
Yes, although crate.io is more ambitious with regard to package hosting (on S3); [pythonpackages.com](http://pythonpackages.com) does not host any packages. Rather, its "secret" feature aims to enable one-click releases from github.com to PyPI (at least initially). Also, the stats and "search" features seem to overlap however crate.io appears to offer "real" search whilst pythonpackages.com currently only allows you to enter exact package names (though it does normalize them for you).
&gt; If you're using an ACID RDBMS somewhere busy, would you see the point in something that so dramatically improved performance? If you're regularly interacting with a database that takes a long time to respond than I see that more as trying to reduce the consequences of anomalous behaviour. Wouldn't it be better to work on improving performance at the database level? "Database still runs like shit, but at least it doesn't hang the web server any more." &gt; in the end, its all about how quickly can you write to disk. For write performance, sure, but what about reads and queries?
A quick confirmation, this website isn't about shaming python 3 for mass killing good libraries, is it?
If you're interested in PyPy I can suggest: * Maciej Fijalkowski [@fijall](https://twitter.com/#!/fijall) * Alex Gaynor [@alex_gaynor](https://twitter.com/#!/alex_gaynor) * Carl Friedrich Bolz [@cfbolz](https://twitter.com/#!/cfbolz) * Benjamin Peterson [@gutworth](https://twitter.com/#!/gutworth) * Antonio Cuni [@antocuni](https://twitter.com/#!/antocuni) * The PyPy Project [@pypyproject](https://twitter.com/#!/pypyproject) I would also suggest: * David Beazley [@dabeaz](https://twitter.com/#!/dabeaz) * Nick Coghlan [@ncoghlan_dev](https://twitter.com/#!/ncoghlan_dev)
I'm sure this is a good thing for some people, but having used Jenkins for the past 3 years all I can think about is the features you'll *loose* using this sort of set-up. For instance, I've used Jenkins to: * build projects on multiple operating systems by using the Amazon EC2 plugin * check and report on 3rd-party API and Documentation changes, to keep my team informed when services we tie into change without notice * build projects that require mock services to be started up in the background * build projects that require test databases to be created/cleaned before running * build projects after the tests for other projects have completed (used for testing libraries used by multiple apps) And all of this with a spare machine that was knocking about in the office. So rather than paying $45p/m for a hosted solution we're just paying for the electricity and the short time any EC2 instances are running. Pennies per month, really. One of the key things in our set-up is that our jenkins config is also stored in git, so if the hardware blows set-up of a new server is negligible. **Additionally** I don't think this system allows you to configure jobs using zc.buildout (I could be wrong).
Ty, man. I got a temporary fix working, but this looks a better solution. The fix involved posting the resulting sql to another script in php that deals with the db. Quite ugly... and i hate php
I use Notepad++ mostly, vim when I'm on a terminal. Lately I've been trying out [Ninja IDE](http://ninja-ide.org/) as a free alternative to PyCharm or WingIDE.
I'd have to agree about twisted (you will be assimilated).
I don't even know what that means. There are many possible exceptions that are thrown and that you can throw, plus error handlers (callbacks including original context objects) that can be overridden if you want to add logging, etc for those exceptions. http://www.tornadoweb.org/documentation/search.html?q=error
Glad to see things are moving so quickly. What's the official plan for keeping up to date with (official) NumPy releases though? Is PyPy gonna constantly be playing catch-up with regards to new features and fixes? 
Yep, fall through is another thing that scares me about the second approach.
I would generally do `return bool(condition)` (unless `condition` is a bool already of course).
```True```/```False``` was just an example, it could be a returning a string. I like the idea of using ```bool()``` though!
&gt; i have no idea what i was thinking, but it works We've all been there... several times.
If you stress-test it it falls over, though. The error handling doesn't actually seem to work: https://github.com/facebook/tornado/issues/365 When I got bitten by that, I naturally good-citizenly dived in, expecting to fork and put in a pull request. But when I looked around the code, I was uncomfortably shocked at the direction it had taken qualitatively since I looked at the first version that came out of friendfeed. It almost feels like different people are responsible. I felt I couldn't really make my 'refactoring' and reversions stick. I am also dismayed by strange choices like add_callback() becoming a list instead of a set and that kind of dismay grows poking elsewhere around the codebase. My colleagues, who I believe provided the curl bindings, have been charting the downward spiral in performance for a long time. However, I really *choked* when I saw this (current version, but sha1 link so it sticks): https://github.com/facebook/tornado/blob/ffa8f152ab9ec479ed2721581a8f088983a9ba8b/tornado/ioloop.py#L304 If there is an exception in a handler, it is printed to log. That's it. Its not closed. There's no hooks for your own code to shut down async_http_client stuff you've fired off or anything really. I've had my servers run out of file handles from this. There was a time when I liked the idea of diving in and cleaning it up and speeding it up and hellepollising it. But not any more. I still turn to tornado every time I want a quick and dirty server. One day one of those servers will grow and it'll bite me, though. So, error handling in tornado... ignorance or malice?
True, guess it's just an irrational fear :) Also it just feels "wrong" to not end a function with a ```return```.
Not impressed so far. Lecture one: a set of slides. Not the presentation, mind you, the set of slides. Lecture two: the same set of slides in an ASCII text file. Lecture three: Literally one line with the urls for programming python the hard way, and a byte of python. Not even hyperlinks. Copy and paste the urls into your browser. If I'd paid for it, I'd be having some serious buyer's remorse right about now.
return apples if condition else oranges
I am pretty sure as it is written that the final return statement in the third example is unreachable. Edit: I use both styles depending on what I am trying to accomplish...I like the first one for cases of simple comparison where I can short-circuit the logic/method/algo.. . The second for more rigorous cases. 
I think i knew back when i wrote it, but the last modified times say over a year ago.
I like the new-ish ternary expression: return 'apples' if condition else 'oranges'
Not exactly “new”, I think it appeared in 2.5. You can still call it “new” if you like, though. :p
I'd trow that documentation into a doc string and get rid of the superfluous return statement. Furthermore, write some tests to reasonably ensure that it behaves as you intend.
Yes, I think my colleagues donated a rewritten curl client, which was adopted. You mean HTTPAsyncClient isn't to be held to the same standard as tornado? That it isn't an integrated part of tornado? Are you seriously suggesting users hook error logging output and parse it to see if they should be closing sockets? I think you're pulling my chain :)
No, not at all. I'm saying they used the `logging` module from the standard library because it provides a uniform, easily-overridden interface. I didn't say anything about piping/parsing `stderr` anywhere?
smartypants; same difference. So, is this how you do your error handling? How do you know which sockets to close when?
The third one is bad in every instance. If someone changes what the else returns, but not the unreachable return and later someone removes the else completely (as it itself is unnecessary), you now have a bug. There's no reason to do it, and there's no reason to allow for introducing a bug like that. Personally I go with the first because it's not any harder to understand and it looks cleaner to me. The second one is equally fine though, I just don't personally think it's as aesthetically pleasing.
You'd have JavaScript's stdlib. Not as well designed, but not useless either.
Personally, it depends on what I'm returning. If it's something parallel (like your example), I'd go with the second option: if a == 1: return 'apple' elif a == 2: return 'orange' else: return 'generic fruit' But if your "else" return value is None or an error code, I'd do the former: if a == 1: return 'apple' elif a == 2: return 'orange' return None #or ERROR_CODE or "error" That's how I do it; I would never do the 3rd option, though.
Which i refuse to use because I don't like the syntax; it should use the same order of condition -- trueblock -- flaseblock that ordinary if statements use, e.g. return if condition then 'apples' else 'oranges' Alternately, if (1) all statements were expressions, and (2) the value of a block of statements was the last expression evaluated, one could say: def foo(): if condition: 'apples' 'oranges'
sry its not in proper format; Is there an easy way to like highlight and shortcut the appropriate spacing for code posts?
Which do you prefer for trivial cases like my example?
If it's really trivial, and the condition is really easy to understand, and the return values are small, I use the ternary option: return 'apples' if conditional else 'oranges' Which is: &gt;&gt;&gt; dis.dis(version_3) 2 0 LOAD_GLOBAL 0 (condition) 3 POP_JUMP_IF_FALSE 10 6 LOAD_CONST 1 ('apples') 9 RETURN_VALUE &gt;&gt; 10 LOAD_CONST 2 ('oranges') 13 RETURN_VALUE I'll flip it into version 2 if the `condition` is long/complex or non obvious, or if the return values are dis-similar or the return values are long. For example, I wouldn't use the ternary if one conditional branch had it returning `False` and the other had it returning a populated list -- it requires too much examining to find out that the returns are not the same. (Barring of course that it's questionable API design to return two different types!)
So I'm mildly insane, but my rule is: if there's a binary condition, I use the else, if it's a special case I don't use the else. For example: if x is None: return None return x.foo vs. if special: return x + y else: return x -y
This is a good change. People far too often don't appreciate the difference between text and bytes. Especially, I am afraid, americans who live far from Europe and only use ASCII themselves. In more recently designed frameworks such as .NET, there is a the same distinction, and you go through either encodings or, more usual, TextReader/Writers, to read/write text into various byte streams (such as files). I've unfortunately spent too many hours arguing with people about the need to handle this correctly in open source software I am involved in.
Hmm, you've given me something wrong here. There's some assignment to the value 'x' that I'm missing. Can you make sure you're giving me the code you're using *right now*?
Interesting! Thanks!
The first one avoids unnecessary nesting. If you had more code in the else block, another if statement for example, the nesting problem would be more apparent. It's also a good pattern from defensive programming: do sanity checks up front and return early if the checks fail. You can then continue with the main function logic. This also separates the checking from the function logic, which has benefits to readability and maintainability.
I use the HTTPPasswordMgrWithDefaultRealm() when dealing with these things. password_mgr = urllib2.HTTPPasswordMgrWithDefaultRealm() url = 'http://yoururl.com/somephpfile.php' password_mgr.add_password(None, url, user, passwd) #passwd is not hashed or encoded handler = urllib2.HTTPBasicAuthHandler(password_mgr) opener = urllib2.build_opener(handler) fp = opener.open(url, data) I found it [here](http://www.voidspace.org.uk/python/articles/urllib2.shtml#id5) a while ago.
yo dude forgot to post a chunk. my b http://pastebin.com/bJgXaUaR its after I define the functions
Requests is a pure Python package, so if you can arrange to adjust your `sys.path` somewhere at the top of the script you could always just upload the files and then make sure that upload directory is on the path. Not a *bad* work around...
Just out of curiosity, are you getting a 401 Authorization Required error back when doing the authenticated request? Or, is it something else that isn't working?
You can try to check the server logs; there might be a clue on why it's a 500 instead of a 401. Also, part of your original question was how to add headers into the opener. If the php is expecting that header, that could be a reason you're getting a 500 error. You can do it like this: opener.add_headers = [('Content-type', 'application/x-www-form-urlencoded')] Then, do the fp = opener.open(url). You could also use urllib2.install_opener(opener) to make any new requests in that script use the Authenticated opener.
Edit: had a typo. it should be: opener.addheaders = [('Content-type', 'application/x-www-form-urlencoded')]
lord, this is gruelling. -&gt;authenticate and html --&gt;works -&gt;authenticate and simple php (no posted data, just echo) --&gt;works -&gt;autenticate and data posted ( opener.open(url,data) ) --&gt; fails, even without real php code, just echo "hello";
&gt; There should be one-- and preferably only one --obvious way to do it. 
It's an unreliable work in progress, like all of FirebirdSQL.
Finally... ty landyman. The missing bits were urlencoding the data and adding the headers for a urlencoded form. For the record: url = my_url user = my_user passwd = my_passwd data=mydata encoded_data=urllib.urlencode(data) password_mgr = urllib2.HTTPPasswordMgrWithDefaultRealm() password_mgr.add_password(None, url, user, passwd) handler = urllib2.HTTPBasicAuthHandler(password_mgr) opener = urllib2.build_opener(handler) opener.addheaders=[("content-type","application/x-www-form-urlencoded")] fp = opener.open(url,encoded_data) php_successful=fp.read() print php_successful A code strip carved line by line, literally, on my server, ugh. And I guess my original code was only missing the addheaders bit, but without landyman's help i'd never have found it. 
Happily married and produced an ogre of a child. The little monster has already eaten the package setup script and the directory for the package.
This is a decent summary of the issue, but Python 3 is over three years old at this point. Are there really that many people who are just now finding out about this?
Hi Barry, There are a number of screencasts I have added as later chapters. I am adding things as I go along, and its free now, as I am looking for feedback like yours. Its gonna become more complete before I start charging. 
[Don't even joke about that.](http://www.quickmeme.com/meme/35uqc2/)
The problem is number of programmer not knowing what pointer is. ... and also how Python default argument works.
Sure, it kinda goes with that, but the appending of else at the end is ugly and not part of that style, not to mention the fact that that style evolved for ease of readability and nested trinary expressions are not readable. I only dabbled a bit with it, but Haskell's guard semantics are a much better way to represent that, assuming I"m not mixing up two features, as they actually looked more or less like that, while trinary operators are just.... no.
If you're going to start with "this is offtopic", you may as well just not post it.
Yes, I think you pretty much summed up my reasoning. If you ensure you only have the single point of exit from the function, it's easier to follow the logic. If you are also in the habit of making relatively small functions, it's fairly easy to understand where the assignments to the result variable happen as well.
Yeah, that's what I meant... right... In all seriousness, though, the distinction between the two is very important. My response may sound a bit tired because I'm irritated by people who want to eliminate this distinction. Perhaps the documentation could be better... well... no, it actually is pretty good. The problem is with all the shoddy examples people find on the internet, so if we want to blame anyone, we should blame the bloggers.
Back when CarlH was doing his C++ programming tutorial reddit thing, one of the things which impressed me the most was, given that it was intended for someone who had never programmed before, how quickly he hit pointers. He just landed them in with other basic variable types in C++ on, like, Day 3 instead of doing what I've seen from every school my friends have gone to, which entails waiting until half-way through the second semester before introducing them.
I went ahead and got a room down the street at the Avatar Hotel. Wasn't expensive, seems nice, and supposedly there's a shuttle. So hopefully that goes well.
Yep, when I started working with Python, I was puzzled because an if statement evaluated to False because I said "if a is b". I knew for a fact that a was indeed b, so I was scratching my head. I later replaced it with == and never gave it a second thought, until now. 
Do link the proper canonical URL.
No, I'm still missing things. `wordstring` for a start. Just send me the *whole* file.
If I understand that correctly, that's simply following the db worker pattern outlined in the blog, but using coroutines instead of threads/processes. That too could benefit from the reordering and coalescing in the article. If you're not reaching the point at which you are searching for ways to speed up your database access, of course, the approach outlined in the blog is not worth it.
I pondered on implementing that feature. Wasn't sure if it was legit though. It adds about 3-4 green packages and diversifies the red ones.
Your expectations are admirable, but also wrong. Which, incidentally, is how we end up with weird shit like that Wat video in the first place. Imagine Einstein's reaction when he realized that the speed of light being constant meant that your observation of time had to slow down to compensate! Some things are surprising but nonetheless are, because logic shows us that they must be so.
Which you could probably encapsulate in the context manager for Python code generation. I wonder if it's possible to make a more abstract code generator where you don't even need to know the syntax of the specific language, but only tell the generator to emit a class definition, variable assignment or function call. Admittedly, that would probably be a [dead bird](http://naminghard.blogspot.com/2011/07/programming-metaphors-you-need-part-1.html), but an interesting exercise nonetheless.
Oops, sorry. Just noticed this! I try to get them out every month. I shoot for the last ten days of the month. The sad fact is, I missed December entirely. But I'm in the process of posting the next episode--look for it in about five minutes!
In more complex cases, with additional functions being called, this way of doing it removes the option of tail call optimization. Of course, python doesn't have tail call optimization, so it's moot here, but as a general programming paradigm, it is good to keep this in mind.
Though there are cases where that may not quite hold. Here's a puzzle - what two characters can you substitute for ?? with that would allow the following to occur: &gt;&gt;&gt; ?? is ?? False &gt;&gt;&gt; id(??) == id(??) True 
Whoa, cute. Took me some time to understand why ids are equal.
yes, I would have loved to find this myself in my endless google searches. The ironic moment of desperation was when i clicked a result that was my OP pastebined code. 
Thanks for the attribution :) I think your installer may have a problem though, regarding the associations. .bmp doesn't always point to Paint.Picture (nor .jpg to jpegfile etc.). You should do this: * Read HKCR\\.bmp\\(Default) to a variable * Go to HKCR\\(variable) and add the shell extension For a similar example, look [here](http://nsis.sourceforge.net/File_Association). Note that this installs a full association for open and edit, it doesn't add one more item in the context menu. One more thing: You can use a shorter name in the registry, and put the full name in the (Default) value, e.g. Windows Registry Editor Version 5.00 [HKEY_CLASSES_ROOT\Paint.Picture\shell\gimp] @="Edit with GIMP" [HKEY_CLASSES_ROOT\Paint.Picture\shell\gimp\command] @="\"C:\\Program Files (x86)\\GIMP-2.0\\bin\\gimp-2.6.exe\" \"%1\"" 
Is it really important that we spend hours agnosing over how pythonic each piece of our code is? How do you get any work done? 
One more thing - you have marked the repository as private, so the source isn't accessible :)
What kisielk said. In any case, I try to follow the rule of always having else statement together with if, because it kills bugs. If that else should never happen, raise the exception.
Are you serious? I was having such a shit day. This'd fix it RIGHT up.
Learning Python: http://www.amazon.com/Learning-Python-Powerful-Object-Oriented-Programming/dp/0596158068/ref=sr_1_1?ie=UTF8&amp;qid=1328018624&amp;sr=8-1
All the reviews on Amazon say that Lutz's books are way too wordy. In the link you gave me, that particular book he apparently spends 72 pages on describing how to run a python program. I am definitely a beginner but I also can program in another language so I already know what a string is, what a variable is and so forth. It looks like all of Lutz's books get the same review. Not structured properly, too wordy, not enough exercise material on the code. However, thank you for your suggestion. Have you read this book?
Yeah, that's great, I do quick little things like this in the interpreter all the time when I need an approximate probability. Maybe it's just my style, but this seems really verbose. I'd probably do it like this: &gt;&gt;&gt; payoff = lambda n,k: "1" * k in bin(random.getrandbits(n)) &gt;&gt;&gt; monte_carlo_solve = lambda n,k,j: 1. * sum(payoff(n,k) for _ in range(j)) / j &gt;&gt;&gt; monte_carlo_solve(10, 3, 1000000) 0.50843300000000002
I've taught computer programming. In my experience, if you leave a topic until late in the course, the students will decide it must be a hard topic. Whereas, really pointers are actually quite simple. Once you have explained memory, pointers can follow from that quite quickly. So why not explain them really early, when the students are still full of confidence? 
Pretty ugly code, especially the payoff function. It is unreadable, in this case consiceness is not an advantage. do_n_flips should return a list of bits, or, if you want to use getrandbits, just an integer of n bits (getrandbits(n)).
Learn Python the Hard Way-----&gt; sidebar
montecarlo for this is absolutely ugly and overkill Here is the exact solution using counting : &gt;&gt;&gt; throws = list(itertools.product('pf', repeat=10)) &gt;&gt;&gt; len([t for t in throws if 'ppp' in ''.join(t)])/len(throws) 0.5078125
"How to think like a computer scientist" is a great book, the digital version is free! Greenteapress.org 
It's not that bad. However, I would avoid using it (as I would with the python one). It's one step away from calling functions and doing arithmetic operations inside of a ternary operator.
I'm not sure you understand this subreddit...
A lot of people expect python to have a ton of books you need to purchase in order to understand it. The reality is that the links on the sidebar really are the best way to dig in. When I learned python I just used the docs included with the language. You honestly don't need to purchase a book. I've never read Shaw's book, but it is repeatedly listed/linked as something people really like. Also, try using /r/learnpython. That is the most appropriate location for this type of a question.
seems to be the case. note that id([4,3]) == id([1]) and so on. It's unspecified behaviour though, so it could easily change between versions, implementations, and even compiles. Also, id([3] * 1000) == id([3]), but id([3] * 1000) != id([3] * 500)
Had to learn Python as part of a Uni module, aside from handouts and tutorial sheets (which were more useful than any website or book I've ever used for learning a language IMO), I used http://www.amazon.co.uk/Beginning-Python-Programmer-Peter-Norton/dp/0764596543/ref=sr_1_6?ie=UTF8&amp;qid=1328025339&amp;sr=8-6
Oh, thanks I was not aware that /r/learnpython existed. I think my biggest problem is figuring out how to use the right modules. I will import os or sys and try to grab the current logged in user, and then build a report of their home folder space and what not, and I get sort of overwhelmed. Sometimes the spacing syntax gets me too. I am trying to think of sys admin type tasks for me to do, and then write code in Python for it. Traditionally I have just used bash for everything, and I am decently proficient in bash programming. However, Python offers some things that are appealing me, profession wise (API programming XML parsing, etc) and I want to start converting my stuff to Python. As always thanks for all the advice.
This used to be one of my favorite books, but I can no longer recommend it. It is 6 years old and covers Python version 2.5. Most of the core language is the same, but it won't cover the "with" statement and a number of future support for Python 3 that was added in 2.6 and 2.7. I like Learning Python and Programming Python, both by Lutz. The latter seems to be another love it or hate it book. I love it--it was the first or second book on Python I bought when I was first learning the language over 10 years ago. All that said, pick any of these books and start reading and practicing. If the book doesn't teach you the way you think you need, then try a different one. All the books suggested in this thread (and many others like them) each have their own pros and cons.
I love these podcasts, they always feel very substantial with a lot of interesting content.
I just realized you're using Inno Setup, not NSIS. The example I've given won't help much.
The best for you(not a total amateur) would be "Dive Into Python" books*. And you can complement them with Martelli's "Python in a nutshell", the online python official tutorial, and Lott's "Building skills in python". O'reilly Learning/Programming Python books are too wordy, and even worst, those extra words don't offer better insight to the language, it's just blabbering to fill pages. Total disaster IMO. *: Dive Into Python shows its age a bit, that is it's a bit old and python is a fast evolving lang. Yet I still recommend it. But even starting with DiPython3 book isn't that big a deal. Python3 isnt that different, you just do some things in a more clear-correct way. It is the same language and you shouldn't be scared.
I used the same one that `omginternets suggested, but I also wrote my own PyGame tutorial, purely for the rotation function: http://blog.tankorsmash.com/?p=128 so maybe you can glean some information off o' that. Also feedback would help me out too.
Generally speaking, traversing through folders can be time consuming for a python program. For example, it's much easier to just do a 'du' command than to try and have python reinvent the du command. And if you need to do post processing, then running a shell command (like du) and dumping that text into python is often a better approach than to do pure python. On Style: It does help to setup your vim to use 4 spaces everywhere as opposed to tabs. But you can use tab instead of spacing in python, if you wish. Whatever you choose for whitespace, though, you need to keep it consistent. The generally accepted method is 4 spaces. There's a style guide under [PEP-8](http://www.python.org/dev/peps/pep-0008/). There is also a semi-working checker that could be helpful, though not in all cases: [PEP8 Checker](http://pypi.python.org/pypi/pep8) Learning the libraries is quite key for making you faster at putting together a program. And that's probably going to be your biggest learning curve, because you just can't pick it up in a day. Also, when learning: I tend to write in very small chunks and then test them. It will help reinforce what you're doing right and immediately correct what you've done wrong. I don't use vim as often as I should because I have been using something called [Slickedit](http://www.slickedit.com) for over a decade. But vim does have several python plugins that are useful and can really spice up your vim interface. I think your approach to use python in place of bash is great for learning python. However, I do believe that bash + awk is often going to work better for the simple tasks you might encounter each day.
The videos from my course are available for free here: http://synapse.cs.iupui.edu/Mediasite/Catalog/Front.aspx?cid=6d8a3243-451c-460c-8c15-fff771bc51f5 (Sadly the videos are produced in an older technology that only supports Windows, but I'm re-taping the course.) The course is based on a book I wrote a few years ago that's still in print, but you don't really need the book unless you want it. All the notes and examples are available here: http://www.aharrisbooks.net/pythonGame/ 
Thanks for the reply. I need to turn in my Unix wizard card I guess, as I tend to use GUI text editors. I have used vi, vim, pico, nano and even emacs, but I always find myself using a GUI text editor. I don't know why. The thing is, I am starting to get into database driven solutions. I need something to parse large amounts of XML data, and grab files, and update files in a database. Python seems like a much wiser choice for these tasks. I mean using awk/sed to pipe through large amounts of XML data seems like a nightmare. I will probably still use bash a lot on small stuff, plus I work with macs so Apple has a lot of apple specific command line binaries in the bash shell that ships with Macs. I just think converting some of my current projects from bash to Python would be a good learning method. Also, thanks for the post man, I appreciate the advice I get here.
And it did, and it did. Wonderful, well worth the wait. Thanks so much for doing this! An extremely interesting guest.
I have had the same experience with finding Python in a Nutshell very good a few years ago and now out of date. The most recent edition of [Python Essential Reference by Dave Beazley][1] is great for learning the basics then working through the stdlib - it covers Python 2.6 with lots of information about using Python 3. [1]: http://www.dabeaz.com/per.html
Welcome to the wonderful world of web frameworks! There are a ton of options based on the size of your project, the needed capabilities and personal preference. If you're just doing something small take a look at [webpy](http://webpy.org/). If you have any experience with Ruby on Rails many people like [pylons](http://www.pylonsproject.org/). My personal favorite is [django](https://www.djangoproject.com/) but this might be overkill for small project. It all depends on what you want to accomplish, so more information on your project would help but I would start looking through webpy and get a feel of how python functions interact on the web. 
I always do it the first way (no else clause), because I hate this: if some_condition: #100 lines of code #... return result else: return something or: if some_condition: return something else: #100 lines of code #... return result I am always in the habit of writing new code or re-writing the above code as: if not some_condition: return something #100 lines of code #... return result Especially if there are multiple "elif" clauses or multiple levels of nesting.
Python is great for parsing text (like XML). :) It's a great choice. You'll want to look into [generators](http://wiki.python.org/moin/Generators) to reduce your memory footprint. Python's [SQL Alchemy](http://www.sqlalchemy.org/) is one of the best ORMs in any language (and it's been ported at least a couple times now). It is daunting to use at first, but give it some time. If you have common operations, you should be able to package your xml parsing into a class and then your class usage could be very simple. I have found that Java scales better with larger (terabyte or more) data sets because of the JIT and the massive amount of support Java already has to deal with databases. At least it does with Postgres. The python library is basically the same as the c library, but it performs significantly worse than Java as data sets increase by orders of magnitude over your caching size (i.e. 10000 results as a cache size).
[Python Essential Reference by Dave Beazley][1] covers Python 2.6 and 3, it is a very good introduction to the basics, shows you quickly what the more advanced features are for, then takes you through using the standard library. And as a Mac admin you should look over [Munki][3], the [stuff in PyMacAdmin][2] and other projects for wrangling OS X networks. BTW 10.7 ships with Python 2.7. [1]: http://www.dabeaz.com/per.html [2]: http://code.google.com/p/pymacadmin/ [3]: http://code.google.com/p/munki/
&gt; Welcome to the wonderful world of web frameworks! Or, use none at all. You only need flup or cherrypy's server to run a Python based site. It's actually more interesting and "clean", at least I like to know how everything works instead of relying on magic. Sure, a framework is more convenient for any bigger project though.
[Flask](http://flask.pocoo.org/) is probably easiest IMHO. It is just a simple webserver with routes and templates. Doesn't have a built-in ORM/database abstraction layer, but you can easily add that if you need it. It's also easy to get running on [Heroku](http://www.heroku.com) if you need free hosting for a small site (and the possibility of scale for a larger one).
Choose one: http://wiki.python.org/moin/WebFrameworks
I have read it, although not in anger, as I wasn't a new python programmer at the time. It doesn't completely suck. The criticism of Lutz as wordy is accurate, but he also covers the bases. Personally, I wouldn't actually use this, or any other "Learn Python" book if I already knew how to program somewhat. The online resources are more than adequate for the basics. The tutorial in the python documentation, think like a computer scientist and Dive into Python are more than good enough to get you up to basic cruising speed. If you are a bit further back on the learning curve, Learn Python the Hard Way is very rudimentary and will run you through everything at a crawl. Personally, I liked Dive Into quite a bit, even tho people throw stones at it for various reasons, because it assumes you know how to code out of the gate and doesn't waste any time at all but throws you into the deep end of the pool. Anyway, you want a dead tree book because of your learning style, I would use the online stuff for the very basics, of which there are few and then pick up another Lutz book, [Programming Python](http://www.amazon.com/Programming-Python-Mark-Lutz/dp/0596158106/ref=ntt_at_ep_dpt_3). It is still wordy but serves as a good place to see a lot of different stuff in action. I haven't looked at it since the first edition, but it was a good overview of what you could do with the language then. You probably will want to find the 3rd edition instead of the 4th if you are on Macs, since I gather the 4th edition is python 3 oriented and not python 2.x oriented.
The only thing I didn't quite understand: In [16]: 1000 is 1000 Out[16]: True Why? Didn't I just create two different objects with value 1000?
Just fyi, Pylons is now Pyramid.
Disclaimer: I wrote this book If you have Amazon Prime, you can get my Python book, [Treading On Python](http://hairysun.com/books/tread), for free. Otherwise it is pretty cheap. This book is based on my hands-on tutorials given at PyCON and OSCON. The premise of this book is to take a programmer and teach them not only the syntax of Python, but gotchas, hints and community best practices. Unlike some of the books you mention, it is short and to the point. The slides, handout and actual assignments that go along with previous versions of the tutorials that inspired this book (and its companion that is being written currently to cover intermediate Python) [are available at github](https://github.com/mattharrison/Python-Full-Meal-Deal).
Thanks! I will try this. 
Not necessarily. The interpreter is allowed to take shortcuts when it comes to literal values. It is perfectly acceptable to create an integer object once and assign it wherever that literal value is encountered.
You might want to give a look at [TurboGears2](http://www.turbogears.org) and its very straightforward dispatching system. It makes easy to manage complexity when things start to get messy and you have many controllers and pages. It also has an appealing [Make a Wiki in 20 Minutes](http://www.turbogears.org/book/part1/wiki20.html) tutorial 
Why would you questionhis sanity? Languages with immutable data are very common. 
 In [1]: x=1000; y=1000; x is y Out[1]: True but In [2]: x=1000 In [3]: y=1000 In [4]: x is y Out[4]: False I think how this works, is that in interpreting a single line it realizes it's using the immutable integer twice so reuses it (which it can always safely do since they are immutable). In the second case it indeed creates two separate immutable 1000s. Only for small integers (between 0 and 256 I believe), it always reuses the existing predefined ones: In [5]: 1000+0 is 1000+0 Out[5]: False In [6]: 256+0 is 256+0 Out[6]: True 
True, but they are also very different languages. I was saying that I would question the sanity of someone wanting to switch to immutable data in *python*
I've read several of the most known Python books, and skimmed through a lot of the lesser known ones. The only one I REALLY like ended up being: [Beginning Python Visualization](http://www.apress.com/open-source/python/9781430218432), by Shai Vaingast. Weird it never gets mentioned. I guess the title doesn't helps much: "Beginning" means people who knows enough as to appreciate it tend to dismiss it, "Visualization" gets "I do console/server/web programming only" reactions. Everybody looses. It is full of good common sense, teaches basic Python and uses that on interesting sample projects. It's also quite an easy and interesting read. I would recommend to also get a good language reference (besides Python's Docs) like the already mentioned "Python Essential Reference" by Dave Beazley, and also keep an eye on ["The Python Module of the Week"](http://www.doughellmann.com/PyMOTW/). EDIT: I also found the [Python Cookbook](http://shop.oreilly.com/product/9780596007973.do) useful.
This may be true, but you should avoid relying on it. This is implementation specific, and can change at any time. It's one of those interesting details that shouldn't be part of your programming vernacular.
Absolutely. This just happens to be the case for the current standard cpython implementation. Relying on this behaviour is always wrong.
Yes, exactly! You said it better than I did.
Why? There's nothing fundamental about Python that would be broken by adding more facilities for immutable data.
For more thoughts on this topic, I recommend Henry Baker's classic paper [Equal Rights For Functional Objects](http://www.pipeline.com/~hbaker1/ObjectIdentity.html). It's possible to have a language where the divide between `is` and `==` is healed and only one operator for object comparison is needed.
[Flask-SQLAlchemy](http://packages.python.org/Flask-SQLAlchemy/) is your friend for adding an ORM/database abstraction layer.
I love django!
Yes, I have those bookmarked already. I also snagged some Python 3 videos from my work's lydna.com account
neat app, bookmarked, and thanks
Your book looks very interesting and it is well priced. Did you self publish this through the Kindle publishing thing? I know that is off topic but I was interested in trying that out. Thanks
unfortunately no Amazon Prime :-( but the book is only like $6 which is very fairly priced. I may pick it up
haha, I checked my python version on my 10.6.8 machine. We don't run 10.7 in production here so I work on 10.6.8 machines. My laptop is Lion but I don't use it when at my desk. I work in a Casper shop. I have looked at Munki, Radmind, Deploy Studio, and I just saw that Google released a ton of Python tools for OS X management. Thanks!
Yeah, there's a sketch of that at the bottom of the post. You could define all of the target language's syntactic constructs and use them. But it might turn out more cumbersome than useful, as it would probably be faster to use ``with BLOCK("if (x &gt; 7)")`` than ``with IF(VAR("x"), GT, 7))``
Cool, that is awesome. I have a bunch of short stories I have written over the years, all fiction, I was looking at self publishing. I know it is off topic from Python, but I am glad to get some feed back from someone who has used it. Thanks again!
Reminds me of the awful comp sci 101 class I was forced to take in university. Classes weren't introduced till the last two weeks. The course was taught in Java.
If you're doing this from a web app, modern browsers have a [geolocation API for Javascript](http://dev.w3.org/geo/api/spec-source.html) ([Demo](http://html5demos.com/geo) ) that is *creepily* accurate, especially on mobile browsers. If the user doesn't have geolocation enabled, fall back to the IP-&gt;Zip Code-&gt;Point method.
I wonder whether the OP realizes there's more than one meaning for "python".
You might give [Plone](http://plone.org) a try. It's a little heavy for just "using Python for a website" but it has some nice features.
If you want to try out some frameworks, there are lots of them (django, web2py, flask, bottle, ...), as cited in the comments. **But**, you could also try out web programming with [mod_python](http://www.modpython.org/), or even with [CGI](http://www.python.org/doc/essays/ppt/sd99east/index.htm). *Note that using CGI has some serious performance issues.* Which one is the best approach? Try it out and make your own choice.
Stylistically, I like the use of the 'in' operator for strings. But I don't think one-line lambdas are preferable to `def`, except in cases like higher order functions.
[0.5460936192499457 :)](http://www.reddit.com/r/Python/comments/p4gej/what_is_your_chance_to_get_3_heads_in_a_row_from/c3mmqfx)
fuzzy regex? That looks useful. 
`ImportError: No module named regex`
Nobody has given you an explicit answer yet, so: &gt;&gt;&gt; [] is [] False &gt;&gt;&gt; id([]) == id([]) True 
Hahaha, did you do the CodeSprint problem from a few weeks ago too? Nice code though.
Could someone break down that regex for me? I don't really understand it. `regex.compile(r"(?:\L&lt;terms&gt;){i,d,s,e&lt;=2}$", regex.I, terms=terms)`
I think it just finds all the words in the "terms" list although I don't know what all the fancy regex stuff does.
I'm sure that's part of it, but clearly the `{i,d,s,e&lt;=2}` must mean something...
Looks like it means fuzziness: http://pypi.python.org/pypi/regex/0.1.20120129 Ctrl-f for: Approximate "fuzzy" matching I still don't get it though. &gt; i = match, permitting insertions &gt; d = match, permitting deletions &gt; s = match, permitting substitutions &gt; e&lt;=2 = permit at most 2 errors
Ahh, thanks. Makes sense. I've never looked at this module before.
Well, I know what I will be listening to on my commute for the next few days.
Thank you, I think you gave me my next project.
In Python 2.7+, you can use {...} for sets. Just change the line to terms = set([ 'drunk','wasted','buzzed','hammered','plastered' ])
So, for grins, I integrated google's geocoding API to this script, so you can watch drunk people tweet anywhere in the world. Feel free to borrow/expand/use. https://github.com/diffra/DrunkTweet
This might be helpful: http://docs.sqlalchemy.org/en/latest/orm/session.html#merging
My idea is to hook a `requests.session()` instance so that it caches responses and subsequent calls to the same URL are turned into conditional HEAD requests sending the cached ETag / modified date. In theory this would get you a kinder, gentler scraper.
Adding SQL constructs can be done with custom [`ClauseElement`](http://docs.sqlalchemy.org/en/latest/core/compiler.html)s. Someone already implemented `ON DUPLICATE KEY` in [sqlalchemy_mysql_ext](https://github.com/bedwards/sqlalchemy_mysql_ext).
It's not ideal, but is there any way you can use the PHP reflection API to do this instead?
yes, but you can always use base64.
As takluyver wrote, for each request to an URL, the server loads a new Python process to run the script requested in the URL.
til: zmq.eventloop ... off to research
i use alot of python in my .do files for redo [ https://github.com/apenwarr/redo ] . pbs is a perfect companion for that
By the way, I just realized that this is yet another facet of an interesting problem with certain uses of GC. Until .NET 2.0 introduced the SafeHandle class, you had to sprinkle your managed wrappers over unmanaged objects with `GC.KeepAlive(this)`. Because, surprisingly, GC can collect an object while its instance method is executed, if there are no references to the object left anywhere. When you write "`return Win32.SomeMethod(this.handle);`", there's a moment between this.handle (a native integer) is extracted and the method is called, if GC executes right then, then the object would be collected and its finalizer would release the handle. Another problem [is said to be pervasive](http://timetobleed.com/the-broken-promises-of-mrireeyarv/) in Ruby libraries dealing with native code: so you create a temporary string object, pass it to some function as a native pointer and BAM! it can get collected when that function tries to create some Ruby object. The core of the problem is that sometimes you need to extract some essential property of a managed object as a naked integer, this property is logically connected to the object itself, it is coupled with its lifetime, and yet GC can't know that, because it's just an integer. The same happens here: we think of id(x) as a property of object x, holding to which should keep x alive, because we still "remember" that x exists, logically, we still "reference" it in a sense. "Yeah, so we have an object with id 123213213 here". And yet it's a simple integer, so it can't actually refer to anything, so the rule "id(x) is unique for each object" seems somewhat broken. 
I would say that [bottle](http://bottlepy.org/docs/dev/) is even easier. Also [deployable on heroku](https://gist.github.com/1224387). But flask is probably more extensible at this point.
This is really awesome. Something like this will land into core one day, and it will be similar. :)
I completely agree with Python Essential Reference. If you already know how to program it concisely and quickly shows you how to do what you already know, but in python. I used it in the second edition, however, when it was a much briefer reference than it is now.
This was submitted 4 years ago, but its still relevant and helped me out recently.
http://diveintohtml5.info/geolocation.html
Of course, none of the specifics listed here apply to PyPy, which is a lot faster anyway. :)
there is Stackoverflow [discussion](http://stackoverflow.com/questions/214881/can-you-add-new-statements-to-pythons-syntax) about this; you could use Python itself to pre-process, but I think it would be tricky to replace `&lt;1,2,3&gt;` using `tokenize` and `ast`. I understand your pain, and I have my own scheme dialect that adds various data types, but I think you might be better of using something like Numpy than adding new reader syntax to python.
&gt;By pure chance, it will use the exact same place for it as it was using for [1,2]. So id will return the same value. But not with every implementation. On [pypy](http://doc.pypy.org/en/latest/cpython_differences.html#object-identity-of-primitive-values-is-and-id), ` id([1,2]) == id([3,4])` is `False`. 
To force Markdown not to apply formatting, you can either put a backslash in front of the character: type \\\_\\\_builtins\\\_\\\_ and you get \_\_builtins\_\_; or surround it in backticks, which also switches to a fixed-width font: type \`\_\_builtins\_\_\` and you get `__builtins__`. To answer your actual question, modifying the python interpreter sounds like a fantastically horrible idea. It means that essentially nobody else in the world can ever use your code, because asking them to build a special-snowflake version of python is too much for the vast majority of people. 
Give each item an ID, either implicitly based on the order they appear in the file, or explicitly with a field that is written with each record. (You could potentially use Python's own `id()` for the latter, but that's questionable since when you re-read the objects a second time, their Python `id()` will no longer be the same as the ID field in the file, so you'd have to store it as an explicit field instead, losing all the appeal of using the built-in ID.) The pointer becomes the ID of the associated object. 
You might want to change your twitter password... 
Pretty much this. Of course, all this work is done for you if you use something like sqlalchemy with a sqlite database as a backing store. However, if there's some reason to avoid that and use text files instead, I think this is a good solution.
Yeah, I already read that. It teaches me some very basic usage of a few functions. What I want is to learn the most effective way of exploring the library to get a sense of how to use all of its functionality. There's very little documentation. For instance, I want my bot to be able to respond to both commands from the person i'm chatting with and myself, and I want it to output responses to the chat window the input came in from. I can do this easily when *receive* a msg, because the onmessagestatus received event comes with a parameter called 'fromHandle', and I can use that handle to send the output to the right chat window. But the onmessagestatus sent event doesn't seem to have anything like toHandle, and I'd like to find out what it does have that I can use to access the right window.
taking into account the time needed to import string this is faster: c = ''.join(map(chr, lst)) and looks nicer, more modern code
well, you can always try opening up the Python repl, importing the module and doing `dir(module)` to get an idea of what the module provides. It doesn't work in all cases (like on a directory full of submodules, but no definitions itelf), depending on how the module was put together, but for most things it's pretty handy. Once you have a list of functions/classes/constants/etc, you can run `help(module.object)` to read the docstrings for the object in question 
it's a matter of prioritization as well as building a feature of general use. A merge() that only implements the standard strictly will almost never be used, as nobody that uses Oracle ever does this kind of thing, and there's no DB2 dialect that even works with SQLA 0.7 at the moment, to my knowledge. One that tries to do some of what MySQL et al do, takes more testing/development effort...and also won't be used very much, though would be used more as the MySQL crowd tends to be where all these weird SQL edge cases are popular. Postgresql has no support for MERGE at all (though lots of chatter about providing it).
In Python 3: &gt;&gt;&gt; [97, 98, 99] [97, 98, 99] &gt;&gt;&gt; bytes(_) b'abc' &gt;&gt;&gt; _.decode("ascii") 'abc' 
[PyQt](http://www.riverbankcomputing.co.uk/software/pyqt/intro) provides Python bindings for the Qt framework, which is a cross-platform GUI framework. It's worth checking out.
Can someone explain why this person is getting downvoted? Is there no edit button in [/r/python](/r/python) or am I missing something?
&gt; nobody that uses Oracle ever does this kind of thing I'm not sure what you mean by this - the merge statement has considerable functional and performance benefits in certain common situations. &gt; no DB2 dialect that even works with SQLA 0.7 at the moment, to my knowledge FYI, it looks like there's a patch ready that supports 0.7, should hopefully be released in a month. I would hope that a future Postgresql implementation is ANSI-compatible. 
pyqt is pretty awesome to work with. only problem is that since it requires C code, you have to distribute a version for mac / linux / windows separately 
Awesome. Really curious to try this out.
My recommendation is to check out ipython. Ipython is like python interpreted mode, but has some nice perks that make testing code (and trying new libraries) much easier. Just fireup ipython, import the module, and use tab complete. &gt; from module import &lt;tab&gt; gives you some &gt; import module &gt; module.&lt;tab&gt; gives you some more &gt; module.class.&lt;tab&gt; gives you more...
I think ALL of the current mainstream Python GUI libs will have that 'professional' look that you talk about. To go beyond this, you'll need to think about what your GUI is doing. If you just want some nicer / funkier widgets but in a normal desktop, you'll have to write your own custom widgets, which is always more work). For in-game stuff, you'll probably want to avoid the standard GUI libs because you lose control of timing and animation stuff - then you would pick a GUI lib that worked with your gfx (and some of these can be very limiting). The imgur link you posted does really show enough detail, but for an mp3 player you'll want to use one of the 'big 3': PyQT, PyGTK or wxWidgets. You'll be able to get what you want in either of these.
More info here: http://ipython.org/ipython-doc/dev/interactive/htmlnotebook.html The setup is a bit involved currently as it requires installation of: * Zeromq * pyzmq * tornado * dev version of ipython See the docs for more details.
Very cool. If you're on OSX here's an install guide: http://minrk.posterous.com/install-ipython-qtconsolenotebook-on-osx-lion 
If you have macports installed a simple "port install py27-ipython" should do the trick. 
https://github.com/wholeslide/ipython_in_a_box prepackaged setup for getting an ipython notebook up and running on an amazon ec2 instance in no time flat. i have used this a few times in the last few weeks, its crunk.
To avoid confusion: Gitpaste is a git-backed revision controlled paste site where you can fork, edit, diff, and commit to any paste. It is completely open source! Some of the open-source projects that make up gitpaste.com: * Django * GitPython * Pygments * GitDB * Whoosh * Haystack * Markdown The server runs Apache + Nginx and Django is via wsgi. Each paste gets its own repository and can be edited by others. Some new suggestions: * Locking a paste from editing * ~~Unicode fixes~~ fixed. * ~~Allow normal usernames~~ added.
It depends on what you mean by study circuits. Obviously you can analyze various kinds of circuits using the standard math. Or do you mean a specialized electronic package with graphics and intrinsic modeling?
The *sympy* package (it's shown on the left in the image) is a symbolic math library and acts as a computer algebra system in the same way as Sage/Maxima/Mathematica. It's pretty cool! You can try a live session [here](http://live.sympy.org/).
Do anybody have experience with it in production, most discussions I found on web are old from 0.1 veersion now is 0.8 ?
Thanks! I have been using Sage, so I managed to overlook sympy, which is pretty sweet. And setting it up to support a local HTTP server is relatively easy: $ ipython notebook --profile=sympy Thanks again! 
I'm one of the kivy devs, so i'm obviously biased :P Kivy is definitly meant to allow exactly what your talking about in terms of non standard / media-rich gui's. Since all the rendering is in OpenGL, you can even get really crazy if you want (Maybe audio visualization in the background?) the docs are at http://kivy.org/docs We're trying to improve the documentation as much as possible, so please feel free to open github issues if something isn't easy to understand. Our game programming contest just finished, and we're releasing the results when we are done looking at all the entries next week; then there will be a bunch of more example games to look at too. Also if you want to use kivy, you can get help on the kivy-users google group or on #kivy on freenode. You can pm me too if you want :) Anyways, whether you end up using kivy or not, good luck on the project; sounds like fun.
huh...didn't realize I had two reddit accounts....freaked out a bit when saw an unread message from 2 years ago and my other post seemed to have disappeared. Not sure why I just used that username instead to reply to your post.... Anyways, if you do want to pm me use this acccount :)
I'm doing a PyQt GUI application at the moment. The Windows package I make with all the relevant libraries (including QtCore, QtGui, QtWebkit) bundled in is about 15MB zipped.
This is truly some of the best Python branding I've seen. Great job.
[Pyglet](http://www.pyglet.org/) is also fun and written in python library, very similar to pygame.
There’s [ep.io][] also. [ep.io]: http://ep.io/
Im not expecting someone to do this for me. Im just looking for some pointers or other perspectives on how this could be done. There is a specific way how i have to do it based on what we did in school. I just know there are other ways to do it and im trying to see how they look.. but as even though these tasks are easy and for beginers i still have to go trough a long trial and error process to make this work...
A general rule when asking for help on the web is: try it yourself first, see how far you get, and ask for help on the bit you've got stuck with. People don't like helping you if it looks like you've given up at the first hurdle. For approaching problems like this, first write out a series of simple steps to solve the problem, then work out how to translate those steps to Python code. If you're new to Python, there are several good tutorials on the web to get you started.
What jeff said, write some "Pseudo-code", think about how you would write what you want to do in english, imagine you are explaining a person what do you want him to do. Make something that looks something between code and english language, then we can help. 
As i said i am doing this myself one way or a nother. I already have a few strings i can use and we did everything in school already and i can send an email to my teacher anytime and ask for help if i need it. I am just trying to see how other people do this. We did just the most basic thing in school but i think that people that have more knowledge about the program or have learned the basics and everyhing by themselves usually think more outside the box. I have a pattern i can follow and with my limited knowledge i have gained in the last week i cant really just write the code and finish in an hour.. i have to go trough all the excercises we did and make this thing work. I am going to do that but i want to see how other people do it.. my teacher is going to know.. she knows what we learned and how my thing should look so turning in something someone else made is not an option.. TL;DR I want to know how the finished thing looks and functions. I have to make mine if you show me anything or not.
All GUI frameworks are written in another language, mostly C++. The user would always have to install the base framework for their system, but the Python code remains the same regardless. I have packed programs with PyQt for windows, mac and linux, though different Python executable packagers are better for each system. Mac is the hardest because of how it handles libraries, and also depending on whether you use macports or homebrew. But using something other than PyQt won't automatically make this easier, unless it's Tk, which is built into Python.
Heh, go for it. Good luck!
The best way to learn a library is always to read the code. Documentation is awesome, but documentation only tells you what the code SHOULD be doing and what methods SHOULD be there. Read the code. Find out what's actually there.
Nice.
Looks nice, but it also looks very strongly like a gist clone, the UI looks like it was practically copied wholesale.
IPython 0.12 supports Python 2.6 and higher, so you should be fine.
After trying it, I found it cumbersome and counter intuitive. Maybe I should toy with it further, but it just annoyed the hell outta me. 
While it looks fancy, I'd need a pretty solid reason to move away from Nagios. With little discussion on the effectiveness of this tool, I'm wary.
using email id as userid is a bad idea (spam). please allow for proper userids.
I have experience distributing a PyQt4 inhouse app + py2exe + NSIS installer; everything works great. A lot of business logic is stored in .NET, so I use pythonnet to load .NET natively into Python, which also works great. Py2exe will combine all dependencies in the dist directory, so it's a simple matter of just zipping all that up. I have more success with py2exe than pyinstaller. PyQT is worth a look. I have experience with Qt in C++ first and then in Python. It's a pretty good toolkit, well documented with a lot of functionality already built in. It has a great setup for data rich widgets: the view/model paradigm is great once you understand it. You can spec out designs with a WYSIWYG designer. All widgets can be modified with a CSS style markup language, so they can be skinned. There is access to raw graphics if that's what you desire. However, if you really want an animated desktop experience, why wouldn't you look at a technology like Flash? Seems silly to reinvent the wheel here, but I don't know what you're trying to do.
Indeed. I didn't literally copy it, but I tried my best to match it visually. It's a great way to create a base derivation that users are already accustomed to, while allowing to change if needed. It is a _gist clone_ after all.
Using supervisor, I can literally fire up my browser, open a new tab and start writing python! Ipython notebooks rock!
GUI is so 1985, I thought it was called UXD since 2008? My advice, make a browser plugin/extension to do this.
I have it working on Python 2.6.6 on Windows 7. 
Awesome. I hadn't heard of supervisor before (though I have written a few initscripts with start-stop-daemon). I'm going to try it out on my linux box at work.
Not sure if you have a web background at all, but you might consider writing mini-web-app with a microframework like Bottle or Flask, integrated with Tornado (IPython's Notebook functionality uses Tornado). You could probably use an existing open source HTML5 media player for the actual presentation of your music.
We use python to rip through netlists and interact with simulators if thats what you mean. 
PM me if you haven't found help yet. I can work with you.
I'd recommend posting this to [/r/sysadmin](/r/sysadmin), since that's where you're most likely to find people who might've used this. It's not like Joe Random Python programmer is going to use a sysadmin tool just because it's written in Python.
What kind of simulators do you guys use? 
Julian Taylor has [a PPA](https://launchpad.net/~jtaylor/+archive/ipython) which should have the necessary versions of things, for Ubuntu 11.10 and 11.04. Add ppa:jtaylor/ipython and install ipython-notebook.
This makes it so that for any given line of code, there's a one in a million random chance that it will throw a `MemoryError` exception (simulating an out of memory condition) rather than working as expected. The motivation is that in the current computing era the memory allocator almost never fails, due to virtual memory. A process can continue successfully allocating memory far past the amount of physical memory on the system, until it runs out of virtual address space. Thus actually running into a real out of memory condition has become somewhat of a mythical beast that never happens and most people don't write code with it in mind. The idea here is to force that to happen randomly every now and then to see how your software copes with it -- I suppose the reasoning is that you'll at least be exposed to how your program will die in flames should that happen, and if it fails to release resources as it goes down in flames you can at least try to write an appropriate handler to do that. (Although it's not a great test in that regard, because a real out of memory condition could prevent the VM from allocating temporary storage, causing a hard crash where the exception handler doesn't get a chance to run, whereas this just simulates that by throwing an exception.) It seems like kind of a sadistic exercise to me, and I think it was meant as a bit of joke.
I've used it a bit and didn't really like it. While my experience is limited enough that I can't go into specific complaints it just didn't click. In terms of nagios alternatives, I have been very satisfied with icinga, but that is hardly a discussion for this sub.
I'd second the recommendation to use Cython and just hand over fugly C. Alternatively, rewrite it in Vala which is a much higher level meta language which is designed to compile to readable C code.
There is no such thing as "ASCII 254". ASCII only defines values 0 to 127, and that page is incorrect in using that terminology. What that page is actually describing is [Code page 437](http://en.wikipedia.org/wiki/Code_page_437), sometimes called OEM because it's what the original IBM PC used. The whole idea of code pages has gone out of fashion, because it's clumsy and doesn't allow representing all characters. The modern replacement is Unicode, which can represent everything without having to specify a code page. Python uses Unicode. As you can see from the chart on that page, the character number 254 in cp437 is equivalent to the Unicode code point [U+25A0](http://www.fileformat.info/info/unicode/char/25a0/index.htm), so to print it in python: print u"This is a block: \u25a0" 
Another alternative is [shedskin](http://code.google.com/p/shedskin/). Not sure if C++ would be a deal breaker for you or not.
Is this your project? If so, what is Celery doing in the other 32,400 lines that yours doesn't? :) Will definitely keep this in mind when the time comes as I was thinking about using Celery. 
I haven't tried any of these, but: * [ahkab](http://code.google.com/p/ahkab/) - An electronic circuit simulator written in Python * [eispice](http://www.thedigitalmachine.net/eispice.html) - clone of the Berkley SPICE 3 Simulation Engine * [pycircuit](https://github.com/henjo/pycircuit/wiki) - an electric circuit analysis package written in Python I suppose it depends on what you want to do, but those look promising.
Ah, you're right. I spoke too quickly. 
You can embed Python in any C app. Try this: #include &lt;Python/Python.h&gt; Py_Intialize() Py_ExecuteSimpleString("x=1+1") (or something like that: look at the link below). The docs also have some good stuff about this. http://docs.python.org/extending/embedding.html As others have said, you can also use Cython to generate unreadable C.
Sweet, that helped a bunch.
If they are complaining about how you will be saving them money, they are doing something wrong...
How will this increase spam? I tried googling no result. Edit: So if i don't display logged in user email id or paste owner email id, there is no way it will cause spamming to user. 
Same thing: http://www.cyberciti.biz/faq/linux-unix-nginx-too-many-open-files/
I'm baffled that your programmer coworkers are C programmers and afraid to maintain a Python module. It's really not that hard to pick up if you already know programming conventions, and they might accidentally remember that they love to program.
Hi, In fact there lot of enhancements, but not enough marketing efforts it's true ;) There are better performances and the distributed architecture that is easer to setup than Nagios/icinga (and manage some cases like DMZ connections), but also monitoring core enhancements, with : * configuration simplification for dependencies * vmware esx dependencies auto-discovery * escalations can now be declared in time way and not "number of notification" * you can setup business rules (&amp; |) * declare services 'importance', and so with the dependencies, it will automatically tag "important" a root problem of your important service impacted. * you don't have to duplicate contacts anymore to manage "mail the day, SMS the night", and you can only got SMS for "important" impacts (see previous point) * discovery process with user defined rule * advanced services definition (apply a service on groups "Linux&amp;Prod" for examples) We are currently working on a configuration UI that will use the discovery process and will "auto-tag" the hosts so the admins will only focus on the hosts definitions and far less on the services. So it's far more than just a Nagios rewrite in Python. There are a lot of features and efforts for the day to day admin job. Remember than the main author (myself :) ) is an admin too :) Jean
The function works only because `'apples'` is truthy. For hilarity, try def the_right_way(condition): return ((condition and 0) or 999) Python's `return 0 if condition else 999` syntax was invented because people run into trouble with the and/or technique. 
Just quit. Python is as fundamental to being a Linux developer as C and bash. If your company develops for Linux systems, they are Doing It Wrong. _Edit_: In my experience, inability to exploit the full ranger of skills of programmers is both a sign of overly conservative management, and studgy senior technical leads. Here are some reasons to legitimately constrain choice of technology: idiotic peers, client requirements, and lack of features. 
&gt; How's your job going? &gt; Very well, I already ~~translated~~ wrote first thousand lines of code!
I find the way you quote 'C' disturbing.
I'm also curious
Right, I should have explained more. That's how I'm doing it now. But instead of using Py_ExecuteSimpleString() I'm calling functions via pValue = PyObject_CallObject(pFunc, pArgs); Later I have to replace the Python with C but I hope to still use Python data types such as lists and dictionaries.
What's wrong with spinning up interpreters with multiprocessing? There's nothing that makes it inherently slow, so there's no point for PyPy reimplementing microprocesses with a non-portable interface.
Judging by the fact that an entire committee was formed just to force you to port a program from Python to C, I'd say that this is a pretty big company. In that case, I'd raise the case before the committee (or someone higher up) and argue that Python costs less to maintain, is less error-prone than C and that existing C programmers can easily maintain the module - therefore making the porting efforts a waste of money.
`chr(254).decode('cp850')` is `u'\u25a0'` which prints as ■. So here's your character.
Originally it was a standalone multi-threaded socket server. I liked that because it kept me out of the mess of C code and gave me a central point to monitoring all the apps that use my code. Now I call my code from C as [embedded Python](http://docs.python.org/extending/embedding.html#pure-embedding). Next is conversion of Python to C. But my plan is to still use the Python library for it's collection of high level data type such as lists and dictionaries.
Yes, the least I can do is lay out the cost of the port. At the risk that they will blame me for the cost. After all, in their way of thinking, it could have been written in C in the first place.
Cross-process communication has lots of overhead, while "internal process" communication is very fast. Plus, if you've got lots of processes, having a unique copy of the interpreter for each process is exceptionally wasteful. If you haven't read Ian Bicking's post, I'd highly recommend it.
Such is reddit; I came here to say this.
Does Sympy simplify expressions? Can it solve integrals?
Ah, so it's older than just 2008. That explains it.
It looks like the answer is yes to both of those. Maybe you should look through the documentation. http://docs.sympy.org/0.7.1/index.html
If it were C++, you could use [ackward](https://code.google.com/p/ackward/) to access parts of Python's standard library. C isn't a comfortable place to implement rich data structures (the type system forces you to use casts), but [you'll find some](http://developer.gnome.org/glib/unstable/glib-data-types.html) in [glib](http://developer.gnome.org/glib/unstable/).
I still dont understand why we don't all just go on a standard time. then during "daylight savings" for those that participate, everyone just collectively says... screw 1900 to 500, we now work 1800 to 400. Or whatever it would be where you live. that way we always know Oh Japan is x hours ahead, but I am waking up early these days so I still shouldn't call until x. Esp. as we go more global... /sigh oh well Friday rant done.
Why don't they want Python? 
I had the same problem today. I hacked together a simpler method here: [https://gist.github.com/1730627](https://gist.github.com/1730627)
Don't read any British English books then!
I usually follow a different convention -- if the string is an identifier, like a dictionary key, it's single quoted. If it's an error message or other string that users will see, it's double quoted.
Strange, why is that?
If you want something lightweight, like coroutines for example, why don't you try running gevent under PyPy. See if it works. I haven't tried, but curious.
Make sure you document the time and resources it takes to create the equivalent module in C. You can then use the cost of development versus the benefit of having it in C to argue that more development should be done in Python.
I really cool video. Although it was slightly rambling I felt like I was trying to understand pypy with him. I wonder if pypy people actually use the build output for anything.
BeautifulSoup on Python 3. Shit just got serious. 
Last week I needed to automatically scrape a web page in a hurry and I ended up using Beautiful Soup. It worked just as advertised and I got good results almost immediately! A+++, would scrape again.
Look like there's an issue in the definition of `from_local()`: def from_local(*args, **kw): """Converts the given local datetime to a universal datetime.""" return from_local(*args, **kw) Looks like an infinite loop to me! (I just posted this on the blog...)
gevent doesn't provide true multiprocessing because again, it is limited to a single software thread by the GIL.
I think it's intended in a similar manner to [requests](http://docs.python-requests.org/en/latest/index.html): making a more natural interface to existing tools, not adding new capabilities. That's a perfectly valid aim, and you're free not to use the new interface if you don't want to.
Have you considered gradually rewriting functions &amp; classes in c? That would allow you to balance this standardization effort against new requirements in the same code-base. And you might hit a certain point of equilibrium where your committee is satisfied, but it isn't 100% C. In fact, it may help you show that python &amp; c can happily cohabitate.
Definitely going to take a look at this and make an update (and probably another blog post, yech) this weekend. Thanks!
Thanks. I am on mac but this points me to the right direction.
Haha, ponies maybe. @coleifer, will Huey support ponies?
BS4 now uses other parsers - mainly lxml or html5lib. They are now pretty good at parsing broken HTML, so it was no longer BeautifulSoup's USP. It [no longer has its own parser](http://www.crummy.com/software/BeautifulSoup/doc/#be-sure-to-install-a-good-parser). The main advantage is how you access the tree after parsing. BeautifulSoup includes a lot of convenience features - e.g. you can simply do `soup.h1` to get the first h1 tag. As [the author says](http://www.crummy.com/2012/02/02/0): &gt; I don't want to duplicate other peoples', work, so I'm getting Beautiful Soup out of the parser businesss. Beautiful Soup's job is now to provide a Pythonic screen-scraping API on top of a data structure created by a third-party parser. 
well, thanks. but it still says " (~2K lines vs ~20K in celery).", if presented as something simpler by using sloc as a metric, then I don't see why the tests should be included. sloc is already a naive and useless metric (I could market Celery as being 134000 lines shorter than Twisted, but I don't as they are different. I would rather focus on how huey could *actually* make your life simpler for the use cases it is designed for, sloc is no proof of this).
&gt; BS is amazing at parsing broken/non-compliant HTML So's html5lib: it implements the HTML5 parsing algorithm which is 1. documented in excruciating details (including error recovery) in the corresponding specification 2. being progressively implemented in all browsers (Chrome ships with an HTML5 parser since Chrome 7, Firefox since FF4, Safari since Safari 5.1, Opera just released it with 11.60, and Microsoft is planning it for IE10), so by using html5lib you get the same document tree a browser does.
I _have_ the British edition, and I'd remember something like that, I feel, as it would bother me.
This implementation is from the time you ask for input, till the time the enter key happens. which is not the same thing. To do what you want, you need to know when the first character is typed. which is python is *difficult*, because python is line buffered by default. There are ways however. Basically the psuedo code would be: getch() startTimer() getRestOfCharacters() stopTimer() (obviously you want this in some sort of loop, and break out on '\n' (enter) or other control characters such as ctrl+c being pressed. Anyways, to get a single character, consult your UI toolkit you are using. *IF* you are not using a UI toolkit, consider using one. But if you can't/won't for some reason.. no worries: some people have figured it out and got you covered: http://stackoverflow.com/questions/510357/python-read-a-single-character-from-the-user 
So I'll release each one of my 'utility' modules I have for my projects as a fully tested and sure-to-be-updated library?
 '''I triple single quote everything'''
What about when I say, "I heard Asdayasman say apostrophes as quote marks are 'disturbing,' then things like 'better hadn't,' and I left the conversation immediately?"
If I understand the low level documentation correctly. Gevent event loop and queuing is indeed single threaded. But it solves the multiple core problem by having multiple queue workers. More or less the classical event-driven style programming. 
if you want to end up with idiomatic and maintainable c, i'd go the route of 1. port the python code to vala 2. port the vala code to c + glib + gobject since vala compiles via c anyway, step 2 can conceivably be done with a lot of automated support from the compiler, though i've never tried it
&gt; when I came to #python on freenode with a problem, they said I should use html5lib instead That's why I would never recommend anyone go into #python. Far too many people leave there only with suggestions of other things to use rather than how to solve the problem they want to solve.
That makes me want to """ the whole thing. Or escape "s inside the main " pair. I don't actually know what it's meant to be in English, though.
python is general-purpose while bash is domain-specific, I do both and I like both but I don't htink you can replace any with the other; whereas bash fall short for complex tasks, python will get in your way for shell stuff.
Thank you, works wonderfully. In this case it is worth the complexity, because I'm plugging into my professor's directly ported Pascal code. It's for a genetic algorithm, so each parameter has to be maintained as a binary string as well as an int (which conveniently doesn't care what base you want thanks to 0bxxxx and int('01..10',2)) and in Pascal this was done in a way I don't care to. Doing this saves me a lot of trouble. Thanks again. I just wish it was as clean as C# where: public double area { get { return w*h } }
I've written very simple memo decorators before for my own use, and figured for this example an explicit memo dictionary was faster and clearer. Can't you do something similar with [functools.lru_cache](http://docs.python.org/py3k/library/functools#functools.lru_cache) with no size bound?
Ah, I see... If each greenlet is modifying a shared data structure (e.g. in-memory dict), then yeah, race conditions can happen. Not a problem if each greenlet is pushing to transactional database or data structure with atomic operations.
I hope you never have to use ASCII....
Do it! Why not? Particularly in Python. I have a lot of third-party one-pagers floating around that work nicely for me...
That part I'm just guessing. I usually just shied away from that. I use gevent often but within certain common practices.
So do I. I read up on encoding recently, and holy shit, fuck that.
Anyone know where I can get a ticket? I was seriously going to buy my ticket this weekend =(
The one drawback is that if your array only contains a single vector and not an entire array of vectors, adding two numpy arrays turns out to be slower than adding two tuples element-wise.
I do that sort of thing, I think I got it from the quoting rules in bash/perl/ruby (single quoted strings don't get expansions).
Yes but what BS is good for us parsing broken pages. Lxml will just give up if you give it some badly formed html
I'm sorry you feel that way. #python played a big role in me learning Python and I try to contribute from time to time.
FYI - there will be no waiting list, and currently the only way to get a ticket is through a sponsorship package but that will soon close as well.
That's no longer the case. BS no longer has its own parser and [lxml provides html5lib](http://lxml.de/dev/html5parser.html) which is very good at parsing HTML.
There are transpilers to Erlang that provide alternative syntaxes: Elixir (Ruby-like), but also efene (Python-like) and neaterl (minimal changes).
lxml with xpath is beautiful and simple. Never found a need for beautiful soup 
Base class of RobustWackAssHTMLParser, no less.
Duly noted, I have left it as "(~2K lines)", since the whole point was that a person could sit down and read the code and grok it in one sitting.
They are reservations, not tickets - no fungability implied. (I'd been waffling about going, missed the early-bird deadline, and was startled that the headcount limit was hit at all, let alone hit so quickly - last year had a 1500 limit as well, but it wasn't actually hit. Is Santa Clara just that much more exciting than Atlanta, or is it an indication that the economy is improving?)
I hadn't even thought of that. I probably picked it up from shell scripting then.
OK, but the point is that there isn't any cake, BS4 already uses lxml internally and lxml by itself already handles broken html just fine. Cake eating doesn't require BeautifulSoup.
Yo dawg, I heard you had an aesthetic sense, so I had you write a C parser in Python so you can appreciate the relative elegance of Python (by actually using it) while you appreciate the relative elegance of Python (by comparing it to what you're parsing). :)
use a 64-bit time_t. granted, this might not have quite the support a 32-bit unixtime does, but it's better in every other way: * it's smaller: 8 bytes vs the smallest possible pickle for a datetime.datetime is at least 17 bytes (to store the string "datetime.datetime") * i'd say it's less ambiguous: so when you depickle a datetime.datetime object 5 years from now, are you going to be surprised because the implementation has changed in a non-backwards compatible way? *this has actually happened to me at work: I was using an object derived from the 'set' builtin, and python 2.6 couldn't deserialize pickles that were made from python 2.4*. Not only that but won't the depickling do something unexpected if somebody has another module named 'datetime' earlier on their python path? * it's more portable: if you are storing the datetime in a column in a db, if you store it as a time_t / unixtime, then you can read/re-write it from damn near any language. if you store it as a pickle, you're stuck with python. I want to reiterate that I support any and all work to fix python dates/times/tz; the nit I'm picking is solely with *storing* a python object when it's completely unnecessary.
I know this is really not an answer, but I'll say it anyway - it grossly depends. You can't have a precise number (say 60% more or 30% less or so), because it'll depend very much on your usage. PyPy has a pretty big start memory (so if you measure memory usage of a fibonacci sequence counter, you'll be scared), around 30M vs 5M in CPython (roughly). Then there are following considerations: * JIT eats some memory, but we found out unless your programs are super-large, that shouldn't be a lot (it depends on the size of stuff compiled to assembler) * GC adds an overhead of about 30% of size of your objects at peak times, but you can tweak it with the env variables * Objects themselves are much smaller - especially instances (like with __slots__ in CPython, except you don't have to define them), list of ints, dicts etc. Hope that kind of clarifies memory usage patterns.
I think it's because Python is getting more traction and growing rapidly.
Reminds me a bit of an old job I had. They had embedded software written in C, which did a lot of string manipulation. I argued for an upgrade to C++ thus fixing or avoiding 90% of the problems they had or would ever have, but they weren't willing to do it, saying people just had to write better code instead. I totally understand not wanting to let everybody code in whichever language they like, because the diversity of the codebase is something they have to consider in future hiring decisions, in security audits (if that applies), etc. But you'd hope that one day they would realise that you need to stop trying to train faster horses and buy a car instead. When a better tool is invented and someone shows you how effective it is, asking them to replicate the functionality with the old tool is not the right long term solution.
Sage is bloated as hell.
Nothing special, but i figure it might be of use to some others here. Haven't tested it on any systems other than Windows. Should be useful for those using foobar2000 or audio players on linux. (I say this as I don't know of any way of getting iTunes to run external commands)
But is it as restrictive?
Check out [what the official Python FAQ says](http://docs.python.org/faq/library.html#can-t-we-get-rid-of-the-global-interpreter-lock).
Ah, ok. Sorry I was in a touch of a hurry, you are correct basically the implementation is the same, but you don't cover getting keystrokes at all, so I assumed you were just doing a readline() without actually looking for it. Sorry. Correct your code handles the timing part, which is terribly easy as you say. The harder part is getting the keystrokes 1 key at a time, which in python is difficult using only the std lib. (yay line buffering) :p 
Just use multiprocesing. It has the same api as threading, but no gil. Works perfect.
^ this the tldr version of my comment.
&gt; Can you elaborate on what you want to "just work" and why it was complicated? It's been a while since I've even bothered with multithreading, so I don't have a specific example; but the GIL is a well known issue, so most people are aware of how much of an annoyance it can be. &gt; the only downside is you don't get shared memory That's a fairly big downside. 
The API for both is nearly identical. I don't mean to be difficult, but you've yet to elucidate on what exactly is the difficulty you are encountering. If there is truly a sane case where PyPy or some other interpreter is the best solution I'd truly like to know the details for my own advancement. edit: [nice slide deck](http://www.slideshare.net/pvergain/multiprocessing-with-python-presentation) about multiprocessing including side by side code examples.
Stackless means you can use coroutines, aka lightweight cooperative threads that don't actually run simultaneously. Useful for IO parallelism, whereas multiprocessing is useful for parallel computation.
I'm curious: is JIT overhead proportional to the code size? Any rough idea about the scaling factor? (e.g. 100*pyc file size or some such). What would be the the worst case scenarios for JIT? Thanks! 
I would say that's something you can potentially report as a bug (350 vs 100M). Can you say which version of PyPy have you used?
it's not proportional to codesize. It's somehow proportional to the code size you use regularly, but there are so many variables it's really hard to predict. Most of the stuff is JIT bookkeeping data, so it depends on how well the JIT can optimize stuff as well. There are also heuristics to tweak it. We should probably come up with a scheme like an env variable "how much do you want to keep" or so, but it's not as clear right now.
check the first example: import subprocess subprocess.call("ls -l", shell=True) here you're constructing a meta-command to execute another command, this on bash is straghtforward because bash is domain-specific, the action is implicit now on python you need to get into this meta-space to get there and that's getting in your way because 90% of the things you do on shell are executing commands and operate on their results and/or return codes.
Out of curiosity, what were your issues? I've had to stick my neck into that recently, due to a bug involving not flushing child process buffers under py3k/windows.
One that come to mind was that multiprocessing was spawning dozens of copies of pythonw.exe, I think because I had some code outside of ```main()``` (it was a while ago, can't remember exactly).
Thanks, that helps tremendously. I understand that YMMV. It's just really hard to find information on this subject -- or maybe I just suck at googling. Fortunately (or unfortunately), I don't have to deal with the issue of handling too much traffic at this point, but I've always been curious about the tradeoff between PyPy and memory-based caching. Of course, it will come down to the nature of the application but it's interesting to hear other's experiences.
I'm not familiar with wx API. But for some directions: You should have 1. a callback in the panel 2. that animates the GIF for one frame, 3. and then tell the wx event loop to call it periodically.
That's a pretty steep difference, if you could put together a bug report with some sort of minimal test case I think we'd love to take a look.
Unfortunately it's non-trivial to minimize, since that's the whole game server (about 5000 LOC, plus dependencies like Twisted) running multiple games. But if I find a similar difference in a smaller piece of code, I'll report it.
Because nobody's got around to removing it yet. There's a new stm (software transactional memory) branch in progress now, which is designed to let you run Python code on multiple cores in parallel *without* programmers needing to manually put locks around shared variables. We'll see if it works out.
I think most people actully forget this. The original BS was one file, pure python, cross-platform, no dependencies, which was one of its main selling points. I can see the reasoning behind the lxml switch (wheel reinvention etc etc), but still it makes me sad. Lxml is an absolute bitch to use on Windows, I do hope BS4 will install even without lxml.
I wouldn't go that far. Let's say that threads *look* like they're easy to use. Nobody who's tried to debug a deadlock in a production system at 2AM (or even tried to debug a deadlock at all) would say threads are easy to use.
taskkill /F /IM python.exe
Darn I have a purchase request going through my work to pay for the conference...I never expected them to sell out when they said you can pay for a ticket at the door.
I would call it `2and3`, maybe. :-)
I don't work with wx. GUI apps need to keep the main loop free of processing and only call out to threads to do work in order to keep everything responsive. You should look into a thread pool management system and put your GIF image processing in something like that.
As other people have mentioned: `@property` will accomplish this. But also, class RectangleInit(object): def __init__(self, h, w): self.area = h * w self.h = h self.w = w class Rectangle(object): def __init__(self, h, w): self.h = h self.w = w def __setattr__(self, attr, value): print attr, value super(Rectangle, self).__setattr__(attr, value) try: if attr != 'area': self.area = self.h * self.w except AttributeError: pass The @property decorator, as you can see, is much cleaner and takes much less in terms of LOC, but essentially that's what it's doing (in a much better way, I hope). The 2nd example just shows a manual way of doing this with setattr. You could do it with getattr to intercept calls to it by picking up when someone calls `object.area` and instead outputting a computed value then. class Rectangle2(object): def __init__(self, h, w): self.h = h self.w = w def __getattr__(self, attr): if attr == 'area': return super(Rectangle2, self).__getattribute__('h') * \ super(Rectangle2, self).__getattribute__('w') else: return super(Rectangle2, self).__getattribute__(attr) As you can see, the latter two methods are extremely convoluted ways to achieve what the @property does in a succinct and pragmatic style of coding. HTH. 
Oh no doubt! I didn't mean to sound so critical. The numbers that I've seen so far are completely reasonable IMO. Concurrency isn't Python's strong point, so in the not-to-distant future, I foresee cheaper RAM and SSDs to have a bigger overall impact -- as opposed to increased CPU parallelism -- on the widespread acceptance of Python via a JIT like PyPy. The CPython folks are fantastic, but I don't agree 100% that CPython runtime performance is adequate (in general). Python will probably never replace languages like C#/Java in the enterprise but the more market share it takes away from them the happier I'd be as a developer! Whether it's justified or not, people still care about speed (how often do you hear stories about how some small startup chose language X over Y to ensure that they can scale easily when they reach the traffic levels of Twitter). Cython and ctypes are fantastic but the majority of users will want a drop-in replacement for CPython, and that's one area where PyPy is being very wise. IDK, I very well may be talking out of my arse as I'm a relative newb compared to the folks who hang out here. ;)
 if hasattr(func, 'im_func'): - func = func.im_func + func = func.__func__ =(
The idea is awesome, Armin. Will look into it...
As I said, work in progress :-)
I had to switch off using pypy for a web service on a small VM, because it was using up too much memory. For that *particular case*, pypyjit wasn't for me... If you have heaps of memory free, and you actually measure pypy going faster for your app then fine. When I tested pypy for some web apps: JSON, database queries, and processing XML were consistently faster with CPython. Note, that since I trialed pypy, it has gotten faster at a few web tasks. For example, creating JSON is as fast as CPython now with pypy (but reading JSON is still slower), and there are some faster database drivers available for pypy too now. But really, higher memory use was the main reason I switched off pypy for these low end apps. When the ram is all gone, any JIT in the world isn't going to make your server go faster, because all the ram is gone, and your processes will fail. If pypy is using 20MB-100MB more per process, that adds up quickly for python web apps. Since you may have 10-20 of them, so the 20MB is multiplied by 10. Low end scaling is fairly important, because the majority of web apps still run on shared servers getting infrequent use. On a platform like a phone, or mini server that has 256MB or so total, that is way too much. Remember pypy has a version without a jit too :) I did compare that to CPython about 2.0 years ago, but don't seem to have written down the results. Because this one app only used cherrypy plus standard lib libraries, I'd hoped that pypy without jit would use less memory. I do seem to recall that both CPython and pypy had a fair bit of room left for optimizing shared pages. That is for when you are running more than one process the ram can be more easily shared between then. Theoretically, a GC in pypy could be made more efficient at sharing memory between forked processes than what CPython could do with its reference counting which stuffs that up. However, I don't see any evidence that the pypy memory subsystem is good at avoiding memory fragmentation. Whereas the CPython implementation has been tuned somewhat to use memory pools, a special memory allocator and such things. CPython can be compiled with a small memory using libc, like ulibc - so you'll use quite a bit less memory for a process than normal glibc that comes on many linux distros. Whereas I don't know if pypy works with ulibc. So your CPython process can use about 680KB of ram, compared to 2.2MB of ram for a normally compiled python. Similarily, CPython can more easily swap out the memory allocator it uses - I never hear of people doing that with pypy (please correct me if this is done!) Setting a smaller thread stack size can reduce your memory use lots for web apps (especially multi threaded ones). I believe the CPython stackless, and greenlets are currently more memory efficient compared to pypy - but stackless improvements are ongoing with pypy. These posts are informative about real world use too: * http://mail.python.org/pipermail/pypy-dev/2011-October/008508.html * http://www.quora.com/Quora-Infrastructure/Did-Quoras-switch-to-PyPy-result-in-increased-memory-consumption You can learn a few things from there. Some parts are faster with CPython even if you have a pypy developer on staff (lxml, crypto etc). Your web server might take 500 requests before it gets back up to speed. This means that your first 500 requests will be slower - but after that PyPy can be faster even with DB access. One worker out of 10 grew from 15MB to 250MB. If the others grew by the same amount, that would be about 2350MB more ram used. In the web world it is common to restart web servers after a number of requests(or even for every request) so that memory leaks do not have as much of an effect and bring down your whole server. If you restarted pypy processes every 500 requests, it would never be able to warm up the JIT. 
How Does it... Add the album art? Does it just stick a file named album.jpg or whatever in the folder or does it attempt to embed it in the music file itself (mp3) ?
Nope, doesn't do anything with either scanning embedded album art or saving album art as embedded art. Foobar2000 (I was making this script as a solution for myself) has a list of filenames to check in a folder for album art. I basically copied this list in order to create settings.py, and wrote the script around foobar's behaviour. Hope that makes sense..
I think I agree with Samus_, but I'm unsure what he's said. I'll try, in my own words: "In what ways does [Python] get in your way for shell stuff?" As Samus_ correctly observes, much of a typical shell script is a "hand-off" to a separate (often built-in) executable. In **sh**, this is particularly easy: one writes, for example, THIS_LIST=`ls -l` Python manages external processes more verbosely (if more precisely, in cases that are rare): import subprocess this_list = subprocess.call("ls -l", shell = True) Conclusion: shell is more succinct and even readable in a use case that's representative of a large, large portion of what shell does. There's more, though: in almost all realistic applications, an idiomatic Python implementation of this particular requirement would pass by way of the glob module rather than invoking **ls**. Also, **sh** will typically need to parse **$THIS_LIST** in some way; even with **sh**'s instant access to **sed**, **cut**, and so on, **sh**'s tokenization rules often make parsing rather confusing. Python's wealth of well-designed built-ins give it a head start. If processing of **$THIS_LIST** is at all complex, the Python coding ends up being, to my eye, more readable and maintainable. My summary: I use both Python and **sh**. The great strength of the latter is in gluing together pipelines that admit direct expression in terms of Unix's standard executables. Once the parsing is at all subtle, though, or when the application exceeds, say, twenty lines, Python likely admits a more lucid and maintainable solution.
Sounds like my company except we're all Java.
Ugh, 'six.advance_iterator(it)'. What would've been wrong with 'from six import next'?
It really depends on what you're doing. I write a lot of software that relies on network communications. These operations spend most of their time waiting or I/O, so they work extremely well in threads. If you're interested in performance there is multi-processing, as already discussed at length in the thread. I've read your concerns with the module, but it's simply a matter of using the right tool for the job. You don't discuss what your specific application needs are, doing so might open the discussion up to more specifics about the correct choice for your goal. 
either some function you're calling is multithreaded C behind the scenes, or, since neither core is maxxed out, your program is jumping cores very often
The only function in here that I didn't write is the distance function in geopy, and I'm certain it's not multithreaded. &gt;since neither core is maxxed out, your program is jumping cores very often I think we have a winner! I've been playing with setting processor affinity and using the timeit module. It's a little bit tricky to be certain, because of the use of random starting points, but after several runs, I don't see a significant difference between running with affinity set to all processors vs set to a single processor. It seems that it's the DoClusters function that is causing things to hop around. I don't know why the recursive version of it in the cleaned up code would exhibit this behavior when the iterative version in my old code did not. It's quite interesting. Now, I can start to actually make this multithreaded :D
I'm working on a [subprocess wrapper](http://readthedocs.org/docs/sarge/en/latest/) which offers something like this: &gt;&gt;&gt; from sarge import capture_stdout &gt;&gt;&gt; with capture_stdout('ls -l --color=auto') as p: ... print p.returncode ... print p.stdout.text ... 0 total 24144 -rw-rw-r-- 1 vinay vinay 1048576 2012-01-17 18:37 dest.txt -rw-rw-r-- 1 vinay vinay 393963 2012-01-09 17:07 devdict.txt [rest of output snipped]
Yes and no, Samus_. That is, I like your suggestion of a better approach. While your detailed example doesn't inspire me, Python's relative clumsiness in sh-like situations isn't a "pain point" for me; I'm not in the likely audience for this, anyway. The deepest observation we can make about Python is that it encourages approaches like yours: come up with a good idea, and it's instantaneous to define and implement such a little DSL, and begin to experiment with it in ones own code. sh, too, of course admits procedure or subroutine definitions, but we all know they don't feel as "first-class" as Python's. So, Samus_, I agree with you that sh-like globbing and word-splitting are examples of potential surprises for sh people new to Python, and I agree that a great strength of Python is its ability to wrap up interfaces so nicely that we can make objects behave as we want or need them to behave. 
Awesome. Haven't tried this but says it works as a Proxy. Add that extra [necessary] layer of safety if you want to deploy/upgrade servers using pypi.
What you are seeing is the scheduler moving your application from one CPU to the other. There are many reasons why you may not have seen this before, maybe previously the scheduler didn't think it pertinent to switch cores, maybe something else was using your second core. Either way your Python isn't suddenly multi-threaded. The only way to take real advantage of multi-threading is with the multiprocessing app. I've written some fairly tight looping code before in C that wasn't multi-threaded and had the Windows scheduler move my app from core to core (4 cores) thereby putting 25% of the load on each one, and I got about the same sort of graphs that you are seeing.
Hi, Unless you force some CPU affinity for your process, Windows is free to balance the workload around on available processors as it sees fit. If your task isn't purely CPU bound (e.g. it periodically does IO), then changes in the timing of this IO (which causes your process to sleep and wake later when the OS has satisfied the request), e.g. due to moving code around, could easily cause the scheduler to appear to behave differently (bearing in mind that the scheduler's behaviour is also impacted by everything else happening on your system at the time). It's a little known secret that on an SMP machine you can get an extra few % perf by binding a CPU-bound thread to a single CPU. See e.g. http://pypi.python.org/pypi/affinity . There are a few reasons for this, but e.g. a context switch (resulting from scheduling a new task on a CPU) causes the processor's TLB cache to be flushed. The TLB provides fast access to virtual&lt;-&gt;physical address mappings (needed by the processor to read the next instruction, or perform any kind of load/store), which are otherwise held in RAM. When the TLB is empty, the processor will stall every time you touch a page that hasn't been touched since the last flush, while a TLB entry is recreated from RAM. If context switches are occurring several times a second, this quickly adds up.
seems someone went a bit further and implemented shell commands as magic imports: https://github.com/amoffat/pbs this seems really good. also there's a guy here working on an approach based on context managers: http://www.reddit.com/r/Python/comments/p9ehc/inviting_and_accurate_introduction_to_python_for/c3o5ooy?context=3
&gt;ability to format shell commands with placeholders, such that variables are quoted to prevent shell injection attacks This is difficult to get right. The most effective solution is a character whitelist, but this obviously restricts functionality. I didn't see whether you had code available. Is this in source control somewhere?
I would say bottle is the simplest framework for a beginner. It is a bit less magic - being a single file and all. The same hello world in bottle is from bottle import route, run @route('/hello/&lt;name&gt;') def index(name='World'): return '&lt;b&gt;Hello %s!&lt;/b&gt;' % name run(host='localhost', port=8080) I agree, Pyramid has more to offer than bottle, but for a beginner, I would recommend bottle.
Interesting. Wondering how it compares to https://github.com/SurveyMonkey/CheesePrism.
Sweet! https://bitbucket.org/gutworth/six/changeset/b03015ec9fa9
Yeah, I probably shouldn't have used the word "magic". It might be fair to say that the less code you have to write in a framework, the more magic it has behind the scenes. But I don't think bottle hides too much from the beginner. And it doesn't hide http. It supports http verbs and headers. It makes it simple to do simple things (simple is better than complex). A beginner shouldn't need to init a Configurator and add routes and views to it. I would even say that a beginner, that has to think in terms of viewsand renderers instead of data returned in responce to a request, has a much larger hurdle to understanding http.
&gt; Why? Because it is a hurdle. &gt; Why draw the line there, and not somewhere else? There is no objective reason. Someone else might come along and explain to me that bottle is too complicated for a beginner. "A beginner should not have to know about hosts and ports", he might say. And I would answer "No! We must draw the line somewhere. Someone who is not willing to learn about ports should not do http." (And, I would be right, I figure.) But I think that bottle draws a good line. It doesn't make the complicated things go away. It just doesn't make any more complicated things to worry about. And it might not turn out to be a good line. But I figure, that a once-beginner that started with bottle, will find out that he wants to do more than bottle can do for him. And he will find that bottle projects are difficult to maintain when they grow too large. And he will go looking for a more full-featured framework. But he will go looking with an understanding of handling routes and methods and parameters. &gt; The extra minute or two required to get a superficial understanding of what the boilerplate of any given framework is there for... I think we are thinking of different beginners. I would not consider anyone, who can understand the concept of views in two minutes, a beginner. I'm thinking more of someone who is learning to program (variables, loops, methods... you know - the basic stuff) and is motivated by writing webpages. I guess you might be thinking of someone, who is a programmer already and is a beginner to python?
Bash is domain specific, but in my experience the benefit gained by that does not outweigh the drawbacks. SQL is domain specific too, and there is a reason why people use ORMs instead of raw SQL. Once you get to a certain point (I'd say once you need to do anything more complex than a loop or a condition), where writing and maintaining python code pays you back **so much better** than writing it as a shell script. It allows you to write real software (using things like modules, OOP, FP, decorators, introspection, docstrings, unit testing, etc.), as opposed to a bunch of imperative shell scripts. Once I came to this realization, I made a rule to myself to never write a shell script again. I have come pretty close to that (using fabric, subprocess, argparse, and the std lib instead), and I don't miss writing bash at all, even for small/quick tasks.
I think a lot of python frameworks do well in the hello world competition. The differences really blossom if you go through their tutorials. This is why I haven't yet been able to break into RoR - because it pukes on trying to go through their step by step tutorial. Django has a good tutorial and so does flask. I will *not* jump to conclusions and say pyramid is hard until I go through its tutorial. Web2py has a great tutorial but deployment outside of something like fluxflex is non-trivial.
Yeah so you just save the art as folder.jpg or whatever is in the too at list, k. Makes sense =)
It's helpful for everyone to know where a source of truth is coming from. Bottle and flask are more for programmers who know that the source of truth is *somewhere*, knowing they can probably change it later (ie Flask app object). Often when working with beginners I notice they want to know "why?" I'm not saying pyramid's solution is best, but having an explicit "configuration" of sorts is great. You can point it to them and say "this is where you display your intention to a the software." It gives the user a base from which to start, and provides an example of good design (separation of interface and implementation).
I mentioned `pbs` in my blog post. As I said, it's probably fine for some scenarios, but I don't find that wc(ls("/etc", "-1"), "-l") is more readable than call(“ls /etc –1 | wc –l”) in the general case. I'm aiming to make Posix-like command-lines available without having to do `shell=True` in more situations (e.g. on Windows, with support for `&amp;&amp;`, `||`, `;`, `&amp;`, `|`, `|&amp;` ). Andrew Moffat's approach is definitely different to the usual - nothing wrong in that. My approach is more evolution than revolution, I'll admit :-)
A character list (or a regex based thereon) *is* being used. The project is under source control but not yet released - I released the docs first, to get feedback about the proposed API and feature set. The approach used for shell quoting is similar (but not identical) to that used in Nick Coghlan's [shell_command](https://bitbucket.org/ncoghlan/shell_command/src/4334e1db26bc/shell_command.py#cl-12).
Have you come across Kenneth Reitz's Envoy? https://github.com/kennethreitz/envoy
Sure, I mentioned Envoy in my blog post. It has some of the same goals, but is not (IMO) as far along as `sarge` is. Just compare the documentation to see the feature sets of each. I've also looked at Anh Hai Trinh's [extproc](https://github.com/aht/extproc) project - some nice ideas there.
Here you go: http://www.reddit.com/ad_inq/
http://amon.cx/
thanks, I agree that nested commands don't look so good I think it would've be better a chained sequence like `ls("/etc/", "-l").wc("-l")` but regarding your approach I think it has the same problems as subprocess, you have to type the commands as strings.
From my notes... sudo python setup.py build sudo ARCHFLAGS="-arch x86_64" python setup.py build sudo python setup.py install For the package in question, the magic is in ARCHFLAGS, I'm not sure what values you're going to need however. 
&gt; what happens with subprocess it makes you write the shell command as a string instead of abstracting it. No, the abstracting happens at a higher level. See the [python-gnupg](http://code.google.com/p/python-gnupg/) project which I maintain: the abstraction is a class called GPG, which offers an [abstract interface](http://packages.python.org/python-gnupg/#getting-started), with the implementation (under the hood) using `subprocess`. At that implementation level, you need to work with the external program directly (e.g. setting arguments to control its behaviour, sending it input data, capturing stderr and stdout and interacting with the child process based on the data sent over those streams), and it's there that you sometimes wish for additional conveniences over what `subprocess` provides.
Thank you! That worked amazingly, it fixed the architecture problem (I had to type "sudo env ARCHFLAGS="i386" python setup.py build" specifically if anyone else runs into this problem). However, I am still getting this error: Traceback (most recent call last): File "RobotArm.py", line 1, in &lt;module&gt; import ode ImportError: No module named ode Do you have any idea how to get Python to find the module?
they think it is hard because they are afraid of the lines beginning with `if __name__ == '__main__':` for many, `python manage.py runserver` takes care of that.
Well this is creepy. My monitoring box at work, which I've had running for the past 2 years, is named amon (named after [Amon Tobin](http://www.youtube.com/watch?v=HAX3m6KXgu8))
@mdipierro, thanks for continuing to build (and champion) your web framework. I attended the dojo you gave at PyCon a few years ago and it was very enlightening. Is there any good documentation out there for scaling a web2py application? Say in the (unlikely) event that I write the next Facebook or Twitter app... Do you have any success stories of apps scaling up to handle hundreds of thousands or millions of users?
I assume you want http://pyode.sourceforge.net/
thanks. there is something on the topic in the book: http://web2py.com/books/default/chapter/29/13#Efficiency-and-scalability You scale it using a load balancer. The problem as usual is database bottleneck. We do have experimental support for mongodb in the dal.
Nevermind, it's actually still not working. Same issue as before.
it's a drawback because by treating the command as a string you're not integrating it into the language, that's the only reason doing shell from python is awkward. the string is flat, you should be able to operate on the command and it's args as any other python structure along with the results.
this is a good example, it doesn't matter how you deal with it internally, it should have a useful interface and that's what the things built on top of subprocess should give you same as the ORM does.
I think the writer of the blog post is making a pretty naive statement about how easy Pyramid is for a beginner. I definitely agree that tutorials are more important than the basic hello world example. I went through all of the Pyramid docs back when it was first released and through the 1.1 release (coming from a Django and Java Spring background - also had read through documentation for Web2py, Groovy, and even Drupal). The documentation was very good and thorough but had some problems that I think make Pyramid a poor choice for beginners (beginner == not much experience with web development): * The tutorials *at the time* felt a bit lacking. I didn't feel like I knew how to make a good Pyramid web application just by going through the tutorials. * The documentation, meanwhile, is very thorough and you really understand a lot of stuff by reading through it. The problem with this is that I can see beginners going through the docs and being overwhelmed by the detail and choices presented by Pyramid. So even though Pyramid is super flexible, which is a great strength, that flexibility makes it tough on beginners because they have no prior experience on which to help them answer the question: "This is the right/best way to do X for me." * Ideally, there would be a middle ground between the tutorials and the documentation that restricts the number of choices a beginner has to make. This would allow beginners to focus on learning the framework while keeping in mind that if something doesn't work for them now, there is surely an alternative provided in Pyramid. The various paster templates (at the time I think I was using routes_alchemy) is supposed to solve this but the documentation for using those paster templates weren't very good. This could have changed by now as I remember something called Akhet that was being worked on and could fit into this stepping stone role. * Finally, if you use hello world as a comparison and have read the documentation, you'll realize that Pyramid does not have a single definitive hello world example. There are a couple different ways you can do the hello world example in Pyramid and they would all be valid. If he had posted all of the ways you can do hello world in Pyramid, then I think he'd realize that hello world programs are not a good judge of beginner friendlyness. Having said all of that, I wouldn't tell a beginner not to try Pyramid if that is what they want to learn. It will teach a lot; however, be prepared to consume and digest a lot of information.
Why did pypy segfault?
I think Samus_ has a good point, but at the end of the day, I'm with you. If I want to run some shell commands in Python, I want to type them as a string and be done with it. The current subprocess module is a bit of a pain in that regard. (Namely when you start piping.) I think you're doing great work so far, and if I ever need to run non-trivial shell commands in Python, I'll likely use your module.
I've spent a significant amount of time reading the Pyramid doc and am working on putting together a first project. They say that the best way to choose a framework is to choose the one that "fits" your brain. Pyramid does exactly that for me. On the other hand, although it's very thorough, the documentation doesn't fit my brain quite as well. I have have half a mind to give another take at preparing a narrative documentation, for those at my level to work from. Not sure I'm up to it though. In any case, I think it's a very worthy project and I'd like to see it continue.
Stdout, stderr readable and usable as iterators (generators in some cases). My pain point with subprocess is that you don't know if you're getting a single line as a string, which you can iterate over character-by-character, or a multi-line file descriptor which you can iterate over line-by-line. I should never have to think about it. Until stdout/stderr is closed I should just be able to read line-by-line in a loop.
I've come across amon a few times already. Right now I am using [munin](http://munin-monitoring.org). Is it worth switching to amon? What would be the advantages I get? The point that's most important for me in munin, is that there are so many plugins available, and it's ridiculously easy to write plugins oneself.
Oops, found this message just now (sorry for the delay) I am not C programmer myself (just Python and Perl), my recommendations were just based on experience of my coleagues... 
I know, it's horrible. Luckily, someone has done it correctly with [Requests](http://docs.python-requests.org/en/latest/index.html)
The collecting agent in Amon started from http://code.google.com/p/psutil/ and https://github.com/boxedice/sd-agent If you compare the source code, you will see the similarities. Everyone is using native unix tools for these kind of operations
If you find an existing module needs backwards incompatible improvements, do you: * Leave it for years until a major release when you're breaking backwards compatibility. * Make the changes and make a backwards incompatible release for them, forcing people to update code or stay on old versions. * Add a new module with the improvements, and put up with having two names until a major release when you can unify them. I think the third option is the least-worst solution.
That thing doesn't take arrays, it's basically an invitation to shoot yourself in the foot with shell injection.
what's your solution (with the requirement that you maintain backwards compatibility)?
I use Python 3 exclusively, and I don't have any problems with it.
I agree with the larger point, but os.listdir(path) is probably a better way to get a directory listing in Python.
&gt; But it doesn't seem like python 3 gets seen much in the wild, and even the official python docs list python 2.7 above 3. Seems like no one's quite ready to move completely to 3. Reason is (or at least, was) that Python 3 broke reverse compatibility, which resulted in large changes that needed to be done to the code for stuff like libraries in order to use them on Python 3. Other issues too, obviously, but needless to say, it was easier for most people to stay with the 2.x line because it kept reverse compatibility. There was never real good incentive to change. &gt; But my main gripe is that at some point someone thought it was a good idea to create a module that does most of the same things that another module does, only in a slightly different way, and then call it module2. Right. It is ugly. I don't think any sane person will disagree with that. They had little choice. If they changed urllib to be more similar to urllib2, then people would have the same kind of reverse compatibility issues that Python 3 is having now. Nobody would bother adopting whatever 2.x decided to change urllib because the libraries they depend on, or their own software, requires that urllib behave a certain way and it no longer does. There would have been on good incentive to change.
Off topic but I wish Tarek could change his theme or use a [syntax highlighter plugin](http://wordpress.org/extend/plugins/wp-syntax/) for his blog as it's quite difficult to read (low contrast, black on white code snippets).
I'd say avoid httplib2. If a request times out, httplib2 retries it. This is not configurable. There is a patch available that would make it configurable, but the maintainer refuses to apply it.
Be assured: it is. I especially love the documentation, including the Quickstart and Tutorial section, thanks for that mitsuhiko :)!
I recently installed this and indeed I must say using Requests is a breeze and feels much more pythonic than all else I've tried thus far
Blah blah flask blah blah best blah blah.
Flask is excellent for beginners, and I find it's also excellent for extremely advanced use cases as well as it tends to get out of the way of what I'm trying to do. It's simple to use and although it has TONS of features it still feels very lightweight.
Hey Mits. Love your work. Use LodgeIt all the time. From a designer sick of the constraints of PHP CMS's standpoint: We are visual people who love pictures and screencasts. I'm sure if you put a lot of thumbnails in your doc and released a series of screencasts that people would flock to Flask. Also, real-world examples (blogs, stores, non-profit sites, etc. etc.) greatly help. People really just need to see good code written out very plainly and eventually something just "clicks".
How about we take a beginner (me) and tell him to check Flask out, and make some suggestions? Update: Started reading the docs, sent my first feedback (to improve sth) In general, the docs are very good, and the framework looks promising. More updates are coming. Update 2: Got to the end of the Quickstart. Sent a few more feedback about doc issues, otherwise I think it is amazing, and will use it for simple projects definitely. **Beginners Conclusion**: Yes, it is Awesome. Simple, easy and still powerful enough. 
It looks like a task you could implement using MapReduce, and use threading or similar to ensure you utilise all cores. Also, try to use stdlib modules whenever possible as many are in C and will run much faster. For text processing you probably want to get your head around collections and itertools. Avoid for loops whenever possible, it runs in the interpreter. count = map(sum(), iter) should be much better than: for thing in iterable: count += thing When processing large datasets, batch things up. This probably matters more for interfacing with other applications but its been observed that e.g. sending 1000 tokens at once rather than one token at a time results in saving a lot of expensive connect/teardown operations and significantly reduces your runtime. 
Flask is my go-to-framework for just about anything webprogramming-related with python. Thank you for making it (and especially the documentation!) so awesome, mitsuhiko :-)
You can set the ARCHFLAGS enviroment variable for that: export ARCHFLAGS="-arch i386" Or do it inside the Python code.
It is possible to support Python 3 and Python 2.4, especially with a tool like [six](http://pypi.python.org/pypi/six) to help you. It's just more work than if you can assume Python 2.6 as a minimum. I think a lot of major modules won't wait until 2017 - e.g. Django is dropping Python 2.4 support for its next release, and is looking at dropping 2.5 support - and supporting Python 3 - for the release after. It's a three-way trade-off between the users still on old versions of Python, the users who want to use Python 3, and the extra effort to support both.
you can consider learning virtualenv and pip
See [here](https://github.com/svenstaro/flamejam). I run it [here](http://bacongamejam.org/) for [this](http://bacongamejam.org/subreddit).
&gt; a pyramid app can be done in one file too I think that he tried to say that the bottle *framework* is one file.
I disagree. Provide some concrete points that are too complicated. Also why wouldn't you use Flask? It's good even for big projects.
You are comparing apples with oranges. The web2py deployment page is not the equivalent of the flask deployment script. The equivalent of the deployment script does not exist. In fact web2py runs your code, while in flask your code imports flask. Here is how you start web2py: wget http://web2py.com/examples/static/web2py_src.zip unzip web2py_src.zip cd web2py python web2py.py -a 'chooseapassword' open http://127.0.0.1:8000/admin Then login and start typing in your code in the browser or do it from the shell cd applications mkdir myapp cp -r welcome/* myapp echo "def index(): return 'hello world' " &gt; myapp/controllers/default.py open http://127.0.0.1:8000/myapp The web2py deployment page is about interfacing/configuration with production systems, optimization tricks, setting up a load balancer, etc. A new user is not expected to start from chapter 11 of the book. Start from chapter 1.
Flask is Awesome, period. I used it for my GSoC project for OpenICC.
Hey, mitsuhiko. Firstly, awesome work on Flask. I love that you can use it for tiny apps or legitimate sites, and it's very easy to get into. My problem is with [Blueprints](http://flask.pocoo.org/docs/blueprints/#blueprints). The documentation of them is rather limited in actual examples of what they're for. I understand *how* to create them, but the documentation is lacking as to *why* I would. Are they like Django apps where you can separate your site code based on functionality? I tend to learn best when I have real-world examples, and Blueprints are one of the things about Flask that I haven't been able to really "get". I've also been trying to figure out a good way to structure larger projects. I think if there was one thing I'd like to see, it would be an example project structure with multiple blueprints and an app. Thanks for all your hard work with Flask and its extensions!
Those are some nice points, I guess I supposed that the conventions we have gotten used to thus far are about as intuitive as some of the adjustments we would have to make on the other end. In terms of the day changes in the financial markets, I have a suspicion that we are moving more and more towards books that don't really close anyway. Many large banks are already doing this by having their books just get handed of around the world. A bank I worked for, if you missed a deadline for parking money overnight, it wasn't nearly as bad as it was in the past, cause it just meant a bit of a hassle in having Asia take on the funds (for a fee of course, but at least it didn't sit.). Will be interresting to see what happens, but think it won't be in my lifetime anyway. 
That's great if you have shell access, but not all shared hosts will give you that. @so4h2: you need to find out a little more about what your hosting provides before you can get a good answer to this question. Most likely your host provides Apache. You need to find out what modules the host supports for Apache. Most likely they support FastCGI, maybe Flup and mod_wsgi. Any of those would let you run Bottle.py and I think Django, although not at top performance under FastCGI. Maybe you could tell us who your hosting provider is?
ty all for your kind answers, I expected some scorn. But I gotta go now, i'll be back soon. My host runs an apache server, that I know, but not much more. Its a shared hosting in Spain, I think from Seville, of all places... I'll try to find out about shell access, but I suspect not, because when I asked for mysqldb module I got a dry no.
Flask isn't just excellent for beginners, it's amazing for prototyping or even throwing together a quick web interface for practically anything. I can't tell you how many times I have blown away my co-workers by how quickly I can get a "working" web interface thrown together in Flask...and since they're all PHP fans, it's also a +1 for Python too :-)...You're doing an awesome job Mits. There would be some things that I would suggest to help Flask gain more popularity, and that is to do some screencasts. Maybe an entire tutorial set, but make it fun. I remember when you did the funny screencast with the Dutch dude pretending to be French (back when flask was an april fool's joke). I think that would be pretty funny :P 
a "simpler" web framework, so you can write dynamic web pages in python. I suggest looking at bottle too.
Last time I needed a tiny framework in python, I ended up picking [bottle](http://bottlepy.org/docs/dev/). Can somebody else who went bottle vs. flask, and end up choosing flask explain why? edit: added url to bottle
It is. As a novice, I was able to code up a couple of projects that interface with my Asterisk server. (This was a year ago) The only problem that I ran into was WSGI related. I couldn't wrap my head around getting that to work sanely. If memory serves, it was related to using dynamic paths of which nginx/apache got confused if I hadn't explicitly defined the url path. Anywho, I found uWSGI and it worked fine.
Biochemist by training, teaching myself bioinformatics becase coding is fun. Flask is really really great. I use it for _everything_ I do on the web now. Anyhow, I made this site to look for enrichment of biophysical properties in high-throughput datasets. Working on getting it published now. [code](https://github.com/jwinget/CARPY/blob/master/carpy.py) [site](http://iplusfour.com/carpy) [sample "Experimental Group" gene list](http://paste.pocoo.org/show/546849/)
Love flask. I've written some small apps that work great. I've replaced some Rails apps with much simpler flask apps. Keep up the great work.
It is an awesome framework for making web applications which scale. 
http://en.wikipedia.org/wiki/Flask_(programming) Half way down the page lists example sites.
The example I link to frequently nowadays is this one here: https://github.com/mitsuhiko/flask-pastebin It's a really small app but uses a facebook auth, websockets via juggernaut and a database.
&gt; I know Flask was never designed as a asynchronous framework, but what are the plans, if any, for websocket support? WSGI itself does not really support it but there are some extensions for it. I hope to be able to bring up that topic on the web panel at pycon this year, now that the specs are fairly stable. That being said: the majority of tasks people want to use long polling / web sockets for is basically just push notifications and for that I kinda like juggernaut or stuff like that for the time being.
[kennethreitz](http://www.reddit.com/user/kennethreitz)
&gt; *WSGI itself does not really support it* Ya. No kidding. A lot of what I have to do is a mix of synchronous interaction (classic query/response) with static resources and asynchronous interaction with "live" sources (ie. real-time data feed). Being able to integrate them in the same application is important. As well as avoiding all the cross-domain annoyances on the browser side. For what we're doing, think more like, "shared DOM", not push. I look forward to what you have to say at pycon. 
http://flask.pocoo.org/docs/patterns/ Is pretty useful.
I found with blueprints they *are a great way to divide up larger apps. http://flask.pocoo.org/docs/patterns/ 
consider heroku, they support python now 
Ahh I've no idea, just posting example sites. :/
I currently use django for my web development. Persuade me as to why I should use flask over django?
that's all true, but it has nothing to do with it's interface to mod_wsgi which you described as easy. that's what I'm asking.
Oh! Sorry, I didn't realize what you were asking. I meant that they have an easy tutorial, I guess. There's not really anything specific about their interface that makes it easier. Sorry for the misleading comment, there.
Point #1 is fair, since RHEL still only supports Python 2.5, but Python 2.6 (the first version shipping json in the standard library) was released in October 2008. Not exactly bleeding edge. Point #2 I would just add one final option: "15. nothing (with mod_wsgi under Apache)". Bottle is a WSGI app, and doesn't need any additional dependencies if deployed on Apache with mod_wsgi.
I was debating on Flask and bottle for the display portion of my photobooth. I ended up using bottle because I just needed the bare minimum to serve a couple of pages locally.
It's an open source project without commercial interest. If you're happy with Django, stick with it :-)
*head explodes*
I usually learn by example so I dl'd Catonmat.net sec code (that guy is real good), the code is overwhelming. I like how he changed the routing to make it more readable I like flask routing but the views become tiring to find if you have a large number of them (I was not able to understand blueprints)
Thanks for the quick response django is also open source but I was just wondering if you had some more specific arguments.
Or you can subclass httplib2.Http and reimplement _conn_request to remove the retry... That the maintainers refuse to apply the patch is crazy. I can see retrying GET, but POST? Broken.
That's right, I didn't mean this performance wise. Rather, it is very expressive.
The last testing phase revealed that my choke point is still the data layer. Meaning that considering the free quota and the pricing, that is the one which will cost me the most on the long term. I've done some optimizations since, but I still think that will be my main issue with GAE. As far as I am aware, this will be free (or, rather, store quantity based) on EC2, and the number of writes and reads are free. Correct me, if I am wrong. (That's exactly what I am looking for :D )
Integrating ZeroMQ goodness and MongoDB in a stack with Flask is simpler (read less time consuming) than doing the same with Django. Even if I were smart enough understanding the Django ORM, I am to old to sink countless hours into that thingy. I think it's getting more and more important these days that you're able to scale your stack (e.g. with Mongrel2 at the front and MongoDB on the back) while still being able to sketch something quickly. So for me I guess it's the best of both worlds why I use Flask more and more over Django. I18n and l10n though is where Django rocks! Python 3 is a milestone I'd like to see happening this year, Django's Python 3 branch already looks quite promising...
Thank you, I'll check that too. (alongside heroku)
It doesn't matter if you're only writing completely new code. If you're trying to use or update existing code - your own or other people's - it certainly matters which functions have changed.
As someone with (almost) no background in web development, why should I look into flask over, say, Django, Bottle, Pyramid? 
I think this is great feedback, but I'm not sure it's best to come from the Flask team. It really sounds like you need an active blog of someone who is learning Python and various design patterns. I'm planning on building an auction service in Flask in the near future. Is that something you'd be interested in reading about? I blog all the time - internet marketing is a passion of mine - so starting a 43rd blog isn't a big deal for me :)
I'd like to point out here that there is a Flask subreddit: /r/Flask I'd love to see it take off, as there are less than a single page of threads there now.
Definitely. Although some "official" stuff would be nice, like discussions of best practices and so forth...
Webfaction.com is a great shared hosting option, complete with 'one-click' Django installer.
I haven't found being limited to Python 2.6 in production to be a problem for any libraries I've used in software I've written, but that will change in another year or two with Python 2.4 support largely dropped from third-party libraries now and others with their sights on dropping 2.5 support (if they haven't already). I see few immediate practical advantages to migrating to Python 3 unless you're working on something that is going to become a legacy application (e.g. it's going to be in use well after 5 years from now) and involves a lot of code/complexity that would make migrating from 2.x to 3.x later problematic. Third-party libraries are still a bit of a problem too for non-trivial applications, although support there is improving over time as well, and maybe you don't need many for your app. There is a lot to be said for personal preference and the ability to choose. If you want/need another Python version and are willing to take on the associated responsibilities (security/stability), go for it!
no it doesn't, if you're upgrading from urllib to urllib2 then that's all, you use urllib2 and don't care about functions being imported from urllib.
I belong to the kind of people that pick stuff up faster when reading examples. In that regard the documentation is kind of lacking. It got lots of explanations and small snippets of code (and in that regard, the documentation is wonderful). But what I am missing is some kind of all-thrown-together example. 
It does integrals. I haven't really tested all its simplification capabilities. Expressions have a .simplify() and a .combsimp() the .combsimp() is supposed to work on complex expressions. For instance factorials: X!/(X-2)! should simplify to X * (X-1) = X**2 -X.
Django has a list of Django-friendly web hosts: [https://code.djangoproject.com/wiki/DjangoFriendlyWebHosts](https://code.djangoproject.com/wiki/DjangoFriendlyWebHosts). I ended up going with A Small Orange and have been very happy so far with their service. I followed one of their [wiki articles](http://wiki.asmallorange.com/HOWTODjangoVirtualenvFcgi) and after a couple of support tickets, had Django up and running.
IMHO, you should share this as a page on your site rather than a PDF.
Then it wouldn't be a cheat sheet, now would it?
Python is not going to be well supported by cheap, easy hosts - that's all there is to it. PHP is great for that because it executes anything with a .PHP extension happily, and everyone supports it.
Even retrying GET is problematic. In our use case, the main reason it times out is that the resource is computationally intensive to create. If it just sends the request again, it doubles up the computationally intensive processing. 
I think Flask is great! I'm new to both Flask and Python, and really appreciate how easy Flask makes things like routing and sessions.
I wish it only had multi server support, I'm sooo hacking that web front-end to support multiple amond installs.
I deploy flask applications with uwsgi. It's fast and easy to configure: definitely something worth checking out.
Why would you downvote this?
For all intents and purposes, no SSH/shell access == no framework. When you've gotten yourself some real hosting, come back and talk to us later.
Agreed. That was painful to watch.
I changed from "requests" to "urllib3" for thread safety. I liked "requests" API very much. Is there any plan to make it thread safe ?
Rackspace Cloud is cheaper than EC2 (at least for the smallest instance). Honestly though I'd probably just stay on GAE for this app; you can worry about the costs after your traffic gets high enough to leave the free tier.
How would I buy your books if I don't have a Kindle? Would you accept paypal and send me a PDF?
That is probably what I will do. On the other hand, I want be prepared to move if needed. Also, thanks for pointing Rackspace out, I'll check that too.
And about 70mb unzipped.
You like MongoDB, have a look at the new kid on the block then https://github.com/sbook/flask-mongoengine :)
The docs could link to these services though, if they aren't already.
I guess it could be something related with [this](http://www.reddit.com/r/Python/comments/ou7uw/14_out_of_25_items_on_this_subreddit_should_be_on/).
Basically, he said he didn't want to change the default behavior and closed the issue. Someone created another ticket encouraging him to leave the default behavior as it is, but integrate the patch to make it configurable. He marked that ticket as a duplicate of the first one and closed it. He hasn't specifically addressed why he won't make it configurable, but those of us who care have tried all the avenues we can think of to get it integrated.
It's a good choice for beginning with Python 2.x as there is not Py3 version yet.
I use Flask for our RESTful API, and I am delighted with it so far. I used web.py before (also an excellent micro web framework) and one thing I missed in Flask was a MimeRender equivalent. So, I went ahead and wrote a port, which is available on github by the way (https://github.com/nicolaiarocci/mimerender_flask). The documentaion I found to be good, but I'll admit that I didn't pay too much attention to the Blueprints section (which, at first glance, seemed a bit vague indeed) 
I believe Flask is set up to serve static files by default at /static/, but I agree - it's not a best practice, as it requires the overhead of running Flask for each static file request. Ideally, once I get this working, I'd move static files to be served by IIS directly with a Virtual Directory. I don't believe that this is the issue, though, because my URL mappings aren't working either. If I use the decorator @app.route('/foo/') then go to http://localhost:8080/foo/, I get a 404.
Yes! I did read your post. I also saw that you found lack of documentation about deployment on various PAAS sites an issue. So therefore I suggested that maybe you could help improving the documentation. After all, you were able to figure out how to deply on dotCloud, so why not make it easier for other people too...
Starting with Flask is fine and it actually hides most of the low-level WSGI stuff.
Should we propose this to the author?
I finally resolved this problem - I installed Apache and mapped it to port 8080. It's running just fine alongside IIS.
But as a beginner, would you recommend I start by learning the low-level stuff? 
You should know how HTTP works (things like error codes, headers, methods, ...). But WSGI - I don't think you actually need it apart of how to get your Flask app working with different web servers. I haven't run into low-level stuff myself with Flask though.
This is really interesting. One note: That chart at the end with times mirrors reddit's daily traffic, so it probably doesn't mean much other than submitting when traffic is high gives you a better chance of getting more votes.
Is there a way to use MySQL's SQL_CALC_FOUND_ROWS with the web2py abstraction layer? I googled a bit but didn't have much luck.
The exception is `urllib.urlencode`, which as OP says does not exist in urllib2, only urllib. That's a wart removed in Py3k though.
It could be used to automate /r/circlejerk!
web2py dal does not support it because is database specific yet it would be easy to add support with a minor change to dal.py. Please open a ticket in google code, I will discuss with other developers and probably implement it in a couple of days. Basically we need to overload select_limitby in MySQLAdapter and replace "select ..." with "select SQL_CALC_FOUND_ROWS ...". You can then use db.executesql("SELECT FOUND_ROWS();") to retrieve the value. I need to understand whether this causes any slowdown if made default behavior for limitby.
Yeah, I've only been using it for a few weeks now, but it's pretty nice using supervisorctl to manage various processes.
When plotting the words, you seem to have used only the number of submissions to rank them. Using the number of upvotes, downvotes or total votes would be better. For example, "best" might simply be a more commonly used word in general, and not just on successful submissions thus contributing to their success. Counting total votes for submissions containing them might reveal, for example, that "best" is used in many lower-scoring submission, while "worst" might be used in very few of the top scoring ones.
Upvote for beautiful soup. I've used it to scrape some classic asp web reports and it works well. I'm a python beginner, btw, so it must be super easy. 
No worries, great lebowski =)
It's just using a dictionary, so any reasonable password should be safe.
I know what web2py is and I know that you're the original author. If you make a post like this, at least mention that. It comes off as disingenuous when you don't. That's the only point I was trying to make. (I upvoted you BTW. I guess I don't understand reddit as well as you do)
Unbelievable - dscl just prints out password has for any local user. WTF. UPDATE: It only prints out if dscl runs as root, otherwise shadow is omitted. Nothing to see here, on any system root has access to password hashes.
I'll do a followup and normalize by reddit's submission rate so you can actually see the probability of front paging.
You're somewhat correct though it really isn't a package, it's more of a recipe so it should "just work" regardless of the reddit api version. Doing the setup.py thing might have been overkill for such a tidbit.
 * Reboot into recovery mode * Open Terminal * Type "resetpassword" and hit enter * ??? * Profit
I heard CCP likes stackless python very much for developing eve online. And eve online seems to have the same usecase.
I second this approach. You probably don't need to scrape the web page. You simply need to POST and get the resultant DAT file. I would recommend testing with "curl" or with "requests" (as opposed to urllib2), and following the 4 steps listed above. Do the POST, and see what comes back. Pretend to be a web browser, using "requests", and see if you can emulate the browsing experience programmatically. Be careful not to trigger any sensors by retrieving it once per second, or something. And maybe check out the terms of service, if you plan to use this commercially - I bet that this is data that they will sell you, but not give you.
Yeah, though at the same time, for someone new looking at your code, they might not immediately realize everything in the 'reddit' folder is a separate library. Also you can specify a specific version in the `pip install` command which could alleviate that problem.
Oh god, mixed tabs and spaces. I had to do research to find out why this doesn't give an error: if len(sys.argv) == 3: # If dictionary file specified [SSSSSSSS]print("Reading from dictionary file '"+sys.argv[2]+"'.") [SSSSSSSS]check(whoami.rstrip()) [TAB]passlist = open(sys.argv[2], "r") [SSSSSSSS]password = passlist.readline() It turns out python interprets a tab character to be identical to 8 spaces when it comes to indent. News to me. [edit] This code is bad in more ways still... It fails with a NameError when not executed with root privileges (NameError: "name 'digest' is not defined"), overwrites built-in datatypes as terremoto has pointed out... *cringe*.
+1 gevent
Ok, so why would I write properties? Some real-world example.
* Reboot into recovery mode * Open Terminal * Type *\`python -c 'print "resetpassword"'`* and hit enter * ??? * Profit Better? 
Oh, meant my comment above to be in reply. Balls.
Why do you limit yourself only to Django and flask? There are Tornado, web.py, bottle, brubeck as micro-frameworks and major ones such as web2py, pyramid like Django. For example I'd use Django if I don't want to bother with form validation, or user authentication etc. I personally like Django's approach to CSRF.
This reminds me of what is [supposed to be possible using WSDL and SOAP services][1]. The WSDL definition describes the interface along with the data types used. From there you can use your favourite library to generate a stub client implementation in whatever language. And the few times I've had to deal with these systems I wonder why they couldn't have just written some proper documentation: a good overview so you can get an idea of the major parts and what they are supposed to do; a detailed description of all those parts that says exactly what is expected and what happens when the unexpected happens; and some code examples showing how to do the common operations. The article is describing a non-XML protocol, so WSDL wouldn't work. But we also have [BER][2] and [Google's protocol buffers][3]. Protocol buffers will [generate bindings for Python][4] and other languages, while for BER we have libraries that make it easy to [model a definition and convert to Python types][6]. I am sceptical that the article's approach is better than the existing alternatives. [1]: http://www.ibm.com/developerworks/library/ws-soap/ [2]: http://en.wikipedia.org/wiki/Basic_Encoding_Rules [3]: http://code.google.com/apis/protocolbuffers/ [4]: http://code.google.com/apis/protocolbuffers/docs/pythontutorial.html [6]: http://pyasn1.sourceforge.net/
You don't have any idea what you'll be doing with the site? The previous thousand "web frameworks wtf" questions didn't help you?
It's not 'better' than ASN.1 or Protocol Buffers, it's different. Both ASN.1 and PB are generic solutions to solve a wide array of problems - using a custom protocol format is a specific solution to a specific problem; the upside of that is that you do not have to make trade-offs or have features that you don't use complicate your models. I've not used BER, but Google Protocol Buffers is nice; however adding the Java library to the J2ME midlet would be an issue even if it would build (which, while I have not tried, I suspect it won't).
I can vouch for using Django for web-apps that are not blog-like being restrictive. I've been doing it for four years -- not of my own decision -- and I've had to write some custom framework code to get it to do the things I want.
Instead of Flask, look at Pyramid which similarly allows you to assemble your web components. Agreed that use the right framework for the task. 
One other nice thing about properties is its compatibility with operators: With getters/setters: a.setX(a.getX()+1) With properties: a.x += 1 Properties are also nice in that you can apply a single docstring to the one property as opposed to having to create 2 separate ones for the getter/setter. Properties also provide a nice presentation of what is accessible in your class and encourages its use. 
Please use descriptive titles and avoid using ~ ° or whatever in it as some sort of "decoration".
Flask is my library of choice, because it's simple, the syntax makes sense, and it offers nice 'n' easy configuration and session settings. It also makes it very easy to use the template system and JSON for any server returns. I've used it for [QRustom](https://qrustom.com) and [stattr](https://gitorious.org/stattr), as well as a few projects I'm still not ready to release. EDIT: And I've used gevent (for stattr, above), but it was too troublesome. I'm definitely happy I switched.
It was close since they are very similar in what they offer, but ultimately you have to make a decision one way or another. The following points helped tip the balance in Bottle's favor: * The one-file package would make it easier to run it on an embedded system. * It also made it very simple to see exactly what was going on since you could look at the Bottle code as if it were just another file in the project. You could also easily monkey-patch the parts where Bottle provided some functionality but we wanted something else. * I preferred the minimalistic simple templating system which comes with Bottle over mako (Pylons) and Jinja2 (Flask). * It defaulted to using the built-in WSGI server so you wouldn't need to install CherryPy or Paste unless you wanted multithreaded performance. * I had no familiarity with Werkzeug, so Flask's family tree didn't work in it's favor (or against it). By the way, I think that both Flask and Bottle are fantastic projects, as well as Pyramid/Pylons, so don't read this as a criticism of any of them.
Wow, I could have used qrustom earlier today at work. I guess the colors have to be pretty contrasty for it to work though..
TIL that Japanese uses squiggly lines for placeholder text.
Gevent 1.0 beta is awesome. Now it has a threadpool which was one of the advantages that eventlet had over gevent. Still I wish it had support for tasklets and not just greenlets.
God i hope this is isnt for a quoting strategy..there is a significant delay. if your goal is to have a list of the current spreads in the market and leaps...pay for NBBO stream or pay for bloomberg.
&gt;And I've used gevent (for stattr, above), but it was too troublesome. I'm definitely happy I switched. This is the first bad thing I've heard about gevent. Why didn't you like it, and what did you use instead?
Or ○○ or ほげほげ (hogehoge) for foobar
Whatever you do, since you choose Python, thus wsgi, so you must be prepared to spend your time thinking about deployment options, worker vs thread models, front-server, proxies, serving static files, environment configurations and so on and so forth. Then you must think about packaging. It will take you far longer than it takes to write a simple web app in flask. 
when you want to find other people to work on it. People focus too much on the technology; at the end of the day, you're never going to find something perfect, and there's always going to be stuff you have to implement yourself that you don't want to. Django has a good sized community, which is a big asset. There's also a big ecosystem of reusable apps, but to be honest the only one that I've found that I actually consider indispensable is [south](http://south.aeracode.org/), the database migration tool.
Bingo. That's the entire point of having shadow passwords; `/etc/passwd` remains accessible to all users, but the actual hashes are stored in the shadow file. [Wikipedia](http://en.wikipedia.org/wiki/Shadow_password#Shadowed_passwords) on the subject.
Yeah, that's a severe problem we've had in testing. It's also difficult to do masking on the corner anchor elements--we usually override the corner shapes when we mask, to make sure that the anchors aren't messed up.
Look at the built-ins. If you need most of the components, then use that framework. If you are going to have to rip stuff out or do more than basic customization, then use Flask or other "microframework". If you want to fully understand your codebase, maybe just use the standard library. edit: I mean this as an exercise in understanding.
Personally I'm not a big Django fan, it try a bit to hard to enforce a certain way of thinking an structuring that I don't like. I would try to build a subset of your application with two or three frameworks, and see which fits your project best. There will be cases where Django is simply the best and easiest solution, sometime it helps that the WSGI layer is really close to your own code, which makes certain other framework a better choice. Other than that, there are a lot of good framework, just pick the one that fit your way of thinking of webapplication, but do pick one that at least a small community around it. 
Django has many batteries included...forms, orm, file/media abstractions, and an excellent ecisystem of packages
How I choose between the two: Django when you need to manage 'things', Flask when you need to 'do something'. 'I want to create a site where people can vote on beards.' Django. Users and the 'free' admin interface make building that kind of site easy. 'I want to create a rest API that mashes these two data sources together.' Flask. No ORM overhead, url mapping is easier (for me). 
largely size, scale and portability requirements.
Maybe a stupid/newb question, but what are the @property and @x.setter lines for? Taking them out seems to make no difference...
No, that's fine. The reason I asked was that I was never able to adequately make matplotlib or gnuplot graphs look good. I know some people manage, but it is an unnecessarily uphill battle. Don't apologize for using spreadsheet software for what it was designed for.
Which version of python are you using? Mine (2.7.2+) doesn't behave like that. *raw_input* always returns a string, while *input* tries to eval what is typed and therefore explodes when something non-pythonic is entered, such as a string without the quotes.
There should be one obvious one way to do things, except sometimes not so much.
I'm confused as to why this is news-worthy.
kaaskop42, you are absolutely right. I'm sorry I've been away working on another project, but looking closer you/toomuchoffeecoder are absolutely right. I will probably look into incorporating selenium into the process. Frankly, I am not surprised at all the way they structured this. I know they have a product where they are selling the quote data/data stream, but my needs were much more static than that (research project). All in all, thank you for the suggestions, I really appreciate your help.
Agreed. If someone wants to have some type-checking without breaking the duck-typing, I would say that a better solution would be to check if the object given has the desired methods.
Django worked well for me when I made http://bitbuffet.com/. Abstracting out a file upload as a ModelField was a big win.
Something else is happening. So at first x is actually assigned to the method, when you set x you change it from a method to a variable. See this code: class Props(object): _x = 0 #@property def x(self): print "get x" return self._x #@x.setter def x(self, x): print "set x" self._x = x props = Props() print str(props.x) props.x = 5 print props.x It returns the result: &lt;bound method Props.x of &lt;__main__.Props object at 0x82b510c&gt;&gt; 5 See how when you first print x it is a bound method, when you call props.x = 5 it doesn't call the print "set x"
There is a slight difference in your code. Try printing out props._x after that. Since you did not use the @x.setter line, rather than calling props.x() with the input 5, it overwrote the function x with the integer 5. When you printed it out, it read the integer 5, rather than calling the function x and returning the value of _x. The most noticeable effect is that x and _x no longer return the same value. Another caveat as a warning. If using 2.7.x, be sure to explicitly inherit from object whenever using properties. Otherwise, you will use old-style classes in which properties are impossible, and you will overwrite the function in the same way.
When you're designing the app and stop to think "man, this'll be easier to do with Django/Flask". 
More good info, THANKS!
That would be an interesting analysis. I'm pretty sure what you'll find is that the probability is inversely proportional to submission rate, but it will be interesting to see if the data bears that out.
Yes I agree too, having met similar problems in a large scale application. However Django helps me make a living, having developed more than 40-50 smaller scale projects within very decent timeframes. 
I like Django, but ultimately switched to Flask because I like SQLAlchemy more and the fact that it can use other libraries interchangeably. For example, I run a lot of command line programs using SQLAlchemy, so I know the library really well; doing so with Django would be overkill.
The problem with lighweigh frameworks are once you have multiple people and any appreciable turnover, you are going to waste a lot of time explaining (and debugging) your hand-rolled security, caching, content management, and admin features. With Django, you just tell them to hit the Django docs, or hire people with Django experience. Prototype with a ligher-weight framework. Working with Django is like working in Java. It's painful. But consider porting to Django when you realize that none of your staff are productive, because they don't understand your ad-hoc framework. Note, you can port gradually, due to the loose coupling of web projects - just start by putting in a Django admin interface, using URL plumbing to keep Flask and Django isolated. 
Thought so. One day I'll switch. Oh yes, one day I'll switch.
Exactly - properties allow you to upgrade old code to use getters and setters, without changing the old code. I can't think of any reason to start off using them. For new code, just use a get method - it's less magic.
PEP 3119 has a nice discussion about the limits of duck typing: http://www.python.org/dev/peps/pep-3119/#abcs-vs-duck-typing Checking types is really the only way to go sometimes.
gevent isn't a web framework, its an event-driven async I/O library, hence its relative lack of things a web framework should do.
Exactly! Which is why I hated using it for a web application....
I find Django quite simple and never find myself ever encountering dirty kludges. About the only argument against Django is not wanting that much code to manage.
Nginx does it all.
&gt; pre-built solutions that I can leverage *twitch*
Nice flair.
I was just thinking that my example would have been better written as def _set_answer(self, value): self._answer = int(value) Shorter, permits number-like strings, and still raises an exception for you when the value is of the wrong kind. Either way, I agree with you that checking types is necessary sometimes.
Sorry.
It's very simple to not think about cleaning data before running SQL statements with it.
If you think working in Django is as painful as Java or .NET, I think you're doing it wrong.
Derp. I think you're missing the point. Gevent does not handle anything web-related. However, it provides a (optional) WSGI server so that you can plug in your WSGI application. Then for every new request, the Gevent WSGI server starts a new greenlet, which runs your WSGI app for that request. It's not designed to provide web framework features because it's supposed to work **with** a web framework. You didn't have to handle routing and such yourself. The Flask object is a WSGI application, so you can [pass your Flask app to the Gevent WSGI server](http://flask.pocoo.org/docs/deploying/others/#gevent). As far as I know, Gevent can work like this with most Python web frameworks. (You can also run Gunicorn as your web server, which can spawn gevent workers, but I'm not sure what the benefit of this is yet.)
When I taught English, we would always say _nani nani_ as placeholder speech. The circle is often used in a manner equivalent to \* in English. "Oh sh\*t, I just saw her マ○コ."
Database wrasslin'
Google "Python decorator."
Hah, forgot that word isn't tech-kosher. I meant "synergy, vertically integrated 2.0".
Django if I want to plug things in. Flask if I want to reinvent all the wheels, tune the shit out of things, and have a feeling of utter control over my app.
Using the standard library for some basic web apps really is NOT a horrible idea. I really like Flask (though I have more experience with CherryPy), but you would be well served to build things from the ground up once and know how things work.
I am confused by your 'support Mac' requirement. Why do you need this if it is going to run on AWS?
Definitely, but I've seen it used as a placeholder and read as *naninani* too..
Hmm perhaps you could suggest a good complementary color when one has been selected
That's an instance where two third party packages don't work well together. It happens with any plugin architecture. I usually take that as my queue to find out why they don't agree, build it so they don't conflict, and send a pull request to both package maintainers. I hate that it reflects badly on Django.
I don't work there anymore, but I'll forward this to the team :)
Usually contributing is the best way to deal with this, or at least letting the author know where it stopped working for you. The greatness in Django is within it's core, yet it's future is in an unstable community of plugins. It's more of a community than a framework, the entire community is based around an app architecture that only makes sense in context with Django. Helping out is the only way to keep it going.
More importantly, it tends to be built in an extensible way. You can customize almost any aspect of it as long as you maintain the parent spec.
Good point, if you want to store in an rbdms you'll need to do that work anyway. Plus, it's not required. Better to say that when you use django it's kind of expected you'll use the orm. If you'll only be dealing with files, or are using an alternative storage backend, flask might be a good choice. 
for simple map reduce: * http://code.google.com/p/octopy/ or maybe just distributed queue with python support: * http://gearman.org/
Good to know. I stick with the default python install of my linux distrib out of laziness.
I've never looked at RPyC, but I can tell you for sure that multiprocessing will get you where you want to go, OP. What's more, you'll probably be amazed at how little code is needed to get there.
Just guessing, but he probably means for prototyping purposes.
Also, Dumbo from Audioscrobbler: https://github.com/klbostee/dumbo
What a great introduction to some of the magic behind PyPy. Well worth the read.
Can you be more specific about your jobs? It sounds like you just want a job queue (call a function with many different parameters and get their results back), not MapReduce specifically. MapReduce implementations can be coerced into doing such things, but it's not what they're for, so that's why they have such an impedance mismatch to your problem. [PiCloud](http://www.picloud.com) is a really nice way to just throw out a bunch of Python tasks without much preparation or overhead. You do pay a bit of a premium over EC2, but for one-off calculations, you probably make that up in developer-time that you don't have to spend setting up an image. Disclosure: I work for Enthought, and we partner with PiCloud to provide many of the binaries for the packages they provide in their Python environment.
&gt; Usually contributing is the best way to deal with this Yeah, "patches are welcome" is usually the standard response to anyone mentioning any shortcomings in a piece of open source software. But if you're using Django for "real work", after having made that choice because of the ready-made components available for it, then you just want to get shit done instead of spending an indefinite amount of time working on those components to get them into a useable state so that you can actually _get shit done_. 
Why do you think web2py is bad? (I'm asking out of total lack of knowledge about web2py)
I do know, what dirty means! The question ist, why the OP defames other frameworks than Django by ascribing them a "dirty" attitude?
Um.. Flask with its doc are on Github. Here's even an example of one of my [latest pull requests](https://github.com/mitsuhiko/flask/pull/394) containing small doc improvement.
Neat, I had no idea that multiprocessing had any support for multiple machines. Is anyone supporting multiprocessing these days, though? I've been a little reluctant to use it since Raymond Hettinger was saying that it was buggy and no longer well supported by its author.
Haha thanks, I guess it's a little outdated as I've been using the gmp library now but yeah before it was just so convenient in python.
I'm working on a distributed project myself right now. Thus far, RPyc looks like a terrific option - have you built anything substantial with it? I'm also considering Pyro. I've read mixed reviews on multiprocessing in distributed environments, but the main problem I have with it is that the doc is horrific, even by Python standards. I love Python, but it's core doc is terrible.
git push heroku master. Welcome to 2012 :)
can't afford.. :(
Came here to find out exactly what the heck he's doing in Python that takes 8 frikkin days... and why he's still using Python for the job.
Disco is really easy to setup. Everything is controlled from the master. If your nodes are deb based everything except disco can be installed via apt. Create 1600 files with the args to your command and fire off a job and push them up to the DFS (distributed file system). I have setup 8 node clusters by hand in under 20 minutes using VMs. Disco is by far the best solution. I think after 4 hrs you will have learned enough to get your prod job launched. You don't have to understand Erlang to use Disco.
Were you also at the SFPython meetup where he talked about this, or has he mentioned it on his blog somewhere I haven't seen?
Works great for me. This is standard stuff were talking about here. &gt; worker vs thread models, front-server, proxies, serving static files, environment configurations and so on and so forth Nginx is basically the best web server for all of these things.
And that has what do do with django? Django itself is about as good as it gets when it comes to a well built framework. The only time you'll see issues is with third party plugins, which i should add, are better than the plugin ecosystem of any other framework.
&amp;#3232;\_&amp;#3232; Also true in 2012 is that the clarity of Python makes it quite easy to learn and it's a powerful place to start.
So, this subreddit is so dry that we pushed to the front page some generic blog post doing a tiny critique from 2006 about an old ass Ziff Davis revenue generating post in 2006? In 2006, .Net was most certainly the language to learn and as Rails/Django was still fairly new, Python/Ruby weren't major hitters on the web yet. Ajax was certainly a technology that was new at the time that learning it would make you fairly "ahead".
Why don't you use [picloud](http://www.picloud.org)? import cloud def func(arg): #do lots of work ret = cloud.map(func, [arg1,arg2,arg3,arg4....]) Pricing can be had for around .05 per hour. So 100 on 100 machines should be complete in about an hour for $5 (this is excluding data transfer cost). 
no: carefully design and write your tests (1 window required, 2 if you have the spec open to write the tests), write your module (1 window required, you should know the spec by now), use `python setup.py develop` to install in a virtualenv (1 window required), run tests and fix module until it works (2 windows [console and module code] required, the tests are already frozen).
yeah boi!
Hmmm, you're already doing better than me. 300 SLOC program with wxWindows (and thus all the DLLs) comes out to 9MB for me.
It's a normal clown nowadays :) Pyramid learned from the things Zope did wrong (and improved) and used it's pros. Nonetheless, Zope is and will be a great platform to host large scale and/or difficult solutions. And if you look at Plone, you'll see a really good and extensible CMS usable for whatever you want. We use Plone (and Zope) exclusively because it match our needs (intranets, custom funky workflow) and AFAIK we will for the next years. When Pyramid has a good CMS layer we might consider switching, but mostly because it's newer.
My first suggestion would have been UPX, but you mentioned already that it didn't help. My next suggestion would be to try 7-zipping the resulting executable, but after just trying that I was only able to shave off about 100k. If you've really got over 5000 Windows machines, surely you're using some sort of group policy or software deployment mechanism? Python's installer is an MSI, so it shouldn't be difficult to get this deployed out to your machines.
The amount of time needed to get somwhere isn't a really good measure for pythonic. One could argue PHP is more pythonic, because it gets some stuff done more easily than Django :) Zope as a platform might be to big for your usecases, but all-in-all Zope (Zope2, Bluebream or Grok) is a great platform to work with. It outperforms Django (or almost any full stack application server) and is fairly easy to work with. Yes, we know zcml isn't the way to go, therefor we have Grok (convention over config), but we still allow to do what we want. If we need a random view, we can do that :) Of course lock-in will happen, it's just a matter of how much you would like to invest to get out of it :) We can (and do) use the Zope component architecture (http://bluebream.zope.org/doc/1.0/manual/componentarchitecture.html) in other environments then Zope. The ZCA is available for Django and used extensively in Pyramid. Plone and Zope still learn everyday on how a good framework should work. We adjust our code everyday based on real usescases and do not case about ego. We look around a lot and try to learn of what is practical and usable in today's solutions. Nevertheless, we try to get to a codebase that doesn't just solve your problems today, but will also do that tomorrow. That said, my view on python is what `import this` says :) And whatever way we can make Python better and more appropriate for your set of problem, is the way to go. 
 - I suggested that getting a plugin for Django to work in your project might be troublesome. - You suggested that contributing to those Django plugins would be a solution. - I suggested that working on Django plugins might not be what you want to do, when you need to get shit done. - You asked what any of this has to do with Django. Well umm.. Yeah. 
Maybe you can put a Portable Python [http://www.portablepython.com/] on a network drive? Then distribute the scripts together with a batch file or shortcut configured to use the networked location as interpreter. Or forget about distributing scripts altogether, just send out pre-configured shortcuts
Linking to a hack a day article that links back to reddit that links to youtube that links to Git. From http://www.reddit.com/r/Python/comments/pfcd4/web_game_bot_coded_with_python_hack_a_day/ -to- http://hackaday.com/2012/02/07/web-game-bot-coded-with-python/ -to- http://www.reddit.com/r/programming/comments/pb63q/speed_running_web_games_with_python/ -to- http://www.youtube.com/watch?v=V7UO53ajBc0&amp;feature=youtu.be -to- https://github.com/Audionautics/Burrito-Bot I just can't help but to think we are doing internet wrong.
###Perfect.
The installation documentation is buggy and is not meant for first-time users. I had a DSA ssh password and it expected RSA so it ask me something via 'ssh-askpass', but Macs don't have ssh-askpass so it only looped with an error message. (ssh-copy-id also doesn't exist on Macs). When I started "bin/disco nodaemon" I got the error message "DISCO_HOME is not specified, where should Disco live?". The setup instructions never say that that environment variable needs to be set. The check-if-it's-running command "ps aux | grep beam.*disco" needs to quote the ".*" grep metacharacters because as written it's interpreted as shell metacharacters. There's also no mention of running Python's setup.py. It looks like the "make install" step isn't mentioned in the documentation. Though if I do "make install" then I have to make sure "/usr/local/var/disco/data" is writeable by me. So, it doesn't come across as "really easy to setup".
&gt; run it on an embedded system. Interesting. could you please tell more about this project?
**tl;dr** it sucks, but you can get through it
I don't understand the motivation in writing a blog post about the sucky programming versus actually trying to improve it. Even if it's bad, a simple comment that the code could use some cleaning up would suffice. Just seemed so mean spirited. 
I would do the img search in python and use wget or curl to fetch the image (or urllib2 if python is a must). import lxml.html from urlparse import urljoin url = '&lt;your url&gt;' for img in lxml.html.parse(url).findall('.//img'): print urljoin(url, img.get('src')) And then pipe the script to wget: ./script | xargs wget {}
What tool do you use to convert it to SVG?
pipe that shit, thats rad
The reasons why a merge hasn't been put into the standards track is given thusly in PEP 3146: &gt; PyPy has good performance on numerical code, but is slower than Unladen Swallow on some workloads. Migration of large applications from CPython to PyPy would be prohibitively expensive: PyPy's JIT compiler supports only 32-bit x86 code generation; important modules, such as MySQLdb and pycrypto, do not build against PyPy; PyPy does not offer an embedding API, much less the same API as CPython. Although the Unladen Swallow -&gt; Python 3 merge was abandoned late last year as well.
Requests is 100% threadsafe. It uses urllib3 internally.
Nearly everything (if not everything) in the quote is significantly out of date.
I’m convinced it will. It will take at least another few years, but I think it will become the mainstream implementation.
If you're planing do go beyond image scraping you could use BeautifulSoup which is perfect for web scraping. Even though you gonna need only small part of it for image scraping.
Use the libraries urllib2 and urllib this way: * In phase 1, download the target page content * In phase 2, use regular expressions to extract all graphic URLs. * In phase 3, use the above URL reading tools to acquire the graphic images. 
How will it compare to cpython when it is running without jit?
Good point. A backend that emits LLVM would help bring JIT to many of these [architectures](http://stackoverflow.com/a/7297209/565259), those that are still competitive enough to be supported anyway. Come to think of it, just bringing the JVM backend up to date should be enough.
I'm developing on a single Mac with 4 processors. I want to use 3 for worker threads. One problem is the default hostname is assigned by my 3G modem. If I disconnect/reconnect then I might get a new hostname. With help of IRC support, I hard-coded cli.py:host to always return "localhost". I don't trust the assigned "c-2ec23ab8-74736162.cust.telenor.se" to last more than a few days at a time. Another problem is that I'm working through "make install" (which isn't documented; but there's no installation documentation which describes how to set up the Python library.). That sets things up for a cluster, and required 3 replicas. I didn't set my system BASH with all of the variables. When you say "noonish tomorrow", I don't think you knew that I'm in the central european timezone, so my noonish is different than yours. ;)
the question was about "mainstream". The long-tail architectures possibly remove pypy from "the only" python out there, but it's only affecting &lt;1% of users who can use whatever they please. Also AIX and friends only have ports of CPython (the patches didn't make it upstream I think).
badly, you don't want to use it.
I'm using Python to manage code written in C++. Specifically, I'm enumerating all subgraphs of up to 8 atoms of all publicly available small molecule compounds (30 million+ published structures from PubChem). It takes a while to generate all that data. Right now it's a combination of C++, Cython, and Python code. I could translate it to C++, but this is the sort of task of one-off task where if I learn how to use a distributed compute cluster then the $10 in CPU costs is well worth not having to spend several days to convert Python code into C.
FYI, I just registered "pythonaut dot com". I've got a busy weekend, but I hope to have the site up by Monday. I've already got a couple of articles rolling around my head ;)
Is there a reason to not do it like this? class rect: def __init__(self, h, w): self.height = w self.width = h self.area = w * h 
Does he not realize Unladen Swallow is dead?
Use re http://docs.python.org/library/re.html
 if substring in afile.read(): foundit() unless you need it to be efficient on large files.
I think wget -A does the latter one.
If you are thinking deployment you are doing it wrong. You will end up in the Java mess of application servers. When really all thats needed is python runmyapp.py and thats all the "deploying" done. 
You can read the file chunk by chunk: with open(...) as fp: s = '1011' n = len(s) buffer = '' while True: chunk = fp.read(1024*1024) if not chunk: break buffer += chunk if s in buffer: return 'HIT' buffer = buffer[-n+1:] The buffer makes sure that you find your search string even if it is split into two chunks. 
overkill if it's a substring but the question is vague so perhaps it's a pattern.
I doubt that supporting other unixes on x86(-64) is going to be a huge problem... In fact, I think FreeBSD is already supported/partially supported... As for tons of dead/nearly dead CPUs, it's not clear that it should be a major consideration: after all, what's more important: support of nearly-irrelevant ancient boxes or the health of the whole python eco-system? Also note, that it'll likely take at least another couple of years before pypy catches up with the main python development (python3 support, CExtensions, Numpy, etc), by that time those CPUd will be even deader. 
http://speed.pypy.org/timeline/ It seems to be 2x-3x slower on average
Hmmm, does **JVM** have JIT for all those CPUs????? I strongly doubt it. Moreover, would not LLVM also need JIT support on all those architectures? LLVM docs explicity say: Just-in-time support: X86, X86-64, PowerPC and PowerPC-64. 
wget can do it, it doesn't seem you care much about the programming itself.
[Nagare](http://www.nagare.org/) looks interesting, with its component-based approach.
Flask: all the pros, none of the cons. On a more serious note, there are 2 broad types of [frameworks](http://wiki.python.org/moin/WebFrameworks): full-stack (you will most likely not need anything outside of what is provided with the framework) and basic or minimalist frameworks where you get a base for which you will use most of the features, but you will need to add some modules for ORM, cache, session, etc. If you are new to web development and want to have a good and easy time, you should go with Django. If you are experienced with the web and you know what you are doing, you will be tempted with one of the various popular basic frameworks: Flask, Bottle, CherryPy?, Pyramid?. As some other people mentioned, you should try before you buy (or invest a lot in your project).
To add to this: for what I do with Python, code speed isn't critical - i.e. it's mostly waiting for the user, the network or the hard drive, not the CPU. But several C extensions are critical. So CPython will remain my main environment for the foreseeable future.
I'll give some advise, since I've done something like this before. First, make sure there isn't anything that does what you want already. I know that wget has some scraping like functionality built in. Once you've exhausted everything, then there's a library called [Beautiful Soup](http://www.crummy.com/software/BeautifulSoup/), which works really well for parsing HTML. The API is fairly simple, and you can use it to traverse the entire HTML document, finding img tags. For downloading, it really doesn't matter what you use. There's several libraries like urllib/urllib2 and [requests](http://kennethreitz.com/requests-python-http-module.html). I haven't tried requests before, but I hear it's way better than anything else available. If you want to implement a scraper that also follows links to other pages, you could also use Beautiful soup to find links on the page, and add them to a queue to be processed.
Search your filesystem for a directory called site-packages. It should contain some third-party libraries that come with the Python system, or any you've installed through other means. Put any packages you want to add to your Python installation there. Alternatively, edit your Python path to manually include the desired package(s).
Why are you reading it into a list? Is the entire file less than your total RAM? If so, you should just be able to read it all in at once like obtu suggested. If you expect/want multiple matches, then use re.findall or re.finditer
Stop downvoting a guy for quoting a PEP
I have a weird issue on Windows with this. I'm getting IOError "No such file or directory" if I'm importing a file in my python script. This only happens when I right click a .py file and use Open With pypy. However, if I make pypy the default app handler for .py files, I don't get this error. More about error: File "app_main.py", line 51, in run_toplevel
In a way the situation that you're describing is totally not being pypy's target. Even if pypy worked well with all the C extensions, you would have no reason to switch anyway.
&gt; However, since the script is to be used on large projects, how do you suggest I create a backup? * Read the file under its own name. * Immediately write it out again as (filename)~ , example myfile.cpp~ * if the backup fails, don't overwrite the original. If the file conversions go as hoped for, the user can then delete all *~ files in the tree. An alternative is to read the file, perform the conversion with a copy of the content, and compare it to the original content. If the content is unchanged, don't write the file out and don't create a backup. This has the advantage files that are unchanged aren't written out, which prevents recompilation of their content in systems that automatically recompile files with new modified dates. &gt; It seems that creating a backup file "File.backup.cpp" for each file processed creates an unwanted clutter in the user's code... There are a handful of conventions for naming backup files, but filename.suffix~ is the most common and easiest to use.
http://docs.python.org/tutorial/
Just take learn python the hard way, its the best I have found 
It might help to: * Read some of the many Python tutorial sites. * Run Python in interactive mode and experiment, so you don't have to wait so long for results. Jut open a shell window and type "Python". * Install and run [IPython](http://ipython.org/) for a much better interactive experience. * [Learn about IPython](http://ipython.org/documentation.html) along with Python itself. I make the latter suggestions because programming should be fun as well as educational, and IPython gives you a lot of positive feedback on a short time scale. 
Honestly, if PyPy _doesn't_ overtake CPython as the primary implementation, it will be an indication of the language's senescence. Here's to hoping the old dog still has some bark in it. Keep it up Armin, Fijal, Alex et al... The future of Python rests on your shoulders :) 
its an output from an analog sensor its a continuous true/false output with a time unit in a second file. It actually wrote block by block , all I did was cat 0xAF1982 &gt; myhugefile.txt what Im trying to do now is just break it into strings of 40 and add a new line , then start searching for patterns. All Astronomical data from Radio Telescope. Previous programmer used assembler/C to create the blocks, now Ive got to make something from this
&gt; a single, abstract, logging interface that allows me to interact with native logging mechanisms on the platforms I'm on So, are you not aware that Python logging integrates with both [syslog](http://docs.python.org/library/logging.handlers.html#sysloghandler) and [NT event logs](http://docs.python.org/library/logging.handlers.html#nteventloghandler)? In what way does the functionality provided not meet your requirements? There are even third-party handlers for aggregation services like Sentry and Loggly. &gt; Logging is not a way to deal with exceptions, either. That was at the tail end of the post and he didn't elaborate on that. If you log an exception and do nothing else, then from the point of view of handling it, you've ignored it (in terms of application behaviour). You've logged that it happened, but the handling of it was effectively to ignore it. Of course, there are times when that's the best you can do.
PTVS has lots of cool features, including: * Supports CPython and IronPython * Python editor with advanced member and signature intellisense * Code navigation: “Find all refs”, goto definition, and object browser * Local and remote debugging * Profiling with multiple views * Integrated REPL window with inline matplotlib graphics * Support for HPC clusters and MPI, including debugging &amp; Profiling * Interactive parallel computing via integrated IPython REPL This release includes improvements across the board including some new refactoring commands, improve debugging, new project system features, and a couple of new sample libraries for Excel and Kinect support. Let us know what you think!
&gt; So, are you not aware that Python logging integrates with both syslog and NT event logs? In what way does the functionality provided not meet your requirements? There are even third-party handlers for aggregation services like Sentry and Loggly. I wasn't aware actually. Any clue what version of Python these were added? I'll admit, since we have to support.... *grumble grumble*... enterprise distros for a long damned time I tend to have to force myself to use fairly old Pythons (2.4.x in the RHEL 5.5 derived distros, for example, which includes CentOS, Oracle, SL... so many that people love and depend on). Basically, I honestly didn't know about logging handlers, and this could be the reason why. As another example of how much working with older Pythons suck- imagine not being able to use "as" and "with".... *Shudder*... 
It's in ``pypy/module/micronumpy/`` specifically ``interp_numarry.py``, there are a number of classes internally (all of which are exposed as a single Python class), but ``BaseArray`` is the bottom of that class hierarchy.
Mostly where it exists in the source tree. And it "looks" different.
PyPy 1.8 and PTVS 1.1 - today's a good day. Very minor suggestion - could you guys use better quality icons for .py files, perhaps similar to the ones Visual Studio uses for other files?
Well, it's a free plug-in for a commercial IDE, not a free IDE. You still need to have spent $800+ on Visual Studio first.
You can use the free [Visual Studio Integrated Shell](http://www.microsoft.com/downloads/en/details.aspx?familyid=8E5AA7B6-8436-43F0-B778-00C3BCA733D3&amp;displaylang=en) if you don't want to buy VS Pro.
Yes, we could use some better icons :) For .py files we generally expected that we wouldn't be replacing the OS icon because usually the user will have a Python installation which brings the icon w/ it. So we choose to not invest the time in making larger versions of the icons and just stuck with the small versions. I think we'll have another round of graphics work for the next release, so hopefully that's something we can address then.
http://mcsp.wartburg.edu/zelle/python/ Is this the one? It looks like a simple python file and not a full blown library. Drop that graphics.py file into the directory where your programs live and import from it using import graphics # Rest of your program here
Make your script dump `sys.path` somewhere.
Sweet, thanks for the update!
It's because you're logged in. Try opening the URL in a browser without being logged in - you get the same empty response. Now, as for why it doesn't work unless you're logged in - I don't know.
web2py. But just not because it [ranked highest](http://www.infoworld.com/d/application-development/pillars-python-six-python-web-frameworks-compared-169442) according to Infoworld or because they awarded it [best technology of 2012](http://www.infoworld.com/slideshow/24605/infoworlds-2012-technology-the-year-award-winners-183313?utm_source=Python+Weekly+Newsletter&amp;utm_campaign=337820f7f5-Python_Weekly_Issue_17_January_12_2012&amp;utm_medium=email#slide23), but because we have the most friendly and most active community. Check posts/month on the google groups, check how many questions are actually answered. Also check the average time to close a ticket. 
If you're coming from Java &amp; javadoc, check out [Epydoc](http://epydoc.sourceforge.net/). Browse through the [most watched](https://github.com/languages/Python/most_watched) repos on GitHub and you'll find plenty of great examples. Sphinx is very diverse in what it allows you to generate, but requires manual labor vs. epydoc to generate per-module/per-class docs. And while not all webapps, some examples: * [Python (official docs](http://docs.python.org/) * [numpy](http://docs.scipy.org/doc/) * [sqlalchemy](http://docs.sqlalchemy.org/en/latest/) * [django](https://docs.djangoproject.com/en/1.3/) * [boto](http://boto.readthedocs.org/en/latest/documentation.html) * [celery](http://readthedocs.org/docs/celery/en/latest/) * [kombu](http://kombu.readthedocs.org/en/latest/introduction.html) * [fabric](http://docs.fabfile.org/en/1.3.4/index.html) * [psycopg2](http://packages.python.org/psycopg2/) * [pyramid](http://docs.pylonsproject.org/en/latest/index.html) * [scrapy](http://doc.scrapy.org/en/0.14/index.html) 
Python is no good for webdev. You need COBOL on Cogs.
Are you thinking of a scenario where code has been copied and pasted, and you want to refactor it by removing duplicate methods and making an abstraction of it? It seems to me that finding these duplicate methods is actually the trivial part—the issue is "automating" the rest of this action.
Honest question: Visual Studio is not cross platform, is it?
Bummer, thanks for the info, I'll see if I can add the hyperlink.
This is amazing, well written, and the code is very readable. Thank you!
No, because of unsupported C extensions. 
It's the "same" build to RC1 right?
Good book, if I was learning pygame I'd use it (or recommend to others). I found a bug however. In http://inventwithpython.com/pygame/chapter1.html, it should say `sudo apt-get install idle3` not `sudo apt-get idle3`.
I couldn't even dump sys.path to a file because I get [Errno 13] Permission denied. So I printed it in the console and the folder that contains the .py file is in the list of paths. I just discovered that this issue also occurs with regular Python if I use Open With. Very strange.
I've got a range of ideas about extending this, including: - A wizard to create the setup.py script to freeze your code. - Integrating it with an open source installer-maker like NSIS (and something equivalent for Mac?) - Build for a different platform - e.g. build a Windows executable from Linux. I can get half way there using WINE, but it can't detect what DLLs it needs to copy.
I use [PythonTidy](http://pypi.python.org/pypi/PythonTidy/) to help me keep my quoting/spacing consistent. The only problem I have with it is that it deletes #comments on a line by themselves. The way it wraps longer lines of code is also sometimes questionable. I direct it's output to a secondary file and use [meld](http://meldmerge.org/) to move the fixes I like back into my code.
PIL is a must, http://www.pythonware.com/products/pil/
I think that part of the problem with some obvious solutions is that you might lose a match in your file if you split the file over that match. While it is possible to solve this with seek, my gut tells me that that would not be an efficient solution. Rather I' suggest this: chunksize = max(len(substring), LARGE_ENOUGH_VALUE) new_chunk = fp.read(chunksize) while new_chunk: old_chunk, new_chunk for chunk in = new_chunk, fp.read(chunksize) if substring in old_chunk+new_chunk: return True
That's pretty much my reasoning. In particular, binary libraries for something like PyQt aren't always simple for the user to get set up. Linux isn't the main target, but having common code for bundling Windows &amp; Mac applications is useful.
emacs
that's like saying there are C compilers for all platforms, why do we need to distribute application binaries.
this is an interesting project, ive been looking for a good program to bundle python code so that it works without python installed, does it work with stuff like pyqt where it has c libraries and whatnot that need to be bundled? also, how hard is the code to understand? i might try looking at it :&gt;
Well, that didn't long to discover the first typo. :)
 def flatten_list(lst): return [result for item in lst for result in (flatten_list(item) if isinstance(item, list) else [item])]
I'm using PyInstaller now. It's working great on Windows. I'm running into hard-to-work-around bugs in its Mac OS support. I'll be trying cx_Freeze soon, to see if it works better on the Mac.
Exactly what I was looking for! Thanks very much!
 def parse_ugly_string(s): return dict(x.split('=') for x in s.replace('\n', ',').split(',') if x) 
don't "we" generally know by now that having the default be un-armored is as error-prone as not having armoring at all? One of the things I like about direct use of subprocess with arrays is that it's *entirely* unambiguous what's going on, and if you want globbing or substitution you have to make an effort to get it...
Is it possible to build a single-file executable similarly to how PyInstaller does it? A quick glance at the documentation doesn't seem to indicate that unfortunately.
For Sublime, start with [PackageControl](http://wbond.net/sublime_packages/package_control), then use that to install others. * SublimeLinter - as someone else mentioned Pep8/Pyflakes, this plugin will show you the errors visually within sublime. This plugin is probably the most important, as it will help ensure your code is nice and clean. It works for both python and javascript code. * Djaneiro - If you're doing any django development, this will give you syntax support for django templates, as well as some snippets. * [ZenCoding](https://code.google.com/p/zen-coding/) - this is pure awesome for HTML editing * Less - Less syntax definition * Soda Theme - A nice UI theme. Add the following to your User File settings: "tab_size": 4, "translate_tabs_to_spaces": true, "trim_trailing_white_space_on_save": true, "auto_complete_commit_on_tab": true, What each one of those does is documented in the Default File settings. 
Nice! I did Quiz #1. . . never got around to doing another, although when I have a bit more free time, I'd like to do some more. I'm going to try this quiz later tonight, when the kids are in bed. . . 
[Posted yesterday by the book's author](http://www.reddit.com/r/Python/comments/pjp78/the_sequel_to_invent_with_python_is_finished_and/)
Holy crap! Thank you so much, I feel like a pro now!
Thanks, any help is welcome. If you want to keep an eye on development, there's a low-traffic [mailing list](https://lists.sourceforge.net/lists/listinfo/cx-freeze-users).
I've not read the new book, but the old one (Invent Your Own Computer Games with Python) is awesome! Nice examples, well detailed explanations. In short, an amazing approach to teach programming. Congrats, and thank you very much for the new book!
It does support C extensions perfectly, just not through the CPython API (which it does too, although it's slow and buggy for the moment). Instead, they have a ridiculously fast implementation of the `ctypes` module, which lets the programmer define a module in pure Python that wraps *any* DLL/shared object. Better still, `ctypes` is also available in CPython, so any wrapper you write will work in both VMs.
Correct. I was replying from my phone and so I didn't fully explain. First, I should have known better, but I was actually was surprised to realize there's no magic way to bundle Python on a new machine and expect it to run n an older OS. With that in mind I was happy to find that I could get Python 2.7.2 and a collection of modules and dependencies built on the seven year old OS. Using the absolute latest 3.x Python wasn't even on my radar.
I know it's heretical and un-pythonic to say this but I don't find nested list comprehensions to be very readable. They're concise and kind of cool but for me, regular old nested for loops are more mentally parsable. Cool quiz though. . . 
Why a lamdba?
No, it isn't.
For windows, we have py2exe.
 #!/usr/bin/env python def parse_ugly_string(pugfugly): return dict(d.split('=') for d in [ b for c in [ a.split(',') for a in pugfugly.split() ] for b in c ] ) print parse_ugly_string("a=1,b=2,c=3\nd=4,e=5,f=6\ng=7,h=8,i=9\n") 
They're hideous and should rarely be used. I'm with you on this one. Fun to play with on occasion, though.
That really depends on why you are evaluating twisted. If you just want async web. probably just try Tornado. If you want an extremely powerful framework that can solve just about any problem with the word 'networking' in the name (over just about any protocol you can name), yeah you want twisted, and no there is no other competition in the python world afaik
Actually, for most tasks you can probably do just as well (and save yourself some serious brain-hurt) with a micro-threading library like gevent. At one time Twisted was really to only way to get things done for async work with event loops, but times have changed and it is no longer necessary to lash yourself completely to the IoC mindset in order to get things done. Twisted is not as painful now that you can hide some of the uglier callback/errback chaining behind deferedGenerators, but for 95% of what you might once have used it for you can now handle more easily with Tornado or gevent.
That is all fine and good assuming the only thing twisted is bringing to the table is async. But that is just not true. http://twistedmatrix.com/documents/8.1.0/api/twisted.protocols.html
Someone please correct me if I'm wrong (I mean this. I am now curious.), but doesn't the library get imported no matter where it is? The slap on the wrist from the python interpreter is just enforcing convention...I think. Don't know. Want to know. I assume you're trying to conditionally import because you want to make your program faster? Or..actually..more lean? Maybe neither. I agree with the other post here. An example would be nice so we can all see exactly what you're trying to do.
No, if the library is only imported in one branch of code, it'll only ever get imported in that one branch. There are definitely good reasons to do an import in a certain function... there are not, however, usually good reasons to do "from module import *". 
That's a really really old API doc. From version 8.x.
Not sure which you're asking why to, so I'll answer both! Why would you want to import a module (or something from a module) in a function or conditional? Well, it could be useful if you've got an application that, for example, loads plugins on demand--each plugin could be a separate module, and would only get loaded when the user requests it. Or you could have a command-line program that's capable of doing a whole bunch of things, but for speed only loads certain modules when particular flags are passed (why load everything just to show some help?) A larger app I wrote a while back fetch updates from a central server, and loaded from that (from a zip file, actually--Python can do that!)--that was definitely in a conditional :) As for avoiding "from module import \*", that one is simpler: it pollutes your namespace. \* means to import *everything* from a module (or, in some cases everything in the module's \__all__ attribute), and it doesn't know or care what your variables are called--it'll overwrite anything. Some more in-depth stuff here: http://stackoverflow.com/questions/3571514/python-why-should-from-module-import-be-prohibited#3571558
Okay, I totally agree that this is a bad idea. You shouldn't do this; you shouldn't want to do this. However, out of sheer curiosity, I messed around a bit, and this function appears to work in Python 2: def foo(): exec '' locals().update(__import__('math').__dict__) return pi The empty `exec` apparently prevents Python from doing some basic optimizations and, as a side effect, allows you to update `locals()`. This works in Python 2 but not in Python 3. I'm not sure if there's a "better" way to do this thing you totally shouldn't do.
Thanks to all for their input. I keep an eye on these projects: twisted, tornado, gevent.
IdleX, the best thing that happened to Idle in years
Nice doing it with the replace function. Definitely more elegant than my solution: dict([i.split('=') for x in [j.split(',') for j in s.split('\n')] for i in x if i]) The idea was to combine all the different subtleties of list comprehensions in one line : )
&gt; Preliminary support of IPV6 on the server side Really? It's 2012 guys, how is it possible there is no full IPv6 support?
For reference my answers were: flatten_list = lambda l: [a for x in l for a in x] make_all_couples = lambda l: [(r1,r2) for r1 in l for r2 in l] parse_ugly_string = lambda s: dict([i.split('=') for x in [j.split(',') for j in s.split('\n')] for i in x if i]) But we have had many interesting and better solutions in the comments ! 
That all doesn't matter. They don't support the C extensions, so they will never become the mainstream implementation. 
That PEP8 checker looks useful. TIL.
I've used both Twisted and Tornado, and prefer Tornado. Twisted is too inflexible for my taste, and the docs are weak. You can get up and running with Tornado in a few minutes, and everything is intuitive. I had quite the opposite experience with Twisted.
I know I'm being a negative nancy, but I can't imagine why someone would waste time learning this framework when there are far simpler and more flexible platforms out there (Tornado, gevent). The two times I've tried my hand at Twisted, everything about it just screamed ugly and unwieldy at me. Tornado was a huge breath of fresh air after that.
Yes, I'm familiar - but they are not applications in the style of Django. &gt; The basic concept of blueprints is that they record operations to execute when registered on an application. Flask associates view functions with blueprints when dispatching requests and generating URLs from one endpoint to another.
Which C extensions are you talking about, exactly, that everyone uses?
Wouldn't it just be easier to compile psycopg2 and libpq from source against your 64bit Python headers, instead of switching the venv to use a 32 bit binary.
Correct me if I'm wrong, but isn't Tornado primarily for web-based applications? Twisted covers a *lot* more than that.
Recently I needed a way to send email via smtp with authentication from Tornado. There was no async library for tornado for this task that I could find. Luckily there exists a Twisted bridge in Tornado, which I used. Since Twisted is a networking toolkit it comes packed with a lot of stuff (not only web), but it does come in handy. I wish that the documentation was better, though :( There's also a tornado port on top of twisted's event loop that I recently discovered: http://cyclone.io/
Obligatory reference to one of the finest pieces of technical documentation I've ever read and (almost) understood, [Krondo](http://krondo.com/?page_id=1327)
It looks nice.
Offtopic - just realised you're Mark Harrison? Right? We're pushing forward with qtile's development if you'd care to join us in the IRC channel.
Yeah, the idea I had for it, was if I were using plugins that were loaded as they were needed where the plugins were meant to override the existing functions, this was the way I was thinking of doing it. But there's no real need to do it that way.
but it *is* highlighted. :D
You have to be making good use of it.
shameless plug: [django-pygments](http://github.com/odeoncg/django-pygments)
That's still not a *good* reason to import everything. It's still much cleaner to import pyglet itself, and do (I don't know pyglet, so this is probably wrong): pyglet.gldraw(). And very few modules prefix methods like that--I'm guessing it's because of a SWIG wrapper or the like.
But does it highlight [Whitespace](http://en.wikipedia.org/wiki/Whitespace_%28programming_language%29)?
The latex it produces is infinitely better than anything else I've ever used. 
Switching from Twisted to gevent was a massive relief for me. You'll get the same or better network I/O speedups with gevent, and the code you write makes way more sense. Plus it's very compatible with a lot of the standard library, while Twisted doesn't even have something like urllib2 or mechanize yet. They have web.client.agent and getPage, but they don't really provide the same functionality.
I use it in combination with [Jekyll](https://github.com/mojombo/jekyll).
Aren't those two totally different? "Tornado is an open source version of the scalable, non-blocking web server." Twisted is much much more than that.
tl;dr `"is active" in pbs.gnome_screensaver_command("-q")`
You mean this? https://code.google.com/p/pyplugin/
ಠ_ಠ
You had to write a python script for this? `gnome-screensaver-command -q` does it, man. And it does it in any GNU/Linux that happens to have GNOME installed. So you're reinventing the wheel--and why, exactly? EDIT: I made the strategic mistake of suggesting conservative use of new utilities to solve already-solved problems. I'm so terribly sorry.
...what? I don't think you read the code, it is calling that command. The idea of the gist is that now you can execute code when your terminal locks. For me, I have it play audio randomly to keep my cat from napping while I'm at work so she doesn't keep me up all night :3 I figured someone else might find this boilerplate useful for running things automatically when they're away too...
I haven't gotten around to putting it on PyPI just yet.
I don't see the point of highlighting useless programming languages. However, I'd like to see cilk/cilk++ on that list. That'd come in handy.
From FAQ: &gt; Instead of waiting for others to include language support, why not write it yourself? All you have to know is outlined [in the docs](http://pygments.org/docs/lexerdevelopment/). Btw, is cilk/cilk++ actually being used somewhere? Just curious, no sarcasm.
I didn't mean any one framework in particular; there are several, and I've never personally used any, so I didn't want to make a recommendation. But sure, give that one a shot! :)
Only problem is, there is still no Python 3 compatible version of pygame for Mac. None that I've been able to find, at least.
Thanks!
[This one is really nice though.](http://pygments.org/demo/18949/)
pygame works with Python 3. I'm going through [this book](http://inventwithpython.com/pygame/chapters/) right now and it requires Python 3. I compiled pygame from source though since I'm using Ubuntu. I don't know if their Mac package works with py3 out of the box. I'm pretty sure you could also compile in Mac if it doesn't.
I get you're venting, but how about you tell us what it is you are trying to do and we'll see if we know the Python tools to get you there.
Nice list. I suppose Tinkerer (a blogging engine/static website generator powered by Sphinx) can be in the list as it uses reST.
Upvote for teaching me a new word - senescence.
Ah, I see. The limitation there is that you're using xscreensaver. OK, it's probably as easy as using xscreensaver-command instead. Want to try it? And it would be as easy as checking for each screensaver (x, gnome, kde, whatever else), if you wanted to be generic.
scipy.optimize is mostly for unconstrained optimization. fmin_cobyla provides some rudimentary support for constrained optimization but as yet there isn't support for general LP solving.
That was one of the most confusing descriptions of pypy I've ever seen. First off, the author doesn't address the fact that commonly, python source code isn't compiled into a machine code binary. So his snarky response about misunderstanding how compilers work and produce binaries from text source is uninformative. The sticking point is that when I write a program in python, usually a python interpreter like CPython is needed to execute my code. So when people say pypy is written in python, one might reasonably expect that pypy also has to run on an interpreter. That leads to confusion, where it seems that pypy is itself interpreted, on CPython, and therefore cannot be faster. What it appears to be happening is that: Machine &lt; CPython &lt; PyPy &lt; Script.py Clearly this isn't the case. PyPy is a set of tools for turning restricted Python (RPython) code into C code that can be compiled into machine code. If that RPython code happens to implement an python interpreter, the resulting interpreter is also called the PyPy interpreter, which replaces the typical CPython interpreter on your system.
Dropbox is more or less rsync with a gui, it would be quite easy indeed to hack something up.
sparkleshare
What are you trying to learn? Python? Networking? Data transformation?Compression? Web development?
I agree that it's confusing. I mean, they came up with this sentence: &gt; In reality, PyPy takes a hybrid approach, where it is a program which produces a program and then does some stuff to it and creates some C code which it compiles with the compiler of your choice and then creates some code which then creates other code and then puts it into memory, not a file, and then executes it directly, but all of that is ancillary tricks and techniques to make your code run faster, not a fundamental property of the kind of thing that PyPy is.
Okay, so that article actually confused me about pypy. All it really says about how pypy works is "it's a self-hosted compiler". Everything else is irrelevant to how pypy works. It's a very confusing article.
New to programming that is.
Well, too bad you haven't come around to really learn vim in all those years. It's okay to dislike vim but saying that there are editor_s_ that are easily ten times better is pure ignorance. The only editor that could try to claim that would be Emacs – but that's matter of taste.
Enlighten me please – which Linux editors are "easily ten times better"? I'm not even pounding on the fact you presumed they are already installed.
That's wrong. Even the indentation inside Python's stdlib varies and PEP8 allows both foo(bar, baz) as well as foo( bar, baz) The second one is perfectly possible with vim's default mode.
Oh my god. I haven't heard a "this is better then that" debate in quite a long time (pertaining to linux). I thought most people grew up and just used what ever worked from them. Whether it's KDE/Gnome, Emacs/Vim... who really cares what the next guy is using????
Yeah but I'm not looking into activating the virtual environment each time I want to use the utility. Imagine I'm writing an alternative to cd :/ 
God, what a pompous idiot.
Gesundheit
I'll look into what you both suggested, thank you.
Just the file accessing aspect, without having to use someone's FTP software or something similar, I would be basically writing my own.
Thanks for the suggestion, someone else said that too so I'll look into that first.
I echo your sentiments and others in this thread. I can never get past twisted's (historical) non-pep8 coding style and java-style classes-only architecture. When you compare it to the implicitly async greenlet-style frameworks, it just immediately falls short; Twisted's proponents say that it catches up in large projects, but having worked on a large twisted project I don't really agree. @inlineCallbacks gets you halfway out of callback hell, but not nearly far enough, and at a pretty heavy semantic cost. Twisted lets you do anything by composing 10 different classes together. Sometimes, that anything is incredible, like running ssh over smtp or something bizarre and completely impossible in most other networking frameworks. Unfortunately, the common, trivial case is almost as complex. I never feel less like I'm using python while still using it than when I'm working on a twisted app.
&gt;There's a command that does it--it's called gnome-screensaver-command. Yes, but it **is** calling that command - that's how it detects the screen is locked. The part that checks if the screensaver is active is the single line: return "is active" in pbs.gnome_screensaver_command("-q") Which is (presumably) just doing a subprocess.call() and retrieving the output, which the script is then looking at. The entire rest of the script is just for spawning a thread to monitor this, and another one that does something based on the status (not such why the two threads admittedly - presumably his actual use case is more complex) &gt;No need for a Python script to call a Bash script There's nothing bash specific about calling a command, and python is doing *exactly* the same thing bash does here, (though with one fewer command being launched since it's using python's string processing rather than spawning a grep process.)
Depending on what you're trying to do, it might be as simple as... $ cd /home/somedir $ python -m SimpleHTTPServer [Explanation](http://www.linuxjournal.com/content/tech-tip-really-simple-http-server-python) 
Nice roundup. Considering it might attract readers even later I think it would be good to add Pyramid as it is pretty big player in Python's web framework category. Maybe someone will write it paragraph for you :) PS: You have bad anchor text in Bottle's "fast overview". 
You still have not really specified anything. Will there be multiple clients accessing it? Read-only or writable? What security is needed? What about conflict resolution due to two clients updating the same file before a sync can happen? Do you need to publicly share branches of the hierarchy? What about versioning? Do you need push updating or is pull updating enough? Manual, triggered or automatic updating?
This article was very confusing, and didn't really tell how PyPy works. A few days ago, I stubled on an article that does adequately explain PyPy, through the lens of implementing another programming language on it. It uses a lot of scary words, but this article has successfully taught a lot of people how tracing JITs work. Give it a try: http://tratt.net/laurie/tech_articles/articles/fast_enough_vms_in_fast_enough_time
&gt;So when people say pypy is written in python, one might reasonably expect that pypy also has to run on an interpreter. That is exactly what I used to think pypy was doing. Basically, pypy is another interpreter, along with a JIT compiler. That should be the starting point for explaining pypy and it is now on [Wikipedia](http://en.wikipedia.org/wiki/Pypy). 
What is your "&lt;"-list supposed to represent? The abstraction stack at runtime? The translator doesn't exist at runtime.
I think of it like this: PyPy is an interpreter. As part of its interpretation work, it does tracing to let it know what would be a good candidate for JIT compilation, which it may then choose to do. Even if it *does* do JIT compilation for hot loops, though, it's still basically an interpreter because it is highly unlikely (impossible?) that it will ever JIT your entire program into machine code.
That is true, but nobody calls the JVM an interpreter despite the fact that main is almost never compiled to machine code on it. Just the fact that it compiles your code *sometimes* means it's not just an interpreter. Also, I was directly replying to: &gt; What PyPy the interpreter does is implement a virtual machine (like the JVM) whereby your python source can be just-in-time compiled to some non-machine byte code, and then run on top of the PyPy virtual machine, not the bare metal directly. Which is just plain wrong.
True enough.
Been thinking the same thing the last few days, good luck!
I would say you should be blaming your fucking mac. the first thing I had to do when I got my pretty "my precious" mac book pro was try fink, mac ports, homebrew because even though it is unix underneath the steve jobs approved shine, they have bastardized it so bad that shit like python installed in the system is really not setup for you to leverage. I would get weird errors about this objective c cocoa shit when I was trying to do web application development. The final solution was "brew install python" and use that one, just pretend the other shit doesn't exist with it's weird locations and directory structures. Oh yeah and install XCode, I have no idea why but shit doesn't work without it. 
From my .bashrc: function pp () { pygmentize -g $1 | less -R ; }
Can this be added to the r/py FAQs sidebar? Someone asks which web framework to start with once a week at least.
I read that article a couple of days ago, and I've already translated two VMs I'd written to RPython and added JITs. It's pretty freaking cool, and really easy too. I'd check [this](http://www.youtube.com/watch?v=Xzqn6G4VzbM) out as well, and just dive into some sources and docs.
When I was working on it Pyramid was brand new. As in it was just recently announced and released. The documentation was not clear in any way shape or form. I'd look up certain functionality and find it talking about repoze.bfg, but that stuff no longer applied to the Pyramids code-base. At the time Paster was used heavily and the documentation for how Pyramid used Paster (as well as the documentation for Paster) was almost non-existant. I was on the bleeding edge so to say. I may have been bit by that but I didn't want to start working in Pylons because they were making it abundantly clear that they were going to move to Pyramids in the near future as a clear replacement.
I was going to say "in direct proportion to your douchebaggery" but whatever.
All the examples (and frameworks) you list have one thing in common: the web application starts the web server. This means one cannot take two web applications written for the same framework and serve them at the same time without: 1) somehow merging them (may require programming or configuration) 2) restarting the web server; 3) hoping there are no library conflicts. Am I wrong?
cyclone
numpy, matplotlib, scipy , ntlk, pygame
Mind that this is not an apples to apples comparison. For example Django includes an ORM, a template language, a form generation/processing library, and a web based database interface. Those lines of code are counted. Flask instead relies on third party libraries/extensions (SQLAlchemy, Jinja2, WTForms, etc.) and those lines are not counted. In fact those "frameworks" with count numbers below ~5000 only include dispatcher and session handling (and may be very good at that) and a little more. Almost everything else is external, that is why people call them micro-frameworks.