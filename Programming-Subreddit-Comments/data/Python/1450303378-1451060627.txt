I find that looking at the page source is much more efficient than constantly retrying the script with prettifying the object.
But then again, even though you can use other interpreters, in the end cpython is the standard and therefore what you should benchmark against. And to be honest, numpy is de facto the "standard lib" for big data. I've not seen any package in the scientific field that's not using it (or something build on top of it, pandas would be a good example) 
I'm just talking about the difference between pure python and not. Numpy is not pure python. Also, standard lib means one that comes with the python interpreter, not how wide spread it is. 
what is shitty in your opinion about using tools like the lru-cache or packages like numpy? can't get more pythonic than that... 
there is the saying that "packages go to the standard lib to die" (and that's kind of true sometimes). and yes you are right. But I believe that the people actually doing this kind of work with big data /computational heavy stuff are frequently using a distribution like anaconda anyway, where it comes bundled (you might say inside anacondas standard library) 
Have you tried [fabric](http://www.fabfile.org/)?
Keras is a library to implement algorithms that automates the prediction of labels of data from some training data. It will be applied to any problem that involves machine learning. http://machinelearningmastery.com/practical-machine-learning-problems/
But I don't get it... what are you trying to say? Are you saying no non-expert should make crypto related apps? Just leave it to others to make them? And when some other person comes up with their app, you might say the same thing to them. Exactly who are on the allowed list here? How does anyone learn to make them if no non-expert is even allowed to experiment with them? 
Paramiko works fine with Python 3.5 (in fact, it's even available from official Ubuntu python3-paramiko package). My guess is that you simply have problems compiling pycrypto due to missing C headers.
To be clear, the proxy will use a wildcard certificate that will match any domain. For that reason, it's critical that you use a certificate you generated yourself. If you use some default certificate that other people have access to, they can also sniff all your encrypted traffic.
AsyncSSH uses the AsyncIO framework found within Python 3.4+ https://github.com/ronf/asyncssh
Duh. My only point was the definition of the phrase "pure python". A purely technical *nit pick*, like I said in my first comment. Like, if you were in a coding challenge and they said "solve this with pure python", they'd mean "no Numpy, etc." And when Pypy says it speeds up pure python, they mean don't go expecting numpy, opencv, etc to work. 
I have no issue with either tool, I just have issue with "okay, so lets take recursive fib function, and litter it with keywords", at that point your syntax highlighting stops working, you need to muck around with your tooling if it doesn't do cython straight off, and then you also introduce platform restrictions which are a pain to overcome simple external things like decorators I have no issue with. Its more just a throw-away thought because just the "optimizations" are wrong (changing a recursive algo to a linear algo completely misses the point of comparing two languages at all (oh and then adding cache to change it so it tends to O(1) IS REAL FAIR RIGHT YEP))(nevermind its comparing the languages themselves, so this "oh realistically u wld do this in C" bullcrap. if one EVER worried about speed in python, they wouldn't use python! so python's "realistic" speed would literally be the same as C, because "fast python" is literally just C!), and all the subsequent praise this person is getting for this bullshit. its fuckin unreal imo and I don't like it because I'm grumpy
Hi there. You have posted a learning question to /r/python. These types of questions are far more suited to /r/learnpython, where users are actively interested in helping people to learn. Please resubmit it over there! Make sure to read their sidebar rules there before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." If your question is about homework, show them that you've tried to solve your problem in your post and you should get all the help you need. Cheers &amp; best of luck with Python!
So could you say that if this is take two, its PythonIsNotC++ I'll see myself out
What kind of signature are you looking for? 
See my previous comment. This version has timeout functionality. # adapted from http://stackoverflow.com/a/34114767/452281 import asyncio import sys from asyncio.subprocess import PIPE, STDOUT def do_something(raw): data = raw.decode("utf-8") lines = data.splitlines() for i in lines: print(i) async def run_command(*args, timeout=None): # start child process # NOTE: universal_newlines parameter is not supported process = await asyncio.create_subprocess_exec(*args, stdout=PIPE, stderr=STDOUT) # read line (sequence of bytes ending with b'\n') asynchronously while True: try: line = await asyncio.wait_for(process.stdout.read(), timeout) except asyncio.TimeoutError: print("timeout occurred") else: if not line: # EOF break elif do_something(line): continue # while some criterium is satisfied process.kill() # timeout or some criterium is not satisfied break return await process.wait() # wait for the child process to exit if sys.platform == "win32": loop = asyncio.ProactorEventLoop() # for subprocess' pipes on Windows asyncio.set_event_loop(loop) else: loop = asyncio.get_event_loop() returncode = loop.run_until_complete(run_command("plink.exe", "jftuga@ubuntu", "-ssh", " ".join(sys.argv[1:]), timeout=10)) loop.close() The timeout is 10 secs. Try "sleep 20" and then you will see a "timeout occurred" message.
Your comment is the exact reason why it's very important to have a threat model. Something I think would be neat to implement is a USB based key - like Yubikey - to prevent the keylogging issues. However, that doesn't prevent the keylogging issues if you type in the passwords to your account.
i can't answer that question (not being one of the people who created julia), but i can try to explain why you might want to use julia rather than python. in short, julia lets you do all the "tricks" in this article in a simple, consistent way. it's like taking these different python solutions, polishing and simplifying them, and putting everything into a single, elegant language. if you use cython for speed, then you find that you can't do all the things you normally do in python. julia avoids that. and julia can also, often, get the speed-up you get from type annotations without you, the programmer, actually having to write the annotations. one side-effect of this is that, unlike numpy, much of the code that manipulates arrays in julia is written in julia itself. that's not all. julia is also interesting for the new things it has, that go beyond python. it supports macros, which can be useful when you want extend the language yourself. and it has multimethods, which are a surprisingly elegant way of extending "object oriented programming" to "more than one class at the same time". both of those, incidentally, are features that help make lisp so powerful.
I will as able, but I'm actually behind on non-coding projects &amp; my Python skill is anemic.
I use kdtrees a lot when dealing with geospatial data. One example is querying digital elevation data. I load the x, y, z data into a kdtree. Then I can query the tree for any arbitrary x, y to get z. I usually start with a kdtree, get my code to work. scipy.spatial.kdtree is a pure python implementation. It's easier to troubleshoot, and the code is easy to read if you're trying to do something weird. If it's working smoothly, I then attempt to swap in ckdtree for performance. Cause it rocks.
if you like python and are looking for polling capabilities there are other options out there. zenoss core is the first example that comes to mind based on your description. free, python based, polling of more than just websites, and port checking capabilities. fyi. zabbix may have some of this as well, it's been a while since i've tried that one.
You don't need to gain access to arbitrary processes to do memory reads, you just need to read memory before clearing after malloc. 1. Allocate 1 meg of memory 2. Read data from the allocation 3. Dump anything interesting to disk 4. Go back to 1 until your program gets killed 5. You have now forced many programs out of RAM and into swap, and in the process, were able to read their memory regions Python programs are actually pretty interesting; once you start hitting Python memory space for a single process, every string has a pointer to the same string base type in the same alignment relative to the string content (and if you're on a 64 bit platform, identical 8-byte values scattered across the memory space is vanishingly unlikely). You've now discovered every string from that one process, and can actually differentiate Python processes by where they have pointers to string types. Note that ssh-keygen and others at least used to use this to help initialize their entropy sources for a variety of reasons.
Do you want to learn python the language? Or focus on all the libraries available for it? For language itself I found Project Euler to be great for getting your feet wet. That's who I started with python and later with Scala. But then to learn libraries, you just need to pick a toy project and start doing it. Big power of python is almost limitless supply of packages that do all kinds of stuff. Some are more mainstream than others. For DB, I would go with SQLAlchemy. 
[Learn Python the Hard Way](http://learnpythonthehardway.org/book/), you can probably blow through a ton of it very quickly. Then build stuff in python.
I think it's a mix of the two. I have a master in computer science (although I graduated a decade ago) so I am fairly well-versed on data structures, algorithms, etc. I am sure there will be some language specific elements of python that will take some learning; however, I feel incredibly lacking with the packages or even how to get a list of them. Any advice in learning the available python packages? Thanks, 
&gt;You don't need to gain access to arbitrary processes I didn't say that you did, but what you do need is a nefarious program running at the same time as the password manager, at which point you might as well just install a keylogger to attain their master password and be done with it. 
Are there actually csv files which don't fit into memory? I use to think that for large data sets one uses RDBs or NoSQL data stores. 
I don't think using a newer compiler is recommended if Python&lt;3.5. The resulting binary would use the wrong crt.
Performance was an issue. I needed to get the closest point in less than a second. The code that needs to be maintained is 10 lines or so now and straightforward. But you are right in general, one should always look for libraries before developing something new in Python. My problem is a nearest neighbor problem, not a mapping problem. If trees aren't the right spatial libraries to use, then I welcome suggestions.
&gt; But I don't get it... what are you trying to say? Learn more before writing crypto. In particular, know enough about cryptography not to make basic mistakes in the implementation before your first public release. &gt; Are you saying no non-expert should make crypto related apps? Just leave it to others to make them? No. And No. &gt; And when some other person comes up with their app, you might say the same thing to them. Exactly who are on the allowed list here? I'm not and never was the gatekeeper of anything on /r/python, or anything cryptography related. OP asked for feedback, I had a few minutes, so I gave OP feedback. Hell, I'm not even close to an expert myself, only a motivated and overly-educated amateur (see my username). If I can find a problem, then a real cryptographer would piss all over it. &gt; How does anyone learn to make them if no non-expert is even allowed to experiment with them? I never said OP or anyone else wasn't allowed. This shit is hard. And practice makes better (though some people will never be anal retentive enough to do cryptography properly). But OP asked for feedback, and if OP didn't want "hey, your app has the following issues: ...", then OP shouldn't have released incomplete and insecure software as open source and posted it to a public forum.
First of all, I never said that this was better than any password manager available. I'm simply making one - for fun. Second, I've warned users about using it. I said how it isn't audited or should be considered secure by any means. You're acting like you're clever saying its implied, but not guaranteed? I explicitly stated that it's not guaranteed secure in the README. Third, I built this to play with PyCrypto and I posted it here for people to play with the interface and see if they could catch something I missed and you're pissed off about it? Go fuck yourself. I never intended for anyone, but myself, to use it for learning this specific library. If you don't like it, don't use it. I like to release my code on github because it contributes to the community. If someone can learn from it, then I succeeded either way. Fourth, my threat model, at the moment, doesn't encompass memory-based attacks. If an attacker has access to your memory, your security has already been defeated. Why even attack the memory at that point? Just use a fucking keylogger and get much more usable information from the poor bastard. I'm not looking to fight the NSA or FBI with it, I'm not looking to prevent the leak of secret nuclear launch codes, I'm looking to play with a fucking Python library. You're acting like a few implementation errors causes the whole script to become a useless waste of time. That's not how engineering works - at all. In fact, in its current implementation, I can argue that someone is better using my manager than no manager at all. Again, I'm working on this in my freetime. If you have a fucking problem with what I like to build in my freetime, you have bigger issues than implementing bad crypto.
I don't think you want to see the list https://pypi.python.org/pypi/?. Anyways you could refine the list by simple google "top python packages" or "popular python packages" that would quickly give you a general sense of what the fundamental packages are in the python realm. Best free way is to google. 
Start writing and never stop writing.
Shinken (&lt;http://www.shinken-monitoring.org/&gt;) is a Nagios replacement written in Python that's been around for more than 5 years and that's actively developed and supported by a french company. I'm surprised it's not mentioned more often.
Normalize might be tricky, no? 
You're not wrong, but you are being an arsehole. I'm an optimistic guy so I'm gonna assume that you're not an arsehole and you just lost your cool briefly (it happens, I'm certainly guilty of it). The problem is comments like this educate very few people, and have the opposite effect on many more. You could easily have just given the two links without any words and people would have followed them and learnt something, but as it stands a lot of people are going to (quite fairly) read your first sentence, downvote, and move on.
People always mention Learn Python The Hard Way or the likes of CodeAcademy... It's weird/sad that the place I learned from never gets mentioned. Google. I learned Python from Google. Course playlist: http://www.youtube.com/playlist?list=PLC8825D0450647509 Course material: https://developers.google.com/edu/python It is really awesome and helped me get started. The videos are great. To be fair, Python wasn't my first language. I had done things like C++, PHP or Bash.
Of course there are CSVs that don't fit into memory. Lazy DBAs, automated systems which simply append data after data row to files, zip them, and transmit. I've got numerous examples on some of the systems I work with. They of course aren't ideal for WORKING with, but they are very common as a poor-man's interface between parties who don't want to set up more complicated data transmission methods. 
These days you'd be way better off just using [anaconda](http://conda.pydata.org/miniconda.html) for all your Windows Python needs. It's like seriously the best thing that happened to Python packaging ever. And yeah, `conda install paramiko` Just Works™.
How long before python 2 become a thing of the past?
with some distributions now moving towards python3 by default, we can only hope this to not take -that- long...
In my view, unless support for 2.7 stops completely, it's unlikely that the majority of the industry will make the switch. It's funny, but an unintended consequence of the transition was that the feature freeze and the long term support made the industry see 2.7 as the "business" Python -- the battle-tested workhorse that's guaranteed to stay the same. Sort of how ANSI C is still seen sometimes. The only thing IMO that could change that attitude would be the withdrawal of support releases, which AFAIK won't happen before 2020. If 2.x is seen as obsolete and a possible a security/stability risk, then maybe the cost of upgrading could be justified. And that's assuming that the key players won't decide to continue supporting it themselves.
Never. Software don't have a hard lifetime, but rather a half-life. With the immense amount of python2 in the wild, it will take forever, before the exponential decay kills off the last one.
never again it felt like php 2008 ...
This is the reality. I started using Python3 as soon as it was feasible to do so. Yet I still have a wide array of legacy projects that will remain that way for the foreseeable future.
&gt; Therefore if LLVM is legitimate for compiling Julia, then it must be legitimate for compiling Python. If it's a superset of a subset, it's no longer Python. Since we don't have a complete language specification, Python is whatever is implemented in CPython. When you have a different implementation, like you do with Cython, Numba or even PyPy, you no longer get to call it "Python". At most, you can call it an "alternative implementation of Python". You may wonder why this is important. Remember where all this started from? A language benchmark. As in a benchmark for Python as implemented by CPython, not a benchmark for Cython, Numba, IronPython, Jython, etc. Also not a benchmark for thin wrappers of C/Fortran libraries. &gt; It does not mater more than having Julia call the Fortran library LAPACK, does it? No, feel free to do the same from Python. The idea when benchmarking language implementations is to put an equal load on each language. That's why you keep the algorithms the same, and if external libraries are used, you make sure they are used the same way. &gt; Python interpreter itself is partly written in C. Not the same thing as wrapping Numpy and claiming Python is fast. You can have the interpreter/compiler written in any language. It does not subtract from the merit of the implementation. But you can't do the same with libraries. Because then you'd just use your FFI and let some C code do all the work. That's not the kind of benchmark we're interested in. &gt; Actually, it is because there is a bunch of Python packages written in C or other languages that Python is so useful. Useful, no doubt, but a terrible waste of resources. Claiming that Python is fast is not only dumb, it's dangerous because most Python programmers (myself included) are not using it simply as a glue language, writing over 90% of the code in C modules. We do the opposite and write more than 90% in Python. That's why we need to face the music and become aware that Python is slow. Your naive article does not help. &gt; I am in full agreement with what Jake Vanderplas wrote Yeah, let's circlejerk with scientists that are extremely modest programmers, and try to forget that they use Python wrappers only because the language is so easy to pick up and maintain. 
&gt; You're not wrong, but you are being an arsehole. Better than the other way around ;-) &gt; The problem is comments like this educate very few people, and have the opposite effect on many more. Can you really educate the cheerleaders? They are not interested in the details and see criticism as an insult. Better filter them out from the start. 
I have updated the post with Julia running times. Main takeway: the difference in speed for fib() is explained by the difference in integers used: 64 bits integers in Julia vs arbitrary precision in Python. Python is faster when the same integers are used. 
I think we'd see things move more quickly if Ubuntu and OS X shipped with Python 3.x. Tons of casual users use Python 2.x because it's there -- myself included. :/
Python 4 will unite us all. Or 5. Definitely 6.
How can I find more info about how strings and bytes can be equivalent in Python 2? This is surprisingly hard to Google for.
I'm doing stuff on google these days because I work with retail data and my customers don't want any of their software dollars supporting Amazon. Not a fan of app engine, but BigQuery is amazing. Dollar for dollar, it blows every other data warehouse solution I've seen out of the water. 
Its not timing fibonacci, its timing a generic stack/recurse heavy algorithm, which people /do/ write in the real world changing it to linear, cached, or just the direct math for it, completely misses the point, yo
Thanks again for this comment. It is clear that we disagree about what Python is or isn't. My view is described here: https://www.ibm.com/developerworks/community/blogs/jfp/entry/What_Python_Really_Is?lang=en It is shared by many. If you disagree with it, which I think is the case, and which is fine, then we won't resolve our disagreement. &gt; The idea when benchmarking language implementations is to put an equal load on each language. That's why you keep the algorithms the same I just found why Julia fib was faster than Python fib. It is not because Julia's recursion is faster. It is because different algorithms are used: Julia uses 64 bits integers when Python uses arbitrary precision. When we use BigInt with Julia in order to get the same algorithm, then Julia is slower than Python. I updated my post to document this. I hope you agree this reveals a flaw in how the benchmark were conducted so far. 
Didn't Ubuntu switch already?
Computing with arbitrary precision arithmetics *is* a different algorithm. At an abstract level it is the same, but they are different. For instance, running time complexity is different when numbers can grow exponentially with the size of the problem. complexity theorist use that all the time. I understand Cython is different from CPYthon. My point is that including Cython functions into a CPython code when they behave as the original CPython function is fine. Said differently, using Cython on the subset where it coincides with CPython is fine with me. Same holds for Numba.
Just start working on tech sideproject 
But then you still have billions* of tutorials out there that don't say if they're for Python 2 or Python 3 and you have to just kind of know the difference between the two. One of the biggest examples of such a change that is used ALL THE TIME in tutorials is the print function. Python2 print "Hello world!" Python3 print("Hello world!") The Python 3 example works in both versions, but the python 2 example gives a Syntax Error when you try to use it in Python 3. Fortunately, for this example, python will tell you that you're missing parentheses, but imagine how frustrating this would be to someone who is just starting to learn python if they constantly ran into issues like this. Add on the fact that there are a lot of modules out there that say they offer 2.7 support, but usually add on "might work in python 3. Maybe. Probably. We've ported a lot of the code, but user beware". Why would anyone in their right mind ever try to work with Python 3 if they want to actually use the code for more than playing around and learning if they needed such modules? EDIT: Found this lovely chart that shows current compatibility of popular modules: https://python3wos.appspot.com/
I actually don't get kind of his main point: &gt; You may have also said it was the bytes representing 97, 98, 99, and 100. Can someone explain this a bit more? I've never run into/used the case where a string is used to represent bytes that represent numbers. (or have I?) _____________ **EDIT**: Thanks for these answers, but none of this is even remotely familiar to me/have never had occasion to care about these issues, and is making this issue seem even more arcane than it already did. Is this issue only pertinent to a particular subspace of the programming world? u/lengau mentioned IP packets, which I have not had reason to deal with, so maybe that's why? I've done GUI programming, file manipulation, databases, and other basic stuff with Python.
What about http://utf8everywhere.org/? That seems to be a cleaner solution.
Nope, i'm on 15.10 and I got 3.5 installed by default. But 2.7 is also here.
Scripts are indeed very easy to port. Big libs are way harder.
Just in case people come here unaware (and might consider this as a reason to move away from Ubuntu because of a Python 2 requirement): Python 2.7 will still be available in the repositories, but will be removed from the default install. Details are on [The Ubuntu Wiki](https://wiki.ubuntu.com/Python). It's unclear when (or if) they plan to make the `python` command refer to python 3, though one possible intermediate step is to use update-alternatives to let `python` refer to python 3 if python 2 is not installed, or python 2 if it is. There is some dislike of this due to the belief that it provides inconsistent behaviour.
Think about it this way: FORTRAN 77 and COBOL are still in use.
*cough* Fortran 77
If it's a protocol that's not interested in the bytes ascii values, you might use it for numbers instead. Though you'd probably use the struct library to pack/unpack integers to/from bytestrings. In python2 you could interpret the string as an integer like this: &gt;&gt;&gt; import struct &gt;&gt;&gt; s = 'abcd' &gt;&gt;&gt; struct.unpack('&gt;L', s)[0] 1633837924 which is essentially their numeric values shifted in the correct places: &gt;&gt;&gt; (97 &lt;&lt; 24) + (98 &lt;&lt; 16) + (99 &lt;&lt; 8) + 100 1633837924 In python3 you have to use bytestrings for that.
s/'ll give Reddit Gold to the first person who writes the code for the simple animation./Please do my homework for $3.99 Fuck off.
&gt; It's funny, but an unintended consequence of the transition was that the feature freeze and the long term support made the industry see 2.7 as the "business" Python -- the battle-tested workhorse that's guaranteed to stay the same. Sort of how ANSI C is still seen sometimes. Definitely. This phenomenon is also exacerbated by the streadily accelerating feature creep in Python 3. It feels like once they stabilized 3.3, flood gates were open for all sorts of wonky proposals that made it into the language. The result is becoming less and less cohesive, and frankly, more and more unpythonic.
To be honest I wouldn't mind if `python` continued to refer to Python 2 until 2020, as long as Python 3 was always available.
Let's say you're reading a raw IP packet. You'd probably (depending on what you need to do with the packet) like to turn it into a nice happy data structure, but before you can do that, you actually have to receive the packet and keep its raw data somewhere. The packet is essentially a bunch of bits. Thanks to standardization, it happens to always be a multiple of 8 bits long, so you can think of it as a bunch of bytes. So in Python 2, you'd stick it into a `str` object, since that's the most efficient way to handle an array of bytes (if you don't mind it being immutable. Which we probably don't). In Python 3, you'll put it into a `bytes` object instead, since not all of it is unicode. For example, the very first byte doesn't contain text at all. The first four bits of it represent the IP version (in practice, this is either `0100` for IPv4 or `0110` for IPv6), and the other four bits are dependent on the IP version (header length for IPv4, part of the traffic class header for IPv6). 
I have an [old project](https://github.com/nemec/Textecute/blob/master/Textecute.py) that definitely works with Gmail that you can use for reference. One thing I note is that mine calls `server.ehlo()` a second time after `server.starttls()`. What is the exact error message? I haven't seen anything about the SMTP lib being limited to only the default ports.
Hi there. You have posted a learning question to /r/python. These types of questions are far more suited to /r/learnpython, where users are actively interested in helping people to learn. Please resubmit it over there! Make sure to read their sidebar rules there before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." If your question is about homework, show them that you've tried to solve your problem in your post and you should get all the help you need. Cheers &amp; best of luck with Python!
I think the answer to your question is that `str` objects *are* sequences of bytes in Py2. They may or may not also be valid encoded strings. Py3 tries to clearly separate strings from bytes. This is very helpful in most cases, but has caused quite a backlash because a lot of very common data formats are mixtures of text and binary data (e.g. HTTP data) or strings of no particular encoding (URLs, emails, the names of files in ZIP archives), and these are a dick to work with in Py3. Recent versions have improved a lot, however, by adding back text-y features to the bytes APIs.
Also risk. Its not just spending $20K to convert a tool to Python 3. You will still have the fear of the new code breaking and causing some disaster. Executives are comfortable with what has already been proven to work. You can't prove non-existence of bugs.
in case anyone else stumbles across this, the answer was burried in the required arguments for the rotate() method. rotate() takes, as first argument, a reference to a numpy array representing the pixels of the image. The Picture object, which is part of the skimage.novice beginner level module, does not default to returning the array when referencing the object. my_pic = skimage.novice.Picture( ... ) # instantiate a Picture object somehow (load a pic from file, etc...) my_pic.array # this gives a direct reference to the underlying pixel array Thus to rotate a Picture object: rot_pic = skimage.transform.rotate(my_pic.array, angle) # this works rot_pic = kimage.transform.rotate(my_pic, angle) # this does not 
Exactly this. We write our code in Python 2.6 because that's what Ubuntu and RHEL ship with. 
And there wasn't even a nice way to FIND such problems in the general case. At least, not in the std lib. I hear nice things about [unicode-nazi](https://github.com/mitsuhiko/unicode-nazi) if you're into that sort of thing.
Hate parentheses? You could always join the [Dark Side](https://www.ruby-lang.org/). We don't even use parens for most method calls! 
I use 2.7 at my job. My job is "devops". I use it for a number of reasons: 1. Our product is written in Python 2, and there's not even a plan in place to migrate to 3. 2. It works good enough, for everything I need it to do. 3. We use ansible for deployment and there's no python3 port yet. In my cozy little home world of pet projects and what not, where I am the Benevolent Dictator, I use Python3.
Same here. Just yesterday I wrote my first actual Python 3 module, and that was only because the server I run was misconfigured by the auto-conf script to have "python" call 2, but "pip" install for 3. I tried to write cross-platform Python for a while, but I fucking hate those parentheses around what you print, and I can't even explain it because I obviously have to use it for console.log() in JS, which is the language I use the most. :)
&gt; support for grapheme clusters / user-perceived characters might be a reasonable thing to add to the stdlib, imho This would be awesome. Python 3 might take care of a lot of decoding/encoding for you, but you still have to worry about normalisation forms and the like yourself. When you're trying to figure out how you're supposed to treat `GREEK CAPITAL LETTER OMEGA` and `OHM SIGN` as the same characters, automatic decoding doesn't seem like such a big help.
As Simon Peyton Jones would say, it has crossed over the [threshold of immortality](https://www.youtube.com/watch?v=6COvD8oynmI) (as explained in the first two minutes in the talk).
A lot of people tend to ignore the odd numbered versions of Ubuntu, because of lack of Long Term Support (LTS), as well as the dot 10s for the same reason.
I think they should just try and follow suggestions in this PEP https://www.python.org/dev/peps/pep-0394/
&gt; their core banking software was written in COBOL that processed all the bank's transactions. My client is currently rewriting their core system... in COBOL.
Have you looked into using [regular expressions](https://docs.python.org/2/library/re.html)? the library for python is called 're' and will make locating the thumbnail in the wall of HTML text much more versatile. something like: def locate_thumb(html_text): match = re.search('&lt;meta property="og:image" content="(.+\.jpg)"&gt;',html_text) if match: url = match.group(1) return url else: return "Not found!" will search the HTML text for the same string your code is trying to find. Also, if you are looking to make this more efficient (rather than just practice), you can figure out the link to the thumbnail straight from any youtube url link (assuming the URI is 11 characters long): def locate_thumb2(url): match = re.search('watch\?v=(.{11})',url) if match: return 'https://i.ytimg.com/vi/%s/hqdefault.jpg'%match.group(1) passing a url like [this one](https://www.youtube.com/watch?v=PgX49xnAVgw&amp;list=PLE7j5FieXSTc-2gbs7NkrDPhkS_rQS9XT&amp;index=5) to it will return the string: 'https://i.ytimg.com/vi/PgX49xnAVgw/hqdefault.jpg' without using your internet connection.
Which is fine if you don't have a legacy codebase.
There are 2 (or more) ways You can do that. First way would be the way described before by storing the request in meta and then calling it again and again till its over. And the second way would be to abuse the spider idle state where You can push a new request each time the spider gets idle.
Here is a [2014 python survey](http://www.randalolson.com/2015/01/30/python-usage-survey-2014/) published in January. Python2 went from a 56% lead in popularity to a only a 32% lead over the course of the year. Even a lot of educational stuff seem geared to Python 2 and hasn't been updated. I am taking a course in Jan 2016 on Python that will still be teaching Python 2. I'm not dropping the class but its kinda lame that people are still teaching Python 2 in 2016. I'm not a programmer by trade and I'd like to just learn Python 3 without also learning Python 2. If the differences are so trivial I'm being lazy then it also shouldn't be a big deal to just update the course material to Python 3 either. 
As someone working with App Engine right now that knows nothing of deployment, how would I get the same scalability and ease of use from Digital Ocean? Are there any tutorials for people like me to follow?
i use 3 in my job (data scientist + programmer) because of the new stdlib features (OMG pathlib!), the sane str/bytes handling (no more `UnicodeDe`/`EncodeError`s) and easier debugging (“During the handling of above exception, another exception occurred:”)
Wow. I can almost understand patching 30 year old legacy systems ("if it ain't broke, don't fix it"), but **new development** in COBOL? Wow. Is the average age of that dev team 65? LOL.
you can't without doing a lot of extra work and it still wouldn't be as good as the autoscaling app engine provides. not that every app needs ROFLSCALE, but if you do, ae works fine. rafael-py is probably butt hurt because the company wanted to do a django app and they soon realized the orm doesn't work with big table or they tried that django-nosql port that was abandoned long ago. their anger is clearly mis-placed
These comments looks like the fox who can't reach the grapes. I like App Engine and I'm using it. Right now I'm using it for my scripts, not related with web too. If you are smart, you will find App Engine great. Of course App Engine is a tool and sometime you need others tools. For some projects I use other providers like OVH.
On AWS you'd get Elastic Bean stalk. Auto scaling you either do it yourself or you pay for an enterprise solution.
No problem! Google's account security is sometimes a double-edged sword but I think it has more positives than negatives :)
&gt; I would also discourage people from using PHP. It's not the best tool for doing web development, and I could give you reasons for that based on *preference* as well. and that would be an opinion as well(a popular/shared one). but if it was as bad as we think it is, then nothing of value would have been built with it ever. &gt; I'm not missing the point, I am saying that this tool in specific is limited with many things and you as well as everyone should be aware of those. jet plane not good in rush hour traffic therefore jet plane bad.
it's good for big boy apps. for run of the mill boring blog/website bullshit, not so much. 
Thanks. Your lib looks great. I will contribute one way or another once I know a little bit more about the issue.
Thanks. It's still very much a work in progress, but I'm hoping to (at the very least) make text extraction super-pythonic. I'll consider it basically complete when it can (reasonably) faithfully render a PDF into HTML.
I'll second requests. Easy to use, but very very useful, too. 
Fedora doesn't install 2 by default. Ubuntu has like 1 more dependancy which should be gone in 1 or 2 more releases.
&gt;This placed Python 2 in this unfortunate position where it was gaining significant &gt;traction in 2004... but it had arguably the weakest support for Unicode text Pfft; Delphi didn't get Unicode support until 2008-2010 and it's still at a worse-than-Python 2 state.
Yes
&gt; which framework is the best for making games(we don't care about portability to mobile phones)? I hear good things about pygame &gt; which python game framework has highest performance? Trust me: the framework you choose will not be the performance bottleneck &gt; python 2 or 3 (I know this has been asked A LOT, but it's just too hard to decide)? Rule of thumb: use Python 3, if you run into compatibility issues, fall back to Python 2
&gt; Without static typing, enums are of questionable utility. Whoever needed them (like ORM libraries), have implemented them already, which makes interoperability a problem. For most other purposes, there is little difference between isinstance(foo, FooEnum) and foo in FOO_VALUES. Code clarity is not questionable to me, and enum's definitely help here. Also, the interop issues you mention are right, but exist now. You can share enum values across libs that define their own. So having an official at least enum allows a path for lib maintainers to move towards an interoperable future 
https://www.eff.org/privacybadger
That seems like such a tiny issue to be the cause of creating a non-compatible new version of a language. Why did the community think making that change was so important?
Just a note: that PEP was written in response to the fact that some distros have python pointing to python 3. Ubuntu would like to influence future versions of that PEP.
I don't. I use g cloud but for data and analytics. Should have elaborated
Once all the required libraries are compatible and the last refuseniks are convinced. For me, I have a large base of mission critical 2.x code in production that I can't justify the man hours to upgrade until bugfixes and security fixes are no longer available, but policy is new projects are written in 3 unless specifically authorized otherwise.
&gt;You can't prove non-existence of bugs. Isn't that what tests are for?
You realize it's only one extra key press, right? Zero extra if your text editor closes parenthesis for you. Then, with range instead of xrange, and `1/3` instead of `1/3.`, not to mention all the unicode crud you don't have to do, python 3 comes out ahead with fewer unecessary key presses.
Oh that would be sweet! Is it too late to file a bug report / feature request?
I could use it but it requires to write a lot from scratch. Was hoping to find some solution.
For MLB you can scrape fangraphs. No matter what you are going to be doing a lot of scraping so get familiar with requests and beautiful soup 
numpy, re, matplotlib
One lesson to learn from this is that people use things (programming languages included) to solve their problems. If you invent a new tool based strictly on conceptual purity while addressing such a tiny problem, people will be slow to adopt. I feel that the text/binary/unicode bit is too small of a reason for the creation of a backward-noncompatible version of Python. I don't have a problem with it myself, but the popular existence of both versions of a language can be problematic. 
For nba statistics you could use the python client that I wrote, [nba_py](https://github.com/seemethere/nba_py)
Isn't part of what keeps old Fortran relevant, though, is that it's used in classified settings where nobody wants to have to put the entire codebase through a new security review, AND nobody wants to change the code that makes the nukes not fire off by accident? To my knowledge, Python doesn't have THAT kind of baggage. 
I use 2, in the testing world. The libraries when we started didn't support 3, so we've stuck with 2 for now, with no real plans to change. I think it was paramiko or pexpect that didn't have compatibility when we started.
This guys NBA court location write up is pretty good [link](https://www.reddit.com/r/Python/comments/3ibvfg/how_to_track_nba_player_movements_in_python/?)
https://emptysqua.re/blog/how-do-python-coroutines-work-live-coding-video-from-open-source-bridge-2015/ Not saying this answers your questions necessarily, but the talk is very good/clear. Maybe the speaker has others that go into the depth you are looking for? 
Is it possible that a future Python 3 version could be backwards-compatible with Python 2? That seems like a good idea.
When you do [::1000], you are skipping 1000 elements every time you increase the iteration by one, so of course it is faster. If you are concerned about speed, I would suggest you try implementing the program in another language. Python is an interpreted language, so it will most of the time be slower than a compiled language.
Web2py.com?
&gt; Most of my stack overflow reputation comes from that time so there is that too. oh man I missed this lol worthy nugget. you are so cute.
No-one does it better than David Beazley: https://www.youtube.com/watch?v=lYe8W04ERnY
... and with more diverse examples than retrieving HTML pages. 
ugh, fine, I'll send my cousins gifts, you happy??
tl;dw Use the [`verbose_name`](https://docs.djangoproject.com/en/1.9/ref/models/options/#verbose-name) and [`verbose_name_plural`](https://docs.djangoproject.com/en/1.9/ref/models/options/#verbose-name-plural) model meta fields. There is also a verbose_name kwarg for most, if not all, model fields.
Bingo.
ohh ok thanks /u/Vicyorus :) 
or better yet, [try haskell](https://www.haskell.org/) no parentheses for any method (er ... function) calls
Thank you for providing me with an example of indexing. I am not sure if I quite understand, yet. I will get there though.
This is my favorite way of creating the rock, paper, scissors game. Great job. This is to the point and works well. Thank you for providing this example.
Because they're not using [requests](http://docs.python-requests.org/en/latest/) :)
No. It's not so different. For a just-starter, probably the main differences [as listed in this web page](http://sebastianraschka.com/Articles/2014_python_2_3_key_diff.html#future_module) are print and input() and maybe range. He goes over them.
[sh](http://amoffat.github.io/sh/)
No you shouldn't I started with python 3 then shifted to 2.7 and it was pretty much an easy transition
Curiously the same consistent `len` gets reported with this variant: def two(): response = urllib2.urlopen(url) print len(response.read()) But inlining `response` is what triggers the differing behavior. I have no real idea. Ready for some wild, baseless speculation? It may be a bug in urllib2 or sockets. Maybe there's an extra `Py_DECREF` somewhere, and when it tries to fetch more from the socket during `urlopen().read()` it checks the reference count first. Seeing the bugged low/zero count makes it attempt to shut itself down, perhaps as a safeguard to prevent some kind of phantom socket communication issue. By keeping the `response` variable, an erroneous `Py_DECREF` wouldn't be enough to cause any code to think the response wasn't in use anymore, which explains why its presence alters the program behavior. Again, wild speculation. I *could* dig through the urllib2 and socket source code to try and isolate the bug but uh... yeah. I'll pass on that for now. Sorry!
Depending of the kind of data and the calculations, you could use numpy to vectorize your loops. Or run your code with pypy, numba, or compile it with cython. Also maybe pandas could also help. You could also use multithreading, multiprocessing or even asynchronious code. Be a little more descriptive so we could help more. 
If you are just learning, like in the very infancy of learning, it doesn't really matter too much. However if you start any new project on your own, you should use Python 3 for that.
I agree with the above guy. Start with numpy and if that doesn't help, do numba/cython
But all the code I'm writing is in python 2.x???
Example code here: http://pastebin.com/uZjxU99S I created this since I couldn't find a flask-like API for daemons, but I also hate writing logging and configuration boilerplate. If I create a daemon spamd, I want it to automatically have the start/stop/restart/status command line interface, I want it to create PID files, I want it to load configurations at ~/.spamd.cfg or /etc/spamd/config, and I want an easy way to log messages. I always end up with pretty much the same use case, so I figured I'd integrate it into one library that was easy for me to get using right away. Hopefully, it helps someone else! cheers PS: configuration and logging is entirely optional. There's no problem with using your own logger instead, and ignoring the configuration functionality. Just make sure that you set the keyword `pid_path` in the `Daemon` initialization if you don't use configuration though. Otherwise it will default to `/var/run/$app.pid` which will be a permission error for lots of use cases.
What /u/ksion is talking about here are cases like max(dictionary.items(), key=lambda (k, v): v) , the equivalent of which in Python 3 is: max(dictionary.items(), key=lambda k_v: k_v[1])
does python anywhere's free tier go to sleep like herokuapp?
Wouldn't that be a ménage à deux?
Multithreading would be really powerful! I have, on average, 250 things to call data on and there's about 15000 points of data per month. It's timeseries data and when it's above a certain threshold I want to keep track of that time. I call the data for each device in an API call and then iterate through it my method is for j in timeseriesData: ##i get a timeseries list for each of the 250 things if value is above threshold and t1==0: t1 = current time if t1!=0 and current value is below threshold: t2 = current time add t2-t1 to the proper bucket based on the month t1 and t2 set to zero I've never done .... anything in your comment, but I'll start looking into multithreading! any tips?
Just iterating thru the list seems to be taking too much time. Maybe you're thrashing to disk. Does the data fit in memory?
My advice is don't touch the threading or multiprocessing module in python. Threading doesnt work and multiprocessing is not super reliable. Forget about multithreading unless you are already in cython/numba.
If the math is simply, try to install pypy and run your python code with pypy. Maybe the resulting speed up is good enough. If not you can try to vectorize the loops with numpy.
Could it be that ftp.ripe.net is using multiple mirrors, some sort of loadbalancing perhaps? 
huh? when i do number crunching, i always use numpy or pandas types, which *are* concrete. other than that, just use list comprehensions. i prefer `map` for very simple cases (i.e. for mapping an already-existing function to an already-assigned iterable) and use generator/list/set/dict comprehensions for everything more complex.
Why? Why can't the community just use gevent? Why is it needed to rewrite entire libraries, documentation and tutorials? &gt; There should be one—and preferably only one—obvious way to do it. If you're having to modify Hello World! something has gone wrong.
Six years ago (!) I started learning Python. At **that** time I was wondering this exact same thing. I've never worried about 3+, and never had to worry about 3+. I'm honestly waiting for "them" to give it up. 3 just doesn't seem to have the devotion that 2 does.
So when I do the API call I should put it into a numpy array? I'll try that out, I guess using the anaconda distribution?
It has already been tried and it sucked. Even NodeJS people are trying to make their language more like gevent. This results in a huge bulky ecosystem to support this mode of concurrency, with monkeypatching or shittier versions of existing libraries "but with async support!". Look up "tornado" and "twisted" in package repos, see all that wasted time reimplementing existing functionality in the latest popular concurrency framework? Do you honestly call that healthy? You're advocating for more of that. Except in some cases gevent will work with existing code. No need to tell people to learn a thing so they can rewrite all their modules. Just use their existing code. Yes, you're very clever for using Python's generator syntax to perform concurrency. It's a very cute trick worthy of a blog article or two. Lets not get distracted from actually important stuff, yeah? Python is a very powerful and easy to use language, if you've recently come from another you might have trouble working out when to not write code. Even if it seems easier in the short term to invent a wheel you're familiar with you'll do better in the long run to familiarize yourself with the wheels already in use. `requests` and `gevent` result in cleaner code, this results in ugly code, why does Hello World! need to be rewritten again?
yet another convenient mess :(
OH MY FGOD. There was a bug in the code, which was multiplying '2.4' by Billion instead of 2.4................. But not sure why it raised Seg fault 11.... Anyone any idea??? I spent two days on it and still no clear answer. 
This is a *great* video. He repeats a lot of the stuff covered in the really old presentation I posted above—but with the new syntax—so you get a great idea of how coroutines work. A must-watch, IMO.
Succeeding.
Worst of all, they never seem to actually demonstrate any concurrency/parallelism. They just do one async HTTP request, which they immediately wait for. It's hard to think of a more pointless demonstration.
When you start writing Python on your computer, if you ever have to use Python 2 put from __future__ import print_function, absolute_import, division, unicode_literals at the top of all your programs. Doing this will mean that any simple Python 2 programs will behave almost identically to Python 3 programs. Then just make sure you use `print` as [a function](https://docs.python.org/3/library/functions.html#print).
If you've only been programming for a few months then don't bother learning two languages, you'll just get yourself confused and frustrated. Python and Ruby would be particularly annoying because in a lot of ways they're very similar.
Did you profiled it, then? Have you confirmed the time is spent iterating the list?
I just wonder one thing. Why are "you people" constantly using print in your programs? What are you print-ing? Why are you not using loggers so that you can change the formatting and logging level? I'm serious, because personally I almost never use print except for either the occasional print debugging or for very simple one-off scripts. And for the very simple scripts I don't see much difference in the print behaviour, it's not like they spend most of their time writing to stdout.
Well, it's a tradeoff. Either you represent your stuff the way python does (latin1, UCS-2, or UTF-32 based on content) and then use those algorithms, hoping people aren't angry when combining characters fuck everything up, or you have to adapt your algorithms to operate on utf-8 bytes. E.g. that string search algorithm with the jump table (aho-corasick?) can now not jump as far ahead if there's multi-byte characters between the jumped-from index and the jumped-to index, and you have to account for the possibility of landing in the middle of a multi-byte character (skip the rest of it and continue matching the next character-starting byte)
Well there are several new submissions within the past week, so ... yes? https://code.activestate.com/recipes/langs/python/
I am a monitoring analyst and use fabric on windows to run commands on linux via SSH, amazing library, I would also recommend it. The big downside is it is python2 only..
 lambda (a,b): a lambda a,b: a These two looked too alike.
I looked up the site before I posted the question, so I know this, but is it still relevant, is anyone reading/posting here, even noticing it? I didn't care for the past 6 years, so I didn't missed it. Part of my motivation to ask this question is that I observe shifts in attention and activity. For example people seem to like writing tutorials for the community a lot but I hardly see any creative ideas or new perspectives popping up. Everyone works and no one dreams.
The thing is, I often find myself with jsons containing several dimensions of data. Because numpy doesn't serialize nicely as a json and because it's no substitute for a dict, I end up with lists and dicts. Sometimes I want one key sometimes another, sometimes filtered by one key etc. Map and filter with lambdas or simple currying factory functions make this relatively easy. Eventually, I'll turn it into an array for more mathematical operations but the data analysis along different dimensions and conditions is not numpy's strong suit and stdlib is much more annoying now that you can't see the results of a map or filter without iterating them. 
&gt; Look up "tornado" and "twisted" in package repos, see all that wasted time reimplementing existing functionality in the latest popular concurrency framework? Do you honestly call that healthy? You're advocating for more of that. This has nothing to do with what style of concurrency is better or worse, and everything to do with the bass-ackwards style of library design used in the Python community. Gevent, generally speaking, is not 100% good. It adds automatic threading into libraries that may not have been designed for it, and as a result can lead to [*extremely* subtle bugs](http://www.projectcalico.org/the-sharp-edges-of-gevent/). To suggest that dropping gevent into the language makes things better is misleading. *Requests* works well with gevent, but that's because special care has been taken to ensure that the library is mostly thread-safe, particularly around the use of sockets, but many libraries do not work anything like as well with gevent. The reason we have to rewrite network libraries so much is because Python programmers have an obsession with writing networked libraries that embed their I/O layer inextricably with their protocol code. This means that you cannot extract, for example, the session management logic from Requests, because that Session management logic is intermingled with the socket code. That, I argue, is a terrible design anti-pattern that costs the Python community dearly in wasted effort. And it doesn't *have* to be this way. In an ideal world, Requests would be a thin wrapper around a library that does no I/O at all, and Requests would be in charge of managing the sockets. Unfortunately, that's not the world we live in right now, but that can change. For example, I've written a [HTTP/2 library that works this way](https://github.com/python-hyper/hyper-h2), and that includes [example servers written](https://github.com/python-hyper/hyper-h2/tree/master/examples) for asyncio, eventlet, curio, and Twisted. Much less duplication of work, and perfect native concurrency for the chosen framework.
No. Python 3 is purposely not backward compatible with Python 2 in order to fix some design mistakes in Python 2. The string/bytes thing is one example of a non-backwards-compatible change.
Brilliant video thast asks all the right questions. 
I'm working as a scientist, and I tested just now; our main project still has 4 dependencies with no support for Python 3. We're a relatively big group who are into open source software, but we just don't have time to go through these enormous projects. As with lots of OSS things, the original writers have probably moved on to other things by now too. So on that project, we'll probably stick with Python 2. On the other hand, for any new software we write, we always stick to the newest version we can. A huge blocker for scientists in general were three packages which an enormous number of people use: Numpy, Scipy and Matplotlib. Until they were updated, no scientist in their right mind would make the move, and Matplotlib wasn't updated until 2012, so I suppose time wise, most scientists now are where general programmers were in 2011.
we will need to see more code to know how bad yours is. Your answers here indicate there is a bunch of weird things you are doing.
&gt; Who says that undergrads can do cool stuff... they certainly can't explain what it is they did.
I tried to vote in your poll but there was no 'yes' option
2.7 and thank you for asking
This is the first one I've seen.
How does one answer "3, except when I use 2"?
I use both, so I picked 2 because it was the first option that fit.
it was dude 
Ok, thank you for your answer. I think you put me on the right track, I will read up on that.
2.7 at work, 3.5 at home
I am trying to login on mbasic.facebook.com and scrape messages, in order to make a bot. And I need to use the word "pass" since I have to send post data to it
So this is interesting to me. Looks like you can use 'pass' as a dictionary key, but not if you're building the dictionary via the `dict()` function. data = dict(pass='PASSWORD') File "&lt;ipython-input-1-e3fadfec40df&gt;", line 1 data = dict(pass='PASSWORD') ^ SyntaxError: invalid syntax data = {'pass': 'PASSWORD'} data {'pass': 'PASSWORD'} 
TLDR: Conclusion is PyCharm. The thing is that Komodo is not just a Python IDE. It works out of the box for many scripting languages. PyCharm is mostly Python specific. The paid version of PyCharm contains everything that's in WebStorm. If you are programming in multiple scripting languages like Python, PHP, Perl, and Ruby, then Komodo is probably going to be the choice. If you are doing just Python, then PyCharm is it.
3 for my stuff. 2 for other people stuff that I want to use (tools and stuff). If there's is both a 2 and 3 packsge, I take the most frequently updated. Usually 3.
I guess the most obvious interpretation would be to answer which one is your preference or first choice when starting a project from scratch. 
Unfortunately the results blog post is down, but thanks to the Wayback Machine, we can see some of it: https://web.archive.org/web/20150228101023/http://blog.frite-camembert.net/python-survey-2014.html From that there are links to the results in several forms... Here's the Google Docs summary: https://docs.google.com/forms/d/1DqxkNi4GvyTCu54usSdE1DjW29zw1tc52iMeH3z4heg/viewanalytics PDF Report: https://wiki.python.org/moin/2.x-vs-3.x-survey?action=AttachFile&amp;do=get&amp;target=2013-2014+Python+2.x-3.x+survey.pdf Results Dataset (this is so cool! Love the inclusion of error bars...): https://www.statwing.com/open/datasets/c52709b8ae94e6814b4aa23f6b8b12bc8acb0958#workspaces/49957 Also useful... 2013-2014 results: https://wiki.python.org/moin/2.x-vs-3.x-survey?action=AttachFile&amp;do=view&amp;target=2013-2014+Python+2.x-3.x+survey.pdf
What you wrote is bullshit. Not necessarily wrong -- it's just such vague whinging and moaning that I can't even tell if it's right or wrong. Hence, bullshit. Like "half a dozen ways of unpacking tuples" -- er, what? You mean: a, b, c = mytuple What's the other five ways? And (paraphrasing) "Well, I don't actually understand async, but I'm pretty sure it's not adding anything new..." Um, okay, whatever you do don't read the [PEP](https://www.python.org/dev/peps/pep-0492/), you might learn something and we couldn't have that, right?
This I've gotta hear. How is the new string behavior less convenient?
It's been a while since I messed with it, so I don't remember the details. I do a lot of stuff with telnet and ssh to network devices. In Python 2, the text responses I get from those devices is very easy to work with. In Python 3, I now have to deal with byte strings and encoding issues, like printing strings that all start with `b` or `u` instead of simply printing the string. It's been a few years since I messed with it. I got annoyed with 3 and just went back to 2. I'd have to try it again to get more details about the problems I was having. I'm still a noob, so there probably were pretty straightforward ways to fix things. And as I recall, a few modules that I use regularly only work with 2, so 2 it is for now.
Well who said software? If you want excellent formal verification you more or less accept it's a manual process. Now actual software? It's more or less a lot of testing by very smart people (hah!) Python sucks hard as a language to verify anyway. 
I'd have been interested in more context. For example, what type of organisation if it's at work. How many people are using it, etc.
True, although in that case I wonder if there would be any reason not to prefer Py3. The only one I could think of is old habit.
2.7, but want to use 3 :(
Well considering I was in the middle of trying to get assignments turned in for finals yeah I didn't take the time to elaborate how I had to implement all the the instructions in software that would be implemented in hardware. I certainly didn't go into how difficult and rewarding that it was when I was able to implement a stack. Yeah an actual stack with pointers that tracked where it was and use it to recursively call functions. I had to send operands to and pull operands out of the stack. Oh yeah the really fun part was getting all the data into and out of Binary. Tracking your position in your instructions and not only having to understand ASM but use it to accomplish tasks. So you scoff at me for claiming that I created a VM. Well I would like to see your version of it. I would like to see you implement software that can take in assembly instructions convert them to binary then execute that binary. I'm not talking no sissy add subtract calculator. I mean making it so that you can do function calls. Don't take the easy way out and use labels everywhere to control you flow no you gotta put those pointers where your program counter should return to on a stack then jump care free out into another section of binary code with only your stack to get you back. Then have the audacity to not use your registers to pass the functions parameters but put them on the stack also. Pull them off when you get there. Then jump back. Oh and the kicker of it all, you have to make it multi-threaded. TL;DR; Yeah I can explain what I did. I did do what I said I did. I just dumbed it down for people like you. 
Because this is Python 3 week on /r/python. Didn't you see all the posts?
Of course. I write and debug small programs, too.
What's weird about iterating through a list and deciding if you care about the value?
I stand corrected. My understanding was based on the [documentation](https://docs.python.org/3.5/library/struct.html) which reads (my emphasis): * Unpack from the **buffer** buffer (presumably packed by pack(fmt, ...)) according to the format **string** fmt. 
Thanks for that. I'd heard the name, but I never put two and two together. 
&gt; I do acknowledge that gevent is not a perfect solution but I see it as not much different from dealing with PyPy incompatibilities It isn't. But it's something that often needs to be considered when you're writing your library. It doesn't Just Work™ &gt; I don't want to litter my code with generators and callbacks. Clearly you haven't written anything using `asyncio` or Twisted's `@inlineCallbacks` (well, not properly, anyway), otherwise you'd know that you don't have to "litter [your] code with generators and callbacks". 
Did you mean to link to anything?
Ah I see what you're trying to do now. Someone else already covered the problem/solution but I'll add: The reason I said you don't have to use reserved keywords in assignments ever is because a variable's name has no inherent meaning. As people, it's nice to make them meaningful, but computers could care less. The issue was just that you were using a sort of odd dictionary construction pattern. A dictionary literal in that case would be more common and avoid your issue entirely. Edit: these are the docs I was looking for [mapping types](https://docs.python.org/2/library/stdtypes.html#mapping-types-dict) Specifically the line "Providing keyword arguments as in the first example only works for keys that are valid Python identifiers. Otherwise, any valid keys can be used."
Try using the open source SFrame package (use pip install SFrame). It uses disk-backed data structures, so it should scale well. I've used it 20+ GB compressed csvs several times on a laptop without issues. Full disclosure: I also work for the company that backs that project (Dato), and we use it heavily on many large datasets. 
Okay, not to really completely agree with the /u/johninbigd, but I actually kinda get him on the parens. It isn't so much about making sense as it is being annoying if you do a lot of trivial scripting that uses print statements. It is the one thing about 3 that very slightly annoys me over 2. I get why, but it makes me type more which I don't love.
2.7
"develop a website", well, I assume with "develop" that you are saying "Python based", first recomendation here is that sometimes a simple (and free) Github pages can be enough. Now, with python, for free, you can BEGIN with Heroku (https://www.heroku.com/) or Python Anywhere (https://www.pythonanywhere.com/). Remember the word here, "BEGIN". If the site is more visited, then you will require more services and both ones have begginer accounts (for free) that you can upgrade for more capabilities. My understanding is that Heroku you will pay more, because you have more services, but sometimes, PythonAnywhere can be enough for your work.
Python 1.x. . . I'm old school.
I'd like to propose "2.7 but I often talk longingly to my coworkers about migrating to 3 and make snarky comments every time we need to deal with unicode" as an option.
Python does not usually use linked lists. Consult materials for your course to better understand what a linked list is and how it works. If you have questions about linked lists, ask your TA or ask in an appropriate learners' forum. (This question is not Python specific so I don't know whether /r/learnpython is applicable.) When you ask, be sure to explain what you understand and what you've tried, to give people a better idea of how to help you.
At work, our new projects are 3 and our old projects are 2. I think that's normal. 
2.7 due to the need to create scripts for some very old boxes
&gt; Have you confirmed the time is spent iterating the list? DEVELOPMENT So, as many of you are aware, I am in fact an idiot. It's taking the program only a few miliseconds to go through all the data and it is actually the API calls which is slowing the program down. I will try to call in batches from the API and that should solve my problem!
&gt; Are there still any reasons not to use Py3 for a fresh project Because you need specific libraries...I'm finally getting my VTK 7.0, which supports Python 3, but my code functions best using VTK 5.10. It'll support VTK 6 with a version check, but things aren't perfect. It doesn't help that the VTK examples don't actually support the different versions properly. Some examples have `if version_5`, but others don't and only work in 5. There also needs to be way better unicode tutorials.
Thanks, that was helpfull! I still do need some more to make a "click" in my brains, but this will keep me going. 
Hi there. You have posted a learning question to /r/python. These types of questions are far more suited to /r/learnpython, where users are actively interested in helping people to learn. Please resubmit it over there! Make sure to read their sidebar rules there before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." If your question is about homework, show them that you've tried to solve your problem in your post and you should get all the help you need. Cheers &amp; best of luck with Python!
What a man and his interpreter do behind closed doors is nobody's business.
I'd start with global last_activated global current_song global next_song_time global is_playing global is_initialized global song_name global songStartTimer global songStopTimer 
That is pretty much our situation as well.
Excellent. Thanks very much for that. Love the fact that this thread makes an appearance in the output. /Inception Unfortunately, now my comments in this thread are incorrect as a result. Damn your eyes, OP! 
Hahahah just read your most recent reply.
Yeah but they fucked everything up with the transport layer change and the 3rd? build / package system in 3 years...
Uhh... What? I use *both* versions, how can I make a decision about which one I use if I use both?
Damn hipsters need to stop shaming the 2.* code that was written back when they were still in high school. You'd be writing Java if it wasn't for us early adopters! Java!!
Sounds great, haven't used it personally. This is more for one off scripts that make more sense to run as a daemon, and it only takes a few lines to do so. You can just add this: from angelic import Daemon daemon = Daemon('small_script') @daemon.daemonize def main_func(): ... daemon.parse_args() and with that you turn a small .py script into a daemon with a start/stop/restart/status interface. Supervisor sounds like a great thing to use, but if you don't need the client/server interface and all that, angelic might be quicker to throw into a script.
Snap. 'Syntax Error', all the time. Edit: to expand on this, I debug with 'print'. Yeah, yeah. I know I should use logging. Whatevsssss
That's pretty cool. How was this done?
3 when I can, 2 when I have to (*cough* Django *cough*)
This is such a problematic question. I have sites running on Python 2, so I use 2. I also have sites running on 3, so I also use 3. There are some libraries that aren't available on 3, so I keep those projects in 2. One some systems, 2 runs by default when I type python. In others, 3.
At work its 2.7 on my hardware and 2.3 on the customers. Python 3 for private projects.
Sounds like Python 3 would be your answer then?
When posting a link, the site will put parenthesis around it, but everything else is not formatted. Thank you so much for your comment!
No, I make an informed decision based on the context of the program I need to write like I should do instead of being forced between one option on a poll?
In my (admittedly limited) experience, formal verification is more of a tortuous exercise in removing logical bugs and replacing them with specification bugs. I'm not convinced by the argument that "oh well if you launch space rockets you'd use it" since the most famous bug I'm aware of that brought down a space rocket was, well, specification related (using the wrong units). Since formal verification makes specification *harder* I really don't see it doing much good.
Right. I just meant that they're kind of an annoyance. It's not a big deal, just one of those little things about switching that is a minor irritant at first.
I haven't been following up with that since I should (hopefully) graduate in March. Rviz has been hard to use, so I'm rolling my own thing with OpenCV. Could you give more details on what changed?
3.4+ or bust. One of the awesome things about writing research code is that I'm not stuck using ancient stuff unless that's what I choose. 
Or, you know, use a debugger. :P 
Nobody is forcing anyone to switch to Python 3. Python is a free, open source language, and if you don't want to switch, you don't have to. You can still can get four more years of extended support from the Python devs for free, and then at least three more years of paid support from Red Hat beyond that, and if you still don't want to switch just take a copy of Python 2.7 and ... don't switch. There are still people today who are quite happily running their scripts using Python 1.5 on ancient systems that haven't seen an upgrade for a decade and a half, because if it works it works and they don't care about vendor support or security upgrades. Good for them. Not *many* people, it's true, but the principle is the same.
2.7 all the way.
Sure, Haskell.
The problem is you are posting the poll in /r/python. Most people who are Python enthusiasts use Python 3. That doesn't mean most programmers who use Python use Python 3. Maybe /r/programming might be a better place to have the poll? 
answered the comment above.
Dependencies...
I'd probably go with pygame 
It's a good point. Thanks!
What would you do differently?
Change is generally viewed as terrible. Remember the whole python 2/python 3 fiasco
Thanks, yep thats a good fix too. I always start with Flask since I find it much simpler to get going.
Change it to `pwd = PASSWORD` `pass` is built in and should not be used
use pastebin.com or pastie.org
Eh, I run it on a mac. I look at it and I think personal computer, not pycharm. The old log was great. The old logo [run through Deep Dream was even better](http://blog.jetbrains.com/pycharm/2015/08/googles-deep-dream-in-pycharm/)
Django supports python 3
Or "we're giving up on Python 3, turns out Python 2 was fine."
Overly snarky comment feedback is literally Hitler. Seriously though, I get sick of these kinds of comments on Reddit. This is clearly a small poll being done by somebody who's curious or wants to write some blog post and put it on /r/dataisbeautiful or whatever. It's not going to solve the national debt, or claiming to be written by Guido himself. Sure, the poll should have a "both" option, but why shouldn't your causal user vote be equal to a full time Python dev's? Saying "this poll irrelevant" or "pointless" is totally unfair, and puts a needlessly combative attitude out there. I'm not trying to pick on you alone, there's *plenty* more of this snark a stones throw away, this comment just put me over my BS line for the day.
Not that it is what is holding me back... But what was wrong with print as a statement? 
You could try [xlwings](http://xlwings.org/).
Using the Win32Com package, you can [use Office Automation](http://win32com.goermezer.de/content/category/7/86/192/) to control Office, although I'll be honest: Office Automation sucks. Sadly, it is the only tool you have to automate Office (short of using VBA macros, which just wrap around the same Automation layer anyway).
Many Delphi users refuse to believe it's in the 20 or 30 range and insist that there are as many Delphi users as Python users! I kid you not, sadly. 
&gt; It isn't. But it's something that often needs to be considered when you're writing your library. It doesn't Just Work™ Unlike PyPy? &gt; Clearly you haven't written anything using asyncio or Twisted's @inlineCallbacks (well, not properly, anyway), otherwise you'd know that you don't have to "litter [your] code with generators and callbacks". Or decorators. I want to use existing code. Why are you dismissing the value of being able to use existing code? Go on, keep telling me why I'm wrong for not wanting a "hottest 2012 trend" library ecosystem cluttering up repos and wasting programmers' time. Should have let the fad run its course before considering adding it to Python.
I CAN HAZ VOTE MULTIPLE TIMES 0 DAY PWNED LOL!111!!!! #pythonsquad
pretty sure a click of a mouse is faster than typing "print 123" :)
2.5 at work [:"(] 2.7 in my legacy projects I didn't really have a chance to use 3.x in any meaningful way yet
I personally am serious about this. Good for you that you don't print out characters to the console (or files) often. For me it is probably also simply the way I learned it in the first place and personal preference. Add to this the fact that it is not very easy to define in a script which interpreter to use on Windows, so in the end I just stick to what I have usually. It's not like Python3 offers something more or greatly improved, the type hinting stuff might be a reason to switch in the future though. Changing operating systems once support for Windows 7 runs out (and then just installing Python3) might be a similar reason though.
I've found comtypes to be a good alternative to win32com. I wouldn't the COM API sucks but it is a bit hard to find documentation. I found that searching for VB examples was best and the conversion to python was pretty obvious. 
Based on how I see this on my phone, it looks pretty neat. I actually added that to my bookmarks. Hope you very best with this projects!
It's more the Office Automation API sucks more than anything else.
&gt; Good for you that you don't print out characters to the console (or files) often. He/she didn't say that. They said they don't use `print`. I don't use it either but I use `log` in everything I write. 
Same. Don't always work in Python but that's I divide it as well. If it's to be a new project it will be 3.x the old projects will be stuck on 2.7.x
Oh wow, they actually *are* saying "we're ending support for 2.7 in 2020. Please move everything to 3 before that". Good idea there YaoPau. [https://hg.python.org/peps/rev/76d43e52d978](https://hg.python.org/peps/rev/76d43e52d978)
Where's the source?
I could have phrased it a lot more delicately, I'll give you that. Should probably have done that. But then “literally Hitler” puts your phrasing so much more firmly beyond the realm of decent interaction that you completely undermine your whole argument. I'll take that as an opportunity to feel smugly superior and bid you a good day, Sir. x)
I'm at heart a Python guy, but my first real development job was on a Rails app. Ruby and Python are really not a great combination of languages to learn because 1) they cover essentially the exact same territory as each other (dynamically typed, interpreted, yada yada) and 2) their syntax is so close as to cause constant confusion. For example, in Ruby the @ symbol denotes an instance variable, the equivalent of self.foo in Python. In Python, @ denotes a decorator. That confuses the hell out of me everytime. My other two big gripes are the fact that Python is whitespace active and Ruby isn't (I'm constantly forgetting "end" in Ruby) and Ruby has an annoying "feature" of implicit returns, meaning you don't have to use the "return" keyword. It'll just return the result of the last operation you did. Its.. annoying. I definitely think you should learn a second language that has a different footprint. Maybe learn a statically typed compiled language like C++ or Go. Or learn Javascript. As for Python vs Ruby, my typical answer is if you absolutely, absolutely know you only want to do webdev work, perhaps go with Ruby. Rails is a pretty good framework, and there's a larger community there than Django or Flask has. However, there's the caveat that there's a pretty general sense that Rails is on the way out and they're talking about what to replace it with already. Python, while the web frameworks are slightly less popular, has a wider footprint and is the go to language in a lot of fields, like data analysis, scientific computing, machine learning, etc. That'd be my choice.
Opinions are like assholes
Why do you consider the transport layer change a fuck up? I know of it, but I haven't followed it closely, so I don't really know. I also didn't realize they were talking about changing their build system again, that's just funny..
Agreed, can we make this a package? I want a raise "should be using py3" error everytime you need string decoding/encoding 
I'm also serious about it. From the beginning print should have been used and called as a function, but it wasn't. There are plenty of necessary changes to python that broke backwards compatibility 2 -&gt; 3. The print statement is not one of them, not even close.
some assholes are better than others
Do you think mutagen is more extensive?
I use print. Guido uses print. Production needs logging. I setup logging immediately now. Hard habit to break, but its so damn quick. 
&gt; Unlike PyPy? You misunderstand: &gt;&gt; not much different from dealing with PyPy &gt; It isn't… That is to say, I was agreeing with you. &gt; I want to use existing code. Why are you dismissing the value of being able to use existing code? I'm not. There is an obvious huge benefit to being able to use existing code. But then we come to the next point… &gt; Go on, keep telling me why I'm wrong for not wanting a "hottest 2012 trend" I've been using Twisted for over a decade. Your "hottest 2012 trend" is my old, old news, and correspondingly, I've been writing my code that way when appropriate, instead of the "normal" way and then hoping `gevent` could bail me out when that turned out to be no good. &gt; cluttering up repos and wasting programmers' time. I have no idea what you mean by that. &gt; Should have let the fad run its course before considering adding it to Python. It isn't a fad. As noted, Twisted has been doing this for over a decade. It is a *very* mature model (far more so than `gevent`). IMO, it boils down to where you lie on the explicit–implicit continuum. Being able to just drop `gevent` into your existing synchronous code is great, *when it works*. `asyncio`, like Twisted, is *explicit* wrt what is async and what is not. I like that. `gevent` is a hack. It may be a damn good one, but it's a hack. I'd go with stackless over `gevent` any day. 
&gt; a submodule has to exist as an attribute in a parent module Not actually true. The name appears to be assigned in the parent module on first import; subsequent imports will use the object in `sys.modules` directly.
&gt; I've been using Twisted for over a decade. Your "hottest 2012 trend" is my old, old news To you perhaps but for the general programming population that style of programming hit its peak around 2012, probably due in part to NodeJS. &gt; I've been writing my code that way when appropriate I remember this saying from my time with Tornado. It means "don't shit up code that won't benefit from being shit". What if I don't want my code to be shit in any case? &gt; , instead of the "normal" way and then hoping gevent could bail me out when that turned out to be no good. I decide on using gevent from the start and deal with issues as they arise, not any different from if I was using Tornado or asyncio or PyPy. For a fair comparison you should "drop-in" Twisted or asyncio into an existing project and note how it measures up against gevent. &gt; It isn't a fad. As noted, Twisted has been doing this for over a decade. It is a very mature model (far more so than gevent). If it's not a fad then why didn't Twisted catch on in a significant way? Why did alternatives such as Torando show up instead of Twisted being developed further? It's because they produce an ecosystem littered with terrible code and forces its users to use it, eventually the quality gets so bad that it can't attract any more users and the "fresher" solution becomes more popular. &gt;&gt; cluttering up repos and wasting programmers' time. &gt;I have no idea what you mean by that. All the support packages and reimplemented libraries needed to do things that can already be done with existing libraries but with the new technology need to be programmed, the programmer could have done other things. Also all these packages end up cluttering search results. &gt; Being able to just drop gevent into your existing synchronous code is great, when it works. Being able to just drop your existing code into PyPy is great, *when it works*.
All 15000 people in your company have one IP? What the fuck?
This is a cool idea. Do you do anything to compensate for latency, or do you find that it's small enough that you don't notice? 
Use capnproto instead?
The whole trick is compensating for latency. A deviation of ~30 ms in playback is noticeable and annoying, so latency is very important to fix. Typical server-to-client fly times are 2-30ms on regular computers, and even larger on Raspberry Pis (which I'm optimizing for). I also take into account the static difference between server clock and computer clocks which deviates anywhere between -10 and 10 seconds. The specific method is [described here](http://www.mine-control.com/zack/timesync/timesync.html), which is simple but works great.
It was sort of tongue in cheek. The parentheses are not a big deal. :) It's dealing with ASCII when using telnetlib and paramiko that is a pain. 
Just doesn't make any sense. See [Guido's email](https://mail.python.org/pipermail/python-dev/2005-September/056154.html) for some explanation.
Why not just use pulseaudio?
I was aiming to get something working on Raspberry pis, to which [pulseaudio has had problems](https://www.raspberrypi.org/forums/viewtopic.php?f=38&amp;t=25684).
As long as 2 is the default on systems this isn't going to change. It's kind of a chicken and the egg problem. 
Again, if it's a pain you're not doing it right. If you're finding something inconvenient, create a small wrapper to make it the way you want.
What is it with people and having enough laziness to feel like writing `print()` is a pain, but not having enough laziness to set up their editors so they never have to write `()` ever again with *any* function?
You know who else felt smugly superior?
Make it some sort of game.
&gt; To you perhaps but for the general programming population that style of programming hit its peak around 2012, probably due in part to NodeJS. So, what's your point? Most people weren't aware of async till 2012, so therefore…??? &gt; What if I don't want my code to be shit in any case? Err … don't write shit code? If you've been paying attention, you may have noticed that `asyncio` and newer version of Twisted do a great job of letting you structure most of your code in a classical, synchronous manner. Indeed, that's kinda the point of `async` and `await`. &gt; If it's not a fad then why didn't Twisted catch on in a significant way? Because Twisted is complex and its developers have never made any meaningful effort to make it accessible. Its documentation has always been an extraordinary kind of shitty. Simultaneously extensive *and* useless. When Facebook came looking for an asynchronous solution, they mistook the mature and production-ready Twisted for a dead project. So they rolled their own instead. The harsh reality of Twisted is that the core developers have fucked their own project over by being incapable of or unwilling to write documentation and/or high-level wrappers that are useful to "normal" programmers who aren't already familiar with how async shit works. If you read anything by glyph, the lead developer, it quickly becomes clear that he isn't able to express himself in a broadly-understandable way when there are hyper-technical CS terms he can throw around instead. Twisted is Python's dojo. A lot of people who made the effort to grok dojo, despite the lack of docs, think it's better than jQuery. But by the time the dojo folks got around to writing useful documentation, jQuery had eaten their lunch. That is Twisted. And the documentation is so fucking terrible that `asyncio`, which came along over a decade later (and is way, way behind Twisted in terms of what can be done with it) is now going to do a jQuery to it. /rant &gt; All the support packages and reimplemented libraries needed to do things that can already be done with existing libraries but with the new technology need to be programmed, the programmer could have done other things. Eh? Adding new libraries somehow cause more clutter than adding old ones? I'm guessing there's a valid point you're trying to make, but I'm not sure what it is. &gt; Being able to just drop your existing code into PyPy is great, *when it works*. As stated above, I agree 100% on this point.
Note that Python 3 has ThreadPoolExecutor https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor
3 only
Very cool! I've been thinking about doing a multi-room, cross-platform audio thing. I'd love to integrate w/ kodi (since that's what I use for all my audio), but that's optional. One funny suggestion; I'd definitely reconsider your name. It's really clever (mu-sic), but essentially ungoogleable. You can always search for "python multi room audio music by schollz" or something, but otherwise the name itself is very generic. Just a thought, since changing the name now is easy (before you gain momentum). I might take a look at this and try it out.
&gt;&gt;To you perhaps but for the general programming population that style of programming hit its peak around 2012, probably due in part to NodeJS. &gt;So, what's your point? Most people weren't aware of async till 2012, so therefore…??? Fads aren't a good reason to add bloat to Python and waste Python devs' time. &gt;&gt;What if I don't want my code to be shit in any case? &gt;Err … don't write shit code? Of course you don't write shit code, you "exercise your professional judgement to determine whether or not the *complexity cost* is worth the performance enhancement". &gt; you may have noticed that asyncio and newer version of Twisted do a great job of letting you structure most of your code in a classical, synchronous manner. If it's so similar why not support the same synchronous code that is conventionally used? Gevent manages this pretty well. &gt; Because Twisted is complex and its developers have never made any meaningful effort to make it accessible. Its documentation has always been an extraordinary kind of shitty. Simultaneously extensive and useless. Do you think depending on the construction and maintenance of a shadow ecosystem made good documentation easier or harder to come by? &gt; Eh? Adding new libraries somehow cause more clutter than adding old ones? I'm guessing there's a valid point you're trying to make, but I'm not sure what it is. Libraries that accomplish existing functionality "but using &lt;framework&gt;" cause lots of clutter for people not using that framework. It's completely unreasonable to expect such libraries to have the same quality and reliability of their conventional counterpart. &gt; The harsh reality of Twisted is that the core developers have fucked their own project over by being incapable of or unwilling to write documentation and/or high-level wrappers that are useful to "normal" programmers who aren't already familiar with how async shit works. If you understand the harsh reality of the general population avoiding frameworks with bad documentation why are blind to the harsh reality of the general population avoiding frameworks that require them to use its shitty shadow ecosystem? &gt; If you read anything by glyph, the lead developer, it quickly becomes clear that he isn't able to express himself in a broadly-understandable way when there are hyper-technical CS terms he can throw around instead. CS experiments are fascinating but experiments tend to fail more often than not. Should Python be taking the hit for this experiments' assumed eventual failure?
How do you show the image on the screen, instead of saving it? I tried uncommenting the img.show() but it didn't work. I'm looking here, but can't find any help. Does anyone have a link to better docs than this? http://effbot.org/imagingbook/imagedraw.htm#tag-ImageDraw.Draw I'm digging into those docs. There's more there than I thought at first....
I am not sure that I understand the entire set-up, nor am I a professional. However, users of conda can create packages with conda. [Here](https://conda.anaconda.org/) The instructions are toward the bottom. Have you tried ansible? Maybe you can still get the control you are after by simply running a playbook with respect to the global and userland anaconda env(s).
[removed]
Did schools even exist back then?
*only
eyed3 can't handle aac last I checked, so if you want to support other audio formats you may want to switch to mutagen, it is more complex to get going but has more features.
Add pew pews?
I don't know about that. I downloaded python 3.whatever at the beginning of the semester for programming class, it included the PIL and other libraries automatically. I can check the syllabus and post links for exactly what version I downloaded later.
Ah OK. I need to do things like plot vector fields on 3D meshes and apply colour maps and things depending on the component, so maybe it's not quite enough at the moment. I'll keep my eyes open though - thanks for the tips!
Yeah, verification in my experience is you spend all the time and money you have identifying and mitigating risks, based on requirements, until you're forced to accept the remaining risk or raise a flag that more time or money is required, or a waiver indicating someone higher accepts the risk instead. You're never 100% safe, but you accept with some confidence the marginal chance that a failure could occur.
Hi there. You have posted a learning question to /r/python. These types of questions are far more suited to /r/learnpython, where users are actively interested in helping people to learn. Please resubmit it over there! Make sure to read their sidebar rules there before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." If your question is about homework, show them that you've tried to solve your problem in your post and you should get all the help you need. Cheers &amp; best of luck with Python!
Can't believe I missed that! Thank you :) (Sorry to the rest.)
Sounds cool! pyqtgraph has a really great examples GUI that will show what it can do. import pyqtgraph as pg from pyqtgraph import examples examples.run()
Never heard of him, but I really like his stuff. Gives me a few ideas. I was actually inspired by [this quilt](http://i.imgur.com/ilLuMg9.jpg).
Hi there, I represent Electronic Arts, Inc. I was just letting you know you got the job
with this specific chunk of code, over time sqllite would likely be faster since it's dumping the entire dict to JSON and then writing the entire JSON blob to the file in every single loop iteration. Being able to just add a new record to the db on each iteration and only writing that new data would be a performance gain over writing out the entire thing every time, especially as it has crawled more and more things.
Try File-&gt;Invalidate caches/restart
Technically you can't, because classes don't exists in Go. But Go has a similar structure called 'structs'. You can use them as [this example](https://github.com/go-python/gopy/tree/master/_examples/structs) shows.
Try /r/learnpython
[Matplotlib](http://matplotlib.org/examples/index.html) can do it. Search the provided link's webpage for `color` and you will find a lot of examples of how to do color bars, color maps, and color line graphs. And you can probably search the web for the actual wavelength function.
Especially since you can also put () around your string while printing in Python2 as well.
By which I mean, try asking there! 
Rename the project folder on disk and try to open the project entry from pycharm.
I'm going to expand to other formats soon, I will give mp4 a try. [Stay tuned](https://github.com/schollz/music/issues/13)!
that has nothing to do with an authentication at a proxy.
Thanks, I will definitely reconsider the name ;) EDIT: Renamed "musicsaur"
I don't know exactly. It may vary, of course. Don't all proxies have the same auth process? In particular, a pop up window.
Komodo's fatal flaw for me was the way it handled commenting. * Not a toggle, but 2 keys... An on key and an off key. * Select multiple lines, get single line commenting on each line. * Select part of one line, get multi line commenting on one line. * You can't choose to use multiline commenting. It is the most backwards thing I've ever seen in an editor.
* Close all your open projects (File -&gt; Close Project on each one) * On the "Welcome to PyCharm" dialog, hover over the project you want to forget * Click the X to the right of the project
Considering you made these programmatically, you should go the extra step and make them as SVGs instead of raster images.
&gt; If not, why has this piece of programming culture withered away? The first place someone looks for "how do I... ?" is Stack Overflow and the search ends there unless it's highly obscure. In which case it's probably unique enough that a recipe won't help the next person. David Beazley has written a very useful Python Cookbook which contains some very useful stuff that does things many might not think of. The other stuff like "Search for oranges in Python with the wikipedia library" is just a re-make of the tutorials for the library used. I cannot see what its use is, except to cargo culters who can't understand the library docs and need to copy the code.
Not just yet. Needs more paths to inject DLC.
Obviously, because a proxy doesn't use a html form-based authentication.
will its not obvious, since you said you open it in a browser but ok
I learned py2, had absolutely no problem changing to 3... well maybe little easily fixed problems. One you know the big things that are done differently it's really, really simple to switch over, especially as a beginner with no deeply ingrained habits 
When choosing a project from the starting screen, hold your mouse over the project and press the DELETE key.
Now that your question is answered, There's ways to not keep the whole array in memory if you want to have better control than the OS paging. Memmap I think. But more ram may decrease your execution time enough to be worth the extra cost.
Thanks for expounding! I actually love this stuff and don't think it harms anything - all of this to me is an effort to make the * and ** behavior as universal and intuitive as possible. I was just suggesting that some of these fantastic developments may be what the previous poster was referring to.
Thank you. I didn't know of [memmap](http://docs.scipy.org/doc/numpy/reference/generated/numpy.memmap.html)'s existence. It might be handy in the future.
There's also pytables. I found this: https://kastnerkyle.github.io/posts/using-pytables-for-larger-than-ram-data-processing/
But a lambda *is* a function which is why the restriction is stupid.
why do you insists on having complex inner functions? They just make the code harder to read. i guess you come from a java background yes? python is a language that is not only focused on efficiency and speed but also on readability. it is a very nice language to learn due to that,but for it to stay that way one has to make sure that certain "antipatterns" are not even an option. complex lambdas (such as inner functions in java) may have their uses in other languages. But python isn't those other languages, readability counts
&gt;i guess you come from a java background yes? No, I come from a python background. &gt;why do you insists on having complex inner functions? Allowing statements or a second expression isn't going to make your code unreadable. People writing unreadable code will find a way regardless of language features.
QuokkaCMS is an excelent Python CMS.
Oh shoot, now that would be neat! I have no idea how I'd go about doing that though. 
What are SVGs and raster images?
What is your email? I have created a slack team that I hope will encourage discussion among redditors and possibly form a viable team.
Definitely, but with all this talk about protobuf some people might not know that there are better options out there.
http://vector-conversions.com/vectorizing/raster_vs_vector.html
Thanks for that
Ok, since no one is replying to my post, I'm gonna do it myself :) I installed python3.5 on my computer to see how it runs, and it didn't. So I once again changed the code and now it runs fine with python3.
I was actually experiencing the exact same thing when I upgraded last week, at a Glance the Konsole and PyCharm icons look way too similar now on the task bar and now it takes me a moment each time to figure out which one to click on... annoying. I can live with the rest of the new design, but the PyCharm icon just looks way too similar to Konsole, I preferred the colour icon rather than monochrome icons which seems to be a trend.
Yes, Stack Overflow is a shift to "customer driven business" so to speak. That's an important shift in perspective and attitude. Otherwise I don't like to debate the usefulness of Cookbooks in general but I remember that people like A.Martelli or R.Hettinger also posted stuff there, the latter even frequently. So it wasn't quite a niche for 2nd rate programmers who rehashed trivialities.
"yes"
Just brainstorming here, but if you know the size of the iamge and the size of the squares, you could load the image, choose a square or two at random, flip it vertical or horizontal, or invert the colours or plain replace it with a new square. It's be an interesting looking thing, seeing it changing small parts at random. I have no idea how you could use that as a wallpaper though! 
Nice article. I've a question that people might know in here. Is there an engine like Unity or Unreal Engine for Python? I'm a web dev (started with PHP that's a poorly designed language). I had the occasion to try Python dev (with Flask) and I just like the language. I'd love to code my game logic in Python and not having to worry about the engine. Is there a solution for that, like a Python or a language agnostic engine? What would be your solution for that?
Does it have to be in a shell? you could make a simple tkinter dialog box
This is cool -- didn't realize such a data structure existed... [WeakValueDictionary](https://docs.python.org/2/library/weakref.html#weakref.WeakValueDictionary) It's a dictionary that contains weak references to things, which offhand sounded dangerous. But -- they get removed from the dictionary automatically when they are destroyed. Neat-o!
If you don't want to have to do the web scraping parts you can use my client for stats.nba.com called [nba_py](github.com/seemethere/nba_py) Nice article BTW! Really cool stuff!
Bokeh is another pretty cool library that I have been using lately for graphs on the web. http://bokeh.pydata.org/en/latest/
Unreal Engine uses Visual Scripting which is about a million times easier to pick up than Python, if I did my math correctly. It can take some time to understand, but it is actually pretty enjoyable to use.
Nope. But recently someone made an extension for UE4 that allows you to script in Javascript so a python one is probably possible if you've got the time and the will.
Flask is certainly not dead (or unpopular); it has a very active community in the #pocoo irc channel.
Yap. I was a bit distracted with two other projects of mine. I will try to remedy the Flask release situation over Christmas.
What about Python3?
It's not really stagnating.. Like the guy said "barebones" and just because it doesn't have a huge community (which I think it does you just have to find it) like Django, it still does what it does well. There is alot of trends out there and yea you can follow them because of employment offers but flask is a beautiful beast by itself.. (Coming from someone who started on flask first before Django)
[other environments do move](https://github.com/KeepSafe/aiohttp/releases) &gt; asvetlov released this 24 days ago &gt; &gt; […] &gt; &gt; Add Python 3.5 async for implementation to …
Thanks! Adding unicode_literals and removing all my old explicit string casting seemed to do the trick. Code is also much cleaner now. Thanks a bunch!
python3 for school and personnal projects
Wasn't actually commenting on Flask in particular, just you downplaying the importance of updates. Python itself is changing and I'd argue libraries should keep up with its new features. 
That's pretty awesome, glad to see `async for` in the real world. 
Ugh. What a mess. Thanks for the links. Fortunately, my tests are passing so I think this is okay for me right now.
I don't read French but what happens if the user tries to send an email of arbitrary size? Construction of the string could grow exponentially, so set up a limit on the length of all incoming data. I had something here about string encodings, but that was because I hadn't notice you set your sys default encoding. Validation of emails with regex is pretty useless, but not too harmful (email addresses are notoriously hard to actually validate using email). Hopefully I'm covering some of the major points and I'm not getting anything wrong. 
The French part is quite unnecessary. You could replace the text with anything you wish and the app would function the same. I'll try to limit the request size, good idea. I modified my post so it's clearer what the form does.
 asyncio support would be nice. A lot of the third party plugins for stuff like WebSockets are broken/buggy and would be nice to have built in. 
Not saying it's your job to fix WSGI's issues or that you're to blame, just that from a users perspective things could move faster. 
&gt; from a users perspective things could move faster. I think fast moving is precisely what I never wanted because it leads down terrible paths. I rather err on the side of caution.
Fair enough!
[KivEnt](http://kivent.org/) is a cross-platform 2d game engine built on top of Kivy, so it is capable of targetting OSX, Android, Windows, Linux, and theoretically iOS (the one platform I still haven't tested on). It uses an entity-component architecture similar to unity and is built entirely in python and cython.
Make sure to never run it with debug mode enabled while open to the Internet. It's possible to extract variable values and execute arbitrary code. 
Thanks. I do disable debug in production.
Yeah, situation currently is just not ideal and a release is necessary. I want to migrate over the whole into into an org of sorts in the process.
&gt; The project was never meant to be open source. I apologize. I would really encourage you to make your software public. You'll learn a lot from the criticism you receive. I promise, none of the software you've written is novel enough to be kept secret.
I learned a ton about the standard Python libraries from the [Python Challenge](http://www.pythonchallenge.com/), and it was a lot of fun, too.
Hopefully you've sorted this out now, it looks like it. However, this shouldn't be giving you a bad taste of Python 3 -- it should be giving you a bad taste of Python 2 and you should expressly understand why Python 3 was created and why Python 2.8 won't be created. In Python 2, you have `str`, `bytes`, and `unicode` so you have three ways to handle stringy data. In Python 3, it's `str` and `bytes` but `str` is like Python 2's `unicode` so it was actually Python 2's `str` that got removed. Now you only need to worry about data being a string or a series of bytes, and not need to worry about how the string is actually encoded. A project I started to write in Python 2.7 worked fine until I encountered input strings coming from some user-defined file (where I'm the only user) that had Icelandic characters. Absolutely failed to output correctly, but switching to Python 3.4 (now 3.5) and it worked as-is (removed the `from future import print_function` line is all because it's not necessary, but actually is a no-op in Python 3 so it's OK to keep it).
Also, if anyone has a good tutorial for any of this I would be very appreciative :) I've been trying to follow [this write up] (http://www.pygopar.com/playing-with-instagrams-api/) but can't seem to get anything working? I'm using python 2.7 with the python-instagram module. I'm running it on ubuntu 14.04 but I don't see how that would matter....
Flask does what it needs to do. Lot of people run the version of Flask that's present now. Most people(I think) are happy with the old versions too. Unless it's a security update, don't really see a point in updating it to be something else. Personally, I see it to be a wrapper around your python code to be a web app. You could really turn any of your python script into a Restful API very quickly.
The date formatting horror ;)
I'm surprised everyone is saying no; the answer is yes, [Pandas3D](https://en.wikipedia.org/wiki/Panda3D).
It's really crazy to be releasing Python 2-only libraries at the end of 2015.
the thing is that there's a reason why ruby on rails, node, and django need updates all the time: it's because they are imperfect for their purpose. Therefore, flask isn't updated, because it's perfect for its purpose. You shouldn't view it as a competitor to node or django or ROR or play or golang's w.e. etc. etc. It's meant for rapid prototyping and allowing you to not get bogged down in flaws paired with a framework (node's passport.js for example)
popularity implies support. number of commits however doesn't imply popularity.
Nope. Finally correct version of date format. :0)
Open source of this would be amazing. 
websockets is one area that needs addressing. There are several competing Flask extensions that also bring in other competing dependencies. However it would be nice if the Flask/werkzeug base had it as standard (batteries included, one way of doing it). Heck I wouldn't even mind if required Python 3.5+.
I will more than likely take your advice on the post above, and also use sqllite.
Webdev in Python stagnating? Django just got half a million $ from Mozilla. It's more active than ever.
How firm are you on using mouse for drag and drop? Your demo seems very custom on a canvas object. Once you have the input and drag and drop implemented, you should be able to leverage autocomplete and TeX command replacement using a textedit buffer that isn't displayed.
God I hate that error so much. I really should switch to Python 3 at some point. 
So you want the Microsoft Word equation editor with TeX formatting to unlock what TeX does with the exact syntax that TeX uses that you already typed? FYI, Word lets you use TeX-lite syntax. It's semi-buried. If you want a good TeX editor in Word, use Aurora. Don't reinvent the wheel if you don't have to. I'd say you're getting way to fancy with your equation editor when you should worry about making a good text editor first. There are open source ones that would be easier to modify.
not really, partial is used to prefill some params in a given function and effectively create a different function with a smaller number of params. def fun1(x, y, z): return x+y+z fun2 = functools.partial(fun1, x=1, y=2) # =&gt; fun2(z) there is nothing in partial that allows you to unpack stuff. i've seen a double lambda though lambda tup: (lambda x,y: (x*x + y*y))(*tup) lambda(tup) passes items produced by *tup as individual params to lambda(x,y) where x, y are finally used. In other words the outer one unpacks its param for the inner one. 
indeed!
Not fixed on the mouse at all, and would be happy to try out other options. Actually, I just had a look at [this PyCon talk](https://www.youtube.com/watch?v=WAitSilLDUA) about making terminal apps, and I am seriously considering going all CLI.
this is why I use COBOL for all my webdev.
First, you should state why you want to do this. This may be an ["xy problem"](http://mywiki.wooledge.org/XyProblem) (coincidentally, in this case) and seemed so after reading the point about not reinventing the wheel by u/billsil. But if you do still want to make this, I'd have to respond to this: &gt; here, the main difficulty I would face is the immense amount of baggage that PyQt naturally brings along as interface -- I don't want to learn the ins and outs of GUI design with Qt (a whole subject by itself) Well, if you're going to make a GUI, I don't see how you'd have a choice but to learn at least *some of*, yes, a GUI toolkit. That could be any of those, or curses (I guess), or HTML/CSS, but you are going to have to learn something. More importantly, it really sounds like you're overstating the case. "Immense amounts of baggage"? You're not making a full-fledged app, are you? (Again, what's your purpose?). So it wouldn't have buttons and menus and timers and grids and stuff. You'd basically need to just learn the "hello, world!" in whatever GUI toolkit, then focus on writing rules for how your equation editor works and integrating that with their text widget(s) and also capture mouse click and text entry events and do the appropriate things with them. 
Wtf, it only takes 2 minutes tops on my 7200RPM HDD
Where's the "Both" option?
Why would you use this when you can use WHIFF? I mean, after all, a framework should be driven by one guy's inability to learn APIs and any semblance of community feedback. Plus, how can you resist a picture of his cat? http://whiff.sourceforge.net/
Django might move in parts but there are no people to write specifications. Django just decided to solve websockets in the same way Flask advertises for years: through a redis broker.
Why would Mozilla pour a ton of money into a server-side web rendering framework in a time of client-side web rendering frameworks?
So not use unicode literals. It does not do the thing you expect and people repeating the recommendation does not make it better. Use the u string prefix which works on pytjon 2 and 3 instead. Unicode works just fine in 2.x. Just encode on the way out. 
That's pleasing to know: I'm worried that the (large) amount of work required to re-spec WSGI would be wasted because the inertia of what we already have is too high. &gt; Also needs to support Python 2 No question. Design goals atm include: - Support Py2 and Py3 (means defining clearly what is bytes and what is 'unicode') - Support HTTP/1.1, HTTP/2, websockets. - Application-level protocol detection and protocol specific features (e.g. server push from the application) This probably means "async by default", though there's some hairiness in working out how we do that in a way that meets our "support 2.7 and 3.x" requirement. Anyway, I don't want to hijack this thread with a WSGI-ng discussion. I'll be pushing this forward on web-sig in January, and I'll ping you on Twitter when that happens.
Yes, but that's an orthogonal issue. As Stack Overflow ages we'll see many questions answered for obsolete versions of tools, languages etc. ( in particular Python versions! ). Entropy will haunt us forever, which is why we occasionally have to re-invent the wheel. 
The "data scientist" Hype is making people forget the good old techniques from the database architecture. If you are a data scientist that comes from database background (as me), getting data from a big database to CSV for data cleansing and wrangling is like having to travel a long way and taking your luggage from the trunk of your car to the back of a bicycle. It makes no sense. You've got a database, use it. If your Dba is not very friendly, feed a local Mysql/postgre with the data. Because it comes from a database the data is structured, so load a database and query it. It will be million times faster than any Python code. With Python, spark, R, big data, and all the buzzwords sometimes I feel like having a hammer: everything looks like a nail
The template engine is but a small part of what Django can do.
Okay, so let's say I'm building a web app with a JS frontend and a micro service backend. The data model is simple enough that I don't want to use an ORM. What does Django offer me?
If you go back to early docs on Flask it mentions that Flask is a minimal project over other libraries and you can even vendor and fork it for your own project. The idea is that there is very little code in Flask itself compared to what it pulls in. So I would argue that even when Flask only had me as developer it did not have a problematic bus factor just because it's not the critical part of your application.
&gt; Sure, both are orthogonal. I just wanted to point out that there is a direction in which underlying technologies develop. WSGI is not the only aspect of python that matters for webdev. No, but it's the only aspect that matters to Flask. &gt; Coroutines are now a language feature. An async WSGI extension will be based on their data model. When WSGI came out the protocol was written to support Python versions without iterators even though iterators were in Python for two versions. It's quite irrelevant what happens in the latest Python versions, specifications need to be written to support a large set of versions.
PM me a private pastebin/gist/whatever if you want me to have look!
Don't know what kind of data you want to collect, but check out http://commoncrawl.org/. Maybe it's the thing you're looking for, maybe you can build on top of that.
Routing, auth handling, Django REST framework is a ready-made RESTful back-end. And it offers a reliable structure, so future maintainers can easily navigate your code. Remember that code is far more often read than written. In Django, what you don't need, you just comment out in the settings file, and Django becomes as "light weight" as a simple URL router that calls one function. Need more functionality in the future? Easily activate it again and have it perfectly integrate with the rest of the app. 
Yes exactly. We use it specifically because it's lightweight and easy to use. I just need an http layer for my other code and that's what flask provides. 
/u/mitsuhiko gave the practical answer, but literally speaking, [using git-pandas](https://github.com/wdm0006/git-pandas), I see 125 committers with a bus-factor of 1 (again, just for the flask repo, not the many packages it brings in).
Think about it this way: Since 1999, there have been more than half a dozen ways to get microphone input from browsers which have come in and out of favor, from Flash, to Firefox Rainbow, to WebRTC, to MediaStream API, etc. Do you really want your framework chasing after the latest trends in that corner case to try to match them up to browser versions for you, or do you want to be able to reliably integrate the best known reference implementation for each approach without worrying how the framework is going to behave for each?
See http://www.pylonsproject.org/projects/pyramid/faq
Specifications are not made in reddit comments. What an async wsgi would look like i cannot tell you but i know that there are too any parties that would need support for this in Python 2 that a spec would not be tulip specific. It was the same for any development in the web sphere in the past and i don't see how it would be different here. 
I'm about to start a new project -- choosing between webapp2 and flask.. 
What are you trying to build then, another todoMVC?
&gt; In Python 2, you have str, bytes, and unicode so you have three ways to handle stringy data. This isn't true because in Python 2: &gt;&gt;&gt; str is bytes True so you actually two ways in either version. The real problem is that Python 2 conflates strings with byte representation of those strings, while Python 3 keeps those more separated.
What has happened in authentication, for example, that Flask's OAuth, OpenID, and basic authentication modules need to keep up with?
At least for me conda shows the environment automatically in my bash shell (in parentheses before my PS1) Regarding showing the git branch, for this you need to adjust your PS1. I personally added the following to my bashrc function parse_git_branch () { git branch 2&gt; /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/ (\1)/' } PS1="$FBLE[ \u- $FCYN\w$FYEL\$(parse_git_branch)$FBLE]\$ $RS" The strange vars are just color codes (having them aliased makes them a bit more readable) If you need some help setting that up I can try to help you. 
I personally have it set up (mainly by copying and editing other people's code), but I consider it a vital part of the workflow which is why I mentioned it for anyone else interested! 
I do not. My usage of websockets wants a hub server anyways and for that i do not need wsgi.
&gt;If you don't want to use an unpopular *, PHP is more popular than Python, Ruby, etc. for web-dev in general. You're already using the wrong language if popularity is an important metric you value. I think that depends somewhat on how you define popularity. Is there more PHP out there on the Web right now? Certainly. But I wouldn't argue that that's a matter of popularity. Rather it's because there's an enormous amount of legacy PHP out there, and so companies would rather continue to use what they're familiar with than redo everything from scratch (which is totally reasonable, since PHP does what it does just fine, overall). If, on the other hand, you look at new projects, startups, etc. and if you look at what people *like* to use, I think you'll find Python to be quite popular in that regard. I find it hard to imagine that someone starting a new project from scratch is going to choose PHP unless they *really* love PHP.
For mobile devs, flask is a godsend backend framework in comparison to django. Just sayin
The size of your project also has a large part to do with how long it takes to do a full index. At work our main app is &gt; 1m lines of python and it can take 3-4m to index. It's not a huge deal, but it's something to consider. 
 #simple web crawling program import urllib import urllib.request from urllib.parse import urljoin from bs4 import BeautifulSoup import sys import json import msvcrt import sqlite3 def start_list(*links): pages = {} visited = set() invalid = set() to_crawl = set(links) while to_crawl: a = to_crawl.pop() try: print("getting results") results = crawl(a) print("Adding to visited list") visited.add(a) print("VISITEDRS:") print(visited)# print("setting pages array") pages[a] = results['html'] #add sql entry here print("adding to crawl list") to_crawl = set(results['links']) - visited - invalid print("To Crawl:") print(list(to_crawl)) except urllib.error.URLError: print("INVALID URL... ADDING") invalid.add(a) print("ADDED") except KeyboardInterrupt: break #for loop here to dump all the results?? print("Visited: ") print(visited) print("Invalid: ") print(invalid) def crawl(url): print("THIS IS THE URL::::") print(str(url)) if url != '' and url: results = {} try: html = urllib.request.urlopen(url) cleanHtml = BeautifulSoup(html, "html.parser") results['html'] = cleanHtml results['links'] = list() for link in cleanHtml.find_all('a'): a = str(link.get('href')) print(a) if url not in a and 'http://' not in a and a != '' and a: a = urljoin(url,a) print(a) print("APPENDING: ") results['links'].append(a) print("RELOOP: ") except: return urllib.error.URLError print("results: ") print(len(results)) print(list(results['links'])) return results else: pass def start(): conn = sqlite3.connect('information.db') c = conn.cursor() c.execute(""" SELECT COUNT(*) FROM sqlite_master WHERE name = 'info' """) res = c.fetchone() if not bool(res[0]): c.execute(""" CREATE TABLE info( id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, url VARCHAR(3200), html VARCHAR(48000), visited INTEGER(1) ) """) start_list(sys.argv[1]) if __name__ == '__main__': start() So this is the code I have now. I've noticed a few things: - The invalid list never gets anything added to it - This program runs so randomly, it never has the same outcome and sometimes it'll find like 8 links and only search those and stop, sometimes it does as I like and essentially never stops finding links and grabbing website content. (this is all using the url http://pastebin.com/ so it should have the same outcome essentially everytime given that pastebins content hasn't changed.) - I am getting a ton of these errors, but yet the errors don't happen EVERY time: Traceback (most recent call last): File "crawler.py", line 96, in &lt;module&gt; start() File "crawler.py", line 93, in start start_list(sys.argv[1]) File "crawler.py", line 28, in start_list pages[a] = results['html'] #add sql entry here TypeError: 'type' object is not subscriptable and THIS IS THE URL:::: Adding to visited list VISITEDRS: {'', 'http://www.sitepromotiondirectory.com/'} setting pages array Traceback (most recent call last): File "crawler.py", line 96, in &lt;module&gt; start() File "crawler.py", line 93, in start start_list(sys.argv[1]) File "crawler.py", line 28, in start_list pages[a] = results['html'] #add sql entry here TypeError: 'NoneType' object is not subscriptable also sometimes the to_crawl list randomly goes blank. Essentially what I'm trying to create is a program that will run forever (given that the original URL it is given can find a link that links to another website and then another etc..) I want it to keep downloading web content so that later on I may search through it using another python program ( and yes I have taken the sqllite side of things as I feel it'll improve my data collection). If you could help me figure out what it is I'm doing wrong, that'd help alot! Thanks 
Sorry hahah, coming from PHP and yeah.. it's a big change!
I actually took the route of writing in each loop so that if the program was stopped the data would not be lost (that was gathered).
As little as possible? If you find a strong developer and you want to keep him/her, pay them more. If they suck, don't. Really, you should be paying by project, not hours spent.
We paid someone $80k a year
You'll be very sad when you deploy Flask as an enterprise or commercial solution for yourself or client and when a vulnerability is discovered, there's no active team to patch it. 
Generally I agree, but read my full comment: not replying to PRs and issues requesting strategical guidance is stagnation. If there were no such questions, the software could be called “done”
Are ebooks of any use to you? I love allitebooks.com 
thanks!
It's a negotiation. You need to set milestones and not pay people unless they produce. Also, what project you estimate at 3-4 months, I promise you they will estimate at a far different number. You need to know clearly what you want vs. what would be nice. You won't be happy with the work unless you know that and if a developer doesn't tell you your schedule is unrealistic given what you want, it's probably a bad developer. It's the classic management expects a site that can handle the same scaleability as Amazon vs. what can realistically done by 1-2 people in a couple months. That's why you need to see examples of their work. Paying people more doesn't get you the product that you want. You can always cut them. I'd honestly go for a bid style system since you don't know what people are worth and people are willing to underbid in order to develop a relationship. 
Cookies? Browser state?
It doesn't happen using Python 3's `urllib.request.urlopen()`. I tested like this: import sys if sys.version_info.major &lt; 3: import urllib2 as request else: from urllib import request # Replace 'urllib2.urlopen' with 'request.urlopen' in OP's code.
I'm not speaking of Flask in particular but about less popular frameworks in general. I can't speak to Flask's particular strengths and weaknesses because I haven't used it all too much.
Thank you for this. I ended up downgrading but this is great to know. Do you have a link on where it's stated it's been deprecated? I had no luck finding this.
You want the framework to format and parse token exchanges with mobile apps which are otherwise sending HTTP to Flask and displaying HTML from Flask? Where are the token exchange protocols defined? Are they RESTful, using TCP and SSL connections such as HTTPS? Do they use UTF-8, JSON, etc.? Why can't they be sent and recieved in HTTPS, just like browser cookies or the JavaScript payloads which set and read DOM browser state, or the HTML to invoke Flash apps to set and read Flash storage? Isn't that the least complexity for the apps?
I didn't mean that comment as "stay away from popularity" or "popularity = bad." I do think it's more important for someone to pick a framework that they're the most productive with - one that lets them build good programs in the most efficient manner. If someone is great with a specific framework that's also popular, even better! I've seen people who abandoned their most productive tools to jump on a bandwagon for the "Next Big Thing", which is what I'm advising against. Don't pick something only because everyone else is doing it. Pick something that will help you as a programmer, even if it's not the sexy option. And if the thing that helps you is also the sexy option, that's great too! ;)
It's briefly mentioned at the very end of the 1.9 release notes, under [Features removed in 1.9](https://docs.djangoproject.com/en/1.9/releases/1.9/#features-removed-in-1-9). There's a much longer explanation in the [1.7 release notes](https://docs.djangoproject.com/en/1.9/releases/1.7/#reorganization-of-django-contrib-contenttypes), when it was first deprecated, which goes into the reasons. Again, it's just the specific file that is removed; the generic relations functionality still exists, just split into separate files.
[Python Algortihms](http://www.amazon.com/Python-Algorithms-Mastering-Language-Experts/dp/1430232374) is quite good.
You can do some reading on metaclasses, as it is related to this. My layman understanding is that `type` is a class that makes classes, and yes - everything is an object (but not `object`). `object` is a class that makes instances (objects maybe the better word?). So because `type` makes classes, `isinstance(object, type) #True`makes sense. Also this; &gt;&gt;&gt; isinstance(object(),type) False
Thank you so much. Merry Christmas! 
You can just do "pip install ..." inside conda if it's only available via pip. It really is as simple as that. Having extensively used both, I have no idea what youare talking about. I have had much fewer problems getting packages from conda to work than from pip. The conda packages more often than not just work, whereas the pip packages often require 7 "apt-get install"s before they work, and they are often cryptic about what exactly it is that they want. And when a package isn't available in conda, it's a "pip install" away (although I always dread that, because -- unlike with conda -- any non-python dependency is system wide).
&gt; Pick something that will help you as a programmer, even if it's not the sexy option. By all means, if your project isn't going to be used by anyone except yourself, go ahead and use it to build your skills. If you're building the next big iOS app, though, you have to balance that desire with the benefits of having a large community.
The only real perk I'm aware of is it using prebuilt packages if available which is mainly useful on Windows (unless you get a compiler installed, mingw or vcvarsall.bat's shenanigans)
No, it's not that hard, but the benefits of managing a projects environment with one tool instead of 2 are pretty immediately obvious. I've never heard of these tools but I'll definitely give conda a try for my next project. 
&gt;&gt; Fads aren't a good reason to add bloat to Python and waste Python devs' time. &gt;It's a proven model in use for over a decade. So is Brainfuck but a PEP for its integration for Python would be rightfully laughed at, the only reason why asyncio isn't receiving similar mockery is because some people think it's a good idea. &gt;&gt; If it's so similar why not support the same synchronous code that is conventionally used? Gevent manages this pretty well. &gt;Because it's a hack. So is using generators for concurrency. I'd rather pick the hack that doesn't require me to rewrite my code to be difficult to read. &gt;&gt; Do you think depending on the construction and maintenance of a shadow ecosystem made good documentation easier or harder to come by? &gt;It's irrelevant. Only the ability of the people working on the project counts. The accumulative ability of all the people working on the project is highly affected by the number of people working on the project. Preventing people from using the libraries they want to use is going to drive them to solutions that don't have that flaw, resulting in fewer programmers to maintain the shadow ecosystem. &gt;&gt; Libraries that accomplish existing functionality "but using &lt;framework&gt;" cause lots of clutter for people not using that framework. &gt;How can you possibly be caused clutter by something you aren't using? What a nonsensical thing to say. If I search "mysql" in a package repo I'll get lots of hits for frameworks such as twisted and tornado. How would you feel if you got another language's packages merged in with your results? &gt;&gt; If you understand the harsh reality of the general population avoiding frameworks with bad documentation why are blind to the harsh reality of the general population avoiding frameworks that require them to use its shitty shadow ecosystem? &gt; Because what you think is a "harsh reality" is merely your imagination. You clearly have no worthwhile experience using Twisted or the like, so you're just making shit up now. I have worthwhile experience using Torando and NodeJS, and I considered using Twisted years ago but decided against it due to poor documentation. Tornado had a problem of library availability and quality, NodeJS didn't have these problems because its ecosystem isn't existing in a shadow. It doesn't matter if I'm an AI constructing random sentences from a random number generator, merit is not experience, merit is merit. &gt; You're just making shit up because you don't have any arguments based in fact, just your whiny "but I don't like it." But it's actually a very valid argument, no one is going to support a framework they don't like. You said yourself that Facebook made Torando because they didn't like Twisted.
Yeah I have definitely run into that but then solved it by not developing on Windows. Personally I like using OSx and Linux commands much more than Windows. Windows feels bloated. I use a Windows for excel and that's pretty much it.
Agreed, I tried using Windows again recently and realized how much of a pain most things I do are on the platform. It's a fine os for most computer users out there, but just didn't really work for how I operate.
My normal linux environment never works on mac os and needs reconfiguring. Virual environment setup was bugged on Ubuntu for about a year and I had to use a workaround. Conda just worked on both. However, I have now this problem by not developing on either Windows or Mac OS. :P
As the sidebars says: If you are about to ask a question, please consider r/learnpython. 
We charge $200/hr, it drops a little bit if the job is right but not much.
That's just the thing. By doing that, you're back to using pip again. You haven't really solved the original problem, which is a single place to maintain your dependencies. 
That option is expressed by not voting.
I'd use someone else's script. In fact I *do*: I use pyenv's virtualenv plugin. 
what's your environment? if you're on anything Unix based I'd suggest using [pyenv] (https://github.com/yyuu/pyenv) + [virtualenv](https://github.com/yyuu/pyenv-virtualenv), it'll handle installing pip for the right version of python
It's Windows 8.1
This is what the customer is charged, but the developer gets anywhere from $30 to maybe $75 an hour.
[Miniconda](http://conda.pydata.org/miniconda.html) is easy to install on all platforms and comes with pip.
when you type "python" in the terminal, what happens? are you using the terminal? if not I won't be any help
I'm sorry I've never used a terminal before, my experiences in programming is strictly within the ide, anything outside of it and I am lost :(
I am currently rewriting a 'production' analytics system centered around social media tracking written by a very good data scientist with who has minimal experience building production quality systems. My work is to boost the performance, maintainability, user experience and such. I have replaced some of his code with pandas which brings in numpy. I was unhappy to discover that building numpy on various Linux kernels has become problematic over the last few years. Condas are Continuum Analytics' solution to this problem and, as such, you have little choice but to use them if you need to deploy a modern data analytics stack on Linux or Windows without a lot of hassle. There is a small learning curve for condas but it is not bad if you are already comfortable with virtualenv and pip. I was able to create some scripts callable via vagrant to set up and provision my app including building a conda env using miniconda. It works although it is interesting to watch the systen negotiate precisely which version of python (i.e., 2.7.10 or 2.7.11) it is going to install based on the requirements of the various modules that you include. Like a lot of young non-trivial system tools, the output generated by the conda installation process is voluminous but not very enlightening. The bottom line for me is that avoiding the hassle of compiling numpy over and over makes up for the hassle of ditching virtualenv for conda. (I still use pip a fair amount but only in the context of a conda.) I need to get deeper into my production push and perhaps create one or more of my own conda packages before I am willing to form a firm opinion about this technology. 
if he is trying to install pip..that means he is a beginner in python..so using the native should be better at first...i mean i was at this position two weeks ago when i was starting on python this is what people did...install that miniconda, anaconda...bull shit..... Just keep it calm and simple at times..... now i use conda thou..... i wrote a script last week for scrapping some websites for sports data...so yeah...SIMPLE
I manage our team's python environment. Basically we use miniconda along with a custom metapackage that roughly mirrors the major Anaconda release, but includes some stuff that we need that isn't included. We distribute it to the team via Anaconda.org, and I build all of the necessary libraries that aren't in Anaconda on Windows, Linux and OSX. This has typically been super easy using `conda skeleton pypi &lt;package name&gt;`. In a pinch, I use pip from within a conda recipe to install a .whl file (usually from Gohlke's site on Windows). It's been pretty rock solid over the last 18 months. Key things for us include: * Ability to package and distribute R in a single bundle along side python dependencies since our team uses rpy2 * The install is totally self contained so no worries about unique environments on different machines. Plus all of the packages are binary-based so no installing from source, which is really important for many of the scientific stack libraries which often have non-python dependencies. 
Your library is quite similar to [DDT](http://ddt.readthedocs.org/en/latest/).
I really, really, really, really, really recommend getting Linux as soon as possible. It will make your life *sooooo* much easier. If you don't do that for whatever reason, then follow these steps: 1. Download get-pip.py 2. Make sure the correct version of python.exe is added to your PATH (in this case, 3.4) 3. Open up terminal, navigate to where you downloaded get-pip.py, and run python get-pip.py I'm not sure if it works the same on Windows, but if you have multiple versions of Python installed (say 2.7 and 3.4), then you should **always** be explicit about which version you are using. For example, if you want to run a script with 3.4, python3 script.py If you want to run a script with 2.7, python2.7 script.py And the same goes for pip: pip3 install numpy versus pip2.7 install numpy --------------------- Honestly, the whole Pythonic spirit is to make things as simple and easy as possible. I think you're only limiting yourself by developing on Windows, especially Windows 8.1. pip really embodies the simplicity of Python because you should theoretically only have to download and run get-pip.py. If it doesn't work out of the box, you're doing something wrong. Also, now that I've seen your comment about terminals and IDEs, please don't be afraid! An IDE is not at all necessary for serious Python development! I've developed Python professionally for 2 years and personally for almost 4. I've only ever used a text editor and shell (terminal). All you have to do to run your program is run "python your_script.py". If you're too lazy to type this out you can make a macro in your text editor. I think IDEs and the lack of a command line do much more harm than good to beginners, at least in the context of Python. You don't need makefiles. You don't need to link things. You just need a keyboard, a text editor, and one command to run it all.
It does everything in its own way that isn't compatible with the rest of my workflow. (I don't like pyenv or virtualenv-wrapper for similar reasons)
well... no. but a point in the right direction would be nice.
1) install python 2) use python to run the code you've posted 3) google whatever error messages you get, follow instructions, return to 2)
[removed]
You should upload it to GitHub so people can contribute pull requests or issues for you to fix :)! That way you still learn the ideas. 
&gt;Which versions of Python are you referring to? 2.1 onwards &gt;I've never had to inherit from Object and don't understand why it isn't implicit. Backwards compatibility.
If you're at all interested in Machine Learning, https://www.packtpub.com/big-data-and-business-intelligence/python-machine-learning is a beast of a book. I've read the first half, an have learnt a huge amount. Also it's only $5 at the moment for an ebook.
Can you explain the the failure to do proper damage control please? 
That's correct. For backwards compatibility reasons "new-style classes" have to be opted in in Python 2 (by inheriting from `object`), but not in Python 3.
Yeah, sorry about that, my job is still on 2.6 so I kind of forgot about them changing that in 3 :)
True single-source Python3 support, performance and a small codebase, mostly. Oh, and an author that does not hate Python3 (me).
Yes, py2.x and py3.x in one code base. You can run Pomp on pypy or even app engine - but you must implement `downloader` for app engine sandbox ))) With asyncio suppoprt - [e04_aiohttp.py](https://bitbucket.org/estin/pomp/src/ca057745b835c5521501e1cb378d29abd4e75430/examples/e04_aiohttp.py?at=default&amp;fileviewer=file-view-default) Also Pomp can - fetch data in concurrent way (ConcurrentDownloader) - extract data in concurrent way (ConcurrentCrawler) - work with centralized queue - easy integreated with headless browsers Pomp ideal for gather data from multiply and same resources.
have a look at Anaconda. It is much more reliable on Windows and is easy to set up. 
I would also advise you **git** as a version control tool if you anyway learn a new tool. It is more widely used and easier to learn than some other tools (like subversion) 
what the heck does your work flow look like? It can't get any simpler than conda
That's awesome. I'll keep a close eye on it. I have the same reservations as you about scrapy (twisted dependency, messy codebase, no py3 support) so this is pretty awesome. You should post it in the sub!
Essentially a converter javascript. It is not enough for my requirements XD
You will enjoy reading this: http://www.effectivepython.com/
Effective Python
I find using [ virtual env ](https://virtualenv.readthedocs.org/en/latest/) quite effective at removing path issues. Also if pip needs to compile things from source follow [this](http://blog.ionelmc.ro/2014/12/21/compiling-python-extensions-on-windows/)
[Image](http://imgs.xkcd.com/comics/workflow.png) **Title:** Workflow **Title-text:** There are probably children out there holding down spacebar to stay warm in the winter! YOUR UPDATE MURDERS CHILDREN. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php/1172#Explanation) **Stats:** This comic has been referenced 575 times, representing 0.6189% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_cy6j10q)
I do more than just create the env. So, for example I might have one that creates an env and a default django project and app. 
Can you explain how you did multi-room on your pi's? I've researched a bit, but it's hard to weed through the old/broken info and find out what's actually working now.
what are your requirements then?
Yeah it also does not protect the "secret" page from being accessed without logging in.
Did you guys know that PEP-8 does not require you to use 80 chars? &gt; Some teams strongly prefer a longer line length. For code maintained exclusively or primarily by a team that can reach agreement on this issue, it is okay to increase the nominal line length from 80 to 100 characters (effectively increasing the maximum length to 99 characters), provided that comments and docstrings are still wrapped at 72 characters. 
Please use /r/learnpython.
I'd personally only make the first change if [n,e,s,w] comes up frequently. Refactoring the whole thing into a find_exits method is probably the best option, but its all speculation without seeing more code.
Find and Replace has been pretty much the state-of-the-art for tool assisted refactoring for a few decades now
Or maybe make `Directions` an `Enum` from the `enum` module. Those are iterable, too: from enum import Enum Directions = Enum('Directions', 'n s e w') for direction in Directions: # ...
I was just about to write the same kind of thing, and then I saw your comment after I finished. Ooops. Apparently we think really similarly. def __init__(self, **kwargs): ... snip ... direction_list = [Directions.n, Directions.e, Directions.s, Directions.w] for cell in self.all_cells(): row, col = cell.r, cell.c for direction in direction_list: rm, cm = g_offsets[direction] row_index = row + rm col_index = col + cm row_in_range = bool(row_index in range(self.num_rows)) col_in_range = bool(col_index in range(self.num_cols)) if row_in_range and col_in_range: grid_item = self.grid[row_index][col_index] neighbor = Cell.Neighbor(direction, grid_item) cell.exits[direction] = neighbor
are binary installers being removed going forward? If so why?
Who programs in a terminal anymore? Who is working on a window with just 80 characters per line anymore? 80 character word limits were obsolete before I was born, and I at least feel like I'm getting to be an old bastard. Far better is a limit which starts at the indentation level - you then have a separate limitation on the number of indentation levels you allow. 80 chars from the point of indentation allows far more flexibility without creating OP's monstrosity.
Accepted it now! :-) 
I like split my screen down the middle so I can look at multiple files at once, which usually results in two files of roughly 80 characters, so I personally hate it when people break this rule.
I find it more readable to break long function calls right at the parens, and indent the next line 4 (which is still PEP 8). So instead of: cell.exits[direction] = Cell.Neighbour(direction, self.grid[row + rm][ col + cm]) I'd do: cell.exits[direction] = Cell.Neighbour( direction, self.grid[row + rm][col + cm] ) or more likely: cell.exits[direction] = Cell.Neighbour( direction, self.grid[row + rm][col + cm] ) Everyone likes to gripe about the 80 char thing; if you don't want to follow it, don't. I spent some time forcing myself to follow it, and found there is an art to keeping lines short. Once you get the hang of it, the results can be pleasing. Though I'm convinced that readability is the in eye of the beholder.
Yeah, we will see if we get any more replies. A split installation functionality is exactly what we need, good way to phrase it.
Yes, it's excellent. It's not really similar to Unity in any way though, apart from the fact that it's a game engine.
VIm and Emacs are still very popular. Being able to split your emacs window into 4 buffers side by side and still see all the code is convenient and conducive to a highly productive workflow.
&gt; Now, some people will claim that having 8-character indentations makes the code move too far to the right, and makes it hard to read on a 80-character terminal screen. The answer to that is that if you need more than 3 levels of indentation, you're screwed anyway, and should fix your program. - Linus Torvalds - - - And I kinda gotta agree with him on that, if you aim for less indenting, you get less control flow branches, and also simpler branches when branches do occur
I covered that with - 'you then have a separate limitation on the number of indentation levels you allow.' 3 levels of indentation with Torvalds' (completely stupid IMO) 8 char tabs means you are actually only working with 56 characters of code - and Torvalds works primarily in C, where you aren't going to deal with namespace or class indentation like you will in other languages. You can also get away with inline loops far more easily than you can with Python and its pesky significant whitespace :-)
Isn't if row + rm in range(self.num_rows) \ and col + cm in range(self.num_cols): just an obscure way of writing: if 0 &lt;= row + rm &lt; self.num_rows and 0 &lt;= col + cm &lt; self.num_cols: (the latter fits within 80 characters)
I didn't look through everything, but with your database stuff you can just do 'create table if not exists...' To avoid the need to manually check if it already does. Also consider a better table name, 'info' is awful.
Try: [Kivy-dev](https://groups.google.com/forum/#!forum/kivy-dev) or [Kivy-users-support](https://groups.google.com/forum/#!forum/kivy-users)
You are missing the string method in the Point class. def __str__(self): return "({0}, {1})".format(self.x, self.y)
I have to say I learned Mercurial before git and I found out later it was a waste of time. Even though Mercurial was faster to use and start for me, the sheer ubiquity of git makes it a powerful force to be reckoned with.
Thanks!
Don't let the awful looking site and forums fool you, the engine actually seems to be quite powerful. Keep in mind that most of the screenshots are from 2004 games, the engine is capable of better looking graphics, there just aren't that many new games that use it. Someone currently is working on a PBR render pipeline, https://github.com/tobspr/RenderPipeline, that's also where most of the recent screenshots come from. A big minus (of Panda) is that there is no editor included, it take a few more step than Unity to get some things done. IIRC, there are some plans to provide some way for Blender to be used as Real-Time Editor for scenes.
ah, sorry for misreading!
I don't think so. This isn't the first time something like this is being done. [Python 2.6.{7,8,9}](https://www.python.org/download/releases/2.6.9/), for example, also have no binary installers. I assume they're doing this to encourage people to upgrade to more recent versions of Python.
4 80-character buffers is gonna need like a 2560 pixel wide screen, isn't it? My laptop at 1366x768 can fit 2 buffers with some room to spare
It's not a converter, it's a full interpreter that supports scripts embedded in the page along with it, although it's a little rough around the edges, no conversion to js takes place, it's literally the closest project to what you asked for.
Where is this quote from? Is there a link to the full response? Thanks.
https://www.kernel.org/doc/Documentation/CodingStyle
&gt; Someone currently is working on a PBR render pipeline, https://github.com/tobspr/RenderPipeline[1] , that's also where most of the recent screenshots come from. Ooo, thanks for this, it looks beautifully engineered. I'll learn a lot from this. I'm doing the same thing right now, but in Nim and on naked opengl.
Even 80 chars looks bad on a phone :)
Yeah, gotta support machines like the IBM 1620
Yeaj, I bumped mine up to 110 because that's how many characters fit in half my monitor 
Modern IBM systems still have similar limits, though you can at least do 120 characters now (or you can put your source on the IFS like a sane person, but I digress)!
Hmm, smells like an ad. 
How is Python capable of effective game development? It's a great language to read and write, and the bindings and abstraction from OpenGL does that part, but don't you still need horsepower to run all the other systems in a game?
There aren't many. I have written python for about 6 years, and still use it for things that aren't performance critical. Outside of utilizing libraries like numpy (which are implemented in C) etc, python is very slow. It's fast enough for certain applications, and when mostly driving a library like numpy, but for something that is more performance critical you a really shooting yourself in the foot using python. That being said, it is an excellent language for general purpose work, and has great great libraries.
What you're written is equivalent to a nested for-loop: for expected in expected_avg_var: for actual in actual_avg_var: self.assertEqual(expected, actual) That's going to compare every element of one list with every element of the other list (i.e. the [Cartesian product](https://en.wikipedia.org/wiki/Cartesian_product).) That's N^(2) combinations, and it's not what you want at all. You want N comparisons: the first element of actual vs the first element of expected; the second element of actual vs. the second element of expected, and so on. You do that with `zip()`. And you should not be using a list comprehension for this. A list comprehension is for when you want a to build a list consisting of the result of evaluating an expression repeatedly. But here you are only interested in the side effects of evaluating the expression, and not the resulting value. In other words, you're needlessly constructing this list of a bunch of `None` values only to throw it away. That's not what a list comprehension is for. This should be a plain for-loop: for expected, actual in zip(expected_avg_var, actual_avg_var): self.assertEqual(actual, expected) 
You violated the there should be one OBVIOUS way to do it.
Well in this case the first thing I would attempt is taking the hot code into cython
No, it dumps an unnecessary ide onto my computer 
Yes I know, I'm one of them (using anaconda) 
PyCharm analyzes Python code and provides tools for refactoring: https://www.jetbrains.com/pycharm/help/refactoring-source-code.html 
I used Panda for a class project and while it is quite powerful, it's also fairly old and doesn't support a lot of nice-to-have features. For one, the packages don't work on OS X starting with Mavericks, and I had some trouble getting the official ones running on Ubuntu, but lots of enterprising hackers have made workarounds. By far the most frustrating limitation is its inability to support virtual environments. It installs to the *system* Python, and it expects things to be in certain places that prevent you from even manually installing it in a venv. You may be able to build it from source into a venv, but I did not attempt this. It's not super Pythonic but it is fairly straightforward to use. It works in a pinch but if you really want to do some future-proof game development, I'd stick to Unity or Unreal. EDIT: There is a tool called vext that supposedly fixed the virtual environment problem, but I spent hours trying to get it to work without success. My final solution was just to install it an Ubuntu VM. 
Generally speaking, you'll find more gigs in Java though.
Is there anywhere we can read more about how Eve uses Python in conjunction with other languages?
Well, sorry for spreading misinformation.
key words being "in other languages". it is a good habit in Python. Readability is king here. And yes, your first example is clearer that the seconde one. But to be fair, a good Python API would override \_\_iter\_\_ and let you do: for cardinal in Directions
... In an emulated terminal that they can made wide as they want. 
&gt; I used Panda for a class project and while it is quite powerful, it's also fairly old and doesn't support a lot of nice-to-have features. For one, the packages don't work on OS X starting with Mavericks, and I had some trouble getting the official ones running on Ubuntu, but lots of enterprising hackers have made workarounds. Not sure when you used it, but there's an announcement on the front page of Panda3D now that it supports OS X all the way up to Capitan now.
Game developer here! Python works just fine for game development. I've used it pretty often actually, though it's more common for server side stuff. Panda3D is the best open source 3D engine for Python that I'm aware of. Python-Ogre used to be really good, but all the developers left, so nobody's updating it to work with newer Ogre features. Anyway, someone else mentioned Eve, but there is another MMO framework called BigWorld (now owned by Wargaming.net) that uses Python on their client and server (with C++ for graphics and networking). A bunch of (mostly non-US) MMOs have been released with it. Really, as long as you've got native code doing the rendering and other low level things like path-finding, the game logic really doesn't require a ton of speed. The benefits you get from not having giant compile times are pretty huge, too!
Ah, the classic curl into sh.
Is there something wrong with that?
better table name?
AIUI you can't re-add it. This is intentional - a security measure to prevent an attacker replacing foo-x.y.z with a different (malicious) file. The best course of action is to bump the version and upload that i.e. do a new release, that happens to contain no changes. For some background, see - https://bitbucket.org/pypa/pypi/issues/206/cannot-overwrite-package-files - https://github.com/pypa/packaging-problems/issues/74
When looking for ready to go compiled packages its always worth taking a look at http://www.lfd.uci.edu/~gohlke/pythonlibs/#pyqt4 he even has pyqt for python 3.5, although only pyqt4
Want to get all the benefits of this book (and a ton more) with none of the reading? Run one (or both) of these two tools and you're done. Merry Xmas. https://flake8.readthedocs.org/en/latest/ http://www.pylint.org/
That seems kind of strange since they still have the binaries for Python (2.7.6)[https://www.python.org/download/releases/2.7.6/], which was released in November of 2013. I guess my question is what will happen with 3.4.5? I'd assume /u/ExoticMandibles is right since he's a core contributor.
Bad error checking in case the download is interrupted. It may be that the package only installs half-way, with no proper error message. Also, lack of proper code signing; a random domain-validated SSL certificate is less trustworthy than a proper signature issued by your operating system developers—you already trust your OS developers, but you should take an informed decision whether to trust software from a different source. Also, zero information on whether this installation will integrate with your system properly (package management, local init daemon, dependencies, etc.)
tmux and open 9 of them
It's easy to slipstream c and c++ into python. You can move your heavy lifting into those languages, and then use python to tie it together, and not have to worry about things like pointers.
Very good, so long as you do the things it's designed to do. It's great at moving meshes around, but it's pretty slow if you're generating your own, for instance.
2.7 is a special case. Under normal circumstances, once Python x.y+1 is out, Python x.y goes into security-fixes-only no-binary-installers mode. Python 3.5 has been out for three or four months, so it's time Python 3.4 goes into this mode.
1: Pure python or is there some cython/nuitka/numba business going on somewhere? 2: What is doing the heavy lifting to get graphics on screen? How is python meshed with that? DirectPython or PyOpenGL involved? Is this too in-house to talk much about? Work often has me producing plots, and some things fit better in animations than images, so I'm always collecting techniques that'll let me quickly slap 3d scenes together and get them animated. matplotlib doesn't quite fit every task. 3: What constitutes a server node? Is it a single process or a host running several processes? Really I'm just curious if you guys are bothering to work around the gil or just living with it server side. 4: This isn't python related: Does anyone over there want celestial objects to move/orbit someday or is that dream dead? I'd love to find someone involved who is interested in talking about how it might work while not breaking everything. For funzies I worked out on paper how it could fit in the game (paying mind to bookmarks/grid expansion/cross-grid interaction/grid collisions/data impact/cpu impact) and I wont be able to let go of the idea until I can hear it from an engineer that its shit/impossible/nonsense because I made a bad assumption about some mechanism. 
Ok, I think I've set that up. Thanks!
Well, what is wrong... Count assignment outside of while loop, wrong use of randint,... What does that "i" printed between head and tails mean?
OH MY BAD it is 1,2. My bad, my bad. "I" means AND.
Each to their own! My guess is that you don't develop on Windows though!
So can you correct my code with some comments and tell me why did i make a mistake, please?
I understand encouraging people to use the latest Python z version in x.y.z and how it shouldn't really matter if they use z-4 vs. z. Since it's not that big of a deal, I understand removing Python 3.4.3 or 2.6.7 installers from python.org while keeping the last version of Python x.y.z, but then why keep installers for 2.7.6 around? It's really old. I guess I don't understand why you'd go into "no more binary installers mode", yet do security bug fixes.
1. We use an older version of Stackless Python. 2. I don't know much about the graphics stuff to be honest. I mostly deal with backend stuff. 3. As I said we use Stackless so that helps a but with threading but for us we run multiple processes per physical machine and lock them to specific CPUs. Each process is a node in our cluster and is mapped to running specific services. Was actually having a chat about our cluster mapping strategy earlier today. 4. We would LOVE for that to happen! However because of how we break apart a solar system and how our game mechanics work it is not really possible. Two major problems, the first is we don't have any way of moving grids. So if you have a planet, which actually moves very quick, it would just be blinking through grids as it goes. All the ships in the game are positioned absolutely, not relative to anything. So just trying to keep up to something would be damn near impossible. Then there is all the bookmarks which we would then have to be updating as things move... arg it gets to be a very big problem very quickly. I know a lot of people that would kill for that though! God the awesome that would bring! Hope that answers your questions, sorry about the graphics stuff. I just don't touch that side of things ever and so anything I say would just be... well not very accurate.
Not that I am aware of sorry. :(
Bummer. It's a really interesting topic.
I think there's an unofficial version of it up using some of the original code. Edit: https://www.toontownrewritten.com/
Edit: Sorry, I realized I got off point. Here's a better example: row, col = cell.r, cell.c # rename poorly named field from external API Original Post: I think in this case I could go either way, but in some cases it makes it much clearer to add a nicely named variable that has no other purpose. For example, I keep running into this: named_variable = object.find_thing('name') arr['named_variable'] = named_variable.get_text.strip() I feel like this is much better: arr['named_variable'] = object.find_thing('name').get_text.strip() If necessary, arr['named_variable'] = object.find_thing( 'name', 'necessary_helper', 'third_param' ).get_text.strip() (If I was typing this with a code editor, I believe line 2 should be further indented, but you get the idea. Once it starts to hit 4-5 line list comprehensions, it's probably better to break it down for readability instead of trying to do everything in one line.
Why don't you do your own homework.
I'm going to re-paste your code, to make sure it all gets in here (your `import random` is off by a line in your post) import random head = 0 tail = 0 count = head + tail while count != 100: toss = random.randint(1,6) if toss == 1: head +=1 if toss == 2: tail +=1 print(head, "i", tail) input("end") Talking through this line-by-line... import random head = 0 tail = 0 Not bad so far. Import the library you'll need to generate a random number and assign zeros to your counter values. count = head + tail This means that `count == 0`. This doesn't update, since it's outside the loop. The loop: while count != 100: toss = random.randint(1,6) if toss == 1: head +=1 if toss == 2: tail +=1 Let's break this down toss = random.randint(1,6) You've mentioned elsewhere that this is a typo on your part, but I'd also like to point out that you don't actually need `randint` in this case. `random.randrange(2)` will return either a 0 or 1, which conveniently works just as well for a heads or tails toss. There's another method in `random` that's pretty handy for scenarios like this, but I'll go into that in a few minutes. if toss == 1: head +=1 if toss == 2: tail +=1 This is good and explicity, but if 1 and 2 (or, if you go with `randrange`, 0 and 1) are the only values you expect to ever receive, you can also use an `else` instead of the second `if`. Now for what's missing in the loop - an iterator. As described above, since you're defining `count = head + tail` outside the loop, it's never going to get updated; therefore, `count != 100` will always be `True`; therefore, your loop will never end. I'd recommend rewriting your while statement to be: while (head + tail) &lt; 100: ... since that will do the count math for you every time, and `&lt;` is also a safer condition than `!=` on a while loop to begin with (that's my opinion, but I've found it to be pretty true over time). print(head, "i", tail) Let's break what I consider to be a bad habit. You have two data points that you want formatted in a string. While, yes, what you've typed is valid code, learning [string formatting operators](https://docs.python.org/3.3/library/string.html#format-specification-mini-language) (preferred, as far as I know) or [printf-style string formatting](http://docs.python.org/2/library/stdtypes.html#string-formatting) will serve you much better in the long run. print('Heads: {h}\nTails: {t}'.format(h=head, t=tail)) or print('Heads: %d\nTails: %d' % (head, tail)) Now onto the final line: input("end") What is the purpose of `input` here? Is it just to pause so that the output can be captured? Now, I mentioned another method in `random` that is handy here, and that is `random.choice()`, which selects a member of an iterable at random. Consider the following code, with comments to explain what's going on: # If you're only using part of a module, only import what you need from random import choice # Define results as a dict, which we'll use with choice in a second results = {'heads': 0, 'tails':0} # dict().values() returns a list of the values from the dictionary, # which we can pass to sum() while sum(results.values()) &lt; 100: # results.keys() returns the keys from the dict, but it does't support indexing # list() converts that to a list, which is indexable # choice() picks one at random # And we add 1 to its value results[choice(list(results.keys()))] += 1 # Since the results are stored in a dict, you can just pass that as the # argument to .format, so long as you name the fields appropriately. print('Heads: {heads}\nTails: {tails}'.format(**results)) Taking the over-aggressive commenting out, that's 5 relatively-readable lines to accomplish the same thing, with fewer variables to worry about. I'd probably throw a single comment inside the loop to the tune of `# Picks one of the keys in results to increment`, just in case someone needs a boost understanding the nested statements there, but the rest of it is fairly simple to understand without any comments. Oh, and in case nobody else has suggested it since I started typing this, I'd recommend /r/learnpython for questions like these - you'll typically get more explanation there to help you keep learning. **Edit to add:** I made a comment about this being short, but please don't misunderstand. Brevity is not a goal in and of itself - more code that's easier to understand and harder to break is always better than less code simply for the sake of less code - but in Python, in many cases, a more succinct and readable method for solving a problem is probably the better solution than a longer one, as you're likely making better use of Python built-in libraries or good programming practices. That's typically what people mean when they call a solution "Pythonic".
Don't get too excited about BigWorld if you're looking for an MMO framework right now. From a discussion my team had with them about a year ago, they aren't looking to continue licensing the software out. Unless anything has changed, they're basically supporting existing licenses minimally and that's pretty much it. It's a pretty good framework, though. I used it for a game (that never got released) a few years back.
This looks truly fantastic. It seems to fill a gap. I'm particularly enchanted by how easy it seems to build a multilingual site. /u/mitsuhiko Did you try [statirator](https://statirator.readthedocs.org/en/latest/) before ? It's like frozen django with multilingual websites in mind, with the possible use of (I guess, didn't check) the admin app. The only thing, it isn't popular and is a bit broken atm.
I was talking about a general case. You need to inspect the script to make sure it's written to handle this case. You don't need to in a good packaging system. And believe or not, some people do use python from OS repositories, together with its set of prepackaged python modules.
In the end, can we write posts in markdown ? (I didn't get the relation between the browser editor, markdown and page contents)
But this is not the general case. This is Lektor's installation script. The general case is quite irrelevant here. 
Post of asvetlov (autor of aiohttp) "Why I do not like Flask" in Russian. http://asvetlov.blogspot.com/2014/10/flask_20.html 
It's true! As Einstein once said: A good redditor finds interesting content, a great redditor hides his sources ;)
Yeah, 120 is too much. Many monitors just won't fit 240 characters, and it's really valuable from a workflow point of view to be able to have two side-by-side windows with no line-wrapping. I stick to 100 because I like a little wiggle room. Anyway, once you get much past 100 characters you're probably doing something wrong. Either your lines are too complex, and the logic needs splitting, or your lines are too deeply nested, and you ought to encapsulate some of your loops in a function.
If the user knows what curl is, she knows how to verify the download. If she doesn't, she has to take any code she downloads on faith.
I may be wrong, but I think Eve Online uses python and pretty sure Civilisation did tool.
What a coincidence. Just a few weeks ago I stumbled upon your GitHub profile. I tried using nba_py, but I remember struggling to get it to work with current games. I will look into nba_py again really soon!
Or just use venv it's built in: https://docs.python.org/3/library/venv.html
Bokeh looks really promising. I will definitely play around with Bokeh in the next few days. Thank you for the tip!
I do, I just took the number from above instead of recalling it from my own memory.. Doesnt matter too much though since I have tools to tell me about these things.
There's a port with Android support: https://github.com/KillerGoldFisch/panda3d-android And it was mentioned in the forums that they're working on Android and iOS. I don't see a webgl/html version, which is more important on desktop than anything, unless you're selling on Steam. But, there's not going to be a "deploy" button, like with Unity. 
To be fair, the client is *NOT* written in python; it uses *some* python for scripts to drive gameplay; but the majority of the engine is written in other languages. Saying it's written in python is like saying UE4 is written in blueprint. (ie. not true at all).
Python does really well solving I/O bound problems and can still integrate with C if that extra performance is needed on a CPU bound problem.
I don't know what py_compile is but it looks like from the error you aren't currently in the same directory as your program.
How hard is it to build Python 3.5.x (and extensions) on Windows platforms, specifically Win 10)?
Ace of Spades too, and the Sims 4 uses python as their scripting language and many others do too. 
/r/learnpython
You need to install python and make sure it is in your environment variables.
The Pyramid team does a great job at maintaining good docs and tutorials. Also, the IRC #pyramid channel and the google group are great resources to answer questions and get you going. Pyramid's philosophy is to let you choose your stack (ORM/backend, templating, middleware, etc.) so a book would probably do more harm than good. The narrative documentation is here: http://docs.pylonsproject.org/projects/pyramid/en/latest/#narrative-documentation
Im a little rusty but look up the documentation for os and see about changing the current working directory. I believe the exact command is os.chdir(directory). 
Makes me think of [screen](https://en.wikipedia.org/wiki/GNU_Screen).
This looks promising. I'm going to try it soon. 
Absolutely! Fixed. I'm really excited to see work happening with llvm, like [Pyston](http://www.infoworld.com/article/2683259/python/pyston-compiler-cranks-up-python-thanks-to-llvm.html). With Google's massive use, you would think someone would be working on a V8 equivalent for python! 
Is this not more for debug rather than multiplexing like screen or tmux ?
Ah yea, I am mainly interested in just learning how they do certain things. :)
Makes sense! The place I worked at had a source licence for the C++ code, so I got to know it fairly well. If it's something I could give a general answer to, feel free to PM. I can't get too specific since I was under NDA.
1. Open file for editing in IDLE 2. Push F5 3. This step intentionally left blank
Best practice - do bulk import, what ever file format would be, but csv format may be imported in native ways for sql database. Crawler must pull, extract and save data. When using sql databases save action may be very slow or even be blocked. Because sql databases have transactions to guaranty data safety. In other words crawler must save all gathered data - normal, dirty, repeatable and then normalize and import data to database.
I thought that as well, until I started using pycharm. Even with a large screen, it's hard to fit the file browser and two editor panes while staying above the 80 mark, especially if you also happen to like side tabs (instead of top) to the editor. 
Isn't that the University that attacked Tor and sold a bunch of info to the FBI?
Blender? 
i'll start with a single concrete and common example that gives an idea * connections in a database pool * web requests * per request transactions other more fuzzy ideas are things like progress bars, output streams (stdin/out per scope) as you can see many of the extended surroundings are not yet clear i'd like to get in touch in the next year as im on a mostly offline vacation soon
I saw similar question here, hope it helps U http://stackoverflow.com/questions/43315/can-i-write-native-iphone-apps-using-python
Gotcha, that's cool. I used my lib with flask often, so I had to stay in touch with "request scope" things. My solution here was to customize standard "provider" for providing particular thing in particular scope and often I do it per project. At the same time, I have some providers that are included in my "standard" library, but there are only very common of them. Anyway, it would be interesting for me (and, I think, not only me) to see results of your work ;)
Sadly, most modern games are 99% CPU bound problems (or GPU-bound, but Python doesn't help there either).
This is really cool. I'll check it out. Edit: and I love charmander :)
A decent screen (27", 2560x1440) that can fit two 120-column editors side-by-side would make it even easier!
It's still like a million lines of python vs. 200,000 lines of C last time I read their dev blog. Some of that python is on the client. They write a lot more python for game development than they do C.
Well, C compilers can inline functions so you don't lose any performance by using extra functions to avoid nesting. In Python and most other scripting languages you do keep the overhead of each function call.
That resolution is terrible, also in terms of height.
I agree 100%. It is literally the only part of my laptop (a Thinkpad X230) that I'm less than satisfied with. At least it's matte IPS and only 12.5". 
Civilisation 4 used Python for gameplay logic. They switched to Lua in Civilisation 5. As for Eve, they definitely do use Python.
Thank you :) I'll update the post soon once I complete the dev work.
To be honest, if one is getting overhead issues for a specific function call, in python, a language that is entirely made up of objects and methods for its basic logic, then... well I'm not sure how that is possible in the real world without some crazy stuff happening, frankly. Regardless, one would get much more efficiency by changing their interpreter to anything-else-but-cpython, as opposed to cluttering code for optimization reasons
Just a minor quibble: a liberal license does not a commercial venture make. The most restrictive open source license, the GPL, is totally fine with selling software. This is one of my biggest frustrations with mistaken knowledge of open source.
I found it on reddit months ago, just like you.
Upvoted you to -3. Not being able to edit a title is maddening. Typos should always be allowed. I would be happy to act as a submission fact checker for something like that.
The python bit
Or private functions. The advantage with private functions is that it becomes very easy to test each step in the process independently of all of the others.
The only rule is readability. Character limit is only a guideline. There is also how much things you try to do on a line, and the amount of syntactic noise it needs. 
I think having the occasional dense &gt;=120 line in your mostly 100 line code is not a huge deal if it is not from nesting. Nesting make code so messy.
Holy crap, why a range()? That is terrible.
Oh wow, the icons on that web page are the *exact* same type as was used in the 2007's state of the art internal web app I worked on last year! Oh the memories... the horrible, terrible memories...
It looks like it's written by someone who used to, or still does, write a lot of Java.
I agree that flake8 and pylint are great tools, but they definitely do not cover all of the anti-patterns mentioned in this book. E.g. will either flake8 or pylint suggest using a defaultdict instead of conditionally looking if a value is missing and setting a default value?
The new release came out late November, and supports all recent Mac OS X versions, as well as all current Ubuntu versions.
I would like to have some concrete examples of good Python code.
in windows cmd window, cd your work dir, run cmd "python hello_world.py", no need to compile, python is script language.
&gt; Everything else in that function is completely trivial code If that were true, the code wouldn't need comments. Not to word this absurdly, but: if I have to read a function to understand what it does, it's too damn complicated. I am not good at thinking. Humans, in general, aren't. "Thinking" is still in the early alpha stages, and frankly, I don't think it's going to catch on. This `__init__` method is making me think, and I don't like that.
I work in FX and program with Python. I'm on the other side of the client trades working on broker-&gt; bridging tech, but your platform looks interesting. I'd like to take a look at this &amp; contribute if possible. Please let me know if that's cool.
Well endowed? Give me a break.
The requests library is always given as an example of well python. 
Whoa. Thanks a tonne for this!
I can agree the function would be better if some of the parts were moved to private functions within the class. I would not remove the comments.
I wanted a simple way to take a nested set of markdown files and write them out as nicely formatted html Ended up with this http://benlowery.co.uk/blog/statomatic.html (not necessary pretty code but it works well) even supports custom templates and full YAML configuration. 
Any contribution is welcome! But out of curiosity, is there a specific reason for this? I'm usually sticking to 2.7.x because of a) my (probably irrational) fear that I can't use any important packages anymore and b) lack of deeper know-how of Python :)
I'd love that screen! When can I expect your shipment? :P
Why would you want to do this? Seems very unpythonic.
Thanks a lot for the solid explanation. Sounds very reasonable, I guess I was just holding back because of lack of knowledge. To bring it to the point, I'd greatly appreciate the help to move to Python 3.
some of it, yes. 
This is what I was able to find: http://stackoverflow.com/questions/138250/how-can-i-read-the-rgb-value-of-a-given-pixel-in-python
a) Most packages are already ported over. In engineering, there's numpy, scipy, scikit-learn, matplotlib, plotly etc. b) It's okay. You'll probably get better eventually if you keep using it. That being said, the why. Python 3 (especially with 3.5) is much nicer to code with than Python 2, fixes many obscure bugs which used to fail silently, and it will be supported going forward. Forcing people to use 2 is not nice. Also, Python 3 is becoming the default in many places. If you try to run it on Arch Linux for instance, it will die because the default python interpreter is 3. It's usually pretty easy to port your code over to Python 3. It's also easy (but annoying) to keep it compatible with both. Usually, it's adding parens for the prints, changing xrange to range, and making sure that if you divide an int by an int, you use // instead of /. First, we need to get your tests working though.
These are the absolute minimum security measures for every web application and none of them are really related to the Bottle framework. One might as well link to [OWASP's Top 10](https://www.owasp.org/index.php/Top_10_2013-Top_10).
Yeah there's an issue right now with the default CurrentSeason being set to last year but it's configurable so that you can set it yourself whenever you create an object. I'm gonna releasing an update soon once I get time off of work for the holidays.
&gt;These are the absolute minimum security measures for every web application Yes, correct. &gt;and none of them are really related to the Bottle framework. It does show Bottle example code. The point of the post is to show how to implement basic security measures using bottle. 
F-Secure stands for "fucking secure".
Yes, but wouldn't you still need P IL? Edit: nevermind, PIL was added to code above
Yup, he doesn't say anything about not using existing libraries. 
I was just saying because I figured that part was "relevant code" 
Good read! very interesting, I'm a recent civil engineering graduate trying to become a software engineer or at least heavily interested in it and I've done some with traffic fatality data particularly on the geospatial side (analyzing roadway geometry, location, and tier of roadway in which it occurred etc.), maybe thats because I look it at from a perspective of what I could change on the civil engineering side to make it safer, but the truth is more often then not its driver error then conditions that can be remedied, which is disheartening. Your also right that were sort of calloused to driving related deaths because it occurs so much here, however we also spend a lot more time in cars then most countries and its a lot more ingrained in our culture. I guess the good news is it use to be a lot worse, and hopefully within a few years it will become a thing off the past. (because it entirely could) I'll definitely look this up later and check out the datasets and what you've already done, did any of the data sets you use have geospatial data? Also I don't have a blog or anything but if you get the time check out my github project where I show some of the analysis I've done: https://github.com/murphy214/pipekml 
Ah fair enough, as a fellow user who needs to compile windows extensions I feel you're pain. However, do you reckon it would be useful if I showed you how using conda might make that compilation workflow easier, at least for releases? I'm thinking about writing a blog post about how we use conda to help provide binaries across all platforms. 
I'm a noob too lol that's why I asked. And I'm trying to make like a super basic editor (if I can read and then write over those rgbs to make a new image)
Thanks! And stupid question- how does it know where the image is? At what point do I set the directory of where the jpg is located?
This seems to work the best for me: expected_avg_var = ['529', '842', '16', '13', '#d0851a', '0', '0'] actual_avg_var = ['529', '842', '16', '13', '#d0851a', '0', '0'] self.assertEqual(expected_avg_var, actual_avg_var)
You can take a look at the opencv library. it receives alot of hate here since it was hard to use in the past, but now with numpy integration since ocv 2.4 its alot easier
Or pillow. 
Supports python 2 only This comment from creator on hacker news made me laugh: http://via.softinio.com/Screen-Shot-2015-12-21-14-28-25
The book is more explanatory than the docs of pylint and flake8 and can be used by anyone who wants to actually understand the issue behind the linter message. 
A free software Unity-like environment would be [Godot](http://www.godotengine.org/projects/godot-engine). However, it doesn't use python, instead a tiny python-derived language called "Godot Script". Highly recommended nonetheless.
python sourcefile.py A word of advice tho for the future: if you want answers and help, learn how to state a proper question and to provide enough information about your problem. 
how does python sourcefile.py work ok im building a game it works fine in the shell but i want it to work in the command line and see if getpass works on that but as soon as i enter a value for the first function it just exits the command line
Code exits when it's done. That's what it does. Also, define works....
You're being incredibly vague. Have you tried reproducing this on a small problem? How do even users input data? What's the termination criteria for the program? Have you added debugging statements to see how the termination criteria change based on how you run the program? What does "just exits" even mean? Does it crash? Does it print anything? How are you instantiating your script in IDLE vs. the shell?
Bear in mind you got a couple of tricks you can use. "./myfile.jpg" This wll look for the.jpg file in the same directory as your .py file. If you store your files in an images subdirectory (very common), you can do the same thing. "./images/myfile.jpg" Now lets assume your program is a little bigger and your .py file is in a data subdirectory, that lies next to the images subdirectory. In other words you gotta move UP a directory first. "../images/myfile.jpg" That's what the .. Is for. Using windows you might have to use \\\ (double backslash) instead of / (forwardslash) because windows is weird. You should absolutely use Pillow for your needs, [scroll down this page to see everything you need to know about basic use of the framework](https://pillow.readthedocs.org/en/3.0.x/handbook/tutorial.html) 
FYI, the name you're looking for is **Mandelbrot**.
sorry im new to python this is my first coursework assignment and yes ive run the stage1 on the command line it basically guesses the number until it gets it right using one function. im now on the third stage which asks you to play two player. So I set the first function so that the user can input to play one player or two player which on they select depends on which type of game will be run. If they enter one player the function for the one player game will be placed within the if statement. 
&gt;This wll look for the.jpg file in the same directory as your .py file Just to note: this will look in your *working directory*, which is not neccessarily the same place your .py file is, unless you run it from the same directory as the script. And in fact, just "myfile.jpg" will do the same - the "./" part is redundant. &gt;Using windows you might have to use \ (double backslash) instead of / (forwardslash) because windows is weird. Actually, windows will accept forward slashes fine - it uses them interchangably with backslashes in all its APIs. The one exception is the command prompt, due to backward compatibility issues ( / was used as a switch prefix in some commands), but unless you're using os.system, it shouldn't be an issue to just use forward slash everywhere.
Nice corrects. I knew somene would step in if I forgot some details, thanks. ^^And ^^windows ^^is ^^still ^^weird. 
Do you know if there's a library to do this, except outputting the Pantone color instead of RGB value?
Is there an image format for pantone you are trying to read? Or are you trying to convert rgb -&gt; Pantone? I'm not really familiar with pantone, it seems that its a proprietary system, and does not map directly on to rgb table. You may have to settle for a closest match.
If you want to do anything at a reasonable speed you should use opencv. If you just make a doubly-nested for loop with PIL or Pillow, I guarantee your code will not be vectorized. On top of that, it'll probably be 20-100 times as slow as a non-vectorized C for loop. Messing around with PIL is fun but don't expect to make anything usable with it if you don't understand what's going on under the hood.
&gt; Using windows you might have to use \ (double backslash) instead of / (forwardslash) because windows is weird. Believe it or not, Windows understands forward slashes just fine in many contexts. Check it out - Start -&gt; Run... -&gt; "C:/windows/system32". For maximum fun, of course, you could delete all the stuff in there. ;)
SimpleCV will export a numpy matrix as you mentioned in two lines: img = Image('path to image') matrix = img.getNumpy() print matrix http://www.simplecv.org/ 
Can you post the code, and the commands you have tried to use?
Sounds like a really nifty idea. I'd be interested to see what the end result looks like!
And the Pantone system requires accounting for perceptual differences based on media: glossy vs. matte vs. projected vs. CRT etc.
This. And if you want to have some fun learning some of the ins-and-outs, IIRC a few of the challenges at http://www.pythonchallenge.com/ have you do some image processing to perform tasks like getting the rgb values of various pixels, and operating on them.
After googling for DI libs for python a while I at least have to give you big props for not making some OOP java-inspired crazy thing, but actually making something that looks like python :P
will do mango
I'll try to explain it better: C code is faster than Python code for a few reasons 1. There is this thing called spacial locality. The basic idea of spatial locality is that code that accesses parts of memory that are right next to each other is faster. How does this apply to your image? We'll, you can think of an image as a 2D array where each element is an RGB value. All of those elements are packed right next to each other in memory. A competent C programmer could write software that exploits this spatial locality --- software that exploits the fact that everything is right next to each other. This will give huge speedups because most of the array will be in the cache rather than in RAM or on disk. If you don't know what those are, all you need to know is cache is faster than RAM is faster than disk. The reason you can't really exploit spacial locality in Python is because all the primitive values --- the ints, the chars, the array pointers --- are below a layer or two of pointers. This is one reason why Python so expressive, but so slow. 2. Remember spatial locality? Well a long time ago, when DVDs became popular, people wanted to watch DVDs and other media on their laptops. But if you think about it, you'd have to load an entire image and draw it to the screen 30 times per second. This doesn't sound feasible with crappy personal computers and laptops right? Well, to alleviate this problem, we can exploit some things that we know are true. We know that every image (every frame) of the movie is right next to each other. We also know that every pxiel of every frame is right next to each other. If you think about the CPU of a computer, each operation --- every load, add, store, subtract, multiply, etc. --- typically takes one cycle. Well, if we're watching a movie, the same thing will happen over and over and over and over: load pixel, then add/subtract/transform the pixel in some way. To exploit this, the people who make your CPU added (in hardware) a way to do these operations --- load, add/subtract, store, etc. --- four times at once! So you can load four values (four adjacent pixels) in one step! Some computers can do even more than four. But the point is, if you are a pretty smart C programmer, you can tell your computer to do four things at once (on the same CPU, this is not multiprocessing or threading). The reason you can't do this in Python, is because everything is beneath a bunch of layers of pointers. So, Python libraries like opencv and numpy are basically: take some Python code, run off and call a bunch of C functions (that exploit 1. spatial locality and 2. SIMD instructions (vectorizable code)). This makes it so you have the expressive power of Python, but the speed and cache-conscious power of C/C++. So think about just doing a doubly-nested for loop in Python. It's slow **because you can't vectorize your code.** It's slow **because it can't exploit spatial locality.** It's slow because depending on your version of Python **you may have to allocate all the memory for range(n)**, which takes a long time. And I'm sure there are many more reasons that I don't know about.
One big practical difference if you care about Windows is that pillow can be pip installed, unlike pil 
I like this a lot and I have some code where this will be very useful. Thanks!
&gt; how does python sourcefile.py work if you ask this: please read a python tutorial first before you write any line of code
Not necessarily. It depends on how the proxy was coded and what it is looking for in regards to authentication. This is generally why there is no silver bullet solution to this process as authentication can vary. If you're looking to create a single use case solution then this shouldn't be too difficult to create. If you're looking for a multi-case solution then you're better off creating a separate module that will handle your authentication needs. You may need to survey the different proxies you are looking to support and build separate authentication methods for each of them. EDIT: Check out [MITMProxy](http://docs.mitmproxy.org/en/stable/features/proxyauth.html) as it handles basic HTTP authentication itself, but is not and end-all solution when using other proxies.
This is such a good description of Python vs. C/C++. 
&gt; directions = [Directions.n, Directions.e, Directions.s, Directions.w] This should be moved out of the loop, unless python is able to optimise it.
Thanks a lot.
That's not what the title suggests, or how the article is framed.
As someone already said... you can use Pillow (pip install pillow). from PIL import Image im = Image.open('lena.jpg') print (im.format, im.size, im.mode) box = (300, 300, 400, 400) region = im.crop(box) px = region.load() count = 0 for x, y in zip(*(range(z) for z in region.size)): count += 1 if count &gt; 10: break print (px[x, y]) The above outputs... JPEG (512, 512) RGB (211, 86, 90) (209, 86, 91) (217, 94, 99) (212, 91, 96) (224, 100, 110) (218, 98, 107) (214, 101, 107) (214, 107, 113) (222, 121, 125) (227, 131, 133) 
all that i hear about anaconda, i figure it's about time i start using it. the crude telnet system i hacked together for this lab is nice and all but it takes vital stuff out of the loop. 
This is faster, but I'm really confused on the output of it. Does it go left to right or what? And why is the "box" (300,300,400,400), shouldnt it be the dimension of pic?
I agree that the performance is definitely critical in a production scenario, and intuitive might have been the wrong word. A double for-loop is more educational/pedagogical for someone trying to learn programming than simply calling a pre-built OpenCV command to give you the answer you're looking for. It teaches *how* that stuff works, even though it is implemented really slowly. The vectorized code does the same double for loop, essentially, it's just more opaque, harder to understand, with much better performance, and that's how the OpenCV and numpy libraries are implemented for sure. But, I'm not trying to be overly critical. Explaining why somethings are fast and somethings are slow is an important thing, for sure.
You make a good point.
http://goffgrafix.com/pantone-rgb-100.php
That adds the extra difficulty that the color from a photo will be far from being an absolute value as it will be greatly affected by photo quality, lighting, etc.
Anaconda is the hands down best thing that ever happened to Python packaging. I'm even tempted to draw Far Reaching Conclusions, like that Linux packaging has the same story: at some point the for-profit Red Had said enough with amateur bullshit, this is __the__ way you package stuff, this is __the__ way you install it and otherwise work with it, and here's __a__ way for you to get packages, and then suddenly pretty much everyone uses a package manager at least built on top of that. (though we are not quite there with Python story, anaconda.org (nee binstar) remains the sole way of publishing unofficial packages AFAIK, -- in practice, I mean. In theory you could point conda at anything). On the other hand for all my enthusiasm I must warn you that anaconda/conda is pretty rough around some corners. Off the top of my head: - There's no such thing as source packages or more importantly even pre-source packages if I can call them that. As in, on Linux you can download the source package for whatever, run a few arcane `rpmbuild` commands and get yourself a directory tree containing the full source code plus a `spec` file that you can build source or binary packages from. Not so with Anaconda: their meta.yaml files are scattered across various git repositories or are outright unavailable (case in point: the official lxml package), there's no way to say "I want to download the source of the package to build it myself". There's not even a way to say "I want to download the source code corresponding to such and such binary package, so that I could look at the C code of lxml of that particular version, you know?". All you have is a bunch of binary packages, official or unofficial, hosted at anaconda.org or elsewhere. This sucks and could be a huge architectural problem, I mean, it would be hard to insert that stuff in when they have not designed for it from the start. The `conda` client is pretty rough on the corners in certain respects as well: as far as I know, there's no way to show the description of a package. When some package says that it depends on some other package, there's no way to see even the one-line description of what that other package is supposed to do, I have to use pip or google. I can't even make it tell me other stuff that it can tell about some installed package, it always tells me all that stuff about every single remote package, regardless of platform or Python version. But the way it Just Works™ with officially hosted packages is so, so, so good I can't imagine going back to installing shit manually. Plus what other people said, repeatable environments etc. If you fit into their current user profile (that of a scientist who wants to install all necessary shit and get back to doing Science), it would be extremely nice to you. And I sure hope that that profile is going to expand, it's really a very young project.
Yea, we'll have an admin review everything, we're shooting for a close approximation where possible. We don't need 100% accuracy, thankfully.
Have you considered adding chat functionality? You could use a voice to text API to translate your queries to text and then have charmander translate that into an action. He could respond with "char", " char char ", etc with a little animation. I'm not sure it'd be useful, but it would be nifty, like a better Cortana.
Um thanks
Posting to tag this. I'm not really into Forex but I'm helping my dad backtest his system, currently just doing simple stuff from scratch using Pepperstone's historical data but will check this out!
good man explain pil and pillow. Another good man respond. New man respond to good man, but change response to this. 
&gt; Using windows you might have to use \ (double backslash) instead of / (forwardslash) because windows is weird. Or... you can use `os.path.join()` to build file paths using the whatever separator your OS requires.
&gt; width = photo.size[0] #define W and H &gt; height = photo.size[1] width, height = photo.size For the children! 
I read the title and article just fine. If you were to change the title to your liking, I think you'll fine that it would turn out to be a pea under all of your mattresses. 
Yeah, I thought the same. It reminded me a very fucked up satisfaction survey system we had which basically subtly pushed clients to write bad reviews for us LOL
good man good. Who was phone?
Indeed. Not to mention the silliness I heard about the so called 5th generation programming languages... programs to write programs...
I'm pretty sure this algorithm can be fully vectorised, which would prevent any need for numba (for speed). But nice work! 
Distribute color calibration cards to the users of your app, and tell them to make sure the card is in-frame with the item they're trying to color-match. Otherwise, you're going to end up getting utterly screwed over by white balance issues.
I've also found Pillow handles transparency in certain animated .gif files correctly where PIL doesn't. (in Python 2.x) So.. bug fixes. I think it's great that they are totally API compatible with each other.
Pillow: easy pillow install PIL: I've spent hours
Neat! I've been eagerly waiting for Indego (Philly's bike share program) to share this kind of data to do the exact same thing. &gt;He plans to make the model and app available for anyone to use—Pronto’s bike-dispatchers, for example. Hopefully they’ll take him up on the offer, ensuring no Seattle rider finds themselves forced to hoof it again. That's going to be the most difficult part by far. Most city programs are afraid of decision trees, much less random forests. Too black box-y.
I started working on this tool a couple months ago, and wanted to get a chance go try async/await + Type Hints in the real world. This didn't strictly need async/await, but given I knew I would be sending a bunch of requests to GitHub I wanted to give it a try. The 3x speed up from async/await was a nice boost though. Async/Await definitely needs better documentation, but is really powerful. For example, parsing output from a web request as it streams in is super easy! https://github.com/lyft/linty_fresh/blob/master/linty_fresh/reporters/github_reporter.py#L122 On the downside, most other languages implementing async/await have async functions return some sort of Future-like object, whereas Python 3 returns a raw co-routine. This leads to somewhat surprising behavior when you await the same variable twice (the second time returns None). There's also not great or examples of async/await yet, but hopefully this will help in some small way :D.
Looking into alternatives, it seems that Click may be a better option for me. I also tested out docopt_dispatcher, but it states that it's only experimental
Why not just use normal required parameters in argparse? If they are actually required for the script that would seem nicer anyway and also give full backwards compatibility, instead of -- arguments. argparser = argparse.ArgumentParser() argparser.add_argument("file") argparser.add_argument("action") args = argparser.parse_args() file = args.file action = args.action 
This is impossible unless the exact temperature of the light is known. The colour in the image will look very different depending on what the camera's white balance is set to: https://i.imgur.com/Tk2hWoe.jpg 
Sure, please do. I'll download over the weekend and see if I can test.
I suppose I shouldn't be surprised that I was taken literally by a bunch of engineers
Godot is worth following, specially since they intend to invest heavily into vulcan. Not sure how well the 3d engine works right now, and I was kinda dissapointed the webgl support was lacking. 
Mainly to have argparse inline with the rest of our coding standards. (And secondarily I forgot about positional arguments `^.^`)
Interesting, in that what you want to do is exactly what I also want to do, but I am still trying to work out what language would be best to write it in, because I will need to do a hell of a lot processing, so raw speed is of the essence.
It is not a good idea to have your tool install its required dependencies if it cannot find them. The Supercharged AWS CLI project may interest you: https://github.com/donnemartin/saws
Just call the function directly. 
Using `from module import *` means that I can't tell which module the functions in example code come from without reading or memorising the APIs. Please use explicit imports - or for example code, just write `module.function()`!
What are you doing under the hood? Interval trees?
Wait, can you use this allplatform thing to build extensions for other platforms without having access to them?
Since it hasn't been suggested yet, [PyPNG](https://pythonhosted.org/pypng/) can do this with PNGs easily enough, if you only care about PNGs. Otherwise, the Pillow suggestion is likely more robust.
&gt; Most city programs are afraid of decision trees, much less random forests. Too black box-y. Even though they are one of the easiest classifiers to understand, sheesh!
&gt;The only access I have for exporting is through a frontend gui into an excel file. Although you say this, note that there are Python APIs for various databases: Oracle (cx_Oracle), SQL Server (pyodbc), etc. If you have the login credentials to the database, you may not need to go through the GUI's CSV export step.
I use the package argh making cli. Each command is represented by a function.and then you list which commands to expose. http://pythonhosted.org/argh/
I use it to do one of two things (90% of the time) 1) Automate tasks that are readily automatible but haven't already been automated (parse all of files of type x for lines containing y and replace with z) Or 2) Write scripts to automate tasks for other people, either in Autodesk Maya or standalone.
Interesting, but I can't seem to wrap my head around this. It seems like it would be a lot like base64, but for when you need to send arbitrary binary data over a unicode channel? Or is it just a joke? 
Probably both. 
Probably encodes to valid UCS-2. Maybe worth it if some idiot implemented a text-only channel in java or some wchar API
Over an *incredibly tolerant* Unicode channel that's cool with control characters like U+8, non-characters like U+FFFE, surrogates like U+DDDD... I'm assuming it's a joke. But it's been done better before.
"@inject" here works very like a "@functools.partial", except of some logic for working with "providers", so in example above it just decorates "example()" with 3 injections that are provided as keyword arguments. One thing, that could be improved here for shortening is using of "example(**kwargs)": @inject(users_service=Services.users) @inject(auth_service=Services.auth) @inject(database=Services.database) def example(**dependencies): assert dependencies['users_service'] is Services.users() Actually, the main idea of this "@inject" decorator (like, may be, the whole library) was to create some syntax sugar... At the current example, it helps me to see all dependencies in one place. Counter variant here is to do something like this: def example(**dependencies): Services.users().do_something() Services.auth().do_something() Services.database().query() But it requires me to read all the "example()" body, to understand all the dependencies, so here is my sense of doing this. Also "@inject" works well with classes: @inject(users_service=Services.users) @inject(auth_service=Services.auth) @inject(database=Services.database) class SomeClass(object): def __init__(self, **dependencies): self.__dict__.update(dependencies) Another one feature, that, to be honest, I use the most is creating so-called catalog bundles: @inject(services=Services.Bundle(Services.users, Services.auth, Services.database)) class SomeClass(object): def __init__(self, services): self.services = services def do_something_with_user(self): self.services.users.do_something() Catalog bundles are like "frozen" limited collections of catalog's providers. You can find more info / examples here - http://dependency-injector.readthedocs.org/en/stable/catalogs/bundles.html Also it is interesting question about this: @inject def example(users_service, auth_service, database): ... My answer here is that I intend don't try to make any kind of autoresolving in this library. It might be only mine IMHO, but I feel some kind of "magic" inside process of autoresolving dependencies. Also I didn't use any kind of introspection / reflection during the implementation.
Thanks, it's interesting to watch... Will post some comments after...
That's really interesting, numba must be smoking-fast, I'll give it a try some time. I had found vectorised calcs to be faster than cython by miles, even when the cython algorithm short cutted calculation much of the time.
Of course! Since it's a new blog I haven't added a CC license yet. I 'll do it probably later today :)
It's almost better to learn django and make a webui for your project, pyqt, tkinter etc all look outdated and ugly imo for the amount of work that they are...
:)
Hey Really cool idea. I've to do little bit of Googling :p . Slack mobile and desktop app should support voice functionality.
What about the installation instructions do you not understand?
I would either go with a numpy binary: http://www.lfd.uci.edu/~gohlke/pythonlibs/ Or go with Anaconda, already including Numpy. It's a pain in the ass to install numpy regularly on windows.
Check out [Unofficial Windows Binaries for Python Extension Packages by Christoph Gohlke](http://www.lfd.uci.edu/~gohlke/pythonlibs/#numpy) 
Nicely written in my opinion: good clean code style; it does its job well and without over-engineering. Thanks for sharing! Just one thing that caught my eye: instead of reducing `add` over those list comps, could you use the builtin `sum`?
https://github.com/zoofIO/flexx here is one of them.
Anaconda is a installer and has a install for Python 3.5. It includes numpy, scipy, etc...
https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable
i tried this but the result is: [1,2,3,5,6,9,10] not the needed answer
I knew what I wanted it to look like, so I just started with the bare essential Tkinter application Window and kept adding the features I wanted by looking them up. 
Yup, also if you want a slick interface is pair it with bootstrap. It's a bit of work in the beginning bit once you finish your first project you can reuse the webui you made for your future projects to save time.
Yes , they did , WOW 
works for me: &gt;&gt;&gt; from itertools import chain &gt;&gt;&gt; l = [[1,5],[10,2],[6,9,3]] &gt;&gt;&gt; list(chain.from_iterable(l)) [1, 5, 10, 2, 6, 9, 3] you must be sorting the list elsewhere
what code did you try? whole bunch of ways and timings in this thread: http://stackoverflow.com/questions/952914/making-a-flat-list-out-of-list-of-lists-in-python
A couple more variants: &gt;&gt;&gt; data = [[1,5],[10,2],[6,9,3]] &gt;&gt;&gt; sum(data, []) [1, 5, 10, 2, 6, 9, 3] &gt;&gt;&gt; [i for d in data for i in d] [1, 5, 10, 2, 6, 9, 3] 
5 month ago i have posted a [text post](https://www.reddit.com/r/Python/comments/3cwva5/dont_you_think_pycharm_logo_is_more_like_a_happy/) about pycharm logo and said it is like a happy worm , It is changed to new logo , we don't know they read the feedback here or not 
Yes, I use tqdm all the time but it was necessary to use the link to this correct version
Thanks - I hadn't realised that. Fixed now.
thanks bro, i notice right now that the previous list was getting sorted the list of lists, was generated by a for loop, appending the internal lists, so, something like : &gt;&gt;&gt;for i in Data: &gt;&gt;&gt; Listoflist.append(list[i]) &gt;&gt;&gt;print Listoflist [[1,5],[6,9,3],[10,2]] well, do you know how to avoid this sorting, assuming that the appending order was [[1,5],[10,2],[6,9,3]] , but after the loop is finished the listoflist was "sorted" to [[1,5],[6,9,3],[10,2]] pd: sorry for not knowing how to write the code at this textbox
eventhough i did everything half manually now i still get this as i really like that. tahnks
How is PySide with building custom widgets?
I do about 2 -3 GUIs with PyQt a year. It does make your code a little complicated. It is by far the most feature rich library you could hope for, from multimedia to multi-threading. The yak shaving is horrible. I really should automate it, but that's something else I have to maintain. The flow is pretty much: 1. Create virtualenv. 2. Get PyQt into the virtualenv. On Windows this can be tricky. By copying the /lib/PyQtX folder to the virtualenv's /site-packages. You may need to tweak your IDE after you fire it up. Sometimes PyCharm catches it, sometimes it doesn't. If it doesn't you need to copy skeletons from the base install. 3. After checking your PyQt import, immediately create a quick window. If it doesn't show up when you run the script, or you get a 'platform' error, your paths are probably wrong for the dlls. You fix this by appending the Qt library path in QtCore. You can check where it is looking by using libraryPaths(). 4. Once you have a test window running, you can start using QtDesigner. Again, just make the most basic MainWindow, and save the .ui file. 5. You now must compile the .ui file into python. You could use this .ui on other platforms as well, but PyQt has a utility to create the .py file for you. It is called pyuicX.bat and it is in the site-packages\PyQtX folder. You run this utility at the command line. Here is some info: http://stackoverflow.com/questions/18429452/convert-pyqt-ui-to-python. Save the file into your root directory. 6. More yak shaving. You must now test that your compiled UI file is correct. You can open it and look at it, but editing it is useless, as it will be overwritten the next time you compile. Here is the boilerplate: import sys #PyQt5 for gui from PyQt5 import QtWidgets, QtCore, QtGui from UI_Compiled import Ui_MainWindow #Main program class Main(QtWidgets.QMainWindow): """ Main program """ # noinspection PyUnresolvedReferences def __init__(self): QtWidgets.QMainWindow.__init__(self) #Setup the UI self.ui = Ui_MainWindow() self.ui.setupUi(self) def main(): #Setup the main application object app = QtWidgets.QApplication(sys.argv) window = Main() window.show() sys.exit(app.exec_()) Notice the UI_Compiled import. This is the compiled ui you created, it could be named anything. The Ui_MainWindow class, however, is the default. Changing the main window name in designer will change this class. Later in Main, you stuff that class into self.ui. This allows for easy access of the widgets you create in Designer. Calling self.ui.setup(self) loads up your compiled ui. So in main(), app sets up the application. Window = Main() created the MainWindow. It is now loaded into memory. Calling window.show() displays the MainWindow. sys.exit(app.exec_()). sys.exit(app.exec_()). Notice the app.exec_()? That doesn't have to be in sys.exit, but will allow you catch any exceptions if the program crashes. You could have app.exec_() right before exit(), but the convention is as written. app.exec_() is very important. It starts the event loop. The thing that handles what happens when you click or drag and drop. If you show your window and do something, even clicking on minimize or close and did not call app.exec_(), you crash it. If all goes well you are looking at your main window. Close this window. 7. VERY IMPORTANT. If you plan on creating an EXE for deployment, you MUST pick a packager (py2exe, cx_freeze, pyInstaller, etc...) and get this working RIGHT NOW. It needs to be a part of your workflow. These packagers sometimes miss libraries or packages or files, and the easiest way to stop a mess is to tackle the problems for every import. Things like Matplotlib and PyQt may not work on your exe, because the packager missed something. Googling the error almost always tells you what you need to specify in the EXE maker. 8. Interfacing your python code to Designer. Go back into designer and drag a button to your MainWindow. Switch to the Signal/Slot mode. Click and drag on your button, to the main window and release. It should look like this: https://imgur.com/gR9Neyk Now click on clicked() in the left pane. Click on Edit... in the right pane. Under the Slots pane, you'll see a +. Click on the +, and type say_hello() https://imgur.com/hjocaxX Hit OK. Click on clicked() again, then you'll see say_hello() on the right pane.https://imgur.com/01igh6u Click on say_hello(). Click OK. 8. SAVE ui. Recompile ui using pyuic. 9. You MUST add that exact function to your code now, like so: """ Main program """ def __init__(self): QtWidgets.QMainWindow.__init__(self) #Setup the UI self.ui = Ui_MainWindow() self.ui.setupUi(self) def say_hello(self): print('Hello') If you fail to add this function, your script will throw an exception. It is looking for it when it sets up the ui. Clicking on the button, will now print Hello to the console. You do not need to setup the signals in designer, but if you add any signals or slots on your python code, then you should keep a list somewhere of the the signals and slots. Designer does this for you in the signal/slot editor window. There is no way to retrieve a list of all connected signals and slots. If there is I'd love to know about it. 10. So now you just keep iterating. Add some stuff in designer, setup a signal if needed, save, compile, add function to your code, execute. Every so often run your packager if needed. 11. With PyQt you can assume there is a module to handle almost anything. Threading, serial comms, settings management, timers, video, audio, networking, queues... It is really powerful. 12. If you want to add resources (pictures, icons etc) you can compile those as well into a single py file. 
Handle
I just save the _upper_ and _lower_ end for each range. I then use the comparison operators to implement all functions on top of that. I am not familiar with interval trees as of now.
I assume you are referring to the 90s example. I will update that to use explicit imports instead. Did you find anything apart from that particular example? EDIT: That particular example is now updated.
I use [Kivy](http://kivy.org/#home) for my latest project, once you understand the .kv layout file its very powerful and it has a fantastic MIT based license. (I personally dislike all *GPL, LGPL+ based ones). But it wasn't easy, as their documentation is a bit lacking, oddly enough, the pdf of their API has more information than the website does. 
Because the python interpreter isn't specified most likely but again I'd need to see all of it before I could actually give a real answer. You can use paste bin to copy &amp; paste large amounts of code. 
It's a data structure you'd almost certainly find useful. https://en.wikipedia.org/wiki/Interval_tree Looks like there are already several python implementations you could leverage. 
Hello! I'm a bot who mirrors websites if they go down due to being posted on reddit. [Here is a screenshot of the website](http://i.imgur.com/3HCftMB.png). *Please feel free to PM me your comments/suggestions/hatemail.* _____ [^FAQ](http://np.reddit.com/r/Website_Mirror_Bot/wiki/faq)
ok
As an ipython user, any benefits of ptpython over ipython?
http://pastebin.com/2wBNyQVi
I made something similar recently. It's basically the same. The symbol is replaced by its number in the ASCII table, and then some mathematical stuff happens and I have a huge amount of numbers that seem to be totally random. The encrypted data is saved in a binary file in a hidden folder, and nobody I know has the knowledge to make hidden folders visible or how to decrypt those numbers. I'm currently working on a way that allows me to encrypt other files *(like docx, xlsx, pptx, pdf, jpg, png, gif, etc...)*. *Edit: I have secured the programs with username and password to ensure nobody stumbles across them and has instant access*
Your smaller resolution logos suck ~ they all look the exact same in my task bar. Here we see [four separate programs](http://imgur.com/OyTaMCO.png) that all look exactly the same at a glance, even on a 1080p monitor. Horrible design choice.
I can recommend click. It's just so easy to turn your scripts into a cli app - I even do it for my one-time scripts. Also look into [setuptools integration](http://click.pocoo.org/5/setuptools/) which makes usage of your scripts as nice as it gets. 
Question: Why would they create a new module (Dill) rather than just extend the functionality of an existing module (Pickle)? Is this common?
[Here is a brief overview](http://pythoncentral.io/pyside-pyqt-tutorial-interactive-widgets-and-layout-containers/) of widget creation with PySide/PyQt. You can use the Qt Designer program with both 
&gt; that includes pyqt4 and pyqt5 I know PyQt5 exists for Python 2.7. Are there actual binaries built for Windows?
Hey. I downloaded your code and tried to run it. I'm assuming you wrote it in python 3. It started up just fine. Here is what my command line looked like. python3 test.py #Command to run the file Welcome the the jailer game... Do you want to play one player or two player? 1 #I inputted 1 You choose to play one player Do you want to play as the jailer or the prisoner: jailer #I inputted jailer You picked to play as the jailer... please enter a guess between 001 and 100: 2 #Input 2 Traceback (most recent call last): File "test.py", line 324, in &lt;module&gt; playerchoice1() File "test.py", line 9, in playerchoice1 playerchoice2() File "test.py", line 18, in playerchoice2 ch1() File "test.py", line 47, in ch1 elif aplphabet in code: NameError: name 'aplphabet' is not defined #BUG So in conclusion. Your code has a bug at line 47. I think you just misspelled alphabet. It should run fine in the terminal. I use linux and had to use "python3 file.py" as "python file.py" didn't work. If you're on windows, not entirely sure how that works, but the file should run fine, one you fix the bug. 
&gt; Note: If you are not familiar with Object Oriented Programing - then GUI work can be VERY daunting at first. I would almost recommend you learn a bit first about how OOP works. In fact, OOP was invented for building GUIs (the original Smalltalk)
Thank you so much! Yeah I should of gone to Learn Python. 
oh thats so cool! I had been using bpython and were happy with it, but now i'm definately going to switch to ptpython.
Its a bit hard to understand what you're trying to do here. Maybe you could specify the use case or elaborate a bit more on why you're doing it. Also what values do `lvl` and `list2` have?
Ive only had a cursory look at progressbar2, the difference for me seems to be that this is just dead easy to use. 
Did you try? python35 -m pip install numpy
Just learning and trying to figure out the limits to see where they can be suitable.
To me, this logo choice comes from the same unfortunate part of the human mind that changed MySpace's logo to "my_______", put that black bar on top of Google pages, changed Iconfinder.com's [awesome graphic](http://www.forodelwebmaster.com/wp-content/uploads/2012/09/iconfinder-busqueda.jpg) to that [black eye of Sauron](https://www.iconfinder.com/), changed the shadows and thick Fitt's Law appropriate back arrows from iOS 6 to the flat buttons and 1px blue "&lt;" instead, and brought us the pain that is the Windows Metro look for Win8+. I truly don't understand why anyone would think this is a good choice.
tinydb has got me excited, because it's easier than having to make a function for json.dumps/json.loads over and over again.
Details?
You'd sort of go about the same way, but change a few things: - You'll need to manually set the height and width, not get them from the image - ... that's about it. [Here](http://pastebin.com/uxLgYD5h) is a link to a script I wrote that generates Julia fractals.
The term you're looking for is socket programming. https://docs.python.org/3/howto/sockets.html If there's stuff in there you don't understand I recommend you read some C/C++ socket programming books/tutorials to understand how things should work and come back to that tutorial. If this is too low level there's stuff like socketio that work on top of web sockets that have higher easier to grasp concepts (channels, clients, messages).
Also, apparently tqdm is 10x faster (says so in the readme)
Doesn't Python already have a shelve unit that does what TinyDB does?
ImageJ is great for your apllication. You might want to check out [Fiji](http://fiji.sc/) . It is a distribution of Imagej and has some great additions a ton of scripts etc. It can also be scripted with [jython] ( http://fiji.sc/Jython ). In Python you would need to do all the segmentation Algorithmus etc from scratch.. Or find then somewhere. Edit: Fixed formatting [Intro to segmentation by the Fiji people](http://fiji.sc/Principles)
This is a known limitation atm: https://bugzilla.gnome.org/show_bug.cgi?id=685275 If you just want to use the param spec and not pass it to some other gi function you can look at the attributes it provides: &gt;&gt;&gt; print dir(bitrate_property) &gt;&gt;&gt; ['__doc__', '__gtype__', 'blurb', 'default_value', 'flags', 'maximum', 'minimum', 'name', 'nick', 'owner_type', 'value_type' When the bug gets fixed and the two types merged those will still be available to ensure backwards compatibility.
I kept the old logos in my e19 ibar
 - **tqdm** Neat API, very convenient - **joblib** might be useful if it got serialization and data models right - **follum** brings us into the future - **tinydb** is a bit over-engineered for something so minimal, but has its head screwed on straight, which is a very rare feature in the space which it operates - **dill** is a scourge. It didn't learn from the mistake which is pickle
Oh come on Gnome bugtracker! You are not visible from Google?! What's the use if one can't find the bug easily???! https://bugzilla.gnome.org/show_bug.cgi?id=682355 The exact error: Expected GObject.ParamSpec, but got gobject.GParamSpec returns nothing (except the SO question now), yet it is on you Gnome bug tracker! So much time lost, for nothing. -_-"
Not that I know off. OpenCV might have similar (or adaptable) methods but is more geared toward machine vision applications. ImageJ is mostly about scientific image/data analysis. I ran into some problems with OpenCV before when I tried to process 32 bit images and the like, which kinda showed the difference in the eco systems. But if anybody has pointers on OpenCV and its application to scientific images let me know. 
Your reply made me laugh in a good way. Thanks and have a great holiday. 
I got into Python because I wanted a particular program that doesn't exist, and got tired of waiting for someone else to write it! I always wanted to learn programming but never actually invested any time in it back in my school days, and after putting in a good deal of study time a couple of years ago for a certification, I figured it was a good time to strike while the iron was still hot. I started with Python because a few google searches led me to think it was a good 'starter' language. I think that's absolutely true - within a few days I was writing scripts to do things that I'd have expected it would take me months to learn. The syntax just makes complete sense to me, even with no programming background whatsoever. I use it at work rarely - mainly specific scripts to save time, as I deal with a lot of reports in varied (ie. usually crappy and non-uniform) formats. I would use it more frequently if I could, but with the industry I work in it's not easy to do much more in an official capacity with it. I would love to work with Python more, but I don't see it ever happening. Most Python-related roles I see are data analyst-type positions, or system support, neither of which is interesting to me.
/r/learnpython is for all questions Why are you doing this recursively? Only reason to use recursion on non-recursive data structures is homework. :/ Why is there a function just to add one? It gets you nothing, you're never going to have to change it from `(x+1)` anyway. Why not just use slices? You're using them anyway. def every_other(L): return L[::2] If you really have to use recursion, then something like this is much simpler: def every_other(L): if not L or len(L)&lt;=1: return L return L[0:1] + every_other(L[2::]) 
This looks awesome. Now I wish I didnt spend so much time looking into click
Isn't JSON (what tinydb uses) the worst format to store lots of data? 
It depends on how that data is structured. If you've heard of NoSQL databases like MongoDB, they often store data in a json-like format. There are trade-offs compared to a relational model like MySQL, but neither is necessarily bad for large data sets. 
I'm very much a beginner and decided to tackle your problem myself when I saw it. I ended up with something pretty similar to yours. import random head = tail = count = 0 while count != 100: toss = random.randrange(2) if toss == 0: head += 1 else: tail += 1 count += 1 print "In 100 coin tosses there were %d heads and %d tails." % (head, tail) print "end"
&gt; I just tried it with python 3.5. You do need Visual Studio 2015 Comunity[1] (or pro) installed, You just need the "Visual C++ Redistributable for Visual Studio 2015", no need to install VS.
It appends to the original list in-place, literally just googled that from the manual, anyway in-place is the exact opposite of functional programming, just go with +, practise the counter+recursion thing if you want but consider passing an index instead, just add 2 each time and bounds check it. If you don't know how to do stuff the Python way you should probably learn that first then see if you prefer to do some stuff in a functional style, as-is you're just over-complicating stuff for the hell of it, and you'll come back in a month's time and not be able to read all the code.
The book [Black Hat Python](http://greysec.ir/ebook/BlackHat.Python_%20Python.Programming.for.Hackers.and.Pentesters_%5Bwww.graymind.ir%5D.pdf) has a whole chapter on building a TCP client / server using sockets. The code samples are definitely slanted towards beginners.
I got into it because I have to teach programming to beginners. I'm primarily a Rubyist and Javascripter but knew Python would be significantly easier to teach because of how strict the syntax is and narrow the accepted conventions. And I knew pretty much every useful third-party adapter/wrapper library has an implementation in Python.
I've used it mainly for scripting small test scenarios and test data loads. I always use it when I can but some systems I work with are quite locked down and I have to resort to perl. Edit: oh also automating documentation requirements (which keep changing so still working on that...)
You might want to look at the asyncio module if you're using python 3. You call start_server and it just goes. You get a reader and writer and can control how to process input and output from the socket for each connection. There is a simple echo server example in the docs.
If you are using client-side rendering with a JS framework, you generally only need your Python backend to provide an HTTP API. You should only need Jinja for any pages that are rendered server-side.
I think it will also works, but not that fast. I get the number of repo pages from GitHub API response headers, and use map to fetch pages one by one. This would be slow if you have 9000 repos, saying 90 pages. But you can easily speed it up using ``multiprocessing.Pool.map`` instead of the origin ``map``. I didn't choose it because most of GitHub users would only have less than 300 repos, I will be easier to understand using builtin ``map``.
They works fine with generators, but I can write them in one line as I use list comprehension instead. BTW. I've updated it with ``sum``. PS. I can also remember Guido prefers list comprehension upon map-reduce.
I got into it by chance. Some google searches, a preliminary view of competing languages for my application (scientific programming) and Python popped out. Now, I use it for mathematical algorithm development and some of the web framework stuff (mostly flask). 
Note that you dont have any fast BLAS libarary doing that.
Well, using something that supports multiline editing helps. But generally I'm not writing large functions in that context anyway. For verifying snippets work like I think they should, playing with a new module I'm trying to learn, or debugging against runtime state even the standard REPL is perfectly fine. 
I got into Python because Matlab was too expensive. Today, I have access to all the Matlab I want, but I use Python instead because it a much better scientific programming environment, with a much nicer community, and a lot more and more powerful packages available.
While I love Wx, it's not a good choice these days. No Python 3 support and phoenix development is non-existent : ( 
&gt;TL;DR; Yeah I can explain what I did. I did do what I said I did. I just dumbed it down for people like you. Let me put this in terms you can understand: being an asshole isn't going to win you many friends or help you influence people
Qt uses 100% native widgets, so the same app looks like a Win7 app in Win7, a MacOS app there, Fusion on Ubuntu, etc. When you say "outdated and ugly" I think you must be thinking of Tk, which certainly could deserve those adjectives.
Yeah, [right here](https://www.riverbankcomputing.com/software/pyqt/download5). &gt; These binary installers for Windows contain everything needed for PyQt5 development except for Python itself.
Also, ipython does auto completion, but not 'auto completion **as you type**` (ie. IDE style, not 'press tab to complete'). 
Javascript is the lingua franca for browsers. When writing in Javascript, devs can more or less assume that that code is executable in the browsers of the vast, vast majority of users who visit the site. Browsers do not typically have Python runtimes, which means, sure, someone could decide to write one for a browser (uh...and which one would that even be...), write python scripts to his/her delight, and find that pretty much no one will ever be able to run them via browser. That's the practical division. JS is ubiquitous among all the browsers. Python and all other scripting languages are not. Now, Python is frequently the language on the backend, talking to a the server and database and rendering HTML views (which includes the links to JS files that will execute upon a browser visit). But JS can be used "server-side" as well (e.g. nodejs). React and Angular are all about the front-end. Here's a great walkthrough on how to make a data-based (though not based around an actual database, just a CSV) app in Flask (a lightweight Python framework) and Jinja, while embedding some Javascript code (interactive maps)...I use it to teach students who have never really programmed before: http://first-news-app.readthedocs.org/en/latest/ 
I started with C 20-some years ago. Python was my 3rd or 4th language, but it's been my favorite ever since. It's basically required for a Linux sysadmin, which is part of what I was early in my career. Now I am a software engineer. Whenever possible I use Python, because the development time is just so much lower than most of the alternatives. This includes a lot of automation, web pages, one-off data crunching, systems interoperations, and whatever other random crap comes up in a manufacturing and test environment.
tqdm isn't an API
Automatic binary serialization (pickle, dill) is super convenient and a great way to make a quick proof of concept. I've used it more than my share of times to whack together some kind of serialization for a project I'm working on. But, just like real pickles, these solutions start to go really bad around the 2-year mark. Dive Into Python3 says, quite sensibly, that the only time it's reasonable to use pickle is when ["the data is only meant to be used by the same program that created it, never sent over a network, and never read by anything other than the program that created it."](http://www.diveintopython3.net/serializing.html) The trick there, I think, is that no program is going to be "the same program that created it" 2 years later unless you've abandoned support for that program entirely. * When you unpickle data, it runs that data as python code - which introduces security vulnerabilities in the same way that using `eval` in JavaScript does. [Untrusted pickle data can 0wn j00](http://www.benfrederickson.com/dont-pickle-your-data/). * If [the python code changes and the pickled data does not](http://code.activestate.com/recipes/521901-upgradable-pickles/), you're going to have a bad time. Versioning your pickles is not a great solution for this problem, as it leaves you either throwing an error on old objects ("welp, this data is ruined forever.") or trying to write code that works with every version of the object that's ever existed. * Pickle itself changes. There are now [4 different versions of the Pickle protocol](https://docs.python.org/3.1/library/pickle.html#data-stream-format). * Pickle is not a text format. [The Art of Unix Programming mounts a pretty passionate defense of text-based formats.](http://www.catb.org/esr/writings/taoup/html/ch05s01.html) Text based formats are * Human readable. * Compressible. * Easy to pass between systems. * Easy to modify with quick scripts Dill is a better Pickle, but it has all of the same problems that Pickle has: it's probably not the right tool for the job. * If you're messaging, you probably want a well-defined binary messaging format, or a text-based format. (RabbitMQ does support pickle, though - [here's someone discovering that this is a problem](http://stackoverflow.com/questions/12184460/consuming-the-pickle-binary-format-from-non-python-with-celery-and-rabbitmq) and switching to JSON) * If you're storing lots of data, you probably want a database of one kind or another. * If you're storing little bits of data, you probably want a text-based format. But, all that being said, when you need to crack something together for a hackathon or over a weekend, pickle is a frigging godsend, and having the ability to save and load a session is pretty useful. 
I agree with lightshadow. I never read the program when im going through different windows. I look at the shape, and, most importantly, the different colors of the current logo. Same with the Adobe suite.
links broken?
reddit_silver.jpg for the well formatted and humorous explanation
Here is an overview page about all the popular Excel options for Python: http://docs.continuum.io/anaconda/excel
Why wouldn't you just use a debugger/IDE/execute the python script at that point?
Javascript --&gt; only in the browser (there are options to use it on a server but thats not what you are facing here) So Angular and the like run in the customers browser and make sure you get a shinny neat web X.0 interface. But the front end (e.g. Angular) needs data from somewhere (the backend). This is where python comes in. The backend then consits of Python and a custom Flask app which talks to the database and spits out the data that the front end is asking for. *In short*: Angular etc.. are front end (client side, in the users browser), Python is the backend (server side) and provides data.
Graduated a Physics degree and got a job as a data analyst. Had little programming experience at that point, and the company operated mostly from ungodly Excel workbooks, some of which took many minutes to open. Working with VBA for data analysis works wonders for your motivation to learn something other than VBA! Learnt Python off my own back by constantly finding ways to do things faster, outside of Excel. Proving to my manager that things could be better! Convinced the manager we should enter the 21st century, learnt php, js &amp; sql, made a database and a server for data dashboards. Now two years down the line, Python is my right hand. Use it for automation and reporting, general data munging, machine learning (I'm now a DA in Marketing at same company), web scraping, etc.. Getting into NLP now too. I chose Python because of the low learning curve and the vast array of libraries. General data munging in the REPL to produce datasets and reports is about 40% of my work, and Python makes this unbelievably easy. 
Get it with Intel's python https://software.intel.com/en-us/forums/intel-distribution-for-python As a bonus It should be powered with MKL 
&gt; Oh come on Gnome bugtracker! You are not visible from Google?! What's the use if one can't find the bug easily???! Seems like bugzilla has a default robots.txt to prevent this. Not sure what the motivation is there... maybe performance, or to reduce drive by commenting. pygobject search: https://bugzilla.gnome.org/page.cgi?id=browse.html&amp;product=pygobject
Well, yeah. I see your point. I mainly use Python 2.7...
Thanks, that made a lot of sense. 
I was a C++ programmer by default, since that's what my college CS curriculum taught. I also knew a bit of several BASICs before that and PHP+JavaScript because I wanted to do web dev. In grad school, I was on a group project working with a VICON tracking system (high end motion capture) and some very custom hardware - think the Microsoft Surface table but about 4 years earlier and made by grad students. Anyhow - the glue that held the system together was Python and I was intrigued that this random language would/could have bindings to all the expensive and custom components we were using. Later, I had some data collection tasks for my thesis research - basically scrape dozens of webpages to get the latest status of the project they contained. I ended up writing Python to automate that task and store the results in human-readable format for the research. I loved Python's flexibility, ease of reading and writing, and batteries-included philosophy. PHP was a fine language to learn on, but I prefer the Python community. C++ is, for me, a miserable language to work in. I can't quite put my finger on it - I think it's ugly when written and has too many sharp edges. Today, I'm a program manager at Microsoft building developer tools (Visual Studio Team Services, née Visual Studio Online). Whenever I have a half-day task or something that will need to be run repeatedly, I write some Python to do it. I'm also passionate about beer so I wrote a beer tracker in Django and have recorded the details of every ounce of beer I've had since Jan 1, 2011. Other languages: I love C# for bigger systems, desktop apps, and projects with lots of developers. JavaScript has some neat features like prototypal inheritance. I have only a cursory knowledge of the Lisp, ML, and Prolog families but am glad I spent some time tinkering in them. I picked up a bit of Forth on my own and want to keep studying it - I think it has some great lessons as a simple yet sophisticated abstraction over the hardware.
Thank you! I have started this project by reason you mentioned: the lack of tools for Python that allow to see the whole picture. If you feel that something is missing or does not work as it should, just open Github issue :)
Rapid GUI Programming with Python and Qt.
Besides the other good answers here: With some tasks you can decide where you want to put them. For creating some simple html interface you can use jinja2 with something like &lt;div class="name" id="friendname"&gt; {{ friend.name }} &lt;/div&gt; But of course you could also set the name clientside via a javascript ajax call &lt;div class="name" id="friendname"&gt;&lt;/div&gt; &lt;script&gt; $.get("friend/name", function(data) { $("#friendname").text(data); }); &lt;/script&gt; Or you could manipulate the dom clientside. Of course you can also mix all of these (and sometimes have to). Then it is not clear anymore if templating is done serverside or clientside (well it's both, so...) or rather it is not clear what templating should be done clientside and what serverside. You could probably ditch most of jinja and does nearly all templating clientside, but if that is a good idea is another topic. (Take all I said with a grain of salt, I'm not that expirienced with javascript stuff)
I would suggest http://shop.oreilly.com/product/0636920028154.do but not http://shop.oreilly.com/product/9780596158118.do The first one has much more useful information (even for advanced programmers). The second one is kind of boring.
I'll try that. If that works, it would be sooo sweet :) Thank you again. The GObject framework is already not that simple to grasp, but with silly bugs like this on the top of that, this is even harder.
Have you ever looked up libraries who work woth MS Excel, PP &amp; co.? I was blown away by how easy to use they are. Can save you a lot of time at times, especially if you regularly have to transfer data from one file to another.
Use CellProfiler. It is built for exactly this problem. It can be extended in Python (it's written in Python), and also can use ImageJ macros (it uses bioformats to load images). If you want to learn how to program image analysis, use Python. ImageJ is in Java, and you spend all your time learning Java, instead of learning image processing. 
Interested to know how you can use python to replace excel workflows, any particular examples you could share? Yay for NLP!
ImageJ can do what the OP wants without any programming, though, and it's a useful application for a scientist to learn. I agree about using python for algorithms though (of course!)
 import antigravity
Yeah, we need better documentation
Yes, indeed. That was really interesting.
I typed a whole reply to this then accidentally deleted it by pressing backspace =\ One very common task for me is finding revenue from a particular campaign/whatever, over a certain period. Without python, my steps would have to be: - export data from database to csv - open in excel - pivot table by date/product/etc - chart This can effectively be done in two lines using pandas: sales = pd.read_sql('...', db.connection, index_col = 'date') sales.resample('MS',how='sum').revenue.plot('line') So simple stuff like that is much easier. But also more intensive analysis is way easier. Say I had a whole bunch of orders data, and I wanted a column which counted how many previous orders that user id (uid) had made in this data. In Excel this would be a countif fuction or something similar: =COUNTIF($A$3:A5, A5) and will be an absolute bitch to calculate if Excel doesn't just fall over. Because pandas vectorizes what it can (very cleverly, too!), this would be very fast in pandas. I forget exactly how I did it, but it's something like df.sort('uid', ascending = True) df['rank'] = df.rank().uid - df.index.value + 2 I've done this before on like, ~10M rows, Excel would totally die at this point, pandas does it in a few seconds. I'm such a fucking nerd, talking about data analysis on Christmas eve, lol. 
I do a lot of development in Django, so for me usually when I'm doing something like this it's because there's a lot of imports/environment needed for this snippet to run, and it would be a bit of a pain in the ass to run it in it's proper context -- like for example, a View I don't have a template for yet.
All of my friends use Node to build sites these days, but I found it simpler and more elegant to use a Flask or Django stack. Less code that's easier to understand, plain and simple. It's also great for command line tools. Node often leans on native extensions, and getting node-gyp to work reliably could drive the Pope to violence. Putting aside the constant struggle of which Python version is available, most things I build work flawlessly on new systems with few or no changes. Ironically, parallelism in Python is infinitely simpler out of the box with the multiprocessing module, since Node doesn't support workers by default. I got into Python as an intern at Mozilla, where I built a static analysis tool for Firefox themes and add-ons. 
&gt; why would anyone stick to Python instead of more widely-used languages It's worth noting that Python is actually one of the the most widely used languages, ranked at number 2 by [PYPl](http://pypl.github.io/PYPL.html) and number 4 by [TIOBE](http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html). The *only* language that is unequivocally a "more widely used language" is Java! Anyway, I used Python for years for miscellaneous fun projects whenever I wanted software to do something. Now I program professionally in Python.
Sorry, my error. Read too hastily. It appears you'd have to build it from the source package also on that page. Not impossible... P.S. there's a [pyqt mailing list](https://www.riverbankcomputing.com/support/lists), you could ask there. It gets pretty good responses.
Also, z+=1 and x-=z. Edit: you could also use 'for z in itertools.count(2)' rather than 'while True'
Ah. So there's a catch... Well, I yes there's still room for improvement :)
[nimfa](https://github.com/marinkaz/nimfa) provides a pretty good interface for MF functions.
Cheers for the detailed response. Excel for big data is a nightmare, I'll actually look into pandas for some statistical stuff I need :) Well, I'm coding this eve :D 
Huh, you made a turtle. edit: Your code, prettier. import itertools import turtle window = turtle.Screen() window.bgcolor("black") t = turtle.Turtle() t.color("red") t.pensize(0.2) t.speed(0) x = 2 for z in itertools.count(2): t.forward(20) t.right(x) x = (x - z) % 360
Ptpython author here. Please report all issues on Github. Jedi isn't always stable, but we should handle that. I hope to push a new release in a few weeks. That will focus on performance/stability and it will support "bracketed paste" (making it possible to paste in the terminal without going to paste mode) and better mouse support. Jonathan
Why not use sets instead of iterating? if not set(expected) &lt;= set(json.keys()): raise BadRequest(...) You could also use abort, but I feel the raw HTTP exceptions give a finer grained control over what happens when an error occurs, but that's me. 
`import module as m` not short enough? 
Can you tell us what you're actually typing into the CMD / shell? I've found youtube-dl to be literally one of the easiest utilities ever to use. It uses sensible defaults and just works 99% of the time.
This (well, yesterday) is the first time I've actually heard about it...I read bioinformatics guides and articles every once in awhile and have seen demonstrations in iPython (but mostly in Ruby)...Biopython seems to be aimed at dealing with many of the conventions that bioinformatic programmers come across (genetic sequences, journal citations)...so it's been very helpful in learning about bio data, even if I don't use many of the actual libraries (I try to avoid bringing in too many specific data structures to my work).
So... just to clarify, as I'm kind of wondering the same thing as the OP... ...you can either use Python (i.e. Flask, Django) for the backend, with templates (i.e. Jinja2, etc.) to generate the pages (views) and use Javascript libraries like Bootstrap to prettify those views, or... ... you can use Python as the backend, to provide a REST api (i.e. Django Rest Framework, etc.) and then a Javascript framework like Angular, Ember, React, etc. to dynamically create the views and get the information from the backend via the REST api provided by your python framework (Django, Flask) of choice (or node.js). Is that pretty close?
I was messing around with them and i didn't use them for that code
Thanks, i was messing around and wasn't aiming for this particular image, thanks for cleaning the code though!
In terms of documentation you could add a module docstring and docstrings for each of the functions describing what they do. For example: def click(x, y): """ Click a given point on the screen. :param int x: The x position of the point to be clicked. :param int y: The y position of the point to be clicked. """ SetCursorPos((x, y)) mouse_event(MOUSEEVENTF_LEFTDOWN, x, y, 0, 0) mouse_event(MOUSEEVENTF_LEFTUP, x, y, 0, 0) 
Alright, so I know [how to get one video to download](http://i.imgur.com/RDr7KzQ.jpg), [but I cant figure out how to do it with a playlist](http://i.imgur.com/lx8uyFa.jpg). I must be a total noob here, il look up some thing on yt about it. Edit: [ahh its always the spelling.](https://i.imgur.com/RwGmewT.jpg)
[I am sure I am messing something up here](http://i.imgur.com/lx8uyFa.jpg), total noob in Python tbh, il solve it via yt if nothing else helps. Edit: [got it to work.](https://i.imgur.com/RwGmewT.jpg)
Unwarranted decorator fascination still alive and well I see.
Holy shit I am an idiot, [tnx it worked.](http://i.imgur.com/RwGmewT.jpg)
I hope this does well. Will give it a try for sure. 
Your teachers are either going to love you or hate you for doing this, but whatever happens don't let them demotivate you. This kind of approach is exactly what comes in useful when doing anything with even the slightest use of computers out there.
I've never used it for playlists and I can't test it right now but it should work but just replacing the link 
We don't use the system anyways, it's used for practice, not school work.
Thanks, is there a reason (code wise) behind this, or is it just to tell the person that click() does this and x is...
- Code wise I'd say refactor your `ocr` function into a couple of other methods, better yet, make it into a class. That way, if you abstract it enough you could have it do other things! Or use it as a module yourself for other automated screen grabbin'/ocrin' kinda project. - Seems like your relying on Windows API mostly. It's probably a fun idea to try to use something that provides a cross-os abstraction for these things, or make one yourself and use it here! - Code style: Follow [PEP8](https://www.python.org/dev/peps/pep-0008/). Get a linting plugin for your editor and make your life easier and your code beautiful to read. For example, use 4-space tab indentation. - Make your package into a proper Python module, ie. with setuptools. Create pip's standard requirements.txt with what your module requires and use it in your setup.py for automatic installation. Other than that, all looks great :)
thanks paul
I'd say validation should be done client and server side. Client side information shouldn't be trusted, even if it's normally coming from a system you control. However, providing basic validation gives "real time" feedback about what's wrong before it's submitted - things like start date must come before end date or acceptable ranges for inputs.
I disagree, I'd much rather have validation be a separate part than embedded inside my routes. It's easier to test both the validation and the route that way.
Yeah Im looking into the settings for dlling vids starting from a specific number, Ill figure it out, tnx.
It is good practice to only place your try except blocks around the code you expect to raise the exception. From what I can tell the only place a syntax error should be raised is from the eval line.
Very cool pattern. It follows simple rules but makes a very complicated design. I remember messing with the original version of the "turtle" on my commodore 64 in the 80s. The program was called LOGO.
I like to use IPython from a debugger, specifically pudb. After using pudb for a little while now, I don't know why anyone would ever use something else.
You might want to look into using jsonschema for more powerful validation including types. https://github.com/Julian/jsonschema Marshmallow is another alternative: https://github.com/marshmallow-code/flask-marshmallow
Didn't even think about that :D [changed](https://github.com/CarlSchou/MatematikFessorSolver/blob/master/main.py) wait now pycharm is being a dickhead http://i.imgur.com/i2JQYxO.png
I put the code in the function itself if it only saves a few keystrokes to do otherwise. It's much easier to read, change, and understand later. I agree that it's useful to factor code, but the choice is not between a decorator or all-inline, the choice is between a decorator or some-inline, and I try to choose the latter. I say this as someone who saw the former pattern taken to its logical absurdist conclusion in Pylons (the ``pylons.decorators.validate`` function). See https://groups.google.com/d/topic/pylons-discuss/zROPqjwdV6Y/discussion for more info.
Another common way I have seen done in the wild: a = [1, 3, 5, 5, 6, 3, 2, 1, 1 ] b = list(zip(*((iter(a),) * 3))) b [(1, 3, 5), (5, 6, 3), (2, 1, 1)] 
I think you want a continue after the click statement? I think you want to continue to the next iteration of the infinite loop if the result could not be parsed?
Would that be what I see called a 'single page application' or 'SPA'?
 I've been working on this whole morning, this is what I came up with http://stackoverflow.com/questions/34458795/image-not-shown-up-when-python-code-is-right?noredirect=1#comment56659737_34458795
Seriously, learn the framework: https://docs.djangoproject.com/en/1.9/intro/tutorial01/. Your example code shows a lack of understanding of the *basics* of Django. You cannot simply jump into this without knowing a modicum of what's going on.
coolio!
As far as I know, yes.
Kind of like eye3D? http://eyed3.nicfit.net
How does it compare to [pyjs](http://pyjs.org)?
&gt;"while 1==1:" a few more cycles in your CPU than "while True:," You should prefer "while True" for clarity, but Python will optimize "while 1 == 1" into "while True". &gt;That use of a while use is inefficient, it would be better to use the modulus operator, "x=x%360." Actually the while loop will be far faster because the loop almost never actually iterates, and modulus is one of the more time intensive CPU operations. 
Ayy fellow Danish person ye i made it do division for a while, then outa nowhere the math problems went from x / x to division of fraction, which i couldn't ocr, so i changed it to multiplication.
that's sick :L
I did the small exercise sets instead of the Supertræner. They give 40 points each and can be solved in ~10 seconds. Do that in 100 tabs at once and you're on your way to the top of the leaderboards.
It's just one L, DL for Down Load, not DLL as in "dynamic link library". You are consistently misspelling this throughout this thread.
To me validation should be an entirely external thing for several reasons: 1. I don't want to navigate validation (and potentially serialization) every time I write a test. Just like I wouldn't put authentication directly in my path for every test. 2. Validation -- or at least the use of validation -- should be reusable and changeable. Unrealistic as it seems, I'd like to be at the point where I can change the validation library being used without much effort (DRF has been driving me absolutely bonkers). 3. Validation is a completely separate concern from "doing the thing"
Loved this book! This book was phenomenal for me in teaching correct ways to make common simple applications and how to properly take advantage of PyQt to do it right. I loved that it started fairly basic, but also covered complex examples and the model, view, delegate stuff for more complex controls. Since the book is a little out of date, be sure to get the downloads you need (all the examples) from the website for python 3, PySide, or whatever you're using.
Well-put.
Will breakpoints still work though?
OP should answer this. I know many people who run Anaconda on 64 bit Windows, and it's usually solid. 
details?
ah, forget it. See the screenshot below: http://imgur.com/PaYDpIt
Yep, agree about monkeypatching, and yeah, neither way really feels great, you're right. FWIW, I am also a testability freak. I am a fan of the way Pyramid works here because its view configuration decorator actually does not cause the function to return a different kind of value, which is really handy for doing view code testing without always needing to functest. Its concept of "renderers" lets you return a dictionary from the view function ultimately destined for serialization when called by the web framework, but your test can just make assertions about the returned value instead of the serialized value. See http://docs.pylonsproject.org/projects/pyramid/en/1.6-branch/narr/project.html#tests-py for an example (the ``testing.setUp()`` call and the teardown is not necessary here, not even sure why it's there).
I've toyed with idea of renders before. I'll have to take a look at how Pyramid does it because all the Flask ones I've seen have been API oriented - which is cool, but I'm curious how it can be well with HTML.
Wow, I did not know you could write CSS mods in Python. Nice!
I have no idea if ES still works or is maintained. Last time I worked with it is almost a decade ago (damn CSS is old). But it was tons of fun and taught me a lot. Without CSS I wouldn't have the job I have now.
It should be exactly the same as doing it from command line except with the break points. 
Are you able to import numpy?
/u/dreyco when and where do you plan to deliver this talk?
I *think* form your screenshot it's obvious you installed 64bit Anaconda on a 32bit operating system? 
It works perfectly fine! Happy holidays!
Do people really rape the space button when coding? \#TabMasterrace
Hmm it's all habit i guess
&gt; python hackers &gt; discourse
Hmm code is one line shorter and works perfectly fine 5/7
You can see if your editor has the option for "soft tabs". It will make tabs into 4 spaces, and pressing backspace will delete all 4, so you won't notice a difference usually. 
It's the grouper function on the Python itertools [recipe](https://docs.python.org/2/library/itertools.html#recipes) page.
#triggered
Lol so much reason. 
`while 1:` is considered the pythonic way to write that loop. 
I'm sure there is. I don't use PyCharm but it's pretty advanced. Plus, there should be an option to change all your tabs into spaces automatically. EDIT: Found: http://stackoverflow.com/questions/11816147/pycharm-convert-tabs-to-spaces-automatically
Trying classes atm just added [SolveEquationFromImage](https://github.com/CarlSchou/MatematikFessorSolver/blob/master/main.py)
And remember, pep8 is a guideline. Not a rule. 
Atm im trying to make one class with all of the functions related to MatematikFessor :) And yes it's unneeded to have a class only to have a __init__ 
I don't know. When I have this problem I am always searching for wheel version of that module and pip installs it quickly. For example the easiest way to install lxml. :0D When I want to get somewhere I will always prefer wheels to eggs. :0D And I LOVE eggs. But only for breakfast. :0)
You get downvoted cause of vague description but there are in fact issues when you use `pip` and `easy_install` together. Eg: https://github.com/pypa/pip/issues/2868 https://github.com/pypa/pip/issues/2751 To put it shortly: don't *ever* use `easy_install` if you plan to use `pip`.
The vectorized version available at https://github.com/pyopencl/pyopencl/blob/master/examples/demo_mandelbrot.py is about 30 times slower than mine with a 1MB image and 800 iterations...
St Paul, MN January 21st. http://meetu.ps/2Rm03H
Yeah if you want to prioritise consistency then that's a good move
&gt; refactor your ocr function into a couple of other methods, better yet, make it into a class It's not necessarily better to make it into a class. What reasons would he have to make a class, vs. using other functions?
Yes, as ffgggggppphvx I think you should change .read for .read() (line "indata = (open(from_file)).read").
If you mean the win32 this just indicates that its running on windows. The important bit is the AMD64 part. It is possible that he has installed a 32 bit numpy and is trying to load that which scipy heavily depends on. Asked if he could import that below to see.
Yeah, I saw that too, it's weird. I'm definitely running on a 64bit system, unless my System screen is lying to me.